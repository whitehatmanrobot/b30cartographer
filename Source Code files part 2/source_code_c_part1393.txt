rt the article number to a string and send the command
            wsprintf(szTemp, "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_BODY, szTemp);
            }
        }
    else
        {
        hr = HrSendCommand((LPSTR) NNTP_BODY, (LPSTR) c_szCRLF);
        }

    if (SUCCEEDED(hr))
        {
        m_state = NS_BODY;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandPOST(LPNNTPMESSAGE pMessage)
    {
    HRESULT hr;

    if (!pMessage || (pMessage && !pMessage->pstmMsg))
        return (E_INVALIDARG);    

    EnterCriticalSection(&m_cs);

    // Make a copy of the message struct so we have it when we get
    // an response from the server that it's OK to post
#pragma prefast(suppress:11, "noise")
    m_rMessage.cbSize = pMessage->cbSize;
    SafeRelease(m_rMessage.pstmMsg);
#pragma prefast(suppress:11, "noise")
    m_rMessage.pstmMsg = pMessage->pstmMsg;
    m_rMessage.pstmMsg->AddRef();

    hr = HrSendCommand((LPSTR) NNTP_POST_CRLF, NULL);
    if (SUCCEEDED(hr))
        {
        m_state = NS_POST;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandLIST(LPSTR pszArgs)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    if (pszArgs)
        hr = HrSendCommand((LPSTR) NNTP_LIST, pszArgs);
    else
        hr = HrSendCommand((LPSTR) NNTP_LIST, (LPSTR) c_szCRLF);

    if (SUCCEEDED(hr))
        {
        m_state = NS_LIST;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }

HRESULT CNNTPTransport::CommandLISTGROUP(LPSTR pszGroup)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    if (pszGroup)
        hr = HrSendCommand((LPSTR) NNTP_LISTGROUP, pszGroup);
    else
        hr = HrSendCommand((LPSTR) NNTP_LISTGROUP, (LPSTR) c_szCRLF);

    if (SUCCEEDED(hr))
        {
        m_state = NS_LISTGROUP;
        m_substate = NS_RESP;
        }


    LeaveCriticalSection(&m_cs);
    return (hr);
    }

HRESULT CNNTPTransport::CommandNEWGROUPS(SYSTEMTIME *pstLast, LPSTR pszDist)
    {
    HRESULT hr = S_OK;
    LPSTR   pszCmd = NULL;
    DWORD   cchCmd = 18;

    // Make sure a SYSTEMTIME struct is provided
    if (!pstLast)
        return (E_INVALIDARG);

    // Allocate enough room for the command string "NEWGROUPS YYMMDD HHMMSS <pszDist>"
    if (pszDist)
        cchCmd += lstrlen(pszDist);
    
    if (!MemAlloc((LPVOID*) &pszCmd, cchCmd))
        {
        OnError(E_OUTOFMEMORY);
        return (E_OUTOFMEMORY);
        }

    // Put the command arguments together
    wsprintf(pszCmd, "%02d%02d%02d %02d%02d%02d ", pstLast->wYear - (100 * (pstLast->wYear / 100)),
             pstLast->wMonth, pstLast->wDay, pstLast->wHour, pstLast->wMinute, 
             pstLast->wSecond);
    if (pszDist)
        lstrcat(pszCmd, pszDist);

    // Send the command
    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_NEWGROUPS, pszCmd);
    if (SUCCEEDED(hr))
        {
        m_state = NS_NEWGROUPS;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);    
    SafeMemFree(pszCmd);
    return (hr);
    }

HRESULT CNNTPTransport::CommandDATE(void)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_DATE_CRLF, NULL);
    if (SUCCEEDED(hr))
        m_state = NS_DATE;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandMODE(LPSTR pszMode)
    {
    HRESULT hr;

    // Make sure the caller provided a mode command to send
    if (!pszMode || (pszMode && !*pszMode))
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_MODE, pszMode);
    if (SUCCEEDED(hr))
        m_state = NS_MODE;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandXHDR(LPSTR pszHeader, LPRANGE pRange, LPSTR pszMessageId)
    {
    HRESULT hr = S_OK;
    LPSTR   pszArgs = 0;

    // You can't specify BOTH a range and a message id
    if (pRange && pszMessageId)
        return (E_INVALIDARG);

    if (!pszHeader)
        return (E_INVALIDARG);

    // Make sure the range information is valid
    if (pRange)
        {
        if ((pRange->idType != RT_SINGLE && pRange->idType != RT_RANGE) || 
            pRange->dwFirst == 0 || 
            (pRange->idType == RT_RANGE && pRange->dwLast < pRange->dwFirst))
            return (E_INVALIDARG);
        }

    // Allocate a string for the arguments
    if (!MemAlloc((LPVOID*) &pszArgs, 
        32 + lstrlen(pszHeader) + (pszMessageId ? lstrlen(pszMessageId) : 0)))
        {
        OnError(E_OUTOFMEMORY);
        return (E_OUTOFMEMORY);
        }

    EnterCriticalSection(&m_cs);

    // Handle the message-id case first 
    if (pszMessageId)
        {
        wsprintf(pszArgs, "%s %s", pszHeader, pszMessageId);
        hr = HrSendCommand((LPSTR) NNTP_XHDR, pszArgs);
        }
    else if (pRange)
        {
        // Range case
        if (pRange->idType == RT_SINGLE)
            {
            wsprintf(pszArgs, "%s %ld", pszHeader, pRange->dwFirst);
            hr = HrSendCommand((LPSTR) NNTP_XHDR, pszArgs);
            }
        else if (pRange->idType == RT_RANGE)
            {
            wsprintf(pszArgs, "%s %ld-%ld", pszHeader, pRange->dwFirst, pRange->dwLast);
            hr = HrSendCommand((LPSTR) NNTP_XHDR, pszArgs);
            }
        }
    else
        {
        // Current article case
        hr = HrSendCommand((LPSTR) NNTP_XHDR, pszHeader);
        }

    // If we succeeded to send the command to the server, then update our state
    // to receive the response from the XHDR command
    if (SUCCEEDED(hr))
        {
        m_state = NS_XHDR;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);
    SafeMemFree(pszArgs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandQUIT(void)
    {
    HRESULT hr = IXP_E_NOT_CONNECTED;

    EnterCriticalSection(&m_cs);

    // Make sure we're actually connected to the server
    if (m_state != NS_DISCONNECTED && m_state != NS_CONNECT || (m_state == NS_CONNECT && m_substate != NS_RECONNECTING))
        {
        // Send the QUIT command to the server
        hr = HrSendCommand((LPSTR) NNTP_QUIT_CRLF, NULL);
        if (SUCCEEDED(hr))
            m_state = NS_QUIT;        
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::GetHeaders(LPRANGE pRange)
    {
    HRESULT hr;
    char    szRange[32];
    
    // Make sure the range information is valid
    if (!pRange)
        return (E_INVALIDARG);

    if ((pRange->idType != RT_SINGLE && pRange->idType != RT_RANGE) || 
        pRange->dwFirst == 0 || 
        (pRange->idType == RT_RANGE && pRange->dwLast < pRange->dwFirst))
        return (E_INVALIDARG);

    if (pRange->idType == RT_SINGLE)
        pRange->dwLast = pRange->dwFirst;

    // In case XOVER isn't supported on this server, we'll store this range so
    // we can try XHDR instead.
    m_rRange = *pRange;

    // Check to see if we know that XOVER will fail
    if (m_fNoXover)
        {
        return (BuildHeadersFromXhdr(TRUE));
        }

    EnterCriticalSection(&m_cs);

    // If dwLast == 0, then the person is requesting a single record, otherwise
    // the person is requesting a range.  Build the commands appropriately.
    if (RT_RANGE == pRange->idType)
        wsprintf(szRange, "%s %lu-%lu\r\n", NNTP_XOVER, pRange->dwFirst, pRange->dwLast);
    else
        wsprintf(szRange, "%s %lu\r\n", NNTP_XOVER, pRange->dwFirst);

    hr = HrSendCommand(szRange, NULL);
    if (SUCCEEDED(hr))
        {
        m_state = NS_HEADERS;
        m_substate = NS_RESP;
        m_gethdr = GETHDR_XOVER;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CNNTPTransport::ReleaseResponse(LPNNTPRESPONSE pResp)
    {
    HRESULT hr = S_OK;
    DWORD   i;

    // First double check to see if this even needs to be released
    if (FALSE == pResp->fMustRelease)
        return (S_FALSE);

    switch (pResp->state)
        {
        case NS_GROUP:
            SafeMemFree(pResp->rGroup.pszGroup);
            break;

        case NS_LAST:
            SafeMemFree(pResp->rLast.pszMessageId);
            break;

        case NS_NEXT:
            SafeMemFree(pResp->rNext.pszMessageId);
            break;

        case NS_STAT:
            SafeMemFree(pResp->rStat.pszMessageId);
            break;

        case NS_ARTICLE:
            SafeMemFree(pResp->rArticle.pszMessageId);
            SafeMemFree(pResp->rArticle.pszLines);
            break;

        case NS_HEAD:
            SafeMemFree(pResp->rHead.pszMessageId);
            SafeMemFree(pResp->rHead.pszLines);
            break;

        case NS_BODY:
            SafeMemFree(pResp->rBody.pszMessageId);
            SafeMemFree(pResp->rBody.pszLines);
            break;

        case NS_NEWGROUPS:
            // Since the response here is just one buffer, then we can just
            // free the first line and all the others will be freed as well.
            if (pResp->rNewgroups.rgszLines)
                {
                SafeMemFree(pResp->rNewgroups.rgszLines[0]);
                MemFree(pResp->rNewgroups.rgszLines);
                }
            break;

        case NS_LIST:
            // Since the response here is just one buffer, then we can just
            // free the first line and all the others will be freed as well.
            if (pResp->rList.rgszLines)
                {
                MemFree(pResp->rList.rgszLines[0]);
                MemFree(pResp->rList.rgszLines);
                }
            break;

        case NS_LISTGROUP:
            SafeMemFree(pResp->rListGroup.rgArticles);
            break;

        case NS_HEADERS:
            {
            // This frees the memory that contains all of the
            PMEMORYINFO pMemInfo = (PMEMORYINFO) pResp->rHeaders.dwReserved;

            for (UINT i = 0; i < pMemInfo->cPointers; i++)
                SafeMemFree(pMemInfo->rgPointers[i]);
            SafeMemFree(pMemInfo);

            // This frees the array that pointed to the parsed xhdr responses
            SafeMemFree(pResp->rHeaders.rgHeaders);
            break;
            }

        case NS_XHDR:
            {
            // This frees the memory that contains all of the
            PMEMORYINFO pMemInfo = (PMEMORYINFO) pResp->rXhdr.dwReserved;
            SafeMemFree(pMemInfo->rgPointers[0]);
            SafeMemFree(pMemInfo);

            // This frees the array that pointed to the parsed xhdr responses
            SafeMemFree(pResp->rXhdr.rgHeaders);
            break;
            }

        default:
            // If we get here that means one of two things:
            // (1) the user messed with pResp->fMustRelease flag and is an idiot
            // (2) Somewhere in the transport we set fMustRelease when we didn't
            //     actually return data that needs to be freed.  This is bad and
            //     should be tracked.
            IxpAssert(FALSE);
        }

    return (hr);
    }


HRESULT CNNTPTransport::BuildHeadersFromXhdr(BOOL fFirst)
    {
    HRESULT      hr = S_OK;
    DWORD        cHeaders;
    BOOL         fDone = FALSE;
    
    if (fFirst)
        {
        // Set the header retrieval type
        m_gethdr = GETHDR_XHDR;
        m_fNoXover = TRUE;
        m_cHeaders = 0;

        // Get the first range of headers to retrieve
        m_rRangeCur.dwFirst = m_rRange.dwFirst;
        m_rRangeCur.dwLast = min(m_rRange.dwLast, m_rRangeCur.dwFirst + NUM_HEADERS);

        cHeaders = m_rRangeCur.dwLast - m_rRangeCur.dwFirst + 1;

        // Allocate an array for the headers
        Assert(m_rgHeaders == 0);

        if (!MemAlloc((LPVOID*) &m_rgHeaders, cHeaders * sizeof(NNTPHEADER)))
            {
            SafeMemFree(m_pMemInfo);
            OnError(E_OUTOFMEMORY);
            DispatchResponse(E_OUTOFMEMORY);
            return (E_OUTOFMEMORY);
            }
        ZeroMemory(m_rgHeaders, cHeaders * sizeof(NNTPHEADER));

        // Set the state correctly
        m_hdrtype = HDR_SUBJECT;
        
        // Issue first request
        hr = SendNextXhdrCommand();
        }
    else
        {
        Assert(m_substate == NS_DATA);

        // Parse the data and add it to our array
        hr = ProcessNextXhdrResponse(&fDone);

        // fDone will be TRUE when we've received all the data from the 
        // preceeding request.  
        if (fDone)
            {
            // If there are still headers left to retrieve, then advance the
            // header type state and issue the next command.
            if (m_hdrtype < HDR_XREF)
                {
                m_hdrtype++;

                // issue command
                hr = SendNextXhdrCommand();
                }
            else
                {
                // All done with this batch.  Send the response to the caller.
                NNTPRESPONSE rResp;
                ZeroMemory(&rResp, sizeof(NNTPRESPONSE));
                rResp.rHeaders.cHeaders = m_cHeaders;
                rResp.rHeaders.rgHeaders = m_rgHeaders;
                rResp.rHeaders.fSupportsXRef = TRUE;
                rResp.rHeaders.dwReserved = (DWORD_PTR) m_pMemInfo;
                rResp.fMustRelease = TRUE;

                // It's the caller's responsibility to free this now
                m_rgHeaders = NULL;
                m_cHeaders = 0;
                m_pMemInfo = 0;
                
                // If these are equal, then we've retrieved all of the headers
                // that were requested
                if (m_rRange.dwLast == m_rRangeCur.dwLast)
                    {
                    rResp.fDone = TRUE;
                    DispatchResponse(S_OK, TRUE, &rResp);
                    }
                else
                    {
                    rResp.fDone = FALSE;
                    DispatchResponse(S_OK, FALSE, &rResp);

                    // There are headers we haven't retrieved yet.  Go ahead
                    // and issue the next group of xhdrs.
                    m_rRange.dwFirst = m_rRangeCur.dwLast + 1;
                    Assert(m_rRange.dwFirst <= m_rRange.dwLast);
                    BuildHeadersFromXhdr(TRUE);
                    }
                
                }
            }
        }

    return (hr);
    }


HRESULT CNNTPTransport::SendNextXhdrCommand(void)
    {
    char    szTemp[256];
    HRESULT hr;

    LPCSTR  c_rgHdr[HDR_MAX] = { NNTP_HDR_SUBJECT,   
                                 NNTP_HDR_FROM,      
                                 NNTP_HDR_DATE,      
                                 NNTP_HDR_MESSAGEID, 
                                 NNTP_HDR_REFERENCES,
                                 NNTP_HDR_LINES,   
                                 NNTP_HDR_XREF };

    // Build the command string to send to the server
    wsprintf(szTemp, "%s %s %ld-%ld\r\n", NNTP_XHDR, c_rgHdr[m_hdrtype],
             m_rRangeCur.dwFirst, m_rRangeCur.dwLast);

    EnterCriticalSection(&m_cs);

    // Send the command to the server
    hr = HrSendCommand(szTemp, NULL, FALSE);
    if (SUCCEEDED(hr))
        {
        m_state = NS_HEADERS;
        m_substate = NS_RESP;
        m_iHeader = 0;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::ProcessNextXhdrResponse(BOOL* pfDone)
    {
    HRESULT             hr;
    LPSTR               pszLines = NULL;
    LPSTR               pszNextLine = NULL;
    LPSTR               pszField = NULL;
    LPSTR               pszNextField = NULL;
    int                 iRead, iLines;
    DWORD               dwTemp;

    // Read the data that is waiting on the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        // Realloc our array of pointers to free and add this pszLines to the end
        if (m_pMemInfo)
            {
            if (MemRealloc((LPVOID*) &m_pMemInfo, sizeof(MEMORYINFO) 
                           + (((m_pMemInfo ? m_pMemInfo->cPointers : 0) + 1) * sizeof(LPVOID))))
                {
                m_pMemInfo->rgPointers[m_pMemInfo->cPointers] = (LPVOID) pszLines;
                m_pMemInfo->cPointers++;            
                }
            }
        else
            {
            if (MemAlloc((LPVOID*) &m_pMemInfo, sizeof(MEMORYINFO)))
                {
                m_pMemInfo->rgPointers[0] = pszLines;
                m_pMemInfo->cPointers = 1;
                }
            }

        // Loop until we either run out of lines or we find a line that begins 
        // with "."
        pszNextLine = pszLines;
        while (*pszNextLine && *pszNextLine != '.')
            {
            pszField = pszNextLine;

            // Scan ahead and find the end of the line
            while (*pszNextLine)
                {
                if (*pszNextLine == '\n')
                    {
                    // NULL out a CR followed by a LF
                    if (pszNextLine > pszField && *(pszNextLine - 1) == '\r')
                        *(pszNextLine - 1) = 0;

                    // NULL out and skip over the LF
                    *pszNextLine++ = 0;
                    break;
                    }
                pszNextLine++;
                }

            // Parse the article number
            if (m_hdrtype == HDR_SUBJECT)
                {
                m_rgHeaders[m_iHeader].dwArticleNum = StrToInt(pszField);
                m_cHeaders++;
                }
            else
                {
                // Make sure this field matches the header that's next in the array
                if (m_rgHeaders[m_iHeader].dwArticleNum != (DWORD) StrToInt(pszField))
                    {
                    dwTemp = m_iHeader;

                    // If the number is less, then we can loop until we find it
                    while (m_iHeader < (m_rRangeCur.dwLast - m_rRangeCur.dwFirst) && 
                           m_rgHeaders[m_iHeader].dwArticleNum < (DWORD) StrToInt(pszField))
                        {
                        m_iHeader++;
                        }

                    // We never found a matching header, so we should consider this record
                    // bogus.
                    if (m_iHeader >= (m_rRangeCur.dwLast - m_rRangeCur.dwFirst + 1))
                        {
                        IxpAssert(0);
                        m_iHeader = dwTemp;
                        goto BadRecord;
                        }
                    }
                }    

            // Find the seperating space
            while (*pszField && *pszField != ' ')
                pszField++;

            // Advance past the space
            if (*pszField)
                pszField++;

            // Parse the actual data field into our header array.  Make 
            // the beginning of the header point to the first character 
            // after the space.
            switch (m_hdrtype)
                {
                case HDR_SUBJECT:
                    m_rgHeaders[m_iHeader].pszSubject = pszField;
                    break;

                case HDR_FROM:
                    m_rgHeaders[m_iHeader].pszFrom = pszField;
                    break;

                case HDR_DATE:
                    m_rgHeaders[m_iHeader].pszDate = pszField;
                    break;

                case HDR_MSGID:
                    m_rgHeaders[m_iHeader].pszMessageId = pszField;
                    break;

                case HDR_REFERENCES:
                    m_rgHeaders[m_iHeader].pszReferences = pszField;
                    break;

                case HDR_LINES:
                    m_rgHeaders[m_iHeader].dwLines = StrToInt(pszField);
                    break;

                case HDR_XREF:
                    m_rgHeaders[m_iHeader].pszXref = pszField;
                    break;

                default:
                    // How the heck do we get here?
                    IxpAssert(0);
                }

            m_iHeader++;

BadRecord:
            ;
            }

        // We've reached the end of the list, otherwise there is more data
        // expected.
        *pfDone = (*pszNextLine == '.');
        return (S_OK);
        }

    return (hr);    
    }


HRESULT CNNTPTransport::HrPostMessage(void)
    {
    HRESULT hr;
    int     cbSent = 0;

    EnterCriticalSection(&m_cs);
    hr = m_pSocket->SendStream(m_rMessage.pstmMsg, &cbSent, TRUE);
    SafeRelease(m_rMessage.pstmMsg);
    LeaveCriticalSection(&m_cs);

    return (hr);
    }

//***************************************************************************
// Function: SetWindow
//
// Purpose:
//   This function creates the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CNNTPTransport::SetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

    if(m_pSocket)
    	hr= m_pSocket->SetWindow();
    else
    	hr= E_UNEXPECTED;
    	
    return hr;
}

//***************************************************************************
// Function: ResetWindow
//
// Purpose:
//   This function closes the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CNNTPTransport::ResetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

	if(m_pSocket)
		hr= m_pSocket->ResetWindow();
	else
		hr= E_UNEXPECTED;
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpnntp.h ===
// --------------------------------------------------------------------------------
// Ixpnntp.h
// Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved
//
// Eric Andrews
// Steve Serdy
// --------------------------------------------------------------------------------

#ifndef __IXPNNTP_H__
#define __IXPNNTP_H__

#include "imnxport.h"
#include "ixpbase.h"
#include "asynconn.h"
#include "sicily.h"

#define MAX_SEC_PKGS           32   // most sec pkgs we will try


// --------------------------------------------------------------------------------
// Sub states that aren't exposed to the user
// --------------------------------------------------------------------------------
typedef enum {
    // These are generic substates that a lot of commands use to differenitate
    // between the response ("200 article follows") and the data (the actual
    // article text).
    NS_RESP,
    NS_DATA,

    // These substates are specific to handling posting
    NS_SEND_ENDPOST,
    NS_ENDPOST_RESP,

    // These substates are specific to connecting or authorizing
    NS_CONNECT_RESP,                    // awaiting the banner that is sent after a connection is made
    NS_MODE_READER_RESP,                // awaiting MODE READER response
    NS_GENERIC_TEST,                    // awaiting AUTHINFO GENERIC response
    NS_GENERIC_PKG_DATA,                // awaiting AUTHINFO_GENERIC data
    NS_TRANSACT_TEST,                   // awaiting AUTHINFO TRANSACT TEST response
    NS_TRANSACT_PACKAGE,                // awaiting AUTHINFO TRANSACT <package> response
    NS_TRANSACT_NEGO,                   // awaiting AUTHINFO TRANSACT <negotiation> response
    NS_TRANSACT_RESP,                   // awaiting AUTHINFO TRANSACT <response> response
    NS_AUTHINFO_USER_RESP,              // awaiting AUTHINFO USER XXXX response
    NS_AUTHINFO_PASS_RESP,              // awaiting AUTHINFO PASS XXXX response
    NS_AUTHINFO_SIMPLE_RESP,            // awaiting AUTHINFO SIMPLE response
    NS_AUTHINFO_SIMPLE_USERPASS_RESP,
    NS_RECONNECTING                     // in the process of doing an internal reconnect

} NNTPSUBSTATE;

typedef enum {
    AUTHINFO_NONE = 0,
    AUTHINFO_GENERIC,
    AUTHINFO_TRANSACT,
} AUTH_TYPE;

typedef enum {
    GETHDR_XOVER,
    GETHDR_XHDR
} GETHDR_TYPE;

enum {
    HDR_SUBJECT = 0,
    HDR_FROM,
    HDR_DATE,
    HDR_MSGID,
    HDR_REFERENCES,
    HDR_LINES,
    HDR_XREF,
    HDR_MAX
};

typedef struct tagMEMORYINFO
    {
    DWORD cPointers;
    LPVOID rgPointers[1];
    } MEMORYINFO, *PMEMORYINFO;

class CNNTPTransport : public INNTPTransport2, public CIxpBase
    {
public:
    // ----------------------------------------------------------------------------
    // Contstruction
    // ----------------------------------------------------------------------------
    CNNTPTransport(void);
    ~CNNTPTransport(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPSTR pszLogFilePath, INNTPCallback *pCallback);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP Stop(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // INNTPTransport2 methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP SetWindow(void);
    STDMETHODIMP ResetWindow(void);

    // ----------------------------------------------------------------------------
    // CIxpBase methods
    // ----------------------------------------------------------------------------
    virtual void ResetBase(void);
    virtual void DoQuit(void);
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void);
    virtual void OnLeaveBusy(void);

    // ----------------------------------------------------------------------------
    // INNTPTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP CommandAUTHINFO(LPNNTPAUTHINFO pAuthInfo);
    STDMETHODIMP CommandGROUP(LPSTR pszGroup);
    STDMETHODIMP CommandLAST(void);
    STDMETHODIMP CommandNEXT(void);
    STDMETHODIMP CommandSTAT(LPARTICLEID pArticleId);    
    STDMETHODIMP CommandARTICLE(LPARTICLEID pArticleId);
    STDMETHODIMP CommandHEAD(LPARTICLEID pArticleId);
    STDMETHODIMP CommandBODY(LPARTICLEID pArticleId);
    STDMETHODIMP CommandPOST(LPNNTPMESSAGE pMessage);
    STDMETHODIMP CommandLIST(LPSTR pszArgs);
    STDMETHODIMP CommandLISTGROUP(LPSTR pszGroup);
    STDMETHODIMP CommandNEWGROUPS(SYSTEMTIME *pstLast, LPSTR pszDist);
    STDMETHODIMP CommandDATE(void);
    STDMETHODIMP CommandMODE(LPSTR pszMode);
    STDMETHODIMP CommandXHDR(LPSTR pszHeader, LPRANGE pRange, LPSTR pszMessageId);
    STDMETHODIMP CommandQUIT(void);
    STDMETHODIMP GetHeaders(LPRANGE pRange);
    STDMETHODIMP ReleaseResponse(LPNNTPRESPONSE pResp);
    

private:
    // ----------------------------------------------------------------------------
    // Private Member functions
    // ----------------------------------------------------------------------------
    void OnSocketReceive(void);
    void DispatchResponse(HRESULT hrResult, BOOL fDone=TRUE, LPNNTPRESPONSE pResponse=NULL);
    HRESULT HrGetResponse(void);
    
    void StartLogon(void);
    HRESULT LogonRetry(HRESULT hrLogon);
    HRESULT TryNextSecPkg(void);
    HRESULT MaybeTryAuthinfo(void);

    HRESULT HandleConnectResponse(void);

    HRESULT ProcessGenericTestResponse(void);
    HRESULT ProcessTransactTestResponse(void);
    HRESULT ProcessGroupResponse(void);
    HRESULT ProcessNextResponse(void);
    HRESULT ProcessListData(void);
    HRESULT ProcessListGroupData(void);
    HRESULT ProcessDateResponse(void);
    HRESULT ProcessArticleData(void);
    HRESULT ProcessXoverData(void);
    HRESULT ProcessXhdrData(void);

    HRESULT BuildHeadersFromXhdr(BOOL fFirst);
    LPSTR GetNextField(LPSTR pszField);
    HRESULT SendNextXhdrCommand(void);
    HRESULT ProcessNextXhdrResponse(BOOL* pfDone);

    HRESULT HrPostMessage(void);

    // ----------------------------------------------------------------------------
    // Private member variables
    // ----------------------------------------------------------------------------
    // Various state variables
    NNTPSTATE           m_state;
    NNTPSUBSTATE        m_substate;
    GETHDR_TYPE         m_gethdr;
    DWORD               m_hdrtype;

    // Sicily information
    SSPICONTEXT         m_sicinfo;
    SSPIBUFFER          m_sicmsg;
    int                 m_cSecPkg;                  // number of sec pkgs to try, -1 if not inited
    int                 m_iSecPkg;                  // current sec pkg being tried
    AUTH_TYPE           m_iAuthType;
    LPSTR               m_rgszSecPkg[MAX_SEC_PKGS]; // pointers into m_szSecPkgs
    LPSTR               m_szSecPkgs;                // string returned by "AUTHINFO TRANSACT TEST"
    BOOL                m_fRetryPkg;

    // From the GetHeaders() command in case the XOVER request fails
    RANGE               m_rRange;
    RANGE               m_rRangeCur;
    LPNNTPHEADER        m_rgHeaders;
    DWORD               m_iHeader;
    DWORD               m_cHeaders;
    PMEMORYINFO         m_pMemInfo;

    // Posting
    NNTPMESSAGE         m_rMessage;

    // Flags
    BOOL                m_fSupportsXRef;            // TRUE if this server's XOver records contain the XRef: field
    BOOL                m_fNoXover;                 // TRUE if the server does not support XOVER

    // Connection info
    HRESULT             m_hrPostingAllowed;

    // Authentication
    LPNNTPAUTHINFO      m_pAuthInfo;
    };



#endif // __IXPNNTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixphttpm.h ===
// --------------------------------------------------------------------------------
// Ixphttpm.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------
#ifndef __IXPHTTPM_H
#define __IXPHTTPM_H

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include <stddef.h> // for offsetof

#include "wininet.h"
#include "propfind.h"
#include "xmlparser.h"
#include "davparse.h"

// --------------------------------------------------------------------------------
// constants
// --------------------------------------------------------------------------------
#define ELE_STACK_CAPACITY    7
#define HTTPMAIL_BUFSIZE      4048
#define PCDATA_BUFSIZE        1024

// optional headers added to http requests
#define RH_NOROOT                   0x00000001
#define RH_ALLOWRENAME              0x00000002
#define RH_TRANSLATEFALSE           0x00000004
#define RH_TRANSLATETRUE            0x00000008
#define RH_XMLCONTENTTYPE           0x00000010
#define RH_MESSAGECONTENTTYPE       0x00000020
#define RH_SMTPMESSAGECONTENTTYPE   0x00000040
#define RH_BRIEF                    0x00000080
#define RH_SAVEINSENTTRUE           0x00000100
#define RH_SAVEINSENTFALSE          0x00000200
#define RH_ROOTTIMESTAMP            0x00000400
#define RH_FOLDERTIMESTAMP          0x00000800
#define RH_ADDCHARSET               0x00001000

// --------------------------------------------------------------------------------
// Forward declarations
// --------------------------------------------------------------------------------
class CHTTPMailTransport;

// --------------------------------------------------------------------------------
// root props
// --------------------------------------------------------------------------------
typedef struct tagROOTPROPS
{
    LPSTR   pszAdbar;
    LPSTR   pszContacts;
    LPSTR   pszInbox;
    LPSTR   pszOutbox;
    LPSTR   pszSendMsg;
    LPSTR   pszSentItems;
    LPSTR   pszDeletedItems;
    LPSTR   pszDrafts;
    LPSTR   pszMsgFolderRoot;
    LPSTR   pszSig;
    DWORD   dwMaxPollingInterval;
} ROOTPROPS, *LPROOTPROPS;

// --------------------------------------------------------------------------------
// Schemas used for XML parsing
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// XPCOLUMNDATATYPE
// --------------------------------------------------------------------------------
typedef enum tagXPCOLUMNDATATYPE
{
    XPCDT_STRA,
    XPCDT_DWORD,
    XPCDT_BOOL,
    XPCDT_IXPHRESULT,
    XPCDT_HTTPSPECIALFOLDER,
    XPCDT_HTTPCONTACTTYPE,
    XPCDT_LASTTYPE
} XPCOLUMNDATATYPE;

// --------------------------------------------------------------------------------
// XPCOLUMN FLAGS
// --------------------------------------------------------------------------------
#define XPCF_PFREQUEST                  0x00000001  // include in propfind request
#define XPCF_MSVALIDMSRESPONSECHILD     0x00000002  // during parse - validate that the ele stack is correct for a child of a <response> in a <multistatus> response
#define XPCF_MSVALIDPROP                0x00000004  // during parse - validate that the stack is correct for a propvalue in an ms response
#define XPCF_DONTSETFLAG                0x00000008  // don't set the found flag when parsing

#define XPFC_PROPFINDPROP   (XPCF_PFREQUEST | XPCF_MSVALIDPROP)
#define XPCF_PROPFINDHREF   (XPCF_MSVALIDMSRESPONSECHILD | XPCF_DONTSETFLAG)

// --------------------------------------------------------------------------------
// XPCOLUMN
// --------------------------------------------------------------------------------
typedef struct tagXPCOLUMN
{
    HMELE               ele;
    DWORD               dwFlags;
    XPCOLUMNDATATYPE    cdt;
    DWORD               offset;
} XPCOLUMN, *LPXPCOLUMN;

// --------------------------------------------------------------------------------
// XP_BEGIN_SCHEMA
// --------------------------------------------------------------------------------
#define XP_BEGIN_SCHEMA(opName) \
    static const XPCOLUMN c_rg##opName##Schema[] = {

// --------------------------------------------------------------------------------
// XP_SCHEMA_COL
// --------------------------------------------------------------------------------
#define XP_SCHEMA_COL(ele, dwFlags, cdt, tyStruct, fieldName ) \
    { ele, dwFlags, cdt, offsetof(tyStruct, fieldName) },

// --------------------------------------------------------------------------------
// XP_END_SCHEMA
// --------------------------------------------------------------------------------
#define XP_END_SCHEMA \
    };

// --------------------------------------------------------------------------------
// XP_FREE_STRUCT
// --------------------------------------------------------------------------------
#define XP_FREE_STRUCT(opName, target, flags) \
    _FreeStruct(c_rg##opName##Schema, ARRAYSIZE(c_rg##opName##Schema), target, flags)

// --------------------------------------------------------------------------------
// XP_BIND_TO_STRUCT
// --------------------------------------------------------------------------------
#define XP_BIND_TO_STRUCT(opName, pwcText, ulLen, target, wasBound) \
    _BindToStruct(pwcText, ulLen, c_rg##opName##Schema, ARRAYSIZE(c_rg##opName##Schema), target, wasBound)

// --------------------------------------------------------------------------------
// XP_CREATE_PROPFIND_REQUEST
// --------------------------------------------------------------------------------
#define XP_CREATE_PROPFIND_REQUEST(opName, pRequest) \
    HrAddPropFindSchemaProps(pRequest, c_rg##opName##Schema, ARRAYSIZE(c_rg##opName##Schema))

// --------------------------------------------------------------------------------
// State Machine Funcs
// --------------------------------------------------------------------------------
typedef HRESULT (CHTTPMailTransport::*PFNHTTPMAILOPFUNC)(void);

// --------------------------------------------------------------------------------
// XML Parsing Funcs
// --------------------------------------------------------------------------------
typedef HRESULT (CHTTPMailTransport::*PFNCREATEELEMENT)(CXMLNamespace *pBaseNamespace, const WCHAR *pwcText, ULONG ulLen, ULONG ulNamespaceLen, BOOL fTerminal);
typedef HRESULT (CHTTPMailTransport::*PFNHANDLETEXT)(const WCHAR *pwcText, ULONG ulLen);
typedef HRESULT (CHTTPMailTransport::*PFNENDCHILDREN)(void);

typedef struct tagXMLPARSEFUNCS
{
    PFNCREATEELEMENT    pfnCreateElement;
    PFNHANDLETEXT       pfnHandleText;
    PFNENDCHILDREN      pfnEndChildren;
} XMLPARSEFUNCS, *LPXMLPARSEFUNCS;

// --------------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------------
HRESULT HrParseHTTPStatus(LPSTR pszStatusStr, DWORD *pdwStatus);
HRESULT HrAddPropFindProps(IPropFindRequest *pRequest, const HMELE *rgEle, DWORD cEle);
HRESULT HrAddPropFindSchemaProps(IPropFindRequest *pRequest, const XPCOLUMN *prgCols, DWORD cCols);
HRESULT _HrGenerateRfc821Stream(LPCSTR pszFrom, LPHTTPTARGETLIST pTargets, IStream **ppRfc821Stream);
HRESULT HrGeneratePostContactXML(LPHTTPCONTACTINFO pciInfo, LPVOID *ppvXML, DWORD *pdwLen);
HRESULT HrCreatePatchContactRequest(LPHTTPCONTACTINFO pciInfo, IPropPatchRequest **ppRequest);
HRESULT HrGenerateSimpleBatchXML(LPCSTR pszRootName, LPHTTPTARGETLIST pTargets, LPVOID *ppvXML, DWORD *pdwLen);
HRESULT HrGenerateMultiDestBatchXML(LPCSTR pszRootName, LPHTTPTARGETLIST pTargets, LPHTTPTARGETLIST pDestinations, LPVOID *ppvXML, DWORD *pdwLen);
HRESULT HrCopyStringList(LPCSTR *rgszInList, LPCSTR **prgszOutList);
void    FreeStringList(LPCSTR *rgszInList);

typedef struct tagHTTPQUEUEDOP
{
    HTTPMAILCOMMAND         command;

    const PFNHTTPMAILOPFUNC *pfnState;
    int                     cState;

    LPSTR                   pszUrl;
    LPSTR                   pszDestination;
    LPCSTR                  pszContentType;
    LPVOID                  pvData;
    ULONG                   cbDataLen;
    DWORD                   dwContext;
    DWORD                   dwDepth;
    DWORD                   dwRHFlags;
    MEMBERINFOFLAGS         dwMIFlags;
    HTTPMAILPROPTYPE        tyProp;
    BOOL                    fBatch;
    LPCSTR                  *rgszAcceptTypes;
    IPropFindRequest        *pPropFindRequest;
    IPropPatchRequest       *pPropPatchRequest;

    IStream                 *pHeaderStream;
    IStream                 *pBodyStream;

    const XMLPARSEFUNCS     *pParseFuncs;

    struct tagHTTPQUEUEDOP  *pNext;

    // Used with Folders PropFind and Inbox PropFind.
    LPSTR                   pszFolderTimeStamp;

    // Used only with Folders PropFind.
    LPSTR                   pszRootTimeStamp;

} HTTPQUEUEDOP, *LPHTTPQUEUEDOP;

typedef struct tagPCDATABUFFER
{
    WCHAR           *pwcText;
    ULONG           ulLen;
    ULONG           ulCapacity;
} PCDATABUFFER, *LPPCDATABUFFER;

typedef struct tagHMELESTACK
{
    HMELE           ele;
    CXMLNamespace   *pBaseNamespace;
    BOOL            fBeganChildren;
    LPPCDATABUFFER  pTextBuffer;
} HMELESTACK, *LPHMELESTACK;


typedef struct tagHTTPMAILOPERATION
{
    const PFNHTTPMAILOPFUNC *pfnState;
    int                     iState;
    int                     cState;

    BOOL                    fLoggedResponse;

    LPSTR                   pszUrl;
    LPSTR                   pszDestination;
    LPCSTR                  pszContentType;
    LPVOID                  pvData;
    ULONG                   cbDataLen;
    DWORD                   dwContext;

    DWORD                   dwHttpStatus;   // http response status

    LPCSTR                  *rgszAcceptTypes;

    HINTERNET               hRequest;
    BOOL                    fAborted;
    DWORD                   dwDepth;
    DWORD                   dwRHFlags;
    MEMBERINFOFLAGS         dwMIFlags;
    HTTPMAILPROPTYPE        tyProp;
    BOOL                    fBatch;
    IPropFindRequest        *pPropFindRequest;
    IPropPatchRequest       *pPropPatchRequest;
    LPPCDATABUFFER          pTextBuffer;

    IStream                 *pHeaderStream;
    IStream                 *pBodyStream;
    
    // xml parsing
    const XMLPARSEFUNCS     *pParseFuncs;
    CXMLNamespace           *pTopNamespace;
    DWORD                   dwStackDepth;
    HMELESTACK              rgEleStack[ELE_STACK_CAPACITY];

    // PropFind Parsing
    BOOL                    fFoundStatus;
    DWORD                   dwStatus;
    DWORD                   dwPropFlags;

    // response
    HTTPMAILRESPONSE        rResponse;

    // Used with Folders PropFind and Inbox PropFind.
    LPSTR                   pszFolderTimeStamp;

    // Used only with Folders PropFind.
    LPSTR                   pszRootTimeStamp;
} HTTPMAILOPERATION, *LPHTTPMAILOPERATION;

class CHTTPMailTransport : public IHTTPMailTransport, public IXMLNodeFactory, public IHTTPMailTransport2
{
private:
    ULONG               m_cRef;                 // Reference Count
    BOOL                m_fHasServer;           // Has been initialized with a server
    BOOL                m_fHasRootProps;        // Root props have been retrieved
    BOOL                m_fTerminating;         // in the terminating state...killing the iothread
    IXPSTATUS           m_status;               // Connection status
    HINTERNET           m_hInternet;            // Root wininet handle
    HINTERNET           m_hConnection;          // Connection handle
    LPSTR               m_pszUserAgent;         // user agent string
    ILogFile            *m_pLogFile;            // Logfile Object
    IHTTPMailCallback   *m_pCallback;           // Transport callback object
    IXMLParser          *m_pParser;             // xml parser
    HWND                m_hwnd;                 // Window used for event synchronization
    HANDLE              m_hevPendingCommand;    // Event object that signals a pending command
    LPHTTPQUEUEDOP      m_opPendingHead;        // Pending operation - head of the queue
    LPHTTPQUEUEDOP      m_opPendingTail;        // Pending operation - tail of the queue
    CRITICAL_SECTION    m_cs;                   // Thread Safety
    HTTPMAILOPERATION   m_op;                   // current operation
    INETSERVER          m_rServer;              // Internet server
    LPSTR               m_pszCurrentHost;       // current server
    INTERNET_PORT       m_nCurrentPort;         // current port
    ROOTPROPS           m_rootProps;
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CHTTPMailTransport(void);
    virtual ~CHTTPMailTransport(void);

    // ----------------------------------------------------------------------------
    // Unimplemented copy constructor and assignment operator
    // ----------------------------------------------------------------------------
private:
    CHTTPMailTransport(const CHTTPMailTransport& other);            // intentionally unimplemented
    CHTTPMailTransport& operator=(const CHTTPMailTransport& other); // intentionally unimplemented

public:
    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
 
    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // IHTTPMailTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPCSTR pszUserAgent, LPCSTR pszLogFilePath, IHTTPMailCallback *pCallback); 
    STDMETHODIMP GetProperty(HTTPMAILPROPTYPE proptype, LPSTR *ppszProp);
    STDMETHODIMP GetPropertyDw(HTTPMAILPROPTYPE proptype, LPDWORD lpdwProp);
    STDMETHODIMP CommandGET(LPCSTR pszPath, LPCSTR *rgszAcceptTypes, BOOL fTranslate, DWORD dwContext);
    STDMETHODIMP CommandPUT(LPCSTR pszPath, LPVOID lpvData, ULONG cbData, DWORD dwContext);
    STDMETHODIMP CommandPOST(LPCSTR pszPath, IStream *pStream, LPCSTR pszContentType, DWORD dwContext);
    STDMETHODIMP CommandDELETE(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP CommandBDELETE(LPCSTR pszPath, LPHTTPTARGETLIST pBatchTargets, DWORD dwContext);
    STDMETHODIMP CommandPROPFIND(LPCSTR pszUrl, IPropFindRequest *pRequest, DWORD dwDepth, DWORD dwContext);
    STDMETHODIMP CommandPROPPATCH(LPCSTR pszUrl, IPropPatchRequest *pRequest, DWORD dwContext);
    STDMETHODIMP CommandMKCOL(LPCSTR pszUrl, DWORD dwContext);
    STDMETHODIMP CommandCOPY(LPCSTR pszPath, LPCSTR pszDestination, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP CommandBCOPY(LPCSTR pszSourceCollection, LPHTTPTARGETLIST pBatchTargets, LPCSTR pszDestCollection, LPHTTPTARGETLIST pBatchDests, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP CommandMOVE(LPCSTR pszPath, LPCSTR pszDestination, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP CommandBMOVE(LPCSTR pszSourceCollection, LPHTTPTARGETLIST pBatchTargets, LPCSTR pszDestCollection, LPHTTPTARGETLIST pBatchDests, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP MemberInfo(LPCSTR pszPath, MEMBERINFOFLAGS flags, DWORD dwDepth, BOOL fIncludeRoot, DWORD dwContext);
    STDMETHODIMP FindFolders(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP MarkRead(LPCSTR pszPath, LPHTTPTARGETLIST pTargets, BOOL fMarkRead, DWORD dwContext);
    STDMETHODIMP SendMessage(LPCSTR pszPath, LPCSTR pszFrom, LPHTTPTARGETLIST pTargets, BOOL fSaveInSent, IStream *pMessageStream, DWORD dwContext);
    STDMETHODIMP ListContacts(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP ListContactInfos(LPCSTR pszCollectionPath, DWORD dwContext);
    STDMETHODIMP ContactInfo(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP PostContact(LPCSTR pszPath, LPHTTPCONTACTINFO pciInfo, DWORD dwContext);
    STDMETHODIMP PatchContact(LPCSTR pszPath, LPHTTPCONTACTINFO pciInfo, DWORD dwContext);

    // ----------------------------------------------------------------------------
    // IXMLNodeFactory methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP NotifyEvent(IXMLNodeSource* pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource* pSource, XML_NODE_INFO *pNodeInfo);   
    STDMETHODIMP EndChildren(IXMLNodeSource* pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource* pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO** apNodeInfo);
    STDMETHODIMP CreateNode(
                        IXMLNodeSource* pSource, 
                        PVOID pNodeParent,
                        USHORT cNumRecs,
                        XML_NODE_INFO** apNodeInfo);

    // ----------------------------------------------------------------------------
    // IHTTPMailTransport2 methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP RootMemberInfo( LPCSTR pszPath, MEMBERINFOFLAGS flags, DWORD dwDepth,
                                 BOOL fIncludeRoot, DWORD dwContext, LPSTR pszRootTimeStamp,
                                 LPSTR pszInboxTimeStamp);
        
    STDMETHODIMP FolderMemberInfo( LPCSTR pszPath, MEMBERINFOFLAGS flags, DWORD dwDepth, BOOL fIncludeRoot,
                                        DWORD dwContext, LPSTR pszFolderTimeStamp, LPSTR pszFolderName);


    // ----------------------------------------------------------------------------
    // New API
    // ----------------------------------------------------------------------------
    HRESULT     HrConnectToHost(LPSTR pszHostName, INTERNET_PORT nPort, LPSTR pszUserName, LPSTR pszPassword);
    HRESULT     DoLogonPrompt(void);
    HRESULT     DoGetParentWindow(HWND *phwndParent);

    HINTERNET   GetConnection(void) { return m_hConnection; }
    LPSTR       GetServerName(void) { return m_rServer.szServerName; }
    LPSTR       GetUserName(void) { return ('/0' == m_rServer.szUserName[0]) ? NULL : m_rServer.szUserName; }
    LPSTR       GetPassword(void) { return ('/0' == m_rServer.szPassword[0]) ? NULL : m_rServer.szPassword; }

    IHTTPMailCallback* GetCallback(void) { return m_pCallback; }

    HWND        GetWindow(void) { return m_hwnd; }

    BOOL        GetHasRootProps(void) { return m_fHasRootProps; }
    void        SetHasRootProps(BOOL fHasRootProps) { m_fHasRootProps = fHasRootProps; }

    LPSTR       GetAdbar(void) { return m_rootProps.pszAdbar; }
    void        AdoptAdbar(LPSTR pszAdbar) { SafeMemFree(m_rootProps.pszAdbar); m_rootProps.pszAdbar = pszAdbar; }
    
    LPSTR       GetContacts(void) { return m_rootProps.pszContacts; }
    void        AdoptContacts(LPSTR pszContacts) { SafeMemFree(m_rootProps.pszContacts); m_rootProps.pszContacts = pszContacts; }
    
    LPSTR       GetInbox(void) { return m_rootProps.pszInbox; }
    void        AdoptInbox(LPSTR pszInbox) { SafeMemFree(m_rootProps.pszInbox); m_rootProps.pszInbox = pszInbox; }

    LPSTR       GetOutbox(void) { return m_rootProps.pszOutbox; }
    void        AdoptOutbox(LPSTR pszOutbox) { SafeMemFree(m_rootProps.pszOutbox); m_rootProps.pszOutbox = pszOutbox; }

    LPSTR       GetSendMsg(void) { return m_rootProps.pszSendMsg; }
    void        AdoptSendMsg(LPSTR pszSendMsg) { SafeMemFree(m_rootProps.pszSendMsg); m_rootProps.pszSendMsg = pszSendMsg; }

    LPSTR       GetSentItems(void) { return m_rootProps.pszSentItems; }
    void        AdoptSentItems(LPSTR pszSentItems) { SafeMemFree(m_rootProps.pszSentItems); m_rootProps.pszSentItems = pszSentItems; }
    
    LPSTR       GetDeletedItems(void) { return m_rootProps.pszDeletedItems; }
    void        AdoptDeletedItems(LPSTR pszDeletedItems) { SafeMemFree(m_rootProps.pszDeletedItems); m_rootProps.pszDeletedItems = pszDeletedItems; }
    
    LPSTR       GetDrafts(void) { return m_rootProps.pszDrafts; }
    void        AdoptDrafts(LPSTR pszDrafts) { SafeMemFree(m_rootProps.pszDrafts); m_rootProps.pszDrafts = pszDrafts; }
    
    LPSTR       GetMsgFolderRoot(void) { return m_rootProps.pszMsgFolderRoot; }
    void        AdoptMsgFolderRoot(LPSTR pszMsgFolderRoot) { SafeMemFree(m_rootProps.pszMsgFolderRoot); m_rootProps.pszMsgFolderRoot = pszMsgFolderRoot; }

    LPSTR       GetSig(void) { return m_rootProps.pszSig; }
    void        AdoptSig(LPSTR pszSig) { SafeMemFree(m_rootProps.pszSig); m_rootProps.pszSig = pszSig; }

    BOOL        WasAborted(void) { return m_op.fAborted; }

private:
    // ----------------------------------------------------------------------------
    // CHTTPMailTransport private implementation
    // ----------------------------------------------------------------------------
public:

    // Translate an HTTPCOMMAND constant into a string
    LPSTR CommandToVerb(HTTPMAILCOMMAND command);

private:
    HRESULT UpdateLogonInfo(void);

    HRESULT GetParentWindow(HWND *phwndParent);

    BOOL ReadBytes(LPSTR pszBuffer, DWORD cbBufferSize, DWORD *pcbBytesRead);

    BOOL _GetStatusCode(DWORD *pdw);
    BOOL _GetContentLength(DWORD *pdw);

    HRESULT _GetRequestHeader(LPSTR *ppszHeader, DWORD dwHeader);
    HRESULT _AddRequestHeader(LPCSTR pszHeader);
    HRESULT _MemberInfo2(LPCSTR pszPath, MEMBERINFOFLAGS   flags, DWORD  dwDepth,
                         BOOL   fIncludeRoot, DWORD dwContext, LPHTTPQUEUEDOP  *ppOp);
    HRESULT _HrParseAndCopy(LPCSTR pszToken, LPSTR *ppszDest, LPSTR lpszSrc);
    HRESULT _HrGetTimestampHeader(LPSTR *ppszHeader);


    BOOL _AuthCurrentRequest(DWORD dwStatus, BOOL fRetryAuth);

    void _LogRequest(LPVOID pvData, DWORD cbData);
    void _LogResponse(LPVOID pvData, DWORD cbData);

    HRESULT QueueGetPropOperation(HTTPMAILPROPTYPE type);

    // ----------------------------------------------------------------------------
    // Element Parsing
    // ----------------------------------------------------------------------------
    BOOL StackTop(HMELE hmEle) { return (m_op.dwStackDepth < ELE_STACK_CAPACITY) && (m_op.rgEleStack[m_op.dwStackDepth - 1].ele == hmEle); }
    BOOL ValidStack(const HMELE *prgEle, DWORD cEle);
    BOOL InValidElementChildren(void) { return ((m_op.dwStackDepth > 0) && (m_op.dwStackDepth <= ELE_STACK_CAPACITY) && (m_op.rgEleStack[m_op.dwStackDepth - 1].fBeganChildren)); }
    void PopNamespaces(CXMLNamespace *pBaseNamespace);
    HRESULT PushNamespaces(XML_NODE_INFO** apNodeInfo, USHORT cNumRecs);

    HRESULT StrNToBoolW(const WCHAR *pwcText, ULONG ulLen, BOOL *pb);
    HRESULT StatusStrNToIxpHr(const WCHAR *pwcText, DWORD ulLen, HRESULT *hr);
    HRESULT AllocStrFromStrNW(const WCHAR *pwcText, ULONG ulLen, LPSTR *ppszAlloc);
    HRESULT StrNToDwordW(const WCHAR *pwcText, ULONG ulLen, DWORD *pi);
    HRESULT StrNToSpecialFolderW(const WCHAR *pwcText, ULONG ulLen, HTTPMAILSPECIALFOLDER *ptySpecial);
    HRESULT StrNToContactTypeW(const WCHAR *pwcText, ULONG ulLen, HTTPMAILCONTACTTYPE *ptyContact);

    // ----------------------------------------------------------------------------
    // Misc.
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Queue Management
    // ----------------------------------------------------------------------------
    HRESULT AllocQueuedOperation(
                        LPCSTR pszUrl, 
                        LPVOID pvData, 
                        ULONG cbDataLen,
                        LPHTTPQUEUEDOP *ppOp,
                        BOOL fAdoptData = FALSE);
    void QueueOperation(LPHTTPQUEUEDOP pOp);
    BOOL DequeueNextOperation(void);

    void FlushQueue(void);
    void TerminateIOThread(void);

    BOOL IsTerminating(void)
    {
        BOOL fResult;

        EnterCriticalSection(&m_cs);
        fResult = m_fTerminating;
        LeaveCriticalSection(&m_cs);

        return fResult;
    }

    // Thread Entry Proxy
    static DWORD CALLBACK IOThreadFuncProxy(PVOID pv);

    DWORD IOThreadFunc();

    // Window Proc
    static LRESULT CALLBACK WndProc(
                    HWND hwnd, 
                    UINT msg, 
                    WPARAM wParam, 
                    LPARAM lParam);

    HRESULT HrReadCompleted(void);

    // Reset the transport object
    void Reset(void);

    // Create a window handle for messaging between the client and i/o thread
    BOOL CreateWnd(void);

    // WinInet callback (proxies through StatusCallbackProxy)
    void OnStatusCallback(
                    HINTERNET hInternet,
                    DWORD dwInternetStatus,
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength);

    // thunks the response to the calling thread
    HRESULT _HrThunkConnectionError(void);
    HRESULT _HrThunkConnectionError(DWORD dwStatus);
    HRESULT _HrThunkResponse(BOOL fDone);
    
    HRESULT InvokeResponseCallback(void);

    // Translate a WinInet status message to an IXPSTATUS message.
    // Returns true if the status was translated.
    BOOL TranslateWinInetMsg(DWORD dwInternetStatus, IXPSTATUS *pIxpStatus);
    
    // WinInet callback proxy, which calls through to non-static
    // OnStatusCallback method
    static void StatusCallbackProxy(
                    HINTERNET hInternet, 
                    DWORD dwContext, 
                    DWORD dwInternetStatus, 
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength);

    // ----------------------------------------------------------------------------
    // Response Management
    // ----------------------------------------------------------------------------
    void FreeMemberInfoList(void);
    void FreeMemberErrorList();
    void FreeContactIdList(void);
    void FreeContactInfoList(void);
    void FreeBCopyMoveList(void);

    // ----------------------------------------------------------------------------
    // State Machine Functions
    // ----------------------------------------------------------------------------
    void DoOperation(void);
    void FreeOperation(void);

    // ----------------------------------------------------------------------------
    // Parser Utils
    // ----------------------------------------------------------------------------
private:
    HRESULT _BindToStruct(const WCHAR *pwcText,
                          ULONG ulLen,
                          const XPCOLUMN *prgCols,
                          DWORD cCols,
                          LPVOID pTarget,
                          BOOL *pfWasBound);

    void _FreeStruct(const XPCOLUMN *prgCols,
                     DWORD cCols,
                     LPVOID pTarget,
                     DWORD *pdwFlags);

    HRESULT _GetTextBuffer(LPPCDATABUFFER *ppTextBuffer)
    {
        if (m_op.pTextBuffer)
        {
            *ppTextBuffer = m_op.pTextBuffer;
            m_op.pTextBuffer = NULL;
            return S_OK;
        }
        else
            return _AllocTextBuffer(ppTextBuffer);
    }

    HRESULT _AppendTextToBuffer(LPPCDATABUFFER pTextBuffer, const WCHAR *pwcText, ULONG ulLen);
    HRESULT _AllocTextBuffer(LPPCDATABUFFER *ppTextBuffer);
    void _ReleaseTextBuffer(LPPCDATABUFFER pTextBuffer)
    {
        IxpAssert(NULL != pTextBuffer);

        // if the buffer capacity is the original byte count, and there is
        // no buffer in the cache, then return this one to the cache
        if (NULL == m_op.pTextBuffer && PCDATA_BUFSIZE == pTextBuffer->ulCapacity)
        {
            pTextBuffer->ulLen = 0;
            m_op.pTextBuffer = pTextBuffer;
        }
        else
            _FreeTextBuffer(pTextBuffer);
    }

    void _FreeTextBuffer(LPPCDATABUFFER pTextBuffer);
    
public:
        // common states
    HRESULT OpenRequest(void);
    HRESULT SendRequest(void);
    HRESULT AddCommonHeaders(void);
    HRESULT RequireMultiStatus(void);
    HRESULT FinalizeRequest(void);
    HRESULT AddCharsetLine(void);

        // GET states
    HRESULT ProcessGetResponse(void);
        
        // POST states
    HRESULT AddContentTypeHeader(void);
    HRESULT SendPostRequest(void);
    HRESULT ProcessPostResponse(void);

        // XML processing
    HRESULT ProcessXMLResponse(void);

        // PROPFIND states
    HRESULT GeneratePropFindXML(void);
    HRESULT AddDepthHeader(void);

        // PROPPATCH states
    HRESULT GeneratePropPatchXML(void);

        // MKCOL states
    HRESULT ProcessCreatedResponse(void);

        // COPY and MOVE states
    HRESULT AddDestinationHeader(void);
    HRESULT ProcessLocationResponse(void);

        // BCOPY and BMOVE states
    HRESULT InitBCopyMove(void);

        // RootProp states
    HRESULT InitRootProps(void);
    HRESULT FinalizeRootProps(void);

        // MemberInfo states
    HRESULT InitMemberInfo(void);

        // MemberError states
    HRESULT InitMemberError(void);

        // ListContacts
    HRESULT InitListContacts(void);

        // ContactInfo
    HRESULT InitContactInfo(void);
        
        // PostContact
    HRESULT ProcessPostContactResponse(void);

        // PatchContact
    HRESULT ProcessPatchContactResponse(void);

    // ----------------------------------------------------------------------------
    // XML Parsing Functions
    // ----------------------------------------------------------------------------
    HRESULT CreateElement(CXMLNamespace *pBaseNamespace, const WCHAR *pwcText, ULONG ulLen, ULONG ulNamespaceLen, BOOL fTerminal);
    HRESULT EndChildren(void);

        // BCOPY and BMOVE
    HRESULT BCopyMove_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT BCopyMove_EndChildren(void);

        // PropFind
    HRESULT PropFind_HandleText(const WCHAR *pwcText, ULONG ulLen);

        // RootProps
    HRESULT RootProps_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT RootProps_EndChildren(void);

        // MemberInfo
    HRESULT MemberInfo_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT MemberInfo_EndChildren(void);

        // MemberError
    HRESULT MemberError_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT MemberError_EndChildren(void);

        // ListContacts
    HRESULT ListContacts_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT ListContacts_EndChildren(void);

        // ContactInfo
    HRESULT ContactInfo_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT ContactInfo_EndChildren(void);

        // PostContact and PatchContact
    HRESULT PostOrPatchContact_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT PostOrPatchContact_EndChildren(void);

public:
    HRESULT _CreateXMLParser(void);
};

#endif // __IXPHTTPM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixppop3.cpp ===
// --------------------------------------------------------------------------------
// Ixppop3.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "ixppop3.h"
#include "asynconn.h"
#include "ixputil.h"  
#include "strconst.h"
#include <shlwapi.h>
#include <ntverp.h>
#include "demand.h"

// --------------------------------------------------------------------------------
// Usefule C++ pointer casting
// --------------------------------------------------------------------------------
#define POP3THISIXP         ((IPOP3Transport *)(CIxpBase *)this)
#define STR_HOTMAILAUTH     "Outlook Express V" VER_PRODUCTVERSION_STR

// --------------------------------------------------------------------------------
// FreeAuthInfo
// --------------------------------------------------------------------------------
void FreeAuthInfo(LPAUTHINFO pAuth)
{
    for (UINT i=0; i<pAuth->cAuthToken; i++)
    {
        SafeMemFree(pAuth->rgpszAuthTokens[i]);
    }
    pAuth->iAuthToken = pAuth->cAuthToken = 0;
    if (pAuth->pPackages && pAuth->cPackages)
    {
        SSPIFreePackages(&pAuth->pPackages, pAuth->cPackages);
        pAuth->pPackages = NULL;
        pAuth->cPackages = 0;
    }
    SSPIFreeContext(&pAuth->rSicInfo);
    ZeroMemory(pAuth, sizeof(AUTHINFO));
}

// --------------------------------------------------------------------------------
// CPOP3Transport::CPOP3Transport
// --------------------------------------------------------------------------------
CPOP3Transport::CPOP3Transport(void) : CIxpBase(IXP_POP3)
{
	DllAddRef();
    ZeroMemory(&m_rInfo, sizeof(POP3INFO));
    m_rInfo.rAuth.authstate = AUTH_NONE;
    m_command = POP3_NONE;
    m_fHotmail = FALSE;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::~CPOP3Transport
// --------------------------------------------------------------------------------
CPOP3Transport::~CPOP3Transport(void)
{
    ResetBase();
	DllRelease();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::ResetBase
// --------------------------------------------------------------------------------
void CPOP3Transport::ResetBase(void)
{
    EnterCriticalSection(&m_cs);
    FreeAuthInfo(&m_rInfo.rAuth);
    SafeMemFree(m_rInfo.prgMarked);
    ZeroMemory(&m_rInfo, sizeof(POP3INFO));
    m_command = POP3_NONE;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPOP3Transport *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)(CIxpBase *)this);

    // IID_IPOP3Transport
    else if (IID_IPOP3Transport == riid)
        *ppv = (IPOP3Transport *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Transport::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Transport::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::InitNew(LPSTR pszLogFilePath, IPOP3Callback *pCallback)
{
    // Call Base Class
    return CIxpBase::OnInitNew("POP3", pszLogFilePath, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (ITransportCallback *)pCallback);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::HandsOffCallback(void)
{
    return CIxpBase::HandsOffCallback();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::GetStatus(IXPSTATUS *pCurrentStatus)
{
    return CIxpBase::GetStatus(pCurrentStatus);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Does user want us to always prompt for his password? Prompt him here to avoid
    // inactivity timeouts while the prompt is up, unless a password was supplied
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pInetServer->szPassword[0])
    {
        HRESULT hr;

        if (NULL != m_pCallback)
            hr = m_pCallback->OnLogonPrompt(pInetServer, POP3THISIXP);

        if (NULL == m_pCallback || S_OK != hr)
            return IXP_E_USER_CANCEL;
    }

    return CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::DropConnection(void)
{
    return CIxpBase::DropConnection();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::Disconnect(void)
{
    return CIxpBase::Disconnect();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::IsState(IXPISSTATE isstate)
{
    return CIxpBase::IsState(isstate);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::GetServerInfo(LPINETSERVER pInetServer)
{
    return CIxpBase::GetServerInfo(pInetServer);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CPOP3Transport::GetIXPType(void)
{
    return CIxpBase::GetIXPType();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnEnterBusy
// --------------------------------------------------------------------------------
void CPOP3Transport::OnEnterBusy(void)
{
    IxpAssert(m_command == POP3_NONE);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnLeaveBusy
// --------------------------------------------------------------------------------
void CPOP3Transport::OnLeaveBusy(void)
{
    m_command = POP3_NONE;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnConnected
// --------------------------------------------------------------------------------
void CPOP3Transport::OnConnected(void)
{
    m_command = POP3_BANNER;
    CIxpBase::OnConnected();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnDisconnect
// --------------------------------------------------------------------------------
void CPOP3Transport::OnDisconnected(void)
{
    ResetBase();
    CIxpBase::OnDisconnected();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnNotify
// --------------------------------------------------------------------------------
void CPOP3Transport::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Handle Event
    switch(ae)
    {
    // --------------------------------------------------------------------------------
    case AE_RECV:
        OnSocketReceive();
        break;

    // --------------------------------------------------------------------------------
    default:
        CIxpBase::OnNotify(asOld, asNew, ae);
        break;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnSocketReceive
// --------------------------------------------------------------------------------
void CPOP3Transport::OnSocketReceive(void)
{
    // Locals
    HRESULT hr;

    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Handle Current pop3 state
    switch(m_command)
    {
    // --------------------------------------------------------------------------------
    case POP3_BANNER:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Detect if the banner had the word hotmail in it
        Assert(m_pszResponse);
        m_fHotmail = (NULL == m_pszResponse || NULL == StrStrIA(m_pszResponse, "hotmail")) ? FALSE : TRUE;

        // Dispatch the response
        DispatchResponse(hr);

        // Authorizing
        if (m_fConnectAuth)
            StartLogon();

        // Ohterwise were connected
        else
        {
            m_command = POP3_CONNECTED;
            DispatchResponse(S_OK);
        }

        // Not yet auth'ed
        m_fAuthenticated = FALSE;
        break;

    // --------------------------------------------------------------------------------
    case POP3_USER:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(FAILED(hr) ? IXP_E_POP3_INVALID_USER_NAME : S_OK);

        // Authorizing
        if (m_fConnectAuth)
        {
            // Retry logon
            if (FAILED(hr))
                LogonRetry(IXP_E_POP3_INVALID_USER_NAME);

            // otherwise send the password
            else
            {
                hr = CommandPASS(m_rServer.szPassword);
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                }
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case POP3_PASS:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(FAILED(hr) ? IXP_E_POP3_INVALID_PASSWORD : S_OK);

        // Authorizing
        if (m_fConnectAuth)
        {
            // Retry if failed
            if (FAILED(hr))
                LogonRetry(IXP_E_POP3_INVALID_PASSWORD);

            // Otherwise, we're authorized
            else
            {
                OnStatus(IXP_AUTHORIZED);
                m_fConnectAuth = FALSE;
                m_command = POP3_CONNECTED;
                DispatchResponse(S_OK);
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case POP3_AUTH:
        // If hotmail, then, we've identified ourselves, so lets send the user command
        if (m_fHotmail)
        {
            // Read Server Response...
            hr = HrGetResponse();
            if (IXP_E_INCOMPLETE == hr)
                goto exit;

            // Issue the user command
            hr = CommandUSER(m_rServer.szUserName);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }
        }

        // Otherwise, lets continue DPA auth
        else if (m_rInfo.rAuth.authstate != AUTH_ENUMPACKS_DATA)
        {
            // Read Server Response...
            hr = HrGetResponse();
            if (IXP_E_INCOMPLETE == hr)
                goto exit;

            // Authenticating
            if (m_fConnectAuth)
            {
                ResponseAUTH(hr);
            }
            else
            {
                // Dispatch the response
                DispatchResponse(hr);
            }
        }

        // Otherwise, handle resposne
        else
        {
            // no HrGetResponse() because we are getting list data
            ResponseAUTH(0);
        }
        break;        

    // --------------------------------------------------------------------------------
    case POP3_STAT:
        ResponseSTAT();
        break;

    // --------------------------------------------------------------------------------
    case POP3_NOOP:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(hr, TRUE);
        break;

    // --------------------------------------------------------------------------------
    case POP3_UIDL:
    case POP3_LIST:
        ResponseGenericList();
        break;

    // --------------------------------------------------------------------------------
    case POP3_DELE:
        ResponseDELE();
        break;

    // --------------------------------------------------------------------------------
    case POP3_RETR:
    case POP3_TOP:
        ResponseGenericRetrieve();
        break;

    // --------------------------------------------------------------------------------
    case POP3_QUIT:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(hr, FALSE);

        // Drop the socket
        m_pSocket->Close();
        break;
    }

exit:
    // Done
    LeaveCriticalSection(&m_cs);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::DispatchResponse
// ------------------------------------------------------------------------------------
void CPOP3Transport::DispatchResponse(HRESULT hrResult, BOOL fDone, LPPOP3RESPONSE pResponse)
{
    // Locals
    POP3RESPONSE rResponse;

    // If a response was passed in, use it...
    if (pResponse)
        CopyMemory(&rResponse, pResponse, sizeof(POP3RESPONSE));
    else
        ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

    // Set the HRESULT
    rResponse.command = m_command;
    rResponse.rIxpResult.hrResult = hrResult;
    rResponse.rIxpResult.pszResponse = m_pszResponse;
    rResponse.rIxpResult.uiServerError = m_uiResponse;
    rResponse.rIxpResult.hrServerError = m_hrResponse;
    rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rResponse.rIxpResult.pszProblem = NULL;
    rResponse.fDone = fDone;
    rResponse.pTransport = this;

    // If Done...
    if (fDone)
    {
        // No current command
        m_command = POP3_NONE;

        // Leave Busy State
        LeaveBusy();
    }

    // Give the Response to the client
    if (m_pCallback)
        ((IPOP3Callback *)m_pCallback)->OnResponse(&rResponse);

    // Reset Last Response
    SafeMemFree(m_pszResponse);
    m_hrResponse = S_OK;
    m_uiResponse = 0;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::HrGetResponse
// --------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrGetResponse(void)
{
    // Locals
    INT          cbLine;
    BOOL         fComplete;

    // Clear current response
    IxpAssert(m_pszResponse == NULL && m_hrResponse == S_OK);

    // Set m_hrResponse
    m_hrResponse = S_OK;

    // Read Line
    m_hrResponse = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
    if (FAILED(m_hrResponse))
        goto exit;

    // If not complete
    if (!fComplete)
        goto exit;

    // - Response
    if ('+' != m_pszResponse[0])
    {
        m_hrResponse = TrapError(IXP_E_POP3_RESPONSE_ERROR);
        if (m_pCallback && m_fCommandLogging)
            m_pCallback->OnCommand(CMD_RESP, m_pszResponse, m_hrResponse, POP3THISIXP);
        goto exit;
    }

    // Don't log UIDL or LIST response lines...
    else if (m_pCallback && m_fCommandLogging)
        m_pCallback->OnCommand(CMD_RESP, m_pszResponse, S_OK, POP3THISIXP);

exit:
    // Exit
    return m_hrResponse;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::StartLogon
// ------------------------------------------------------------------------------------
void CPOP3Transport::StartLogon(void)
{
    // Locals
    HRESULT     hr;

    // Progress
    OnStatus(IXP_AUTHORIZING);

    // If Not Using Sicily or its not installed, then send USER command
    if (FALSE == m_rServer.fTrySicily || FALSE == FIsSicilyInstalled())
    {
        // If Hotmail, send the AUTH OutlookExpress command
        if (m_fHotmail)
        {
            // Otherwise, send AUTH enumpacks command
            hr = CommandAUTH(STR_HOTMAILAUTH);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }
        }

        // Otherwise
        else
        {
            // Issue the user command
            hr = CommandUSER(m_rServer.szUserName);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }
        }

        // Done
        return;
    }

    // Turn Off HOtmail
    m_fHotmail = FALSE;

    // Otherwise, send AUTH enumpacks command
    hr = CommandAUTH((LPSTR)"");
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }

    // Otherwise, set the state
    m_rInfo.rAuth.authstate = AUTH_ENUMPACKS;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::LogonRetry
// ------------------------------------------------------------------------------------
void CPOP3Transport::LogonRetry(HRESULT hrLogon)
{
    // Locals
    HRESULT         hr=S_OK;

    // Give logon failed status
    // OnError(hrLogon);

    // Auth Retry
    OnStatus(IXP_AUTHRETRY);

    // Enter Auth Retry State
    m_pSocket->Close();

    // Logon
    if (NULL == m_pCallback || m_pCallback->OnLogonPrompt(&m_rServer, POP3THISIXP) != S_OK)
    {
        // Go to terminal state, were done.
        OnDisconnected();
        return;
    }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        OnError(TrapError(IXP_E_SOCKET_CONNECT_ERROR));
        OnDisconnected();
        return;
    }

    // Start WatchDog
    m_pSocket->StartWatchDog();
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseAUTH
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseAUTH(HRESULT hrResponse)
{
    // Locals
    HRESULT         hr;
    BOOL            fPackageInstalled;
    SSPIBUFFER      Negotiate;
    SSPIBUFFER      Challenge;
    SSPIBUFFER      Response;
    ULONG           i;

    // We better be in sicily
    Assert(FIsSicilyInstalled());

    // If we just started enumerating packages...
    if (m_rInfo.rAuth.authstate == AUTH_ENUMPACKS)
    {
        // Free old tokens
        for (i=0; i<m_rInfo.rAuth.cAuthToken; i++)
        {
            SafeMemFree(m_rInfo.rAuth.rgpszAuthTokens[i]);
        }
        m_rInfo.rAuth.iAuthToken = m_rInfo.rAuth.cAuthToken = 0;

        if (SUCCEEDED(hrResponse))
        {
            m_rInfo.rAuth.authstate = AUTH_ENUMPACKS_DATA;
            goto EnumData;
        }

        OnError(IXP_E_SICILY_LOGON_FAILED);
        hr = CommandQUIT();
        if (FAILED(hr))        
            DropConnection();
        return;
    }

    else if (m_rInfo.rAuth.authstate == AUTH_ENUMPACKS_DATA)
    {
EnumData:
        int     cbLine;
        BOOL    fComplete;

        // Clear Response
        SafeMemFree(m_pszResponse);
        m_uiResponse = 0;
        m_hrResponse = S_OK;

        // Read a blob of lines
        while (1)
        {
            // Read the line
            hr = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }

            // If not complete
            if (!fComplete)
                return;

            // Add Detail
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, S_OK, POP3THISIXP);

            // StripCRLF
            StripCRLF(m_pszResponse, (ULONG *)&cbLine);

            // If its a dot, were done
            if (*m_pszResponse == '.')
                break;

            m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.cAuthToken++] = m_pszResponse;            
        }

        if (!m_rInfo.rAuth.cAuthToken)
        {
            OnError(IXP_E_SICILY_LOGON_FAILED);
            hr = CommandQUIT();
            if (FAILED(hr))        
                DropConnection();
            return;
        }

        // Free current packages...
        if (m_rInfo.rAuth.pPackages && m_rInfo.rAuth.cPackages)
        {
            SSPIFreePackages(&m_rInfo.rAuth.pPackages, m_rInfo.rAuth.cPackages);
            m_rInfo.rAuth.pPackages = NULL;
            m_rInfo.rAuth.cPackages = 0;
        }

        // Get installed security packages
        if (FAILED(SSPIGetPackages(&m_rInfo.rAuth.pPackages, &m_rInfo.rAuth.cPackages)))
        {
            OnError(IXP_E_LOAD_SICILY_FAILED);
            hr = CommandQUIT();
            if (FAILED(hr))        
                DropConnection();
            return;
        }
    }

    // Otherwise, we must have just tryed a package
    else if (m_rInfo.rAuth.authstate == AUTH_TRYING_PACKAGE)
    {
        // Stop the WatchDog
        m_pSocket->StopWatchDog();

        // If Success Response
        if (SUCCEEDED(hrResponse))
        {
            // Do Sicily Logon
            Assert(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken);

            if (SUCCEEDED(SSPILogon(&m_rInfo.rAuth.rSicInfo, m_rInfo.rAuth.fRetryPackage, SSPI_BASE64, m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken], &m_rServer, m_pCallback)))
            {
                if (m_rInfo.rAuth.fRetryPackage)
                {
                    // Don't retry again
                    m_rInfo.rAuth.fRetryPackage = FALSE;
                }

                // Get negotiation string
                if (SUCCEEDED(SSPIGetNegotiate(&m_rInfo.rAuth.rSicInfo, &Negotiate)))
                {
                    // Send AUTH Respons
                    if (SUCCEEDED(HrSendSicilyString(Negotiate.szBuffer)))
                    {
                        m_rInfo.rAuth.authstate = AUTH_NEGO_RESP;
                    }
                }
                else
                {
                    HrCancelAuthInProg();
                }
            }
            else
            {
                HrCancelAuthInProg();
            }

            // Start the WatchDog
            m_pSocket->StartWatchDog();

            // Done
            return;
        }

        // That failed, free sicinfo and go on with life
        SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);

        // Goto Next Package
        m_rInfo.rAuth.iAuthToken++;
    }

    // Otherwise, we got a response from a negotiation string
    else if (m_rInfo.rAuth.authstate == AUTH_NEGO_RESP)
    {
        // Start the WatchDog
        m_pSocket->StopWatchDog();

        // Succeeded Response
        if (SUCCEEDED(hrResponse))
        {
            // Set Chal String - skip over "+ "
            SSPISetBuffer(m_pszResponse + 2, SSPI_STRING, 0, &Challenge);

            // Get response from challenge
            if (SUCCEEDED(SSPIResponseFromChallenge(&m_rInfo.rAuth.rSicInfo, &Challenge, &Response)))
            {
                // Send AUTH Respons
                if (SUCCEEDED(HrSendSicilyString(Response.szBuffer)))
                {
                    // if we need to continue, we keep the state the same
                    // else we transition to the AUTH_RESP_RESP state.
                    if (!Response.fContinue)
                        m_rInfo.rAuth.authstate = AUTH_RESP_RESP;
                }
            }
            else
            {
                HrCancelAuthInProg();
            }
        }
        else
        {
            // retry current package, with prompt
            m_rInfo.rAuth.fRetryPackage = TRUE;

            Assert(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken);
            hr = CommandAUTH(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
                return;
            }

            // We are in the TRYING_PACKAGE state
            m_rInfo.rAuth.authstate = AUTH_TRYING_PACKAGE;

            SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);
        }

        // Start the WatchDog
        m_pSocket->StartWatchDog();

        // Done
        return;
    }

    // Otherwise, we got a response from a challenge response string
    else if (m_rInfo.rAuth.authstate == AUTH_RESP_RESP)
    {
        // If that succeeded
        if (SUCCEEDED(hrResponse))
        {
            // We will free the context, but keep the credential handle
            SSPIReleaseContext(&m_rInfo.rAuth.rSicInfo);

            // Connected (Authorized) state
            OnStatus(IXP_AUTHORIZED);
            m_fConnectAuth = FALSE;
            m_command = POP3_CONNECTED;
            DispatchResponse(S_OK);

        }
        else
        {
            // retry current package, with prompt
            m_rInfo.rAuth.fRetryPackage = TRUE;

            Assert(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken);
            hr = CommandAUTH(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
                return;
            }

            // We are in the TRYING_PACKAGE state
            m_rInfo.rAuth.authstate = AUTH_TRYING_PACKAGE;

            SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);
        }
        return;
    }
    else if (m_rInfo.rAuth.authstate == AUTH_CANCELED)
    {
        SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);

        // Goto Next Package
        m_rInfo.rAuth.iAuthToken++;
    }


    // Loop through the auth tokens, and try to authenticate with each one in order
    while(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken)
    {
        // We will handle basic authentication
        if (lstrcmpi(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken], "BASIC") != 0)
        {
            // Package not installed ?
            fPackageInstalled=FALSE;
            for (i=0; i<m_rInfo.rAuth.cPackages; i++)
            {
                // Null Package ??
                if (!m_rInfo.rAuth.pPackages[i].pszName)
                    continue;

                // Is this the package I am looking for
                if (lstrcmpi(m_rInfo.rAuth.pPackages[i].pszName, m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]) == 0)
                {
                    fPackageInstalled = TRUE;
                    break;
                }
            }

            // Package not installed ?
            if (fPackageInstalled)
            {
                m_rInfo.rAuth.fRetryPackage = FALSE;

                // If the package has a realm, send digest, otherwise, send normal
                hr = CommandAUTH(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]);
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                    return;
                }

                // We are in the TRYING_PACKAGE state
                m_rInfo.rAuth.authstate = AUTH_TRYING_PACKAGE;

                // Done
                return;
            }
        }

        // Goto Next Package String
        m_rInfo.rAuth.iAuthToken++;
    }

    // If we make it here, we have exhausted all packages, so it is time 
    // to report an error and drop the connection
    OnError(IXP_E_SICILY_LOGON_FAILED);
    hr = CommandQUIT();
    if (FAILED(hr))        
        DropConnection();
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrSendSicilyString
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrSendSicilyString(LPSTR pszData)
{
    // Locals
    LPSTR           pszLine=NULL;
    HRESULT         hr=S_OK;

    // Check Param
    Assert(pszData);

    // Allocate a line
    pszLine = PszAllocA(lstrlen(pszData) + 5);
    if (NULL == pszLine)
    {
        hr = TrapError(E_OUTOFMEMORY);
        return hr;
    }

    // Make Line
    wsprintf(pszLine, "%s\r\n", pszData);

    // Send the lin
    hr = HrSendLine(pszLine);
    SafeMemFree(pszLine);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandAUTH
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandAUTH(LPSTR pszAuthType)
{
    // check params
    if (NULL == pszAuthType)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)POP3_AUTH_STR, pszAuthType, !m_fConnectAuth);
    if (SUCCEEDED(hr))
        m_command = POP3_AUTH;

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCancelAuthInProg
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCancelAuthInProg()
{
    // Locals
    HRESULT         hr;

    // Send *, quit and die if it fails
    hr = HrSendCommand((LPSTR)POP3_AUTH_CANCEL_STR, NULL, FALSE);
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }
    else
    {
        // New state
        m_command = POP3_AUTH;
        m_rInfo.rAuth.authstate = AUTH_CANCELED;
    }
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandUSER
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandUSER(LPSTR pszUserName)
{
    // check params
    if (NULL == pszUserName)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)POP3_USER_STR, pszUserName);
    if (SUCCEEDED(hr))
        m_command = POP3_USER;

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandPASS
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandPASS(LPSTR pszPassword)
{
    // check params
    if (NULL == pszPassword)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)POP3_PASS_STR, pszPassword);
    if (SUCCEEDED(hr))
        m_command = POP3_PASS;

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandSTAT
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandSTAT(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)POP3_STAT_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_STAT;
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::DoQuit
// ------------------------------------------------------------------------------------
void CPOP3Transport::DoQuit(void)
{
    CommandQUIT();
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandQUIT
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandQUIT(void)
{
    // Send Command
    OnStatus(IXP_DISCONNECTING);
    HRESULT hr = HrSendCommand((LPSTR)POP3_QUIT_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_QUIT;
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandRSET
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandRSET(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)POP3_RSET_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_RSET;
    return hr;
}


// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandNOOP
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandNOOP(void)
{
    // Locals
    HRESULT           hr = S_OK;
    SYSTEMTIME        stNow;
    FILETIME          ftNow;
    static FILETIME   ftNext = { 0, 0 };
    LARGE_INTEGER     liNext;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Checks for need for NOOP
    GetSystemTime (&stNow);
    SystemTimeToFileTime (&stNow, &ftNow);
    if (CompareFileTime (&ftNow, &ftNext) < 0)
        goto exit;

    // Sets the next NOOP time (+60 seconds)
    liNext.HighPart = ftNow.dwHighDateTime;
    liNext.LowPart  = ftNow.dwLowDateTime;
    liNext.QuadPart += 600000000i64;
    ftNext.dwHighDateTime = liNext.HighPart;
    ftNext.dwLowDateTime  = liNext.LowPart;

    // Send Command
    hr = HrSendCommand((LPSTR)POP3_NOOP_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_NOOP;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandLIST
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandLIST(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_LIST, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandTOP
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandTOP (POP3CMDTYPE cmdtype, DWORD dwPopId, DWORD cPreviewLines)
{
    // Issue complex command
    return HrComplexCommand(POP3_TOP, cmdtype, dwPopId, cPreviewLines);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandUIDL
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandUIDL(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_UIDL, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandDELE
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandDELE(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_DELE, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandRETR
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandRETR(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_RETR, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::MarkItem
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::MarkItem(POP3MARKTYPE marktype, DWORD dwPopId, boolean fMarked)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No stat yet...
    if (FALSE == m_rInfo.fStatDone)
    {
        hr = TrapError(IXP_E_POP3_NEED_STAT);
        goto exit;
    }

    // No Messages...
    if (0 == m_rInfo.cMarked || NULL == m_rInfo.prgMarked)
    {
        hr = TrapError(IXP_E_POP3_NO_MESSAGES);
        goto exit;
    }

    // Bad PopId
    if (0 == dwPopId || dwPopId > m_rInfo.cMarked)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Message Index
    i = dwPopId - 1;

    // Handle Mark Type
    switch(marktype)
    {
    // Mark for Top
    case POP3_MARK_FOR_TOP:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_TOP);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_TOP);   
        break;

    // Mark for Retrieval
    case POP3_MARK_FOR_RETR:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_RETR);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_RETR);   
        break;

    // Mark for Delete
    case POP3_MARK_FOR_DELE:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_DELE);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_DELE);   
        break;

    // Mark for UIDL
    case POP3_MARK_FOR_UIDL:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_UIDL);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_UIDL);   
        break;

    // Mark for List
    case POP3_MARK_FOR_LIST:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_LIST);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_LIST);   
        break;

    // E_INVALIDARG
    default:
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrComplexCommand
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrComplexCommand(POP3COMMAND command, POP3CMDTYPE cmdtype, DWORD dwPopId, ULONG cPreviewLines)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cMarked;
    BOOL            fDone;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // go Busy
    CHECKHR(hr = HrEnterBusy());

    // Save top preview lines
    m_rInfo.cPreviewLines = cPreviewLines;

    // Save command type
    m_rInfo.cmdtype = cmdtype;

    // Locals
    switch(cmdtype)
    {
    // Single command
    case POP3CMD_GET_POPID:

        // Bad PopId
        if (0 == dwPopId)
        {
            hr = TrapError(IXP_E_POP3_POPID_OUT_OF_RANGE);
            goto exit;
        }

        // Have we done a stat command
        if (m_rInfo.fStatDone && dwPopId > m_rInfo.cMarked)
        {
            hr = TrapError(IXP_E_POP3_POPID_OUT_OF_RANGE);
            goto exit;
        }

        // Save as Current
        m_rInfo.dwPopIdCurrent = dwPopId;

        // Do the command
        CHECKHR(hr = HrCommandGetPopId(command, dwPopId));

        // Done
        break;

    // Get marked items
    case POP3CMD_GET_MARKED:

        // No stat yet...
        if (FALSE == m_rInfo.fStatDone)
        {
            hr = TrapError(IXP_E_POP3_NEED_STAT);
            goto exit;
        }

        // No Messages...
        if (0 == m_rInfo.cMarked || NULL == m_rInfo.prgMarked)
        {
            hr = TrapError(IXP_E_POP3_NO_MESSAGES);
            goto exit;
        }

        // Are there any messages mared for this command...
        cMarked = CountMarked(command);
        if (0 == cMarked)
        {
            hr = TrapError(IXP_E_POP3_NO_MARKED_MESSAGES);
            goto exit;
        }

        // Init Marked State
        m_rInfo.dwPopIdCurrent = 0;

        // Do next marked...
        CHECKHR(hr = HrCommandGetNext(command, &fDone));
        IxpAssert(fDone == FALSE);

        // Done
        break;

    // Multiple commands or a list operation
    case POP3CMD_GET_ALL:

        // Do the command
        CHECKHR(hr = HrCommandGetAll(command));

        // done
        break;

    // E_INVALIDARG
    default:
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Failure
    if (FAILED(hr))
        LeaveBusy();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCommandGetPopId
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCommandGetPopId(POP3COMMAND command, DWORD dwPopId)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szPopId[30];

    // Handle command type
    IxpAssert(dwPopId == m_rInfo.dwPopIdCurrent);
    switch(command)
    {
    case POP3_DELE:
        wsprintf(szPopId, "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_DELE_STR, szPopId, FALSE));
        m_command = POP3_DELE;
        break;

    case POP3_RETR:
        ZeroMemory(&m_rInfo.rFetch, sizeof(FETCHINFO));
        wsprintf(szPopId, "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_RETR_STR, szPopId, FALSE));
        m_command = POP3_RETR;
        break;

    case POP3_TOP:
        ZeroMemory(&m_rInfo.rFetch, sizeof(FETCHINFO));
        wsprintf(szPopId, "%d %d", dwPopId, m_rInfo.cPreviewLines);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_TOP_STR, szPopId, FALSE));
        m_command = POP3_TOP;
        break;

    case POP3_LIST:
        m_rInfo.cList = 0;
        wsprintf(szPopId, "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_LIST_STR, szPopId, FALSE));
        m_command = POP3_LIST;
        break;

    case POP3_UIDL:
        m_rInfo.cList = 0;
        wsprintf(szPopId, "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_UIDL_STR, szPopId, FALSE));
        m_command = POP3_UIDL;
        break;

    default:
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::DwGetCommandMarkedFlag
// ------------------------------------------------------------------------------------
DWORD CPOP3Transport::DwGetCommandMarkedFlag(POP3COMMAND command)
{
    DWORD dw;

    switch(command)
    {
    case POP3_LIST:
        dw = POP3_MARK_FOR_LIST;
        break;

    case POP3_DELE:
        dw = POP3_MARK_FOR_DELE;
        break;

    case POP3_RETR:
        dw = POP3_MARK_FOR_RETR;
        break;

    case POP3_TOP:
        dw = POP3_MARK_FOR_TOP;
        break;

    case POP3_UIDL:
        dw = POP3_MARK_FOR_UIDL;
        break;

    default:
        IxpAssert(FALSE);
        dw = 0;
        break;
    }

    return dw;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CountMarked
// ------------------------------------------------------------------------------------
ULONG CPOP3Transport::CountMarked(POP3COMMAND command)
{
    // Locals
    DWORD       dw = 0;
    ULONG       c=0,
                i;

    // Check some stuff
    IxpAssert(m_rInfo.cMarked && m_rInfo.prgMarked);

    // Handle Command type
    dw = DwGetCommandMarkedFlag(command);
    if (0 == dw)
        return 0;

    // Count
    for (i=0; i<m_rInfo.cMarked; i++)
        if (dw & m_rInfo.prgMarked[i])
            c++;

    // Done
    return c;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCommandGetNext
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCommandGetNext(POP3COMMAND command, BOOL *pfDone)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szPopId[30];
    DWORD       dw;
    ULONG       i;

    // check params
    IxpAssert(pfDone && m_rInfo.dwPopIdCurrent <= m_rInfo.cMarked);

    // Init - Assume were done
    *pfDone = TRUE;

    // Doing all
    if (POP3CMD_GET_ALL == m_rInfo.cmdtype)
    {
        // Done
        IxpAssert(m_rInfo.fStatDone == TRUE);
        if (m_rInfo.dwPopIdCurrent == m_rInfo.cMarked)
            goto exit;

        // Next Message..
        m_rInfo.dwPopIdCurrent++;
        *pfDone = FALSE;
        CHECKHR(hr = HrCommandGetPopId(command, m_rInfo.dwPopIdCurrent));
    }

    // Doing Marked
    else
    {
        // Check Parms
        IxpAssert(POP3CMD_GET_MARKED == m_rInfo.cmdtype);

        // Get marked flag
        dw = DwGetCommandMarkedFlag(command);
        if (0 == dw)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Step Over Last Marked Item
        m_rInfo.dwPopIdCurrent++;

        // Start comparing at iCurrent
        for (i=m_rInfo.dwPopIdCurrent-1; i<m_rInfo.cMarked; i++)
        {
            // Is this item marked...
            if (dw & m_rInfo.prgMarked[i])
            {
                // Send Command
                m_rInfo.dwPopIdCurrent = i + 1;
                *pfDone = FALSE;
                CHECKHR(hr = HrCommandGetPopId(command, m_rInfo.dwPopIdCurrent));
                break;
            }
        }
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCommandGetAll
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCommandGetAll(POP3COMMAND command)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szPopId[30];
    BOOL            fDone;

    // Init current
    m_rInfo.dwPopIdCurrent = 0;

    // POP3_LIST
    if (POP3_LIST == command)
    {
        m_rInfo.cList = 0;
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_LIST_ALL_STR, NULL, FALSE));
        m_command = POP3_LIST;
    }

    // POP3_UIDL
    else if (POP3_UIDL == command)
    {
        m_rInfo.cList = 0;
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_UIDL_ALL_STR, NULL, FALSE));
        m_command = POP3_UIDL;
    }

    // Otherwise, we better have done the stat command
    else
    {
        // No stat yet...
        if (FALSE == m_rInfo.fStatDone)
        {
            hr = TrapError(IXP_E_POP3_NEED_STAT);
            goto exit;
        }

        // No Messages...
        if (0 == m_rInfo.cMarked || NULL == m_rInfo.prgMarked)
        {
            hr = TrapError(IXP_E_POP3_NO_MESSAGES);
            goto exit;
        }

        // Next Command
        CHECKHR(hr = HrCommandGetNext(command, &fDone));
        IxpAssert(fDone == FALSE);
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseSTAT
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseSTAT(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cMessages=0,
                    cbMessages=0;
    LPSTR           pszPart1=NULL,
                    pszPart2=NULL;
    POP3RESPONSE    rResponse;

    // Read Server Response...
    hr = HrGetResponse();
    if (IXP_E_INCOMPLETE == hr)
        return;

    // Init Response
    ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

    // Parse the response
    CHECKHR(hr = HrSplitPop3Response(m_pszResponse, &pszPart1, &pszPart2));

    // Convert
    IxpAssert(pszPart1 && pszPart2);
    cMessages = StrToInt(pszPart1);
    cbMessages = StrToInt(pszPart2);

    // Are there messages
    if (FALSE == m_rInfo.fStatDone && cMessages > 0)
    {
        // Set Number of messages
        IxpAssert(m_rInfo.prgMarked == NULL);
        m_rInfo.cMarked = cMessages;

        // Allocate message array
        CHECKHR(hr = HrAlloc((LPVOID *)&m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked));

        // Zero
        ZeroMemory(m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked);
    }

    // Success
    m_rInfo.fStatDone = TRUE;

exit:
    // Cleanup
    SafeMemFree(pszPart1);
    SafeMemFree(pszPart2);

    // Build Response
    rResponse.fValidInfo = TRUE;
    rResponse.rStatInfo.cMessages = cMessages;
    rResponse.rStatInfo.cbMessages = cbMessages;
    DispatchResponse(hr, TRUE, &rResponse);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrSplitPop3Response
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrSplitPop3Response(LPSTR pszLine, LPSTR *ppszPart1, LPSTR *ppszPart2)
{
    // Locals
    LPSTR           psz,
                    pszStart;
    CHAR            ch;
    HRESULT         hr=IXP_E_POP3_PARSE_FAILURE;

    // No Response...
    IxpAssert(pszLine && pszLine[0] != '-' && ppszPart1 && ppszPart2);
    if (NULL == pszLine)
        goto exit;

    // Parse: '+OK' 432 1234
    psz = PszSkipWhiteA(pszLine);
    if ('\0' == *psz)
        goto exit;

    // Parse response token
    pszStart = psz;
    if ('+' == *pszLine)
    {
        // Parse: '+OK' 432 1234
        psz = PszScanToWhiteA(psz);
        if ('\0' == *psz)
            goto exit;

#ifdef DEBUG
        IxpAssert(' ' == *psz);
        *psz = '\0';
        IxpAssert(lstrcmpi(pszStart, "+OK") == 0);
        *psz = ' ';
#endif

        // Parse: +OK '432' 1234
        psz = PszSkipWhiteA(psz);
        if ('\0' == *psz)
            goto exit;
    }

    // Parse: +OK '432' 1234
    pszStart = psz;
    psz = PszScanToWhiteA(psz);
    if ('\0' == *psz)
        goto exit;

    // Get Message Count
    *psz = '\0';
    *ppszPart1 = PszDupA(pszStart);
    *psz = ' ';

    // Parse: +OK 432 '1234'
    psz = PszSkipWhiteA(psz);
    if ('\0' == *psz)
    {
        // Raid 28435 - Outlook needs INETCOMM to accept empty UIDL responses
        *ppszPart2 = PszDupA(c_szEmpty);
        hr = S_OK;
        goto exit;
    }

    // Parse: +OK 432 1234
    pszStart = psz;
    psz = PszScanToWhiteA(psz);

    // Get Message Count
    ch = *psz;
    *psz = '\0';
    *ppszPart2 = PszDupA(pszStart);
    *psz = ch;

    // Success
    hr = S_OK;

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseGenericList
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseGenericList(void)
{
    // Locals
    HRESULT         hr;
    INT             cbLine;
    BOOL            fDone,
                    fComplete;
    LPSTR           pszPart1=NULL,
                    pszPart2=NULL;
    POP3RESPONSE    rResponse;

    // Same response as single LIST x command, but then get next
    if (POP3CMD_GET_MARKED == m_rInfo.cmdtype || POP3CMD_GET_POPID == m_rInfo.cmdtype)
    {
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Otherwise, if failure...
        else if (FAILED(hr))
        {
            DispatchResponse(hr, TRUE);
            goto exit;
        }

        // Get the two parts from the line
        hr = HrSplitPop3Response(m_pszResponse, &pszPart1, &pszPart2);
        if (FAILED(hr))
        {
            DispatchResponse(hr, TRUE);
            goto exit;
        }

        // Init Response
        ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

        // POP3_LIST
        if (POP3_LIST == m_command)
        {
            rResponse.fValidInfo = TRUE;
            rResponse.rListInfo.dwPopId = StrToInt(pszPart1);
            rResponse.rListInfo.cbSize = StrToInt(pszPart2);
            IxpAssert(rResponse.rListInfo.dwPopId == m_rInfo.dwPopIdCurrent);
        }

        // POP3_UIDL
        else
        {
            rResponse.fValidInfo = TRUE;
            rResponse.rUidlInfo.dwPopId = StrToInt(pszPart1);
            rResponse.rUidlInfo.pszUidl = pszPart2;
            IxpAssert(rResponse.rUidlInfo.dwPopId == m_rInfo.dwPopIdCurrent);
        }

        // Do Next
        if (POP3CMD_GET_MARKED == m_rInfo.cmdtype)
        {
            // Give the response
            DispatchResponse(S_OK, FALSE, &rResponse);

            // Do the next marked list item
            hr = HrCommandGetNext(m_command, &fDone);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // Done Response
            if (fDone)
                DispatchResponse(S_OK, TRUE);
        }

        // Dispatch Done or single item response
        else
            DispatchResponse(S_OK, TRUE, &rResponse);
    }

    // Full LIST response
    else if (POP3CMD_GET_ALL == m_rInfo.cmdtype)
    {
        // First call...
        if (m_rInfo.dwPopIdCurrent == 0)
        {
            // Read Server Response...
            hr = HrGetResponse();
            if (IXP_E_INCOMPLETE == hr)
                goto exit;

            // Otherwise, if failure...
            else if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // Current
            m_rInfo.dwPopIdCurrent = 1;
        }

        // Clear Response
        SafeMemFree(m_pszResponse);
        m_uiResponse = 0;
        m_hrResponse = S_OK;

        // Read a blob of lines
        while(1)
        {
            // Read Line
            hr = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // If not complete
            if (!fComplete)
                goto exit;

            // Add Detail
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, S_OK, POP3THISIXP);

            // If its a dot, were done
            if (*m_pszResponse == '.')
            {
                // If we haven't done a stat yet, we can use these totals...
                IxpAssert(m_rInfo.fStatDone ? m_rInfo.cList == m_rInfo.cMarked : TRUE);
                if (FALSE == m_rInfo.fStatDone && m_rInfo.cList > 0)
                {
                    // Have I build my internal array of messages yet...
                    IxpAssert(m_rInfo.prgMarked == NULL);
                    m_rInfo.cMarked = m_rInfo.cList;

                    // Allocate message array
                    CHECKHR(hr = HrAlloc((LPVOID *)&m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked));

                    // Zero
                    ZeroMemory(m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked);
                }

                // Were Done
                DispatchResponse(S_OK, TRUE);

                // Stat Done
                m_rInfo.fStatDone = TRUE;

                // Done
                break;
            }

            // Get the two parts from the line
            hr = HrSplitPop3Response(m_pszResponse, &pszPart1, &pszPart2);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // Init Response
            ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

            // POP3_LIST
            if (POP3_LIST == m_command)
            {
                rResponse.fValidInfo = TRUE;
                rResponse.rListInfo.dwPopId = StrToInt(pszPart1);
                rResponse.rListInfo.cbSize = StrToInt(pszPart2);
            }

            // POP3_UIDL
            else
            {
                rResponse.fValidInfo = TRUE;
                rResponse.rUidlInfo.dwPopId = StrToInt(pszPart1);
                rResponse.rUidlInfo.pszUidl = pszPart2;
                IxpAssert(rResponse.rUidlInfo.dwPopId == m_rInfo.dwPopIdCurrent);
            }

            // Count the number of messages
            m_rInfo.cList++;

            // Dispatch the response
            DispatchResponse(S_OK, FALSE, &rResponse);
            m_rInfo.dwPopIdCurrent++;

            // Cleanup
            SafeMemFree(pszPart1);
            SafeMemFree(pszPart2);

            // Clear Response
            SafeMemFree(m_pszResponse);
            m_uiResponse = 0;
            m_hrResponse = S_OK;
        }
    }

    // Otherwise failure...
    else
    {
        IxpAssert(FALSE);
        goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszPart1);
    SafeMemFree(pszPart2);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::FEndRetrRecvHeader
// ------------------------------------------------------------------------------------
BOOL CPOP3Transport::FEndRetrRecvHeader(LPSTR pszLines, ULONG cbRead)
{
    // If we see CRLFCRLF
    if (StrStr(pszLines, "\r\n\r\n"))
        return TRUE;

    // Otherwise, did last block end with a CRLF and this block begins with a crlf
    else if (cbRead >= 2                  &&
             m_rInfo.rFetch.fLastLineCRLF &&
             pszLines[0] == '\r'          &&
             pszLines[1] == '\n')
        return TRUE;

    // Header is not done
    return FALSE;
}


// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseGenericRetrieve
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseGenericRetrieve(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszLines=NULL;
    INT             cbRead,
                    cLines;
    ULONG           cbSubtract;
    BOOL            fDone,
                    fMessageDone;
    POP3RESPONSE    rResponse;

    // First call...
    if (FALSE == m_rInfo.rFetch.fGotResponse)
    {
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Otherwise, if failure...
        else if (FAILED(hr))
        {
            FillRetrieveResponse(&rResponse, NULL, 0, &fMessageDone);
            DispatchResponse(hr, TRUE, &rResponse);
            goto exit;
        }

        // Current
        m_rInfo.rFetch.fGotResponse = TRUE;
    }

    // While there are lines to read...
    hr = m_pSocket->ReadLines(&pszLines, &cbRead, &cLines);

    // Incomplete data available...
    if (IXP_E_INCOMPLETE == hr)
        goto exit;

    // Or if we failed...
    else if (FAILED(hr))
    {
        FillRetrieveResponse(&rResponse, NULL, 0, &fMessageDone);
        DispatchResponse(hr, TRUE, &rResponse);
        goto exit;
    }

    // Are we receiving the header...
    if (FALSE == m_rInfo.rFetch.fHeader)
    {
        // Test for end of header found
        if (FEndRetrRecvHeader(pszLines, cbRead))
            m_rInfo.rFetch.fHeader = TRUE;

        // $$BUG$$ Our good buddies on Exchange produced the following message:
        // 
        // To: XXXXXXXXXXXXXXXXXXX
        // From: XXXXXXXXXXXXXXXXX
        // Subject: XXXXXXXXXXXXXX
        // .
        //
        // As you can see there is not CRLFCRLF following the last header line which is very
        // illegal. This message caused us to hange because we never saw the end of the header.
        // So this is why I also test for the end of the body...
        else if (FEndRetrRecvBody(pszLines, cbRead, &cbSubtract))
        {
            cbRead -= cbSubtract;
            m_rInfo.rFetch.fHeader = TRUE;
            m_rInfo.rFetch.fBody = TRUE;
        }

        // Otherwise, did this block end with a crlf
        else if (cbRead >= 2 && pszLines[cbRead - 1] == '\n' && pszLines[cbRead - 2] == '\r')
            m_rInfo.rFetch.fLastLineCRLF = TRUE;
        else
            m_rInfo.rFetch.fLastLineCRLF = FALSE;
    }

    // Also check to see if body was received in same set of lines
    if (TRUE == m_rInfo.rFetch.fHeader)
    {
        // Test for end of header found
        if (FEndRetrRecvBody(pszLines, cbRead, &cbSubtract))
        {
            cbRead -= cbSubtract;
            m_rInfo.rFetch.fBody = TRUE;
        }

        // Otherwise, check for line ending with crlf
        else if (cbRead >= 2 && pszLines[cbRead - 1] == '\n' && pszLines[cbRead - 2] == '\r')
            m_rInfo.rFetch.fLastLineCRLF = TRUE;
        else
            m_rInfo.rFetch.fLastLineCRLF = FALSE;
    }

    // Count bytes downloaded on this fetch
    m_rInfo.rFetch.cbSoFar += cbRead;

    // UnStuff
    UnStuffDotsFromLines(pszLines, &cbRead);

    // Fill the response
    FillRetrieveResponse(&rResponse, pszLines, cbRead, &fMessageDone);

    // Dispatch This Resposne...
    if (POP3CMD_GET_POPID == m_rInfo.cmdtype)
        DispatchResponse(S_OK, fMessageDone, &rResponse);

    // Otherwise
    else
    {
        // Check command type
        IxpAssert(POP3CMD_GET_MARKED == m_rInfo.cmdtype || POP3CMD_GET_ALL == m_rInfo.cmdtype);

        // Dispatch current response
        DispatchResponse(S_OK, FALSE, &rResponse);

        // If done with current message...
        if (fMessageDone)
        {
            // Get Next
            hr = HrCommandGetNext(m_command, &fDone);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // If Done
            if (fDone)
                DispatchResponse(S_OK, TRUE);
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszLines);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::FillRetrieveResponse
// ------------------------------------------------------------------------------------
void CPOP3Transport::FillRetrieveResponse(LPPOP3RESPONSE pResponse, LPSTR pszLines, ULONG cbRead,
    BOOL *pfMessageDone)
{
    // Clear Response
    ZeroMemory(pResponse, sizeof(POP3RESPONSE));

    // POP3_TOP
    if (POP3_TOP == m_command)
    {
        // Build Response
        pResponse->fValidInfo = TRUE;
        pResponse->rTopInfo.dwPopId = m_rInfo.dwPopIdCurrent;
        pResponse->rTopInfo.cPreviewLines = m_rInfo.cPreviewLines;
        pResponse->rTopInfo.cbSoFar = m_rInfo.rFetch.cbSoFar;
        pResponse->rTopInfo.pszLines = pszLines;
        pResponse->rTopInfo.cbLines = cbRead;
        pResponse->rTopInfo.fHeader = m_rInfo.rFetch.fHeader;
        pResponse->rTopInfo.fBody = m_rInfo.rFetch.fBody;
        *pfMessageDone = (m_rInfo.rFetch.fHeader && m_rInfo.rFetch.fBody);
    }

    // POP3_RETR
    else
    {
        IxpAssert(POP3_RETR == m_command);
        pResponse->fValidInfo = TRUE;
        pResponse->rRetrInfo.fHeader = m_rInfo.rFetch.fHeader;
        pResponse->rRetrInfo.fBody = m_rInfo.rFetch.fBody;
        pResponse->rRetrInfo.dwPopId = m_rInfo.dwPopIdCurrent;
        pResponse->rRetrInfo.cbSoFar = m_rInfo.rFetch.cbSoFar;
        pResponse->rRetrInfo.pszLines = pszLines;
        pResponse->rRetrInfo.cbLines = cbRead;
        *pfMessageDone = (m_rInfo.rFetch.fHeader && m_rInfo.rFetch.fBody);
    }
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseDELE
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseDELE(void)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fDone;
    POP3RESPONSE    rResponse;

    // Read Server Response...
    hr = HrGetResponse();
    if (IXP_E_INCOMPLETE == hr)
        goto exit;

    // Otherwise, if failure...
    else if (FAILED(hr))
    {
        DispatchResponse(hr, TRUE);
        goto exit;
    }

    // Clear Response
    ZeroMemory(&rResponse, sizeof(POP3RESPONSE));
    rResponse.fValidInfo = TRUE;
    rResponse.dwPopId = m_rInfo.dwPopIdCurrent;

    // Dispatch This Resposne...
    if (POP3CMD_GET_POPID == m_rInfo.cmdtype)
        DispatchResponse(S_OK, TRUE, &rResponse);

    // Otherwise
    else
    {
        // Check command type
        IxpAssert(POP3CMD_GET_MARKED == m_rInfo.cmdtype || POP3CMD_GET_ALL == m_rInfo.cmdtype);

        // Dispatch current response
        DispatchResponse(S_OK, FALSE, &rResponse);

        // Get Next
        hr = HrCommandGetNext(m_command, &fDone);
        if (FAILED(hr))
        {
            DispatchResponse(hr, TRUE);
            goto exit;
        }

        // If Done
        if (fDone)
            DispatchResponse(S_OK, TRUE);
    }

exit:
    // Done
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixphttpm.cpp ===
// --------------------------------------------------------------------------------
// Ixphttpm.cpp
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------

#include "pch.hxx"
#include "dllmain.h"
#include "ixphttpm.h"
#include "wininet.h"
#include "ocidl.h"
#include "Vstream.h"
#include "shlwapi.h"
#include "htmlstr.h"
#include "strconst.h"
#include "propfind.h"
#include "davparse.h"
#include "davstrs.h"
#include <ntverp.h>
#include <process.h>
#include "oleutil.h"
#include "ixputil.h"
#include <demand.h>

typedef struct tagHTTPERROR
{
    DWORD   dwHttpError;
    HRESULT ixpResult;
} HTTPERROR, *LPHTTPERROR;

static const HTTPERROR c_rgHttpErrorMap[] =
{
    { HTTP_STATUS_USE_PROXY, IXP_E_HTTP_USE_PROXY },
    { HTTP_STATUS_BAD_REQUEST, IXP_E_HTTP_BAD_REQUEST  },
    { HTTP_STATUS_DENIED, IXP_E_HTTP_UNAUTHORIZED },
    { HTTP_STATUS_FORBIDDEN, IXP_E_HTTP_FORBIDDEN },
    { HTTP_STATUS_NOT_FOUND, IXP_E_HTTP_NOT_FOUND },
    { HTTP_STATUS_BAD_METHOD, IXP_E_HTTP_METHOD_NOT_ALLOW },
    { HTTP_STATUS_NONE_ACCEPTABLE, IXP_E_HTTP_NOT_ACCEPTABLE },
    { HTTP_STATUS_PROXY_AUTH_REQ, IXP_E_HTTP_PROXY_AUTH_REQ },
    { HTTP_STATUS_REQUEST_TIMEOUT, IXP_E_HTTP_REQUEST_TIMEOUT },
    { HTTP_STATUS_CONFLICT, IXP_E_HTTP_CONFLICT },
    { HTTP_STATUS_GONE, IXP_E_HTTP_GONE },
    { HTTP_STATUS_LENGTH_REQUIRED, IXP_E_HTTP_LENGTH_REQUIRED },
    { HTTP_STATUS_PRECOND_FAILED, IXP_E_HTTP_PRECOND_FAILED },
    { HTTP_STATUS_SERVER_ERROR, IXP_E_HTTP_INTERNAL_ERROR },
    { HTTP_STATUS_NOT_SUPPORTED, IXP_E_HTTP_NOT_IMPLEMENTED },
    { HTTP_STATUS_BAD_GATEWAY, IXP_E_HTTP_BAD_GATEWAY },
    { HTTP_STATUS_SERVICE_UNAVAIL, IXP_E_HTTP_SERVICE_UNAVAIL },
    { HTTP_STATUS_GATEWAY_TIMEOUT, IXP_E_HTTP_GATEWAY_TIMEOUT },
    { HTTP_STATUS_VERSION_NOT_SUP, IXP_E_HTTP_VERS_NOT_SUP },
    { 425, IXP_E_HTTP_INSUFFICIENT_STORAGE },   // obsolete out of storage error
    { 507, IXP_E_HTTP_INSUFFICIENT_STORAGE },   // preferred out of storage error
    { ERROR_INTERNET_OUT_OF_HANDLES, E_OUTOFMEMORY },
    { ERROR_INTERNET_TIMEOUT, IXP_E_TIMEOUT },
    { ERROR_INTERNET_NAME_NOT_RESOLVED, IXP_E_CANT_FIND_HOST },
    { ERROR_INTERNET_CANNOT_CONNECT, IXP_E_FAILED_TO_CONNECT },
    { HTTP_STATUS_NOT_MODIFIED, IXP_E_HTTP_NOT_MODIFIED},
};

#define FAIL_ABORT \
    if (WasAborted()) \
    { \
        hr = TrapError(IXP_E_USER_CANCEL); \
        goto exit; \
    } \
    else

#define FAIL_EXIT_STREAM_WRITE(stream, psz) \
    if (FAILED(hr = stream.Write(psz, lstrlen(psz), NULL))) \
        goto exit; \
    else

#define FAIL_EXIT(hr) \
    if (FAILED(hr)) \
        goto exit; \
    else

#define FAIL_CREATEWND \
    if (!m_hwnd && !CreateWnd()) \
    { \
        hr = TrapError(E_OUTOFMEMORY); \
        goto exit;  \
    } \
    else
    
// these arrays describe element stack states, and are used to asses
// the current state of the element stack
static const HMELE c_rgPropFindPropStatStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_DAV_PROPSTAT    
};

static const HMELE c_rgPropFindPropValueStack[] = 
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_DAV_PROPSTAT,
    HMELE_DAV_PROP,
    HMELE_UNKNOWN   // wildcard
};

static const HMELE c_rgPropFindResponseStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE
};

static const HMELE c_rgMultiStatusResponseChildStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_UNKNOWN
};

static const HMELE c_rgPropFindStatusStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_DAV_PROPSTAT,
    HMELE_DAV_STATUS
}; 
// GET command
static const PFNHTTPMAILOPFUNC c_rgpfGet[] = 
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessGetResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// DELETE command
static const PFNHTTPMAILOPFUNC c_rgpfDelete[] = 
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::FinalizeRequest
};

// PROPPATCH command
static const PFNHTTPMAILOPFUNC c_rgpfnPropPatch[] =
{
    &CHTTPMailTransport::GeneratePropPatchXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::FinalizeRequest
};

// MKCOL command
static const PFNHTTPMAILOPFUNC c_rgpfnMkCol[] =
{
    &CHTTPMailTransport::OpenRequest,
	&CHTTPMailTransport::AddCharsetLine,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessCreatedResponse,
    &CHTTPMailTransport::ProcessLocationResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// COPY command
static const PFNHTTPMAILOPFUNC c_rgpfnCopy[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDestinationHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessCreatedResponse,
    &CHTTPMailTransport::ProcessLocationResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// MOVE command
static const PFNHTTPMAILOPFUNC c_rgpfnMove[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDestinationHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessCreatedResponse,
    &CHTTPMailTransport::ProcessLocationResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// BMOVE command (data applies to bcopy and bmove)

#define BCOPYMOVE_MAXRESPONSES  10

XP_BEGIN_SCHEMA(HTTPMAILBCOPYMOVE)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_STRA, HTTPMAILBCOPYMOVE, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_LOCATION, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_STRA, HTTPMAILBCOPYMOVE, pszLocation)
    XP_SCHEMA_COL(HMELE_DAV_STATUS, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_IXPHRESULT, HTTPMAILBCOPYMOVE, hrResult)
XP_END_SCHEMA

static const PFNHTTPMAILOPFUNC c_rgpfnBMove[] =
{
    &CHTTPMailTransport::InitBCopyMove,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDestinationHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

static const XMLPARSEFUNCS c_rgpfnBCopyMoveParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::BCopyMove_HandleText,
    &CHTTPMailTransport::BCopyMove_EndChildren
};

// MemberInfo Data. There are four schemas associated with this command.
// The first three are used to build up the propfind request, and are
// not used to parse responses. The fourth is the combined schema that
// is used for parsing.
//
// THE FOURTH SCHEMA MUST BE KEPT IN SYNC WITH THE FIRST THREE TO
// GUARANTEE THAT RESPONSES WILL BE PARSED CORRECTLY.

#define MEMBERINFO_MAXRESPONSES    10

// common property schema - used only for building the request
XP_BEGIN_SCHEMA(HTTPMEMBERINFO_COMMON)
    // common properties
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPMEMBERINFO, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ISFOLDER, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fIsFolder)
XP_END_SCHEMA

// folder property schema - used only for building the request
XP_BEGIN_SCHEMA(HTTPMEMBERINFO_FOLDER)
    XP_SCHEMA_COL(HMELE_DAV_DISPLAYNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDisplayName)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    
    XP_SCHEMA_COL(HMELE_DAV_HASSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasSubs)
    XP_SCHEMA_COL(HMELE_DAV_NOSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fNoSubs)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_UNREADCOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwUnreadCount)
    XP_SCHEMA_COL(HMELE_DAV_VISIBLECOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwVisibleCount)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    
XP_END_SCHEMA

// message property schema - used only for building the request
XP_BEGIN_SCHEMA(HTTPMEMBERINFO_MESSAGE)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_READ, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fRead)
    XP_SCHEMA_COL(HMELE_MAIL_HASATTACHMENT, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasAttachment)
    XP_SCHEMA_COL(HMELE_MAIL_TO, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszTo)
    XP_SCHEMA_COL(HMELE_MAIL_FROM, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszFrom)
    XP_SCHEMA_COL(HMELE_MAIL_SUBJECT, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszSubject)
    XP_SCHEMA_COL(HMELE_MAIL_DATE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDate)
    XP_SCHEMA_COL(HMELE_DAV_GETCONTENTLENGTH, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwContentLength)
XP_END_SCHEMA

// combined schema - used for parsing responses
XP_BEGIN_SCHEMA(HTTPMEMBERINFO)
    // common properties
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPMEMBERINFO, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ISFOLDER, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fIsFolder)

    // folder properties    
    XP_SCHEMA_COL(HMELE_DAV_DISPLAYNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDisplayName)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    
    XP_SCHEMA_COL(HMELE_DAV_HASSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasSubs)
    XP_SCHEMA_COL(HMELE_DAV_NOSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fNoSubs)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_UNREADCOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwUnreadCount)
    XP_SCHEMA_COL(HMELE_DAV_VISIBLECOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwVisibleCount)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    

    // message properties
    XP_SCHEMA_COL(HMELE_HTTPMAIL_READ, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fRead)
    XP_SCHEMA_COL(HMELE_MAIL_HASATTACHMENT, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasAttachment)
    XP_SCHEMA_COL(HMELE_MAIL_TO, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszTo)
    XP_SCHEMA_COL(HMELE_MAIL_FROM, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszFrom)
    XP_SCHEMA_COL(HMELE_MAIL_SUBJECT, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszSubject)
    XP_SCHEMA_COL(HMELE_MAIL_DATE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDate)
    XP_SCHEMA_COL(HMELE_DAV_GETCONTENTLENGTH, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwContentLength)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnMemberInfoParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::MemberInfo_HandleText,
    &CHTTPMailTransport::MemberInfo_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnMemberInfo[] =
{
    &CHTTPMailTransport::InitMemberInfo,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::RequireMultiStatus,
    &CHTTPMailTransport::FinalizeRequest
};
    
// Operations which share MemberError-based responses (MarkRead, BDELETE)


#define MEMBERERROR_MAXRESPONSES    10

XP_BEGIN_SCHEMA(HTTPMEMBERERROR)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPMEMBERERROR, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_STATUS, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_IXPHRESULT, HTTPMEMBERERROR, hrResult)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnMemberErrorParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::MemberError_HandleText,
    &CHTTPMailTransport::MemberError_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnMarkRead[] =
{
    &CHTTPMailTransport::InitMemberError,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// SendMessage

static const PFNHTTPMAILOPFUNC c_rgpfnSendMessage[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddContentTypeHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendPostRequest,
    &CHTTPMailTransport::ProcessPostResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// RootProps

XP_BEGIN_SCHEMA(ROOTPROPS)
    XP_SCHEMA_COL(HMELE_HOTMAIL_ADBAR, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszAdbar)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_CONTACTS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszContacts)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_INBOX, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszInbox)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_OUTBOX, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszOutbox)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SENDMSG, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszSendMsg)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SENTITEMS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszSentItems)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_DELETEDITEMS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszDeletedItems)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_DRAFTS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszDrafts)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_MSGFOLDERROOT, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszMsgFolderRoot)
    XP_SCHEMA_COL(HMELE_HOTMAIL_MAXPOLLINGINTERVAL, XPFC_PROPFINDPROP, XPCDT_DWORD, ROOTPROPS, dwMaxPollingInterval)
    XP_SCHEMA_COL(HMELE_HOTMAIL_SIG, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszSig)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnRootPropsParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::RootProps_HandleText,
    &CHTTPMailTransport::RootProps_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnRootProps[] = 
{
    &CHTTPMailTransport::InitRootProps,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRootProps
};

static const PFNHTTPMAILOPFUNC c_rgpfnPost[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddContentTypeHeader,
	&CHTTPMailTransport::AddCharsetLine,
    &CHTTPMailTransport::SendPostRequest,
    //&CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPostResponse,
    &CHTTPMailTransport::FinalizeRequest
};

static const PFNHTTPMAILOPFUNC c_rgpfnPut[] = 
{
    &CHTTPMailTransport::OpenRequest,
	&CHTTPMailTransport::AddCharsetLine,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPostResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// ListContacts Data

#define LISTCONTACTS_MAXRESPONSES   10

XP_BEGIN_SCHEMA(HTTPCONTACTID)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPCONTACTID, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ID, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTID, pszId)    
    XP_SCHEMA_COL(HMELE_CONTACTS_GROUP, XPFC_PROPFINDPROP, XPCDT_HTTPCONTACTTYPE, HTTPCONTACTID, tyContact)
    XP_SCHEMA_COL(HMELE_HOTMAIL_MODIFIED, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTID, pszModified)
XP_END_SCHEMA

static const PFNHTTPMAILOPFUNC c_rgpfnListContacts[] = 
{
    &CHTTPMailTransport::InitListContacts,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::RequireMultiStatus,
    &CHTTPMailTransport::FinalizeRequest
};

static const XMLPARSEFUNCS c_rgpfnListContactsParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::ListContacts_HandleText,
    &CHTTPMailTransport::ListContacts_EndChildren
};

// ContactInfo Data
#define CONTACTINFO_MAXRESPONSES   10

XP_BEGIN_SCHEMA(HTTPCONTACTINFO)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPCONTACTINFO, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ID, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszId)    
    XP_SCHEMA_COL(HMELE_CONTACTS_GROUP, XPFC_PROPFINDPROP, XPCDT_HTTPCONTACTTYPE, HTTPCONTACTINFO, tyContact)
    XP_SCHEMA_COL(HMELE_HOTMAIL_MODIFIED, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszModified)
    XP_SCHEMA_COL(HMELE_CONTACTS_CN, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszDisplayName)
    XP_SCHEMA_COL(HMELE_CONTACTS_GIVENNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszGivenName)
    XP_SCHEMA_COL(HMELE_CONTACTS_SN, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszSurname)
    XP_SCHEMA_COL(HMELE_CONTACTS_NICKNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszNickname)
    XP_SCHEMA_COL(HMELE_CONTACTS_MAIL, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszEmail)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMESTREET, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeStreet)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMECITY, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeCity)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMESTATE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeState)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMEPOSTALCODE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomePostalCode)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMECOUNTRY, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeCountry)
    XP_SCHEMA_COL(HMELE_CONTACTS_O, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszCompany)
    XP_SCHEMA_COL(HMELE_CONTACTS_STREET, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkStreet)
    XP_SCHEMA_COL(HMELE_CONTACTS_L, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkCity)
    XP_SCHEMA_COL(HMELE_CONTACTS_ST, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkState)
    XP_SCHEMA_COL(HMELE_CONTACTS_POSTALCODE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkPostalCode)
    XP_SCHEMA_COL(HMELE_CONTACTS_FRIENDLYCOUNTRYNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkCountry)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMEPHONE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomePhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMEFAX, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeFax)
    XP_SCHEMA_COL(HMELE_CONTACTS_TELEPHONENUMBER, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkPhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_FACSIMILETELEPHONENUMBER, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkFax)
    XP_SCHEMA_COL(HMELE_CONTACTS_MOBILE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszMobilePhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_OTHERTELEPHONE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszOtherPhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_BDAY, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszBday)
    XP_SCHEMA_COL(HMELE_CONTACTS_PAGER, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszPager)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnContactInfoParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::ContactInfo_HandleText,
    &CHTTPMailTransport::ContactInfo_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnContactInfo[] =
{
    &CHTTPMailTransport::InitContactInfo,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// PostContact Data
static const PFNHTTPMAILOPFUNC c_rgpfnPostContact[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPostContactResponse,
    &CHTTPMailTransport::InitListContacts,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

static const XMLPARSEFUNCS c_rgpfnPostOrPatchContactParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::PostOrPatchContact_HandleText,
    &CHTTPMailTransport::PostOrPatchContact_EndChildren
};

// PatchContact data

static const PFNHTTPMAILOPFUNC c_rgpfnPatchContact[] =
{
    &CHTTPMailTransport::GeneratePropPatchXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPatchContactResponse,
    &CHTTPMailTransport::InitListContacts,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// special folders
typedef struct tagHTTPSPECIALFOLDER
{
    const WCHAR             *pwcName;
    ULONG                   ulLen;
    HTTPMAILSPECIALFOLDER   tyFolder;
} HTTPSPECIALFOLDER, *LPHTTPSPECIALFOLDER;

static const HTTPSPECIALFOLDER c_rgpfnSpecialFolder[] =
{
    { DAV_STR_LEN(InboxSpecialFolder), HTTPMAIL_SF_INBOX },
    { DAV_STR_LEN(DeletedItemsSpecialFolder), HTTPMAIL_SF_DELETEDITEMS },
    { DAV_STR_LEN(DraftsSpecialFolder), HTTPMAIL_SF_DRAFTS },
    { DAV_STR_LEN(OutboxSpecialFolder), HTTPMAIL_SF_OUTBOX },
    { DAV_STR_LEN(SentItemsSpecialFolder), HTTPMAIL_SF_SENTITEMS },
    { DAV_STR_LEN(ContactsSpecialFolder), HTTPMAIL_SF_CONTACTS },
    { DAV_STR_LEN(CalendarSpecialFolder), HTTPMAIL_SF_CALENDAR },
    { DAV_STR_LEN(MsnPromoSpecialFolder), HTTPMAIL_SF_MSNPROMO },
    { DAV_STR_LEN(BulkMailSpecialFolder), HTTPMAIL_SF_BULKMAIL },
};

#define VALIDSTACK(rg) ValidStack(rg, ARRAYSIZE(rg))

static const char s_szHTTPMailWndClass[] = "HTTPMailWndClass";

// Notification messages used to communicate between the async thread
// and the window proc
#define SPM_HTTPMAIL_STATECHANGED       (WM_USER + 1)
#define SPM_HTTPMAIL_SENDRESPONSE       (WM_USER + 2)
#define SPM_HTTPMAIL_LOGONPROMPT        (WM_USER + 3)
#define SPM_HTTPMAIL_GETPARENTWINDOW    (WM_USER + 4)

// --------------------------------------------------------------------------------
// static functions
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrCrackUrl
// --------------------------------------------------------------------------------

HRESULT HrCrackUrl(
                LPSTR pszUrl, 
                LPSTR *ppszHost, 
                LPSTR *ppszPath, 
                INTERNET_PORT *pPort)
{
    URL_COMPONENTS      uc;
    char                szHost[INTERNET_MAX_HOST_NAME_LENGTH];
    char                szPath[INTERNET_MAX_PATH_LENGTH];

    if (NULL == pszUrl)
        return E_INVALIDARG;

    if (ppszHost)
        *ppszHost = NULL;

    if (ppszPath)
        *ppszPath = NULL;

    if (pPort)
        *pPort = INTERNET_INVALID_PORT_NUMBER;

    ZeroMemory(&uc, sizeof(URL_COMPONENTS));
    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.lpszHostName = szHost;
    uc.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;
    uc.lpszUrlPath = szPath;
    uc.dwUrlPathLength = INTERNET_MAX_PATH_LENGTH;
    
    if (!InternetCrackUrl(pszUrl, NULL, 0, &uc))
        return E_INVALIDARG;

    // validate the protocol
    if (INTERNET_SCHEME_HTTP != uc.nScheme && INTERNET_SCHEME_HTTPS != uc.nScheme)
        return E_INVALIDARG;

    // copy the response data
    if (ppszHost)
    {
        *ppszHost = PszDupA(uc.lpszHostName);
        if (!*ppszHost)
            return E_OUTOFMEMORY;
    }

    if (ppszPath)
    {
        *ppszPath = PszDupA(uc.lpszUrlPath);
        if (!*ppszPath)
        {
            SafeMemFree(*ppszHost);
            return E_OUTOFMEMORY;
        }
    }

    if (pPort)
        *pPort = uc.nPort;

    return S_OK;
}

// --------------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// HttpErrorToIxpResult
// --------------------------------------------------------------------------------
HRESULT HttpErrorToIxpResult(DWORD dwHttpError)
{
    for (DWORD dw = 0; dw < ARRAYSIZE(c_rgHttpErrorMap); dw++)
    {
        if (c_rgHttpErrorMap[dw].dwHttpError == dwHttpError)
            return c_rgHttpErrorMap[dw].ixpResult;
    }

    return E_FAIL;
}

// --------------------------------------------------------------------------------
// HrParseHTTPStatus
// --------------------------------------------------------------------------------
HRESULT HrParseHTTPStatus(LPSTR pszStatusStr, DWORD *pdwStatus)
{
    LPSTR   psz;
    LPSTR   pszEnd;
    char    chSaved;

    if (!pszStatusStr || !pdwStatus)
        return E_INVALIDARG;

    *pdwStatus = 0;

    // status is of the form "HTTP/1.1 200 OK"
    psz = PszSkipWhiteA(pszStatusStr);
    if ('\0' == *psz)
        return E_INVALIDARG;

    psz = PszScanToWhiteA(psz);
    if ('\0' == *psz)
        return E_INVALIDARG;

    psz = PszSkipWhiteA(psz);
    if ('\0' == *psz)
        return E_INVALIDARG;

    // psz now points at the numeric component
    pszEnd = PszScanToWhiteA(psz);
    if ('\0' == *psz)
        return E_INVALIDARG;
    
    // temporarily modify the string in place
    chSaved = *pszEnd;
    *pszEnd = '\0';
    
    *pdwStatus = StrToInt(psz);
    *pszEnd = chSaved;

    return S_OK;
}

// --------------------------------------------------------------------------------
// HrGetStreamSize
// --------------------------------------------------------------------------------
static HRESULT HrGetStreamSize(LPSTREAM pstm, ULONG *pcb)
{
    // Locals
    HRESULT hr=S_OK;
    ULARGE_INTEGER uliPos = {0,0};
    LARGE_INTEGER liOrigin = {0,0};

    // Seek
    hr = pstm->Seek(liOrigin, STREAM_SEEK_END, &uliPos);
    if (FAILED(hr))
        goto error;

    // set size
    *pcb = uliPos.LowPart;

error:
    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// HrAddPropFindProps
// --------------------------------------------------------------------------------
HRESULT HrAddPropFindProps(IPropFindRequest *pRequest, const HMELE *rgEle, DWORD cEle)
{
    HRESULT     hr;
    HMELE       ele;

    for (DWORD i = 0; i < cEle; ++i)
    {
        ele = rgEle[i];
        hr = pRequest->AddProperty(
                        rgHTTPMailDictionary[ele].dwNamespaceID,
                        const_cast<char *>(rgHTTPMailDictionary[ele].pszName));
        if (FAILED(hr))
            goto exit;
    }

exit:

    return hr;
}

// --------------------------------------------------------------------------------
// HrAddPropFindSchemaProps
// --------------------------------------------------------------------------------
HRESULT HrAddPropFindSchemaProps(
                        IPropFindRequest *pRequest, 
                        const XPCOLUMN *prgCols, 
                        DWORD cCols)
{
    HRESULT     hr = S_OK;
    HMELE       ele;

    for (DWORD i = 0; i < cCols; i++)
    {
        if (!!(prgCols[i].dwFlags & XPCF_PFREQUEST))
        {
            hr = pRequest->AddProperty(
                            rgHTTPMailDictionary[prgCols[i].ele].dwNamespaceID,
                            rgHTTPMailDictionary[prgCols[i].ele].pszName);

            if (FAILED(hr))
                goto exit;
        }
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// _HrGenerateRfc821Stream
// --------------------------------------------------------------------------------
HRESULT _HrGenerateRfc821Stream(LPCSTR pszFrom, 
                                LPHTTPTARGETLIST pTargets,
                                IStream **ppRfc821Stream)
{
    HRESULT     hr = S_OK;
    IStream     *pStream = NULL;
    DWORD       dw;
    DWORD       cbCloseTerm;
    DWORD       cbRcptTo;

    IxpAssert(pszFrom);
    IxpAssert(pTargets);
    IxpAssert(ppRfc821Stream);

    *ppRfc821Stream = NULL;

    cbCloseTerm = lstrlen(c_szXMLCloseElementCRLF);
    cbRcptTo = lstrlen(c_szRcptTo);

    pStream = new CVirtualStream();
    if (NULL == pStream)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // write out 'mail from'
    FAIL_EXIT_STREAM_WRITE((*pStream), c_szMailFrom);
    FAIL_EXIT_STREAM_WRITE((*pStream), pszFrom);
    FAIL_EXIT(hr = pStream->Write(c_szXMLCloseElementCRLF, cbCloseTerm, NULL));

    // write out the 'rcpt to' lines
    for (dw = 0; dw < pTargets->cTarget; ++dw)
    {
        FAIL_EXIT(hr = pStream->Write(c_szRcptTo, cbRcptTo, NULL));
        FAIL_EXIT_STREAM_WRITE((*pStream), pTargets->prgTarget[dw]);
        FAIL_EXIT(hr = pStream->Write(c_szXMLCloseElementCRLF, cbCloseTerm, NULL));
    }

    // append an extra crlf to the end of the stream
    FAIL_EXIT_STREAM_WRITE((*pStream), c_szCRLF);
    
    *ppRfc821Stream = pStream;
    pStream = NULL;

exit:
    SafeRelease(pStream);
    return hr;
}

// --------------------------------------------------------------------------------
// _EscapeString
// --------------------------------------------------------------------------------
LPSTR   _EscapeString(LPSTR pszIn)
{
    CByteStream     stream;
    DWORD           dwLen;
    LPSTR           pszLastNonEsc, pszNext, pszOut;    
    HRESULT         hr;
    
    if (NULL == pszIn)
        return NULL;

    pszLastNonEsc = pszIn;
    pszNext = pszIn;

    while (*pszNext)
    {
        switch (*pszNext)
        {
            case '<':
            case '>':
            case '&':
                if (FAILED(hr = stream.Write(pszLastNonEsc, (ULONG) (pszNext - pszLastNonEsc), NULL)))
                    goto exit;

                if (*pszNext == '<')
                {
                    if (FAILED(hr = stream.Write(c_szEscLessThan, lstrlen(c_szEscLessThan), NULL)))
                        goto exit;
                }
                else if (*pszNext == '>')
                {
                    if (FAILED(hr = stream.Write(c_szEscGreaterThan, lstrlen(c_szEscGreaterThan), NULL)))
                        goto exit;
                }
                else
                {
                    if (FAILED(hr = stream.Write(c_szEscAmp, lstrlen(c_szEscAmp), NULL)))
                        goto exit;
                }
                pszLastNonEsc = CharNextExA(CP_ACP, pszNext, 0);
                break;
        }
        pszNext = CharNextExA(CP_ACP, pszNext, 0);
    }

    if (FAILED(hr = stream.Write(pszLastNonEsc, (ULONG) (pszNext - pszLastNonEsc), NULL)))
        goto exit;

    FAIL_EXIT(hr = stream.HrAcquireStringA(&dwLen, (LPSTR *)&pszOut, ACQ_DISPLACE));
    
    return pszOut;

exit:
    return NULL;
}

const HMELE g_rgContactEle[] = {
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_CONTACTS_GIVENNAME,
    HMELE_CONTACTS_SN,
    HMELE_CONTACTS_NICKNAME,
    HMELE_CONTACTS_MAIL,
    HMELE_CONTACTS_HOMESTREET,
    HMELE_CONTACTS_HOMECITY,
    HMELE_CONTACTS_HOMESTATE,
    HMELE_CONTACTS_HOMEPOSTALCODE,
    HMELE_CONTACTS_HOMECOUNTRY,
    HMELE_CONTACTS_O,
    HMELE_CONTACTS_STREET,
    HMELE_CONTACTS_L,
    HMELE_CONTACTS_ST,
    HMELE_CONTACTS_POSTALCODE,
    HMELE_CONTACTS_FRIENDLYCOUNTRYNAME,
    HMELE_CONTACTS_HOMEPHONE,
    HMELE_CONTACTS_HOMEFAX,
    HMELE_CONTACTS_TELEPHONENUMBER,
    HMELE_CONTACTS_FACSIMILETELEPHONENUMBER,
    HMELE_CONTACTS_MOBILE,
    HMELE_CONTACTS_OTHERTELEPHONE,
    HMELE_CONTACTS_BDAY,
    HMELE_CONTACTS_PAGER
};

#define CCHMAX_TAGBUFFER    128

HRESULT HrGeneratePostContactXML(LPHTTPCONTACTINFO pciInfo, LPVOID *ppvXML, DWORD *pdwLen)
{
    HRESULT                 hr = S_OK;
    CByteStream             stream;
    CDAVNamespaceArbiterImp dna;
    DWORD                   dwIndex, dwSize = ARRAYSIZE(g_rgContactEle);
    DWORD                   iBufferSize;
    TCHAR                   szTagBuffer[CCHMAX_TAGBUFFER+1];
    LPSTR                  *prgsz = (LPSTR*)pciInfo, pszEsc;
    LPCSTR                  pszPropName;
    *ppvXML = NULL;
    *pdwLen = 0;

    if (NULL == ppvXML)
        return E_INVALIDARG;

    // write the DAV header. we ALWAYS post using the windows-1252 code
    // page for this release.
    if (FAILED(hr = stream.Write(c_szXML1252Head, lstrlen(c_szXML1252Head), NULL)))
        goto exit;

    dna.m_rgbNsUsed[DAVNAMESPACE_CONTACTS] = TRUE;
    dna.m_rgbNsUsed[DAVNAMESPACE_DAV] = TRUE;

    // write out the contacts header
    if (FAILED(hr = stream.Write(c_szContactHead, lstrlen(c_szContactHead), NULL)))
        goto exit;

    if (FAILED(hr = dna.WriteNamespaces(&stream)))
        goto exit;

    if (FAILED(hr = stream.Write(c_szXMLCloseElement, lstrlen(c_szXMLCloseElement), NULL)))
        goto exit;

    // [PaulHi] 3/11/99  Implementing WAB/HM group contact syncing
    // Include the xml group tag if this is a group contact item
    if (pciInfo->tyContact == HTTPMAIL_CT_GROUP)
    {
        if (FAILED(hr = stream.Write(c_szCRLFTab, lstrlen(c_szCRLFTab), NULL)))
            goto exit;
        if (FAILED(hr = stream.Write(c_szGroupSwitch, lstrlen(c_szGroupSwitch), NULL)))
            goto exit;
    }

    for (dwIndex = 0; dwIndex < dwSize; dwIndex ++)
    {
        if (prgsz[dwIndex] && g_rgContactEle[dwIndex] != HMELE_UNKNOWN)
        {
            pszPropName = rgHTTPMailDictionary[g_rgContactEle[dwIndex]].pszName;

            if (FAILED(hr = stream.Write(c_szOpenContactNamespace, lstrlen(c_szOpenContactNamespace), NULL)))
                goto exit;
    
            if (FAILED(hr = stream.Write(pszPropName, lstrlen(pszPropName), NULL)))
                goto exit;

            if (FAILED(hr = stream.Write(c_szXMLCloseElement, lstrlen(c_szXMLCloseElement), NULL)))
                goto exit;

            pszEsc = _EscapeString(prgsz[dwIndex]);

            if (!pszEsc)
                goto exit;

            hr = stream.Write(pszEsc, lstrlen(pszEsc), NULL);

            SafeMemFree(pszEsc);

            if (FAILED(hr))
                goto exit;
            
            if (FAILED(hr = stream.Write(c_szCloseContactNamespace, lstrlen(c_szCloseContactNamespace), NULL)))
                goto exit;
    
            if (FAILED(hr = stream.Write(pszPropName, lstrlen(pszPropName), NULL)))
                goto exit;

            if (FAILED(hr = stream.Write(c_szXMLCloseElement, lstrlen(c_szXMLCloseElement), NULL)))
                goto exit;
        }
    }

    if (FAILED(hr = stream.Write(c_szContactTail, lstrlen(c_szContactTail), NULL)))
        goto exit;

    FAIL_EXIT(hr = stream.HrAcquireStringA(pdwLen, (LPSTR *)ppvXML, ACQ_DISPLACE));

exit:
    return hr;
}

HRESULT HrCreatePatchContactRequest(LPHTTPCONTACTINFO pciInfo, IPropPatchRequest **ppRequest)
{
    HRESULT             hr = S_OK;
    LPSTR              *prgsz = (LPSTR*)pciInfo, pszEsc;
    DWORD               dwIndex, dwSize = ARRAYSIZE(g_rgContactEle);
    CPropPatchRequest  *pRequest = NULL;
    
    *ppRequest = NULL;

    pRequest = new CPropPatchRequest();
    if (NULL == pRequest)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // always specify windows-1252 encoding for this release
    pRequest->SpecifyWindows1252Encoding(TRUE);

    for (dwIndex = 0; dwIndex < dwSize; dwIndex ++)
    {
        if (g_rgContactEle[dwIndex] != HMELE_UNKNOWN)
        {
            if (prgsz[dwIndex])
            {
                // values with content are added.  Empty strings are deleted.  Null values are ignored.
                if (*(prgsz[dwIndex]))
                {
                    pszEsc = _EscapeString(prgsz[dwIndex]);
                    if (!pszEsc)
                        goto exit;

                    hr = pRequest->SetProperty(DAVNAMESPACE_CONTACTS, const_cast<char *>(rgHTTPMailDictionary[g_rgContactEle[dwIndex]].pszName), pszEsc);
                    
                    SafeMemFree(pszEsc);

                    if (FAILED(hr))
                        goto exit;
                                
                }
                else
                {
                    if (FAILED(hr = pRequest->RemoveProperty(DAVNAMESPACE_CONTACTS, const_cast<char *>(rgHTTPMailDictionary[g_rgContactEle[dwIndex]].pszName))))
                        goto exit;
                }
            }
        }
    }
exit:
    if (FAILED(hr))
        SafeRelease(pRequest);
    else
        *ppRequest = pRequest;

    return hr;
}

HRESULT HrGenerateSimpleBatchXML(
                            LPCSTR pszRootName,
                            LPHTTPTARGETLIST pTargets,
                            LPVOID *ppvXML,
                            DWORD *pdwLen)
{
    HRESULT                 hr = S_OK;
    CByteStream             stream;
    DWORD                   dwIndex;
    DWORD                   dwHrefHeadLen, dwHrefTailLen;

    IxpAssert(NULL != pszRootName);
    IxpAssert(NULL != pTargets);
    IxpAssert(pTargets->cTarget >= 1);
    IxpAssert(NULL != pTargets->prgTarget);
    IxpAssert(NULL != ppvXML);
    IxpAssert(NULL != pdwLen);

    dwHrefHeadLen = lstrlen(c_szHrefHead);
    dwHrefTailLen = lstrlen(c_szHrefTail);

    // write the DAV header
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLHead);

    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead1);
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead2);

    FAIL_EXIT_STREAM_WRITE(stream, c_szTargetHead);

    // write out the targets
    for (dwIndex = 0; dwIndex < pTargets->cTarget; dwIndex++)
    {
        if (FAILED(hr = stream.Write(c_szHrefHead, dwHrefHeadLen, NULL)))
            goto exit;

        FAIL_EXIT_STREAM_WRITE(stream, pTargets->prgTarget[dwIndex]);

        if (FAILED(hr = stream.Write(c_szHrefTail, dwHrefTailLen, NULL)))
            goto exit;
    }

    FAIL_EXIT_STREAM_WRITE(stream, c_szTargetTail);

    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchTail);
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);

    // take ownership of the bytestream
    FAIL_EXIT(hr = stream.HrAcquireStringA(pdwLen, (LPSTR *)ppvXML, ACQ_DISPLACE));

exit:
    return hr;
}

HRESULT HrGenerateMultiDestBatchXML(
                        LPCSTR pszRootName,
                        LPHTTPTARGETLIST pTargets, 
                        LPHTTPTARGETLIST pDestinations,
                        LPVOID *ppvXML,
                        DWORD *pdwLen)
{
    HRESULT         hr = S_OK;
    CByteStream     stream;
    DWORD           dwIndex;

    IxpAssert(NULL != pszRootName);
    IxpAssert(NULL != pTargets);
    IxpAssert(NULL != pDestinations);
    IxpAssert(NULL != ppvXML);
    IxpAssert(NULL != pdwLen);

    // source and destination must have same count
    if (pTargets->cTarget != pDestinations->cTarget)
        return E_INVALIDARG;

    *ppvXML = NULL;
    *pdwLen = 0;

    // write the DAV header
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLHead);

    // write the command header
    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead1);
    
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead2);

    // write out the targets
    for (dwIndex = 0; dwIndex < pTargets->cTarget; dwIndex++)
    {
        IxpAssert(NULL != pTargets->prgTarget[dwIndex]);
        if (NULL != pTargets->prgTarget[dwIndex])
        {
            FAIL_EXIT_STREAM_WRITE(stream, c_szTargetHead);

            FAIL_EXIT_STREAM_WRITE(stream, c_szHrefHead);
            FAIL_EXIT_STREAM_WRITE(stream, pTargets->prgTarget[dwIndex]);
            FAIL_EXIT_STREAM_WRITE(stream, c_szHrefTail);

            if (NULL != pDestinations->prgTarget[dwIndex])
            {
                FAIL_EXIT_STREAM_WRITE(stream, c_szDestHead);
                FAIL_EXIT_STREAM_WRITE(stream, pDestinations->prgTarget[dwIndex]);
                FAIL_EXIT_STREAM_WRITE(stream, c_szDestTail);
            }

            FAIL_EXIT_STREAM_WRITE(stream, c_szTargetTail);
        }
    }

    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchTail);
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);

    // take ownership of the byte stream
    hr = stream.HrAcquireStringA(pdwLen, (LPSTR *)ppvXML, ACQ_DISPLACE);

exit:
    return hr;
}

HRESULT HrCopyStringList(LPCSTR *rgszInList, LPCSTR **prgszOutList)
{

    DWORD   cStrings = 0;
    HRESULT hr = S_OK;
    LPCSTR  pszCur;
    DWORD   i = 0;

    IxpAssert(NULL != rgszInList);
    IxpAssert(NULL != prgszOutList);

    *prgszOutList = NULL;

    // count the strings in the list
    while (NULL != rgszInList[i++])
        ++cStrings;

    // allocate the new list
    if (!MemAlloc((void **)prgszOutList, (cStrings + 1) * sizeof(LPCSTR)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // copy the strings over. if an allocation fails,
    // stay in the loop and null out all of the slots
    // that haven't been filled
    for (i = 0; i <= cStrings; i++)
    {
        if (SUCCEEDED(hr) && NULL != rgszInList[i])
        {
            (*prgszOutList)[i] = PszDupA(rgszInList[i]);
            if (NULL == (*prgszOutList)[i])
                hr = E_OUTOFMEMORY;
        }
        else
            (*prgszOutList)[i] = NULL;
    }
    
    if (FAILED(hr))
    {
        FreeStringList(*prgszOutList);
        *prgszOutList = NULL;
    }

exit:
    return hr;
}

void FreeStringList(LPCSTR *rgszList)
{
    DWORD i = 0;

    IxpAssert(NULL != rgszList);
    
    if (rgszList)
    {
        while (NULL != rgszList[i])
            MemFree((void *)rgszList[i++]);

        MemFree(rgszList);
    }
}

// --------------------------------------------------------------------------------
// class CHTTPMailTransport
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CHTTPMailTransport
// --------------------------------------------------------------------------------
CHTTPMailTransport::CHTTPMailTransport(void) :
    m_cRef(1),
    m_fHasServer(FALSE),
    m_fHasRootProps(FALSE),
    m_fTerminating(FALSE),
    m_status(IXP_DISCONNECTED),
    m_hInternet(NULL),
    m_hConnection(NULL),
    m_pszUserAgent(NULL),
    m_pLogFile(NULL),
    m_pCallback(NULL),
    m_pParser(NULL),
    m_hwnd(NULL),
    m_hevPendingCommand(NULL),
    m_opPendingHead(NULL),
    m_opPendingTail(NULL),
    m_pszCurrentHost(NULL),
    m_nCurrentPort(INTERNET_INVALID_PORT_NUMBER)
{
    DWORD dwTempID;
    HANDLE hThread = NULL;

    InitializeCriticalSection(&m_cs);
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    ZeroMemory(&m_op, sizeof(HTTPMAILOPERATION));
    ZeroMemory(&m_rootProps, sizeof(ROOTPROPS));

    m_op.rResponse.command = HTTPMAIL_NONE;

    m_hevPendingCommand = CreateEvent(NULL, TRUE, FALSE, NULL);

    // Create the IO thread
    hThread = CreateThread(NULL, 0, IOThreadFuncProxy, (LPVOID)this, 0, &dwTempID);

    // We do not need to manipulate the IO Thread through its handle, so close it
    // This will NOT terminate the thread
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }

    DllAddRef();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::~CHTTPMailTransport
// --------------------------------------------------------------------------------
CHTTPMailTransport::~CHTTPMailTransport(void)
{
    IxpAssert(0 == m_cRef);
    
    // Shouldn't be pending commands
    IxpAssert(HTTPMAIL_NONE == m_op.rResponse.command);
    IxpAssert(!m_opPendingHead);
    IxpAssert(!m_opPendingTail);

    IxpAssert(m_fTerminating);


    // Destroy the critical sections
    DeleteCriticalSection(&m_cs);

    // Close the window    
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0);

    SafeMemFree(m_pszUserAgent);

    CloseHandle(m_hevPendingCommand);

    SafeMemFree(m_rootProps.pszAdbar);
    SafeMemFree(m_rootProps.pszContacts);
    SafeMemFree(m_rootProps.pszInbox);
    SafeMemFree(m_rootProps.pszOutbox);
    SafeMemFree(m_rootProps.pszSendMsg);
    SafeMemFree(m_rootProps.pszSentItems);
    SafeMemFree(m_rootProps.pszDeletedItems);
    SafeMemFree(m_rootProps.pszDrafts);
    SafeMemFree(m_rootProps.pszMsgFolderRoot);
    SafeMemFree(m_rootProps.pszSig);

    SafeMemFree(m_pszCurrentHost);

    SafeRelease(m_pLogFile);
    SafeRelease(m_pCallback);
    SafeRelease(m_pParser);

    SafeInternetCloseHandle(m_hInternet);

    // BUGBUG: clean up window, thread and event, release buffers, etc
    DllRelease();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::HrConnectToHost
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::HrConnectToHost(
                                LPSTR pszHostName, 
                                INTERNET_PORT nPort,
                                LPSTR pszUserName,
                                LPSTR pszPassword)
{
    IxpAssert(m_hInternet);

    // if a connection exists, determine if it is to the same host/port
    // that the caller is specifying.
    if (NULL != m_hConnection)
    {
        // if we are already connected to the correct host, return immediately
        if (m_nCurrentPort == nPort && m_pszCurrentHost && (lstrcmp(pszHostName, m_pszCurrentHost) == 0))
            return S_OK;

        // if we are connected to the wrong server, close the existing connection
        SafeInternetCloseHandle(m_hConnection);
        SafeMemFree(m_pszCurrentHost);
        m_nCurrentPort = INTERNET_INVALID_PORT_NUMBER;
    }

    // establish a connection to the specified server
    m_hConnection = InternetConnect(
                        m_hInternet,
                        pszHostName,
                        nPort,
                        NULL,                           // user name
                        NULL,                           // password
                        INTERNET_SERVICE_HTTP,          // service
                        0,                              // flags
                        reinterpret_cast<DWORD_PTR>(this)); // context

    // what can cause this?
    if (NULL == m_hConnection)
        return E_OUTOFMEMORY;

    // save the host name. don't bother checking for failure...we just won't reuse
    // the connection next time through.
    m_pszCurrentHost = PszDupA(pszHostName);
    m_nCurrentPort = nPort;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DoLogonPrompt
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::DoLogonPrompt(void)
{
    HRESULT             hr = S_OK;
    IHTTPMailCallback   *pCallback = NULL;

    EnterCriticalSection(&m_cs);

    if (m_pCallback)
    {
        pCallback = m_pCallback;
        pCallback->AddRef();
    }
    else
        hr = E_FAIL;

    LeaveCriticalSection(&m_cs);

    if (pCallback)
    {
        hr = pCallback->OnLogonPrompt(&m_rServer, this);
        pCallback->Release();
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DoGetParentWindow
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::DoGetParentWindow(HWND *phwndParent)
{
    HRESULT             hr = S_OK;
    IHTTPMailCallback   *pCallback = NULL;

    EnterCriticalSection(&m_cs);

    if (m_pCallback)
    {
        pCallback = m_pCallback;
        pCallback->AddRef();
    }
    else
        hr = E_FAIL;

    LeaveCriticalSection(&m_cs);

    if (pCallback)
    {
        hr = pCallback->GetParentWindow(phwndParent);
        pCallback->Release();
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CreateWnd
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::CreateWnd()
{
    WNDCLASS wc;

    IxpAssert(!m_hwnd);
    if (m_hwnd)
        return TRUE;

    if (!GetClassInfo(g_hLocRes, s_szHTTPMailWndClass, &wc))
    {
        wc.style                = 0;
        wc.lpfnWndProc         = CHTTPMailTransport::WndProc;
        wc.cbClsExtra           = 0;
        wc.cbWndExtra           = 0;
        wc.hInstance            = g_hLocRes;
        wc.hIcon                = NULL;
        wc.hCursor              = NULL;
        wc.hbrBackground        = NULL;
        wc.lpszMenuName         = NULL;
        wc.lpszClassName        = s_szHTTPMailWndClass;
        RegisterClass(&wc);
    }

    m_hwnd = CreateWindowEx(0,
                        s_szHTTPMailWndClass,
                        s_szHTTPMailWndClass,
                        WS_POPUP,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        g_hLocRes,
                        (LPVOID)this);

    return (NULL != m_hwnd);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DequeueNextOperation
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::DequeueNextOperation(void)
{
    if (NULL == m_opPendingHead)
        return FALSE;

    IxpAssert(HTTPMAIL_NONE == m_op.rResponse.command);
    IxpAssert(HTTPMAIL_NONE != m_opPendingHead->command);

    m_op.rResponse.command = m_opPendingHead->command;

    m_op.pfnState = m_opPendingHead->pfnState;
    m_op.cState = m_opPendingHead->cState;    
     
    m_op.pszUrl                = m_opPendingHead->pszUrl;
    m_op.pszDestination        = m_opPendingHead->pszDestination;
    m_op.pszContentType        = m_opPendingHead->pszContentType;
    m_op.pvData                = m_opPendingHead->pvData;
    m_op.cbDataLen             = m_opPendingHead->cbDataLen;
    m_op.dwContext             = m_opPendingHead->dwContext;
    m_op.dwDepth               = m_opPendingHead->dwDepth;
    m_op.dwRHFlags             = m_opPendingHead->dwRHFlags;
    m_op.dwMIFlags             = m_opPendingHead->dwMIFlags;
    m_op.tyProp                = m_opPendingHead->tyProp;
    m_op.fBatch                = m_opPendingHead->fBatch;
    m_op.rgszAcceptTypes       = m_opPendingHead->rgszAcceptTypes;
    m_op.pPropFindRequest      = m_opPendingHead->pPropFindRequest;
    m_op.pPropPatchRequest     = m_opPendingHead->pPropPatchRequest;
    m_op.pParseFuncs           = m_opPendingHead->pParseFuncs;
    m_op.pHeaderStream         = m_opPendingHead->pHeaderStream;
    m_op.pBodyStream           = m_opPendingHead->pBodyStream;
    m_op.pszFolderTimeStamp    = m_opPendingHead->pszFolderTimeStamp;
    m_op.pszRootTimeStamp      = m_opPendingHead->pszRootTimeStamp;
    //m_op.pszFolderName         = m_opPendingHead->pszFolderName;

    LPHTTPQUEUEDOP pDelete = m_opPendingHead;

    m_opPendingHead = m_opPendingHead->pNext;
    if (NULL == m_opPendingHead)
        m_opPendingTail = NULL;

    MemFree(pDelete);

    return TRUE;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FlushQueue
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FlushQueue(void)
{
    // destroy any commands that are pending.
    // REVIEW: these commands need to notify their callers
    LPHTTPQUEUEDOP pOp = m_opPendingHead;
    LPHTTPQUEUEDOP pNext;

    while (pOp)
    {
        pNext = pOp->pNext;

        SafeMemFree(pOp->pszUrl);
        SafeMemFree(pOp->pszDestination);
        if (pOp->pszContentType)
            MemFree((void *)pOp->pszContentType);
        SafeMemFree(pOp->pvData);
        if (pOp->rgszAcceptTypes)
            FreeStringList(pOp->rgszAcceptTypes);
        SafeRelease(pOp->pPropFindRequest);
        SafeRelease(pOp->pPropPatchRequest);

        MemFree(pOp);
        pOp = pNext;
    }

    m_opPendingHead = m_opPendingTail = NULL;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::TerminateIOThread
// --------------------------------------------------------------------------------
void CHTTPMailTransport::TerminateIOThread(void)
{
    EnterCriticalSection(&m_cs);
    // acquire a reference to the transport that will be owned
    // by the io thread. the reference will be release when the
    // io thread exits. this reference is not acquired when the
    // thread is created, because it would prevent the transport
    // from going away.
    AddRef();

    m_fTerminating = TRUE;

    FlushQueue();

    // signal the io thread to wake it.
    SetEvent(m_hevPendingCommand);

    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::IOThreadFunc
// --------------------------------------------------------------------------------

DWORD CALLBACK CHTTPMailTransport::IOThreadFuncProxy(PVOID pv)
{
    CHTTPMailTransport  *pHTTPMail = (CHTTPMailTransport*)pv;
    DWORD               dwResult = S_OK;

    IxpAssert(pHTTPMail);

    // Initialize COM
    if(S_OK == (dwResult = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
    {
        dwResult = pHTTPMail->IOThreadFunc();
        //Bug #101165 -- MSXML needs notification to clean up per thread data.
        CoUninitialize();
    }

    return dwResult;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::IOThreadFunc
// Called by IOThreadProxy to transition into an object method
// --------------------------------------------------------------------------------
DWORD CHTTPMailTransport::IOThreadFunc()
{
    LPSTR       pszVerb = NULL;
    BOOL        bQueueEmpty = FALSE;
    
    // block until a command is pending.
    while (WAIT_OBJECT_0 == WaitForSingleObject(m_hevPendingCommand, INFINITE))
    {
        if (IsTerminating())
            break;

        // Reset the event
        ResetEvent(m_hevPendingCommand);

        // unhook commands from the queue one at a time, and process them until
        // the queue is empty

        while (TRUE)
        {
            // dequeue the next operation

            EnterCriticalSection(&m_cs);
            
            IxpAssert(HTTPMAIL_NONE == m_op.rResponse.command);
            
            bQueueEmpty = !DequeueNextOperation();

            // if no commands left, break out of the loop and block
           
            LeaveCriticalSection(&m_cs);

            if (bQueueEmpty)
                break;
            
            DoOperation();
        }

        if (IsTerminating())
            break;
    }

    IxpAssert(IsTerminating());

    // TerminateIOThread acquired a reference that gets released here
    Release();

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::WndProc
// --------------------------------------------------------------------------------

LRESULT CALLBACK CHTTPMailTransport::WndProc(HWND hwnd,
                                             UINT msg,
                                             WPARAM wParam,
                                             LPARAM lParam)
{
    CHTTPMailTransport *pThis = (CHTTPMailTransport*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    LRESULT             lr = 0;

    switch (msg)
    {
    case WM_NCCREATE:
        IxpAssert(!pThis);
        pThis = (CHTTPMailTransport*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
        lr = DefWindowProc(hwnd, msg, wParam, lParam);       
        break;
    
    case SPM_HTTPMAIL_SENDRESPONSE:
        IxpAssert(pThis);
        pThis->InvokeResponseCallback();
        break;

    case SPM_HTTPMAIL_LOGONPROMPT:
        IxpAssert(pThis);
        lr = pThis->DoLogonPrompt();
        break;

    case SPM_HTTPMAIL_GETPARENTWINDOW:
        IxpAssert(pThis);
        lr = pThis->DoGetParentWindow((HWND *)wParam);
        break;
        
    default:
        lr = DefWindowProc(hwnd, msg, wParam, lParam);
        break;
    }

    return lr;
}


// --------------------------------------------------------------------------------
// CHTTPMailTransport::Reset
// --------------------------------------------------------------------------------
void CHTTPMailTransport::Reset(void)
{
    // REVIEW: this is incomplete. Should we be aborting the current command?
    EnterCriticalSection(&m_cs);

    SafeRelease(m_pLogFile);
    
    SafeInternetCloseHandle(m_hConnection);
    SafeInternetCloseHandle(m_hInternet);

    SafeMemFree(m_pszUserAgent);

    SafeRelease(m_pCallback);
    m_status = IXP_DISCONNECTED;
    m_fHasServer = FALSE;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IHTTPMailTransport *)this);

    // IID_IInternetTransport 
    else if (IID_IInternetTransport == riid)
        *ppv = (IInternetTransport *)this;

    // IID_IHTTPMailTransport
    else if (IID_IHTTPMailTransport == riid)
        *ppv = (IHTTPMailTransport *)this;

    // IID_IXMLNodeFactory
    else if (IID_IXMLNodeFactory == riid)
        *ppv = (IXMLNodeFactory *)this;

    else if (IID_IHTTPMailTransport2 == riid)
        *ppv = (IHTTPMailTransport2 *)this;

    // if not NULL, acquire a reference and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}
// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailTransport::AddRef(void) 
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailTransport::Release(void) 
{
    if (0 != --m_cRef)
        return m_cRef;

    // our refcount dropped to zero, and we aren't terminating,
    // begin terminating
    if (!IsTerminating())
    {
        TerminateIOThread();
        return 1;
    }
    
    // if we were terminating, and our refCount dropped to zero,
    // then the iothread has been unwound and we can safely exit.
    delete this;
    return 0;
}

// ----------------------------------------------------------------------------
// IInternetTransport methods
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::Connect(LPINETSERVER pInetServer, 
                                        boolean fAuthenticate, 
                                        boolean fCommandLogging)
{
    HRESULT                     hr = S_OK; 

    if (NULL == pInetServer  || FIsEmptyA(pInetServer->szServerName))
        return TrapError(E_INVALIDARG);

    // Thread safety
    EnterCriticalSection(&m_cs);

    // not init
    if (NULL == m_hInternet || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    FAIL_CREATEWND;

    // busy
    if (IXP_DISCONNECTED != m_status || m_fHasServer)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    // copy the server struct
    CopyMemory(&m_rServer, pInetServer, sizeof(INETSERVER));
    m_fHasServer = TRUE;
    m_fHasRootProps = FALSE;
    
exit:
    // ThreadSafety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::DropConnection(void)
{
    // this function is called to stop any current and pending i/o

    // Locals
    HRESULT     hr = S_OK;
    BOOL        fSendResponse;

    EnterCriticalSection(&m_cs);
    
    // flush any pending i/o from the queue
    FlushQueue();
    
    // if a command is being processed, mark it aborted and
    // send a response if necessary. stay in the critical
    // section to prevent the io thread from sending any
    // notifications at the same time.
    if (m_op.rResponse.command != HTTPMAIL_NONE)
    {
        m_op.fAborted = TRUE;
        m_op.rResponse.fDone = TRUE; 
    }

    Disconnect();

    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::Disconnect(void)
{
    // Locals
    HRESULT     hr = S_OK;

    // Thread safety
    EnterCriticalSection(&m_cs);

    if (NULL == m_hConnection)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Disconnecting
    if (m_pCallback)
        m_pCallback->OnStatus(IXP_DISCONNECTING, this);

    SafeInternetCloseHandle(m_hConnection);

    m_status = IXP_DISCONNECTED;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));

    if (m_pCallback)
        m_pCallback->OnStatus(IXP_DISCONNECTED, this);

     // Close the window    
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0);
    m_hwnd = NULL;
    m_fHasServer = FALSE;

exit:
    // Thread safety
    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::IsState(IXPISSTATE isstate)
{
    // Locals
    HRESULT     hr = S_OK;

    // Thread safety
    EnterCriticalSection(&m_cs);

    switch(isstate)
    {
        // are we connected?
        case IXP_IS_CONNECTED:
            hr = (NULL == m_hConnection) ? S_FALSE : S_OK;
            break;

        // are we busy?
        case IXP_IS_BUSY:
            hr = (HTTPMAIL_NONE != m_op.rResponse.command) ? S_OK : S_FALSE;
            break;

        // are we ready
        case IXP_IS_READY:
            hr = (HTTPMAIL_NONE == m_op.rResponse.command) ? S_OK : S_FALSE;
            break;

        case IXP_IS_AUTHENTICATED:
            // REVIEW
            hr = S_OK;
            break;

        default:
            IxpAssert(FALSE);
            break;
    }

    // Thread safety
    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetServerInfo(LPINETSERVER pInetServer)
{
    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // Thread safety
    EnterCriticalSection(&m_cs);

    // Copy server info
    CopyMemory(pInetServer, &m_rServer, sizeof(INETSERVER));

    // Thread safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CHTTPMailTransport::GetIXPType(void)
{
    return IXP_HTTPMail;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    HRESULT     hr = S_OK;
    DWORD       fAlwaysPromptPassword = FALSE;

    // check params
    if (NULL == pAccount || NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // ZeroInit
    ZeroMemory(pInetServer, sizeof(INETSERVER));

    // Get the account name
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, pInetServer->szAccount, ARRAYSIZE(pInetServer->szAccount))))
    {
        hr = TrapError(IXP_E_INVALID_ACCOUNT);
        goto exit;
    }

    // Get the RAS connectoid
    if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, pInetServer->szConnectoid, ARRAYSIZE(pInetServer->szConnectoid))))
        *pInetServer->szConnectoid = '\0';

    // Connection Type
    Assert(sizeof(pInetServer->rasconntype) == sizeof(DWORD));
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, (DWORD *)&pInetServer->rasconntype)))
        pInetServer->rasconntype = RAS_CONNECT_LAN;

           // Get Server Name
    hr = pAccount->GetPropSz(AP_HTTPMAIL_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_INVALID_ACCOUNT);
        goto exit;
    }

    // Password
    if (FAILED(pAccount->GetPropDw(AP_HTTPMAIL_PROMPT_PASSWORD, &fAlwaysPromptPassword)) || FALSE == fAlwaysPromptPassword)
        pAccount->GetPropSz(AP_HTTPMAIL_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));

    if (fAlwaysPromptPassword)
        pInetServer->dwFlags |= ISF_ALWAYSPROMPTFORPASSWORD;

    // Sicily
    Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
    pAccount->GetPropDw(AP_HTTPMAIL_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);


    // User Name
    pAccount->GetPropSz(AP_HTTPMAIL_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::HandsOffCallback(void)
{
    // Locals
    HRESULT hr = S_OK;

    // Thread safety
    EnterCriticalSection(&m_cs);

    // No current callback
    if (NULL == m_pCallback)
    {
        hr = TrapError(S_FALSE);
        goto exit;
    }

    // Release it
    SafeRelease(m_pCallback);

exit:
    // Thread safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetStatus(IXPSTATUS *pCurrentStatus)
{
    if (NULL == pCurrentStatus)
        return TrapError(E_INVALIDARG);

    *pCurrentStatus = m_status;
    return S_OK;
}

// ----------------------------------------------------------------------------
// IHTTPMailTransport methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// CHTTPMailTransport::GetProperty
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetProperty(
                                        HTTPMAILPROPTYPE type, 
                                        LPSTR *ppszProp)
{
    HRESULT         hr = S_OK;

    if (type <= HTTPMAIL_PROP_INVALID || type >= HTTPMAIL_PROP_LAST)
        return E_INVALIDARG;

    if (ppszProp)
        *ppszProp = NULL;

    if (!m_fHasRootProps || NULL == ppszProp)
    {
        IF_FAILEXIT(hr = QueueGetPropOperation(type));
    }

    switch (type)
    {
    case HTTPMAIL_PROP_ADBAR:
        *ppszProp = PszDupA(m_rootProps.pszAdbar);
        break;

    case HTTPMAIL_PROP_CONTACTS:
        *ppszProp = PszDupA(m_rootProps.pszContacts);
        break;
        
    case HTTPMAIL_PROP_INBOX:
        *ppszProp = PszDupA(m_rootProps.pszInbox);
        break;

    case HTTPMAIL_PROP_OUTBOX:
        *ppszProp = PszDupA(m_rootProps.pszOutbox);
        break;

    case HTTPMAIL_PROP_SENDMSG:
        *ppszProp = PszDupA(m_rootProps.pszSendMsg);
        break;

    case HTTPMAIL_PROP_SENTITEMS:
        *ppszProp = PszDupA(m_rootProps.pszSentItems);
        break;

    case HTTPMAIL_PROP_DELETEDITEMS:
        *ppszProp = PszDupA(m_rootProps.pszDeletedItems);
        break;
    
    case HTTPMAIL_PROP_DRAFTS:
        *ppszProp = PszDupA(m_rootProps.pszDrafts);
        break;
    
    case HTTPMAIL_PROP_MSGFOLDERROOT:
        *ppszProp = PszDupA(m_rootProps.pszMsgFolderRoot);
        break;

    case HTTPMAIL_PROP_SIG:
        *ppszProp = PszDupA(m_rootProps.pszSig);
        break;

    default:
        hr = TrapError(E_INVALIDARG);
        break;
    }

    if (SUCCEEDED(hr) && !*ppszProp)
        hr = IXP_E_HTTP_ROOT_PROP_NOT_FOUND;

exit:
    return hr;
}

HRESULT CHTTPMailTransport::QueueGetPropOperation(HTTPMAILPROPTYPE type)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp;

    if (!m_fHasServer || NULL == m_rServer.szServerName)
    {
        hr = E_FAIL;
        goto exit;
    }

    FAIL_CREATEWND;

    // queue the getprop operation
    if (FAILED(hr = AllocQueuedOperation(m_rServer.szServerName, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_GETPROP;
    pOp->tyProp = type;

    pOp->pfnState = c_rgpfnRootProps;
    pOp->cState = ARRAYSIZE(c_rgpfnRootProps);
    pOp->pParseFuncs = c_rgpfnRootPropsParse;
    pOp->dwRHFlags = (RH_XMLCONTENTTYPE | RH_BRIEF);

    QueueOperation(pOp);

    hr = E_PENDING;

exit:
    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::GetPropertyDw
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetPropertyDw(
                                        HTTPMAILPROPTYPE type, 
                                        LPDWORD          lpdwProp)
{
    HRESULT         hr = S_OK;

    if (type <= HTTPMAIL_PROP_INVALID || type >= HTTPMAIL_PROP_LAST)
        IF_FAILEXIT(hr = E_INVALIDARG);

    if (lpdwProp)
        *lpdwProp = 0;

    if (!m_fHasRootProps || NULL == lpdwProp)
    {
        IF_FAILEXIT(hr = QueueGetPropOperation(type));
        
    }

    switch (type)
    {
        case HTTPMAIL_PROP_MAXPOLLINGINTERVAL:
            *lpdwProp = m_rootProps.dwMaxPollingInterval;
            break;

        default:
            hr = TrapError(E_INVALIDARG);
            break;
    }

exit:
    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandGET
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandGET(LPCSTR pszUrl, 
                                            LPCSTR *rgszAcceptTypes,
                                            BOOL fTranslate,
                                            DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPCSTR          *rgszAcceptTypesCopy = NULL;

    if (NULL == pszUrl)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (NULL != rgszAcceptTypes)
    {
        hr = HrCopyStringList(rgszAcceptTypes, &rgszAcceptTypesCopy);
        if (FAILED(hr))
            goto exit;
    }

    if (FAILED(hr = AllocQueuedOperation(pszUrl, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_GET;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfGet;
    pOp->cState = ARRAYSIZE(c_rgpfGet);
    pOp->rgszAcceptTypes = rgszAcceptTypesCopy;
    if (!fTranslate)
        pOp->dwRHFlags = RH_TRANSLATEFALSE;

    rgszAcceptTypesCopy = NULL;

    QueueOperation(pOp);

exit:        
    if (NULL != rgszAcceptTypesCopy)
        FreeStringList(rgszAcceptTypesCopy);

    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandPUT
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPUT(
                                        LPCSTR pszPath, 
                                        LPVOID lpvData,
                                        ULONG cbSize,
                                        DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPCSTR          pszLocalContentType = NULL;
    LPVOID          lpvCopy = NULL;

    if (NULL == pszPath || NULL == lpvData || 0 == cbSize)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (!MemAlloc(&lpvCopy, cbSize))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    CopyMemory(lpvCopy, lpvData, cbSize);

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_PUT;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPut;
    pOp->cState = ARRAYSIZE(c_rgpfnPut);
    pOp->pvData = lpvCopy;
    lpvCopy = NULL;
    pOp->cbDataLen = cbSize;

    QueueOperation(pOp);

exit:
    SafeMemFree(lpvCopy);
    return hr;
}
                                    
// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandPOST
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPOST(
                                    LPCSTR pszPath,
                                    IStream *pStream,
                                    LPCSTR pszContentType,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPCSTR          pszLocalContentType = NULL;

    if (NULL == pszPath || NULL == pStream)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (pszContentType)
    {
        pszLocalContentType = PszDupA(pszContentType);
        if (NULL == pszLocalContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_POST;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPost;
    pOp->cState = ARRAYSIZE(c_rgpfnPost);
    pOp->pBodyStream = pStream;
    pOp->pBodyStream->AddRef();
    pOp->pszContentType = pszLocalContentType;
    pszLocalContentType = NULL;

    QueueOperation(pOp);

exit:
    if (pszLocalContentType)
        MemFree((void *)pszLocalContentType);

    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandDELETE
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandDELETE(
                                    LPCSTR pszPath,
                                    DWORD dwContext)
{    
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;
    
    pOp->command = HTTPMAIL_DELETE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfDelete;
    pOp->cState = ARRAYSIZE(c_rgpfDelete);

    QueueOperation(pOp);

exit:
    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandBDELETE
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandBDELETE(
                                    LPCSTR pszPath,
                                    LPHTTPTARGETLIST pBatchTargets,
                                    DWORD dwContext)
{    
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPVOID          pvXML = NULL;
    DWORD           dwXMLLen = 0;

    if (NULL == pszPath || NULL == pBatchTargets)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = HrGenerateSimpleBatchXML(c_szDelete, pBatchTargets, &pvXML, &dwXMLLen)))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszPath, pvXML, dwXMLLen, &pOp, TRUE)))
        goto exit;
    
    pvXML = NULL;

    pOp->command = HTTPMAIL_BDELETE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfDelete;
    pOp->cState = ARRAYSIZE(c_rgpfDelete);
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);

    return hr;
}
// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandPROPFIND
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPROPFIND(
                                    LPCSTR pszPath,
                                    IPropFindRequest *pRequest,
                                    DWORD dwDepth,
                                    DWORD dwContext)
{
    if (NULL == pszPath || NULL == pRequest)
        return TrapError(E_INVALIDARG);

    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandPROPPATCH
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPROPPATCH(
                                        LPCSTR pszUrl, 
                                        IPropPatchRequest *pRequest, 
                                        DWORD dwContext)
{
    if (NULL == pszUrl || NULL == pRequest)
        return TrapError(E_INVALIDARG);

    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszUrl, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_PROPPATCH;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPropPatch;
    pOp->cState = ARRAYSIZE(c_rgpfnPropPatch);
    pOp->pPropPatchRequest = pRequest;
    pRequest->AddRef();
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    return hr;
}
    
// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandMKCOL
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::CommandMKCOL(LPCSTR pszUrl, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszUrl)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszUrl, NULL, 0, &pOp)))
        goto exit;

    pOp->command   = HTTPMAIL_MKCOL;
    pOp->dwContext = dwContext;
    pOp->pfnState  = c_rgpfnMkCol;
    pOp->cState    = ARRAYSIZE(c_rgpfnMkCol);
    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandCOPY
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandCOPY(
                                    LPCSTR pszPath, 
                                    LPCSTR pszDestination, 
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszPath || NULL == pszDestination)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestination);
    if (NULL == pszDupDestination)
        return TrapError(E_OUTOFMEMORY);

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_COPY;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnCopy;
    pOp->cState = ARRAYSIZE(c_rgpfnCopy);

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;

    if (fAllowRename)
        pOp->dwRHFlags = RH_ALLOWRENAME;

    QueueOperation(pOp);

exit:
    SafeMemFree(pszDupDestination);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandBCOPY
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandBCOPY(
                                    LPCSTR pszSourceCollection, 
                                    LPHTTPTARGETLIST pTargets, 
                                    LPCSTR pszDestCollection, 
                                    LPHTTPTARGETLIST pDestinations,
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPVOID          pvXML = NULL;
    DWORD           dwXMLLen = 0;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszSourceCollection || NULL == pTargets || NULL == pszDestCollection)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestCollection);
    if (NULL == pszDupDestination)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (NULL == pDestinations)
        hr = HrGenerateSimpleBatchXML(c_szCopy, pTargets, &pvXML, &dwXMLLen);
    else
        hr = HrGenerateMultiDestBatchXML(c_szCopy, pTargets, pDestinations, &pvXML, &dwXMLLen);

    if (FAILED(hr))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszSourceCollection, pvXML, dwXMLLen, &pOp, TRUE)))
        goto exit;

    pvXML = NULL;

    pOp->command = HTTPMAIL_BCOPY;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnBMove;
    pOp->cState = ARRAYSIZE(c_rgpfnBMove);
    pOp->pParseFuncs = c_rgpfnBCopyMoveParse;

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;
    
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;
    if (fAllowRename)
        pOp->dwRHFlags |= RH_ALLOWRENAME;

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);
    SafeMemFree(pszDupDestination);
    return hr;
}


// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandMOVE
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandMOVE(
                                    LPCSTR pszPath, 
                                    LPCSTR pszDestination,
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszPath || NULL == pszDestination)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestination);
    if (NULL == pszDupDestination)
        return TrapError(E_OUTOFMEMORY);

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_MOVE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnMove;
    pOp->cState = ARRAYSIZE(c_rgpfnMove);

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;
    
    if (fAllowRename)
        pOp->dwRHFlags = RH_ALLOWRENAME;
    
    QueueOperation(pOp);

exit:
    SafeMemFree(pszDupDestination);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandBMOVE
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandBMOVE(
                                    LPCSTR pszSourceCollection, 
                                    LPHTTPTARGETLIST pTargets, 
                                    LPCSTR pszDestCollection, 
                                    LPHTTPTARGETLIST pDestinations,
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPVOID          pvXML = NULL;
    DWORD           dwXMLLen = 0;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszSourceCollection || NULL == pTargets || NULL == pszDestCollection)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestCollection);
    if (NULL == pszDupDestination)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (NULL == pDestinations)
        hr = HrGenerateSimpleBatchXML(c_szMove, pTargets, &pvXML, &dwXMLLen);
    else
        hr = HrGenerateMultiDestBatchXML(c_szMove, pTargets, pDestinations, &pvXML, &dwXMLLen);

    if (FAILED(hr))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszSourceCollection, pvXML, dwXMLLen, &pOp, TRUE)))
        goto exit;

    pvXML = NULL;

    pOp->command = HTTPMAIL_BMOVE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnBMove;
    pOp->cState = ARRAYSIZE(c_rgpfnBMove);
    pOp->pParseFuncs = c_rgpfnBCopyMoveParse;

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;

    pOp->dwRHFlags = RH_XMLCONTENTTYPE;
    if (fAllowRename)
        pOp->dwRHFlags |= RH_ALLOWRENAME;

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);
    SafeMemFree(pszDupDestination);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::MemberInfo(
                                        LPCSTR pszPath, 
                                        MEMBERINFOFLAGS flags, 
                                        DWORD dwDepth,
                                        BOOL fIncludeRoot,
                                        DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_MEMBERINFO;
    pOp->dwMIFlags = flags;
    pOp->dwDepth = dwDepth;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnMemberInfo;
    pOp->cState = ARRAYSIZE(c_rgpfnMemberInfo);
    pOp->pParseFuncs = c_rgpfnMemberInfoParse;

    pOp->dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);
    if (!fIncludeRoot)
        pOp->dwRHFlags |= RH_NOROOT;

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FindFolders
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::FindFolders(LPCSTR pszPath, DWORD dwContext)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MarkRead
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MarkRead(
                                LPCSTR                  pszPath,
                                LPHTTPTARGETLIST        pTargets,
                                BOOL                    fMarkRead,
                                DWORD                   dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    CPropPatchRequest   *pRequest = NULL;
    LPSTR               pszXML = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pRequest = new CPropPatchRequest();
    if (NULL == pRequest)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    if (fMarkRead)
        FAIL_EXIT(hr = pRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "1"));
    else
        FAIL_EXIT(hr = pRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "0"));
    
    FAIL_EXIT(hr = pRequest->GenerateXML(pTargets, &pszXML));

    FAIL_EXIT(hr = AllocQueuedOperation(pszPath, pszXML, lstrlen(pszXML), &pOp, TRUE));
    pszXML = NULL;
    
    pOp->command = HTTPMAIL_MARKREAD;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnMarkRead;
    pOp->cState = ARRAYSIZE(c_rgpfnMarkRead);
    pOp->pParseFuncs = c_rgpfnMemberErrorParse;

    pOp->dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);
    if (pTargets && pTargets->cTarget > 0)
        pOp->fBatch = TRUE;

    QueueOperation(pOp);

exit:
    SafeRelease(pRequest);
    SafeMemFree(pszXML);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::SendMessage
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::SendMessage(LPCSTR pszPath, 
                                        LPCSTR pszFrom, 
                                        LPHTTPTARGETLIST pTargets, 
                                        BOOL fSaveInSent, 
                                        IStream *pMessageStream, 
                                        DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    IStream             *pRfc821Stream = NULL;

    if (NULL == pszPath || 
            NULL == pszFrom || 
            NULL == pTargets || pTargets->cTarget < 1 ||
            NULL == pMessageStream)
        return E_INVALIDARG;

    FAIL_CREATEWND;

    // build the rfc821 stream that will precede the mime message
    FAIL_EXIT(hr = _HrGenerateRfc821Stream(pszFrom, pTargets, &pRfc821Stream));

    FAIL_EXIT(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp));

    pOp->command = HTTPMAIL_SENDMESSAGE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnSendMessage;
    pOp->cState = ARRAYSIZE(c_rgpfnSendMessage);
    pOp->pHeaderStream = pRfc821Stream;
    pRfc821Stream = NULL;
    pOp->pBodyStream = pMessageStream;
    if (NULL != pOp->pBodyStream)
        pOp->pBodyStream->AddRef();
    pOp->dwRHFlags = (RH_TRANSLATETRUE | RH_SMTPMESSAGECONTENTTYPE);
    pOp->dwRHFlags |= (fSaveInSent ? RH_SAVEINSENTTRUE : RH_SAVEINSENTFALSE);

    QueueOperation(pOp);

exit:
    SafeRelease(pRfc821Stream);

    return hr;

}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContacts
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContacts(LPCSTR pszPath, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_LISTCONTACTS;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnListContacts;
    pOp->cState = ARRAYSIZE(c_rgpfnListContacts);
    pOp->pParseFuncs = c_rgpfnListContactsParse;

    pOp->dwDepth = 1;
    pOp->dwRHFlags = (RH_NOROOT | RH_XMLCONTENTTYPE);

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContactInfos
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContactInfos(LPCSTR pszCollectionPath, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszCollectionPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszCollectionPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_CONTACTINFO;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnContactInfo;
    pOp->cState = ARRAYSIZE(c_rgpfnContactInfo);
    pOp->pParseFuncs = c_rgpfnContactInfoParse;

    pOp->dwDepth = 1;
    pOp->dwRHFlags = (RH_NOROOT | RH_XMLCONTENTTYPE);

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ContactInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ContactInfo(LPCSTR pszPath, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_CONTACTINFO;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnContactInfo;
    pOp->cState = ARRAYSIZE(c_rgpfnContactInfo);
    pOp->pParseFuncs = c_rgpfnContactInfoParse;

    pOp->dwDepth = 0;
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PostContact
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PostContact(LPCSTR pszPath, 
                                        LPHTTPCONTACTINFO pciInfo, 
                                        DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    LPVOID              pvXML = NULL;
    DWORD               cb;

    if (NULL == pciInfo)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = HrGeneratePostContactXML(pciInfo, &pvXML, &cb)))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->pvData = pvXML;
    pOp->cbDataLen = cb;
    pvXML = NULL;

    pOp->command = HTTPMAIL_POSTCONTACT;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPostContact;
    pOp->cState = ARRAYSIZE(c_rgpfnPostContact);

    pOp->dwDepth = 0;
    pOp->dwRHFlags = (RH_XMLCONTENTTYPE | RH_TRANSLATEFALSE);

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PatchContact
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PatchContact(LPCSTR pszPath, 
                                         LPHTTPCONTACTINFO pciInfo, 
                                         DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    IPropPatchRequest   *pRequest = NULL;

    if (NULL == pciInfo)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = HrCreatePatchContactRequest(pciInfo, &pRequest)))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_PATCHCONTACT;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPatchContact;
    pOp->cState = ARRAYSIZE(c_rgpfnPatchContact);

    pOp->pPropPatchRequest = pRequest;
    pRequest = NULL;

    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    SafeRelease(pRequest);

    return hr;
}

// --------------------------------------------------------------------------------
// INodeFactory Methods
// --------------------------------------------------------------------------------
 
// --------------------------------------------------------------------------------
// CHTTPMailTransport::NotifyEvent
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::NotifyEvent(IXMLNodeSource* pSource, 
                                             XML_NODEFACTORY_EVENT iEvt)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::BeginChildren
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::BeginChildren(IXMLNodeSource* pSource, XML_NODE_INFO *pNodeInfo)
{
    if (m_op.dwStackDepth <= ELE_STACK_CAPACITY)
        m_op.rgEleStack[m_op.dwStackDepth - 1].fBeganChildren = TRUE;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::EndChildren
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::EndChildren(
                                    IXMLNodeSource* pSource, 
                                    BOOL fEmpty, 
                                    XML_NODE_INFO *pNodeInfo)
{
    HRESULT hr = S_OK;

    IxpAssert(HTTPMAIL_NONE != m_op.rResponse.command);
    IxpAssert(NULL != m_op.pParseFuncs);

    if (HTTPMAIL_NONE == m_op.rResponse.command || NULL == m_op.pParseFuncs)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (XML_ELEMENT == pNodeInfo->dwType)
        hr = (this->*(m_op.pParseFuncs->pfnEndChildren))();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Error
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::Error(IXMLNodeSource* pSource, 
                                       HRESULT hrErrorCode, 
                                       USHORT cNumRecs, 
                                       XML_NODE_INFO** apNodeInfo)
{
    BSTR  bstr = NULL;

    if (NULL == m_op.rResponse.rIxpResult.pszResponse)
    {
        if (FAILED(pSource->GetErrorInfo(&bstr)))
            goto exit;
    
        HrBSTRToLPSZ(CP_ACP, bstr, &m_op.rResponse.rIxpResult.pszResponse);
    }

exit:
    if (NULL != bstr)
        SysFreeString(bstr);

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CreateNode
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CreateNode(
                        IXMLNodeSource* pSource, 
                        PVOID pNodeParent,
                        USHORT cNumRecs,
                        XML_NODE_INFO** apNodeInfo)
{
    HRESULT         hr = S_OK;
    LPPCDATABUFFER  pTextBuffer = NULL;
    CXMLNamespace   *pBaseNamespace = m_op.pTopNamespace;
    XML_NODE_INFO   *pNodeInfo;

    IxpAssert(HTTPMAIL_NONE != m_op.rResponse.command);
    IxpAssert(NULL != m_op.pParseFuncs);

    if (HTTPMAIL_NONE == m_op.rResponse.command || NULL == m_op.pParseFuncs)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (NULL == apNodeInfo || 0 == cNumRecs)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pNodeInfo = apNodeInfo[0];

    switch (pNodeInfo->dwType)
    {
        case XML_ELEMENT:
            if (cNumRecs > 1 && FAILED(hr = PushNamespaces(apNodeInfo, cNumRecs)))
                goto exit;
            hr = (this->*(m_op.pParseFuncs->pfnCreateElement))(pBaseNamespace, pNodeInfo->pwcText, pNodeInfo->ulLen, pNodeInfo->ulNsPrefixLen, pNodeInfo->fTerminal);
            break;

        case XML_PCDATA:
            // we only parse element content...we don't care about attributes
            if (InValidElementChildren())
            {
                // get the buffer
                pTextBuffer = m_op.rgEleStack[m_op.dwStackDepth - 1].pTextBuffer;

                // request one if we don't already have one
                if (NULL == pTextBuffer)
                {
                    if (FAILED(hr = _GetTextBuffer(&pTextBuffer)))
                        goto exit;
                    m_op.rgEleStack[m_op.dwStackDepth - 1].pTextBuffer = pTextBuffer;
                }
                
                hr = _AppendTextToBuffer(pTextBuffer, pNodeInfo->pwcText, pNodeInfo->ulLen);
                    goto exit;
            }
            break;
            
        default:
            break;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrThunkConnectionError
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrThunkConnectionError(void)
{
    return _HrThunkConnectionError(m_op.dwHttpStatus);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrThunkConnectionError
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrThunkConnectionError(DWORD dwStatus)
{
    IxpAssert(NULL == m_op.rResponse.rIxpResult.pszResponse);
    IxpAssert(NULL == m_op.rResponse.rIxpResult.pszProblem);

    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    m_op.rResponse.rIxpResult.hrResult = HttpErrorToIxpResult(dwStatus);
    _GetRequestHeader(&m_op.rResponse.rIxpResult.pszResponse, HTTP_QUERY_STATUS_TEXT);
    m_op.rResponse.rIxpResult.dwSocketError = GetLastError();

    return _HrThunkResponse(TRUE);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrThunkResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrThunkResponse(BOOL fDone)
{
    HRESULT     hr = S_OK;
    BOOL        fSendResponse;

    // Thread safety
    EnterCriticalSection(&m_cs);

    IxpAssert(HTTPMAIL_NONE != m_op.rResponse.command);

    if (m_op.rResponse.fDone)
    {
        fSendResponse = FALSE;
    }
    else
    {
        fSendResponse = TRUE;

        if (!fDone && WasAborted())
        {
            m_op.rResponse.rIxpResult.hrResult = IXP_E_USER_CANCEL;
            m_op.rResponse.fDone = TRUE;
        }
        else
            m_op.rResponse.fDone = fDone;
    }

    LeaveCriticalSection(&m_cs);

    if (fSendResponse)
        hr = (HRESULT) ::SendMessage(m_hwnd, SPM_HTTPMAIL_SENDRESPONSE, 0, NULL);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InvokeResponseCallback
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InvokeResponseCallback(void)
{
    HRESULT             hr = S_OK;
    IHTTPMailCallback   *pCallback = NULL;

    EnterCriticalSection(&m_cs);

    if (m_pCallback)
    {
        pCallback = m_pCallback;
        pCallback->AddRef();
    }

    LeaveCriticalSection(&m_cs);

    if (pCallback)
    {
        hr = pCallback->OnResponse(&m_op.rResponse);
        pCallback->Release();
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::InitNew(
                    LPCSTR pszUserAgent,
                    LPCSTR pszLogFilePath, 
                    IHTTPMailCallback *pCallback)
{   
    HRESULT hr = S_OK;

    if (NULL == pszUserAgent || NULL == pCallback)
        return TrapError(E_INVALIDARG);

    IxpAssert(NULL == m_hInternet);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    if (IXP_DISCONNECTED != m_status)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    Reset();

    m_pszUserAgent = PszDupA(pszUserAgent);
    if (NULL == m_pszUserAgent)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // open log file
    if (pszLogFilePath)
        CreateLogFile(g_hInst, pszLogFilePath, "HTTPMAIL", DONT_TRUNCATE, &m_pLogFile,
            FILE_SHARE_READ | FILE_SHARE_WRITE);
    
    m_pCallback = pCallback;
    m_pCallback->AddRef();

    m_hInternet = InternetOpen(m_pszUserAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (NULL == m_hInternet)
    {
        hr = TrapError(IXP_E_SOCKET_INIT_ERROR);
        goto exit;
    }
        
    // Install the callback ptr for the internet handle and all of its derived handles
    //InternetSetStatusCallbackA(m_hInternet, StatusCallbackProxy);

exit:
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::OnStatusCallback
// --------------------------------------------------------------------------------
void CHTTPMailTransport::OnStatusCallback(
                    HINTERNET hInternet,
                    DWORD dwInternetStatus,
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength)
{
#if 0
    // Locals
    IXPSTATUS           ixps;

    EnterCriticalSection(&m_cs);

    // if the status message is one of the defined IXPSTATUS messages,
    // notify the callback.
    if ((NULL != m_pCallback) && TranslateWinInetMsg(dwInternetStatus, &ixps))
        m_pCallback->OnStatus(ixps, (IHTTPMailTransport *)this);

    // for now, we just handle the request_complete message
    if (INTERNET_STATUS_REQUEST_COMPLETE == dwInternetStatus)
        HrCommandCompleted();

    LeaveCriticalSection(&m_cs);
#endif
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::AllocQueuedOperation
// ----------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AllocQueuedOperation(
                                    LPCSTR pszUrl, 
                                    LPVOID pvData, 
                                    ULONG cbDataLen,
                                    LPHTTPQUEUEDOP *ppOp,
                                    BOOL fAdoptData)
{
    HRESULT hr = S_OK;
    LPHTTPQUEUEDOP pTempOp = NULL;

    if (!MemAlloc((void **)&pTempOp , sizeof(HTTPQUEUEDOP)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pTempOp, sizeof(HTTPQUEUEDOP));
    
    if (NULL != pszUrl)
    {
        pTempOp->pszUrl = PszDupA(pszUrl);
        if (NULL == pTempOp->pszUrl)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }
    
    // can't have a length if data ptr is null
    IxpAssert(!pvData || cbDataLen);
    if (pvData)
    {
        if (!fAdoptData)
        {
            if (!MemAlloc((LPVOID*)&pTempOp->pvData, cbDataLen + 1))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            CopyMemory(pTempOp->pvData, pvData, cbDataLen);
            ((char *)pTempOp->pvData)[cbDataLen] = '\0';
        }
        else
            pTempOp->pvData = pvData;

        pTempOp->cbDataLen = cbDataLen;
    }

    *ppOp = pTempOp;
    pTempOp = NULL;

exit:
    if (pTempOp)
    {
        SafeMemFree(pTempOp->pszUrl);
        if (!fAdoptData)
            SafeMemFree(pTempOp->pvData);

        MemFree(pTempOp);
    }

    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::QueueOperation
// ----------------------------------------------------------------------------
void CHTTPMailTransport::QueueOperation(LPHTTPQUEUEDOP pOp)
{
    // Thread safety
    EnterCriticalSection(&m_cs);

    if (m_opPendingTail)
        m_opPendingTail->pNext = pOp;
    else
    {
        // if there is no tail, there shouldn't be a head
        IxpAssert(!m_opPendingHead);
        m_opPendingHead = m_opPendingTail = pOp;
    }

    // signal the io thread
    SetEvent(m_hevPendingCommand);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StatusCallbackProxy
// --------------------------------------------------------------------------------
void CHTTPMailTransport::StatusCallbackProxy(
                    HINTERNET hInternet, 
                    DWORD dwContext, 
                    DWORD dwInternetStatus, 
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength)
{
    // Locals
    CHTTPMailTransport  *pHTTPMail = reinterpret_cast<CHTTPMailTransport *>(IntToPtr(dwContext));

    IxpAssert(NULL != pHTTPMail);
    
    if (NULL != pHTTPMail)
        pHTTPMail->OnStatusCallback(hInternet, dwInternetStatus, pvStatusInformation, dwStatusInformationLength);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DoOperation
// --------------------------------------------------------------------------------
void CHTTPMailTransport::DoOperation(void)
{
    HRESULT hr = S_OK;

    while (m_op.iState < m_op.cState)
    {
        hr = (this->*(m_op.pfnState[m_op.iState]))();

        if (FAILED(hr))
            break;

        m_op.iState++;
    }

    if (!m_op.rResponse.fDone && FAILED(hr))
    {
        m_op.rResponse.rIxpResult.hrResult = hr;
        _HrThunkResponse(TRUE);
    }

    FreeOperation();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeOperation
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeOperation(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    SafeMemFree(m_op.pszUrl);
    SafeMemFree(m_op.pszDestination);
    if (m_op.pszContentType)
    {
        MemFree((void *)m_op.pszContentType);
        m_op.pszContentType = NULL;

    }
    SafeMemFree(m_op.pvData);
    SafeInternetCloseHandle(m_op.hRequest);
    SafeRelease(m_op.pPropFindRequest);
    SafeRelease(m_op.pPropPatchRequest);
    if (NULL != m_op.rgszAcceptTypes)
        FreeStringList(m_op.rgszAcceptTypes);
    SafeRelease(m_op.pHeaderStream);
    SafeRelease(m_op.pBodyStream);

    if (m_op.pTextBuffer)
        _FreeTextBuffer(m_op.pTextBuffer);

    // Free the response
    SafeMemFree(m_op.rResponse.rIxpResult.pszResponse);
    SafeMemFree(m_op.rResponse.rIxpResult.pszProblem);

    PopNamespaces(NULL);

    // in the case of an error, the element stack can
    // contain text buffers that need to be freed
    for (DWORD i = 0; i < m_op.dwStackDepth; ++i)
    {
        if (NULL != m_op.rgEleStack[i].pTextBuffer)
            _FreeTextBuffer(m_op.rgEleStack[i].pTextBuffer);
    }

    SafeMemFree(m_op.rResponse.rIxpResult.pszResponse);

    switch (m_op.rResponse.command)
    {
        case HTTPMAIL_GET:
            SafeMemFree(m_op.rResponse.rGetInfo.pvBody);
            SafeMemFree(m_op.rResponse.rGetInfo.pszContentType);
            break;

        case HTTPMAIL_POST:
        case HTTPMAIL_SENDMESSAGE:
            SafeMemFree(m_op.rResponse.rPostInfo.pszLocation);
            break;

        case HTTPMAIL_COPY:
        case HTTPMAIL_MOVE:
        case HTTPMAIL_MKCOL:
            SafeMemFree(m_op.rResponse.rCopyMoveInfo.pszLocation);
            break;

        case HTTPMAIL_BCOPY:
        case HTTPMAIL_BMOVE:
            SafeMemFree(m_op.rResponse.rBCopyMoveList.prgBCopyMove);
            break;
        
        case HTTPMAIL_MEMBERINFO:
            FreeMemberInfoList();
            SafeMemFree(m_op.rResponse.rMemberInfoList.prgMemberInfo);
            SafeMemFree(m_op.pszRootTimeStamp);
            SafeMemFree(m_op.pszFolderTimeStamp);
            SafeMemFree(m_op.rResponse.rMemberInfoList.pszRootTimeStamp);
            SafeMemFree(m_op.rResponse.rMemberInfoList.pszFolderTimeStamp);
            break;

        case HTTPMAIL_MARKREAD:
            FreeMemberErrorList();
            SafeMemFree(m_op.rResponse.rMemberErrorList.prgMemberError);
            break;


        case HTTPMAIL_LISTCONTACTS:
            FreeContactIdList();
            SafeMemFree(m_op.rResponse.rContactIdList.prgContactId);
            break;

        case HTTPMAIL_CONTACTINFO:
            FreeContactInfoList();
            SafeMemFree(m_op.rResponse.rContactInfoList.prgContactInfo);
            break;

        case HTTPMAIL_POSTCONTACT:
            XP_FREE_STRUCT(HTTPCONTACTID, &m_op.rResponse.rPostContactInfo, NULL);
            break;
           
        case HTTPMAIL_PATCHCONTACT:
            XP_FREE_STRUCT(HTTPCONTACTID, &m_op.rResponse.rPatchContactInfo, NULL);
            break;

        default:
            break;
    }

    ZeroMemory(&m_op, sizeof(HTTPMAILOPERATION));
    m_op.rResponse.command = HTTPMAIL_NONE;
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_BindToStruct
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_BindToStruct(const WCHAR *pwcText,
                                          ULONG ulLen,
                                          const XPCOLUMN *prgCols,
                                          DWORD cCols,
                                          LPVOID pTarget,
                                          BOOL *pfWasBound)
{
    HRESULT                 hr = S_OK;
    DWORD                   dwColIndex;
    DWORD                   dwColFlags;
    LPSTR                   *ppsz;
    DWORD                   *pdw;
    BOOL                    *pb;
    HTTPMAILSPECIALFOLDER   *ptySpecial;
    HTTPMAILCONTACTTYPE     *ptyContact;
    HMELE                   ele;
    HRESULT                 *phr;

    if (pfWasBound)
        *pfWasBound = FALSE;

    // if the stack is overflowed, we definitely won't do anything with the text
    if (m_op.dwStackDepth >= ELE_STACK_CAPACITY)
        goto exit;

    ele = m_op.rgEleStack[m_op.dwStackDepth - 1].ele;

    for (dwColIndex = 0; dwColIndex < cCols; dwColIndex++)
    {
        if (ele == prgCols[dwColIndex].ele)
            break;
    }

    if (dwColIndex >= cCols)
        goto exit;

    dwColFlags = prgCols[dwColIndex].dwFlags;

    // the column may require validation of the element stack
    if (!!(dwColFlags & XPCF_MSVALIDPROP))
    {
        if (!VALIDSTACK(c_rgPropFindPropValueStack))
            goto exit;
    }
    else if (!!(dwColFlags & XPCF_MSVALIDMSRESPONSECHILD))
    {
        if (!VALIDSTACK(c_rgMultiStatusResponseChildStack))
            goto exit;
    }

    if (dwColIndex < cCols)
    {
        switch (prgCols[dwColIndex].cdt)
        {
            case XPCDT_STRA:
                ppsz = (LPSTR *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                SafeMemFree(*ppsz);
                hr = AllocStrFromStrNW(pwcText, ulLen, ppsz);
                break;

            case XPCDT_DWORD:
                pdw = (DWORD *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *pdw = 0;
                hr = StrNToDwordW(pwcText, ulLen, pdw);
                break;

            case XPCDT_BOOL:
                pb = (BOOL *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *pb = FALSE;
                hr = StrNToBoolW(pwcText, ulLen, pb);
                break;

            case XPCDT_IXPHRESULT:
                phr = (HRESULT *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *phr = S_OK;
                hr = StatusStrNToIxpHr(pwcText, ulLen, phr);
                break;

            case XPCDT_HTTPSPECIALFOLDER:
                ptySpecial = (HTTPMAILSPECIALFOLDER *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *ptySpecial = HTTPMAIL_SF_NONE;
                hr = StrNToSpecialFolderW(pwcText, ulLen, ptySpecial);
                break;

            case XPCDT_HTTPCONTACTTYPE:
                ptyContact = (HTTPMAILCONTACTTYPE *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *ptyContact = HTTPMAIL_CT_CONTACT;
                hr = StrNToContactTypeW(pwcText, ulLen, ptyContact);
                break;

            default:
                IxpAssert(FALSE);
                break;
        }

        if (FAILED(hr))
            goto exit;

        // set the bit in the flag word to indicate that this field
        // has been set.
        if (!(dwColFlags & XPCF_DONTSETFLAG))
            m_op.dwPropFlags |= (1 << dwColIndex);

        if (pfWasBound)
            *pfWasBound = TRUE;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_FreeStruct
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_FreeStruct(const XPCOLUMN *prgCols,
                                     DWORD cCols,
                                     LPVOID pTarget,
                                     DWORD *pdwFlags)
{
    DWORD                   dwFlags;
    DWORD                   dwIndex = 0;
    LPSTR                   *ppsz;
    DWORD                   *pdw;
    BOOL                    *pb;
    HTTPMAILSPECIALFOLDER   *ptySpecial;
    HTTPMAILCONTACTTYPE     *ptyContact;
    HRESULT                 *phr;

    if (NULL != pdwFlags)
    {   
        dwFlags = *pdwFlags;
        *pdwFlags = NOFLAGS;
    }   
    else
        dwFlags = 0xFFFFFFFF;

    while (0 != dwFlags && dwIndex < cCols)
    {
        // test the low bit
        if (!!(dwFlags & 0x00000001))
        {
            switch (prgCols[dwIndex].cdt)
            {
                case XPCDT_STRA:
                    ppsz = (LPSTR *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    SafeMemFree(*ppsz);
                    break;

                case XPCDT_DWORD:
                    pdw = (DWORD *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *pdw = 0;
                    break;

                case XPCDT_BOOL:
                    pb = (BOOL *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *pb = FALSE;
                    break;

                case XPCDT_IXPHRESULT:
                    phr = (HRESULT *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *phr = S_OK;
                    break;

                case XPCDT_HTTPSPECIALFOLDER:
                    ptySpecial = (HTTPMAILSPECIALFOLDER *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *ptySpecial = HTTPMAIL_SF_NONE;
                    break;

                case XPCDT_HTTPCONTACTTYPE:
                    ptyContact = (HTTPMAILCONTACTTYPE *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *ptyContact = HTTPMAIL_CT_CONTACT;
                    break;

                default:
                    IxpAssert(FALSE);
                    break;
            }
        }
        
        dwFlags >>= 1;
        dwIndex++;
    }
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AppendTextToBuffer
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_AppendTextToBuffer(LPPCDATABUFFER pTextBuffer, 
                                                const WCHAR *pwcText, 
                                                ULONG ulLen)
{
    HRESULT hr = S_OK;
    ULONG ulNewCapacity = pTextBuffer->ulLen + ulLen;

    IxpAssert(ulLen > 0);

    // grow the buffer if necessary, and append the text
    if (pTextBuffer->ulCapacity < ulNewCapacity)
    {
        if (!MemRealloc((void **)&(pTextBuffer->pwcText), sizeof(WCHAR) * ulNewCapacity))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pTextBuffer->ulCapacity = ulNewCapacity;
    }

    // copy the new text over. special case the one-byte case to avoid
    // calls to CopyMemory when we see one character entities
    if (1 == ulLen)
    {
        pTextBuffer->pwcText[pTextBuffer->ulLen++] = *pwcText;
    }
    else
    {
        CopyMemory(&pTextBuffer->pwcText[pTextBuffer->ulLen], pwcText, sizeof(WCHAR) * ulLen);
        pTextBuffer->ulLen += ulLen;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AllocTextBuffer
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_AllocTextBuffer(LPPCDATABUFFER *ppTextBuffer)
{
    HRESULT hr = S_OK;

    IxpAssert(NULL != ppTextBuffer);

    *ppTextBuffer = NULL;

    if (!MemAlloc((void **)ppTextBuffer, sizeof(PCDATABUFFER)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // allocate the buffer
    if (!MemAlloc((void **)(&((*ppTextBuffer)->pwcText)), PCDATA_BUFSIZE * sizeof(WCHAR)))
    {
        MemFree(*ppTextBuffer);
        *ppTextBuffer = NULL;

        hr = E_OUTOFMEMORY;
        goto exit;
    }

    (*ppTextBuffer)->ulLen = 0;
    (*ppTextBuffer)->ulCapacity = PCDATA_BUFSIZE ;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeTextBuffer
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_FreeTextBuffer(LPPCDATABUFFER pTextBuffer)
{
    if (pTextBuffer)
    {
        if (pTextBuffer->pwcText)
            MemFree(pTextBuffer->pwcText);

        MemFree(pTextBuffer);
    }
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeMemberInfoList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeMemberInfoList(void)
{
    DWORD               cInfo = m_op.rResponse.rMemberInfoList.cMemberInfo;
    LPHTTPMEMBERINFO    rgInfo = m_op.rResponse.rMemberInfoList.prgMemberInfo;

    // free the completed infos
    for (DWORD i = 0; i < cInfo; i++)
        XP_FREE_STRUCT(HTTPMEMBERINFO, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < MEMBERINFO_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPMEMBERINFO, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rMemberInfoList.cMemberInfo= 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeMemberErrorList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeMemberErrorList(void)
{
    DWORD               cInfo = m_op.rResponse.rMemberErrorList.cMemberError;
    LPHTTPMEMBERERROR   rgInfo = m_op.rResponse.rMemberErrorList.prgMemberError;

    // free the completed infos
    for (DWORD i = 0; i < cInfo; i++)
        XP_FREE_STRUCT(HTTPMEMBERERROR, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < MEMBERERROR_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPMEMBERERROR, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rMemberErrorList.cMemberError = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeContactIdList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeContactIdList(void)
{
    DWORD cId = m_op.rResponse.rContactIdList.cContactId;
    LPHTTPCONTACTID rgId = m_op.rResponse.rContactIdList.prgContactId;

    // free the completed ids
    for (DWORD i = 0; i < cId; ++i)
        XP_FREE_STRUCT(HTTPCONTACTID, &rgId[i], NULL);

    // free the partial id
    if (m_op.dwPropFlags)
    {
        IxpAssert(cId < LISTCONTACTS_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPCONTACTID, &rgId[cId], &m_op.dwPropFlags);

        m_op.dwPropFlags = NOFLAGS;
    }

    m_op.rResponse.rContactIdList.cContactId = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeContactInfoList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeContactInfoList(void)
{
    DWORD cInfo = m_op.rResponse.rContactInfoList.cContactInfo;
    LPHTTPCONTACTINFO rgInfo = m_op.rResponse.rContactInfoList.prgContactInfo;

    // free the completed ids
    for (DWORD i = 0; i < cInfo; ++i)
        XP_FREE_STRUCT(HTTPCONTACTINFO, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < CONTACTINFO_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPCONTACTINFO, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rContactInfoList.cContactInfo = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeBCopyMoveList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeBCopyMoveList(void)
{
    DWORD cInfo = m_op.rResponse.rBCopyMoveList.cBCopyMove;
    LPHTTPMAILBCOPYMOVE rgInfo = m_op.rResponse.rBCopyMoveList.prgBCopyMove;

    // free the completed records
    for (DWORD i = 0; i < cInfo; ++i)
        XP_FREE_STRUCT(HTTPMAILBCOPYMOVE, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < BCOPYMOVE_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPMAILBCOPYMOVE, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rBCopyMoveList.cBCopyMove = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ValidStack
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::ValidStack(const HMELE *prgEle, DWORD cEle)
{
    BOOL bResult = TRUE;
    DWORD dw;

    if (cEle != m_op.dwStackDepth)
    {
        bResult = FALSE;
        goto exit;
    }

    IxpAssert(cEle <= ELE_STACK_CAPACITY);

    for (dw = 0; dw < cEle; ++dw)
    {
        if (prgEle[dw] != HMELE_UNKNOWN && prgEle[dw] != m_op.rgEleStack[dw].ele)
        {
            bResult = FALSE;
            goto exit;
        }
    }

exit:
    return bResult;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PopNamespaces
// --------------------------------------------------------------------------------
void CHTTPMailTransport::PopNamespaces(CXMLNamespace *pBaseNamespace)
{
    CXMLNamespace *pTemp;

    while (pBaseNamespace != m_op.pTopNamespace)
    {
        IxpAssert(m_op.pTopNamespace);
        pTemp = m_op.pTopNamespace->GetParent();
        m_op.pTopNamespace->Release();
        m_op.pTopNamespace = pTemp;
    }
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PushNamespaces
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PushNamespaces(XML_NODE_INFO** apNodeInfo, USHORT cNumRecs)
{
    HRESULT         hr = S_OK;
    CXMLNamespace   *pNamespace = NULL;

    for (USHORT i = 0; i < cNumRecs; ++i)
    {
        if (apNodeInfo[i]->dwType == XML_ATTRIBUTE && apNodeInfo[i]->dwSubType == XML_NS)
        {
            // better have at least one more record
            IxpAssert(i < (cNumRecs - 1));
            if (i < (cNumRecs - 1) && apNodeInfo[i + 1]->dwType == XML_PCDATA)
            {
                pNamespace = new CXMLNamespace();
                if (!pNamespace)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }

                if (apNodeInfo[i]->ulLen != apNodeInfo[i]->ulNsPrefixLen)
                {
                    if (FAILED(hr = pNamespace->SetPrefix(
                                        &apNodeInfo[i]->pwcText[apNodeInfo[i]->ulNsPrefixLen + 1],
                                        apNodeInfo[i]->ulLen - (apNodeInfo[i]->ulNsPrefixLen + 1))))
                        goto exit;
                }

                if (FAILED(hr = pNamespace->SetNamespace(apNodeInfo[i + 1]->pwcText, apNodeInfo[i + 1]->ulLen)))
                    goto exit;

                pNamespace->SetParent(m_op.pTopNamespace);
                if (m_op.pTopNamespace)
                    m_op.pTopNamespace->Release();
                m_op.pTopNamespace = pNamespace;
                pNamespace = NULL;
            }
        }
    }

exit:
    SafeRelease(pNamespace);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AllocStrFromStrW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AllocStrFromStrNW(
                                const WCHAR *pwcText, 
                                ULONG ulLen, 
                                LPSTR *ppszAlloc)
{
    HRESULT     hr = S_OK;
    DWORD       iBufferSize;
    DWORD       iConvertedChars;

    IxpAssert(NULL != ppszAlloc);

    if (NULL == ppszAlloc)
        return E_INVALIDARG;

    *ppszAlloc = NULL;

    // if pwcText is NULL, the result is null, but not an error
    if (NULL == pwcText)
        goto exit;

    iBufferSize = WideCharToMultiByte(CP_ACP, 0, pwcText, ulLen, NULL, 0, NULL, NULL);
    if (0 == iBufferSize)
    {
        m_op.rResponse.rIxpResult.uiServerError = GetLastError();
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // allocate the buffer (add 1 to the size to allow for eos)
    if (!MemAlloc((void **)ppszAlloc, iBufferSize + 1))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // convert the string
    iConvertedChars = WideCharToMultiByte(CP_ACP, 0, pwcText, ulLen, *ppszAlloc, iBufferSize, NULL, NULL);
    if (0 == iConvertedChars)
    {
        m_op.rResponse.rIxpResult.uiServerError = GetLastError();
        hr = TrapError(E_FAIL);
        goto exit;
    }

    IxpAssert(iConvertedChars == iBufferSize);
    // terminate the new string
    (*ppszAlloc)[iConvertedChars] = 0;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToDwordW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToDwordW(const WCHAR *pwcText, ULONG ulLen, DWORD *pdw)
{
    HRESULT     hr = S_OK;
    int         i;
    WCHAR       wcBuf[32];
    WCHAR       *pwcUseBuf;
    BOOL        fFreeBuf = FALSE;

    IxpAssert(NULL != pdw);
    
    if (NULL == pdw)
        return E_INVALIDARG;

    *pdw = 0;

    if (NULL == pwcText)
        goto exit;

    // decide whether to use a local buffer or an allocated buffer
    if (ulLen < 32)
        pwcUseBuf = wcBuf;
    else
    {
        if (!MemAlloc((void **)&pwcUseBuf, (ulLen + 1) * sizeof(WCHAR)))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        fFreeBuf = TRUE;
    }

    // copy the string over
    CopyMemory(pwcUseBuf, pwcText, ulLen * sizeof(WCHAR));
    pwcUseBuf[ulLen] = 0;

    *pdw = StrToIntW(pwcUseBuf);

exit:
    if (fFreeBuf)
        MemFree(pwcUseBuf);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToSpecialFolderW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToSpecialFolderW(const WCHAR *pwcText, 
                                                 ULONG ulLen, 
                                                 HTTPMAILSPECIALFOLDER *ptySpecial)
{
    HRESULT     hr = S_OK;

    if (NULL == ptySpecial)
        return E_INVALIDARG;

    *ptySpecial = HTTPMAIL_SF_UNRECOGNIZED;

    if (NULL != pwcText && ulLen > 0)
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(c_rgpfnSpecialFolder); dw++)
        {
            if (ulLen == c_rgpfnSpecialFolder[dw].ulLen)
            {
                if (0 == StrCmpNW(c_rgpfnSpecialFolder[dw].pwcName, pwcText, ulLen))
                {
                    *ptySpecial = c_rgpfnSpecialFolder[dw].tyFolder;
                    break;
                }
            }
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToContactTypeW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToContactTypeW(const WCHAR *pwcText, 
                                                 ULONG ulLen, 
                                                 HTTPMAILCONTACTTYPE *ptyContact)
{
    HRESULT hr = S_OK;
    BOOL    fGroup = FALSE;

    IxpAssert(NULL != ptyContact);

    if (NULL == ptyContact)
        return E_INVALIDARG;

    // for now, we treat the presence of the <group> element as an indication that
    // the contact is a group
    *ptyContact = HTTPMAIL_CT_GROUP;

#if 0

    // for now, we treat the value as an integer-based bool
    hr = StrNToBoolW(pwcText, ulLen, &fGroup);

    // default is contact
    *ptyContact = fGroup ? HTTPMAIL_CT_GROUP : HTTPMAIL_CT_CONTACT;
#endif

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToBoolW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToBoolW(const WCHAR *pwcText, DWORD ulLen, BOOL *pb)
{
    HRESULT     hr = S_OK;
    DWORD       dw;

    IxpAssert(NULL != pb);

    if (NULL == pb)
        return E_INVALIDARG;

    *pb = FALSE;

    if (NULL == pwcText)
        goto exit;

    if (FAILED(hr = StrNToDwordW(pwcText, ulLen, &dw)))
        goto exit;

    if (dw != 0)
        *pb = TRUE;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StatusStrNToIxpHr
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StatusStrNToIxpHr(const WCHAR *pwcText, DWORD ulLen, HRESULT *phr)
{
    HRESULT     hr = S_OK;
    DWORD       dw;
    LPSTR       pszStatus = NULL;
    DWORD       dwStatus = 0;

    IxpAssert(NULL != phr);

    if (NULL == phr)
        return E_INVALIDARG;

    *phr = S_OK;

    if (NULL == pwcText)
        goto exit;

    if (FAILED(hr = AllocStrFromStrNW(pwcText, ulLen, &pszStatus)) || NULL == pszStatus)
        goto exit;

    HrParseHTTPStatus(pszStatus, &dwStatus);

    if (dwStatus < 200 || dwStatus > 299)
        *phr = HttpErrorToIxpResult(dwStatus);

exit:
    SafeMemFree(pszStatus);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandToVerb
// --------------------------------------------------------------------------------
LPSTR CHTTPMailTransport::CommandToVerb(HTTPMAILCOMMAND command)
{
    LPSTR pszVerb = NULL;

   // convert the command to a string
    switch (command)
    {
    case HTTPMAIL_GET:
        pszVerb = "GET";
        break;

    case HTTPMAIL_POST:
    case HTTPMAIL_SENDMESSAGE:
        pszVerb = "POST";
        break;

    case HTTPMAIL_PUT:
        pszVerb = "PUT";
        break;

    case HTTPMAIL_GETPROP:
    case HTTPMAIL_PROPFIND:
    case HTTPMAIL_MEMBERINFO:
    case HTTPMAIL_LISTCONTACTS:
    case HTTPMAIL_CONTACTINFO:
        pszVerb = "PROPFIND";
        break;

    case HTTPMAIL_MARKREAD:
        if (m_op.fBatch)
            pszVerb = "BPROPPATCH";
        else
            pszVerb = "PROPPATCH";
        break;

    case HTTPMAIL_MKCOL:
        pszVerb = "MKCOL";
        break;

    case HTTPMAIL_COPY:
        pszVerb = "COPY";
        break;

    case HTTPMAIL_BCOPY:
        pszVerb = "BCOPY";
        break;

    case HTTPMAIL_MOVE:
        pszVerb = "MOVE";
        break;

    case HTTPMAIL_BMOVE:
        pszVerb = "BMOVE";
        break;

    case HTTPMAIL_PROPPATCH:
        pszVerb = "PROPPATCH";
        break;

    case HTTPMAIL_DELETE:
        pszVerb = "DELETE";
        break;

    case HTTPMAIL_BDELETE:
        pszVerb = "BDELETE";
        break;

    case HTTPMAIL_POSTCONTACT:
        // first post the contact, then do a propfind
        if (NULL == m_op.rResponse.rPostContactInfo.pszHref)
            pszVerb = "POST";
        else
            pszVerb = "PROPFIND";
        break;

    case HTTPMAIL_PATCHCONTACT:
        // first patch the contact, then do a propfind
        if (NULL == m_op.rResponse.rPatchContactInfo.pszHref)
            pszVerb = "PROPPATCH";
        else
            pszVerb = "PROPFIND";
        break;


    default:
        pszVerb = "";
        IxpAssert(FALSE);
        break;
    }

    return pszVerb;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::UpdateLogonInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::UpdateLogonInfo(void)
{
    // send the message synchronously
    return (HRESULT) (::SendMessage(m_hwnd, SPM_HTTPMAIL_LOGONPROMPT, NULL, NULL));
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetParentWindow
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::GetParentWindow(HWND *phwndParent)
{
    // send the message synchronously
    return (HRESULT) (::SendMessage(m_hwnd, SPM_HTTPMAIL_GETPARENTWINDOW, (WPARAM)phwndParent, NULL));
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ReadBytes
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::ReadBytes(LPSTR pszBuffer, DWORD cbBufferSize, DWORD *pcbBytesRead)
{
    return InternetReadFile(m_op.hRequest, pszBuffer, cbBufferSize, pcbBytesRead);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetStatusCode
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::_GetStatusCode(DWORD *pdw)
{
    IxpAssert(NULL != pdw);

    DWORD dwStatusSize = sizeof(DWORD);
    *pdw = 0;
    return HttpQueryInfo(m_op.hRequest, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, pdw, &dwStatusSize, NULL);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetContentLength
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::_GetContentLength(DWORD *pdw)
{
    IxpAssert(NULL != pdw);

    DWORD dwLengthSize = sizeof(DWORD);
    *pdw = 0;
    return HttpQueryInfo(m_op.hRequest, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, pdw, &dwLengthSize, NULL);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetRequestHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_GetRequestHeader(LPSTR *ppszHeader, DWORD dwHeader)
{
    HRESULT     hr = S_OK;
    DWORD       dwSize = MAX_PATH;
    LPSTR       pszHeader = NULL;

    Assert(NULL != ppszHeader);
    *ppszHeader = NULL;

retry:
    if (!MemAlloc((void **)&pszHeader, dwSize))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (!HttpQueryInfo(m_op.hRequest, dwHeader, pszHeader, &dwSize, NULL))
    {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
            goto exit;
        
        SafeMemFree(pszHeader);        
        goto retry;
    }

    *ppszHeader = pszHeader;
    pszHeader = NULL;

exit:
    SafeMemFree(pszHeader);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AddRequestHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_AddRequestHeader(LPCSTR pszHeader)
{
    HRESULT     hr = S_OK;

    if (!HttpAddRequestHeaders(m_op.hRequest, pszHeader, lstrlen(pszHeader), HTTP_ADDREQ_FLAG_ADD))
        hr = GetLastError();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AuthCurrentRequest
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::_AuthCurrentRequest(DWORD dwStatus, BOOL fRetryAuth)
{
    BOOL        fResult = FALSE;
    HRESULT     hr;

    // unused code to let wininet do the ui
    #if 0
    if (HTTP_STATUS_PROXY_AUTH_REQ == dwStatus || HTTP_STATUS_DENIED == dwStatus)
    {
        if (!fRequestedParent)
        {
            GetParentWindow(&hwndParent);
            fRequestedParent = TRUE;
        }

        hr = InternetErrorDlg(hwndParent, m_op.hRequest, hr, 
                           FLAGS_ERROR_UI_FILTER_FOR_ERRORS | 
                           FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS |
                           FLAGS_ERROR_UI_FLAGS_GENERATE_DATA,
                           NULL);
        if (ERROR_INTERNET_FORCE_RETRY == hr)
            goto resend;
    }
#endif

        // TODO: should probably let wininet handle proxy auth errors
#if 0
    case HTTP_STATUS_PROXY_AUTH_REQ:    //Proxy Authentication Required
        InternetSetOption(m_op.hRequest, INTERNET_OPTION_PROXY_USERNAME, 
                        GetUserName(), strlen(GetUserName())+1);
        InternetSetOption(m_op.hRequest, INTERNET_OPTION_PROXY_PASSWORD, 
                        GetPassword(), strlen(GetPassword())+1);
        break;
#endif

    if (HTTP_STATUS_DENIED == dwStatus)     //Server Authentication Required
    {
        if (fRetryAuth || (SUCCEEDED(hr = UpdateLogonInfo()) && S_FALSE != hr))
        {
            InternetSetOption(m_op.hRequest, INTERNET_OPTION_USERNAME, 
                        GetUserName(), strlen(GetUserName())+1);
            InternetSetOption(m_op.hRequest, INTERNET_OPTION_PASSWORD, 
                        GetPassword(), strlen(GetPassword())+1);
            fResult = TRUE;
        }
    }

    return fResult;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_LogRequest
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_LogRequest(LPVOID pvData, DWORD cbData)
{
    HRESULT     hr = S_OK;
    CByteStream bs;
    LPSTR       pszCommand = CommandToVerb(m_op.rResponse.command);
    LPSTR       pszLogData = NULL;

    Assert(NULL != m_pLogFile);
    if (NULL == m_pLogFile)
        return;

    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
    FAIL_EXIT_STREAM_WRITE(bs, pszCommand);
    FAIL_EXIT_STREAM_WRITE(bs, c_szSpace);
    FAIL_EXIT_STREAM_WRITE(bs, m_op.pszUrl);

    if (pvData && cbData)
    {
        FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
        if (FAILED(hr = bs.Write(pvData, cbData, NULL)))
            goto exit;
    }

    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);

    FAIL_EXIT(hr = bs.HrAcquireStringA(NULL, &pszLogData, ACQ_DISPLACE));

    m_pLogFile->WriteLog(LOGFILE_TX, pszLogData);

exit:
    SafeMemFree(pszLogData);

    return;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_LogResponse
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_LogResponse(LPVOID pvData, DWORD cbData)
{
    HRESULT     hr = S_OK;
    CByteStream bs;
    LPSTR       pszHeaders = NULL;
    LPSTR       pszLogData = NULL;

    Assert(NULL != m_pLogFile);
    if (NULL == m_pLogFile || m_op.fLoggedResponse)
        return;
    
    FAIL_EXIT(_GetRequestHeader(&pszHeaders, HTTP_QUERY_RAW_HEADERS_CRLF));

    if (pszHeaders)
    {
        // prefix with a CRLF
        if ('\r' != pszHeaders[0])
            FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);

        FAIL_EXIT_STREAM_WRITE(bs, pszHeaders);
    }

    if (pvData && cbData)
    {
        if (FAILED(hr = bs.Write(pvData, cbData, NULL)))
            goto exit;
    }

    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);

    FAIL_EXIT(hr = bs.HrAcquireStringA(NULL, &pszLogData, ACQ_DISPLACE));

    m_pLogFile->WriteLog(LOGFILE_RX, pszLogData);

exit:
    m_op.fLoggedResponse = TRUE;

    SafeMemFree(pszHeaders);
    SafeMemFree(pszLogData);

    return;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::TranslateWinInetMsg
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::TranslateWinInetMsg(
                                DWORD dwInternetStatus,
                                IXPSTATUS *pIxpStatus)
{
    IxpAssert(NULL != pIxpStatus);

    switch (dwInternetStatus)
    {
    case INTERNET_STATUS_RESOLVING_NAME:
        *pIxpStatus = IXP_FINDINGHOST;
        break;

    case  INTERNET_STATUS_CONNECTING_TO_SERVER:
        *pIxpStatus = IXP_CONNECTING;
        break;
    
    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        *pIxpStatus = IXP_CONNECTED;
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        *pIxpStatus = IXP_DISCONNECTING;
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        *pIxpStatus = IXP_DISCONNECTED;
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        *pIxpStatus = IXP_LAST;
        break;

    default:
        // status codes that are not translated:
        //      INTERNET_STATUS_NAME_RESOLVED 
        //      INTERNET_STATUS_SENDING_REQUEST 
        //      INTERNET_STATUS_ REQUEST_SENT
        //      INTERNET_STATUS_RECEIVING_RESPONSE
        //      INTERNET_STATUS_RESPONSE_RECEIVED
        //      INTERNET_STATUS_REDIRECT
        //      INTERNET_STATUS_HANDLE_CREATED
        //      INTERNET_STATUS_HANDLE_CLOSING

        return FALSE;
    }

    return TRUE;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_CreateXMLParser
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_CreateXMLParser()
{
    HRESULT                 hr = S_OK;
    
    if (NULL == m_pParser)
    {
            // instantiate the xml document
        hr = ::CoCreateInstance(CLSID_XMLParser, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER, 
                                 IID_IXMLParser, 
                                 reinterpret_cast<void **>(&m_pParser));

        if (FAILED(hr))
            goto exit;


        if (FAILED(hr = m_pParser->SetFlags(XMLFLAG_FLOATINGAMP)))
            goto exit;
    }

    hr = m_pParser->SetFactory(this);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::OpenRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::OpenRequest(void)
{
    LPSTR           pszVerb = NULL;
    HRESULT         hr = S_OK;
    LPSTR           pszHostName = NULL;
    LPSTR           pszUrlPath = NULL;
    INTERNET_PORT   nPort;
    LPSTR           pszUserName = GetUserName();
    LPSTR           pszPassword = GetPassword();

    if (NULL == pszUserName)
        pszUserName = "";

    if (NULL == pszPassword)
        pszPassword = "";

    // crack the url into component parts
    if (FAILED(hr = HrCrackUrl(m_op.pszUrl, &pszHostName, &pszUrlPath, &nPort)))
    {
        TrapError(hr);
        goto exit;
    }

    if (FAILED(hr = HrConnectToHost(pszHostName, nPort, pszUserName, NULL)))
    {
        TrapError(hr);
        goto exit;
    }

    // We have to set the password and username on every connection. If we don't,
    // and and incorrect password or username forces us to prompt the user, the
    // newly entered data won't get used on subsequent requests
    InternetSetOption(GetConnection(), INTERNET_OPTION_USERNAME, pszUserName, lstrlen(pszUserName) + 1);
    InternetSetOption(GetConnection(), INTERNET_OPTION_PASSWORD, pszPassword, lstrlen(pszPassword) + 1);

    FAIL_ABORT;

    // convert the command to a verb string
    pszVerb = CommandToVerb(m_op.rResponse.command);

    // Open the HTTP request
    m_op.hRequest = HttpOpenRequest(
                        GetConnection(), 
                        pszVerb, 
                        pszUrlPath,
                        NULL,
                        NULL,
                        m_op.rgszAcceptTypes,
                        INTERNET_FLAG_EXISTING_CONNECT | 
                        INTERNET_FLAG_RELOAD |
                        INTERNET_FLAG_KEEP_CONNECTION,
                        0);
    
    if (NULL == m_op.hRequest)
    {
        DWORD dwErr = GetLastError();
        hr = E_FAIL;
    }

exit:
    SafeMemFree(pszHostName);
    SafeMemFree(pszUrlPath);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::SendPostRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::SendPostRequest(void)
{
    HRESULT             hr = S_OK;
    INTERNET_BUFFERS    buffers;
    DWORD               cbData;
    ULONG               cbRead;
    ULONG               cbWritten;
    BOOL                fResult;
    CHAR                localBuffer[HTTPMAIL_BUFSIZE];
    LARGE_INTEGER       liOrigin = {0,0};
    DWORD               dwBufferLength;
    BOOL                fSentData = FALSE;
    BOOL                fWillSend;
    DWORD               dwWinInetErr = 0;
    BOOL                fRetryAuth = FALSE;

    // log the request, but don't log the request body
    if (m_pLogFile)
        _LogRequest(NULL, 0);

    if (m_op.pHeaderStream)
    {
        if (FAILED(hr = HrGetStreamSize(m_op.pHeaderStream, &m_op.rResponse.rPostInfo.cbTotal)))
            goto exit;
    }

    if (m_op.pBodyStream)
    {
        if (FAILED(hr = HrGetStreamSize(m_op.pBodyStream, &cbData)))
            goto exit;

        m_op.rResponse.rPostInfo.cbTotal += cbData;
    }

    buffers.dwStructSize = sizeof(INTERNET_BUFFERSA);
    buffers.Next = NULL;
    buffers.lpcszHeader = NULL;
    buffers.dwHeadersLength = 0;
    buffers.dwHeadersTotal = 0;
    buffers.lpvBuffer = NULL;
    buffers.dwBufferLength = 0;
    buffers.dwBufferTotal = m_op.rResponse.rPostInfo.cbTotal;
    buffers.dwOffsetLow = 0;
    buffers.dwOffsetHigh = 0;

resend:
    if (fSentData)
    {
        m_op.rResponse.rPostInfo.fResend = TRUE;
        m_op.rResponse.rPostInfo.cbCurrent = 0;
        
        _HrThunkResponse(FALSE);

        m_op.rResponse.rPostInfo.fResend = FALSE;

        FAIL_ABORT;
    }

    fResult = HttpSendRequestEx(m_op.hRequest, &buffers, NULL, 0, 0);
    if (!fResult)
    {
        dwWinInetErr = GetLastError();
        if (ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION == dwWinInetErr)
        {
            fRetryAuth = TRUE;
            goto resend;
        }

        _HrThunkConnectionError(dwWinInetErr);
        hr = E_FAIL;
        goto exit;
    }
    
    // with some auth methods (e.g., NTLM), wininet will send a post request
    // with a content length of 0, and will ignore calls to InternetWriteFile
    // until the server sends a 100 (continue) response. wininet will then
    // return ERROR_INTERNET_FORCE_RETRY to force a resend. we detect this
    // case here so that we don't send a bunch of OnResponse progress notifications
    // when no data is actually going out over the wire

    // this constant isn't in the wininet headers as of 10/6/98!!
#ifndef INTERNET_OPTION_DETECT_POST_SEND
#define INTERNET_OPTION_DETECT_POST_SEND        71
#endif

    dwBufferLength = sizeof(fWillSend);
    if (!InternetQueryOption(m_op.hRequest, INTERNET_OPTION_DETECT_POST_SEND, &fWillSend, &dwBufferLength))
        fWillSend = TRUE;
    else
    {
        Assert(dwBufferLength == sizeof(BOOL));
    }

    if (fWillSend)
    {
        fSentData = TRUE;

        if (m_op.pHeaderStream)
        {
            // rewind the stream
            if (FAILED(hr = m_op.pHeaderStream->Seek(liOrigin, STREAM_SEEK_SET, NULL)))
                goto exit;

            while (TRUE)
            {
                if (FAILED(hr = m_op.pHeaderStream->Read(localBuffer, sizeof(localBuffer), &cbRead)))
                    goto exit;

                if (0 == cbRead)
                    break;
            
                fResult = InternetWriteFile(m_op.hRequest, localBuffer, cbRead, &cbWritten);
                IxpAssert(!fResult || (cbRead == cbWritten));
                if (!fResult)
                {
                    _HrThunkConnectionError(GetLastError());
                    hr = E_FAIL;
                    goto exit;
                }
            
                m_op.rResponse.rPostInfo.cbIncrement = cbWritten;
                m_op.rResponse.rPostInfo.cbCurrent += cbWritten;

                _HrThunkResponse(FALSE);

                m_op.rResponse.rPostInfo.cbIncrement = 0;

                FAIL_ABORT;
            }
        }

        if (m_op.pBodyStream)
        {
            // rewind the stream
            if (FAILED(hr = m_op.pBodyStream->Seek(liOrigin, STREAM_SEEK_SET, NULL)))
                goto exit;

            while (TRUE)
            {
                if (FAILED(hr = m_op.pBodyStream->Read(localBuffer, sizeof(localBuffer), &cbRead)))
                    goto exit;

                if (0 == cbRead)
                    break;

                fResult = InternetWriteFile(m_op.hRequest, localBuffer, cbRead, &cbWritten);
                IxpAssert(!fResult || (cbRead == cbWritten));
                if (!fResult)
                {
                    _HrThunkConnectionError(GetLastError());
                    hr = E_FAIL;
                    goto exit;
                }
            
                m_op.rResponse.rPostInfo.cbIncrement = cbWritten;
                m_op.rResponse.rPostInfo.cbCurrent += cbWritten;

                _HrThunkResponse(FALSE);

                m_op.rResponse.rPostInfo.cbIncrement = 0;

                FAIL_ABORT;
 
            }
        }
    }

    fResult = HttpEndRequest(m_op.hRequest, NULL, 0, 0);
    if (!fResult)
    {
        if (ERROR_INTERNET_FORCE_RETRY == GetLastError())
            goto resend;

        _HrThunkConnectionError(GetLastError());
    }

    if (!_GetStatusCode(&m_op.dwHttpStatus))
    {
        _HrThunkConnectionError(GetLastError());
        hr = E_FAIL;
        goto exit;
    }

    if (_AuthCurrentRequest(m_op.dwHttpStatus, fRetryAuth))
    {
        fRetryAuth = FALSE;
        goto resend;
    }

    if (!fResult)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    // status codes not in the 200-299 range indicate an error
    if (200 > m_op.dwHttpStatus || 299 < m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::SendRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::SendRequest(void)
{
    HRESULT     hr = S_OK;
    DWORD       dwError;
    BOOL        bResult;
    HWND        hwndParent = NULL;
    BOOL        fRequestedParent = FALSE;
    DWORD       dwWinInetErr = 0;
    BOOL        fRetryAuth = FALSE;

    // log the request, including the requets body
    if (m_pLogFile)
        _LogRequest(m_op.pvData, m_op.cbDataLen);

resend:
    hr = S_OK;
    bResult = HttpSendRequest(m_op.hRequest, NULL, 0L, m_op.pvData, m_op.cbDataLen);
    if (!bResult)
    {
        dwWinInetErr = GetLastError();
        if (ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION == dwWinInetErr)
        {
            fRetryAuth = TRUE;
            goto resend;
        }

        _HrThunkConnectionError(dwWinInetErr);
        hr = E_FAIL;
        goto exit;
    }

    if (!_GetStatusCode(&m_op.dwHttpStatus))
    {
        _HrThunkConnectionError(GetLastError());
        hr = E_FAIL;
        goto exit;
    }

    if (_AuthCurrentRequest(m_op.dwHttpStatus, fRetryAuth))
    {
        fRetryAuth = FALSE;
        goto resend;
    }

    // status codes not in the 200-299 range indicate an error
    if (200 > m_op.dwHttpStatus|| 299 < m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RequireMultiStatus
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::RequireMultiStatus(void)
{
    HRESULT hr = S_OK;

    if (207 != m_op.dwHttpStatus)
    {
        _HrThunkConnectionError(ERROR_INTERNET_CANNOT_CONNECT);
        hr = E_FAIL;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FinalizeRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::FinalizeRequest(void)
{
    HRESULT     hr                  = S_OK;
    LPSTR       pszTimestampHeader  = NULL;

    // log the response if it hasn't already been logged
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (HTTPMAIL_MEMBERINFO == m_op.rResponse.command)
    {
        // Get the headers and copy them. If we don't get timestamp header, its not a big deal. We don't report an error.
        hr = _HrGetTimestampHeader(&pszTimestampHeader);
        if (SUCCEEDED(hr))
        {
            // Get the Active timestamp
            FAIL_EXIT(hr = _HrParseAndCopy(c_szActive, &m_op.rResponse.rMemberInfoList.pszFolderTimeStamp, pszTimestampHeader));
            
            // Get RootTimeStamp which for some strange reason comes as Folders TimeStamp
            // This call might fail for legitimate reasons. For Inbox list headers we do not get a RootTimeStamp. 
            // Hence we do not exit if we can't get root time stamp.
            _HrParseAndCopy(c_szFolders, &m_op.rResponse.rMemberInfoList.pszRootTimeStamp, pszTimestampHeader);

            SafeMemFree(pszTimestampHeader);
             
        }
    }

    hr =  _HrThunkResponse(TRUE);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessGetResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessGetResponse(void)
{
    HRESULT     hr = S_OK;
    BOOL        bRead;
    DWORD       cbReadBytes = 0;

    // log the respnse, but don't log the response body
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    Assert(NULL == m_op.rResponse.rGetInfo.pszContentType);

    // extract the content type header
    FAIL_EXIT(hr  = _GetRequestHeader(&m_op.rResponse.rGetInfo.pszContentType, HTTP_QUERY_CONTENT_TYPE));

    // try to get the content length
    m_op.rResponse.rGetInfo.fTotalKnown = _GetContentLength(&m_op.rResponse.rGetInfo.cbTotal);

    do
    {
        // The buffer is owned by this object, but the client
        // has the option of taking ownership of the buffer
        // whenever a read completes. We reallocate the buffer
        // here if necessary
        FAIL_ABORT;
        
        if (!m_op.rResponse.rGetInfo.pvBody && !MemAlloc((void**)&m_op.rResponse.rGetInfo.pvBody, HTTPMAIL_BUFSIZE + 1))
        {    
            hr = E_OUTOFMEMORY;
            break;
        }


        bRead = ReadBytes((char *)m_op.rResponse.rGetInfo.pvBody, HTTPMAIL_BUFSIZE, &cbReadBytes);
        
        m_op.rResponse.rGetInfo.cbIncrement = cbReadBytes;
        m_op.rResponse.rGetInfo.cbCurrent += cbReadBytes;

        // we guarantee space for the terminating null by allocating
        // a buffer one larger than bufsize
        static_cast<char *>(m_op.rResponse.rGetInfo.pvBody)[cbReadBytes] = '\0';

        // Send a message to the window that lives in the client's thread
        _HrThunkResponse(0 == cbReadBytes);

    } while (0 < cbReadBytes);

exit:
    SafeMemFree(m_op.rResponse.rGetInfo.pvBody);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessPostResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessPostResponse(void)
{
    HRESULT     hr = S_OK;

    // log the response
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (m_op.dwHttpStatus < 200 || m_op.dwHttpStatus > 299)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    hr = _GetRequestHeader(&m_op.rResponse.rPostInfo.pszLocation, HTTP_QUERY_LOCATION);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessXMLResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessXMLResponse(void)
{
    HRESULT         hr = S_OK;
    BOOL            bRead;
    LPSTR           pszBody = NULL;
    DWORD           cbLength = 0;
    CByteStream     *pLogStream = NULL;
    BOOL            fFoundBytes = FALSE;

    if (m_pLogFile && !m_op.fLoggedResponse)
        pLogStream = new CByteStream();

    // we only parse xml if the response is a 207 (multistatus)
    if (m_op.dwHttpStatus != 207)
        goto exit;

    // create the xml parser
    if (FAILED(hr = _CreateXMLParser()))
        goto exit;

    if (!MemAlloc((void **)&pszBody, HTTPMAIL_BUFSIZE))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    do
    {
        FAIL_ABORT;

        bRead = ReadBytes(pszBody, HTTPMAIL_BUFSIZE, &cbLength);
        if (0 == cbLength)
        {
            if (fFoundBytes)
            {
                // parse any remaining bytes in the parser's buffer
                if (FAILED(hr = m_pParser->PushData(NULL, 0, TRUE)))
                    goto exit;

                if (FAILED(hr = m_pParser->Run(-1)))
                    goto exit;
            }

            break;
        }

        fFoundBytes = TRUE;

        // if logging, write the block into the log stream
        if (pLogStream)
            pLogStream->Write(pszBody, cbLength, NULL);

        if (FAILED(hr = m_pParser->PushData(pszBody, cbLength, FALSE)))
            goto exit;

        if (FAILED(hr = m_pParser->Run(-1)))
        {
            if (hr == E_PENDING)
                hr = S_OK;
            else
                goto exit;
        }

    } while (TRUE);

exit:
    SafeMemFree(pszBody);

    if (pLogStream)
    {
        LPSTR pszLog = NULL;
        DWORD dwLog = 0;
        
        pLogStream->HrAcquireStringA(&dwLog, &pszLog, ACQ_DISPLACE);
    
        _LogResponse(pszLog, dwLog);
        SafeMemFree(pszLog);

        delete pLogStream;
    }

    if (m_pParser)
        m_pParser->Reset();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GeneratePropFindXML
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::GeneratePropFindXML(void)
{
    HRESULT hr = S_OK;
    LPSTR   pszXML = NULL;

    IxpAssert(NULL == m_op.pvData && 0 == m_op.cbDataLen);
    IxpAssert(NULL != m_op.pPropFindRequest);

    if (FAILED(hr = m_op.pPropFindRequest->GenerateXML(&pszXML)))
        goto exit;

    m_op.pvData = pszXML;
    m_op.cbDataLen = lstrlen(pszXML);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddDepthHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddDepthHeader(void)
{
    HRESULT hr = S_OK;
    char szDepthHeader[64];
    
    if (0 != m_op.dwDepth && !!(m_op.dwRHFlags & RH_NOROOT))
    {
        if (DEPTH_INFINITY == m_op.dwDepth)
            lstrcpy(szDepthHeader, c_szDepthInfinityNoRootHeader);
        else
            wsprintf(szDepthHeader, c_szDepthNoRootHeader, m_op.dwDepth);
    }
    else
    {
        if (DEPTH_INFINITY == m_op.dwDepth)
            lstrcpy(szDepthHeader, c_szDepthInfinityHeader);
        else
            wsprintf(szDepthHeader, c_szDepthHeader, m_op.dwDepth);
    }
    
    if (!HttpAddRequestHeaders(m_op.hRequest, szDepthHeader, lstrlen(szDepthHeader), HTTP_ADDREQ_FLAG_ADD))
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
    }

    return hr;    
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GeneratePropPatchXML
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::GeneratePropPatchXML(void)
{
    HRESULT hr = S_OK;
    LPSTR pszXML = NULL;

    IxpAssert(NULL == m_op.pvData && 0 == m_op.cbDataLen);
    IxpAssert(NULL != m_op.pPropPatchRequest);

    if (FAILED(hr = m_op.pPropPatchRequest->GenerateXML(&pszXML)))
        goto exit;

    m_op.pvData = pszXML;
    m_op.cbDataLen = lstrlen(pszXML);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessCreatedResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessCreatedResponse(void)
{
    HRESULT     hr = S_OK;
    
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (HTTP_STATUS_CREATED != m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddCommonHeaders
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddCommonHeaders(void)
{
    HRESULT     hr = S_OK;
    CHAR        szHeader[CCHMAX_RES];

    if (!!(RH_ALLOWRENAME & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szAllowRenameHeader)))
            goto exit;
    }

    if (!!(RH_TRANSLATEFALSE & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szTranslateFalseHeader)))
            goto exit;
    }

    if (!!(RH_TRANSLATETRUE & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szTranslateTrueHeader)))
            goto exit;
    }

    if (!!(RH_XMLCONTENTTYPE & m_op.dwRHFlags))
    {
        IxpAssert(NULL == m_op.pszContentType);
        m_op.pszContentType = PszDupA(c_szXmlContentType);
        if (NULL == m_op.pszContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
        if (FAILED(hr = AddContentTypeHeader()))
            goto exit;
    }

    if (!!(RH_MESSAGECONTENTTYPE & m_op.dwRHFlags))
    {
        IxpAssert(NULL == m_op.pszContentType);
        m_op.pszContentType = PszDupA(c_szMailContentType);
        if (NULL == m_op.pszContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
        if (FAILED(hr = AddContentTypeHeader()))
            goto exit;
    }

    if (!!(RH_SMTPMESSAGECONTENTTYPE & m_op.dwRHFlags))
    {
        IxpAssert(NULL == m_op.pszContentType);
        m_op.pszContentType = PszDupA(c_szSmtpMessageContentType);
        if (NULL == m_op.pszContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
        if (FAILED(hr = AddContentTypeHeader()))
            goto exit;
    }

    if (!!(RH_BRIEF & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szBriefHeader)))
            goto exit;
    }

    if (!!(RH_SAVEINSENTTRUE & m_op.dwRHFlags))
    {
        FAIL_EXIT(hr = _AddRequestHeader(c_szSaveInSentTrue));
    }

    if (!!(RH_SAVEINSENTFALSE & m_op.dwRHFlags))
    {
        FAIL_EXIT(hr = _AddRequestHeader(c_szSaveInSentFalse));
    }

    if (!!(RH_ROOTTIMESTAMP & m_op.dwRHFlags))
    {
        wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szRootTimeStampHeader, m_op.pszRootTimeStamp, m_op.pszFolderTimeStamp);

        FAIL_EXIT(hr = _AddRequestHeader(szHeader));
    }

    if (!!(RH_FOLDERTIMESTAMP & m_op.dwRHFlags))
    {
        wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szFolderTimeStampHeader, m_op.pszFolderTimeStamp);

        FAIL_EXIT(hr = _AddRequestHeader(szHeader));

    }


    // Fix for 88820
    if (!!(RH_ADDCHARSET & m_op.dwRHFlags))
    {
        CODEPAGEINFO CodePageInfo;

        MimeOleGetCodePageInfo(CP_ACP, &CodePageInfo);

        *szHeader = 0;
        wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szAcceptCharset, CodePageInfo.szWebCset);

        FAIL_EXIT(hr = _AddRequestHeader(szHeader));
    }
    // end  of fix

exit:
    return hr;
}
// CHTTPMailTransport::AddCharsetLine
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddCharsetLine(void)
{
    HRESULT     hr = S_OK;
    CHAR        szHeader[CCHMAX_RES];
	
	CODEPAGEINFO CodePageInfo;
	
	MimeOleGetCodePageInfo(CP_ACP, &CodePageInfo);
	
	*szHeader = 0;
	wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szAcceptCharset, CodePageInfo.szWebCset);
	
	hr = _AddRequestHeader(szHeader);

    return hr;
}
// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddDestinationHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddDestinationHeader(void)
{
    HRESULT hr = S_OK;
    ULONG   cb = lstrlen(c_szDestinationHeader) + lstrlen(m_op.pszDestination) + sizeof(char);
    LPSTR   pszDestHeader = NULL;

    if (!MemAlloc((void **)&pszDestHeader, cb))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    wsprintf(pszDestHeader, "%s%s", c_szDestinationHeader, m_op.pszDestination);
    hr = _AddRequestHeader(pszDestHeader);

exit:
    SafeMemFree(pszDestHeader);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddContentTypeHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddContentTypeHeader(void)
{
    HRESULT     hr = S_OK;
    ULONG       cb;
    LPSTR       pszContentTypeHeader = NULL;

    if (NULL == m_op.pszContentType)
        goto exit;

    cb = lstrlen(c_szContentTypeHeader) + lstrlen(m_op.pszContentType) + sizeof(CHAR);
    if (!MemAlloc((void **)&pszContentTypeHeader, cb))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    wsprintf(pszContentTypeHeader, "%s%s", c_szContentTypeHeader, m_op.pszContentType);
    hr = _AddRequestHeader(pszContentTypeHeader);

exit:
    SafeMemFree(pszContentTypeHeader);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessLocationResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessLocationResponse(void)
{
    _GetRequestHeader(&m_op.rResponse.rCopyMoveInfo.pszLocation, HTTP_QUERY_LOCATION);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitBCopyMove
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitBCopyMove(void)
{
    HRESULT     hr = S_OK;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rBCopyMoveList.prgBCopyMove, 
        BCOPYMOVE_MAXRESPONSES * sizeof(HTTPMAILBCOPYMOVE)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    ZeroMemory(m_op.rResponse.rBCopyMoveList.prgBCopyMove, BCOPYMOVE_MAXRESPONSES * sizeof(HTTPMAILBCOPYMOVE));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitRootProps
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitRootProps(void)
{
    HRESULT     hr = S_OK;

    // it is possible to end up here, and have the root props
    // if the caller either forced the request to go async,
    // or queued up multiple requests for root props.
    if (GetHasRootProps())
    {
        // finalize the root props, and return an error.
        // this will generate the response to the caller,
        // and fall out of the fsm.
        FinalizeRootProps();
        hr = E_FAIL;
    }
    else
    {
        IxpAssert(NULL == m_op.pPropFindRequest);

        m_op.pPropFindRequest = new CPropFindRequest();
        if (NULL == m_op.pPropFindRequest)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        hr = XP_CREATE_PROPFIND_REQUEST(ROOTPROPS, m_op.pPropFindRequest);
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FinalizeRootProps
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::FinalizeRootProps(void)
{
    HRESULT     hr = S_OK;

    m_fHasRootProps = TRUE;

    m_op.rResponse.rGetPropInfo.type = m_op.tyProp;

    if (m_op.tyProp != HTTPMAIL_PROP_MAXPOLLINGINTERVAL)
    {
        m_op.rResponse.rIxpResult.hrResult = GetProperty(m_op.tyProp, &m_op.rResponse.rGetPropInfo.pszProp);
    }
    else
    {
        m_op.rResponse.rIxpResult.hrResult = GetPropertyDw(m_op.tyProp, &m_op.rResponse.rGetPropInfo.dwProp);
    }

    hr = _HrThunkResponse(TRUE);
    SafeMemFree(m_op.rResponse.rGetPropInfo.pszProp);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitMemberInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitMemberInfo(void)
{
    HRESULT     hr = S_OK;

    IxpAssert(NULL == m_op.pPropFindRequest);

    // create the propfind request
    m_op.pPropFindRequest = new CPropFindRequest();
    if (NULL == m_op.pPropFindRequest)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // always add the common properties
    FAIL_EXIT(hr = XP_CREATE_PROPFIND_REQUEST(HTTPMEMBERINFO_COMMON, m_op.pPropFindRequest));

    // if the client requested folder props, add that schema
    if (!!(m_op.dwMIFlags & HTTP_MEMBERINFO_FOLDERPROPS))
        FAIL_EXIT(hr = XP_CREATE_PROPFIND_REQUEST(HTTPMEMBERINFO_FOLDER, m_op.pPropFindRequest));

    // if the client requested message props, add that schema
    if (!!(m_op.dwMIFlags & HTTP_MEMBERINFO_MESSAGEPROPS))
        FAIL_EXIT(hr = XP_CREATE_PROPFIND_REQUEST(HTTPMEMBERINFO_MESSAGE, m_op.pPropFindRequest));

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rMemberInfoList.prgMemberInfo,
        MEMBERINFO_MAXRESPONSES * sizeof(HTTPMEMBERINFO)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    ZeroMemory(m_op.rResponse.rMemberInfoList.prgMemberInfo, MEMBERINFO_MAXRESPONSES * sizeof(HTTPMEMBERINFO));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitMemberError
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitMemberError(void)
{
    HRESULT     hr = S_OK;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rMemberErrorList.prgMemberError,
        MEMBERERROR_MAXRESPONSES * sizeof(HTTPMEMBERERROR)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    ZeroMemory(m_op.rResponse.rMemberErrorList.prgMemberError, MEMBERERROR_MAXRESPONSES * sizeof(HTTPMEMBERERROR));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// InitListContacts
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitListContacts(void)
{
    HRESULT     hr = S_OK;

    IxpAssert(NULL == m_op.pPropFindRequest);

    m_op.pPropFindRequest = new CPropFindRequest();
    if (NULL == m_op.pPropFindRequest)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = XP_CREATE_PROPFIND_REQUEST(HTTPCONTACTID, m_op.pPropFindRequest);
    if (FAILED(hr))
        goto exit;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rContactIdList.prgContactId,
        LISTCONTACTS_MAXRESPONSES * sizeof(HTTPCONTACTID)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(m_op.rResponse.rContactIdList.prgContactId, LISTCONTACTS_MAXRESPONSES * sizeof(HTTPCONTACTID));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitContactInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitContactInfo(void)
{
    HRESULT     hr = S_OK;

    IxpAssert(NULL == m_op.pPropFindRequest);

    m_op.pPropFindRequest = new CPropFindRequest();
    if (NULL == m_op.pPropFindRequest)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = XP_CREATE_PROPFIND_REQUEST(HTTPCONTACTINFO, m_op.pPropFindRequest);
    if (FAILED(hr))
        goto exit;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rContactInfoList.prgContactInfo,
        CONTACTINFO_MAXRESPONSES * sizeof(HTTPCONTACTINFO)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(m_op.rResponse.rContactInfoList.prgContactInfo, CONTACTINFO_MAXRESPONSES * sizeof(HTTPCONTACTINFO));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessPostContactResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessPostContactResponse(void)
{
    HRESULT                 hr = S_OK;
    DWORD                   dwSize = MAX_PATH;
    LPSTR                   pszLocation = NULL;
    DWORD                   dwContext;
    int                     iState;

    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (HTTP_STATUS_CREATED != m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    if (FAILED(hr = _GetRequestHeader(&pszLocation, HTTP_QUERY_LOCATION)))
        goto exit;

    // Prepare for the next phase

    // save the context and the state
    dwContext = m_op.dwContext;
    iState = m_op.iState;

    FreeOperation();

    // restore context, state, parsing funcs, etc.

    m_op.rResponse.command = HTTPMAIL_POSTCONTACT;
    m_op.pszUrl = pszLocation;
    pszLocation = NULL;
    m_op.dwContext = dwContext;

    m_op.pfnState = c_rgpfnPostContact;
    m_op.cState = ARRAYSIZE(c_rgpfnPostContact);
    m_op.iState = iState;
    m_op.pParseFuncs = c_rgpfnPostOrPatchContactParse;

    m_op.dwDepth = 0;
    m_op.dwRHFlags = (RH_XMLCONTENTTYPE | RH_BRIEF);

    m_op.rResponse.rPostContactInfo.pszHref = PszDupA(m_op.pszUrl);
    if (NULL == m_op.rResponse.rPostContactInfo.pszHref)
        hr = E_OUTOFMEMORY;

exit:
    SafeMemFree(pszLocation);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessPatchContactResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessPatchContactResponse(void)
{
    HRESULT             hr = S_OK;
    LPSTR               pszUrl = NULL;
    DWORD               dwContext;
    int                 iState;
    IHTTPMailCallback   *pCallback = NULL;

    // REVIEW: we should be handling multistatus responses
    if (200 > m_op.dwHttpStatus || 300 < m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    // prepare for the next phase
    
    // save the context and the state
    pszUrl = m_op.pszUrl;
    m_op.pszUrl = NULL;
    dwContext = m_op.dwContext;
    iState = m_op.iState;

    FreeOperation();

    // restore context, etc.
    m_op.rResponse.command = HTTPMAIL_PATCHCONTACT;
    m_op.pszUrl = pszUrl;
    m_op.dwContext = dwContext;
    m_op.pfnState = c_rgpfnPatchContact;
    m_op.cState = ARRAYSIZE(c_rgpfnPatchContact);
    m_op.iState = iState;
    m_op.pParseFuncs = c_rgpfnPostOrPatchContactParse; // share the post contact parse funcs

    m_op.dwDepth = 0;
    m_op.rResponse.rPatchContactInfo.pszHref = PszDupA(m_op.pszUrl);

    m_op.dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);

    pszUrl = NULL;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// XML Parsing Callbacks
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CreateElement
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::CreateElement(
                                        CXMLNamespace *pBaseNamespace,
                                        const WCHAR *pwcText, 
                                        ULONG ulLen, 
                                        ULONG ulNamespaceLen,
                                        BOOL fTerminal)
{
    // increment the stack pointer and, if there is room on the stack,
    // push the element type
    if (!fTerminal)
    {
        if (m_op.dwStackDepth < ELE_STACK_CAPACITY)
        {
            m_op.rgEleStack[m_op.dwStackDepth].ele = XMLElementToID(pwcText, ulLen, ulNamespaceLen, m_op.pTopNamespace);
            m_op.rgEleStack[m_op.dwStackDepth].pBaseNamespace = pBaseNamespace;
            m_op.rgEleStack[m_op.dwStackDepth].fBeganChildren = FALSE;
            m_op.rgEleStack[m_op.dwStackDepth].pTextBuffer = NULL;
        }

        ++m_op.dwStackDepth;
    }
    
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::EndChildren(void)
{
    HRESULT hr = S_OK;

    // decrement the stack pointer
    if (m_op.dwStackDepth <= ELE_STACK_CAPACITY)
    {
        LPPCDATABUFFER pTextBuffer = m_op.rgEleStack[m_op.dwStackDepth - 1].pTextBuffer;

        if (pTextBuffer)
        {
            hr = (this->*(m_op.pParseFuncs->pfnHandleText))(pTextBuffer->pwcText, pTextBuffer->ulLen);
            _ReleaseTextBuffer(pTextBuffer);
        }
        else
            hr = (this->*(m_op.pParseFuncs->pfnHandleText))(NULL, 0);

        // unroll the namespace
        PopNamespaces(m_op.rgEleStack[m_op.dwStackDepth - 1].pBaseNamespace);
    }

    --m_op.dwStackDepth;

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::BCopyMove_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::BCopyMove_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT                 hr = S_OK;
    LPHTTPMAILBCOPYMOVE     pInfo = &m_op.rResponse.rBCopyMoveList.prgBCopyMove[m_op.rResponse.rBCopyMoveList.cBCopyMove];
    
    return XP_BIND_TO_STRUCT(HTTPMAILBCOPYMOVE, pwcText, ulLen, pInfo, NULL);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::BCopyMove_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::BCopyMove_EndChildren(void)
{
    HRESULT     hr = S_OK;

    if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // clear the prop flags, since we are about to increment the count
        m_op.dwPropFlags = NOFLAGS;

        // increment the list count and, if we've hit the max, send the notification
        if (BCOPYMOVE_MAXRESPONSES == ++m_op.rResponse.rBCopyMoveList.cBCopyMove)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeBCopyMoveList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PropFind_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PropFind_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT         hr = S_OK;
    LPSTR           pszStatus = NULL;

    // the only element that is handled here is <status>
    if (StackTop(HMELE_DAV_STATUS) && VALIDSTACK(c_rgPropFindStatusStack))
    {
        m_op.fFoundStatus = TRUE;
        m_op.dwStatus = 0;

        if (SUCCEEDED(hr = AllocStrFromStrNW(pwcText, ulLen, &pszStatus)) && NULL != pszStatus)
        {        
            // ignore errors parsing the status...we treat malformed status
            // as status 0, which is an error
            HrParseHTTPStatus(pszStatus, &m_op.dwStatus);
        }
    }

    SafeMemFree(pszStatus);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RootProps_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::RootProps_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT hr = S_OK;
    BOOL    fWasBound = FALSE;

    hr = XP_BIND_TO_STRUCT(ROOTPROPS, pwcText, ulLen, &m_rootProps, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RootProps_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::RootProps_EndChildren(void)
{
    // if we are popping a prop node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(ROOTPROPS, &m_rootProps, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }

    return EndChildren();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberInfo_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberInfo_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT             hr = S_OK;
    LPHTTPMEMBERINFO    pInfo = &m_op.rResponse.rMemberInfoList.prgMemberInfo[m_op.rResponse.rMemberInfoList.cMemberInfo];
    BOOL                fWasBound = FALSE;

    FAIL_EXIT(hr = XP_BIND_TO_STRUCT(HTTPMEMBERINFO, pwcText, ulLen, pInfo, &fWasBound));

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberInfo_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberInfo_EndChildren(void)
{
    HRESULT     hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the folder info we are accumulating
        LPHTTPMEMBERINFO pInfo = 
                &m_op.rResponse.rMemberInfoList.prgMemberInfo[m_op.rResponse.rMemberInfoList.cMemberInfo];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPMEMBERINFO, pInfo, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (MEMBERINFO_MAXRESPONSES == ++m_op.rResponse.rMemberInfoList.cMemberInfo)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeMemberInfoList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberError_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberError_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT             hr = S_OK;
    LPHTTPMEMBERERROR   pInfo = &m_op.rResponse.rMemberErrorList.prgMemberError[m_op.rResponse.rMemberErrorList.cMemberError];
    BOOL                fWasBound = FALSE;

    FAIL_EXIT(hr = XP_BIND_TO_STRUCT(HTTPMEMBERERROR, pwcText, ulLen, pInfo, &fWasBound));

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberError_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberError_EndChildren(void)
{
    HRESULT     hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the folder info we are accumulating
        LPHTTPMEMBERERROR pInfo = 
                &m_op.rResponse.rMemberErrorList.prgMemberError[m_op.rResponse.rMemberErrorList.cMemberError];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPMEMBERERROR, pInfo, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (MEMBERERROR_MAXRESPONSES == ++m_op.rResponse.rMemberErrorList.cMemberError)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeMemberErrorList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}


// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContacts_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContacts_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT         hr = S_OK;
    LPHTTPCONTACTID pId = &m_op.rResponse.rContactIdList.prgContactId[m_op.rResponse.rContactIdList.cContactId];
    BOOL            fWasBound = FALSE;

    hr = XP_BIND_TO_STRUCT(HTTPCONTACTID, pwcText, ulLen, pId, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContacts_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContacts_EndChildren(void)
{
    HRESULT hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the contact id we are accumulating
        LPHTTPCONTACTID pId = &m_op.rResponse.rContactIdList.prgContactId[m_op.rResponse.rContactIdList.cContactId];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPCONTACTID, pId, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (LISTCONTACTS_MAXRESPONSES == ++m_op.rResponse.rContactIdList.cContactId)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeContactIdList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ContactInfo_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ContactInfo_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT             hr = S_OK;
    LPHTTPCONTACTINFO   pInfo = &m_op.rResponse.rContactInfoList.prgContactInfo[m_op.rResponse.rContactInfoList.cContactInfo];
    BOOL                fWasBound = FALSE;

    hr = XP_BIND_TO_STRUCT(HTTPCONTACTINFO, pwcText, ulLen, pInfo, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ContactInfo_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ContactInfo_EndChildren()
{
    HRESULT hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the contact id we are accumulating
        LPHTTPCONTACTINFO pInfo = &m_op.rResponse.rContactInfoList.prgContactInfo[m_op.rResponse.rContactInfoList.cContactInfo];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPCONTACTINFO, pInfo, &m_op.dwPropFlags);
 
        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (CONTACTINFO_MAXRESPONSES == ++m_op.rResponse.rContactInfoList.cContactInfo)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeContactInfoList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PostOrPatchContact_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PostOrPatchContact_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT         hr = S_OK;
    LPHTTPCONTACTID pId = NULL;
    BOOL            fWasBound = FALSE;

    if (HTTPMAIL_POSTCONTACT == m_op.rResponse.command)
        pId = &m_op.rResponse.rPostContactInfo;
    else if (HTTPMAIL_PATCHCONTACT == m_op.rResponse.command)
        pId = &m_op.rResponse.rPatchContactInfo;

    IxpAssert(pId);

    hr = XP_BIND_TO_STRUCT(HTTPCONTACTID, pwcText, ulLen, pId, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PostOrPatchContact_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PostOrPatchContact_EndChildren(void)
{
    HRESULT hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the contact id we are accumulating
        LPHTTPCONTACTID pId = NULL;
        
        if (HTTPMAIL_POSTCONTACT == m_op.rResponse.command)
            pId = &m_op.rResponse.rPostContactInfo;
        else if (HTTPMAIL_PATCHCONTACT == m_op.rResponse.command)
            pId = &m_op.rResponse.rPatchContactInfo;

        IxpAssert(pId);

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPCONTACTID, pId, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }

    hr = EndChildren();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_MemberInfo2
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_MemberInfo2(LPCSTR            pszPath, 
                                         MEMBERINFOFLAGS   flags, 
                                         DWORD             dwDepth,
                                         BOOL              fIncludeRoot,
                                         DWORD             dwContext,
                                         LPHTTPQUEUEDOP    *ppOp)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (!ppOp)
    {
        IF_FAILEXIT(hr = E_INVALIDARG);
    }

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

#pragma prefast(suppress:11, "noise")
    *ppOp = NULL;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command        = HTTPMAIL_MEMBERINFO;
    pOp->dwMIFlags      = flags;
    pOp->dwDepth        = dwDepth;
    pOp->dwContext      = dwContext;
    pOp->pfnState       = c_rgpfnMemberInfo;
    pOp->cState         = ARRAYSIZE(c_rgpfnMemberInfo);
    pOp->pParseFuncs    = c_rgpfnMemberInfoParse;

    pOp->dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);
    if (!fIncludeRoot)
        pOp->dwRHFlags |= RH_NOROOT;


exit:
    if (SUCCEEDED(hr))
    {
#pragma prefast(suppress:11, "noise")
        *ppOp = pOp;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RootMemberInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::RootMemberInfo(LPCSTR                  pszPath,
                                                MEMBERINFOFLAGS         flags,
                                                DWORD                   dwDepth,
                                                BOOL                    fIncludeRoot,
                                                DWORD                   dwContext,
                                                LPSTR                   pszRootTimeStamp,
                                                LPSTR                   pszInboxTimeStamp)                  
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp;

    IF_FAILEXIT(hr = _MemberInfo2(pszPath, flags, dwDepth, fIncludeRoot, dwContext, &pOp));

    pOp->dwRHFlags |= RH_ROOTTIMESTAMP | RH_ADDCHARSET;
    pOp->pszRootTimeStamp   = PszDupA(pszRootTimeStamp);
    pOp->pszFolderTimeStamp = PszDupA(pszInboxTimeStamp);

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FolderMemberInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::FolderMemberInfo(LPCSTR                  pszPath,
                                                  MEMBERINFOFLAGS         flags,
                                                  DWORD                   dwDepth,
                                                  BOOL                    fIncludeRoot,
                                                  DWORD                   dwContext,
                                                  LPSTR                   pszFolderTimeStamp,
                                                  LPSTR                   pszFolderName)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp;

    IF_FAILEXIT(hr = _MemberInfo2(pszPath, flags, dwDepth, fIncludeRoot, dwContext, &pOp));

    pOp->dwRHFlags              |= RH_FOLDERTIMESTAMP | RH_ADDCHARSET;
    pOp->pszFolderTimeStamp      = PszDupA(pszFolderTimeStamp);

    // To be used when we do timestamping on every folder. Right now the default is inbox
    //pOp->pszFolderName           = PszDupA(pszFolderName);

    QueueOperation(pOp);

exit:
    return hr;
}

HRESULT CHTTPMailTransport::_HrParseAndCopy(LPCSTR pszToken, LPSTR *ppszDest, LPSTR lpszSrc)
{
    LPSTR   lpszBeginning = lpszSrc;
    LPSTR   lpszEnd;
    DWORD   dwCount = 0;
    HRESULT hr = E_FAIL;    
    int cchSize;

    lpszBeginning = StrStr(lpszSrc, pszToken);
    if (!lpszBeginning)
        goto exit;

    lpszBeginning = StrChr(lpszBeginning, '=');
    if (!lpszBeginning)
        goto exit;

    // Skip the equal sign
    ++lpszBeginning;

    SkipWhitespace(lpszBeginning, &dwCount);
    lpszBeginning += dwCount;

    lpszEnd = StrChr(lpszBeginning, ',');

    if (!lpszEnd)
    {
        //Its possible that this token is at the end. So use the remaining string.
        //Lets take a look at the length and make sure that it doesn't fall off the deep end.
        lpszEnd = lpszBeginning + strlen(lpszBeginning);
    }

    AssertSz(((lpszEnd - lpszBeginning + 1) < 20), "This number looks awfully long, please make sure that this is correct")

    cchSize = (int)(lpszEnd - lpszBeginning + 2);
    if (!MemAlloc((void**)ppszDest, cchSize))
        goto exit;

    cchSize = (int)(lpszEnd - lpszBeginning + 1);
    StrCpyN(*ppszDest, lpszBeginning, cchSize);

    // Null terminate it
    *(*ppszDest + (lpszEnd - lpszBeginning + 1)) = 0;

    hr = S_OK;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetTimestampHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrGetTimestampHeader(LPSTR *ppszHeader)
{
    HRESULT     hr        = S_OK;
    DWORD       dwSize    = MAX_PATH;
    LPSTR       pszHeader = NULL;

    Assert(NULL != ppszHeader);
    *ppszHeader = NULL;

retry:
    if (!MemAlloc((void **)&pszHeader, dwSize))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    StrCpyN(pszHeader, c_szXTimestamp, dwSize);

    if (!HttpQueryInfo(m_op.hRequest, HTTP_QUERY_RAW_HEADERS | HTTP_QUERY_CUSTOM, pszHeader, &dwSize, NULL))
    {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            hr = E_FAIL;
            goto exit;
        }

        SafeMemFree(pszHeader);        
        goto retry;
    }

    *ppszHeader = pszHeader;
    pszHeader   = NULL;

exit:
    SafeMemFree(pszHeader);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixppop3.h ===
// --------------------------------------------------------------------------------
// Ixppop3.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPPOP3_H
#define __IXPPOP3_H

// ------------------------------------------------------------------------------------
// Depends
// ------------------------------------------------------------------------------------
#include "ixpbase.h"
#include "asynconn.h"
#include "sicily.h"

// ------------------------------------------------------------------------------------
// AUTHSTATE
// ------------------------------------------------------------------------------------
typedef enum {
    AUTH_NONE,
    AUTH_ENUMPACKS,
    AUTH_ENUMPACKS_DATA,
    AUTH_TRYING_PACKAGE,
    AUTH_NEGO_RESP,
    AUTH_RESP_RESP,
    AUTH_CANCELED,
    AUTH_SMTP_LOGIN,
    AUTH_SMTP_LOGIN_USERNAME,
    AUTH_SMTP_LOGIN_PASSWORD
} AUTHSTATE;

// ------------------------------------------------------------------------------------
// UIDLTYPE
// ------------------------------------------------------------------------------------
typedef enum {
    UIDL_NONE,
    UIDL_BY_UIDL,
    UIDL_BY_TOP
} UIDLTYPE;

// ------------------------------------------------------------------------------------
// FETCHINFO
// ------------------------------------------------------------------------------------
typedef struct tagFETCHINFO {
    DWORD               cbSoFar;        // Number of bytes downloaded so far
    BOOL                fLastLineCRLF;  // Last line ended with a CRLF
    BOOL                fGotResponse;   // First response after issuing the POP3_TOP or POP3_RETR command
    BOOL                fHeader;        // Header has been downloaded
    BOOL                fBody;          // Body has been downloaded
} FETCHINFO, *LPFETCHINFO;

#define MAX_AUTH_TOKENS 32

// ------------------------------------------------------------------------------------
// AUTHINFO
// ------------------------------------------------------------------------------------
typedef struct tagAUTHINFO {
    AUTHSTATE           authstate;      // Sicily Authorization State
    BOOL                fRetryPackage;  // Retry sicily package with differenty isc flags
    SSPICONTEXT         rSicInfo;       // Data used for logging onto a sicily server
    LPSTR               rgpszAuthTokens[MAX_AUTH_TOKENS];  // AUTH security package tokens
    UINT                cAuthToken;     // count of server packages
    UINT                iAuthToken;     // current package being tried
    LPSSPIPACKAGE       pPackages;      // Array of installed security packages
    ULONG               cPackages;      // Number of installed security packages (pPackages)
} AUTHINFO, *LPAUTHINFO;

void FreeAuthInfo(LPAUTHINFO pAuth);

// ------------------------------------------------------------------------------------
// POP3INFO
// ------------------------------------------------------------------------------------
typedef struct tagPOP3INFO {
    BOOL                fStatDone;      // Has the stat command been issued on this session
    DWORD               cList;          // Number of messages listed in the full UIDL or LIST command
    DWORD               cMarked;        // Number of messages in the prgMarked array, set after STAT is issued
    LPDWORD             prgMarked;      // Array of marked messages 
    FETCHINFO           rFetch;         // Information for the POP3_TOP or POP3_RETR command
    AUTHINFO            rAuth;          // Sicily Authorization Information
    POP3CMDTYPE         cmdtype;        // Current command type
    ULONG               cPreviewLines;  // Number of lines to retrieve on the preview command
    DWORD               dwPopIdCurrent; // Current PopId
} POP3INFO, *LPPOP3INFO;

// ------------------------------------------------------------------------------------
// CPOP3Transport
// ------------------------------------------------------------------------------------
class CPOP3Transport : public IPOP3Transport, public CIxpBase
{
private:
    POP3INFO            m_rInfo;         // Structure containing pop3 information
    POP3COMMAND         m_command;       // Current state
    BYTE                m_fHotmail;      // Are we connected to hotmail ?

private:
    // Processes POP3 command responses
    HRESULT HrGetResponse(void);
    void FillRetrieveResponse(LPPOP3RESPONSE pResponse, LPSTR pszLines, ULONG cbRead, BOOL *pfMessageDone);

    // Response Dispatcher for general command
    void DispatchResponse(HRESULT hrResult, BOOL fDone=TRUE, LPPOP3RESPONSE pResponse=NULL);

    // Sends sicily data to the server
    HRESULT HrSendSicilyString(LPSTR pszData);

    // Build parameterized command
    HRESULT HrBuildParams(POP3CMDTYPE cmdtype, DWORD dwp1, DWORD dwp2);

    // Frees the current message array
    void FreeMessageArray(void);

    // Logon retry
    void LogonRetry(HRESULT hrLogon);

    // Socket data receive handler
    void OnSocketReceive(void);

    // Initiates the logon process
    void StartLogon(void);

    // Response Handler
    void ResponseAUTH(HRESULT hrResponse);
    void ResponseSTAT(void); 
    void ResponseGenericList(void);
    void ResponseGenericRetrieve(void);
    void ResponseDELE(void);

    // Issues a parameterized command
    DWORD   DwGetCommandMarkedFlag(POP3COMMAND command);
    ULONG   CountMarked(POP3COMMAND command);
    HRESULT HrCommandGetPopId(POP3COMMAND command, DWORD dwPopId);
    HRESULT HrSplitPop3Response(LPSTR pszLine, LPSTR *ppszPart1, LPSTR *ppszPart2);
    HRESULT HrComplexCommand(POP3COMMAND command, POP3CMDTYPE cmdtype, DWORD dwPopId, ULONG cPreviewLines);
    HRESULT HrCommandGetNext(POP3COMMAND command, BOOL *pfDone);
    HRESULT HrCommandGetAll(POP3COMMAND command);
    BOOL    FEndRetrRecvHeader(LPSTR pszLines, ULONG cbRead);
    HRESULT HrCancelAuthInProg();
    
    // Moved to ixputil.cpp
    // BOOL    FEndRetrRecvBody(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract);


public:                          
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPOP3Transport(void);
    ~CPOP3Transport(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPSTR pszLogFilePath, IPOP3Callback *pCallback);
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // IPOP3Transport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP MarkItem(POP3MARKTYPE marktype, DWORD dwPopId, boolean fMarked);
    STDMETHODIMP CommandAUTH(LPSTR pszAuthType);
    STDMETHODIMP CommandUSER(LPSTR pszUserName);
    STDMETHODIMP CommandPASS(LPSTR pszPassword);
    STDMETHODIMP CommandLIST(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandTOP (POP3CMDTYPE cmdtype, DWORD dwPopId, DWORD cPreviewLines);
    STDMETHODIMP CommandUIDL(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandDELE(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandRETR(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandRSET(void);
    STDMETHODIMP CommandQUIT(void);
    STDMETHODIMP CommandSTAT(void);
    STDMETHODIMP CommandNOOP(void);

    // ----------------------------------------------------------------------------
    // CIxpBase methods
    // ----------------------------------------------------------------------------
    virtual void ResetBase(void);
    virtual void DoQuit(void);
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void);
    virtual void OnLeaveBusy(void);
};

#endif // __IXPPOP3_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpurl.h ===
// --------------------------------------------------------------------------------
// Ixpurl.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPURL_H
#define __IXPURL_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "privunk.h"
#include "urlmon.h"
#include "inetprot.h"

// --------------------------------------------------------------------------------
// DOWNLOADSOURCE
// --------------------------------------------------------------------------------
typedef struct tagDOWNLOADSOURCE {
    IXPTYPE             ixptype;            // Type of transport working
    INETSERVER          rServer;            // Internet Server Information
    LPSTR               pszFolder;          // NNTP Newsgroup / IMAP Folder
    LPSTR               pszArticle;         // NNTP Article Number
    DWORD               dwMessageId;        // POP3 Message Id / IMAP Message UID
    IInternetTransport *pTransport;         // Release this guy
    union {
        IPOP3Transport *pIxpPop3;           // POP3 Transport
        IIMAPTransport *pIxpImap;           // IMAP Transport
        INNTPTransport *pIxpNntp;           // NNTP Transport
    };
} DOWNLOADSOURCE, *LPDOWNLOADSOURCE;

// --------------------------------------------------------------------------------
// Use to process Transport Shutdown on Switch/Continue
// --------------------------------------------------------------------------------
#define TRANSPORT_DISCONNECT    1000

// --------------------------------------------------------------------------------
// DOWNLOADSTATE
// --------------------------------------------------------------------------------
typedef enum tagDOWNLOADSTATE {
    DWLS_IDLE,
    DWLS_WORKING,
    DWLS_FINISHED
} DOWNLOADSTATE;

// --------------------------------------------------------------------------------
// IMAPTRANSACT
// --------------------------------------------------------------------------------
typedef enum tagIMAPTRANSACT {
    TRX_IMAP_SELECT     = 1000,
    TRX_IMAP_FETCH      = 1001
} IMAPTRANSACT;

// --------------------------------------------------------------------------------
// CInternetMessageUrl
// --------------------------------------------------------------------------------
class CInternetMessageUrl : public CPrivateUnknown,
                            public IOInetProtocol,
                            public IServiceProvider,
                            public IIMAPCallback,
                            public IPOP3Callback,
                            public INNTPCallback
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CInternetMessageUrl(IUnknown *pUnkOuter=NULL);
    virtual ~CInternetMessageUrl(void);
    
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // ----------------------------------------------------------------------------
    // IOInetProtocol methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Start(LPCWSTR pwszUrl, IOInetProtocolSink *pProtSink, IOInetBindInfo *pBindInfo, DWORD grfSTI, DWORD dwReserved);
    STDMETHODIMP Continue(PROTOCOLDATA *pStateInfo);
    STDMETHODIMP Abort(HRESULT hrReason, DWORD dwOptions);
    STDMETHODIMP Terminate(DWORD dwOptions);
    STDMETHODIMP Suspend(void);
    STDMETHODIMP Resume(void);
    STDMETHODIMP Read(LPVOID pv,ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP LockRequest(DWORD dwOptions);
    STDMETHODIMP UnlockRequest(void);
    STDMETHODIMP QueryService(REFGUID rsid, REFIID riid, void **ppvObj);

    // --------------------------------------------------------------------------------
    // ITransportCallback Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport);
    STDMETHODIMP OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport);
    STDMETHODIMP_(INT) OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport);
    STDMETHODIMP OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport);
    STDMETHODIMP OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport);
    STDMETHODIMP OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport);

    // --------------------------------------------------------------------------------
    // INNTPCallback\IPOP3Callback\IIMAPCallback Members
    // --------------------------------------------------------------------------------
    STDMETHODIMP OnResponse(LPNNTPRESPONSE pResponse);
    STDMETHODIMP OnResponse(LPPOP3RESPONSE pResponse);
    STDMETHODIMP OnResponse(const IMAP_RESPONSE *pResponse);

    // ----------------------------------------------------------------------------
    // Actual QI
    // ----------------------------------------------------------------------------
    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);
    friend HRESULT IInternetMessageUrl_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);

private:
    // ----------------------------------------------------------------------------
    // Private Methods
    // ----------------------------------------------------------------------------
    HRESULT _HrCrackMessageUrl(LPCSTR pszUrl);
    HRESULT _HrDispatchDataAvailable(LPBYTE pbData, ULONG cbData, BOOL fDone);
    HRESULT _HrTransportFromUrl(LPCSTR pszUrl);
    void    _OnFinished(HRESULT hrResult, DWORD dwResult=0, LPCWSTR pszResult=NULL);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
    IOInetProtocolSink *m_pProtSink;    // Protocol Sink from IOInetProtocol::Start
    IOInetBindInfo     *m_pBindInfo;    // BindInfo from IOInetProtocol::Start
    PROTOCOLSOURCE      m_rSource;      // Protocol Source
    DOWNLOADSOURCE      m_rDownload;    // Download Source
    LPWSTR              m_pszUrl;       // The original Url
    HRESULT             m_hrResult;     // Final ReportResult Information
    LPWSTR              m_pszResult;    // Final ReportResult Information
    DWORD               m_dwResult;     // Final ReportResult Information
    CRITICAL_SECTION    m_cs;           // Thread Safety
};

#endif // __IXPURL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpurl.cpp ===
// --------------------------------------------------------------------------------
// Ixpurl.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "ixpurl.h"
#define _SHLWAPI_
#define NO_SHLWAPI_PATH
#include "shlwapi.h"
#undef NO_SHLWAPI_PATH
#include "shlwapip.h"
#include "strparse.h"
#include "bytestm.h"
#include "stmlock.h"
#include "wchar.h"

// --------------------------------------------------------------------------------
// IInternetMessageUrl_CreateInstance
// --------------------------------------------------------------------------------
HRESULT IInternetMessageUrl_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CInternetMessageUrl *pNew = new CInternetMessageUrl(pUnkOuter);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::CInternetMessageUrl
// --------------------------------------------------------------------------------
CInternetMessageUrl::CInternetMessageUrl(IUnknown *pUnkOuter) : CPrivateUnknown(&m_cs, pUnkOuter)
{
    DllAddRef();
    m_pProtSink = NULL;
    m_pBindInfo = NULL;
    m_pszUrl = NULL;
    m_hrResult = S_OK;
    m_pszResult = NULL;
    m_dwResult = 0;
    ZeroMemory(&m_rSource, sizeof(PROTOCOLSOURCE));
    ZeroMemory(&m_rDownload, sizeof(DOWNLOADSOURCE));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::~CInternetMessageUrl
// --------------------------------------------------------------------------------
CInternetMessageUrl::~CInternetMessageUrl(void)
{
    // These should have died in ::Terminate
    Assert(NULL == m_pProtSink && NULL == m_pBindInfo && NULL == m_rDownload.pTransport);

    // Release these objects anyways
    SafeRelease(m_pProtSink);
    SafeRelease(m_pBindInfo);
    SafeRelease(m_rDownload.pTransport);
    
    // Release LockBytes
    SafeRelease(m_rSource.pLockBytes);

    // Free Message Url
    SafeMemFree(m_pszUrl);
    SafeMemFree(m_pszResult);
    SafeMemFree(m_rDownload.pszFolder);
    SafeMemFree(m_rDownload.pszArticle);

    // Kill CS
    DeleteCriticalSection(&m_cs);

    // Release the Dll
    DllRelease();
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::PrivateQueryInterface
// --------------------------------------------------------------------------------
HRESULT CInternetMessageUrl::PrivateQueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Find IID
    if (IID_IOInetProtocol == riid)
        *ppv = (IOInetProtocol *)this;
    else if (IID_IOInetProtocolRoot == riid)
        *ppv = (IOInetProtocolRoot *)this;
    else if (IID_IServiceProvider == riid)
        *ppv = (IServiceProvider *)this;
    else if (IID_INNTPCallback == riid)
        *ppv = (INNTPCallback *)this;
    else if (IID_IPOP3Callback == riid)
        *ppv = (IPOP3Callback *)this;
    else if (IID_IIMAPCallback == riid)
        *ppv = (IIMAPCallback *)this;
    else
    {
        *ppv = NULL;
        hr = TrapError(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Start (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Start(LPCWSTR pwszUrl, IOInetProtocolSink *pProtSink, 
    IOInetBindInfo *pBindInfo, DWORD grfSTI, DWORD dwReserved)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pStream=NULL;
    LPSTR           pszUrl=NULL;

    // Invalid Args
    if (NULL == pwszUrl || NULL == pProtSink || NULL == pBindInfo)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // We Better not have been Initialized Yet...
    Assert(m_pProtSink == NULL && m_pBindInfo == NULL);

    // Convert URL to MultiByte
    CHECKALLOC(pszUrl = PszToANSI(CP_ACP, pwszUrl));

    // Convert URL to MultiByte
    CHECKALLOC(m_pszUrl = PszDupW(pwszUrl));

    // unescape the URL string
    CHECKHR(hr = UrlUnescapeInPlace(pszUrl, 0));

    // Transport From Url
    CHECKHR(hr = _HrTransportFromUrl(pszUrl));

    // Assume the Sink (QueryService below depends on m_pProtSink)
    m_pProtSink = pProtSink;
    m_pProtSink->AddRef();

    // Assume the BindInfo
    m_pBindInfo = pBindInfo;
    m_pBindInfo->AddRef();

    // Seek If I can get a lockbytes from the QueryService
    if (FAILED(QueryService(IID_IBindMessageStream, IID_IBindMessageStream, (LPVOID *)&pStream)))
    {
        // Create a Virtual Stream
        CHECKHR(hr = MimeOleCreateVirtualStream(&pStream));
    }

    // Create a ILockBytes
    CHECKALLOC(m_rSource.pLockBytes = new CStreamLockBytes(pStream));

    // If IMAP
    if (IXP_IMAP == m_rDownload.ixptype)
    {
        // Tell the Transport to connect
        CHECKHR(hr = m_rDownload.pTransport->Connect(&m_rDownload.rServer, TRUE, FALSE));
    }

    // Otherwise
    else
    {
        // Tell the Transport to connect
        CHECKHR(hr = m_rDownload.pTransport->Connect(&m_rDownload.rServer, TRUE, TRUE));
    }

    // all went well, return E_PENDING to indicate we're going ASYNC
    hr = E_PENDING;
   
exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pszUrl);

    // Failure
    if (E_PENDING != hr && FAILED(hr))
    {
        // Tell the sink about my mime type
        _OnFinished(hr);

        // Release some objects
        Terminate(0);
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::_HrTransportFromUrl
// ----------------------------------------------------------------------------
HRESULT CInternetMessageUrl::_HrTransportFromUrl(LPCSTR pszUrl)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szLogFile[MAX_PATH];

    // Invalid ARg
    Assert(pszUrl);

    // Get Windows system Directory
    GetSystemDirectory(szLogFile, MAX_PATH);
    if (szLogFile[lstrlen(szLogFile) - 1] != '\\')
        lstrcat(szLogFile, "\\Msgurlp.log");
    else
        lstrcat(szLogFile, "Msgurlp.log");

    // We should not have been inited
    Assert(NULL == m_rDownload.pTransport);

    // Default Timeout
    m_rDownload.rServer.dwTimeout = 30;
#ifdef DEBUG
    m_rDownload.rServer.fTrySicily = TRUE;
#endif

    // IXP_NNTP
    if (StrCmpNI(pszUrl, "nntp:", 5) == 0)
    {
        // Set the source Type
        m_rDownload.ixptype = IXP_NNTP;

        // Create the NNTP Transport
        CHECKHR(hr = CreateNNTPTransport(&m_rDownload.pIxpNntp));

        // Init the Transport
        CHECKHR(hr = m_rDownload.pIxpNntp->InitNew(szLogFile, (INNTPCallback *)this));

        // Save IInternetTranport Interface
        m_rDownload.pTransport = (IInternetTransport *)m_rDownload.pIxpNntp;

        // Default Port
        m_rDownload.rServer.dwPort = DEFAULT_NNTP_PORT;
    }

    // IXP_IMAP
    else if (StrCmpNI(pszUrl, "imap:", 5) == 0)
    {
        // Set the ixp type
        m_rDownload.ixptype = IXP_IMAP;

        // Create the IMAP Transport
        CHECKHR(hr = CreateIMAPTransport(&m_rDownload.pIxpImap));

        // Init the Transport
        CHECKHR(hr = m_rDownload.pIxpImap->InitNew(szLogFile, (IIMAPCallback *)this));

        // Save IInternetTranport Interface
        m_rDownload.pTransport = (IInternetTransport *)m_rDownload.pIxpImap;

        // Default Port
        m_rDownload.rServer.dwPort = DEFAULT_IMAP_PORT;
    }

    // IXP_POP3
    else if (StrCmpNI(pszUrl, "pop3:", 5) == 0)
    {
        // Set the protocol type
        m_rDownload.ixptype = IXP_POP3;

        // Create the POP3 Transport
        CHECKHR(hr = CreatePOP3Transport(&m_rDownload.pIxpPop3));

        // Init the Transport
        CHECKHR(hr = m_rDownload.pIxpPop3->InitNew(szLogFile, (IPOP3Callback *)this));

        // Save IInternetTranport Interface
        m_rDownload.pTransport = (IInternetTransport *)m_rDownload.pIxpPop3;

        // Default Port
        m_rDownload.rServer.dwPort = DEFAULT_POP3_PORT;
    }

    // Bad Protocol
    else
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Crack the Message Url
    CHECKHR(hr = _HrCrackMessageUrl(pszUrl));

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::_HrCrackMessageUrl
// ----------------------------------------------------------------------------
HRESULT CInternetMessageUrl::_HrCrackMessageUrl(LPCSTR pszUrl)
{
    // Locals
    HRESULT         hr=E_FAIL;
    CStringParser   cString;
    CHAR            chToken;

    // Invalid Args
    Assert(pszUrl && ':' == pszUrl[4]);

    // Init the Parser
    cString.Init(pszUrl, lstrlen(pszUrl), PSF_NOFRONTWS | PSF_NOTRAILWS);

    // Bad Length
    if (cString.GetLength() < 7)
        return TrapError(E_FAIL);

    // Parse
    chToken = cString.ChParse(":");
    if ('\0' == chToken)
        goto exit;

    // Bad Length
    if (cString.CchValue() > 4)
        return TrapError(E_FAIL);

    // Skip Tokens
    chToken = cString.ChSkip("\\/");
    if ('\0' == chToken)
        goto exit;

    // Bad Length
    if (cString.GetIndex() > 7)
        return TrapError(E_FAIL);

    // Skip Tokens
    chToken = cString.ChParse(":\\/");
    if ('\0' == chToken)
        goto exit;

    // This is the server name
    lstrcpyn(m_rDownload.rServer.szServerName, cString.PszValue(), CCHMAX_SERVER_NAME);

    // Extract Port Number
    if (':' == chToken)
    {
        // Skip Tokens
        chToken = cString.ChParse("\\/");
        if ('\0' == chToken)
            goto exit;

        // Convert the port number
        m_rDownload.rServer.dwPort = StrToInt(cString.PszValue());
    }

    // IXP_NNTP - nntp://<host>:<port>/<newsgroup-name>/<article-number>
    if (IXP_NNTP == m_rDownload.ixptype)
    {
        // Skip Tokens
        chToken = cString.ChParse("\\/");
        if ('\0' == chToken)
            goto exit;

        // Save the News group Name
        CHECKALLOC(m_rDownload.pszFolder = PszDupA(cString.PszValue()));

        // Skip Tokens
        chToken = cString.ChParse("\\/");
        if (0 == cString.CchValue())
            goto exit;

        // Save the article number
        CHECKALLOC(m_rDownload.pszArticle = PszDupA(cString.PszValue()));
    }

    // IXP_IMAP - nntp://<host>:<port>/<folder>/<uid>
    else if (IXP_IMAP == m_rDownload.ixptype)
    {
        // Skip Tokens
        chToken = cString.ChParse("\\/");
        if ('\0' == chToken)
            goto exit;

        // Save the Folder Name
        CHECKALLOC(m_rDownload.pszFolder = PszDupA(cString.PszValue()));

        // Skip Tokens
        chToken = cString.ChParse("\\/");
        if (0 == cString.CchValue())
            goto exit;

        // Save the article number
        m_rDownload.dwMessageId = StrToInt(cString.PszValue());
    }

    // IXP_POP3 - pop3://<host>:<port>/<popid>
    else if (IXP_POP3 == m_rDownload.ixptype)
    {
        // Skip Tokens
        chToken = cString.ChParse("\\/");
        if (0 == cString.CchValue())
            goto exit;

        // Save the article number
        m_rDownload.dwMessageId = StrToInt(cString.PszValue());
    }

    // Problems
    else
    {
        Assert(FALSE);
        goto exit;
    }

    // Success
    hr = S_OK;

exit:
    // Done
    return TrapError(hr);
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Continue (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Continue(PROTOCOLDATA *pStateInfo)
{
    // Locals
    HRESULT         hr=S_OK;
    PROTOCOLDATA    rProtocol;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Switch on the data
    switch(pStateInfo->dwState)
    {
    case TRANSPORT_DISCONNECT:
        // Not disconnected yet ?
        if (m_rDownload.pTransport->IsState(IXP_IS_CONNECTED) == S_OK)
        {
            // Setup the Protocol Data
            ZeroMemory(&rProtocol, sizeof(PROTOCOLDATA));
            rProtocol.grfFlags = PI_FORCE_ASYNC;
            rProtocol.dwState = DWLS_FINISHED;

            // Switch State
            m_pProtSink->Switch(&rProtocol);

            // Pending
            hr = E_PENDING;
        }

        // Otherwise, issue the final result
        else
        {
            // Final Result
            m_pProtSink->ReportResult(m_hrResult, m_dwResult, m_pszResult);
        }

        // Done
        break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Abort (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Abort(HRESULT hrReason, DWORD dwOptions)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // _OnFinished
    _OnFinished(IXP_E_USER_CANCEL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Terminate (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Terminate(DWORD dwOptions)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Better not be connected
    Assert(m_rDownload.pTransport->IsState(IXP_IS_CONNECTED) == S_FALSE);

    // Release the Transport
    SafeRelease(m_rDownload.pTransport);

    // Release Objects
    SafeRelease(m_pProtSink);
    SafeRelease(m_pBindInfo);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Suspend (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Suspend(void)
{
    return TrapError(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Resume (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Resume(void)
{
    return TrapError(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Read (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Read(LPVOID pv,ULONG cb, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call Utility Function
    CHECKHR(hr = HrPluggableProtocolRead(&m_rSource, pv, cb, pcbRead));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::Seek (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call Utility Function
    CHECKHR(hr = HrPluggableProtocolSeek(&m_rSource, dlibMove, dwOrigin, plibNew));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::LockRequest (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::LockRequest(DWORD dwOptions)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::UnlockRequest (IOInetProtocol)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::UnlockRequest(void)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CInternetMessageUrl::QueryService (IServiceProvider)
// --------------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::QueryService(REFGUID rsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT             hr=S_OK;
    IServiceProvider   *pSP=NULL;

    // Invalid Arg
    if (NULL == ppv)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Protocol Sink Yet ?
    if (NULL == m_pProtSink)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // QI the Sink for the IServiceProvider
    CHECKHR(hr = m_pProtSink->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP));

    // Query Service the Service Provider
    CHECKHR(hr = pSP->QueryService(rsid, riid, ppv));

exit:
    // Cleanup
    SafeRelease(pSP);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
} 

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnTimeout
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnTimeout(DWORD *pdwTimeout, IInternetTransport *pTransport)
{
    // _OnFinished
    _OnFinished(IXP_E_TIMEOUT);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnLogonPrompt
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnLogonPrompt(LPINETSERVER pInetServer, IInternetTransport *pTransport)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // $$TODO$$ User Logon Prompt
    lstrcpy(pInetServer->szUserName, "sbailey");
    lstrcpy(pInetServer->szPassword, "password");

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnPrompt
// ----------------------------------------------------------------------------
STDMETHODIMP_(INT) CInternetMessageUrl::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType, IInternetTransport *pTransport)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    INT nAnswer = MessageBox(NULL, pszText, pszCaption, uType);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return nAnswer;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnStatus
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnStatus(IXPSTATUS ixpstatus, IInternetTransport *pTransport)
{
    // Locals
    PROTOCOLDATA rProtocol;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Map IxpStatus to BINDSTATUS
    switch(ixpstatus)
    {
    case IXP_FINDINGHOST:
        m_pProtSink->ReportProgress(BINDSTATUS_FINDINGRESOURCE, m_pszUrl);
        break;

    case IXP_CONNECTING:
        m_pProtSink->ReportProgress(BINDSTATUS_CONNECTING, m_pszUrl);
        break;

    case IXP_SECURING:
        m_pProtSink->ReportProgress(BINDSTATUS_CONNECTING, m_pszUrl);
        break;

    case IXP_CONNECTED:
        m_pProtSink->ReportProgress(BINDSTATUS_CONNECTING, m_pszUrl);
        break;

    case IXP_AUTHORIZING:
        m_pProtSink->ReportProgress(BINDSTATUS_CONNECTING, m_pszUrl);
        break;

    case IXP_AUTHRETRY:
        m_pProtSink->ReportProgress(BINDSTATUS_CONNECTING, m_pszUrl);
        break;

    case IXP_AUTHORIZED:
        m_pProtSink->ReportProgress(BINDSTATUS_SENDINGREQUEST, m_pszUrl);

        // Select the folder
        if (IXP_IMAP == m_rDownload.ixptype)
        {
            // Issue Select
            HRESULT hr = m_rDownload.pIxpImap->Select(TRX_IMAP_SELECT, 0, NULL, m_rDownload.pszFolder);
            if (FAILED(hr))
            {
                _OnFinished(hr);
                goto exit;
            }
        }

        // Done
        break;

    case IXP_DISCONNECTED:
        // Setup for the protocol switch
        Assert(DWLS_FINISHED == m_state);
        ZeroMemory(&rProtocol, sizeof(PROTOCOLDATA));
        rProtocol.grfFlags = PI_FORCE_ASYNC;
        rProtocol.dwState = DWLS_FINISHED;

        // Switch State
        m_pProtSink->Switch(&rProtocol);
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnError
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnError(IXPSTATUS ixpstatus, LPIXPRESULT pResult, IInternetTransport *pTransport)
{
    // _OnFinished
    _OnFinished(pResult->hrResult, ixpstatus);

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnCommand
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnCommand(CMDTYPE cmdtype, LPSTR pszLine, HRESULT hrResponse, IInternetTransport *pTransport)
{
#ifdef DEBUG
    if (CMD_SEND == cmdtype)
        DebugTrace("SEND (hr = %0X): %s", hrResponse, pszLine);
    else
        DebugTrace("RECV (hr = %0X): %s", hrResponse, pszLine);

    // CR ?
    if (pszLine[lstrlen(pszLine) - 1] != '\n')
        DebugTrace("\n");
#endif

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnResponse (NNTP)
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnResponse(LPNNTPRESPONSE pResponse)
{
    // Switch on the Command
    switch(pResponse->state)
    {
    case NS_IDLE:
        break;
    }

    // Done
    return S_OK;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnResponse (POP3)
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnResponse(LPPOP3RESPONSE pResponse)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Failure
    if (FAILED(pResponse->rIxpResult.hrResult))
    {
        _OnFinished(pResponse->rIxpResult.hrResult);
        goto exit;
    }

    // Switch on the Command
    switch(pResponse->command)
    {
    case POP3_CONNECTED:
        // Issue STAT Command
        hr = m_rDownload.pIxpPop3->CommandSTAT();
        if (FAILED(hr))
        {
            _OnFinished(hr);
            goto exit;
        }

        // Done
        break;

    case POP3_STAT:
        // Issue List Command for this popid
        hr = m_rDownload.pIxpPop3->CommandLIST(POP3CMD_GET_POPID, m_rDownload.dwMessageId);
        if (FAILED(hr))
        {
            _OnFinished(hr);
            goto exit;
        }

        // Done
        break;

    case POP3_LIST:
        // Save Message Size
        Assert(pResponse->rListInfo.dwPopId == m_rDownload.dwMessageId);

        // Save the size
        m_rSource.cbTotalSize.QuadPart = pResponse->rListInfo.cbSize;

        // Size is known
        FLAGSET(m_rSource.dwFlags, INETPROT_TOTALSIZEKNOWN);
        
        // Issue Retr Command for this popid
        hr = m_rDownload.pIxpPop3->CommandRETR(POP3CMD_GET_POPID, m_rDownload.dwMessageId);
        if (FAILED(hr))
        {
            _OnFinished(hr);
            goto exit;
        }

        // Done
        break;


    case POP3_RETR:
        // Deliver the Information
        hr = _HrDispatchDataAvailable((LPBYTE)pResponse->rRetrInfo.pszLines, pResponse->rRetrInfo.cbLines, pResponse->fDone);
        if (FAILED(hr))
        {
            _OnFinished(hr);
            goto exit;
        }

        // Done
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::OnResponse (IMAP)
// ----------------------------------------------------------------------------
STDMETHODIMP CInternetMessageUrl::OnResponse(const IMAP_RESPONSE *pResponse)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szUID[50];
    LPBYTE      pbMessage=NULL;
    ULONG       cbMessage;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Switch on the Command
    switch(pResponse->irtResponseType)
    {
    case irtUPDATE_MSG:
        // Ignore it completely, we just care about the body
        break;

    case irtFETCH_BODY:
        // Deliver the Information
        hr = _HrDispatchDataAvailable((LPBYTE)pResponse->irdResponseData.pFetchBodyPart->pszData,
            pResponse->irdResponseData.pFetchBodyPart->dwSizeOfData,
            pResponse->irdResponseData.pFetchBodyPart->fDone);
        if (FAILED(hr))
        {
            _OnFinished(hr);
            goto exit;
        }

        // Done
        break;

    case irtCOMMAND_COMPLETION:
        switch(pResponse->wParam)
        {
        case TRX_IMAP_FETCH:
            // Failure
            if (FAILED(pResponse->hrResult))
            {
                _OnFinished(pResponse->hrResult);
                goto exit;
            }

            // Done
            break;

        case TRX_IMAP_SELECT:
            // Failure
            if (FAILED(pResponse->hrResult))
            {
                _OnFinished(pResponse->hrResult);
                goto exit;
            }

            // Format UID
            wsprintf(szUID, "%lu (RFC822)", m_rDownload.dwMessageId);

            // Select the folder
            hr = m_rDownload.pIxpImap->Fetch(TRX_IMAP_FETCH, 0, NULL, NULL, TRUE, szUID);
            if (FAILED(hr))
            {
                _OnFinished(hr);
                goto exit;
            }

            // Done
            break;
        }

        // Done
        break;
    }

exit:
    // Cleanup
    SafeMemFree(pbMessage);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CMessageDownload::_HrDispatchDataAvailable
// ----------------------------------------------------------------------------
HRESULT CInternetMessageUrl::_HrDispatchDataAvailable(LPBYTE pbData, ULONG cbData, BOOL fDone)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           grfBSCF;
    ULONG           cbWrote;

    // First Notification
    if (0 == m_rSource.offInternal.QuadPart)
    {
        // BindStatusCallback
        grfBSCF = BSCF_FIRSTDATANOTIFICATION;

        // Tell the sink about my mime type
        m_pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, L"message/rfc822");
    }

    // Last Notification
    else if (fDone)
    {
        // Finished
        FLAGSET(m_rSource.dwFlags, INETPROT_DOWNLOADED);

        // BindStatusCallback
        grfBSCF = BSCF_LASTDATANOTIFICATION;
    }

    // Intermediate Notification
    else
        grfBSCF = BSCF_INTERMEDIATEDATANOTIFICATION;

    // Write it into m_pLockBytes
    CHECKHR(hr = m_pLockBytes->WriteAt(m_rSource.offInternal, pbData, cbData, &cbWrote));

    // Another type of failure
    if (cbData != cbWrote)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Increment m_offInternal
    m_rSource.offInternal.QuadPart += cbWrote;

    // Increment m_cbCurrent
    if (m_rSource.offInternal.QuadPart + cbWrote > m_rSource.cbSize.QuadPart)
        m_rSource.cbSize.QuadPart = m_rSource.offInternal.QuadPart + cbWrote;

    // Increment Current
    m_rSource.offInternal.QuadPart += cbWrote;

    // Done ?
    if (fDone)
    {

        // Close Connection
        _OnFinished(S_OK);
    }

    // Report data to the sink
    m_pProtSink->ReportData(grfBSCF, (ULONG)m_rSource.offInternal.QuadPart, (ULONG)m_rSource.cbSize.QuadPart);

exit:
    // Done
    return hr;
}

// ----------------------------------------------------------------------------
// CInternetMessageUrl::_OnFinished
// ----------------------------------------------------------------------------
void CInternetMessageUrl::_OnFinished(HRESULT hrResult, DWORD dwResult, LPCWSTR pszResult)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If Not Finished
    if (DWLS_FINISHED != m_state)
    {
        // If Still Connected
        Assert(m_rDownload.pTransport->IsState(IXP_IS_CONNECTED) == S_OK);

        // Save the Result State
        m_hrResult = hrResult;

        //  Safe Result
        m_dwResult = dwResult;

        // Safe pszResult
        m_pszResult = PszDupW(pszResult);

        // Finished
        m_state = DWLS_FINISHED;

        // Start Disconnect
        if (FAILED(hrResult))
            m_rDownload.pTransport->DropConnection();

        // Graceful disconnect
        else
            m_rDownload.pTransport->Disconnect();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpras.cpp ===
// --------------------------------------------------------------------------------
// Ixpras.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "ixpras.h"
#include "strconst.h"
#include "resource.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// RAS API Typedefs
// --------------------------------------------------------------------------------
typedef DWORD (APIENTRY *RASDIALPROC)(LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (APIENTRY *RASENUMCONNECTIONSPROC)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASENUMENTRIESPROC)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASGETCONNECTSTATUSPROC)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROC)(UINT, LPTSTR, DWORD);
typedef DWORD (APIENTRY *RASHANGUPPROC)(HRASCONN);
typedef DWORD (APIENTRY *RASSETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL);
typedef DWORD (APIENTRY *RASGETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL*);
typedef DWORD (APIENTRY *RASCREATEPHONEBOOKENTRYPROC)(HWND, LPTSTR);
typedef DWORD (APIENTRY *RASEDITPHONEBOOKENTRYPROC)(HWND, LPTSTR, LPTSTR);                                                    

// --------------------------------------------------------------------------------
// RAS Function Pointers
// --------------------------------------------------------------------------------
static RASDIALPROC                 g_pRasDial=NULL;
static RASENUMCONNECTIONSPROC      g_pRasEnumConnections=NULL;
static RASENUMENTRIESPROC          g_pRasEnumEntries=NULL;
static RASGETCONNECTSTATUSPROC     g_pRasGetConnectStatus=NULL;
static RASGETERRORSTRINGPROC       g_pRasGetErrorString=NULL;
static RASHANGUPPROC               g_pRasHangup=NULL;
static RASSETENTRYDIALPARAMSPROC   g_pRasSetEntryDialParams=NULL;
static RASGETENTRYDIALPARAMSPROC   g_pRasGetEntryDialParams=NULL;
static RASCREATEPHONEBOOKENTRYPROC g_pRasCreatePhonebookEntry=NULL;
static RASEDITPHONEBOOKENTRYPROC   g_pRasEditPhonebookEntry=NULL;

#define DEF_HANGUP_WAIT            10 // Seconds

// --------------------------------------------------------------------------------
// Make our code look prettier
// --------------------------------------------------------------------------------
#undef RasDial
#undef RasEnumConnections
#undef RasEnumEntries
#undef RasGetConnectStatus
#undef RasGetErrorString
#undef RasHangup
#undef RasSetEntryDialParams
#undef RasGetEntryDialParams
#undef RasCreatePhonebookEntry
#undef RasEditPhonebookEntry

#define RasDial                    (*g_pRasDial)
#define RasEnumConnections         (*g_pRasEnumConnections)
#define RasEnumEntries             (*g_pRasEnumEntries)
#define RasGetConnectStatus        (*g_pRasGetConnectStatus)
#define RasGetErrorString          (*g_pRasGetErrorString)
#define RasHangup                  (*g_pRasHangup)
#define RasSetEntryDialParams      (*g_pRasSetEntryDialParams)
#define RasGetEntryDialParams      (*g_pRasGetEntryDialParams)
#define RasCreatePhonebookEntry    (*g_pRasCreatePhonebookEntry)
#define RasEditPhonebookEntry      (*g_pRasEditPhonebookEntry)

// --------------------------------------------------------------------------------
// HrLoadRAS
// --------------------------------------------------------------------------------
HRESULT HrLoadRAS(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UINT        uOldErrorMode;

    // Thread Safety
    EnterCriticalSection(&g_csRAS);

    // If dll is loaded, lets verify all of my function pointers
    if (g_hinstRAS)
        goto exit;

    // Bug #20573 - Let's do a little voodoo here.  On NT, it appears that they
    //              have a key in the registry to show which protocols are 
    //              supported by RAS service.  AKA - if this key doesn't exist,
    //              then RAS isn't installed.  This may enable us to avoid some
    //              special bugs when RAS get's uninstalled on NT.
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&os);

    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
        HKEY hKey;
        const TCHAR c_szRegKeyRAS[] = TEXT("SOFTWARE\\Microsoft\\RAS");

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyRAS, 0, KEY_READ, &hKey))
            {
            hr = TrapError(IXP_E_RAS_NOT_INSTALLED);
            goto exit;
            }

        RegCloseKey(hKey);
        }

    // Try loading RAS
    uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    g_hinstRAS = LoadLibraryA("RASAPI32.DLL");
    SetErrorMode(uOldErrorMode);

    // Failure ?
    if (NULL == g_hinstRAS)
    {
        hr = TrapError(IXP_E_RAS_NOT_INSTALLED);
        goto exit;
    }

    // Did we load it
    g_pRasDial                  = (RASDIALPROC)GetProcAddress(g_hinstRAS, c_szRasDial);
    g_pRasEnumConnections       = (RASENUMCONNECTIONSPROC)GetProcAddress(g_hinstRAS, c_szRasEnumConnections);                    
    g_pRasEnumEntries           = (RASENUMENTRIESPROC)GetProcAddress(g_hinstRAS, c_szRasEnumEntries);                    
    g_pRasGetConnectStatus      = (RASGETCONNECTSTATUSPROC)GetProcAddress(g_hinstRAS, c_szRasGetConnectStatus);                    
    g_pRasGetErrorString        = (RASGETERRORSTRINGPROC)GetProcAddress(g_hinstRAS, c_szRasGetErrorString);                    
    g_pRasHangup                = (RASHANGUPPROC)GetProcAddress(g_hinstRAS, c_szRasHangup);                    
    g_pRasSetEntryDialParams    = (RASSETENTRYDIALPARAMSPROC)GetProcAddress(g_hinstRAS, c_szRasSetEntryDialParams);                    
    g_pRasGetEntryDialParams    = (RASGETENTRYDIALPARAMSPROC)GetProcAddress(g_hinstRAS, c_szRasGetEntryDialParams);
    g_pRasCreatePhonebookEntry  = (RASCREATEPHONEBOOKENTRYPROC)GetProcAddress(g_hinstRAS, c_szRasCreatePhonebookEntry);    
    g_pRasEditPhonebookEntry    = (RASEDITPHONEBOOKENTRYPROC)GetProcAddress(g_hinstRAS, c_szRasEditPhonebookEntry);    

    // Make sure all functions have been loaded
    if (g_pRasDial                      &&
        g_pRasEnumConnections           &&
        g_pRasEnumEntries               &&
        g_pRasGetConnectStatus          &&
        g_pRasGetErrorString            &&
        g_pRasHangup                    &&
        g_pRasSetEntryDialParams        &&
        g_pRasGetEntryDialParams        &&
        g_pRasCreatePhonebookEntry      &&
        g_pRasEditPhonebookEntry)
        goto exit;

    // Failure...
    hr = TrapError(IXP_E_RAS_PROCS_NOT_FOUND);

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csRAS);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::CRASTransport
// --------------------------------------------------------------------------------
CRASTransport::CRASTransport(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pCallback = NULL;
    *m_szConnectoid = '\0';
    m_hConn = NULL;
    m_fConnOwner = FALSE;
    m_hwndRAS = NULL;
    m_uRASMsg = 0;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    ZeroMemory(&m_rDialParams, sizeof(RASDIALPARAMS));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CRASTransport::~CRASTransport
// --------------------------------------------------------------------------------
CRASTransport::~CRASTransport(void)
{
    EnterCriticalSection(&m_cs);
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    SafeRelease(m_pCallback);
    *m_szConnectoid = '\0';
    m_hConn = NULL;
    if (m_hwndRAS)
        DestroyWindow(m_hwndRAS);
    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CRASTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)this);

    // IID_IRASTransport
    else if (IID_IRASTransport == riid)
        *ppv = (IRASTransport *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASTransport::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CRASTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASTransport::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CRASTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::HandsOffCallback(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No current callback
    if (NULL == m_pCallback)
    {
        hr = TrapError(S_FALSE);
        goto exit;
    }

    // Release it
    SafeRelease(m_pCallback);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::InitNew(IRASCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pCallback)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release current callback
    SafeRelease(m_pCallback);

    // Assume new callback
    m_pCallback = pCallback;
    m_pCallback->AddRef();

    // Have I Create my modeless window for RAS connections yet?
    if (NULL == m_hwndRAS)
    {
        // Create Modeless Window
        m_hwndRAS = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(IDD_RASCONNECT), NULL, (DLGPROC)RASConnectDlgProc, (LPARAM)this);
        if (NULL == m_hwndRAS)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Get registered RAS event message id
        m_uRASMsg = RegisterWindowMessageA(RASDIALEVENT);
        if (m_uRASMsg == 0)
            m_uRASMsg = WM_RASDIALEVENT;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetCurrentConnectoid
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::GetCurrentConnectoid(LPSTR pszConnectoid, ULONG cchMax)
{
    // Locals
    HRESULT     hr=S_OK;
    LPRASCONN   prgConnection=NULL;
    DWORD       cConnection;

    // Invalid Arg
    if (NULL == pszConnectoid || cchMax < CCHMAX_CONNECTOID)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Current RAS Connection
    if (FEnumerateConnections(&prgConnection, &cConnection) == 0 || 0 == cConnection)
    {
        hr = IXP_E_NOT_CONNECTED;
        goto exit;
    }

    // Is there at l
    lstrcpyn(pszConnectoid, prgConnection[0].szEntryName, cchMax);

exit:
    // Cleanup
    SafeMemFree(prgConnection);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRASCONN       prgConn=NULL;
    DWORD           cConn,
                    dwError;

    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // RAS_CONNECT_RAS ?
    if (RAS_CONNECT_RAS != pInetServer->rasconntype)
        return IXP_S_RAS_NOT_NEEDED;

    // Empty Connectoid
    if (FIsEmptyA(pInetServer->szConnectoid))
        return TrapError(IXP_E_RAS_INVALID_CONNECTOID);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Initialized
    if (NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // LoadRAS
    CHECKHR(hr = HrLoadRAS());

    // Save pInetServer
    CopyMemory(&m_rServer, pInetServer, sizeof(INETSERVER));

    // No Current Known Connection
    if (NULL == m_hConn)
    {
        // Get Current RAS Connection
        if (FEnumerateConnections(&prgConn, &cConn) && cConn > 0)
        {
            m_fConnOwner = FALSE;
            m_hConn = prgConn[0].hrasconn;
            lstrcpyn(m_szConnectoid, prgConn[0].szEntryName, CCHMAX_CONNECTOID);
        }
    }

    // Otherwise, verify the connection status
    else
    {
        // Locals
        RASCONNSTATUS   rcs;

        // Get Connection Status
        rcs.dwSize = sizeof(RASCONNSTATUS);
        dwError = RasGetConnectStatus(m_hConn, &rcs);
        if (dwError || rcs.dwError || RASCS_Disconnected == rcs.rasconnstate)
        {
            m_fConnOwner = FALSE;
            m_hConn = NULL;
            *m_szConnectoid = '\0';
        }
    }

    // If RAS Connection present, is it equal to suggested
    if (m_hConn)
    {
        // Better have a connectoid
        Assert(*m_szConnectoid);

        // Current connection is what I want ?
        if (lstrcmpi(m_szConnectoid, m_rServer.szConnectoid) == 0)
        {
            m_pCallback->OnRasDialStatus(RASCS_Connected, 0, this);
            hr = IXP_S_RAS_USING_CURRENT;
            goto exit;
        }

        // Otherwise, if we didn't start the RAS connection...
        else if (FALSE == m_fConnOwner)
        {
            // Prompt to Close un-owner current connection...
            hr = m_pCallback->OnReconnect(m_szConnectoid, m_rServer.szConnectoid, this);

            // Cancel ?
            if (IXP_E_USER_CANCEL == hr)
                goto exit;

            // Use Current Connection...
            else if (S_FALSE == hr)
            {
                hr = IXP_S_RAS_USING_CURRENT;
                goto exit;
            }

            // Close Current ?
            else
            {
                FRasHangupAndWait(DEF_HANGUP_WAIT);
            }
        }

        // Otherwise, I started the connection, so close it
        else if (m_fConnOwner == TRUE)
        {
            FRasHangupAndWait(DEF_HANGUP_WAIT);
        }
    }

    // We probably shouldn't have a connection handle at this point
    Assert(m_hConn == NULL);

    // Dial the connection
    CHECKHR(hr = HrStartRasDial());

    // If Synchronous -- Woo - hoo were connected and we started the connection
    m_fConnOwner = TRUE;
    lstrcpy(m_szConnectoid, m_rServer.szConnectoid);

exit:
    // Cleanup
    SafeMemFree(prgConn);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::HrStartRasDial
// --------------------------------------------------------------------------------
HRESULT CRASTransport::HrStartRasDial(void)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fRetry=FALSE;
    DWORD           dwError;

    // Prompt for while
    while(1)
    {
        // Logon first ?
        hr = HrLogon(fRetry);
        if (FAILED(hr))
            goto exit;

        // If Succeeded
#ifndef WIN16
        dwError = RasDial(NULL, NULL, &m_rDialParams, 0xFFFFFFFF, m_hwndRAS, &m_hConn);
#else
        dwError = RasDial(NULL, NULL, &m_rDialParams, 0xFFFFFFFF, (LPVOID)m_hwndRAS, &m_hConn);
#endif
        if (dwError == 0)
            break;

        // Lets feed the user the error
        m_pCallback->OnRasDialStatus(RASCS_Disconnected, dwError, this);

        // Retry Logon
        fRetry = TRUE;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::RASConnectDlgProc
// --------------------------------------------------------------------------------
INT_PTR CALLBACK CRASTransport::RASConnectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    CRASTransport  *pTransport=(CRASTransport *)GetWndThisPtr(hwnd);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        pTransport = (CRASTransport *)lParam;
        Assert(pTransport);
        SetWndThisPtr(hwnd, pTransport);
        return 0;

    case WM_DESTROY:
        SetWndThisPtr(hwnd, NULL);
        break;

    default:
        if (NULL != pTransport)
        {
            // Thread Safety
            EnterCriticalSection(&pTransport->m_cs);

            // Our Message
            if (NULL != pTransport->m_pCallback && uMsg == pTransport->m_uRASMsg)
            {
                // Handle Error
                if (lParam)
                {
                    // Hangup
                    if (pTransport->m_hConn)
                        pTransport->FRasHangupAndWait(DEF_HANGUP_WAIT);
                }

                // Give to callback
                pTransport->m_pCallback->OnRasDialStatus((RASCONNSTATE)wParam, (DWORD) lParam, pTransport);
            }

            // thread Safety
            LeaveCriticalSection(&pTransport->m_cs);
        }
    }

    // Done
    return 0;
}

// --------------------------------------------------------------------------------
// CRASTransport::HrLogon
// --------------------------------------------------------------------------------
HRESULT CRASTransport::HrLogon(BOOL fForcePrompt)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwRasError;
    BOOL            fSavePassword;

    // Do we need to prompt for logon information first ?
    ZeroMemory(&m_rDialParams, sizeof(RASDIALPARAMS));
    m_rDialParams.dwSize = sizeof(RASDIALPARAMS);
    Assert(sizeof(m_rDialParams.szEntryName) >= sizeof(m_rServer.szConnectoid));
    lstrcpyn(m_rDialParams.szEntryName, m_rServer.szConnectoid, sizeof(m_rDialParams.szEntryName));

    // Get params
    dwRasError = RasGetEntryDialParams(NULL, &m_rDialParams, &fSavePassword);
    if (dwRasError)
    {
        hr = TrapError(IXP_E_RAS_GET_DIAL_PARAMS);
        goto exit;
    }

    // Do we need to get password / account information
    if (fForcePrompt   || 
        !fSavePassword || 
        FIsEmpty(m_rDialParams.szUserName) || 
        FIsEmpty(m_rDialParams.szPassword))
    {
        // Locals
        IXPRASLOGON rLogon;

        // Init
        ZeroMemory(&rLogon, sizeof(IXPRASLOGON));

        // Fill Logon Data...
        lstrcpyn(rLogon.szConnectoid, m_rDialParams.szEntryName, ARRAYSIZE(rLogon.szConnectoid));
        lstrcpyn(rLogon.szUserName, m_rDialParams.szUserName, ARRAYSIZE(rLogon.szUserName));
        lstrcpyn(rLogon.szPassword, m_rDialParams.szPassword, ARRAYSIZE(rLogon.szPassword));
        lstrcpyn(rLogon.szDomain, m_rDialParams.szDomain, ARRAYSIZE(rLogon.szDomain));
        lstrcpyn(rLogon.szPhoneNumber, m_rDialParams.szPhoneNumber, ARRAYSIZE(rLogon.szPhoneNumber));
        rLogon.fSavePassword = fSavePassword;

        // Prompt
        hr = m_pCallback->OnLogonPrompt(&rLogon, this);

        // If OK, lets save the settings
        if (S_OK == hr)
        {
            // Copy parameters back
            lstrcpyn(m_rDialParams.szUserName, rLogon.szUserName, ARRAYSIZE(m_rDialParams.szUserName));
            lstrcpyn(m_rDialParams.szPassword, rLogon.szPassword, ARRAYSIZE(m_rDialParams.szPassword));
            lstrcpyn(m_rDialParams.szDomain, rLogon.szDomain, ARRAYSIZE(m_rDialParams.szDomain));
            lstrcpyn(m_rDialParams.szPhoneNumber, rLogon.szPhoneNumber, ARRAYSIZE(m_rDialParams.szPhoneNumber));

            // Save the dial params
            if (RasSetEntryDialParams(NULL, &m_rDialParams, !rLogon.fSavePassword))
            {
                Assert(FALSE);
                TrapError(E_FAIL);
            }
        }

        // RAID-26845 - RAS Transport: Canceling RAS Logon doesn't cancel
        else
        {
            hr = TrapError(IXP_E_USER_CANCEL);
            goto exit;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::DropConnection(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Hangup
    if (m_hConn)
        FRasHangupAndWait(DEF_HANGUP_WAIT);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CRASTransport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::Disconnect(void)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If not using RAS, who give a crap
    if (RAS_CONNECT_RAS != m_rServer.rasconntype)
    {
        Assert(m_hConn == NULL);
        Assert(m_fConnOwner == FALSE);
        goto exit;
    }

    // Do we have a RAS connection
    if (m_hConn)
    {
        if (m_pCallback->OnDisconnect(m_szConnectoid, (boolean) !!m_fConnOwner, this) == S_OK)
            FRasHangupAndWait(DEF_HANGUP_WAIT);
    }

    // Pretend the connection is owned by the user
    m_hConn = NULL;
    m_fConnOwner = FALSE;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::IsState(IXPISSTATE isstate)
{
    // Locals
    HRESULT         hr=S_FALSE;

    // Thread Safety
	EnterCriticalSection(&m_cs);

    // Initialized
    if (NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }                               

    // Lets validate m_hConn first
    if (NULL != m_hConn)
    {
        // Get Connection Status
        RASCONNSTATUS rcs;
        DWORD dwError;

        // Setup Structure Size
        rcs.dwSize = sizeof(RASCONNSTATUS);

        // Get Ras Connection Status
        dwError = RasGetConnectStatus(m_hConn, &rcs);
        
        // Failure or not connected
        if (dwError || rcs.dwError || RASCS_Disconnected == rcs.rasconnstate)
        {
            m_fConnOwner = FALSE;
            m_hConn = NULL;
            *m_szConnectoid = '\0';
        }
    }

    // Handle IsType
    switch(isstate)
    {
    // Are we connected
    case IXP_IS_CONNECTED:
        hr = (m_hConn) ? S_OK : S_FALSE;
        break;

    // Are we busy
    case IXP_IS_BUSY:
        if (NULL == m_hConn)
            hr = IXP_E_NOT_CONNECTED;
        else
            hr = S_FALSE;
        break;

    // Are we busy
    case IXP_IS_READY:
        if (NULL == m_hConn)
            hr = IXP_E_NOT_CONNECTED;
        else
            hr = S_OK;
        break;

    // Have we been authenticated yet
    case IXP_IS_AUTHENTICATED:
        if (NULL == m_hConn)
            hr = IXP_E_NOT_CONNECTED;
        else
            hr = S_OK;
        break;

    // Unhandled ixpistype
    default:
        IxpAssert(FALSE);
        break;
    }

exit:
    // Thread Safety
	LeaveCriticalSection(&m_cs);

    // Done
	return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::GetServerInfo(LPINETSERVER pInetServer)
{
    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Copy Server information
    CopyMemory(pInetServer, &m_rServer, sizeof(INETSERVER));

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CRASTransport::GetIXPType(void)
{
    return IXP_RAS;
}

// --------------------------------------------------------------------------------
// CRASTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CRASTransport::FEnumerateConnections
// --------------------------------------------------------------------------------
BOOL CRASTransport::FEnumerateConnections(LPRASCONN *pprgConn, ULONG *pcConn)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw, 
                dwSize;
    BOOL        fResult=FALSE;

    // Check Params
    Assert(pprgConn && pcConn);

    // Init
    *pprgConn = NULL;
    *pcConn = 0;

    // Sizeof my buffer
    dwSize = sizeof(RASCONN);

    // Allocate enough for 1 ras connection info object
    CHECKHR(hr = HrAlloc((LPVOID *)pprgConn, dwSize));

    // Buffer size
    (*pprgConn)->dwSize = dwSize;

    // Enumerate ras connections
    dw = RasEnumConnections(*pprgConn, &dwSize, pcConn);

    // Not enough memory ?
    if (dw == ERROR_BUFFER_TOO_SMALL)
    {
        // Reallocate
        CHECKHR(hr = HrRealloc((LPVOID *)pprgConn, dwSize));
        *pcConn = 0;
        (*pprgConn)->dwSize = sizeof(RASCONN);
        dw = RasEnumConnections(*pprgConn, &dwSize, pcConn);
    }

    // If still failed
    if (dw)
    {
        AssertSz(FALSE, "RasEnumConnections failed");
        goto exit;
    }

    // Success
    fResult = TRUE;

exit:
    // Done
    return fResult;
}

// --------------------------------------------------------------------------------
// CRASTransport::FFindConnection
// --------------------------------------------------------------------------------
BOOL CRASTransport::FFindConnection(LPSTR pszConnectoid, LPHRASCONN phConn)
{
    // Locals
    ULONG       cConn,
                i;
    LPRASCONN   prgConn=NULL;
    BOOL        fResult=FALSE;

    // Check Params
    Assert(pszConnectoid && phConn);

    // Init
    *phConn = NULL;

    // Enumerate Connections
    if (!FEnumerateConnections(&prgConn, &cConn))
        goto exit;

    // If still failed
    for (i=0; i<cConn; i++)
    {
        if (lstrcmpi(prgConn[i].szEntryName, pszConnectoid) == 0)
        {
            *phConn = prgConn[i].hrasconn;
            fResult = TRUE;
            goto exit;
        }
    }

exit:
    // Cleanup
    SafeMemFree(prgConn);

    // Done
    return fResult;
}

// --------------------------------------------------------------------------------
// CRASTransport::FRasHangupAndWait
// --------------------------------------------------------------------------------
BOOL CRASTransport::FRasHangupAndWait(DWORD dwMaxWaitSeconds)
{
    // Locals
    RASCONNSTATUS   rcs;
    DWORD           dwTicks=GetTickCount();

    // Check Params
    Assert(m_hConn);
    if (NULL == m_hConn || RasHangup(m_hConn))
    {
        m_hConn = NULL;
        m_fConnOwner = FALSE;
        *m_szConnectoid = '\0';
        return FALSE;
    }

    // Wait for connection to really close
    ZeroMemory(&rcs, sizeof(RASCONNSTATUS));
    rcs.dwSize = sizeof(RASCONNSTATUS);
    while (RasGetConnectStatus(m_hConn, &rcs) == 0 && rcs.rasconnstate != RASCS_Disconnected)
    {
        // Wait timeout
        if (GetTickCount() - dwTicks >= dwMaxWaitSeconds * 1000)
            break;

        // Sleep and yields
        Sleep(0);
    }

    // Wait 2 seconds for modem to reset
    Sleep(2000);

    // Reset
    m_hConn = NULL;
    m_fConnOwner = FALSE;
    *m_szConnectoid = '\0';

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// CRASTransport::FillConnectoidCombo
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::FillConnectoidCombo(HWND hwndComboBox, boolean fUpdateOnly, DWORD *pdwRASResult)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (NULL == hwndComboBox || FALSE == IsWindow(hwndComboBox))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call global function
    CHECKHR(hr = HrFillRasCombo(hwndComboBox, fUpdateOnly, pdwRASResult));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::EditConnectoid
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::EditConnectoid(HWND hwndParent, LPSTR pszConnectoid, DWORD *pdwRASResult)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pszConnectoid)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call general function
    CHECKHR(hr = HrEditPhonebookEntry(hwndParent, pszConnectoid, pdwRASResult));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetRasErrorString
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::GetRasErrorString(UINT uRasErrorValue, LPSTR pszErrorString, ULONG cchMax, DWORD *pdwRASResult)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pdwRASResult || 0 == uRasErrorValue || NULL == pszErrorString || cchMax <= 1)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Make Sure RAS is Loaded
    CHECKHR(hr = HrLoadRAS());

    // Call RAS Function
    *pdwRASResult = RasGetErrorString(uRasErrorValue, pszErrorString, cchMax);
    if (*pdwRASResult)
    {
        hr = TrapError(IXP_E_RAS_ERROR);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::CreateConnectoid
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::CreateConnectoid(HWND hwndParent, DWORD *pdwRASResult)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call General Function
    CHECKHR(hr = HrCreatePhonebookEntry(hwndParent, pdwRASResult));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpsmtp.cpp ===
// --------------------------------------------------------------------------------
// Ixpsmtp.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "asynconn.h"
#include "ixpsmtp.h"
#include "ixputil.h"  
#include "strconst.h"
#include <shlwapi.h>
#include <demand.h>

// --------------------------------------------------------------------------------
// Useful C++ pointer casting
// --------------------------------------------------------------------------------
#define SMTPTHISIXP         ((ISMTPTransport *)(CIxpBase *)this)

// --------------------------------------------------------------------------------
// Some string constants
// --------------------------------------------------------------------------------

// These constants are from the draft spec for SMTP authenication
// draft-myers-smtp-auth-11.txt
static const char   g_szSMTPAUTH11[]    = "AUTH ";
static const int    g_cchSMTPAUTH11     = sizeof(g_szSMTPAUTH11) - 1;

// These constants are from the draft spec for SMTP authenication
// draft-myers-smtp-auth-10.txt
static const char   g_szSMTPAUTH10[]    = "AUTH=";
static const int    g_cchSMTPAUTH10     = sizeof(g_szSMTPAUTH10) - 1;

// These constants are from the draft spec for Secure SMTP over TLS
// draft-hoffman-smtp-ssl-08.txt
static const char   g_szSMTPSTARTTLS08[]    = "STARTTLS";
static const int    g_cchSMTPSTARTTLS08     = sizeof(g_szSMTPSTARTTLS08) - 1;

// These constants are from the draft spec for Secure SMTP over TLS
// draft-hoffman-smtp-ssl-06.txt
static const char   g_szSMTPSTARTTLS06[]    = "TLS";
static const int    g_cchSMTPSTARTTLS06     = sizeof(g_szSMTPSTARTTLS06) - 1;

// These constants are from RFC1891 for DSN support
static const char   g_szSMTPDSN[]  = "DSN";
static const int    g_cchSMTPDSN   = sizeof(g_szSMTPDSN) - 1;

static const char g_szDSNENVID[]   = "ENVID=";

static const char g_szDSNRET[]     = "RET=";

static const char g_szDSNHDRS[]    = "HDRS";
static const char g_szDSNFULL[]    = "FULL";

static const char g_szDSNNOTIFY[]  = "NOTIFY=";

static const char g_szDSNNEVER[]   = "NEVER";
static const char g_szDSNSUCCESS[] = "SUCCESS";
static const char g_szDSNFAILURE[] = "FAILURE";
static const char g_szDSNDELAY[]   = "DELAY";


// --------------------------------------------------------------------------------
// CSMTPTransport::CSMTPTransport
// --------------------------------------------------------------------------------
CSMTPTransport::CSMTPTransport(void) : CIxpBase(IXP_SMTP)
{
    DllAddRef();
    m_command = SMTP_NONE;
    m_iAddress = 0;
    m_cRecipients = 0;
    m_cbSent = 0;
    m_cbTotal = 0;
    m_fReset = FALSE;
    m_fSendMessage = FALSE;
    m_fSTARTTLSAvail = FALSE;
    m_fTLSNegotiation = FALSE;
    m_fSecured = FALSE;
    *m_szEmail = '\0';
    ZeroMemory(&m_rAuth, sizeof(m_rAuth));
    ZeroMemory(&m_rMessage, sizeof(SMTPMESSAGE2));
    m_fDSNAvail= FALSE;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::~CSMTPTransport
// --------------------------------------------------------------------------------
CSMTPTransport::~CSMTPTransport(void)
{
    ResetBase();
    DllRelease();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::ResetBase
// --------------------------------------------------------------------------------
void CSMTPTransport::ResetBase(void)
{
    EnterCriticalSection(&m_cs);
    FreeAuthInfo(&m_rAuth);
    m_command = SMTP_NONE;
    m_fSendMessage = FALSE;
    m_iAddress = 0;
    m_cRecipients = 0;
    m_cbSent = 0;
    m_fSTARTTLSAvail = FALSE;
    m_fTLSNegotiation = FALSE;
    m_fSecured = FALSE;
    SafeRelease(m_rMessage.smtpMsg.pstmMsg);
    SafeMemFree(m_rMessage.smtpMsg.rAddressList.prgAddress);
    SafeMemFree(m_rMessage.pszDSNENVID);
    ZeroMemory(&m_rMessage, sizeof(SMTPMESSAGE2));
    m_fDSNAvail= FALSE;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(ISMTPTransport2 *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)(CIxpBase *)this);

    // IID_ISMTPTransport
    else if (IID_ISMTPTransport == riid)
        *ppv = (ISMTPTransport *)this;

    // IID_ISMTPTransport2
    else if (IID_ISMTPTransport2 == riid)
        *ppv = (ISMTPTransport2 *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPTransport::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPTransport::Release(void) 
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::HandsOffCallback(void)
{
    return CIxpBase::HandsOffCallback();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::GetStatus(IXPSTATUS *pCurrentStatus)
{
    return CIxpBase::GetStatus(pCurrentStatus);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::InitNew(LPSTR pszLogFilePath, ISMTPCallback *pCallback)
{
    return CIxpBase::OnInitNew("SMTP", pszLogFilePath, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (ITransportCallback *)pCallback);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Check if user wants us to always prompt for password. Prompt before we connect
    // to avoid inactivity disconnections
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD))
    {
        HRESULT hr;

        if (NULL != m_pCallback)
            hr = m_pCallback->OnLogonPrompt(pInetServer, SMTPTHISIXP);

        if (NULL == m_pCallback || S_OK != hr)
            return IXP_E_USER_CANCEL;
    }

    return CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::DropConnection(void)
{
    return CIxpBase::DropConnection();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::Disconnect(void)
{
    return CIxpBase::Disconnect();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::IsState(IXPISSTATE isstate)
{
    return CIxpBase::IsState(isstate);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::GetServerInfo(LPINETSERVER pInetServer)
{
    return CIxpBase::GetServerInfo(pInetServer);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CSMTPTransport::GetIXPType(void)
{
    return CIxpBase::GetIXPType();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::SendMessage(LPSMTPMESSAGE pMessage)
{
	SMTPMESSAGE2 pMessage2= {0};

	pMessage2.smtpMsg= *pMessage;
	return SendMessage2(&pMessage2);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMessage2
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::SendMessage2(LPSMTPMESSAGE2 pMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fDSNAvail= FALSE;

    // check params
    if (NULL == pMessage || NULL == pMessage->smtpMsg.pstmMsg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

	// Enter Busy
    CHECKHR(hr = HrEnterBusy());

    // Zero Init Current State
    fDSNAvail = m_fDSNAvail; // save DSN state!
    ResetBase();
    m_fDSNAvail = fDSNAvail;

    // Special State in this transport
    m_fSendMessage = TRUE;

    // Copy Mesage
    m_rMessage.smtpMsg.pstmMsg = pMessage->smtpMsg.pstmMsg;
    m_rMessage.smtpMsg.pstmMsg->AddRef();

    // Copy the Address List
    m_rMessage.smtpMsg.rAddressList.cAddress = pMessage->smtpMsg.rAddressList.cAddress;
    CHECKHR(hr = HrAlloc((LPVOID *)&m_rMessage.smtpMsg.rAddressList.prgAddress, sizeof(INETADDR) *  m_rMessage.smtpMsg.rAddressList.cAddress));
    CopyMemory(m_rMessage.smtpMsg.rAddressList.prgAddress, pMessage->smtpMsg.rAddressList.prgAddress, sizeof(INETADDR) *  m_rMessage.smtpMsg.rAddressList.cAddress);

    // Copy the message Size
    m_rMessage.smtpMsg.cbSize = pMessage->smtpMsg.cbSize;

    // Copy DSN data
    if(pMessage->pszDSNENVID)
    {
    	// ENVID max length is 100 characters
    	ULONG cbAlloc= max(lstrlen(pMessage->pszDSNENVID) + 1, 101);
    	CHECKALLOC(m_rMessage.pszDSNENVID = (LPSTR)g_pMalloc->Alloc(cbAlloc));
    	lstrcpyn(m_rMessage.pszDSNENVID, pMessage->pszDSNENVID, 101);
    }
    m_rMessage.dsnRet = pMessage->dsnRet;

    // Send RSET command (this initiates a send)
    if (m_fReset)
    {
        // Send the RSET command
        CHECKHR(hr = CommandRSET());
    }

    // Otherwise, start sending this message
    else
    {
        // Start sending this message
        SendMessage_MAIL();

        // A reset will be needed
        m_fReset = TRUE;
    }

    // return warning if client requested DSN but it isn't available
    if((m_rServer.dwFlags & ISF_QUERYDSNSUPPORT) && !m_fDSNAvail)
    	hr= IXP_S_SMTP_NO_DSN_SUPPORT;

exit:
    // Failure
    if (FAILED(hr))
    {
        ResetBase();
        LeaveBusy();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CSMTPTransport::OnNotify
// --------------------------------------------------------------------------------
void CSMTPTransport::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    switch(ae)
    {
    // --------------------------------------------------------------------------------
    case AE_RECV:
        OnSocketReceive();
        break;

    // --------------------------------------------------------------------------------
    case AE_SENDDONE:
        if (SMTP_SEND_STREAM == m_command)
        {
            // Leave Busy State
            LeaveBusy();

            // Send Dot Command
            HRESULT hr = CommandDOT();

            // Failure Causes Send Stream Response to finish
            if (FAILED(hr))
                SendStreamResponse(TRUE, hr, 0);
        }
        break;

    // --------------------------------------------------------------------------------
    case AE_WRITE:
        if (SMTP_DOT == m_command || SMTP_SEND_STREAM == m_command)
            SendStreamResponse(FALSE, S_OK, m_pSocket->UlGetSendByteCount());
        break;

    // --------------------------------------------------------------------------------
    default:
        CIxpBase::OnNotify(asOld, asNew, ae);
        break;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnEnterBusy
// --------------------------------------------------------------------------------
void CSMTPTransport::OnEnterBusy(void)
{
    IxpAssert(m_command == SMTP_NONE);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnLeaveBusy
// --------------------------------------------------------------------------------
void CSMTPTransport::OnLeaveBusy(void)
{
    m_command = SMTP_NONE;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnConnected
// --------------------------------------------------------------------------------
void CSMTPTransport::OnConnected(void)
{
    if (FALSE == m_fTLSNegotiation)
    {
        m_command = SMTP_BANNER;
        CIxpBase::OnConnected();
    }
    else
    {
        HRESULT hr = S_OK;
        
        CIxpBase::OnConnected();
        
        // Clear out the TLS state
        m_fSecured = TRUE;

        // Clear out info from the banner
        m_fSTARTTLSAvail = FALSE;
        FreeAuthInfo(&m_rAuth);
        
        // Performing auth
        if (m_fConnectAuth)
        {
            // If we aren't doing sicily authenication or querying DSN
            // then just send a HELO message
            if ((FALSE == m_rServer.fTrySicily) && 
                        (0 == (m_rServer.dwFlags & ISF_QUERYAUTHSUPPORT)) &&
                        (0 == (m_rServer.dwFlags & ISF_QUERYDSNSUPPORT)))
            {
                // Issue HELO
                hr = CommandHELO();
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                }
            }

            else
            {
                // Issue EHLO
                hr = CommandEHLO();
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                }
            }

            // We've finished doing negotiation
            m_fTLSNegotiation = FALSE;
        }

        // Otherwise, were connected, user can send HELO command
        else
        {
            m_command = SMTP_CONNECTED;
            DispatchResponse(S_OK, TRUE);
        }

        // Were not authenticated yet
        m_fAuthenticated = FALSE;
    }
    
    return;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnDisconnect
// --------------------------------------------------------------------------------
void CSMTPTransport::OnDisconnected(void)
{
    ResetBase();
    m_fReset = FALSE;
    CIxpBase::OnDisconnected();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnSocketReceive
// --------------------------------------------------------------------------------
void CSMTPTransport::OnSocketReceive(void)
{
    // Locals
    HRESULT hr=S_OK;

    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Read Server Response...
    hr = HrGetResponse();
    if (IXP_E_INCOMPLETE == hr)
        goto exit;

    // Handle smtp state
    switch(m_command)
    {
    // --------------------------------------------------------------------------------
    case SMTP_BANNER:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);

        // Failure, were done
        if (SUCCEEDED(hr))
        {
            // Performing auth
            if (m_fConnectAuth)
            {
                // If we aren't doing sicily authenication or
                // SSL security via STARTTLS or querying for DSN then just send a HELO message
                if ((FALSE == m_rServer.fTrySicily) && 
                            (0 == (m_rServer.dwFlags & ISF_QUERYAUTHSUPPORT)) &&
                            (FALSE == m_fConnectTLS) &&
                            (0 == (m_rServer.dwFlags & ISF_QUERYDSNSUPPORT)))
                {
                    // Issue HELO
                    hr = CommandHELO();
                    if (FAILED(hr))
                    {
                        OnError(hr);
                        DropConnection();
                    }
                }

                else
                {
                    // Issue EHLO
                    hr = CommandEHLO();
                    if (FAILED(hr))
                    {
                        OnError(hr);
                        DropConnection();
                    }
                }
            }

            // Otherwise, were connected, user can send HELO command
            else
            {
                m_command = SMTP_CONNECTED;
                DispatchResponse(S_OK, TRUE);
            }

            // Were not authenticated yet
            m_fAuthenticated = FALSE;
        }

        // Done
        break;

    // --------------------------------------------------------------------------------
    case SMTP_HELO:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);

        // Failure, were done
        if (SUCCEEDED(hr))
        {
            // Were performing AUTH
            if (m_fConnectAuth)
            {
                // Were authenticated
                m_fAuthenticated = TRUE;

                // Authorized
                OnAuthorized();
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_EHLO:
        // Are we just trying to negotiate a SSL connection
        
        // EHLO Response
        if (FALSE == m_fTLSNegotiation)
        {
            OnEHLOResponse(m_pszResponse);
        }

        // Failure, were done
        if (m_fConnectAuth)
        {
            // Do we need to do STARTTLS?
            if ((FALSE != m_fConnectTLS) && (FALSE == m_fSecured))
            {
                if (SUCCEEDED(hr))
                {
                    if (FALSE == m_fTLSNegotiation)
                    {
                        // Start TLS negotiation
                        StartTLS();
                    }
                    else
                    {
                        TryNextSecurityPkg();
                    }
                }
                else
                {
                    OnError(hr);
                    DropConnection();
                }
            }
            else
            {
                // Dispatch Response, always success...
                DispatchResponse(S_OK, TRUE);

                // Success ?
                if (SUCCEEDED(hr))
                {
                    // No Auth Tokens, just try normal authentication
                    if (m_rAuth.cAuthToken <= 0)
                    {
                        // Were authenticated
                        m_fAuthenticated = TRUE;

                        // Authorized
                        OnAuthorized();
                    }

                    // Otherwise, start sasl
                    else
                    {
                        // StartLogon
                        StartLogon();
                    }
                }

                // Otherwise, just try the HELO command
                else
                {
                    // Issue HELO
                    hr = CommandHELO();
                    if (FAILED(hr))
                    {
                        OnError(hr);
                        DropConnection();
                    }
                }
            }
        }
        // Otherwise, just dispatch the Response           
        else
            DispatchResponse(hr, TRUE);
        break;

    // --------------------------------------------------------------------------------
    case SMTP_AUTH:
        Assert(m_rAuth.authstate != AUTH_ENUMPACKS_DATA)

        // Authenticating
        if (m_fConnectAuth)
            ResponseAUTH(hr);
        else
            DispatchResponse(hr, TRUE);
        break;        

    // --------------------------------------------------------------------------------
    case SMTP_RSET:
        // Dispatch the Response
        if (FALSE == m_fConnectAuth)
            DispatchResponse(hr, TRUE);

        // Failure, were done
        if (SUCCEEDED(hr))
        {
            // If sending message, start it...
            if (m_fSendMessage)
                SendMessage_MAIL();
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_MAIL:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // Doing a Send Message..
            if (m_fSendMessage)
                SendMessage_RCPT();
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_RCPT:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // Doing a Send Message..
            if (m_fSendMessage)
                SendMessage_RCPT();
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_DATA:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // Doing a Send Message..
            if (m_fSendMessage)
            {
                // Send the data stream
                hr = SendDataStream(m_rMessage.smtpMsg.pstmMsg, m_rMessage.smtpMsg.cbSize);
                if (FAILED(hr))
                {
                    SendMessage_DONE(hr);
                }
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_DOT:
        // Dispatch the response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // If doing a send message
            if (m_fSendMessage)
                SendMessage_DONE(S_OK);
        }
        break;        

    // --------------------------------------------------------------------------------
    case SMTP_QUIT:
        // Doing a Send Message..were not done until disconnected.
        DispatchResponse(hr, FALSE);
        m_pSocket->Close();
        break;
    }

exit:
    // Enter Critical Section
    LeaveCriticalSection(&m_cs);
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::SendMessage_DONE
// ------------------------------------------------------------------------------------
void CSMTPTransport::SendMessage_DONE(HRESULT hrResult, LPSTR pszProblem)
{
    m_command = SMTP_SEND_MESSAGE;
    m_fSendMessage = FALSE;
    m_fReset = TRUE;
    SafeRelease(m_rMessage.smtpMsg.pstmMsg);
    DispatchResponse(hrResult, TRUE, pszProblem);
    SafeMemFree(m_rMessage.smtpMsg.rAddressList.prgAddress);
    SafeMemFree(m_rMessage.pszDSNENVID);
    ZeroMemory(&m_rMessage, sizeof(m_rMessage));
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::OnEHLOResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::OnEHLOResponse(LPCSTR pszResponse)
{
    // Do we have anything to do?
    if (NULL == pszResponse || FALSE != m_fTLSNegotiation)
        goto exit;

    // DSN support?
    if (m_rServer.dwFlags & ISF_QUERYDSNSUPPORT)
    {
        if (0 == StrCmpNI(pszResponse + 4, g_szSMTPDSN, g_cchSMTPDSN))
        {
            m_fDSNAvail = TRUE;
        }

    }

    // Searching for: 250 STARTTLS
    if (TRUE == m_fConnectTLS)
    {
        if (0 == StrCmpNI(pszResponse + 4, g_szSMTPSTARTTLS08, g_cchSMTPSTARTTLS08))
        {
            m_fSTARTTLSAvail = TRUE;
        }
    }

    // Searching for: 250 AUTH=LOGIN NTLM or 250 AUTH LOGIN NTLM
    if ((FALSE != m_rServer.fTrySicily) || (0 != (m_rServer.dwFlags & ISF_QUERYAUTHSUPPORT)))
    {
        if ((0 == StrCmpNI(pszResponse + 4, g_szSMTPAUTH11, g_cchSMTPAUTH11)) || 
                (0 == StrCmpNI(pszResponse + 4, g_szSMTPAUTH10, g_cchSMTPAUTH10)))
        {
            // If we haven't read the tokens yet...
            if (0 == m_rAuth.cAuthToken)
            {
                // Locals
                CStringParser cString;
                CHAR chToken;

                // State Check
                Assert(m_rAuth.cAuthToken == 0);

                // Set the Members
                cString.Init(pszResponse + 9, lstrlen(pszResponse + 9), PSF_NOTRAILWS | PSF_NOFRONTWS);

                // Parse tokens
                while(1)
                {
                    // Set Parse Tokens
                    chToken = cString.ChParse(" ");
                    if (0 == cString.CchValue())
                        break;
                
                    // Can't take any more
                    if (m_rAuth.cAuthToken == MAX_AUTH_TOKENS)
                    {
                        Assert(FALSE);
                        break;
                    }

                    // Store the auth type
                    m_rAuth.rgpszAuthTokens[m_rAuth.cAuthToken] = PszDupA(cString.PszValue());
                    if (m_rAuth.rgpszAuthTokens[m_rAuth.cAuthToken])
                        m_rAuth.cAuthToken++;
                }
            }
        }
    }

exit:
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::_PszGetCurrentAddress
// ------------------------------------------------------------------------------------
LPSTR CSMTPTransport::_PszGetCurrentAddress(void)
{
    return (*m_szEmail == '\0') ? NULL : m_szEmail;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DispatchResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::DispatchResponse(HRESULT hrResult, BOOL fDone, LPSTR pszProblem)
{
    // Locals
    SMTPRESPONSE rResponse;

    // If not in SendMessage
    if (FALSE == m_fSendMessage)
    {
        // Clear the Response
        ZeroMemory(&rResponse, sizeof(SMTPRESPONSE));

        // Set the HRESULT
        rResponse.command = m_command;
        rResponse.fDone = fDone;
        rResponse.rIxpResult.pszResponse = m_pszResponse;
        rResponse.rIxpResult.hrResult = hrResult;
        rResponse.rIxpResult.uiServerError = m_uiResponse;
        rResponse.rIxpResult.hrServerError = m_hrResponse;
        rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
        rResponse.rIxpResult.pszProblem = NULL;
        rResponse.pTransport = this;

        // Map HRESULT and set problem...
        if (FAILED(hrResult))
        {
            // Handle Rejected Sender
            if (SMTP_MAIL == m_command)
            {
                rResponse.rIxpResult.hrResult = IXP_E_SMTP_REJECTED_SENDER;
                rResponse.rIxpResult.pszProblem = _PszGetCurrentAddress();
            }

            // Handle Rejected Recipient
            else if (SMTP_RCPT == m_command)
            {
                rResponse.rIxpResult.hrResult = IXP_E_SMTP_REJECTED_RECIPIENTS;
                rResponse.rIxpResult.pszProblem = _PszGetCurrentAddress();
            }
        }

        // Finished...
        if (fDone)
        {
            // No current command
            m_command = SMTP_NONE;

            // Leave Busy State
            LeaveBusy();
        }

        // Give the Response to the client
        if (m_pCallback)
            ((ISMTPCallback *)m_pCallback)->OnResponse(&rResponse);

        // Reset Last Response
        SafeMemFree(m_pszResponse);
        m_hrResponse = S_OK;
        m_uiResponse = 0;
    }

    // Otherwise, if FAILED
    else if (FAILED(hrResult))
    {
        // Handle Rejected Sender
        if (SMTP_MAIL == m_command)
            SendMessage_DONE(IXP_E_SMTP_REJECTED_SENDER, _PszGetCurrentAddress());

        // Handle Rejected Recipient
        else if (SMTP_RCPT == m_command)
            SendMessage_DONE(IXP_E_SMTP_REJECTED_RECIPIENTS, _PszGetCurrentAddress());

        // General Failure
        else
            SendMessage_DONE(hrResult);
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::HrGetResponse
// ------------------------------------------------------------------------------------
HRESULT CSMTPTransport::HrGetResponse(void)
{
    // Locals
    HRESULT     hr = S_OK;
    INT         cbLine = 0;
    BOOL        fKnownResponse = TRUE;
    BOOL        fComplete = FALSE;
    BOOL        fMoreLinesNeeded = FALSE;

    // Clear current response
    IxpAssert(m_pszResponse == NULL && m_hrResponse == S_OK);

    // We received a line from the host $$ERROR$$ - How do I know if there are more lines
    while(1)
    {
        // Read the line
        IxpAssert(m_pszResponse == NULL);
        hr = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
        if (FAILED(hr))
        {
            hr = TRAPHR(IXP_E_SOCKET_READ_ERROR);
            goto exit;
        }

        // Not complete
        if (!fComplete)
        {
            if (FALSE != fMoreLinesNeeded)
            {
                hr = IXP_E_INCOMPLETE;
            }
            
            goto exit;
        }

        // Parse the response code
        if ((cbLine < 3) ||
            (m_pszResponse[0] < '0' || m_pszResponse[0] > '9') ||
            (m_pszResponse[1] < '0' || m_pszResponse[1] > '9') ||
            (m_pszResponse[2] < '0' || m_pszResponse[2] > '9'))
        {
            hr = TrapError(IXP_E_SMTP_RESPONSE_ERROR);
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, SMTPTHISIXP);
            goto exit;
        }

        // Ignores continuation lines for now
        if ((cbLine >= 4) && (m_pszResponse[3] == '-'))
        {
            // Locals
            SMTPRESPONSE rResponse;

            // General command
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, IXP_S_SMTP_CONTINUE, SMTPTHISIXP);

            // Clear the Response
            ZeroMemory(&rResponse, sizeof(SMTPRESPONSE));

            // Set the HRESULT
            rResponse.command = m_command;
            rResponse.fDone = FALSE;
            rResponse.rIxpResult.pszResponse = m_pszResponse;
            rResponse.rIxpResult.hrResult = IXP_S_SMTP_CONTINUE;
            rResponse.rIxpResult.uiServerError = 0;
            rResponse.rIxpResult.hrServerError = S_OK;
            rResponse.rIxpResult.dwSocketError = 0;
            rResponse.rIxpResult.pszProblem = NULL;
            rResponse.pTransport = this;

            // Give the Response to the client
            if (m_pCallback)
                ((ISMTPCallback *)m_pCallback)->OnResponse(&rResponse);

            // EHLO Response
            if (SMTP_EHLO == m_command)
                OnEHLOResponse(m_pszResponse);

            // Reset Last Response
            SafeMemFree(m_pszResponse);
            m_hrResponse = S_OK;
            m_uiResponse = 0;

            // We still need to get more lines from the server
            fMoreLinesNeeded = TRUE;
            
            // Continue
            continue;
        }

        // Not a valid SMTP response line.
        if ((cbLine >= 4) && (m_pszResponse[3] != ' '))
        {
            hr = TrapError(IXP_E_SMTP_RESPONSE_ERROR);
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, SMTPTHISIXP);
            goto exit;
        }

        // Done
        break;
    }

    // Compute Actual Response code
    m_uiResponse = (m_pszResponse[0] - '0') * 100 +
                   (m_pszResponse[1] - '0') * 10  +
                   (m_pszResponse[2] - '0');

    // Assume it is not recognized
    switch(m_uiResponse)
    {
    case 500: hr = IXP_E_SMTP_500_SYNTAX_ERROR;             break;
    case 501: hr = IXP_E_SMTP_501_PARAM_SYNTAX;             break;
    case 502: hr = IXP_E_SMTP_502_COMMAND_NOTIMPL;          break;
    case 503: hr = IXP_E_SMTP_503_COMMAND_SEQ;              break;
    case 504: hr = IXP_E_SMTP_504_COMMAND_PARAM_NOTIMPL;    break;
    case 421: hr = IXP_E_SMTP_421_NOT_AVAILABLE;            break;
    case 450: hr = IXP_E_SMTP_450_MAILBOX_BUSY;             break;
    case 550: hr = IXP_E_SMTP_550_MAILBOX_NOT_FOUND;        break;
    case 451: hr = IXP_E_SMTP_451_ERROR_PROCESSING;         break;
    case 551: hr = IXP_E_SMTP_551_USER_NOT_LOCAL;           break;
    case 452: hr = IXP_E_SMTP_452_NO_SYSTEM_STORAGE;        break;
    case 552: hr = IXP_E_SMTP_552_STORAGE_OVERFLOW;         break;
    case 553: hr = IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX;      break;
    case 554: hr = IXP_E_SMTP_554_TRANSACT_FAILED;          break;
    case 211: hr = IXP_S_SMTP_211_SYSTEM_STATUS;            break;
    case 214: hr = IXP_S_SMTP_214_HELP_MESSAGE;             break;
    case 220: hr = IXP_S_SMTP_220_READY;                    break;
    case 221: hr = IXP_S_SMTP_221_CLOSING;                  break;
    case 250: hr = IXP_S_SMTP_250_MAIL_ACTION_OKAY;         break;
    case 251: hr = IXP_S_SMTP_251_FORWARDING_MAIL;          break;
    case 354: hr = IXP_S_SMTP_354_START_MAIL_INPUT;         break;
    case 334: hr = IXP_S_SMTP_334_AUTH_READY_RESPONSE;      break;
    case 235: hr = IXP_S_SMTP_245_AUTH_SUCCESS;             break;
    case 454: hr = IXP_E_SMTP_454_STARTTLS_FAILED;          break;
    case 530: hr = IXP_E_SMTP_530_STARTTLS_REQUIRED;        break;
    default: 
        hr = IXP_E_SMTP_UNKNOWN_RESPONSE_CODE;
        fKnownResponse = FALSE;
        break;
    }

    // Set hr
    m_hrResponse = hr;

    // Give to callback
    if (m_pCallback && m_fCommandLogging)
        m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, SMTPTHISIXP);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::_HrFormatAddressString
// --------------------------------------------------------------------------------
HRESULT CSMTPTransport::_HrFormatAddressString(LPCSTR pszEmail, LPCSTR pszExtra, LPSTR *ppszAddress)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;

    // Invalid Arg
    Assert(pszEmail && ppszAddress);

    cbAlloc= lstrlen(pszEmail) + 3; // length of pszEmail plus <> and a null term
    if(pszExtra && pszExtra[0])
        cbAlloc += lstrlen(pszExtra) + 1; // length of pszExtra plus a space

    // Allocate string
    CHECKALLOC(*ppszAddress = (LPSTR)g_pMalloc->Alloc(cbAlloc));

    // Format the String
    wsprintf(*ppszAddress, "<%s>", pszEmail);
    if(pszExtra && pszExtra[0])
    {
    	strcat(*ppszAddress, " ");
    	strcat(*ppszAddress, pszExtra);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandMAIL
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandMAIL(LPSTR pszEmailFrom)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszAddress=NULL;
    CHAR        pszDSNData[128];

    pszDSNData[0]= '\0';

    // Check params
    if (NULL == pszEmailFrom)
        return TrapError(E_INVALIDARG);

	// build DSN parameters if necessary
	if(m_fDSNAvail)
	{
		if(DSNRET_DEFAULT != m_rMessage.dsnRet)
		{
			strcat(pszDSNData, g_szDSNRET);

			if(m_rMessage.dsnRet == DSNRET_HDRS)
				strcat(pszDSNData, g_szDSNHDRS);
			else if(DSNRET_FULL == m_rMessage.dsnRet)
				strcat(pszDSNData, g_szDSNFULL);

		}

		if(m_rMessage.pszDSNENVID)
		{
			if(pszDSNData[0])
				strcat(pszDSNData, " ");

			strcat(pszDSNData, g_szDSNENVID);
			strcat(pszDSNData, m_rMessage.pszDSNENVID);
		}
	}
	
    // Put pszEmailFrom into <pszEmailFrom>
    CHECKHR(hr = _HrFormatAddressString(pszEmailFrom, pszDSNData, &pszAddress));

    // Send Command
    hr = HrSendCommand((LPSTR)SMTP_MAIL_STR, pszAddress, !m_fSendMessage);
    if (SUCCEEDED(hr))
    {
        lstrcpyn(m_szEmail, pszEmailFrom, ARRAYSIZE(m_szEmail));
        m_command = SMTP_MAIL;
    }

exit:
    // Cleanup
    SafeMemFree(pszAddress);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CSMTPTransport::CommandRCPT
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandRCPT(LPSTR pszEmailTo)
{
	return CommandRCPT2(pszEmailTo, (INETADDRTYPE)0);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandRCPT2
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandRCPT2(LPSTR pszEmailTo, INETADDRTYPE atDSN)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszAddress=NULL;
    CHAR        pszDSNData[32];
    int iatDSN= atDSN;

    pszDSNData[0]= '\0';

    // Check params
    if (NULL == pszEmailTo)
        return TrapError(E_INVALIDARG);
    if ((atDSN & ~ADDR_DSN_MASK) ||
    	  ((atDSN & ADDR_DSN_NEVER) &&
   		  (atDSN & ~ADDR_DSN_NEVER)))
    	return TrapError(E_INVALIDARG);

	// build DSN parameters if necessary
    if(m_fDSNAvail && atDSN)
    {
		strcat(pszDSNData, g_szDSNNOTIFY);

		if(atDSN & ADDR_DSN_NEVER)
			strcat(pszDSNData, g_szDSNNEVER);
		else
		{
			bool fPrev= false;
			
			if(atDSN & ADDR_DSN_SUCCESS)
			{
				strcat(pszDSNData, g_szDSNSUCCESS);
				fPrev= true;
			}
			if(atDSN & ADDR_DSN_FAILURE)
			{
				if(fPrev)
					strcat(pszDSNData, ",");
				strcat(pszDSNData, g_szDSNFAILURE);
				fPrev= true;
			}
			if(atDSN & ADDR_DSN_DELAY)
			{
				if(fPrev)
					strcat(pszDSNData, ",");
				strcat(pszDSNData, g_szDSNDELAY);
			}
		}
    }

    // Put pszEmailFrom into <pszEmailFrom>
    CHECKHR(hr = _HrFormatAddressString(pszEmailTo, pszDSNData, &pszAddress));

    // Send Command
    hr = HrSendCommand((LPSTR)SMTP_RCPT_STR, pszAddress, !m_fSendMessage);
    if (SUCCEEDED(hr))
    {
        lstrcpyn(m_szEmail, pszEmailTo, ARRAYSIZE(m_szEmail));
        m_command = SMTP_RCPT;
    }

exit:
    // Cleanup
    SafeMemFree(pszAddress);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandEHLO
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandEHLO(void)
{
    return _HrHELO_Or_EHLO(SMTP_EHLO_STR, SMTP_EHLO);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandHELO
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandHELO(void)
{
    return _HrHELO_Or_EHLO(SMTP_HELO_STR, SMTP_HELO);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::_HrHELO_Or_EHLO
// --------------------------------------------------------------------------------
HRESULT CSMTPTransport::_HrHELO_Or_EHLO(LPCSTR pszCommand, SMTPCOMMAND eNewCommand)
{
    // Locals
    HRESULT hr=S_OK;

    // Use an IP address
    if (ISFLAGSET(m_rServer.dwFlags, ISF_SMTP_USEIPFORHELO))
    {
        // Locals
        LPHOSTENT   pHost=NULL;
        SOCKADDR_IN sa;

        // Get Host by name
        pHost = gethostbyname(SzGetLocalHostName());

        // Cast ip
        sa.sin_addr.s_addr = (ULONG)(*(DWORD *)pHost->h_addr);

        // Send HELO, quit and die if it fails
        hr = HrSendCommand((LPSTR)pszCommand, inet_ntoa(sa.sin_addr), !m_fSendMessage && !m_fTLSNegotiation);
        if (SUCCEEDED(hr))
            m_command = eNewCommand;
    }

    // Otherwise, this code uses a host name to do the ehlo or helo command
    else    
    {
        // Locals
        CHAR    szLocalHost[255];
        LPSTR   pszHost=SzGetLocalHostName();

        // Get legal local host name
#ifdef DEBUG
        StripIllegalHostChars("GTE/Athena", szLocalHost);
        StripIllegalHostChars("foobar.", szLocalHost);
        StripIllegalHostChars("127.256.34.23", szLocalHost);
        StripIllegalHostChars("56foo1", szLocalHost);
#endif
        // Get legal local host name
        StripIllegalHostChars(pszHost, szLocalHost);

        // Send HELO, quit and die if it fails
        hr = HrSendCommand((LPSTR)pszCommand, szLocalHost, !m_fSendMessage && !m_fTLSNegotiation);
        if (SUCCEEDED(hr))
            m_command = eNewCommand;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::DoQuit
// --------------------------------------------------------------------------------
void CSMTPTransport::DoQuit(void)
{
    CommandQUIT();
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::CommandAUTH
// ------------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandAUTH(LPSTR pszAuthType)
{
    // check params
    if (NULL == pszAuthType)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_AUTH_STR, pszAuthType, !m_fConnectAuth);
    if (SUCCEEDED(hr))
        m_command = SMTP_AUTH;

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandQUIT
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandQUIT(void)
{            
    // Send QUIT
    OnStatus(IXP_DISCONNECTING);
    HRESULT hr = HrSendCommand((LPSTR)SMTP_QUIT_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_QUIT;
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandRSET
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandRSET(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_RSET_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_RSET;
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandDATA
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandDATA(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_DATA_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_DATA;
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandDOT
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandDOT(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_END_DATA_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_DOT;
    return hr;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::CommandSTARTTLS
// ------------------------------------------------------------------------------------
HRESULT CSMTPTransport::CommandSTARTTLS(void)
{
    // Locals
    HRESULT         hr=S_OK;
    
    // Is StartTLS supported?
    if(FALSE == m_fSTARTTLSAvail)
    {
        hr= IXP_E_SMTP_NO_STARTTLS_SUPPORT;
        goto exit;
    }

    // Do the command
    hr = HrSendCommand((LPSTR)SMTP_STARTTLS_STR, NULL, !m_fConnectAuth);
    if (SUCCEEDED(hr))
        m_fTLSNegotiation = TRUE;

    // Done
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendDataStream
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::SendDataStream(IStream *pStream, ULONG cbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    INT             cb;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Busy...
    if (m_fSendMessage == FALSE)
    {
        CHECKHR(hr = HrEnterBusy());
    }

    // Save Total Size
    m_cbSent = 0;
    m_cbTotal = cbSize;

    // Send the stream, if it fails, move the the next message
    hr = m_pSocket->SendStream(pStream, &cb, TRUE);
    if (FAILED(hr))
    {
        // If this is a blocking situation, enter SMTP_SEND_STREAM_RESP
        if (hr == IXP_E_WOULD_BLOCK)
        {
            m_command = SMTP_SEND_STREAM;
            SendStreamResponse(FALSE, S_OK, cb);
            hr =S_OK;
            goto exit;
        }

        // Otherwise, someother error
        else
        {
            hr = TrapError(IXP_E_SOCKET_WRITE_ERROR);
            goto exit;
        }
    }

    // Give send stream response
    SendStreamResponse(TRUE, S_OK, cb);

    // Not Busy
    if (FALSE == m_fSendMessage)
        LeaveBusy();

    // Send DOT
    CHECKHR(hr = CommandDOT());

exit:
    // Failure
    if (FALSE == m_fSendMessage && FAILED(hr))
        LeaveBusy();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendStreamResponse
// --------------------------------------------------------------------------------
void CSMTPTransport::SendStreamResponse(BOOL fDone, HRESULT hrResult, DWORD cbIncrement)
{
    // Locals
    SMTPRESPONSE rResponse;

    // Increment Current
    m_cbSent += cbIncrement;

    // Set the HRESULT
    rResponse.command = SMTP_SEND_STREAM;
    rResponse.fDone = fDone;
    rResponse.rIxpResult.pszResponse = NULL;
    rResponse.rIxpResult.hrResult = hrResult;
    rResponse.rIxpResult.uiServerError = 0;
    rResponse.rIxpResult.hrServerError = S_OK;
    rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rResponse.rIxpResult.pszProblem = NULL;
    rResponse.pTransport = this;
    rResponse.rStreamInfo.cbIncrement = cbIncrement;
    rResponse.rStreamInfo.cbCurrent = m_cbSent;
    rResponse.rStreamInfo.cbTotal = m_cbTotal;

    // Finished...
    if (fDone)
    {
        // No current command
        m_command = SMTP_NONE;

        // Leave Busy State
        LeaveBusy();
    }

    // Give the Response to the client
    if (m_pCallback)
        ((ISMTPCallback *)m_pCallback)->OnResponse(&rResponse);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMAIL
// --------------------------------------------------------------------------------
void CSMTPTransport::SendMessage_MAIL(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPINETADDR      pInetAddress;

    // Loop address list
    for (i=0; i<m_rMessage.smtpMsg.rAddressList.cAddress; i++)
    {
        // Readability
        pInetAddress = &m_rMessage.smtpMsg.rAddressList.prgAddress[i];

        // From...
        if (ADDR_FROM == (pInetAddress->addrtype & ADDR_TOFROM_MASK))
        {
			// Save index of sender
			m_iAddress = 0;

            // Send Command
            hr = CommandMAIL(pInetAddress->szEmail);
            if (FAILED(hr))
                SendMessage_DONE(hr);

            // Done
            return;
        }
    }

    // No Sender
    SendMessage_DONE(TrapError(IXP_E_SMTP_NO_SENDER));
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMessage_RCPT
// --------------------------------------------------------------------------------
void CSMTPTransport::SendMessage_RCPT(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPINETADDR      pInetAddress;

    // Find next ADDR_TO, starting with m_rCurrent.iRcptAddrList
    IxpAssert(m_iAddress <= m_rMessage.smtpMsg.rAddressList.cAddress);
    for(i=m_iAddress; i<m_rMessage.smtpMsg.rAddressList.cAddress; i++)
    {
        // Readability
        pInetAddress = &m_rMessage.smtpMsg.rAddressList.prgAddress[i];

        // Recipient
        if (ADDR_TO == (pInetAddress->addrtype & ADDR_TOFROM_MASK))
        {
            // Count recipients
            m_cRecipients++;

            // Send Command
            hr = CommandRCPT2(pInetAddress->szEmail, (INETADDRTYPE)(pInetAddress->addrtype & ADDR_DSN_MASK));
            if (FAILED(hr))
                SendMessage_DONE(hr);
            else
            {
                m_iAddress = i + 1;
                m_cRecipients++;
            }

            // Done
            return;
        }
    }

    // If no recipients
    if (0 == m_cRecipients)
        SendMessage_DONE(TrapError(IXP_E_SMTP_NO_RECIPIENTS));

    // Otherwise, were done with rcpt, lets send the message
    else
    {
        hr = CommandDATA();
        if (FAILED(hr))
            SendMessage_DONE(hr);
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::StartLogon
// ------------------------------------------------------------------------------------
void CSMTPTransport::StartLogon(void)
{
    // Locals
    HRESULT hr;

    // Progress
    OnStatus(IXP_AUTHORIZING);

    // Free current packages...
    if (NULL == m_rAuth.pPackages)
    {
        // If Not Using Sicily or its not installed, then send USER command
        SSPIGetPackages(&m_rAuth.pPackages, &m_rAuth.cPackages);
    }

    // ResponseAUTH
    TryNextAuthPackage();

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::LogonRetry
// ------------------------------------------------------------------------------------
void CSMTPTransport::LogonRetry(void)
{
    // Locals
    HRESULT         hr=S_OK;

    // Auth Retry
    OnStatus(IXP_AUTHRETRY);

    // Enter Auth Retry State
    m_pSocket->Close();

    // Logon
    if (NULL == m_pCallback || m_pCallback->OnLogonPrompt(&m_rServer, SMTPTHISIXP) != S_OK)
    {
        // Go to terminal state, were done.
        OnDisconnected();
        return;
    }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        OnError(TrapError(IXP_E_SOCKET_CONNECT_ERROR));
        OnDisconnected();
        return;
    }

    // Reset the secured state
    m_fSecured = FALSE;

    // Start WatchDog
    m_pSocket->StartWatchDog();
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::TryNextAuthPackage
// ------------------------------------------------------------------------------------
void CSMTPTransport::TryNextAuthPackage(void)
{
    // Locals
    HRESULT hr=S_OK;
    BOOL    fPackageInstalled;
    BOOL    fLoginMethod=FALSE;
    ULONG   i;

    // Set auth state
    m_rAuth.authstate = AUTH_NONE;

    // Loop through the auth tokens, and try to authenticate with each one in order
    for (;m_rAuth.iAuthToken < m_rAuth.cAuthToken; m_rAuth.iAuthToken++)
    {
        // Assume package is not installed
        fPackageInstalled = FALSE;

        // "LOGIN"
        if (lstrcmpi(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken], "LOGIN") == 0)
        {
            fLoginMethod = TRUE;
            fPackageInstalled = TRUE;
        }

        // Loop through installed packages
        else
        {
            for (i=0; i<m_rAuth.cPackages; i++)
            {
                // Null Package ??
                if (!m_rAuth.pPackages[i].pszName)
                    continue;

                // Is this the package I am looking for
                if (lstrcmpi(m_rAuth.pPackages[i].pszName, m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken]) == 0)
                {
                    fPackageInstalled = TRUE;
                    break;
                }
            }
        }

        // Package not installed ?
        if (!fPackageInstalled)
            continue;

        // We are not retrying the current package
        m_rAuth.fRetryPackage = FALSE;

        // Otherwise, send AUTH enumpacks command
        hr = CommandAUTH(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken]);
        if (FAILED(hr))
        {
            OnError(hr);
            DropConnection();
            return;
        }

        // We are in the TRYING_PACKAGE state
        m_rAuth.authstate = fLoginMethod ? AUTH_SMTP_LOGIN : AUTH_TRYING_PACKAGE;

        // Done
        break;
    }

    // If auth state is none, try HELO command
    if (AUTH_NONE == m_rAuth.authstate)
    {
        // Were authenticated
        m_fAuthenticated = TRUE;

        // Authorized
        OnAuthorized();
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::ResponseAUTH
// ------------------------------------------------------------------------------------
void CSMTPTransport::ResponseAUTH(HRESULT hrResponse)
{
    // Stop the WatchDog
    m_pSocket->StopWatchDog();

    // I know how to do this
    if (lstrcmpi(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken], "LOGIN") == 0)
    {
        // DoLogonAuth
        DoLoginAuth(hrResponse);
    }

    // Otherwise, we must have just tryed a package
    else if (m_rAuth.authstate == AUTH_TRYING_PACKAGE)
    {
        // DoPackageAuth
        DoPackageAuth(hrResponse);
    }

    // Otherwise, we got a response from a negotiation string
    else if (m_rAuth.authstate == AUTH_NEGO_RESP)
    {
        // DoAuthNegoResponse
        DoAuthNegoResponse(hrResponse);
    }

    // Otherwise, we got a response from a challenge response string
    else if (m_rAuth.authstate == AUTH_RESP_RESP)
    {
        // DoAuthRespResp
        DoAuthRespResponse(hrResponse);
    }

    // Auth was cancelled, try next package
    else if (m_rAuth.authstate == AUTH_CANCELED)
    {
        // Free Current Context
        SSPIFreeContext(&m_rAuth.rSicInfo);

        // Goto next package
        m_rAuth.iAuthToken++;

        // Try the next package
        TryNextAuthPackage();
    }

    // Free Current Response
    SafeMemFree(m_pszResponse);
    m_hrResponse = S_OK;

    // Start the WatchDog
    m_pSocket->StartWatchDog();
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoLoginAuth
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoLoginAuth(HRESULT hrResponse)
{
    // Locals
    SSPIBUFFER Buffer;

    // Failure, retry login
    if (FAILED(hrResponse))
    {
        // I just issued the AUTH LOGIN command, this should not happen
        if (AUTH_SMTP_LOGIN == m_rAuth.authstate)
        {
            // Free Current Context
            SSPIFreeContext(&m_rAuth.rSicInfo);

            // Goto next package
            m_rAuth.iAuthToken++;

            // Try the next package
            TryNextAuthPackage();
        }

        // Otherwise, I just issued the AUTH LOGIN USERNAME
        else if (AUTH_SMTP_LOGIN_USERNAME == m_rAuth.authstate || AUTH_SMTP_LOGIN_PASSWORD == m_rAuth.authstate)
        {
            // Retry the Logon
            LogonRetry();
        }
        else
            Assert(FALSE);

        // Done
        goto exit;
    }

    // Should have a response
    Assert(m_pszResponse);

    // 334
    if (334 == m_uiResponse)
    {
        // Set the Length
        SSPISetBuffer(m_pszResponse + 4, SSPI_STRING, 0, &Buffer);

        // Base64 Decode
        if (FAILED(SSPIDecodeBuffer(TRUE, &Buffer)))
        {
            OnError(E_FAIL);
            DropConnection();
            goto exit;
        }

        // If the user name is empty, lets retry the login...
        if (FIsEmptyA(m_rServer.szUserName))
        {
            // LogonRetry
            LogonRetry();

            // Done
            goto exit;
        }

        // Handle Next STep
        if (StrCmpNI(Buffer.szBuffer, "username:", lstrlen("username:")) == 0)
        {
            // Set the Buffer 
            SSPISetBuffer(m_rServer.szUserName, SSPI_STRING, 0, &Buffer);

            // Encode the User Name
            if (FAILED(SSPIEncodeBuffer(TRUE, &Buffer)))
            {
                OnError(E_FAIL);
                DropConnection();
                goto exit;
            }

            // Send the user name
            if (FSendSicilyString(Buffer.szBuffer))
                m_rAuth.authstate = AUTH_SMTP_LOGIN_USERNAME;
        }

        // Password
        else if (StrCmpNI(Buffer.szBuffer, "password:", lstrlen("password:")) == 0)
        {
            // Set the Buffer 
            SSPISetBuffer(m_rServer.szPassword, SSPI_STRING, 0, &Buffer);

            // Encode the password
            if (FAILED(SSPIEncodeBuffer(TRUE, &Buffer)))
            {
                OnError(E_FAIL);
                DropConnection();
                goto exit;
            }

            // Send the password
            if (FSendSicilyString(Buffer.szBuffer))
                m_rAuth.authstate = AUTH_SMTP_LOGIN_PASSWORD;
        }

        // Bad response from the server
        else
        {
            OnError(E_FAIL);
            DropConnection();
            goto exit;
        }
    }

    // Connected
    else if (235 == m_uiResponse)
    {
        // OnAuthorizied
        OnAuthorized();
    }

    // Error Response ?
    else
    {
        OnError(E_FAIL);
        DropConnection();
        goto exit;
    }

exit:
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoPackageAuth
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoPackageAuth(HRESULT hrResponse)
{
    // Locals
    SSPIBUFFER Negotiate;

    // Failure, retry login
    if (FAILED(hrResponse))
    {
        // Free Current Context
        SSPIFreeContext(&m_rAuth.rSicInfo);

        // Goto next package
        m_rAuth.iAuthToken++;

        // Try the next package
        TryNextAuthPackage();

        // Done
        goto exit;
    }

    // Invalid Arg
    Assert(m_rAuth.iAuthToken < m_rAuth.cAuthToken);

    // Do Sicily Logon
    if (FAILED(SSPILogon(&m_rAuth.rSicInfo, m_rAuth.fRetryPackage, SSPI_BASE64, m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken], &m_rServer, m_pCallback)))
    {
        // Cancel Authentication
        CancelAuthInProg();

        // Done
        goto exit;
    }

    // Retrying current package
    if (m_rAuth.fRetryPackage)
    {
        // Don't retry again
        m_rAuth.fRetryPackage = FALSE;
    }

    // Get negotiation string
    if (FAILED(SSPIGetNegotiate(&m_rAuth.rSicInfo, &Negotiate)))
    {
        // Cancel Authentication
        CancelAuthInProg();

        // Done
        goto exit;
    }

    // Send AUTH Respons
    if (FSendSicilyString(Negotiate.szBuffer))
        m_rAuth.authstate = AUTH_NEGO_RESP;

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoAuthNegoResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoAuthNegoResponse(HRESULT hrResponse)
{
    // Locals
    HRESULT     hr=S_OK;
    SSPIBUFFER  Challenge;
    SSPIBUFFER  Response;

    // Invalid Arg
    Assert(m_rAuth.iAuthToken < m_rAuth.cAuthToken);

    // Failure, retry login
    if (FAILED(hrResponse) || lstrlen(m_pszResponse) < 4)
    {
        // RetryPackage
        RetryPackage();

        // Done
        goto exit;
    }

    // Set Chal String - skip over "+ "
    SSPISetBuffer(m_pszResponse + 4, SSPI_STRING, 0, &Challenge);

    // Get response from challenge
    if (FAILED(SSPIResponseFromChallenge(&m_rAuth.rSicInfo, &Challenge, &Response)))
    {
        // Cancel Authentication
        CancelAuthInProg();

        // Done
        goto exit;
    }

    // Send AUTH Respons
    if (FSendSicilyString(Response.szBuffer))
    {
        // if we need to continue, we keep the state the same
        // else we transition to the AUTH_RESP_RESP state.
        if (!Response.fContinue)
            m_rAuth.authstate = AUTH_RESP_RESP;
    }

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoAuthRespResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoAuthRespResponse(HRESULT hrResponse)
{
    // Failure
    if (FAILED(hrResponse))
    {
        // RetryPackage
        RetryPackage();

        // Done
        goto exit;
    }

    // We will free the context, but keep the credential handle
    SSPIReleaseContext(&m_rAuth.rSicInfo);

    // OnAuthorized
    OnAuthorized();

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::OnAuthorized
// ------------------------------------------------------------------------------------
void CSMTPTransport::OnAuthorized(void)
{
    // Connected (Authorized) state
    OnStatus(IXP_AUTHORIZED);

    // No more authorization
    m_fConnectAuth = FALSE;

    // Send command
    m_command = SMTP_CONNECTED;

    // Dispatch response
    DispatchResponse(S_OK, TRUE);
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::RetryPackage
// ------------------------------------------------------------------------------------
void CSMTPTransport::RetryPackage(void)
{
    // retry current package, with prompt
    m_rAuth.fRetryPackage = TRUE;

    // Send the auth command again
    HRESULT hr = CommandAUTH(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken]);
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
        goto exit;
    }

    // New State
    m_rAuth.authstate = AUTH_TRYING_PACKAGE;

    // Free current information
    SSPIFreeContext(&m_rAuth.rSicInfo);

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::FSendSicilyString
// ------------------------------------------------------------------------------------
BOOL CSMTPTransport::FSendSicilyString(LPSTR pszData)
{
    // Locals
    LPSTR           pszLine=NULL;
    HRESULT         hr=S_OK;

    // Check Param
    Assert(pszData);

    // Allocate a line
    pszLine = PszAllocA(lstrlen(pszData) + 5);
    if (NULL == pszLine)
    {
        OnError(E_OUTOFMEMORY);
        DropConnection();
        return FALSE;
    }

    // Make Line
    wsprintf(pszLine, "%s\r\n", pszData);

    // Send the lin
    hr = HrSendLine(pszLine);
    SafeMemFree(pszLine);

    // Failure
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
        return FALSE;
    }

    // Success
    return TRUE;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::CancelAuthInProg
// ------------------------------------------------------------------------------------
void CSMTPTransport::CancelAuthInProg(void)
{
    // Locals
    HRESULT         hr;

    // Send *, quit and die if it fails
    hr = HrSendCommand((LPSTR)SMTP_AUTH_CANCEL_STR, NULL, FALSE);
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }
    else
    {
        // New state
        m_command = SMTP_AUTH;
        m_rAuth.authstate = AUTH_CANCELED;
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::StartTLS
// ------------------------------------------------------------------------------------
void CSMTPTransport::StartTLS(void)
{
    // Locals
    HRESULT hr;

    // Progress
    OnStatus(IXP_SECURING);

    hr = CommandSTARTTLS();
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }
    
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::TryNextSecurityPkg
// ------------------------------------------------------------------------------------
void CSMTPTransport::TryNextSecurityPkg(void)
{
    if (FALSE != FIsSecurityEnabled())
    {
        m_pSocket->TryNextSecurityPkg();
    }
    else
    {
        OnError(E_FAIL);
        DropConnection();
    }
        
    return;
}

//***************************************************************************
// Function: SetWindow
//
// Purpose:
//   This function creates the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CSMTPTransport::SetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

    if(m_pSocket)
    	hr= m_pSocket->SetWindow();
    else
    	hr= E_UNEXPECTED;
    	
    return hr;
}

//***************************************************************************
// Function: ResetWindow
//
// Purpose:
//   This function closes the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CSMTPTransport::ResetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

	if(m_pSocket)
		hr= m_pSocket->ResetWindow();
	else
		hr= E_UNEXPECTED;
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixputil.cpp ===
// --------------------------------------------------------------------------------
// Utility.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "imnxport.h"
#include "dllmain.h"
#include "ixputil.h"
#include <demand.h>

// --------------------------------------------------------------------------------
// HrInitializeWinsock
// --------------------------------------------------------------------------------
HRESULT HrInitializeWinsock(void)
{
    // Locals
    HRESULT     hr=S_OK;
    int         err;
    WSADATA     wsaData;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // If Already Initialized...
    if (g_fWinsockInit)
        goto exit;

    // Do Startup
    err = WSAStartup(MAKEWORD(1,1), &wsaData);

    // Start up Windows Sockets DLL
    if (!err)
    {
        // Check WinSock version
        if ((LOBYTE(wsaData.wVersion) == 1) && (HIBYTE(wsaData.wVersion) == 1))
        {
            g_fWinsockInit = TRUE;
            goto exit;
        }
        else
        {
            DebugTrace("Winsock version %d.%d not supported", LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion));
            hr = TrapError(IXP_E_WINSOCK_WSAVERNOTSUPPORTED);
            goto exit;
        }
    }

    // Otherwise, map the error
    else
    {
        DebugTrace("WSAStartup failed: %d\n", err);
        switch(err)
        {
        case WSASYSNOTREADY:
            hr = TrapError(IXP_E_WINSOCK_WSASYSNOTREADY);
            break;

        case WSAVERNOTSUPPORTED:
            hr = TrapError(IXP_E_WINSOCK_WSAVERNOTSUPPORTED);
            break;

        case WSAEINPROGRESS:
            hr = TrapError(IXP_E_WINSOCK_WSAEINPROGRESS);
            break;

        case WSAEPROCLIM:
            hr = TrapError(IXP_E_WINSOCK_WSAEPROCLIM);
            break;

        case WSAEFAULT:
            hr = TrapError(IXP_E_WINSOCK_WSAEFAULT);
            break;

        default:
            hr = TrapError(IXP_E_WINSOCK_FAILED_WSASTARTUP);
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UnInitializeWinsock
// --------------------------------------------------------------------------------
void UnInitializeWinsock(void)
{
    // Locals
    int err;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Has been initialized ?
    if (g_fWinsockInit)
    {
        // Shutdown Winsock
        err = WSACleanup();
        if (err)
            DebugTrace("WSACleanup failed: %d\n", WSAGetLastError());

        // Not initialized
        else
            g_fWinsockInit = FALSE;
    }

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// PszGetDomainName
// --------------------------------------------------------------------------------
LPSTR PszGetDomainName(void)
{
    // pszHost
    LPSTR pszHost = SzGetLocalHostNameForID();

    // Set pszDomain
    LPSTR pszDomain = pszHost;

    // Strip Off Host Name?
    while (*pszHost)
    {
        // Skip DBCS Characters
        if (IsDBCSLeadByte(*pszHost))
        {
            // Skip DBCS Char
            pszHost+=2;

            // Goto next
            continue;
        }

        // Otherwise, test for @ sign
        else if (*pszHost == '.' && *(pszHost + 1) != '\0')
        {
            // Set pszDomain
            pszDomain = pszHost + 1;

            // We are Done
            break;
        }

        // Increment
        pszHost++;
    }

    // Return pszDomain
    return pszDomain;
}

// --------------------------------------------------------------------------------
// SzGetLocalHostNameForID
// --------------------------------------------------------------------------------
LPSTR SzGetLocalHostNameForID(void)
{
    // Locals
    static char s_szLocalHostId[255] = {0};

    // Gets local host name from socket library
    if (*s_szLocalHostId == 0)
    {
        // Locals
        LPHOSTENT       pHost;
        LPSTR           pszLocalHost;

        // Use gethostbyname
        pHost = gethostbyname(SzGetLocalHostName());

        // Failure ?
        if (pHost && pHost->h_name)
            pszLocalHost = pHost->h_name;
        else
            pszLocalHost = SzGetLocalHostName();

        // Strip illegals
        StripIllegalHostChars(pszLocalHost, s_szLocalHostId);

        // if we stripped out everything, then just copy in something
        if (*s_szLocalHostId == 0)
            lstrcpyA(s_szLocalHostId, "LocalHost");
    }

    // Done
    return s_szLocalHostId;
}


// --------------------------------------------------------------------------------
// SzGetLocalPackedIP
// --------------------------------------------------------------------------------
LPSTR SzGetLocalPackedIP(void)
{
    // Locals
    static CHAR s_szLocalPackedIP[255] = "";

    // Init WinSock...
    HrInitializeWinsock();

    // Gets local host name from socket library
    if (*s_szLocalPackedIP == '\0')
    {
        LPHOSTENT hp = NULL;

        hp = gethostbyname(SzGetLocalHostName());
        if (hp != NULL)
            wsprintf (s_szLocalPackedIP, "%08x", *(long *)hp->h_addr);
        else
        {
            // $REVIEW - What should i do if this fails ???
            Assert (FALSE);
            DebugTrace("gethostbyname failed: WSAGetLastError: %ld\n", WSAGetLastError());
            lstrcpy(s_szLocalPackedIP, "LocalHost");
        }
    }

    // Done
    return s_szLocalPackedIP;
}

// --------------------------------------------------------------------------------
// SzGetLocalHostName
// --------------------------------------------------------------------------------
LPSTR SzGetLocalHostName(void)
{
    // Locals
    static char s_szLocalHost[255] = {0};

    // Init WinSock...
    HrInitializeWinsock();

    // Gets local host name from socket library
    if (*s_szLocalHost == 0)
    {
        if (gethostname (s_szLocalHost, sizeof (s_szLocalHost)) == SOCKET_ERROR)
        {
            // $REVIEW - What should i do if this fails ???
            Assert (FALSE);
            DebugTrace ("gethostname failed: WSAGetLastError: %ld\n", WSAGetLastError ());
            lstrcpyA (s_szLocalHost, "LocalHost");
        }
    }

    // Done
    return s_szLocalHost;
}

// --------------------------------------------------------------------------------
// StripIllegalHostChars
// --------------------------------------------------------------------------------
void StripIllegalHostChars(LPSTR pszSrc, LPSTR pszDst)
{
    // Locals
    LPSTR       pszT;
    CHAR        ch;
    ULONG       cchDst=0;

    // Setup pszT
    pszT = pszDst;

    // Loop through the Source
    while('\0' != *pszSrc)
    {
        // Set ch
        ch = *pszSrc++;

        // A-Z, a-z, 0-9, no trailing dots
        if ('.' == ch || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'))
        {
            // Store the Character
            *pszT++ = ch;

            // Increment Size
            cchDst++;
        }
    }

    // Null terminate pszT
    *pszT = '\0';

    // Strip Trailing dots...
    while (cchDst > 0)
    {
        // Last char is a dot
        if ('.' != pszDst[cchDst - 1])
            break;

        // Strip It
        pszDst[cchDst - 1] = '\0';

        // Decrement cchDst
        cchDst--;
    }

    // Nothing Left ?
    if (0 == cchDst)
        lstrcpy(pszDst, "LocalHost");
}

// ------------------------------------------------------------------------------------
// FEndRetrRecvBody
// ------------------------------------------------------------------------------------
BOOL FEndRetrRecvBody(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract)
{
    // Loop the data until we hit the end of the data (i.e. '.') or there is no more data
    if (cbRead >= 5                  &&
        pszLines[cbRead - 1] == '\n' &&
        pszLines[cbRead - 2] == '\r' &&
        pszLines[cbRead - 3] == '.'  &&
        pszLines[cbRead - 4] == '\n' &&
        pszLines[cbRead - 5] == '\r')
    {
        *pcbSubtract = 5;
        return TRUE;
    }

    // If Last Line Ended with a CRLF, then lets just check for a .CRLF
    else if (cbRead >= 3                   &&
             // m_rInfo.rFetch.fLastLineCRLF  &&
             pszLines[0] == '.'            &&
             pszLines[1] == '\r'           &&
             pszLines[2] == '\n')
    {
        *pcbSubtract = 3;
        return TRUE;
    }

    // Not done yet
    return FALSE;
}

BOOL FEndRetrRecvBodyNews(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract)
{
    DWORD       dwIndex = 0;
    BOOL        fRet    = FALSE;

    // If we have at least 5 characters...
    if (cbRead >= 5)
    {    
        //[shaheedp] Bug# 85807
        for (dwIndex = 0; dwIndex <= (cbRead - 5); dwIndex++)
        {
            if ((pszLines[dwIndex] == '\r') &&
                (pszLines[dwIndex + 1] == '\n') &&
                (pszLines[dwIndex + 2] == '.')  &&
                (pszLines[dwIndex + 3] == '\r') &&
                (pszLines[dwIndex + 4] == '\n'))
            {
                *pcbSubtract = (cbRead - dwIndex);
                fRet = TRUE;
                break;
            }
        }
    }

    //If we didn't find CRLF.CRLF, then lets find .CRLF at the beginning of the line.
    if (!fRet)
    {
        if ((cbRead >= 3) &&
            (pszLines[0] == '.') &&
            (pszLines[1] == '\r') &&
            (pszLines[2] == '\n'))
        {
            *pcbSubtract = cbRead;
            fRet = TRUE;
        }
    }
    return fRet;
}

// ------------------------------------------------------------------------------------
// UnStuffDotsFromLines
// ------------------------------------------------------------------------------------
void UnStuffDotsFromLines(LPSTR pszBuffer, INT *pcchBuffer)
{
    // Locals
    ULONG   iIn=0;
    ULONG   iOut=0;
    CHAR    chPrev='\0';
    CHAR    chNext;
    CHAR    chT;
    ULONG   cchBuffer=(*pcchBuffer);

    // Invalid Args
    Assert(pszBuffer && pcchBuffer);

    // Loop
    while(iIn < cchBuffer)
    {
        // Get Current Char
        chT = pszBuffer[iIn++];

        // Validate
        Assert(chT);

        // Leading dot
        if ('.' == chT && ('\0' == chPrev || '\n' == chPrev || '\r' == chPrev) && iIn < cchBuffer)
        {
            // Compute chNext
            chNext = pszBuffer[iIn];

            // Valid to strip ?
            if ('\r' != chNext && '\n' != chNext)
            {
                // Next Character
                chT = pszBuffer[iIn++];

                // Set chPrev
                chPrev = '.';
            }

            // Save Previous
            else
                chPrev = chT;
        }

        // Save Previous
        else
            chPrev = chT;

        // Set the character
        pszBuffer[iOut++] = chT;
    }

    // Reset pcchBuffer
    *pcchBuffer = iOut;

    // Done
    return;
}

// =============================================================================================
// SkipWhitespace
// Assumes piString points to character boundary
// =============================================================================================
void SkipWhitespace (LPCTSTR lpcsz, ULONG *pi)
{
    if (!lpcsz || !pi)
    {
        Assert (FALSE);
        return;
    }

#ifdef DEBUG
    Assert (*pi <= (ULONG)lstrlen (lpcsz)+1);
#endif

    LPTSTR lpsz = (LPTSTR)(lpcsz + *pi);
    while (*lpsz != '\0')
    {
        if (!IsSpace(lpsz))
            break;

            lpsz++;
            (*pi)+=1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixputil.h ===
// --------------------------------------------------------------------------------
// Ixputil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __IXPUTIL_H
#define __IXPUTIL_H

// --------------------------------------------------------------------------------
// Host Name Utilities
// --------------------------------------------------------------------------------
void    StripIllegalHostChars(LPSTR pszSrc, LPSTR pszDst);
HRESULT HrInitializeWinsock(void);
void    UnInitializeWinsock(void);
LPSTR   SzGetLocalPackedIP(void);
LPSTR   SzGetLocalHostNameForID(void);
LPSTR   SzGetLocalHostName(void);
BOOL    FEndRetrRecvBody(LPTSTR pszLines, ULONG cbRead, ULONG *pcbSubtract);
LPSTR   PszGetDomainName(void);
void    UnStuffDotsFromLines(LPSTR pszBuffer, INT *pcchBuffer);
BOOL    FEndRetrRecvBodyNews(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract);
void    SkipWhitespace (LPCTSTR lpcsz, ULONG *pi);
#endif // __IXPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpras.h ===
// --------------------------------------------------------------------------------
// Ixpras.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPRAS_H
#define __IXPRAS_H

// --------------------------------------------------------------------------------
// Dependencies
// --------------------------------------------------------------------------------
#include "imnxport.h"

// --------------------------------------------------------------------------------
// CRASTransport
// --------------------------------------------------------------------------------
class CRASTransport : public IRASTransport
{
private:
    ULONG               m_cRef;         // Reference counting
    CHAR                m_szConnectoid[CCHMAX_CONNECTOID]; // Current connectoid
    HRASCONN            m_hConn;        // Handle to current RAS Connection
    BOOL                m_fConnOwner;   // We own the current RAS connection
    IRASCallback       *m_pCallback;    // RAS callback interface
    INETSERVER          m_rServer;      // Server Information
    RASDIALPARAMS       m_rDialParams;  // Dialing information
    UINT                m_uRASMsg;      // RAS Message
    HWND                m_hwndRAS;      // RAS callback window
    CRITICAL_SECTION    m_cs;           // Thread Safety

private:
    BOOL    FRasHangupAndWait(DWORD dwMaxWaitSeconds);
    BOOL    FEnumerateConnections(LPRASCONN *pprgConn, ULONG *pcConn);
    BOOL    FFindConnection(LPSTR pszConnectoid, LPHRASCONN phConn);
    HRESULT HrLogon(BOOL fForcePrompt);
    HRESULT HrStartRasDial(void);

    static INT_PTR CALLBACK RASConnectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CRASTransport(void);
    ~CRASTransport(void);

    // ----------------------------------------------------------------------------
    // IUnknown Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus) {return E_NOTIMPL;};

    // ----------------------------------------------------------------------------
    // IRASTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(IRASCallback *pCallback);
    STDMETHODIMP GetRasErrorString(UINT uRasErrorValue, LPSTR pszErrorString, ULONG cchMax, DWORD *pdwRASResult);
    STDMETHODIMP FillConnectoidCombo(HWND hwndComboBox, boolean fUpdateOnly, DWORD *pdwRASResult);
    STDMETHODIMP EditConnectoid(HWND hwndParent, LPSTR pszConnectoid, DWORD *pdwRASResult);
    STDMETHODIMP CreateConnectoid(HWND hwndParent, DWORD *pdwRASResult);
    STDMETHODIMP GetCurrentConnectoid(LPSTR pszConnectoid, ULONG cchMax);
};

#endif // __IXPRAS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpsmtp.h ===
// --------------------------------------------------------------------------------
// Ixpsmtp.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPSMTP_H
#define __IXPSMTP_H

// ------------------------------------------------------------------------------------
// Depends
// ------------------------------------------------------------------------------------
#include "ixpbase.h"
#include "ixppop3.h"

// --------------------------------------------------------------------------------
// CSMTPTransport
// --------------------------------------------------------------------------------
class CSMTPTransport : public CIxpBase, public ISMTPTransport2
{
private:
    AUTHINFO            m_rAuth;            // Authorization Information
    SMTPCOMMAND         m_command;          // Current command being processed
    SMTPMESSAGE2        m_rMessage;         // Current Message
    ULONG               m_iAddress;         // Current RCPT/MAIL address in rAdressList::prgAddress
    ULONG               m_cRecipients;      // Number of recipients for current message
    DWORD               m_cbSent;           // SendDataStream current Number of bytes sent
    DWORD               m_cbTotal;          // SendDataStream total bytes
    BOOL                m_fSendMessage;     // Are we in the process of a ::SendMessage
    BOOL                m_fReset;           // Is a reset needed on next ::SendMessage Call
    CHAR                m_szEmail[255];     // The last sent email address using MAIL or RCPT
    BOOL                m_fSTARTTLSAvail;   // Is the STARTTLS command available on this server?
    BOOL                m_fTLSNegotiation;  // Are we in TLS negotiation?
    BOOL                m_fSecured;         // Is the connection secured?
    BOOL                m_fDSNAvail;        // Does the server support DSNs?

private:
    void OnSocketReceive(void);
    void SendMessage_DATA(void);
    void SendMessage_MAIL(void);
    void SendMessage_RCPT(void);
    void SendMessage_DONE(HRESULT hrResult, LPSTR pszProblem=NULL);
    HRESULT HrGetResponse(void);
    void DispatchResponse(HRESULT hrResult, BOOL fDone, LPSTR pszProblem=NULL);
    void SendStreamResponse(BOOL fDone, HRESULT hrResult, DWORD cbIncrement);
    HRESULT _HrFormatAddressString(LPCSTR pszEmail, LPCSTR pszExtra, LPSTR *ppszAddress);
    void OnEHLOResponse(LPCSTR pszResponse);
    void ResponseAUTH(HRESULT hrResponse);
    BOOL FSendSicilyString(LPSTR pszData);
    void CancelAuthInProg(void);
    void StartLogon(void);
    void LogonRetry(void);
    void TryNextAuthPackage(void);
    void DoLoginAuth(HRESULT hrResponse);
    void DoPackageAuth(HRESULT hrResponse);
    void DoAuthNegoResponse(HRESULT hrResponse);
    void OnAuthorized(void);
    void RetryPackage(void);
    void DoAuthRespResponse(HRESULT hrResponse);
    HRESULT _HrHELO_Or_EHLO(LPCSTR pszCommand, SMTPCOMMAND eNewCommand);
    LPSTR _PszGetCurrentAddress(void);
    HRESULT CommandSTARTTLS(void);
    void StartTLS(void);
    void TryNextSecurityPkg(void);

public:                          
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CSMTPTransport(void);
    ~CSMTPTransport(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // ISMTPTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPSTR pszLogFilePath, ISMTPCallback *pCallback);
    STDMETHODIMP SendMessage(LPSMTPMESSAGE pMessage);
    STDMETHODIMP FreeInetAddrList(LPINETADDRLIST pAddressList);
    STDMETHODIMP CommandAUTH(LPSTR pszAuthType);
    STDMETHODIMP CommandMAIL(LPSTR pszEmailFrom);
    STDMETHODIMP CommandRCPT(LPSTR pszEmailTo);
    STDMETHODIMP CommandEHLO(void);
    STDMETHODIMP CommandHELO(void);
    STDMETHODIMP CommandQUIT(void);
    STDMETHODIMP CommandRSET(void);
    STDMETHODIMP CommandDATA(void);
    STDMETHODIMP CommandDOT(void);
    STDMETHODIMP SendDataStream(IStream *pStream, ULONG cbSize);

    // ----------------------------------------------------------------------------
    // ISMTPTransport2 methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP SendMessage2(LPSMTPMESSAGE2 pMessage);
    STDMETHODIMP CommandRCPT2(LPSTR pszEmailTo, INETADDRTYPE atDSN);
    STDMETHODIMP SetWindow(void);
    STDMETHODIMP ResetWindow(void);

    // ----------------------------------------------------------------------------
    // CIxpBase methods
    // ----------------------------------------------------------------------------
    virtual void ResetBase(void);
    virtual void DoQuit(void);
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void);
    virtual void OnLeaveBusy(void);
};

#endif // __IXPSMTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\lookup.h ===
/*
 *    lookup.h
 *    
 *    Purpose:
 *        hostname lookup
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Jun 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#ifndef __LOOKUP_H__
#define __LOOKUP_H__

void InitLookupCache(void);
void DeInitLookupCache(void);

HRESULT LookupHostName(LPTSTR pszHostName, HWND hwndNotify, ULONG *pulAddr, LPBOOL pfCached, BOOL fForce);
HRESULT CancelLookup(LPTSTR pszHostName, HWND hwndNotify);

#define SPM_WSA_GETHOSTBYNAME   (WM_USER + 2)

#endif // __LOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\lookup.cpp ===
/*
 *    lookup.cpp
 *    
 *    Purpose:
 *        hostname lookup
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Jun 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#include <pch.hxx>
#include <process.h>
#include <demand.h>
#include "lookup.h"

ASSERTDATA

#define HWND_ALLOC_NUM      4
#define LOOKUP_ALLOC_NUM    16
#define MAX_CACHED_ADDRS    16

struct LOOKUPINFO {
    LPTSTR  pszHostName;
    ULONG   rgAddr[MAX_CACHED_ADDRS];
    ULONG   cAddr;
    HTHREAD hThreadLookup;
    HWND   *rgHwndNotify;
    ULONG   cHwnd;
    ULONG   cHwndAlloc;
};

static LOOKUPINFO *s_rgLookUp = NULL;
static ULONG       s_cLookUp = 0;
static ULONG       s_cLookUpAlloc = 0;

static CRITICAL_SECTION s_csLookup;

HRESULT AddHwnd(LOOKUPINFO *pLI, HWND hwnd)
{
    HRESULT hr = S_OK;

    if (pLI->cHwnd == pLI->cHwndAlloc)
        {
        if (FAILED(HrRealloc((LPVOID*)&pLI->rgHwndNotify, (pLI->cHwndAlloc + HWND_ALLOC_NUM) * sizeof(HWND))))
            return E_OUTOFMEMORY;
        pLI->cHwndAlloc += HWND_ALLOC_NUM;
        }

    pLI->rgHwndNotify[pLI->cHwnd++] = hwnd;
    return S_OK;    
}

unsigned int __stdcall LookupThreadProc(LPVOID pv)
{
    LOOKUPINFO *pLI;
    LPHOSTENT   pHostEnt;
    LPTSTR      pszHostName;
    int         iLastError = 0;
    ULONG       ulAddr = (ULONG)-1, i;

    EnterCriticalSection(&s_csLookup);
    pszHostName = s_rgLookUp[(ULONG_PTR)pv].pszHostName;            
    LeaveCriticalSection(&s_csLookup);

    // do the actual lookup
    pHostEnt = gethostbyname(pszHostName);
    if (NULL == pHostEnt)
    iLastError = WSAGetLastError();

    EnterCriticalSection(&s_csLookup);
    pLI = &s_rgLookUp[(ULONG_PTR)pv];
    if (pHostEnt)
        {
        // copy the returned addresses into our buffer    
        while (pLI->cAddr < MAX_CACHED_ADDRS && pHostEnt->h_addr_list[pLI->cAddr])
            {
            pLI->rgAddr[pLI->cAddr] = *(ULONG *)(pHostEnt->h_addr_list[pLI->cAddr]);
            pLI->cAddr++;
            }
        ulAddr = pLI->rgAddr[0];
        }
    else
        {
        Assert(0 == pLI->cAddr);
        }
    // notify the registered windows that the lookup is complete
    for (i = 0; i < pLI->cHwnd; i++)
        if (IsWindow(pLI->rgHwndNotify[i]))
            PostMessage(pLI->rgHwndNotify[i], SPM_WSA_GETHOSTBYNAME, (WPARAM)iLastError, (LPARAM)ulAddr);
    pLI->cHwnd = 0;
    CloseHandle(pLI->hThreadLookup);
    pLI->hThreadLookup = NULL;
    LeaveCriticalSection(&s_csLookup);

    return 0;
}

void InitLookupCache(void)
{
    InitializeCriticalSection(&s_csLookup);
}

void DeInitLookupCache(void)
{
    ULONG       i;
    LOOKUPINFO *pLI;
    HANDLE      hThread;

    EnterCriticalSection(&s_csLookup);
    for (i = 0, pLI = s_rgLookUp; i < s_cLookUp; i++, pLI++)
        {
        if (pLI->hThreadLookup)
            {
            pLI->cHwnd = 0;
            // Raid 42360: WSACleanup() faults on Win95 if we still have a 
            //  lookup thread running.  WaitForSingleObject() on a thread 
            //  doesn't seem to work at DLL_PROCESS_DETACH time. 
            //  TerminateThread() seems to be the only reliable solution - 
            //  gross but it works.
            TerminateThread(pLI->hThreadLookup, 0);
            CloseHandle(pLI->hThreadLookup);
            }
        SafeMemFree(pLI->pszHostName);
        SafeMemFree(pLI->rgHwndNotify);
        }
    SafeMemFree(s_rgLookUp);
    s_cLookUp = s_cLookUpAlloc = 0;
    LeaveCriticalSection(&s_csLookup);
    DeleteCriticalSection(&s_csLookup);
}

HRESULT LookupHostName(LPTSTR pszHostName, HWND hwndNotify, ULONG *pulAddr, LPBOOL pfCached, BOOL fForce)
{
    ULONG       i;
    LOOKUPINFO *pLI;
    HRESULT     hr;
    DWORD       uiThreadId;

    *pfCached = FALSE;

    EnterCriticalSection(&s_csLookup);

    for (i = 0, pLI = s_rgLookUp; i < s_cLookUp; i++, pLI++)
        {
        Assert(pLI->pszHostName);
        if (!lstrcmpi(pLI->pszHostName, pszHostName))
            {
            if (pLI->hThreadLookup)
                {
                // there's a lookup in progress, so just append
                hr = AddHwnd(pLI, hwndNotify);
                goto exit;
                }
            else if (fForce || !pLI->cAddr)
                {
                // a previous connect or lookup failed, so try again
                pLI->cAddr = 0;
                goto startlookup;
                }
            else
                {
                // we've got the address cached
                *pulAddr = pLI->rgAddr[0];
                *pfCached = TRUE;
                hr = S_OK;
                goto exit;
                }
            }
        }

    // we didn't find it, so add it
    if (s_cLookUp == s_cLookUpAlloc)
        {
        if (FAILED(hr = HrRealloc((LPVOID*)&s_rgLookUp, (s_cLookUpAlloc + LOOKUP_ALLOC_NUM) * sizeof(LOOKUPINFO))))
            goto exit;
        s_cLookUpAlloc += LOOKUP_ALLOC_NUM;
        ZeroMemory(&s_rgLookUp[s_cLookUp], LOOKUP_ALLOC_NUM * sizeof(LOOKUPINFO));
        pLI = &s_rgLookUp[s_cLookUp];
        }

    pLI->pszHostName = PszDup(pszHostName);
    if (NULL == pLI->pszHostName)
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }

    s_cLookUp++;

startlookup:
    Assert(pLI->cAddr == 0);

    hr = AddHwnd(pLI, hwndNotify);
    if (FAILED(hr))
        goto exit;

    Assert(pLI->cHwnd == 1);

    // pLI->hThreadLookup = (HANDLE)_beginthreadex(NULL, 0, LookupThreadProc, (LPVOID)i, 0, &uiThreadId);
    pLI->hThreadLookup = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)LookupThreadProc, (LPVOID)IntToPtr(i), 0, &uiThreadId);
    if (NULL == pLI->hThreadLookup)
        {
        hr = E_FAIL;
        pLI->cHwnd = 0;
        }

exit:
    LeaveCriticalSection(&s_csLookup);
    return hr;
}

HRESULT CancelLookup(LPTSTR pszHostName, HWND hwndNotify)
{
    ULONG       i, j, cMove;
    LOOKUPINFO *pLI;
    HRESULT     hr = E_INVALIDARG;

    EnterCriticalSection(&s_csLookup);

    for (i = 0, pLI = s_rgLookUp; i < s_cLookUp; i++, pLI++)
        {
        Assert(pLI->pszHostName);
        if (!lstrcmpi(pLI->pszHostName, pszHostName))
            {
            for (j = 0; j < pLI->cHwnd; j++)
                {
                if (pLI->rgHwndNotify[j] == hwndNotify)
                    {
                    while (j + 1 < pLI->cHwnd)
                        {
                        pLI->rgHwndNotify[j] = pLI->rgHwndNotify[j+1];
                        j++;
                        }
                    pLI->cHwnd--;
                    hr = S_OK;
                    break;
                    }
                }
            break;
            }
        }

    LeaveCriticalSection(&s_csLookup);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\range.cpp ===
//
// RANGE.CPP
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
//

// -*- C -*-
//
//  Copyright 1992 Software Innovations, Inc.
//
//  $Source: D:\CLASS\SOURCE\range.c-v $
//  $Author: martin $
//  $Date: 92/07/15 05:09:24 $
//  $Revision: 1.1 $
//
//

#include "pch.hxx"
#include "range.h"
#include "dllmain.h"

// QUANTUM defines the number of m_rangeTable cells to be allocated at
//   one time.  Whenever the m_rangeTable becomes full, it is expanded
//   by QUANTUM range cells.  m_rangeTable's never shrink.
const int QUANTUM = 64;


inline int inRange(RangeType r, ULONG x) { return ((x>=r.low) && (x<=r.high)); };

CRangeList::CRangeList()
{
    DllAddRef();
    m_numRanges = 0;
    m_rangeTableSize = 0;
    m_rangeTable = NULL;
    m_lRefCount = 1;
}

CRangeList::~CRangeList()
{
    Assert(0 == m_lRefCount);

    if (m_rangeTable)
        MemFree(m_rangeTable);

    DllRelease();
}


HRESULT STDMETHODCALLTYPE CRangeList::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppvObject);

    // Init variables, check the arguments
    hrResult = E_NOINTERFACE;
    if (NULL == ppvObject)
        goto exit;

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid)
        *ppvObject = (IUnknown *) this;

    if (IID_IRangeList == iid)
        *ppvObject = (IRangeList *) this;

    // If we returned an interface, AddRef it
    if (NULL != *ppvObject) {
        ((IUnknown *)*ppvObject)->AddRef();
        hrResult = S_OK;
    }

exit:
    return hrResult;
} // QueryInterface



//***************************************************************************
// Function: AddRef
//
// Purpose:
//   This function should be called whenever someone makes a copy of a
// pointer to this object. It bumps the reference count so that we know
// there is one more pointer to this object, and thus we need one more
// release before we delete ourselves.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CRangeList::AddRef(void)
{
    Assert(m_lRefCount > 0);

    m_lRefCount += 1;

    DOUT ("CRangeList::AddRef, returned Ref Count=%ld", m_lRefCount);
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release
//
// Purpose:
//   This function should be called when a pointer to this object is to
// go out of commission. It knocks the reference count down by one, and
// automatically deletes the object if we see that nobody has a pointer
// to this object.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CRangeList::Release(void)
{
    Assert(m_lRefCount > 0);
    
    m_lRefCount -= 1;
    DOUT("CRangeList::Release, returned Ref Count = %ld", m_lRefCount);

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release




HRESULT STDMETHODCALLTYPE CRangeList::IsInRange(const ULONG value)
{
    Assert(m_lRefCount > 0);
    
    for (int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return S_OK;
    return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CRangeList::MinOfRange(const ULONG value,
                                                 ULONG *pulMinOfRange)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMinOfRange);

    *pulMinOfRange = RL_RANGE_ERROR;
    if (RL_RANGE_ERROR == value)
        return S_OK; // No need to loop through the ranges

    for (register int i=0; i<m_numRanges; i++) {
        if (inRange(m_rangeTable[i], value)) {
            *pulMinOfRange = m_rangeTable[i].low;
            break;
        } // if
    } // for

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::MaxOfRange(const ULONG value,
                                                 ULONG *pulMaxOfRange)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMaxOfRange);

    *pulMaxOfRange = RL_RANGE_ERROR;
    if (RL_RANGE_ERROR == value)
        return S_OK; // No need to loop through the ranges

    for (register int i=0; i<m_numRanges; i++) {
        if (inRange(m_rangeTable[i], value)) {
            *pulMaxOfRange = m_rangeTable[i].high;
            break;
        } // if
    } // for

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Max(ULONG *pulMax)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMax);
    
    if (m_numRanges==0)
        *pulMax = RL_RANGE_ERROR;
    else
        *pulMax = m_rangeTable[m_numRanges-1].high;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Min(ULONG *pulMin)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMin);
    
    if (m_numRanges==0)
        *pulMin = RL_RANGE_ERROR;
    else
        *pulMin = m_rangeTable[0].low;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Save(LPBYTE *ppb, ULONG *pcb)
{
    Assert(m_lRefCount > 0);
    Assert(ppb);
    Assert(pcb);

    *pcb = m_numRanges * sizeof(RangeType);
    if (*pcb)
        {
        if (!MemAlloc((LPVOID*)ppb, *pcb))
            return E_OUTOFMEMORY;
        CopyMemory(*ppb, m_rangeTable, *pcb);
        }
    else
        *ppb = NULL;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Load(LPBYTE pb, const ULONG cb)
{
    Assert(m_lRefCount > 0);
    
    m_numRanges = m_rangeTableSize = cb / sizeof(RangeType);
    if (m_rangeTable)
        MemFree(m_rangeTable);
    m_rangeTable = (RangeType *)pb;

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRangeList::AddSingleValue(const ULONG value)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { value, value };
    return AddRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::AddRange(const ULONG low, const ULONG high)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { low, high };
    return AddRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::AddRangeList(const IRangeList *prl)
{
    Assert(m_lRefCount > 0);
    AssertSz(FALSE, "Not implemented, probably never will be");
    return E_NOTIMPL;
}


HRESULT CRangeList::AddRangeType(const RangeType range)
{
    int  possibleLoc;
    int  insertPosition;

    Assert(m_lRefCount > 0);
    
    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to AddRange()");
        return E_INVALIDARG;
        }

    if (m_numRanges==0) 
        {
        if (m_rangeTableSize == 0)
            if (!Expand())
                return E_OUTOFMEMORY;
        m_numRanges = 1;
        CopyMemory(&m_rangeTable[0], &range, sizeof(RangeType));
        } 
    else 
        {
        possibleLoc = BinarySearch(range.low);
        if (!((possibleLoc > -1) &&
              (inRange(m_rangeTable[possibleLoc], range.low)) &&
              (inRange(m_rangeTable[possibleLoc], range.high)))) 
            {
            insertPosition = possibleLoc + 1;
            if (m_numRanges == m_rangeTableSize)
                if (!Expand())
                    return E_OUTOFMEMORY;
            ShiftRight(insertPosition, 1);
            CopyMemory(&m_rangeTable[insertPosition], &range, sizeof(RangeType));
            if (insertPosition > 0)
                SubsumeDown(insertPosition);
            if (insertPosition < m_numRanges)
                SubsumeUpwards(insertPosition);
            }
        }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::DeleteSingleValue(const ULONG value)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { value, value };
    return DeleteRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::DeleteRange(const ULONG low, const ULONG high)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { low, high };
    return DeleteRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::DeleteRangeList(const IRangeList *prl)
{
    Assert(m_lRefCount > 0);
    
    AssertSz(FALSE, "Not implemented, probably never will be");
    return E_NOTIMPL;
}

HRESULT CRangeList::DeleteRangeType(const RangeType range)
{
    int lowEndChange;
    int highEndChange;

    Assert(m_lRefCount > 0);
    
    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to DeleteRange()");
        return E_INVALIDARG;
        }

    lowEndChange = BinarySearch(range.low);
    highEndChange = BinarySearch(range.high);

    if ((lowEndChange != -1) && (highEndChange == lowEndChange))  
        {
        if (inRange(m_rangeTable[lowEndChange], range.low)) 
            {
            if (inRange(m_rangeTable[lowEndChange], range.high)) 
                {
                if ((m_rangeTable[lowEndChange].low == range.low) &&
                    (m_rangeTable[lowEndChange].high == range.high)) 
                    {
                    if (lowEndChange == (m_numRanges-1))  
                        {
                        m_numRanges--;
                        } 
                    else 
                        {
                        ShiftLeft(lowEndChange + 1, 1);
                        }
                    } 
                else 
                    {
                    if (m_rangeTable[lowEndChange].low == range.low)  
                        {
                        m_rangeTable[lowEndChange].low = range.high + 1;
                        } 
                    else 
                        {
                        if (m_rangeTable[lowEndChange].high == range.high) 
                            {
                            Assert(range.low > 0);
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            } 
                        else 
                            {
                            // the range to be deleted is properly contained in 
                            //  m_rangeTable[lowEndChange]
                            if (m_numRanges == m_rangeTableSize)
                                if (!Expand())
                                    return E_OUTOFMEMORY;
                            ShiftRight(lowEndChange + 1, 1);
                            m_rangeTable[lowEndChange + 1].low = range.high + 1;
                            m_rangeTable[lowEndChange + 1].high = m_rangeTable[lowEndChange].high;
                            Assert(range.low > 0);    
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            }
                        }
                    }
                } 
            else 
                {
                // range.low is in m_rangeTable[lowEndChange], but range.high
                //  is not
                if (m_rangeTable[lowEndChange].low == range.low) 
                    {
                    ShiftLeft(lowEndChange + 1, 1);
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }  // of the cases where range.low actually in m_rangeTable[lowEndChange]
        } 
    else 
        { // of the cases where highEndChange == lowEndChange
        if (lowEndChange != -1)  
            {
            if (inRange(m_rangeTable[lowEndChange], range.low))  
                {
                if (range.low == m_rangeTable[lowEndChange].low) 
                    {
                    lowEndChange = lowEndChange - 1;
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }
        if (highEndChange != -1)  
            {
            if (inRange(m_rangeTable[highEndChange], range.high))  
                {
                if (range.high == m_rangeTable[highEndChange].high)  
                    {
                    highEndChange = highEndChange + 1;
                    } 
                else 
                    {
                    m_rangeTable[highEndChange].low = range.high + 1;
                    }
                } 
            else 
                {
                highEndChange++;
                }
            }
        if (!(lowEndChange > highEndChange)) 
            {
            // (0 <= lowEndChange < m_numRanges => m_rangeTable[lowEndChange] has received
            //                 any requisite adjustments and is to be kept)
            //  and (0 <= highEndChange < m_numRanges => m_rangeTable[highEndChange]
            //                 has received any requistie adjs. and is a keeper)
            //  and "forall" i [ lowEndChange < i < highEndChange => 
            //                   m_rangeTable[i] is to be overwritten]
            if (highEndChange >= m_numRanges)  
                {
                m_numRanges = lowEndChange + 1;
                } 
            else 
                {
                if ((highEndChange - lowEndChange - 1) > 0)  
                    {
                    ShiftLeft(highEndChange, (highEndChange-lowEndChange-1));
                    }
                }
            } //  else there's a problem with this code...
        }
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRangeList::Next(const ULONG current, ULONG *pulNext)
{
    int loc;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulNext);
    
    if (m_numRanges == 0)
        {
        *pulNext = RL_RANGE_ERROR;
        return S_OK;
        }

    if ((loc = BinarySearch(current)) == -1)
        {
        *pulNext = m_rangeTable[0].low;
        return S_OK;
        }
    else if (loc == (m_numRanges-1))
        {
        if (inRange(m_rangeTable[m_numRanges-1], current))
            {
            if (inRange(m_rangeTable[m_numRanges-1], current + 1))
                {
                *pulNext = current + 1;
                return S_OK;
                }
            else
                {
                *pulNext = RL_RANGE_ERROR;
                return S_OK;
                }
            }
        else
            {
            *pulNext = RL_RANGE_ERROR;
            return S_OK;
            }
        }
    else // case where loc == m_numRanges-1
        {
        // 1 <= loc < m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (inRange(m_rangeTable[loc], current + 1))
                {
                *pulNext = current + 1;
                return S_OK;
                }
            else
                {
                *pulNext = m_rangeTable[loc + 1].low;
                return S_OK;
                }
            }
        else
            {
            *pulNext = m_rangeTable[loc + 1].low;
            return S_OK;
            }
        }
}

HRESULT STDMETHODCALLTYPE CRangeList::Prev(const ULONG current, ULONG *pulPrev)
{
    int loc;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulPrev);
    
    if (m_numRanges == 0)
        {
        *pulPrev = RL_RANGE_ERROR;
        return S_OK;
        }

    if ((loc = BinarySearch(current)) == -1) 
        {
        *pulPrev = RL_RANGE_ERROR;
        return S_OK;
        } 
    else if (loc == 0)
        {
        if (inRange(m_rangeTable[0], current))
            {
            if (current > 0 && inRange(m_rangeTable[0], current - 1))
                {
                *pulPrev = current - 1;
                return S_OK;
                }
            else
                {
                *pulPrev = RL_RANGE_ERROR;
                return S_OK;
                }
            }
        else
            {
            *pulPrev = m_rangeTable[0].high;
            return S_OK;
            }
        }
    else
        {
        // 1 < loc <= m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (current > 0 && inRange(m_rangeTable[loc], current - 1))
                {
                *pulPrev = current - 1;
                return S_OK;
                }
            else
                {
                *pulPrev = m_rangeTable[loc-1].high;
                return S_OK;
                }
            }
        else
            {
            *pulPrev = m_rangeTable[loc].high;
            return S_OK;
            }
        }
}

HRESULT STDMETHODCALLTYPE CRangeList::Cardinality(ULONG *pulCardinality)
{
    ULONG card = 0;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulCardinality);
    
    for (int i=0 ; i<m_numRanges ; i++)
        card += (m_rangeTable[i].high - m_rangeTable[i].low + 1);

    *pulCardinality = card;
    return S_OK;
}



HRESULT STDMETHODCALLTYPE CRangeList::CardinalityFrom(const ULONG ulStartPoint,
                                                      ULONG *pulCardinalityFrom)
{
    ULONG ulNumMsgsInRange;
    int i;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulCardinalityFrom);
    
    // Initialize variables
    ulNumMsgsInRange = 0;
    *pulCardinalityFrom = 0;

    // Find the range where ulStartPoint lives
    i = BinarySearch(ulStartPoint + 1);
    if (-1 == i || ulStartPoint > m_rangeTable[i].high)
        return S_OK; // ulStartPoint + 1 is not in the range

    // If ulStartPoint is at start or middle of range, add incomplete range to total
    if (ulStartPoint >= m_rangeTable[i].low &&
        ulStartPoint <= m_rangeTable[i].high) {
        // Add incomplete range to total - Don't include ulStartPoint!
        ulNumMsgsInRange += m_rangeTable[i].high - ulStartPoint;
        i += 1;
    }

    // Add the remaining WHOLE ranges
    for (; i < m_numRanges; i++)
        ulNumMsgsInRange += m_rangeTable[i].high - m_rangeTable[i].low + 1;

    *pulCardinalityFrom = ulNumMsgsInRange;
    return S_OK;
} // Cardinality (with start point arg)



int CRangeList::BinarySearch(const ULONG value) const
{
//  We are looking for `value' in the m_rangeTable.  If value is in the
//  set of valid ranges, we return the array subscript of the range
//  containing `value'.  If `value' is not contained in any of the 
//  ranges then return `loc' where
//        (0 <= loc < m_numRanges =>
//                 (m_rangeTable[loc].low < rangeNum)
//           "and" (m_rangeTable[loc + 1].low > rangeNum))
//    "and" (loc = m_numRanges => rangeNum > m_rangeTable[m_numRanges].low)
//    "and" (loc = -1 =>     m_numRanges = 0
//                     "or" rangeNum < m_rangeTable[0].low) }
    long low, high, mid;
    int loc = -1;

    Assert(m_lRefCount > 0);

    if (m_numRanges == 0)
        return -1;

    if (value < m_rangeTable[0].low)
        return -1;

    low = 0;
    high = m_numRanges - 1;
    while (low <= high) {
        // inv: low < high - 1, and if rngNum is any where in m_rangeTable, it is in
        //      the range from m_rangeTable[low] to m_rangeTable[high]
        mid = (low + high) / 2;
        if ((value >= m_rangeTable[mid].low) && 
            ((mid == (m_numRanges-1)) || (value < m_rangeTable[mid + 1].low))) 
            {
            loc = mid;
            high = low - 1;
            } 
        else 
            {
            if (value > m_rangeTable[mid].low)
                low = mid + 1;
            else
                high = mid - 1;
            }
    }
    return loc;
}

// Expand() will grow the m_rangeTable by QUANTUM range cells.
BOOL CRangeList::Expand()
{
    RangeType *newRangeTable;

    Assert(m_lRefCount > 0);
    
    if (!MemAlloc((LPVOID*)&newRangeTable, (m_rangeTableSize + QUANTUM) * sizeof(RangeType)))
        return FALSE;

    m_rangeTableSize += QUANTUM;
    if (m_rangeTable) 
        {
        if (m_numRanges > 0)
            CopyMemory(newRangeTable, m_rangeTable, m_numRanges * sizeof(RangeType));
        MemFree(m_rangeTable);
        }
    m_rangeTable = newRangeTable;
    return TRUE;
}

void CRangeList::ShiftLeft(int low, int distance)
{
    Assert(m_lRefCount > 0);
    
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low-distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges -= distance;
}

void CRangeList::ShiftRight(int low, int distance)
{
    Assert(m_lRefCount > 0);
    
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low+distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges += distance;
}

// pre: (m_rangeTable[anchorPosition] has probably just been added to m_rangeTable.)
//          1 <= anchorPosition <= m_numRanges
//      and (   anchorPosition = 1
//           or (m_rangeTable[anchorPosition].low >
//                 m_rangeTable[anchorPosition - 1].high) )
// post: No overlapping or contiguous ranges from 1 to m_numRanges. }
void CRangeList::SubsumeUpwards(const int anchor)
{
    int posOfLargerLow;
    int copyDownDistance;
    int copyPos;

    Assert(m_lRefCount > 0);
    
    posOfLargerLow = anchor + 1;
    while ((posOfLargerLow < m_numRanges) && 
           (m_rangeTable[posOfLargerLow].low <= m_rangeTable[anchor].high + 1))
        posOfLargerLow++;

    if (posOfLargerLow == m_numRanges) 
        {
        if (m_rangeTable[m_numRanges-1].high > m_rangeTable[anchor].high)
            m_rangeTable[anchor].high = m_rangeTable[m_numRanges-1].high;
        m_numRanges = anchor + 1;
        } 
    else 
        {
        // posOfLargerLow now indexes the first element of m_rangeTable, looking from
        // m_rangeTable[anchor], with .low > m_rangeTable[anchor].high + 1
        if (posOfLargerLow > (anchor + 1)) 
            {
            if (m_rangeTable[posOfLargerLow - 1].high > m_rangeTable[anchor].high) 
                m_rangeTable[anchor].high = m_rangeTable[posOfLargerLow - 1].high;
            copyDownDistance = posOfLargerLow - anchor - 1;
            copyPos = posOfLargerLow;
            while (copyPos < m_numRanges) 
                {
                m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
                copyPos = copyPos + 1;
                }
            m_numRanges -= copyDownDistance;
            }
        }
}

void CRangeList::SubsumeDown(int& anchor)
{
    int posOfSmallerHigh;
    int copyDownDistance;
    int copyPos;

    Assert(m_lRefCount > 0);
    
    posOfSmallerHigh = anchor - 1;
    while ((posOfSmallerHigh >= 0) &&
           (m_rangeTable[posOfSmallerHigh].high + 1 >= m_rangeTable[anchor].low)) 
        {
        posOfSmallerHigh--;
        }

    if (posOfSmallerHigh < 0) 
        {
        if (m_rangeTable[0].low < m_rangeTable[anchor].low)
            m_rangeTable[anchor].low = m_rangeTable[0].low;
        }

    // posOfSmallerHigh either has value 0 or subscripts the first element of
    //  m_rangeTable, looking down from anchor, with a .high that is
    //  less than m_rangeTable[anchor].low - 1.
    if (m_rangeTable[posOfSmallerHigh + 1].low < m_rangeTable[anchor].low)
        m_rangeTable[anchor].low = m_rangeTable[posOfSmallerHigh + 1].low;
    copyDownDistance = anchor - posOfSmallerHigh - 1;
    if (copyDownDistance > 0) 
        {
        copyPos = anchor;
        while (copyPos < m_numRanges) 
            {
            m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
            copyPos++;
            }
        m_numRanges -= copyDownDistance;
        anchor -= copyDownDistance;
        }
}



//***************************************************************************
// Function: RangeToIMAPString
//
// Purpose:
//   This function outputs the rangelist as an IMAP message set, suitable
// for use in IMAP commands.
//
// Arguments:
//   LPSTR *ppszDestination [out] - an IMAP message set string is
//     returned here. It is the responsibility of the caller to CoTaskMemFree
//     this buffer when he is done with it. Pass in NULL if not interested.
//   LPDWORD pdwLengthOfDestination [out] - if successful, this function
//     returns the length of the IMAP msg set returned via pszDestination.
//     Pass in NULL if not interested.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CRangeList::RangeToIMAPString(LPSTR *ppszDestination,
                                                        LPDWORD pdwLengthOfDestination)
{
    int i;
    BOOL bFirstRange;
    CByteStream bstmIMAPString;
    HRESULT hrResult;

    Assert(m_lRefCount > 0);

    // Initialize return values
    if (ppszDestination)
        *ppszDestination = NULL;
    if (pdwLengthOfDestination)
        *pdwLengthOfDestination = 0;

    hrResult = S_OK;
    bFirstRange = TRUE; // Suppress leading comma for first range
    for (i = 0; i < m_numRanges; i += 1) {
        char szTemp[128];
        int iLengthOfTemp;

        // Convert current range to string form
        if (m_rangeTable[i].low == m_rangeTable[i].high)
            iLengthOfTemp = wsprintf(szTemp + 1, "%lu", m_rangeTable[i].low);
        else
            iLengthOfTemp = wsprintf(szTemp + 1, "%lu:%lu", m_rangeTable[i].low,
                m_rangeTable[i].high);

        if (FALSE == bFirstRange) {
            szTemp[0] = ','; // Prepend a comma
            iLengthOfTemp += 1; // Include leading comma
        }

        // Append new range to destination buffer (with or without leading comma)
        hrResult = bstmIMAPString.Write(bFirstRange ? szTemp + 1 : szTemp,
            iLengthOfTemp, NULL);
        if (FAILED(hrResult))
            break;

        bFirstRange = FALSE;
    } // for

    if (SUCCEEDED(hrResult))
        hrResult = bstmIMAPString.HrAcquireStringA(pdwLengthOfDestination,
            ppszDestination, ACQ_DISPLACE);

    return hrResult;
} // RangeToIMAPString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\propfind.h ===
// --------------------------------------------------------------------------------
// propfind.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------

#ifndef __PROPFIND_H
#define __PROPFIND_H

#include "mimeole.h" // for base IHashTable interface
#include "hash.h"

class CByteStream;

const DWORD c_dwMaxNamespaceID = DAVNAMESPACE_CONTACTS;

// --------------------------------------------------------------------------------
// class CStringArray
// Description : CStringArray is a simple utility class that maintains
// an list of strings that are retrievable by index.
// --------------------------------------------------------------------------------
class CStringArray
{
public:
    CStringArray(void);
    ~CStringArray(void);

private:
    CStringArray(const CStringArray& other);
    CStringArray& operator=(const CStringArray& other);

public:
    ULONG   Length(void) { return m_ulLength; }

    HRESULT Add(LPCSTR psz);
    HRESULT Adopt(LPCSTR psz);
    LPCSTR  GetByIndex(ULONG ulIndex);

    HRESULT RemoveByIndex(ULONG ulIndex);

private:
    BOOL    Expand(void);

private:
    LPCSTR  *m_rgpszValues;
    ULONG   m_ulLength;
    ULONG   m_ulCapacity;
};

// wrap a CHash to provide a destructor that deallocates
// string data.
class CStringHash : public CHash
{
public:
    virtual ~CStringHash();
};

class CDAVNamespaceArbiterImp
{
public:
    CDAVNamespaceArbiterImp(void);
    ~CDAVNamespaceArbiterImp(void);

    HRESULT AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    HRESULT GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    HRESULT GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix);

    LPSTR AllocExpandedName(DWORD dwNamespaceID, LPCSTR pszPropertyName);

    HRESULT WriteNamespaces(IStream *pStream);

    BOOL                m_rgbNsUsed[c_dwMaxNamespaceID + 1];    // flags indicating whether the
                                                                // known namespaces are used
    CStringArray        m_saNamespaces;                         // string array of namespaces

private:
    HRESULT _AppendXMLNamespace(IStream *pStream, LPCSTR pszNamespace, DWORD dwNamespaceID, BOOL fWhitespacePrefix);
};

class CPropPatchRequest : public IPropPatchRequest
{
public:
    // ----------------------------------------------------------------------------
    // Construction/Destruction
    // ----------------------------------------------------------------------------
    CPropPatchRequest(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IDAVNamespaceArbiter methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix);

    // ----------------------------------------------------------------------------
    // IPropPatchRequest methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP SetProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName, LPCSTR pszNewValue);
    STDMETHODIMP RemoveProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName);
    STDMETHODIMP GenerateXML(LPSTR *ppszXML);

    // ----------------------------------------------------------------------------
    // Internal Methods
    // ----------------------------------------------------------------------------
    void         SpecifyWindows1252Encoding(BOOL fSpecify1252) { m_fSpecify1252 = fSpecify1252; }
    STDMETHODIMP GenerateXML(LPHTTPTARGETLIST pTargets, LPSTR *ppszXML);

private:
    BOOL                    m_fSpecify1252;
    CDAVNamespaceArbiterImp m_dna;
    ULONG                   m_cRef;             // Reference Count
    CStringArray            m_saPropNames;      // string array of property names
    CStringArray            m_saPropValues;     // string array of property values
    CStringArray            m_saRemovePropNames;// string array of properties to remove
};

class CPropFindRequest : public IPropFindRequest
{
public:
    // ----------------------------------------------------------------------------
    // Construction/Destruction
    // ----------------------------------------------------------------------------
    CPropFindRequest(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IDAVNamespaceArbiter methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix);

    // ----------------------------------------------------------------------------
    // IPropFindRequest methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP AddProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName);
    STDMETHODIMP GenerateXML(LPSTR *ppszXML);

private:
    HRESULT AppendXMLNamespace(CByteStream& bs, LPCSTR pszNamespace, DWORD dwNamespaceID);

private:
    CDAVNamespaceArbiterImp m_dna;
    ULONG                   m_cRef;            // Reference Count
    CStringArray            m_saProperties;    // string array of properties
};

class CPropFindMultiResponse : public IPropFindMultiResponse
{
public:
    CPropFindMultiResponse(void);
    ~CPropFindMultiResponse(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IPropFindMultiStatus methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(BOOL) IsComplete(void);
    STDMETHODIMP GetLength(ULONG *pulLength);
    STDMETHODIMP GetResponse(ULONG ulIndex, IPropFindResponse **ppResponse);

    // ----------------------------------------------------------------------------
    // CPropFindMultiStatus methods
    // ----------------------------------------------------------------------------
    BOOL GetDone(void) { return m_bDone; }
    void SetDone(BOOL bDone) { m_bDone = bDone; }

    HRESULT HrAddResponse(IPropFindResponse *pResponse);
    
private:
    ULONG               m_cRef;
    BOOL                m_bDone;
    ULONG               m_ulResponseCapacity;
    ULONG               m_ulResponseLength;
    IPropFindResponse   **m_rgResponses;
};

class CPropFindResponse : public IPropFindResponse
{
public:
    CPropFindResponse(void);
    ~CPropFindResponse(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IPropFindResponse methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(BOOL) IsComplete(void);
    STDMETHODIMP GetHref(LPSTR *ppszHref);
    STDMETHODIMP GetProperty(DWORD dwNamespaceID, LPSTR pszPropertyName, LPSTR *ppszPropertyValue);

public:
    // ----------------------------------------------------------------------------
    // CPropFindResponse methods
    // ----------------------------------------------------------------------------
    HRESULT HrInitPropFindResponse(IPropFindRequest *pRequest);
    HRESULT HrAdoptHref(LPCSTR pszHref);
    HRESULT HrAdoptProperty(LPCSTR pszKey, LPCSTR pszValue);

private:
    ULONG               m_cRef;
    BOOL                m_bDone;
    LPCSTR              m_pszHref;
    IPropFindRequest    *m_pRequest;
    CStringHash         m_shProperties;
    DWORD               m_dwCachedNamespaceID;
    LPSTR               m_pszCachedNamespacePrefix;
};

#endif // __PROPFIND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\propfind.cpp ===
// --------------------------------------------------------------------------------
// propfind.cpp
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------

#include <pch.hxx>
#include "propfind.h"
#include "strconst.h"
#include "davstrs.h"

#define FAIL_EXIT_STREAM_WRITE(stream, psz) \
    if (FAILED(hr = stream.Write(psz, lstrlen(psz), NULL))) \
        goto exit; \
    else

#define FAIL_EXIT(hr) \
    if (FAILED(hr)) \
        goto exit; \
    else

const ULONG c_ulGrowSize = 4;

static const char *g_rgszNamespaces[] =
{
    c_szDAVDavNamespace,
    c_szDAVHotMailNamespace,
    c_szDAVHTTPMailNamespace,
    c_szDAVMailNamespace,
    c_szDAVContactsNamespace
};

// predefine the first 10 namespace prefixes. if custom namespaces
// exceed the predefined set, additional prefixes are generated on
// the fly.

static const char *g_rgszNamespacePrefixes[] =
{
    c_szDavNamespacePrefix,
    c_szHotMailNamespacePrefix,
    c_szHTTPMailNamespacePrefix,
    c_szMailNamespacePrefix,
    c_szContactsNamespacePrefix,
    "_5",
    "_6",
    "_7",
    "_8",
    "_9"
};

const DWORD c_dwMaxDefinedNamespacePrefix = 10;

CStringArray::CStringArray(void) :
    m_rgpszValues(NULL),
    m_ulLength(0),
    m_ulCapacity(0)
{
}


CStringArray::~CStringArray(void)
{
    for (ULONG i = 0; i < m_ulLength; ++i)
    {
        if (NULL != m_rgpszValues[i])
            MemFree((void *)m_rgpszValues[i]);
    }

    SafeMemFree(m_rgpszValues);
}

HRESULT CStringArray::Add(LPCSTR psz)
{
    if (NULL == psz)
        return E_INVALIDARG;

    if (m_ulLength == m_ulCapacity && !Expand())
        return E_OUTOFMEMORY;

    m_rgpszValues[m_ulLength] = PszDupA(psz);
    if (NULL == m_rgpszValues)
        return E_OUTOFMEMORY;

    ++m_ulLength;
    return S_OK;
}

HRESULT CStringArray::Adopt(LPCSTR psz)
{
    if (NULL == psz)
        return E_INVALIDARG;

    if (m_ulLength == m_ulCapacity && !Expand())
        return E_OUTOFMEMORY;

    m_rgpszValues[m_ulLength] = psz;
    ++m_ulLength;
    return S_OK;
}

LPCSTR CStringArray::GetByIndex(ULONG ulIndex)
{
    if (0 == m_ulLength || (ulIndex > m_ulLength - 1))
        return NULL;

    return m_rgpszValues[ulIndex];
}

// --------------------------------------------------------------------------------
// CStringArray::RemoveByIndex
// --------------------------------------------------------------------------------
HRESULT CStringArray::RemoveByIndex(ULONG ulIndex)
{
    if (ulIndex > m_ulLength - 1)
        return E_INVALIDARG;

    if (NULL != m_rgpszValues[ulIndex])
    {
        MemFree(const_cast<char *>(m_rgpszValues[ulIndex]));
        m_rgpszValues[ulIndex] = NULL;
    }

    // shift down
    CopyMemory(&m_rgpszValues[ulIndex], m_rgpszValues[ulIndex + 1], (m_ulLength - ulIndex) * sizeof(LPSTR));
    --m_ulLength;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CStringArray::Expand
// --------------------------------------------------------------------------------
BOOL CStringArray::Expand(void)
{
    LPCSTR *rgpszNewValues = NULL;
    if (!MemAlloc((void **)&rgpszNewValues, sizeof(LPSTR) * (m_ulCapacity + c_ulGrowSize)))
        return FALSE;

    // clear the new slots
    for (ULONG i = m_ulCapacity; i < (m_ulCapacity + c_ulGrowSize); ++i)
        rgpszNewValues[i] = NULL;

    // copy the old values over and swap in the new buffer
    CopyMemory(rgpszNewValues, m_rgpszValues, sizeof(LPSTR) * m_ulCapacity); 
    SafeMemFree(m_rgpszValues);
    
    m_rgpszValues = rgpszNewValues;
    m_ulCapacity += c_ulGrowSize;

    return TRUE;
}

// --------------------------------------------------------------------------------
// CStringHash::~CStringHash
// --------------------------------------------------------------------------------
CStringHash::~CStringHash(void)
{
    PHASHENTRY phe;

    // data stored in the hash table
    // are strings that can need to 
    // be deallocated.
    for (DWORD dw = 0; dw < m_cBins; dw++)
    {
        SafeMemFree(m_rgBins[dw].pv);

        phe = m_rgBins[dw].pheNext;
        while (phe)
        {
            SafeMemFree(phe->pv);
            phe = phe->pheNext;
        }
    }
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::CDAVNamespaceArbiterImp
// --------------------------------------------------------------------------------
CDAVNamespaceArbiterImp::CDAVNamespaceArbiterImp(void)
{
    for (ULONG i = 0; i <= c_dwMaxNamespaceID; ++i)
        m_rgbNsUsed[i] = FALSE;

    // the DAV namespace is always included
    m_rgbNsUsed[DAVNAMESPACE_DAV] = TRUE;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::~CDAVNamespaceArbiterImp
// --------------------------------------------------------------------------------
CDAVNamespaceArbiterImp::~CDAVNamespaceArbiterImp(void)
{
    // nothing to do
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::AddNamespace
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    HRESULT hr = S_OK;

    if (NULL == pszNamespace || NULL == pdwNamespaceID)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (FAILED(hr = m_saNamespaces.Add(pszNamespace)))
        goto exit;
    
    *pdwNamespaceID = m_saNamespaces.Length() + c_dwMaxNamespaceID;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::GetNamespaceID
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    DWORD dwIndex;
    DWORD dwEntries;

    if (NULL == pszNamespace || NULL == pdwNamespaceID)
        return E_INVALIDARG;

    // look for a predefined namespace
    for (dwIndex = 0; dwIndex < c_dwMaxNamespaceID; ++dwIndex)
    {
        if (!lstrcmp(pszNamespace, g_rgszNamespaces[dwIndex]))
        {
            *pdwNamespaceID = dwIndex;
            return S_OK;
        }
    }

    // look for a user-defined prefix
    dwEntries = m_saNamespaces.Length();
    for (dwIndex = 0; dwIndex < dwEntries; ++dwIndex)
    {
        if (!lstrcmp(pszNamespace, m_saNamespaces.GetByIndex(dwIndex)))
        {
            *pdwNamespaceID = (dwIndex + (c_dwMaxNamespaceID + 1));
            return S_OK;
        }
    }
    
    // if it wasn't found, the namespace doesn't exist
    return E_INVALIDARG;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::GetNamespacePrefix
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix)
{
    HRESULT hr = S_OK;
    LPSTR   pszTemp = NULL;

    if (NULL == ppszNamespacePrefix)
        return E_INVALIDARG;

    if (dwNamespaceID <= c_dwMaxDefinedNamespacePrefix)
        *ppszNamespacePrefix = PszDupA(g_rgszNamespacePrefixes[dwNamespaceID]);
    else
    {
        char szBuffer[12];
        wsprintf(szBuffer, "_%d", dwNamespaceID);
        *ppszNamespacePrefix = PszDupA(szBuffer);
    }
    
    if (NULL == *ppszNamespacePrefix)
        hr = E_OUTOFMEMORY;

    return hr;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::AllocExpandedName
// --------------------------------------------------------------------------------
LPSTR CDAVNamespaceArbiterImp::AllocExpandedName(DWORD dwNamespaceID, LPCSTR pszPropertyName)
{
    LPSTR       pszPrefixedName = NULL;
    const DWORD c_dwMaxIntLength = 10;

    if (dwNamespaceID < c_dwMaxDefinedNamespacePrefix)
    {
        // allocate a buffer to hold the prefixed name.
        if (!MemAlloc((void **)&pszPrefixedName, lstrlen(pszPropertyName) + lstrlen(g_rgszNamespacePrefixes[dwNamespaceID]) + (2 * sizeof(TCHAR))))
            return NULL;

        // generate the prefixed name
        wsprintf(pszPrefixedName, "%s:%s", g_rgszNamespacePrefixes[dwNamespaceID], pszPropertyName);
    }
    else
    {
        // allocate a buffer to hold the prefixed name. the "2" is for the prefix char '_" , the delimiting
        // colon and the eos.    

        if (!MemAlloc((void **)&pszPrefixedName, lstrlen(pszPropertyName) + c_dwMaxIntLength + (sizeof(TCHAR) * 3)))
            return NULL;


        // generate the prefixed name. use an underscore as the first char, because
        // DAV explicitly disallows digits for the first char.
        wsprintf(pszPrefixedName, "_%d:%s", dwNamespaceID, pszPropertyName);
    }

    return pszPrefixedName;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::WriteNamespaces
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::WriteNamespaces(IStream *pStream)
{
    HRESULT         hr = S_OK;
    ULONG           i;
    ULONG           cEntries;
    BOOL            fNeedSpacePrefix = FALSE;

    // write out the intrinsic namespaces
    for (i = 0; i <= c_dwMaxNamespaceID; ++i)
    {
        if (m_rgbNsUsed[i])
        {
            if (FAILED(hr = _AppendXMLNamespace(pStream, g_rgszNamespaces[i], i, fNeedSpacePrefix)))
                goto exit;
            fNeedSpacePrefix = TRUE;
        }
    }

    // write out the installed namespaces
    cEntries = m_saNamespaces.Length();
    for (i = 0; i < cEntries; ++i)
    {
        if (FAILED(hr = _AppendXMLNamespace(pStream, m_saNamespaces.GetByIndex(i), i + i + c_dwMaxNamespaceID + 1, fNeedSpacePrefix)))
            goto exit;

        fNeedSpacePrefix = TRUE;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::_AppendXMLNamespace
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::_AppendXMLNamespace(IStream *pStream, 
                                                     LPCSTR pszNamespace, 
                                                     DWORD dwNamespaceID,
                                                     BOOL fWhitespacePrefix)
{
    HRESULT hr = S_OK;
    TCHAR   szPrefix[12];

    if (fWhitespacePrefix)
    {
        IxpAssert(1 == lstrlen(c_szEqual));
        if (FAILED(hr = pStream->Write(g_szSpace, 1, NULL)))
            goto exit;
    }

    if (FAILED(hr = pStream->Write(c_szXMLNsColon, lstrlen(c_szXMLNsColon), NULL)))
        goto exit;

    if (dwNamespaceID < c_dwMaxDefinedNamespacePrefix)
    {
        if (FAILED(hr = pStream->Write(g_rgszNamespacePrefixes[dwNamespaceID], lstrlen(g_rgszNamespacePrefixes[dwNamespaceID]), NULL)))
            goto exit;
    }
    else
    {
        wsprintf(szPrefix, "_%d", dwNamespaceID);

        if (FAILED(hr = pStream->Write(szPrefix, lstrlen(szPrefix), NULL)))
            goto exit;
    }

    IxpAssert(1 == lstrlen(c_szEqual));
    IxpAssert(1 == lstrlen(c_szDoubleQuote));

    if (FAILED(hr = pStream->Write(c_szEqual, 1, NULL)))
        goto exit;

    if (FAILED(hr = pStream->Write(c_szDoubleQuote, 1, NULL)))
        goto exit;

    if (FAILED(hr = pStream->Write(pszNamespace, lstrlen(pszNamespace), NULL)))
        goto exit;

    hr = pStream->Write(c_szDoubleQuote, 1, NULL);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::CPropPatchRequest
// --------------------------------------------------------------------------------
CPropPatchRequest::CPropPatchRequest(void) :
    m_fSpecify1252(FALSE),
    m_cRef(1)
{
    // nothing to do
}

// --------------------------------------------------------------------------------
// IUnknown Methods
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropPatchRequest::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindRequest *)this);
    else if (IID_IPropPatchRequest == riid)
        *ppv = ((IPropPatchRequest *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropPatchRequest::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropPatchRequest::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// ----------------------------------------------------------------------------
// IDAVNamespaceArbiter methods
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropPatchRequest::CPropPatchRequest::AddNamespace
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.AddNamespace(pszNamespace, pdwNamespaceID);    
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GetNamespaceID
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.GetNamespaceID(pszNamespace, pdwNamespaceID);
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GetNamespacePrefix
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix)
{
    return m_dna.GetNamespacePrefix(dwNamespaceID, ppszNamespacePrefix);
}

// --------------------------------------------------------------------------------
// IPropPatchRequest Methods
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
// CPropPatchRequest::SetProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::SetProperty(
                                    DWORD dwNamespaceID, 
                                    LPCSTR pszPropertyName, 
                                    LPCSTR pszNewValue)
{
    LPSTR pszPrefixedName = NULL;
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == pszPropertyName || NULL == pszNewValue || dwNamespaceID > c_dwMaxNamespaceID + m_dna.m_saNamespaces.Length())
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pszPrefixedName = m_dna.AllocExpandedName(dwNamespaceID, pszPropertyName);
    if (NULL == pszPrefixedName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // if the namespace is one of the known namespaces, mark it in
    // the array so that we can include the namespace directive in
    // the generated xml
    if (dwNamespaceID <= c_dwMaxNamespaceID)
        m_dna.m_rgbNsUsed[dwNamespaceID] = TRUE;

    if (FAILED(hr = m_saPropValues.Add(pszNewValue)))
        goto exit;

    if (FAILED(hr = m_saPropNames.Adopt(pszPrefixedName)))
    {
        MemFree(pszPrefixedName);
        m_saPropValues.RemoveByIndex(m_saPropValues.Length() - 1);
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::RemoveProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::RemoveProperty(
                                    DWORD dwNamespaceID, 
                                    LPCSTR pszPropertyName)
{
    LPSTR pszPrefixedName = NULL;
    HRESULT hr = S_OK;

    if (NULL == pszPropertyName || dwNamespaceID > c_dwMaxNamespaceID + m_dna.m_saNamespaces.Length())
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pszPrefixedName = m_dna.AllocExpandedName(dwNamespaceID, pszPropertyName);
    if (NULL == pszPrefixedName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // if the namespace is one of the known namespaces, mark it in
    // the array so that we can include the namespace directive in the
    // generated xml
    if (dwNamespaceID <= c_dwMaxNamespaceID)
        m_dna.m_rgbNsUsed[dwNamespaceID] = TRUE;

    hr = m_saRemovePropNames.Adopt(pszPrefixedName);

exit:
    return hr;    
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GenerateXML
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GenerateXML(LPSTR *ppszXML)
{
    return GenerateXML(NULL, ppszXML);
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GenerateXML
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GenerateXML(LPHTTPTARGETLIST pTargets, LPSTR *ppszXML)
{
    const DWORD c_dwLocalBufferSize = 256;

    HRESULT         hr = S_OK;
    CByteStream     stream;
    ULONG           cEntries;
    LPCSTR          pszName = NULL;
    LPCSTR          pszValue = NULL;
    ULONG           i;
    DWORD           dwIndex;
    DWORD           cbStr1, cbStr2;

    if (NULL == ppszXML)
        return E_INVALIDARG;

    *ppszXML= NULL;

    // write the DAV header
    if (m_fSpecify1252)
        FAIL_EXIT_STREAM_WRITE(stream, c_szXML1252Head);
    else
        FAIL_EXIT_STREAM_WRITE(stream, c_szXMLHead);

    // write out the proppatch header
    FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchHead);

	// write out namespace directives using the new form
    FAIL_EXIT(hr = m_dna.WriteNamespaces(&stream));

    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);
    
    // write out the targets
    if (NULL != pTargets && pTargets->cTarget > 0)
    {
        cbStr1 = lstrlen(c_szHrefHead);
        cbStr2 = lstrlen(c_szHrefTail);

        FAIL_EXIT_STREAM_WRITE(stream, c_szTargetHead);
        
        // write out the targets
        for (dwIndex = 0; dwIndex < pTargets->cTarget; dwIndex++)
        {
            FAIL_EXIT(hr = stream.Write(c_szHrefHead, cbStr1, NULL));

            FAIL_EXIT_STREAM_WRITE(stream, pTargets->prgTarget[dwIndex]);

            FAIL_EXIT(hr = stream.Write(c_szHrefTail, cbStr2, NULL));
        }
        FAIL_EXIT_STREAM_WRITE(stream, c_szTargetTail);
    }

    // write out the "set" properties
    cEntries = m_saPropNames.Length();
    if (cEntries > 0)
    {
        // write the set header
        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchSetHead);

        for (i = 0; i < cEntries; ++i)
        {
            FAIL_EXIT_STREAM_WRITE(stream, c_szCRLFTabTabTabOpenElement);

            pszName = m_saPropNames.GetByIndex(i);
            if (NULL == pszName)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            FAIL_EXIT_STREAM_WRITE(stream, pszName);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);

            pszValue = m_saPropValues.GetByIndex(i);
            if (NULL == pszValue)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            FAIL_EXIT_STREAM_WRITE(stream, pszValue);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLOpenTermElement);
            FAIL_EXIT_STREAM_WRITE(stream, pszName);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);
        }

        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchSetTail);
    }

    // write out the remove properties
    cEntries = m_saRemovePropNames.Length();
    if (cEntries > 0)
    {
        // write the remove header
        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchRemoveHead);

        for (i = 0; i < cEntries; ++i)
        {
            FAIL_EXIT_STREAM_WRITE(stream, c_szCRLFTabTabTabOpenElement);

            pszName = m_saRemovePropNames.GetByIndex(i);
            if (NULL == pszName)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            FAIL_EXIT_STREAM_WRITE(stream, pszName);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseTermElement);
        }

        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchRemoveTail);
    }

    FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchTailCRLF);

    hr = stream.HrAcquireStringA(NULL, ppszXML, ACQ_DISPLACE);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::CPropFindRequest
// --------------------------------------------------------------------------------
CPropFindRequest::CPropFindRequest(void) :
    m_cRef(1)
{
}

// --------------------------------------------------------------------------------
// IUnknown Methods
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindRequest::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindRequest *)this);
    else if (IID_IPropFindRequest == riid)
        *ppv = ((IPropFindRequest *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindRequest::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindRequest::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// ----------------------------------------------------------------------------
// IDAVNamespaceArbiter methods
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindRequest::CPropPatchRequest::AddNamespace
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.AddNamespace(pszNamespace, pdwNamespaceID);    
}

// --------------------------------------------------------------------------------
// CPropFindRequest::GetNamespaceID
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.GetNamespaceID(pszNamespace, pdwNamespaceID);
}

// --------------------------------------------------------------------------------
// CPropFindRequest::GetNamespacePrefix
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix)
{
    return m_dna.GetNamespacePrefix(dwNamespaceID, ppszNamespacePrefix);
}

// --------------------------------------------------------------------------------
// IPropFindRequest Methods
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindRequest::AddProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::AddProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName)
{
    const DWORD c_dwMaxIntLength = 10;
    LPSTR pszPrefixedName = NULL;

    // Validate Params
    if (NULL == pszPropertyName || dwNamespaceID > c_dwMaxNamespaceID + m_dna.m_saNamespaces.Length())
        return E_INVALIDARG;

    pszPrefixedName = m_dna.AllocExpandedName(dwNamespaceID, pszPropertyName);
    if (NULL == pszPrefixedName)
        return E_OUTOFMEMORY;

    // if the namespace is one of the known namespaces, mark
    // the array so that we can include the namespace directive
    // in the generated xml.
    if (dwNamespaceID <= c_dwMaxNamespaceID)
        m_dna.m_rgbNsUsed[dwNamespaceID] = TRUE;

    m_saProperties.Adopt(pszPrefixedName);

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::GenerateXML
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::GenerateXML(LPSTR *ppszXML)
{
    const DWORD c_dwLocalBufferSize = 256;

    HRESULT         hr = S_OK;
    CByteStream     stream;
    ULONG           cbLength = 0;
    ULONG           cEntries;
    ULONG           i;
    LPCSTR          pszProperty;

    if (NULL == ppszXML)
        return E_INVALIDARG;

    *ppszXML = NULL;

    // write the DAV header
    if (FAILED(hr = stream.Write(c_szXMLHead, lstrlen(c_szXMLHead), NULL)))
        goto exit;

    // write out the propfind header
    if (FAILED(hr = stream.Write(c_szPropFindHead1, lstrlen(c_szPropFindHead1), NULL)))
        goto exit;

	// write out namespaces using the new form
	if (FAILED(hr = m_dna.WriteNamespaces(&stream)))
		goto exit;

    if (FAILED(hr = stream.Write(c_szPropFindHead2, lstrlen(c_szPropFindHead2), NULL)))
        goto exit;
    
    // write out the properties
    cEntries = m_saProperties.Length();
    for (i = 0; i < cEntries; ++i)
    {
        if (FAILED(hr = stream.Write(c_szCRLFTabTabOpenElement, lstrlen(c_szCRLFTabTabOpenElement), NULL)))
            goto exit;

        // properties are prefixed when they are added to the collection
        pszProperty = m_saProperties.GetByIndex(i);
        if (!pszProperty)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if (FAILED(hr = stream.Write(pszProperty, lstrlen(pszProperty), NULL)))
            goto exit;

        if (FAILED(hr = stream.Write(c_szXMLCloseTermElement, lstrlen(c_szXMLCloseTermElement), NULL)))
            goto exit;
    }
    
    if (FAILED(hr = stream.Write(c_szPropFindTail, lstrlen(c_szPropFindTail), NULL)))
        goto exit;
    
    hr = stream.HrAcquireStringA(NULL, ppszXML, ACQ_DISPLACE);

exit:
    return hr;
}


// --------------------------------------------------------------------------------
// class CPropFindMultiResponse
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::CPropFindMultiResponse
// --------------------------------------------------------------------------------
CPropFindMultiResponse::CPropFindMultiResponse(void) :
    m_cRef(1),
    m_bDone(FALSE),
    m_ulResponseCapacity(0),
    m_ulResponseLength(0),
    m_rgResponses(NULL)
{
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::~CPropFindMultiResponse
// --------------------------------------------------------------------------------
CPropFindMultiResponse::~CPropFindMultiResponse(void)
{
    for (ULONG i = 0; i < m_ulResponseLength; i++)
        SafeRelease(m_rgResponses[i]);

    SafeMemFree(m_rgResponses);
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindMultiResponse::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindRequest *)this);
    else if (IID_IPropFindMultiResponse == riid)
        *ppv = ((IPropFindMultiResponse *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindMultiResponse::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindMultiResponse::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::IsComplete
// --------------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CPropFindMultiResponse::IsComplete(void)
{
    return m_bDone;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::GetLength
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindMultiResponse::GetLength(ULONG *pulLength)
{
    if (NULL == pulLength)
        return E_INVALIDARG;

    *pulLength = m_ulResponseLength;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::GetResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindMultiResponse::GetResponse(ULONG ulIndex, 
                                                 IPropFindResponse **ppResponse)
{
    if (ulIndex >= m_ulResponseLength || !ppResponse)
        return E_INVALIDARG;

    *ppResponse = m_rgResponses[ulIndex];
    (*ppResponse)->AddRef();

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::HrAddResponse
// --------------------------------------------------------------------------------
HRESULT CPropFindMultiResponse::HrAddResponse(IPropFindResponse *pResponse)
{
    const ULONG c_dwInitialCapacity = 4;

    HRESULT hr = S_OK;
    IPropFindResponse **ppNewResponses = NULL;
    DWORD dwNewCapacity;

    if (!pResponse)
        return E_INVALIDARG;
    

    if (m_ulResponseLength == m_ulResponseCapacity)
    {
        dwNewCapacity = !m_ulResponseCapacity ? c_dwInitialCapacity : (m_ulResponseCapacity * 2);

        if (!MemAlloc((void **)&ppNewResponses, dwNewCapacity * sizeof(IPropFindResponse *)))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        ZeroMemory(ppNewResponses, dwNewCapacity * sizeof(IPropFindResponse *));
        
        // copy the old values over
        if (m_ulResponseCapacity)
            CopyMemory(ppNewResponses, m_rgResponses, m_ulResponseCapacity * sizeof(IPropFindResponse *));

        // free the old buffer
        SafeMemFree(m_rgResponses);

        m_rgResponses = ppNewResponses;
        m_ulResponseCapacity = dwNewCapacity;
    }

    m_rgResponses[m_ulResponseLength++] = pResponse;
    pResponse->AddRef();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// Class CPropFindResponse
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindResponse::CPropFindResponse
// --------------------------------------------------------------------------------
CPropFindResponse::CPropFindResponse(void) :
    m_cRef(1),
    m_bDone(FALSE),
    m_pszHref(NULL),
    m_pRequest(NULL),
    m_shProperties(),
    m_dwCachedNamespaceID(0),
    m_pszCachedNamespacePrefix(NULL)
{

}

// --------------------------------------------------------------------------------
// CPropFindResponse::~CPropFindResponse
// --------------------------------------------------------------------------------
CPropFindResponse::~CPropFindResponse(void)
{
    if (NULL != m_pszHref)
        MemFree(const_cast<char*>(m_pszHref));
    SafeRelease(m_pRequest);
    SafeMemFree(m_pszCachedNamespacePrefix);
}

// --------------------------------------------------------------------------------
// CPropFindResponse::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindResponse::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindResponse *)this);
    else if (IID_IPropFindResponse == riid)
        *ppv = ((IPropFindResponse *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindResponse::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindResponse::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::IsComplete
// --------------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CPropFindResponse::IsComplete(void)
{
    return m_bDone;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::GetHref
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindResponse::GetHref(LPSTR *pszHref)
{
    if (NULL == pszHref)
        return E_INVALIDARG;

    *pszHref = NULL;

    if (NULL == m_pszHref)
        return E_FAIL;

    *pszHref = PszDupA(m_pszHref);
    if (!*pszHref)
        return E_OUTOFMEMORY;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::GetProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindResponse::GetProperty(
                                    DWORD dwNamespaceID, 
                                    LPSTR pszPropertyName, 
                                    LPSTR *ppszPropertyValue)
{
    char    szLocalPropBuffer[256];
    LPSTR   pszPropBuffer = NULL;
    BOOL    bFreePropBuffer = FALSE;
    LPSTR   pszPrefix = NULL;
    HRESULT hr = S_OK;
    ULONG   ulPrefixLength;
    ULONG   ulPropertyLength;
    LPSTR   pszFoundValue = NULL;

    if (!pszPropertyName)
        return E_INVALIDARG;

    *ppszPropertyValue = NULL;

    // first convert the namespace id into a prefix.
    // to facilitate fast lookups, we cache the most recently
    // seen custom namespace

    if (dwNamespaceID < c_dwMaxDefinedNamespacePrefix)
        pszPrefix = const_cast<char *>(g_rgszNamespacePrefixes[dwNamespaceID]);
    else if (dwNamespaceID == m_dwCachedNamespaceID)
        pszPrefix = m_pszCachedNamespacePrefix;
    else if (m_pRequest)
    {
        if (FAILED(hr = m_pRequest->GetNamespacePrefix(dwNamespaceID, &pszPrefix)))
            goto exit;

        // free the one-deep cache and store the new
        // prefix and ID.
        SafeMemFree(m_pszCachedNamespacePrefix);
        m_dwCachedNamespaceID = dwNamespaceID;
        m_pszCachedNamespacePrefix = pszPrefix;
    }

    ulPrefixLength = lstrlen(pszPrefix);
    ulPropertyLength = lstrlen(pszPropertyName);

    if ((ulPrefixLength + ulPropertyLength + (2 * sizeof(TCHAR))) < 256)
    {
        // the combined length is small enough to use
        // the stack-based buffer
        pszPropBuffer = szLocalPropBuffer;
    }
    else
    {
        if (!MemAlloc((void **)&pszPropBuffer, ulPrefixLength + ulPropertyLength + (2 * sizeof(TCHAR))))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        bFreePropBuffer = TRUE;
    }
    
    wsprintf(pszPropBuffer, "%s:%s", pszPrefix, pszPropertyName);

    // XML parser uppercases everything
    CharUpper(pszPropBuffer);

    // now that the property name has been created, look for the
    // value in the property hash table
    if (FAILED(hr = m_shProperties.Find(pszPropBuffer, FALSE, (void **)&pszFoundValue)))
        goto exit;
    
    *ppszPropertyValue = PszDupA(pszFoundValue);
    if (NULL == *ppszPropertyValue)
        hr = E_OUTOFMEMORY;

exit:
    if (bFreePropBuffer)
        SafeMemFree(pszPropBuffer);

    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::HrInitPropFindResponse
// --------------------------------------------------------------------------------
HRESULT CPropFindResponse::HrInitPropFindResponse(IPropFindRequest *pRequest)
{
    if (NULL == pRequest)
        return E_INVALIDARG;
    
    IxpAssert(!m_pRequest);
    
    HRESULT hr = S_OK;

    m_pRequest = pRequest;
    m_pRequest->AddRef();

    hr = m_shProperties.Init(17, TRUE);

    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::HrAdoptHref
// --------------------------------------------------------------------------------
HRESULT CPropFindResponse::HrAdoptHref(LPCSTR pszHref)
{
    if (NULL == pszHref)
        return E_INVALIDARG;

    IxpAssert(!m_pszHref);
    m_pszHref = pszHref;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::HrAdoptProperty
// --------------------------------------------------------------------------------
HRESULT CPropFindResponse::HrAdoptProperty(LPCSTR pszKey, LPCSTR pszValue)
{
    if (!pszKey || !pszValue)
        return E_INVALIDARG;

    return m_shProperties.Insert(const_cast<char *>(pszKey), const_cast<char *>(pszValue), NOFLAGS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\sicily.cpp ===
//--------------------------------------------------------------------------
// Sicily.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "imnxport.h"
#include "sicily.h"
#include "dllmain.h"
#include "resource.h"
#include "imnxport.h"
#include "strconst.h"
#include <shlwapi.h>
#include "demand.h"

//--------------------------------------------------------------------------
// NTLMSSP_SIGNATURE
//--------------------------------------------------------------------------
#define NTLMSSP_SIGNATURE "NTLMSSP"

//--------------------------------------------------------------------------
// NegotiateFlags
//--------------------------------------------------------------------------
#define NTLMSSP_NEGOTIATE_UNICODE       0x0001  // Text strings are in unicode

//--------------------------------------------------------------------------
// Security Buffer Counts
//--------------------------------------------------------------------------
#define SEC_BUFFER_NUM_NORMAL_BUFFERS       1

//--------------------------------------------------------------------------
// Security Buffer Indexes
//--------------------------------------------------------------------------
#define SEC_BUFFER_CHALLENGE_INDEX          0
#define SEC_BUFFER_USERNAME_INDEX           1
#define SEC_BUFFER_PASSWORD_INDEX           2
#define SEC_BUFFER_NUM_EXTENDED_BUFFERS     3

//--------------------------------------------------------------------------
// NTLM_MESSAGE_TYPE
//--------------------------------------------------------------------------
typedef enum {
    NtLmNegotiate = 1,
    NtLmChallenge,
    NtLmAuthenticate,
    NtLmUnknown
} NTLM_MESSAGE_TYPE;

//--------------------------------------------------------------------------
// STRING
//--------------------------------------------------------------------------
typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWCHAR Buffer;
} STRING, *PSTRING;

//--------------------------------------------------------------------------
// AUTHENTICATE_MESSAGE
//--------------------------------------------------------------------------
typedef struct _AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING LmChallengeResponse;
    STRING NtChallengeResponse;
    STRING DomainName;
    STRING UserName;
    STRING Workstation;
    STRING SessionKey;
    ULONG NegotiateFlags;
} AUTHENTICATE_MESSAGE, *PAUTHENTICATE_MESSAGE;

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define CCHMAX_NTLM_DOMAIN      255
#define LOGON_OK		        10000

//--------------------------------------------------------------------------
// String Constants
//--------------------------------------------------------------------------
static const CHAR c_szSecurityDLL[] = "security.dll";
static const CHAR c_szSecur32DLL[]  = "secur32.dll";

//--------------------------------------------------------------------------
// MSN/DPA CleareCredentialsCache Function Prototype
//--------------------------------------------------------------------------
typedef BOOL (WINAPI * PFNCLEANUPCREDENTIALCACHE)(void);

//--------------------------------------------------------------------------
// CREDENTIAL
//--------------------------------------------------------------------------
typedef struct tagCREDENTIAL *LPCREDENTIAL;
typedef struct tagCREDENTIAL {
    CHAR            szServer[CCHMAX_SERVER_NAME];
    CHAR            szUserName[CCHMAX_USERNAME];
    CHAR            szPassword[CCHMAX_PASSWORD];
    CHAR            szDomain[CCHMAX_NTLM_DOMAIN];
    DWORD           cRetry;
    LPCREDENTIAL    pNext;
} CREDENTIAL; 

//--------------------------------------------------------------------------
// SSPIPROMPTINFO
//--------------------------------------------------------------------------
typedef struct tagSSPIPROMPTINFO {
    HRESULT         hrResult;
    LPSSPICONTEXT   pContext;
    ULONG           fContextAttrib;
    PSecBufferDesc  pInDescript;
    PSecBufferDesc  pOutDescript;
    TimeStamp       tsExpireTime;
    PCtxtHandle     phCtxCurrent;
    DWORD           dwFlags;
} SSPIPROMPTINFO, *LPSSPIPROMPTINFO;

//--------------------------------------------------------------------------
// SSPILOGON
//--------------------------------------------------------------------------
typedef struct tagSSPILOGON {
    LPCREDENTIAL    pCredential;
    LPSSPICONTEXT   pContext;
} SSPILOGON, *LPSSPILOGON;

//--------------------------------------------------------------------------
// SSPILOGONFLAGS
//--------------------------------------------------------------------------
typedef DWORD SSPILOGONFLAGS;
#define SSPI_LOGON_RETRY            0x00000001
#define SSPI_LOGON_FLUSH            0x00000002

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
static PSecurityFunctionTable	    g_pFunctions = NULL;
static HINSTANCE                    g_hInstSSPI = NULL;
static LPCREDENTIAL                 g_pCredentialHead=NULL;
static LPSSPIPACKAGE                g_prgPackage=NULL;
static DWORD                        g_cPackages=0;

//--------------------------------------------------------------------------
// base642six
//--------------------------------------------------------------------------
static const int base642six[256] = {
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//--------------------------------------------------------------------------
// six2base64
//--------------------------------------------------------------------------
static const char six2base64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

//--------------------------------------------------------------------------
// uu2six
//--------------------------------------------------------------------------
const int uu2six[256] = {
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};
     
//--------------------------------------------------------------------------
// six2uu
//--------------------------------------------------------------------------
static const char six2uu[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT SSPIFlushMSNCredentialCache(void);

//--------------------------------------------------------------------------
// SSPISetBuffer
//--------------------------------------------------------------------------
HRESULT SSPISetBuffer(LPCSTR pszString, SSPIBUFFERTYPE tyBuffer, 
    DWORD cbBuffer, LPSSPIBUFFER pBuffer) 
{
    // Trace
    TraceCall("SSPISetBuffer");

    // No Length Passed In ?
    if (SSPI_STRING == tyBuffer)
    {
        // Get the Length
        pBuffer->cbBuffer = lstrlen(pszString) + 1;

        // Too Long
        if (pBuffer->cbBuffer > CBMAX_SSPI_BUFFER)
            pBuffer->cbBuffer = CBMAX_SSPI_BUFFER;

        // Copy the data
        CopyMemory(pBuffer->szBuffer, pszString, pBuffer->cbBuffer);

        // Stuff a Null
        pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';

        // Loop
        while (pBuffer->cbBuffer >= 2)
        {
            // Not a CRLF
            if ('\r' != pBuffer->szBuffer[pBuffer->cbBuffer - 2] && '\n' != pBuffer->szBuffer[pBuffer->cbBuffer - 2])
                break;

            // Decrement Length
            pBuffer->cbBuffer--;

            // Null Terminate
            pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';
        }
    }

    // Otherwise, set cbBuffer
    else
    {
        // Set cbBuffer
        pBuffer->cbBuffer = min(cbBuffer + 1, CBMAX_SSPI_BUFFER);

        // Null Terminate
        pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';

        // Copy the data
        CopyMemory(pBuffer->szBuffer, pszString, pBuffer->cbBuffer);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// GetCredentialDlgProc
//--------------------------------------------------------------------------
BOOL CALLBACK GetCredentialDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPSSPILOGON     pLogon=(LPSSPILOGON)GetWndThisPtr(hwnd);
    CHAR            szRes[CCHMAX_RES];
    CHAR            szTitle[CCHMAX_RES + CCHMAX_SERVER_NAME];

    // Trace
    TraceCall("GetCredentialDlgProc");
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the pointer
        pLogon = (LPSSPILOGON)lParam;
        Assert(pLogon);

        // Set pContext hwndLogon
        pLogon->pContext->hwndLogon = hwnd;

        // Set myself to the foreground
        SetForegroundWindow(hwnd);

        // Center remember location
        CenterDialog(hwnd);

	    // Limit Text
        Edit_LimitText(GetDlgItem(hwnd, IDE_USERNAME), CCHMAX_USERNAME - 1);
        Edit_LimitText(GetDlgItem(hwnd, IDE_PASSWORD), CCHMAX_PASSWORD - 1);
        Edit_LimitText(GetDlgItem(hwnd, IDE_DOMAIN), CCHMAX_NTLM_DOMAIN - 1);

        // Set Window Title
        GetWindowText(hwnd, szRes, ARRAYSIZE(szRes));
        wsprintf(szTitle, "%s - %s", szRes, pLogon->pCredential->szServer);
        SetWindowText(hwnd, szTitle);

        // Set User Name
        Edit_SetText(GetDlgItem(hwnd, IDE_USERNAME), pLogon->pCredential->szUserName);
        Edit_SetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pCredential->szPassword);
        Edit_SetText(GetDlgItem(hwnd, IDE_DOMAIN), pLogon->pCredential->szDomain);

        // Focus
        if (pLogon->pCredential->szUserName[0] == '\0')
            SetFocus(GetDlgItem(hwnd, IDE_USERNAME));
        else 
            SetFocus(GetDlgItem(hwnd, IDE_PASSWORD));

        // Save the pointer
        SetWndThisPtr(hwnd, pLogon);

        // Done
        return(FALSE);

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            if (pLogon)
                pLogon->pContext->hwndLogon = NULL;
            EndDialog(hwnd, IDCANCEL);
            return(TRUE);

        case IDOK:
            Assert(pLogon);
            if (pLogon)
            {
                Edit_GetText(GetDlgItem(hwnd, IDE_USERNAME), pLogon->pCredential->szUserName, CCHMAX_USERNAME);
                Edit_GetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pCredential->szPassword, CCHMAX_PASSWORD);
                Edit_GetText(GetDlgItem(hwnd, IDE_DOMAIN),   pLogon->pCredential->szDomain,   CCHMAX_NTLM_DOMAIN);
                pLogon->pContext->hwndLogon = NULL;
            }
            EndDialog(hwnd, LOGON_OK);
            return(TRUE);
        }
        break;

    case WM_DESTROY:
        // This is here because when OE shuts down and this dialog is displayed, a WM_QUIT is posted to the thread
        // that this dialog lives on. WM_QUIT causes a WM_DESTROY dialog to get sent to this dialog, but the parent
        // doesn't seem to get re-enabled
        EnableWindow(GetParent(hwnd), TRUE);

        // Null out the this pointer
        SetWndThisPtr(hwnd, NULL);

        // Set pContext hwndLogon
        if (pLogon)
            pLogon->pContext->hwndLogon = NULL;

        // Done
        return(FALSE);
    }

    // Done
    return(FALSE);
}

//--------------------------------------------------------------------------
// SSPIFillAuth
//--------------------------------------------------------------------------
HRESULT SSPIFillAuth(LPCSTR pszUserName, LPCSTR pszPassword, LPCSTR pszDomain,
    SEC_WINNT_AUTH_IDENTITY *pAuth)
{
    // Set Flags
    pAuth->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // Fill It
    pAuth->User = (unsigned char *)(pszUserName ? pszUserName : c_szEmpty);
    pAuth->UserLength = lstrlen((LPSTR)pAuth->User);
    pAuth->Domain = (unsigned char *)(pszDomain ? pszDomain : c_szEmpty);
    pAuth->DomainLength = lstrlen((LPSTR)pAuth->Domain);
    pAuth->Password = (unsigned char *)(pszPassword ? pszPassword : c_szEmpty);
    pAuth->PasswordLength = lstrlen((LPSTR)pAuth->Password);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIAuthFromCredential
//--------------------------------------------------------------------------
HRESULT SSPIAuthFromCredential(LPCREDENTIAL pCredential, SEC_WINNT_AUTH_IDENTITY *pAuth)
{
    // Fill It
    SSPIFillAuth(pCredential->szUserName, pCredential->szPassword, pCredential->szDomain, pAuth);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIFindCredential
//--------------------------------------------------------------------------
HRESULT SSPIFindCredential(LPSSPICONTEXT pContext, ITransportCallback *pCallback)
{
    // Locals
    HRESULT                     hr=S_OK;
    LPCREDENTIAL                pCurrent;
    LPCREDENTIAL                pPrevious=NULL;
    LPCREDENTIAL                pNew=NULL;
    SSPILOGON                   Logon;
    HWND                        hwndParent=NULL;
    ITransportCallbackService  *pService=NULL;

    // Trace
    TraceCall("SSPIFindCredential");

    // Invalid Arg
    Assert(pContext->pszServer && pCallback);

    // No Callback
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Search the list for cached credentials...
    for (pCurrent=g_pCredentialHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Is this It ?
        if (lstrcmpi(pContext->pszServer, pCurrent->szServer) == 0)
            break;

        // Save Previous
        pPrevious = pCurrent;
    }

    // If we found one and there are no retries...
    if (pCurrent)
    {
        // If no retries, then use this
        if (0 == pCurrent->cRetry)
        {
            // Reset pContext ?
            SafeMemFree(pContext->pszUserName);
            SafeMemFree(pContext->pszPassword);
            SafeMemFree(pContext->pszDomain);

            // Duplicate the good stuff
            IF_NULLEXIT(pContext->pszUserName = PszDupA((LPSTR)pCurrent->szUserName));
            IF_NULLEXIT(pContext->pszDomain = PszDupA((LPSTR)pCurrent->szDomain));
            IF_NULLEXIT(pContext->pszPassword = PszDupA((LPSTR)pCurrent->szPassword));

            // Increment retry count
            pCurrent->cRetry++;

            // Thread Safety
            LeaveCriticalSection(&g_csDllMain);

            // Done
            goto exit;
        }

        // Unlink pCurrent from the list
        if (pPrevious)
        {
            Assert(pPrevious->pNext == pCurrent);
            pPrevious->pNext = pCurrent->pNext;
        }
        else
        {
            Assert(g_pCredentialHead == pCurrent);
            g_pCredentialHead = pCurrent->pNext;
        }
    }

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Didn't find anything...allocate one
    if (NULL == pCurrent)
    {
        // Allocate
        IF_NULLEXIT(pNew = (LPCREDENTIAL)g_pMalloc->Alloc(sizeof(CREDENTIAL)));

        // Zero
        ZeroMemory(pNew, sizeof(CREDENTIAL));

        // Set pCurrent
        pCurrent = pNew;

        // Store the Server Name
        lstrcpyn(pCurrent->szServer, pContext->pszServer, ARRAYSIZE(pCurrent->szServer));
    }

    // No pNext
    pCurrent->pNext = NULL;

    // QI pTransport for ITransportCallbackService
    hr = pCallback->QueryInterface(IID_ITransportCallbackService, (LPVOID *)&pService);
    if (FAILED(hr))
    {
        // Raid-69382 (2/5/99): CDO: loop in ISMTPTransport/INNTPTransport when Sicily authentication fails
        // Clients who don't support this interface, I will treat them as a cancel.
        pContext->fPromptCancel = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // Get a Window Handle
    hr = pService->GetParentWindow(0, &hwndParent);
    if (FAILED(hr))
    {
        // Raid-69382 (2/5/99): CDO: loop in ISMTPTransport/INNTPTransport when Sicily authentication fails
        // Clients who don't support this interface, I will treat them as a cancel.
        pContext->fPromptCancel = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // No Parent...
    if (NULL == hwndParent || FALSE == IsWindow(hwndParent))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Bring to the foreground
	ShowWindow(hwndParent, SW_SHOW);
    SetForegroundWindow(hwndParent);

	// Clear the password
	*pCurrent->szPassword = '\0';

    // Initialize Current...
    if (pContext->pszUserName)
        lstrcpyn(pCurrent->szUserName, pContext->pszUserName, ARRAYSIZE(pCurrent->szUserName));
    if (pContext->pszDomain)
        lstrcpyn(pCurrent->szDomain, pContext->pszDomain, ARRAYSIZE(pCurrent->szDomain));

    // Set Logon
    Logon.pCredential = pCurrent;
    Logon.pContext = pContext;

    // Do the Dialog Box
    if (LOGON_OK != DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(IDD_NTLMPROMPT), hwndParent, (DLGPROC)GetCredentialDlgProc, (LPARAM)&Logon))
    {
        pContext->fPromptCancel = TRUE;
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Not cancel
    pContext->fPromptCancel = FALSE;

    // Reset pContext ?
    SafeMemFree(pContext->pszUserName);
    SafeMemFree(pContext->pszPassword);
    SafeMemFree(pContext->pszDomain);

    // Duplicate the good stuff
    IF_NULLEXIT(pContext->pszUserName = PszDupA((LPSTR)pCurrent->szUserName));
    IF_NULLEXIT(pContext->pszDomain = PszDupA((LPSTR)pCurrent->szDomain));
    IF_NULLEXIT(pContext->pszPassword = PszDupA((LPSTR)pCurrent->szPassword));

    // Set Next
    pCurrent->pNext = g_pCredentialHead;

    // Reset Head
    g_pCredentialHead = pCurrent;

    // Set Retry Count
    pCurrent->cRetry++;

    // Don't Free It
    pNew = NULL;

exit:
    // Cleanup
    SafeMemFree(pNew);
    SafeRelease(pService);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIFreeCredentialList
//--------------------------------------------------------------------------
HRESULT SSPIFreeCredentialList(void)
{
    // Locals
    LPCREDENTIAL pCurrent;
    LPCREDENTIAL pNext;

    // Trace
    TraceCall("SSPIFreeCredentialList");

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Set pCurrent
    pCurrent = g_pCredentialHead;

    // While we have a node
    while (pCurrent)
    {
        // Save pNext
        pNext = pCurrent->pNext;

        // Free pCurrent
        g_pMalloc->Free(pCurrent);

        // Goto Next
        pCurrent = pNext;
    }

    // Clear the header
    g_pCredentialHead = NULL;

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIUninitialize
//--------------------------------------------------------------------------
HRESULT SSPIUninitialize(void)
{
    // Trace
    TraceCall("SSPIUninitialize");

    // If we have loaded the dll...
    if (g_hInstSSPI)
    {
        // Free the Lib
        FreeLibrary(g_hInstSSPI);
    }

    // Free Credential List
    SSPIFreeCredentialList();

    // Free Packages
    if (g_prgPackage)
    {
        // Loop through Packages
        for (DWORD i = 0; i < g_cPackages; i++)
        {
            // Free pszName
            SafeMemFree(g_prgPackage[i].pszName);

            // Free pszComment
            SafeMemFree(g_prgPackage[i].pszComment);
        }

        // Free packages
        SafeMemFree(g_prgPackage);

        // No Packages
        g_cPackages = 0;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIIsInstalled
//--------------------------------------------------------------------------
HRESULT SSPIIsInstalled(void)
{
    // Locals
    HRESULT                     hr=S_FALSE;
    INIT_SECURITY_INTERFACE	    addrProcISI = NULL;

    // Trace
    TraceCall("SSPIIsInstalled");

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Already Loaded ?
    if (g_hInstSSPI)
    {
        hr = S_OK;
        goto exit;
    }

    // Load Security DLL
    if (S_OK == IsPlatformWinNT())
        g_hInstSSPI = LoadLibrary(c_szSecurityDLL);
    else
        g_hInstSSPI = LoadLibrary(c_szSecur32DLL);

    // Could not be loaded
    if (NULL == g_hInstSSPI)
    {
        TraceInfo("SSPI: LoadLibrary failed.");
        goto exit;
    }

    // Load the function table
    addrProcISI = (INIT_SECURITY_INTERFACE)GetProcAddress(g_hInstSSPI, SECURITY_ENTRYPOINT);       
    if (NULL == addrProcISI)
    {
        TraceInfo("SSPI: GetProcAddress failed failed.");
        goto exit;
    }

    // Get the SSPI function table
    g_pFunctions = (*addrProcISI)();

    // If the didn't work
    if (NULL == g_pFunctions)
    {
        // Free the library
        FreeLibrary(g_hInstSSPI);

        // Null the handle
        g_hInstSSPI = NULL;

        // Failed to get the function table
        TraceInfo("SSPI: Load Function Table failed.");

        // Done
        goto exit;
    }

    // Woo-hoo
    hr = S_OK;

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIGetPackages
//--------------------------------------------------------------------------
HRESULT SSPIGetPackages(LPSSPIPACKAGE *pprgPackage, LPDWORD pcPackages)
{
    // Locals
    SECURITY_STATUS hr=SEC_E_OK;
    PSecPkgInfo     prgPackage=NULL;
    ULONG           i;

    // Trace
    TraceCall("SSPIGetPackages");

    // Check Params
    if (NULL == pprgPackage || NULL == pcPackages)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // Init
    *pprgPackage = NULL;
    *pcPackages = 0;

    // Already have packages ?
    EnterCriticalSection(&g_csDllMain);

    // Do I already have the packages ?
    if (NULL == g_prgPackage)
    {
        // Enumerate security packages
        IF_FAILEXIT(hr = (*(g_pFunctions->EnumerateSecurityPackages))(&g_cPackages, &prgPackage));

        // RAID - 29645 - EnumerateSecurityPackages seems to return cSec = Rand and pSec == NULL, so, I need to return at this point if cSec == 0 or pSec == NULL
        if (0 == g_cPackages || NULL == prgPackage)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Allocate pprgPackage
        IF_NULLEXIT(g_prgPackage = (LPSSPIPACKAGE)ZeroAllocate(g_cPackages * sizeof(SSPIPACKAGE)));

        // Copy data into ppPackages
        for (i = 0; i < g_cPackages; i++)
        {
            g_prgPackage[i].ulCapabilities = prgPackage[i].fCapabilities;
            g_prgPackage[i].wVersion = prgPackage[i].wVersion;
            g_prgPackage[i].cbMaxToken = prgPackage[i].cbMaxToken;
            g_prgPackage[i].pszName = PszDupA(prgPackage[i].Name);
            g_prgPackage[i].pszComment = PszDupA(prgPackage[i].Comment);
        }
    }

    // Return Global
    *pprgPackage = g_prgPackage;
    *pcPackages = g_cPackages;

exit:
    // Already have packages ?
    LeaveCriticalSection(&g_csDllMain);

    // Free the package
    if (prgPackage)
    {
        // Free the Array
        (*(g_pFunctions->FreeContextBuffer))(prgPackage);
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPILogon
//--------------------------------------------------------------------------
HRESULT SSPILogon(LPSSPICONTEXT pContext, BOOL fRetry, BOOL fBase64, 
    LPCSTR pszPackage, LPINETSERVER pServer, ITransportCallback *pCallback)
{
    // Locals
    SECURITY_STATUS           hr = SEC_E_OK;
    TimeStamp                 tsLifeTime;
    SEC_WINNT_AUTH_IDENTITY  *pAuth = NULL;
    SEC_WINNT_AUTH_IDENTITY   Auth={0};

    // Trace
    TraceCall("SSPILogon");

    // Validate
    Assert(pCallback);

    // Invalid Args
    if (NULL == pContext || NULL == pszPackage || NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // Already have credential
    if (pContext->fCredential && SSPI_STATE_USE_CACHED == pContext->tyState)
        goto exit;

    // Installed ?
    if (S_FALSE == SSPIIsInstalled())
    {
        hr = TraceResult(IXP_E_LOAD_SICILY_FAILED);
        goto exit;
    }

    // Reset fPropmtCancel
    pContext->fPromptCancel = FALSE;

    // No retry
    if (NULL == pContext->pCallback)
    {
        // Locals
        ITransportCallbackService *pService;

        // Validate
        Assert(!pContext->pszPackage && !pContext->pszServer && !pContext->pCallback && !pContext->pszUserName && !pContext->pszPassword);

        // Save fBase64
        pContext->fBase64 = fBase64;

        // Copy Some Strings
        IF_NULLEXIT(pContext->pszPackage = PszDupA(pszPackage));
        IF_NULLEXIT(pContext->pszServer = PszDupA(pServer->szServerName));
        IF_NULLEXIT(pContext->pszUserName = PszDupA(pServer->szUserName));

        // Empty Password
        if (FALSE == FIsEmptyA(pServer->szPassword))
        {
            // Copy It
            IF_NULLEXIT(pContext->pszPassword = PszDupA(pServer->szPassword));
        }

        // Assume Callback
        pContext->pCallback = pCallback;
        pContext->pCallback->AddRef();

        // Supports Callback Service
        if (SUCCEEDED(pContext->pCallback->QueryInterface(IID_ITransportCallbackService, (LPVOID *)&pService)))
        {
            // This object supports the Service
            pContext->fService = TRUE;

            // Release
            pService->Release();
        }

        // Otherwise
        else
            pContext->fService = FALSE;
    }

    // Clear current credential
    if (pContext->fCredential)
    {
        // Free Credential Handle
        (*(g_pFunctions->FreeCredentialHandle))(&pContext->hCredential);

        // No Credential
        pContext->fCredential = FALSE;
    }

    // Use Cached
    if (SSPI_STATE_USE_CACHED == pContext->tyState)
    {
        // If not a retry...
        if (FALSE == fRetry)
        {
            // No Retries
            pContext->cRetries = 0;

            // Thread Safety
            EnterCriticalSection(&g_csDllMain);

            // Search the list for cached credentials...
            for (LPCREDENTIAL pCurrent=g_pCredentialHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
            {
                // Is this It ?
                if (lstrcmpi(pContext->pszServer, pCurrent->szServer) == 0)
                {
                    pCurrent->cRetry = 0;
                    break;
                }
            }

            // Thread Safety
            LeaveCriticalSection(&g_csDllMain);
        }

		// Otherwise, assume we will need to force a prompt...
		else
        {
            // Increment Retry Count
            pContext->cRetries++;

            // Valid Retry States...
            Assert(SSPI_STATE_USE_CACHED == pContext->tyRetryState || SSPI_STATE_PROMPT_USE_PACKAGE == pContext->tyRetryState);

            // The next phase may be to tell the package to prompt...
			pContext->tyState = pContext->tyRetryState;
        }
    }

    // Use Supplied
    else if (SSPI_STATE_USE_SUPPLIED == pContext->tyState)
    {
        // Locals
        CredHandle hCredential;

        // Next State...
        pContext->tyState = SSPI_STATE_USE_CACHED;

        // Fill It
        SSPIFillAuth(NULL, NULL, NULL, &Auth);

        // Do some security stuff
        if (SUCCEEDED((*(g_pFunctions->AcquireCredentialsHandle))(NULL, (LPSTR)pContext->pszPackage, SECPKG_CRED_OUTBOUND, NULL, &Auth, NULL, NULL, &hCredential, &tsLifeTime)))
        {
            // Free the Handle
            (*(g_pFunctions->FreeCredentialHandle))(&hCredential);
        }

        // Use Supplied Credentials...
        SSPIFillAuth(pContext->pszUserName, pContext->pszPassword, pContext->pszDomain, &Auth);

        // Set pAuth
        pAuth = &Auth;
    }

    // Otherwise, try to get cached credentials
    else if (SSPI_STATE_PROMPT_USE_OWN == pContext->tyState)
    {
        // Next State...
        pContext->tyState = SSPI_STATE_USE_CACHED;

        // Failure
        IF_FAILEXIT(hr = SSPIFindCredential(pContext, pCallback));

        // Fill and return credentials
        SSPIFillAuth(pContext->pszUserName, pContext->pszPassword, pContext->pszDomain, &Auth);

        // Set Auth Information
        pAuth = &Auth;
    }

    // Do some security stuff
    IF_FAILEXIT(hr = (*(g_pFunctions->AcquireCredentialsHandle))(NULL, (LPSTR)pContext->pszPackage, SECPKG_CRED_OUTBOUND, NULL, pAuth, NULL, NULL, &pContext->hCredential, &tsLifeTime));

    // We have a credential
    pContext->fCredential = TRUE;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIGetNegotiate
//--------------------------------------------------------------------------
HRESULT SSPIGetNegotiate(LPSSPICONTEXT pContext, LPSSPIBUFFER pNegotiate)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("SSPIGetNegotiate");

    // Invalid Args
    if (NULL == pContext || NULL == pNegotiate)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // If the context is currently initialized
    if (pContext->fContext)
    {
        // Delete this context
        (*(g_pFunctions->DeleteSecurityContext))(&pContext->hContext);

        // No Context
        pContext->fContext = FALSE;
    }

    // Reset this state.
    pContext->fUsedSuppliedCreds = FALSE;

    // Build Negotiation String
    IF_FAILEXIT(hr = SSPIMakeOutboundMessage(pContext, 0, pNegotiate, NULL));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIResponseFromChallenge
//--------------------------------------------------------------------------
HRESULT SSPIResponseFromChallenge(LPSSPICONTEXT pContext, LPSSPIBUFFER pChallenge, 
    LPSSPIBUFFER pResponse)
{
    // Locals
    HRESULT          hr=S_OK;
    DWORD            nBytesReceived;
    DWORD            dwFlags=0;
    SecBufferDesc    Descript;
    SecBuffer        Buffer[SEC_BUFFER_NUM_EXTENDED_BUFFERS];

    // Trace
    TraceCall("SSPIResponseFromChallenge");

    // Invalid Args
    if (NULL == pContext || NULL == pChallenge || NULL == pResponse)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // More Unexpected Stuff
    if (FALSE == pContext->fContext || FALSE == pContext->fCredential)
        return TraceResult(E_UNEXPECTED);

	// Decode the Challenge Buffer
    IF_FAILEXIT(hr == SSPIDecodeBuffer(pContext->fBase64, pChallenge));

    // Fill SecBufferDesc
    Descript.ulVersion = 0;
    Descript.pBuffers = Buffer;
    Descript.cBuffers = 1;

    // Setup the challenge input buffer always (0th buffer)
    Buffer[SEC_BUFFER_CHALLENGE_INDEX].pvBuffer = pChallenge->szBuffer;
    Buffer[SEC_BUFFER_CHALLENGE_INDEX].cbBuffer = pChallenge->cbBuffer - 1;
    Buffer[SEC_BUFFER_CHALLENGE_INDEX].BufferType = SECBUFFER_TOKEN;

    // If Digest
    if (FALSE == pContext->fUsedSuppliedCreds && lstrcmpi(pContext->pszPackage, "digest") == 0)
    {
        // If we have a user, setup the user buffer (1st buffer)
        Buffer[SEC_BUFFER_USERNAME_INDEX].pvBuffer = pContext->pszUserName ? pContext->pszUserName : NULL;
        Buffer[SEC_BUFFER_USERNAME_INDEX].cbBuffer = pContext->pszUserName ? lstrlen(pContext->pszUserName) : NULL;
        Buffer[SEC_BUFFER_USERNAME_INDEX].BufferType = SECBUFFER_TOKEN;
    
        // If we have a password, setup the password buffer (2nd buffer for
        // a total of 3 buffers passed in (challenge + user + pass)
        Buffer[SEC_BUFFER_PASSWORD_INDEX].pvBuffer = pContext->pszPassword ? pContext->pszPassword : NULL;
        Buffer[SEC_BUFFER_PASSWORD_INDEX].cbBuffer = pContext->pszPassword ? lstrlen(pContext->pszPassword) : NULL;
        Buffer[SEC_BUFFER_PASSWORD_INDEX].BufferType = SECBUFFER_TOKEN;

        // If either or both user and pass passed in, set num input buffers to 3 // (SEC_BUFFER_NUM_EXTENDED_BUFFERS)
        if (pContext->pszUserName || pContext->pszPassword)
            Descript.cBuffers = SEC_BUFFER_NUM_EXTENDED_BUFFERS;

        // else we're just passing in the one challenge buffer (0th buffer as usual)
        else
            Descript.cBuffers = SEC_BUFFER_NUM_NORMAL_BUFFERS;

        // We are supplying creds
        pContext->fUsedSuppliedCreds = TRUE;

        // Set dwFlags
        dwFlags = ISC_REQ_USE_SUPPLIED_CREDS;
    }

    // Prepare for OutMsg
    IF_FAILEXIT(hr = SSPIMakeOutboundMessage(pContext, dwFlags, pResponse, &Descript));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIReleaseContext
//--------------------------------------------------------------------------
HRESULT SSPIReleaseContext(LPSSPICONTEXT pContext)
{
    // Was Context Initialized
    if (pContext->fContext)
    {
        // Delete the Security Context
        (*(g_pFunctions->DeleteSecurityContext))(&pContext->hContext);

        // No context
        pContext->fContext = FALSE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIFreeContext
//--------------------------------------------------------------------------
HRESULT SSPIFreeContext(LPSSPICONTEXT pContext)
{
    // Locals
    SSPICONTEXTSTATE tyState;
    SSPICONTEXTSTATE tyRetryState;
    DWORD            cRetries;

    // Trace
    TraceCall("SSPIFreeContext");

    // Is the context initialized
    if (pContext->fContext)
    {
        // Delete It
        (*(g_pFunctions->DeleteSecurityContext))(&pContext->hContext);

        // No Context
        pContext->fContext = FALSE;
    }

    // Credential Handle Initialized
    if (pContext->fCredential)
    {
        // Free Credential Handle
        (*(g_pFunctions->FreeCredentialHandle))(&pContext->hCredential);

        // No Context
        pContext->fCredential = FALSE;
    }

    // Free Package, Server and Callback
    SafeMemFree(pContext->pszPackage);
    SafeMemFree(pContext->pszUserName);
    SafeMemFree(pContext->pszPassword);
    SafeMemFree(pContext->pszServer);
    SafeRelease(pContext->pCallback);

    // Close hMutexUI
    if (pContext->hwndLogon)
    {
        // Nuke the Window
        DestroyWindow(pContext->hwndLogon);

        // Null
        pContext->hwndLogon = NULL;
    }

    // Save It
    tyState = (SSPICONTEXTSTATE)pContext->tyState;
    tyRetryState = (SSPICONTEXTSTATE)pContext->tyRetryState;
    cRetries = pContext->cRetries;

    // Zero It Out
    ZeroMemory(pContext, sizeof(SSPICONTEXT));

    // Do Prompt
    pContext->tyState = tyState;
    pContext->tyRetryState = tyRetryState;
    pContext->cRetries = cRetries;

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// SSPIPromptThreadEntry
// --------------------------------------------------------------------------------
DWORD SSPIPromptThreadEntry(LPDWORD pdwParam) 
{  
    // Locals
    HRESULT          hr=S_OK;
    LPSSPIPROMPTINFO pPrompt=(LPSSPIPROMPTINFO)pdwParam;

    // Trace
    TraceCall("SSPIPromptThreadEntry");

    // Validate
    Assert(pPrompt && pPrompt->pContext);

    // Fixup pInDescript
    if (pPrompt->pInDescript && pPrompt->pInDescript->cBuffers >= 3 && lstrcmpi(pPrompt->pContext->pszPackage, "digest") == 0)
    {
        // Raid-66013: Make sure the password is empty or digest will crash
        pPrompt->pInDescript->pBuffers[SEC_BUFFER_PASSWORD_INDEX].pvBuffer = NULL;
        pPrompt->pInDescript->pBuffers[SEC_BUFFER_PASSWORD_INDEX].cbBuffer = 0;
        //pPrompt->pInDescript->cBuffers = 2;
    }

    // Try to get the package to prompt for credentials...
    pPrompt->hrResult = (*(g_pFunctions->InitializeSecurityContext))(
        &pPrompt->pContext->hCredential, 
        pPrompt->phCtxCurrent, 
        pPrompt->pContext->pszServer, 
        pPrompt->dwFlags | ISC_REQ_PROMPT_FOR_CREDS, 
        0, 
        SECURITY_NATIVE_DREP, 
        pPrompt->pInDescript, 
        0, 
        &pPrompt->pContext->hContext, 
        pPrompt->pOutDescript, 
        &pPrompt->fContextAttrib, 
        &pPrompt->tsExpireTime);

    // Trace
    TraceResultSz(pPrompt->hrResult, "SSPIPromptThreadEntry");

    // Done
    return(0);
}

//--------------------------------------------------------------------------
// SSPISetAccountUserName
//--------------------------------------------------------------------------
HRESULT SSPISetAccountUserName(LPCSTR pszName, LPSSPICONTEXT pContext)
{
    // Locals
    HRESULT                     hr=S_OK;
    DWORD                       dwServerType;
    IImnAccount                *pAccount=NULL;
    ITransportCallbackService  *pService=NULL;

    // Trace
    TraceCall("SSPISetAccountUserName");

    // Validate Args
    Assert(pszName);
    Assert(pContext);
    Assert(pContext->pCallback);

    // Get ITransportCallbackService
    IF_FAILEXIT(hr = pContext->pCallback->QueryInterface(IID_ITransportCallbackService, (LPVOID *)&pService));

    // Get the Account
    IF_FAILEXIT(hr = pService->GetAccount(&dwServerType, &pAccount));

    // SRV_POP3
    if (ISFLAGSET(dwServerType, SRV_POP3))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_POP3_USERNAME, (LPSTR)pszName));
    }

    // SRV_SMTP
    else if (ISFLAGSET(dwServerType, SRV_SMTP))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_SMTP_USERNAME, (LPSTR)pszName));
    }

    // SRV_IMAP
    else if (ISFLAGSET(dwServerType, SRV_IMAP))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_IMAP_USERNAME, (LPSTR)pszName));
    }

    // SRV_NNTP
    else if (ISFLAGSET(dwServerType, SRV_NNTP))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_NNTP_USERNAME, (LPSTR)pszName));
    }

    // Save Changes
    pAccount->SaveChanges();

exit:
    // Cleanup
    SafeRelease(pService);
    SafeRelease(pAccount);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIMakeOutboundMessage
//--------------------------------------------------------------------------
HRESULT SSPIMakeOutboundMessage(LPSSPICONTEXT pContext, DWORD dwFlags, 
    LPSSPIBUFFER pBuffer, PSecBufferDesc pInDescript)
{
    // Locals
    SECURITY_STATUS         hr=S_OK;
    SSPIPROMPTINFO          Prompt={0};
    SecBuffer               OutBuffer;
    SecBufferDesc           OutDescript;
    ULONG                   fContextAttrib;
    TimeStamp               tsExpireTime;
    HANDLE                  hPromptThread;
    DWORD                   dwThreadId;
    DWORD                   dwWait;
    MSG                     msg;
    PCtxtHandle             phCtxCurrent=NULL;
    PAUTHENTICATE_MESSAGE   pAuthMsg;
    LPSTR                   pszName=NULL;

    // Invalid Args
    if (NULL == pContext || NULL == pBuffer)
        return TraceResult(E_INVALIDARG);

    // Bad Context
    if (NULL == pContext->pszPackage)
        return TraceResult(E_INVALIDARG);

    // Bad Context
    if (NULL == pContext->pszServer)
        return TraceResult(E_INVALIDARG);

    // Bad Context
    if (NULL == pContext->pCallback)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // Bad State
    if (FALSE == pContext->fCredential)
        return TraceResult(E_UNEXPECTED);

    // Validate
    Assert(pInDescript == NULL ? FALSE == pContext->fContext : TRUE);

    // Initialize Out Descriptor
    OutDescript.ulVersion = 0;
    OutDescript.cBuffers = 1;
    OutDescript.pBuffers = &OutBuffer;

    // Initialize Output Buffer
    OutBuffer.cbBuffer = CBMAX_SSPI_BUFFER - 1;
    OutBuffer.BufferType = SECBUFFER_TOKEN;
    OutBuffer.pvBuffer = pBuffer->szBuffer;

    // phCtxCurrent
    if (pInDescript)
    {
        // Set Current Context
        phCtxCurrent = &pContext->hContext;
    }

    // First Retry ?
    if (SSPI_STATE_PROMPT_USE_PACKAGE == pContext->tyState && (0 != lstrcmpi(pContext->pszPackage, "digest") || pInDescript))
    {
        // Force failure to do the prompt
        hr = SEC_E_NO_CREDENTIALS;
    }

    // Otherwise, do the next security context
    else
    {
        // Generate a negotiate/authenticate message to be sent to the server.        
        hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, phCtxCurrent, pContext->pszServer, dwFlags, 0, SECURITY_NATIVE_DREP, pInDescript, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
    }

    // Set Retry State...
    pContext->tyRetryState = SSPI_STATE_PROMPT_USE_PACKAGE;

    // Failure
    if (FAILED(hr))
    {
        // Trace
        TraceResult(hr);

        // No credentials ? lets do it again and get some credentials
        if (SEC_E_NO_CREDENTIALS != hr)
            goto exit;

        // If no retries yet...
        if (TRUE == pContext->fService && 0 == lstrcmpi(pContext->pszPackage, "MSN") && 0 == pContext->cRetries)
        {
            // Don't retry again...
            pContext->tyState = SSPI_STATE_USE_SUPPLIED;

            // Do the logon Now...
            hr = SSPILogon(pContext, FALSE, pContext->fBase64, pContext->pszPackage, NULL, pContext->pCallback);

            // Cancel ?
            Assert(FALSE == pContext->fPromptCancel);

            // Success
            if (SUCCEEDED(hr))
            {
                // Try Again
                hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, NULL, pContext->pszServer, 0, 0, SECURITY_NATIVE_DREP, NULL, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
            }
        }

        // Still Failed ?
        if (FAILED(hr))
        {
            // Fill up the prompt info...
            Assert(dwFlags == 0 || dwFlags == ISC_REQ_USE_SUPPLIED_CREDS);
            Prompt.pContext = pContext;
            Prompt.pInDescript = pInDescript;
            Prompt.pOutDescript = &OutDescript;
            Prompt.phCtxCurrent = phCtxCurrent;
            Prompt.dwFlags = dwFlags;

            // Create the Thread
            IF_NULLEXIT(hPromptThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SSPIPromptThreadEntry, &Prompt, 0, &dwThreadId));

            // Wait for the thread to finish
            WaitForSingleObject(hPromptThread, INFINITE);

            // This is what I tried to do so that the spooler window would paint, but it caused all sorts of voodo
#if 0
            // Wait for the thread to finish
            while (1)
            {
                // Wait
                dwWait = MsgWaitForMultipleObjects(1, &hPromptThread, FALSE, INFINITE, QS_PAINT);

                // Done ?
                if (dwWait != WAIT_OBJECT_0 + 1)
                    break;

                // Pump Messages
                while (PeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_REMOVE))
                {
                    // Translate the Message
                    TranslateMessage(&msg);

                    // Dispatch the Message
                    DispatchMessage(&msg);
                }
            }
#endif

            // Close the Thread
            CloseHandle(hPromptThread);

            // Set hr
            hr = Prompt.hrResult;

            // If that failed
            if (FAILED(hr))
            {
                // Decide when its no longer needed to continue...
                if (SEC_E_NO_CREDENTIALS == hr)
                    goto exit;

                // Only do this if on negotiate phase otherwise NTLM prompt comes up twice
                if (NULL == pInDescript)
                {
                    // Do Prompt
                    pContext->tyState = SSPI_STATE_PROMPT_USE_OWN;

                    // Do the logon Now...
                    hr = SSPILogon(pContext, TRUE, pContext->fBase64, pContext->pszPackage, NULL, pContext->pCallback);

                    // Cancel ?
                    if (pContext->fPromptCancel)
                    {
                        hr = TraceResult(E_FAIL);
                        goto exit;
                    }

                    // Success
                    if (SUCCEEDED(hr))
                    {
                        // Try Again
                        hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, phCtxCurrent, pContext->pszServer, 0, 0, SECURITY_NATIVE_DREP, pInDescript, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
                    }
                }
            }
        }
    }

    // Success
    if (SUCCEEDED(hr))
    {
        // We have a context
        pContext->fContext = TRUE;

        // If MSN or NTLM...
        if (TRUE == pContext->fService && 0 == lstrcmpi(pContext->pszPackage, "MSN"))
        {
            // Look at the buffer...
            pAuthMsg = (PAUTHENTICATE_MESSAGE)pBuffer->szBuffer;

            // Validate Signature
            Assert(0 == StrCmpNI((LPCSTR)pAuthMsg->Signature, NTLMSSP_SIGNATURE, sizeof(NTLMSSP_SIGNATURE)));

            // Right Phase ?
            if (NtLmAuthenticate == pAuthMsg->MessageType)
            {
                // Allocate
                IF_NULLEXIT(pszName = (LPSTR)g_pMalloc->Alloc(pAuthMsg->UserName.Length + sizeof(CHAR)));

                // Copy the name
                CopyMemory(pszName, (LPBYTE)pBuffer->szBuffer + PtrToUlong(pAuthMsg->UserName.Buffer), pAuthMsg->UserName.Length);

                // Stuff a Null....
                pszName[pAuthMsg->UserName.Length] = '\0';

                // If Context UserName is empty, lets store pszName into the account
                if ('\0' == *pContext->pszUserName)
                {
                    // Put pszName as the username for this account
                    if (SUCCEEDED(SSPISetAccountUserName(pszName, pContext)))
                    {
                        // Reset the UserName
                        SafeMemFree(pContext->pszUserName);

                        // Copy the new username 
                        IF_NULLEXIT(pContext->pszUserName = PszDupA(pszName));
                    }
                }

                // Name Change
                if (lstrcmpi(pszName, pContext->pszUserName) != 0)
                {
                    // Don't retry again...
                    pContext->tyState = SSPI_STATE_USE_SUPPLIED;

                    // Set Retry State...
                    pContext->tyRetryState = SSPI_STATE_USE_CACHED;

                    // Do the logon Now...
                    hr = SSPILogon(pContext, FALSE, pContext->fBase64, pContext->pszPackage, NULL, pContext->pCallback);

                    // Cancel ?
                    Assert(FALSE == pContext->fPromptCancel);

                    // Success
                    if (SUCCEEDED(hr))
                    {
                        // Try Again
                        hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, NULL, pContext->pszServer, 0, 0, SECURITY_NATIVE_DREP, NULL, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
                    }

                    // Fail, but continue...
                    if (FAILED(hr))
                    {
                        // We are going to need to prompt...
                        pContext->tyState = SSPI_STATE_PROMPT_USE_PACKAGE;

                        // Trace
                        TraceResult(hr);

                        // Always Succeed, but cause authentication to fail...
                        hr = S_OK;

                        // Reset Length
                        OutBuffer.cbBuffer = 0;
                    }
                }
            }
        }
    }

    // Otherwise...
    else
    {
        // Trace
        TraceResult(hr);

        // Always Succeed, but cause authentication to fail...
        hr = S_OK;

        // Reset Length
        OutBuffer.cbBuffer = 0;
    }

    // Continue required
    pBuffer->fContinue = (SEC_I_CONTINUE_NEEDED == hr) ? TRUE : FALSE;

    // Set cbBuffer
    pBuffer->cbBuffer = OutBuffer.cbBuffer + 1;

    // Null Terminate
    pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';

	// need to encode the blob before send out
    IF_FAILEXIT(hr == SSPIEncodeBuffer(pContext->fBase64, pBuffer));

    // All Good
    hr = S_OK;

exit:
    // Cleanup
    SafeMemFree(pszName);

    // Done
    return(hr);
}

//-------------------------------------------------------------------------------------------
// SSPIEncodeBuffer
//-------------------------------------------------------------------------------------------
HRESULT SSPIEncodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer)
{
    // Locals
    LPBYTE          pbIn=(LPBYTE)pBuffer->szBuffer;
    DWORD           cbIn=pBuffer->cbBuffer - 1;
    BYTE            rgbOut[CBMAX_SSPI_BUFFER - 1];
    LPBYTE          pbOut=rgbOut;
    DWORD           i;

    // Trace
    TraceCall("SSPIEncodeBuffer");

    // Validate
    Assert(pBuffer->szBuffer[pBuffer->cbBuffer - 1] == '\0');

    // Set the lookup table to use to encode
    LPCSTR rgchDict = (fBase64 ? six2base64 : six2uu);

    // Loop
    for (i = 0; i < cbIn; i += 3) 
    {
        // Encode
        *(pbOut++) = rgchDict[*pbIn >> 2];
        *(pbOut++) = rgchDict[((*pbIn << 4) & 060) | ((pbIn[1] >> 4) & 017)];
        *(pbOut++) = rgchDict[((pbIn[1] << 2) & 074) | ((pbIn[2] >> 6) & 03)];
        *(pbOut++) = rgchDict[pbIn[2] & 077];

        // Increment pbIn
        pbIn += 3;
    }

    // If nbytes was not a multiple of 3, then we have encoded too many characters.  Adjust appropriately.
    if (i == cbIn + 1) 
    {
        // There were only 2 bytes in that last group
        pbOut[-1] = '=';
    }

    // There was only 1 byte in that last group
    else if (i == cbIn + 2) 
    {
        pbOut[-1] = '=';
        pbOut[-2] = '=';
    }

    // Null Terminate
    *pbOut = '\0';

    // Copy Back into pBuffer
    SSPISetBuffer((LPCSTR)rgbOut, SSPI_STRING, 0, pBuffer);

    // Done
    return(S_OK);
}

//-------------------------------------------------------------------------------------------
// SSPIDecodeBuffer
//-------------------------------------------------------------------------------------------
HRESULT SSPIDecodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer)
{
    // Locals
    LPSTR           pszStart=pBuffer->szBuffer;
    LPBYTE          pbIn=(LPBYTE)pBuffer->szBuffer;
    DWORD           cbIn=pBuffer->cbBuffer - 1;         
    BYTE            rgbOut[CBMAX_SSPI_BUFFER - 1];
    LPBYTE          pbOut=rgbOut;
    long            cbDecode;
    DWORD           cbOut=0;

    // Trace
    TraceCall("SSPIDecodeBuffer"); 

    // Validate
    Assert(pBuffer->szBuffer[pBuffer->cbBuffer - 1] == '\0');

    // Set the lookup table to use to encode
    const int *rgiDict = (fBase64 ? base642six : uu2six);

    // Strip leading whitespace
    while (*pszStart == ' ' || *pszStart == '\t')
        pszStart++;

    // Set pbIn
    pbIn = (LPBYTE)pszStart;

    // Hmmm, I don't know what this does
    while (rgiDict[*(pbIn++)] <= 63)
        {};

    // Actual Number of bytes to encode
    cbDecode = (long) ((LPBYTE)pbIn - (LPBYTE)pszStart) - 1;

    // Computed length of outbound buffer
    cbOut = ((cbDecode + 3) / 4) * 3;

    // Reset pbIn
    pbIn = (LPBYTE)pszStart;

    // Decode
    while (cbDecode > 0) 
    {
        // Decode
        *(pbOut++) = (unsigned char) (rgiDict[*pbIn] << 2 | rgiDict[pbIn[1]] >> 4);
        *(pbOut++) = (unsigned char) (rgiDict[pbIn[1]] << 4 | rgiDict[pbIn[2]] >> 2);
        *(pbOut++) = (unsigned char) (rgiDict[pbIn[2]] << 6 | rgiDict[pbIn[3]]);

        // Increment pbIn
        pbIn += 4;

        // Decrement cbDecode
        cbDecode -= 4;
    }

    // Special termination case
    if (cbDecode & 03) 
    {
        if (rgiDict[pbIn[-2]] > 63)
            cbOut -= 2;
        else
            cbOut -= 1;
    }

    // Set the Outbuffer
    SSPISetBuffer((LPCSTR)rgbOut, SSPI_BLOB, cbOut, pBuffer);

    // Done
    return(S_OK);
}

//-------------------------------------------------------------------------------------------
// SSPIFlushMSNCredentialCache - This code was given to us by kingra/MSN (see csager)
//-------------------------------------------------------------------------------------------
HRESULT SSPIFlushMSNCredentialCache(void)
{
    // Locals
    HRESULT                     hr=S_OK;
    HKEY                        hKey=NULL;
    DWORD                       dwType;
    CHAR                        szDllName[MAX_PATH];
    CHAR                        szProviders[1024];
    DWORD                       cb=ARRAYSIZE(szProviders);
    HINSTANCE                   hInstDll=NULL;
    PFNCLEANUPCREDENTIALCACHE   pfnCleanupCredentialCache;

    // Open the HKLM Reg Entry
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\SecurityProviders", 0, KEY_READ, &hKey))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Read the Providers
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, "SecurityProviders", NULL, &dwType, (LPBYTE)szProviders, &cb))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Upper Case the Providers
    CharUpper(szProviders);

    // Map to something...
    if (StrStrA(szProviders, "MSAPSSPS.DLL"))
        lstrcpy(szDllName, "MSAPSSPS.DLL");
    else if (StrStrA(szProviders, "MSAPSSPC.DLL"))
        lstrcpy(szDllName, "MSAPSSPC.DLL");
    else
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Load the DLL
    hInstDll = LoadLibrary(szDllName);

    // Failed to Load
    if (NULL == hInstDll)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Get the ProcAddress
    pfnCleanupCredentialCache = (PFNCLEANUPCREDENTIALCACHE)GetProcAddress(hInstDll, "CleanupCredentialCache");

    // Failure ?
    if (NULL == pfnCleanupCredentialCache)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Call the function that clears the cache
    if (!pfnCleanupCredentialCache())
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }
    
exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);
    if (hInstDll)
        FreeLibrary(hInstDll);

    // Done
    return(hr);
}


// The MSN SSPI package seems to give back invalid NegotiateFlags
#if 0
                // Unicode ?
                if (ISFLAGSET(pAuthMsg->NegotiateFlags, NTLMSSP_NEGOTIATE_UNICODE))
                {
                    // Get User Name
                    LPWSTR pwszName;

                    // Allocate
                    IF_NULLEXIT(pwszName = (LPWSTR)g_pMalloc->Alloc(pAuthMsg->UserName.Length + sizeof(WCHAR)));

                    // Copy the name
                    CopyMemory(pwszName, (LPBYTE)pBuffer->szBuffer + (DWORD)pAuthMsg->UserName.Buffer, pAuthMsg->UserName.Length);

                    // Stuff a Null....
                    pwszName[pAuthMsg->UserName.Length / sizeof(WCHAR)] = L'\0';

                    // Convert top ANSI...
                    IF_NULLEXIT(pszName = PszToANSI(CP_ACP, pwszName));

                    // Free pwszName
                    g_pMalloc->Free(pwszName);
                }

                // Otherwise, do it in ansi...
                else
                {
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\range.h ===
//
// RANGE.H
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
// 8-96:    Functions added to facilitate finding of "anti" lists 
//

// -*- C -*-
//--------------------------------------------------------------------------------------
//
// Module:       range.h
//
// Description:  Definition of a class to manipulate range lists
//               (e.g. 1-6,7,10-11,19,24,33-40 ...)
//
// Copyright Microsoft Corporation 1995, All Rights Reserved
//
//--------------------------------------------------------------------------------------

#include "imnxport.h"

#ifndef _RANGE_H
#define _RANGE_H
//
//  Copyright 1992 Software Innovations, Inc
//      All Rights Reserved
//
//  $Source: D:\CLASS\INCLUDE\range.h-v $
//  $Author: martin $
//  $Date: 92/07/15 04:56:38 $
//  $Revision: 1.1 $
//


//  a CRangeList is a dynamic array of these...
typedef struct {
    ULONG low;
    ULONG high;
} RangeType;

class CRangeList : public IRangeList
{
public:
    CRangeList();
    ~CRangeList();

    // IUnknown Methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // IRangeList Methods
    HRESULT STDMETHODCALLTYPE Clear(void) { m_numRanges = 0; return S_OK; };
    HRESULT STDMETHODCALLTYPE IsInRange(const ULONG value);    // is `value' in one of the ranges
                                                               // in this CRangeList?

    HRESULT STDMETHODCALLTYPE Min(ULONG *pulMin);    // return the minimum in-range value
    HRESULT STDMETHODCALLTYPE Max(ULONG *pulMax);    // return the maximum in-range value

    HRESULT STDMETHODCALLTYPE Save(LPBYTE *ppbDestination, ULONG *pulSizeOfDestination);
    HRESULT STDMETHODCALLTYPE Load(LPBYTE pbSource, const ULONG ulSizeOfSource);

    // void AddRange(const char *);
                                     // a string in the form "low-high,..."
                                     //  or just "value,..."
    HRESULT STDMETHODCALLTYPE AddRange(const ULONG low, const ULONG high);
    HRESULT STDMETHODCALLTYPE AddSingleValue(const ULONG value);
    HRESULT STDMETHODCALLTYPE AddRangeList(const IRangeList *prl);

    HRESULT STDMETHODCALLTYPE DeleteRange(const ULONG low, const ULONG high);
    HRESULT STDMETHODCALLTYPE DeleteSingleValue(const ULONG value);
    HRESULT STDMETHODCALLTYPE DeleteRangeList(const IRangeList *prl);

    // finds the range "value" is in and returns the min/max of that
    HRESULT STDMETHODCALLTYPE MinOfRange(const ULONG value, ULONG *pulMinOfRange);
    HRESULT STDMETHODCALLTYPE MaxOfRange(const ULONG value, ULONG *pulMaxOfRange);

    // Outputs the rangelist to an IMAP message set string
    HRESULT STDMETHODCALLTYPE RangeToIMAPString(LPSTR *ppszDestination,
        LPDWORD pdwLengthOfDestination);

    // next() returns the smallest in-range value greater than `current', or -1
    HRESULT STDMETHODCALLTYPE Next(const ULONG current, ULONG *pulNext);
    // prev() returns the largest in-range value less than `current', or -1
    HRESULT STDMETHODCALLTYPE Prev(const ULONG current, ULONG *pulPrev);

    HRESULT STDMETHODCALLTYPE Cardinality(ULONG *pulCardinality);  // return the cardinality of the set of
                                                                   // in-range values
    HRESULT STDMETHODCALLTYPE CardinalityFrom(const ULONG ulStartPoint,
                                              ULONG *pulCardinalityFrom); // Return the cardinality of the set of
                                                                          // in-range values starting after ulStartPoint

private:
    BOOL Expand();
    int  BinarySearch(const ULONG value) const;
    void ShiftLeft(int low, int distance);
    void ShiftRight(int low, int distance);
    void SubsumeDown(int&);
    void SubsumeUpwards(const int);

    HRESULT AddRangeType(const RangeType range);
    HRESULT DeleteRangeType(const RangeType range);

    signed long m_lRefCount;

protected:
    int        m_numRanges;         // number of ranges in the rangeTable
    int        m_rangeTableSize;    // range table has room for this many ranges
    RangeType *m_rangeTable;        // the array of ranges
};

#endif // _RANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\sicily.h ===
//--------------------------------------------------------------------------
// S I C I L Y . H
//--------------------------------------------------------------------------
#pragma once 

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#ifndef SECURITY_WIN32
#define SECURITY_WIN32  1
#endif
#include <sspi.h>
#include <spseal.h>
#include <rpcdce.h>
#include <issperr.h>
#include <imnxport.h>

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
interface ITransportCallback;

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define SSP_SSPS_DLL            "msnsspc.dll"
#define CBMAX_SSPI_BUFFER       1042
#define SSPI_BASE64             TRUE
#define SSPI_UUENCODE           FALSE

//--------------------------------------------------------------------------
// SSPIBUFFERTYPE
//--------------------------------------------------------------------------
typedef enum tagSSPIBUFFERTYPE {
    SSPI_STRING,
    SSPI_BLOB
} SSPIBUFFERTYPE;

//--------------------------------------------------------------------------
// SSPICONTEXTSTATE
//--------------------------------------------------------------------------
typedef enum tagSSPICONTEXTSTATE {
    SSPI_STATE_USE_CACHED,
    SSPI_STATE_USE_SUPPLIED,
    SSPI_STATE_PROMPT_USE_PACKAGE,
    SSPI_STATE_PROMPT_USE_OWN,
} SSPICONTEXTSTATE;

//--------------------------------------------------------------------------
// SSPICONTEXT
//--------------------------------------------------------------------------
typedef struct tagSSPICONTEXT {
    DWORD               tyState;
    DWORD               tyRetry;
    DWORD               tyRetryState;
    DWORD               cRetries;
    BYTE                fPromptCancel;
    HWND                hwndLogon;
    BYTE                fCredential;
    CredHandle          hCredential;
    BYTE                fContext;
    CtxtHandle          hContext;
    BOOL                fBase64;
    LPSTR               pszServer;
    LPSTR               pszPackage;
    LPSTR               pszUserName;
    LPSTR               pszPassword;
    LPSTR               pszDomain;
    BOOL                fService;
    BOOL                fUsedSuppliedCreds;
    ITransportCallback *pCallback;
} SSPICONTEXT, *LPSSPICONTEXT;

//--------------------------------------------------------------------------
// SSPIBUFFER
//--------------------------------------------------------------------------
typedef struct tagSSPIBUFFER {
    CHAR            szBuffer[CBMAX_SSPI_BUFFER];
    DWORD           cbBuffer;
    BOOL            fContinue;
} SSPIBUFFER, *LPSSPIBUFFER;

//--------------------------------------------------------------------------
// SSPIPACKAGE
//--------------------------------------------------------------------------
typedef struct tagSSPIPACKAGE {
    ULONG           ulCapabilities;
    WORD            wVersion;
    ULONG           cbMaxToken;
    LPSTR           pszName;
    LPSTR           pszComment;
} SSPIPACKAGE, *LPSSPIPACKAGE;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT SSPIIsInstalled(void);
HRESULT SSPIGetPackages(LPSSPIPACKAGE *pprgPackage, ULONG *pcPackages);
HRESULT SSPILogon(LPSSPICONTEXT pContext, BOOL fRetry, BOOL fBase64, LPCSTR szPackage, LPINETSERVER pServer, ITransportCallback *pCallback);
HRESULT SSPIGetNegotiate(LPSSPICONTEXT pContext, LPSSPIBUFFER pNegotiate);
HRESULT SSPIResponseFromChallenge(LPSSPICONTEXT pContext, LPSSPIBUFFER pChallenge, LPSSPIBUFFER pResponse);
HRESULT SSPIUninitialize(void);
HRESULT SSPIFreeContext(LPSSPICONTEXT pContext);
HRESULT SSPIReleaseContext(LPSSPICONTEXT pContext);
HRESULT SSPIMakeOutboundMessage(LPSSPICONTEXT pContext, DWORD dwFlags, LPSSPIBUFFER pBuffer, PSecBufferDesc pInDescript);
HRESULT SSPIEncodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer);
HRESULT SSPIDecodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer);
HRESULT SSPISetBuffer(LPCSTR pszString, SSPIBUFFERTYPE tyBuffer, DWORD cbBytes, LPSSPIBUFFER pBuffer);
HRESULT SSPIFindCredential(LPSSPICONTEXT pContext, SEC_WINNT_AUTH_IDENTITY *pAuth, ITransportCallback *pCallback);

//--------------------------------------------------------------------------
// FIsSicilyInstalled
//--------------------------------------------------------------------------
inline HRESULT SSPIFreePackages(LPSSPIPACKAGE *pprgPackage, ULONG cPackages) { return(S_OK); }
inline BOOL FIsSicilyInstalled(void) { 
    return (S_OK == SSPIIsInstalled()) ? TRUE : FALSE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\strtokex.c ===
/***
*strtokex.c - tokenize a string with given delimiters
*
*       Copyright (c) 1989-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines strtok() - breaks string into series of token
*       via repeated calls.
*
*******************************************************************************/
#if defined(unix)
#define __cdecl
#endif
#include <windows.h>
#include <string.h>
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/
char * __cdecl StrTokEx (char ** pstring, const char * control)
{
    unsigned char *psz;
    const unsigned char *pszCtrl = (const unsigned char *)control;
    unsigned char map[32] = {0};
    
    LPSTR pszToken;
    
    if(*pstring == NULL)
        return NULL;
    
    /* Set bits in delimiter table */
    do
    {
        map[*pszCtrl >> 3] |= (1 << (*pszCtrl & 7));
    } 
    while (*pszCtrl++);
    
    /* Initialize str. */
    psz = (unsigned char*)*pstring;
    
    /* Find beginning of token (skip over leading delimiters). Note that
    * there is no token if this loop sets str to point to the terminal
    * null (*str == '\0') */
    while ((map[*psz >> 3] & (1 << (*psz & 7))) && *psz)
        psz++;
    
    pszToken = (LPSTR)psz;
    
    /* Find the end of the token. If it is not the end of the string,
    * put a null there. */
    for (; *psz ; psz++)
    {
        if (map[*psz >> 3] & (1 << (*psz & 7))) 
        {
            *psz++ = '\0';
            break;
        }
    }
    
    /* string now points to beginning of next token */
    *pstring = (LPSTR)psz;
    
    /* Determine if a token has been found. */
    if (pszToken == (LPSTR)psz)
        return NULL;
    else
        return pszToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\thorsspi.h ===
#ifndef _THORSSPI_H
#define _THORSSPI_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WIN16
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#endif //!WIN16
#include <schnlsp.h>
#include <sspi.h>
#include <issperr.h>
#include <spseal.h>

typedef PSecurityFunctionTable  (APIENTRY *INITSECURITYINTERFACE) (VOID);

extern  PSecurityFunctionTable  g_pSecFuncTable;

#define g_EnumerateSecurityPackages \
        (*(g_pSecFuncTable->EnumerateSecurityPackagesA))
#define g_AcquireCredentialsHandle  \
        (*(g_pSecFuncTable->AcquireCredentialsHandleA))
#define g_FreeCredentialsHandle     \
        (*(g_pSecFuncTable->FreeCredentialHandle))
#define g_InitializeSecurityContext \
        (*(g_pSecFuncTable->InitializeSecurityContextA))
#define g_DeleteSecurityContext     \
        (*(g_pSecFuncTable->DeleteSecurityContext))
#define g_QueryContextAttributes    \
        (*(g_pSecFuncTable->QueryContextAttributesA))
#define g_FreeContextBuffer         \
        (*(g_pSecFuncTable->FreeContextBuffer))
#define g_SealMessage               \
        (*((SEAL_MESSAGE_FN)g_pSecFuncTable->Reserved3))
#define g_UnsealMessage             \
        (*((UNSEAL_MESSAGE_FN)g_pSecFuncTable->Reserved4))

//
//  Encryption Capabilities
//
#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//  PCT & SSL are both supported
//
#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | ENC_CAPS_PCT)
#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

#define INVALID_CRED_VALUE         {0xFFFFFFFF, 0xFFFFFFFF}

typedef struct _SEC_PROVIDER
{
    CHAR        *pszName;          // security pkg name
    CredHandle   hCreds;           // credential handle
    DWORD        dwFlags;          // encryption capabilities
    BOOL         fEnabled;         // enable flag indicator
} SEC_PROVIDER, *PSEC_PROVIDER;

extern SEC_PROVIDER s_SecProviders[];
extern int g_cSSLProviders;

//
// prototypes
//
VOID  SecurityInitialize(VOID);
DWORD LoadSecurity(VOID);
BOOL  FIsSecurityEnabled();
VOID  UnloadSecurity(VOID);
SECURITY_STATUS InitiateSecConnection(LPSTR pszServer, BOOL fForceSSL2ClientHello, LPINT piPkg,
                                      PCtxtHandle phContext, PSecBuffer  pOutBuffers);
SECURITY_STATUS ContinueHandshake(int iPkg, PCtxtHandle phContext, LPSTR pszBuf, int cbBuf,
                                  LPINT pcbEaten, PSecBuffer pOutBuffers);
DWORD DecryptData(PCtxtHandle phContext, LPSTR pszBufIn, int cbBufIn,
                  LPINT pcbBufOut, LPINT pcbEaten);
DWORD EncryptData(PCtxtHandle phContext, LPVOID pBufIn, int cbBufIn,
                  LPVOID *ppBufOut, int *pcbBufOut);
HRESULT ChkCertificateTrust(IN PCtxtHandle phContext, IN LPSTR pszHostName);

#ifdef __cplusplus
}
#endif

#endif // _THORSSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\imnxport\thorsspi.cpp ===
/*
 *    thorsspi.cpp
 *    
 *    Purpose:
 *        implementation of SSL/PCT security
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Jun 96: Created.  Major portions glommed from WININET.
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#include <pch.hxx>
#include "imnxport.h"
#include "thorsspi.h"
#include "strconst.h"
#include <wincrypt.h>
#include <wintrust.h>
#include <cryptdlg.h>
#include "demand.h"
#include <shlwapi.h>

#ifdef WIN16
#ifndef GetLastError
// From win16x.h
#define GetLastError() ((DWORD) -1)
#endif
#endif // WIN16


//
// s_csInitializationSecLock - protects against multiple threads loading security.dll
// (secur32.dll) and entry points
//
static CRITICAL_SECTION s_csInitializationSecLock = {0};

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//
static HINSTANCE s_hSecurity = NULL;

//
// g_pSecFuncTable - Pointer to Global Structure of Pointers that are used 
//  for storing the entry points into the SCHANNEL.dll
// 
PSecurityFunctionTable g_pSecFuncTable = NULL;

//
//
//  List of encryption packages:  PCT, SSL, etc
//
//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//
SEC_PROVIDER s_SecProviders[] =
{
    UNISP_NAME,  INVALID_CRED_VALUE , ENC_CAPS_PCT | ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT,                FALSE,
    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL,                FALSE,
    SSL2SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL,                FALSE,
};

int g_cSSLProviders = ARRAYSIZE(s_SecProviders);

DWORD s_dwEncFlags = 0;

#define LOCK_SECURITY()   EnterCriticalSection(&s_csInitializationSecLock)
#define UNLOCK_SECURITY() LeaveCriticalSection(&s_csInitializationSecLock)

BOOL SecurityPkgInitialize(VOID);
DWORD VerifyServerCertificate(PCCERT_CONTEXT pServerCert, LPSTR pszServerName, DWORD dwCertFlags, BOOL fCheckRevocation);

/////////////////////////////////////////////////////////////////////////////
// 
// The following code through SslRecordSize() was stolen from MSN.

typedef struct _Ssl_Record_Header {
    UCHAR   Byte0;
    UCHAR   Byte1;
} Ssl_Record_Header, * PSsl_Record_Header;

#define SIZEOFSSLMSG(pMessage)  (SslRecordSize((PSsl_Record_Header) pMessage ) )
#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

/////////////////////////////////////////////////////////////////////////////
// 
// SslRecordSize()
//
//    This function calculates the expected size of an SSL packet to work
//      around a bug in some security packages.
//
DWORD
SslRecordSize(
    PSsl_Record_Header  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return( Size + sizeof(Ssl_Record_Header) );
}

/////////////////////////////////////////////////////////////////////////////
// 
// SecurityInitialize()
//
//    This function initializes the global lock required for the security
//    pkgs.
//
VOID SecurityInitialize(VOID)
{
    InitializeCriticalSection( &s_csInitializationSecLock );
}

/////////////////////////////////////////////////////////////////////////////
// 
// UnloadSecurity()
//
//    This function terminates the global data required for the security
//    pkgs and dynamically unloads security APIs from security.dll (NT)
//    or secur32.dll (WIN95).
//
VOID UnloadSecurity(VOID)
{
    DWORD i;

    LOCK_SECURITY();

    //
    //  free all security pkg credential handles
    //
    for (i = 0; i < ARRAYSIZE(s_SecProviders); i++)
        {
        if (s_SecProviders[i].fEnabled) 
            {
            g_FreeCredentialsHandle(&s_SecProviders[i].hCreds);
            }
        }

    //
    //  unload dll
    //
    if (s_hSecurity != NULL) 
        {
        FreeLibrary(s_hSecurity);
        s_hSecurity = NULL;
        }

    UNLOCK_SECURITY();

    DeleteCriticalSection(&s_csInitializationSecLock);
}


/////////////////////////////////////////////////////////////////////////////
// 
// LoadSecurity()
//
//    This function dynamically loads security APIs from security.dll (NT)
//    or secur32.dll (WIN95).
//
DWORD LoadSecurity(VOID)
{
    DWORD dwErr = ERROR_SUCCESS;
    INITSECURITYINTERFACE pfInitSecurityInterface = NULL;

    LOCK_SECURITY();

    if (s_hSecurity != NULL) 
        {
        goto quit;
        }

    //
    // load dll.
    //

#ifdef LOAD_SECURE32
    if (GlobalUseSchannelDirectly)
        {
#endif
        //
        // This is better for performance. Rather than call through
        //    SSPI, we go right to the DLL doing the work.
        //

#ifndef WIN16
        s_hSecurity = LoadLibrary("schannel");
#else
        s_hSecurity = LoadLibrary("schnl16.dll");
#endif // !WIN16
#ifdef LOAD_SECURE32
        }
    else
        {
#ifndef WIN16
        if (IsPlatformWinNT() == S_OK) 
            {
            s_hSecurity = LoadLibrary("security");
            }
        else 
            {
            s_hSecurity = LoadLibrary("secur32");
            }
#else
        s_hSecurity = LoadLibrary("secur16.dll");
#endif // !WIN16
        }
#endif

    if (s_hSecurity == NULL) 
        {
        dwErr = GetLastError();
        goto quit;
        }

    //
    // get function addresses.
    //

    pfInitSecurityInterface = (INITSECURITYINTERFACE)GetProcAddress(s_hSecurity, SECURITY_ENTRYPOINT);

    if (pfInitSecurityInterface == NULL)
        {
        dwErr = GetLastError();
        goto quit;
        }

#ifdef USE_CLIENT_AUTH
    //
    // Get SslCrackCertificate func pointer,
    //  utility function declared in SCHANNEL that 
    //  is used for parsing X509 certificates.
    //

    pSslCrackCertificate =
        (SSL_CRACK_CERTIFICATE_FN)GetProcAddress(s_hSecurity, SSL_CRACK_CERTIFICATE_NAME);

    if (pSslCrackCertificate == NULL)
        {
        dwErr = GetLastError();
        goto quit;
        }

    pSslFreeCertificate =
        (SSL_FREE_CERTIFICATE_FN)GetProcAddress(s_hSecurity, SSL_FREE_CERTIFICATE_NAME);

    if (pSslFreeCertificate == NULL)
        {
        dwErr = GetLastError();
        goto quit;
        }
#endif // USE_CLIENT_AUTH

    g_pSecFuncTable = (SecurityFunctionTable*)((*pfInitSecurityInterface)());

    if (g_pSecFuncTable == NULL) 
        {
        dwErr = GetLastError(); // BUGBUG does this work?
        goto quit;
        }

    if (!SecurityPkgInitialize()) 
        {
        dwErr = GetLastError();
        }


quit:

    if (dwErr != ERROR_SUCCESS)
        {        
        FreeLibrary(s_hSecurity);
        s_hSecurity = NULL;
        }

    UNLOCK_SECURITY();

    return dwErr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// SecurityPkgInitialize()
//
// Description:
//    This function finds a list of security packages that are supported
//    on the client's machine, checks if pct or ssl is supported, and
//    creates a credential handle for each supported pkg.
//
// Return:
//    TRUE if at least one security pkg is found; otherwise FALSE
//
BOOL SecurityPkgInitialize(VOID)
{
    TimeStamp         tsExpiry;
    SECURITY_STATUS   scRet;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages = 0;
    ULONG             fCapabilities;
    ULONG             i;
    ULONG             j;
    DWORD             cProviders = 0;
    VOID *            pvCreds = NULL;
    SCHANNEL_CRED     schnlCreds = {0};

    //
    //  check if this routine has been called.  if yes, return TRUE
    //  if we've found a supported pkg; otherwise FALSE
    //
    if (s_dwEncFlags == ENC_CAPS_NOT_INSTALLED)
        return FALSE;
    else if (s_dwEncFlags & ENC_CAPS_TYPE_MASK)
        return TRUE;

    //
    //  Initialize s_dwEncFlags
    //
    s_dwEncFlags = ENC_CAPS_NOT_INSTALLED;

    //
    //  Check if at least one security package is supported
    //
    scRet = g_EnumerateSecurityPackages(&cPackages, &pPackageInfo);
    if (scRet != SEC_E_OK)
        {
        DOUTL(2, "EnumerateSecurityPackages failed, error %lx", scRet);
        SetLastError(scRet); //$REVIEW - is this cool? (EricAn)
        return FALSE;
        }

    // Sometimes EnumerateSecurityPackages() returns SEC_E_OK with 
    // cPackages > 0 and pPackageInfo == NULL !!! This is clearly a bug 
    // in the security subsystem, but let's not crash because of it.  (EricAn)
    if (!cPackages || !pPackageInfo)
        return FALSE;

    for (i = 0; i < cPackages; i++)
        {
        //
        //  Use only if the package name is the PCT/SSL package
        //
        fCapabilities = pPackageInfo[i].fCapabilities;

        if (fCapabilities & SECPKG_FLAG_STREAM)
            {
            //
            //  Check if the package supports server side authentication
            //  and all recv/sent messages are tamper proof
            //
            if ((fCapabilities & SECPKG_FLAG_CLIENT_ONLY) ||
                !(fCapabilities & SECPKG_FLAG_PRIVACY))
                {
                continue;
                }

            //
            //  Check if the pkg matches one of our known packages
            //
            for (j = 0; j < ARRAYSIZE(s_SecProviders); j++)
                {
                if (!lstrcmpi(pPackageInfo[i].Name, s_SecProviders[j].pszName))
                    {
                    // RAID - 9611
                    // This is an ugly hack for NT 5 only
                    //
                    // For NT5, the universal security protocol provider will try
                    // to do automatic authenication of the certificate unless
                    // we pass in these flags.
                    if (0 == lstrcmpi(s_SecProviders[j].pszName, UNISP_NAME))
                        {
                        OSVERSIONINFO   osinfo = {0};

                        osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                        if ((FALSE != GetVersionEx(&osinfo)) &&
                                    (VER_PLATFORM_WIN32_NT == osinfo.dwPlatformId) && (5 == osinfo.dwMajorVersion))
                            {
                            schnlCreds.dwVersion = SCHANNEL_CRED_VERSION;
                            schnlCreds.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION | SCH_CRED_NO_DEFAULT_CREDS;

                            pvCreds = (VOID *) &schnlCreds;
                            }
                        }
                        
                    //
                    //  Create a credential handle for each supported pkg
                    //
                    scRet = g_AcquireCredentialsHandle(NULL,
                                                       s_SecProviders[j].pszName,
                                                       SECPKG_CRED_OUTBOUND,
                                                       NULL, 
                                                       pvCreds, 
                                                       NULL, 
                                                       NULL,
                                                       &(s_SecProviders[j].hCreds),
                                                       &tsExpiry);

                    if (scRet != SEC_E_OK)
                        {
                        DOUTL(2, "AcquireCredentialHandle failed, error %lx", scRet);
                        }
                    else 
                        {
                        DOUTL(2, 
                              "AcquireCredentialHandle() supports %s, acquires %x:%x",
                              s_SecProviders[j].pszName,
                              s_SecProviders[j].hCreds.dwUpper,
                              s_SecProviders[j].hCreds.dwLower);
                        s_SecProviders[j].fEnabled = TRUE;
                        cProviders++;
                        s_dwEncFlags |= s_SecProviders[j].dwFlags;
                        }
                    break;
                    }
                }
            }
        }

    if (!cProviders)
        {
        //
        //  No security packages were found, return FALSE to caller
        //
        DOUTL(2, "No security packages were found.");
        Assert(pPackageInfo);
        g_FreeContextBuffer(pPackageInfo);
        SetLastError((DWORD)SEC_E_SECPKG_NOT_FOUND); //$REVIEW - is this cool? (EricAn)
        return FALSE;
        }

    //
    //  Successfully found a security package(s)
    //
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// 
// FIsSecurityEnabled()
//
// Description:
//    Checks if security is initialized, if so returns TRUE, otherwise tries
//    to initialize it.
//
// Return:
//    TRUE if at least one security pkg is enabled; otherwise FALSE
//
BOOL FIsSecurityEnabled()
{
    if (s_dwEncFlags == ENC_CAPS_NOT_INSTALLED)
        return FALSE;
    else if (s_dwEncFlags == 0) 
        {
        //
        //  first time thru, do the load.
        //
        DOUTL(2, "Loading security dll.");
        if (ERROR_SUCCESS != LoadSecurity())
            return FALSE;
        }
    // at least one security package should be active
    Assert(s_dwEncFlags & ENC_CAPS_TYPE_MASK);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// 
// InitiateSecConnection()
//
// Description:
//    Initiates a secure connection using SSL/PCT.
//
// Parameters:
//    pszServer             - server name
//    fForceSSL2ClientHello - hack for IIS 1.0 servers that fail SSL3 HELLOs
//    piPkg                 - on input, first package to try.
//                            on output, package being used.
//    phContext             - returned security context handle
//    pOutBuffers           - returned buffer
//
// Return:
//    SECURITY_STATUS - SEC_I_CONTINUE_NEEDED expected
//
SECURITY_STATUS
      InitiateSecConnection(IN      LPSTR       pszServer,              // server name
                            IN      BOOL        fForceSSL2ClientHello,  // SSL2 hack?
                            IN OUT  LPINT       piPkg,                  // index of package to try
                            OUT     PCtxtHandle phContext,              // returned context handle
                            OUT     PSecBuffer  pOutBuffers)            // negotiation buffer to send
{
    TimeStamp            tsExpiry;
    DWORD                ContextAttr;
    SECURITY_STATUS      scRet;
    SecBufferDesc        InBuffer;
    SecBufferDesc        *pInBuffer;
    SecBufferDesc        OutBuffer;
    SecBuffer            InBuffers[2];
    DWORD                i;
    CredHandle           hCreds;
    DWORD                dwSSL2Code;

    Assert(piPkg);
    Assert(*piPkg >= 0 && *piPkg < ARRAYSIZE(s_SecProviders));
    Assert(pszServer);
    Assert(phContext);

    scRet = SEC_E_SECPKG_NOT_FOUND; //default error if we run out of packages

    //
    //  set OutBuffer for InitializeSecurityContext call
    //
    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = pOutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // SSL2 hack for IIS Servers.  The caller asked
    //  for us to send a SSL2 Client Hello usually in
    //  response to a failure of send a SSL3 Client Hello.
    //
    if (fForceSSL2ClientHello)
        {
        dwSSL2Code = 0x2;

        InBuffers[0].pvBuffer   = (VOID *) &dwSSL2Code;
        InBuffers[0].cbBuffer   = sizeof(DWORD);
        InBuffers[0].BufferType = SECBUFFER_PKG_PARAMS;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        InBuffer.cBuffers   = 2;
        InBuffer.pBuffers   = InBuffers;
        InBuffer.ulVersion  = SECBUFFER_VERSION;

        pInBuffer = &InBuffer;
        }
    else
        pInBuffer = NULL; // default, don't do hack.

    for (i = *piPkg; i < ARRAYSIZE(s_SecProviders); i++)
        {
        if (!s_SecProviders[i].fEnabled)
            continue;

        DOUTL(2, "Starting handshake protocol with pkg %d - %s", i, s_SecProviders[i].pszName);

        hCreds = s_SecProviders[i].hCreds;

        //
        //  1. initiate a client HELLO message and generate a token
        //
        pOutBuffers->pvBuffer = NULL;
        pOutBuffers->BufferType = SECBUFFER_TOKEN;

        scRet = g_InitializeSecurityContext(&hCreds,
                                            NULL,
                                            pszServer,
                                            ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |
                                                ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_USE_SUPPLIED_CREDS,
                                            0,
                                            SECURITY_NATIVE_DREP,
                                            pInBuffer,
                                            0,
                                            phContext,
                                            &OutBuffer,         // address where output data go
                                            &ContextAttr,
                                            &tsExpiry);

        DOUTL(2, "1. InitializeSecurityContext returned [%x]", scRet);

        if (scRet == SEC_I_CONTINUE_NEEDED)
            {
            DOUTL(2, "2. OutBuffer is <%x, %d, %x>", pOutBuffers->pvBuffer, pOutBuffers->cbBuffer, pOutBuffers->BufferType);
            *piPkg = i;
            return scRet;
            }
        else if (scRet == SEC_E_INVALID_HANDLE)
            {
            //
            //  First call to InitializeSecurityContext should not return
            //  SEC_E_INVALID_HANDLE ; if this is the returned error,
            //  we should disable this pkg
            //
            s_SecProviders[i].fEnabled = FALSE;
            }
        
        if (pOutBuffers->pvBuffer)
            g_FreeContextBuffer(pOutBuffers->pvBuffer);
        // loop and try the next provider
        }

    // if we get here we ran out of providers
    return SEC_E_SECPKG_NOT_FOUND;    
}

/////////////////////////////////////////////////////////////////////////////
// 
// ContinueHandshake()
//
// Description:
//    Continues a secure handshake using SSL/PCT.
//
// Parameters:
//    iPkg          - security package being used
//    phContext     - security context handle returned from InitiateSecConnection
//    pszBuf        - recv'd buffer
//    cbBuf         - size of recv'd buffer
//    pcbEaten      - number of bytes of pszBuf actually used
//    pOutBuffers   - buffer to be sent
//
// Return:
//    SECURITY_STATUS - expected values:
//      SEC_E_OK                    - secure connection established
//      SEC_I_CONTINUE_NEEDED       - more handshaking required
//      SEC_E_INCOMPLETE_MESSAGE    - need more recv data before continuing
//
SECURITY_STATUS ContinueHandshake(IN    int         iPkg,
                                  IN    PCtxtHandle phContext,
                                  IN    LPSTR       pszBuf,
                                  IN    int         cbBuf,
                                  OUT   LPINT       pcbEaten,
                                  OUT   PSecBuffer  pOutBuffers)
{
    TimeStamp            tsExpiry;
    DWORD                ContextAttr;
    SECURITY_STATUS      scRet;
    SecBufferDesc        InBuffer;
    SecBufferDesc        OutBuffer;
    SecBuffer            InBuffers[2];
    CredHandle           hCreds;
    int                  cbEaten = 0;

#if 0
    //
    // BUGBUG: work around bug in NT's SSLSSPI.DLL shipped with IIS 1.0
    // The DLL does not check the expected size of message properly and
    // as result we need to do the check ourselves and fail appropriately
    //
    if (pszBuf && cbBuf)
        {
        if (cbBuf == 1 || cbBuf < SIZEOFSSLMSG(pszBuf))
            {
            DOUTL(2, "incomplete handshake msg received: %d, expected: %d", cbBuf, SIZEOFSSLMSG(pszBuf));
            pOutBuffers->pvBuffer = 0;
            pOutBuffers->cbBuffer = 0;
            *pcbEaten = 0;
            return SEC_E_INCOMPLETE_MESSAGE;
            }
        }
#endif

    Assert(iPkg >= 0 && iPkg < ARRAYSIZE(s_SecProviders) && s_SecProviders[iPkg].fEnabled);
    hCreds = s_SecProviders[iPkg].hCreds;

    //
    // InBuffers[1] is for getting extra data that
    //  SSPI/SCHANNEL doesn't proccess on this
    //  run around the loop.
    //
    InBuffers[0].pvBuffer   = pszBuf;
    InBuffers[0].cbBuffer   = cbBuf;
    InBuffers[0].BufferType = SECBUFFER_TOKEN;

    InBuffers[1].pvBuffer   = NULL;
    InBuffers[1].cbBuffer   = 0;
    InBuffers[1].BufferType = SECBUFFER_EMPTY;

    InBuffer.cBuffers       = 2;
    InBuffer.pBuffers       = InBuffers;
    InBuffer.ulVersion      = SECBUFFER_VERSION;

    //
    //  set OutBuffer for InitializeSecurityContext call
    //
    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = pOutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // Initialize these so if we fail, pvBuffer contains NULL,
    // so we don't try to free random garbage at the quit
    //
    pOutBuffers->pvBuffer   = NULL;
    pOutBuffers->BufferType = SECBUFFER_TOKEN;
    pOutBuffers->cbBuffer   = 0;

    scRet = g_InitializeSecurityContext(&hCreds,
                                        phContext,
                                        NULL,
                                        ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY |
                                            ISC_REQ_ALLOCATE_MEMORY | ISC_RET_EXTENDED_ERROR,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        &InBuffer,
                                        0,
                                        NULL,
                                        &OutBuffer,
                                        &ContextAttr,
                                        &tsExpiry);

    DOUTL(2, "InitializeSecurityContext returned [%x]", scRet);

    if (scRet == SEC_E_OK || scRet == SEC_I_CONTINUE_NEEDED || scRet == SEC_E_INCOMPLETE_MESSAGE)
        {
        // got one of the expected returns
        if (scRet == SEC_E_INCOMPLETE_MESSAGE)
            {
            // make sure we don't send anything in this case
            if (pOutBuffers->pvBuffer)
                {
                g_FreeContextBuffer(pOutBuffers->pvBuffer);
                pOutBuffers->pvBuffer = 0;
                pOutBuffers->cbBuffer = 0;
                }
            }
        else
            {
            // there was extra data left over
            if (InBuffers[1].BufferType == SECBUFFER_EXTRA)
                cbEaten = (cbBuf - InBuffers[1].cbBuffer);
            else
                cbEaten = cbBuf;
            }
        }
    else
        {
        // handle an unexpected return
        if (!(ContextAttr & ISC_RET_EXTENDED_ERROR))
            {
            // only send an error packet if there is one
            if (pOutBuffers->pvBuffer)
                {
                g_FreeContextBuffer(pOutBuffers->pvBuffer);
                pOutBuffers->pvBuffer = 0;
                pOutBuffers->cbBuffer = 0;
                }
            }
        }

    *pcbEaten = cbEaten;
    return scRet;
}

/////////////////////////////////////////////////////////////////////////////
// 
// EncryptData()
//
// Description:
//    Encrypts a packet to be sent using SSL/PCT by calling SealMessage().
//
// Parameters:
//    phContext     - security context handle returned from InitiateSecConnection
//    pBufIn        - buffer to be encrypted
//    cbBufIn       - length of buffer to be encrypted
//    ppBufOut      - allocated encrypted buffer, to be freed by caller
//    pcbBufOut     - length of encrypted buffer
//
// Return:
//    SECURITY_STATUS
//
DWORD EncryptData(IN  PCtxtHandle phContext,
                  IN  LPVOID      pBufIn,
                  IN  int         cbBufIn,
                  OUT LPVOID     *ppBufOut,
                  OUT int        *pcbBufOut)
{
    SECURITY_STATUS           scRet = ERROR_SUCCESS;
    SecBufferDesc             Buffer;
    SecBuffer                 Buffers[3];
    SecPkgContext_StreamSizes Sizes;

    Assert(pBufIn);
    Assert(cbBufIn);
    Assert(ppBufOut);
    Assert(pcbBufOut);
    
    *pcbBufOut = 0;

    //
    //  find the header and trailer sizes
    //

    scRet = g_QueryContextAttributes(phContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );

    if (scRet != ERROR_SUCCESS)
        {
        DOUTL(2, "QueryContextAttributes returned [%x]", scRet);
        return scRet;
        }
    else 
        {
        DOUTL(128, "QueryContextAttributes returned header=%d trailer=%d", Sizes.cbHeader, Sizes.cbTrailer);
        }

    if (!MemAlloc(ppBufOut, cbBufIn + Sizes.cbHeader + Sizes.cbTrailer))
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // prepare data for SecBuffer
    //
    Buffers[0].pvBuffer = *ppBufOut;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_TOKEN;

    Buffers[1].pvBuffer = (LPBYTE)*ppBufOut + Sizes.cbHeader;
    CopyMemory(Buffers[1].pvBuffer,
               pBufIn,
               cbBufIn);
    Buffers[1].cbBuffer = cbBufIn;
    Buffers[1].BufferType = SECBUFFER_DATA;

    //
    // check if security pkg supports trailer: PCT does
    //
    if (Sizes.cbTrailer) 
        {
        Buffers[2].pvBuffer = (LPBYTE)*ppBufOut + Sizes.cbHeader + cbBufIn;
        Buffers[2].cbBuffer = Sizes.cbTrailer;
        Buffers[2].BufferType = SECBUFFER_TOKEN;
        }
    else 
        {
        Buffers[2].pvBuffer = NULL;
        Buffers[2].cbBuffer = 0;
        Buffers[2].BufferType = SECBUFFER_EMPTY;
        }

    Buffer.cBuffers = 3;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    scRet = g_SealMessage(phContext, 0, &Buffer, 0);

    DOUTL(128, "SealMessage returned [%x]", scRet);

    if (scRet != ERROR_SUCCESS)
        {
        //
        // Map the SSPI error.
        //
        DOUTL(2, "SealMessage failed with [%x]", scRet);
        SafeMemFree(*ppBufOut);
        return scRet;
        }

    // Bug# 80814 June 1999 5.01
    // [shaheedp] Starting with NT4 SP4 the sizes of headers and trailers are not constant. 
    // The function SealMessage calculates the sizes correctly. 
    // Hence the sizes returned by SealMessage should be used to determine the actual size of the packet.

    *pcbBufOut = Buffers[0].cbBuffer + Buffers[1].cbBuffer + Buffers[2].cbBuffer;

    DOUTL(128, "SealMessage returned Buffer = %x, EncryptBytes = %d, UnencryptBytes = %d",
          *ppBufOut, *pcbBufOut, cbBufIn);
    return scRet;
}

/////////////////////////////////////////////////////////////////////////////
// 
// DecryptData()
//
// Description:
//    Decrypts a buffer received using SSL/PCT by calling UnsealMessage().
//
// Parameters:
//    phContext     - security context handle returned from InitiateSecConnection
//    pszBufIn      - buffer to be decrypted
//    cbBufIn       - length of buffer to be decrypted
//    pcbBufOut     - length of decrypted data, stored at beginning of pszBufIn
//    pcbEaten      - number of bytes of pszBufIn that were decrypted, 
//                      (cbBufIn - *pcbEaten) is the number of extra bytes located
//                      at (pszBufIn + *pcbEaten) that need to be saved until more
//                      data is received
//
// Return:
//    SECURITY_STATUS
//      ERROR_SUCCESS               - some data was decrypted, there may be extra
//      SEC_E_INCOMPLETE_MESSAGE    - not enough data to decrypt
//
DWORD DecryptData(IN    PCtxtHandle phContext,
                  IN    LPSTR       pszBufIn,
                  IN    int         cbBufIn,
                  OUT   LPINT       pcbBufOut,
                  OUT   LPINT       pcbEaten)
{
    SecBufferDesc   Buffer;
    SecBuffer       Buffers[4];  // the 4 buffers are: header, data, trailer, extra
    DWORD           scRet = ERROR_SUCCESS;
    int             cbEaten = 0, cbOut = 0;
    LPSTR           pszBufOut = NULL;

    while (cbEaten < cbBufIn && scRet == ERROR_SUCCESS)
        {
        //
        // prepare data the SecBuffer for a call to SSL/PCT decryption code.
        //
        Buffers[0].pvBuffer   = pszBufIn + cbEaten;
        Buffers[0].cbBuffer   = cbBufIn - cbEaten;
        Buffers[0].BufferType = SECBUFFER_DATA;

        for (int i = 1; i < 4; i++)
            {
            //
            // clear other 3 buffers for receving result from SSPI package
            //
            Buffers[i].pvBuffer   = NULL;
            Buffers[i].cbBuffer   = 0;
            Buffers[i].BufferType = SECBUFFER_EMPTY;
            }

        Buffer.cBuffers = 4; // the 4 buffers are: header, data, trailer, extra
        Buffer.pBuffers = Buffers;
        Buffer.ulVersion = SECBUFFER_VERSION;

        //
        // Decrypt the DATA !!!
        //
        scRet = g_UnsealMessage(phContext, &Buffer, 0, NULL);
        DOUTL(128, "UnsealMessage returned [%x]", scRet);
        if (scRet != ERROR_SUCCESS)
            {
            DOUTL(2, "UnsealMessage failed with [%x]", scRet);
            Assert(scRet != SEC_E_MESSAGE_ALTERED);
            if (scRet == SEC_E_INCOMPLETE_MESSAGE)
                DOUTL(2, "UnsealMessage short of %d bytes.", Buffers[1].cbBuffer);
            break;
            }
    
        //
        // Success we decrypted a block
        //
        if (Buffers[1].cbBuffer)
            {
            MoveMemory(pszBufIn + cbOut, Buffers[1].pvBuffer, Buffers[1].cbBuffer);
            cbOut += Buffers[1].cbBuffer;
            Assert(cbOut <= cbBufIn);
            }
        else
            AssertSz(0, "UnsealMessage returned success with 0 bytes!");

        //
        // BUGBUG [arthurbi] this is hack to work with the OLD SSLSSPI.DLL .
        //  They return extra on the second buffer instead of the third.
        //
        if (Buffers[2].BufferType == SECBUFFER_EXTRA)
            {
            cbEaten = cbBufIn - Buffers[2].cbBuffer;
            }
        else if (Buffers[3].BufferType == SECBUFFER_EXTRA)
            {
            cbEaten = cbBufIn - Buffers[3].cbBuffer;
            }
        else
            {
            cbEaten = cbBufIn;
            }
        }

    // if we decrypted something, return success
    if (scRet == SEC_E_INCOMPLETE_MESSAGE && cbOut)
        scRet = ERROR_SUCCESS;

    *pcbBufOut = cbOut;
    *pcbEaten = cbEaten;
    return scRet;
}

/////////////////////////////////////////////////////////////////////////////
//
// ChkCertificateTrust()
//
// Description:
//  This function checks the server certificate stored in an active SSPI Context
//  Handle and verifies that it and the certificate chain is valid.
//  
// Parameters:
//  phContext   - security context handle returned from InitiateSecConnection
//  pszHostName - passed in hostname to validate against
//
HRESULT ChkCertificateTrust(IN PCtxtHandle phContext, IN LPSTR pszHostName)
{
    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD           dwErr;
    HKEY            hkey;
    DWORD           dwCertFlags = 0;
    BOOL            fCheckRevocation = FALSE;
    HRESULT         hr = NOERROR;

    dwErr = g_QueryContextAttributes(phContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     (PVOID)&pCertContext);
    if (dwErr != ERROR_SUCCESS)
        {
        DOUTL(2, "QueryContextAttributes failed to retrieve remote cert, returned %#x", dwErr);
        hr = E_FAIL;
        goto quit;
        }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_READ, &hkey))
    {
        DWORD dwVal, cb;

        cb = sizeof(dwVal);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szCertCheckRevocation, 0, NULL, (LPBYTE)&dwVal, &cb))
        {
            // if set then we want to perform revocation checking of the cert chain
            if (dwVal == 1)
                fCheckRevocation = TRUE;
        }
        cb = sizeof(dwVal);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szCertIgnoredErr, 0, NULL, (LPBYTE)&dwVal, &cb))
        {
            // if set then set the certification checking errors to ignore
            dwCertFlags = dwVal;
        }

        RegCloseKey(hkey);
    }

    hr = VerifyServerCertificate(pCertContext, pszHostName, dwCertFlags, fCheckRevocation);

quit:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    return hr;
}

DWORD
VerifyServerCertificate(
    PCCERT_CONTEXT  pServerCert,
    LPSTR           pszServerName,
    DWORD           dwCertFlags,
    BOOL            fCheckRevocation)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;

    DWORD   Status;
    LPWSTR  pwszServerName;
    DWORD   cchServerName;

    if (pServerCert == NULL)
        return SEC_E_WRONG_PRINCIPAL;

    //
    // Convert server name to unicode.
    //
    if (pszServerName == NULL || strlen(pszServerName) == 0)
        return SEC_E_WRONG_PRINCIPAL;

    pwszServerName = PszToUnicode(CP_ACP, pszServerName);
    if (pwszServerName == NULL)
        return SEC_E_INSUFFICIENT_MEMORY;

    //
    // Build certificate chain.
    //
    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    if(!CertGetCertificateChain(
                            NULL,
                            pServerCert,
                            NULL,
                            pServerCert->hCertStore,
                            &ChainPara,
                            (fCheckRevocation?CERT_CHAIN_REVOCATION_CHECK_CHAIN:0),
                            NULL,
                            &pChainContext))
    {
        Status = GetLastError();
        DOUTL(2, "Error 0x%x returned by CertGetCertificateChain!\n", Status);
        goto cleanup;
    }

    //
    // Validate certificate chain.
    // 
    ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = dwCertFlags;
    polHttps.pwszServerName     = pwszServerName;

    ZeroMemory(&PolicyPara, sizeof(PolicyPara));
    PolicyPara.cbSize            = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &polHttps;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if(!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_SSL,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus))
    {
        Status = GetLastError();
        DOUTL(2, "Error 0x%x returned by CertVerifyCertificateChainPolicy!\n", Status);
        goto cleanup;
    }

    if(PolicyStatus.dwError)
    {
        Status = PolicyStatus.dwError;
        goto cleanup;
    }

    Status = SEC_E_OK;

cleanup:
    if(pChainContext)
        CertFreeCertificateChain(pChainContext);

    SafeMemFree(pwszServerName);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\icdebug.h ===
// --------------------------------------------------------------------------------
// ICDEBUG.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __ICDEBUG_H
#define __ICDEBUG_H

#define APP_DOUTL         0x00000008

#endif // __ICDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\exrwlck.h ===
#ifndef	_CEXRWLCK_H
#define	_CEXRWLCK_H
                        
#include	<limits.h>


#ifndef WIN16


//
// This class contains the meat - does actual locking etc...
//
class	CExShareLock {
private : 
    long	cReadLock ;			// Number of Readers who have passed through the lock OR 
                                // the number of readers waiting for the lock (will be negative).
                                // A value of 0 means nobody in the lock
    long	cOutRdrs ;			// The number of readers remainin in the lock if 
                                // there is a writer waiting.  This can become temporarily negative
    CRITICAL_SECTION	critWriters ; 	// Critical section to allow only one writer into the lock at a time
    HANDLE	hWaitingWriters ;	// Semaphore for waiting writers to block on (Only 1 ever, others will 
                                // be queued on critWriters)
    HANDLE	hWaitingReaders ;	// Semaphore for waiting readers to block on 
public : 
    CExShareLock( ) ;
    ~CExShareLock( ) ;

    void	ShareLock( ) ;
    void	ShareUnlock( ) ;
    void	ExclusiveLock( ) ;
    void	ExclusiveUnlock( ) ;

    BOOL	SharedToExclusive( ) ;	// returns TRUE if successful
} ;



//
// This class implements a wrapper class around CExShareLock class so that
// it alows the nested hold on Exclusive lock if a thread
// has an exclusive lock and calls for holding exclusive lock or Share lock
// again
//
class    CExShareLockWithNestAllowed 
{
private : 
    CExShareLock  m_lock;                 // class around which the wrapper is formed
    DWORD         m_dwThreadID;           // The thread id of the thred currently holding
                                          //  the exclusive lock
    DWORD         m_dwNestCount;          // The count of number of nested calls to lock by the thread holding the
                                          // exclusive lock less 1

public : 
    
    CExShareLockWithNestAllowed( ) : m_dwThreadID(0xffffffff), m_dwNestCount(0)
    {
        // nothing
    };
    ~CExShareLockWithNestAllowed( )
    {
        Assert( (m_dwThreadID == 0xffffffff ) && ( m_dwNestCount == 0 ) );
    } 

    void    ShareLock( )
    {
        if(! nest() ) 
        {
            m_lock.ShareLock();
        }
    }

    void    ShareUnlock( )
    {
        if (! unnest() ) 
        {
            m_lock.ShareUnlock();
        }
    }

    void    ExclusiveLock( )
    {
        if(! nest() ) 
        {
            m_lock.ExclusiveLock();
            Assert( m_dwNestCount == 0 );
            Assert( m_dwThreadID == 0xffffffff );
            m_dwThreadID = GetCurrentThreadId();
        }
    }

    void    ExclusiveUnlock( )
    {
        if (! unnest() ) 
        {
            m_dwThreadID = 0xffffffff;
            m_lock.ExclusiveUnlock();
        }
    }

protected :
    BOOL nest() 
    {
        if( m_dwThreadID != GetCurrentThreadId() )
            return ( FALSE );
        m_dwNestCount++;
        return( TRUE );
    }
    
    BOOL unnest()
    {
        if ( ! m_dwNestCount ) 
            return ( FALSE );
        Assert( m_dwThreadID == GetCurrentThreadId() );
        m_dwNestCount--;
        return( TRUE);
    }
};



#else


class CExShareLock {
    public:
        CExShareLock() {
            InitializeCriticalSection(&m_cs);
        };
        ~CExShareLock() {
            DeleteCriticalSection(&m_cs);
        };
        void ShareLock(){
            EnterCriticalSection(&m_cs);
        };
        void ShareUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        void ExclusiveLock(){
            EnterCriticalSection(&m_cs);
        };
        void ExclusiveUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        BOOL SharedToExclusive() {
            return (TRUE);
        };
    private:
        CRITICAL_SECTION	m_cs;


};

class CExShareLockWithNestAllowed {
    public:
        CExShareLockWithNestAllowed() {
            InitializeCriticalSection(&m_cs);
        };
        ~CExShareLockWithNestAllowed() {
            DeleteCriticalSection(&m_cs);
        };
        void ShareLock(){
            EnterCriticalSection(&m_cs);
        };
        void ShareUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        void ExclusiveLock(){
            EnterCriticalSection(&m_cs);
        };
        void ExclusiveUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        
    private:
        CRITICAL_SECTION	m_cs;


};


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\icoint.h ===
// --------------------------------------------------------------------------------
// Icoint.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __ICOINT_H
#define __ICOINT_H

// --------------------------------------------------------------------------------
// Some Basic Function Definitions
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFDLLREGSERVER)(void);
typedef HRESULT (APIENTRY *PFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);

// --------------------------------------------------------------------------------
// Int64 Macros
// --------------------------------------------------------------------------------
#ifdef MAC
#define ULISET32(_pint64, _value)              ULISet32((* _pint64), (_value))
#define LISET32(_pint64, _value)               LISet32((* _pint64), (_value))
#define INT64SET(_pint64, _value)              ULISet32((* _pint64), (_value))
#define INT64INC(_pint64, _value)              BuildBreak
#define INT64DEC(_pint64, _value)              BuildBreak
#define INT64GET(_pint64)                      BuildBreak
#else   // !MAC
#define ULISET32(_pint64, _value)              ((_pint64)->QuadPart =  _value)
#define LISET32(_pint64, _value)               ((_pint64)->QuadPart =  _value)
#define INT64SET(_pint64, _value)              ((_pint64)->QuadPart =  _value)
#define INT64INC(_pint64, _value)              ((_pint64)->QuadPart += _value)
#define INT64DEC(_pint64, _value)              ((_pint64)->QuadPart -= _value)
#define INT64GET(_pint64)                      ((_pint64)->QuadPart)
#endif  // MAC

#endif // __ICOINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\icutil.h ===
#pragma once

/* ---------------------------------------------------------------------------
   ICUTILS.H
   ---------------------------------------------------------------------------
   Copyright (c) 1999 Microsoft Corporation
 
   Miscellaneous functions shared between inetcomm libs.
   --------------------------------------------------------------------------- 
*/

BOOL GetTextExtentPoint32AthW(HDC hdc, LPCWSTR lpwString, int cchString, LPSIZE lpSize, DWORD dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#define INITGUID
#include <initguid.h>
#include <ole2.h>
#include "mimeole.h"
#ifdef WIN16
#include <olectlid.h>           // IID_IPersistStreamInit
#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef _RESOURCE_H
#define _RESOURCE_H


/////////////////////////////////////////////////////////////////////////////
//
//  * * * RESOURCE NAMING CONVENTIONS * * *
//
/////////////////////////////////////////////////////////////////////////////
//
//  Resource Type       Prefix      Comments
//  -------------       ------      --------
//
//  String              ids         menu help strings should end in MH
//  Menu command        idm
//  Menu resource       idmr
//  Bitmap              idb
//  Icon                idi
//  Animation           idan
//  Dialog              idd
//  Dialog control      idc
//  Cursor              idcur
//  Raw RCDATA          idr
//  Accelerator         idac
//  Window              idw
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------------
// Types
// --------------------------------------------------------------------------------
#define RT_FILE                         2110

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN String Resource IDs
//
#define IDS_FIRST                       100

#define IDS_APPNAME                     (IDS_FIRST + 1)
#define IDS_MULTIPARTPROLOG             (IDS_FIRST + 2)
#define IDS_FROM                        (IDS_FIRST + 3)
#define IDS_TO                          (IDS_FIRST + 4)
#define IDS_CC                          (IDS_FIRST + 5)
#define IDS_SUBJECT                     (IDS_FIRST + 6)
#define IDS_DATE                        (IDS_FIRST + 7)
#define IDS_UNKNOWN_ALG                 (IDS_FIRST + 8)

// IMNXPORT Errors
#define idsHostNotFoundFmt              (IDS_FIRST + 1000)
#define idsFailedToConnect              (IDS_FIRST + 1001)
#define idsFailedToConnectSecurely      (IDS_FIRST + 1002)
#define idsUnexpectedTermination        (IDS_FIRST + 1003)
#define idsNlogIConnect                 (IDS_FIRST + 1004)
#define idsNegotiatingSSL               (IDS_FIRST + 1005)
#define idsErrConnLookup                (IDS_FIRST + 1006)
#define idsErrConnSelect                (IDS_FIRST + 1007)
#define idsNlogErrConnError             (IDS_FIRST + 1008)
#define idsNlogErrConnClosed            (IDS_FIRST + 1009)
#define idsNotConnected                 (IDS_FIRST + 1010)
#define idsReconnecting                 (IDS_FIRST + 1011)
#define idsFindingHost                  (IDS_FIRST + 1012)
#define idsFoundHost                    (IDS_FIRST + 1013)
#define idsConnecting                   (IDS_FIRST + 1014)
#define idsConnected                    (IDS_FIRST + 1015)
#define idsSecuring                     (IDS_FIRST + 1016)
#define idsInvalidCertCN                (IDS_FIRST + 1017)
#define idsInvalidCertDate              (IDS_FIRST + 1018)
#define idsInvalidCert                  (IDS_FIRST + 1019)
#define idsSecurityErr                  (IDS_FIRST + 1020)
#define idsIgnoreSecureErr              (IDS_FIRST + 1021)
#define idsErrPeerClosed                (IDS_FIRST + 1022)
#define idsSvrRefusesConnection         (IDS_FIRST + 1023)
#define idsUnknownIMAPGreeting          (IDS_FIRST + 1024)
#define idsFailedIMAPCmdSend            (IDS_FIRST + 1025)
#define idsIMAPFailedCapability         (IDS_FIRST + 1026)
#define idsConnectError                 (IDS_FIRST + 1027)
#define idsIMAPSicilyInitFail           (IDS_FIRST + 1029)
#define idsIMAPSicilyPkgFailure         (IDS_FIRST + 1030)
#define idsIMAPAuthNotPossible          (IDS_FIRST + 1031) 
#define idsIMAPOutOfAuthMethods         (IDS_FIRST + 1032)
#define idsIMAPAbortAuth                (IDS_FIRST + 1033)
#define idsGeneral                      (IDS_FIRST + 1034)
#define idsMemory                       (IDS_FIRST + 1035)
#define idsFailedLogin                  (IDS_FIRST + 1036)
#define idsIMAPAuthFailedFmt            (IDS_FIRST + 1037)
#define idsIMAPSocketReadError          (IDS_FIRST + 1038)
#define idsIMAPUnsolicitedBYE           (IDS_FIRST + 1039)
#define idsIMAPCmdNotSent               (IDS_FIRST + 1040)
#define idsIMAPCmdStillPending          (IDS_FIRST + 1041)
#define idsIMAPUIDChanged               (IDS_FIRST + 1042)
#define idsIMAPUIDOrder                 (IDS_FIRST + 1043)
#define idsAppName                      (IDS_FIRST + 1044)
#define idsSaveModifiedObject           (IDS_FIRST + 1045)
#define idsUserTypeApp                  (IDS_FIRST + 1046)
#define idsUserTypeShort                (IDS_FIRST + 1047)
#define idsUserTypeFull                 (IDS_FIRST + 1048)
#define idsInlineImagePlaceHolder       (IDS_FIRST + 1049)
#define idsInlineImageHeader            (IDS_FIRST + 1050)
#define idsPrintHeader                  (IDS_FIRST + 1051)
#define idsPrintFooter                  (IDS_FIRST + 1052)
#define idsFromField                    (IDS_FIRST + 1060)
#define idsNewsgroupsField              (IDS_FIRST + 1061)
#define idsToField                      (IDS_FIRST + 1062)
#define idsCcField                      (IDS_FIRST + 1063)
#define idsDateField                    (IDS_FIRST + 1064)
#define idsSubjectField                 (IDS_FIRST + 1065)
#define idsReplySep                     (IDS_FIRST + 1066)
#define idsReplyTextPrefix              (IDS_FIRST + 1067)
#define idsReplyFont                    (IDS_FIRST + 1068)
#define idsAddToFavorites               (IDS_FIRST + 1069)
#define idsAddToWAB                     (IDS_FIRST + 1070)
#define idsSaveAttachmentAs             (IDS_FIRST + 1071)
#define idsFilterAttSave                (IDS_FIRST + 1072)
#define idsAttachTitleBegin             (IDS_FIRST + 1073)
#define idsImagesOnly                   (IDS_FIRST + 1074)
// Options Spelling dialog strings
#define idsSpellClose                   (IDS_FIRST + 1104)
#define idsSpellCaption                 (IDS_FIRST + 1105)
#define idsSpellRepeatWord              (IDS_FIRST + 1106)
#define idsSpellWordNeedsCap            (IDS_FIRST + 1107)
#define idsSpellWordNotFound            (IDS_FIRST + 1108)
#define idsSpellNoSuggestions           (IDS_FIRST + 1109)
#define idsSpellDelete                  (IDS_FIRST + 1110)
#define idsSpellDeleteAll               (IDS_FIRST + 1111)
#define idsSpellChange                  (IDS_FIRST + 1112)
#define idsSpellChangeAll               (IDS_FIRST + 1113)
#define idsSpellMsgDone                 (IDS_FIRST + 1114)
#define idsSpellMsgContinue             (IDS_FIRST + 1115)
#define idsSpellMsgConfirm              (IDS_FIRST + 1116)
#define idsSpellMsgSendOK               (IDS_FIRST + 1117)
#define idsErrSpellGenericSpell         (IDS_FIRST + 1118)
#define idsErrSpellGenericLoad          (IDS_FIRST + 1119)
#define idsErrSpellMainDictLoad         (IDS_FIRST + 1120)
#define idsErrSpellVersion              (IDS_FIRST + 1121)
#define idsErrSpellUserDictLoad         (IDS_FIRST + 1122)
#define idsErrSpellUserDictOpenRO       (IDS_FIRST + 1123)
#define idsErrSpellCacheWordLen         (IDS_FIRST + 1124)
#define idsPrefixReply                  (IDS_FIRST + 1125)
#define idsPrefixForward                (IDS_FIRST + 1126)
#define idsErrCannotOpenMailMsg         (IDS_FIRST + 1127)
#define idsErrSpellLangChanged          (IDS_FIRST + 1129)
#define idsErrSpellWarnDictionary       (IDS_FIRST + 1130)

#define idsTTFormattingFont             (IDS_FIRST + 1137)
#define idsTTFormattingSize             (IDS_FIRST + 1138)

#define idsFontSize0                    (IDS_FIRST + 1140)
#define idsFontSize1                    (IDS_FIRST + 1141)
#define idsFontSize2                    (IDS_FIRST + 1142)
#define idsFontSize3                    (IDS_FIRST + 1143)
#define idsFontSize4                    (IDS_FIRST + 1144)
#define idsFontSize5                    (IDS_FIRST + 1145)
#define idsFontSize6                    (IDS_FIRST + 1146)
#define idsFontCacheError               (IDS_FIRST + 1147)

#define idsAutoColor                    (IDS_FIRST + 1150)
#define idsColor1                       (IDS_FIRST + 1151)
#define idsColor2                       (IDS_FIRST + 1152)
#define idsColor3                       (IDS_FIRST + 1153)
#define idsColor4                       (IDS_FIRST + 1154)
#define idsColor5                       (IDS_FIRST + 1155)
#define idsColor6                       (IDS_FIRST + 1156)
#define idsColor7                       (IDS_FIRST + 1157)
#define idsColor8                       (IDS_FIRST + 1158)
#define idsColor9                       (IDS_FIRST + 1159)
#define idsColor10                      (IDS_FIRST + 1160)
#define idsColor11                      (IDS_FIRST + 1161)
#define idsColor12                      (IDS_FIRST + 1162)
#define idsColor13                      (IDS_FIRST + 1163)
#define idsColor14                      (IDS_FIRST + 1164)
#define idsColor15                      (IDS_FIRST + 1165)
#define idsColor16                      (IDS_FIRST + 1166)
#define idsTextOrHtmlFileFilter         (IDS_FIRST + 1167)
#define idsTextFileFilter               (IDS_FIRST + 1168)
#define idsDefTextExt                   (IDS_FIRST + 1169)
#define idsInsertTextTitle              (IDS_FIRST + 1170)
#define idsSaveAsStationery             (IDS_FIRST + 1171)
#define idsHtmlFileFilter               (IDS_FIRST + 1172)
#define idsWarnFileExist                (IDS_FIRST + 1173)
#define idsWarnBoringStationery         (IDS_FIRST + 1174)
#define idsOpenAttachControl            (IDS_FIRST + 1175)
#define idsSaveAttachControl            (IDS_FIRST + 1176)
#define idsBtnBarTTList                 (IDS_FIRST + 1177)
#define idsErrFolderInvalid             (IDS_FIRST + 1178)
#define idsSaveAttachments              (IDS_FIRST + 1179)
#define idsErrOneOrMoreAttachSaveFailed (IDS_FIRST + 1180)
#define idsFileExistWarning             (IDS_FIRST + 1181)
#define idsPickAtachDir                 (IDS_FIRST + 1182)
#define idsSaveAllAttach                (IDS_FIRST + 1183)
#define idsSaveAllAttachMH              (IDS_FIRST + 1184)
#define idsBgSound                      (IDS_FIRST + 1185)
#define idsErrBgSoundFileBad            (IDS_FIRST + 1186)
#define idsFilterAudio                  (IDS_FIRST + 1187)
#define idsPickBGSound                  (IDS_FIRST + 1188)
#define idsErrBgSoundLoopRange          (IDS_FIRST + 1189)
#define idsEditTab                      (IDS_FIRST + 1190)      // reorder and die
#define idsHTMLTab                      (IDS_FIRST + 1191)      // reorder and die
#define idsPreviewTab                   (IDS_FIRST + 1192)      // reorder and die
#define idsSearchHLink                  (IDS_FIRST + 1193)
#define idsSearchHLinkPC                (IDS_FIRST + 1194)
#define idsErrInsertFileHasFrames       (IDS_FIRST + 1195)
#define idsAttachField                  (IDS_FIRST + 1196)
#define idsPrintTable_UserName          (IDS_FIRST + 1197)
#define idsPrintTable_Header            (IDS_FIRST + 1198)
#define idsPrintTable_HeaderRow         (IDS_FIRST + 1199)
#define idsReplyHeader_Html_SepBlock    (IDS_FIRST + 1200)
#define idsReplyHeader_SepBlock         (IDS_FIRST + 1201)
#define idsColorSourcePC                (IDS_FIRST + 1202)

#define TT_BASE                         (IDM_LAST + 1)

//
// END String Resource IDs
//
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Menu Resource IDs
//

#define idmrCtxtEditMode                1
#define idmrCtxtBrowseMode              2
#define idmrCtxtSpellSuggest            3
#define idmrCtxtViewSrc                 4

//
// END Menu Resource IDs
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Command IDs
//

#define IDM_FIRST               100

#define idmCut                  (IDM_FIRST +  1)
#define idmCopy                 (IDM_FIRST +  2)
#define idmPaste                (IDM_FIRST +  3)
#define idmSelectAll            (IDM_FIRST +  5)
#define idmUndo                 (IDM_FIRST +  6)
#define idmRedo                 (IDM_FIRST +  7)
#define idmFindText             (IDM_FIRST +  8)
#define idmTab                  (IDM_FIRST +  9)

#define idmProperties           (IDM_FIRST + 20)
#define idmSavePicture          (IDM_FIRST + 21)
#define idmSaveBackground       (IDM_FIRST + 22)
#define idmPopupFmtAlign        (IDM_FIRST + 23)
#define idmAddToFavorites       (IDM_FIRST + 24)
#define idmAddToWAB             (IDM_FIRST + 25)

#define idmFmtFontDlg           (IDM_FIRST + 30)
#define idmFmtLeft              (IDM_FIRST + 31)
#define idmFmtCenter            (IDM_FIRST + 32)
#define idmFmtRight             (IDM_FIRST + 33)
#define idmFmtJustify           (IDM_FIRST + 34)
#define idmFmtNumbers           (IDM_FIRST + 35)
#define idmFmtBullets           (IDM_FIRST + 36)
#define idmFmtIncreaseIndent    (IDM_FIRST + 37)
#define idmFmtDecreaseIndent    (IDM_FIRST + 38)
#define idmFmtBlockDirLTR       (IDM_FIRST + 39)
#define idmFmtBlockDirRTL       (IDM_FIRST + 40)
#define idmFmtBulletsNone       (IDM_FIRST + 41)
#define idmFmtParagraphDlg      (IDM_FIRST + 42)

// formatbar
#define idmFmtFont              (IDM_FIRST + 70)
#define idmFmtSize              (IDM_FIRST + 71)
#define idmFmtColor             (IDM_FIRST + 72)
#define idmFmtColorAuto         (IDM_FIRST + 73)
#define idmFmtColor1            (IDM_FIRST + 74)
#define idmFmtColor2            (IDM_FIRST + 75)
#define idmFmtColor3            (IDM_FIRST + 76)
#define idmFmtColor4            (IDM_FIRST + 77)
#define idmFmtColor5            (IDM_FIRST + 78)
#define idmFmtColor6            (IDM_FIRST + 79)
#define idmFmtColor7            (IDM_FIRST + 80)
#define idmFmtColor8            (IDM_FIRST + 81)
#define idmFmtColor9            (IDM_FIRST + 82)
#define idmFmtColor10           (IDM_FIRST + 83)
#define idmFmtColor11           (IDM_FIRST + 84)
#define idmFmtColor12           (IDM_FIRST + 85)
#define idmFmtColor13           (IDM_FIRST + 86)
#define idmFmtColor14           (IDM_FIRST + 87)
#define idmFmtColor15           (IDM_FIRST + 88)
#define idmFmtColor16           (IDM_FIRST + 89)
#define idmFmtBold              (IDM_FIRST + 90)
#define idmFmtItalic            (IDM_FIRST + 91)
#define idmFmtUnderline         (IDM_FIRST + 92)
#define idmFmtInsertHLine       (IDM_FIRST + 94)
#define idmFmtBkgroundImage     (IDM_FIRST + 95)
#define idmFmtTag               (IDM_FIRST + 96)
#define idmEditLink             (IDM_FIRST + 97)
#define idmInsertImage          (IDM_FIRST + 98)
#define idmUnInsertLink         (IDM_FIRST + 99)

#define idmAccelIncreaseIndent  (IDM_FIRST + 100)
#define idmAccelDecreaseIndent  (IDM_FIRST + 101)
#define idmAccelBullets         (IDM_FIRST + 102)
#define idmAccelLeft            (IDM_FIRST + 103)
#define idmAccelCenter          (IDM_FIRST + 104)
#define idmAccelRight           (IDM_FIRST + 105)
#define idmAccelJustify         (IDM_FIRST + 106)
#define idmBkColorAuto          (IDM_FIRST + 107)
#define idmPaneBadSigning       (IDM_FIRST + 108)
#define idmPaneBadEncryption    (IDM_FIRST + 109)
#define idmPaneSigning          (IDM_FIRST + 110)
#define idmPaneEncryption       (IDM_FIRST + 111)
#define idmPanePaperclip        (IDM_FIRST + 112)
#define idmPaneVCard            (IDM_FIRST + 113)
#define idmSaveAllAttach        (IDM_FIRST + 114)

#define idmSuggest0             (IDM_FIRST + 115)
#define idmSuggest1             (IDM_FIRST + 116)
#define idmSuggest2             (IDM_FIRST + 117)
#define idmSuggest3             (IDM_FIRST + 118)
#define idmSuggest4             (IDM_FIRST + 119)

#define idmIgnore               (IDM_FIRST + 120)
#define idmIgnoreAll            (IDM_FIRST + 121)
#define idmAdd                  (IDM_FIRST + 122)
#define idmCopyShortcut         (IDM_FIRST + 123)
#define idmSaveTargetAs         (IDM_FIRST + 124)
#define idmOpenLink             (IDM_FIRST + 125)

#define IDM_LAST                (IDM_FIRST + 5000)

// reserve 50 id's for format bar style menu
#define idmFmtTagFirst          (IDM_LAST + 1)
#define idmFmtTagLast           (idmFmtTagFirst + 50)


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Templates
//

#define IDD_RASCONNECT                  100
#define iddMsgSource                    101
#define iddSafeOpen                     102
#define iddSpelling                     103
#define iddSaveAttachments              104
#define IDD_NTLMPROMPT                  105
#define iddBackSound                    106
#define iddFormatPara                   107
#define iddCSFormatPara                 108

//
// END Dialog Templates
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Control ID's
//

// iddMsgSource
#define idcTxtSource            100

// Tools.Spelling dialog
#define IDC_STATIC                  -1
#define PSB_Spell_Ignore            101
#define PSB_Spell_IgnoreAll         102
#define PSB_Spell_Change            103
#define PSB_Spell_ChangeAll         104
#define PSB_Spell_Add               105
#define PSB_Spell_Suggest           106
#define PSB_Spell_UndoLast          107
#define EDT_Spell_WrongWord         108
#define TXT_Spell_Error             109
#define PSB_Spell_Options           110
#define TXT_Spell_Suggest           111
#define LBX_Spell_Suggest           112
#define EDT_Spell_ChangeTo          113
#define TXT_Spell_ChangeTo          114
#define CHK_AlwaysSuggest           202
#define CHK_CheckSpellingOnSend     203
#define CHK_IgnoreUppercase         204
#define CHK_IgnoreNumbers           205
#define CHK_IgnoreDBCS              206
#define CHK_IgnoreOriginalMessage   207
#define CHK_IgnoreURL               208
#define idcSpellLanguages           209
#define idcViewDictionary           210
#define GRP_SpellOptions            511
#define GRP_SpellIgnore             512
#define idcFmtBar                   600
#define idcBtnBar                   601
#define idcSelectAllAttBtn          700
#define idcAttachList               701
#define idcPathEdit                 702
#define idcBrowseBtn                703
#define IDE_USERNAME                705
#define IDE_PASSWORD                706
#define IDE_DOMAIN                  707
#define IDC_SPIN1                   708
#define IDC_STATIC1                 750
#define IDC_STATIC2                 751
#define IDC_STATIC3                 752
#define IDC_STATIC4                 753

// iddNext

// iddBackgroundSound

#define ideSoundLoc                 800
#define idbtnBrowseSound            801
#define idrbPlayNTimes              802
#define idePlayCount                803
#define idrbPlayInfinite            804

//
// END Control ID's
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap ID's
//

#define idbFormatBar                    1
#define idbFormatBarFont                2
#define idbPaneBar32                    3
#define idbPaneBar32Hot                 4
#define idbFormatBarHot                 5

//
// END Bitmap ID's
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap indicies
//
enum {    
    itbEncryption,
    itbSigning,
    itbBadEnc,
    itbBadSign,
    itbPaperclip,
    itbVCard,
    };

//
// END Bitmap indicies
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Icon ID's

#define idiDefaultAtt                   1
#define idiSound                        2

//
// END Icon ID's
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN ACCEL ID's

#define idacSrcView                   1

//
// END ACCEL ID's
//
/////////////////////////////////////////////////////////////////////////////



#endif //RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**	Copyright (C) Microsoft Corp. 1997
*/

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   
#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HMODULE s_hINetComm;

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// INETCOMM.DLL

BOOL DemandLoadINETCOMM(void);

interface IHTMLDocument2;
interface IMimeMessage;

LOADER_FUNCTION( HRESULT, MimeEditViewSource,
    (HWND hwnd, IMimeMessage *pMsg),
    (hwnd, pMsg),
    E_FAIL, INETCOMM)
#define MimeEditViewSource VAR_MimeEditViewSource

LOADER_FUNCTION( HRESULT, MimeEditCreateMimeDocument,
    (IHTMLDocument2 *pDoc, IMimeMessage *pMsgSrc, DWORD dwFlags, IMimeMessage **ppMsg),
    (pDoc, pMsgSrc, dwFlags, ppMsg),
    E_FAIL, INETCOMM)
#define MimeEditCreateMimeDocument VAR_MimeEditCreateMimeDocument
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\dochost.cpp ===
/*
 *    d o c h o s t . c p p
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include "pch.hxx"
#include <resource.h>
#include "globals.h"
#include "dochost.h"




/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

static CHAR c_szDocHostWndClass[] = "MEPAD_DocHost";
/*
 *  t y p e d e f s
 */

/*
 *  g l o b a l s 
 */

/*
 *  f u n c t i o n   p r o t y p e s
 */

/*
 *  f u n c t i o n s
 */

HRESULT HrInitNew(LPUNKNOWN pUnk)
{
    LPPERSISTSTREAMINIT ppsi=0;
    HRESULT hr;

    if (!pUnk)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi);
    if (FAILED(hr))
        goto error;

    hr = ppsi->InitNew();

error:
    ReleaseObj(ppsi);
    return hr;
}


CDocHost::CDocHost()
{
/*
    Not initialised
    Member:                 Initialised In:
    --------------------+---------------------------
*/
    m_cRef=1;
    m_hwnd=0;
    m_pDocView=0;
    m_lpOleObj=0;
    m_pCmdTarget=0;
    m_ulAdviseConnection=0;
    m_hwndDocObj=NULL;
    m_fUIActive=FALSE;
    m_fFocus=FALSE;
    m_fDownloading=FALSE;
    m_dhbBorder=dhbNone;
    m_fCycleFocus=FALSE;
    m_pInPlaceActiveObj = NULL;
    m_dwFrameWidth = 0;
    m_dwFrameHeight = 0;
	m_pInPlaceFrame =0;
}

CDocHost::~CDocHost()
{
    SafeRelease(m_pInPlaceFrame);
	SafeRelease(m_pCmdTarget);
    SafeRelease(m_lpOleObj);
    SafeRelease(m_pDocView);
    SafeRelease(m_pInPlaceActiveObj);
    HrCloseDocObj();
}

ULONG CDocHost::AddRef()
{
    return ++m_cRef;
}

ULONG CDocHost::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


HRESULT CDocHost::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(LPUNKNOWN)(LPOLEINPLACEFRAME)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *lplpObj = (LPVOID)(LPOLEINPLACESITE)this;

    else if (IsEqualIID(riid, IID_IOleClientSite))
        *lplpObj = (LPVOID)(LPOLECLIENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleControlSite))
        *lplpObj = (LPVOID)(IOleControlSite *)this;

    else if (IsEqualIID(riid, IID_IAdviseSink))
        *lplpObj = (LPVOID)(LPADVISESINK)this;

    else if (IsEqualIID(riid, IID_IOleDocumentSite))
        *lplpObj = (LPVOID)(LPOLEDOCUMENTSITE)this;

    // BUG BUGB
    // I don't think we need to provide this, here for debugging for now
    // brettm
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(LPSERVICEPROVIDER)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



LRESULT CALLBACK CDocHost::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPDOCHOST pDocHost;

    if(msg==WM_CREATE)
        {
        pDocHost=(CDocHost *)((LPMDICREATESTRUCT)((LPCREATESTRUCT)lParam)->lpCreateParams)->lParam;
        if(!pDocHost)
            return -1;

        if(!pDocHost->WMCreate(hwnd))
            return -1;
        }
    
    pDocHost = (LPDOCHOST)GetWndThisPtr(hwnd);
    if(pDocHost)
        return pDocHost->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefMDIChildProc(hwnd, msg, wParam, lParam);
}

LRESULT CDocHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
        {
        case WM_MDIACTIVATE:
			// if lParam is our HWND we're being activated, else deactivated
			if (m_pInPlaceActiveObj)
				m_pInPlaceActiveObj->OnDocWindowActivate((HWND)lParam == m_hwnd);
			break;

		case WM_DESTROY:
            HrCloseDocObj();
            break;

        case WM_SETFOCUS:
            if(m_pDocView)
                m_pDocView->UIActivate(TRUE);
            break;

        case WM_SIZE:
            WMSize(LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_NCDESTROY:
            WMNCDestroy();
            break;

        }
    return DefMDIChildProc(hwnd, msg, wParam, lParam);
}

void CDocHost::WMNCDestroy()
{
    SetWindowLong(m_hwnd, GWL_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
}


BOOL CDocHost::WMCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    SetWindowLong(hwnd, GWL_USERDATA, (LPARAM)this);
    AddRef();

    return SUCCEEDED(HrSubWMCreate())?TRUE:FALSE;
}


HRESULT CDocHost::HrCreateDocObj(LPCLSID pCLSID)
{
    HRESULT             hr=NOERROR;

    if(!pCLSID)
        return E_INVALIDARG;


    hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                        IID_IOleObject, (LPVOID *)&m_lpOleObj);

    if (FAILED(hr))
        {
        MessageBox(m_hwnd, "MEPAD", "Failed to create DocObj", MB_OK);
        goto error;
        }

    hr = m_lpOleObj->SetClientSite((LPOLECLIENTSITE)this);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->Advise((LPADVISESINK)this, &m_ulAdviseConnection);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pCmdTarget);
    if (FAILED(hr))  
        goto error;  

    hr = HrInitNew(m_lpOleObj);
    if (FAILED(hr))  
        goto error;  

error:
    return hr;
}


HRESULT CDocHost::HrShow()
{
    RECT                rc;
    HRESULT             hr;

    GetClientRect(m_hwnd, &rc);
    HrGetDocObjSize(&rc);
  
    hr=m_lpOleObj->DoVerb(OLEIVERB_SHOW, NULL, (LPOLECLIENTSITE)this, 0, m_hwnd, &rc);
    if(FAILED(hr))
        goto error;

	ShowWindow(m_hwnd, SW_SHOW);

error:
    return hr;
}



HRESULT CDocHost::HrCloseDocObj()
{
    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    SafeRelease(m_pInPlaceFrame);
	SafeRelease(m_pCmdTarget);
    SafeRelease(m_pInPlaceActiveObj);

    if(m_pDocView)
        {
        m_pDocView->UIActivate(FALSE);
        m_pDocView->CloseView(0);
        m_pDocView->SetInPlaceSite(NULL);
        SafeRelease(m_pDocView);
        }

    if (m_lpOleObj)
        {
        if (m_ulAdviseConnection)
            {
            m_lpOleObj->Unadvise(m_ulAdviseConnection);
            m_ulAdviseConnection=NULL;
            }

        // deactivate the docobj. mshtml seems more sensitive to this than Trident.
        if (!FAILED(m_lpOleObj->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&pInPlaceObj)))
            {
            pInPlaceObj->InPlaceDeactivate();
            pInPlaceObj->Release();
            }
        
        // close the ole object, but blow off changes as we have either extracted 
        // them ourselves or don't care.
        m_lpOleObj->Close(OLECLOSE_NOSAVE);
#ifdef DEBUG
        ULONG   uRef;
        uRef=
#endif
        m_lpOleObj->Release();
        m_lpOleObj=NULL;
        }

    m_fDownloading=FALSE;
    m_fFocus=FALSE;
    m_fUIActive=FALSE;
    return NOERROR;
}

 
HRESULT CDocHost::HrInit(HWND hwndParent, int idDlgItem, DWORD dhbBorder)
{
    HRESULT hr=S_OK;
    HWND    hwnd;
    WNDCLASS    wc={0};

    if(!IsWindow(hwndParent))
        return E_INVALIDARG;

    m_dhbBorder=dhbBorder;

    if (!GetClassInfo(g_hInst, c_szDocHostWndClass, &wc))
        {
        wc.lpfnWndProc   = (WNDPROC)CDocHost::ExtWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_szDocHostWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(idiApp));
        wc.style = CS_DBLCLKS;

        if(!RegisterClass(&wc))
            return E_OUTOFMEMORY;

        }

    hwnd = CreateMDIWindow(
                c_szDocHostWndClass, 
                "MimeEdit Host", 
                MDIS_ALLCHILDSTYLES|
                WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_MAXIMIZEBOX|WS_CAPTION|WS_SYSMENU|WS_THICKFRAME,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                hwndParent,
                g_hInst,
                (LONG)this);

    if(!hwnd)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

error:
    return hr;
}




// *** IOleWindow methods ***
HRESULT CDocHost::GetWindow(HWND *phwnd)
{
    *phwnd=m_hwnd;
    return NOERROR;
}

HRESULT CDocHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// *** IOleInPlaceUIWindow methods ***
HRESULT CDocHost::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT CDocHost::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    return NOERROR;
}

HRESULT CDocHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return NOERROR;
}

HRESULT CDocHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    
    SafeRelease(m_pInPlaceActiveObj);
    m_pInPlaceActiveObj=pActiveObject;
    if(m_pInPlaceActiveObj)
        m_pInPlaceActiveObj->AddRef();
    return NOERROR;
}

// **** IOleInPlaceSite methods ****
HRESULT CDocHost::CanInPlaceActivate()
{
    return NOERROR;
}

HRESULT CDocHost::OnInPlaceActivate()
{
    LPOLEINPLACEACTIVEOBJECT    pInPlaceActive=0;


    m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pInPlaceActive);
    if(pInPlaceActive)
        {
        pInPlaceActive->GetWindow(&m_hwndDocObj);
        ReleaseObj(pInPlaceActive);
        }
    return NOERROR;
}

HRESULT CDocHost::OnUIActivate()
{
    m_fUIActive=TRUE;
    return NOERROR;
}

HRESULT CDocHost::GetWindowContext(IOleInPlaceFrame **ppFrame,
                                 IOleInPlaceUIWindow **ppDoc,
                                 LPRECT lprcPosRect, 
                                 LPRECT lprcClipRect,
                                 LPOLEINPLACEFRAMEINFO lpFrameInfo)
{

	*ppFrame = (LPOLEINPLACEFRAME)m_pInPlaceFrame;
	m_pInPlaceFrame->AddRef();

    *ppDoc = (IOleInPlaceUIWindow *)this;
	AddRef();

    GetClientRect(m_hwnd, lprcClipRect);
    GetClientRect(m_hwnd, lprcPosRect);
    HrGetDocObjSize(lprcClipRect);
    HrGetDocObjSize(lprcPosRect);
    lpFrameInfo->fMDIApp = FALSE;

    lpFrameInfo->hwndFrame=m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;
    return NOERROR;
}

HRESULT CDocHost::Scroll(SIZE scrollExtent)
{
    // the docobject consumes the entireview, so scroll requests
    // are meaningless. Return NOERROR to indicate that they're scolled
    // into view.
    return NOERROR;
}

HRESULT CDocHost::OnUIDeactivate(BOOL fUndoable)
{
    m_fUIActive=FALSE;
    return S_OK;
}

HRESULT CDocHost::OnInPlaceDeactivate()
{
    return S_OK;
}

HRESULT CDocHost::DiscardUndoState()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::DeactivateAndUndo()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::OnPosRectChange(LPCRECT lprcPosRect)
{
    return E_NOTIMPL;
}


// IOleClientSite methods.
HRESULT CDocHost::SaveObject()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppmnk)
{
    return E_NOTIMPL;
}

HRESULT CDocHost::GetContainer(LPOLECONTAINER *ppCont)
{
    if(ppCont)
        *ppCont=NULL;
    return E_NOINTERFACE;
}


HRESULT CDocHost::ShowObject()
{
    // always shown. 
    // $TODO: do we need to restore the browser here if it is
    // minimised?
    return NOERROR;
}

HRESULT CDocHost::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

HRESULT CDocHost::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}


// IAdviseSink methods
void CDocHost::OnDataChange(FORMATETC *pfetc, STGMEDIUM *pstgmed)
{
}

void CDocHost::OnViewChange(DWORD dwAspect, LONG lIndex)
{
}

void CDocHost::OnRename(LPMONIKER pmk)
{
}

void CDocHost::OnSave()
{
}

void CDocHost::OnClose()
{
}


// IOleDocumentSite
HRESULT CDocHost::ActivateMe(LPOLEDOCUMENTVIEW pViewToActivate)
{

    return HrCreateDocView();
}


HRESULT CDocHost::HrCreateDocView()
{
    HRESULT         hr;
    LPOLEDOCUMENT   pOleDoc=NULL;

    hr=OleRun(m_lpOleObj);
    if(FAILED(hr))
        goto error;
    
    hr=m_lpOleObj->QueryInterface(IID_IOleDocument, (LPVOID*)&pOleDoc);
    if(FAILED(hr))
        goto error;

    hr=pOleDoc->CreateView(this, NULL,0,&m_pDocView);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->SetInPlaceSite(this);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->Show(TRUE);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pOleDoc);
    return hr;
}


HRESULT CDocHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG ul;

    // BUGBUG: Check IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView) as well

    if (!rgCmds)
        return E_INVALIDARG;

    if (pguidCmdGroup == NULL)
        {
        for (ul=0;ul<cCmds; ul++)
            {
            switch (rgCmds[ul].cmdID)
                {
                case OLECMDID_OPEN:
                case OLECMDID_SAVE:
                case OLECMDID_PRINT:
                    rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
                }
            }

        /* for now we deal only with status text*/
        if (pCmdText)
            {
            if (!(pCmdText->cmdtextf & OLECMDTEXTF_STATUS))
                {
                pCmdText->cmdtextf = OLECMDTEXTF_NONE;// is this needed?
                pCmdText->cwActual = 0;
                return NOERROR;
                }
            }
        return NOERROR;
        }

    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CDocHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,	VARIANTARG *pvaOut)
{
    if (pguidCmdGroup == NULL)
        {
        switch(nCmdID)
            {
             case OLECMDID_SETDOWNLOADSTATE:
                if(pvaIn->vt==VT_I4)
                    {
                    m_fDownloading=pvaIn->lVal;
                    return S_OK;
                    }
                break;

            case OLECMDID_UPDATECOMMANDS:
                OnUpdateCommands();
                break;

            case OLECMDID_SETPROGRESSPOS:
                // when done downloading trident now hits us with a 
                // setprogresspos == -1 to indicate we should remove the "Done"
                if (pvaIn->lVal == -1)
                    m_pInPlaceFrame->SetStatusText(NULL);
                return S_OK;

            case OLECMDID_SETPROGRESSTEXT:
                if(pvaIn->vt == (VT_BSTR))
                    m_pInPlaceFrame->SetStatusText((LPCOLESTR)pvaIn->bstrVal);
                return S_OK;
            }
        }
    return OLECMDERR_E_UNKNOWNGROUP;
}

void CDocHost::WMSize(int cxBody, int cyBody)
{
    RECT rc={0};

    if(m_pDocView)
        {
        rc.bottom=cyBody;
        rc.right=cxBody;

        // give the subclass a chance to override the size of the
        // docobj
        HrGetDocObjSize(&rc);
        m_pDocView->SetRect(&rc);
        }

    // notify the subclass of a wmsize
    OnWMSize(&rc);
} 



HRESULT CDocHost::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    return E_UNEXPECTED;
}



HRESULT CDocHost::HrSubWMCreate()
{
    return NOERROR;
}


HRESULT CDocHost::OnControlInfoChanged()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::LockInPlaceActive(BOOL fLock)
{
    return E_NOTIMPL;
}


HRESULT CDocHost::GetExtendedControl(LPDISPATCH *ppDisp)
{
    if (ppDisp)
        *ppDisp=NULL;

    return E_NOTIMPL;
}

HRESULT CDocHost::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
{
    return E_NOTIMPL;
}

/*
 * this is a little trippy, so bear with me. When we get a tab, and trident is UIActive we always pass it off to them
 * if it tabs off the end of its internal tab order (a list of urls for instance) then we get hit with a VK_TAB in our
 * IOleControlSite::TranslateAccel. If so then we set m_fCycleFocus to TRUE and return S_OK to indicate we took the tab
 * tridents IOIPAO::TranslateAccel returns S_OK to indicate it snagged the TAB, we then detect if we set cyclefocus to true
 * there and if so, we return S_FALSE from CBody::HrTranslateAccel to indicate to the browser that we didn't take it and it
 * move the focus on
 *
 */
HRESULT CDocHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
    if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB)
        {
        m_fCycleFocus=TRUE;
        return S_OK;
        }

    return E_NOTIMPL;
}

HRESULT CDocHost::OnFocus(BOOL fGotFocus)
{
    m_fFocus = fGotFocus;
    return S_OK;
}

HRESULT CDocHost::ShowPropertyFrame(void)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\htmlstr.h ===
/*
 * htmlstr.h
 *
 * HTML string constants
 *
 */

#ifndef _HTMLSTR_H
#define _HTMLSTR_H

#if !defined( WIN16 ) || !defined( __WATCOMC__ )

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" CDECL const WORD DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, L##strdata}; \
    extern "C" CDECL BSTR name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y

#else
#define MAKEBSTR(name, count, strdata) extern "C" CDECL LPCWSTR name

#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#else // !WIN16 || !__WATCOMC__

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" const char CDECL DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, strdata}; \
    extern "C" BSTR  CDECL name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y

#else
#define MAKEBSTR(name, count, strdata) extern "C" LPCWSTR CDECL name

#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#endif

#endif // !WIN16 || !__WATCOMC__




STR_GLOBAL(c_szHtml_DivOpen, "<DIV>");
STR_GLOBAL(c_szHtml_DivClose, "</DIV>");

STR_GLOBAL_WIDE(c_wszHtml_DivOpen, "<DIV>");
STR_GLOBAL_WIDE(c_wszHtml_DivClose, "</DIV>");

//STR_GLOBAL(c_szHtml_FontOpen, "<FONT>");
STR_GLOBAL(c_szHtml_FontClose, "</FONT>");

STR_GLOBAL(c_szHtml_BoldOpen, "<B>");
STR_GLOBAL(c_szHtml_BoldClose, "</B>");

//STR_GLOBAL(c_szHtml_UnderlineOpen, "<U>");
//STR_GLOBAL(c_szHtml_UnderlineClose, "</U>");

//STR_GLOBAL(c_szHtml_ItallicOpen, "<I>");
//STR_GLOBAL(c_szHtml_ItallicClose, "</I>");

STR_GLOBAL(c_szHtml_Break, "<BR>");

//fSTR_GLOBAL(c_szHtml_MetaTagf, "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;charset=%s\">\r\n");

STR_GLOBAL(c_szHtml_HtmlOpenCR,     "<HTML>\r\n");
STR_GLOBAL(c_szHtml_HtmlCloseCR,    "</HTML>\r\n");
STR_GLOBAL(c_szHtml_HeadOpenCR,     "<HEAD>\r\n<STYLE>\r\n");
STR_GLOBAL(c_szHtml_HeadCloseCR,    "</STYLE>\r\n</HEAD>\r\n");
STR_GLOBAL(c_szHtml_BodyOpenNbspCR, "<BODY>\r\n&nbsp;");
STR_GLOBAL(c_szHtml_BodyOpenBgCR,   "<BODY BACKGROUND=\"%s\">\r\n&nbsp;\r\n");
STR_GLOBAL(c_szHtml_BodyCloseCR,    "</BODY>\r\n");

MAKEBSTR(c_bstr_AfterBegin,     10, "AfterBegin");
MAKEBSTR(c_bstr_BeforeEnd,      9,  "BeforeEnd");
MAKEBSTR(c_bstr_TabChar,        4,  "\xA0\xA0\xA0\x20");
MAKEBSTR(c_bstr_SRC,            3,  "src");
//MAKEBSTR(c_bstr_HREF,           4,  "HREF");
MAKEBSTR(c_bstr_IMG,            3,  "IMG");
MAKEBSTR(c_bstr_BASE,           4,  "BASE");
MAKEBSTR(c_bstr_OBJECT,         6,  "OBJECT");
MAKEBSTR(c_bstr_STYLE,          5,  "STYLE");
MAKEBSTR(c_bstr_ANCHOR,         1,  "A");
MAKEBSTR(c_bstr_LEFTMARGIN,    10,  "leftmargin");
MAKEBSTR(c_bstr_TOPMARGIN,      9,  "topmargin");

MAKEBSTR(c_bstr_Word,           4,  "Word");
MAKEBSTR(c_bstr_Character,      9,  "Character");
MAKEBSTR(c_bstr_StartToEnd,     10, "StartToEnd");
MAKEBSTR(c_bstr_EndToEnd,       8,  "EndToEnd");
MAKEBSTR(c_bstr_StartToStart,   12, "StartToStart");
MAKEBSTR(c_bstr_EndToStart,     10, "EndToStart");
//MAKEBSTR(c_bstr_ANCHOR,         1,  "A");
MAKEBSTR(c_bstr_BLOCKQUOTE,     10, "BLOCKQUOTE");
MAKEBSTR(c_bstr_1,              1,  "1");
MAKEBSTR(c_bstr_NOSEND,         6,  "NOSEND");
MAKEBSTR(c_bstr_BGSOUND,        7,  "BGSOUND");
MAKEBSTR(c_bstr_BGSOUND_TAG,    9,  "<BGSOUND>");
MAKEBSTR(c_bstr_MonoSpace,      9, "monospace");

#endif //_HTMLSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\demand.cpp ===
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "shlwapi.h"
//#include "shared.h"
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
HMODULE s_hINetComm = 0;

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void FreeDemandLoadedLibs(void)
{
    if (s_hINetComm)
        {
        FreeLibrary(s_hINetComm);
        s_hINetComm=NULL;
        }
}


// --------------------------------------------------------------------------------
// SmartLoadLibrary
// --------------------------------------------------------------------------------
HINSTANCE SmartLoadLibrary(HKEY hKeyRoot, LPCSTR pszRegRoot, LPCSTR pszRegValue,
    LPCSTR pszDllName)
{
    // Locals
    BOOL            fProblem=FALSE;
    HINSTANCE       hInst=NULL;
    HKEY            hKey=NULL, hKey2 = NULL;
    CHAR            szPath[MAX_PATH];
    DWORD           cb=MAX_PATH;
    DWORD           dwT;
    LPSTR           pszPath=szPath;
    CHAR            szT[MAX_PATH];

    // Try to open the regkey
    if (ERROR_SUCCESS != RegOpenKeyEx(hKeyRoot, pszRegRoot, 0, KEY_QUERY_VALUE, &hKey))
        goto exit;

    // Query the Value
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, pszRegValue, 0, &dwT, (LPBYTE)szPath, &cb))
        goto exit;

    // Remove the file name from the path
    PathRemoveFileSpecA(szPath);
    PathAppendA(szPath, pszDllName);

    // Expand Sz ?
    if (REG_EXPAND_SZ == dwT)
    {
        // Expand It
        cb = ExpandEnvironmentStrings(szPath, szT, MAX_PATH);

        // Failure
        if (cb == 0 || cb > MAX_PATH)
        {
            goto exit;
        }

        // Change pszPath
        pszPath = szT;
    }

    // Try to Load Library the Dll
    hInst = LoadLibrary(pszPath);

    // Failure ?
    if (NULL == hInst)
    {
        // If we are not going to try the GetModuleFName, just try the dll name
        hInst = LoadLibrary(pszDllName);

        // We really failed
        if (NULL == hInst)
        {
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return hInst;
}

// --------------------------------------------------------------------------------
// DemandLoadINETCOMM
// --------------------------------------------------------------------------------
BOOL DemandLoadINETCOMM(void)
{
    BOOL                fRet = TRUE;

    if (0 == s_hINetComm)
        {
 
        s_hINetComm = SmartLoadLibrary(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Outlook Express\\Inetcomm", "DllPath", "INETCOMM.DLL");

        if (0 == s_hINetComm)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hINetComm, MimeEditViewSource);
            GET_PROC_ADDR(s_hINetComm, MimeEditCreateMimeDocument);
            }
        }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\dochost.h ===
/*
 *    d o c h o s t . h
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _DOCHOST_H
#define _DOCHOST_H

#include <docobj.h>

// DocHost border sytles
enum
{
    dhbNone     =0x0,   // no border
    dhbHost     =0x01,  // dochost paints border
    dhbObject   =0x02   // docobj paints border
};

class CDocHost:
    public IOleInPlaceUIWindow,
    public IOleInPlaceSite,
    public IOleClientSite,
    public IOleControlSite,
    public IAdviseSink,
    public IOleDocumentSite,
    public IOleCommandTarget,
    public IServiceProvider
{
public:
    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 
    
    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

    // IOleControlSite
    virtual HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
    virtual HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
    virtual HRESULT STDMETHODCALLTYPE GetExtendedControl(LPDISPATCH *ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *lpMsg,DWORD grfModifiers);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    virtual HRESULT STDMETHODCALLTYPE ShowPropertyFrame(void);

    // IAdviseSink methods
    virtual void STDMETHODCALLTYPE OnDataChange(FORMATETC *, STGMEDIUM *);
    virtual void STDMETHODCALLTYPE OnViewChange(DWORD, LONG);
    virtual void STDMETHODCALLTYPE OnRename(LPMONIKER);
    virtual void STDMETHODCALLTYPE OnSave();
    virtual void STDMETHODCALLTYPE OnClose();

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD [], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);


    CDocHost();
    virtual ~CDocHost();
    
    // statics
    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // overridble virtuals
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
    // derrived class notifications
    virtual HRESULT HrSubWMCreate();
    virtual void OnWMSize(LPRECT prc){};
    virtual void OnUpdateCommands(){};
    virtual HRESULT HrGetDocObjSize(LPRECT prc)
        {return E_NOTIMPL;};

    HRESULT HrCreateDocObj(LPCLSID pCLSID);
    HRESULT HrCloseDocObj();

    HRESULT HrInit(HWND hwndParent, int idDlgItem, DWORD dhbBorder);

protected:
    HWND                        m_hwnd,
                                m_hwndDocObj;
    LPOLEOBJECT                 m_lpOleObj;
    LPOLEDOCUMENTVIEW           m_pDocView;
    LPOLECOMMANDTARGET          m_pCmdTarget;
    BOOL                        m_fDownloading,
                                m_fFocus,
                                m_fUIActive,
                                m_fCycleFocus;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
	LPOLEINPLACEFRAME			m_pInPlaceFrame;

    void WMSize(int x, int y);
    HRESULT HrShow();

private:
    ULONG               m_cRef,
                        m_ulAdviseConnection;
    DWORD               m_dwFrameWidth,
                        m_dwFrameHeight,
                        m_dhbBorder;

        

    HRESULT HrCreateDocView();

    BOOL WMCreate(HWND hwnd);
    void WMNCDestroy();

};

typedef CDocHost DOCHOST;
typedef DOCHOST *LPDOCHOST;

#endif //_DOCHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\frame.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "frame.h"
#include "mehost.h"

void SaveFocus(BOOL fActive, HWND *phwnd);

CMDIFrame::CMDIFrame()
{
    m_hwnd = 0;
    m_hToolbar = 0;
    m_hStatusbar = 0;
    m_fToolbar = TRUE;
    m_fStatusbar = TRUE;
    m_cRef = 1;
	m_pInPlaceActiveObj=0;
    m_hwndFocus=0;
}


CMDIFrame::~CMDIFrame()
{
	SafeRelease(m_pInPlaceActiveObj);
}


ULONG CMDIFrame::AddRef()
{
    return ++m_cRef;
}

ULONG CMDIFrame::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CMDIFrame::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IOleInPlaceFrame))
        *lplpObj = (LPVOID)(LPOLEINPLACEFRAME)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *lplpObj = (LPVOID)(IOleInPlaceUIWindow *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}


HRESULT CMDIFrame::HrInit(LPSTR pszCmdLine)
{
    static char szAppName[] = "Mepad";
    HWND        hwnd = NULL;
    WNDCLASSEX  wndclass;
    HRESULT     hr=E_FAIL;

    wndclass.cbSize        = sizeof(wndclass);
    wndclass.style         = 0;
    wndclass.lpfnWndProc   = (WNDPROC)CMDIFrame::ExtWndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = g_hInst;
    wndclass.hIcon         = LoadIcon(g_hInst, MAKEINTRESOURCE(idiApp));
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName  = MAKEINTRESOURCE(idmrMainMenu);
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm       = LoadIcon(g_hInst, MAKEINTRESOURCE(idiApp));

    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT,
                    szAppName,
                    "Mepad",
                    WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN,
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hInst, (LPVOID)this);

    if(!hwnd)
        goto error;

    ShowWindow(hwnd, SW_SHOWNORMAL);
    UpdateWindow(hwnd);
    hr = NOERROR;

    if (pszCmdLine)
        hr = OpenDoc(pszCmdLine);

error:
    return hr;
}


LRESULT CALLBACK CMDIFrame::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMDIFrame *pFrame=0;

    if(msg==WM_CREATE)
    {
        pFrame=(CMDIFrame *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(pFrame && pFrame->WMCreate(hwnd))
            return 0;
        else
            return -1;
    }

    pFrame = (CMDIFrame *)GetWindowLong(hwnd, GWL_USERDATA);
    if(pFrame)
        return pFrame->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

enum 
{
    itbNew,
    itbOpen,
    itbSave,
    itbBack,
    itbForward,
    itbPrint,
    itbAbout,
    itbEditDoc,
    ctbToolbar
};

#define cxButtonSep 8
#define dxToolbar           16
#define dxStatusbar         14

static TBBUTTON rgtbbutton[] =
{
    { itbNew, idmNew,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbOpen, idmOpen,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbSave, idmSave,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbEditDoc, idmEditDocument,
            TBSTATE_ENABLED, TBSTYLE_BUTTON|TBSTYLE_CHECK, {0}, 0L, -1 }

};

#define ctbbutton           (sizeof(rgtbbutton) / sizeof(TBBUTTON))

BOOL CMDIFrame::WMCreate(HWND hwnd)
{
    HMENU           hMenu;
    MENUITEMINFO    mii;
    
    hMenu = GetMenu(hwnd);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    GetMenuItemInfo(hMenu, idmPopupWindow, FALSE, &mii);

    SetWindowLong(hwnd, GWL_USERDATA, (LONG)this);
    AddRef();
    m_hwnd=hwnd;

    // toolbar
    m_hToolbar = CreateToolbarEx(
        hwnd,
        WS_CLIPCHILDREN|WS_CHILD|TBSTYLE_TOOLTIPS|WS_VISIBLE|WS_BORDER,
        0, 
        ctbToolbar,
        g_hInst,
        idbToolbar,
        rgtbbutton, ctbbutton, 
        dxToolbar, dxToolbar, dxToolbar, dxToolbar,
        sizeof(TBBUTTON));

    m_hStatusbar = CreateWindowEx(
        0,
        STATUSCLASSNAME,
        "",
        WS_CHILD|WS_VISIBLE|WS_BORDER|SBS_SIZEGRIP,
        0,0,0,0,
        hwnd,
        0,
        g_hInst,
        NULL);

    CLIENTCREATESTRUCT  ccs;

    ccs.hWindowMenu = (HMENU)mii.hSubMenu;
    ccs.idFirstChild = 100;

    m_hwndClient = CreateWindowEx(
        0,
        "MDICLIENT",
        "",
        WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE,
        0,0,0,0,
        hwnd,
        0,
        g_hInst,
        (LPVOID)&ccs);


    SendMessage(m_hwndClient, WM_MDISETMENU, (WPARAM)hMenu, (LPARAM)mii.hSubMenu);

    SetToolbar();
    SetStatusbar();
    return TRUE;
}


void CMDIFrame::WMDestroy()
{
    PostQuitMessage(0);
    SetWindowLong(m_hwnd, GWL_USERDATA, 0);
    Release();
}


LRESULT CMDIFrame::WndProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    LONG lRet;

    switch (iMsg)
    {
		case WM_CLOSE:
            HWND    hwndKid;

            hwndKid = ::GetWindow(m_hwndClient, GW_CHILD);
            while (hwndKid)
                {
                if (SendMessage(hwndKid, WM_CLOSE, 0, 0))
                    return 1;
                hwndKid = ::GetWindow(hwndKid, GW_HWNDNEXT);
                }
            break;

        case WM_ACTIVATE:
			if (m_pInPlaceActiveObj)
				m_pInPlaceActiveObj->OnFrameWindowActivate(LOWORD(wParam) != WA_INACTIVE);
			break;

        case WM_SIZE:
            WMSize();
            return 0;

        case WM_COMMAND:
            if(HrWMCommand(GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;
            break;

        case WM_NOTIFY:
            WMNotify(wParam, (NMHDR*)lParam);
            return 0;

        case WM_INITMENUPOPUP:
            return WMInitMenuPopup(hwnd, (HMENU)wParam, (UINT)LOWORD(lParam));

        case WM_MENUSELECT:
            if(m_hStatusbar)
                HandleMenuSelect(m_hStatusbar, wParam, lParam);
            return 0;

        case WM_DESTROY :
            WMDestroy();
            return 0 ;
    }
    lRet = DefFrameProc(hwnd, m_hwndClient, iMsg, wParam, lParam);

    if(iMsg==WM_ACTIVATE)
        {
        // post-process wm_activates to set focus back to
        // controls
        SaveFocus((BOOL)(LOWORD(wParam)), &m_hwndFocus);
        }

    return lRet;
}


void CMDIFrame::WMNotify(WPARAM wParam, NMHDR* pnmhdr)
{
    switch(pnmhdr->code)
    {
        case TTN_NEEDTEXT:
            ProcessTooltips((LPTOOLTIPTEXT) pnmhdr);
            break;

    }
}

HRESULT CMDIFrame::HrWMCommand(HWND hwnd, int id, WORD wCmd)
{
    HWND    hwndChild;
    CMeHost *pHost;

    HRESULT hr = S_FALSE;

    switch(id)
        {
        case idmOptions:
            DoOptions();
            break;

        case idmToggleToolbar:
            m_fToolbar = !m_fToolbar;
            SetToolbar();
            break;

        case idmToggleStatusbar:
            m_fStatusbar = !m_fStatusbar;
            SetStatusbar();
            break;

        case idmPopupFile:
            break;

        case idmTile:
            SendMessage(m_hwndClient, WM_MDITILE, MDITILE_HORIZONTAL, 0);
            break;

        case idmCascade:
            SendMessage(m_hwndClient, WM_MDICASCADE, 0, 0);
            break;

        case idmNew:
            pHost = new CMeHost();
            if (pHost)
                {
                hr = pHost->HrInit(m_hwndClient, (IOleInPlaceFrame *)this);
				pHost->Release();
                }
            if (FAILED(hr))
                MessageBox(hwnd, "Failed", "Mepad", MB_OK);
            break;

        case idmClose:
            PostMessage(m_hwnd, WM_CLOSE, 0, 0);
            return 0;

        case idmPageSetup:
        case idmPopupGo  :
        case idmPopupHelp:
            MessageBox(hwnd, "Not Implemented yet", "Mepad", MB_OK);
            hr = NOERROR;
            break;

        case idmAbout:
            MessageBox(hwnd, "MimeEdit Pad\nA test container for MimeEdit.\n(c) brettm", "Mepad", MB_OK);
            break;
        }

    // delegate the the active MDI child window
    hwndChild = (HWND)SendMessage(m_hwndClient, WM_MDIGETACTIVE, 0, 0);
    if (hwndChild)
        {
        pHost = (CMeHost *)GetWindowLong(hwndChild, GWL_USERDATA);
        if (pHost)
            pHost->OnCommand(hwnd, id, wCmd);
        }

    return hr;

}


void CMDIFrame::WMSize()
{
    RECT            rcToolbar,
                    rc,
                    rcStatus;
    int                 cy;

    SetWindowPos(m_hToolbar, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER);
    SetWindowPos(m_hStatusbar, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);

    GetClientRect(m_hToolbar, &rcToolbar);
    GetClientRect(m_hToolbar, &rcStatus);

    GetClientRect(m_hwnd, &rc);
    cy = rc.bottom - rcToolbar.bottom - rcStatus.bottom + 3;
    SetWindowPos(m_hwndClient, NULL, 0, rcToolbar.bottom, rc.right-rc.left, cy, SWP_NOACTIVATE|SWP_NOZORDER);
}



void CMDIFrame::SetToolbar()
{
    ShowWindow(m_hToolbar, m_fToolbar?SW_SHOW:SW_HIDE);
    WMSize();
    InvalidateRect(m_hwnd, NULL, TRUE);
}

void CMDIFrame::SetStatusbar()
{
    ShowWindow(m_hStatusbar, m_fStatusbar?SW_SHOW:SW_HIDE);
    WMSize();
    InvalidateRect(m_hwnd, NULL, TRUE);
}


LRESULT CMDIFrame::WMInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos)
{
    MENUITEMINFO    mii;
    HMENU           hmenuMain;
    UINT            ustate;
    HWND            hwndChild;
    CMeHost         *pHost;

    hmenuMain = GetMenu(hwnd);
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    GetMenuItemInfo(hmenuMain, uPos, TRUE, &mii);

    // grey all the commands handled by the children, then can reenable them
    EnableMenuItem(hmenuPopup, idmOpen, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmEditDocument, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmCut, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmCopy, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmPaste, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmUndo, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmRedo, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmSelectAll, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmPrint, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmSaveAs, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmFind, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmRot13, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmNoHeader, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmPreview, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmMiniHeader, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmFormatBar, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmFmtPreview, MF_BYCOMMAND|MF_GRAYED);

    switch (mii.wID)
    {
        case idmPopupView:
            ustate = (m_fToolbar?MF_CHECKED:MF_UNCHECKED) | MF_BYCOMMAND;
            CheckMenuItem(hmenuPopup, idmToggleToolbar, ustate);
            ustate = (m_fStatusbar?MF_CHECKED:MF_UNCHECKED) | MF_BYCOMMAND;
            CheckMenuItem(hmenuPopup, idmToggleStatusbar, ustate);
            break;
    }

    // delegate to the active MDI child window
    hwndChild = (HWND)SendMessage(m_hwndClient, WM_MDIGETACTIVE, 0, 0);
    if (hwndChild)
        {
        pHost = (CMeHost *)GetWindowLong(hwndChild, GWL_USERDATA);
        if (pHost)
            pHost->OnInitMenuPopup(hwnd, hmenuPopup, uPos);
        }

    return 0;
}


static HACCEL   hAccel=0;

HRESULT CMDIFrame::TranslateAcclerator(LPMSG lpmsg)
{
    HWND    hwndChild;

    if (!hAccel)
        hAccel = LoadAccelerators(g_hInst, MAKEINTRESOURCE(idacMeHost));

    if(::TranslateAccelerator(m_hwnd, hAccel, lpmsg))
        return S_OK;

    hwndChild = (HWND)SendMessage(m_hwndClient, WM_MDIGETACTIVE, 0, 0);
    
    if(hwndChild && 
        ::TranslateAccelerator(hwndChild, hAccel, lpmsg))
        return S_OK;

    if (TranslateMDISysAccel(m_hwndClient, lpmsg))
        return S_OK;

	if (m_pInPlaceActiveObj)
		return m_pInPlaceActiveObj->TranslateAccelerator(lpmsg);

    return S_FALSE;
}


// *** IOleInPlaceFrame methods ***
HRESULT CMDIFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{

    return NOERROR;
}

HRESULT CMDIFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return NOERROR;
}

HRESULT CMDIFrame::RemoveMenus(HMENU hmenuShared)
{
    return NOERROR;
}

HRESULT CMDIFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    if (pszStatusText)
        {
        TCHAR   rgch[MAX_PATH];

        WideCharToMultiByte(CP_ACP, 0, pszStatusText, -1, rgch, MAX_PATH, NULL, NULL);
        SendMessage(m_hStatusbar, SB_SIMPLE, (WPARAM)TRUE, 0);
        SendMessage(m_hStatusbar, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM) rgch);
        }
    else
        {
        SendMessage(m_hStatusbar, SB_SIMPLE, (WPARAM)FALSE, 0);
        }

    return S_OK;
}

HRESULT CMDIFrame::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

HRESULT CMDIFrame::TranslateAccelerator(LPMSG lpMsg, WORD wID)
{
    return E_NOTIMPL;
}


HRESULT CMDIFrame::GetWindow(HWND *phwnd)
{
	*phwnd = m_hwnd;
	return S_OK;
}

HRESULT CMDIFrame::ContextSensitiveHelp(BOOL)
{
	return E_NOTIMPL;
}


    // *** IOleInPlaceUIWindow methods ***
HRESULT CMDIFrame::GetBorder(LPRECT)
{
	return E_NOTIMPL;

}

HRESULT CMDIFrame::RequestBorderSpace(LPCBORDERWIDTHS)
{
	return E_NOTIMPL;

}

HRESULT CMDIFrame::SetBorderSpace(LPCBORDERWIDTHS)
{
	return E_NOTIMPL;

}

HRESULT CMDIFrame::SetActiveObject(IOleInPlaceActiveObject *pInPlaceActiveObj, LPCOLESTR)
{
	ReplaceInterface(m_pInPlaceActiveObj, pInPlaceActiveObj);
	return S_OK;
}


void CMDIFrame::DoOptions()
{
    DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddOptions), m_hwnd, (DLGPROC)ExtOptDlgProc, (LPARAM)this);
}


BOOL CALLBACK CMDIFrame::ExtOptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMDIFrame *pFrame=(CMDIFrame *)GetWindowLong(hwnd, DWL_USER);

    if (msg==WM_INITDIALOG)
        {
        pFrame = (CMDIFrame *)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);
        }

    return pFrame?pFrame->OptDlgProc(hwnd, msg, wParam, lParam):FALSE;
}


BOOL    g_fHTML         =TRUE,
        g_fIncludeMsg   =TRUE,
        g_fQuote        =FALSE,
        g_fSlideShow    =FALSE,
        g_fAutoInline   =TRUE,
        g_fSendImages   =TRUE,
        g_fComposeFont  =TRUE,
        g_fBlockQuote   =TRUE,
        g_fAutoSig      =FALSE,
        g_fSigHtml      =FALSE;
        
CHAR    g_chQuote       ='>';
CHAR    g_szComposeFont[MAX_PATH] = "0,1,0,2,0.0.128,,Verdana";
LONG    g_lHeaderType   = 0;
CHAR    g_szSig[MAX_PATH]         = "<your signature goes here>";

BOOL CMDIFrame::OptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    char sz[5];
    int i;

    switch (msg)
        { 
        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    g_fHTML = IsDlgButtonChecked(hwnd, idcHTML);
                    g_fIncludeMsg = IsDlgButtonChecked(hwnd, idcInclude);
                    g_fQuote = IsDlgButtonChecked(hwnd, idcQuote);
                    g_fSlideShow = IsDlgButtonChecked(hwnd, idcSlide);
                    g_fAutoInline = IsDlgButtonChecked(hwnd, idcAuto);
                    g_fSendImages = IsDlgButtonChecked(hwnd, idcSendImages);
                    g_fComposeFont = IsDlgButtonChecked(hwnd, idcComposeFont);
                    g_fAutoSig = IsDlgButtonChecked(hwnd, idcSig);
                    g_fSigHtml = IsDlgButtonChecked(hwnd, idcSigHtml);

                    GetWindowText(GetDlgItem(hwnd, ideComposeFont), g_szComposeFont, MAX_PATH);
                    GetWindowText(GetDlgItem(hwnd, ideSig), g_szSig, MAX_PATH);

                    GetWindowText(GetDlgItem(hwnd, ideQuote), sz, 1);
                    g_chQuote = sz[0];

                    g_fBlockQuote = IsDlgButtonChecked(hwnd, idcBlockQuote);
                    for (i=0; i<4; i++)
                        if (IsDlgButtonChecked(hwnd, idrbNone+i))
                            g_lHeaderType = i;

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            CheckDlgButton(hwnd, idcHTML, g_fHTML ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcInclude, g_fIncludeMsg ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcQuote, g_fQuote ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSlide, g_fSlideShow ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcAuto, g_fAutoInline ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSendImages, g_fSendImages ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcComposeFont, g_fComposeFont ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSig, g_fAutoSig ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSigHtml, g_fSigHtml ? BST_CHECKED:BST_UNCHECKED);

            sz[0] = g_chQuote;
            sz[1] = 0;
            SetWindowText(GetDlgItem(hwnd, ideQuote), sz);
            SetWindowText(GetDlgItem(hwnd, ideComposeFont), g_szComposeFont);
            SetWindowText(GetDlgItem(hwnd, ideSig), g_szSig);

            CheckRadioButton(hwnd, idrbNone, idrbPrint, idrbNone+g_lHeaderType);
            CheckDlgButton(hwnd, idcBlockQuote, g_fBlockQuote ? BST_CHECKED:BST_UNCHECKED);
            break;
        }

    return FALSE;
}


void SaveFocus(BOOL fActive, HWND *phwnd)
{
    if(fActive&&IsWindow(*phwnd))
        SetFocus(*phwnd);
    else
        *phwnd=GetFocus();
}


HRESULT CMDIFrame::OpenDoc(LPSTR pszFileName)
{
    CMeHost *pHost;
    HRESULT hr;

    if (pszFileName && *pszFileName)
        {
        pHost = new CMeHost();
        if (pHost)
            {
            hr = pHost->HrInit(m_hwndClient, (IOleInPlaceFrame *)this);
            if (!FAILED(hr))
                hr = pHost->HrLoadFile(pszFileName);
		    pHost->Release();
            }

        if (FAILED(hr))
            MessageBox(m_hwnd, "Failed to open file", "Mepad", MB_OK);
        }    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\inc\strconst.h ===
// --------------------------------------------------------------------------------
// Strconst.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __STRCONST_H
#define __STRCONST_H

#include "mimeole.h"

#define STR_REG_PATH_FLAT          "Software\\Microsoft\\Outlook Express"
#define STR_REG_PATH_ROOT          "Software\\Microsoft\\Outlook Express\\5.0"

#define wchCR   L'\r'   
#define wchLF   L'\n'
#define chCR    '\r'   
#define chLF    '\n'

// --------------------------------------------------------------------------------
// Common String Constants
// --------------------------------------------------------------------------------
STRCONSTA(c_szCRLFCRLF,             "\r\n\r\n");
STRCONSTA(c_szCRLF,                 "\r\n");
STRCONSTA(c_szCRLFTab,              "\r\n\t");
STRCONSTA(c_szRegRoot,              STR_REG_PATH_ROOT);
STRCONSTA(c_szRegFlat,              STR_REG_PATH_FLAT);

// --------------------------------------------------------------------------------
// IMNACCT String Constants
// --------------------------------------------------------------------------------
STRCONSTA(g_szSpace,               " ");
//STRCONSTA(g_szTab,                 "\t");
STRCONSTA(g_szNewline,             "\n");
//STRCONSTA(g_szCR,                  "\r");
STRCONSTA(g_szCRLF,                "\r\n");
//STRCONSTA(szRasDll,                "RASAPI32.DLL");
//STRCONSTA(c_szInetcfgDll,          "inetcfg.dll");
STRCONSTA(c_szMLANGDLL,            "mlang.dll");
STRCONSTA(c_szDllRegisterServer,   "DllRegisterServer");
//STRCONSTA(c_szCreateAcct,          "InetCreateMailNewsAccount");
//STRCONSTA(c_szCreateDirServ,       "InetCreateDirectoryService");
//STRCONSTA(c_szCtxHelpFile,         "inetcomm.hlp");
//STRCONSTA(c_szRegRootNew,          "Software\\Microsoft\\Internet Account Manager");

STRCONSTA(c_szCtxHelpFile,         "msoe.hlp");

// --------------------------------------------------------------------------------
// WebPage String Constants
// --------------------------------------------------------------------------------
STRCONSTA(STR_METATAG_PREFIX,      "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;charset=");
STRCONSTA(STR_METATAG_POSTFIX,     "\">\r\n");
STRCONSTA(STR_SEGMENT_SPLIT,       "<P><HR></P>");
STRCONSTA(STR_INLINE_IMAGE1,       "<P>\n\r<CENTER><IMG SRC=\"CID:");
STRCONSTA(STR_INLINE_IMAGE2,       "\"></CENTER>");
STRCONSTA(STR_ATTACH_TITLE_END,    "<UL>");
STRCONSTA(STR_ATTACH_BEGIN,        "<LI><A href=\"CID:");
STRCONSTA(STR_ATTACH_MIDDLE,       "\">");
STRCONSTA(STR_ATTACH_END,          "</A></LI>\r\n");
STRCONSTW(STR_SLIDEIMG_BEGIN,      "g_ImageTable[g_imax++] = new Array (\"cid:");
STRCONSTW(STR_QUOTECOMMASPACEQUOTE,"\", \"");
STRCONSTW(STR_QUOTEPARASEMI,       "\");\r\n");

// --------------------------------------------------------------------------------
// MIMEOLE String Constants
// --------------------------------------------------------------------------------
STRCONSTW(STR_XRICH,               "<x-rich>");
STRCONSTA(c_szXRich,               "<x-rich>");
STRCONSTA(STR_ISO88591,            "ISO-8859-1");
STRCONSTW(STR_TEXTHTML,            "text/html");
STRCONSTA(c_szAddressDelims,        "\",<(");
STRCONSTA(c_szMHTMLColon,           "mhtml:");
STRCONSTA(c_szMHTMLExt,             ".mhtml");
STRCONSTA(c_szFileUrl,              "file://");
//STRCONSTA(c_szMHTMLColonWackWack,   "mhtml://");
STRCONSTA(c_szCID,                  "CID:");
//STRCONSTA(c_szNo,                   "No");
//STRCONSTA(c_szYes,                  "Yes");
STRCONSTA(c_szISO2022JP,            "iso-2022-jp");
STRCONSTA(c_szISO2022JPControl,     "JP_ISO_SIO_Control");
STRCONSTA(c_szISO88591,             "iso-8859-1");
STRCONSTA(STR_HDR_XMIMEOLE,         "X-MimeOLE");
STRCONSTA(STR_HDR_UNKNOWN,          "Unknown");
STRCONSTA(STR_PRI_HIGHEST,          "Highest");
STRCONSTA(STR_PRI_LOWEST,           "Lowest");
STRCONSTA(c_szDescription,          "Description");
//STRCONSTA(c_szStoreInetProps,       "Store Internet Properties");
//STRCONSTA(c_szType,                 "Type");
//STRCONSTA(c_szFlags,                "Flags");
STRCONSTA(c_szMimeVersion,          "1.0");
STRCONSTA(c_szDoubleDash,           "--");
//STRCONSTA(c_szRegMimeOLE,           "Software\\Microsoft\\MimeOLE Engine");
//STRCONSTA(c_szRegInetProps,         "Software\\Microsoft\\MimeOLE Engine\\Internet Properties");
STRCONSTA(c_szCommaSpace,           ", ");
STRCONSTW(c_wszCommaSpace,          ", ");
STRCONSTA(c_szCommaSpaceDash,       ", -");
STRCONSTA(c_szAddressFold,          ",\r\n\t");
STRCONSTW(c_wszAddressFold,         ",\r\n\t");
STRCONSTA(c_szParamFold,            ";\r\n\t");
//STRCONSTA(c_szAddressSep,           ", ");
STRCONSTA(c_szEmpty,                "");
STRCONSTW(c_szEmptyW,               "");
//STRCONSTA(c_szSemiColon,            ";");
STRCONSTA(c_szSemiColonSpace,       "; ");
STRCONSTW(c_wszSemiColonSpace,      "; ");
STRCONSTA(c_szEmailSpaceStart,      " <");
STRCONSTW(c_wszEmailSpaceStart,     " <");
STRCONSTA(c_szEmailStart,           "<");
STRCONSTW(c_wszEmailStart,          "<");
STRCONSTA(c_szEmailEnd,             ">");
STRCONSTW(c_wszEmailEnd,            ">");
STRCONSTA(c_szColonSpace,           ": ");
//STRCONSTA(c_szFoldCRLF,             "\r\n ");
//STRCONSTA(c_szPeriod,               ".");
STRCONSTA(c_szForwardSlash,         "/");
STRCONSTA(c_szEqual,                "=");
STRCONSTA(c_szDoubleQuote,          "\"");
STRCONSTW(c_wszDoubleQuote,         "\"");
STRCONSTA(c_szMDBContentType,       "MIME\\Database\\Content Type");
//STRCONSTA(c_szMDBCodePage,          "MIME\\Database\\CodePage");
//STRCONSTA(c_szMDBCharset,           "MIME\\Database\\Charset");
STRCONSTA(c_szExtension,            "Extension");
STRCONSTA(c_szCLSID,                "CLSID");
//STRCONSTA(c_szFixedWidthFont,       "FixedWidthFont");
//STRCONSTA(c_szProportionalFont,     "ProportionalFont");
//STRCONSTA(c_szBodyCharset,          "BodyCharset");
//STRCONSTA(c_szWebCharset,           "WebCharset");
//STRCONSTA(c_szHeaderCharset,        "HeaderCharset");
//STRCONSTA(c_szAliasCharset,         "AliasForCharset");
//STRCONSTA(c_szCodePage,             "CodePage");
//STRCONSTA(c_szInternetEncoding,     "InternetEncoding");
//STRCONSTA(c_szMailMimeEncoding,     "MailMIMEEncoding");
//STRCONSTA(c_szNewsMimeEncoding,     "NewsMIMEEncoding");
//STRCONSTA(c_szFamily,               "Family");
STRCONSTA(c_szCharset,              "charset");
STRCONSTA(c_szBoundary,             "boundary");
STRCONSTA(c_szFileName,             "filename");
STRCONSTA(c_szID,                   "id");
STRCONSTA(c_szName,                 "name");
STRCONSTA(c_szUUENCODE_END,         "end\r\n");
STRCONSTA(c_szUUENCODE_BEGIN,       "begin ");
STRCONSTA(c_szUUENCODE_DAT,         "uuencode.uue");
STRCONSTA(c_szUUENCODE_666,         "666 ");
STRCONSTA(c_szContentType,          "Content Type");
STRCONSTW(c_szContentTypeW,         "Content Type");
STRCONSTA(c_szDefaultAttach,        "attach.dat");
STRCONSTW(c_wszDefaultAttach,       "attach.dat");
STRCONSTA(c_szDotDat,               ".dat");
STRCONSTW(c_wszDotDat,              ".dat");
STRCONSTA(c_szDotTxt,               ".txt");
STRCONSTW(c_wszDotTxt,              ".txt");
//STRCONSTA(c_szDotUUE,               ".uue");
STRCONSTA(c_szDotEml,               ".eml");
STRCONSTW(c_wszDotEml,              ".eml");
STRCONSTA(c_szDotNws,               ".nws");
STRCONSTW(c_wszDotNws,              ".nws");
STRCONSTA(c_szWinmailDotDat,        "winmail.dat");
STRCONSTA(c_szUUEncodeZeroLength,   "`\r\n");
STRCONSTA(c_szRfc822MustQuote,      "()<>,;:\\\"[] ");
STRCONSTA(c_szXrefColon,            "xref:");
STRCONSTW(REG_BC_ATHENAMESSAGE,             "__MimeOle__IMimeMessage");
STRCONSTW(REG_BC_BINDSTATUSCALLBACK,        "_BSCB_Holder_");
STRCONSTA(REG_Y2K_THRESHOLD,                "Control Panel\\International\\Calendars\\TwoDigitYearMax");

// --------------------------------------------------------------------------------
// SMTP command strings
// --------------------------------------------------------------------------------
STRCONSTA(SMTP_AUTH_CANCEL_STR, "*\r\n");
STRCONSTA(SMTP_AUTH_STR,       "AUTH");
STRCONSTA(SMTP_HELO_STR,       "HELO");
STRCONSTA(SMTP_EHLO_STR,       "EHLO");
STRCONSTA(SMTP_STARTTLS_STR,   "STARTTLS\r\n");
STRCONSTA(SMTP_MAIL_STR,       "MAIL FROM:");
STRCONSTA(SMTP_RCPT_STR,       "RCPT TO:");
STRCONSTA(SMTP_RSET_STR,       "RSET\r\n");
//STRCONSTA(SMTP_SEND_STR,       "SEND FROM");
//STRCONSTA(SMTP_SOML_STR,       "SOML FROM");
//STRCONSTA(SMTP_SAML_STR,       "SAML FROM");
//STRCONSTA(SMTP_VRFY_STR,       "VRFY");
//STRCONSTA(SMTP_EXPN_STR,       "EXPN");
//STRCONSTA(SMTP_HELP_STR,       "HELP");
//STRCONSTA(SMTP_NOOP_STR,       "NOOP");
STRCONSTA(SMTP_QUIT_STR,       "QUIT\r\n");
//STRCONSTA(SMTP_TURN_STR,       "TURN");
STRCONSTA(SMTP_DATA_STR,       "DATA\r\n");
STRCONSTA(SMTP_END_DATA_STR,   "\r\n.\r\n");

// --------------------------------------------------------------------------------
// POP3 command strings
// --------------------------------------------------------------------------------
STRCONSTA(POP3_USER_STR,       "USER");
STRCONSTA(POP3_PASS_STR,       "PASS");
STRCONSTA(POP3_STAT_STR,       "STAT\r\n");
STRCONSTA(POP3_LIST_STR,       "LIST");
STRCONSTA(POP3_LIST_ALL_STR,   "LIST\r\n");
STRCONSTA(POP3_RETR_STR,       "RETR");
STRCONSTA(POP3_DELE_STR,       "DELE");
STRCONSTA(POP3_NOOP_STR,       "NOOP\r\n");
//STRCONSTA(POP3_LAST_STR,       "LAST");
STRCONSTA(POP3_RSET_STR,       "RSET");
STRCONSTA(POP3_QUIT_STR,       "QUIT\r\n");
//STRCONSTA(POP3_APOP_STR,       "APOP");
STRCONSTA(POP3_TOP_STR,        "TOP");
STRCONSTA(POP3_UIDL_ALL_STR,   "UIDL\r\n");
STRCONSTA(POP3_UIDL_STR,       "UIDL");
STRCONSTA(POP3_AUTH_STR,       "AUTH");
STRCONSTA(POP3_AUTH_CANCEL_STR, "*\r\n");
//STRCONSTA(POP3_END_DATA_STR,   ".");

// --------------------------------------------------------------------------------
// NNTP command strings
// --------------------------------------------------------------------------------
STRCONSTA(NNTP_AUTHINFOUSER,          "AUTHINFO USER");
STRCONSTA(NNTP_AUTHINFOPASS,          "AUTHINFO PASS");
STRCONSTA(NNTP_TRANSACTTEST_CRLF,     "AUTHINFO TRANSACT TWINKIE\r\n");
STRCONSTA(NNTP_TRANSACTCMD,           "AUTHINFO TRANSACT");
STRCONSTA(NNTP_AUTHINFOSIMPLE_CRLF,   "AUTHINFO SIMPLE\r\n");
STRCONSTA(NNTP_GENERICTEST_CRLF,      "AUTHINFO GENERIC\r\n");
STRCONSTA(NNTP_GENERICCMD,            "AUTHINFO GENERIC");
STRCONSTA(NNTP_GROUP,                 "GROUP");
STRCONSTA(NNTP_LAST_CRLF,             "LAST\r\n");
STRCONSTA(NNTP_NEXT_CRLF,             "NEXT\r\n");
STRCONSTA(NNTP_STAT,                  "STAT");
STRCONSTA(NNTP_ARTICLE,               "ARTICLE");
STRCONSTA(NNTP_HEAD,                  "HEAD");
STRCONSTA(NNTP_BODY,                  "BODY");
STRCONSTA(NNTP_POST_CRLF,             "POST\r\n");
STRCONSTA(NNTP_LIST,                  "LIST");
STRCONSTA(NNTP_LISTGROUP,             "LISTGROUP");
STRCONSTA(NNTP_NEWGROUPS,             "NEWGROUPS");
STRCONSTA(NNTP_DATE_CRLF,             "DATE\r\n");
STRCONSTA(NNTP_MODE,                  "MODE");
STRCONSTA(NNTP_MODE_READER_CRLF,      "MODE READER\r\n");
STRCONSTA(NNTP_QUIT_CRLF,             "QUIT\r\n");
STRCONSTA(NNTP_XOVER,                 "XOVER");
//STRCONSTA(NNTP_CRLF_DOT_CRLF,         "\r\n.\r\n");
STRCONSTA(NNTP_BASIC,                 "BASIC");
STRCONSTA(NNTP_XHDR,                  "XHDR");
//STRCONSTA(NNTP_RANGE,                 "%lu-%lu");
//STRCONSTA(NNTP_RANGE_OPEN,            "%lu-");
STRCONSTA(NNTP_ENDPOST,               "\r\n.\r\n");

// --------------------------------------------------------------------------------
// NNTP Header strings
// --------------------------------------------------------------------------------
STRCONSTA(NNTP_HDR_SUBJECT,           "subject");
STRCONSTA(NNTP_HDR_FROM,              "from");
STRCONSTA(NNTP_HDR_DATE,              "date");
STRCONSTA(NNTP_HDR_MESSAGEID,         "message-id");
STRCONSTA(NNTP_HDR_REFERENCES,        "references");
//STRCONSTA(NNTP_HDR_BYTES,             "bytes");
STRCONSTA(NNTP_HDR_LINES,             "lines");
STRCONSTA(NNTP_HDR_XREF,              "xref");

// --------------------------------------------------------------------------------
// HTTPMAIL command strings
// --------------------------------------------------------------------------------
STRCONSTA(c_szXMLOpenElement,               "<");
STRCONSTA(c_szXMLCloseElement,              ">");
STRCONSTA(c_szXMLCloseElementCRLF,          ">\r\n");
STRCONSTA(c_szTabTabOpenElement,            "\t\t<");
STRCONSTA(c_szCRLFTabTabOpenElement,        "\r\n\t\t<");
STRCONSTA(c_szCRLFTabTabTabOpenElement,     "\r\n\t\t\t<");
STRCONSTA(c_szXMLOpenTermElement,           "</");
STRCONSTA(c_szXMLCloseTermElement,          "/>");

STRCONSTA(c_szDavNamespacePrefix,           "D");
STRCONSTA(c_szHotMailNamespacePrefix,       "h");
STRCONSTA(c_szHTTPMailNamespacePrefix,      "hm");
STRCONSTA(c_szMailNamespacePrefix,          "m");
STRCONSTA(c_szContactsNamespacePrefix,      "c"); 

STRCONSTA(c_szXMLHead,                      "<?xml version=\"1.0\"?>");
STRCONSTA(c_szXML1252Head,                  "<?xml version=\"1.0\" encoding=\"windows-1252\"?>");

STRCONSTA(c_szXMLNsColon,                   "xmlns:");

STRCONSTA(c_szPropFindHead1,				"\r\n<D:propfind ");
STRCONSTA(c_szPropFindHead2,			    ">\r\n\t<D:prop>");
STRCONSTA(c_szPropFindTail,                 "\r\n\t</D:prop>\r\n</D:propfind>");

STRCONSTA(c_szPropPatchHead,				"\r\n<D:propertyupdate ");
STRCONSTA(c_szPropPatchTailCRLF,            "\r\n</D:propertyupdate>");

STRCONSTA(c_szPropPatchSetHead,             "\r\n\t<D:set>\r\n\t\t<D:prop>");
STRCONSTA(c_szPropPatchSetTail,             "\r\n\t\t</D:prop>\r\n\t</D:set>");

STRCONSTA(c_szPropPatchRemoveHead,          "\r\n\t<D:remove>\r\n\t\t<D:prop>");
STRCONSTA(c_szPropPatchRemoveTail,          "\r\n\t\t</D:prop>\r\n\t</D:remove>");

STRCONSTA(c_szOpenContactNamespace,         "\r\n\t<c:");
STRCONSTA(c_szCloseContactNamespace,        "</c:");
STRCONSTA(c_szContactHead,                  "<c:contact ");
STRCONSTA(c_szContactTail,                  "\r\n</c:contact>");
STRCONSTA(c_szGroupSwitch,                  "<c:group/>");

STRCONSTA(c_szEscLessThan,                  "&lt;");
STRCONSTA(c_szEscGreaterThan,               "&gt;");
STRCONSTA(c_szEscAmp,                       "&amp;");


STRCONSTA(c_szDestinationHeader,            "Destination: ");
STRCONSTA(c_szTranslateFalseHeader,         "Translate: f");
STRCONSTA(c_szTranslateTrueHeader,          "Translate: t");
STRCONSTA(c_szAllowRenameHeader,            "Allow-Rename: t");
STRCONSTA(c_szContentTypeHeader,            "Content-Type: ");
STRCONSTA(c_szBriefHeader,                  "Brief: t");
STRCONSTA(c_szDepthHeader,                  "Depth: %d");
STRCONSTA(c_szDepthNoRootHeader,            "Depth: %d,noroot");
STRCONSTA(c_szDepthInfinityHeader,          "Depth: infinity");
STRCONSTA(c_szDepthInfinityNoRootHeader,    "Depth: infinity,noroot");

STRCONSTA(c_szMailContentType,              "message/rfc822");
STRCONSTA(c_szXmlContentType,               "text/xml");
STRCONSTA(c_szSmtpMessageContentType,       "message/rfc821");

STRCONSTA(c_szRootTimeStampHeader,          "X-Timestamp: folders=%s,ACTIVE=%s");
STRCONSTA(c_szFolders,                      "folders");
STRCONSTA(c_szFolderTimeStampHeader,        "X-Timestamp: ACTIVE=%s");
STRCONSTA(c_szActive,                       "ACTIVE");
STRCONSTA(c_szXTimestamp,                   "X-Timestamp");
STRCONSTA(c_szAcceptCharset,                "Accept-CharSet:%s");

// strings used to build batch command xml
STRCONSTA(c_szBatchHead1,                   "\r\n<D:");
STRCONSTA(c_szBatchHead2,                   " xmlns:D=\"DAV:\">");
STRCONSTA(c_szBatchTail,                    "\r\n</D:");

STRCONSTA(c_szTargetHead,                   "\r\n\t<D:target>");
STRCONSTA(c_szTargetTail,                   "\r\n\t</D:target>");

STRCONSTA(c_szHrefHead,                     "\r\n\t\t<D:href>");
STRCONSTA(c_szHrefTail,                     "</D:href>");
STRCONSTA(c_szDestHead,                     "\r\n\t\t<D:dest>");
STRCONSTA(c_szDestTail,                     "</D:dest>");

STRCONSTA(c_szDelete,                       "delete");
STRCONSTA(c_szCopy,                         "copy");
STRCONSTA(c_szMove,                         "move");

// strings used to build rfc821 streams
STRCONSTA(c_szMailFrom,                     "MAIL FROM:<");
STRCONSTA(c_szRcptTo,                       "RCPT TO:<");
STRCONSTA(c_szSaveInSentTrue,               "SAVEINSENT: t");
STRCONSTA(c_szSaveInSentFalse,              "SAVEINSENT: f");

// --------------------------------------------------------------------------------
// RAS function strings
// --------------------------------------------------------------------------------
STRCONSTA(c_szRasDial,                     "RasDialA");    
STRCONSTA(c_szRasEnumConnections,          "RasEnumConnectionsA");
STRCONSTA(c_szRasEnumEntries,              "RasEnumEntriesA");
STRCONSTA(c_szRasGetConnectStatus,         "RasGetConnectStatusA");
STRCONSTA(c_szRasGetErrorString,           "RasGetErrorStringA");
STRCONSTA(c_szRasHangup,                   "RasHangUpA");
STRCONSTA(c_szRasSetEntryDialParams,       "RasSetEntryDialParamsA");
STRCONSTA(c_szRasGetEntryDialParams,       "RasGetEntryDialParamsA");
//STRCONSTA(c_szRasGetEntryProperties,       "RasGetEntryPropertiesA");
//STRCONSTA(c_szRasSetEntryProperties,       "RasSetEntryPropertiesA");
STRCONSTA(c_szRasCreatePhonebookEntry,     "RasCreatePhonebookEntryA");
STRCONSTA(c_szRasEditPhonebookEntry,       "RasEditPhonebookEntryA");
// ********************************************************************************
// MIMEEDIT String Constants
// ********************************************************************************
STRCONSTA(c_szBmpExt,              ".bmp");
STRCONSTA(c_szJpgExt,              ".jpg");
STRCONSTA(c_szJpegExt,             ".jpeg");
STRCONSTA(c_szGifExt,              ".gif");
STRCONSTA(c_szIcoExt,              ".ico");
STRCONSTA(c_szWmfExt,              ".wmf");
STRCONSTA(c_szPngExt,              ".png");
STRCONSTA(c_szEmfExt,              ".emf");
STRCONSTA(c_szArtExt,              ".art");
STRCONSTA(c_szXbmExt,              ".xbm");
STRCONSTW(c_szExeExt,              ".exe");
STRCONSTW(c_wszDocHostWndClass,    "##MimeEdit_Server");

//STRCONSTA(c_szLnkExt,              ".lnk");
STRCONSTA(c_szSpace,               " ");
STRCONSTA(c_szIexploreExe,         "iexplore.exe");
//STRCONSTA(c_szPathFileFmt,         "%s\\%s");
//STRCONSTA(c_szEllipsis,            "...");
//STRCONSTA(c_szAppPaths,            "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths");
STRCONSTA(c_szExplorerRegPath,     "Software\\Microsoft\\Internet Explorer");
//STRCONSTA(c_szRegPath,             "Path");

//STRCONSTA(c_szRegSpellLangID,      	"SpellLangID");
STRCONSTA(c_szRegShellFoldersKey,  		"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
STRCONSTA(c_szValueAppData,             "AppData");
STRCONSTA(c_szRegSpellKeyDef,      		"Spelling\\%s\\Normal");
STRCONSTA(c_szRegSpellKeyDefRoot,  		"SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Spelling");
STRCONSTA(c_szRegSpellKeyCustom,   		"Custom Dictionaries");
STRCONSTA(c_szRegSpellProfile,     		"SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\");
STRCONSTA(c_szRegSharedTools,      		"SOFTWARE\\Microsoft\\Shared Tools\\");
STRCONSTA(c_szRegSharedToolsPath,  		"SharedFilesDir");
STRCONSTA(c_szSpellCSAPI3T1Path,   		"Proof\\CSAPI3T1.DLL");
STRCONSTA(c_szCSAPI3T1,                 "CSAPI3T1.DLL");
STRCONSTA(c_szSpellOffice9ProofPath,	"Microsoft\\Proof\\");
STRCONSTA(c_szRegSpellPath,        		"Engine");
STRCONSTA(c_szRegSpellPathLex,     		"Dictionary");
STRCONSTA(c_szRegSpellPathDict,    		"1");
STRCONSTA(c_szRegDefCustomDict,    		"custom.dic");
STRCONSTA(c_szRegDICHandlerKEY,    		".DIC");
STRCONSTA(c_szRegDICHandlerDefault,		"txtfile");
STRCONSTA(c_szInstallRoot,              "InstallRoot");

#ifdef SMIME_V3
// Security Policy strings.
STRCONSTA(c_szDefaultPolicyOid,			"default");
STRCONSTA(c_szSecLabelPoliciesRegKey,	"Software\\Microsoft\\Cryptography\\OID\\EncodingType 1\\SMIMESecurityLabel");
STRCONSTA(c_szSecurityPolicyDllPath,	"DllPath");
STRCONSTA(c_szSecurityPolicyFuncName,	"FuncName");

STRCONSTA(c_szSecLabelAdminRegKey,		"Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\SMIMESecurityLabel");
STRCONSTA(c_szHideMsgWithDifferentLabels,"HideMsgWithDifferentLabels");
STRCONSTA(c_szCertErrorWithLabel,		"CertErrorWithLabel");
#endif // SMIME_V3

// --------------------------------------------------------------------------------
// Registry value strings
// --------------------------------------------------------------------------------
STRCONSTA(c_szCertCheckRevocation,      "Check Cert Revocation");
STRCONSTA(c_szCertIgnoredErr,           "Ignored Cert Errors");

#endif // __STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\frame.h ===
#ifndef _FRAME_H
#define _FRAME_H

class CMDIFrame :
    public IOleInPlaceFrame
{
public:
    CMDIFrame();
    virtual ~CMDIFrame();

    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 

    // *** IOleInPlaceFrame methods ***
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);


    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK ExtOptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL OptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT HrInit(LPSTR pszCmdLine);
    HRESULT TranslateAcclerator(LPMSG);

private:
    HWND                m_hwnd,
                        m_hToolbar,
                        m_hStatusbar,
                        m_hwndClient,
                        m_hwndFocus;
    BOOL                m_fToolbar;
    BOOL                m_fStatusbar;
    ULONG               m_cRef;
	IOleInPlaceActiveObject	*m_pInPlaceActiveObj;

    BOOL WMCreate(HWND hwnd);
    void WMDestroy();
    HRESULT HrWMCommand(HWND hwnd, int id, WORD wCmd);
    void WMNotify(WPARAM wParam, NMHDR* pnmhdr);
    void WMPaint();
    void WMSize();
    void SetToolbar();
    void SetStatusbar();
    void DoOptions();
    LRESULT WMInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos);
    HRESULT OpenDoc(LPSTR pszFileName);
};

typedef CMDIFrame *LPMDIFRAME;

#endif //_FRAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\globals.h ===
#ifndef _GLOBALS_H
#define _GLOBALS_H

extern  HINSTANCE g_hInst;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\mehost.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "mehost.h"
#include "demand.h"

#define SetMenuItem(_hmenu, _id, _fOn)     EnableMenuItem(_hmenu, _id, (_fOn)?MF_ENABLED:MF_DISABLED|MF_GRAYED)

extern BOOL    
        g_fHTML,
        g_fIncludeMsg,
        g_fQuote,
        g_fSlideShow,
        g_fAutoInline,
        g_fSendImages,
        g_fComposeFont,
        g_fBlockQuote,
        g_fAutoSig,
        g_fSigHtml;
       
extern CHAR     g_chQuote;
extern CHAR     g_szComposeFont[MAX_PATH];
extern CHAR     g_szSig[MAX_PATH];
extern LONG     g_lHeaderType;

BOOL CALLBACK MhtmlDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT SetEncodingOptions(IMimeMessage *pMsg, HCHARSET hCharset);
HRESULT IPersistMimeLoad(IUnknown *pUnk, IMimeMessage *pMsg);

CMeHost::CMeHost()
{
    m_fEditMode=FALSE;
    m_fHTMLMode=TRUE;
    *m_szFileW=0;
    *m_szFmt = 0;
    m_pMsg=NULL;
    m_pIntl=NULL;
}


CMeHost::~CMeHost()
{
    SafeRelease(m_pIntl);
    SafeRelease(m_pMsg);
}

 
ULONG CMeHost::AddRef()
{
    return CDocHost::AddRef();
}

ULONG CMeHost::Release()
{
    return CDocHost::Release();
}


HRESULT CMeHost::HrInit(HWND hwndMDIClient, IOleInPlaceFrame *pFrame)
{
    HRESULT         hr=E_FAIL;
    IMimeMessage    *pMsg=0;

	if (pFrame==NULL)
		return E_INVALIDARG;

    hr=CDocHost::HrInit(hwndMDIClient, 99, dhbHost);
    if (FAILED(hr))
        goto error;

	ReplaceInterface(m_pInPlaceFrame, pFrame);

	hr=CDocHost::HrCreateDocObj((LPCLSID)&CLSID_MimeEdit);
    if (FAILED(hr))
        goto error;

    hr=CDocHost::HrShow();
    if (FAILED(hr))
        goto error;

    // need to init MimeEdit with a blank message
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (FAILED(hr))
        goto error;

    hr = pMsg->InitNew();
    if (FAILED(hr))
        goto error;

    hr = IPersistMimeLoad(m_lpOleObj, pMsg);

    // need to init MimeEdit with a blank message
    hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, IID_IMimeInternational, (LPVOID *)&m_pIntl);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pMsg);
    return hr;
}

static char c_szFilter[] = "Rfc 822 Messages (*.eml)\0*.eml\0\0";
HRESULT CMeHost::HrOpen(HWND hwnd)
{
    OPENFILENAME    ofn;
    TCHAR           szFile[MAX_PATH];
    TCHAR           szTitle[MAX_PATH];
    TCHAR           szDefExt[30];

    if (!m_lpOleObj)
        return E_FAIL;

    lstrcpy(szFile, "c:\\*.eml");
    lstrcpy(szDefExt, ".eml");
    lstrcpy(szTitle, "Browse for message...");
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = c_szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

    // Show OpenFile Dialog
    if (!GetOpenFileName(&ofn))
        return E_OUTOFMEMORY;

    return HrLoadFile(szFile);
}



HRESULT CMeHost::OnCommand(HWND hwnd, int id, WORD wCmd)
{
    VARIANTARG  va;
    ULONG       uCmd=0,
                uCmdMimeEdit,
                uPrompt = OLECMDEXECOPT_DODEFAULT;
    VARIANTARG  *pvaOut=0,
                *pvaIn=0;
    BSTR        bstrFree=0;
    CHAR        rgch[MAX_PATH];
    WCHAR       rgchW[MAX_PATH];

    switch (id)
        {
        case idmBackground:
            return BackgroundPicture();

        case idmTestBackRed:
            return BackRed();
        
        case idmTestForeRed:
            return ForeRed();

        case idmInsertFile:
            uCmdMimeEdit = MECMDID_INSERTTEXTFILE;
            
            // if shift it down prompt ourselves to test the other codepath
            if (GetKeyState(VK_SHIFT)&0x8000)
                {
                lstrcpy(rgch, "c:\\foo.txt");
                if (GenericPrompt(hwnd, "Insert File...", "pick a filename", rgch, MAX_PATH)!=S_OK)
                    return S_FALSE;
                
                MultiByteToWideChar(CP_ACP, 0, rgch, -1, rgchW, MAX_PATH);
                bstrFree = SysAllocString(rgchW);
                va.vt = VT_BSTR;
                va.bstrVal = bstrFree;
                pvaIn = &va;
                }

            break;

        case idmFont:
            uCmdMimeEdit = MECMDID_FORMATFONT;
            break;

        case idmSetText:
            uCmdMimeEdit = MECMDID_SETTEXT;
            va.vt = VT_BSTR;
            va.bstrVal = SysAllocString(L"This is a sample text string. <BR> It <b><i>can</b></i> be HTML.");
            bstrFree = va.bstrVal;
            pvaIn = &va;
            break;

        case idmSaveAsStationery:
            SaveAsStationery();
            break;

        case idmSaveAsMHTML:
            SaveAsMhtmlTest();
            break;

        case idmLang:
            DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddLang), m_hwnd, (DLGPROC)ExtLangDlgProc, (LPARAM)this);
            break;

        case idmFmtPreview:
            DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddFmt), m_hwnd, (DLGPROC)ExtFmtDlgProc, (LPARAM)this);
            break;

        case idmNoHeader:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_NOHEADER;
            pvaIn = &va;
            break;

        case idmPreview:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_PREVIEW;
            pvaIn = &va;
            break;

        case idmMiniHeader:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_MINIHEADER;
            pvaIn = &va;
            break;

        case idmFormatBar:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_FORMATBAR;
            pvaIn = &va;
            break;

        case idmViewSource:
        case idmViewMsgSource:
            uCmdMimeEdit = MECMDID_VIEWSOURCE;
            va.vt = VT_I4;
            va.lVal = (id == idmViewSource ? MECMD_VS_HTML : MECMD_VS_MESSAGE);
            pvaIn = &va;
            break;

        case idmCut:
            uCmd=OLECMDID_CUT;
            break;

        case idmCopy:
            uCmd=OLECMDID_COPY;
            break;

        case idmPaste:
            uCmd=OLECMDID_PASTE;
            break;

        case idmUndo:
            uCmd=OLECMDID_UNDO;
            break;

        case idmRedo:
            uCmd=OLECMDID_REDO;
            break;

        case idmSelectAll:
            uCmd=OLECMDID_SELECTALL;
            break;

        case idmOpen:
            HrOpen(hwnd);
            return S_OK;
        
        case idmHTMLMode:
            m_fHTMLMode = !m_fHTMLMode;

            va.vt = VT_BOOL;
            va.boolVal = m_fHTMLMode ? VARIANT_TRUE : VARIANT_FALSE;
            pvaIn = &va;
            m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_EDITHTML, OLECMDEXECOPT_DODEFAULT, &va, NULL);

            if (!m_fHTMLMode && 
                m_pCmdTarget && 
                MessageBox(m_hwnd, "You are going from HTML to plaintext. Do you want to downgrade the document?", "MeHost", MB_YESNO)==IDYES)
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_DOWNGRADEPLAINTEXT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);

            return S_OK;

        case idmEditDocument:
            m_fEditMode = !m_fEditMode;
            uCmdMimeEdit = MECMDID_EDITMODE;
            va.vt = VT_BOOL;
            va.boolVal = m_fEditMode ? VARIANT_TRUE : VARIANT_FALSE;
            pvaIn = &va;
            break;
        
        case idmRot13:
            uCmdMimeEdit = MECMDID_ROT13;
            break;

        case idmFind:
            uCmd = OLECMDID_FIND;
            break;

        case idmSpelling:
            uCmd = OLECMDID_SPELL;
            break;

        case idmPrint:
            uCmd = OLECMDID_PRINT;
            break;
        
        case idmSaveAs:
            SaveAs();
            return 0;
        }

    if (m_pCmdTarget)
        {
        if (uCmd)
            m_pCmdTarget->Exec(NULL, uCmd, uPrompt, pvaIn, pvaOut);   
    
        if (uCmdMimeEdit)
            m_pCmdTarget->Exec(&CMDSETID_MimeEdit, uCmdMimeEdit, uPrompt, pvaIn, pvaOut);
        }

    SysFreeString(bstrFree);
    return S_OK;
}


LRESULT CMeHost::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos)
{
    MENUITEMINFO    mii;
    HMENU           hmenuMain;
    OLECMD          rgMimeEditCmds[]=   {{MECMDID_EDITMODE, 0},
                                         {MECMDID_ROT13, 0},
                                         {MECMDID_EDITHTML, 0}};
    OLECMD          rgStdCmds[]=       {{OLECMDID_CUT, 0},
                                        {OLECMDID_COPY, 0},
                                        {OLECMDID_PASTE, 0},
                                        {OLECMDID_SELECTALL, 0},
                                        {OLECMDID_UNDO, 0},
                                        {OLECMDID_REDO, 0},
                                        {OLECMDID_FIND, 0}};
    int     rgidsStd[]=                 {idmCut,
                                        idmCopy,
                                        idmPaste,
                                        idmSelectAll,
                                        idmUndo,
                                        idmRedo,
                                        idmFind};
    int     rgidsMimeEdit[]=            {idmEditDocument,
                                         idmRot13,
                                         idmHTMLMode};
    int     i,
            idm;
    VARIANTARG  va;
    ULONG   u;

    hmenuMain = GetMenu(hwnd);
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    GetMenuItemInfo(hmenuMain, uPos, TRUE, &mii);

    switch (mii.wID)
        {
        case idmPopupFile:
            EnableMenuItem(hmenuPopup, idmOpen, MF_BYCOMMAND|MF_ENABLED);
            EnableMenuItem(hmenuPopup, idmPrint, MF_BYCOMMAND|MF_ENABLED);
            EnableMenuItem(hmenuPopup, idmSaveAs, MF_BYCOMMAND|MF_ENABLED);
            break;

        case idmPopupEdit:
            if (m_pCmdTarget)
                {
                if (m_pCmdTarget->QueryStatus(NULL, sizeof(rgStdCmds)/sizeof(OLECMD), rgStdCmds, NULL)==S_OK)
                    for(i=0; i<sizeof(rgStdCmds)/sizeof(OLECMD); i++)
                        SetMenuItem(hmenuPopup, rgidsStd[i], rgStdCmds[i].cmdf & OLECMDF_ENABLED);

                if (m_pCmdTarget->QueryStatus(&CMDSETID_MimeEdit, sizeof(rgMimeEditCmds)/sizeof(OLECMD), rgMimeEditCmds, NULL)==S_OK)
                    for(i=0; i<sizeof(rgMimeEditCmds)/sizeof(OLECMD); i++)
                        {
                        SetMenuItem(hmenuPopup, rgidsMimeEdit[i], rgMimeEditCmds[i].cmdf & OLECMDF_ENABLED);
                        CheckMenuItem(hmenuPopup, rgidsMimeEdit[i], MF_BYCOMMAND|(rgMimeEditCmds[i].cmdf & OLECMDF_LATCHED ? MF_CHECKED: MF_UNCHECKED));
                        }                
                }
            break;

        case idmPopupView:
            u = MESTYLE_NOHEADER;
            if (m_pCmdTarget && 
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
                u = va.lVal;
            
            switch(u)
                {
                case MESTYLE_NOHEADER:
                    idm = idmNoHeader;
                    break;
                case MESTYLE_MINIHEADER:
                    idm = idmMiniHeader;
                    break;
                case MESTYLE_PREVIEW:
                    idm = idmPreview;
                    break;
                case MESTYLE_FORMATBAR:
                    idm = idmFormatBar;
                    break;
                }
            CheckMenuRadioItem(hmenuPopup, idmNoHeader, idmFormatBar, idm, MF_BYCOMMAND|MF_ENABLED);
            SetMenuItem(hmenuPopup, idmNoHeader, TRUE);
            SetMenuItem(hmenuPopup, idmMiniHeader, TRUE);            
            SetMenuItem(hmenuPopup, idmPreview, TRUE);
            SetMenuItem(hmenuPopup, idmFormatBar, TRUE);
            break;

        case idmPopupTools:
            {
            OLECMD CmdSpell = {OLECMDID_SPELL, 0};

            SetMenuItem(hmenuPopup, idmFmtPreview, TRUE);
            if (m_pCmdTarget)
                m_pCmdTarget->QueryStatus(NULL, 1, &CmdSpell, NULL);

            SetMenuItem(hmenuPopup, idmSpelling, CmdSpell.cmdf & OLECMDF_ENABLED);
            }

            break;
        }
    return 0;
}



HRESULT CMeHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   uCmd;
    HRESULT hr;

    if (pguidCmdGroup &&
        IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEditHost))
        {
        for (uCmd=0; uCmd < cCmds; uCmd++)
            rgCmds[uCmd].cmdf = OLECMDF_SUPPORTED|OLECMDF_ENABLED;
        return S_OK;
        }

    hr = CDocHost::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);

    if (pguidCmdGroup==NULL)
        {
        for (uCmd=0; uCmd < cCmds; uCmd++)
            {
            switch(rgCmds[uCmd].cmdID)
                {
                case OLECMDID_PROPERTIES:
                    rgCmds[uCmd].cmdf = OLECMDF_SUPPORTED|OLECMDF_ENABLED;
                    break;
                }
            }
        }

    return hr;
}

        

HRESULT CMeHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,	VARIANTARG *pvaOut)
{
    CHAR    rgch[MAX_PATH];
    WCHAR   rgchW[MAX_PATH];

    if (pguidCmdGroup &&
        IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEditHost))
        {
        switch (nCmdID)
            {
            case MEHOSTCMDID_BORDERFLAGS:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = MEBF_OUTERCLIENTEDGE|MEBF_FORMATBARSEP;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SIGNATURE:
                if (pvaOut)
                    {
                    MultiByteToWideChar(CP_ACP, 0, g_szSig, -1, rgchW, MAX_PATH);

                    pvaOut->vt = VT_BSTR;
                    pvaOut->bstrVal = SysAllocString(rgchW);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SIGNATURE_OPTIONS:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = MESIGOPT_TOP|(g_fSigHtml?MESIGOPT_HTML:MESIGOPT_PLAIN);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SIGNATURE_ENABLED:
                if (pvaIn)
                    {
                    if (pvaIn->lVal == MESIG_AUTO && !g_fAutoSig)
                        return S_FALSE;
                    else
                        return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_REPLY_TICK_COLOR:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4; 
                    pvaOut->lVal = RGB(255,0,0);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_HEADER_TYPE:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = g_lHeaderType;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_QUOTE_CHAR:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4; // apply quoteing to plain-text stream
                    pvaOut->lVal = g_fQuote?g_chQuote:NULL;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SLIDESHOW_DELAY:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = 5;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_COMPOSE_FONT:
                if (pvaOut && g_fComposeFont)
                    {
                    MultiByteToWideChar(CP_ACP, 0, g_szComposeFont, -1, rgchW, MAX_PATH);

                    pvaOut->vt = VT_BSTR;
                    pvaOut->bstrVal = SysAllocString(rgchW);
                    }

                return g_fComposeFont?S_OK:S_FALSE;

            case MEHOSTCMDID_FLAGS:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = 0;
                    
                    if (g_fAutoSig)
                        pvaOut->lVal |= MEO_FLAGS_AUTOTEXT;

                    if (g_fHTML && m_fHTMLMode)
                        pvaOut->lVal |= MEO_FLAGS_HTML;

                    if (g_fAutoInline)
                        pvaOut->lVal |= MEO_FLAGS_AUTOINLINE;

                    if (g_fSlideShow)
                        pvaOut->lVal |= MEO_FLAGS_SLIDESHOW;

                    if (g_fIncludeMsg)
                        pvaOut->lVal |= MEO_FLAGS_INCLUDEMSG;

                    if (g_fSendImages)
                        pvaOut->lVal |= MEO_FLAGS_SENDIMAGES;

                    if (g_fBlockQuote)
                        pvaOut->lVal |= MEO_FLAGS_BLOCKQUOTE;

                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_ADD_TO_ADDRESSBOOK:
            case MEHOSTCMDID_ADD_TO_FAVORITES:
                if (pvaIn &&
                    pvaIn->vt == VT_BSTR &&
                    pvaIn->bstrVal != NULL)
                    {
                    WideCharToMultiByte(CP_ACP, 0, pvaIn->bstrVal, -1, rgch, MAX_PATH, NULL, NULL);                    
                    MessageBox(m_hwnd, rgch, nCmdID == MEHOSTCMDID_ADD_TO_FAVORITES ? 
                                        "CMeHost - AddToFavorites" :
                                        "CMeHost - AddToAddressBook", MB_OK);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            }
            return OLECMDERR_E_NOTSUPPORTED;
        }

    if (pguidCmdGroup==NULL)
        {
        switch (nCmdID)
            {
            case OLECMDID_PROPERTIES:
                MessageBox(m_hwnd, "This is a place holder for the note properties dialog", "MePad", MB_OK);
                return S_OK;
            }
        }

    return CDocHost::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut);
}


BOOL CALLBACK MhtmlDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD   dwFlags;

    switch (msg)
        {
        case WM_INITDIALOG:
            CheckDlgButton(hwnd, idcHTML, BST_CHECKED);
            CheckDlgButton(hwnd, idcPlain, BST_CHECKED);
            CheckDlgButton(hwnd, idcImages, BST_CHECKED);
            CheckDlgButton(hwnd, idcFiles, BST_CHECKED);

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    dwFlags = 0;

                    if (IsDlgButtonChecked(hwnd, idcImages))
                        dwFlags |= MECD_ENCODEIMAGES;

                    if (IsDlgButtonChecked(hwnd, idcPlain))
                        dwFlags |= MECD_PLAINTEXT;

                    if (IsDlgButtonChecked(hwnd, idcHTML))
                        dwFlags |= MECD_HTML;

                    if (IsDlgButtonChecked(hwnd, idcFiles))
                        dwFlags |= MECD_ENCODEFILEURLSONLY;

                    EndDialog(hwnd, dwFlags);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hwnd, -1);
                    return TRUE;
                }
            break;
        }


    return FALSE;
}


BOOL CALLBACK CMeHost::ExtFmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMeHost *pHost=(CMeHost *)GetWindowLong(hwnd, DWL_USER);

    if (msg==WM_INITDIALOG)
        {
        pHost = (CMeHost *)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);
        }

    return pHost?pHost->FmtDlgProc(hwnd, msg, wParam, lParam):FALSE;
}


BOOL CMeHost::FmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WCHAR       rgchW[MAX_PATH];
    VARIANTARG  va;
    
    switch (msg)
        {
        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    GetWindowText(GetDlgItem(hwnd, idcEdit), m_szFmt, sizeof(m_szFmt));
                    MultiByteToWideChar(CP_ACP, 0, m_szFmt, -1, rgchW, MAX_PATH);
                    if (m_pCmdTarget)
                        {
                        va.vt = VT_BSTR;
                        va.bstrVal = (BSTR)rgchW;
                        m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_PREVIEWFORMAT, OLECMDEXECOPT_DODEFAULT, &va, NULL);
                        }

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            SetWindowText(GetDlgItem(hwnd, idcEdit), m_szFmt);
            SetFocus(GetDlgItem(hwnd, idcEdit));
            break;
        }

    return FALSE;
}


UINT uCodePageFromCharset(IMimeInternational *pIntl, HCHARSET hCharset)
{
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = GetACP();

    if (hCharset && 
        (pIntl->GetCharsetInfo(hCharset, &CsetInfo)==S_OK))
        uiCodePage = CsetInfo.cpiWindows ;

    return uiCodePage;
}


BOOL CALLBACK CMeHost::ExtLangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMeHost *pHost=(CMeHost *)GetWindowLong(hwnd, DWL_USER);

    if (msg==WM_INITDIALOG)
        {
        pHost = (CMeHost *)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);
        }

    return pHost?pHost->LangDlgProc(hwnd, msg, wParam, lParam):FALSE;
}


BOOL CMeHost::LangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    VARIANTARG  va;
    HKEY        hk=0,
                hkSub;
    LONG        cb;
    DWORD       n=0,
                l,
                dwCodePage,
                dwType;
    TCHAR       rgch[MAX_PATH];
    HWND        hwndCombo = GetDlgItem(hwnd, idcLang);
    HCHARSET    hCharset;
    HRESULT     hr;

    switch (msg)
        {
        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    l = SendMessage(hwndCombo, CB_GETCURSEL, 0 ,0);
                    dwCodePage = SendMessage(hwndCombo, CB_GETITEMDATA, l, 0);
                    m_pIntl->GetCodePageCharset(dwCodePage, CHARSET_BODY, &hCharset);
                    if (m_pCmdTarget)
                        {
                        va.vt = VT_I4;
                        va.lVal = (LONG)hCharset;
                        if (FAILED(hr=m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_CHARSET, OLECMDEXECOPT_DODEFAULT, &va, NULL)))
                            {
                            wsprintf(rgch, "Could not switch language hr=0x%x", hr);
                            MessageBox(m_hwnd, rgch, "MePad", MB_OK);
                            }
                        }

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            if (RegOpenKey(HKEY_CLASSES_ROOT, "MIME\\Database\\Codepage", &hk)==ERROR_SUCCESS)
                {            
                while (RegEnumKey(hk, n++, rgch, MAX_PATH)==ERROR_SUCCESS)
                    {
                    dwCodePage = atoi(rgch);

                    if (RegOpenKey(hk, rgch, &hkSub)==ERROR_SUCCESS)
                        {
                        cb = MAX_PATH;
                        if (RegQueryValueEx(hkSub, "Description", 0, &dwType, (LPBYTE)rgch, (ULONG *)&cb)==ERROR_SUCCESS)
                            {
                            l = SendMessage(hwndCombo, CB_ADDSTRING, NULL, (LPARAM)rgch);
                            if (l>=0)
                                SendMessage(hwndCombo, CB_SETITEMDATA, l, dwCodePage);

                            }
                        CloseHandle(hkSub);
                        }
                    }
                CloseHandle(hk);
                }; 

            if (m_pCmdTarget)
                {
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_CHARSET, OLECMDEXECOPT_DODEFAULT, NULL, &va);
                dwCodePage = uCodePageFromCharset(m_pIntl, (HCHARSET)va.lVal);
                }
            else
                dwCodePage = 0;

            l = SendMessage(hwndCombo, CB_GETCOUNT, NULL, NULL);
            for (n=0; n<l; n++)
                {
                if ((DWORD)SendMessage(hwndCombo, CB_GETITEMDATA, n, NULL)==dwCodePage)
                    {
                    SendMessage(hwndCombo, CB_SETCURSEL, n, NULL);
                    break;
                    }
                }
            
            SetFocus(hwndCombo);
            return TRUE;
        }

    return FALSE;
}



LRESULT CMeHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    VARIANTARG          va;
    int                 id;
    BOOL                fDirty=FALSE;
    IOleDocumentView    *pDocView;

    switch (msg)
        {
        case WM_NCACTIVATE:
            if (m_lpOleObj && 
                m_lpOleObj->QueryInterface(IID_IOleDocumentView, (LPVOID *)&pDocView)==S_OK)
                {
                pDocView->UIActivate(LOWORD(wParam));
                pDocView->Release();
                }
            break;

        case WM_CLOSE:
            if (m_pCmdTarget && 
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_DIRTY, 0, 0, &va)==S_OK &&
                va.vt == VT_BOOL)
                fDirty = va.boolVal == VARIANT_TRUE;
            
            if (fDirty)
                {
                id = MessageBox(m_hwnd, "This message has been modified. Do you want to save the changes?", 
                                        "MimeEdit Host", MB_YESNOCANCEL);
                if (id==IDCANCEL)
                    return 0;
                
                if (id==IDYES)
                    {
                    if (Save()==MIMEEDIT_E_USERCANCEL)
                        return 0;
                    }

                }
            break;
        }

    return CDocHost::WndProc(hwnd, msg, wParam, lParam);
}





HRESULT CMeHost::Save()
{
    if (*m_szFileW==NULL)
        return SaveAs();

    return SaveToFile(m_szFileW);
}

HRESULT CMeHost::SaveAs()
{
    OPENFILENAME    ofn;
    TCHAR           szFile[MAX_PATH];
    TCHAR           szTitle[MAX_PATH];
    TCHAR           szDefExt[30];

    if (!m_lpOleObj)
        return E_FAIL;

    lstrcpy(szFile, "c:\\*.eml");
    lstrcpy(szDefExt, ".eml");
    lstrcpy(szTitle, "Save Message As...");
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = c_szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;

    if (*szFile==NULL)
        return E_FAIL;
    

    // Show OpenFile Dialog
    if (!GetSaveFileName(&ofn))
        return MIMEEDIT_E_USERCANCEL;
 
    MultiByteToWideChar(CP_ACP, 0, szFile, -1, m_szFileW, MAX_PATH);

    SetWindowText(m_hwnd, szFile);
    return SaveToFile(m_szFileW);
}

HRESULT CMeHost::SaveAsMhtmlTest()
{
    IMimeMessage        *pMsg;
    IHTMLDocument2      *pDoc;
    IServiceProvider    *pSP;
    DWORD               dwFlags;
            
    if (m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
        {
        if (pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&pDoc)==S_OK)
            {
            dwFlags = DialogBox(g_hInst, MAKEINTRESOURCE(iddSaveAsMHTML), m_hwnd, (DLGPROC)MhtmlDlgProc);
            if (dwFlags != -1)
                {
                if (!FAILED(MimeEditCreateMimeDocument(pDoc, m_pMsg, dwFlags, &pMsg)))
                    {
                    SetEncodingOptions(pMsg, GetCharset());
                    pMsg->Commit(0);
                    MimeEditViewSource(m_hwnd, pMsg);
                    pMsg->Release();
                    }
                }
            pDoc->Release();
            }
        pSP->Release();
        }
    return S_OK;
}

HRESULT CMeHost::SaveToFile(LPWSTR pszW)
{
    IPersistMime        *ppm;
    IPersistFile        *pPF;
    IMimeMessage        *pMsg;
    HRESULT             hr;

    hr = m_lpOleObj->QueryInterface(IID_IPersistMime, (LPVOID *)&ppm);
    if (!FAILED(hr))
        {
        hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
        if (!FAILED(hr))
            {
            pMsg->InitNew();

            hr = pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF);
            if (!FAILED(hr))
                {
                hr = ppm->Save(pMsg, PMS_TEXT|PMS_HTML);
                if (!FAILED(hr))
                    {
                    SetEncodingOptions(pMsg, GetCharset());
                    hr = pPF->Save(pszW, FALSE);
                    }
                pPF->Release();
                }
            pMsg->Release();
            }
        ppm->Release();
        }

    return hr;
}

HCHARSET CMeHost::GetCharset()
{
    VARIANTARG  va;
    HCHARSET    hCharset=0;

    if (m_pCmdTarget && 
        m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_CHARSET, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
        hCharset = (HCHARSET)va.lVal;

    // if no charset has been set yet, let's use system codepage
    if (hCharset==NULL)
        m_pIntl->GetCodePageCharset(GetACP(), CHARSET_BODY, &hCharset);

    return hCharset;
}

HRESULT SetEncodingOptions(IMimeMessage *pMsg, HCHARSET hCharset)
{
    PROPVARIANT     rVariant;

    // Save Format
    rVariant.vt = VT_UI4;
    rVariant.ulVal = (ULONG)SAVE_RFC1521;
    pMsg->SetOption(OID_SAVE_FORMAT, &rVariant);

    // Text body encoding
    rVariant.ulVal = (ULONG)IET_QP;
    pMsg->SetOption(OID_TRANSMIT_TEXT_ENCODING, &rVariant);

    // Plain Text body encoding
    rVariant.ulVal = (ULONG)IET_QP;
    pMsg->SetOption(OID_XMIT_PLAIN_TEXT_ENCODING, &rVariant);

    // HTML Text body encoding
    rVariant.ulVal = (ULONG)IET_QP;
    pMsg->SetOption(OID_XMIT_HTML_TEXT_ENCODING, &rVariant);

    pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
    return S_OK;
}



HRESULT IPersistMimeLoad(IUnknown *pUnk, IMimeMessage *pMsg)
{
    IPersistMime    *pPM;
    HRESULT         hr;

    hr = pUnk->QueryInterface(IID_IPersistMime, (LPVOID *)&pPM);
    if (!FAILED(hr))
        {
        hr = pPM->Load(pMsg);
        pPM->Release();
        }
    return hr;
}


HRESULT CMeHost::BackRed()
{
    IServiceProvider    *pSP;
    IHTMLDocument2      *pDoc;
    IHTMLElement        *pElem;
    IHTMLBodyElement    *pBody;
    VARIANTARG          v;    

    if (m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
        {
        if (pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&pDoc)==S_OK)
            {
            pElem=0;
            pDoc->get_body(&pElem);
            if (pElem)
                {
                if (pElem->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)&pBody)==S_OK)
                    {
                    v.vt = VT_BSTR;
                    v.bstrVal = SysAllocString(L"#FF0000");
                    if (v.bstrVal)
                        {
                        pBody->put_bgColor(v);
                        SysFreeString(v.bstrVal);
                        }
                    pBody->Release();
                    }
                pElem->Release();
                }
            pDoc->Release();
            }
        pSP->Release();
        }
    return S_OK;
    
}

HRESULT CMeHost::ForeRed()
{
    IServiceProvider        *pSP;
    IHTMLDocument2          *pDoc;
    IHTMLSelectionObject    *pSel=0;
    IOleCommandTarget       *pCmdTarget;
    IDispatch               *pID;

    if (m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
        {
        if (pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&pDoc)==S_OK)
            {
            pDoc->get_selection(&pSel);
            if (pSel)
                {
                pSel->createRange(&pID);
                if (pID)
                    {
                    if (pID->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
                        {
                        VARIANTARG  v;
                        v.vt = VT_BSTR;
                        v.bstrVal = SysAllocString(L"#FF0000");
                        if (v.bstrVal)
                            {
                            pCmdTarget->Exec(&CMDSETID_Forms3, IDM_BACKCOLOR, NULL, &v, NULL);
                            SysFreeString(v.bstrVal);
                            }
                        }
                    pID->Release();
                    }
                pSel->Release();
                }
            pDoc->Release();
            }
        pSP->Release();
        }
    return S_OK;
}


HRESULT CMeHost::SaveAsStationery()
{
    VARIANTARG  vaIn,
                vaOut;
    char        rgch[MAX_PATH],
                rgch2[MAX_PATH+50];
                

    vaIn.vt = VT_BSTR;
    vaIn.bstrVal = SysAllocString(L"C:\\PROGRAM FILES\\COMMON FILES\\MICROSOFT SHARED\\STATIONERY");
    if (vaIn.bstrVal)
        {
        if (m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_SAVEASSTATIONERY, NULL, &vaIn, &vaOut)==S_OK)
            {
            if (WideCharToMultiByte(CP_ACP, 0, vaOut.bstrVal, SysStringLen(vaOut.bstrVal), rgch, MAX_PATH, NULL, NULL))
                {
                wsprintf(rgch2, "Stationery saved to %s", rgch);
                MessageBox(m_hwnd, rgch, "SaveAsStationery", MB_OK);
                }
            SysFreeString(vaOut.bstrVal);
            }
        SysFreeString(vaIn.bstrVal);
        }
    return S_OK;
}

HRESULT CMeHost::BackgroundPicture()
{
    VARIANT va;
    char    szUrl[MAX_PATH];
    WCHAR   szUrlW[MAX_PATH];
    BSTR    bstr;

    *szUrl=0;

    if (m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, NULL, NULL, &va)==S_OK)
        WideCharToMultiByte(CP_ACP, 0, va.bstrVal, -1, szUrl, MAX_PATH, NULL, NULL);

    if (GenericPrompt(m_hwnd, "Edit Background Picture...", "Choose a picture", szUrl, MAX_PATH)==S_OK)
        {
        if (MultiByteToWideChar(CP_ACP, 0, szUrl, -1, szUrlW, MAX_PATH) &&
            (bstr = SysAllocString(szUrlW)))
            {
            va.vt = VT_BSTR;
            va.bstrVal = bstr;
            m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, NULL, &va, NULL);
            SysFreeString(bstr);
            }
        }
    return S_OK;
}

HRESULT CMeHost::HrLoadFile(LPSTR pszFile)
{
    IPersistFile    *pPF;
    IMimeMessage    *pMsg;

    if (!m_lpOleObj)
        return E_FAIL;

    if (pszFile == NULL || *pszFile==NULL)
        return E_FAIL;
    
    MultiByteToWideChar(CP_ACP, 0, pszFile, -1, m_szFileW, MAX_PATH);

    if (CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg)==S_OK)
        {
        if (pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF)==S_OK)
            {
            if (pPF->Load(m_szFileW, 0)==S_OK)
                {
                if (IPersistMimeLoad(m_lpOleObj, pMsg)==S_OK)
                    {
                    SetWindowText(m_hwnd, pszFile);
                    ReplaceInterface(m_pMsg, pMsg);
                    }
                }
            pPF->Release();
            } 
        pMsg->Release();
        }            
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\mepad.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "frame.h"

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
HINSTANCE           g_hInst=NULL;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
    CMDIFrame *pFrame=0;
    MSG         msg;

    g_hInst = hInstance;

    OleInitialize(NULL);

    pFrame = new CMDIFrame();
    if(pFrame)
    {
        pFrame->HrInit(szCmdLine);
        while(GetMessage(&msg, NULL, 0, 0))
        {
             if (pFrame->TranslateAcclerator(&msg)==S_OK)
                continue;

             TranslateMessage(&msg) ;
             DispatchMessage(&msg) ;
        }
        ReleaseObj(pFrame);
		OleUninitialize();
        return msg.wParam ;
    }

	OleUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\mehost.h ===
#ifndef _MEHOST_H
#define _MEHOST_H

#include "dochost.h"
#include "mimeole.h"

class CMeHost :
    public CDocHost
{

public:
    CMeHost();
    virtual ~CMeHost();
    virtual ULONG   STDMETHODCALLTYPE AddRef();
    virtual ULONG   STDMETHODCALLTYPE Release();

    HRESULT HrInit(HWND hwndMDIClient, IOleInPlaceFrame *pFrame);
    HRESULT HrLoadFile(LPSTR pszFile);

    HRESULT OnCommand(HWND hwnd, int id, WORD wCmd);
    LRESULT OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos);

    // IOleCommandTarget 
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD [], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);
    static BOOL CALLBACK ExtFmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK ExtLangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    BOOL                m_fEditMode,
                        m_fHTMLMode;
    char                m_szFmt[256];
    WCHAR               m_szFileW[MAX_PATH];
    IMimeMessage        *m_pMsg;
    IMimeInternational  *m_pIntl;

    HRESULT HrOpen(HWND hwnd);

    BOOL FmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL LangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT Save();
    HRESULT SaveAs();
    HRESULT SaveAsStationery();
    HRESULT SaveToFile(LPWSTR pszW);
    HRESULT SaveAsMhtmlTest();
    HCHARSET GetCharset();
    HRESULT BackRed();
    HRESULT ForeRed();
    HRESULT BackgroundPicture();
};

typedef CMeHost *LPMEHOST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\pch.cpp ===
#include "pch.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\mepadrt.h ===
#ifndef _MEPADRT_H
#define _MEPADRT_H

 // -------------------------------------------------------------------------
 // ReplaceInterface - Replaces a member interface with a new interface
 // -------------------------------------------------------------------------

 #define ReplaceInterface(_pUnk, _pUnkNew)  \
     { \
     if (_pUnk)  \
         _pUnk->Release();   \
     if (_pUnk = _pUnkNew)   \
         _pUnk->AddRef();    \
     }

#define ReleaseObj(_object)   (_object) ? (_object)->Release() : 0

#define SafeRelease(_object) \
    if (_object) { \
        (_object)->Release(); \
        (_object) = NULL; \
    } else

#define GetWndThisPtr(hwnd) \
    GetWindowLong(hwnd, GWL_USERDATA)


#endif // _MEPADRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\util.h ===
#ifndef _UTIL_H
#define _UTIL_H

#include <commctrl.h>

#define ReleaseObj(_object) (_object) ? (_object)->Release() : 0

void ProcessTooltips(LPTOOLTIPTEXT lpttt);
UINT TTIdFromCmdId(UINT idCmd);
void HandleMenuSelect(HWND hStatus, WPARAM wParam, LPARAM lParam);
HRESULT GenericPrompt(HWND hwnd, char *szCaption, char *szPrompt, char *szBuffer, int nLen);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\util.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "mimeole.h"

BOOL CALLBACK GenericDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

void ProcessTooltips(LPTOOLTIPTEXT lpttt)
{
    if (lpttt->lpszText = MAKEINTRESOURCE(TTIdFromCmdId(lpttt->hdr.idFrom)))
        lpttt->hinst = g_hInst;
    else
        lpttt->hinst = NULL;
}


UINT TTIdFromCmdId(UINT idCmd)
{
    if (idCmd >= IDM_FIRST && idCmd <= IDM_LAST)
        idCmd += TT_BASE;
    else
        idCmd = 0;
    return(idCmd);
}


void HandleMenuSelect(HWND hStatus, WPARAM wParam, LPARAM lParam)
{
    UINT    fuFlags, uItem;
    HMENU   hmenu=GET_WM_MENUSELECT_HMENU(wParam, lParam);
    CHAR    rgch[MAX_PATH]={0};
    LPSTR   psz=NULL;
    
    if (!hStatus)
        return;

    uItem = (UINT)LOWORD(wParam);
    fuFlags = (UINT)HIWORD(wParam);

    if(fuFlags & MF_POPUP)
    {
        MENUITEMINFO mii = { sizeof(MENUITEMINFO), MIIM_ID, 0 };
        if(hmenu && IsMenu(hmenu) && GetMenuItemInfo(hmenu, uItem, TRUE, &mii))
        {
            // change the parameters to simulate a normal menu item
            uItem = mii.wID;
            fuFlags = 0;
        }
    }         

    if(0 == (fuFlags & (MF_SYSMENU | MF_POPUP)))
    {
        if(uItem >= IDM_FIRST && uItem <= IDM_LAST)
        {
            uItem = uItem + MH_BASE;
            LoadString(g_hInst, (UINT)MAKEINTRESOURCE(uItem), rgch, sizeof(rgch));
            psz = rgch; 
        }
    }

    SendMessage(hStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)psz);

}


typedef struct GPINFO_tag
{
    char    *szCaption;
    char    *szPrompt;
    char    *szBuffer;
    int     nLen;
} GPINFO, *PGPINFO;

HRESULT GenericPrompt(HWND hwnd, char *szCaption, char *szPrompt, char *szBuffer, int nLen)
{
    GPINFO  rGInfo;

    rGInfo.szCaption = szCaption;
    rGInfo.szPrompt = szPrompt;
    rGInfo.szBuffer= szBuffer;
    rGInfo.nLen = nLen;

    if (DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddGeneric), hwnd, (DLGPROC)GenericDlgProc, (LPARAM)&rGInfo)==IDOK)
        return S_OK;
    else
        return MIMEEDIT_E_USERCANCEL;
}


BOOL CALLBACK GenericDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PGPINFO pGInfo;

    switch (msg)
        {
        case WM_COMMAND:
            pGInfo = (PGPINFO)GetWindowLong(hwnd, DWL_USER);

            switch (LOWORD(wParam))
                {
                case IDOK:
                    GetWindowText(GetDlgItem(hwnd, idcEdit), pGInfo->szBuffer, pGInfo->nLen);

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            SetWindowLong(hwnd, DWL_USER, lParam);
            pGInfo = (PGPINFO)lParam;
            
            SetWindowText(GetDlgItem(hwnd, -1), pGInfo->szPrompt);
            SetWindowText(hwnd, pGInfo->szCaption);
            SetWindowText(GetDlgItem(hwnd, idcEdit), pGInfo->szBuffer);
            break;
        }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mepad\resource.h ===
#ifndef _RESOURCE_H
#define _RESOURCE_H

#define idiApp                          4
// bitmaps
#define idbToolbar                      9
//menu help
#define MH_BASE                         1

// menu commands
#define IDM_FIRST                       100

#define idmPopupFile                    (IDM_FIRST + 0)  
#define idmNew                          (IDM_FIRST + 1)  
#define idmOpen                         (IDM_FIRST + 2)  
#define idmSave                         (IDM_FIRST + 3)  
#define idmSaveAs                       (IDM_FIRST + 4)  
#define idmPageSetup                    (IDM_FIRST + 5)  
#define idmPrint                        (IDM_FIRST + 6)  
#define idmClose                        (IDM_FIRST + 7)  
#define idmPopupGo                      (IDM_FIRST + 8)  
#define idmBack                         (IDM_FIRST + 9)  
#define idmForward                      (IDM_FIRST + 10)  
#define idmPopupHelp                    (IDM_FIRST + 12)  
#define idmAbout                        (IDM_FIRST + 13)  
#define idmToggleToolbar                (IDM_FIRST + 14)  
#define idmToggleStatusbar              (IDM_FIRST + 15)  
#define idmPopupView                    (IDM_FIRST + 16)
#define idmCascade                      (IDM_FIRST + 17)
#define idmTile                         (IDM_FIRST + 18)
#define idmUndo                         (IDM_FIRST + 19)
#define idmRedo                         (IDM_FIRST + 20)
#define idmCut                          (IDM_FIRST + 21)
#define idmCopy                         (IDM_FIRST + 22)
#define idmPaste                        (IDM_FIRST + 23)
#define idmEditDocument                 (IDM_FIRST + 24)
#define idmSelectAll                    (IDM_FIRST + 25)
#define idmPopupEdit                    (IDM_FIRST + 26)
#define idmPopupWindow                  (IDM_FIRST + 27)
#define idmFind                         (IDM_FIRST + 28)
#define idmViewSource                   (IDM_FIRST + 29)
#define idmViewMsgSource                (IDM_FIRST + 30)
#define idmRot13                        (IDM_FIRST + 31)
#define idmNoHeader                     (IDM_FIRST + 35)
#define idmPreview                      (IDM_FIRST + 36)
#define idmMiniHeader                   (IDM_FIRST + 37)
#define idmFormatBar                    (IDM_FIRST + 38)
#define idmPopupTools                   (IDM_FIRST + 39)
#define idmFmtPreview                   (IDM_FIRST + 40)
#define idmLang                         (IDM_FIRST + 41)
#define idmSpelling                     (IDM_FIRST + 42)
#define idmOptions                      (IDM_FIRST + 43)
#define idmSaveAsMHTML                  (IDM_FIRST + 44)
#define idmHTMLMode                     (IDM_FIRST + 45)
#define idmSetText                      (IDM_FIRST + 46)
#define idmFont                         (IDM_FIRST + 47)
#define idmPara                         (IDM_FIRST + 48)
#define idmInsertFile                   (IDM_FIRST + 49)
#define idmTestBackRed                  (IDM_FIRST + 50)
#define idmTestForeRed                  (IDM_FIRST + 51)
#define idmSaveAsStationery             (IDM_FIRST + 52)
#define idmBackground                   (IDM_FIRST + 53)

#define IDM_LAST                        (IDM_FIRST + 2000)


// TOOLTIP strings
#define TT_BASE                         (IDM_LAST + MH_BASE + 1)

// menus
#define idmrMainMenu                    8

// accels
#define idacMeHost                      10

// dialog ID's
#define iddFmt                          100
#define iddLang                         101
#define iddOptions                      102
#define iddSaveAsMHTML                  103
#define iddGeneric                      104

// controls
#define idcEdit                         10
#define idcLang                         11

#define idcAuto                         21
#define idcSlide                        22
#define idcQuote                        23
#define ideQuote                        24
#define idcHTML                         25
#define idcInclude                      26
#define idcSendImages                   27
#define idcImages                       28
#define idcPlain                        29
#define idcHtml                         30
#define idcComposeFont                  31
#define ideComposeFont                  32
#define idrbNone                        40
#define idrbMail                        41
#define idrbNews                        42
#define idrbPrint                       43
#define idcBlockQuote                   50
#define idcSigHtml                      51
#define idcSig                          52
#define ideSig                          53
#define idcFiles                        54
    
#endif  // _RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\attrun.h ===
#define IDC_SAFEOPEN_ALWAYS             1001
#define IDC_SAFEOPEN_ICON               1002
#define IDC_SAFEOPEN_EXPL               1003
#define IDC_SAFEOPEN_AUTOOPEN           1004
#define IDC_SAFEOPEN_AUTOSAVE           1005
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\basemht.cpp ===
/*
 *    b a s e m h t . c p p 
 *    
 *    Purpose:
 *        Base classes for MHTML packer objects
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "mhtml.h"
#include "basemht.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

/*
 *  t y p e d e f s
 */

 
/* 
 *   F u n c t i o n s
 */


CBaseTag::CBaseTag()
{
    m_cRef = 1;
    m_pElem = NULL;
    m_bstrDest = NULL;
    m_bstrSrc = NULL;
}


CBaseTag::~CBaseTag()
{
    ReleaseObj(m_pElem);
    SysFreeString(m_bstrDest);
    SysFreeString(m_bstrSrc);

}

ULONG CBaseTag::AddRef()
{
    return ++m_cRef;
}

ULONG CBaseTag::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CBaseTag::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return TraceResult(E_INVALIDARG);

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IUnknown *)this;
    else if (IsEqualIID(riid, IID_IMimeEditTag))
        *lplpObj = (LPVOID)(IMimeEditTag *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CBaseTag::Init(IHTMLElement *pElem)
{
    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    ReplaceInterface(m_pElem, pElem);
    return S_OK;
}

HRESULT CBaseTag::GetSrc(BSTR *pbstr)
{
    if (pbstr == NULL)
        return TraceResult(E_INVALIDARG);

    *pbstr = SysAllocString(m_bstrSrc);
    return *pbstr ? S_OK : E_FAIL;
}

HRESULT CBaseTag::SetSrc(BSTR bstr)
{
    return E_NOTIMPL;
}

HRESULT CBaseTag::GetDest(BSTR *pbstr)
{
    if (pbstr == NULL)
        return TraceResult(E_INVALIDARG);

    *pbstr = SysAllocString(m_bstrDest);
    return *pbstr ? S_OK : E_FAIL;
}

HRESULT CBaseTag::SetDest(BSTR bstr)
{
    SysFreeString(m_bstrDest);
    m_bstrDest = SysAllocString(bstr);
    return S_OK;
}

HRESULT CBaseTag::OnPreSave()
{
    return S_OK;
}

HRESULT CBaseTag::OnPostSave()
{
    return S_OK;
}


HRESULT CBaseTag::CanPackage()
{
    return S_OK;
}

HRESULT CBaseTag::IsValidMimeType(LPWSTR pszTypeW)
{
    return S_OK;
}

    
    
CBaseTagCollection::CBaseTagCollection()
{
    m_cRef = 1;
    m_rgpTags = NULL;
    m_cTags = 0;
    m_uEnum = 0;
}


CBaseTagCollection::~CBaseTagCollection()
{
    _FreeCollection();
}

ULONG CBaseTagCollection::AddRef()
{
    return ++m_cRef;
}

ULONG CBaseTagCollection::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CBaseTagCollection::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return TraceResult(E_INVALIDARG);

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IUnknown *)this;
    else if (IsEqualIID(riid, IID_IMimeEditTagCollection))
        *lplpObj = (LPVOID)(IMimeEditTagCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CBaseTagCollection::Init(IUnknown *pDocUnk)
{
    IHTMLDocument2  *pDoc=0;
    HRESULT         hr;

    if (pDocUnk == NULL)
        return E_INVALIDARG;

    hr = pDocUnk->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
    if (FAILED(hr))
        goto error;
    
    hr = _BuildCollection(pDoc);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pDoc);
    return hr;
}

HRESULT CBaseTagCollection::Next(ULONG cWanted, IMimeEditTag **prgpTag, ULONG *pcFetched)
{
    HRESULT     hr=S_OK;
    ULONG       cFetch,
                uTag;

    if (pcFetched)
        *pcFetched = 0;

    // nothing to give back
    if (m_cTags == 0)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cTags - m_uEnum);
    if (0 == cFetch)
        goto exit;

    // Copy cWanted
    for (uTag=0; uTag<cFetch; uTag++)
    {
        prgpTag[uTag] = m_rgpTags[m_uEnum++];
        if (prgpTag[uTag])
            prgpTag[uTag]->AddRef();
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    return hr;
}

HRESULT CBaseTagCollection::Reset()
{
    m_uEnum = 0;
    return S_OK;
}

HRESULT CBaseTagCollection::Count(ULONG *pcItems)
{
    if (pcItems == NULL)
        return TraceResult(E_INVALIDARG);

    *pcItems = m_cTags;
    return S_OK;
}

HRESULT CBaseTagCollection::_FreeCollection()
{
    ULONG   uImages;

    if (m_rgpTags)
    {
        for (uImages = 0; uImages < m_cTags; uImages++)
            ReleaseObj(m_rgpTags[uImages]);

        MemFree(m_rgpTags);
        m_rgpTags = 0;
        m_cTags = 0;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\basemht.h ===
/*
 *    b a s e m h t . c p p 
 *    
 *    Purpose:
 *        Base classes for MHTML packer objects
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _BASEMHT_H_
#define _BASEMHT_H_


class CBaseTag :
    public IMimeEditTag
{
public:

    CBaseTag();
    virtual ~CBaseTag();

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    virtual HRESULT STDMETHODCALLTYPE GetSrc(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE SetSrc(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE GetDest(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE SetDest(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE OnPreSave();
    virtual HRESULT STDMETHODCALLTYPE OnPostSave();

    virtual HRESULT STDMETHODCALLTYPE CanPackage();
    virtual HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);

    
    virtual HRESULT Init(IHTMLElement *pElem);

protected:
    ULONG           m_cRef;
    IHTMLElement    *m_pElem;
    BSTR            m_bstrDest,
                    m_bstrSrc;
};

 
class CBaseTagCollection :
    public IMimeEditTagCollection
{
public:

    CBaseTagCollection();
    virtual ~CBaseTagCollection();

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    virtual HRESULT STDMETHODCALLTYPE Init(IUnknown *pUnk);
    virtual HRESULT STDMETHODCALLTYPE Next(ULONG cFetch, IMimeEditTag **ppTag, ULONG *pcFetched);
    virtual HRESULT STDMETHODCALLTYPE Reset();
    virtual HRESULT STDMETHODCALLTYPE Count(ULONG *pcItems);

protected:
    ULONG           m_cRef,
                    m_cTags,
                    m_uEnum;
    IMimeEditTag    **m_rgpTags;
    
    
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc) PURE;
    virtual HRESULT _FreeCollection();
};





#endif //_BASEMHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\bodyutil.h ===
/*
 *    b o d y u t i l . h
 *    
 *    Purpose:
 *        Utility functions for body
 *
 *  History
 *      September '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _BODYUTIL_H
#define _BODYUTIL_H

interface IMimeMessage;

// header style:
// Mutually Exclusive. Plain means no formatting, html means bolding on field names, table will construct the
// header as a html-table
#define HDR_HTML        0x10000000L
#define HDR_TABLE       0x40000000L
#define HDR_PLAIN       0x80000000L

// additional flags:
#define HDR_PADDING     0x00000001L     // add CRLF before header, or <HR> tag in table mode.
#define HDR_NEWSSTYLE   0x00000002L
#define HDR_HARDCODED   0x00000004L     // hard-coded english headers

HRESULT GetHeaderTable(IMimeMessageW *pMsg, LPWSTR pwszUserName, DWORD dwHdrStyle, LPSTREAM *ppstm);

void GetStringRGB(DWORD rgb, LPSTR pszColor);
void GetRGBFromString(DWORD* pRBG, LPSTR pszColor);

#endif //_BODYUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\body.cpp ===
/*
 *    b o d y . c p p
 *    
 *    Purpose:
 *        base class implementation of Body object. Derrives from CDocHost to host the trident
 *        control.
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include <shfusion.h>
#include "resource.h"
#include "strconst.h"
#include "htmlstr.h"
#include "mimeolep.h"
#include "mimeutil.h"
#include "htiframe.h"       // ITargetFrame2
#include "htiface.h"        // ITargetFramePriv
#include "vervec.h"         // IVersion*
#include "triutil.h"
#include "util.h"
// #include "dochost.h"
#ifdef PLUSPACK
#include "htmlsp.h"
#endif //PLUSPACK
#include "body.h"
#include "bodyutil.h"
#include "oleutil.h"
#include "secmgr.h"
#include "mhtml.h"
#include "fmtbar.h"
#include "fontcash.h"
#include "attmenu.h"
#include "saveatt.h"
#include "frames.h"
#include "richedit.h"
#include "viewsrc.h"
#include "spell.h"
#include "tags.h"
#include "optary.h"
#include "shlwapip.h"
#include <icutil.h>
#include <demand.h>

ASSERTDATA

/*
 *  m a c r o s
 */
#define SetMenuItem(hmenu, id, fOn)     EnableMenuItem(hmenu, id, (fOn)?MF_ENABLED:MF_DISABLED|MF_GRAYED);

/*
 *  c o n s t a n t s
 */
#define BKGRNDSPELL_TICKTIME    100
#define AUTODETECT_CHUNK        16384
#define AUTODETECT_TICKTIME     200
#define AUTODETECT_TIMEOUT      10
//#define USE_ABORT_TIMER

#define idTimerAutoDetect        110
#define idTimerBkgrndSpell       111

static WCHAR    c_szMailToW[]   =L"mailto:",
                c_szOECmdW[]    =L"oecmd:",                
                c_szHttpW[]     =L"http://",
                c_szFileW[]     =L"file://";

#define CX_LABEL_PADDING        4
#define CY_LINE_PADDING         4

#define COLOR_HEADER            COLOR_3DFACE
#define COLOR_HEADERTXT         COLOR_BTNTEXT
#define COLOR_HEADERFOCUS       COLOR_HIGHLIGHT
#define COLOR_HEADERTXTFOCUS    COLOR_HIGHLIGHTTEXT

#define SMALLHEADERHEIGHT                   3
#define CX_PANEICON             30
#define CY_PANEICON             30
#define CY_PANEPADDING          (2*GetSystemMetrics(SM_CYBORDER))
#define CX_PANEPADDING          (2*GetSystemMetrics(SM_CXBORDER))

enum
    {
    IBTF_INSERTATEND    = 0x0001,
    IBTF_URLHIGHLIGHT   = 0x0002
    };

#define idcTabs     999
#define idcSrcEdit  998

#define HDRTXT_BOLD         0x01
#define HDRTXT_SYSTEMFONT   0x02

/*
 *  t y p e d e f s
 */
class CVerHost :
    public IVersionHost
{
public:
    CVerHost();
    virtual ~CVerHost();


    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IVersionHost
    virtual HRESULT STDMETHODCALLTYPE QueryUseLocalVersionVector(BOOL *fUseLocal);
    virtual HRESULT STDMETHODCALLTYPE QueryVersionVector(IVersionVector *pVersion);


private:
    ULONG               m_cRef;
};


/*
 *  g l o b a l s 
 */

static const TCHAR  c_szCaretSpanTag[]      = "<SPAN id=\"__#Ath#CaretPos__\">&nbsp;</SPAN>",
                    c_szCaretSpan[]         = "__#Ath#CaretPos__",
                    c_szSignatureSpanTag[]  = "&nbsp;<SPAN id=\"__#Ath#SignaturePos__\"></SPAN>&nbsp;",
                    c_szSignatureSpan[]     = "__#Ath#SignaturePos__",
                    c_szSigPrefix[]         = "\r\n-- \r\n";

/*
 *  f u n c t i o n   p r o t y p e s
 */
HRESULT CALLBACK FreeDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt);
HRESULT HrSniffUrlForRfc822(LPWSTR pszUrlW);

/*
 *  f u n c t i o n s
 */

//+---------------------------------------------------------------
//
//  Member:     CBody
//
//  Synopsis:   
//
//---------------------------------------------------------------

CBody::CBody()
{
    m_dwReadyState = READYSTATE_UNINITIALIZED;
    m_pszUrlW = NULL;
    m_pMsg = NULL;
    m_pMsgW = NULL;
    m_pDoc = NULL;
    m_hCharset=NULL;
    m_dwNotify=0;
    m_pTempFileUrl=NULL;
    m_pParentDocHostUI=NULL;
    m_pParentCmdTarget=NULL;
    m_pParentInPlaceSite=0;
    m_pParentInPlaceFrame=0;
    m_fPlainMode=FALSE;
    m_uHdrStyle = MESTYLE_NOHEADER ;
    m_pszLayout = NULL;
    m_pszFrom = 0;
    m_pszTo = 0;
    m_pszCc = 0;
    m_pszSubject = 0;
    m_fEmpty = 1;
    m_fMessageParsed=0;
    m_fDirty=0;
    m_fDesignMode=0;
    m_fAutoDetect=0;
    m_fOnImage=0;
    m_fTabLinks=0;
    m_pFmtBar=NULL;
    m_fLoading=1;
    m_fForceCharsetLoad=FALSE;
    m_pRangeIgnoreSpell=0;
    m_pFontCache=0;
    m_pDocActiveObj = 0;
    m_pAttMenu=NULL;
    m_hwndBtnBar=NULL;
    m_hIml=0;
    m_hImlHot=0;
    m_cVisibleBtns=0;
    m_pAttMenu=NULL;
    m_pSecMgr = NULL;
    m_hwndTab=NULL;
    m_hwndSrc=NULL;
    m_uSrcView = 0;
    m_pSrcView=NULL;
    m_fSrcTabs = 0;
    m_fReloadingSrc = FALSE;
    m_pSpell = 0;
    m_fBkgrndSpelling = FALSE;
    m_cchTotal = 0;
    m_dwFontCacheNotify = 0;
    m_fWasDirty = 0;
    m_pDispContext=0;
    m_dwContextItem=0;
    m_pstmHtmlSrc=NULL;
    m_pHashExternal = NULL;
    m_dwAutoTicks = 0;
    m_pAutoStartPtr = 0;
    m_fIgnoreAccel = 0;
#ifdef PLUSPACK
	m_pBkgSpeller = NULL;
#endif //PLUSPACK
}


//+---------------------------------------------------------------
//
//  Member:     CBody
//
//  Synopsis:   
//
//---------------------------------------------------------------
CBody::~CBody()
{
    Assert (m_pDispContext==NULL);
    SafeRelease(m_pAttMenu);
    SafeRelease(m_pParentInPlaceSite);
    SafeRelease(m_pParentInPlaceFrame);
    SafeRelease(m_pFmtBar);
    SafeRelease(m_pRangeIgnoreSpell);
    SafeRelease(m_pFontCache);
    SafeRelease(m_pSecMgr);
    SafeRelease(m_pSrcView);
    SafeRelease(m_pstmHtmlSrc);
    SafeRelease(m_pHashExternal);
    SafeRelease(m_pAutoStartPtr);

    Assert(m_pMsg==NULL);
    Assert(m_pMsgW==NULL);
    Assert(m_pTempFileUrl==NULL);
    Assert(m_pszFrom == 0);
    Assert(m_pszTo == 0);
    Assert(m_pszCc == 0);
    Assert(m_pszSubject == 0);
    SafeMemFree(m_pszLayout);
    if (m_hIml)
        ImageList_Destroy(m_hIml);
    if (m_hImlHot)
        ImageList_Destroy(m_hImlHot);
}


//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   pHostInfo is used to set parent's sites and frames. 
//             the parent inplace site is sent notifications on activation etc
//
//---------------------------------------------------------------
HRESULT CBody::Init(HWND hwndParent, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo)
{
    HRESULT hr;

    TraceCall("CBody::Init");

    if (pHostInfo)
    {
        ReplaceInterface(m_pParentInPlaceSite, pHostInfo->pInPlaceSite);
        ReplaceInterface(m_pParentInPlaceFrame, pHostInfo->pInPlaceFrame);
        ReplaceInterface(m_pDocActiveObj, pHostInfo->pDoc);
        if (m_pParentInPlaceSite)
        {
            // get the dochostUIhandler to delegate to when setparent sites is called
            Assert(m_pParentDocHostUI==NULL);
            Assert(m_pParentCmdTarget==NULL);
            m_pParentInPlaceSite->QueryInterface(IID_IDocHostUIHandler, (LPVOID *)&m_pParentDocHostUI);
            m_pParentInPlaceSite->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pParentCmdTarget);
        }
    }

    m_dwStyle=dwFlags;

    hr = CDocHost::Init(hwndParent, dwFlags&MEBF_OUTERCLIENTEDGE, prc);
    if (FAILED(hr))
        goto error;

    hr = HrCreateFormatBar(m_hwnd, idcFmtBar, dwFlags&MEBF_FORMATBARSEP, &m_pFmtBar);
    if (FAILED(hr))
        goto error;

    // fire-up trident at init time
    hr = EnsureLoaded();

error:
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     Close
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Close()
{
    IConnectionPoint    *pCP;

    TraceCall("CBody::Close");
    
    UnloadAll();
    RegisterLoadNotify(FALSE);

#ifdef PLUSPACK
	SafeRelease(m_pBkgSpeller);
#endif //PLUSPACK

#ifdef BACKGROUNDSPELL
    if (m_pSpell && m_fBkgrndSpelling)
    {
        m_pSpell->HrRegisterKeyPressNotify(FALSE);
        KillTimer(m_hwnd, idTimerBkgrndSpell);       // done. Stop the timer
    }
#endif // BACKGROUNDSPELL

	// scotts@directeq.com - moved this from destructor - 31463 & 36253
    if(m_pSpell)
        m_pSpell->CloseSpeller();
    SafeRelease(m_pSpell);

    SafeRelease(m_pFmtBar);
    SafeRelease(m_pDoc);
    SafeRelease(m_pParentCmdTarget);
    SafeRelease(m_pParentDocHostUI);
    SafeRelease(m_pParentInPlaceSite);
    SafeRelease(m_pParentInPlaceFrame);
    SafeRelease(m_pDocActiveObj);
    
    if (m_pFontCache && 
        m_pFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *)&pCP)==S_OK)
    {
        pCP->Unadvise(m_dwFontCacheNotify);
        pCP->Release();
    }
    SafeRelease(m_pFontCache);

    CloseDocObj();
    if (m_hwnd)
    {
        DestroyWindow(m_hwnd);
        m_hwnd=NULL;
    }
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     WndProc
//
//  Synopsis:   
//
//---------------------------------------------------------------
LRESULT CBody::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND    hwndT;

    switch (msg)
        {
        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (m_pFmtBar && 
                m_pFmtBar->GetWindow(&hwndT)==S_OK)
                SendMessage(hwndT, msg, wParam, lParam);
            break;

        case WM_LBUTTONDOWN:
            if (!m_fFocus)
                SetFocus(m_hwnd);
            break;

        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            OnFocus(msg==WM_SETFOCUS);
            break;

        case WM_SIZE:
            // since we do blit stuff we invalidate here
            InvalidateRect(m_hwnd, NULL, FALSE);
            break;

        case WM_ERASEBKGND:
            OnEraseBkgnd((HDC)wParam);
            return TRUE;

        case WM_CREATE:
            if (FAILED(OnWMCreate()))
                return -1;
            break;

        case WM_TIMER:
            if (wParam == idTimerAutoDetect)
                {
                AutoDetectTimer();
                return 0;
                }
            
#ifdef BACKGROUNDSPELL
            if (wParam == idTimerBkgrndSpell)
                {
                if (m_pSpell)
                    m_pSpell->HrBkgrndSpellTimer();
                return 0;
                }
#endif // BACKGROUNDSPELL

            if (m_pSrcView &&
                m_pSrcView->OnTimer(wParam)==S_OK)
                return 0;

            break;

        case WM_COMMAND:
            if(OnWMCommand(
                GET_WM_COMMAND_HWND(wParam, lParam),
                GET_WM_COMMAND_ID(wParam, lParam),
                GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;

            break;

        case WM_NOTIFY:
            return WMNotify(wParam, (NMHDR*)lParam);

        case WM_PAINT:
            if (OnPaint()==S_OK)
                return 0;
            break;
        }
    
    return CDocHost::WndProc(hwnd, msg, wParam, lParam);
}


//+---------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    TraceCall("CBody::QueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (IUnknown *)(IPropertyNotifySink *)this;
    else if (IsEqualIID(riid, IID_IPropertyNotifySink))
        *lplpObj = (IPropertyNotifySink *)this;
    else if (IsEqualIID(riid, IID_IDocHostUIHandler))
        *lplpObj = (IDocHostUIHandler*) this;
    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (IPersistMime*) this;
    else if (IsEqualIID(riid, IID_ITargetFramePriv))
        *lplpObj = (ITargetFramePriv*) this;
    else if (IsEqualIID(riid, IID_IPersistMoniker))
        *lplpObj = (LPVOID)(IPersistMoniker *)this;
    else if (IsEqualIID(riid, IID_IFontCacheNotify))
        *lplpObj = (LPVOID)(IFontCacheNotify *)this;
#if 0
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)this;
#endif
    else
        return CDocHost::QueryInterface(riid, lplpObj);
        
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     AddRef
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CBody::AddRef()
{
    TraceCall("CBody::AddRef");
    return CDocHost::AddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Release
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CBody::Release()
{
    TraceCall("CBody::Release");
    return CDocHost::Release();
}



//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    HRESULT             hr=E_FAIL;
    IServiceProvider    *pSP;
    IVersionHost        *pVersion;

    //DebugPrintInterface(riid, "CBody::QueryService");

    // delegate to the mimeedit host first
    if (m_pParentInPlaceSite)
        {
        if (m_pParentInPlaceSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
            {
            hr = pSP->QueryService(guidService, riid, ppvObject);
            pSP->Release();
            if (hr==S_OK)
                return S_OK;
            }
        }

    if (IsEqualGUID(guidService, SID_SInternetSecurityManager))
        {
        if (!m_pSecMgr)
            CreateSecurityManger(m_pParentCmdTarget, &m_pSecMgr);

        if (m_pSecMgr)
            return m_pSecMgr->QueryInterface(riid, ppvObject);
        }
    else if (IsEqualGUID(guidService, IID_ITargetFrame2))
        return QueryInterface(riid, ppvObject); 
    else if (IsEqualGUID(guidService, SID_SVersionHost) && IsEqualIID(riid, IID_IVersionHost))
    {
        pVersion = new CVerHost();
        if (!pVersion)
            return E_OUTOFMEMORY;

        *ppvObject = (LPVOID)(IVersionHost *)pVersion;
        return S_OK;
    }

    return CDocHost::QueryService(guidService, riid, ppvObject);
}

// *** IDocHostUIHandler ***

//+---------------------------------------------------------------
//
//  Member:     GetHostInfo
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
    HRESULT     hr;

    TraceCall("CBody::GetHostInfo");

    if (m_pParentDocHostUI)
    {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetHostInfo(pInfo);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
    }

    pInfo->dwDoubleClick    = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags          = DOCHOSTUIFLAG_DIV_BLOCKDEFAULT|DOCHOSTUIFLAG_OPENNEWWIN|
                              DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY|
                              DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION |
                              DOCHOSTUIFLAG_CODEPAGELINKEDFONTS;
    
    //This sets the flags that match the browser's encoding
    fGetBrowserUrlEncoding(&pInfo->dwFlags);

    if (!(m_dwStyle & MEBF_INNERCLIENTEDGE))
        pInfo->dwFlags |= DOCHOSTUIFLAG_NO3DBORDER;

    if (m_dwStyle & MEBF_NOSCROLL)
        pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ShowUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ShowUI(DWORD dwID,   IOleInPlaceActiveObject *pActiveObject,
                      IOleCommandTarget       *pCommandTarget,
                      IOleInPlaceFrame        *pFrame,
                      IOleInPlaceUIWindow     *pDoc)
{
    HRESULT     hr;

    TraceCall("CBody::ShowUI");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     HideUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::HideUI(void)
{
    HRESULT     hr;

    TraceCall("CBody::HideUI");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->HideUI();
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     UpdateUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UpdateUI(void)
{
    HRESULT hr;

    TraceCall("CBody::UpdateUI");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->UpdateUI();
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     EnableModeless
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::EnableModeless(BOOL fEnable)
{
    HRESULT     hr;

    TraceCall("CBody::EnableModeless");
    
    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->EnableModeless(fEnable);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }
    
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnDocWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnDocWindowActivate(BOOL fActivate)
{
    HRESULT     hr;

    TraceCall("CBody::OnDocWindowActivate");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->OnDocWindowActivate(fActivate);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnFrameWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnFrameWindowActivate(BOOL fActivate)
{
    HRESULT     hr;
    TraceCall("CBody::OnFrameWindowActivate");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->OnFrameWindowActivate(fActivate);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ResizeBorder
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ResizeBorder(LPCRECT prcBorder,
                            IOleInPlaceUIWindow* pUIWindow,
                            BOOL fRameWindow)
{
    HRESULT     hr;
    TraceCall("CBody::ResizeBorder");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->ResizeBorder(prcBorder, pUIWindow, fRameWindow);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     ShowContextMenu
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ShowContextMenu( DWORD       dwID,
                               POINT       *pptPosition,
                               IUnknown    *pcmdtReserved,
                               IDispatch   *pDispatchObjectHit)
{
    HRESULT         hr;
    HMENU           hMenu=0;
    INT             id;
    IHTMLTxtRange   *pTxtRange=0;
#ifdef PLUSPACK
    ISpellingSuggestions * pSuggestions = NULL;
    IMarkupPointer       * pPointerLeft = NULL;
    IMarkupPointer       * pPointerRight = NULL;
    IMarkupServices      * pMarkupServices = NULL;
    IDisplayPointer      * pDispPointer = NULL;
    IDisplayServices     * pDisplayServices = NULL;
    IHTMLElement         * pElement = NULL;
    IHTMLBodyElement     * pBody = NULL;
    IHTMLTxtRange           *pRange = NULL;
    IHTMLWindow2            *pWindow = NULL;
    IHTMLEventObj           *pEvent = NULL;
    IHTMLSelectionObject * pSelection = NULL;
    VARIANT_BOOL         fInSquiggle = VARIANT_FALSE;
    VARIANT         var;
    BSTR            bstrSuggestion = NULL;
    BSTR            bstrWord = NULL;
    BSTR            bstrSelectionType = NULL;    
    TCHAR           szAnsiSuggestion[256];
    INT             cch;
    BOOL            fRepeatWord;
    LONG            lCount = 0;
    MENUITEMINFO        mii = {0};

    LONG                    lButton;
    int i;
#else
    BOOL fSpellSuggest=FALSE;
#endif //PLUSPACK
    
    TraceCall("CBody::ShowContextMenu");
    
    if (m_pParentDocHostUI)
    {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->ShowContextMenu(dwID, pptPosition, pcmdtReserved, pDispatchObjectHit);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
    }
    
    Assert(m_lpOleObj && m_hwnd);
    
    m_dwContextItem = dwID;
#ifdef PLUSPACK
    hr = GetSelection(&pTxtRange);

    // Background spell context menu
    if(m_fDesignMode && m_pBkgSpeller && m_pDoc)
    {
        // Check for squiggle
        //          
        CHECKHR(hr = m_pBkgSpeller->IsInSquiggle(pTxtRange, &fInSquiggle) );

        if (fInSquiggle)
        {   //only if we have a suggestion
        // Get suggestions
                //
            CHECKHR(hr = m_pBkgSpeller->GetSpellingSuggestions(pTxtRange, FALSE, &pSuggestions) );
                
            //
            // Create the context menu
            //
                
            if (!(hMenu = LoadPopupMenu(idmrCtxtSpellSuggest)))
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
            /* CHECKHR(hr = pSuggestions->get_IsDoubleWord(&fRepeatWord) );
            if (fRepeatWord)
                {
                    // if (!AppendMenuA(hMenu, MF_STRING, IDM_DELETEWORD, "&Delete Repeated Word"))
                    //    goto exit;
                    
                }
                else 
                { */
            //
            // Fill with suggestions
            //
            CHECKHR(hr = pSuggestions->get_Count(&lCount) );
                    
            if (lCount < 1)
            {
                if (!AppendMenuA(hMenu, MF_DISABLED | MF_GRAYED, 1, "(no suggestions)"))
                    goto exit;
            }
            else
            {
                V_VT(&var) = VT_I4;
                for (i = 0; (i <= lCount) && ((i + idmSuggest0) <= idmSuggest4); ++i)
                {
                    V_I4(&var) = i + 1; // get_Item starts from 1
                            
                    SysFreeString(bstrSuggestion);
                    bstrSuggestion = NULL;
                    CHECKHR(hr = pSuggestions->get_Item(&var, &bstrSuggestion));
                            
                    cch = WideCharToMultiByte(0, 0, bstrSuggestion, SysStringLen(bstrSuggestion), szAnsiSuggestion, 255, NULL, NULL);
                    if (!cch)
                        goto exit;
                                
                    szAnsiSuggestion[cch] = 0;
                                
                    // Initialize the menu info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;
                    mii.fState = MFS_ENABLED;
                    mii.wID = i + idmSuggest0;
                    mii.dwTypeData = szAnsiSuggestion;
                    mii.cch = lstrlen(szAnsiSuggestion);

                    if(!InsertMenuItem(hMenu, 0, TRUE, &mii))
//					if (!AppendMenuA(hMenu, MF_STRING, i + idmSuggest0, szAnsiSuggestion))
                        goto exit;
                }
            }
                    
//            if (!AppendMenuA(hMenu, MF_SEPARATOR, 0, NULL))
//				goto exit;
                    
//                    if (!AppendMenuA(hMenu, MF_STRING, IDM_IGNOREWORD, "&Ignore All"))
//                        goto exit;
        }
        
    }
#endif //PLUSPACK

#ifdef BACKGROUNDSPELL
    if (m_pSpell && m_fBkgrndSpelling)
    {
        HRESULT       hr;
        
        hr = GetSelection(&pTxtRange);
        if (pTxtRange)
        {
            if (m_pSpell->HrHasSquiggle(pTxtRange)==S_OK)
            {
                if (!(hMenu = LoadPopupMenu(idmrCtxtSpellSuggest)))
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }
                
                hr = m_pSpell->HrInsertMenu(hMenu, pTxtRange);
                if (FAILED(hr))
                    goto exit;
                fSpellSuggest = TRUE;
            }
        }
    }
#endif // BACKGROUNDSPELL

#ifdef PLUSPACK
    if (!fInSquiggle)
#else
    if (!fSpellSuggest)
#endif //PLUSPACK
    {
        if (!(hMenu = LoadPopupMenu(m_fDesignMode?idmrCtxtEditMode:idmrCtxtBrowseMode)))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }
        
        if (!m_fDesignMode)
        {
            // if in browse mode, query the host to see if we can provider add to WAB and
            // add to fave menu items
            if (dwID == CONTEXT_MENU_ANCHOR)
            {
                AppendAnchorItems(hMenu, pDispatchObjectHit);
            }
            else
            {
                // remove the CopyShortCut command if it's not an anchor
                RemoveMenu(hMenu, idmCopyShortcut, MF_BYCOMMAND);
                // remove the SaveTargetAs command if it's not an anchor
                RemoveMenu(hMenu, idmSaveTargetAs, MF_BYCOMMAND);
            }
            
            if (dwID != CONTEXT_MENU_IMAGE)
                EnableMenuItem(hMenu, idmSavePicture, MF_BYCOMMAND|MF_GRAYED);
        }
        else
        {
            // if in editmode, trident does not pass dwID==CONTEXT_MENU_ANCHOR so we have to
            // test to see if the selection in an anchor to set this. It may fix this in the future
            // so code for both cases
            
            if (dwID==0 && GetSelectedAnchor(NULL)==S_OK)
                dwID = CONTEXT_MENU_ANCHOR;
            
#ifdef FOLLOW_LINK
            // if edit-mode, and not on an anchor, hide the openlink menu command
            if (dwID != CONTEXT_MENU_ANCHOR)
                RemoveMenu(hMenu, idmOpenLink, MF_BYCOMMAND);
#endif
        }
        
        m_fOnImage = !!(dwID == CONTEXT_MENU_IMAGE);
        UpdateContextMenu(hMenu, (dwID == CONTEXT_MENU_IMAGE || dwID == CONTEXT_MENU_ANCHOR), pDispatchObjectHit);
    }
    
    id = (INT)TrackPopupMenu(
        hMenu,
        TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
        pptPosition->x,
        pptPosition->y,
        0,
        GetParent(m_hwnd),
        NULL);
    
    // we have to use TPM_RETURNCMD here as we need to process the command-id before returning from this
    // function, other wise trident will be confused about the object being clicked on.
#ifdef PLUSPACK
    if (pTxtRange && id!=0 && m_pBkgSpeller && fInSquiggle)
    {
        //
        // Handle command
        //

        switch (id)
        {
            case idmIgnoreAll:
				CHECKHR(hr = m_pBkgSpeller->IgnoreWord(pTxtRange) );
				break;

            /*case IDM_DELETEWORD:
            {
                SysFreeString(bstrSuggestion);
                bstrSuggestion = SysAllocString(L"");
                CHECKHR(hr = pTxtRange->put_text(bstrSuggestion) );
                break;
            } */

            case idmIgnore:
            {
                //
                // mark this as clean
                //
                CHECKHR(hr = m_pBkgSpeller->MarkRegion(pTxtRange, VARIANT_FALSE) );
                break;
            }

            default:
                if ((id - idmSuggest0) <= lCount)
                {
                V_I4(&var) = id - idmSuggest0 + 1; // get_Item starts from 1

                SysFreeString(bstrSuggestion);
                bstrSuggestion = NULL;
                CHECKHR(hr = pSuggestions->get_Item(&var, &bstrSuggestion) );
    
                CHECKHR(hr = pTxtRange->put_text(bstrSuggestion) );
/*                {
                    CHAR    szBuf[MAX_PATH] = {0};
                    BSTR    bstr=0;
                    BSTR    bstrPut=0;
                    LPSTR   pch=0;
                    INT     i=0;
                    cch = WideCharToMultiByte(0, 0, bstrSuggestion, SysStringLen(bstrSuggestion), szAnsiSuggestion, 255, NULL, NULL);
					szAnsiSuggestion[cch] = '\0';
                    pch = szAnsiSuggestion;
                    strcpy(szBuf, pch);

                    if (SUCCEEDED(pTxtRange->get_text(&bstr)) && bstr)
                    {
                        LPSTR   pszText = 0;
                        if (SUCCEEDED(HrBSTRToLPSZ(CP_ACP, bstr, &pszText)) && pszText)
                        {
                            LPSTR   psz;
                            INT     nSpaces=0;
                            psz = StrChrI(pszText, ' ');
                            if(psz)
                            {
                                nSpaces = (INT) (&pszText[lstrlen(pszText)] - psz);
                                Assert(nSpaces>=0);
                                for(int i=0; i<(nSpaces-1); i++)
                                    lstrcat(szBuf, "&nbsp;");
                                if (nSpaces>0)
                                    lstrcat(szBuf, " ");
                            }
                            hr = HrLPSZToBSTR(szBuf, &bstrPut);

                            SafeMemFree(pszText);
                        }
                        SafeSysFreeString(bstr);
                    }
                    if (bstrPut)
                    {
                        pTxtRange->pasteHTML(bstrPut);
                        SafeSysFreeString(bstrPut);
                    }

                }*/
				break;
            }
        }

        hr = S_OK;
        goto exit;
    } 
#else
    if (pTxtRange && id!=0 && m_pSpell && fSpellSuggest && m_pSpell->OnWMCommand(id, pTxtRange)==S_OK)
        goto exit;
#endif //PLUSPACK
    
    // stuff the IDispatch object, so our WMCommand handler can use it
    if (m_pDispContext = pDispatchObjectHit)
        pDispatchObjectHit->AddRef();
    
    if(id != 0)
        OnWMCommand(NULL, id, 0);
       
exit:
    SafeRelease(m_pDispContext);
#ifdef PLUSPACK
    SysFreeString(bstrSuggestion);
    SysFreeString(bstrWord);
    SysFreeString(bstrSelectionType);
#endif //PLUSPACK
    if (hMenu)
        DestroyMenu(hMenu);
#ifdef PLUSPACK
    SafeRelease(pSuggestions);
    SafeRelease(pPointerLeft);
    SafeRelease(pPointerRight);
    SafeRelease(pMarkupServices);
    SafeRelease(pDispPointer);
    SafeRelease(pDisplayServices);
    SafeRelease(pElement);
    SafeRelease(pBody);
    SafeRelease(pSelection);
    SafeRelease(pWindow);
    SafeRelease(pRange);
    SafeRelease(pEvent);
#endif //PLUSPACK
    ReleaseObj(pTxtRange);
    
    m_dwContextItem = 0;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetDropTarget
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    HRESULT     hr;

    TraceCall("CBody::GetDropTarget");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetDropTarget(pDropTarget, ppDropTarget);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetExternal
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetExternal(IDispatch **ppDispatch)
{
    HRESULT     hr;

    TraceCall("CBody::GetExternal");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetExternal(ppDispatch);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateUrl
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::TranslateUrl(DWORD dwTranslate, OLECHAR *pwszUrlIn, OLECHAR **ppwszUrlOut)
{
    HRESULT             hr=S_OK;
    LPSTR               pszUrlIn=NULL;
    LPSTR               pszBodyUrl=NULL;
    LPSTR               pszFilePath=NULL;
    LPSTR               pszUrlOut=NULL;
    LPSTR               pszFree=NULL;
    LPSTR               pszGenFName=NULL;
    LPSTR               pszParameters=NULL;
    LPSTR               pszCommandLine=NULL;
    CHAR                szBuffer[MAX_PATH];
    HBODY               hBody;
    IMimeBody          *pBody=NULL;
    IStream            *pStream=NULL;
    PROPVARIANT         rVariant;
    HANDLE              hFile=INVALID_HANDLE_VALUE;
    ULONG               cbTotal;
    CHAR                szFilePath[MAX_PATH + MAX_PATH];
    ULONG               cch;
    BOOL                fReturnAbort=FALSE;
    LPTEMPFILEINFO      pTempFile;
    SHELLEXECUTEINFO    rExecute;

    TraceCall("CBody::TranslateUrl");


    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->TranslateUrl(dwTranslate, pwszUrlIn, ppwszUrlOut);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    // Init
    *ppwszUrlOut = NULL;

    if (NULL == pwszUrlIn || NULL == ppwszUrlOut)
        return TraceResult(E_INVALIDARG);

    // No Message Object
    if ((NULL == m_pMsg) || (NULL == m_pMsgW))
        return S_FALSE;

    // If pwszUrlIn is not already an mhtml: url
    if (StrCmpNIW(pwszUrlIn, L"mhtml:", 6) != 0)
        return S_FALSE;

    // Convert To ANSI
    pszUrlIn = PszToANSI(CP_ACP, pwszUrlIn);
    if (!pszUrlIn)
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }

    // UnEscape the Url
    hr = UrlUnescapeA(pszUrlIn, NULL, NULL, URL_UNESCAPE_INPLACE);
    if (FAILED(hr))
        goto error;

    // Split It
    hr = MimeOleParseMhtmlUrl(pszUrlIn, NULL, &pszBodyUrl);
    if (FAILED(hr))
        goto error;

    // Resolve the body url
    hr = m_pMsg->ResolveURL(NULL, NULL, pszBodyUrl, 0, &hBody);
    if (FAILED(hr))
        goto error;

    // Get an IMimeBody
    hr = m_pMsg->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
        goto error;

    // Abort
    fReturnAbort = TRUE;

    // If HTML, then write the entire message source to a temp file and return an mhtml url
    if (pBody->IsContentType(STR_CNT_TEXT, STR_SUB_HTML) == S_OK)
        {
        // Get ixplorer.exe path
        GetExePath(c_szIexploreExe, szBuffer, ARRAYSIZE(szBuffer), FALSE);

        // Set command line
        pszCommandLine = szBuffer;

        // Get a Stream
        hr = m_pMsg->GetMessageSource(&pStream, 0);
        if (FAILED(hr))
            goto error;

        // Init Variant
        rVariant.vt = VT_LPSTR;

        // Get a filename from the message object
        hr = m_pMsg->GetProp(PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant);
        if (FAILED(hr))
            goto error;

        // Save pszFilePath
        pszGenFName = rVariant.pszVal;

        // Create temp file
        hr = CreateTempFile(pszGenFName, c_szMHTMLExt, &pszFilePath, &hFile);
        if (FAILED(hr))
            goto error;

        // Write the stream to a file
        hr = WriteStreamToFileHandle(pStream, hFile, &cbTotal);
        if (FAILED(hr))
            goto error;

        // Build: mhtml:(pszFilePath)!pszBodyUrl
        pszParameters = PszAllocA(lstrlen(c_szMHTMLColon) + lstrlen(c_szFileUrl) + lstrlen(pszFilePath) + 1 + lstrlen(pszBodyUrl) + 1);
        if (!pszParameters)
            {
            hr = E_OUTOFMEMORY;
            goto error;
            }
    
        // Build pszParameters
        wsprintf(pszParameters, "%s%s%s!%s", c_szMHTMLColon, c_szFileUrl, pszFilePath, pszBodyUrl);
    }
    
    // Otherwise, dump the body data to a temp file and return a url to it
    else
    {
        // Get a Stream
        hr = pBody->GetData(IET_INETCSET, &pStream);
        if (FAILED(hr))
            goto error;

        // Set sizeof szFilePath
        cch = ARRAYSIZE(szFilePath);

        // If cid:
        if (StrCmpNIA(pszBodyUrl, "cid:", 4) == 0 || FAILED(PathCreateFromUrlA(pszBodyUrl, szFilePath, &cch, 0)))
        {
            // Init Variant
            rVariant.vt = VT_LPSTR;

            // Get a filename from the message object
            hr = pBody->GetProp(PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant);
            if (FAILED(hr))
                goto error;

            // Save pszFilePath
            pszGenFName = rVariant.pszVal;

            // Create temp file
            hr = CreateTempFile(pszGenFName, NULL, &pszFilePath, &hFile);
            if (FAILED(hr))
                goto error;

        }
        else
        {
            // Create temp file
            hr = CreateTempFile(szFilePath, NULL, &pszFilePath, &hFile);
            if (FAILED(hr))
                goto error;

        }

        // Write the stream to a file
        hr = WriteStreamToFileHandle(pStream, hFile, &cbTotal);
        if (FAILED(hr))
            goto error;

        // Build: file://(pszFilePath)
        pszUrlOut = PszAllocA(lstrlen(c_szFileUrl) + lstrlen(pszFilePath) + 1);
        if (FAILED(hr))
            goto error;

        // Build pszUrlOut
        wsprintf(pszUrlOut, "%s%s", c_szFileUrl, pszFilePath);

        // Set the pszCommandLine
        pszCommandLine = pszUrlOut;
    }

    // Close the file - the file must get closed here (i.e. after the call to MimeOleCleanupTempFiles)
    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    // Is this file safe to run ?
    hr = MimeEditIsSafeToRun(m_hwnd, pszFilePath, FALSE);
    if (FAILED(hr))
        goto error;

    // SaveAs
    if (MIMEEDIT_S_OPENFILE == hr)
    {
        // Locals
        OPENFILENAME    ofn;
        TCHAR           szTitle[CCHMAX_STRINGRES];
        TCHAR           szFilter[CCHMAX_STRINGRES];
        TCHAR           szFile[MAX_PATH];

        // Init
        *szFile=0;
        *szFilter=0;
        *szTitle=0;

        // Copy filename
        lstrcpyn(szFile, pszFilePath, MAX_PATH);

        // Init Open file structure
        ZeroMemory (&ofn, sizeof(OPENFILENAME));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = m_hwnd;
        LoadString(g_hLocRes, idsFilterAttSave, szFilter, sizeof(szFilter));
        ReplaceChars(szFilter, '|', '\0');
        ofn.lpstrFilter = szFilter;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = sizeof (szFile);
        LoadString(g_hLocRes, idsSaveAttachmentAs, szTitle, sizeof(szTitle));
        ofn.lpstrTitle = szTitle;
        ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

        // Show SaveAs Dialog
        if (HrAthGetFileName(&ofn, FALSE) == S_OK)
        {
            // If the same...
            if (lstrcmpi(pszFilePath, szFile) == 0)
            {
                // Just free pszfilePath so that we don't delete it
                SafeMemFree(pszFilePath);
            }

            // Copy the file - Overwrite
            else
                CopyFile(pszFilePath, szFile, FALSE);
        }

        // Done
        goto error;
    }

    // Must be trying to execute the file
    hr = MimeEditVerifyTrust(m_hwnd, PathFindFileName(pszFilePath), pszFilePath);
    if (FAILED(hr))
        goto error;

    // Setup the Shell Execute Structure
    ZeroMemory (&rExecute, sizeof(SHELLEXECUTEINFO));
    rExecute.cbSize = sizeof(SHELLEXECUTEINFO);
    rExecute.fMask = SEE_MASK_NOCLOSEPROCESS;
    rExecute.hwnd = m_hwnd;
    rExecute.nShow = SW_SHOWNORMAL;
    rExecute.lpFile = pszCommandLine;
    rExecute.lpVerb = NULL;
    rExecute.lpParameters = pszParameters;

    // Execute the File
    TraceInfoSideAssert((0 != ShellExecuteEx(&rExecute)), _MSG("ShellExecuteEx failed - GetLastError() = %d\n", GetLastError()));

    // Add the temp file to the list
    if (SUCCEEDED(AppendTempFileList(&m_pTempFileUrl, pszFilePath, rExecute.hProcess)))
        pszFilePath = NULL;

error:
    // Cleanup
    SafeRelease(pBody);
    SafeRelease(pStream);
    SafeMemFree(pszUrlIn);
    SafeMemFree(pszBodyUrl);
    SafeMemFree(pszFree);
    SafeMemFree(pszUrlOut);
    SafeMemFree(pszGenFName);
    SafeMemFree(pszParameters);

    // Close the file - the file must get closed here (i.e. after the call to MimeOleCleanupTempFiles)
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    // If we still have pszFilePath, delete the file
    if (pszFilePath)
    {
        DeleteFile(pszFilePath);
        g_pMalloc->Free(pszFilePath);
    }

    // Done
    return (TRUE == fReturnAbort) ? E_ABORT : S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     FilterDataObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    IDataObject     *pDataObjNew = NULL;
    HRESULT         hr = S_FALSE;
    STGMEDIUM       stgmed;
    DATAOBJINFO*    pInfo = 0;
    DATAOBJINFO*    pInfoCopy = 0;
    FORMATETC       fetc = {0};
    LPBYTE          pCopy=0;
    INT             i, j, cFormats=0;
    USHORT          cfFormat[2] = 
                            {CF_TEXT, CF_UNICODETEXT};
    LPBYTE          lpsz[2]={0};
    ULONG           lStreamLength[2]={0};

    TraceCall("CBody::FilterDataObject");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->FilterDataObject(pDO, ppDORet);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    if (!m_fPlainMode || !m_fDesignMode)
        return S_FALSE;

    if (pDO==NULL || ppDORet==NULL)
        return S_FALSE;

    *ppDORet = NULL;

    for (i=0; i<ARRAYSIZE(cfFormat); i++)
        {
        // get the plain-text
        fetc.cfFormat=cfFormat[i];
        fetc.dwAspect=DVASPECT_CONTENT;
        fetc.tymed=TYMED_HGLOBAL;
        fetc.lindex=0;

        hr=pDO->QueryGetData(&fetc);
        if(FAILED(hr))
            continue;

        ZeroMemory(&stgmed, sizeof(stgmed));
        hr=pDO->GetData(&fetc, &stgmed);
        if(FAILED(hr))
            goto cleanloop;

        Assert(stgmed.hGlobal);

        // make a copy of the plain text string.
        pCopy = (LPBYTE)GlobalLock(stgmed.hGlobal);

        if (!pCopy)
            {
            hr=E_FAIL;
            goto cleanloop;
            }

        if(fetc.cfFormat == CF_TEXT)
            lStreamLength[i] = lstrlen((LPSTR)pCopy) + 1;
        else
            lStreamLength[i] =  sizeof(WCHAR) * (lstrlenW((LPWSTR)pCopy)+1);

        if (!MemAlloc((LPVOID*)&lpsz[i], lStreamLength[i]))
            {
            hr = E_OUTOFMEMORY;
            goto cleanloop;
            }

        CopyMemory(lpsz[i], pCopy, lStreamLength[i]);
        GlobalUnlock(stgmed.hGlobal);
        cFormats++;

cleanloop:
        // addref the pUnk as it will be release in releasestgmed
        if(stgmed.pUnkForRelease)
            stgmed.pUnkForRelease->AddRef();
        ReleaseStgMedium(&stgmed);
        if(FAILED(hr))
            goto error;
        }

    if(cFormats == 0)
        {
        hr = E_FAIL;
        goto error;
        }

    if (!MemAlloc((LPVOID*)&pInfo, sizeof(DATAOBJINFO)*cFormats))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    ZeroMemory(pInfo, sizeof(DATAOBJINFO)*cFormats);

    j = 0;
    for(i=0; i<ARRAYSIZE(cfFormat); i++)
        {
        if(lpsz[i] != 0)
            {
            SETDefFormatEtc(pInfo[j].fe, cfFormat[i], TYMED_HGLOBAL);
            pInfo[j].pData = lpsz[i];
            pInfo[j].cbData = lStreamLength[i];
            j++;
            }
        }
    Assert(j == cFormats);

    hr = CreateDataObject(pInfo, cFormats, (PFNFREEDATAOBJ)FreeDataObj, &pDataObjNew);
    if (FAILED(hr))
        goto error;

    //CDataObject will free this now it accepted it
    for(i=0; i<ARRAYSIZE(cfFormat); i++)
        lpsz[i]=NULL;
    pInfo=NULL;
    *ppDORet = pDataObjNew;
    pDataObjNew = NULL;

error:
    for(i=0; i<ARRAYSIZE(cfFormat); i++)
        SafeMemFree(lpsz[i]);
    SafeMemFree(pInfo);     
    ReleaseObj(pDataObjNew);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
//  Synopsis:   
//              Trident calls the host first before handling an 
//              accelerator. If we return S_OK, it assumes we handled
//              it and carries on. If we return S_FALSE it assumes 
//              we don't care, and it will do it's own action
//
//---------------------------------------------------------------
HRESULT CBody::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    HRESULT hr;

    TraceCall("CBody::TranslateAccelerator");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    // commands which are always available
    switch (nCmdID)
    {
        case 0:
        case IDM_CUT:
        case IDM_COPY:
        case IDM_PASTE:
        case IDM_PASTEINSERT:
        case IDM_DELETE:
        case IDM_DELETEWORD:
        case IDM_SELECTALL:
        case IDM_UNDO:
        case IDM_REDO:
        case IDM_CHANGECASE:
        case IDM_NONBREAK:
            return S_FALSE;
    }

    // commands only available in HTML edit mode
    if (!m_fPlainMode)
    {
        switch  (nCmdID)
        {
            case IDM_BOLD:
            case IDM_UNDERLINE:
            case IDM_ITALIC:
            case IDM_REMOVEFORMAT:
            case IDM_CENTERALIGNPARA:
            case IDM_LEFTALIGNPARA:
            case IDM_RIGHTALIGNPARA:
            case IDM_REMOVEPARAFORMAT:
            case IDM_APPLYNORMAL:
                return S_FALSE;
        }
    }

    if (nCmdID)
        m_fIgnoreAccel = 1;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     GetOptionKeyPath
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetOptionKeyPath(LPOLESTR * pstrKey, DWORD dw)
{
    HRESULT     hr;
    TCHAR       rgch[MAX_PATH];

    TraceCall("CBody::GetOptionKeyPath");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetOptionKeyPath(pstrKey, dw);
        if (hr==S_OK)
            {
            WideCharToMultiByte(CP_ACP, 0, (WCHAR*)*pstrKey, -1, rgch, MAX_PATH, NULL, NULL);
            CreateFontCache(rgch);
            }

        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    CreateFontCache(NULL);
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     EnsureLoaded
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::EnsureLoaded()
{
    HRESULT hr=NOERROR;

    TraceCall("CBody::EnsureLoaded");

    if (!m_lpOleObj)
        {
        hr=CDocHost::CreateDocObj((LPCLSID)&CLSID_HTMLDocument);
        if(FAILED(hr))
            goto error;

        hr = CDocHost::Show();
        if(FAILED(hr))
            goto error;

        Assert (!m_pDoc);

        hr = m_lpOleObj->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&m_pDoc);
        if (FAILED(hr))
            goto error;

        hr = RegisterLoadNotify(TRUE);
        if (FAILED(hr))
            goto error;

        if (m_pFmtBar)
            m_pFmtBar->SetCommandTarget(m_pCmdTarget);
	}

error:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     RegisterLoadNotify
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::RegisterLoadNotify(BOOL fRegister)
{
    IConnectionPointContainer   *pCPContainer;
    IConnectionPoint            *pCP;
    HRESULT                     hr=E_FAIL;

    TraceCall("CBody::RegisterLoadNotify");

    if (!m_pDoc)
        return E_FAIL;

    if (m_pDoc)
        {
        hr = m_pDoc->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
        if (!FAILED(hr))
            {
            hr = pCPContainer->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
            if (!FAILED(hr))
                {
                if (fRegister)
                    {
                    Assert(m_dwNotify == 0);
                    hr = pCP->Advise((IPropertyNotifySink *)this, &m_dwNotify);
                    }
                else
                    {
                    if (m_dwNotify)
                        {
                        hr = pCP->Unadvise(m_dwNotify);
                        m_dwNotify=0;
                        }
                    }
                pCP->Release();
                }        
            pCPContainer->Release();
            }
        }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     OnChanged
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnChanged(DISPID dispid)
{
    TraceCall("CBody::OnChanged");

    if (dispid == DISPID_READYSTATE)
        OnReadyStateChanged();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnRequestEdit
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnRequestEdit (DISPID dispid)
{
    TraceCall("CBody::OnRequestEdit");

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     OnReadyStateChanged
//
//  Synopsis:   
//
//---------------------------------------------------------------
void CBody::OnReadyStateChanged()
{
    HRESULT     hr = S_OK;
    VARIANT     Var;
    IDispatch * pdisp;

    TraceCall("CBody::OnReadyStateChanged");

    if (NULL == m_lpOleObj)
        return;

    if (m_lpOleObj->QueryInterface(IID_IDispatch, (void **)&pdisp)==S_OK)
        {
        if (GetDispProp(pdisp, DISPID_READYSTATE, 0, &Var, NULL)==S_OK)
            {
            // maybe either I4 or I2
            Assert (Var.vt == VT_I4 || Var.vt == VT_I2);
            // we get the ready state so we can warn about sending while downloading
            m_dwReadyState = Var.lVal;
            }
        pdisp->Release();
        }
}

//+---------------------------------------------------------------
//
//  Member:     OnDocumentReady
//
//  Synopsis:   
//
//---------------------------------------------------------------
void CBody::OnDocumentReady()
{
    DWORD   dwFlags;
	
    // quick-scan for CID's not requested before ParseComplete
    if (m_fLoading && !m_fReloadingSrc)
        SearchForCIDUrls();
	
    // send a notification up to the parent
    if (m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_ONPARSECOMPLETE, 0, NULL, NULL);
	
    if (m_fAutoDetect)
        StartAutoDetect();
	
#ifdef PLUSPACK
	// Test for new Trident backgound spell check
	if(m_fDesignMode && !m_pBkgSpeller && m_pDoc)
	{
		HRESULT hr = S_OK;
		IHTMLElement     * pElement = NULL;
		IHTMLBodyElement * pBodyElement = NULL;
		IHTMLTxtRange    * pRange = NULL;
		
		//
		// Create the speller
		//
		CHECKHR(hr = CoCreateInstance(CLSID_HTMLSpell, NULL, CLSCTX_INPROC_SERVER,
				IID_IHTMLSpell, (LPVOID*)&m_pBkgSpeller));
		
		//
		// Attach the speller
		//
		
		CHECKHR(hr = m_pDoc->get_body(&pElement));
		
		CHECKHR(hr = m_pBkgSpeller->SetDoc(m_pDoc) );
		CHECKHR(hr = m_pBkgSpeller->Attach(pElement) );
		
		//
		// Mark current content as clean
		//
		
		CHECKHR(hr = pElement->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)&pBodyElement) );
		CHECKHR(hr = pBodyElement->createTextRange(&pRange) );
		CHECKHR(hr = m_pBkgSpeller->MarkRegion((IDispatch *)pRange, TRUE /* fSpellable */) );
		
exit:
		// just cannot load background speller...
		if(FAILED(hr))
			Assert(FALSE);
		
		SafeRelease(pRange);
		SafeRelease(pBodyElement);
		SafeRelease(pElement);
//		return; //(S_OK);
	}
#endif //PLUSPACK
	
#ifdef BACKGROUNDSPELL
	HrCreateSpeller(TRUE);
#endif // BACKGROUNDSPELL
	
    if (m_fLoading && !m_fReloadingSrc)
    {
        // OnDocumentReady can be called >1 times during a load. We use m_fLoading to keep track so
        // we only do this init once.
        
        // paste in the reply header and auto-text on the first download notification.
        if (m_fDesignMode)
        {
            if (m_fForceCharsetLoad)
            {
                TCHAR               rgchCset[CCHMAX_CSET_NAME];
				
                if (SUCCEEDED(HrGetMetaTagName(m_hCharset, rgchCset)))
                {
                    BSTR bstr;
                    if (SUCCEEDED(HrLPSZToBSTR(rgchCset, &bstr)))
                    {
                        m_pDoc->put_charset(bstr);
                        SysFreeString(bstr);
                    }
                }
            }
			
            // if the host wants to to not send images that originate from an external source
            // then tag them as such now.
            if (GetHostFlags(&dwFlags)==S_OK &&
                !(dwFlags & MEO_FLAGS_SENDEXTERNALIMGSRC))
            {
                SafeRelease(m_pHashExternal);
                HashExternalReferences(m_pDoc, m_pMsg, &m_pHashExternal);
            }
            
            if (!m_fPlainMode)
            {
                SetHostComposeFont();
                SetWindowBgColor(FALSE);
            }
        }
        
        PasteReplyHeader();
        PasteAutoText();
        
        ClearUndoStack();
        ClearDirtyFlag();
        
        // if we get a load notify and we're the previewpane, show the attachment clip
        if (m_uHdrStyle == MESTYLE_PREVIEW)
        {
            UpdateBtnBar();
            UpdatePreviewLabels();
        }
        m_fLoading=0;
    }
    
    m_fMessageParsed=1;
    m_fReloadingSrc=FALSE;
    
}

//+---------------------------------------------------------------
//
//  Member:     SetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SetRect(LPRECT prc)
{
    TraceCall("CBody::SetRect");

    SetWindowPos(m_hwnd, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOZORDER);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetRect(LPRECT prcView)
{
    TraceCall("CBody::GetRect");

    if (prcView == NULL)
        return E_INVALIDARG;

    Assert (IsWindow(m_hwnd));

    GetClientRect(m_hwnd, prcView);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     UIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UIActivate(BOOL fUIActivate)
{
    TraceCall("CBody::UIActivate");

    if(!m_pDocView)
        return S_OK;

    return m_pDocView->UIActivate(fUIActivate);
}


//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CBody::Exec");

    if (pguidCmdGroup && 
        IsEqualGUID(CMDSETID_Forms3, *pguidCmdGroup))
        {
        if (nCmdID == IDM_PARSECOMPLETE)
            {
            OnDocumentReady();
            return S_OK;
            }
        }
    
    if (pguidCmdGroup==NULL)
        {
        switch (nCmdID)
            {
            case OLECMDID_UPDATECOMMANDS:
                UpdateCommands();
                break;
            }
        }        
    return CDocHost::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut);
}



//+---------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetClassID(CLSID *pCLSID)
{
    TraceCall("CBody::GetClassID");

    *pCLSID = CLSID_MimeEdit;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Load(IMimeMessage *pMsg)
{
    BODYINITDATA    biData;

    TraceCall("CBody::Load");

    if (pMsg == NULL)
        return TraceResult(E_INVALIDARG);

    biData.dwType = BI_MESSAGE;
    biData.pMsg = pMsg;

    return LoadFromData(&biData);
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Save(IMimeMessage *pMsg, DWORD dwFlags)
{
    HRESULT                 hr;
    DWORD                   dwMHTMLFlags=0,
                            dwHostFlags;

    TraceCall("CBody::Save");

    if (pMsg==NULL)
        return E_INVALIDARG;

    if (!m_lpOleObj)
        return CO_E_NOT_SUPPORTED;


    if (m_uSrcView != MEST_EDIT)
        return TraceResult(MIMEEDIT_E_CANNOTSAVEWHILESOURCEEDITING);

    if (!((dwFlags & PMS_HTML) || (dwFlags & PMS_TEXT)))
        return TraceResult(MIMEEDIT_E_ILLEGALBODYFORMAT);

    // if trident is not yet done parsing the HTML, we cannot safely save from the tree. 
    if (!m_fMessageParsed)
        return MIMEEDIT_E_CANNOTSAVEUNTILPARSECOMPLETE;
        
    if(dwFlags & PMS_HTML)
        dwMHTMLFlags |= MECD_HTML;

    if(dwFlags & PMS_TEXT)
        dwMHTMLFlags |= MECD_PLAINTEXT;

    if ((GetHostFlags(&dwHostFlags)==S_OK) &&
        (dwHostFlags & MEO_FLAGS_SENDIMAGES))
        dwMHTMLFlags |= MECD_ENCODEIMAGES|MECD_ENCODESOUNDS|MECD_ENCODEVIDEO|MECD_ENCODEPLUGINS;

    // turn off sound-playing during a save
    EnableSounds(FALSE);
    hr = SaveAsMHTML(m_pDoc, dwMHTMLFlags, m_pMsg, pMsg, m_pHashExternal);
    EnableSounds(TRUE);
    // if save was sucessful, but we haven't yet had a readystate complete notify then
    // bubble a warning backup to give the user a chance to cancel.
    if (hr==S_OK)
        {
        if (m_dwReadyState != READYSTATE_COMPLETE)
            hr = MIMEEDIT_W_DOWNLOADNOTCOMPLETE;
        else
            ClearDirtyFlag();   // clear dirty flag if OK with no warnings.
        }

    return hr;
}

HRESULT CBody::Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode)
{
    IMimeMessage       *pMsg=0;
    IPersistMoniker    *pMsgMon=0;
    HRESULT             hr;
    BODYINITDATA        biData;
    LPWSTR              pszUrlW=0;

    if (!pMoniker)
        return E_INVALIDARG;

    if (pMoniker->GetDisplayName(NULL, NULL, &pszUrlW)==S_OK &&
        HrSniffUrlForRfc822(pszUrlW)==S_OK)
        {
        // if its a message moniker, load via IMimeMessage
        hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
        if (FAILED(hr))
            goto error;

        hr = pMsg->QueryInterface(IID_IPersistMoniker, (LPVOID*)&pMsgMon);
        if (FAILED(hr))
            goto error;

        hr = pMsgMon->Load(fFullyAvailable, pMoniker, pBindCtx, grfMode);
        if (FAILED(hr))
            goto error;

        biData.dwType = BI_MESSAGE;
        biData.pMsg = pMsg;
        }
    else
        {
        biData.dwType = BI_MONIKER;
        biData.pmk = pMoniker;
        }

    hr = LoadFromData(&biData);

error:
    SafeRelease(pMsg);
    SafeRelease(pMsgMon);
    SafeMemFree(pszUrlW);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     IsDirty
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::IsDirty()
{
    IPersistStreamInit  *ppsi;
    HRESULT hr=S_FALSE;

    TraceCall("CBody::IsDirty");

    // if we're not on the source-tab, use the old dirty-state
    // if we're on richedit, make sure to see if source changes there
    switch (m_uSrcView)
    {
        case MEST_SOURCE:
            Assert (m_pSrcView);
            return m_pSrcView->IsDirty();

        case MEST_PREVIEW:
            return m_fWasDirty ?S_OK:S_FALSE;
    }

    if (m_lpOleObj && 
        m_lpOleObj->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi)==S_OK)
        {
        hr = ppsi->IsDirty();
        ppsi->Release();
        }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     LoadStream
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::LoadStream(LPSTREAM pstm)
{
    HRESULT         hr;
    BODYINITDATA    biData;
    IMimeMessage    *pMsg;

    TraceCall("CBody::LoadStream");

    if (pstm == NULL)
        return TraceResult(E_INVALIDARG);

    // convert RFC822 stream into message
    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (!FAILED(hr))
        {
        hr = pMsg->Load(pstm);
        if (!FAILED(hr))
            {
            biData.dwType = BI_MESSAGE;
            biData.pMsg = pMsg;
            hr = LoadFromData(&biData);
            }
        pMsg->Release();
        }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     LoadFromData
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::LoadFromData(LPBODYINITDATA  pbiData)
{
    HRESULT         hr;
    LPMONIKER       pmk=0;
    IMimeMessage    *pMsg;
    DWORD           dwMsgFlags;

    TraceCall("CBody::LoadFromData");

    AssertSz(pbiData && 
            (   (pbiData->dwType == BI_MESSAGE && pbiData->pMsg) || 
                (pbiData->dwType == BI_MONIKER && pbiData->pmk)), 
                "Caller should be validating params");

    Assert (m_lpOleObj);

    // make sure we're unloaded in case of failure
    UnloadAll();

    switch (pbiData->dwType)
    {
        case BI_MESSAGE:
        {
            WEBPAGEOPTIONS  rOptions;
            BOOL            fIncludeMsg;
            BOOL            fDisplayingHtmlHelp = FALSE;
            BOOL            fGotHtmlHelpCharset = FALSE;
            VARIANTARG      va;

            pMsg = pbiData->pMsg;
            Assert(pMsg);
        
            if(SUCCEEDED(m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_HTML_HELP, 0, NULL, &va)))
                fDisplayingHtmlHelp = (va.boolVal == VARIANT_TRUE);

            if(fDisplayingHtmlHelp)
            {
                IStream     *pStream=NULL;
                LPSTR       pszCharset=NULL;

                if(SUCCEEDED(pMsg->GetTextBody(TXT_HTML, IET_INETCSET, &pStream, NULL)))
                {
                    if(SUCCEEDED(GetHtmlCharset(pStream, &pszCharset)))
                    {
                        if(SUCCEEDED(MimeOleFindCharset(pszCharset, &m_hCharset)))
                            fGotHtmlHelpCharset = TRUE;
                        MemFree(pszCharset);
                    }

                    pStream->Release();
                }
            }
        
            if(!fGotHtmlHelpCharset)
            {
                // set the character set for use by the preview pane, painting etc
                IF_FAILEXIT(hr = pMsg->GetCharset(&m_hCharset));
            }
        
            Assert(m_hCharset);
        
            GetWebPageOptions(&rOptions, &fIncludeMsg);

            if (m_fReloadingSrc || fIncludeMsg)
            {
                // only do autodetection if a plain-text message. this will occur if the
                // message is plain-text only or the host is denying HTML.
                if ( (pMsg->GetFlags(&dwMsgFlags)==S_OK) &&
                    (!(dwMsgFlags & IMF_HTML) || !(rOptions.dwFlags & WPF_HTML)))
                    m_fAutoDetect = 1;
            
                 // add NOMETACHASET as we setup a HTML load options now
                 rOptions.dwFlags |= WPF_NOMETACHARSET;

                IF_FAILEXIT(hr = pMsg->CreateWebPage(NULL, &rOptions, 0, &pmk));
            
                pmk->GetDisplayName(NULL, NULL, &m_pszUrlW);
            
                IF_FAILEXIT(hr = LoadFromMoniker(pmk, m_hCharset));
            }
            else
            {
                m_fForceCharsetLoad = TRUE;
            }

            IF_FAILEXIT(hr = pMsg->QueryInterface(IID_IMimeMessageW, (LPVOID*)&m_pMsgW));
            ReplaceInterface(m_pMsg, pMsg);
            break;
        }            

        case BI_MONIKER:
            IF_FAILEXIT(hr = LoadFromMoniker(pbiData->pmk, NULL));
            
            pbiData->pmk->GetDisplayName(NULL, NULL, &m_pszUrlW);
            break;
    }

    if (m_uHdrStyle == MESTYLE_PREVIEW)
        UpdatePreviewLabels();

    m_fEmpty=0;

exit:
    ReleaseObj(pmk);
    return hr;
}




//+---------------------------------------------------------------
//
//  Member:     CreateBodyObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CreateBodyObject(HWND hwnd, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo, LPBODYOBJ *ppBodyObj)
{
    CBody           *pBody;
    HRESULT         hr;
    
    TraceCall("CreateBodyObject");

    pBody = new CBody();
    if (!pBody)
        return TraceResult(E_OUTOFMEMORY);

    hr = pBody->Init(hwnd, dwFlags, prc, pHostInfo);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    *ppBodyObj = pBody;
    pBody->AddRef();

error:
    pBody->Release();
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     UrlHighlight
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UrlHighlight(IHTMLTxtRange *pRange)
{
    IOleCommandTarget   *pCmdTarget=NULL;
    VARIANT_BOOL        boolVal;

    TraceCall("UrlHighlight");

    if (!pRange)
        return E_INVALIDARG;

    // calling IDM_AUTODETECT will mark the tree dirty, this is bad for replying to plaintext
    // messages etc. To fix this we preserve the dirty between calls.
    boolVal = IsDirty()==S_OK?VARIANT_TRUE:VARIANT_FALSE;
    if (pRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
        pCmdTarget->Exec(&CMDSETID_Forms3, IDM_AUTODETECT, NULL, NULL, NULL);
        pCmdTarget->Release();
        HrSetDirtyFlagImpl(m_pDoc, boolVal);
        }
    return S_OK;
}

HRESULT CBody::StartAutoDetect()
{
    m_cchTotal=0;
    m_cchStart=0;
    SetTimer(m_hwnd, idTimerAutoDetect, AUTODETECT_TICKTIME, NULL);
    return S_OK;
}

HRESULT CBody::AutoDetectTimer()
{
    LONG            cch=0;
    IMimeBody       *pBody;
    IMarkupPointer  *pEndPtr=NULL;
    DWORD           dwPercent;
    WCHAR           wsz[CCHMAX_STRINGRES],
                    wszFmt[CCHMAX_STRINGRES],
                    wsz2[CCHMAX_STRINGRES];
    LPWSTR          pszW;
    HBODY           hBody;
    HRESULT         hr;

    TraceCall("AutoDetectTimer");

    // if mouse has capture, then ignore this timer-tick as user might be scrolling etc.
    if (GetCapture())
        return S_OK;

    // turn of the timer, in case it takes a while
    KillTimer(m_hwnd, idTimerAutoDetect);

    // we try and give a rough %age estimate if autodetect is taking forever
    // we get the total size of the plain-stream and divide the auto detect
    // chunk into it. If we overflow, we sit at 100% for a while. Also, we don't show
    // a %age until we've hit at least 2 auto detect timers (ie. a big document)
    if (m_cchStart == AUTODETECT_CHUNK * 2)
    {
        // time to start showing progress.

        Assert (m_cchTotal == 0);
        if (m_pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, NULL, &hBody)==S_OK)
        {
            if (m_pMsg->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody)==S_OK)
            {
                pBody->GetEstimatedSize(IET_BINARY, &m_cchTotal);
                pBody->Release();
            }
        }
    }

    *wsz = 0;
    LoadStringWrapW(g_hLocRes, idsSearchHLink, wsz, ARRAYSIZE(wsz));

    if (m_cchTotal &&
        LoadStringWrapW(g_hLocRes, idsSearchHLinkPC, wszFmt, ARRAYSIZE(wszFmt)))
    {
        dwPercent = ( m_cchStart * 100 / m_cchTotal );
        if (dwPercent > 100)
            dwPercent = 100;
        AthwsprintfW(wsz2, ARRAYSIZE(wsz2), wszFmt, dwPercent);
        StrCatW(wsz, wsz2);
    }

    SetStatusText(wsz);

    m_fAutoDetect = 0;

    if (m_pAutoStartPtr == NULL)
    {
        // create a starting pointer cache it incase we
        // do chunking
        hr = _CreateRangePointer(&m_pAutoStartPtr);
        if (FAILED(hr))
            goto error;
    }

    // create an end pointer
    hr = _CreateRangePointer(&pEndPtr);
    if (FAILED(hr))
        goto error;

    // set the end poniter to the start pointer
    hr = pEndPtr->MoveToPointer(m_pAutoStartPtr);
    if (FAILED(hr))
        goto error;

    // increment the end pointer by the amount to detect
    cch = AUTODETECT_CHUNK;
    hr = _MovePtrByCch(pEndPtr, &cch);
    if (FAILED(hr))
        goto error;
    
    m_cchStart += cch;

    hr = _UrlHighlightBetweenPtrs(m_pAutoStartPtr, pEndPtr);
    if (FAILED(hr))
        goto error;

    // there must be more to detect, so set the timer
    if (cch >= AUTODETECT_CHUNK)
    {
        m_fAutoDetect = 1;

        // move the cached start pointer to the current end pointer
        hr = m_pAutoStartPtr->MoveToPointer(pEndPtr);
        if (FAILED(hr))
            goto error;
    }

error:    

    if (m_fAutoDetect)
        SetTimer(m_hwnd, idTimerAutoDetect, AUTODETECT_TICKTIME, NULL);
    else
    {
        SetStatusText(NULL);
        SafeRelease(m_pAutoStartPtr);
    }
    
    ReleaseObj(pEndPtr);
    return hr;
}


HRESULT CBody::_MovePtrByCch(IMarkupPointer *pPtr, LONG *pcp)
{
    HRESULT                 hr;
    LONG                    cch,
                            cchDone=0;
    MARKUP_CONTEXT_TYPE     ctxt;

    do
    {
        cch = *pcp - cchDone ;
        
        hr = pPtr->Right(TRUE, &ctxt, NULL, &cch, NULL);
        if (!FAILED(hr))
            cchDone += cch;
    }
    while ( !FAILED(hr) && 
            ctxt != CONTEXT_TYPE_None &&
            cchDone < *pcp);

    *pcp = cchDone;
    return cchDone ? S_OK : E_FAIL;
}


HRESULT CBody::_CreateRangePointer(IMarkupPointer **ppPtr)
{
    IMarkupServices         *pMarkupServices=0;
    IMarkupPointer          *pPtr=0;
    IHTMLBodyElement        *pBodyElem=0;
    IHTMLElement            *pElem=0;
    HRESULT                 hr;

    if (ppPtr == NULL)
        return E_INVALIDARG;

    *ppPtr = 0;

    // get a markup services object
    hr = m_pDoc->QueryInterface(IID_IMarkupServices, (void **) &pMarkupServices);
    if (FAILED(hr))
        goto error;

    hr = pMarkupServices->CreateMarkupPointer(&pPtr);
    if (FAILED(hr))
        goto error;

    // get the body element
    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    // get right interface
    hr = pBodyElem->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem);
    if (FAILED(hr))
        goto error;

    // move start pointer to after begining of <BODY> tag
    hr = pPtr->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto error;

    // hand back pointers
    *ppPtr = pPtr;
    pPtr = NULL;

error:
    ReleaseObj(pElem);
    ReleaseObj(pBodyElem);
    ReleaseObj(pMarkupServices);
    ReleaseObj(pPtr);
    return hr;
}

HRESULT CBody::_UrlHighlightBetweenPtrs(IMarkupPointer *pStartPtr, IMarkupPointer *pEndPtr)
{
    IMarkupServices     *pMarkupServices=0;
    IHTMLTxtRange       *pRange=0;
    HRESULT             hr;

    // get a markup services object
    hr = m_pDoc->QueryInterface(IID_IMarkupServices, (void **) &pMarkupServices);
    if (FAILED(hr))
        goto error;

    // create a text range
    hr = CreateRange(&pRange);
    if (FAILED(hr))
        goto error;

    // use markup services to move pointers to range 
    hr = pMarkupServices->MoveRangeToPointers(pStartPtr, pEndPtr, pRange);
    if (FAILED(hr))
        goto error;

    // autodetect range
    hr = UrlHighlight(pRange);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pMarkupServices);
    ReleaseObj(pRange);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     StopAutoDetect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::StopAutoDetect()
{
    TraceCall("CBody::StopAutoDetect");
    
    if (m_fAutoDetect)
        {
        m_fAutoDetect = 0;
        KillTimer(m_hwnd, idTimerAutoDetect);
        TraceInfo("AutoDetect: CANCELED");
        }
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     UnloadAll
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UnloadAll()
{
    TraceCall("CBody::UnloadAll");
    
    StopAutoDetect();

    InvalidateRect(m_hwnd, NULL, TRUE);

    if (!m_fEmpty)
        {
        if (m_lpOleObj)
            HrInitNew(m_lpOleObj);

        // if unloading due to a tab-switch in source-view
        // don't blow away our restriction hash
        if (!m_fReloadingSrc)
            SafeRelease(m_pHashExternal);
        
        SafeRelease(m_pAttMenu);
        SafeRelease(m_pMsg);
        SafeRelease(m_pMsgW);
        SafeRelease(m_pRangeIgnoreSpell);
        SafeRelease(m_pAutoStartPtr);
        SafeCoTaskMemFree(m_pszUrlW);
        SafeFreeTempFileList(m_pTempFileUrl);
        
        SafeMimeOleFree(m_pszSubject);
        SafeMimeOleFree(m_pszTo);
        SafeMimeOleFree(m_pszCc);
        SafeMimeOleFree(m_pszFrom);

        // if unloading, clear button-bar
        if (m_uHdrStyle == MESTYLE_PREVIEW)
            UpdateBtnBar();

        m_dwReadyState = READYSTATE_UNINITIALIZED;
        m_fMessageParsed = 0;
        m_fEmpty = 1;
        m_hCharset = NULL;

        }
    m_fLoading =1;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     LoadFromMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------

HRESULT CBody::LoadFromMoniker(IMoniker *pmk, HCHARSET hCharset)
{
    HRESULT             hr=E_FAIL;
    LPPERSISTMONIKER    pPMoniker=0;
    LPBC                pbc=0;
    IHtmlLoadOptions    *phlo;
    DWORD               uCodePage=0;
    INETCSETINFO        CsetInfo;

    TraceCall("CBody::LoadFromMoniker");

    Assert (m_lpOleObj);

    hr=m_lpOleObj->QueryInterface(IID_IPersistMoniker, (LPVOID *)&pPMoniker);
    if(FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr=CreateBindCtx(0, &pbc);
    if(FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    if (hCharset)
    {
        // caller wants to override document charset
        if (MimeOleGetCharsetInfo(hCharset, &CsetInfo)==S_OK)
            uCodePage = CsetInfo.cpiInternet;

        if (uCodePage &&
            CoCreateInstance(CLSID_HTMLLoadOptions, NULL, CLSCTX_INPROC_SERVER,
                                IID_IHtmlLoadOptions, (void**)&phlo)==S_OK)
        {
            if (SUCCEEDED(phlo->SetOption(HTMLLOADOPTION_CODEPAGE, 
                                    &uCodePage, sizeof(uCodePage))))
                pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
            phlo->Release();
        }
    }

    hr=pPMoniker->Load(TRUE, pmk, pbc, STGM_READWRITE);
    if(FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }
error:
    ReleaseObj(pPMoniker);
    ReleaseObj(pbc);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     OnFrameActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------

HRESULT CBody::OnFrameActivate(BOOL fActivate)
{
    TraceCall("CBody::OnFrameActivate");
    
    if (m_pInPlaceActiveObj)
        m_pInPlaceActiveObj->OnFrameWindowActivate(fActivate);
    
    // enable/disable sounds on frame activation
    EnableSounds(fActivate);
    return S_OK;
}


BOOL CBody::IsEmpty()
{
    BOOL fEmpty = FALSE;
    if (!m_fDesignMode)
    {
        if (m_fEmpty)
            fEmpty = TRUE;
    }

    /*
    ** We need to come up with a good way to test if the text is
    ** empty. The test below always returns FALSE because of an nbsp
    ** that is in the text. If a better algorithm can be found, then 
    ** we can reimplement this. The case that will hit this is posting
    ** a news note without any text. This should generate a TRUE.
    else
    {
        IHTMLElement    *pElem=0;
        IHTMLTxtRange   *pTxtRangeBegin = NULL,
                        *pTxtRangeEnd = NULL;

        m_pDoc->get_body(&pElem);
        if (pElem)
        {
            if (SUCCEEDED(CreateRange(&pTxtRangeBegin)))
            {
                pTxtRangeBegin->collapse(VARIANT_TRUE);
                if (SUCCEEDED(CreateRange(&pTxtRangeEnd)))
                {
                    pTxtRangeEnd->collapse(VARIANT_FALSE);
                    VARIANT_BOOL varBool = VARIANT_FALSE;
                    if (SUCCEEDED(pTxtRangeBegin->isEqual(pTxtRangeEnd, &varBool)) && (VARIANT_TRUE == varBool))
                        fEmpty = TRUE;
                    pTxtRangeEnd->Release();
                }
                pTxtRangeBegin->Release();
            }
            pElem->Release();
        }
    }
    */
    return fEmpty;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::PrivateQueryStatus
//
//  Synopsis:   Private IOleCmdTarget called from the outer document
//              to implement CDoc::CmdTarget
//
//---------------------------------------------------------------
HRESULT CBody::PrivateQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   uCmd;
    HRESULT hr=E_FAIL;
    OLECMD  *pCmd;
    ULONG   uCmdDisable;
    static const UINT c_rgcmdIdNoPlain[] = 
    {
        IDM_INDENT, IDM_OUTDENT, IDM_FONT, IDM_BLOCKFMT, IDM_IMAGE, 
        IDM_HORIZONTALLINE, IDM_UNLINK, IDM_HYPERLINK
    };



    TraceCall("CBody::PrivateQueryStatus");

    if (m_uSrcView != MEST_EDIT &&
        m_pSrcView &&
        m_pSrcView->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText)==S_OK)
        return S_OK;

    if (pguidCmdGroup == NULL)
    {
        if (m_pCmdTarget)
            hr = m_pCmdTarget->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
        
        for (uCmd=0; uCmd < cCmds; uCmd++)
        {
            pCmd = &prgCmds[uCmd];
            switch(pCmd->cmdID)
            {
            case OLECMDID_PRINT:
                // if we have no m_pMsg, disable the print verb
                if (!m_pMsg)
                    pCmd->cmdf=OLECMDF_SUPPORTED;
                break;
                
            case OLECMDID_FIND:
                pCmd->cmdf=OLECMDF_ENABLED|OLECMDF_SUPPORTED;
                hr = S_OK;
                break;
                
            case OLECMDID_SPELL:
                pCmd->cmdf=OLECMDF_SUPPORTED;
                
                if ((m_uSrcView == MEST_EDIT) && FCheckSpellAvail(m_pParentCmdTarget))
                    pCmd->cmdf |= OLECMDF_ENABLED;
				hr = S_OK;
                break;
            }
        }
        // delegate standard group to trident
    }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_Forms3))
    {
        // delegate Forms3 group to trident
        if (m_pCmdTarget)
            hr = m_pCmdTarget->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
        
        // post-process triden't query status and disable commands that are not
        // available in plain-text mode
        if (m_fPlainMode)
        {
            for (uCmd=0; uCmd < cCmds; uCmd++)
            {
                for (uCmdDisable = 0; uCmdDisable < ARRAYSIZE(c_rgcmdIdNoPlain); uCmdDisable++)
                {
                    if (c_rgcmdIdNoPlain[uCmdDisable] == prgCmds[uCmd].cmdID)
                    {
                        // if enabled, disable it
                        prgCmds[uCmd].cmdf &= ~OLECMDF_ENABLED;
                        break;
                    }
                }
            }
                
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEdit))
    {
        for (uCmd=0; uCmd < cCmds; uCmd++)
        {
            pCmd = &prgCmds[uCmd];
            
            pCmd->cmdf = OLECMDF_SUPPORTED;
            
            switch(pCmd->cmdID)
            {
            case MECMDID_TABLINKS:
            case MECMDID_APPLYDOCUMENT:
            case MECMDID_SAVEASSTATIONERY:
            case MECMDID_DIRTY:
            case MECMDID_INSERTTEXTFILE:
            case MECMDID_FORMATFONT:
            case MECMDID_SETTEXT:
            case MECMDID_DOWNGRADEPLAINTEXT:
            case MECMDID_CHARSET:
            case MECMDID_ROT13:
            case MECMDID_INSERTTEXT:
            case MECMDID_INSERTHTML:
            case MECMDID_BACKGROUNDCOLOR:
            case MECMDID_STYLE:
            case MECMDID_CANENCODETEXT:    
                pCmd->cmdf|=OLECMDF_ENABLED; 
                break;
                
            case MECMDID_SHOWSOURCETABS:
                if (!m_fPlainMode)
                {
                    // source-editing only available in plain-text mode
                    pCmd->cmdf|=OLECMDF_ENABLED; 
                    if (m_fSrcTabs)
                        pCmd->cmdf|=OLECMDF_LATCHED; 
                }
                break;
                
            case MECMDID_EMPTY:
                pCmd->cmdf|=OLECMDF_ENABLED;
             
                if (IsEmpty())
                    pCmd->cmdf|=OLECMDF_LATCHED;
                break;
                
            case MECMDID_EDITHTML:
                pCmd->cmdf|=OLECMDF_ENABLED;
                
                if (!m_fPlainMode)
                    pCmd->cmdf|=OLECMDF_LATCHED;
                break;
                
            case MECMDID_EDITMODE:
                pCmd->cmdf|=OLECMDF_ENABLED;
                
                if (m_fDesignMode)
                    pCmd->cmdf|=OLECMDF_LATCHED;
                
                break;
                
            case MECMDID_SAVEATTACHMENTS:
                EnsureAttMenu();
                if (m_pAttMenu &&
                    m_pAttMenu->HasEnabledAttach()==S_OK)
                    pCmd->cmdf|=OLECMDF_ENABLED;
                break;
                
            case MECMDID_FORMATPARAGRAPH:
                if (!m_fPlainMode)
                    pCmd->cmdf|=OLECMDF_ENABLED;
                break;
                
            default:
                // not a recognised command
                pCmd->cmdf = 0;
                break;                    
            }
        }
        hr = S_OK;
    }
    else
        hr = OLECMDERR_E_UNKNOWNGROUP;
    
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::PrivateExec
//
//  Synopsis:   Private IOleCmdTarget called from the outer document
//              to implement CDoc::CmdTarget
//
//---------------------------------------------------------------
HRESULT CBody::PrivateExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr=E_FAIL;

    TraceCall("CBody::PrivateExec");

    if (m_uSrcView != MEST_EDIT &&
        m_pSrcView &&
        m_pSrcView->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut)==S_OK)
        return S_OK;

    if (pguidCmdGroup == NULL || IsEqualGUID(*pguidCmdGroup, CMDSETID_Forms3) || IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView))
        {
        switch (nCmdID)
            {
            case OLECMDID_SPELL:
                {
                VARIANTARG  va;
                // tell trident we are bringing up a modal dialog
                // by calling PrivateEnableModeless
                if (!m_pSpell) //no background spellchecking
                    HrCreateSpeller(FALSE);

                if (m_pSpell)
                    {
                    PrivateEnableModeless(FALSE);
#ifdef BACKGROUNDSPELL
                    if (m_fBkgrndSpelling)
                        KillTimer(m_hwnd, idTimerBkgrndSpell);
#endif // BACKGROUNDSPELL
                    hr = m_pSpell->HrSpellChecking(m_pRangeIgnoreSpell, m_hwnd, (OLECMDEXECOPT_DONTPROMPTUSER==nCmdExecOpt)?TRUE:FALSE);
#ifdef BACKGROUNDSPELL
                    if (m_fBkgrndSpelling)
                        SetTimer(m_hwnd, idTimerBkgrndSpell, BKGRNDSPELL_TICKTIME, NULL);
#endif // BACKGROUNDSPELL
                    PrivateEnableModeless(TRUE);
                    }
                }
                return hr;

            case OLECMDID_PRINT: 
                return Print(nCmdExecOpt!=OLECMDEXECOPT_DONTPROMPTUSER, pvaIn);
            
            case OLECMDID_REFRESH:
                return m_pCmdTarget ? m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_REFRESH, OLECMDEXECOPT_DODEFAULT, NULL, NULL) : E_FAIL; 

            case OLECMDID_FIND:
                // Trident has own private Find, map OLE find to this.
                return m_pCmdTarget ? m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FIND, OLECMDEXECOPT_DODEFAULT, NULL, NULL) : E_FAIL; 
            }
        
        // delegate standard commands and trident commandset we don't handle
        // to trident
        return m_pCmdTarget?m_pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut):E_NOTIMPL;
        }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEdit))
        {
        hr = E_INVALIDARG;

        switch (nCmdID)
            {
            case MECMDID_SETSOURCETAB:
                if (pvaIn && pvaIn->vt == VT_I4)
                    return SetSourceTabs(pvaIn->lVal);
                else if (pvaOut)
                {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = m_fSrcTabs ? m_uSrcView : MEST_EDIT;
                    return S_OK;
                }
                return E_INVALIDARG;

            case MECMDID_TABLINKS:
                if (pvaIn && pvaIn->vt == VT_BOOL)
                {
                    m_fTabLinks = (pvaIn->boolVal == VARIANT_TRUE);
                    return S_OK;
                }
                return E_INVALIDARG;

            case MECMDID_SAVEATTACHMENTS:
                return SaveAttachments();

            case MECMDID_INSERTBGSOUND:
                return InsertBackgroundSound();

            case MECMDID_BACKGROUNDIMAGE:
                if (pvaIn && pvaIn->vt == VT_BSTR)
                    return SetBackgroundImage(m_pDoc, pvaIn->bstrVal);
                
                if (pvaOut)
                    {
                    pvaOut->vt = VT_BSTR;
                    return GetBackgroundImage(m_pDoc, &pvaOut->bstrVal);
                    }
                
                return E_INVALIDARG;
                
            case MECMDID_SHOWSOURCETABS:
                if (pvaIn && pvaIn->vt == VT_BOOL)
                    {
                    ShowSourceTabs(pvaIn->boolVal == VARIANT_TRUE);
                    return S_OK;
                    }
                return E_INVALIDARG;
                    
            case MECMDID_APPLYDOCUMENT:
                return ApplyDocumentVerb(pvaIn);

            case MECMDID_SAVEASSTATIONERY:
                return SaveAsStationery(pvaIn, pvaOut);

            case MECMDID_DIRTY:
                if (pvaIn &&
                    pvaIn->vt == VT_BOOL)
                    {
                    return HrSetDirtyFlagImpl(m_pDoc, pvaIn->boolVal==VARIANT_TRUE);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = IsDirty()==S_OK?VARIANT_TRUE:VARIANT_FALSE;
                    return S_OK;
                    }
                break;

            case MECMDID_FORMATPARAGRAPH:
                return HrFormatParagraph();
                break;    

            case MECMDID_EMPTY:
                if (pvaOut)
                {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = (IsEmpty() ? VARIANT_TRUE : VARIANT_FALSE);
                    return S_OK;
                }
                break;

            case MECMDID_DOWNGRADEPLAINTEXT:
                return DowngradeToPlainText(pvaIn ? (pvaIn->vt == VT_BOOL ? (pvaIn->boolVal == VARIANT_TRUE) : NULL ): NULL );

            case MECMDID_CHARSET:
                if (pvaIn && 
                    pvaIn->vt == VT_I8)
                    {
                    return SetCharset((HCHARSET)pvaIn->ullVal);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_I8;
                    pvaOut->ullVal = (ULONGLONG)m_hCharset;
                    return S_OK;
                    }
                        
                break;

            case MECMDID_FORMATFONT:
                return FormatFont();

            case MECMDID_PREVIEWFORMAT:
                if (pvaIn && 
                    pvaIn->vt == VT_BSTR)
                    {
                    SafeMemFree(m_pszLayout);
                    HrBSTRToLPSZ(CP_ACP, pvaIn->bstrVal, &m_pszLayout);
                    RecalcPreivewHeight(NULL);
                    Resize();
                    return S_OK;
                    }
                break;


            case MECMDID_INSERTTEXTFILE:
                return InsertFile((pvaIn && pvaIn->vt==VT_BSTR) ? pvaIn->bstrVal : NULL);

            case MECMDID_VIEWSOURCE:
                if (pvaIn && 
                    pvaIn->vt == VT_I4)
                    {
                    ViewSource(pvaIn->lVal == MECMD_VS_MESSAGE);
                    return S_OK;
                    }
                break;

            case MECMDID_STYLE:
                if (pvaIn && 
                    pvaIn->vt == VT_I4)
                    return SetStyle(pvaIn->lVal);

                if (pvaOut)
                    {
                    pvaOut->vt=VT_I4;
                    pvaOut->lVal = m_uHdrStyle;
                    return S_OK;
                    }
                break;

            case MECMDID_ROT13:
                if (pvaIn == NULL && pvaOut == NULL)
                    {
                    DoRot13();
                    return S_OK;
                    }
                break;

            case MECMDID_INSERTTEXT:
            case MECMDID_INSERTHTML:
                if (pvaIn && pvaIn->vt == VT_BSTR)
                    {
                    return InsertTextAtCaret(pvaIn->bstrVal, MECMDID_INSERTHTML == nCmdID, FALSE);
                    }
                break;

            case MECMDID_BACKGROUNDCOLOR:
                if (pvaIn && VT_I4 == pvaIn->vt)
                    return SetBackgroundColor(pvaIn->ulVal);
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    return GetBackgroundColor(&(pvaOut->ulVal));
                    }
                break;

            case MECMDID_EDITHTML:
                if (pvaIn &&
                    pvaIn->vt == VT_BOOL)
                    {
                    return SetPlainTextMode(pvaIn->boolVal!=VARIANT_TRUE);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = m_fPlainMode?VARIANT_FALSE:VARIANT_TRUE;
                    return S_OK;
                    }
                break;

            case MECMDID_EDITMODE:
                if (pvaIn &&
                    pvaIn->vt == VT_BOOL)
                    {
                    return SetDesignMode(pvaIn->boolVal==VARIANT_TRUE);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = m_fDesignMode?VARIANT_TRUE:VARIANT_FALSE;
                    return S_OK;
                    }
                return E_INVALIDARG;
            
            case MECMDID_SETTEXT:
                if (pvaIn==NULL || pvaIn->vt != VT_BSTR)
                    return E_INVALIDARG;

                return SetDocumentText(pvaIn->bstrVal);

            case MECMDID_CANENCODETEXT:
                if (!pvaIn || pvaIn->vt != VT_UI4)
                    return E_INVALIDARG;
                return SafeToEncodeText(pvaIn->lVal);

            default:
                hr = E_NOTIMPL;

            }
        }

    return hr;

}


HRESULT CBody::PrivateTranslateAccelerator(LPMSG lpmsg)
{
    HRESULT     hr=S_FALSE;
    BOOL        fTabbing=FALSE;
    HWND        hwndFocus;

    // first of all, see if the formatbar is taking it...
    if (m_fUIActive &&
        m_uHdrStyle==MESTYLE_FORMATBAR &&
        m_pFmtBar &&
        m_pFmtBar->TranslateAcclerator(lpmsg)==S_OK)
        return S_OK;
    
    if (m_pSrcView &&
        m_uSrcView == MEST_SOURCE)
        {
        return m_pSrcView->TranslateAccelerator(lpmsg);
        }

    // if trident is not in-place active, don't pass accelerators
    if(!m_pInPlaceActiveObj)
        return S_FALSE;

    if (!m_fFocus)
    {
        // if trident doesn't have focus, make sure it's not a child
        // of trident before blocking
        hwndFocus = GetFocus();
        
        if (hwndFocus == NULL || 
            !IsChild(m_hwndDocObj, hwndFocus))
            return S_FALSE;
    }

    // if Trident has focus and we get a TAB key in edit mode, we snag it and
    // insert a tab ourselves
    if (m_fFocus && 
        lpmsg->message == WM_KEYDOWN && 
        lpmsg->wParam == VK_TAB &&
        m_fDesignMode && 
        !(GetKeyState(VK_SHIFT)&0x8000))
        {
        // plain-tab with no shift in design mode inserts a tag
        InsertTextAtCaret((BSTR)c_bstr_TabChar, FALSE, TRUE);
        return S_OK;
        }

    if (lpmsg->message == WM_KEYDOWN)
        {
        if (lpmsg->wParam == VK_F6)
            return S_FALSE;

        if (lpmsg->wParam == VK_TAB)
            {
            if (!(m_fTabLinks))
                return S_FALSE;
            
            // if this control want's link-tabbing...
            fTabbing=TRUE;
            m_fCycleFocus=0;
            }
        }

    // trident snags EVERYTHING. even non-keystrokes, only pass them keys...
    if(lpmsg->message >= WM_KEYFIRST && lpmsg->message <= WM_KEYLAST)
        {
        hr=m_pInPlaceActiveObj->TranslateAccelerator(lpmsg);

        if (m_fIgnoreAccel)
        {
            m_fIgnoreAccel = 0;
            return S_FALSE;
        }

        if (fTabbing && m_fCycleFocus)
            return S_FALSE;
        }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::PrivateQueryService
//
//  Synopsis:   Private QueryService called from the outer document
//              to implement CDoc::IServiceProvider
//
//---------------------------------------------------------------
HRESULT CBody::PrivateQueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    HRESULT             hr;

    TraceCall("CBody::PrivateQueryService");

    if (!m_pDoc)
        return E_UNEXPECTED;

    if (IsEqualGUID(guidService, IID_IHTMLDocument2) &&
        IsEqualGUID(riid, IID_IHTMLDocument2))
        {
        *ppvObject = (LPVOID)m_pDoc;
        m_pDoc->AddRef();
        return S_OK;
        }

    // RAID 12020. Needed to be able to get at DocHostUI for drop stuff
    else if (IsEqualGUID(guidService, IID_IDocHostUIHandler) &&
        IsEqualGUID(riid, IID_IDocHostUIHandler))
        {
        *ppvObject = (LPVOID)(IDocHostUIHandler*)this;
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::SetDesignMode
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SetDesignMode(BOOL fOn)
{
    HRESULT hr;

    TraceCall("CBody::SetDesignMode");

    if (fOn == m_fDesignMode)   // bitfield!
        return S_OK;

    Assert (m_pCmdTarget);
    Assert (m_lpOleObj);

    hr = m_pCmdTarget->Exec(&CMDSETID_Forms3, 
                            (fOn?IDM_EDITMODE:IDM_BROWSEMODE),  
                            MSOCMDEXECOPT_DONTPROMPTUSER, 
                            NULL, NULL);
    if (!FAILED(hr))
        {
        m_fDesignMode = !!fOn;  // bitfield
        if (fOn)
            {
            SetHostComposeFont();
            }
        }
    return hr;
}

HRESULT CBody::SetPlainTextMode(BOOL fOn)
{
    VARIANTARG  va;
    BSTR        bstr=0;

    m_fPlainMode=fOn;

    va.bstrVal = NULL;
    if (!fOn && 
        m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_COMPOSE_FONT, OLECMDEXECOPT_DODEFAULT, NULL, &va);

    SetComposeFont(va.bstrVal);     //va.bstrVal could be NULL to turn compose font OFF
    SysFreeString(va.bstrVal);
    if (fOn)
    {
        // if going to plain-text mode, remove the tabs
        ShowSourceTabs(FALSE);
    }
    else
    {
        // if going from plain-text > html, then exec a remove formatting command
        // so that the new compose font is applied 
        IHTMLTxtRange           *pTxtRange;
        IOleCommandTarget       *pCmdTarget;

        if (!FAILED(CreateRange(&pTxtRange)))
        {
            if (!FAILED(pTxtRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)))
            {
                pCmdTarget->Exec(&CMDSETID_Forms3, IDM_REMOVEFORMAT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                pCmdTarget->Release();
            }
            pTxtRange->Release();
        }
    }
    return S_OK;
}




//+---------------------------------------------------------------
//
//  Member:     DeleteElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::DeleteElement(IHTMLElement *pElem)
{
    HRESULT     hr=E_INVALIDARG;
    
    TraceCall("CBody::DeleteElement");
    if (pElem)
        hr = pElem->put_outerHTML(NULL);

    return hr;        
}


//+---------------------------------------------------------------
//
//  Member:     ReplaceElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ReplaceElement(LPCTSTR pszName, BSTR bstrPaste, BOOL fHtml)
{
    IHTMLElement    *pElem;
    HRESULT         hr;

    TraceCall("CBody::HrReplaceElement");

    if (!FAILED(hr = GetElement(pszName, &pElem)))
        {
        if (fHtml)
            hr = pElem->put_outerHTML(bstrPaste);
        else
            hr = pElem->put_outerText(bstrPaste);
        pElem->Release();
        }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SelectElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SelectElement(IHTMLElement *pElem, BOOL fScrollIntoView)
{
    IHTMLTxtRange *pRange;
    HRESULT         hr;
    VARIANT         v;        
    
    TraceCall("CBody::SelectElement");

    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    if (!FAILED(hr=CreateRangeFromElement(pElem, &pRange)))
        {
        pRange->collapse(VARIANT_TRUE);
        pRange->select();
        if (fScrollIntoView)
            pRange->scrollIntoView(VARIANT_TRUE);
        pRange->Release();
        }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CreateRangeFromElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::CreateRangeFromElement(IHTMLElement *pElem, IHTMLTxtRange **ppRange)
{
    HRESULT hr;
    IHTMLTxtRange *pRange;

    TraceCall("CBody::CreateRangeFromElement");

    Assert (pElem && ppRange);

    if (!FAILED(hr = CreateRange(&pRange)))
        {
        if (!FAILED(hr = pRange->moveToElementText(pElem)))
            {
            *ppRange = pRange;
            pRange->AddRef();
            }
        pRange->Release();
        }
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     HrCreateRange
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::CreateRange(IHTMLTxtRange **ppRange)
{
    IHTMLBodyElement        *pBodyElem=0;
    HRESULT                 hr=E_FAIL;

    TraceCall("CBody::HrCreateRange");

    Assert (ppRange);
    *ppRange = NULL;
    if (!FAILED(GetBodyElement(&pBodyElem)))
    {
        pBodyElem->createTextRange(ppRange);
        if (*ppRange)
            hr = S_OK;
        pBodyElem->Release();
    }
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelection
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetSelection(IHTMLTxtRange **ppRange)
{
    IHTMLSelectionObject    *pSel=0;
    IHTMLTxtRange           *pTxtRange=0;
    IDispatch               *pID=0;
    HRESULT                 hr=E_FAIL;

    TraceCall("CBody::GetSelection");

    if (ppRange == NULL)
        return TraceResult(E_INVALIDARG);

    *ppRange = NULL;

    if(m_pDoc)
        {
        m_pDoc->get_selection(&pSel);
        if (pSel)
            {
            pSel->createRange(&pID);
            if (pID)
                {
                hr = pID->QueryInterface(IID_IHTMLTxtRange, (LPVOID *)ppRange);
                pID->Release();
                }
            pSel->Release();
            }
        }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelection
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetElement(LPCTSTR pszName, IHTMLElement **ppElem)
{
    TraceCall("CBody::GetElement");

    return ::HrGetElementImpl(m_pDoc, pszName, ppElem);
}


//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelection
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetBodyElement(IHTMLBodyElement **ppBody)
{
    TraceCall("CBody::GetBodyElement");

    return ::HrGetBodyElement(m_pDoc, ppBody);
}



//+---------------------------------------------------------------
//
//  Member:     CBody::Print
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Print(BOOL fPrompt, VARIANTARG *pvaIn)
{
    VARIANTARG      va;
    SAFEARRAY      *psa = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    LONG            l;
    BSTR            bstrFooter  = NULL,
                    bstrHeader  = NULL,
                    bstrUrl     = NULL;
    HRESULT         hr;
    VARIANT         v;
    LPSTREAM        pstm = NULL;
    BOOL            fMHtml = FALSE;
    HBODY           hBody;
    WCHAR           wsz[CCHMAX_STRINGRES];
    LPWSTR          pwszUser = NULL;
    
    TraceCall("CBody::Print");
    
    if (m_pCmdTarget==NULL)
        return TraceResult(E_UNEXPECTED);
    
    // if we're printing an MHTML message, print by URL so that cid:'s print
    // NB: this is a loss of fidelity.
    if (m_pMsg)
        fMHtml = (MimeOleGetRelatedSection(m_pMsg, FALSE, &hBody, NULL)==S_OK) && m_pszUrlW;
    
    rgsaBound[0].lLbound = 0;
    rgsaBound[0].cElements = fMHtml ? 4 : 3;
    
    IF_NULLEXIT(psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound));
    
    va.vt = VT_ARRAY|VT_BYREF;
    va.parray = psa;
    
    *wsz = 0;
    SideAssert(LoadStringWrapW(g_hLocRes, idsPrintHeader, wsz, ARRAYSIZE(wsz)));
    
    IF_NULLEXIT(bstrHeader = SysAllocString(wsz));
    
    v.vt = VT_BSTR;
    v.bstrVal = bstrHeader;
    
    // don't show the <TITLE> tag on the header
    l=0;
    IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
    
    *wsz = 0;
    SideAssert(LoadStringWrapW(g_hLocRes, idsPrintFooter, wsz, ARRAYSIZE(wsz)));
    
    // we want footer to have only date, not URL.
    IF_NULLEXIT(bstrFooter = SysAllocString(wsz));
    
    v.vt = VT_BSTR;
    v.bstrVal = bstrFooter;
    
    // FOOTER
    l=1;
    IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
    
    if (m_pMsg)
    {
        if (pvaIn && pvaIn->vt == VT_BSTR)
            pwszUser = pvaIn->bstrVal;

        IF_FAILEXIT(hr = GetHeaderTable(m_pMsgW, pwszUser, HDR_TABLE, &pstm));
        
        HrRewindStream(pstm);
        
        // ISTREAM containing table
        v.vt = VT_UNKNOWN;
        v.punkVal = (LPUNKNOWN)pstm;
        
        l=2;
        IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
        
        if (fMHtml)
        {
            bstrUrl = SysAllocString(m_pszUrlW);
            
            v.vt = VT_BSTR;
            v.bstrVal = bstrUrl;
            
            l=3;
            IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
        }
        
    }
    
    hr = m_pCmdTarget->Exec(NULL, OLECMDID_PRINT, 
        (fPrompt)?(OLECMDEXECOPT_PROMPTUSER):(OLECMDEXECOPT_DONTPROMPTUSER), &va, NULL);
    IF_FAILEXIT(hr);

exit:
    SysFreeString(bstrFooter);
    SysFreeString(bstrHeader);
    SysFreeString(bstrUrl);
    if (psa)
        SafeArrayDestroy(psa);
    ReleaseObj(pstm);
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CBody::OnWMCommand
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnWMCommand(HWND hwnd, int id, WORD wCmd)
{
    DWORD               nCmdId=0,
                        nCmdIdTrident=0,
                        nCmdIdOESecure=0;
    POINT               pt;
    VARIANTARG          va;
    VARIANTARG          *pvaIn=0,
                        *pvaOut=0;

    TraceCall("CBody::OnWMCommand");

    if (m_pSrcView &&
        m_pSrcView->OnWMCommand(hwnd, id, wCmd)==S_OK)
        return S_OK;

    if (m_pFmtBar && 
        m_pFmtBar->OnWMCommand(hwnd, id, wCmd)==S_OK)
        return S_OK;

    if (!m_pCmdTarget)
        return S_FALSE;

    switch (id)
    {
        case idmPaneEncryption:
        case idmPaneBadEncryption:
            if (PointFromButton(id, &pt)==S_OK)
            {
                va.vt = VT_BYREF;
                va.byref = &pt;
                pvaIn = &va;
                nCmdIdOESecure = OECSECCMD_ENCRYPTED;
            }
            break;

        case idmPaneBadSigning:
        case idmPaneSigning:
            if (PointFromButton(id, &pt)==S_OK)
            {
                va.vt = VT_BYREF;
                va.byref = &pt;
                pvaIn = &va;
                nCmdIdOESecure = OECSECCMD_SIGNED;
            }
            break;

        case idmPaneVCard:
            if (m_pAttMenu)
                m_pAttMenu->LaunchVCard(m_hwnd);
            break;

#ifdef FOLLOW_LINK
        case idmOpenLink:
            nCmdIdTrident = IDM_FOLLOWLINKN;
            break;
#endif

        case idmCopy:
            nCmdId = OLECMDID_COPY;
            break;

        case idmSaveTargetAs:
            nCmdIdTrident = IDM_SAVETARGET;
            break;

        case idmCopyShortcut:
            nCmdIdTrident = IDM_COPYSHORTCUT;
            break;

        case idmCut:
            nCmdId = OLECMDID_CUT;
            break;

        case idmPaste:
            nCmdId = OLECMDID_PASTE;
            break;

        case idmSelectAll:
            nCmdId = OLECMDID_SELECTALL;
            break;

        case idmUndo:
            nCmdId = OLECMDID_UNDO;
            break;

        case idmRedo:
            nCmdId = OLECMDID_REDO;
            break;

        case idmAddToFavorites:
            AddToFavorites();
            return S_OK;

        case idmAddToWAB:
            AddToWab();
            return S_OK;

        case idmSaveBackground:
            nCmdIdTrident = IDM_SAVEBACKGROUND;
            break;

        case idmSavePicture:
			_OnSaveImage();
            break;

        case idmFmtLeft:
            nCmdIdTrident = IDM_JUSTIFYLEFT;
            break;

        case idmFmtCenter:
            nCmdIdTrident = IDM_JUSTIFYCENTER;
            break;

        case idmFmtRight:
            nCmdIdTrident = IDM_JUSTIFYRIGHT;
            break;

        case idmFmtNumbers:
            nCmdIdTrident = IDM_ORDERLIST;
            break;

        case idmFmtBullets:
            nCmdIdTrident = IDM_UNORDERLIST;
            break;

        case idmFmtBlockDirLTR:
            nCmdIdTrident = IDM_BLOCKDIRLTR;
            break;

        case idmFmtBlockDirRTL:
            nCmdIdTrident = IDM_BLOCKDIRRTL;
            break;

        case idmFmtFontDlg:
            return FormatFont();

        case idmFmtParagraphDlg:
            return HrFormatParagraph();
            
        case idmProperties:
            nCmdIdTrident = DwChooseProperties();
            if (nCmdIdTrident==0)
            {
                return DoHostProperties();
            }
            break;
    }

    if(nCmdId)
    {
        m_pCmdTarget->Exec(NULL, nCmdId, OLECMDEXECOPT_DODEFAULT, pvaIn, pvaOut);
        return S_OK;
    }
    
    if(nCmdIdTrident)
    {
        m_pCmdTarget->Exec(&CMDSETID_Forms3, nCmdIdTrident, OLECMDEXECOPT_DODEFAULT,  pvaIn, pvaOut);
        return S_OK;
    }
    
    if (nCmdIdOESecure && m_pParentCmdTarget)
    {
        // delegate security commands to the host
        m_pParentCmdTarget->Exec(&CMDSETID_OESecurity, nCmdIdOESecure, OLECMDEXECOPT_DODEFAULT, pvaIn, pvaOut);
        return S_OK;
    }

    return S_FALSE;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::UpdateContextMenu
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UpdateContextMenu(HMENU hmenuEdit, BOOL fEnableProperties, IDispatch *pDisp)
{
    OLECMD  rgTridentCmds[]=   {{IDM_FIND, 0},
                                {IDM_SAVEBACKGROUND, 0},
                                {IDM_COPYSHORTCUT, 0},
                                {IDM_SAVETARGET, 0}};
    OLECMD  rgStdCmds[]=       {{OLECMDID_CUT, 0},
                                {OLECMDID_COPY, 0},
                                {OLECMDID_PASTE, 0},
                                {OLECMDID_SELECTALL, 0},
                                {OLECMDID_UNDO, 0},
                                {OLECMDID_REDO, 0}};
    int     rgidsStd[]=        {idmCut,
                                idmCopy,
                                idmPaste,
                                idmSelectAll,
                                idmUndo,
                                idmRedo};    
    int     rgidsTrident[]=    {idmFindText,
                                idmSaveBackground,
                                idmCopyShortcut,
                                idmSaveTargetAs};
    OLECMD  rgFmtCmds[]=       {{IDM_INDENT, 0},    // careful about ordering!!
                                {IDM_OUTDENT, 0},
                                {IDM_FONT, 0}};
    int     rgFmtidm[] =       {idmFmtIncreaseIndent,    // careful about ordering!!
                                idmFmtDecreaseIndent,
                                idmFmtFontDlg};
    OLECMD  rgHostCmds[]=       {{OLECMDID_PROPERTIES, 0}};
    int     rgHostidm[]=    {idmProperties};
    UINT                    ustate;
    int                     i,
                            id;
    BSTR                    bstrHref=NULL;
    BOOL                    fBadLink = FALSE;
    IHTMLAnchorElement      *pAE;

    TraceCall("CBody::UpdateContextMenu");

    if (!m_pCmdTarget || !hmenuEdit)
        return E_INVALIDARG;
    
    if (pDisp &&
        pDisp->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
    {
        pAE->get_href(&bstrHref);
        if (bstrHref &&
            StrCmpNIW(bstrHref, c_szOECmdW, ARRAYSIZE(c_szOECmdW)-sizeof(WCHAR))==0)
            fBadLink = TRUE;

        pAE->Release();
    }
            
    m_pCmdTarget->QueryStatus(NULL, sizeof(rgStdCmds)/sizeof(OLECMD), rgStdCmds, NULL);
    for (i=0; i<sizeof(rgStdCmds)/sizeof(OLECMD); i++)
        SetMenuItem(hmenuEdit, rgidsStd[i], rgStdCmds[i].cmdf & OLECMDF_ENABLED);

    m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgTridentCmds)/sizeof(OLECMD), rgTridentCmds, NULL);

    for (i=0; i<sizeof(rgTridentCmds)/sizeof(OLECMD); i++)
    {
        ustate = rgTridentCmds[i].cmdf & OLECMDF_ENABLED;
        
        if (rgidsTrident[i] == idmSaveTargetAs || rgidsTrident[i] == idmCopyShortcut)
            ustate = ustate && !fBadLink;

        SetMenuItem(hmenuEdit, rgidsTrident[i], ustate);
    }

    // set the formatting commands. The are only available when we have focus and we are editing an HTML document
    if (m_fFocus && !m_fPlainMode)
        m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgFmtCmds)/sizeof(OLECMD), rgFmtCmds, NULL);

    ustate = !m_fPlainMode ? MF_ENABLED : (MF_DISABLED|MF_GRAYED);    
    EnableMenuItem(hmenuEdit, idmFmtParagraphDlg, ustate);

    for(i=0; i<sizeof(rgFmtCmds)/sizeof(OLECMD); i++)
    {
        ustate = (rgFmtCmds[i].cmdf&OLECMDF_ENABLED ? MF_ENABLED: MF_DISABLED|MF_GRAYED) | MF_BYCOMMAND;
        EnableMenuItem(hmenuEdit, rgFmtidm[i], ustate);
        ustate = (rgFmtCmds[i].cmdf&OLECMDF_LATCHED?MF_CHECKED:MF_UNCHECKED) | MF_BYCOMMAND;
        CheckMenuItem(hmenuEdit, rgFmtidm[i], ustate);
    }

    if (m_pParentCmdTarget)
        m_pParentCmdTarget->QueryStatus(NULL, sizeof(rgHostCmds)/sizeof(OLECMD), rgHostCmds, NULL);

    // if we are handling idmProperties then override the host state
    if (fEnableProperties)
        rgHostCmds[0].cmdf = OLECMDF_ENABLED;
    
    for(i=0; i<sizeof(rgHostCmds)/sizeof(OLECMD); i++)
        SetMenuItem(hmenuEdit, rgHostidm[i], rgHostCmds[i].cmdf & OLECMDF_ENABLED);

    SysFreeString(bstrHref);
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::AppendAnchorItems
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::AppendAnchorItems(HMENU hMenu, IDispatch *pDisp)
{
    BSTR                    bstr=0;
    TCHAR                   rgch[CCHMAX_STRINGRES];
    HRESULT                 hr=S_OK;
    IHTMLAnchorElement      *pAE;
    OLECMD                  rgHostCmds[]={  {MEHOSTCMDID_ADD_TO_ADDRESSBOOK, 0},
                                            {MEHOSTCMDID_ADD_TO_FAVORITES,  0}};

    TraceCall("CBody::AppendAnchorItems");

    if (!pDisp)
        return S_OK;

    // if no parent cmdtarget, can't do these verbs anyway
    if (m_pParentCmdTarget && 
        m_pParentCmdTarget->QueryStatus(&CMDSETID_MimeEditHost, sizeof(rgHostCmds)/sizeof(OLECMD), rgHostCmds, NULL)==S_OK)
    {
        if (pDisp->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
        {
            hr = pAE->get_href(&bstr);
            pAE->Release();
        }            
        
        if (bstr)
        {
            *rgch = 0;
            
            // If "mailto:" is in bstr then add it to wab; If "http:" is in bstr, add it to favorites
            if (rgHostCmds[0].cmdf & OLECMDF_ENABLED && 
                StrCmpNIW(bstr, c_szMailToW, ARRAYSIZE(c_szMailToW)-sizeof(WCHAR))==0)
            {
                SideAssert(LoadString(g_hLocRes, idsAddToWAB, rgch, sizeof(rgch)/sizeof(TCHAR)));
                AppendMenu(hMenu, MF_SEPARATOR, 0, 0);
                AppendMenu(hMenu, MF_STRING, idmAddToWAB, rgch);
                RemoveMenu(hMenu, idmSaveTargetAs, MF_BYCOMMAND);   // no point on a mailto: url
            }
            else if (rgHostCmds[1].cmdf & OLECMDF_ENABLED &&
                (StrCmpNIW(bstr, c_szHttpW, ARRAYSIZE(c_szHttpW)-sizeof(WCHAR))==0 || 
                StrCmpNIW(bstr, c_szFileW, ARRAYSIZE(c_szFileW)-sizeof(WCHAR))==0 ))
            {
                SideAssert(LoadString(g_hLocRes, idsAddToFavorites, rgch, sizeof(rgch)/sizeof(TCHAR)));
                AppendMenu(hMenu, MF_SEPARATOR, 0, 0);
                AppendMenu(hMenu, MF_STRING, idmAddToFavorites, rgch);
            }

            SysFreeString(bstr);
        }
    }

    
    return hr;
}




//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelectedAnchor
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetSelectedAnchor(BSTR* pbstr)
{
    HRESULT                 hr;
    IHTMLTxtRange           *pTxtRange;
    IHTMLAnchorElement      *pAE;
    IHTMLElement            *pElemParent;

    TraceCall("CBody::GetSelectedAnchor");

    if (pbstr)
        *pbstr=NULL;

    hr = GetSelection(&pTxtRange);
    if (!FAILED(hr))
    {
        hr = pTxtRange->parentElement(&pElemParent);
        if (!FAILED(hr))
        {
            hr = pElemParent->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE);
            if (!FAILED(hr))
            {
                if (pbstr)
                    hr = pAE->get_href(pbstr);
                pAE->Release();
            }            
            pElemParent->Release();
        }
        pTxtRange->Release();
    }

    return hr;
}





//+---------------------------------------------------------------
//
//  Member:     CBody::AddToWab
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::AddToWab()
{
    BSTR                    bstr=0,
                            bstrOut;
    HRESULT                 hr=E_FAIL;
    WCHAR                   *pszW;
    VARIANTARG              va;
    IHTMLAnchorElement      *pAE;

    TraceCall("CBody::AddToWab");

    if (!m_pParentCmdTarget)
        return TraceResult(E_UNEXPECTED);

    if (m_pDispContext &&
        m_pDispContext->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
    {
        pAE->get_href(&bstr);
        pAE->Release();
    }

    if (bstr)
    {
        // double check this is a mailto:
        if (StrCmpNIW(bstr, c_szMailToW, ARRAYSIZE(c_szMailToW)-sizeof(WCHAR))==0)
        {
            pszW = bstr + (ARRAYSIZE(c_szMailToW)-1);
            
            bstrOut = SysAllocString(pszW);
            if (bstrOut)
            {
                va.vt = VT_BSTR;
                va.bstrVal = bstrOut;
                hr = m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_ADD_TO_ADDRESSBOOK, OLECMDEXECOPT_DODEFAULT, &va, NULL);
                SysFreeString(bstrOut);
            }
            else
                hr = TraceResult(E_OUTOFMEMORY);
        }
        SysFreeString(bstr);
    }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CBody::AddToFavorites
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::AddToFavorites()
{
    SAFEARRAY              *psa=NULL;
    SAFEARRAYBOUND          rgsaBound[1];
    BSTR                    bstrURL=NULL,
                            bstrDescr=NULL;
    HRESULT                 hr=E_FAIL;
    VARIANTARG              va;
    IHTMLAnchorElement     *pAE=NULL;
    IHTMLElement           *pE=NULL;
    LONG                    l;

    TraceCall("CBody::AddToFavorites");

    if (!m_pParentCmdTarget)
        return TraceResult(E_UNEXPECTED);

    if (m_pDispContext &&
        m_pDispContext->QueryInterface(IID_IHTMLElement, (LPVOID *)&pE)==S_OK)
    {
        pE->get_innerText(&bstrDescr);
        pE->Release();
    }

    if (m_pDispContext &&
        m_pDispContext->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
    {
        pAE->get_href(&bstrURL);
        pAE->Release();
    }

    if (bstrURL)
    {
        if(!bstrDescr)
            bstrDescr=SysAllocString(bstrURL);

        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = 2;
    
        IF_NULLEXIT(psa = SafeArrayCreate(VT_BSTR, 1, rgsaBound));
    
        va.vt = VT_ARRAY|VT_BSTR;
        va.parray = psa;
    
        l=0;
        IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, bstrDescr));

        l=1;
        IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, bstrURL));

        IF_FAILEXIT(hr = m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_ADD_TO_FAVORITES, OLECMDEXECOPT_DODEFAULT, &va, NULL));
    }

exit:
    SysFreeString(bstrDescr);
    SysFreeString(bstrURL);
    if(psa) 
        SafeArrayDestroy(psa);
    
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CBody::GetWebPageOptions
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetWebPageOptions(WEBPAGEOPTIONS *pOptions, BOOL *pfIncludeMsg)
{
    VARIANTARG  va;
    DWORD       dwFlags;

    TraceCall("GetWebPageOptions");

    // set defaults for IN params
    pOptions->cbSize = sizeof(WEBPAGEOPTIONS);
    pOptions->dwFlags = WPF_HTML|WPF_AUTOINLINE;
    pOptions->dwDelay = 5000;
    pOptions->wchQuote = NULL;

    if (pfIncludeMsg)
        *pfIncludeMsg=TRUE;

    // callback to Host for real options
    if (m_pParentCmdTarget)
    {
        if (GetHostFlags(&dwFlags)==S_OK)
        {
            BOOL fSecurityForcesHTMLOff = FALSE;
            VARIANTARG va = {0};

            va.vt = VT_BOOL;
            va.boolVal = VARIANT_FALSE;
            // read msgs all have the autoinline flag set so we use that along with the option setting to determine
            // if html should be disabled
            if (SUCCEEDED(m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_IS_READ_IN_TEXT_ONLY, OLECMDEXECOPT_DODEFAULT, NULL, &va)))
                fSecurityForcesHTMLOff = (VARIANT_TRUE == va.boolVal) && (dwFlags & MEO_FLAGS_AUTOINLINE);

            // convert MEHOST_* flags to WPF_*
            pOptions->dwFlags = 0;

            if (!fSecurityForcesHTMLOff && (dwFlags & MEO_FLAGS_HTML))
                pOptions->dwFlags |= WPF_HTML;

            if (dwFlags & MEO_FLAGS_AUTOINLINE)
                pOptions->dwFlags |= WPF_AUTOINLINE;

            if (dwFlags & MEO_FLAGS_SLIDESHOW)
                pOptions->dwFlags |= WPF_SLIDESHOW;

            if ((!(dwFlags & MEO_FLAGS_INCLUDEMSG)) && pfIncludeMsg)
                *pfIncludeMsg = FALSE;
        }

        if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_QUOTE_CHAR, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
            pOptions->wchQuote = (WCHAR)va.lVal;
        
        if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SLIDESHOW_DELAY, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
            pOptions->dwDelay = (WCHAR)va.lVal;
        
    }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ViewSource
//
//  Synopsis:   
//
//---------------------------------------------------------------

HRESULT CBody::ViewSource(BOOL fMessage)
{
    TraceCall("CBody::ViewSource");

    if (fMessage)
        MimeEditViewSource(m_hwnd, m_pMsg);
    else
    {
        if (m_pCmdTarget)
            m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_VIEWSOURCE, OLECMDEXECOPT_DODEFAULT, NULL, NULL); 
    }
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     OnUIDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnUIDeactivate(BOOL fUndoable)
{
    HRESULT     hr;

    TraceCall("CBody::OnUIDeactivate");
    
    hr = CDocHost::OnUIDeactivate(fUndoable);;

    if (m_pParentInPlaceSite)
        m_pParentInPlaceSite->OnUIDeactivate(fUndoable);

    if (m_pParentInPlaceFrame)
        m_pParentInPlaceFrame->SetActiveObject(NULL, NULL);

    if (m_pFmtBar)
        m_pFmtBar->Update();

    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     OnUIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnUIActivate()
{
    HRESULT hr;

    TraceCall("CBody::OnUIActivate");

    hr = CDocHost::OnUIActivate();

    if (m_pParentInPlaceSite)
        m_pParentInPlaceSite->OnUIActivate();
    
    if (m_pParentInPlaceFrame)
        m_pParentInPlaceFrame->SetActiveObject(m_pDocActiveObj, NULL);

    if (m_pFmtBar)
        m_pFmtBar->Update();

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SetStatusText
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SetStatusText(LPCOLESTR pszW)
{
    LPWSTR  pszTempW;

    TraceCall("CDocHost::SetStatusText");

    // bug #2137. This is a nasty hack. If we get a statusbar update
    // with mid://xxx#bookmark then we tear off the mid://xxx portion
    // to show the name more cleanly. 
    // the right fix is for trident to add handling for displaying urls to
    // call IInternetInfo::ParseUrl with PARSE_URL_FRIENDLY

    if (pszW && 
        StrCmpNIW(pszW, L"mid:", 4) == 0 && 
        (pszTempW = StrPBrkW(pszW, L"#")))
        pszW = pszTempW;

    if (m_pParentInPlaceFrame)
        m_pParentInPlaceFrame->SetStatusText(pszW);

    return CDocHost::SetStatusText(pszW);;
}


//+---------------------------------------------------------------
//
//  Member:     DoRot13
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::DoRot13()
{
    IHTMLTxtRange           *pTxtRange;
    HRESULT                 hr;
    BSTR                    bstr;
    LPWSTR                  lpszW;
    ULONG                   cb;

    hr = CreateRange(&pTxtRange);
    if (!FAILED(hr))
    {
        hr=pTxtRange->get_text(&bstr);
        if (!FAILED(hr))
        {
            cb=SysStringLen(bstr);
            
            while(cb--)
            {
                register WCHAR chW;
                
                chW=bstr[cb];
                if (chW >= 'a' && chW <= 'z')
                    bstr[cb] = 'a' + (((chW - 'a') + 13) % 26);
                else if (chW >= 'A' && chW <= 'Z')
                    bstr[cb] = 'A' + (((chW - 'A') + 13) % 26);
                
            }
            
            hr=pTxtRange->put_text(bstr);
            SysFreeString(bstr);
        }
        pTxtRange->Release();
    }
    return hr;
}


void CBody::OutputHeaderText(HDC hdc, LPWSTR psz, int *pcxPos, int cyPos, int cxMax, ULONG uFlags)
{
    static int yLabel = 0;
    int     cch,
            cyOffset = 0;
    SIZE    size;
    RECT    rc;
    WCHAR   szRes[CCHMAX_STRINGRES];
    HFONT   hFont;

    if (IS_INTRESOURCE(psz))
    {
        LoadStringWrapW(g_hLocRes, PtrToUlong(psz), szRes, ARRAYSIZE(szRes));
        psz = szRes;        
    }
    
    cch = lstrlenW(psz);
    
    if (m_pFontCache &&
        m_pFontCache->GetFont((uFlags & HDRTXT_BOLD)?FNT_SYS_ICON_BOLD:FNT_SYS_ICON, (uFlags & HDRTXT_SYSTEMFONT )? NULL : m_hCharset, &hFont)==S_OK)
        SelectObject(hdc, hFont);
    
    GetTextExtentPoint32AthW(hdc, psz, cch, &size, DT_NOPREFIX);

    // bobn: Raid 84705  We need to make sure that the fields line up
    if(yLabel && !(uFlags & (HDRTXT_BOLD|HDRTXT_SYSTEMFONT)))
    {
        cyOffset = yLabel - size.cy;
    }

    rc.top    = cyPos + ((cyOffset < (-2))? (-2) : cyOffset); // bobn: Raid 84705  We need to make sure that the fields line up
    rc.left   = *pcxPos;
    rc.right  = min(*pcxPos + size.cx + 1, cxMax);
    rc.bottom = cyPos + size.cy + cyOffset; // bobn: Raid 84705  We need to make sure that the fields line up
    DrawTextExWrapW(hdc, psz, cch, &rc, DT_NOPREFIX | DT_WORD_ELLIPSIS, NULL);
    *pcxPos=rc.right;

    // bobn: Raid 84705  We need to make sure that the fields line up
    if (uFlags & (HDRTXT_BOLD|HDRTXT_SYSTEMFONT))
    {
        yLabel = size.cy;
    }
}

/* 
 * control strings:
 *   &s - Subject:      &c - Cc:
 *   &t - To:           &d - Date:
 *   &f - From:
 *
 */
HRESULT CBody::OnPaint()
{
    HDC             hdc,
                    hdcMem;
    PAINTSTRUCT     ps;
    RECT            rc,
                    rcBtnBar;
    int             idc;
    SIZE            sze;
    HBITMAP         hbmMem;
    HGDIOBJ         hbmOld;
    int             cx,
                    cxLabels,
                    cy,
                    cxPos,
                    cyPos,
                    cyLine;
    int             iBackColor,
                    iTextColor;
    LPSTR           pszFmt;
    LPSTR           psz,
                    pszLast;
    HFONT           hFont;

    if (m_uHdrStyle == MESTYLE_PREVIEW || 
        m_uHdrStyle == MESTYLE_MINIHEADER)
    {
        hdc=BeginPaint(m_hwnd, &ps);
        
        hdcMem = CreateCompatibleDC(hdc);
        idc=SaveDC(hdcMem);
        
        // select font so cyLine is accurate
        if (m_pFontCache &&
            m_pFontCache->GetFont(FNT_SYS_ICON_BOLD, NULL, &hFont)==S_OK)
            SelectObject(hdcMem, hFont);
        
        GetClientRect(m_hwnd, &rc);
        cx = rc.right;
        cxLabels =  cx - (GetSystemMetrics(SM_CXBORDER)*2);      // account for client-edge
        cy = lGetClientHeight();
        
        if (m_cVisibleBtns)
        {   
            // trim cx if buttons are shown
            Assert(IsWindow(m_hwndBtnBar));
            GetClientRect(m_hwndBtnBar, &rcBtnBar);
            cxLabels -= rcBtnBar.right;
        }
        
        hbmMem = CreateCompatibleBitmap(hdc, cx, cy);
        hbmOld = SelectObject(hdcMem, (HGDIOBJ)hbmMem);
        
        if (m_fFocus)
        {
            iBackColor = COLOR_HEADERFOCUS;
            iTextColor = COLOR_HEADERTXTFOCUS;
        }
        else
        {
            iBackColor = COLOR_HEADER;
            iTextColor = COLOR_HEADERTXT;
        }
        
        FillRect(hdcMem, &rc, GetSysColorBrush(iBackColor));
        
        cxPos = CX_LABEL_PADDING;
        cyPos = CY_LINE_PADDING;
        
        SetBkMode(hdcMem, OPAQUE);
        SetBkColor(hdcMem, GetSysColor(iBackColor));
        SetTextColor(hdcMem, GetSysColor (iTextColor));
        cyLine = lGetLineHeight(hdcMem);
        
        if (m_uHdrStyle == MESTYLE_PREVIEW)
        {
            // if we want the full preview header, let's render the text
            pszFmt = m_pszLayout;
            pszLast = pszFmt;
            
            while (*pszFmt)
            {
                if (*pszFmt == '&')
                {
                    // control character
                    pszFmt++;
                    switch (*pszFmt)
                    {
                    case 'f':
                    case 'F':
                        // from field
                        if (*pszFmt=='f' || (m_pszFrom&& *m_pszFrom))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsFromField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszFrom)
                            OutputHeaderText(hdcMem, m_pszFrom, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 's':
                    case 'S':
                        if (*pszFmt=='s' || (m_pszSubject && *m_pszSubject))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsSubjectField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszSubject)
                            OutputHeaderText(hdcMem, m_pszSubject, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 'c':
                    case 'C':
                        if (*pszFmt=='c' || (m_pszCc && *m_pszCc))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsCcField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszCc)
                            OutputHeaderText(hdcMem, m_pszCc, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 't':
                    case 'T':
                        if (*pszFmt=='t' || (m_pszTo && *m_pszTo))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsToField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszTo)
                            OutputHeaderText(hdcMem, m_pszTo, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 'b':
                        // &b is a line break
                        cxPos = CX_LABEL_PADDING;
                        cyPos += cyLine + 2; // bobn: Arbitrary pad so that we don't clip to the line below
                        break;
                        
                    }
                }
                
                pszFmt++;
            }
            
            if (!m_fFocus)
            {
                // if we don't have focus, paint a 3d edge
                rc.top = 0;
                rc.left = 0;
                rc.right = cx;
                rc.bottom = m_cyPreview;
                DrawEdge(hdcMem, &rc, BDR_RAISEDINNER, BF_RECT);
            }            
        }
        
        BitBlt(hdc, 0, 0, cx, cy, hdcMem, 0, 0, SRCCOPY);
        
        if (!m_lpOleObj)
        {
            HBRUSH hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
            GetClientRect(m_hwnd, &rc);
            GetDocObjSize(&rc);
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
            SelectBrush(hdc, hBrush);
        }
        
        SelectObject(hdcMem, hbmOld);
        RestoreDC(hdcMem, idc);
        
        DeleteObject(hbmMem);
        DeleteDC(hdcMem);
        EndPaint(m_hwnd, &ps);
        return S_OK;
    }
    else
        if (!m_lpOleObj)
        {
            HDC         hdc;
            PAINTSTRUCT ps;
            RECT        rc;
            HBRUSH      hBrush;
            
            GetClientRect(m_hwnd, &rc);
            GetDocObjSize(&rc);
            hdc = BeginPaint(m_hwnd, &ps);
            if (m_dwStyle & MEBF_INNERCLIENTEDGE)
                DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT|BF_ADJUST);
            hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
            PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, PATCOPY);
            SelectBrush(hdc, hBrush);
            EndPaint(m_hwnd, &ps);
            return S_OK;
        }

    return S_FALSE;
}


LONG CBody::lGetLineHeight(HDC hdc)
{
    HFONT       hfontOld=0,
                hFont;
    TEXTMETRIC  tm;

    if (hdc)
        GetTextMetrics(hdc, &tm);
    else
    {
        // Calculate the height of the line: based on the height of the bold font
        hdc=GetDC(NULL);
        
        if (m_pFontCache &&
            m_pFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
            hfontOld = (HFONT)SelectObject(hdc, hFont);
        
        GetTextMetrics(hdc, &tm);
        
        // Set things back
        if (hfontOld)
            SelectObject(hdc, hfontOld);
        ReleaseDC(NULL, hdc);
    }
    
    return tm.tmHeight;
}

HRESULT CBody::RecalcPreivewHeight(HDC hdc)
{
    ULONG       cLines=1;
    LPSTR       psz;
    RECT        rc;

    // default
    if (!m_pszLayout)
        m_pszLayout = PszDup("&f&t&C&b&s");

    // cruise thro' the preview layout string and figure out how many line high we are and the
    // physical pixel height of those lines in the current font

    if (psz = m_pszLayout)
        while (*psz)
        {
            if (*psz == '&' && *(psz+1) == 'b')
                cLines++;
            psz++;
        }

    m_cyPreview = cLines * lGetLineHeight(hdc);
    m_cyPreview+=2*CY_LINE_PADDING;    // padding
    
    if (m_hwndBtnBar)
    {
        // if the button bar is show, account for it.
        GetClientRect(m_hwndBtnBar, &rc);
        rc.bottom+= (2*GetSystemMetrics(SM_CYBORDER));  // factor client edge
        m_cyPreview = max (m_cyPreview, (ULONG)rc.bottom);
    }
    
    
    return S_OK;
}


HRESULT CBody::GetDocObjSize(LPRECT prc)
{
    if(!prc)
        return E_INVALIDARG;

    if (m_uSrcView == MEST_EDIT)
        prc->top+=lGetClientHeight();
        
    if (m_fSrcTabs)
        prc->top+=4;

    if (m_fSrcTabs)
    {
        RECT rc={0};
        
        Assert (m_hwndTab);
        if (TabCtrl_GetItemRect(m_hwndTab, 0, &rc))
            prc->bottom -= (rc.bottom - rc.top) + 2;
        
        InflateRect(prc, -4, -4);
    }

    // make sure we don't make a nonsense rect.
    if(prc->bottom<prc->top)
        prc->bottom=prc->top;

    return NOERROR;
}

HRESULT CBody::UpdatePreviewLabels()
{
    HRESULT hr = S_OK;

    SafeMemFree(m_pszSubject);
    SafeMemFree(m_pszTo);
    SafeMemFree(m_pszCc);
    SafeMemFree(m_pszFrom);

    if (m_pMsgW)
    {
        m_pMsgW->GetAddressFormatW(IAT_CC, AFT_DISPLAY_FRIENDLY, &m_pszCc);

        m_pMsgW->GetAddressFormatW(IAT_FROM, AFT_DISPLAY_FRIENDLY, &m_pszFrom);

        if (FAILED(m_pMsgW->GetAddressFormatW(IAT_TO, AFT_DISPLAY_FRIENDLY, &m_pszTo)))
            MimeOleGetBodyPropW(m_pMsgW, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &m_pszTo);

        MimeOleGetBodyPropW(m_pMsgW, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &m_pszSubject);
    }

    InvalidateRect(m_hwnd, NULL, TRUE);
    return hr;
}




HRESULT CBody::OnFocus(BOOL fGotFocus)
{
    if (m_uHdrStyle == MESTYLE_PREVIEW || m_uHdrStyle == MESTYLE_MINIHEADER)
    {
        InvalidateRect(m_hwnd, NULL, TRUE);
        if (m_hwndBtnBar)
            InvalidateRect(m_hwndBtnBar, NULL, TRUE);
    }

    return CDocHost::OnFocus(fGotFocus);
}

HRESULT CBody::OnEraseBkgnd(HDC hdc)
{
    RECT rc;

    GetClientRect(m_hwnd, &rc);
    rc.bottom = lGetClientHeight();
    FillRect(hdc, &rc, GetSysColorBrush(m_fFocus?COLOR_HEADERFOCUS:COLOR_HEADER));
    return S_OK;
}


HRESULT CBody::SetStyle(ULONG uStyle)
{
    if (uStyle == m_uHdrStyle)
        return S_OK;

    m_uHdrStyle = uStyle;
    
    ShowFormatBar(uStyle == MESTYLE_FORMATBAR);
    ShowPreview(uStyle == MESTYLE_PREVIEW);
    Resize();
    return S_OK;
}



LONG CBody::lGetClientHeight()
{
    HWND    hwndFmtbar;
    RECT    rc;

    // even if we don't have a big header, leave a thin
    // line for users to click
    switch (m_uHdrStyle)
        {
        case MESTYLE_PREVIEW:
            return m_cyPreview;
        
        case MESTYLE_MINIHEADER:
            return SMALLHEADERHEIGHT;
        
        case MESTYLE_FORMATBAR:
            
            hwndFmtbar = GetDlgItem(m_hwnd, idcFmtBar);

            if (hwndFmtbar)
            {
                GetClientRect(hwndFmtbar, &rc);
                return rc.bottom-rc.top;
            }
            break;
        }
    return 0;
}


HRESULT CBody::Resize()
{
    RECT rc;

    GetClientRect(m_hwnd, &rc);
    WMSize(rc.right-rc.left, rc.bottom-rc.top);
    InvalidateRect(m_hwnd, NULL, TRUE);
    return S_OK;
}



HRESULT CBody::SetCharset(HCHARSET hCharset)
{
    HRESULT             hr=S_OK;
    BSTR                bstr;
    TCHAR               rgchCset[CCHMAX_CSET_NAME];

    if (hCharset == NULL)
        return E_INVALIDARG;

    if (m_hCharset == hCharset)
        return S_OK;

    if (!m_pDoc)
        return E_UNEXPECTED;

    if (m_fDesignMode)
    {
        // if we're in edit-mode, then we can't reload the document, so we use the trident object
        // model to tell it the charset we want...
        hr = HrGetMetaTagName(hCharset, rgchCset);
        if (!FAILED(hr))
        {
            hr = HrLPSZToBSTR(rgchCset, &bstr);
            if (!FAILED(hr))
            {
                // this will cause trident to reload with a new meta tag, if the user has changed the charset
                // on the view|language menu
                hr=m_pDoc->put_charset(bstr);
                if (!FAILED(hr))
                {
                    // all went well - switch the language
                    m_hCharset = hCharset;
                }
                SysFreeString(bstr);
            }
        }
        else
        {
            // if lookup in mime database fails, return a good error
            hr = MIMEEDIT_E_CHARSETNOTFOUND;
        }
    }
    else
    {
        // if we're in browse mode, let the base class take care of reloading the document
        if (m_pMsg)
        {
            hr = m_pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
            if (!FAILED(hr))
            {
                IMimeMessage *pMsg=m_pMsg;
                pMsg->AddRef();
                hr = Load(pMsg);
                pMsg->Release();
            }
        }
    }
    
    return hr;
}


HRESULT CBody::PrivateEnableModeless(BOOL fEnable)
{
    if (m_pInPlaceActiveObj)
        m_pInPlaceActiveObj->EnableModeless(fEnable);
    
    return S_OK;
}





HRESULT CBody::ClearDirtyFlag()
{
     return HrSetDirtyFlagImpl(m_pDoc, FALSE);
}



DWORD CBody::DwChooseProperties()
{
    DWORD   dwRet=0;

    // if we are on an image
    if(m_fOnImage)
    {
        m_fOnImage = 0;
        return IDM_IMAGE;
    }
    
    // if we are on an anchor
    if (GetSelectedAnchor(NULL)==S_OK)
        return IDM_HYPERLINK;

    return 0;
}

HRESULT CBody::ShowFormatBar(BOOL fOn)
{
    Assert (m_pFmtBar); // created in Init
        
    if (fOn)
        return m_pFmtBar->Show();
    else
        return m_pFmtBar->Hide();
}


void CBody::WMSize(int cxBody, int cyBody)
{
    RECT    rc,
            rcBar;

    switch (m_uHdrStyle)
        {
        case MESTYLE_FORMATBAR:
            if (m_hwnd)
            {
                HWND    hwndFmtbar = GetDlgItem(m_hwnd, idcFmtBar);
                
                if (hwndFmtbar)
                {
                    // if the format bar is on adjust the window rect accordingly
                    GetClientRect(hwndFmtbar, &rc);
                    SetWindowPos(hwndFmtbar, NULL, m_fSrcTabs?4:0, m_fSrcTabs?4:0, cxBody-(m_fSrcTabs?8:0), rc.bottom-rc.top, SWP_NOACTIVATE|SWP_NOZORDER);
                }
            }
            break;
        
        case MESTYLE_PREVIEW:
            // center toolbar in the preview header and right-align it (note: account for the client edge we paint)
            if (m_hwndBtnBar)
            {
                GetClientRect(m_hwndBtnBar, &rcBar);
                SetWindowPos(m_hwndBtnBar, NULL, cxBody - rcBar.right - (GetSystemMetrics(SM_CXBORDER)*2), (m_cyPreview - rcBar.bottom)/2, 0, 0,SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER|SWP_NOSIZE);
            }
            break;
        }

    if (m_fSrcTabs)
    {
        RECT rc;
        
        Assert (m_hwndTab);
        GetClientRect(m_hwnd, &rc);
        GetDocObjSize(&rc);
        
        SetWindowPos(m_hwndTab, HWND_BOTTOM, 0, 0, cxBody, cyBody, SWP_NOACTIVATE);
        if (m_pSrcView)
            m_pSrcView->SetRect(&rc);
    }
    CDocHost::WMSize(cxBody, cyBody);
}

HRESULT CBody::InsertTextAtCaret(BSTR bstr, BOOL fHtml, BOOL fMoveCaretToEnd)
{
    IHTMLTxtRange           *pTxtRange=0;
    HRESULT                 hr=E_FAIL;

    if (!FAILED(hr = GetSelection(&pTxtRange)))
    {
        if(fHtml)
            hr=pTxtRange->pasteHTML(bstr);
        else
            hr=pTxtRange->put_text(bstr);
        
        pTxtRange->collapse( fMoveCaretToEnd ? VARIANT_FALSE : VARIANT_TRUE);
        pTxtRange->select();
        pTxtRange->Release();
    }
    return hr;
}


HRESULT CBody::UpdateCommands()
{
    IHTMLTxtRange           *pTxtRange=0;

    if (m_pFmtBar)
        m_pFmtBar->Update();

    if (m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(NULL, OLECMDID_UPDATECOMMANDS, 0, NULL, NULL);

    return S_OK;
}


LRESULT CBody::WMNotify(WPARAM wParam, NMHDR* pnmhdr)
{
    HFONT   hFont;
    LRESULT lRet;

    if (m_pSrcView &&
        m_pSrcView->OnWMNotify(wParam, pnmhdr, &lRet)==S_OK)
        return lRet;

    switch (wParam)
    {
        case idcTabs:
            switch (pnmhdr->code)
            {
                case TCN_SELCHANGE:
                    ShowSourceView(TabCtrl_GetCurSel(m_hwndTab));
                    break;

                case TCN_SELCHANGING:
                    if (m_fReloadingSrc)
                    {
                        // while loading, prevent switching of tabs
                        MessageBeep(MB_ICONSTOP);
                        return TRUE;
                    }
                    break;
            }
            break;
        
        case idcFmtBar:
            switch (pnmhdr->code)
            {
            case FBN_GETMENUFONT:
                hFont = 0;
                if (m_pFontCache)
                    m_pFontCache->GetFont(FNT_SYS_MENU, NULL, &hFont);
            
                return (LPARAM)hFont;
            
            case FBN_BODYSETFOCUS:
                UIActivate(FALSE);
                UIActivate(TRUE);
                return 0;
            
            case FBN_BODYHASFOCUS:
                return m_fFocus;
            }
            break;
        
        case idcBtnBar:
            switch (pnmhdr->code)
            {
            case NM_RCLICK:
                if (((NMCLICK *)pnmhdr)->dwItemSpec == idmPanePaperclip)
                    ShowAttachMenu(TRUE);
                break;

            case TBN_DROPDOWN:
                if (((TBNOTIFY *)pnmhdr)->iItem == idmPanePaperclip)
                    ShowAttachMenu(FALSE);
                break;
            }
            break;
    }
    return 0;
}



HRESULT CBody::SetHostComposeFont()
{
    VARIANTARG  va;
    
    va.bstrVal = NULL;

    if (m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_COMPOSE_FONT, OLECMDEXECOPT_DODEFAULT, NULL, &va);

    SetComposeFont(va.bstrVal);
    SysFreeString(va.bstrVal);
    return S_OK;
}

HRESULT CBody::SetComposeFont(BSTR bstr)
{
    VARIANTARG  va;

    va.vt = VT_BOOL;
    va.boolVal = bstr?VARIANT_TRUE:VARIANT_FALSE;

    if (m_pCmdTarget)
    {
        // turn OFF HTML-Edit mode if bstr==NULL
        m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_HTMLEDITMODE, OLECMDEXECOPT_DODEFAULT, &va, NULL);
        if (bstr)
        {
            va.vt = VT_BSTR;
            va.bstrVal = bstr;
            m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_COMPOSESETTINGS, OLECMDEXECOPT_DODEFAULT, &va, NULL);
        }
    }
    return S_OK;
}


HRESULT CBody::ClearUndoStack()
{
    IOleUndoManager     *pUndoManager;
    IServiceProvider    *pSP;
    HRESULT         hr;

    if (!m_lpOleObj)
        return E_FAIL;

    if (!FAILED(hr=m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)))
    {
        if (!FAILED(hr = pSP->QueryService(SID_SOleUndoManager, IID_IOleUndoManager, (LPVOID *)&pUndoManager)))
        {
            hr = pUndoManager->DiscardFrom(NULL);
            pUndoManager->Release();
        }
        pSP->Release();
    }
    return hr;
}

HRESULT CBody::DowngradeToPlainText(BOOL fForceFixedFont)
{
    IHTMLElement    *pElem=0;
    IHTMLStyle      *pStyle=0;
    IHTMLTxtRange   *pTxtRange;

    BSTR            bstr=0;

    m_pDoc->get_body(&pElem);
    if (pElem)
    {
        pElem->get_innerText(&bstr);    // might be NULL if only images
        pElem->put_innerText(bstr);
        HrRemoveStyleSheets(m_pDoc);
        HrRemoveBackground(m_pDoc);
        SetWindowBgColor(TRUE);         // force back to default color
        SysFreeString(bstr);
        
        if (fForceFixedFont)
        {
            // add <STYLE: font-family: monospace> to the body tag
            pElem->get_style(&pStyle);
            if (pStyle)
            {
                pStyle->put_fontFamily((BSTR)c_bstr_MonoSpace);
                pStyle->Release();
            }
        }        
        
        if (m_fDesignMode)
        {
            // set caret at start
            if (!FAILED(CreateRange(&pTxtRange)))
            {
                pTxtRange->collapse(VARIANT_TRUE);
                pTxtRange->select();
                pTxtRange->Release();
            }
        }

        pElem->Release();
    }

    ClearUndoStack();
    return S_OK;
}

// Returns MIME_S_CHARSET_CONFLICT if can't convert
HRESULT CBody::SafeToEncodeText(ULONG ulCodePage)
{
    HRESULT         hr = S_OK;
    IHTMLElement   *pElem = NULL;
    BSTR            bstr = NULL;
    DWORD           dwTemp = 0;
    INT             cbIn;

    m_pDoc->get_body(&pElem);
    if (pElem)
    {
        pElem->get_innerText(&bstr);
        if (NULL != bstr)
        {
            cbIn = SysStringByteLen(bstr);

            IF_FAILEXIT(hr = ConvertINetString(&dwTemp, CP_UNICODE, ulCodePage, (LPCSTR)bstr, &cbIn, NULL, NULL));
            if (S_FALSE == hr)
                hr = MIME_S_CHARSET_CONFLICT;
        }
    }

exit:
    ReleaseObj(pElem);
    SysFreeString(bstr);
    return hr;
}

HRESULT CBody::SetDocumentText(BSTR bstr)
{
    IHTMLTxtRange           *pTxtRange;
    HRESULT                 hr;

    if (!m_lpOleObj)
        return CO_E_NOT_SUPPORTED;

    hr = CreateRange(&pTxtRange);
    if (!FAILED(hr))
    {
        hr=pTxtRange->pasteHTML(bstr);
        if (!FAILED(hr))
        {
            ClearDirtyFlag();
            // we not empty anymore
            m_fEmpty=FALSE;
        }
        pTxtRange->Release();
    }
    return hr;
}



HRESULT CBody::FormatFont()
{
    return m_pCmdTarget?m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FONT, OLECMDEXECOPT_DODEFAULT,  NULL, NULL):E_FAIL;
}



HRESULT CBody::PasteReplyHeader()
{
    HRESULT             hr=S_OK;
    ULONG               uHdrStyle=0;
    LPSTREAM            pstm;
    DWORD               dwFlags=0,
                        dwHdr;
    IHTMLTxtRange       *pRange;
    IOleCommandTarget   *pCmdTarget;
    VARIANTARG          va;

    if (m_pParentCmdTarget)
    {
        if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_HEADER_TYPE, 0, NULL, &va)==S_OK)
            uHdrStyle = va.lVal;
        GetHostFlags(&dwFlags);    
    }
    
    if ((uHdrStyle != MEHEADER_NONE) && 
        (dwFlags & MEO_FLAGS_INCLUDEMSG))
    {
        // check to see if the rootstream inserted the auto reply header placeholder
        // if so, replace it
        Assert ((uHdrStyle & MEHEADER_NEWS) || (uHdrStyle & MEHEADER_MAIL));
        
        dwHdr = HDR_PADDING|(dwFlags&MEO_FLAGS_HTML?HDR_HTML:HDR_PLAIN);
        
        if (uHdrStyle & MEHEADER_NEWS)
            dwHdr |= HDR_NEWSSTYLE;
        
        if (uHdrStyle & MEHEADER_FORCE_ENGLISH)
            dwHdr |= HDR_HARDCODED;
        
        pstm = NULL;
        if (SUCCEEDED(hr=GetHeaderTable(m_pMsgW, NULL, dwHdr, &pstm)))
        {
            BSTR    bstr;
            
            if (SUCCEEDED(hr = HrIStreamWToBSTR(pstm, &bstr)))
            {
                // paste reply-headers at the top of the message
                InsertBodyText(bstr, IBTF_URLHIGHLIGHT);
                SysFreeString(bstr);
            }
            pstm->Release();
        }
        
        if (dwFlags & MEO_FLAGS_BLOCKQUOTE)
        {
            // block quote the text
            if (SUCCEEDED(CreateRange(&pRange)))
            {
                if (SUCCEEDED(pRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)))
                {
                    if (pCmdTarget->Exec(&CMDSETID_Forms3, IDM_INDENT, NULL, NULL, NULL)==S_OK)
                    {
                        if (m_pParentCmdTarget &&
                            m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_REPLY_TICK_COLOR, 0, 0, &va)==S_OK)
                            FormatBlockQuote((COLORREF)va.lVal); 
                    }
                    pCmdTarget->Release();
                }
                pRange->Release();
            }
        }        
        
        
        if (dwFlags & MEO_FLAGS_DONTSPELLCHECKQUOTED)
            CreateRange(&m_pRangeIgnoreSpell);
        
    }
    return hr;
}

HRESULT CBody::InsertBodyText(BSTR bstrPaste, DWORD dwFlags)
{
    IHTMLElement        *pElem;
    IHTMLBodyElement    *pBodyElem;
    HRESULT             hr=E_FAIL;

    if (!FAILED(GetBodyElement(&pBodyElem)))
    {
        if (!FAILED(pBodyElem->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem)))
        {
            hr = pElem->insertAdjacentHTML((BSTR)(dwFlags & IBTF_INSERTATEND ?c_bstr_BeforeEnd:c_bstr_AfterBegin), bstrPaste);
            
            IHTMLTxtRange       *pRange;
            LONG                cch;
            
            if (!FAILED(hr) && (dwFlags & IBTF_URLHIGHLIGHT))
            {
                if (CreateRangeFromElement(pElem, &pRange)==S_OK)
                {
                    if (!FAILED(pRange->collapse(VARIANT_TRUE)))
                    {
                        if (!FAILED(pRange->moveEnd((BSTR)c_bstr_Character, (LONG)SysStringLen(bstrPaste), (LPLONG)&cch)) && cch!=0)
                            UrlHighlight(pRange);
                    }
                    pRange->Release();
                }
            }
            
            pElem->Release();
        }
        pBodyElem->Release();
    }
    return hr;
}


HRESULT CBody::FormatBlockQuote(COLORREF crTextColor)
{
    HRESULT hr;
    IHTMLElementCollection  *pCollect;
    IHTMLStyle              *pStyle=0;
    IHTMLElement            *pElem;
    ULONG                   cItems;
    TCHAR                   rgch[CCHMAX_STRINGRES];
    BSTR                    bstr;
    VARIANT                 v;

    if (!FAILED(HrGetCollectionOf(m_pDoc, (BSTR)c_bstr_BLOCKQUOTE, &pCollect)))
    {
        cItems = (int)UlGetCollectionCount(pCollect);
        if (cItems > 0 &&
            !FAILED(HrGetCollectionItem(pCollect, 0, IID_IHTMLElement, (LPVOID *)&pElem)))
        {
            pElem->get_style(&pStyle);
            if (pStyle)
            {
                // set the style on the elemen
                // .replyTick { border-left:solid ; border-left-width: 4;
                // border-color: #0000ff; padding-left: 5;
                // margin-left: 5}
                // 5/19/98: fix margin on nesting:
                // padding-right: 0, margin-right:0 
                wsprintf(rgch, "solid 2 #%02x%02x%02x", GetRValue(crTextColor), GetGValue(crTextColor), GetBValue(crTextColor));
                
                if (HrLPSZToBSTR(rgch, &bstr)==S_OK)
                {
                    pStyle->put_borderLeft(bstr);
                    SysFreeString(bstr);
                }
                
                // set the padding and the margin
                v.vt = VT_I4;
                v.lVal = 5;
                pStyle->put_paddingLeft(v);
                pStyle->put_marginLeft(v);
                v.lVal = 0;
                pStyle->put_paddingRight(v);
                pStyle->put_marginRight(v);
                pStyle->Release();
            }
            // first dude in the collection should be the one at the root of the tree
            pElem->Release();
        }
        pCollect->Release();
    }
    return S_OK;
}


HRESULT CBody::GetAutoText(BSTR *pbstr, BOOL *pfTop)
{
    HRESULT         hr;
    BOOL            fSig;
    ULONG           uSigOpt;
    TCHAR           rgchAutoText[4096]; // buffer big enough to build autotext into
    VARIANTARG      va;

    if (!m_pParentCmdTarget)
        return E_FAIL;
    
    if (pfTop)
        *pfTop = TRUE;
    
    *rgchAutoText = 0;
    
    va.vt = VT_I4;
    va.lVal = MESIG_AUTO;        
    fSig = (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_ENABLED, 0, &va, NULL)==S_OK);
    if (fSig &&
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_OPTIONS, 0, NULL, &va)==S_OK)
    {
        Assert(va.vt==VT_I4);
        uSigOpt = va.lVal;
    }
    
    /*
    let's build a BSTR of the HTML we want to insert.
    
      <DIV>
      <SPAN id=\"__CaretPos__\"><BR></SPAN>
      </DIV>
      <DIV>
      <SPAN id="__Signature__"></SPAN>
      </DIV>
    */
    
    lstrcat(rgchAutoText, c_szHtml_DivOpen);
    lstrcat(rgchAutoText, c_szCaretSpanTag);
    lstrcat(rgchAutoText, c_szHtml_DivClose);
    
    if (fSig)
    {
        lstrcat(rgchAutoText, c_szHtml_DivOpen);
        lstrcat(rgchAutoText, c_szSignatureSpanTag);
        lstrcat(rgchAutoText, c_szHtml_DivClose);
    }
    
    if (pfTop && fSig && uSigOpt & MESIGOPT_BOTTOM)
        *pfTop = FALSE;

    // can use ACP for this conversion as we know all the text is lowansi
    return HrLPSZToBSTR(rgchAutoText, pbstr);
}

HRESULT CBody::PasteAutoText()
{
    HRESULT         hr=S_OK;
    LPSTREAM        pstm;
    DWORD           dwFlags=0;
    BSTR            bstrAutoText=0,
                    bstrSig=0;
    IHTMLElement    *pElem;
    BOOL            fPasteAtTop=TRUE;
    DWORD           dwSigOpt=0;
    VARIANTARG      va;

/*
    For AutoText, we search for a <SPAN> tag that indicates where the caret should be. 
    To find the caret, we use the following rules
        1. look for "_AthCaret"         this is used by a stationery author to set the caret for the stationery
        2. look for "__Ath_AutoCaret"   this is inserted by the rootstream it maybe at the top or bottom (sigopts)
                                        of the document. It should always be present if autotext is needed

    when we find the caret, we insert the auto-text stream we build (contains compose font and/or signature) and
    put the caret at the start of this.
*/
       
    GetHostFlags(&dwFlags);
    
    if (dwFlags & MEO_FLAGS_AUTOTEXT &&
        !FAILED(GetAutoText(&bstrAutoText, &fPasteAtTop)))
    {
        // try a stationery-authored caret
        if (FAILED(ReplaceElement("_AthCaret", bstrAutoText, TRUE)))
        {
            // if there wasn't one, then put at start or end of the body
            // depending on signature
            InsertBodyText(bstrAutoText, fPasteAtTop ? 0:IBTF_INSERTATEND);
        }
        
        va.vt = VT_I4;
        va.lVal = MESIG_AUTO;        
        
        // let's try and insert the signature now.
        if (m_pParentCmdTarget &&
            (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_ENABLED, 0, &va, NULL)==S_OK) &&
            (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_OPTIONS, 0, NULL, &va)==S_OK) && 
            va.vt==VT_I4)
        {
            dwSigOpt = va.lVal;
            if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE, 0, NULL, &va)==S_OK && 
                va.vt==VT_BSTR)
            {
                bstrSig = va.bstrVal;
                // sleazy v2. workaround. Trident pulled out the springloader font code from
                // CElem::put_outerText, so plain-signatures etc no longer go in in the 
                // compose font. We fix this by inserting an &nbsp after the signature span
                // (if there is one) then we can select the nbsp; and paste at that range.
                if (!FAILED(GetElement(c_szSignatureSpan, &pElem)))
                {
                    IHTMLTxtRange *pRange;
                    
                    if (CreateRangeFromElement(pElem, &pRange)==S_OK)
                    {
                        // small change. Now we put in &nbsp;<SPAN>&nbsp; we move the range to
                        // the span and then expand it a char left and right. This range includes the span
                        // do it get's nuked when we paste.
                        LONG cch;
                        
                        SideAssert(pRange->moveEnd((BSTR)c_bstr_Character, 1, &cch)==S_OK && cch==1);
                        SideAssert(pRange->moveStart((BSTR)c_bstr_Character, -1, &cch)==S_OK && cch==-1);
                        
                        if (dwSigOpt & MESIGOPT_HTML)
                            pRange->pasteHTML(bstrSig);
                        else
                        {
                            if(dwSigOpt & MESIGOPT_PREFIX)
                            {
                                BSTR    bstrPrefix;
                                
                                // if a prefix is required (for news), then append one
                                if (HrLPSZToBSTR(c_szSigPrefix, &bstrPrefix)==S_OK)
                                {
                                    pRange->put_text(bstrPrefix);
                                    pRange->collapse(VARIANT_FALSE);
                                    SysFreeString(bstrPrefix);
                                }
                            }
                            pRange->put_text(bstrSig);
                        }
                        pRange->Release();
                    }
                    pElem->Release();
                }
                SysFreeString(bstrSig);
            }
        }
        // if we sucessfully pasted, set the caret at the span marker we
        // just pasted
        if (!FAILED(GetElement(c_szCaretSpan, &pElem)))
        {
            SelectElement(pElem, TRUE);
            DeleteElement(pElem);
            pElem->Release();
        }
        
        SysFreeString(bstrAutoText);
    }
    
    return S_OK;
}


HRESULT CBody::GetHostFlags(LPDWORD pdwFlags)
{
    VARIANTARG  va;
    HRESULT     hr=E_FAIL;
    
    *pdwFlags = 0;
    
    if (m_pParentCmdTarget &&
        !FAILED(hr = m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_FLAGS, 0, NULL, &va)))
        *pdwFlags = va.lVal;

    return hr;
}


HRESULT CBody::GetBackgroundColor(DWORD *pdwColor)
{
    HRESULT             hr;
    IHTMLBodyElement   *pBodyElem=0;
    VARIANT             var;
    TCHAR              *lpszColor = NULL;

    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    hr = pBodyElem->get_bgColor(&var);
    if (FAILED(hr))
        goto error;

    if (var.bstrVal)
    {
        hr = HrBSTRToLPSZ(CP_ACP, var.bstrVal, &lpszColor);
        if (FAILED(hr))
            goto error;
        
        // get_bgColor returns format "#RRGGBB"
        // Only send in "RRGGBB" part of the string
        GetRGBFromString(pdwColor, lpszColor+1);
    }
    else
        *pdwColor = 0x00FFFFFF | GetSysColor(COLOR_WINDOW);

error:
    ReleaseObj(pBodyElem);
    SafeMemFree(lpszColor);
    SysFreeString(var.bstrVal);
    return hr;
}

HRESULT CBody::SetBackgroundColor(DWORD dwColor)
{
    HRESULT             hr;
    IHTMLBodyElement   *pBodyElem=0;
    VARIANT             var;
    TCHAR               szColor[7];  //"#RRGGBB\0"
    BSTR                bstrColor = NULL;

    GetStringRGB(dwColor, szColor);
    hr = HrLPSZToBSTR(szColor, &bstrColor);
    if (FAILED(hr))
        goto error;

    var.vt = VT_BSTR;
    var.bstrVal = bstrColor;

    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    hr = pBodyElem->put_bgColor(var);

error:
    ReleaseObj(pBodyElem);
    SysFreeString(bstrColor);

    return hr;
}

HRESULT CBody::SetWindowBgColor(BOOL fForce)
{
    HRESULT                 hr;
    IHTMLBodyElement        *pBodyElem=0;
    CHAR                    szBuf[MAX_PATH] = {0};
    DWORD                   dColors = 0;
    VARIANT                 v1, v2;

    v1.vt = VT_BSTR;
    v1.bstrVal = NULL;
    v2.vt = VT_BSTR;
    v2.bstrVal = NULL;

    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    hr=pBodyElem->get_bgColor(&v1);
    if (FAILED(hr))
        goto error;
    
    if(NULL != v1.bstrVal && !fForce)
        goto error;

    dColors = GetSysColor(COLOR_WINDOW);
    GetStringRGB(dColors, szBuf);

    hr=HrLPSZToBSTR(szBuf, &(v2.bstrVal));
    if (FAILED(hr))
        goto error;

    hr=pBodyElem->put_bgColor(v2);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pBodyElem);
    SysFreeString(v1.bstrVal);
    SysFreeString(v2.bstrVal);
    return hr;
}

#define CCBMAX_FRAMESEARCH  4096

HRESULT CBody::InsertFile(BSTR bstrFileName)
{
    OPENFILENAMEW   ofn;
    WCHAR           wszFile[MAX_PATH],
                    wszTitle[CCHMAX_STRINGRES],                    
                    wszFilter[100],
                    wszDefExt[30];
    BYTE            pbHtml[CCBMAX_FRAMESEARCH];
    HRESULT         hr;
    LPSTREAM        pstm = NULL;
    DWORD           dwFlags=0;
    BOOL            fHtml;
    ULONG           cb=0;    
    
    if (!m_lpOleObj)
        IF_FAILEXIT(hr = E_FAIL);
    
    *wszFile = 0;
    *wszTitle = 0;
    *wszFilter = 0;
    *wszDefExt = 0;
    
    // Load Res Strings
    GetHostFlags(&dwFlags);
    
    if (bstrFileName)
    {
        // if we have a filename, let's use that else prompt for one
        StrCpyNW(wszFile, (LPWSTR)bstrFileName, ARRAYSIZE(wszFile));
    }
    else
    {
        LoadStringWrapW(g_hLocRes, dwFlags&MEO_FLAGS_HTML?idsTextOrHtmlFileFilter:idsTextFileFilter, wszFilter, ARRAYSIZE(wszFilter));
        ReplaceCharsW(wszFilter, L'|', L'\0');
        LoadStringWrapW(g_hLocRes, idsDefTextExt, wszDefExt, ARRAYSIZE(wszDefExt));
        LoadStringWrapW(g_hLocRes, idsInsertTextTitle, wszTitle, ARRAYSIZE(wszTitle));
        
        // Setup Save file struct
        ZeroMemory (&ofn, sizeof (ofn));
        ofn.lStructSize = sizeof (ofn);
        ofn.hwndOwner = m_hwnd;
        ofn.lpstrFilter = wszFilter;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = wszFile;
        ofn.nMaxFile = ARRAYSIZE(wszFile);
        ofn.lpstrTitle = wszTitle;
        ofn.lpstrDefExt = wszDefExt;
        ofn.Flags = OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
        
        // Show OpenFile Dialog
        if (!GetOpenFileNameWrapW(&ofn))
            return NOERROR;
    }
    
    if (*wszFile==NULL)
        IF_FAILEXIT(hr = E_FAIL);

    IF_FAILEXIT(hr=OpenFileStreamW(wszFile, OPEN_EXISTING, GENERIC_READ, &pstm));

    fHtml = (dwFlags&MEO_FLAGS_HTML)&&FIsHTMLFileW(wszFile);

    if (fHtml)
    {     
        BOOL fFrames = FALSE;
        BOOL fLittleEndian;

        // if html, do a quick scan of the first 2k for a frameset
        pstm->Read(pbHtml, sizeof(pbHtml) - 2, &cb);
        pbHtml[cb] = 0;
        pbHtml[cb+1] = 0;

        // if we found a frameset tag, warn the user
        if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
        {
            if(StrStrIW((WCHAR*)pbHtml, L"<FRAMESET"))
                fFrames = TRUE;
        }
        else if (StrStrI((CHAR*)pbHtml, "<FRAMESET"))
            fFrames = TRUE;

        if (fFrames)
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsInsertTextTitle), MAKEINTRESOURCEW(idsErrInsertFileHasFrames), NULL, MB_OK);
    }

    IF_FAILEXIT(hr=InsertStreamAtCaret(pstm, fHtml));

exit:
    ReleaseObj(pstm);
    return hr;
}


HRESULT CBody::InsertStreamAtCaret(LPSTREAM pstm, BOOL fHtml)
{
    BSTR            bstr;
    HRESULT         hr;
    UINT            uiCodePage = 0 ;
    INETCSETINFO    CsetInfo ;
    LPSTR           pszCharset=NULL;
    HCHARSET        hCharset=NULL;
    IStream         *pstm2;

    HrRewindStream(pstm);

    if (fHtml)
    {
        if (SUCCEEDED(MimeOleCreateVirtualStream(&pstm2)))
        {
            if (SUCCEEDED(HrCopyStream(pstm, pstm2, 0)))
            {
                // if HTML then try and SNIFF the charset from the document
                if (GetHtmlCharset(pstm2, &pszCharset)==S_OK)
                {
                    MimeOleFindCharset(pszCharset, &hCharset);
                    MemFree(pszCharset);
                }
            }

            // Free up the stream
            pstm2->Release();
        }
    }
    
    // if nothing so far, try the message-charset
    if (!hCharset)
        hCharset = m_hCharset;
        
    if (hCharset)
    {
        // get CodePage from HCHARSET
        MimeOleGetCharsetInfo(hCharset,&CsetInfo);
        uiCodePage = CsetInfo.cpiInternet;
    }

    hr=HrIStreamToBSTR(uiCodePage ? uiCodePage : GetACP(), pstm, &bstr);
    if (!(FAILED(hr)))
    {
        hr = InsertTextAtCaret(bstr, fHtml, TRUE);
        SysFreeString(bstr);
    }
    return hr;
}


HRESULT CALLBACK FreeDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt)
{
    // Loop through the data and free it all
    if (pDataObjInfo)
        {
        for (DWORD i = 0; i < celt; i++)
            SafeMemFree(pDataObjInfo[i].pData);
        SafeMemFree(pDataObjInfo);    
        }
    return S_OK;
}

HRESULT CBody::CreateFontCache(LPCSTR pszTridentKey)
{
    VARIANTARG          va;
    HRESULT             hr=S_OK;
    IConnectionPoint   *pCP;

    // time to try and create a font cache. First of all, ask the host if he has one already that we should use
    // if so, we're done. If not, create based on pszTridentKey. If this is NULL we use the IE regkey

    if (m_pFontCache)
        return S_OK;

    if (m_pParentCmdTarget &&
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_FONTCACHE, 0, NULL, &va)==S_OK && 
        va.vt == VT_UNKNOWN)
    {
        ReplaceInterface(m_pFontCache, (IFontCache *)va.punkVal);
        (va.punkVal)->Release();
        goto done;
    }
    
    if(g_lpIFontCache)
    {
        ReplaceInterface(m_pFontCache, g_lpIFontCache);
        goto done;
    }
    
done:

    if (m_pFontCache && 
        m_pFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *)&pCP)==S_OK)
    {
        pCP->Advise((IUnknown *)(IFontCacheNotify *)this, &m_dwFontCacheNotify);
        pCP->Release();
    }

    RecalcPreivewHeight(NULL);
    return hr;
}



HRESULT CBody::DoHostProperties()
{
    return m_pParentCmdTarget?m_pParentCmdTarget->Exec(NULL, OLECMDID_PROPERTIES, 0, NULL, NULL):E_FAIL;
}



HRESULT CBody::SaveAsStationery(VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    BSTR                        bstr=0;
    LPSTREAM                    pstm=0,
                                pstmImage=0;
    LPSTR                       lpsz,
                                lpszName;
    TCHAR                       rgch[MAX_PATH],
                                sz[MAX_PATH+CCHMAX_STRINGRES],
                                rgchRes[CCHMAX_STRINGRES],
                                rgchExt[10];
    TCHAR                       rgchUrl[MAX_PATH],      
                                rgchPath[MAX_PATH];
    OPENFILENAME                ofn;
    TCHAR                       szFile[MAX_PATH];
    TCHAR                       szTitle[CCHMAX_STRINGRES];
    TCHAR                       szFilter[100];
    HRESULT                     hr;
    LPSTR                       pszOpenFilePath=NULL;
    WCHAR                       rgchW[MAX_PATH];

    TraceCall("CBody::SaveAsStationery");

    *rgchUrl=0;
    *rgchPath = 0;
    *szFile = 0;
    *szFilter = 0;

    LoadString(g_hLocRes, idsHtmlFileFilter, szFilter, sizeof(szFilter));
    ReplaceChars(szFilter, '|', '\0');

    LoadString(g_hLocRes, idsSaveAsStationery, szTitle, sizeof(szTitle));

    if (pvaIn && pvaIn->vt==VT_BSTR)
    {
        // if we get passed in an initial path to save into, then use it
        if (WideCharToMultiByte(CP_ACP, 0, (WCHAR*)pvaIn->bstrVal, -1, rgchPath, ARRAYSIZE(rgchPath), NULL, NULL))
            pszOpenFilePath = rgchPath;
    }
    
    // Setup Save file struct
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrInitialDir = rgchPath;
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR;
    
    // Show OpenFile Dialog
    if (!GetSaveFileName(&ofn) || *szFile==NULL)
        return MIMEEDIT_E_USERCANCEL;
    
    lstrcpy(rgchPath, szFile);
    rgchPath[ofn.nFileOffset] = NULL;
    
    lpszName = &szFile[ofn.nFileOffset];
    if (ofn.nFileExtension)
    {
        if(szFile[ofn.nFileExtension-1] == '.')
            szFile[ofn.nFileExtension-1]=NULL;
    }
    
    if (FAILED(MimeOleCreateVirtualStream(&pstm)))
        return E_OUTOFMEMORY;
    
    HrGetStyleTag(m_pDoc, &bstr);
    
    pstm->Write(c_szHtml_HtmlOpenCR, lstrlen(c_szHtml_HtmlOpenCR), 0);
    if (bstr)
    {
        pstm->Write(c_szHtml_HeadOpenCR, lstrlen(c_szHtml_HeadOpenCR), 0);
        if (HrBSTRToLPSZ(CP_ACP, bstr, &lpsz)==S_OK)
        {
            pstm->Write(lpsz, lstrlen(lpsz), 0);
            MemFree(lpsz);
        }
        pstm->Write(c_szHtml_HeadCloseCR, lstrlen(c_szHtml_HeadCloseCR), 0);
    }
    SysFreeString(bstr);
    
    if (GetBackgroundImage(m_pDoc, &bstr)==S_OK)
    {
        if (HrBSTRToLPSZ(CP_ACP, bstr, &lpsz)==S_OK)
        {
            if (HrBindToUrl(lpsz, &pstmImage)!=S_OK)
                HrFindUrlInMsg(m_pMsg, lpsz, FINDURL_SEARCH_RELATED_ONLY, &pstmImage);
            
            if (pstmImage)
            {
                lstrcpy(rgchUrl, lpszName);
                
                // append an extension
                if (HrSniffStreamFileExt(pstmImage, &lpsz)==S_OK) 
                {
                    lstrcat(rgchUrl, lpsz);
                    SafeMimeOleFree(lpsz);
                }
                
                lstrcpy(rgch, rgchPath);
                lstrcat(rgch, rgchUrl);
                
                if (PathFileExists(rgch))
                {
                    if (!LoadString(g_hLocRes, idsWarnFileExist, rgchRes, ARRAYSIZE(rgchRes)))
                    {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    wsprintf(sz, rgchRes, rgch);
                    
                    // the file exists, warn the dude
                    if (AthMessageBox(m_hwnd, MAKEINTRESOURCE(idsSaveAsStationery), sz, NULL, MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION )!=IDYES)
                    {
                        hr = S_OK;
                        goto error;
                    }
                }
                WriteStreamToFile(pstmImage, rgch, CREATE_ALWAYS, GENERIC_WRITE);
                pstmImage->Release();
            }
            MemFree(lpsz);
        }
        SysFreeString(bstr);
    }
    
    if (*rgchUrl)
    {
        // output the body tag with background image
        wsprintf(rgch, c_szHtml_BodyOpenBgCR, rgchUrl);
        pstm->Write(rgch, lstrlen(rgch), 0);
    }
    else
    {
        // reference point for BUG 31874
        if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSaveAsStationery), MAKEINTRESOURCEW(idsWarnBoringStationery), NULL, MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION )!=IDYES)
        {
            hr=MIMEEDIT_E_USERCANCEL;
            goto error;
        }    
        pstm->Write(c_szHtml_BodyOpenNbspCR, lstrlen(c_szHtml_BodyOpenNbspCR), 0);
    }
    
    pstm->Write(c_szHtml_BodyCloseCR, lstrlen(c_szHtml_BodyCloseCR), 0);
    pstm->Write(c_szHtml_HtmlCloseCR, lstrlen(c_szHtml_HtmlCloseCR), 0);
    
    lstrcpy(rgch, rgchPath);
    lstrcat(rgch, lpszName);
    lstrcat(rgch, ".htm");
    WriteStreamToFile(pstm, rgch, CREATE_ALWAYS, GENERIC_WRITE);
    
    if (pvaOut)
    {
        // if set, the caller wants the actual filename that was written, so convert rgch to a BSTR
        pvaOut->vt = VT_BSTR;
        pvaOut->bstrVal = NULL;
        HrLPSZToBSTR(rgch, &pvaOut->bstrVal);
    }

error:
    ReleaseObj(pstm);
    return hr;
}

HRESULT CBody::TagUnreferencedImages()
{
    ULONG                   uImage,
                            cImages;
    IHTMLElementCollection  *pCollect;
    IHTMLBodyElement        *pBody;
    IUnknown                *pUnk;
    BSTR                    bstr;
    CHAR                    szUrl[INTERNET_MAX_URL_LENGTH];

    // BUG: we can't use the image collection, as it shows images up multiple times
    // for NAV compatibility. Have to filter the 'all' collection on "IMG" tags.
    
    if (HrGetCollectionOf(m_pDoc, (BSTR)c_bstr_IMG, &pCollect)==S_OK)
    {
        cImages = UlGetCollectionCount(pCollect);
        
        for (uImage=0; uImage<cImages; uImage++)
        {
            if (HrGetCollectionItem(pCollect, uImage, IID_IUnknown, (LPVOID *)&pUnk)==S_OK)
            {
                if (HrGetMember(pUnk, (BSTR)c_bstr_SRC, VARIANT_FALSE, &bstr)==S_OK)
                {
                    if (WideCharToMultiByte(CP_ACP, 0, bstr, -1, szUrl, INTERNET_MAX_URL_LENGTH, NULL, NULL) &&
                        HrFindUrlInMsg(m_pMsg, szUrl, FINDURL_SEARCH_RELATED_ONLY, NULL)!=S_OK)
                    {
                        // this URL was not in the message, let's tag it as a NOSEND url
                        HrSetMember(pUnk, (BSTR)c_bstr_NOSEND, (BSTR)c_bstr_1);
                    }                
                    SysFreeString(bstr);
                }
                pUnk->Release();
            }
        }
        pCollect->Release();
    }
    
    // if the background is not included tag as NOSEND
    if (!FAILED(GetBodyElement(&pBody)))
    {
        if (!FAILED(GetBackgroundImage(m_pDoc, &bstr)))
        {
            if (WideCharToMultiByte(CP_ACP, 0, bstr, -1, szUrl, INTERNET_MAX_URL_LENGTH, NULL, NULL) &&
                HrFindUrlInMsg(m_pMsg, szUrl, FINDURL_SEARCH_RELATED_ONLY, NULL)!=S_OK)
            {
                HrSetMember(pBody, (BSTR)c_bstr_NOSEND, (BSTR)c_bstr_1);
            }
            SysFreeString(bstr);
        }
        pBody->Release();
    }
    
    return S_OK;
}


HRESULT CBody::FindFrameDownwards(LPCWSTR pszTargetName, DWORD dwFlags, IUnknown **ppunkTargetFrame)
{
    if (ppunkTargetFrame)
        *ppunkTargetFrame=NULL;

    return E_NOTIMPL;
}

HRESULT CBody::FindFrameInContext(LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame) 
{
    return DoFindFrameInContext(m_lpOleObj, (IUnknown *)(IPropertyNotifySink *)this, 
                                pszTargetName, punkContextFrame, dwFlags, ppunkTargetFrame);
}

HRESULT CBody::OnChildFrameActivate(IUnknown *pUnkChildFrame)
{
    return S_OK;
}

HRESULT CBody::OnChildFrameDeactivate(IUnknown *pUnkChildFrame)
{
    return S_OK;
}

HRESULT CBody::NavigateHack(DWORD grfHLNF,LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation)
{
    return E_NOTIMPL;
}

HRESULT CBody::FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser)
{
    if (ppunkBrowser)
        *ppunkBrowser=NULL;

    return E_NOTIMPL;
}


HRESULT CBody::ApplyDocumentVerb(VARIANTARG *pvaIn)
{
    HRESULT             hr;
    IHTMLDocument2      *pDoc=0;

    TraceCall("CBody::ApplyDocumentVerb");

    if(pvaIn && pvaIn->vt==VT_UNKNOWN && pvaIn->punkVal)
        pvaIn->punkVal->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);

    hr = ApplyDocument(pDoc);
    ReleaseObj(pDoc);
    return hr;
}

HRESULT CBody::ApplyDocument(IHTMLDocument2 *pDocStationery)
{
    HRESULT             hr;

    TraceCall("CBody::ApplyDocument");
    
    if(pDocStationery)
    {
        hr = HrCopyStyleSheets(pDocStationery, m_pDoc);
        if  (!FAILED(hr))
            hr = HrCopyBackground(pDocStationery, m_pDoc);
    }
    else
    {
        hr = HrRemoveStyleSheets(m_pDoc);
        if (!FAILED(hr))
            hr = HrRemoveBackground(m_pDoc);
    }
    return hr;
}



HRESULT CBody::OnWMCreate()
{
    RecalcPreivewHeight(NULL);
    return S_OK;
}



static const TBBUTTON g_rgBtnBarButtons[] = {
        { itbBadSign,   idmPaneBadSigning,      TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  2 },
        { itbSigning,   idmPaneSigning,         TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  0 },
        { itbEncryption,idmPaneEncryption,      TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  1 },
        { itbBadEnc,    idmPaneBadEncryption,   TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  3 },
        { itbVCard,     idmPaneVCard,           TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  4 },
        { itbPaperclip, idmPanePaperclip,       TBSTATE_ENABLED, TBSTYLE_DROPDOWN, {0,0}, 0,  5 },
    };


HRESULT CBody::InitToolbar()
{
    TCHAR       rgch[CCHMAX_STRINGRES];
    DWORD       dwBtnSize;
    
    if (!m_hwndBtnBar)
    {
        Assert (!m_hIml);
        Assert (!m_hImlHot);
        
        m_hwndBtnBar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
            TBSTYLE_TRANSPARENT|TBSTYLE_FLAT|TBSTYLE_TOOLTIPS|WS_CHILD|WS_CLIPSIBLINGS|CCS_NODIVIDER|CCS_NORESIZE|CCS_NOPARENTALIGN,
            0, 0, 32, 100, m_hwnd, (HMENU)idcBtnBar, g_hInst, NULL);
        
        if (!m_hwndBtnBar)
            return E_FAIL;
        
        m_hIml = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbPaneBar32), CX_PANEICON, 0, RGB(255, 0, 255), IMAGE_BITMAP, LR_LOADMAP3DCOLORS|LR_CREATEDIBSECTION);
        if (!m_hIml)
            return E_OUTOFMEMORY;
        
        SendMessage(m_hwndBtnBar, TB_SETIMAGELIST, 0, (LPARAM)m_hIml);
        
        m_hImlHot = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbPaneBar32Hot), CX_PANEICON, 0, RGB(255, 0, 255), IMAGE_BITMAP, LR_LOADMAP3DCOLORS|LR_CREATEDIBSECTION);
        if (!m_hImlHot)
            return E_OUTOFMEMORY;
        
        SendMessage(m_hwndBtnBar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_hImlHot);
        SendMessage(m_hwndBtnBar, TB_SETMAXTEXTROWS, 0, 0L);
        SendMessage(m_hwndBtnBar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(m_hwndBtnBar, TB_ADDBUTTONS, ARRAYSIZE(g_rgBtnBarButtons), (LPARAM)g_rgBtnBarButtons);
        if (LoadString(g_hLocRes, idsBtnBarTTList, rgch, ARRAYSIZE(rgch)))
        {
            ReplaceChars(rgch, '|', '\0');
            SendMessage(m_hwndBtnBar, TB_ADDSTRING,  0, (LPARAM)rgch);
        }
        
        m_cVisibleBtns = 0;
        // set the initial height of the toolbar, based on the button size
        dwBtnSize = (DWORD) SendMessage(m_hwndBtnBar, TB_GETBUTTONSIZE, 0, 0);
        SetWindowPos(m_hwndBtnBar, NULL, 0, 0, 0, HIWORD(dwBtnSize), SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER|SWP_NOMOVE);
        // now that we have setup the button height, recalc the preview header height
        RecalcPreivewHeight(NULL);
        Resize();
    }
    return S_OK;
}


HRESULT CBody::UpdateButtons()
{
    ULONG   dwBtnSize,
            uBtn;
    OLECMD  rgSecureCmds[]={{OECSECCMD_ENCRYPTED, 0},
                            {OECSECCMD_SIGNED, 0}};
    RECT    rc;
    int     cxBar;

    Assert (m_hwndBtnBar);

    // hide all the buttons
    m_cVisibleBtns=0;
    for (uBtn = 0; uBtn < ARRAYSIZE(g_rgBtnBarButtons); uBtn++)
        SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, g_rgBtnBarButtons[uBtn].idCommand, MAKELONG(TRUE, 0));

    // turn on the applicable buttons.
    if (m_pAttMenu && m_pAttMenu->HasAttach()==S_OK)
    {
        SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, idmPanePaperclip, MAKELONG(FALSE, 0));
        m_cVisibleBtns++; 
    }
    
    if (m_pAttMenu && m_pAttMenu->HasVCard()==S_OK)
    {
        SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, idmPaneVCard, MAKELONG(FALSE, 0));
        m_cVisibleBtns++;
    }
    
    // see if the host supports our private S/Mime functionality
    // we query the host for the security state of the message, this can take one of 3 forms for both
    // signed and ecrypted: (none, good or bad) represented by (OLECMDF_INVISIBLE, OLECMDF_ENABLED, and OLECMDF_DISABLED) 
    // respectivley
    if (m_pParentCmdTarget)
    {
        if (m_pParentCmdTarget->QueryStatus(&CMDSETID_OESecurity, ARRAYSIZE(rgSecureCmds), rgSecureCmds, NULL)==S_OK)
        {
            if (rgSecureCmds[0].cmdf & OLECMDF_SUPPORTED && !(rgSecureCmds[0].cmdf & OLECMDF_INVISIBLE))
            {
                SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, rgSecureCmds[0].cmdf & OLECMDF_ENABLED ? idmPaneEncryption : idmPaneBadEncryption, MAKELONG(FALSE, 0));
                m_cVisibleBtns++;
            }
            
            if (rgSecureCmds[1].cmdf & OLECMDF_SUPPORTED && !(rgSecureCmds[1].cmdf & OLECMDF_INVISIBLE))
            {
                SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, rgSecureCmds[1].cmdf & OLECMDF_ENABLED ? idmPaneSigning : idmPaneBadSigning, MAKELONG(FALSE, 0));
                m_cVisibleBtns++;
            }
        }
    }

    // size the toolbar based on the number of visible buttons
    dwBtnSize = (DWORD) SendMessage(m_hwndBtnBar, TB_GETBUTTONSIZE, 0, 0);
    cxBar = LOWORD(dwBtnSize)*m_cVisibleBtns;
    GetClientRect(m_hwnd, &rc);
    AssertSz(m_cyPreview >= HIWORD(dwBtnSize), "preview header is too small for the button bar");
    SetWindowPos(m_hwndBtnBar, NULL, rc.right - cxBar, (m_cyPreview - HIWORD(dwBtnSize))/2, LOWORD(dwBtnSize)*m_cVisibleBtns, HIWORD(dwBtnSize),SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER|SWP_SHOWWINDOW);
    return S_OK;
}

HRESULT CBody::ShowAttachMenu(BOOL fRightClick)
{
    POINT   pt;

    PointFromButton(idmPanePaperclip, &pt);

    if (m_pAttMenu && m_pAttMenu->HasAttach()==S_OK)
        m_pAttMenu->Show(m_hwnd, &pt, fRightClick);

    return S_OK;
}

HRESULT CBody::ShowPreview(BOOL fOn)
{
    if (fOn)
    {
        UpdatePreviewLabels();
        
        // if user turns on the preview pane after loaded, then defer-create the attachment menu
        if (m_fMessageParsed)
            UpdateBtnBar();
        
    }

    if (m_hwndBtnBar)
        ShowWindow(m_hwndBtnBar, fOn?SW_SHOW:SW_HIDE);

    return S_OK;
}

HRESULT CBody::PointFromButton(int idm, POINT *ppt)
{
    RECT    rc;

    if (!SendMessage(m_hwndBtnBar, TB_GETRECT, idm, (LPARAM)&rc))
        return E_FAIL;

    ppt->x = rc.right;
    ppt->y = rc.bottom;
    ClientToScreen(m_hwndBtnBar, ppt);
    return S_OK;    
}


HRESULT CBody::UpdateBtnBar()
{
    HRESULT     hr;

    // create the attachment menu. This will be destroyed on every load/unload to reflect the new state of the
    // message
    if (!m_pAttMenu && m_pMsg)
        {
        hr = EnsureAttMenu();
        if (FAILED(hr))
            goto error;
        }

    // make sure the button bar is created. This will be created once per preview pane
    hr = InitToolbar();
    if (FAILED(hr))
        goto error;

    hr = UpdateButtons();

error:
    return hr;
}


HRESULT CBody::EnsureAttMenu()
{
    HRESULT hr=S_OK;
        
    if (!m_pAttMenu && m_pMsg)
    {
        m_pAttMenu = new CAttMenu();
        if (!m_pAttMenu)
            return E_OUTOFMEMORY;
        
        hr = m_pAttMenu->Init(m_pMsg, m_pFontCache, m_pParentInPlaceFrame, m_pParentCmdTarget);
        if (FAILED(hr))
            goto error;
    }
error:
    return hr;
}



HRESULT HrSniffUrlForRfc822(LPWSTR pszUrlW)
{
    LPWSTR  lpszW;
    HRESULT hr = S_FALSE;

    if (!FAILED(FindMimeFromData(NULL, pszUrlW, NULL, NULL, NULL, NULL, &lpszW, 0)))
        {
        if (StrCmpW(lpszW, L"message/rfc822")==0)
            hr = S_OK;
        CoTaskMemFree(lpszW);
        }
    return hr;
}

HRESULT CBody::SaveAttachments()
{
    return SaveAttachmentsWithPath(m_hwnd, m_pParentCmdTarget, m_pMsg);
}

HRESULT CBody::InsertBackgroundSound()
{
    ULONG           cRepeat;
    BSTR            bstrUrl;
    BGSOUNDDLG      rBGSound;
    
    rBGSound.wszUrl[0]=0;    // null string
    rBGSound.cRepeat = 1;   // default to 1 repeat
    
    if (GetBackgroundSound(m_pDoc, &rBGSound.cRepeat, &bstrUrl)==S_OK)
    {
        StrCpyNW(rBGSound.wszUrl, bstrUrl, ARRAYSIZE(rBGSound.wszUrl));
        SysFreeString(bstrUrl);
    }
    
    if (S_OK == DoBackgroundSoundDlg(m_hwnd, &rBGSound))
    {
        bstrUrl = SysAllocString(rBGSound.wszUrl);
        if (bstrUrl)
        {
            SetBackgroundSound(m_pDoc, rBGSound.cRepeat, bstrUrl);
            SysFreeString(bstrUrl);
        }
    }
    return S_OK;
}

HRESULT CBody::EnableSounds(BOOL fOn)
{
    VARIANTARG  va;

    va.vt = VT_I4;
    va.lVal = fOn;
    if (m_pCmdTarget)
        m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_ENABLE_INTERACTION, NULL, &va, NULL);
    return S_OK;
}

HRESULT CBody::ShowSourceTabs(BOOL fOn)
{
    TC_ITEM     tci;
    HFONT       hFont;
    TCHAR       rgch[CCHMAX_STRINGRES];
    WNDCLASSEX  wc;
    int         i;
    
    if (fOn == m_fSrcTabs)
        return S_OK;
    
    if (!fOn && m_hwndTab)
    {       
        // if turning off, make sure we got back to edit-mode
        SetSourceTabs(MEST_EDIT);
    }
    
    if (m_hwndTab)
    {               // already created
        ShowWindow(m_hwndTab, fOn?SW_SHOW:SW_HIDE);
        goto exit;
    }
    
    
    m_hwndTab = CreateWindowEx(0,
        WC_TABCONTROL, 
        NULL,
        WS_CHILD|WS_TABSTOP|WS_VISIBLE|TCS_BOTTOM|TCS_FIXEDWIDTH,
        0, 0, 0, 0,
        m_hwnd, 
        (HMENU)idcTabs, 
        g_hLocRes, 
        NULL);
    if (!m_hwndTab)
        return E_FAIL;
    
    tci.mask = TCIF_TEXT;
    for (i=MEST_EDIT; i<=MEST_PREVIEW; i++)
    {
        LoadString(g_hLocRes, idsEditTab+i, rgch, ARRAYSIZE(rgch));
        tci.pszText = rgch;
        TabCtrl_InsertItem(m_hwndTab, i, &tci);
    }
    
    if (m_pFontCache &&
        m_pFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
        SendMessage(m_hwndTab, WM_SETFONT, (WPARAM)hFont, 0);

exit:
    m_fSrcTabs = fOn;
    Resize();
    return S_OK;
}


HRESULT CBody::ShowSourceView(ULONG uSrcView)
{
    IStream *pstm;
    BOOL    fFocus;
    HRESULT hr=S_OK;

    if (m_uSrcView == uSrcView) // noop
        return S_OK;

    /* store information about the current state. we care about
        - who has focus
        - caching the IStream of 'current' HTML
        - dirty states
    */
    switch (m_uSrcView)
    {
        case MEST_EDIT:
            // if switching away from edit-mode remember the dirty state
            m_fWasDirty = IsDirty() == S_OK;
            fFocus = m_fUIActive;
            SafeRelease(m_pstmHtmlSrc);
            GetBodyStream(m_pDoc, TRUE, &m_pstmHtmlSrc);
            break;
            
        case MEST_PREVIEW:
            // m_pstmHtml is not saved from this mode, assume the previous setting
            AssertSz(m_pstmHtmlSrc, "This should be set from a previous switch");
            fFocus = m_fUIActive;
            break;
        
        case MEST_SOURCE:
            // if switching away from source-mode remember the dirty state
            Assert (m_pSrcView);
            SafeRelease(m_pstmHtmlSrc);
            m_pSrcView->Save(&m_pstmHtmlSrc);
            m_fWasDirty = m_pSrcView->IsDirty() == S_OK;
            fFocus = m_pSrcView->HasFocus()==S_OK;
            break;
    }


    m_pDocView->UIActivate(FALSE);

    // at this point m_pstmSrcHtml contains the new HTML source
    switch (uSrcView)
    {
        case MEST_EDIT:
            /* when switching to edit mode.
                - reload trident
                - ensure design-mode
                - restore focus
                - restore dirty state 
                - hide source-view (if shown) 
            */
            SetDesignMode(TRUE);
            _ReloadWithHtmlSrc(m_pstmHtmlSrc);
            HrSetDirtyFlagImpl(m_pDoc, !!m_fWasDirty);
            if (fFocus)
                m_pDocView->UIActivate(TRUE);
            if (m_pSrcView)
                m_pSrcView->Show(FALSE, FALSE);
            m_pDocView->Show(TRUE);
            break;
            
        case MEST_PREVIEW:
            /* when switching to preview mode.
                - reload trident
                - ensure design-mode is OFF
                - restore focus
                - restore dirty state
                - hide source-view (if shown) 
            */
            SetDesignMode(FALSE);
            _ReloadWithHtmlSrc(m_pstmHtmlSrc);
            if (fFocus)
                m_pDocView->UIActivate(TRUE);
            if (m_pSrcView)
                m_pSrcView->Show(FALSE, FALSE);
            m_pDocView->Show(TRUE);
            break;

        case MEST_SOURCE:
            /* when switching to source mode.
                - defer-create the source view window (if needed)
                - hide trident
                - restore focus 
                - restore dirty state */

            hr = _EnsureSrcView();
            if (FAILED(hr))
                goto error;
              
            Assert (m_pSrcView);
            m_pSrcView->Show(TRUE, IsColorSourceEditing()==S_OK);
            m_pSrcView->Load(m_pstmHtmlSrc);
            m_pSrcView->SetDirty(m_fWasDirty);
            m_pDocView->Show(FALSE);
            // restore focus
            if (fFocus)
                m_pSrcView->SetFocus();
            break;
    }

    ShowFormatBar(uSrcView == MEST_EDIT && m_uHdrStyle == MESTYLE_FORMATBAR);
    m_uSrcView = uSrcView;
    Resize();

error:
    return hr;
}


HRESULT CBody::SetSourceTabs(ULONG ulTab)
{
    int     rgNext[3] = {MEST_SOURCE, MEST_PREVIEW, MEST_EDIT},
            rgPrev[3] = {MEST_PREVIEW, MEST_EDIT, MEST_SOURCE};

    if (!m_fSrcTabs)            // do nothing if not in source-tab-mode
        return E_UNEXPECTED;

    switch (ulTab)
    {
        case MEST_NEXT:
            ulTab = rgNext[m_uSrcView];
            break;

        case MEST_PREVIOUS:
            ulTab = rgPrev[m_uSrcView];
            break;

        case MEST_EDIT:
        case MEST_SOURCE:
        case MEST_PREVIEW:
            break;
        
        default:
            return E_INVALIDARG;
    }

    Assert (((int) ulTab) >= MEST_EDIT && ((int) ulTab) <= MEST_PREVIEW);
    ShowSourceView(ulTab);
    TabCtrl_SetCurSel(m_hwndTab, ulTab);
    return S_OK;
} 

HRESULT CBody::IsColorSourceEditing()
{
    VARIANTARG  va;
    
    if (m_pParentCmdTarget &&
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SOURCEEDIT_FLAGS, 0, NULL, &va)==S_OK &&
        va.vt == VT_I4 &&
        !(va.lVal & MESRCFLAGS_COLOR))
        return S_FALSE;

    return S_OK;
}

HRESULT CBody::HrCreateSpeller(BOOL fBkgrnd)
{
    HRESULT     hr;
    VARIANTARG  va;

    if (m_pSpell)
        return NOERROR;

#ifndef BACKGROUNDSPELL
	// just to make sure background spelling is disabled
	Assert(!fBkgrnd);
	fBkgrnd = FALSE;
#endif // !BACKGROUNDSPELL

    if (m_fDesignMode && m_pDoc && m_pParentCmdTarget && FCheckSpellAvail(m_pParentCmdTarget) &&
        SUCCEEDED(m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SPELL_OPTIONS, OLECMDEXECOPT_DODEFAULT, NULL, &va)))
    {
        if (((V_I4(&va) & MESPELLOPT_CHECKONTYPE) && fBkgrnd) || !fBkgrnd)
            m_pSpell = new CSpell(m_pDoc, m_pParentCmdTarget, V_I4(&va));
    }

    if (m_pSpell)
    {
        if (!m_pSpell->OpenSpeller())
        {
            SafeRelease(m_pSpell);
            return E_FAIL;
        }

#ifdef BACKGROUNDSPELL
        if (fBkgrnd)
        {
            SetTimer(m_hwnd, idTimerBkgrndSpell, BKGRNDSPELL_TICKTIME, NULL);
            m_pSpell->HrRegisterKeyPressNotify(TRUE);
            m_fBkgrndSpelling = TRUE;
        }
#endif // BACKGROUNDSPELL
    }

    return m_pSpell ? NOERROR : E_FAIL;
}



HRESULT CBody::OnPreFontChange()
{
    return S_OK;
}

HRESULT CBody::OnPostFontChange()
{
    HFONT   hFont;

    RecalcPreivewHeight(NULL);
    Resize();

    // update the tabfont
    if (m_hwndTab && 
        m_pFontCache &&
        m_pFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
        SendMessage(m_hwndTab, WM_SETFONT, (WPARAM)hFont, 0);

    return S_OK;
}

extern BOOL                g_fCanEditBiDi;
HRESULT CBody::HrFormatParagraph()
{
    OLECMD  rgCmds[]= { {IDM_JUSTIFYLEFT, 0},    // careful about ordering!!
                        {IDM_JUSTIFYRIGHT, 0},
                        {IDM_JUSTIFYCENTER, 0},
                        {IDM_JUSTIFYFULL, 0},
                        {IDM_ORDERLIST, 0},
                        {IDM_UNORDERLIST, 0},
                        {IDM_BLOCKDIRLTR, 0},
                        {IDM_BLOCKDIRRTL, 0}};

    int     rgidm[] = { idmFmtLeft,              // careful about ordering!!
                        idmFmtRight,
                        idmFmtCenter,
                        idmFmtJustify,
                        idmFmtNumbers,
                        idmFmtBullets,
                        idmFmtBlockDirLTR,
                        idmFmtBlockDirRTL};
    PARAPROP ParaProp;
    int i;
    if(FAILED(m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgCmds)/sizeof(OLECMD), rgCmds, NULL)))
        return E_FAIL;
    memset(&ParaProp, 0, sizeof(PARAPROP));

    for(i = 0; i < 4; i++)
        if(rgCmds[i].cmdf&OLECMDF_LATCHED)
            ParaProp.group[0].iID=rgidm[i];

    ParaProp.group[1].iID = idmFmtBulletsNone;
   
    for(i = 4; i < 6; i++)
        if(rgCmds[i].cmdf&OLECMDF_LATCHED)
            ParaProp.group[1].iID=rgidm[i];

    for(i = 6; i < 8; i++)
        if(rgCmds[i].cmdf&OLECMDF_LATCHED)
            ParaProp.group[2].iID=rgidm[i];

    if(DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddFormatPara), m_hwnd, FmtParaDlgProc, (LPARAM)&ParaProp)==IDOK)
    {
        // Dir attribute implies direction.
        // lets change it first
        for(i = g_fCanEditBiDi? 2 : 1; i > -1; i--)
            if(ParaProp.group[i].bChanged)
            {
                OnWMCommand(m_hwnd, ParaProp.group[i].iID, 0);
            }
        
    }
            
  return S_OK;     
}

//+---------------------------------------------------------------
//
//  Member:     SearchForCIDUrls
//
//  Synopsis:   added to support MSPHONE. They send documents with
//              multipart/related CID:foo.wav files, the URLs are renderd
//              using an Active-Movive control embedded in the HTML. 
//              Trident never fires pluggable protocol requests for the 
//              urls and so we don't flag the attachments as rendered. Here we 
//              walk the document and try and find any CID's that are referenced
//              in the HTML. APP requests get fired when the page goes oncomplete and 
//              the activex controls are activated.
//---------------------------------------------------------------
HRESULT CBody::SearchForCIDUrls()
{
    HBODY                   hBody;
    IMimeEditTagCollection *pCollect;
    ULONG                   cFetched;
    IMimeEditTag           *pTag;
    BSTR                    bstrSrc;
    LPSTR                   pszUrlA,
                            pszBodyA;

    // nothing todo if there is no multipart/related section
    if (m_pMsg == NULL ||  
        MimeOleGetRelatedSection(m_pMsg, FALSE, &hBody, NULL)!=S_OK)
        return S_OK;

    // active-movie controls (for MSPHONE)
    if (CreateActiveMovieCollection(m_pDoc, &pCollect)==S_OK)
    {
        pCollect->Reset();

        while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
        {
            if (pTag->GetSrc(&bstrSrc)==S_OK)
            {
                pszUrlA = PszToANSI(CP_ACP, bstrSrc);
                if (pszUrlA)
                {
                    // if it's an MHTML: url then we have to fixup to get the cid:
                    // as ResolveURL won't recognize it
                    if (StrCmpNIA(pszUrlA, "mhtml:", 6)==0)
                    {
                        if (!FAILED(MimeOleParseMhtmlUrl(pszUrlA, NULL, &pszBodyA)))
                        {
                            // pszBody pszUrlA is guarnteed to be smaller 
                            lstrcpy(pszUrlA, pszBodyA);
                            SafeMimeOleFree(pszBodyA);
                        }
                    }
                    m_pMsg->ResolveURL(NULL, NULL, pszUrlA, URL_RESOLVE_RENDERED, NULL);
                    MemFree(pszUrlA);
                }
                SysFreeString(bstrSrc);
            }
            pTag->Release();
        }
        pCollect->Release();
    }
    return S_OK;
}

HRESULT CBody::_ReloadWithHtmlSrc(IStream *pstm)
{
    IMimeMessage    *pMsg;

    // if we're currently in HTML view, save the changes and reload trident
    if (m_pMsg && pstm)
    {
        pMsg = m_pMsg;
        pMsg->AddRef();
        pMsg->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pstm, NULL);
        m_fReloadingSrc = TRUE;
        Load(pMsg);
        m_fLoading = FALSE;
        pMsg->Release();
    }
    return S_OK;
}


HRESULT CBody::_EnsureSrcView()
{
    HRESULT hr=S_OK;

    if (!m_pSrcView)
    {
        m_pSrcView = new CMsgSource();
        if (!m_pSrcView)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        hr = m_pSrcView->Init(m_hwnd, idcSrcEdit, (IOleCommandTarget *)this);
        if (FAILED(hr))
            goto error;
    }
    
error:
    return hr;
}



/*
 * Function: _OnSaveImage
 * 
 * Purpose:
 *      if we're doing a SaveAs on an image, trident will not show the correct options in the save-as dialog
 *	    unless the image is in the cache. For auto-inlined images, we changed the behaviour for OE5 to show
 *      them thro' the pluggable protocol. This is a hack to preload the cache with the pluggable protocol to
 *      the image. Note that we also need to delete the cache entry as the full URL is not persitable across sessions. 
 *      ie: given the mhtml://mid:xxxxx!foobar.gif the mid: generated number is reused across OE sessions.
 *
 */

HRESULT CBody::_OnSaveImage()
{
	IHTMLImgElement	*pImg;
	BSTR			bstr=NULL;
    LPSTR           pszUrlA=NULL;
    LPSTREAM        pstm=NULL;
    HRESULT         hrCached=E_FAIL;

    // try and get the image URL (m_pDispContext points to the object the context menu is acting on)
	if (m_pDispContext &&
		m_pDispContext->QueryInterface(IID_IHTMLImgElement, (LPVOID *)&pImg)==S_OK)
	{
		pImg->get_src(&bstr);
		if (bstr)
        {
            pszUrlA = PszToANSI(CP_ACP, bstr);
            SysFreeString(bstr);
        }
        pImg->Release();
	}
	
    // if this URL is in the mutlipart/related secion
    if (!FAILED(HrFindUrlInMsg(m_pMsg, pszUrlA, 0, &pstm)))
    {
        DeleteUrlCacheEntryA(pszUrlA);
        hrCached = CreateCacheFileFromStream(pszUrlA, pstm);
        pstm->Release();
    }
    
	
	Assert (m_pCmdTarget);
    m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_SAVEPICTURE, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    
    // if we successfully cached this URL, be sure to remove it once the save is complete.
    if (SUCCEEDED(hrCached))
        DeleteUrlCacheEntryA(pszUrlA);

    MemFree(pszUrlA);
    return S_OK;
}


CVerHost::CVerHost()
{
    m_cRef=1;
}


CVerHost::~CVerHost()
{
}


HRESULT CVerHost::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IVersionHost))
        *lplpObj = (IVersionHost *) this;
    else
        return E_NOINTERFACE;
        
    AddRef();
    return NOERROR;
}

ULONG CVerHost::AddRef()
{
    return ++m_cRef;
}


ULONG CVerHost::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CVerHost::QueryUseLocalVersionVector(BOOL *fUseLocal)
{
    *fUseLocal = TRUE;
    return S_OK;
}


HRESULT CVerHost::QueryVersionVector(IVersionVector *pVersion)
{

    if (pVersion == NULL)
        return E_INVALIDARG;

   return pVersion->SetVersion(L"VML", NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\doc.cpp ===
/*
 *    d o c  . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <resource.h>
#include <strconst.h>
#ifdef PLUSPACK
#include "htmlsp.h"
#endif //PLUSPACK
#include "demand.h"
#include "dllmain.h"
#include "msoert.h"
#include "doc.h"
#include "htiframe.h"       //ITargetFrame2
#include "htiface.h"        //ITargetFramePriv
#include "body.h"
#include "util.h" 
#include "oleutil.h"
#include "triutil.h"

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDoc::CDoc(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_ulState = OS_PASSIVE;
    m_hwndParent = NULL;
    m_pClientSite = NULL;
    m_pIPSite = NULL;
    m_lpszAppName = NULL;
    m_pInPlaceFrame=NULL;
    m_pInPlaceUIWindow=NULL;
    m_pBodyObj=NULL;
    m_pTypeInfo=NULL;
    DllAddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDoc::~CDoc()
{
    DllRelease();
    SafeMemFree(m_lpszAppName);
    SafeRelease(m_pClientSite);
}

//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CDoc::PrivateQueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IOleObject))
        *lplpObj = (LPVOID)(IOleObject *)this;
    else if (IsEqualIID(riid, IID_IOleDocument))
        *lplpObj = (LPVOID)(IOleDocument *)this;
    else if (IsEqualIID(riid, IID_IOleDocumentView))
        *lplpObj = (LPVOID)(IOleDocumentView *)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(IOleCommandTarget *)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceObject))
        *lplpObj = (LPVOID)(IOleInPlaceObject *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceActiveObject))
        *lplpObj = (LPVOID)(IOleInPlaceActiveObject *)this;
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
        *lplpObj = (LPVOID)(IPersistStreamInit *)this;
    else if (IsEqualIID(riid, IID_IPersistMoniker))
        *lplpObj = (LPVOID)(IPersistMoniker *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)this;
    else if (IsEqualIID(riid, IID_IMimeEdit))
        *lplpObj = (LPVOID)(IMimeEdit *)this;
    else if (IsEqualIID(riid, IID_IQuickActivate))
        *lplpObj = (LPVOID)(IQuickActivate *)this;
#ifdef OFFICE_BINDER
    else if (IsEqualIID(riid, IID_IPersistStorage))
        *lplpObj = (LPVOID)(IPersistStorage *)this;
#endif
    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IPersistFile))
        *lplpObj = (LPVOID)(IPersistFile *)this;
    else
        {
        //DebugPrintInterface(riid, "CDoc::{not supported}=");
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetClassID(CLSID *pClassID)
{
	TraceCall("CDoc::GetClassID");

	*pClassID = CLSID_MimeEdit;
    return NOERROR;
}

// *** IPersistMime ***


//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Load(IMimeMessage *pMsg)
{
	TraceCall("CDoc::Load");

    return m_pBodyObj ? m_pBodyObj->Load(pMsg) : TraceResult(E_UNEXPECTED);
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Save(IMimeMessage *pMsg, DWORD dwFlags)
{
    IPersistMime    *pPM;
    HRESULT         hr;

	TraceCall("CDoc::Save");

    if (!m_pBodyObj)
        return TraceResult(E_UNEXPECTED);

    hr = m_pBodyObj->QueryInterface(IID_IPersistMime, (LPVOID *)&pPM);
    if (!FAILED(hr))
        {
        hr = pPM->Save(pMsg, dwFlags);
        pPM->Release();
        }
    return hr;
}

// *** IPersistStreamInit ***

//+---------------------------------------------------------------
//
//  Member:     IsDirty
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::IsDirty()
{
	TraceCall("CDoc::IsDirty");

    return m_pBodyObj?m_pBodyObj->IsDirty():TraceResult(E_UNEXPECTED);
}

//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Load(LPSTREAM pstm)
{
	TraceCall("CDoc::Load");

    return m_pBodyObj?m_pBodyObj->LoadStream(pstm):TraceResult(E_UNEXPECTED);
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Save(LPSTREAM pstm, BOOL fClearDirty)
{
	TraceCall("CDoc::Save");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetSizeMax
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetSizeMax(ULARGE_INTEGER * pCbSize)
{
	TraceCall("CDoc::GetSizeMax");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     InitNew
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::InitNew()
{
	TraceCall("CDoc::InitNew");
    if (m_pBodyObj)
        return m_pBodyObj->UnloadAll();

    return S_OK;
}

// *** IOleDocument ***
//+---------------------------------------------------------------
//
//  Member:     CreateView
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::CreateView(IOleInPlaceSite *pIPSite, IStream *pstm, DWORD dwReserved, IOleDocumentView **ppView)
{
    HRESULT         hr;

    TraceCall("CDoc::CreateView");

    if (pIPSite == NULL || ppView == NULL)
        return TraceResult(E_INVALIDARG);

    if (m_pClientSite == NULL)
        return TraceResult(E_FAIL);

    hr = SetInPlaceSite(pIPSite);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

error:
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     GetDocMiscStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetDocMiscStatus(DWORD *pdwStatus)
{
    TraceCall("CDoc::GetDocMiscStatus");
    
    *pdwStatus = DOCMISC_CANTOPENEDIT | DOCMISC_NOFILESUPPORT;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     EnumViews
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnumViews(IEnumOleDocumentViews **ppEnum, IOleDocumentView **ppView)
{
    TraceCall("CDoc::EnumViews");

    HRESULT hr = S_OK;

    if (ppEnum == NULL || ppView == NULL)
        return TraceResult(E_INVALIDARG);
        
    *ppEnum = NULL;

    return PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView);
}


// *** IOleDocumentView ***
//+---------------------------------------------------------------
//
//  Member:     SetInPlaceSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetInPlaceSite(IOleInPlaceSite *pIPSite)
{
    TraceCall("CDoc::SetInPlaceSite");

    // destroys the docobj and detaches from the current client site
    // replaces the client site pointer read for a ::Show
    DeactivateInPlace();
    ReplaceInterface(m_pIPSite, pIPSite);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetInPlaceSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetInPlaceSite(IOleInPlaceSite **ppIPSite)
{
    TraceCall("CDoc::GetInPlaceSite");

    if (!ppIPSite)
        return E_INVALIDARG;

    if (*ppIPSite=m_pIPSite)
        {
        m_pIPSite->AddRef();
        return S_OK;
        }
    else
        return E_FAIL;
}


//+---------------------------------------------------------------
//
//  Member:     GetDocument
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetDocument(IUnknown **ppunk)
{
    TraceCall("CDoc::GetDocument");

    if (ppunk==NULL)
        return E_INVALIDARG;

    *ppunk = (IOleDocument *)this;
    (*ppunk)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetRect(LPRECT prcView)
{
    if (m_pBodyObj)
        m_pBodyObj->SetRect(prcView);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetRect(LPRECT prcView)
{
    TraceCall("CDoc::GetRect");

    if (m_pBodyObj)
        m_pBodyObj->GetRect(prcView);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetRectComplex
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetRectComplex(LPRECT prcView, LPRECT prcHScroll, LPRECT prcVScroll, LPRECT prcSizeBox)
{
    TraceCall("CDoc::SetRectComplex");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Show
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Show(BOOL fShow)
{
    HRESULT hr;

    TraceCall("CDoc::Show");
    
    hr = ActivateInPlace();
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

error:
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     UIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::UIActivate(BOOL fUIActivate)
{
    HRESULT     hr=S_OK;

    TraceCall("CDoc::UIActivate");

#ifdef OFFICE_BINDER
    if (fUIActivate)
        {
        hr = ActivateInPlace();
        }
#endif    
    if (m_pBodyObj)
        return m_pBodyObj->UIActivate(fUIActivate);
    
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     Open
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Open()
{
    TraceCall("CDoc::Open");
    
    // no single instance View|Frame supported
    return E_NOTIMPL;
}
//+---------------------------------------------------------------
//
//  Member:     CloseView
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::CloseView(DWORD dwReserved)
{
    TraceCall("CDoc::CloseView");
    
    // to close the view, set the Site to NULL
    SetInPlaceSite(NULL);
    return S_OK;
}
//+---------------------------------------------------------------
//
//  Member:     SaveViewState
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SaveViewState(LPSTREAM pstm)
{
    TraceCall("CDoc::SaveViewState");
    return S_OK;    // we don't keep view state
}
//+---------------------------------------------------------------
//
//  Member:     ApplyViewState
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ApplyViewState(LPSTREAM pstm)
{
    TraceCall("CDoc::ApplyViewState");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Clone
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Clone(IOleInPlaceSite *pIPSiteNew, IOleDocumentView **ppViewNew)
{
    TraceCall("CDoc::Clone");
    return E_NOTIMPL;
}

// *** IOleObject ***
//+---------------------------------------------------------------
//
//  Member:     SetClientSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetClientSite(IOleClientSite *pClientSite)
{
    TraceCall("CDoc::SetClientSite");

    if (m_pClientSite && pClientSite)
        {
        // don't allow them to change the client site
        TraceInfo("Host attempt to change client-site fefused");
        return E_INVALIDARG;
        }

    ReplaceInterface(m_pClientSite, pClientSite);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetClientSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetClientSite(IOleClientSite **ppClientSite)
{
    TraceCall("CDoc::GetClientSite");

    if (!ppClientSite)
        return E_INVALIDARG;

    if (*ppClientSite=m_pClientSite)
        {
        m_pClientSite->AddRef();
        return S_OK;
        }
    else
        return E_FAIL;
}

//+---------------------------------------------------------------
//
//  Member:     SetHostNames
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetHostNames(LPCOLESTR szContainerAppW, LPCOLESTR szContainerObjW)
{
    TraceCall("CDoc::SetHostNames");

    SafeMemFree(m_lpszAppName);
    if (szContainerAppW)
        m_lpszAppName = PszToANSI(CP_ACP, szContainerAppW);

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Close
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Close(DWORD dwSaveOption)
{
    HRESULT hr = S_OK;
    BOOL    fSave;
    int     id;
    TCHAR   szTitle[MAX_PATH];

    TraceCall("CDoc::Close");

    // if our object is dirty then we should save it, depending on the
    // save options
    if (m_pClientSite && 
        m_pBodyObj && 
        m_pBodyObj->IsDirty()==S_OK)
        {
        switch(dwSaveOption)
            {
            case OLECLOSE_SAVEIFDIRTY:
                fSave = TRUE;
                break;

            case OLECLOSE_NOSAVE:
                fSave = FALSE;
                break;

            case OLECLOSE_PROMPTSAVE:
                {
                if(m_ulState != OS_UIACTIVE)
                    {
                    // if we're not UI active, then don't prompt
                    fSave=TRUE;
                    break;
                    }

                GetHostName(szTitle, sizeof(szTitle)/sizeof(TCHAR));
                id = AthMessageBox(m_hwndParent, szTitle, MAKEINTRESOURCE(idsSaveModifiedObject), NULL, MB_YESNOCANCEL);
                if (id == 0)
                    return TraceResult(E_OUTOFMEMORY);
                else if (id == IDCANCEL)
                    return TraceResult(OLE_E_PROMPTSAVECANCELLED);

                fSave=(id == IDYES);
                }
                break;

        default:
            return TraceResult(E_INVALIDARG);
            }
        
        if (fSave)
            hr = m_pClientSite->SaveObject();
        }

    if (hr==S_OK)
        hr = DeactivateInPlace();

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SetMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
{
    TraceCall("CDoc::SetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    TraceCall("CDoc::GetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     InitFromData
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::InitFromData(IDataObject *pDataObject, BOOL fCreation, DWORD dwReserved)
{
    TraceCall("CDoc::InitFromData");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetClipboardData
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetClipboardData(DWORD dwReserved, IDataObject **ppDataObject)
{
    TraceCall("CDoc::GetClipboardData");
    
    if (ppDataObject == NULL)
        return TraceResult(E_INVALIDARG);

    *ppDataObject = NULL;
    return TraceResult(E_NOTIMPL);
}

//+---------------------------------------------------------------
//
//  Member:     DoVerb
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    TraceCall("CDoc::DoVerb");
    switch (iVerb)
        {
        case OLEIVERB_SHOW:
        case OLEIVERB_PRIMARY:
            return DoShow(pActiveSite, hwndParent, lprcPosRect);;
        
        case OLEIVERB_INPLACEACTIVATE:
            return Show(TRUE);
        }
  
    return OLEOBJ_S_INVALIDVERB;
}

//+---------------------------------------------------------------
//
//  Member:     EnumVerbs
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    TraceCall("CDoc::EnumVerbs");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Update
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Update()
{
    TraceCall("CDoc::Update");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     IsUpToDate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::IsUpToDate()
{
    TraceCall("CDoc::IsUpToDate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetUserClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetUserClassID(CLSID *pCLSID)
{
    TraceCall("CDoc::GetUserClassID");
	
    if (pCLSID==NULL)
        return TraceResult(E_INVALIDARG);

    *pCLSID = CLSID_MimeEdit;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetUserType
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    TCHAR   szRes[CCHMAX_STRINGRES];
    int     ids;

    TraceCall("CDoc::GetUserType");
   
    if (pszUserType==NULL)
        return TraceResult(E_INVALIDARG);

    *pszUserType = NULL;

    switch (dwFormOfType)
        {
        case USERCLASSTYPE_APPNAME:
            ids = idsUserTypeApp;
            break;

        case USERCLASSTYPE_SHORT:
            ids = idsUserTypeShort;
            break;

        case USERCLASSTYPE_FULL:
            ids = idsUserTypeFull;
            break;

        default:
            return TraceResult(E_INVALIDARG);
        }   

    if (!LoadString(g_hLocRes, ids, szRes, sizeof(szRes)/sizeof(TCHAR)))
        return TraceResult(E_OUTOFMEMORY);

    *pszUserType = PszToUnicode(CP_ACP, szRes);
    return *pszUserType ? S_OK : TraceResult(E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Member:     SetExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    TraceCall("CDoc::SetExtent");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    TraceCall("CDoc::GetExtent");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Advise
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    TraceCall("CDoc::Advise");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Unadvise
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Unadvise(DWORD dwConnection)
{
    TraceCall("CDoc::Unadvise");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     EnumAdvise
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    TraceCall("CDoc::EnumAdvise");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMiscStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    TraceCall("CDoc::GetMiscStatus");
    
    if (pdwStatus==NULL)
        return E_INVALIDARG;    

    *pdwStatus = OLEMISC_INSIDEOUT; // BUGBUG: not sure what to set here
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetColorScheme
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetColorScheme(LOGPALETTE *pLogpal)
{
    TraceCall("CDoc::SetColorScheme");

    return E_NOTIMPL;
}


// *** IOleInPlaceObject ***

//+---------------------------------------------------------------
//
//  Member:     InPlaceDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::InPlaceDeactivate()
{
    TraceCall("CDoc::InPlaceDeactivate");
    
    return DeactivateInPlace();
}

//+---------------------------------------------------------------
//
//  Member:     UIDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::UIDeactivate()
{
    TraceCall("CDoc::UIDeactivate");

    if (m_pBodyObj)
        m_pBodyObj->UIActivate(FALSE);

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetObjectRects
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    TraceCall("CDoc::SetObjectRects");
 
    return SetRect((LPRECT)lprcPosRect);
}

//+---------------------------------------------------------------
//
//  Member:     ReactivateAndUndo
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ReactivateAndUndo()
{
    TraceCall("CDoc::ReactivateAndUndo");
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     GetWindow
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetWindow(HWND *phwnd)
{
    TraceCall("CDoc::GetWindow");

    if (phwnd==NULL)
        return E_INVALIDARG;

    return m_pBodyObj?m_pBodyObj->GetWindow(phwnd):E_FAIL;
}

//+---------------------------------------------------------------
//
//  Member:     ContextSensitiveHelp
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CDoc::ContextSensitiveHelp");
    return E_NOTIMPL;
}



//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::TranslateAccelerator(LPMSG lpmsg)
{
    return m_pBodyObj ? m_pBodyObj->PrivateTranslateAccelerator(lpmsg) : S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     OnFrameWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::OnFrameWindowActivate(BOOL fActivate)
{
    TraceCall("CDoc::OnFrameWindowActivate");
    if (m_pBodyObj)
		m_pBodyObj->OnFrameActivate(fActivate);

	return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnDocWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::OnDocWindowActivate(BOOL fActivate)
{
    TraceCall("CDoc::OnDocWindowActivate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ResizeBorder
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow)
{
    TraceCall("CDoc::ResizeBorder");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     EnableModeless
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnableModeless(BOOL fEnable)
{
    TraceCall("CDoc::EnableModeless");
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    TraceCall("CDoc::QueryStatus");

    if (m_pBodyObj==NULL)
        return TraceResult(E_UNEXPECTED);

    return m_pBodyObj->PrivateQueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
}

//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut)
{
    HRESULT     hr=E_FAIL;

    TraceCall("CDoc::Exec");

    if (m_pBodyObj==NULL)
        return TraceResult(E_UNEXPECTED);

    return m_pBodyObj->PrivateExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
}


//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    TraceCall("CDoc::QueryService");

    if (m_pBodyObj==NULL)
        return TraceResult(E_UNEXPECTED);

    return m_pBodyObj->PrivateQueryService(guidService, riid, ppvObject);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::DoShow
//
//  Synopsis:   response to IOleObject::DoVerb for showing object
//
//---------------------------------------------------------------
HRESULT CDoc::DoShow(IOleClientSite *pActiveSite, HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT     hr;

    TraceCall("CDoc::DoShow");

    if (m_ulState >= OS_INPLACE)        // if we're already running return S_OK
        return S_OK;
    
    if (!IsWindow(hwndParent))
        return OLEOBJ_S_INVALIDHWND;

    if (pActiveSite == NULL)
        return E_INVALIDARG;

    ReplaceInterface(m_pClientSite, pActiveSite);
    m_hwndParent = hwndParent;

    return ActivateView();
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ActivateView
//
//  Synopsis:   Activate an IOleDocumentView
//
//---------------------------------------------------------------
HRESULT CDoc::ActivateView()
{
    HRESULT             hr;
    IOleDocumentSite    *pDocSite;

    TraceCall("CDoc::ActivateView");

    Assert(m_ulState < OS_INPLACE);
    Assert(m_pClientSite);

    if (!FAILED(hr = m_pClientSite->QueryInterface(IID_IOleDocumentSite, (void **)&pDocSite)))
        {
        hr = pDocSite->ActivateMe((IOleDocumentView *)this);
        pDocSite->Release();
        }

    return hr;
}


HRESULT CDoc::Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode)
{
    return m_pBodyObj->Load(fFullyAvailable, pMoniker, pBindCtx, grfMode);
}

HRESULT CDoc::GetCurMoniker(IMoniker **ppMoniker)
{
    return m_pBodyObj->GetCurMoniker(ppMoniker);
}

HRESULT CDoc::Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember)
{
    return m_pBodyObj->Save(pMoniker, pBindCtx, fRemember);
}

HRESULT CDoc::SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx)
{
    return m_pBodyObj->SaveCompleted(pMoniker, pBindCtx);
}

//+---------------------------------------------------------------
//
//  Member:     ActivateInPlace
//
//  Synopsis:   In place activates the object using the std. inplace
//              activation protocol to create the inplace window.
//
//---------------------------------------------------------------
HRESULT CDoc::ActivateInPlace()
{
    HRESULT             hr;
    HWND                hwndSite;
    RECT                rcPos,
                        rcClip;
    OLEINPLACEFRAMEINFO rFrameInfo;

    TraceCall("CDoc::ActivateInPlace");

    if (!m_pClientSite)
        return TraceResult(E_UNEXPECTED);

    if (m_ulState >= OS_INPLACE)        // if we're already running return S_OK
        return S_OK;

    // If we don't already have an inplace site, query for one. Note. we don't yet support 
    // negotiation for a windowless site. We may want to add this code.
    if (!m_pIPSite)
        m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pIPSite);

    if (!m_pIPSite)
        return TraceResult(E_FAIL);

    if (m_pIPSite->CanInPlaceActivate() != S_OK)
        {
        TraceInfo("Container refused In-Place activation!");
        return TraceResult(E_FAIL);        
        }

    Assert(m_pInPlaceFrame==NULL && m_pInPlaceUIWindow==NULL);

    rFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    ZeroMemory(&rcPos, sizeof(RECT));
    ZeroMemory(&rcClip, sizeof(RECT));

    hr = m_pIPSite->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow,  &rcPos, &rcClip, &rFrameInfo);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = m_pIPSite->GetWindow(&hwndSite);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = AttachWin(hwndSite, &rcPos);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    //  Notify our container that we are going in-place active.
    m_ulState = OS_INPLACE;
    m_pIPSite->OnInPlaceActivate();

    if (m_pInPlaceFrame)
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

    if (m_pInPlaceUIWindow)
        m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        
error:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     AttachWin
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::AttachWin(HWND hwndParent, LPRECT lprcPos)
{
    HRESULT		        hr;
	DWORD               dwFlags=MEBF_OUTERCLIENTEDGE|MEBF_FORMATBARSEP;
    VARIANTARG          va;
    IOleCommandTarget   *pCmdTarget;
    BODYHOSTINFO        rHostInfo;

	TraceCall("CDoc::AttachWin");

    if (!IsWindow(hwndParent) || lprcPos == NULL)
        return TraceResult(E_INVALIDARG);

    // get border flags from host before we create the body, so we can fix the client edges
    if (m_pClientSite &&
        m_pClientSite->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
        if (pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_BORDERFLAGS, 0, NULL, &va)==S_OK && va.vt==VT_I4)
            dwFlags = va.lVal;
        pCmdTarget->Release();
        }

	rHostInfo.pInPlaceSite = m_pIPSite;
    rHostInfo.pInPlaceFrame = m_pInPlaceFrame;
    rHostInfo.pDoc = (IOleInPlaceActiveObject *)this;
    
    hr = CreateBodyObject(hwndParent, dwFlags, lprcPos, &rHostInfo, &m_pBodyObj);
	if (FAILED(hr))
		{
		TraceResult(hr);
		goto error;
		}

error:
	return hr;
}


//+---------------------------------------------------------------
//
//  Member:     DeactivateInPlace
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::DeactivateInPlace()
{
    TraceCall("CDoc::DeactivateInPlace");

    if (m_pBodyObj)
        {
        m_pBodyObj->Close();
        m_pBodyObj->Release();
        m_pBodyObj=NULL;
        }

    //  Notify our container that we're in-place deactivating
    if (m_ulState == OS_INPLACE)
        {
        //  The container may reenter us, so need to remember that
        //    we've done almost all the transition to OS_RUNNING

        m_ulState = OS_RUNNING;

        //  Errors from this notification are ignored (in the function
        //    which calls this one); we don't allow our container to stop
        //    us from in-place deactivating

        if (m_pIPSite)
            m_pIPSite->OnInPlaceDeactivate();

        }

    SafeRelease(m_pIPSite);
    SafeRelease(m_pInPlaceFrame);
    SafeRelease(m_pInPlaceUIWindow);
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     ActivateUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ActivateUI()
{
    HRESULT     hr;

    TraceCall("CDoc::ActivateUI");

    if (!m_pIPSite)
        return TraceResult(E_UNEXPECTED);

    m_ulState = OS_UIACTIVE;

    if (FAILED(hr=m_pIPSite->OnUIActivate()))
        {
        //  If the container fails the OnUIActivate call, then we
        //  give up and stay IPA

        if (m_ulState == OS_UIACTIVE)
            m_ulState = OS_INPLACE;

        }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     DeactivateUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::DeactivateUI()
{
    TraceCall("CDoc::DectivateInPlace");

    if (!m_pIPSite)
        return TraceResult(E_UNEXPECTED);

    m_ulState = OS_INPLACE;
    m_pIPSite->OnUIDeactivate(FALSE);
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     GetHostName
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetHostName(LPSTR szTitle, ULONG cch)
{
	TraceCall("CDoc::GetHostName");

    *szTitle = 0;

    if (m_lpszAppName)
        {
        lstrcpyn(szTitle, m_lpszAppName, cch);
        }
    else
        {
        SideAssert(LoadString(g_hLocRes, idsAppName, szTitle, cch));
        }
    return S_OK;
}


#ifdef OFFICE_BINDER
HRESULT CDoc::InitNew(IStorage *pStg)
{
    return S_OK;
}
HRESULT CDoc::Load(IStorage *pStg)
{
    return S_OK;
}

HRESULT CDoc::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    return S_OK;
}

HRESULT CDoc::SaveCompleted(IStorage *pStgNew)
{
    return S_OK;
}

HRESULT CDoc::HandsOffStorage()
{
    return S_OK;
}
#endif

HRESULT CDoc::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

HRESULT CDoc::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    HRESULT hr;

    *pptinfo = NULL;
    
    if (itinfo)
        return DISP_E_BADINDEX;

    hr = EnsureTypeLibrary();
    if (FAILED(hr))
        goto error;

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

error:
    return hr;
}

HRESULT CDoc::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    HRESULT hr;

    hr = EnsureTypeLibrary();
    if (FAILED(hr))
        goto error;

    hr = DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);

error:
    return hr;
}

HRESULT CDoc::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr;

    hr = EnsureTypeLibrary();
    if (FAILED(hr))
        goto error;

    hr = DispInvoke((IDispatch *)this, m_pTypeInfo, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);    

error:
    return hr;
}

// *** IQuickActivate ***
//+---------------------------------------------------------------
//
//  Member:     QuickActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::QuickActivate(QACONTAINER *pQaContainer, QACONTROL *pQaControl)
{
    TraceCall("CDoc::QuickActivate");

    if (pQaControl == NULL || pQaContainer == NULL)
        return E_INVALIDARG;

    pQaControl->cbSize = sizeof(QACONTROL);
    pQaControl->dwMiscStatus = OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE;
    pQaControl->dwViewStatus = 0;
    pQaControl->dwEventCookie = 0;
    pQaControl->dwPropNotifyCookie = 0;
    pQaControl->dwPointerActivationPolicy = 0;

    if (m_pClientSite || pQaContainer->pClientSite==NULL)
        return E_FAIL;

    m_pClientSite = pQaContainer->pClientSite;
    m_pClientSite ->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetContentExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetContentExtent(LPSIZEL pSizel)
{
    TraceCall("CDoc::SetContentExtent");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetContentExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetContentExtent(LPSIZEL pSizel)
{
    TraceCall("CDoc::GetContentExtent");
    return S_OK;
}


HRESULT CDoc::EnsureTypeLibrary()
{
    HRESULT     hr;
    ITypeLib    *pTypeLib;
    
    TraceCall("EnsureTypeLibrary()");

    if (m_pTypeInfo)
        return S_OK;

    hr = GetTypeLibrary(&pTypeLib);
    if (!FAILED(hr))
        {
        hr = pTypeLib->GetTypeInfoOfGuid(IID_IMimeEdit, &m_pTypeInfo);
        pTypeLib->Release();
        }
    return hr;
}

HRESULT CDoc::get_src(BSTR *pbstr)
{
    *pbstr = NULL;
    return E_NOTIMPL;
}

HRESULT CDoc::put_src(BSTR bstr)
{
    IMoniker        *pmk;

    HRESULT         hr;
    IMimeMessage    *pMsg;
    IPersistMoniker    *pPMK;
        
    if (CreateURLMoniker(NULL, bstr, &pmk))
        return E_FAIL;

    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (!FAILED(hr))
        {
        hr = pMsg->QueryInterface(IID_IPersistMoniker, (LPVOID *)&pPMK);
        if (!FAILED(hr))
            {
            hr=pPMK->Load(TRUE, pmk, NULL, STGM_READWRITE);
            if (!FAILED(hr))
                {
                hr = Load(pMsg);
                }
            pPMK->Release();
            } 
        pMsg->Release();
        }            
    return hr;
}

HRESULT CDoc::put_header(LONG lStyle)
{
    VARIANTARG va;

    va.vt = VT_I4;
    va.lVal = lStyle;
    return m_pBodyObj?m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, &va, NULL):E_FAIL;
}
 
HRESULT CDoc::put_editMode(VARIANT_BOOL b)
{
    VARIANTARG va;

    va.vt = VT_BOOL;
    va.boolVal = b;
    return m_pBodyObj?m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_EDITMODE, OLECMDEXECOPT_DODEFAULT, &va, NULL):E_FAIL;
}

HRESULT CDoc::get_editMode(VARIANT_BOOL *pbool)
{
    VARIANTARG va;
    
    TraceCall("CDoc::get_editMode");

    if (m_pBodyObj &&
        m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_EDITMODE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
        {
        Assert(va.vt == VT_BOOL);
        *pbool = va.boolVal;
        return S_OK;
        }
    return TraceResult(E_FAIL);
}


HRESULT CDoc::get_messageSource(BSTR *pbstr)
{
    IMimeMessage    *pMsg;
    IStream         *pstm;
    HRESULT         hr=E_FAIL;

    if (MimeOleCreateMessage(NULL, &pMsg)==S_OK)
        {
        if (!FAILED(Save(pMsg, MECD_HTML|MECD_PLAINTEXT|MECD_ENCODEIMAGES|MECD_ENCODESOUNDS)) &&
            pMsg->Commit(0)==S_OK && 
            pMsg->GetMessageSource(&pstm, 0)==S_OK)
            {
            hr = HrIStreamToBSTR(GetACP(), pstm, pbstr);
            pstm->Release();
            }
        pMsg->Release();
        }
    return hr;
}

HRESULT CDoc::get_text(BSTR *pbstr)
{
    IStream *pstm;

    *pbstr = NULL;
    if (GetBodyStream(m_pBodyObj->GetDoc(), FALSE, &pstm)==S_OK)
        {
        HrIStreamToBSTR(NULL, pstm, pbstr);
        pstm->Release();
        }
    return S_OK;
}

HRESULT CDoc::get_html(BSTR *pbstr)
{
// BUGBUGBUG: hack for HOTMAIL page demo
    IStream     *pstm;
    HCHARSET    hCharset;

    *pbstr = NULL;
    
    MimeOleGetCodePageCharset(1252, CHARSET_BODY, &hCharset);
    m_pBodyObj->SetCharset(hCharset);

    if (GetBodyStream(m_pBodyObj->GetDoc(), TRUE, &pstm)==S_OK)
        {
        HrIStreamToBSTR(NULL, pstm, pbstr);
        pstm->Release();
        }
    return S_OK;
// BUGBUGBUG: hack for HOTMAIL page demo
}

HRESULT CDoc::get_doc(IDispatch **ppDoc)
{
    *ppDoc = 0;
    if (m_pBodyObj)
        (m_pBodyObj->GetDoc())->QueryInterface(IID_IDispatch, (LPVOID *)ppDoc);
    return S_OK;
}

 

HRESULT CDoc::get_header(LONG *plStyle)
{
    VARIANTARG va;
    HRESULT     hr;

    if (!m_pBodyObj)
        return E_FAIL;

    hr = m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, NULL, &va);
    *plStyle = va.lVal;
    return hr;
}

HRESULT CDoc::clear()
{
    if (m_pBodyObj)
        m_pBodyObj->UnloadAll();
 
    return S_OK;
}

 


HRESULT CDoc::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT         hr;
    IMimeMessage    *pMsg;
    IPersistFile    *pPF;
        
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (!FAILED(hr))
        {
        hr = pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF);
        if (!FAILED(hr))
            {
            hr = pPF->Load(pszFileName, dwMode);
            if (!FAILED(hr))
                {
                hr = Load(pMsg);
                }
            pPF->Release();
            } 
        pMsg->Release();
        }            
    return hr;
}

HRESULT CDoc::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

HRESULT CDoc::SaveCompleted(LPCOLESTR pszFileName)
{
    return S_OK;
}

HRESULT CDoc::GetCurFile(LPOLESTR * ppszFileName)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\body.h ===
#ifndef _BODY_H
#define _BODY_H

/*
 * includes
 */

#include "dochost.h"

/*
 * forward references
 */
interface IHTMLTxtRange;
interface IHTMLElement;
interface IHTMLDocument2;
interface IMoniker;
interface IHTMLBodyElement;
interface IDocHostUIHandler;
interface ITargetFrame2;
interface ITargetFramePriv;

class CBody;
class CFmtBar;
class CAttMenu;
class CSecManager;
class CMsgSource;
class CSpell;

/*
 * constants
 */

enum
{
    BI_MESSAGE,
    BI_MONIKER 
};

/*
 * typedefs
 */
typedef struct BODYINITDATA_tag
{
    DWORD   dwType;
    union
        {
        IMimeMessage    *pMsg;
        IMoniker        *pmk;
        };
}   BODYINITDATA, * LPBODYINITDATA;

typedef CBody *LPBODYOBJ;

typedef struct BODYHOSTINFO_tag
{
    IOleInPlaceSite         *pInPlaceSite;
    IOleInPlaceFrame        *pInPlaceFrame;
    IOleInPlaceActiveObject *pDoc;
} BODYHOSTINFO, *PBODYHOSTINFO;

/*
 * objects
 */

class CBody :
    public CDocHost,
    public IPropertyNotifySink,
    public IDocHostUIHandler,
    public IPersistMime,
    public ITargetFramePriv,
    public IPersistMoniker,
    public IFontCacheNotify
#if 0
    public IDispatch

#endif
{
public:
    CBody();
    virtual ~CBody();


    // override QI to add IBodyObj
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IPersist     
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pCLSID);

    // IPersistMime
    virtual HRESULT STDMETHODCALLTYPE Load(IMimeMessage *pMsg);
    virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwFlags);

    // IPersistMoniker Members
    virtual HRESULT STDMETHODCALLTYPE Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode);
    virtual HRESULT STDMETHODCALLTYPE GetCurMoniker(IMoniker **ppMoniker) {return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember) {return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx) {return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE IsDirty();

    // IPropertyNotifySink
    virtual HRESULT STDMETHODCALLTYPE OnChanged(DISPID dispid);
    virtual HRESULT STDMETHODCALLTYPE OnRequestEdit (DISPID dispid);

    // DocHostUIHandler
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO * pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI(DWORD dwID, IOleInPlaceActiveObject * pActiveObject, IOleCommandTarget * pCommandTarget, IOleInPlaceFrame * pFrame, IOleInPlaceUIWindow * pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI(void);
    virtual HRESULT STDMETHODCALLTYPE UpdateUI(void);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow * pUIWindow,BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR * pbstrKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu(DWORD dwID, POINT* ppt, IUnknown* pcmdtReserved, IDispatch* pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpMsg, const GUID * pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDispatch);        
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // ITargetFramePriv
    virtual HRESULT STDMETHODCALLTYPE FindFrameDownwards(LPCWSTR pszTargetName, DWORD dwFlags, IUnknown **ppunkTargetFrame);
    virtual HRESULT STDMETHODCALLTYPE FindFrameInContext(LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame) ;
    virtual HRESULT STDMETHODCALLTYPE OnChildFrameActivate(IUnknown *pUnkChildFrame);
    virtual HRESULT STDMETHODCALLTYPE OnChildFrameDeactivate(IUnknown *pUnkChildFrame);
    virtual HRESULT STDMETHODCALLTYPE NavigateHack(DWORD grfHLNF,LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation);
    virtual HRESULT STDMETHODCALLTYPE FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser);

    // *** IFontCacheNotify ***
    virtual HRESULT STDMETHODCALLTYPE OnPreFontChange();
    virtual HRESULT STDMETHODCALLTYPE OnPostFontChange();

#if 0
    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);
#endif

    // override CDocHost members
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT GetDocObjSize(LPRECT prc);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
    HRESULT Init(HWND hwnd, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo);
    HRESULT Close();
    HRESULT UnloadAll();

    HRESULT SetRect(LPRECT prc);
    HRESULT GetRect(LPRECT prc);
    HRESULT UIActivate(BOOL fUIActivate);
    HRESULT LoadStream(LPSTREAM pstm);

    HRESULT OnFrameActivate(BOOL fActivate);

    HRESULT PrivateQueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);
    HRESULT PrivateQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    HRESULT PrivateExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT PrivateTranslateAccelerator(LPMSG lpmsg);
    HRESULT PrivateEnableModeless(BOOL fEnable);
    HRESULT SetParentSites(IOleInPlaceSite *pInPlaceSite, IOleInPlaceFrame *pInPlaceFrame, IOleInPlaceActiveObject *pDoc);

    IHTMLDocument2  *GetDoc(){return m_pDoc;};

    HRESULT SetCharset(HCHARSET hCharset);
    HRESULT GetSelection(IHTMLTxtRange **ppRange);

private:
    DWORD                       m_dwStyle,
                                m_dwNotify,
                                m_dwReadyState,
                                m_cchTotal,
                                m_dwAutoTicks,
                                m_dwFontCacheNotify;
    HCHARSET                    m_hCharset;
    BOOL                        m_fEmpty            : 1,
                                m_fDirty            : 1,
                                m_fDesignMode       : 1,
                                m_fAutoDetect       : 1,
                                m_fPlainMode        : 1,
                                m_fMessageParsed    : 1,
                                m_fOnImage          : 1,
                                m_fLoading          : 1,
                                m_fTabLinks         : 1,
                                m_fSrcTabs          : 1,
                                m_fBkgrndSpelling   : 1,
                                m_fReloadingSrc     : 1,    // reloading source-view
                                m_fWasDirty         : 1,    // used by source-tabs to remember state of edit-mode
                                m_fForceCharsetLoad : 1,    // used when replying and don't keep message body
                                m_fIgnoreAccel      : 1;
    IMimeMessage                *m_pMsg;
    IMimeMessageW               *m_pMsgW;
    IHTMLDocument2              *m_pDoc;
    LPWSTR                      m_pszUrlW;     
    LPTEMPFILEINFO              m_pTempFileUrl;
    ULONG                       m_cchStart,
                                m_uHdrStyle,
                                m_cyPreview,
                                m_cVisibleBtns;
    IDocHostUIHandler          *m_pParentDocHostUI;
    IOleCommandTarget          *m_pParentCmdTarget;
    LPOLEINPLACESITE            m_pParentInPlaceSite;
    LPOLEINPLACEFRAME           m_pParentInPlaceFrame;
    CMsgSource                  *m_pSrcView;
    HWND                        m_hwndBtnBar,
                                m_hwndTab,
                                m_hwndSrc;
    LPSTR                       m_pszLayout;
    LPWSTR                      m_pszFrom,
                                m_pszTo,
                                m_pszCc, 
                                m_pszSubject;
    CFmtBar                    *m_pFmtBar;
    CSpell                     *m_pSpell;
    IHTMLTxtRange              *m_pRangeIgnoreSpell;
    IFontCache                 *m_pFontCache;
    IOleInPlaceActiveObject    *m_pDocActiveObj;
    CAttMenu                   *m_pAttMenu;
    HIMAGELIST                  m_hIml,
                                m_hImlHot;
    CSecManager                 *m_pSecMgr;
    ULONG                       m_uSrcView;
    IDispatch                   *m_pDispContext;
    DWORD                       m_dwContextItem;
    LPSTREAM                    m_pstmHtmlSrc;
    IHashTable                 *m_pHashExternal;
    IMarkupPointer             *m_pAutoStartPtr;

#ifdef PLUSPACK
    // Background speller
	IHTMLSpell					*m_pBkgSpeller;
#endif //PLUSPACK

    // notifications
    void OnReadyStateChanged();
    void OnDocumentReady();
    HRESULT OnWMCommand(HWND hwnd, int id, WORD wCmd);
    HRESULT OnPaint();
    HRESULT OnEraseBkgnd(HDC hdc);
    void WMSize(int x, int y);
    LRESULT WMNotify(WPARAM wParam, NMHDR* pnmhdr);
    HRESULT OnWMCreate();

    // load functions
    HRESULT RegisterLoadNotify(BOOL fRegister);
    HRESULT EnsureLoaded();
    HRESULT LoadFromData(LPBODYINITDATA pbiData);
    HRESULT LoadFromMoniker(IMoniker *pmk, HCHARSET hCharset);

    // Auto-Detect
    HRESULT AutoDetectTimer();
    HRESULT StopAutoDetect();
    HRESULT StartAutoDetect();
    HRESULT UrlHighlight(IHTMLTxtRange *pRange);

    // Trident OM helper functions
    HRESULT DeleteElement(IHTMLElement *pElem);
    HRESULT ReplaceElement(LPCTSTR pszName, BSTR bstrPaste, BOOL fHtml);
    HRESULT SelectElement(IHTMLElement *pElem, BOOL fScrollIntoView);
    HRESULT CreateRangeFromElement(IHTMLElement *pElem, IHTMLTxtRange **ppRange);
    HRESULT CreateRange(IHTMLTxtRange **ppRange);
    HRESULT GetElement(LPCTSTR pszName, IHTMLElement **ppElem);
    HRESULT GetBodyElement(IHTMLBodyElement **ppBody);
    HRESULT GetSelectedAnchor(BSTR* pbstr);
    HRESULT InsertTextAtCaret(BSTR bstr, BOOL fHtml, BOOL fMoveCaretToEnd);
    HRESULT InsertStreamAtCaret(LPSTREAM pstm, BOOL fHtml);
    HRESULT InsertBodyText(BSTR bstrPaste, DWORD dwFlags);
    HRESULT _CreateRangePointer(IMarkupPointer **pPtr);
    HRESULT _UrlHighlightBetweenPtrs(IMarkupPointer *pStartPtr, IMarkupPointer *pEndPtr);
    HRESULT _MovePtrByCch(IMarkupPointer *pPtr, LONG *pcp);

    // Printing
    HRESULT Print(BOOL fPrompt, VARIANTARG *pvaIn);

    // menu helpers
    HRESULT UpdateContextMenu(HMENU hmenuEdit, BOOL fEnableProperties, IDispatch *pDisp);
    HRESULT AppendAnchorItems(HMENU hMenu, IDispatch *pDisp);

    // verb supports
    HRESULT AddToWab();
    HRESULT AddToFavorites();
    HRESULT ViewSource(BOOL fMessage);
    HRESULT DoRot13();
    HRESULT SetStyle(ULONG uStyle);
    DWORD DwChooseProperties();
    HRESULT UpdateCommands();
    HRESULT ShowFormatBar(BOOL fOn);
    HRESULT SetDesignMode(BOOL fOn);
    HRESULT SetPlainTextMode(BOOL fOn);
    HRESULT InsertFile(BSTR bstrFileName);
    HRESULT FormatFont();
    HRESULT FormatPara();
    HRESULT DowngradeToPlainText(BOOL fForceFixedFont);
    HRESULT SetDocumentText(BSTR bstr);
    HRESULT ApplyDocumentVerb(VARIANTARG *pvaIn);
    HRESULT ApplyDocument(IHTMLDocument2 *pDoc);
    HRESULT SaveAttachments();
    HRESULT _OnSaveImage();
    BOOL    IsEmpty();
    HRESULT SafeToEncodeText(ULONG ulCodePage);

    // edit mode support
    HRESULT SetComposeFont(BSTR bstr);
    HRESULT SetHostComposeFont();
    HRESULT PasteReplyHeader();
    HRESULT FormatBlockQuote(COLORREF crTextColor);
    HRESULT GetAutoText(BSTR *pbstr, BOOL *pfTop);
    HRESULT PasteAutoText();
    HRESULT GetHostFlags(LPDWORD pdwFlags);
    HRESULT SetWindowBgColor(BOOL fForce);
    HRESULT InsertBackgroundSound();

    // other
    HRESULT GetWebPageOptions(WEBPAGEOPTIONS *pOptions, BOOL *pfIncludeMsg);
    HRESULT CreateFontCache(LPCSTR pszTridentKey);
    HRESULT HrFormatParagraph();

    // preview pane mode helpers
    HRESULT RecalcPreivewHeight(HDC hdc);
    HRESULT UpdatePreviewLabels();
    LONG lGetClientHeight();
    HRESULT Resize();
    void OutputHeaderText(HDC hdc, LPWSTR psz, int *pcxPos, int cyPos, int cxMax, ULONG uFlags);
    LONG lGetLineHeight(HDC hdc);

    // MHTML saving helpers
    HRESULT ClearDirtyFlag();
    HRESULT ClearUndoStack();
    HRESULT DoHostProperties();
    HRESULT SaveAsStationery(VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT TagUnreferencedImages();
    HRESULT GetBackgroundColor(DWORD *pdwColor);
    HRESULT SetBackgroundColor(DWORD dwColor);
    HRESULT SearchForCIDUrls();

    HRESULT UpdateBtnBar();

    HRESULT InitToolbar();
    HRESULT UpdateButtons();
    HRESULT ShowAttachMenu(BOOL fRightClick);
    HRESULT ShowPreview(BOOL fOn);
    HRESULT PointFromButton(int idm, POINT *ppt);
    HRESULT EnsureAttMenu();
    HRESULT EnableSounds(BOOL fOn);

    // source editing mode helpers
    HRESULT ShowSourceView(ULONG uSrcView);
    HRESULT ShowSourceTabs(BOOL fOn);
    HRESULT SetSourceTabs(ULONG ulTab);
    HRESULT IsColorSourceEditing();

    // spellchecker
    HRESULT HrCreateSpeller(BOOL fBkgrnd);
    HRESULT _ReloadWithHtmlSrc(IStream *pstm);
    HRESULT _EnsureSrcView();
};


HRESULT CreateBodyObject(HWND hwnd, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo, LPBODYOBJ *ppBodyObj);


#endif //_BODY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\dochost.cpp ===
/*
 *    d o c h o s t . c p p
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "strconst.h"
#include "msoert.h"
#include "dochost.h"
#include "oleutil.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

/*
 *  t y p e d e f s
 */

/*
 *  g l o b a l s 
 */

/*
 *  f u n c t i o n   p r o t y p e s
 */

/*
 *  f u n c t i o n s
 */




//+---------------------------------------------------------------
//
//  Member:     CDocHost
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDocHost::CDocHost()
{
/*
    Not initialised
    Member:                 Initialised In:
    --------------------+---------------------------
*/
    m_cRef=1;
    m_hwnd=0;
    m_pDocView=0;
    m_lpOleObj=0;
    m_pCmdTarget=0;
    m_hwndDocObj=NULL;
    m_fUIActive=FALSE;
    m_fFocus=FALSE;
    m_fDownloading=FALSE;
    m_fCycleFocus=FALSE;
    m_pInPlaceActiveObj = NULL;
    m_dwFrameWidth = 0;
    m_dwFrameHeight = 0;
}

//+---------------------------------------------------------------
//
//  Member:     
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDocHost::~CDocHost()
{
    // These should all get feed up when we get a WM_DESTROY and close the docobj
    Assert(m_lpOleObj==NULL);
    Assert(m_pDocView==NULL);
    Assert(m_pInPlaceActiveObj==NULL);
    Assert(m_pCmdTarget==NULL);
}

//+---------------------------------------------------------------
//
//  Member:     AddRef
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CDocHost::AddRef()
{
    TraceCall("CDocHost::AddRef");

    //TraceInfo(_MSG("CDocHost::AddRef: cRef==%d", m_cRef+1));
    return ++m_cRef;
}

//+---------------------------------------------------------------
//
//  Member:     Release
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CDocHost::Release()
{
    TraceCall("CDocHost::Release");
    
    //TraceInfo(_MSG("CDocHost::Release: cRef==%d", m_cRef-1));    
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


//+---------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CDocHost::QueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    //DebugPrintInterface(riid, "CDocHost");

    if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *lplpObj = (LPVOID)(IOleInPlaceUIWindow *)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *lplpObj = (LPVOID)(LPOLEINPLACESITE)this;

    else if (IsEqualIID(riid, IID_IOleClientSite))
        *lplpObj = (LPVOID)(LPOLECLIENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleControlSite))
        *lplpObj = (LPVOID)(IOleControlSite *)this;

    else if (IsEqualIID(riid, IID_IAdviseSink))
        *lplpObj = (LPVOID)(LPADVISESINK)this;

    else if (IsEqualIID(riid, IID_IOleDocumentSite))
        *lplpObj = (LPVOID)(LPOLEDOCUMENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(LPSERVICEPROVIDER)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     ExtWndProc
//
//  Synopsis:   
//
//---------------------------------------------------------------
LRESULT CALLBACK CDocHost::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPDOCHOST pDocHost;

    if(msg==WM_CREATE)
        {
        pDocHost=(CDocHost *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pDocHost)
            return -1;

        if(FAILED(pDocHost->OnCreate(hwnd)))
            return -1;
        }
    
    pDocHost = (LPDOCHOST)GetWndThisPtr(hwnd);
    if(pDocHost)
        return pDocHost->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member:     WndProc
//
//  Synopsis:   
//
//---------------------------------------------------------------
LRESULT CDocHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
        {

        case WM_SETFOCUS:
            if(m_pDocView)
                m_pDocView->UIActivate(TRUE);
            break;

        case WM_SIZE:
            WMSize(LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_CLOSE:
            return 0;   // prevent alt-f4's

        case WM_DESTROY:
            OnDestroy();
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (m_hwndDocObj)
                return SendMessage(m_hwndDocObj, msg, wParam, lParam);
            break;
            
        case WM_USER + 1:
            // Hook for testing automation
            // copy the contents of trident onto the clipboard.
            return CmdSelectAllCopy(m_pCmdTarget);
        }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member:     OnNCDestroy
//
//  Synopsis:   
//

//+---------------------------------------------------------------
//
//  Member:     OnNCDestroy
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnNCDestroy()
{
    TraceCall("CDocHost::OnNCDestroy");
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnDestroy
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnDestroy()
{
    TraceCall("CDocHost::OnDestroy");

    return CloseDocObj();
}


//+---------------------------------------------------------------
//
//  Member:     OnCreate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnCreate(HWND hwnd)
{
    TraceCall("CDocHost::OnCreate");

    m_hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)this);
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CreateDocObj
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CreateDocObj(LPCLSID pCLSID)
{
    HRESULT             hr=NOERROR;

    TraceCall("CDocHost::CreateDocObj");

    if(!pCLSID)
        return E_INVALIDARG;

    Assert(!m_lpOleObj);
    Assert(!m_pDocView);
    Assert(!m_pCmdTarget);

    hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                        IID_IOleObject, (LPVOID *)&m_lpOleObj);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = m_lpOleObj->SetClientSite((LPOLECLIENTSITE)this);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = m_lpOleObj->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pCmdTarget);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = HrInitNew(m_lpOleObj);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

error:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     Show
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Show()
{
    RECT                rc;
    HRESULT             hr;

    TraceCall("CDocHost::Show");

    GetClientRect(m_hwnd, &rc);
    GetDocObjSize(&rc);
  
    hr=m_lpOleObj->DoVerb(OLEIVERB_SHOW, NULL, (LPOLECLIENTSITE)this, 0, m_hwnd, &rc);
    if(FAILED(hr))
        goto error;
error:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     CloseDocObj
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CloseDocObj()
{
    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    TraceCall("CDocHost::CloseDocObj");

    SafeRelease(m_pCmdTarget);

    if(m_pDocView)
        {
        m_pDocView->UIActivate(FALSE);
        m_pDocView->CloseView(0);
        m_pDocView->SetInPlaceSite(NULL);
        m_pDocView->Release();
        m_pDocView=NULL;
        }

    if (m_lpOleObj)
        {
        // deactivate the docobj
        if (!FAILED(m_lpOleObj->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&pInPlaceObj)))
            {
            pInPlaceObj->InPlaceDeactivate();
            pInPlaceObj->Release();
            }
        
        // close the ole object, but blow off changes as we have either extracted 
        // them ourselves or don't care.
        m_lpOleObj->Close(OLECLOSE_NOSAVE);
#ifdef DEBUG
        ULONG   uRef;
        uRef=
#endif
        m_lpOleObj->Release();
        m_lpOleObj=NULL;
        AssertSz(uRef==0, "We leaked a docobject!");
        }

    m_fDownloading=FALSE;
    m_fFocus=FALSE;
    m_fUIActive=FALSE;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Init(HWND hwndParent, BOOL fBorder, LPRECT prc)
{
    HRESULT     hr=S_OK;
    HWND        hwnd;
    WNDCLASSW   wc;

    TraceCall("CDocHost::Init");

    if(!IsWindow(hwndParent))
        return E_INVALIDARG;

    if (!GetClassInfoWrapW(g_hLocRes, c_wszDocHostWndClass, &wc))
        {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        wc.lpfnWndProc   = (WNDPROC)CDocHost::ExtWndProc;
        wc.hInstance     = g_hLocRes;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_wszDocHostWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.style = CS_DBLCLKS;

        if(!RegisterClassWrapW(&wc))
            return E_OUTOFMEMORY;
        }

    hwnd=CreateWindowExWrapW(WS_EX_NOPARENTNOTIFY|(fBorder?WS_EX_CLIENTEDGE:0),
                        c_wszDocHostWndClass, 
                        NULL,
                        WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_CHILD|WS_TABSTOP|WS_VISIBLE,
                        prc->left, 
                        prc->right,
                        prc->right-prc->left, 
                        prc->bottom-prc->top, 
                        hwndParent, 
                        NULL, 
                        g_hLocRes, 
                        (LPVOID)this);
    if(!hwnd)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

    SetWindowPos(m_hwnd, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOZORDER);

error:
    return hr;
}


// *** IOleWindow ***

//+---------------------------------------------------------------
//
//  Member:     GetWindow
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetWindow(HWND *phwnd)
{
    TraceCall("CDocHost::GetWindow");
    *phwnd=m_hwnd;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     ContextSensitiveHelp
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CDocHost::ContextSensitiveHelp");
    return E_NOTIMPL;
}

// *** IOleInPlaceUIWindow methods ***
//+---------------------------------------------------------------
//
//  Member:     GetBorder
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetBorder(LPRECT lprectBorder)
{
    TraceCall("CDocHost::GetBorder");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestBorderSpace
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    TraceCall("CDocHost::RequestBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetBorderSpace
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    TraceCall("CDocHost::IOleInPlaceUIWindow::SetBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetActiveObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    TraceCall("CDocHost::IOleInPlaceUIWindow::SetActiveObject");

    ReplaceInterface(m_pInPlaceActiveObj, pActiveObject);
    return S_OK;
}

    // *** IOleInPlaceFrame methods ***

//+---------------------------------------------------------------
//
//  Member:     CDocHost::InsertMenus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS)
{
    TraceCall("CDocHost::InsertMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::SetMenu
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetMenu(HMENU, HOLEMENU, HWND)
{
    TraceCall("CDocHost::SetMenu");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::RemoveMenus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::RemoveMenus(HMENU)
{
    TraceCall("CDocHost::RemoveMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::SetStatusText
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetStatusText(LPCOLESTR pszW)
{
    TraceCall("CDocHost::SetStatusText");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::EnableModeless
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::EnableModeless(BOOL fEnable)
{
    TraceCall("CDocHost::EnableModeless");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::TranslateAccelerator
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::TranslateAccelerator(LPMSG, WORD)
{
    TraceCall("CDocHost::TranslateAccelerator");
    return E_NOTIMPL;
}




// **** IOleInPlaceSite methods ****

//+---------------------------------------------------------------
//
//  Member:     CanInPlaceActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CanInPlaceActivate()
{
    TraceCall("CDocHost::IOleInPlaceSite::CanInPlaceActivate");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnInPlaceActivate()
{
    LPOLEINPLACEACTIVEOBJECT    pInPlaceActive;

    TraceCall("CDocHost::OnInPlaceActivate");

    Assert(m_lpOleObj);

    if (m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pInPlaceActive)==S_OK)
        {
        SideAssert((pInPlaceActive->GetWindow(&m_hwndDocObj)==NOERROR)&& IsWindow(m_hwndDocObj));
        pInPlaceActive->Release();
        }
    
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnUIActivate()
{
    TraceCall("CDocHost::OnUIActivate");
    m_fUIActive=TRUE;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     GetWindowContext
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetWindowContext( IOleInPlaceFrame    **ppFrame,
                                    IOleInPlaceUIWindow **ppDoc,
                                    LPRECT              lprcPosRect, 
                                    LPRECT              lprcClipRect,
                                    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    TraceCall("CDocHost::IOleInPlaceSite::GetWindowContext");

    *ppFrame = (LPOLEINPLACEFRAME)this;
    AddRef();

    *ppDoc = NULL;

    GetClientRect(m_hwnd, lprcPosRect);
    GetDocObjSize(lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     Scroll
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Scroll(SIZE scrollExtent)
{
    // the docobject consumes the entireview, so scroll requests
    // are meaningless. Return NOERROR to indicate that they're scolled
    // into view.
    TraceCall("CDocHost::IOleInPlaceSite::Scroll");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnUIDeactivate(BOOL fUndoable)
{
    TraceCall("CDocHost::OnUIDeactivate");
    m_fUIActive=FALSE;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnInPlaceDeactivate()
{
    TraceCall("CDocHost::OnInPlaceDeactivate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     DiscardUndoState
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::DiscardUndoState()
{
    TraceCall("CDocHost::IOleInPlaceSite::DiscardUndoState");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     DeactivateAndUndo
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::DeactivateAndUndo()
{
    TraceCall("CDocHost::IOleInPlaceSite::DeactivateAndUndo");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnPosRectChange
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnPosRectChange(LPCRECT lprcPosRect)
{
    TraceCall("CDocHost::IOleInPlaceSite::OnPosRectChange");
    return E_NOTIMPL;
}


// IOleClientSite methods.

//+---------------------------------------------------------------
//
//  Member:     SaveObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SaveObject()
{
    TraceCall("CDocHost::IOleClientSite::SaveObject");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppmnk)
{
    TraceCall("CDocHost::IOleClientSite::GetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetContainer
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetContainer(LPOLECONTAINER *ppCont)
{
    TraceCall("CDocHost::IOleClientSite::GetContainer");
    if(ppCont)
        *ppCont=NULL;
    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member:     ShowObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ShowObject()
{
    // always shown. 
    // $TODO: do we need to restore the browser here if it is
    // minimised?
    TraceCall("CDocHost::IOleClientSite::ShowObject");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnShowWindow
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnShowWindow(BOOL fShow)
{
    TraceCall("CDocHost::IOleClientSite::OnShowWindow");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestNewObjectLayout
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::RequestNewObjectLayout()
{
    TraceCall("CDocHost::IOleClientSite::RequestNewObjectLayout");
    return E_NOTIMPL;
}

// IOleDocumentSite

//+---------------------------------------------------------------
//
//  Member:     ActivateMe
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ActivateMe(LPOLEDOCUMENTVIEW pViewToActivate)
{
    TraceCall("CDocHost::IOleDocumentSite::ActivateMe");
    return CreateDocView();
}


//+---------------------------------------------------------------
//
//  Member:     CreateDocView
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CreateDocView()
{
    HRESULT         hr;
    LPOLEDOCUMENT   pOleDoc=NULL;

    TraceCall("CDocHost::CreateDocView");
    AssertSz(!m_pDocView, "why is this still set??");
    AssertSz(m_lpOleObj, "uh? no docobject at this point?");

    hr=OleRun(m_lpOleObj);
    if(FAILED(hr))
        goto error;
    
    hr=m_lpOleObj->QueryInterface(IID_IOleDocument, (LPVOID*)&pOleDoc);
    if(FAILED(hr))
        goto error;

    hr=pOleDoc->CreateView(this, NULL,0,&m_pDocView);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->SetInPlaceSite(this);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->Show(TRUE);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pOleDoc);
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG ul;

    TraceCall("CDocHost::CDocHost::QueryStatus");

    if (!rgCmds)
        return E_INVALIDARG;

    if (pguidCmdGroup == NULL)
        {
        TraceInfo("IOleCmdTarget::QueryStatus - std group");
        DebugPrintCmdIdBlock(cCmds, rgCmds);

        for (ul=0;ul<cCmds; ul++)
            {
            switch (rgCmds[ul].cmdID)
                {
                case OLECMDID_OPEN:
                case OLECMDID_SAVE:
                case OLECMDID_PRINT:
                    rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
                }
            }

        /* for now we deal only with status text*/
        if (pCmdText)
            {
            if (!(pCmdText->cmdtextf & OLECMDTEXTF_STATUS))
                {
                pCmdText->cmdtextf = OLECMDTEXTF_NONE;// is this needed?
                pCmdText->cwActual = 0;
                return NOERROR;
                }
            }
        return NOERROR;
        }

    TraceInfo("IOleCmdTarget::QueryStatus - unknown group");
    return OLECMDERR_E_UNKNOWNGROUP;
}

//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,    VARIANTARG *pvaOut)
{
    TraceCall("CDocHost::Exec");

    if (pguidCmdGroup == NULL)
        {
        switch(nCmdID)
            {
             case OLECMDID_SETDOWNLOADSTATE:
                if(pvaIn->vt==VT_I4)
                    {
                    m_fDownloading=pvaIn->lVal;
                    return S_OK;
                    }
                break;

            case OLECMDID_UPDATECOMMANDS:
                OnUpdateCommands();
                break;

            case OLECMDID_SETPROGRESSPOS:
                // when done downloading trident now hits us with a 
                // setprogresspos == -1 to indicate we should remove the "Done"
                if (pvaIn->lVal == -1)
                    SetStatusText(NULL);
                return S_OK;

            case OLECMDID_SETPROGRESSTEXT:
                if(pvaIn->vt == (VT_BSTR))
                    SetStatusText((LPCOLESTR)pvaIn->bstrVal);
                return S_OK;

            default:
                return OLECMDERR_E_NOTSUPPORTED;
            }
        }
    return OLECMDERR_E_UNKNOWNGROUP;
}

//+---------------------------------------------------------------
//
//  Member:     WMSize
//
//  Synopsis:   
//
//---------------------------------------------------------------
void CDocHost::WMSize(int cxBody, int cyBody)
{
    RECT rc={0};

    TraceCall("CDocHost::WMSize");

    if(m_pDocView)
        {
        rc.bottom=cyBody;
        rc.right=cxBody;

        // give the subclass a chance to override the size of the
        // docobj
        GetDocObjSize(&rc);
#ifndef WIN16  //Trident RECTL
        m_pDocView->SetRect(&rc);
#else
        RECTL  rc2 = { rc.left, rc.top, rc.right, rc.bottom };
        m_pDocView->SetRect((LPRECT)&rc2);
#endif
        }

} 



//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    TraceCall("CDocHost::QueryService");

    //DebugPrintInterface((REFIID)riid, "CDocHost::QueryService");
    return E_UNEXPECTED;
}


// *** IOleControlSite *** 

//+---------------------------------------------------------------
//
//  Member:     OnControlInfoChanged
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnControlInfoChanged()
{
    TraceCall("CDocHost::OnControlInfoChanged");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     LockInPlaceActive
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::LockInPlaceActive(BOOL fLock)
{
    TraceCall("CDocHost::LockInPlaceActive");
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     GetExtendedControl
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetExtendedControl(LPDISPATCH *ppDisp)
{
    TraceCall("CDocHost::GetExtendedControl");

    if (ppDisp)
        *ppDisp=NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TransformCoords
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
{
    TraceCall("CDocHost::TransformCoords");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
// Synopsis:   
//
// this is a little trippy, so bear with me. When we get a tab, and trident is UIActive we always pass it off to them
// if it tabs off the end of its internal tab order (a list of urls for instance) then we get hit with a VK_TAB in our
// IOleControlSite::TranslateAccel. If so then we set m_fCycleFocus to TRUE and return S_OK to indicate we took the tab
// tridents IOIPAO::TranslateAccel returns S_OK to indicate it snagged the TAB, we then detect if we set cyclefocus to true
// there and if so, we return S_FALSE from CBody::HrTranslateAccel to indicate to the browser that we didn't take it and it
// move the focus on
//
//---------------------------------------------------------------
HRESULT CDocHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
    TraceCall("CDocHost::TranslateAccelerator");
    if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB)
        {
        m_fCycleFocus=TRUE;
        return S_OK;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnFocus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnFocus(BOOL fGotFocus)
{
    TraceCall("CDocHost::OnFocus");

    m_fFocus = fGotFocus;

    // the docobj has focus now, be sure to send a notification
    // to the parent of the dochost so that in the case of the
    // mailview, it can call OnViewActivate
#if 0
    // BUGBUG needed here??
    NMHDR nmhdr;
    
    nmhdr.hwndFrom = m_hwnd;
    nmhdr.idFrom = GetDlgCtrlID(m_hwnd);
    nmhdr.code = m_fFocus ? NM_SETFOCUS : NM_KILLFOCUS;
    SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
#endif
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ShowPropertyFrame
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ShowPropertyFrame(void)
{
    TraceCall("CDocHost::ShowPropertyFrame");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnUpdateCommands
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnUpdateCommands()
{
    TraceCall("CDocHost::OnUpdateCommands");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\doc.h ===
/*
 *    d o c . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _DOC_H
#define _DOC_H

#include "privunk.h"
#include "mimeedit.h"

class CBody;
interface IOleObject;
interface IOleDocument;
interface IOleDocumentView;
interface IPersistMime; 
interface IMimeMessage;
 
//#define OFFICE_BINDER

enum OLE_SERVER_STATE
    {
    OS_PASSIVE,
    OS_LOADED,                          // handler but no server
    OS_RUNNING,                         // server running, invisible
    OS_INPLACE,                         // server running, inplace-active, no U.
    OS_UIACTIVE,                        // server running, inplace-active, w/ U.
    };

class CDoc:
    public IOleObject,
    public IOleInPlaceObject,
    public IOleInPlaceActiveObject,
    public IOleDocument,
    public IOleDocumentView,
    public IOleCommandTarget,
    public IServiceProvider,
    public IPersistMime,
    public IPersistStreamInit,
    public IPersistFile,
    public IPersistMoniker,
    public IMimeEdit,
    public IQuickActivate,
#ifdef OFFICE_BINDER
    public IPersistStorage,
#endif

    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // *** IOleDocument ***
    virtual HRESULT STDMETHODCALLTYPE CreateView(IOleInPlaceSite *pSite, IStream *pstm, DWORD dwReserved, IOleDocumentView **ppView);
    virtual HRESULT STDMETHODCALLTYPE GetDocMiscStatus(DWORD *pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE EnumViews(IEnumOleDocumentViews **ppEnum, IOleDocumentView **ppView);

    // *** IOleDocumentView ***
    virtual HRESULT STDMETHODCALLTYPE SetInPlaceSite(IOleInPlaceSite *pIPSite);
    virtual HRESULT STDMETHODCALLTYPE GetInPlaceSite(IOleInPlaceSite **ppIPSite);
    virtual HRESULT STDMETHODCALLTYPE GetDocument(IUnknown **ppunk);
    virtual HRESULT STDMETHODCALLTYPE SetRect(LPRECT prcView);
    virtual HRESULT STDMETHODCALLTYPE GetRect(LPRECT prcView);
    virtual HRESULT STDMETHODCALLTYPE SetRectComplex(LPRECT prcView, LPRECT prcHScroll, LPRECT prcVScroll, LPRECT prcSizeBox);
    virtual HRESULT STDMETHODCALLTYPE Show(BOOL fShow);
    virtual HRESULT STDMETHODCALLTYPE UIActivate(BOOL fUIActivate);
    virtual HRESULT STDMETHODCALLTYPE Open();
    virtual HRESULT STDMETHODCALLTYPE CloseView(DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE SaveViewState(LPSTREAM pstm);
    virtual HRESULT STDMETHODCALLTYPE ApplyViewState(LPSTREAM pstm);
    virtual HRESULT STDMETHODCALLTYPE Clone(IOleInPlaceSite *pIPSiteNew, IOleDocumentView **ppViewNew);

    // *** IOleObject ***
    virtual HRESULT STDMETHODCALLTYPE SetClientSite(IOleClientSite *pClientSite);
    virtual HRESULT STDMETHODCALLTYPE GetClientSite(IOleClientSite **ppClientSite);
    virtual HRESULT STDMETHODCALLTYPE SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    virtual HRESULT STDMETHODCALLTYPE Close(DWORD dwSaveOption);
    virtual HRESULT STDMETHODCALLTYPE SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk);
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    virtual HRESULT STDMETHODCALLTYPE InitFromData(IDataObject *pDataObject, BOOL fCreation, DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE GetClipboardData(DWORD dwReserved, IDataObject **ppDataObject);
    virtual HRESULT STDMETHODCALLTYPE DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
    virtual HRESULT STDMETHODCALLTYPE EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    virtual HRESULT STDMETHODCALLTYPE Update();
    virtual HRESULT STDMETHODCALLTYPE IsUpToDate();
    virtual HRESULT STDMETHODCALLTYPE GetUserClassID(CLSID *pClsid);
    virtual HRESULT STDMETHODCALLTYPE GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType);
    virtual HRESULT STDMETHODCALLTYPE SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT STDMETHODCALLTYPE GetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT STDMETHODCALLTYPE Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwConnection);
    virtual HRESULT STDMETHODCALLTYPE EnumAdvise(IEnumSTATDATA **ppenumAdvise);
    virtual HRESULT STDMETHODCALLTYPE GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE SetColorScheme(LOGPALETTE *pLogpal);

    // *** IOleInPlaceObject ***
    virtual HRESULT STDMETHODCALLTYPE InPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE UIDeactivate();
    virtual HRESULT STDMETHODCALLTYPE SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);
    virtual HRESULT STDMETHODCALLTYPE ReactivateAndUndo();

    // *** IOleWindow *** 
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *phwnd);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);

    // *** IOleInPlaceActiveObject ***
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);

    // *** IOleCommandTarget ***
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);

    // *** IServiceProvider ***
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // *** IPersist ***
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);

    // *** IPersistMime ***
	virtual HRESULT STDMETHODCALLTYPE Load(IMimeMessage *pMsg);
	virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwFlags);

    // *** IPersistStreamInit ***
    virtual HRESULT STDMETHODCALLTYPE IsDirty();
    virtual HRESULT STDMETHODCALLTYPE Load(LPSTREAM pstm);
    virtual HRESULT STDMETHODCALLTYPE Save(LPSTREAM pstm, BOOL fClearDirty);
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER * pCbSize);
    virtual HRESULT STDMETHODCALLTYPE InitNew();

    // IPersistMoniker Members
    virtual HRESULT STDMETHODCALLTYPE Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode);
    virtual HRESULT STDMETHODCALLTYPE GetCurMoniker(IMoniker **ppMoniker);
    virtual HRESULT STDMETHODCALLTYPE Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx);

#ifdef OFFICE_BINDER
    // *** IPersistStorage ***
    virtual HRESULT STDMETHODCALLTYPE InitNew(IStorage *pStg);
    virtual HRESULT STDMETHODCALLTYPE Load(IStorage *pStg);
    virtual HRESULT STDMETHODCALLTYPE Save(IStorage *pStgSave, BOOL fSameAsLoad);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IStorage *pStgNew);
    virtual HRESULT STDMETHODCALLTYPE HandsOffStorage();
#endif

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // *** IMimeEdit **
    virtual HRESULT STDMETHODCALLTYPE put_src(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_src(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_header(LONG lStyle);
    virtual HRESULT STDMETHODCALLTYPE get_header(LONG *plStyle);
    virtual HRESULT STDMETHODCALLTYPE put_editMode(VARIANT_BOOL b);
    virtual HRESULT STDMETHODCALLTYPE get_editMode(VARIANT_BOOL *pbool);
    virtual HRESULT STDMETHODCALLTYPE get_messageSource(BSTR *pbstr);

// OE5_BETA2 needs to be defined in public headers
    virtual HRESULT STDMETHODCALLTYPE get_text(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE get_html(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE clear();
    virtual HRESULT STDMETHODCALLTYPE get_doc(IDispatch **ppDoc);

// OE5_BETA2 needs to be defined in public headers

    // *** IQuickActivate ***
    virtual HRESULT STDMETHODCALLTYPE QuickActivate(QACONTAINER *pQaContainer, QACONTROL *pQaControl);
    virtual HRESULT STDMETHODCALLTYPE SetContentExtent(LPSIZEL pSizel);
    virtual HRESULT STDMETHODCALLTYPE GetContentExtent(LPSIZEL pSizel);

    // *** IPersistFile ***
    virtual HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pszFileName, DWORD dwMode);
    virtual HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pszFileName, BOOL fRemember);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pszFileName);
    virtual HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR * ppszFileName);

    CDoc(IUnknown *pUnkOuter=NULL);
    virtual ~CDoc();

private:
    ULONG               m_ulState;
    HWND                m_hwndParent;
    LPSTR               m_lpszAppName;
    IOleClientSite      *m_pClientSite;
    IOleInPlaceSite     *m_pIPSite;
    IOleInPlaceFrame    *m_pInPlaceFrame;
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;
	CBody				*m_pBodyObj;
    LPTYPEINFO          m_pTypeInfo;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT ActivateView();
    HRESULT ActivateInPlace();
    HRESULT DeactivateInPlace();
    HRESULT ActivateUI();
    HRESULT DeactivateUI();

    HRESULT DoShow(IOleClientSite *pActiveSite, HWND hwndParent, LPCRECT lprcPosRect);

	HRESULT AttachWin(HWND hwndParent, LPRECT lprcPos);

    BOOL OnCreate(HWND hwnd);
    BOOL OnNCDestroy();

    HRESULT GetHostName(LPSTR szTitle, ULONG cch);
    HRESULT EnsureTypeLibrary();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\dochost.h ===
/*
 *    d o c h o s t . h
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _DOCHOST_H
#define _DOCHOST_H

class CDocHost:
    public IOleInPlaceFrame,
    public IOleInPlaceSite,
    public IOleClientSite,
    public IOleControlSite,
    public IOleDocumentSite,
    public IOleCommandTarget,
    public IServiceProvider
{
public:
    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 
    
    // *** IOleInPlaceFrame methods ***
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);

    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

    // IOleControlSite
    virtual HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
    virtual HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
    virtual HRESULT STDMETHODCALLTYPE GetExtendedControl(LPDISPATCH *ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *lpMsg,DWORD grfModifiers);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    virtual HRESULT STDMETHODCALLTYPE ShowPropertyFrame(void);

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    CDocHost();
    virtual ~CDocHost();
    
    // statics
    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
   
    virtual HRESULT GetDocObjSize(LPRECT prc)
        {return E_NOTIMPL;};

    HRESULT CreateDocObj(LPCLSID pCLSID);
    HRESULT CloseDocObj();

    HRESULT Init(HWND hwndParent, BOOL fBorder, LPRECT prc);

    
    LPOLEOBJECT                 m_lpOleObj;
    LPOLECOMMANDTARGET          m_pCmdTarget;

protected:
    HWND                        m_hwnd,
                                m_hwndDocObj;
    LPOLEDOCUMENTVIEW           m_pDocView;
    BOOL                        m_fDownloading,
                                m_fFocus,
                                m_fUIActive,
                                m_fCycleFocus;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
	
	virtual HRESULT Show();
    virtual HRESULT OnUpdateCommands();
    virtual void WMSize(int x, int y);

private:
    ULONG               m_cRef;
    DWORD               m_dwFrameWidth,
                        m_dwFrameHeight;

    HRESULT CreateDocView();

    HRESULT OnCreate(HWND hwnd);
    HRESULT OnNCDestroy();
    HRESULT OnDestroy();
};

typedef CDocHost DOCHOST;
typedef DOCHOST *LPDOCHOST;

#endif //_DOCHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\bodyutil.cpp ===
/*
 *    b o d y u t i l . c p p
 *    
 *    Purpose:
 *        utility functions for body
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "olealloc.h"
#include "resource.h"
#include "htmlstr.h"
#include "strconst.h"
#include "bodyutil.h"
#include "plainstm.h"
#include "mimeutil.h"
#include "util.h"
#include "demand.h"

ASSERTDATA


/*
 *  t y p e d e f s
 */

enum
{
    HEADER_FROM=0,
    HEADER_NEWSGROUP,
    HEADER_TO,
    HEADER_CC,
    HEADER_SENT,
    HEADER_ATTACH,
    HEADER_SUBJECT,
    HEADER_MAX
};


/*
 *  m a c r o s
 */
#define WSZ_CB(str)         (lstrlenW(str)*sizeof(WCHAR))
#define WSZ_CBNULL(str)     ((lstrlenW(str)+1)*sizeof(WCHAR))

#define WSZ_CCH(str)        lstrlenW(str)
#define WSZ_CCHNULL(str)    (lstrlenW(str)+1)

/*
 *  c o n s t a n t s
 */

static const WCHAR  c_wszHtmlDIV_Close[]            = L"</DIV>\r\n",
                    c_wszTableTag_Close[]           = L"</TABLE>\r\n",
                    c_wszHtml[]                     = L"<HTML>\r\n",
                    c_wszHtmlReplyAnchor[]          = L"<A href=\"mailto:%s\" TITLE=\"%s\">%s</A>\r\n",
                    c_wszHtml_HeaderDIV[]           = L"<DIV>\r\n<B>%s</B> ",
                    c_wszHtml_DIV_BR_DIV[]          = L"<DIV><BR></DIV>\r\n",
                    c_wszHtml_FromDIV[]             = L"<DIV STYLE=\"background:#E4E4E4; font-color:black\">\r\n<B>%s</B> ",
                    
                    c_wszHtml_HeaderDIVFmt_Start[]  = L"<DIV>\r\n<B>",
                    c_wszHtml_HeaderDIVFmt_Middle[] = L"</B> ",
                    c_wszHtml_HeaderDIVFmt_End[]    = L"</DIV>",

                    c_wszHtml_HeaderDIVFmt_Plain_Start[]= L"<DIV>\r\n",
                    c_wszHtml_HeaderDIVFmt_Plain_Middle[]= L" ",
                    c_wszHtml_HeaderDIVFmt_Plain_End[]  = L"</DIV>";

static const int    c_cchHtml_HeaderDIVFmt_Start   = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Start) - 1,
                    c_cchHtml_HeaderDIVFmt_Middle  = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Middle) - 1,
                    c_cchHtml_HeaderDIVFmt_End     = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_End) - 1,
                                       
                    c_cchHtml_HeaderDIVFmt_Plain_Start  = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Plain_Start) - 1,
                    c_cchHtml_HeaderDIVFmt_Plain_Middle = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Plain_Middle) - 1,
                    c_cchHtml_HeaderDIVFmt_Plain_End    = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Plain_End) - 1;

// HARDCODED Western headers
static const LPWSTR c_rgwszHeaders[HEADER_MAX] = {  L"From:",
                                                    L"Newsgroups:",
                                                    L"To:",
                                                    L"Cc:",
                                                    L"Sent:",
                                                    L"Attach:",
                                                    L"Subject:"};
static const int   c_rgidsHeaders[HEADER_MAX] ={   
                                                    idsFromField, 
                                                    idsNewsgroupsField, 
                                                    idsToField, 
                                                    idsCcField, 
                                                    idsDateField, 
                                                    idsAttachField,
                                                    idsSubjectField};

/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */
HRESULT CreatePrintHeader(IMimeMessageW *pMsg, LPWSTR pwszUser, DWORD dwFlags, LPSTREAM pstm);
HRESULT CreateMailHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm);
HRESULT CreateNewsHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm);
HRESULT GetHeaderLabel(ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut);
HRESULT GetHeaderText(IMimeMessageW *pMsg, ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut);
HRESULT CreateHTMLAddressLine(IMimeMessageW *pMsg, DWORD dwAdrTypes, LPWSTR *ppwszOut);
void DropAngles(LPWSTR pwszIn, LPWSTR *ppwszOut);

/*
 *  f u n c t i o n s
 */

 
 /*
 * Trident doesn't do a good job of converting tables->plaintext, so we can't use
 * a table to construct the header of a re: fw: etc to get nice alignment on the 
 * field boundaries. We can use a table, however for printing. We need to be able to
 * construct a header (in html source) in 3 flavours:
 *
 * HDR_PLAIN    (regular text, eg: reply in plain-mode)
 * HDR_HTML     (regular text, with bolded fields, eg: reply in html-mode)
 * HDR_TABLE    (use table to get improved output, eg: printing)
 *
 */
HRESULT GetHeaderTable(IMimeMessageW *pMsg, LPWSTR pwszUserName, DWORD dwHdrStyle, LPSTREAM *ppstm)
{
    HRESULT     hr = S_OK;
    LPSTREAM    pstm = NULL;
    BYTE        bUniMark = 0xFF;

    if (pMsg==NULL || ppstm==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));

    // Write out the BOM
    IF_FAILEXIT(hr = pstm->Write(&bUniMark, sizeof(bUniMark), NULL));
    bUniMark = 0xFE;
    IF_FAILEXIT(hr = pstm->Write(&bUniMark, sizeof(bUniMark), NULL));

    if (dwHdrStyle & HDR_TABLE)
        IF_FAILEXIT(hr = CreatePrintHeader(pMsg, pwszUserName, dwHdrStyle, pstm));

    else if (dwHdrStyle & HDR_NEWSSTYLE)
        IF_FAILEXIT(hr = CreateNewsHeader(pMsg, dwHdrStyle, pstm));

    else
        IF_FAILEXIT(hr = CreateMailHeader(pMsg, dwHdrStyle, pstm));

    *ppstm = pstm;
    pstm = NULL;

exit:
    ReleaseObj(pstm);
    return hr;
}


HRESULT CreateNewsHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm)
{
    HRESULT         hr = S_OK;
    WCHAR           wsz[CCHMAX_STRINGRES];
    ULONG           cch,
                    cb;
    LPWSTR          pwsz = NULL,
                    pwszFrom = NULL,
                    pwszMsgId = NULL,
                    pwszFmtMsgId = NULL,
                    pwszHtml;

    Assert(pMsg);
    Assert(pstm);

    pMsg->GetAddressFormatW(IAT_FROM, AFT_DISPLAY_BOTH, &pwszFrom);
    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pwszMsgId);

    *wsz = 0;
    cch = LoadStringWrapW(g_hLocRes, idsReplyTextPrefix, wsz, ARRAYSIZE(wsz));
    cb = cch*sizeof(WCHAR);
        
    // Opie assumes me these Sz function never return NULL. Only an empty buffer
    if (pwszFrom)
        cb += WSZ_CB(pwszFrom);
    else
        pwszFrom=(LPWSTR)c_szEmptyW;

    if (pwszMsgId)
    {
            // We purposely remove < and > from the msgId so Trident will correctly
            // format the msgId as a news: link and not a mailto:
            DropAngles(pwszMsgId, &pwszFmtMsgId);
            cb += WSZ_CB(pwszFmtMsgId);
    }
    else
        pwszFmtMsgId=(LPWSTR)c_szEmptyW;

    // Add null
    cb += sizeof(WCHAR);

    IF_NULLEXIT(MemAlloc((LPVOID *)&pwsz, cb));
    
    IF_FAILEXIT(hr = pstm->Write(c_wszHtml_DivOpen, WSZ_CB(c_wszHtml_DivOpen), NULL));

    // We just write out the e-mail name and news:message-id,
    // trident does URL autodetection and makes the e-mail into a mailto link and the
    // news: into a news link.
    AthwsprintfW(pwsz, cb, wsz, pwszFrom, pwszFmtMsgId);

    IF_FAILEXIT(hr = EscapeStringToHTML(pwsz, &pwszHtml));

    pstm->Write(pwszHtml, WSZ_CB(pwszHtml), NULL);
    MemFree(pwszHtml);
        
    IF_FAILEXIT(hr = pstm->Write(c_wszHtml_DivClose, WSZ_CB(c_wszHtml_DivClose), NULL));

exit:    
    if (pwszFrom != c_szEmptyW)
        MemFree(pwszFrom);

    MemFree(pwszMsgId);
    // pwszFmtMsgId was freed when we freed lpsMsgId

    MemFree(pwsz);
    return hr;
}





/*
<DIV style="font: 10pt arial">
  -----Original Message-----
  <DIV STYLE="background:gainsboro; font-color:black">
    <B>From:</B> <a href="mailto:justinf@microsoft.com">Justin Ferrari</a>
  </DIV>
  <DIV>
    <B>To:</B> 
    <A href="mailto:johnt@microsoft.com" TITLE="johnt@microsoft.com">John Tafoya</A>; 
    <A href="mailto:laurena@microsoft.com" TITLE="laurena@microsoft.com">Lauren Antonoff</A>; 
    <A href="mailto:dhaws@microsoft.com" TITLE="dhaws@microsoft.com">Dave Haws</A>; 
    <A href="mailto:jdoe@microsoft.com" TITLE="jdoe@microsoft.com">John Doe</A>
  </DIV>
  <DIV>
    <B>Date:</B> Tuesday, September 01, 1998 10:40 AM
  </DIV>
  <DIV>
    <B>Subject: </B>Re: A plea to save the life of the News Server combo box
  </DIV>
  <DIV><BR></DIV>
</DIV>
*/

HRESULT CreateMailHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm)
{
    ULONG           uHeader,
                    cchFmt;
    WCHAR           wsz[CCHMAX_STRINGRES],
                    wszText[CCHMAX_STRINGRES];
    LPWSTR          pwsz = NULL,
                    pwszText = NULL,
                    pwszLabel = NULL,
                    pwszHtml = NULL;
    
    LPCWSTR         pwszFmtStart,
                    pwszFmtMiddle,
                    pwszFmtEnd;
    int             cchFmtStart,
                    cchFmtMiddle,
                    cchFmtEnd;

    HRESULT         hr = S_OK;

    if (pMsg==NULL || pstm==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

    // emit a table to display the username
    if (LoadStringWrapW(g_hLocRes, 
                        dwFlags & HDR_HTML ? idsReplyHeader_Html_SepBlock : idsReplyHeader_SepBlock, 
                        wsz, 
                        ARRAYSIZE(wsz)))
    {
        *wszText=0;
        if (dwFlags & HDR_HARDCODED)
            StrCpyW(wszText, L"----- Original Message -----");
        else
            LoadStringWrapW(g_hLocRes, idsReplySep, wszText, ARRAYSIZE(wszText));

        IF_NULLEXIT(pwsz = PszAllocW(WSZ_CCH(wszText) + WSZ_CCH(wsz) + 1));

        AthwsprintfW(pwsz, (WSZ_CCH(wszText) + WSZ_CCH(wsz) + 1), wsz, wszText);
        pstm->Write(pwsz, WSZ_CB(pwsz), NULL);
        SafeMemFree(pwsz);
    }

    if (dwFlags & HDR_HTML)
    {
        pwszFmtStart  = c_wszHtml_HeaderDIVFmt_Start;
        pwszFmtMiddle = c_wszHtml_HeaderDIVFmt_Middle;
        pwszFmtEnd    = c_wszHtml_HeaderDIVFmt_End;

        cchFmtStart  = c_cchHtml_HeaderDIVFmt_Start;
        cchFmtMiddle = c_cchHtml_HeaderDIVFmt_Middle;
        cchFmtEnd    = c_cchHtml_HeaderDIVFmt_End;
    }
    else
    {
        pwszFmtStart  = c_wszHtml_HeaderDIVFmt_Plain_Start;
        pwszFmtMiddle = c_wszHtml_HeaderDIVFmt_Plain_Middle;
        pwszFmtEnd    = c_wszHtml_HeaderDIVFmt_Plain_End;

        cchFmtStart  = c_cchHtml_HeaderDIVFmt_Plain_Start;
        cchFmtMiddle = c_cchHtml_HeaderDIVFmt_Plain_Middle;
        cchFmtEnd    = c_cchHtml_HeaderDIVFmt_Plain_End;
    }

    // write out each header row
    for (uHeader=0; uHeader<HEADER_MAX; uHeader++)
    {
        // skip attachment header for reply and forward headers
        if (uHeader == HEADER_ATTACH)
            continue;

        // special case address-headers in HTML-Mode
        if (dwFlags & HDR_HTML)
        {
            switch (uHeader)
            {
                case HEADER_FROM:
                {
                    if (CreateHTMLAddressLine(pMsg, IAT_FROM, &pwsz)==S_OK)
                    {
                        if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
                        {
                            // pszLabel is fixed size
                            AthwsprintfW(wsz, ARRAYSIZE(wsz), c_wszHtml_FromDIV, pwszLabel); 
                            pstm->Write(wsz, WSZ_CB(wsz), NULL);
                            pstm->Write(pwsz, WSZ_CB(pwsz), NULL);
                            pstm->Write(c_wszHtmlDIV_Close, WSZ_CB(c_wszHtmlDIV_Close), NULL);
                            SafeMemFree(pwszLabel);
                        }
                        SafeMemFree(pwsz);
                    }
                    continue;
                }

                case HEADER_TO:
                case HEADER_CC:
                {
                    if (CreateHTMLAddressLine(pMsg, uHeader == HEADER_TO ? IAT_TO : IAT_CC, &pwsz)==S_OK)
                    {
                        if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
                        {
                            AthwsprintfW(wsz, ARRAYSIZE(wsz), c_wszHtml_HeaderDIV, pwszLabel);   // pszLabel is fixed size
                            pstm->Write(wsz, WSZ_CB(wsz), NULL);
                            pstm->Write(pwsz, WSZ_CB(pwsz), NULL);
                            pstm->Write(c_wszHtmlDIV_Close, WSZ_CB(c_wszHtmlDIV_Close), NULL);
                            SafeMemFree(pwszLabel);
                        }
                        SafeMemFree(pwsz);
                    }
                    continue;
                }
            }
        }

        // normal headers
        if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
        {
            if (GetHeaderText(pMsg, uHeader, dwFlags, &pwszText)==S_OK)
            {
                if (*pwszText)   // ignore empty strings
                {
                    int cch = 0;
                    int cchLabel;
                    int cchHtml;
                    
                    IF_FAILEXIT(hr = EscapeStringToHTML(pwszText, &pwszHtml));
                    
                    cchLabel = WSZ_CCH(pwszLabel);
                    cchHtml  = WSZ_CCH(pwszHtml);

                    // 1 for the NULL
                    IF_NULLEXIT(pwsz = PszAllocW(cchLabel + cchHtml + cchFmtStart + cchFmtMiddle + cchFmtEnd + 1));

                    // Avoid potentially dumping > 1024 into AthwsprintfW
                    StrCpyW(pwsz, pwszFmtStart);
                    cch = cchFmtStart;
                    StrCpyW(&pwsz[cch], pwszLabel);
                    cch += cchLabel;
                    StrCpyW(&pwsz[cch], pwszFmtMiddle);
                    cch += cchFmtMiddle;
                    StrCpyW(&pwsz[cch], pwszHtml);
                    cch += cchHtml;
                    StrCpyW(&pwsz[cch], pwszFmtEnd);
                    cch += cchFmtEnd;

                    pstm->Write(pwsz, cch * sizeof(WCHAR), NULL);

                    SafeMemFree(pwsz);
                    SafeMemFree(pwszHtml);
                }
                SafeMemFree(pwszText);
            }
            SafeMemFree(pwszLabel);
        }            
    }

    // Close the <DIV> that wraps the whole thing in a font
    pstm->Write(c_wszHtmlDIV_Close, WSZ_CB(c_wszHtmlDIV_Close), NULL);
    
    // add a <DIV><BR></DIV> to give one line-spacing
    pstm->Write(c_wszHtml_DIV_BR_DIV, WSZ_CB(c_wszHtml_DIV_BR_DIV), NULL);

exit:
    MemFree(pwszHtml);
    MemFree(pwszText);
    MemFree(pwszLabel);
    MemFree(pwsz);

    return hr;
}


HRESULT CreatePrintHeader(IMimeMessageW *pMsg, LPWSTR pwszUser, DWORD dwFlags, LPSTREAM pstm)
{
    ULONG           uHeader;
    WCHAR           wsz[CCHMAX_STRINGRES];
    LPWSTR          pwsz = NULL,
                    pwszText = NULL,
                    pwszLabel = NULL,
                    pwszHtml = NULL;
    HRESULT         hr = S_OK;
    int             cch = 0;

    if (pMsg==NULL || pstm==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);
    
    // if no username, use "" so wsprintf is happy
    if (pwszUser == NULL)
        pwszUser = (LPWSTR)c_szEmptyW;

    // Emit an <HTML> tag for trident autodetector (used on the print-header)
    pstm->Write(c_wszHtml, WSZ_CB(c_wszHtml), NULL);

    // emit a table to display the username
    if (LoadStringWrapW(g_hLocRes, idsPrintTable_UserName, wsz, ARRAYSIZE(wsz)))
    {
        IF_FAILEXIT(hr = EscapeStringToHTML(pwszUser, &pwszHtml));
        IF_NULLEXIT(pwsz = PszAllocW(WSZ_CCH(wsz) + WSZ_CCH(pwszHtml) + 1));

        AthwsprintfW(pwsz, (WSZ_CCH(wsz) + WSZ_CCH(pwszHtml) + 1), wsz, pwszHtml);
        pstm->Write(pwsz, WSZ_CB(pwsz), NULL);

        SafeMemFree(pwsz);
        SafeMemFree(pwszHtml);
    }

    // start the main-table
    if (LoadStringWrapW(g_hLocRes, idsPrintTable_Header, wsz, ARRAYSIZE(wsz)))
    {
        pstm->Write(wsz, WSZ_CB(wsz), NULL);

        if (LoadStringWrapW(g_hLocRes, idsPrintTable_HeaderRow, wsz, ARRAYSIZE(wsz)))
        {
            // write out each header row
            for (uHeader=0; uHeader<HEADER_MAX; uHeader++)
            {
                if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
                {
                    if (GetHeaderText(pMsg, uHeader, dwFlags, &pwszText)==S_OK)
                    {
                        if (*pwszText)   // ignore empty strings
                        {
                            IF_FAILEXIT(hr = EscapeStringToHTML(pwszText, &pwszHtml));

                            cch = lstrlenW(pwszLabel) + lstrlenW(pwszHtml) + lstrlenW(wsz) +1;
                            IF_NULLEXIT(pwsz = PszAllocW(cch));

                            AthwsprintfW(pwsz, cch, wsz, pwszLabel, pwszHtml);
                            pstm->Write(pwsz, WSZ_CB(pwsz), NULL);

                            SafeMemFree(pwsz);
                            SafeMemFree(pwszHtml);
                        }
                        SafeMemFree(pwszText);
                    }
                    SafeMemFree(pwszLabel);
                }
            }
        }
        pstm->Write(c_wszTableTag_Close, WSZ_CB(c_wszTableTag_Close), NULL);
    }

exit:
    MemFree(pwsz);
    MemFree(pwszHtml);
    MemFree(pwszText);
    MemFree(pwszLabel);

    return hr;
}


HRESULT GetHeaderText(IMimeMessageW *pMsg, ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut)
{
    PROPVARIANT     pv;
    HBODY          *rghAttach = NULL;
    ULONG           cAttach,
                    uAttach,
                    cb=0;
    LPWSTR         *rgpwsz = NULL,
                    pwszWrite = NULL;
    HRESULT         hr = S_OK;

    Assert(pMsg);
    Assert(ppwszOut);
    *ppwszOut = 0;

    switch (uHeader)
    {
        case HEADER_FROM:
            pMsg->GetAddressFormatW(IAT_FROM, AFT_DISPLAY_BOTH, ppwszOut);
            break;

        case HEADER_NEWSGROUP:
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, ppwszOut);
            break;

        case HEADER_TO:
            pMsg->GetAddressFormatW(IAT_TO, AFT_DISPLAY_BOTH, ppwszOut);
            break;

        case HEADER_CC:
            pMsg->GetAddressFormatW(IAT_CC, AFT_DISPLAY_BOTH, ppwszOut);
            break;

        case HEADER_ATTACH:
            if (pMsg->GetAttachments(&cAttach, &rghAttach)==S_OK && cAttach)
            {
                // create cache-string list
                IF_NULLEXIT(rgpwsz = (LPWSTR*)ZeroAllocate(sizeof(*rgpwsz) * cAttach));
            
                for (uAttach=0; uAttach<cAttach; uAttach++)
                {
                    if (MimeOleGetBodyPropW(pMsg, rghAttach[uAttach], PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &rgpwsz[uAttach])==S_OK)
                        cb += (WSZ_CCH(rgpwsz[uAttach]) + 2) * sizeof(WCHAR);     // +2 for "; "
                }

                IF_NULLEXIT(MemAlloc((LPVOID *)ppwszOut, cb));
                pwszWrite = *ppwszOut;

                for (uAttach=0; uAttach<cAttach; uAttach++)
                {
                    StrCpyW(pwszWrite, rgpwsz[uAttach]);
                    pwszWrite += WSZ_CCH(rgpwsz[uAttach]);
                    if (uAttach != cAttach -1)
                    {
                        StrCpyW(pwszWrite, L"; ");
                        pwszWrite += 2;
                    }
                }
            }
            break;

        case HEADER_SENT:
            pv.vt = VT_FILETIME;
            if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv)))
            {
                LPWSTR  lpwsz = NULL;
                INT     cch = 0;
                
                IF_NULLEXIT(MemAlloc((LPVOID*)&lpwsz, CCHMAX_STRINGRES * sizeof(*lpwsz)));

                *lpwsz = 0;

                // always force a western date if using hardcoded headers
                // For the formatted date, DTM_FORCEWESTERN flag returns English date and time. 
                // Without DTM_FORCEWESTERN the formatted time may not be representable in ASCII.
                cch = AthFileTimeToDateTimeW(&pv.filetime, lpwsz, CCHMAX_STRINGRES, 
                                             DTM_NOSECONDS|DTM_LONGDATE|(dwFlags & HDR_HARDCODED ?DTM_FORCEWESTERN:0));
                
                *ppwszOut = lpwsz;
            }
            break;
        
        case HEADER_SUBJECT:
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, ppwszOut);
            break;

        default:
            AssertSz(0, "Not Supported");
    }

exit:
    // free cached string-list
    if (rgpwsz)
    {
        for (uAttach=0; uAttach<cAttach; uAttach++)
            MemFree(rgpwsz[uAttach]);
        MemFree(rgpwsz);
    }

    MemFree(rghAttach);

    // In this case, we failed but that is ok so don't trace result.
    // Just means that the field asked for is empty.
    if (SUCCEEDED(hr) && (0 == *ppwszOut))
        hr = E_FAIL;


    return hr;
}

HRESULT GetHeaderLabel(ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut)
{
    WCHAR           wsz[CCHMAX_STRINGRES];

    Assert(ppwszOut);
    *ppwszOut = 0;

    if (dwFlags & HDR_HARDCODED)
        *ppwszOut = PszDupW(c_rgwszHeaders[uHeader]);
    else
    {
        if(LoadStringWrapW(g_hLocRes, c_rgidsHeaders[uHeader], wsz, ARRAYSIZE(wsz)))
            *ppwszOut = PszDupW(wsz);
    }
    return *ppwszOut ? S_OK : E_FAIL;
}


HRESULT CreateHTMLAddressLine(IMimeMessageW *pMsg, DWORD dwAdrTypes, LPWSTR *ppwszOut)
{
    ADDRESSLIST     rAdrList = {0};
    BOOL            fFreeAdrList;
    ULONG           i;
    ULONG           cb=0;
    LPWSTR          pwsz = NULL,
                    pwszWrite = NULL,
                    pwszEmail = NULL,
                    pwszEmailLoop = NULL,
                    pwszFriendly = NULL,
                   *rgpwszEmail = NULL,
                   *rgpwszFriendly = NULL;
    ULONG           cAddr = 0;
    HRESULT         hr = S_OK;

    Assert (pMsg);
    
    // Get address table
    IF_FAILEXIT(hr = pMsg->GetAddressTypes(dwAdrTypes, IAP_FRIENDLYW|IAP_EMAIL, &rAdrList));

    cAddr = rAdrList.cAdrs;
    
    // If no addresses, bail
    if (cAddr == 0)
        IF_FAILEXIT(hr = E_FAIL);

    // Allocate array for escaped email addresses
    IF_NULLEXIT(rgpwszEmail = (LPWSTR*)ZeroAllocate(sizeof(*rgpwszEmail) * cAddr));
    
    // Allocate array for escaped displaynames
    IF_NULLEXIT(rgpwszFriendly = (LPWSTR*)ZeroAllocate(sizeof(*rgpwszFriendly) * cAddr));

    for (i=0; i < cAddr; i++)
    {
        // escape all of the names into our name array
        if (rAdrList.prgAdr[i].pszEmail)
        {
            IF_NULLEXIT(pwszEmail = PszToUnicode(CP_ACP, rAdrList.prgAdr[i].pszEmail));

            // Escape Into Array
            IF_FAILEXIT(hr = EscapeStringToHTML(pwszEmail, &rgpwszEmail[i]));

            // Use Email if no Friendly Name
            if (NULL == (pwszFriendly = rAdrList.prgAdr[i].pszFriendlyW))
                pwszFriendly = pwszEmail;

            IF_FAILEXIT(hr = EscapeStringToHTML(pwszFriendly, &rgpwszFriendly[i]));
            
            // for each address we use 2*email + display + htmlgoo + "; "
            // if display == null, we use email. We skip if email==NULL (failure case)
            cb += (
                    2*WSZ_CCH(rgpwszEmail[i]) + 
                    WSZ_CCH(rgpwszFriendly[i]) + 
                    WSZ_CCH(c_wszHtmlReplyAnchor) + 
                    2
                  ) * sizeof(WCHAR);
            SafeMemFree(pwszEmail);
        }
    }

    IF_NULLEXIT(MemAlloc((LPVOID *)&pwsz, cb));

    pwszWrite = pwsz;
    for (i=0; i < cAddr; i++)
    {
        if (pwszEmailLoop = rgpwszEmail[i])
        {
            pwszFriendly = rgpwszFriendly[i];
            Assert (pwszFriendly);
            AthwsprintfW(pwszWrite, (cb/sizeof(WCHAR)), c_wszHtmlReplyAnchor, pwszEmailLoop, pwszEmailLoop, pwszFriendly);
            pwszWrite += WSZ_CCH(pwszWrite);
            if (i != cAddr-1)
            {
                StrCpyW(pwszWrite, L"; ");
                pwszWrite += 2;
            }
        }
    }

    *ppwszOut = pwsz;
    pwsz = NULL;         // freed by caller

exit:
    if (rgpwszEmail)
    {
        for (i=0; i < cAddr; i++)
            MemFree(rgpwszEmail[i]);
        MemFree(rgpwszEmail);
    }

    if (rgpwszFriendly)
    {
        for (i=0; i < cAddr; i++)
            MemFree(rgpwszFriendly[i]);
        MemFree(rgpwszFriendly);
    }

    MemFree(pwsz);
    MemFree(pwszEmail);
    g_pMoleAlloc->FreeAddressList(&rAdrList);
    return hr;
}



void GetRGBFromString(DWORD* pRGB, LPSTR pszColor)
{
    DWORD   dwShiftAmount = 0,
            rgb = 0,
            n;
    CHAR    ch;
    
    Assert(pRGB);
    Assert(lstrlen(pszColor) == lstrlen("RRGGBB"));
    
    *pRGB = 0;
    
    while (0 != (ch = *pszColor++))
    {
        if (ch >= '0' && ch <= '9')
            n = ch - '0';
        else if(ch >= 'A' && ch <= 'F')
            n = ch - 'A' + 10;
        else 
        {
            Assert(ch >= 'a' && ch <= 'f')
                n = ch - 'a' + 10;
        }
        rgb = (rgb << 4) + n;
    }
    
    rgb = ((rgb & 0x00ff0000) >> 16 ) | (rgb & 0x0000ff00) | ((rgb & 0x000000ff) << 16);
    *pRGB = rgb;
}

void GetStringRGB(DWORD rgb, LPSTR pszColor)
{
    INT           i;
    DWORD         crTemp;
    
    Assert(pszColor);
    
    rgb = ((rgb & 0x00ff0000) >> 16 ) | (rgb & 0x0000ff00) | ((rgb & 0x000000ff) << 16);
    for(i = 0; i < 6; i++)
    {
        crTemp = (rgb & (0x00f00000 >> (4*i))) >> (4*(5-i));
        pszColor[i] = (CHAR)((crTemp < 10)? (crTemp+'0') : (crTemp+ 'a' - 10));
    }
    pszColor[6] = '\0';
}


/*
    This function drops the enclosing < and > around a msg-id
    RFC822:     msg-id = "<" addr-spec ">"
    NOTE:
    The input buffer is MODIFIED and the output pointer
    points to memory in pszIn!
*/
void DropAngles(LPWSTR pwszIn, LPWSTR *ppwszOut)
{
    if (pwszIn)
    {
        WCHAR ch;
        LPWSTR pwszCurrent = pwszIn;
        
        // First character should be <, but be robust and scan for it
        while ((ch = *pwszCurrent++) && (ch != L'<'));
        
        if (ch)
            // We are interested in stuff after the angle bracket
            *ppwszOut = pwszCurrent;
        else
            // Perhaps the message-id was malformed and doesn't contain a <
            *ppwszOut = pwszIn;
        
        pwszCurrent = *ppwszOut;
        
        // Find the close bracket and null it out
        while ((ch = *pwszCurrent) && (ch != L'>'))
            pwszCurrent++;
        
        // If we found a >, overwrite it with NULL
        if (ch)
            *pwszCurrent = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\fmtbar.cpp ===
/*
 *      f m t b a r . c p p
 *
 *      Format Bar based on IOleCommandTarget
 *      Owner:  brettm / a-mli
 *
 */
#include <pch.hxx>
#include "dllmain.h"
#include <shfusion.h>
#include "demand.h"
#include "resource.h"
#include "util.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "mshtmcid.h"
#include "docobj.h"
#include "fmtbar.h"
#include "strconst.h"
#include "comctrlp.h"
#include <shlguidp.h>

/*
 *  WS_EX_LAYOUTRTL ported from winuser.h
 */
#if WINVER < 0X0500
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#endif // WS_EX_LAYOUTRTL

/*
 *  m a c r o s
 */
#define GETINDEX(m) ((DWORD)((((m & 0xff000000) >> 24) & 0x000000ff)))
#define MAKEINDEX(b, l) (((DWORD)l & 0x00ffffff) | ((DWORD)b << 24))

/*
 *  c o n s t a n t s
 */
#define cxButtonSep 8
#define dxToolbarButton 16
#define COMBOBUFSIZE 64
#define dxFormatFontBitmap 20
#define dyFormatFontBitmap 12
#define NFONTSIZES 7
#define TEMPBUFSIZE 30
#define CYDROPDOWNEXPANDRATIO  8
#define SIZETEXTLIMIT 8
#define cxDUName 100
#define cyToolbarOffset 2
#define idcCoolbar      45

// FormatBar stuff
enum 
    {
    itbFormattingTag,
    itbFormattingBold,
    itbFormattingItalic,
    itbFormattingUnderline,
    itbFormattingColor,
    itbFormattingNumbers,
    itbFormattingBullets,
    itbFormattingDecreaseIndent,
    itbFormattingIncreaseIndent,
    itbFormattingLeft,
    itbFormattingCenter,
    itbFormattingRight,
    itbFormattingJustify,
    itbFormattingInsertHLine,
    itbFormattingInsertLink,
    itbFormattingInsertImage,
    ctbFormatting
    };


// FormatBar Paragraph direction stuff
enum
    {
    itbFormattingBlockDirLTR = ctbFormatting,
    itbFormattingBlockDirRTL,
    };



/*
 *  t y p e d e f s
 */
/*
 *  g l o b a l   d a t a
 */

static const TCHAR      c_szComboBox[] =    "ComboBox",
                        c_szFmtBarClass[] = "MimeEdit_FormatBar",
                        c_szThis[]          = "OE_This";

/*
 *      Color table for dropdown on toolbar.  Matches COMMDLG colors
 *      exactly.
 */

static DWORD rgrgbColors[] = 
    {
    RGB(  0,   0, 0),     // "BLACK"},   
    RGB(128,   0, 0),     // "MAROON"},
    RGB(  0, 128, 0),     // "GREEN"},
    RGB(128, 128, 0),     // "OLIVE"},
    RGB(  0,   0, 128),   // "NAVY"},
    RGB(128,   0, 128),   // "PURPLE"},
    RGB(  0, 128, 128),   // "TEAL"},
    RGB(128, 128, 128),   // "GREY"}, 
    RGB(192, 192, 192),   // "SILVER"},  
    RGB(255,   0, 0),     // "RED"}, 
    RGB(  0, 255, 0),     // "LIME"}, 
    RGB(255, 255, 0),     // "YELLOW"},
    RGB(  0,   0, 255),   // "BLUE"},  
    RGB(255,   0, 255),   // "FUSCHIA"},
    RGB(  0, 255, 255),   // "AQUA"}, 
    RGB(255, 255, 255)    // "WHITE"}    
    };


static TBBUTTON rgtbbutton[] =
{
    { itbFormattingTag, idmFmtTag,
            TBSTATE_ENABLED, TBSTYLE_DROPDOWN, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingBold, idmFmtBold,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingItalic, idmFmtItalic,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingUnderline, idmFmtUnderline,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingColor, idmFmtColor,
            TBSTATE_ENABLED, TBSTYLE_DROPDOWN, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingNumbers, idmFmtNumbers,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingBullets, idmFmtBullets,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingDecreaseIndent, idmFmtDecreaseIndent,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbFormattingIncreaseIndent, idmFmtIncreaseIndent,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingLeft, idmFmtLeft,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingCenter, idmFmtCenter,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingRight, idmFmtRight,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingJustify, idmFmtJustify,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingInsertHLine, idmFmtInsertHLine,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbFormattingInsertLink, idmEditLink,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbFormattingInsertImage, idmInsertImage,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 }
};

static TBBUTTON rgtbblkdirbutton[] =
{

    { itbFormattingBlockDirLTR, idmFmtBlockDirLTR,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingBlockDirRTL, idmFmtBlockDirRTL,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 }
};            
            
#define ctbbutton           (sizeof(rgtbbutton) / sizeof(TBBUTTON))


/*
 *  p r o t o t y p e s
 */

HRESULT ColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf);
void Color_WMDrawItem(HWND hwnd, LPDRAWITEMSTRUCT pdis);
void Color_WMMeasureItem(HWND hwnd, HDC hdc, LPMEASUREITEMSTRUCT pmis);
INT GetColorIndex(INT rbg);
HFONT hFontGetMenuFont(HWND hwnd);

/*
 *  f u n c t i o n s
 */

CFmtBar::CFmtBar(BOOL fSep)
{
    m_cRef=1;

    m_hwnd = NULL;
    m_hwndToolbar = NULL;
    m_hwndName = NULL;
    m_hwndSize = NULL;

    m_wndprocEdit = NULL;
    m_wndprocNameComboBox = NULL;
    m_wndprocSizeComboBox = NULL;
    m_hbmName = NULL;
    m_hmenuColor = NULL;
    m_hmenuTag = NULL;
    m_fDestroyTagMenu = 1;
    m_pCmdTarget=0;
    m_fVisible = 0;
    m_fSep = !!fSep;
    m_himlHot = NULL;
    m_himl = NULL;
}

CFmtBar::~CFmtBar()
{
    if (m_hbmName)
        DeleteObject(m_hbmName);

    if (m_hmenuColor)
        DestroyMenu(m_hmenuColor);

    if (m_hmenuTag && !!m_fDestroyTagMenu)
        DestroyMenu(m_hmenuTag);

    _FreeImageLists();
}

ULONG CFmtBar::AddRef()
{
    return ++m_cRef;
}

ULONG CFmtBar::Release()
{
    ULONG   cRef=--m_cRef;

    if(m_cRef==0)
        delete this;

    return cRef;
}


HRESULT CreateColorMenu(ULONG idmStart, HMENU* pMenu)
{
    DWORD               irgb;
    DWORD               mniColor;

    if(pMenu == NULL)
        return E_INVALIDARG;

    *pMenu = CreatePopupMenu();

    if (*pMenu == NULL)
        return E_OUTOFMEMORY;

    // Add the COLORREF version of each entry into the menu
    for (irgb = 0, mniColor=idmStart; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb, ++mniColor)
        AppendMenu(*pMenu, MF_ENABLED|MF_OWNERDRAW, mniColor, (LPCSTR)IntToPtr(MAKEINDEX(irgb, rgrgbColors[irgb])));

    return S_OK;
}




LRESULT CALLBACK CFmtBar::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPFORMATBAR pFmtBar=0;

    if (msg==WM_NCCREATE)
        {
        pFmtBar=(CFmtBar *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pFmtBar)
            return -1;

        return (pFmtBar->OnNCCreate(hwnd)==S_OK);
        }

    pFmtBar = (LPFORMATBAR)GetWndThisPtr(hwnd);
    if (pFmtBar)
        return pFmtBar->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

extern BOOL g_fCanEditBiDi;


HRESULT CFmtBar::OnNCCreate(HWND hwnd)
{
    RECT    rc;
    HFONT           hfontOld,
                    hfontToolbar;
    HWND            hwndEdit,
                    hwndToolTips;
    BOOL            fRet;
    HDC             hdc, 
                    hdcParent;
    TEXTMETRIC      tm;
    INT             yPos;
    INT             cxDownButton;
    INT             cxName;
    INT             cxSize,
                    cx;
    INT             cyToolbarButton;
    INT             cyDropDownRollHeight;
    INT             cyExpandedList;
    const POINT     pt = {5, 5};
    LONG            lstyle;
    TOOLINFO        ti;
    
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);
    m_hwnd=hwnd;
    AddRef();

    m_hwndRebar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                        WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                        WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                        0, 0, 100, 136, m_hwnd, (HMENU) idcCoolbar, g_hInst, NULL);

    if (!m_hwndRebar)
        return E_OUTOFMEMORY;

	SendMessage(m_hwndRebar, RB_SETTEXTCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNTEXT));
    SendMessage(m_hwndRebar, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));
    //SendMessage(m_hwndRebar, RB_SETEXTENDEDSTYLE, RBS_EX_OFFICE9, RBS_EX_OFFICE9);
	SendMessage(m_hwndRebar, CCM_SETVERSION, COMCTL32_VERSION, 0);


    // [a-msadek]; Fix for bug#55069
    // DO NOT remove CCS_TOP from creation styles below
    // It is a default style and toolbar WinProc will addit any way durin
    // WM_NCCREATE processing. However, it will cause WM_STYLECHANGING to be sent
    // Due to a bug in SetWindowPos() for a mirrored window, it will never return from seding
    // messages calling a stack overflow
    // No need to put it only for a mirrored window since it will be added any way
    // Look @ comctl32\toolbar.c, functions ToolbarWndProc() and TBAutoSize();
    
    m_hwndToolbar = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                        WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE|CCS_TOP|CCS_NOPARENTALIGN|CCS_NODIVIDER|
                        TBSTYLE_TOOLTIPS|TBSTYLE_FLAT,
                        0, 0, 0, 0, m_hwndRebar, NULL, 
                        g_hInst, NULL);


    if (!m_hwndToolbar)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_hwndToolbar, TB_ADDBUTTONS, (WPARAM)ctbbutton, (LPARAM)rgtbbutton);
    SendMessage(m_hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(dxToolbarButton, dxToolbarButton));

    _SetToolbarBitmaps();

    // add BiDi direction buttons
    if(g_fCanEditBiDi)
    {
        SendMessage(m_hwndToolbar, TB_INSERTBUTTON, ctbbutton - 3, (LPARAM) (LPVOID) &rgtbblkdirbutton[2]);
        SendMessage(m_hwndToolbar, TB_INSERTBUTTON, ctbbutton - 3, (LPARAM) (LPVOID) &rgtbblkdirbutton[1]);
        SendMessage(m_hwndToolbar, TB_INSERTBUTTON, ctbbutton - 3, (LPARAM) (LPVOID) &rgtbblkdirbutton[0]);
        SendMessage(m_hwndToolbar, TB_AUTOSIZE, (WPARAM)0, (LPARAM)0);
    }

    hdcParent = GetDC(GetParent(hwnd));
    if (!hdcParent)
        return E_OUTOFMEMORY;

    hdc = CreateCompatibleDC(hdcParent);
    ReleaseDC(GetParent(hwnd), hdcParent);

    if (!hdc)
        return E_OUTOFMEMORY;

    hfontToolbar = (HFONT) SendMessage(m_hwndToolbar, WM_GETFONT, 0, 0);

    // Get font metrics (of System font) so that we can properly scale the
    // format bar layout
    hfontOld = (HFONT)SelectObject(hdc, hfontToolbar);
    GetTextMetrics(hdc, &tm);
    
    cxDownButton = GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXDLGFRAME);
    cxName = (cxDUName * tm.tmAveCharWidth) / 4 + cxDownButton;
    cxSize = XFontSizeCombo(hdc) + cxDownButton;
    SelectObject(hdc, hfontOld);
    DeleteDC(hdc);

    // set the size of the formatbar based on the size of the toolbar plus 2 pixels padding
    GetClientRect(m_hwndToolbar, &rc);
    SetWindowPos(m_hwnd, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top + (2*cyToolbarOffset) + (m_fSep?2:0), SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

    // Determine how tall the buttons are so we can size our other controls
    // accordingly
    SendMessage(m_hwndToolbar, TB_GETITEMRECT, 1, (LPARAM) &rc);
    cyToolbarButton = rc.bottom - rc.top + 1;

    // Figure out size of expanded dropdown lists
    cyExpandedList = CYDROPDOWNEXPANDRATIO * cyToolbarButton;

    // Get the ToolTips window handle
    hwndToolTips = (HWND) SendMessage(m_hwndToolbar, TB_GETTOOLTIPS, 0, 0);

    m_hwndName = CreateWindow(c_szComboBox, NULL,
                                      WS_CHILD | WS_VSCROLL | CBS_DROPDOWN |
                                      CBS_SORT | CBS_HASSTRINGS |
                                      CBS_OWNERDRAWFIXED |WS_VISIBLE,
                                      0, 0, cxName, cyExpandedList,
                                      m_hwndToolbar,
                                      (HMENU) idmFmtFont, g_hLocRes, NULL);

    if (!m_hwndName)
        return E_OUTOFMEMORY;

    ComboBox_SetExtendedUI(m_hwndName, TRUE);

    // Load up the mini-icons for TrueType or Printer font
    m_hbmName = LoadDIBBitmap(idbFormatBarFont);
    if (!m_hbmName)
        return E_OUTOFMEMORY;

    // Compute the right edge of the combobox
    SetWindowFont(m_hwndName, hfontToolbar, TRUE);

    // The Size
    m_hwndSize = CreateWindow(c_szComboBox, NULL,
                                      WS_CHILD | WS_VSCROLL | CBS_DROPDOWNLIST |
                                      WS_VISIBLE,
                                      cxName + cxButtonSep, 0, cxSize, cyExpandedList,
                                      m_hwndToolbar,
                                      (HMENU) idmFmtSize, g_hLocRes, NULL);

    if (!m_hwndSize)
        return E_OUTOFMEMORY;

    m_hwndTT = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL, 0,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, (HMENU) NULL, g_hInst, NULL);
    if (!m_hwndTT)
        return E_OUTOFMEMORY;

    ZeroMemory(&ti, sizeof(TOOLINFO));
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd = m_hwndName;
    ti.uId = (ULONG_PTR)m_hwndName;

    SendMessage(m_hwndTT, TTM_ADDTOOL, 0, (LPARAM)&ti);
    SendMessage(m_hwndTT, WM_SETFONT, (WPARAM)(HFONT)SendMessage(m_hwndToolbar, WM_GETFONT, 0, 0), 0);

    ComboBox_SetExtendedUI(m_hwndSize, TRUE);
    SetWindowFont(m_hwndSize, hfontToolbar, TRUE);
    // font sizes up to 4 digits are allowed
    ComboBox_LimitText(m_hwndSize, SIZETEXTLIMIT);
    // The color popup menu (initially empty)
    // Set the rolled-up heights of the combo boxes to all be the same
    cyDropDownRollHeight = LOWORD(SendMessage(m_hwndSize, CB_GETITEMHEIGHT, (WPARAM)-1, 0));
    // hwndName is ownerdrawn
    SendMessage(m_hwndName, CB_SETITEMHEIGHT, (WPARAM)-1, cyDropDownRollHeight);
    // Determine how tall the toolbar is so we can center the comboboxes
    GetClientRect(m_hwndToolbar, &rc);
    // Get size of toolbar window
    yPos = rc.bottom;
    // Get size of combobox
    GetClientRect(m_hwndSize, &rc);
    yPos = (yPos - rc.bottom) / 2;

    // We have a mirroring bug in GetWindowRect
    // It will give wrong cocordinates causing combos to go outside the screen
    // Ignore y-positioning in this case

    if(!(GetWindowLong(m_hwndToolbar, GWL_EXSTYLE) & WS_EX_LAYOUTRTL))
    {
        GetWindowRect(m_hwndName, &rc);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
        MoveWindow(m_hwndName, rc.left, yPos, rc.right-rc.left, rc.bottom-rc.top, FALSE);
        GetWindowRect(m_hwndSize, &rc);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
        MoveWindow(m_hwndSize, rc.left, yPos, rc.right-rc.left, rc.bottom-rc.top, FALSE);
    }
    hwndEdit = ::GetWindow(m_hwndName, GW_CHILD);

    // Add tooltips for the controls we just added
    AddToolTip(hwndToolTips, m_hwndName, idsTTFormattingFont);
    AddToolTip(hwndToolTips, m_hwndSize, idsTTFormattingSize);
    AddToolTip(hwndToolTips, hwndEdit, idsTTFormattingFont);

    // Subclass the comboboxes and their edit controls
    // Do the name edit control first
    m_wndprocEdit = SubclassWindow(hwndEdit, EditSubProc);
    m_wndprocNameComboBox = SubclassWindow(m_hwndName, ComboBoxSubProc);
    m_wndprocSizeComboBox = SubclassWindow(m_hwndSize, ComboBoxSubProc);

    // give the control This pointers
    SetProp(m_hwndName, c_szThis, (LPVOID)this);
    SetProp(m_hwndSize, c_szThis, (LPVOID)this);
    SetProp(hwndEdit, c_szThis, (LPVOID)this);

    GetClientRect(m_hwndToolbar, &rc);

    cx = cxName + cxSize + cxButtonSep * 2;
    REBARBANDINFO   rbbi;

    POINT   ptIdeal = {0};
    SendMessage(m_hwndToolbar, TB_GETIDEALSIZE, FALSE, (LPARAM)&ptIdeal);

    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_SIZE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE | RBBIM_STYLE;
	rbbi.fStyle		= RBBS_USECHEVRON;
    rbbi.cx         = 0;
    rbbi.hwndChild  = m_hwndToolbar;
    rbbi.cxMinChild = 0;
    rbbi.cyMinChild = rc.bottom;
    rbbi.cxIdeal    = ptIdeal.x + cx;

    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT)-1, (LPARAM)(LPREBARBANDINFO)&rbbi);

    // Indent the toolbar buttons for the comboboxes
    SendMessage(m_hwndToolbar, TB_SETINDENT, cx, 0);

    // Load up the names of the fonts and colors
    FillFontNames();
    FillSizes();
    return S_OK;
}


void CFmtBar::OnNCDestroy()
{
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
    m_hwnd=0;
    Release();
}

LRESULT CALLBACK CFmtBar::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_DESTROY:
            // unsubclass the windows
            if (m_wndprocEdit)
            {
                SubclassWindow(::GetWindow(m_hwndName, GW_CHILD), m_wndprocEdit);
                RemoveProp(::GetWindow(m_hwndName, GW_CHILD), c_szThis);
            }

            if (m_wndprocNameComboBox)
            {
                SubclassWindow(m_hwndName, m_wndprocNameComboBox);
                RemoveProp(m_hwndName, c_szThis);
            }

            if (m_wndprocSizeComboBox)
            {
                SubclassWindow(m_hwndSize, m_wndprocSizeComboBox);
                RemoveProp(m_hwndSize, c_szThis);
            }
            DestroyWindow(m_hwndTT);
            m_hwndTT=NULL;
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;

        case WM_COMMAND:
            if(OnWMCommand(GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;
            break;

        case WM_PAINT:
            if (m_fSep)
                {
                HDC         hdc;
                PAINTSTRUCT ps;
                RECT        rc;                
                
                hdc=BeginPaint(hwnd, &ps);
                if (hdc)
                    {
                    GetClientRect(hwnd, &rc);
                    rc.top = rc.bottom-3;
                    //rc.bottom+=1;
                    DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_BOTTOM);
                    EndPaint(hwnd, &ps);
                    }
                return 0;
                }
            break;

        case WM_NOTIFY:
            WMNotify(wParam, (NMHDR*)lParam);
            return 0;

        case WM_SIZE:
            {
            RECT        rc;

            GetClientRect(m_hwndRebar, &rc);

            // resize the width of the toolbar
            if(rc.right != (INT)LOWORD(lParam))
                SetWindowPos(m_hwndRebar, NULL, 0, cyToolbarOffset, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER|SWP_NOACTIVATE);
            }
            break;

        case WM_DRAWITEM:
            OnDrawItem((LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_SYSCOLORCHANGE:
            _SetToolbarBitmaps();
            UpdateRebarBandColors(m_hwndRebar);
            // fall thro'

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            SendMessage(m_hwndRebar, msg, wParam, lParam);
            break;


        case WM_MEASUREITEM:
            OnMeasureItem((LPMEASUREITEMSTRUCT)lParam);
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HRESULT CFmtBar::Init(HWND hwndParent, int idDlgItem)
{
    // stuff these values. We don't create the formatbar until the first call to Show()
    // to allow better perf.
    m_hwndParent = hwndParent;
    m_idd = idDlgItem;
    return S_OK;
}



// displays the colorpopup menu at the specified point. if clrf if NULL, then no clrf is returned
// but instead the appropriate WM_COMMAND is dispatched to the parent window
HRESULT ColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf)
{
    HRESULT     hr=NOERROR;
    int         tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;

    if(hmenuColor == NULL)
        return E_INVALIDARG;

    if(pclrf)
         tpm|=TPM_RETURNCMD;

    int id = TrackPopupMenu(hmenuColor, tpm,pt.x, pt.y, 0, hwndParent, NULL);

    switch(id)
        {
        case 1:
            return NOERROR;
        case 0:
            return E_FAIL;
        case -1:
            return MIMEEDIT_E_USERCANCEL;

        case idmFmtColor1:
        case idmFmtColor2:
        case idmFmtColor3:
        case idmFmtColor4:
        case idmFmtColor5:
        case idmFmtColor6:
        case idmFmtColor7:
        case idmFmtColor8:
        case idmFmtColor9:
        case idmFmtColor10:
        case idmFmtColor11:
        case idmFmtColor12:
        case idmFmtColor13:
        case idmFmtColor14:
        case idmFmtColor15:
        case idmFmtColor16:
            AssertSz(pclrf, "this HAS to be set to get this id back...");
            *pclrf=rgrgbColors[id-idmFmtColor1];
            return NOERROR;

        default:
            AssertSz(0, "unexpected return from TrackPopupMenu");
        }

    return E_FAIL;
}

HRESULT CFmtBar::CheckColor()
{
    HRESULT     hr=E_FAIL;
    INT         iFound = -1, irgb;
    VARIANTARG  va;

    if (!m_pCmdTarget)
        return E_FAIL;

    va.vt = VT_I4;
    va.lVal = -1;
    hr = m_pCmdTarget->Exec(&CMDSETID_Forms3,
                       IDM_FORECOLOR,
                       MSOCMDEXECOPT_DONTPROMPTUSER,
                       NULL, &va);
    if(FAILED(hr))
        goto error;

    if(va.lVal == -1)
        goto error;

    iFound = GetColorIndex(va.lVal);

error:
    CheckMenuRadioItem(m_hmenuColor, idmFmtColor1, idmFmtColor16, idmFmtColor1+iFound, MF_BYCOMMAND);
    return hr;
}


INT GetColorIndex(INT rbg)
{
    INT iFound = -1;

    for (int irgb = 1; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb)
        if  ((rbg&0x00ffffff) == (LONG)rgrgbColors[irgb])
            {
            iFound = irgb;
            break;
            }
    return iFound;
}



HRESULT CFmtBar::HrInitTagMenu()
{
    HRESULT     hr=NOERROR;
    int         id;
    int         tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;
    VARIANTARG  va;
    VARIANTARG  *pvaIn=0;
    TCHAR szBufMenu[MAX_PATH] = {0};
    TCHAR szBufTag[MAX_PATH] = {0};

    if (!m_pCmdTarget)
        return E_FAIL;

    if (!m_hmenuTag && 
        FAILED(HrCreateTridentMenu(m_pCmdTarget, TM_TAGMENU, idmFmtTagFirst, idmFmtTagLast-idmFmtTagFirst, &m_hmenuTag)))
        return E_FAIL;

    hr = HrCheckTridentMenu(m_pCmdTarget, TM_TAGMENU, idmFmtTagFirst, idmFmtTagLast, m_hmenuTag);

    return hr;
}


HRESULT CFmtBar::HrShowTagMenu(POINT pt)
{
    HRESULT hr;
    int     tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;

    hr = HrInitTagMenu();
    if(FAILED(hr))
        return hr;

    TrackPopupMenu(m_hmenuTag, tpm, pt.x, pt.y, 0, m_hwnd, NULL);

    return hr;
}

HMENU CFmtBar::hmenuGetStyleTagMenu()
{
    HRESULT hr;

    hr = HrInitTagMenu();
    if(FAILED(hr))
        return NULL;

    m_fDestroyTagMenu = 0;
    return m_hmenuTag;
}


// update toolbar buttons and font name/size combo boxes.
HRESULT CFmtBar::Update()
{
    UINT        uCmdID=0;
    CHAR        szBuf[COMBOBUFSIZE/2];
    CHAR        szBufbstrVal[COMBOBUFSIZE/2];
    int         i;
    INT         iPointSize=0, iHTMLSize=0;
    HWND        hwndEdit;
    OLECMD  rgCmds[]= {
                        {IDM_FONTNAME, 0},
                        {IDM_FONTSIZE, 0},
                        {IDM_FORECOLOR, 0},
                        {IDM_BOLD, 0},
                        {IDM_ITALIC, 0},
                        {IDM_UNDERLINE, 0},
                        {IDM_ORDERLIST, 0},
                        {IDM_UNORDERLIST, 0},
                        {IDM_JUSTIFYLEFT, 0},
                        {IDM_JUSTIFYRIGHT, 0},
                        {IDM_JUSTIFYCENTER, 0},
                        {IDM_JUSTIFYFULL, 0},
                        {IDM_BLOCKDIRLTR, 0},
                        {IDM_BLOCKDIRRTL, 0},                        
                        {IDM_OUTDENT, 0},
                        {IDM_INDENT, 0},
                        {IDM_HORIZONTALLINE, 0},
                        {IDM_HYPERLINK, 0},
                        {IDM_IMAGE, 0},
                        {IDM_BLOCKFMT, 0}};

    int     rgidm[] = { 0,
                        0,
                        idmFmtColor,
                        idmFmtBold,
                        idmFmtItalic,
                        idmFmtUnderline,
                        idmFmtNumbers,
                        idmFmtBullets,
                        idmFmtLeft,
                        idmFmtRight,
                        idmFmtCenter,
                        idmFmtJustify,
                        idmFmtBlockDirLTR,
                        idmFmtBlockDirRTL,
                        idmFmtDecreaseIndent,
                        idmFmtIncreaseIndent,
                        idmFmtInsertHLine,
                        idmEditLink,
                        idmInsertImage,
                        idmFmtTag};

    ULONG   uState;
    BOOL    fUIActive;

    if (!m_hwnd)        // no UI visible yet
        return S_OK;

    if (!m_pCmdTarget)
    {
        EnableWindow(m_hwndName, FALSE);
        EnableWindow(m_hwndSize, FALSE);
        
        for (i=2; i<sizeof(rgCmds)/sizeof(OLECMD); i++)
            SendMessage(m_hwndToolbar, TB_SETSTATE, rgidm[i], MAKELONG(0, 0));
        return S_OK;
    }

    HWND hwndFocus = GetFocus();

    if (m_hwndToolbar == hwndFocus ||
       (hwndFocus && m_hwndToolbar==GetParent(hwndFocus)) ||
       (hwndFocus && GetParent(hwndFocus) && m_hwndToolbar==GetParent(GetParent(hwndFocus))) )
        return S_OK;

    fUIActive = FBodyHasFocus();
    
    if (fUIActive)
        m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgCmds)/sizeof(OLECMD), rgCmds, NULL);
    
    EnableWindow(m_hwndName, fUIActive  && (rgCmds[0].cmdf&OLECMDF_ENABLED));
    EnableWindow(m_hwndSize, fUIActive  && (rgCmds[1].cmdf&OLECMDF_ENABLED));
    
    for (i=2; i<sizeof(rgCmds)/sizeof(OLECMD); i++)
    {
        uState=(rgCmds[i].cmdf&OLECMDF_LATCHED ? TBSTATE_PRESSED: 0)|
            (rgCmds[i].cmdf&OLECMDF_ENABLED ? TBSTATE_ENABLED: 0);
        SendMessage(m_hwndToolbar, TB_SETSTATE, rgidm[i], MAKELONG(uState, 0));
    }

    if (!fUIActive)
        return S_OK;

    // update font name combo box
    VARIANTARG  va;
    va.vt = VT_BSTR;
    va.bstrVal = NULL;
    
    if (m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FONTNAME, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &va) == S_OK)
    {
        hwndEdit = ::GetWindow(m_hwndName, GW_CHILD);
        if (va.vt == VT_BSTR)
        {
            *szBuf = 0;
            *szBufbstrVal = 0;

            // we have a font-name, let's see if we need to update
            ComboBox_GetText(hwndEdit, szBuf, COMBOBUFSIZE/2);
            WideCharToMultiByte(CP_ACP, 0, (WCHAR*)va.bstrVal, -1, szBufbstrVal, COMBOBUFSIZE/2, NULL, NULL);
            
            if (StrCmpI(szBufbstrVal, szBuf) != 0)
            {
                if(ComboBox_SelectString(m_hwndName, -1, szBufbstrVal) == -1)
                    ComboBox_SetText(hwndEdit, szBufbstrVal);
            }
            
            SafeSysFreeString(va.bstrVal);
        }
        else
            ComboBox_SetText(hwndEdit, "");
    }


    // update font size combo box
    va.vt = VT_I4;
    va.lVal = 0;
    
    if (m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FONTSIZE, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &va)==S_OK && 
        va.vt == VT_I4)
    {
        // font size if returned in the 1 to 7 range, for I4
        // see if the font size has changed
        *szBuf = 0;

        if(ComboBox_GetText(m_hwndSize, szBuf, sizeof(szBuf)))
        {
            iPointSize = StrToInt(szBuf);
            Assert(iPointSize>=8 && iPointSize<=36);
            iHTMLSize = PointSizeToHTMLSize(iPointSize);
        }

        if(iHTMLSize != va.lVal)
            ComboBox_SetCurSel(m_hwndSize, va.lVal-1);
    }
    else
        ComboBox_SetCurSel(m_hwndSize, -1);

    return S_OK;
}

HRESULT CFmtBar::OnWMCommand(HWND hwnd, int id, WORD wCmd)
{
    UINT        uCmdID=0;
    VARIANTARG  va;
    VARIANTARG  *pvaIn=0;
    HRESULT     hr = S_FALSE;
    DWORD       dwOpt=MSOCMDEXECOPT_DONTPROMPTUSER;
    TOOLINFO    ti;

    ZeroMemory(&va, sizeof(va));

    switch(wCmd)
        {
        case CBN_SELENDCANCEL:
            // clear the tooltip
            ZeroMemory(&ti, sizeof(TOOLINFO));
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = m_hwndName;
            ti.uId = (ULONG_PTR)m_hwndName;

            SendMessage(m_hwndTT, TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
            break;

        case CBN_SELENDOK:
            {
            CHAR                szBuf[COMBOBUFSIZE];
            UINT                uSel;

            // clear the tooltip
            ZeroMemory(&ti, sizeof(TOOLINFO));
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = m_hwndName;
            ti.uId = (ULONG_PTR)m_hwndName;

            SendMessage(m_hwndTT, TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);

            if(idmFmtFont == id)
            {
                uCmdID = IDM_FONTNAME;

                uSel = ComboBox_GetCurSel(m_hwndName);
//                if(uSel < 0)
//                    return hr;

                ComboBox_GetLBText(m_hwndName, uSel, szBuf);
            
                va.vt = VT_BSTR;
                pvaIn = &va;
                hr=HrLPSZToBSTR(szBuf, &va.bstrVal);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if(idmFmtSize == id)
            {
                // when setting font size use:
                // VT_I4: for 1 - 7 range
                // VT_STRING: for -2 -> +4 range.
                uCmdID = IDM_FONTSIZE;
                uSel = ComboBox_GetCurSel(m_hwndSize);
                if(-1 == uSel)
                   return hr;
                va.vt = VT_I4;
                va.lVal = uSel + 1;
                pvaIn = &va;
            }
        
            // set focus back to Trident, call HrUIActivate() after ComboBox operations.
            SetBodyFocus();
        
            hr = ExecCommand(uCmdID, dwOpt, pvaIn);
            if(FAILED(hr))
                goto Cleanup;

    Cleanup:
            if(va.vt == VT_BSTR && va.bstrVal != NULL)
               SysFreeString(va.bstrVal);

            return hr;
            }
        }

    switch(id)
        {
        case idmFmtBold:
            uCmdID=IDM_BOLD;
            break;

        case idmFmtItalic:
           uCmdID=IDM_ITALIC;
           break;

        case idmFmtUnderline:
            uCmdID=IDM_UNDERLINE;
            break;

        case idmAccelBullets:
        case idmFmtBullets:
            uCmdID=IDM_UNORDERLIST;
            break;

        case idmFmtNumbers:
            uCmdID=IDM_ORDERLIST;
            break;

        case idmAccelJustify:
        case idmFmtJustify:
            uCmdID=IDM_JUSTIFYFULL;
            break;

        case idmAccelLeft:
        case idmFmtLeft:
            uCmdID=IDM_JUSTIFYLEFT;
            break;

        case idmAccelCenter:
        case idmFmtCenter:
            uCmdID=IDM_JUSTIFYCENTER;
            break;

        case idmAccelRight:
        case idmFmtRight:
            uCmdID=IDM_JUSTIFYRIGHT;
            break;

        case idmFmtBlockDirLTR:
            uCmdID=IDM_BLOCKDIRLTR;
            break;

        case idmFmtBlockDirRTL:
            uCmdID=IDM_BLOCKDIRRTL;
            break;
            
        case idmAccelDecreaseIndent:
        case idmFmtDecreaseIndent:
            uCmdID=IDM_OUTDENT;

            break;

        case idmAccelIncreaseIndent:
        case idmFmtIncreaseIndent:
            uCmdID=IDM_INDENT;
            break;

        case idmEditLink:
            uCmdID=IDM_HYPERLINK;
            dwOpt = MSOCMDEXECOPT_PROMPTUSER;
            break;

        case idmUnInsertLink:
            uCmdID=IDM_UNLINK;
            break;

        case idmFmtInsertHLine:
            uCmdID=IDM_HORIZONTALLINE;
            break;

        case idmInsertImage:
            uCmdID=IDM_IMAGE;
            dwOpt = MSOCMDEXECOPT_PROMPTUSER;
            break;

        case idmFmtColor1:
        case idmFmtColor2:
        case idmFmtColor3:
        case idmFmtColor4:
        case idmFmtColor5:
        case idmFmtColor6:
        case idmFmtColor7:
        case idmFmtColor8:
        case idmFmtColor9:
        case idmFmtColor10:
        case idmFmtColor11:
        case idmFmtColor12:
        case idmFmtColor13:
        case idmFmtColor14:
        case idmFmtColor15:
        case idmFmtColor16:
            {
            uCmdID  = IDM_FORECOLOR;
            va.vt   = VT_I4;
            va.lVal = rgrgbColors[id-idmFmtColor1];
            pvaIn   = &va;
            break;
            }
        }


    if(id >= idmFmtTagFirst && id <= idmFmtTagLast) //style tags
        {
        TCHAR szBuf[MAX_PATH] = {0};
        GetMenuString(m_hmenuTag, id, szBuf, MAX_PATH, MF_BYCOMMAND);
        Assert(*szBuf);//should not be empty

        hr=HrLPSZToBSTR(szBuf, &va.bstrVal);
        if (FAILED(hr))
            goto error;

        va.vt      = VT_BSTR;
        pvaIn      = &va;
        uCmdID = IDM_BLOCKFMT;
        }

    if(0 != uCmdID && m_pCmdTarget)
        {
        hr = ExecCommand(uCmdID, dwOpt, pvaIn);
        if(FAILED(hr))
            goto error;
        }

error:
    if(va.vt == VT_BSTR && va.bstrVal != NULL)
       SysFreeString(va.bstrVal);

    return hr;

}

HRESULT CFmtBar::ExecCommand(UINT uCmdID, DWORD dwOpt, VARIANTARG  *pvaIn)
{
    HRESULT hr = S_FALSE;

    if(uCmdID && m_pCmdTarget)
        hr = m_pCmdTarget->Exec(&CMDSETID_Forms3,
                             uCmdID,
                             dwOpt,
                             pvaIn, NULL);
    return hr;

}

HRESULT CFmtBar::SetCommandTarget(LPOLECOMMANDTARGET pCmdTarget)
{
    // ALERT: we don't refcount these to avoid circular counts
    // as this poitner is valid during the lifetime of the formatbar
    m_pCmdTarget=pCmdTarget;
    return NOERROR;
}

HRESULT HrCreateFormatBar(HWND hwndParent, int iddlg, BOOL fSep, LPFORMATBAR *ppFmtBar)
{
    LPFORMATBAR pFmtBar=0;
    HRESULT     hr;

    if(!ppFmtBar)
        return E_INVALIDARG;

    *ppFmtBar=NULL;

    if(!(pFmtBar=new CFmtBar(fSep)))
        return E_OUTOFMEMORY;

    hr=pFmtBar->Init(hwndParent, iddlg);
    if(FAILED(hr))
        goto error;

    *ppFmtBar=pFmtBar;
    pFmtBar->AddRef();

error:
    ReleaseObj(pFmtBar);
    return hr;
}

void CFmtBar::WMNotify(WPARAM wParam, NMHDR* pnmhdr)
{

    LPNMREBARCHEVRON pnmch;

    if (pnmhdr->idFrom == idcCoolbar)
    {
        switch (pnmhdr->code)
        {

            case RBN_CHEVRONPUSHED:
            {                    
                ITrackShellMenu* ptsm;                   
                CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER, IID_ITrackShellMenu, 
                    (LPVOID*)&ptsm);
                if (!ptsm)
                    break;

                ptsm->Initialize(0, 0, 0, SMINIT_TOPLEVEL|SMINIT_VERTICAL);
            
                LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnmhdr;                                        
                ptsm->SetObscured(m_hwndToolbar, NULL, SMSET_TOP);
            
                MapWindowPoints(m_hwndRebar, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);                  
                POINTL pt = {pnmch->rc.left, pnmch->rc.right};                   
                ptsm->Popup(m_hwndRebar, &pt, (RECTL*)&pnmch->rc, MPPF_BOTTOM);            
                ptsm->Release();                  
                break;      
            }

        }
    }


    switch(pnmhdr->code)
    {
        case TBN_DROPDOWN:
            {
            RECT    rc;
            POINT   pt;
            LPTBNOTIFY pTBN = (LPTBNOTIFY) pnmhdr;

            if(pTBN->iItem == idmFmtColor)
                SendMessage(m_hwndToolbar, TB_GETITEMRECT, 5, (LPARAM) &rc);
            else if(pTBN->iItem == idmFmtTag)
                SendMessage(m_hwndToolbar, TB_GETITEMRECT, 1, (LPARAM) &rc);

            MapWindowPoints(m_hwndToolbar, NULL, (LPPOINT)&rc, 2);
            pt.x=(GetWindowLong(m_hwndToolbar, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ?rc.right : rc.left;
            pt.y=rc.bottom+2;

            if(pTBN->iItem == idmFmtColor)
                {
                CheckColor();
                ColorMenu_Show(m_hmenuColor, m_hwnd, pt, NULL);
                }
            else 
                if(pTBN->iItem == idmFmtTag)
                    HrShowTagMenu(pt);
            }
            break;

        case TTN_NEEDTEXT:
            ProcessTooltips((LPTOOLTIPTEXTOE) pnmhdr);
            break;

    }

}


void CFmtBar::OnDrawItem(LPDRAWITEMSTRUCT pdis)
{
    switch(pdis->CtlType)
    {
    case ODT_MENU:
        Color_WMDrawItem(m_hwnd, pdis);
        break;

    case ODT_COMBOBOX:
        ComboBox_WMDrawItem(pdis);
        break;

    default:
        AssertSz(0, "OwnerDraw type not supported");
    }
}


void CFmtBar::OnMeasureItem(LPMEASUREITEMSTRUCT pmis)
{
    HDC         hdc;
    HFONT       hfontOld;
    TEXTMETRIC  tm;
        
    hdc = GetDC(m_hwnd);
    if(hdc)
        {
        switch(pmis->CtlType)
            {
            case ODT_MENU:
                Color_WMMeasureItem(m_hwnd, hdc, pmis);
                break;
            
            case ODT_COMBOBOX:
                hfontOld = (HFONT)SelectObject(hdc, (HFONT)SendMessage(m_hwndToolbar, WM_GETFONT, 0, 0));
                GetTextMetrics(hdc, &tm);
                SelectObject(hdc, hfontOld);
                pmis->itemHeight = tm.tmHeight;
                break;
            
            default:
                AssertSz(0, "OwnerDraw type not supported");
            }
        
        ReleaseDC(m_hwnd, hdc);
        }
}

void Color_WMMeasureItem(HWND hwnd, HDC hdc, LPMEASUREITEMSTRUCT pmis)
{
    HFONT       hfontOld;
    TEXTMETRIC  tm;
    UINT        id = pmis->itemID;
    TCHAR       szColor[MAX_PATH]={0};

    Assert (pmis->CtlType == ODT_MENU);

    
    hfontOld = (HFONT)SelectObject(hdc, hFontGetMenuFont(hwnd));
    GetTextMetrics(hdc, &tm);
    SelectObject(hdc, hfontOld);

    ULONG index = GETINDEX(pmis->itemData);
    LoadString(g_hLocRes, index + idsColor1,
                       szColor, sizeof(szColor)/sizeof(TCHAR));

    pmis->itemHeight = tm.tmHeight;
    pmis->itemWidth = GetSystemMetrics(SM_CXMENUCHECK) +
                      2 * GetSystemMetrics(SM_CXBORDER) + 
                      2 * tm.tmHeight +
                      (lstrlen(szColor) + 2) *tm.tmAveCharWidth;
}

// fill font name combo box
void CFmtBar::FillFontNames()
{
    LOGFONT lf = {0};
    HDC hdc;

    // reset the contents of the combo
    SendMessage(m_hwndName, CB_RESETCONTENT, 0, 0);

    hdc = GetDC(NULL);
    if (hdc)
    {
        //to enumerate all styles of all fonts for the default character set
        lf.lfFaceName[0] = '\0';
        lf.lfCharSet = DEFAULT_CHARSET;

        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)ExtEnumFontNamesProcEx, (LPARAM)this, 0);
        ReleaseDC(NULL, hdc);
    }
}


LRESULT CALLBACK CFmtBar::EditSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CHAR    szBuf[TEMPBUFSIZE];
    HWND    hwndCombo = GetParent(hwnd);
    LPFORMATBAR pFmtBar = NULL;

    if(hwndCombo == NULL)
    {
        AssertSz(0, "This is bad");
        return 0;
    }

    pFmtBar = (LPFORMATBAR)GetProp(hwnd, c_szThis);
    if(pFmtBar == NULL)
    {
        AssertSz(0, "This is bad");
        return 0;
    }

    *szBuf = 0;

    switch (wMsg)
    {
    case WM_KEYDOWN:
        switch(wParam)
        {
        case VK_ESCAPE:
            pFmtBar->SetBodyFocus();
            return 0;

        case VK_RETURN:
            if (!SendMessage(pFmtBar->m_hwndName, CB_GETDROPPEDSTATE, 0, 0))
            {
                ComboBox_GetText(hwnd, szBuf, sizeof(szBuf));
                ComboBox_SelectString(pFmtBar->m_hwndName, -1, szBuf);
                SendMessage(pFmtBar->m_hwnd, WM_COMMAND, (WPARAM)MAKELONG(idmFmtFont, CBN_SELENDOK), (LPARAM)pFmtBar->m_hwndName);
                return 0;
            }
        }

        break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
        {
        MSG msg;

        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hwnd;

        SendMessage((HWND)SendMessage(pFmtBar->m_hwndToolbar, TB_GETTOOLTIPS, 0, 0), TTM_RELAYEVENT, 0, (LPARAM) &msg);
        }
        break;
    }

    return CallWindowProc(pFmtBar->m_wndprocEdit, hwnd, wMsg, wParam, lParam);
}

LRESULT CALLBACK CFmtBar::ComboBoxSubProc(HWND hwnd, UINT wMsg, WPARAM wParam,
                                                                        LPARAM lParam)
{
    INT                             nID = GetWindowID(hwnd);
    WNDPROC                         wndprocNext;
    LPFORMATBAR pFmtBar = NULL;

    pFmtBar = (LPFORMATBAR)GetProp(hwnd, c_szThis);
    if(pFmtBar == NULL)
    {
        AssertSz(0, "This is bad");
        return 0;
    }

    
    switch (wMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
        {
          MSG msg;

          msg.lParam = lParam;
          msg.wParam = wParam;
          msg.message = wMsg;
          msg.hwnd = hwnd;

            SendMessage((HWND)SendMessage(pFmtBar->m_hwndToolbar, TB_GETTOOLTIPS, 0, 0), TTM_RELAYEVENT, 0, (LPARAM) &msg);
        }
         break;
    }

    if (nID == idmFmtFont)
        wndprocNext = pFmtBar->m_wndprocNameComboBox;
    else
        wndprocNext = pFmtBar->m_wndprocSizeComboBox;
    return wndprocNext ? CallWindowProc(wndprocNext, hwnd, wMsg, wParam, lParam) : 0;
}


INT CALLBACK CFmtBar::ExtEnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam)
{
    return ((CFmtBar *)lParam)->EnumFontNamesProcEx(plf, ptm, nFontType);
}

INT CFmtBar::EnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType)
{
    CFmtBar     *pFmtBar;
    LONG        l;

    // skip vertical fonts for OE
    if (plf->elfLogFont.lfFaceName[0]=='@')
        return TRUE;

    // if the font is already listed, don't re-list it
    if(ComboBox_FindStringExact(m_hwndName, -1, plf->elfLogFont.lfFaceName) != -1)
        return TRUE;

    l = ComboBox_AddString(m_hwndName, plf->elfLogFont.lfFaceName);
    if (l!=-1)
        ComboBox_SetItemData(m_hwndName, l, nFontType);

    return TRUE;
}

INT CFmtBar::XFontSizeCombo(HDC hdc)
{
    LONG                id;
    TCHAR               szBuf[TEMPBUFSIZE];
    *szBuf = 0;
    INT                 iMax=0;
    SIZE                rSize;

    for(id = idsFontSize0; id < NFONTSIZES + idsFontSize0; ++id)
        {
        LoadString(g_hLocRes, id, szBuf, sizeof(szBuf));
        GetTextExtentPoint32 (hdc, szBuf, lstrlen(szBuf), &rSize);
        if(rSize.cx > iMax)
            iMax = rSize.cx;
        }
    return iMax + 10;
}

void CFmtBar::FillSizes()
{
    LONG                            id;
    TCHAR                           szBuf[TEMPBUFSIZE];
    *szBuf = 0;
    LRESULT                         lr;

    // Empty the current list
    SendMessage(m_hwndSize, CB_RESETCONTENT, 0, 0);

    for (id = idsFontSize0; id < NFONTSIZES + idsFontSize0; ++id)
        {
        LoadString(g_hLocRes, id, szBuf, sizeof(szBuf));
        lr = SendMessage(m_hwndSize, CB_ADDSTRING, 0, (LPARAM) szBuf);
        if (lr == CB_ERR || lr == CB_ERRSPACE)
           break;
        }

}

#define BACKGROUND              0x000000FF      // bright blue
#define BACKGROUNDSEL   0x00FF00FF      // bright blue
DWORD CFmtBar::FlipColor(DWORD rgb)
{
    return RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb));
}

// load bitmap for true type font
HBITMAP CFmtBar::LoadDIBBitmap(int id)
{
    HDC                                     hdc;
    HRSRC                           h;
    DWORD FAR *                     p;
    LPSTR                           lpBits;
    HANDLE                          hRes;
    LPBITMAPINFOHEADER      lpBitmapInfo;
    LPVOID                          lpRes;
    DWORD                           cbRes;
    int                                     numcolors;
    DWORD                           rgbSelected;
    DWORD                           rgbUnselected;
    HBITMAP                         hbm;

    rgbSelected = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
    rgbUnselected = FlipColor(GetSysColor(COLOR_WINDOW));

    h = FindResource(g_hLocRes, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(g_hLocRes, h);

    /* Lock the bitmap and get a pointer to the color table. */
    lpRes = LockResource(hRes);

    if (!lpRes)
            return NULL;

    /* Copy the resource since we shouldn't modify the original */
    cbRes = SizeofResource(g_hLocRes, h);
    if(!MemAlloc((LPVOID *)&lpBitmapInfo, LOWORD(cbRes)))
            return NULL;
    CopyMemory(lpBitmapInfo, lpRes, cbRes);

    p = (DWORD FAR *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    /* Search for the Solid Blue entry and replace it with the current
     * background RGB.
    */
    numcolors = 16;

    while (numcolors-- > 0)
    {
       if (*p == BACKGROUND)
           *p = rgbUnselected;
       else if (*p == BACKGROUNDSEL)
           *p = rgbSelected;
       p++;
    }

    /* First skip over the header structure */
    lpBits = (LPSTR)(lpBitmapInfo + 1);

    /* Skip the color table entries, if any */
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    /* Create a color bitmap compatible with the display device */
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap(hdc, lpBitmapInfo, (DWORD)CBM_INIT, lpBits,
                                             (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS);
    ReleaseDC(NULL, hdc);

    SafeMemFree(lpBitmapInfo);
    FreeResource(hRes);

    return hbm;
}

VOID CFmtBar::AddToolTip(HWND hwndToolTips, HWND hwnd, UINT idRsrc)
{
    TOOLINFO        ti = { 0 };

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND;

    ti.hwnd = hwnd;
    ti.uId = (UINT_PTR) hwnd;
    GetWindowRect(hwnd, &ti.rect);
    ti.hinst = g_hLocRes;
    ti.lpszText = (LPSTR) IntToPtr(idRsrc);

    SendMessage(hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) &ti);
}


HRESULT CFmtBar::TranslateAcclerator(LPMSG lpMsg)
{
    HWND    hwndFocus;

    if (m_hwnd && 
        lpMsg->message==WM_KEYDOWN &&
        ((lpMsg->wParam==VK_RETURN || lpMsg->wParam==VK_ESCAPE)))
        {
        hwndFocus=GetFocus();

        // if focus is on the size combolist or in the edit of the
        // name combobox, then we translate the messages to the window.
        if(hwndFocus==::GetWindow(m_hwndName, GW_CHILD) || 
            hwndFocus==m_hwndSize)
            {
            TranslateMessage(lpMsg);
            DispatchMessage(lpMsg);
            return S_OK;
            }
        }

    return S_FALSE;
}

BOOL CFmtBar::FBodyHasFocus()
{
    NMHDR   nmhdr;

    nmhdr.hwndFrom=m_hwnd;
    nmhdr.idFrom=GetDlgCtrlID(m_hwnd);
    nmhdr.code=FBN_BODYHASFOCUS;

    return (0 != SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr));
}

void CFmtBar::SetBodyFocus()
{
    NMHDR   nmhdr;

    nmhdr.hwndFrom=m_hwnd;
    nmhdr.idFrom=GetDlgCtrlID(m_hwnd);
    nmhdr.code=FBN_BODYSETFOCUS;

    SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
}



void CFmtBar::ComboBox_WMDrawItem(LPDRAWITEMSTRUCT pdis)
{
    HDC     hdc, 
            hdcMem;
    DWORD   rgbBack, rgbText;
    char    szFace[LF_FACESIZE + 10];
    HBITMAP hbmOld;
    int     dy, 
            x;
    INT     nFontType = (INT) pdis->itemData;
    SIZE    size;
    TOOLINFO    ti;
    RECT        rc;
    
    Assert(pdis->CtlID == idmFmtFont);
    hdc = pdis->hDC;

    if (pdis->itemState & ODS_SELECTED)
        {
        rgbBack = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
    else
        {
        rgbBack = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        }

    SendMessage(pdis->hwndItem, CB_GETLBTEXT, pdis->itemID,
                            (LPARAM)(LPSTR)szFace);
    ExtTextOut(hdc, pdis->rcItem.left + dxFormatFontBitmap,
                       pdis->rcItem.top, ETO_OPAQUE, &pdis->rcItem,
                       szFace, lstrlen(szFace), NULL);

    // if selected, see if it is clipped, so that we know to show a tooltip
    if ((pdis->itemState & ODS_SELECTED) && 
        GetTextExtentPoint32(hdc, szFace, lstrlen(szFace), &size) && 
        size.cx + dxFormatFontBitmap >= pdis->rcItem.right)
    {
        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hwndName;
        ti.uId = (UINT_PTR)m_hwndName;
        ti.lpszText = szFace;
        
        SendMessage(m_hwndName, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)&rc);

        SendMessage(m_hwndTT, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
        SendMessage(m_hwndTT, TTM_TRACKPOSITION, 0, MAKELPARAM(rc.left + pdis->rcItem.left + dxFormatFontBitmap, 
                                                               rc.top + pdis->rcItem.top));
        SendMessage(m_hwndTT, TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
    }
    else
        SendMessage(m_hwndTT, TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);


    hdcMem = CreateCompatibleDC(hdc);
    if (hdcMem)
        {
        if (m_hbmName)
            {
            hbmOld = (HBITMAP)SelectObject(hdcMem, m_hbmName);

            x = dxFormatFontBitmap;
            if (nFontType & TRUETYPE_FONTTYPE)
                x = 0;
            else if ((nFontType & (PRINTER_FONTTYPE | DEVICE_FONTTYPE)) ==
                         (PRINTER_FONTTYPE | DEVICE_FONTTYPE))
                x = dxFormatFontBitmap;
            else
                goto SkipBlt;

            dy = ((pdis->rcItem.bottom - pdis->rcItem.top) -
                            dyFormatFontBitmap) / 2;

            BitBlt(hdc, pdis->rcItem.left, pdis->rcItem.top + dy,
                       dxFormatFontBitmap, dyFormatFontBitmap, hdcMem,
                       x, pdis->itemState & ODS_SELECTED ? dyFormatFontBitmap: 0,
                       SRCCOPY);

SkipBlt:
        SelectObject(hdcMem, hbmOld);
            }
            DeleteDC(hdcMem);
        }

    SetTextColor(hdc, rgbText);
    SetBkColor(hdc, rgbBack);
}


void Color_WMDrawItem(HWND hwnd, LPDRAWITEMSTRUCT pdis)
{
    HBRUSH                          hbr;
    WORD                            dx, dy, dxBorder;
    RECT                            rc;
    TCHAR                           szColor[MAX_PATH]={0};
    DWORD                           rgbBack, rgbText;
    UINT                            id = pdis->itemID;
    ULONG                           index = 0;

    Assert (pdis->CtlType == ODT_MENU);

    if(pdis->itemState&ODS_SELECTED)
        {
        rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
    else
        {
        rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_MENU));
        rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_MENUTEXT));
        }
        
    // compute coordinates of color rectangle and draw it
    dxBorder  = (WORD) GetSystemMetrics(SM_CXBORDER);
    dx    = (WORD) GetSystemMetrics(SM_CXMENUCHECK);

    dy        = (WORD) GetSystemMetrics(SM_CYBORDER);
    rc.top    = pdis->rcItem.top + dy;
    rc.bottom = pdis->rcItem.bottom - dy;
    rc.left   = pdis->rcItem.left + dx;
    rc.right  = rc.left + 2 * (rc.bottom - rc.top);

    index = GETINDEX(pdis->itemData);
    LoadString(g_hLocRes, index + idsColor1,
                       szColor, sizeof(szColor)/sizeof(TCHAR));

    SelectObject(pdis->hDC, hFontGetMenuFont(hwnd));

    ExtTextOut(pdis->hDC, rc.right + 2*dxBorder,
                       pdis->rcItem.top, ETO_OPAQUE, &pdis->rcItem,
                       szColor, lstrlen(szColor), NULL);


    hbr = CreateSolidBrush((DWORD)(pdis->itemData & 0x00ffffff));

    if (hbr)
        {
        hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
        Rectangle(pdis->hDC, rc.left, rc.top, rc.right, rc.bottom);
        DeleteObject(SelectObject(pdis->hDC, hbr));
        }

    // draw radio check.
    if (pdis->itemState&ODS_CHECKED)
        {
        WORD left, top, radius;

        if(pdis->itemState&ODS_SELECTED)
            hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHTTEXT));
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));

        if (hbr)
            {
            hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
#ifndef WIN16
            left = (WORD) (pdis->rcItem.left + GetSystemMetrics(SM_CXMENUCHECK) / 2);
#else
            left = pdis->rcItem.left + LOWORD( GetMenuCheckMarkDimensions() ) / 2;
#endif
            top = (WORD) (rc.top + (rc.bottom - rc.top) / 2);
#ifndef WIN16
            radius = (WORD) (GetSystemMetrics(SM_CXMENUCHECK) / 4);
#else
            radius = LOWORD( GetMenuCheckMarkDimensions() ) / 4;
#endif
            Ellipse(pdis->hDC, left-radius, top-radius, left+radius, top+radius);
            DeleteObject(SelectObject(pdis->hDC, hbr));
            }
        }

    SetTextColor(pdis->hDC, rgbText);
    SetBkColor(pdis->hDC, rgbBack);
}


HRESULT CFmtBar::Show()
{
    HRESULT hr;

    if (m_fVisible)
        return S_OK;

    hr = AttachWin();
    if (FAILED(hr))
        return hr;

    ShowWindow(m_hwnd, SW_SHOW);
    m_fVisible=1;
    Update();
    return S_OK;
}

HRESULT CFmtBar::Hide()
{
    if (!m_fVisible)
        return S_OK;

    ShowWindow(m_hwnd, SW_HIDE);
    m_fVisible=0;
    return S_OK;
}

HRESULT CFmtBar::GetWindow(HWND *pHwnd)
{
    *pHwnd = m_hwnd;
    return S_OK;
}

HRESULT CFmtBar::AttachWin()
{
    HWND            hwnd;
    WNDCLASS        wc;

    if (m_hwnd)     // already created
        return S_OK;

    if (FAILED(CreateColorMenu(idmFmtColor1, &m_hmenuColor)))
        return E_FAIL;

    if (!GetClassInfo(g_hLocRes, c_szFmtBarClass, &wc))
        {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        
        wc.style = CS_BYTEALIGNWINDOW;
        wc.lpfnWndProc = CFmtBar::ExtWndProc;
        wc.hInstance = g_hLocRes;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszClassName = c_szFmtBarClass;
        if (!RegisterClass(&wc))
            return E_FAIL;
        }

    hwnd = CreateWindowEx(WS_EX_CONTROLPARENT,
                          c_szFmtBarClass, NULL,
                          WS_CHILD|WS_CLIPCHILDREN,
                          0, 0, 0, 0,
                          m_hwndParent, (HMENU)IntToPtr(m_idd), g_hLocRes, (LPVOID)this);

    if(!hwnd)
        return E_OUTOFMEMORY;

    return S_OK;
}

HFONT hFontGetMenuFont(HWND hwnd)
{
    NMHDR   nmhdr;

    nmhdr.hwndFrom=hwnd;
    nmhdr.idFrom=GetDlgCtrlID(hwnd);
    nmhdr.code=FBN_GETMENUFONT;

    return (HFONT)SendMessage(GetParent(hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
}



HRESULT CFmtBar::_SetToolbarBitmaps()
{
    // release toolbar references
    SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)NULL);
    SendMessage(m_hwndToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)NULL);

    _FreeImageLists();

    // set the normal imagelist
    m_himl = LoadMappedToolbarBitmap(g_hLocRes, idbFormatBar, dxToolbarButton);
    if (!m_himl)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_himl);

    // the the HOT imagelist
    m_himlHot = LoadMappedToolbarBitmap(g_hLocRes, idbFormatBarHot, dxToolbarButton);
    if (!m_himlHot)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlHot);
    return S_OK;
}

HRESULT CFmtBar::_FreeImageLists()
{
    if (m_himlHot)
    {
        ImageList_Destroy(m_himlHot);
        m_himlHot = NULL;
    }

    if (m_himl)
    {
        ImageList_Destroy(m_himl);
        m_himl = NULL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\frames.h ===
#ifndef _FRAMES_H
#define _FRAMES_H

HRESULT DoFindFrameInContext(IUnknown *pUnkTrident, IUnknown *pUnkThis,LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame);


#endif //_FRAMES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\frames.cpp ===
/*
 *    f r a m e s . c p p
 *    
 *    Purpose:
 *        Frameset helper functions
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "frames.h"
#include "htiframe.h"       //ITargetFrame2
#include "htiface.h"        //ITargetFramePriv

ASSERTDATA

typedef enum _TARGET_TYPE {
    TARGET_FRAMENAME,
    TARGET_SELF,
    TARGET_PARENT,
    TARGET_BLANK,
    TARGET_TOP,
    TARGET_MAIN
} TARGET_TYPE;

typedef struct _TARGETENTRY 
    {
    TARGET_TYPE     targetType;
    const WCHAR     *pTargetValue;
    } TARGETENTRY;

static const TARGETENTRY targetTable[] =
{
    {TARGET_SELF, L"_self"},
    {TARGET_PARENT, L"_parent"},
    {TARGET_BLANK, L"_blank"},
    {TARGET_TOP, L"_top"},
    {TARGET_MAIN, L"_main"},
    {TARGET_SELF, NULL}
};


/*******************************************************************

    NAME:       ParseTargetType

    SYNOPSIS:   Maps pszTarget into a target class.

    IMPLEMENTATION:
    Treats unknown MAGIC targets as _self

********************************************************************/
TARGET_TYPE ParseTargetType(LPCOLESTR pszTarget)
{
    const TARGETENTRY *pEntry = targetTable;

    if (pszTarget[0] != '_') return TARGET_FRAMENAME;
    while (pEntry->pTargetValue)
    {
        if (!StrCmpW(pszTarget, pEntry->pTargetValue)) return pEntry->targetType;
        pEntry++;
    }
    //  Treat unknown MAGIC targets as regular frame name! <<for NETSCAPE compatibility>>
    return TARGET_FRAMENAME;
}


HRESULT DoFindFrameInContext(IUnknown *pUnkTrident, IUnknown *pUnkThis, LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame) 
{
    IOleContainer       *pOleContainer;
    LPENUMUNKNOWN       penumUnknown;
    LPUNKNOWN           punkChild,
                        punkChildFrame;
    ITargetFramePriv    *ptgfpChild;
    HRESULT             hr = E_FAIL;    
    TARGET_TYPE         targetType;

    Assert (pUnkTrident && pUnkThis);

    targetType = ParseTargetType(pszTargetName);
    if (targetType != TARGET_FRAMENAME)
        {
        // blank frames need to open a new browser window
        if (targetType == TARGET_BLANK)
            {
            *ppunkTargetFrame = NULL;
            return S_OK;
            }

        // must be a margic target name if it's _self, _parent, _top or _main
        // let's just return our own target frame
        *ppunkTargetFrame = pUnkThis;
        pUnkThis->AddRef();
        return S_OK;
        }
    else
        {
        if (pUnkTrident && 
            pUnkTrident->QueryInterface(IID_IOleContainer, (LPVOID *)&pOleContainer)==S_OK)
            {
            if (pOleContainer->EnumObjects(OLECONTF_EMBEDDINGS, &penumUnknown)==S_OK)
                {
                while(  hr!=S_OK && 
                        penumUnknown->Next(1, &punkChild, NULL)==S_OK)
                    {
                    if (punkChild->QueryInterface(IID_ITargetFramePriv, (LPVOID *)&ptgfpChild)==S_OK)
                        {
                        if (ptgfpChild->QueryInterface(IID_IUnknown, (LPVOID *)&punkChildFrame)==S_OK)
                            {
                            //  to avoid recursion - if this isn't the punkContextFrame, see if embedding supports ITargetFrame 
                            if (punkChildFrame != punkContextFrame)
                                {
                                hr = ptgfpChild->FindFrameDownwards(pszTargetName, dwFlags, ppunkTargetFrame); 
                                }
                            punkChildFrame->Release();
                            }
                        ptgfpChild->Release();
                        }
                    punkChild->Release();
                    }
                penumUnknown->Release();
                }
            pOleContainer->Release();
            } 
        }
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\fmtbar.h ===
#ifndef _FMTBAR_H
#define _FMTBAR_H

#define FBN_BODYHASFOCUS    8001
#define FBN_BODYSETFOCUS    8002
#define FBN_GETMENUFONT     8003

class CFmtBar
{
public:
   	CFmtBar(BOOL fSep);
	~CFmtBar();

    ULONG AddRef();
    ULONG Release();

    HRESULT Init(HWND hwndParent, int iddlg);
    HRESULT SetCommandTarget(LPOLECOMMANDTARGET pCmdTarget);
    HRESULT OnWMCommand(HWND hwnd, int id, WORD wCmd);
    HRESULT Update();

    HRESULT Show();
    HRESULT Hide();

    HRESULT TranslateAcclerator(LPMSG lpMsg);
    HRESULT GetWindow(HWND *pHwnd);

    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK EditSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ComboBoxSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK RebarSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static INT CALLBACK ExtEnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam);

private:
    IOleCommandTarget   *m_pCmdTarget;
    ULONG               m_cRef;
    HWND                m_hwnd,
                        m_hwndParent,
                        m_hwndToolbar,
                        m_hwndName,
                        m_hwndSize,
                        m_hwndRebar,
                        m_hwndTT;

    HMENU               m_hmenuColor,
                        m_hmenuTag;
    WNDPROC             m_wndprocEdit,
                        m_wndprocNameComboBox,
                        m_wndprocSizeComboBox,
                        m_wndprocRebar;
    HBITMAP             m_hbmName;
    BOOL                m_fDestroyTagMenu   :1,
                        m_fVisible          :1,
                        m_fSep              :1;
    int                 m_idd;
    HIMAGELIST          m_himlHot,
                        m_himl;

    HBITMAP LoadDIBBitmap(int id);
    VOID AddToolTip(HWND hwndToolTips, HWND hwnd, UINT idRsrc);
    DWORD FlipColor(DWORD rgb);
    HRESULT HrShowTagMenu(POINT pt);
    HRESULT HrInitTagMenu();
    INT XFontSizeCombo(HDC hdc);
    HRESULT CheckColor();

    INT EnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType);

    // format bar
    void FillFontNames();
    void FillSizes();

    HRESULT ExecCommand(UINT uCmDId, DWORD dwOpt, VARIANTARG  *pvaIn);
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // message handling
    void OnNCDestroy();
    HRESULT OnNCCreate(HWND hwnd);
    void WMNotify(WPARAM wParam, NMHDR* pnmhdr);

    // owner draw
    void OnDrawItem(LPDRAWITEMSTRUCT pdis);
    void OnMeasureItem(LPMEASUREITEMSTRUCT pmis);
    void ComboBox_WMDrawItem(LPDRAWITEMSTRUCT pdis);

    BOOL FBodyHasFocus();
    void SetBodyFocus();

    HMENU hmenuGetStyleTagMenu();

    HRESULT AttachWin();
    
    HIMAGELIST _CreateToolbarBitmap(int idb, int cx);
    HRESULT _SetToolbarBitmaps();    
    HRESULT _FreeImageLists();
    
};



typedef CFmtBar *LPFORMATBAR;

HRESULT HrCreateFormatBar(HWND hwndParent, int iddlg, BOOL fSep, LPFORMATBAR *ppFmtBar);

#endif  // _FMTBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\hash.cpp ===
/*
 *    hash.cpp
 *    
 *    Purpose:
 *        implementation of a string hash table
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Mar 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#include <pch.hxx>
#include "dllmain.h"
#include "privunk.h"
#include "hash.h"
#include "demand.h"

// possible hash-table sizes, chosen from primes not close to powers of 2
static const DWORD s_rgPrimes[] = { 29, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593 };

BOOL FastStrCmp(char *psz1, char *psz2)
{
    if (psz1 == NULL || psz2 == NULL)
        return FALSE;

    while (*psz1 && *psz2 && (*psz1 == *psz2)) 
    {
        psz1++;
        psz2++;
    };

    return *psz1 == *psz2;
}

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CHash::CHash(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_cBins = 0;
    m_rgBins = NULL;
    m_fDupe = FALSE;
    m_pLastEntryEnum = NULL;
    m_iListBinEnum = 0;

    DllAddRef();
}


CHash::~CHash()
{
    PHASHENTRY phe, pheTemp;

    for (DWORD dw = 0; dw < m_cBins; dw++)
        {
        if (m_rgBins[dw].pheNext)
            {
            phe = m_rgBins[dw].pheNext;
            while (phe)
                {
                pheTemp = phe;
                phe = phe->pheNext;
                if (m_fDupe && pheTemp->pszKey)
                    MemFree(pheTemp->pszKey);

                MemFree(pheTemp);
                }
            }
        
        if (m_rgBins[dw].pszKey && m_fDupe)
            MemFree(m_rgBins[dw].pszKey);

        }
    SafeMemFree(m_rgBins);
    DllRelease();
}

HRESULT CHash::Init(DWORD dwSize, BOOL fDupeKeys)
{    
    int i = 0;

    m_fDupe = fDupeKeys;

    while (i < (ARRAYSIZE(s_rgPrimes) - 1) && s_rgPrimes[i] < dwSize)
        i++;
    Assert(s_rgPrimes[i] >= dwSize || i == (ARRAYSIZE(s_rgPrimes)-1));
    m_cBins = s_rgPrimes[i];

    if (!MemAlloc((LPVOID*)&m_rgBins, m_cBins * sizeof(HASHENTRY)))
        return E_OUTOFMEMORY;

    ZeroMemory(m_rgBins, m_cBins * sizeof(HASHENTRY));

    return NOERROR;
}

DWORD CHash::Hash(LPSTR psz)
{
    DWORD h = 0;
    while (*psz)
        h = ((h << 4) + *psz++ + (h >> 28));
    return (h % m_cBins);
}

HRESULT CHash::Insert(LPSTR psz, LPVOID pv, DWORD dwFlags)
{
    PHASHENTRY phe = &m_rgBins[Hash(psz)];

    if (m_fDupe &&
        (!(psz = PszDupA(psz))))
        return E_OUTOFMEMORY;

    if (HF_NO_DUPLICATES & dwFlags)
    {
        PHASHENTRY pheCurrent = phe;

        // Check for duplicate entries: if found, do not insert this entry
        do
        {
            if (pheCurrent->pszKey && FastStrCmp(pheCurrent->pszKey, psz))
            {
                // This is already in our hash table. Replace data value
                pheCurrent->pv = pv;
                if (m_fDupe)
                    MemFree(psz);

                return NOERROR;
            }

            // Advance pointer
            pheCurrent = pheCurrent->pheNext;
        } while (NULL != pheCurrent);
    }

    if (phe->pszKey)
        {
        PHASHENTRY pheNew;

        if (!MemAlloc((LPVOID*)&pheNew, sizeof(HASHENTRY)))
            {
            if (m_fDupe)
                MemFree(psz);
            return E_OUTOFMEMORY;
            }
        pheNew->pheNext = phe->pheNext;
        phe->pheNext = pheNew;
        phe = pheNew;
        }

    phe->pszKey = psz;
    phe->pv = pv;
    return NOERROR;
}

HRESULT CHash::Find(LPSTR psz, BOOL fRemove, LPVOID * ppv)
{
    PHASHENTRY  phe     = &m_rgBins[Hash(psz)],
                phePrev = NULL,
                pheTemp;

    if (phe->pszKey)
    {
        do
        {
            if (FastStrCmp(phe->pszKey, psz))
            {
                *ppv = phe->pv;
                if (fRemove)
                {
                    if (m_fDupe)
                        SafeMemFree(phe->pszKey);

                    if (phePrev)
                    {
                        // mid-chain
                        phePrev->pheNext = phe->pheNext;
                        MemFree(phe);
                    }
                    else
                    {
                        // head of bucket
                        phe->pv = NULL;
                        phe->pszKey = NULL;
                        pheTemp = phe->pheNext;
                        if (pheTemp)
                        {
                            CopyMemory(phe, pheTemp, sizeof(HASHENTRY));
                            MemFree(pheTemp);
                        }
                    }
                }
                return NOERROR;
            }
            phePrev = phe;
            phe = phe->pheNext;
        }
        while (phe);
    }
    return CO_E_NOMATCHINGNAMEFOUND;
}

HRESULT CHash::Replace(LPSTR psz, LPVOID pv)
{
    PHASHENTRY phe = &m_rgBins[Hash(psz)];

    if (phe->pszKey)
        {
        do
            {
            if (FastStrCmp(phe->pszKey, psz))
                {
                phe->pv = pv;
                return NOERROR;
                }
            phe = phe->pheNext;
            }
        while (phe);
        }
    return CO_E_NOMATCHINGNAMEFOUND;
}


HRESULT CHash::Reset()
{
    m_iListBinEnum = 0;
    m_pLastEntryEnum = &m_rgBins[0];
    return S_OK;
}

HRESULT CHash::Next(ULONG cFetch, LPVOID **prgpv, ULONG *pcFetched)
{
    LPVOID      *rgpv;
    ULONG       cFound=0;
    PHASHENTRY  phe;
    HRESULT     hr;

    if (!MemAlloc((LPVOID *)&rgpv, sizeof(LPVOID) * cFetch))
        return E_OUTOFMEMORY;
 
    ZeroMemory(rgpv, sizeof(LPVOID) * cFetch);

    while (m_pLastEntryEnum)
    {
        if (m_pLastEntryEnum->pszKey)
            rgpv[cFound++] = m_pLastEntryEnum->pv;
        
        m_pLastEntryEnum = m_pLastEntryEnum->pheNext;
        
        if (!m_pLastEntryEnum && m_iListBinEnum < m_cBins -1)
            m_pLastEntryEnum = &m_rgBins[++m_iListBinEnum];

        if (cFound == cFetch)
            break;
    }

    hr = cFound ? (cFound == cFetch ? S_OK : S_FALSE) : E_FAIL;
    if (FAILED(hr))
    {
        MemFree(rgpv);
        rgpv = NULL;
    }

    *prgpv = rgpv;
    *pcFetched = cFound;
    return hr;
}


#ifdef DEBUG
void CHash::Stats()
{
    DWORD       dwLongest = 0;
    DWORD       dwCollisions = 0;
    DWORD       dwTotalCost = 0;
    DWORD       dwItems = 0;
    DWORD       dwLength;
    DWORD       dw;
    PHASHENTRY  phe;
    DWORD       rgLen[100];

    TraceCall("CHash::Stats()");

    ZeroMemory(rgLen, sizeof(rgLen));

    for (dw = 0; dw < m_cBins; dw++)
        {
        dwLength = 0;
        if (m_rgBins[dw].pszKey)
            {
            dwLength++;
            phe = m_rgBins[dw].pheNext;
            while (phe)
                {
                dwCollisions++;
                dwLength++;
                phe = phe->pheNext;
                }
            }
        if (dwLength > dwLongest)
            dwLongest = dwLength;
        dwTotalCost += (dwLength * (dwLength + 1)) / 2;
        dwItems += dwLength;
        rgLen[dwLength]++;
        }

    TraceInfo(_MSG("\tdwCollisions = %ld\r\n\tdwLongest = %ld\r\n\tdwItems = %ld\r\n\tdwTotalCost = %ld",
                dwCollisions, dwLongest, dwItems, dwTotalCost));

    for (dw = 0; dw <= dwLongest; dw++)
        TraceInfo(_MSG("Len %d: %d", dw, rgLen[dw]));
}
#endif


//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CHash::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IHashTable))
        *lplpObj = (LPVOID)(IHashTable *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\mhtml.h ===
/*
 *    m h t m l . c p p
 *    
 *    Purpose:
 *        MHTML packing utilities
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _MHTML_H
#define _MHTML_H



HRESULT SaveAsMHTML(IHTMLDocument2 *pDoc, DWORD dwFlags, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, IHashTable *pHashRestricted);
HRESULT HashExternalReferences(IHTMLDocument2 *pDoc, IMimeMessage *pMsg, IHashTable **ppHash);



#endif // _MHTML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\hash.h ===
/*
 *    hash.h
 *    
 *    Purpose:
 *        implementation of a string hash table
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Mar 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#ifndef __HASH_H
#define __HASH_H

typedef struct tagHASHENTRY *PHASHENTRY;
typedef struct tagHASHENTRY {
    LPSTR       pszKey;
    LPVOID      pv;
    PHASHENTRY  pheNext;        
} HASHENTRY;

class CHash :
    public IHashTable,
    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // IHashTable
    HRESULT STDMETHODCALLTYPE Init(DWORD dwSize, BOOL fDupeKeys);
    HRESULT STDMETHODCALLTYPE Insert(LPSTR psz, LPVOID pv, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE Replace(LPSTR psz, LPVOID pv);
    HRESULT STDMETHODCALLTYPE Find(LPSTR psz, BOOL fRemove, LPVOID *ppv);
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Next(ULONG cFetch, LPVOID **prgpv, ULONG *pcFetched);


    CHash(IUnknown *pUnkOuter=NULL);
    virtual ~CHash();

protected:
    inline DWORD Hash(LPSTR psz);

    DWORD       m_cBins,
                m_iListBinEnum;
    PHASHENTRY  m_rgBins,
                m_pLastEntryEnum;
    BOOL        m_fDupe;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

#ifdef DEBUG
    void Stats();
#endif

};

#endif // __HASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\mimeapi.cpp ===
#include <pch.hxx>
#include "dllmain.h"
#include "demand.h"
#include "resource.h"
#include "saferun.h"
#include "viewsrc.h"
#include "triutil.h"
#include "mhtml.h"

MIMEOLEAPI MimeEditViewSource(HWND hwndParent, IMimeMessage *pMsg)
{
    TraceCall("MimeEditViewSource");

    return ViewSource(hwndParent, pMsg);
}

MIMEOLEAPI MimeEditVerifyTrust(HWND hwnd, LPCSTR pszFileName, LPCSTR pszPathName)
{
    LPWSTR  pszFileNameW = NULL,
            pszPathNameW = NULL; 
    HRESULT hr = S_OK;

    TraceCall ("MimeEditVerifyTrust");

    AssertSz(pszFileName, "Someone forgot to pass in name. Bummer.");
    AssertSz(pszPathName, "Someone forgot to pass in name. Bummer.");

    IF_NULLEXIT(pszFileNameW = PszToUnicode(CP_ACP, pszFileName));
    IF_NULLEXIT(pszPathNameW = PszToUnicode(CP_ACP, pszPathName));

    hr = VerifyTrust(hwnd, pszFileNameW, pszFileNameW);

exit:
    MemFree(pszFileNameW);
    MemFree(pszPathNameW);

    return TraceResult(hr);
}

MIMEOLEAPI MimeEditIsSafeToRun(HWND hwnd, LPCSTR pszFileName, BOOL fPrompt)
{
    HRESULT hr = S_OK;
    LPWSTR pwszFileName;

    TraceCall ("MimeEditIsSafeToRun");

    Assert(pszFileName);

    IF_NULLEXIT(pwszFileName = PszToUnicode(CP_ACP, pszFileName));
    IF_FAILEXIT(hr = IsSafeToRun(hwnd, pwszFileName, fPrompt));

exit:    
    MemFree(pwszFileName);

    return hr;
}


MIMEOLEAPI MimeEditGetBackgroundImageUrl(IUnknown *pDocUnk, BSTR *pbstr)
{
    IHTMLDocument2  *pDoc;
    HRESULT         hr;

    TraceCall ("MimeEditGetBackgroundImageUrl");

    if (pDocUnk == NULL || pbstr == NULL)
        return E_INVALIDARG;

    hr = pDocUnk->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
    if (!FAILED(hr))
    {
        hr = GetBackgroundImage(pDoc, pbstr);
        pDoc->Release();
    }
    return hr;
}

MIMEOLEAPI MimeEditCreateMimeDocument(IUnknown *pDocUnk, IMimeMessage *pMsgSrc, DWORD dwFlags, IMimeMessage **ppMsg)
{
    HRESULT         hr;
    IMimeMessage    *pMsg=0;
    IHTMLDocument2  *pDoc=0;
    
    TraceCall ("MimeEditCreateMimeDocument");

    if (pDocUnk == NULL || ppMsg == NULL)
        return TraceResult(E_INVALIDARG);

    hr = pDocUnk->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
    if (FAILED(hr))
        goto error;

    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (FAILED(hr))
        goto error;

    hr = SaveAsMHTML(pDoc, dwFlags, pMsgSrc, pMsg, NULL);
    if (FAILED(hr))
        goto error;

    *ppMsg = pMsg;
    pMsg = NULL;

error:
    ReleaseObj(pMsg);
    ReleaseObj(pDoc);
    return hr;
}


MIMEOLEAPI MimeEditDocumentFromStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv)
{
    TraceCall ("MimeEditDocumentFromStream");

    if (pstm==NULL || ppv==NULL)
        return TraceResult(E_FAIL);
        
    return HrCreateSyncTridentFromStream(pstm, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\mimeutil.h ===
// --------------------------------------------------------------------------------
// Mimeutil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __MIMEUTIL_H
#define __MIMEUTIL_H

#define SafeMimeOleFree SafeMemFree

// --------------------------------------------------------------------------------
// Random Utility Functions
// --------------------------------------------------------------------------------
HRESULT HrComputeLineCount(LPMIMEMESSAGE pMsg, LPDWORD pdw);
HRESULT HrHasEncodedBodyParts(LPMIMEMESSAGE pMsg, ULONG cBody, LPHBODY rghBody);
HRESULT HrHasBodyParts(LPMIMEMESSAGE pMsg);
HRESULT HrIsBodyEncoded(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrCopyHeader(LPMIMEMESSAGE pMsgDest, HBODY hBodyDest, LPMIMEMESSAGE pMsgSrc, HBODY hBodySrc, LPCSTR pszName);

// --------------------------------------------------------------------------------
// MHTML Utility Functions
// --------------------------------------------------------------------------------
HRESULT HrIsInRelatedSection(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt);

// --------------------------------------------------------------------------------
// Random functions that probably shouldn't even be in this file
// --------------------------------------------------------------------------------
HRESULT HrEscapeQuotedString (LPTSTR pszIn, LPTSTR *ppszOut);
// sizeof(lspzBuffer) needs to be == or > CCHMAX_CSET_NAME
HRESULT HrGetMetaTagName(HCHARSET hCharset, LPSTR lpszBuffer);

// --------------------------------------------------------------------------------
// international support
// --------------------------------------------------------------------------------
UINT uCodePageFromCharset(HCHARSET hCharset);
UINT uCodePageFromMsg(LPMIMEMESSAGE pMsg);
HRESULT HrIStreamWToInetCset(LPSTREAM pstmW, HCHARSET hCharset, LPSTREAM *ppstm);

// --------------------------------------------------------------------------------
// functions for ghosting props
// --------------------------------------------------------------------------------
HRESULT HrMarkGhosted(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrIsGhosted(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrGhostKids(LPMIMEMESSAGE pMsg, HBODY hBody);
HRESULT HrDeleteGhostedKids(LPMIMEMESSAGE pMsg, HBODY hBody);

#endif // __MIMEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\oleutil.cpp ===
/*
 *    o l e u t i l . c p p
 *    
 *    Purpose:
 *        OLE utilities
 *
 *  History
 *      Feb '97: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include "pch.hxx"
#include "msoert.h"
#include "oleutil.h"
#include "demand.h"

ASSERTDATA



HRESULT HrGetDataStream(LPUNKNOWN pUnk, CLIPFORMAT cf, LPSTREAM *ppstm)
{
    LPDATAOBJECT            pDataObj=0;
    HRESULT                 hr;
    FORMATETC               fetc={cf, 0, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    STGMEDIUM               stgmed;

    ZeroMemory(&stgmed, sizeof(STGMEDIUM));

    if (!pUnk || !ppstm)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IDataObject, (LPVOID *)&pDataObj);
    if(FAILED(hr))
        goto error;

    hr=pDataObj->GetData(&fetc, &stgmed);
    if(FAILED(hr))
        goto error;

    Assert(stgmed.pstm);
    *ppstm = stgmed.pstm;
    (*ppstm)->AddRef();

    // addref the pUnk as it will be release in releasestgmed
    if(stgmed.pUnkForRelease)
        stgmed.pUnkForRelease->AddRef();
    ReleaseStgMedium(&stgmed);

error:
    ReleaseObj(pDataObj);
    return hr;
}


HRESULT CmdSelectAllCopy(LPOLECOMMANDTARGET pCmdTarget)
{
    HRESULT hr;

    if (!pCmdTarget)
        return E_FAIL;

    hr=pCmdTarget->Exec(NULL, OLECMDID_SELECTALL, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    if (FAILED(hr))
        goto error;

    hr=pCmdTarget->Exec(NULL, OLECMDID_COPY, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    if (FAILED(hr))
        goto error;
error:
    return hr;
}

HRESULT HrInitNew(LPUNKNOWN pUnk)
{
    LPPERSISTSTREAMINIT ppsi=0;
    HRESULT hr;

    if (!pUnk)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi);
    if (FAILED(hr))
        goto error;

    hr = ppsi->InitNew();

error:
    ReleaseObj(ppsi);
    return hr;
}

HRESULT HrIPersistStreamInitLoad(LPUNKNOWN pUnk, LPSTREAM pstm)
{
    LPPERSISTSTREAMINIT ppsi=0;
    HRESULT hr;

    if (!pUnk)
        return E_INVALIDARG;

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        goto error;

    hr=pUnk->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi);
    if (FAILED(hr))
        goto error;

    hr = ppsi->Load(pstm);

error:
    ReleaseObj(ppsi);
    return hr;
}



HRESULT HrIPersistFileSave(LPUNKNOWN pUnk, LPSTR lpszFile)
{
    HRESULT         hr;
    LPPERSISTFILE   ppf=0;
    WCHAR           szFileW[MAX_PATH];

    Assert(lstrlen(lpszFile) <= MAX_PATH);

    if (lpszFile == NULL || *lpszFile == NULL)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto error;

    if(!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpszFile, -1, szFileW, MAX_PATH))
        {
        hr=E_FAIL;
        goto error;
        }

    hr=ppf->Save(szFileW, FALSE);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(ppf);
    return hr;
}


HRESULT HrIPersistFileLoad(LPUNKNOWN pUnk, LPSTR lpszFile)
{
    HRESULT         hr;
    LPPERSISTFILE   ppf=0;
    WCHAR           szFileW[MAX_PATH];

    Assert(lstrlen(lpszFile) <= MAX_PATH);

    if (lpszFile == NULL || *lpszFile == NULL)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistFile, (LPVOID *)&ppf);
    if (FAILED(hr))
        goto error;

    if(!MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, lpszFile, -1, szFileW, MAX_PATH))
        {
        hr=E_FAIL;
        goto error;
        }

    hr=ppf->Load(szFileW, STGM_READ|STGM_SHARE_DENY_NONE);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(ppf);
    return hr;
}



HRESULT GetDispProp(IDispatch * pDisp, DISPID dispid, LCID lcid, VARIANT *pvar, EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    Assert(pDisp);
    Assert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    return (pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr));
}

HRESULT SetDispProp(IDispatch *pDisp, DISPID dispid, LCID lcid, VARIANTARG *pvarg, EXCEPINFO *pexcepinfo, DWORD dwFlags)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT;     // Dispid of prop arg.
    DISPPARAMS  dp;                                 // Params for Invoke
    UINT        uiErr;                              // Invoke error param.

    Assert(pDisp);
    Assert(pvarg);

    dp.rgvarg = pvarg;
    dp.cArgs = 1;

    if (dwFlags & DISPATCH_METHOD)
    {
        dp.cNamedArgs = 0;
        dp.rgdispidNamedArgs = NULL;
    }
    else
    {
        dp.cNamedArgs = 1;
        dp.rgdispidNamedArgs = &dispidPut;
    }

    return pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            (UINT)dwFlags,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);
}

HRESULT HrLoadSync(LPUNKNOWN pUnk, LPSTR lpszFile)
{
    LPSTREAM    pstm=0;
    HRESULT     hr;

    hr = OpenFileStream(lpszFile, OPEN_EXISTING	, GENERIC_READ, &pstm);
    if (!FAILED(hr))
        {
        hr = HrIPersistStreamInitLoad(pUnk, pstm);
        pstm->Release();
        }
   return hr;    
}


HRESULT HrCoTaskStringDupeToW(LPCSTR lpsz, LPOLESTR *ppszW)
{
    HRESULT hr = NOERROR;
    ULONG   cch, cchRet;
    LPCSTR  lpszPath;

    if (lpsz == NULL || ppszW == NULL)
        return E_INVALIDARG;

    *ppszW = 0;

    cch = lstrlen(lpsz)+1;

    // allocate a wide-string with enough character to hold string
    *ppszW=(LPOLESTR)CoTaskMemAlloc(cch * sizeof(OLECHAR));
    if(!*ppszW)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

    cchRet=MultiByteToWideChar(CP_ACP, 0, lpsz, cch, *ppszW, cch);
    if(!cchRet)
        {
        hr=E_FAIL;
        goto error;
        }

error:
    if(FAILED(hr))
        CoTaskMemFree(*ppszW);
    return hr;
}

#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN Debug Code
//

void DebugPrintInterface(REFIID riid, char *szPrefix)
{
    LPOLESTR    pszW=0;
    char        szGuid[MAX_PATH];
    char        szTmp[MAX_PATH];
    char        szOut[MAX_PATH];
    LONG        cb=MAX_PATH;
    HKEY        hk=0;

    TraceCall("DebugPrintInterface");
    
    AssertSz(szPrefix, "Hey! Atleast pass an empty string!");

    StringFromIID(riid, &pszW);

    WideCharToMultiByte(CP_ACP, 0, pszW, -1, szGuid, MAX_PATH, NULL, NULL);
        
    lstrcpy(szTmp, "SOFTWARE\\Classes\\Interface\\");
    lstrcat(szTmp, szGuid);
    
    if((RegOpenKey(HKEY_LOCAL_MACHINE, szTmp, &hk)==ERROR_SUCCESS) &&
        RegQueryValue(hk, NULL, szTmp, &cb)==ERROR_SUCCESS)
        wsprintf(szOut, "%s: {%s}", szPrefix, szTmp);
    else    
        wsprintf(szOut, "%s: [notfound] %s", szPrefix, szGuid);

    TraceInfo(szOut);

    if(hk)
        RegCloseKey(hk);
    if(pszW)
        CoTaskMemFree(pszW);
}

void DebugPrintCmdIdBlock(ULONG cCmds, OLECMD *rgCmds)
{
    char    sz[255],
            szT[255];

    TraceCall("DebugPrintCmdIdBlock");
    wsprintf(sz, "CmdId:: {%d,{", cCmds);
    for (ULONG ul=0;ul<cCmds; ul++)
        {
        switch (rgCmds[ul].cmdID)
            {
            case OLECMDID_COPY:
                lstrcat(sz, "copy");
                break;

            case OLECMDID_CUT:
                lstrcat(sz, "cut");
                break;
            
            case OLECMDID_PASTE:
                lstrcat(sz, "paste");
                break;

            default:
                wsprintf(szT, "%d", rgCmds[ul].cmdID);
                lstrcat(sz, szT);
            }
            if(ul+1!=cCmds)
                lstrcat(sz, ", ");
        }
    lstrcat(sz, "}}");
    TraceInfo(sz);
}


//
//  END Debug Code
//
/////////////////////////////////////////////////////////////////////////////
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\mhtml.cpp ===
/*
 *    m h t m l . c p p
 *    
 *    Purpose:
 *        MHTML packing utilities
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include "resource.h"
#include "strconst.h"
#include "htmlstr.h"
#include "mimeutil.h"
#include "triutil.h"
#include "util.h"
#include "oleutil.h"
#include "demand.h"
#include "mhtml.h"
#include "tags.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

static const TCHAR   c_szRegExtension[] = "SOFTWARE\\Microsoft\\MimeEdit\\MHTML Extension";



/*
 *  t y p e d e f s
 */

/*
 *  g l o b a l s 
 */
    
/*
 *  f u n c t i o n   p r o t y p e s
 */


/*
 *  f u n c t i o n s
 */


class CPackager
{
public:
    
    CPackager();
    virtual ~CPackager();

    ULONG AddRef();
    ULONG Release();

    HRESULT PackageData(IHTMLDocument2 *pDoc, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, DWORD dwFlags, IHashTable *pHashRestricted);

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsgSrc,
                    *m_pMsgDest;
    IHashTable      *m_pHash,
                    *m_pHashRestricted;

    HRESULT _PackageCollectionData(IMimeEditTagCollection *pCollect);
    HRESULT _PackageUrlData(IMimeEditTag *pTag);

    HRESULT _RemapUrls(IMimeEditTagCollection *pCollect, BOOL fSave);
    HRESULT _CanonicaliseContentId(LPWSTR pszUrlW, BSTR *pbstr);
    HRESULT _ShouldUseContentId(LPSTR pszUrl);
    HRESULT _BuildCollectionTable(DWORD dwFlags, IHTMLDocument2 *pDoc, IMimeEditTagCollection ***prgpCollect, ULONG *pcCount);

};





CPackager::CPackager()
{
    m_cRef = 1;
    m_pMsgSrc = NULL;
    m_pMsgDest = NULL;
    m_pHash = NULL;
    m_pHashRestricted = NULL;
}

CPackager::~CPackager()
{
    ReleaseObj(m_pMsgSrc);
    ReleaseObj(m_pMsgDest);
    ReleaseObj(m_pHash);
    ReleaseObj(m_pHashRestricted);
}


ULONG CPackager::AddRef()
{
    return ++m_cRef;
}

ULONG CPackager::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CPackager::PackageData(IHTMLDocument2 *pDoc, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, DWORD dwFlags, IHashTable *pHashRestricted)
{
    LPSTREAM                pstm;
    HRESULT                 hr,
                            hrWarnings=S_OK;
    HBODY                   hBodyHtml=0;
    IMimeEditTagCollection  **rgpCollect=NULL;
    ULONG                   uCollect,
                            cCollect=0,
                            cItems=0,
                            cCount;

    // BUGBUG: propagate hrWarnings back up
    TraceCall("CBody::Save");

    if (pDoc==NULL || pMsgDest==NULL)
        return E_INVALIDARG;

    ReplaceInterface(m_pMsgSrc, pMsgSrc);
    ReplaceInterface(m_pMsgDest, pMsgDest);
    ReplaceInterface(m_pHashRestricted, pHashRestricted);

    hr = _BuildCollectionTable(dwFlags, pDoc, &rgpCollect, &cCollect);
    if (FAILED(hr))
        hrWarnings = hr;

    // count the number of items we need to package and 
    // prepare a hash-table for duplicate entries
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        Assert (rgpCollect[uCollect]);

        if ((rgpCollect[uCollect])->Count(&cCount)==S_OK)
            cItems+=cCount;
    }

    if (cItems)
    {
        // create the hashtable
        hr = MimeOleCreateHashTable(cItems, TRUE, &m_pHash);
        if (FAILED(hr))
            goto error;
    }

    // package the data required for each collection
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        // package the data
        hr = _PackageCollectionData(rgpCollect[uCollect]);
        if (FAILED(hr))
            goto error;

        if (hr != S_OK)         // retain any 'warnings'
            hrWarnings = hr;

        // map all the URLs to CID:// urls if necessary
        hr = _RemapUrls(rgpCollect[uCollect], TRUE);
        if (FAILED(hr))
            goto error;
    }
        
    // get an HTML stream
    if(dwFlags & MECD_HTML)
    {
        hr = GetBodyStream(pDoc, TRUE, &pstm);
        if (!FAILED(hr))
        {
            hr = pMsgDest->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pstm, &hBodyHtml);
            pstm->Release();
        }

        if (FAILED(hr))
            goto error;
    }

    // get a plain-text stream
    if(dwFlags & MECD_PLAINTEXT)
    {
        hr = GetBodyStream(pDoc, FALSE, &pstm);
        if (!FAILED(hr))
        {
            // if we set a html body part, then be sure to pass in hBodyHtml so Opie knows what the alternate is
            // alternative to.
            hr = pMsgDest->SetTextBody(TXT_PLAIN, IET_UNICODE, hBodyHtml, pstm, NULL);
            pstm->Release();
        }
        
        if (FAILED(hr))
            goto error;
    }

    
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        // remap all of the URL's back to their original location
        hr = _RemapUrls(rgpCollect[uCollect], FALSE);
        if (FAILED(hr))
            goto error;
    
    }
        
    
error:
    // release the collection objects
    if (rgpCollect)
    {
        for (uCollect = 0; uCollect < cCollect; uCollect++)
            ReleaseObj(rgpCollect[uCollect]);
        MemFree(rgpCollect);
    }
    
    return hr==S_OK ? hrWarnings : hr;
}


HRESULT CPackager::_BuildCollectionTable(DWORD dwFlags, IHTMLDocument2 *pDoc, IMimeEditTagCollection ***prgpCollect, ULONG *pcCount)
{
    IMimeEditTagCollection    **rgpCollect=NULL;
    HKEY                        hkey;
    ULONG                       cPlugin=0,
                                cCount = 0,
                                cAlloc = 0,
                                i,
                                cb;
    TCHAR                       szGUID[MAX_PATH];
    IID                         iid;
    HRESULT                     hr=E_FAIL;
    LONG                        lResult;
    LPWSTR                      pszGuidW;
    
    *prgpCollect = NULL;
    *pcCount = NULL;

    // reserve space for 2 image collections (bgimage and img)
    if (dwFlags & MECD_ENCODEIMAGES)
        cAlloc+=2;

    // reserver space for bgsounds
    if (dwFlags & MECD_ENCODESOUNDS)
        cAlloc++;

    // reserver space for active-movies
    if (dwFlags & MECD_ENCODEVIDEO)
        cAlloc++;

    // reserve space for plugin types
    if ((dwFlags & MECD_ENCODEPLUGINS) && 
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegExtension, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        if (RegQueryInfoKey(hkey, NULL, NULL, 0, &cPlugin, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS &&
            cPlugin > 0)
            cAlloc += cPlugin;
        RegCloseKey(hkey);
    }

    // allocate the table of collection pointers
    if (!MemAlloc((LPVOID *)&rgpCollect, sizeof(IMimeEditTagCollection *) * cAlloc))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }
    
    // zero-init the table
    ZeroMemory((LPVOID)rgpCollect, sizeof(IMimeEditTagCollection *) * cAlloc);


    if (dwFlags & MECD_ENCODEIMAGES)
    {
        // image collection
        if (FAILED(CreateOEImageCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    if (dwFlags & MECD_ENCODEIMAGES)
    {
        // background images
        if (FAILED(CreateBGImageCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    if (dwFlags & MECD_ENCODESOUNDS)
    {
        // background sounds
        if (FAILED(CreateBGSoundCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    
    if (dwFlags & MECD_ENCODEVIDEO)
    {
        // active-movie controls (for MSPHONE)
        if (FAILED(CreateActiveMovieCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    if ((dwFlags & MECD_ENCODEPLUGINS) && 
        cPlugin &&
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegExtension, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        // Start Enumerating the keys
        for (i = 0; i < cPlugin; i++)
        {
            // Enumerate Friendly Names
            cb = sizeof(szGUID);
            lResult = RegEnumKeyEx(hkey, i, szGUID, &cb, 0, NULL, NULL, NULL);

            // No more items
            if (lResult == ERROR_NO_MORE_ITEMS)
                break;

            // Error, lets move onto the next account
            if (lResult != ERROR_SUCCESS)
            {
                Assert(FALSE);
                continue;
            }

            pszGuidW = PszToUnicode(CP_ACP, szGUID);
            if (pszGuidW)
            {
                // convert the string to a guid
                if (IIDFromString(pszGuidW, &iid) == S_OK)
                {
                    // cocreate the plugin
                    if (CoCreateInstance(iid, NULL, CLSCTX_INPROC_SERVER, IID_IMimeEditTagCollection, (LPVOID *)&rgpCollect[cCount])==S_OK)
                    {
                        // try and init the document
                        if (!FAILED((rgpCollect[cCount])->Init(pDoc)))
                        {
                            cCount++;
                        }
                        else
                        {
                            SafeRelease(rgpCollect[cCount]);
                        }
                    }
                    else
                        hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
                }
                MemFree(pszGuidW);
            }
        }
        RegCloseKey(hkey);
    }


    *prgpCollect = rgpCollect;
    *pcCount = cCount;
    rgpCollect = NULL;
    hr = S_OK;

error:
    if (rgpCollect)
    {   
        for (i = 0; i < cAlloc; i++)
            SafeRelease(rgpCollect[i]);

        MemFree(rgpCollect);
    }
    return hr;
}


HRESULT CPackager::_PackageCollectionData(IMimeEditTagCollection *pCollect)
{
    ULONG           cFetched;
    IMimeEditTag    *pTag;
    BOOL            fBadLinks = FALSE;

    Assert (pCollect);

    pCollect->Reset();

    while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
    {
        Assert (pTag);

        if (pTag->CanPackage() != S_OK ||
            _PackageUrlData(pTag) != S_OK)
        {
            // we failed to package this body part. Be sure to return a warning when we're done
            // but let's keep trucking for now...
            fBadLinks = TRUE;
        }
        pTag->Release();
    }

    return fBadLinks ? MIMEEDIT_W_BADURLSNOTATTACHED : S_OK;;
}


HRESULT CPackager::_PackageUrlData(IMimeEditTag *pTag)
{
    HRESULT     hr=S_OK;
    LPSTREAM    pstm;
    HBODY       hBody=0,
                hBodyOld;
    LPSTR       lpszCID=0,
                lpszCIDUrl;
    LPSTR       pszUrlA=0,
                pszBody;

    BSTR        bstrSrc=NULL,
                bstrCID=NULL;
    LPWSTR      pszMimeTypeW=NULL;

    if (pTag == NULL)
        return E_INVALIDARG;

    pTag->GetSrc(&bstrSrc);

    pszUrlA = PszToANSI(CP_ACP, bstrSrc);
    if (!pszUrlA)
        return TraceResult(E_OUTOFMEMORY);

    // if the URL is a restricted URL then we simply exit without packing any data
    if (m_pHashRestricted &&
        m_pHashRestricted->Find(pszUrlA, FALSE, (LPVOID *)&hBody)==S_OK)
    {
        MemFree(pszUrlA);
        return S_OK;
    }

    // hack: if it's an MHTML: url then we have to fixup to get the cid:
    if (StrCmpNIA(pszUrlA, "mhtml:", 6)==0)
    {
        if (!FAILED(MimeOleParseMhtmlUrl(pszUrlA, NULL, &pszBody)))
        {
            // pszBody pszUrlA is guarnteed to be smaller 
            lstrcpy(pszUrlA, pszBody);
            SafeMimeOleFree(pszBody);
        }
    }
    
    if (m_pHash && 
        m_pHash->Find(pszUrlA, FALSE, (LPVOID *)&hBody)==S_OK)
    {
        // we've already seen this url one before in this document, and have it's HBODY already
        // so there's no need to do any work
        // try and get the content-id incase the caller is interested
        
        // BUGBUG? possible more than CID need to be ported here...
        MimeOleGetBodyPropA(m_pMsgDest, hBody, PIDTOSTR(PID_HDR_CNTID), NOFLAGS, &lpszCID);
        goto found;
    }

    // see if szUrl is in the related section of the source message
    if (m_pMsgSrc && 
        m_pMsgSrc->ResolveURL(NULL, NULL, pszUrlA, 0, &hBody)==S_OK)
    {
        hBodyOld = hBody;
        
        // this URL is already in the related section, and we haven't seen it already.
        // then let's bind to the data and attach it
        if (m_pMsgSrc->BindToObject(hBody, IID_IStream, (LPVOID *)&pstm)==S_OK)
        {
            // if it's a FILE:// url we use CID: else we use Content-Location
            hr = m_pMsgDest->AttachURL(NULL, pszUrlA, (_ShouldUseContentId(pszUrlA)==S_OK ? URL_ATTACH_GENERATE_CID : 0 )|URL_ATTACH_SET_CNTTYPE, pstm, &lpszCID, &hBody);
            pstm->Release();
        }
        
        // be sure to copy the old content-type and filename over
        HrCopyHeader(m_pMsgDest, hBody, m_pMsgSrc, hBodyOld, PIDTOSTR(PID_HDR_CNTTYPE));
        HrCopyHeader(m_pMsgDest, hBody, m_pMsgSrc, hBodyOld, PIDTOSTR(PID_HDR_CNTLOC));
        HrCopyHeader(m_pMsgDest, hBody, m_pMsgSrc, hBodyOld, PIDTOSTR(STR_PAR_FILENAME));
    }
    else
    {
        // if not, then let's try and bind to it ourselves. We don't go thro' MimeOle for this, as we want to
        // fail if the URL is bad, so we don't add the part to the Tree.
        hr = HrBindToUrl(pszUrlA, &pstm);
        if (!FAILED(hr))
        {
            hr = SniffStreamForMimeType(pstm, &pszMimeTypeW);
            if (!FAILED(hr))
            {
                if (pTag->IsValidMimeType(pszMimeTypeW)==S_OK)
                {
                    LPWSTR  pszFileNameW;

                    // if it's a FILE:// url we use CID: else we use Content-Location
                    hr = m_pMsgDest->AttachURL(NULL, pszUrlA, (_ShouldUseContentId(pszUrlA)==S_OK ? URL_ATTACH_GENERATE_CID : 0 )|URL_ATTACH_SET_CNTTYPE, pstm, &lpszCID, &hBody);
                    if (!FAILED(hr))
                    {
                        // if attaching a new attachment, try and sniff the file-name
                        pszFileNameW = PathFindFileNameW(bstrSrc);
                        if (pszFileNameW)
                            MimeOleSetBodyPropW(m_pMsgDest, hBody, PIDTOSTR(STR_PAR_FILENAME), NOFLAGS, pszFileNameW);
                    }
                }
                else
                    hr = E_FAIL;
                
                CoTaskMemFree(pszMimeTypeW);
            }
            pstm->Release();
        }
    }

    // add to the hash table
    if (m_pHash && 
        !FAILED(hr) && hBody)
        hr = m_pHash->Insert(pszUrlA, (void*)hBody, NOFLAGS);


found:
    // if we found the content-ID we need to return an allocated BSTR with it in.
    if (lpszCID)
    {
        LPWSTR  pszCIDW;

        pszCIDW = PszToUnicode(CP_ACP, lpszCID);
        if (pszCIDW)
        {
            if (_CanonicaliseContentId(pszCIDW, &bstrCID)==S_OK)
            {
                pTag->SetDest(bstrCID);
                SysFreeString(bstrCID);
            }
            MemFree(pszCIDW);
        }
        SafeMimeOleFree(lpszCID);
    }

    SafeMemFree(pszUrlA);
    return hr;
}

HRESULT CPackager::_ShouldUseContentId(LPSTR pszUrl)
{
    // we use Content-Location for urls that begin with "http:", "https:" and "ftp:" for all
    // others we will use Content-Id

    if (StrCmpNIA(pszUrl, "ftp:", 4)==0 ||
        StrCmpNIA(pszUrl, "http:", 5)==0 ||
        StrCmpNIA(pszUrl, "https:", 6)==0)
        return S_FALSE;

    return S_OK;        
}




HRESULT CPackager::_RemapUrls(IMimeEditTagCollection *pCollect, BOOL fSave)
{
    ULONG       cFetched;
    IMimeEditTag *pTag;

    Assert (pCollect);

    pCollect->Reset();

    while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
    {
        Assert (pTag);

        if (fSave)
            pTag->OnPreSave();
        else 
            pTag->OnPostSave();

        pTag->Release();
    }
    return S_OK;
}

HRESULT CPackager::_CanonicaliseContentId(LPWSTR pszUrlW, BSTR *pbstr)
{
    HRESULT     hr;

    *pbstr = NULL;

    if (StrCmpNIW(pszUrlW, L"cid:", 4)!=0)
    {
        *pbstr = SysAllocStringLen(NULL, lstrlenW(pszUrlW) + 4);
        if (*pbstr)
        {
            StrCpyW(*pbstr, L"cid:");
            StrCatW(*pbstr, pszUrlW);
        }
    }
    else
        *pbstr = SysAllocString(pszUrlW);

    return *pbstr ? S_OK : E_OUTOFMEMORY;
}

HRESULT SaveAsMHTML(IHTMLDocument2 *pDoc, DWORD dwFlags, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, IHashTable *pHashRestricted)
{
    CPackager   *pPacker=0;
    HRESULT     hr;

    TraceCall("CBody::Save");

    pPacker = new CPackager();
    if (!pPacker)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    hr = pPacker->PackageData(pDoc, pMsgSrc, pMsgDest, dwFlags, pHashRestricted);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pPacker);
    return hr;
}




HRESULT HashExternalReferences(IHTMLDocument2 *pDoc, IMimeMessage *pMsg, IHashTable **ppHash)
{
    HRESULT                 hr;
    IMimeEditTagCollection  *rgpCollect[4];
    IMimeEditTagCollection  *pCollect;
    ULONG                   uCollect,
                            cCollect=0,
                            cItems=0,
                            cCount,
                            cFetched;
    IHashTable              *pHash;
    IMimeEditTag            *pTag;
    BSTR                    bstrSrc;
    LPSTR                   pszUrlA;

    // keep trucking if we fail, to catch as many as we can
    *ppHash = NULL;

    // image collection
    if (CreateOEImageCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // background images
    if (CreateBGImageCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // background sounds
    if (CreateBGSoundCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // active-movie controls (for MSPHONE)
    if (CreateActiveMovieCollection(pDoc, &rgpCollect[cCollect])==S_OK)
        cCollect++;

    // count the number of items we need to package and 
    // prepare a hash-table for duplicate entries
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        Assert (rgpCollect[uCollect]);

        if ((rgpCollect[uCollect])->Count(&cCount)==S_OK)
            cItems+=cCount;
    }

    // create the hashtable
    hr = MimeOleCreateHashTable(cItems, TRUE, &pHash);
    if (FAILED(hr))
        goto error;

    // looks for external references in each
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        pCollect = rgpCollect[uCollect];
        if (pCollect)
        {
            pCollect->Reset();
            
            while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
            {
                Assert (pTag);

                if (pTag->GetSrc(&bstrSrc)==S_OK)
                {
                    pszUrlA = PszToANSI(CP_ACP, bstrSrc);
                    if (pszUrlA)
                    {
                        if (HrFindUrlInMsg(pMsg, pszUrlA, FINDURL_SEARCH_RELATED_ONLY, NULL)!=S_OK)
                        {
                            // this URL was not in the message and it external
                            // let's track it as a restricted URL in our hash
                            pHash->Insert(pszUrlA, NULL, NOFLAGS);
                        }
                        MemFree(pszUrlA);
                    }
                    SysFreeString(bstrSrc);
                }
                pTag->Release();
            }
            pCollect->Release();
        }
    }
        
    // return our new hash
    *ppHash = pHash;
    pHash = NULL;

error:
    ReleaseObj(pHash);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\mimeutil.cpp ===
// --------------------------------------------------------------------------------
// Mimeutil.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "resource.h"
#include "dllmain.h"
#include "mimeutil.h"
#include "demand.h"

HRESULT HrHasBodyParts(LPMIMEMESSAGE pMsg)
{
    DWORD   dwFlags=0;

    if (pMsg)
        pMsg->GetFlags(&dwFlags);

    return (dwFlags&IMF_HTML || dwFlags & IMF_PLAIN)? S_OK : S_FALSE;
}

HRESULT HrHasEncodedBodyParts(LPMIMEMESSAGE pMsg, ULONG cBody, LPHBODY rghBody)
{
    ULONG   uBody;

    if (cBody==0 || rghBody==NULL)
        return S_FALSE;

    for (uBody=0; uBody<cBody; uBody++)
        {
        if (HrIsBodyEncoded(pMsg, rghBody[uBody])==S_OK)
            return S_OK;
        }

    return S_FALSE;
}


/*
 * looks for non-7bit or non-8bit encoding
 */
HRESULT HrIsBodyEncoded(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    LPSTR   lpsz;
    HRESULT hr=S_FALSE;

    if (!FAILED(MimeOleGetBodyPropA(pMsg, hBody, PIDTOSTR(PID_HDR_CNTXFER), NOFLAGS, &lpsz)))
        {
        if (lstrcmpi(lpsz, STR_ENC_7BIT)!=0 && lstrcmpi(lpsz, STR_ENC_8BIT)!=0)
            hr=S_OK;

        SafeMimeOleFree(lpsz);
        }
    return hr;
}

// sizeof(lspzBuffer) needs to be == or > CCHMAX_CSET_NAME
HRESULT HrGetMetaTagName(HCHARSET hCharset, LPSTR lpszBuffer)
{
    INETCSETINFO    rCsetInfo;
    CODEPAGEINFO    rCodePage;
    HRESULT         hr;
    LPSTR           psz;

    if (hCharset == NULL)
        return E_INVALIDARG;

    hr = MimeOleGetCharsetInfo(hCharset, &rCsetInfo);
    if (FAILED(hr))
        goto error;

    hr = MimeOleGetCodePageInfo(rCsetInfo.cpiInternet, &rCodePage);
    if (FAILED(hr))
        goto error;

    psz = rCodePage.szWebCset;

    if (FIsEmpty(psz))      // if no webset, try the body cset
        psz = rCodePage.szBodyCset;

    if (FIsEmpty(psz))
        {
        hr = E_FAIL;
        goto error;
        }

    lstrcpy(lpszBuffer, psz);

error:
    return hr;
}



HRESULT HrIsInRelatedSection(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HBODY   hBodyParent;

    if (!FAILED(pMsg->GetBody(IBL_PARENT, hBody, &hBodyParent)) &&
            (pMsg->IsContentType(hBodyParent, STR_CNT_MULTIPART, STR_SUB_RELATED)==S_OK))
        return S_OK;
    else
        return S_FALSE;
}


HRESULT HrMarkGhosted(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT pv;

    Assert (pMsg && hBody);

    pv.vt = VT_I4;
    pv.lVal = TRUE;
    return pMsg->SetBodyProp(hBody, PIDTOSTR(PID_ATT_GHOSTED), NOFLAGS, &pv);
}

HRESULT HrIsReferencedUrl(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT rVariant;

    rVariant.vt = VT_I4;

    if (!FAILED(pMsg->GetBodyProp(hBody, PIDTOSTR(PID_ATT_RENDERED), NOFLAGS, &rVariant)) && rVariant.ulVal)
        return S_OK;

    return S_FALSE;
}


HRESULT HrIsGhosted(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    PROPVARIANT pv;

    pv.vt = VT_I4;



    if (pMsg->GetBodyProp(hBody, PIDTOSTR(PID_ATT_GHOSTED), NOFLAGS, &pv)==S_OK &&
        pv.vt == VT_I4 && pv.lVal == TRUE)
        return S_OK;
    else
        return S_FALSE;
}


HRESULT HrGhostKids(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HRESULT hr=S_OK;

    if (pMsg && hBody)
        {
        if (!FAILED(pMsg->GetBody(IBL_FIRST, hBody, &hBody)))
            {
            do
                {
                if (HrIsReferencedUrl(pMsg, hBody)==S_OK)
                    {
                    hr = HrMarkGhosted(pMsg, hBody);
                    if (FAILED(hr))
                        goto error;
                    }
                }
            while (!FAILED(pMsg->GetBody(IBL_NEXT, hBody, &hBody)));
            }
        }
error:
    return hr;
}


HRESULT HrDeleteGhostedKids(LPMIMEMESSAGE pMsg, HBODY hBody)
{
    HRESULT     hr=S_OK;
    ULONG       cKids=0,
                uKid;
    LPHBODY     rghKids=0;

    pMsg->CountBodies(hBody, FALSE, &cKids);
    if (cKids)
        {
        if (!MemAlloc((LPVOID *)&rghKids, sizeof(HBODY) * cKids))
            {
            hr = E_OUTOFMEMORY;
            goto error;
            }

        cKids = 0;

        if (!FAILED(pMsg->GetBody(IBL_FIRST, hBody, &hBody)))
            {
            do
                {
                if (HrIsGhosted(pMsg, hBody)==S_OK)
                    {
                    rghKids[cKids++] = hBody;
                    }
                }
            while (!FAILED(pMsg->GetBody(IBL_NEXT, hBody, &hBody)));
            }

        for (uKid = 0; uKid < cKids; uKid++)
            {
            hr=pMsg->DeleteBody(rghKids[uKid], 0);
            if (FAILED(hr))
                goto error;
            }

        }

error:
    SafeMemFree(rghKids);
    return hr;
}

UINT uCodePageFromCharset(HCHARSET hCharset)
{
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = GetACP();

    if (hCharset &&
        (MimeOleGetCharsetInfo(hCharset, &CsetInfo)==S_OK))
        uiCodePage = CsetInfo.cpiInternet ;

    return uiCodePage;
}

UINT uCodePageFromMsg(LPMIMEMESSAGE pMsg)
{
    HCHARSET hCharset=0;

    if (pMsg)
        pMsg->GetCharset(&hCharset);
    return uCodePageFromCharset(hCharset);
}



HRESULT HrIStreamWToInetCset(LPSTREAM pstmW, HCHARSET hCharset, LPSTREAM *ppstmOut)
{
    IMimeBody   *pBody;
    HRESULT     hr;

    hr = MimeOleCreateBody(&pBody);
    if (!FAILED(hr))
        {
        hr = pBody->InitNew();
        if (!FAILED(hr))
            {
            hr = pBody->SetData(IET_UNICODE, STR_CNT_TEXT, STR_SUB_HTML, IID_IStream, pstmW);
            if (!FAILED(hr))
                {
                hr = pBody->SetCharset(hCharset, CSET_APPLY_ALL);
                if (!FAILED(hr))
                    hr =  pBody->GetData(IET_INETCSET, ppstmOut);
                }
            }
        pBody->Release();
        }
    return hr;
}


HRESULT HrCopyHeader(LPMIMEMESSAGE pMsgDest, HBODY hBodyDest, LPMIMEMESSAGE pMsgSrc, HBODY hBodySrc, LPCSTR pszName)
{
    LPSTR   lpszProp;
    HRESULT hr;

    hr = MimeOleGetBodyPropA(pMsgSrc, hBodySrc, pszName, NOFLAGS, &lpszProp);
    if (!FAILED(hr))
        {
        hr = MimeOleSetBodyPropA(pMsgDest, hBodyDest, pszName, NOFLAGS, lpszProp);
        SafeMimeOleFree(lpszProp);
        }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\oleutil.h ===
/*
 *    o l e u t i l . h
 *    
 *    Purpose: OLE utilities
 *
 *    Owner: brettm 
 *
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _OLEUTIL_H
#define _OLEUTIL_H

#include <docobj.h>

/* 
 * Persist Functions
 */
HRESULT HrInitNew(LPUNKNOWN pUnk);
HRESULT HrIPersistStreamLoad(LPUNKNOWN pUnk, LPSTREAM pstm);
HRESULT HrIPersistStreamInitLoad(LPUNKNOWN pUnk, LPSTREAM pstm);
HRESULT HrIPersistFileSave(LPUNKNOWN pUnk, LPSTR lpszFile);
HRESULT HrIPersistFileLoad(LPUNKNOWN pUnk, LPSTR lpszFile);
HRESULT HrLoadSync(LPUNKNOWN pUnk, LPSTR lpszFile);

/*
 * Data Object functions
 */
HRESULT HrGetDataStream(LPUNKNOWN pUnk, CLIPFORMAT cf, LPSTREAM *ppstm);
HRESULT CmdSelectAllCopy(LPOLECOMMANDTARGET pCmdTarget);

/*
 * IDispatch Helpers
 */
HRESULT GetDispProp(IDispatch * pDisp, DISPID dispid, LCID lcid, VARIANT *pvar, EXCEPINFO * pexcepinfo);
HRESULT SetDispProp(IDispatch *pDisp, DISPID dispid, LCID lcid, VARIANTARG *pvarg, EXCEPINFO *pexcepinfo, DWORD dwFlags);

/* 
 * OLE Allocator Helpers
 */
HRESULT HrCoTaskStringDupeToW(LPCSTR lpsz, LPOLESTR *ppszW);

#define SafeCoTaskMemFree(_pv)	\
	{							\
    if (_pv)					\
        {						\
        CoTaskMemFree(_pv);		\
        _pv=NULL;				\
        }                       \
    }

/* 
 * Debug Helpers
 */
#ifdef DEBUG
void DebugPrintInterface(REFIID riid, char *szPrefix);
void DebugPrintCmdIdBlock(ULONG cCmds, OLECMD *rgCmds);
#else
#define DebugPrintInterface       1 ? (void)0 : (void)
#define DebugPrintCmdIdBlock         1 ? (void)0 : (void)
#endif

#define RECT_WIDTH(_prc) (_prc->right - _prc->left)
#define RECT_HEIGHT(_prc) (_prc->bottom - _prc->top)

#endif //_OLEUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\plainstm.h ===
/*
 *    p l a i n c n v . h
 *    
 *    Purpose:
 *        Plain Stream -> html converter
 *
 *  History
 *      September '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _PLAINCONV_H
#define _PLAINCONV_H

#define CCHMAX_BUFFER       8192

class CPlainConverter
{
public:
    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    CPlainConverter();
    ~CPlainConverter();

    HRESULT HrConvert(LPSTREAM pstmPlain, WCHAR chQuoteW, LPSTREAM *ppstmHtml);

private:
    ULONG                   m_cRef;
    LPSTREAM                m_pstmPlain,
                            m_pstmOut;
    ULONG                   m_cchOut,
                            m_cchBuffer,
                            m_cchPos,
                            m_nSpcs;
    BOOL                    m_fCRLF;
    WCHAR                   m_rgchOutBufferW[CCHMAX_BUFFER];
    WCHAR                   m_rgchBufferW[CCHMAX_BUFFER],
                            m_chQuoteW;

    HRESULT HrParseStream();
    HRESULT HrWrite(LPCWSTR pszW, ULONG cch);
    HRESULT HrOutputSpaces(ULONG cSpaces);
    inline HRESULT HrOutputQuoteChar();

};

typedef CPlainConverter *LPPLAINCONVERTER;

HRESULT HrConvertPlainStreamW(LPSTREAM pstm, WCHAR chQuote, LPSTREAM *ppstmHtml);
HRESULT HrConvertHTMLToFormat(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf);

HRESULT EscapeStringToHTML(LPWSTR pwszIn, LPWSTR *ppwszOut);

#endif //_PLAINCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\plainstm.cpp ===
/*
 *    p l a i n s t m . c p p
 *
 *    Purpose:
 *        IStream implementation that wraps a plain stream as html and does URL detection
 *
 *  History
 *      September '96: brettm - created
 *
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "strconst.h"
#include "plainstm.h"
#include "triutil.h"
#include "oleutil.h"
#include "demand.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  t y p e d e f s
 */

/*
 *  c o n s t a n t s
 */
#define MAX_URL_SIZE            8+1

#define WCHAR_BYTES(_lpsz)     (sizeof(_lpsz) - sizeof(WCHAR))
#define WCHAR_CCH(_lpsz)       (WCHAR_BYTES(_lpsz)/sizeof(WCHAR))

static const WCHAR  c_szHtmlNonBreakingSpaceW[]  =L"&nbsp;",
                    c_szHtmlBreakW[]             =L"<BR>\r\n",
                    c_szSpaceW[]                 =L" ",
                    c_szEscGreaterThanW[]        =L"&gt;",
                    c_szEscLessThanW[]           =L"&lt;",
                    c_szEscQuoteW[]              =L"&quot;",
                    c_szEscAmpersandW[]          =L"&amp;";
                    
#define chSpace         ' '
#define chCR            '\r'
#define chLF            '\n'
#define chQuoteChar     '\"' 
#define chLessThan      '<'
#define chGreaterThan   '>'
#define chAmpersand     '&'

#define IsSpecialChar(_ch)  ( _ch == chLessThan || _ch == chSpace || _ch == chCR || _ch == chLF || _ch == chQuoteChar || _ch == chLessThan || _ch == chGreaterThan || _ch == chAmpersand )

/*
 *  g l o b a l s
 */
enum
{
    escInvalid=-1,
    escGreaterThan=0,
    escLessThan,
    escAmpersand,
    escQuote
};

/*
 *  f u n c t i o n   p r o t y p e s
 */


/*
 *  f u n c t i o n s
 */

HRESULT HrConvertPlainStreamW(LPSTREAM pstm, WCHAR chQuoteW, LPSTREAM *ppstmHtml)
{
    LPPLAINCONVERTER    pPlainConv=0;
    HRESULT             hr;

    if (!(pPlainConv=new CPlainConverter()))
        return E_OUTOFMEMORY;

    hr=pPlainConv->HrConvert(pstm, chQuoteW, ppstmHtml);
    if (FAILED(hr))
        goto error;

    HrRewindStream(*ppstmHtml);

error:
    ReleaseObj(pPlainConv);
    return hr;
}



CPlainConverter::CPlainConverter()
{
    m_cRef=1;
    m_pstmPlain=NULL;
    m_pstmOut=NULL;
    m_cchPos = 0;
    m_cchBuffer = 0;
    m_cchOut = 0;
    m_fCRLF = 0;
}

CPlainConverter::~CPlainConverter()
{
    SafeRelease(m_pstmPlain);
    SafeRelease(m_pstmOut);
}

HRESULT CPlainConverter::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if (!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    if (!*lplpObj)
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

ULONG CPlainConverter::AddRef()
{
    return ++m_cRef;
}

ULONG CPlainConverter::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CPlainConverter::HrWrite(LPCWSTR pszW, ULONG cch)
{
    ULONG   cb;
    HRESULT hr=S_OK;

    AssertSz(cch <= sizeof(m_rgchOutBufferW)/sizeof(WCHAR), "Hey! why are you writing too much out at once");

    if (m_cchOut + cch > sizeof(m_rgchOutBufferW)/sizeof(WCHAR))
        {
        // fill buffer then flush it
        cb = sizeof(m_rgchOutBufferW) - (m_cchOut*sizeof(WCHAR));
        CopyMemory((LPVOID)&m_rgchOutBufferW[m_cchOut], (LPVOID)pszW, cb);
        hr = m_pstmOut->Write(m_rgchOutBufferW, sizeof(m_rgchOutBufferW), NULL);
        
        // we just filled the buffer with an extra cb off the string, so copy the rest into 
        pszW = (LPCWSTR)((LPBYTE)pszW + cb);
        cch -= cb / sizeof(WCHAR);
        CopyMemory((LPVOID)m_rgchOutBufferW, (LPVOID)pszW, cch*sizeof(WCHAR));
        m_cchOut=cch;
        }
    else
        {
        CopyMemory((LPVOID)&m_rgchOutBufferW[m_cchOut], (LPVOID)pszW, cch*sizeof(WCHAR));
        m_cchOut+=cch;
        }
    return hr;
}

HRESULT CPlainConverter::HrConvert(LPSTREAM pstm, WCHAR chQuoteW, LPSTREAM *ppstmHtml)
{
    HRESULT         hr;

    if (ppstmHtml==NULL)
        return E_INVALIDARG;

    // caller wants a stream created? or use his own??
    if (*ppstmHtml==NULL)
        {
        if (FAILED(MimeOleCreateVirtualStream(&m_pstmOut)))
            return E_OUTOFMEMORY;
        }
    else
        {
        m_pstmOut=*ppstmHtml;
        }

    m_pstmPlain=pstm;
    if (pstm)
        pstm->AddRef();

    if (m_pstmPlain)
        {
        hr=HrRewindStream(m_pstmPlain);
        if (FAILED(hr))
            goto error;
        }

    m_nSpcs=0;
    m_chQuoteW=chQuoteW;

    if (m_pstmPlain)
        {
        // if quoting, quote the first line.
        HrOutputQuoteChar();
        hr = HrParseStream();
        }

    if (m_cchOut)
        hr = m_pstmOut->Write(m_rgchOutBufferW, m_cchOut*sizeof(WCHAR), NULL);

    *ppstmHtml=m_pstmOut;

error:
    m_pstmOut = NULL;
    return hr;
}


HRESULT CPlainConverter::HrParseStream()
{
    LPSTREAM    pstmOut=m_pstmOut;
    ULONG       cchLast;

    Assert(pstmOut);


    ULONG   cb;

    Assert(m_pstmPlain);

    m_pstmPlain->Read(m_rgchBufferW, sizeof(m_rgchBufferW), &cb);
    m_cchBuffer = cb / sizeof(WCHAR);
    m_cchPos=0;

    // Raid 63406 - OE doesn't skip byte order marks when inlining unicode text
    if (cb >= 4 && *m_rgchBufferW == 0xfeff)
        m_cchPos++;

    while (cb)
        {
        if (m_nSpcs && m_rgchBufferW[m_cchPos] != chSpace)
            {
            // this character is not a space, and we have spaces queued up, output
            // spaces before the character
            HrOutputSpaces(m_nSpcs);
            m_nSpcs = 0;
            }

        switch (m_rgchBufferW[m_cchPos])
            {
            case chSpace:                   // queue spaces
                m_nSpcs++;                
                break;

            case chCR:                      // swallow carriage returns as they are always in CRLF pairs.
                break;

            case chLF:
                // if we're quoting, insert a quote after the CRLF.
                HrWrite(c_szHtmlBreakW, WCHAR_BYTES(c_szHtmlBreakW)/sizeof(WCHAR));
                HrOutputQuoteChar();
                m_fCRLF = 1;
                break;

            case chQuoteChar:
                HrWrite(c_szEscQuoteW, WCHAR_BYTES(c_szEscQuoteW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;
    
            case chLessThan:
                HrWrite(c_szEscLessThanW, WCHAR_BYTES(c_szEscLessThanW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;

            case chGreaterThan:
                HrWrite(c_szEscGreaterThanW, WCHAR_BYTES(c_szEscGreaterThanW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;

            case chAmpersand:
                HrWrite(c_szEscAmpersandW, WCHAR_BYTES(c_szEscAmpersandW)/sizeof(WCHAR));
                m_fCRLF = 0;
                break;

            default:
                // set the last pointer and pull these up...
                cchLast = m_cchPos;
                m_cchPos++;
                while (m_cchPos < m_cchBuffer &&
                        !IsSpecialChar(m_rgchBufferW[m_cchPos]))
                    {
                    m_cchPos++;
                    }                
                HrWrite(&m_rgchBufferW[cchLast], m_cchPos - cchLast);
                m_cchPos--;     //rewind as we INC below
                m_fCRLF = 0;
                break;
            }
        
        m_cchPos++;
        Assert(m_cchPos <= m_cchBuffer);
        if (m_cchPos == m_cchBuffer)
            {
            // hit end of buffer, re-read next block
            m_pstmPlain->Read(m_rgchBufferW, sizeof(m_rgchBufferW), &cb);
            m_cchPos=0;
            m_cchBuffer = cb / sizeof(WCHAR);
            }
        }


    return S_OK;
}



HRESULT CPlainConverter::HrOutputQuoteChar()
{
    if (m_chQuoteW)
        {
        // don't bother escaping all quote chars as we only use ">|:"
        AssertSz(m_chQuoteW != '<' && m_chQuoteW != '&' && m_chQuoteW != '"', "need to add support to escape these, if we use them as quote chars!!");
        if (m_chQuoteW== chGreaterThan)
            HrWrite(c_szEscGreaterThanW, WCHAR_BYTES(c_szEscGreaterThanW)/sizeof(WCHAR));
        else
            HrWrite(&m_chQuoteW, 1);
        HrWrite(L" ", 1);
        }
    return S_OK;
}

HRESULT CPlainConverter::HrOutputSpaces(ULONG cSpaces)
{
    if (cSpaces == 1 && m_fCRLF)    // if we get "\n foo" make sure it's an nbsp;
        return HrWrite(c_szHtmlNonBreakingSpaceW, WCHAR_CCH(c_szHtmlNonBreakingSpaceW));


    while (--cSpaces)
        HrWrite(c_szHtmlNonBreakingSpaceW, WCHAR_CCH(c_szHtmlNonBreakingSpaceW));

    return HrWrite(c_szSpaceW, 1);
}



/*
 * Warning This Function Trashes the Input Buffer aka: strtok
 *
 */
HRESULT EscapeStringToHTML(LPWSTR pwszIn, LPWSTR *ppwszOut)
{   
    int         cchPos,
                esc=escInvalid,
                cb = 0;
    LPWSTR      pwszText = pwszIn,
                pwszWrite = NULL;
    HRESULT     hr = S_OK;

    if (!pwszIn)
        return S_OK;

    // count space required
    while (*pwszText)
    {
        switch (*pwszText)
        {
            case chGreaterThan:
                cb += WCHAR_BYTES(c_szEscGreaterThanW);
                break;
    
            case chLessThan:
                cb += WCHAR_BYTES(c_szEscLessThanW);
                break;
    
            case chAmpersand:
                cb += WCHAR_BYTES(c_szEscAmpersandW);
                break;
    
            case chQuoteChar:
                cb += WCHAR_BYTES(c_szEscQuoteW);
                break;
        
            default:
                cb += sizeof(*pwszText);
        }
        
        pwszText++;
    }

    IF_NULLEXIT(MemAlloc((LPVOID *)&pwszWrite, cb+sizeof(WCHAR)));

    pwszText = pwszIn;
    *ppwszOut = pwszWrite;

    // count space required
    while (*pwszText)
    {
        switch (*pwszText)
        {
            case chGreaterThan:
                StrCpyW(pwszWrite, c_szEscGreaterThanW);
                pwszWrite += WCHAR_CCH(c_szEscGreaterThanW);
                break;

            case chLessThan:
                StrCpyW(pwszWrite, c_szEscLessThanW);
                pwszWrite += WCHAR_CCH(c_szEscLessThanW);
                break;

            case chQuoteChar:
                StrCpyW(pwszWrite, c_szEscQuoteW);
                pwszWrite += WCHAR_CCH(c_szEscQuoteW);
                break;

            case chAmpersand:
                StrCpyW(pwszWrite, c_szEscAmpersandW);
                pwszWrite += WCHAR_CCH(c_szEscAmpersandW);
                break;
    
            default:
                *pwszWrite++ = *pwszText;
        }

        pwszText++;
    }
    *pwszWrite = 0;
    pwszWrite = NULL;

exit:
    MemFree(pwszWrite);
    return S_OK;
}


HRESULT HrConvertHTMLToFormat(LPSTREAM pstmHtml, LPSTREAM *ppstm, CLIPFORMAT cf)
{
    HRESULT     hr;
    LPUNKNOWN   pUnkTrident=0;
    LPSTREAM    pstmPlain=0;

    if (!ppstm)
        return E_INVALIDARG;

    hr = HrCreateSyncTridentFromStream(pstmHtml, IID_IUnknown, (LPVOID *)&pUnkTrident);
    if (FAILED(hr))
        goto error;

    hr = HrGetDataStream(pUnkTrident, cf, &pstmPlain);
    if (FAILED(hr))
        goto error;

    *ppstm = pstmPlain;
    pstmPlain->AddRef();

error:
    ReleaseObj(pUnkTrident);
    ReleaseObj(pstmPlain);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\saferun.h ===
#ifndef _SAFERUN_H
#define _SAFERUN_H

/*
 * IsSafeToRun
 *
 * return codes:
 *   S_OPENFILE : file should be opened
 *   S_SAVEFILE : file should be saved
 *
 * errors:
 *   E_FAIL, E_INVALIDARG, hrUserCancel
 *
 */

HRESULT IsSafeToRun(HWND hwnd, LPCWSTR lpszFileName, BOOL fPrompt);

HRESULT VerifyTrust(HWND hwnd, LPCWSTR pszFileName, LPCWSTR pszPathName);

#endif //_SAFERUN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\saferun.cpp ===
/*
 *    s a f e r u n . c p p
 *    
 *    Purpose:
 *		Athena's version of shdocvw's saferun dialog
 *    
 *    Owner:
 *      brettm.
 *
 *    History:
 *      Created: March 1997
 *    
 *    Copyright (C) Microsoft Corp. 1996.
 */


#include "pch.hxx"
#include <pch.hxx>
#include "dllmain.h"
#include "resource.h"
#include "util.h"
#include "attrun.h"
#include "saferun.h"
#include "strconst.h"
#include <wintrust.h>
#include "demand.h"
#include "shlwapip.h"


/*
 *      c o n s t a n t s
 */

#define FTA_OpenIsSafe    0x00010000 // 17. the file class's open verb may be safely invoked for downloaded files
#define FTA_NoEdit        0x00000008 //  4. no editing of file type


/*
 *      t y p e d e f s
 */
typedef struct SAFEOPENPARAM_tag
{
    LPCWSTR     lpszFileName;
    LPCWSTR     lpszFileClass;
    LPCWSTR     lpszExt;
    HRESULT     hr;
}   SAFEOPENPARAM, *LPSAFEOPENPARAM;


/*
 *      p r o t o t y p e s
 */
LRESULT SetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, LPCWSTR pcszValue, DWORD dwType, const BYTE *pcbyte, DWORD dwcb);
LRESULT GetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, PCWSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteBuf, PDWORD pdwcbBufLen);
BOOL RememberFileIsSafeToOpen(LPCWSTR szFileClass);
BOOL FIsExtBad(LPCWSTR lpszExt);
HRESULT SafeOpenDialog(HWND hwnd, LPSAFEOPENPARAM pSafeOpen);
INT_PTR CALLBACK SafeOpenDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

/*
 * return codes:
 *   S_OPENFILE : file should be opened
 *   S_SAVEFILE : file should be saved
 *
 * errors:
 *   E_FAIL, E_INVALIDARG, hrUserCancel
 *
 */
HRESULT IsSafeToRun(HWND hwnd, LPCWSTR lpszFileName, BOOL fPrompt)
{
    BOOL            fSafe;
    DWORD           dwValueType, 
                    dwEditFlags;
    ULONG           cb;
    WCHAR          *szExt,
                    szFileClass[MAX_PATH];
    SAFEOPENPARAM  rSafeOpen={0}; 

    if (lpszFileName == NULL || *lpszFileName == NULL)
        return E_INVALIDARG;

    *szFileClass = 0;

    szExt = PathFindExtensionW(lpszFileName);
    if (*szExt)
        {
	    cb = sizeof(szFileClass);
        RegQueryValueWrapW(HKEY_CLASSES_ROOT, szExt, szFileClass, (LONG*)&cb);
        }

    cb = sizeof(dwEditFlags);

    // $34489. Make HTML files ALWAYS unsafe
    if (PathIsHTMLFileW(lpszFileName))
        fSafe = FALSE;
    else
        fSafe = ((GetRegKeyValue(HKEY_CLASSES_ROOT, szFileClass, L"EditFlags", &dwValueType, (PBYTE)&dwEditFlags, &cb) == ERROR_SUCCESS) && 
                (dwValueType == REG_BINARY || dwValueType == REG_DWORD) && 
                (dwEditFlags & FTA_OpenIsSafe)) && !FIsExtBad(szExt);

    rSafeOpen.lpszFileName = lpszFileName;
    rSafeOpen.lpszFileClass = szFileClass;
    rSafeOpen.lpszExt = szExt;

    return fSafe ? MIMEEDIT_S_OPENFILE : (fPrompt ? SafeOpenDialog(hwnd, &rSafeOpen) : MIMEEDIT_E_USERCANCEL);
}


HRESULT SafeOpenDialog(HWND hwnd, LPSAFEOPENPARAM pSafeOpen)
{
    pSafeOpen->hr = E_FAIL;  // incase we fail
    DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSafeOpen), hwnd, SafeOpenDlgProc, (LPARAM)pSafeOpen);
    return pSafeOpen->hr;
}

#define MAXDISPLAYNAMELEN 64

INT_PTR CALLBACK SafeOpenDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPSAFEOPENPARAM     pSafeOpen;

    switch(msg)
        {
        case WM_INITDIALOG:
            {
	        Assert (lParam);
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
	
            pSafeOpen = (LPSAFEOPENPARAM)lParam;
	        // if an UNSAFE extension type, don't allow user to set edit flags
            if (FIsExtBad(pSafeOpen->lpszExt))
		        EnableWindow(GetDlgItem(hwnd, IDC_SAFEOPEN_ALWAYS), FALSE);

	        CheckDlgButton(hwnd, IDC_SAFEOPEN_ALWAYS, TRUE);
	        CheckDlgButton(hwnd, IDC_SAFEOPEN_AUTOSAVE, TRUE);

	        WCHAR szBuf[32];
            WCHAR szBuf2[MAX_PATH+32]; // ok with MAX_PATH
	        WCHAR szBuf3[MAX_PATH+32]; // ok with MAX_PATH
            int length = 0;

            lstrcpyW(szBuf3, pSafeOpen->lpszFileName);
            PathStripPathW(szBuf3);
            length = lstrlenW(szBuf3);
            if (length > MAXDISPLAYNAMELEN)
            {
                WCHAR *szExt;
                szExt = PathFindExtensionW(pSafeOpen->lpszFileName);
                if (*szExt)
                {
                    int cExt = lstrlenW(szExt);
                    if (cExt < MAXDISPLAYNAMELEN-3)
                    {
                        PathCompactPathExW(szBuf2, szBuf3, MAXDISPLAYNAMELEN-cExt, 0);
                        lstrcatW(szBuf2, szExt);
                    }
                    else
                        PathCompactPathExW(szBuf2, szBuf3, MAXDISPLAYNAMELEN, 0);
                }
                else
                {
                    PathCompactPathExW(szBuf2, szBuf3, MAXDISPLAYNAMELEN, 0);
                }
                lstrcpyW(szBuf3, szBuf2);
            }

	        GetDlgItemTextWrapW(hwnd, IDC_SAFEOPEN_EXPL, szBuf, ARRAYSIZE(szBuf));
            AthwsprintfW(szBuf2, ARRAYSIZE(szBuf2), szBuf, szBuf3);

	        SetDlgItemTextWrapW(hwnd, IDC_SAFEOPEN_EXPL, szBuf2);
	        CenterDialog(hwnd);
            }
            return TRUE;

        case WM_COMMAND:
	        switch (GET_WM_COMMAND_ID(wParam, lParam)) 
                {
	            case IDOK:
                    pSafeOpen = (LPSAFEOPENPARAM)GetWindowLongPtr(hwnd, DWLP_USER);

	                if (!IsDlgButtonChecked(hwnd, IDC_SAFEOPEN_ALWAYS))
		                RememberFileIsSafeToOpen(pSafeOpen->lpszFileClass);

	                pSafeOpen->hr = IsDlgButtonChecked(hwnd, IDC_SAFEOPEN_AUTOSAVE) ? MIMEEDIT_S_SAVEFILE : MIMEEDIT_S_OPENFILE;
	                EndDialog(hwnd, IDOK);
                    break;
                                        
                case IDCANCEL:
                    pSafeOpen = (LPSAFEOPENPARAM)GetWindowLongPtr(hwnd, DWLP_USER);

                    pSafeOpen->hr = MIMEEDIT_E_USERCANCEL;
                    EndDialog(hwnd, IDCANCEL);
	                break;
	            }
            break;

        }
    return FALSE;
}



LRESULT GetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, PCWSTR pcszValue, PDWORD pdwValueType, PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
    LONG lResult;
    HKEY hkeySubKey;

    if (GetSystemMetrics(SM_CLEANBOOT))
	    return ERROR_GEN_FAILURE;

    lResult = RegOpenKeyExWrapW(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE, &hkeySubKey);
    if (lResult == ERROR_SUCCESS)
        {
	    LONG lResultClose;

	    lResult = RegQueryValueExWrapW(hkeySubKey, pcszValue, NULL, pdwValueType,
				      pbyteBuf, pdwcbBufLen);

	    lResultClose = RegCloseKey(hkeySubKey);

	    if (lResult == ERROR_SUCCESS)
	        lResult = lResultClose;
        }

    return(lResult);
}

LRESULT SetRegKeyValue(HKEY hkeyParent, PCWSTR pcszSubKey, LPCWSTR pcszValue, DWORD dwType, const BYTE *pcbyte, DWORD dwcb)
{
    LONG lResult;
    HKEY hkeySubKey;

    lResult = RegCreateKeyExWrapW(hkeyParent, pcszSubKey, 0, NULL, 0, KEY_SET_VALUE,
                                NULL, &hkeySubKey, NULL);

    if (lResult == ERROR_SUCCESS)
        {
        LONG lResultClose;

        lResult = RegSetValueExWrapW(hkeySubKey, pcszValue, 0, dwType, pcbyte, dwcb);

        lResultClose = RegCloseKey(hkeySubKey);

        if (lResult == ERROR_SUCCESS)
            lResult = lResultClose;
        }
    return(lResult);
}


BOOL RememberFileIsSafeToOpen(LPCWSTR szFileClass)
{
    DWORD dwValueType, dwEditFlags;
    ULONG cb = sizeof(dwEditFlags);

    if (szFileClass==NULL || *szFileClass == NULL)
        return FALSE;

    if (GetRegKeyValue(HKEY_CLASSES_ROOT, szFileClass, L"EditFlags",
			   &dwValueType, (PBYTE)&dwEditFlags, &cb) == ERROR_SUCCESS &&
	    (dwValueType == REG_BINARY || dwValueType == REG_DWORD))
        {
	    dwEditFlags &= ~FTA_NoEdit;
	    dwEditFlags |= FTA_OpenIsSafe;
        } 
    else 
        {
	    dwEditFlags = FTA_OpenIsSafe;
        }

    return (SetRegKeyValue(HKEY_CLASSES_ROOT, szFileClass, L"EditFlags",
			     REG_BINARY, (BYTE*)&dwEditFlags,
			     sizeof(dwEditFlags)) == ERROR_SUCCESS);
}

// Keep in sync with c_arszUnsafeExts in shell\shdocvw\download.cpp
// @todo [NeilBren, TonyC] Move this to the registry and have IE and OE share it
static const LPWSTR szBadExt[] = 
{   L".exe", L".com", L".bat", L".lnk", L".url",
    L".cmd", L".inf", L".reg", L".isp", L".bas", L".pcd",
    L".mst", L".pif", L".scr", L".hlp", L".chm", L".hta", L".asp", 
    L".js",  L".jse", L".vbs", L".vbe", L".ws",  L".wsh", L".msi",
    L".ade", L".adp", L".crt", L".ins", L".mdb",
    L".mde", L".msc", L".msp", L".sct", L".shb",
    L".vb",  L".wsc", L".wsf", L".cpl", L".shs",
    L".vsd", L".vst", L".vss", L".vsw", L".its", L".tmp",
    L".mdw", L".mdt", L".ops", L".mda", L".mdz", L".prf",
    L".scf", L".ksh", L".csh", L".app", L".fxp", L".prg",
    L".htm", L".html",L".zip", L".vsmacros"
};      

    

BOOL FIsExtBad(LPCWSTR lpszExt)
{
    if (lpszExt == NULL || *lpszExt == NULL)
        return TRUE;

    for (int i=0; i<ARRAYSIZE(szBadExt); i++)
        if (StrCmpIW(lpszExt, szBadExt[i]) == 0)
            return TRUE;

    return FALSE;
}

// Returns:
//
//  IDOK     -- If it's trusted
//  IDNO     -- If it's not known (warning dialog requried)
//  IDCANCEL -- We need to stop download it
//
HRESULT VerifyTrust(HWND hwnd, LPCWSTR pszFileName, LPCWSTR pszPathName)
{
    UINT    uRet = IDNO; // assume unknown
    HANDLE  hFile;
    HRESULT hr=E_FAIL;
    WCHAR   *szExt;

    if (pszFileName==NULL || *pszFileName==NULL || pszPathName==NULL || *pszPathName==NULL)
        return S_OK;        // REVIEW$: ?? should I fail if these are NULL ??

    szExt = PathFindExtensionW(pszFileName);

    if (StrCmpIW(szExt, c_szExeExt) != 0) // don't check for non-exe's
        return S_OK;

    hFile = CreateFileWrapW(pszPathName, GENERIC_READ, FILE_SHARE_READ,
		    NULL, OPEN_EXISTING,
		    FILE_ATTRIBUTE_NORMAL, 0);
            
    if (hFile == INVALID_HANDLE_VALUE)
        return E_HANDLE;

	GUID PublishedSoftware = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
	GUID SubjectPeImage = WIN_TRUST_SUBJTYPE_PE_IMAGE;
	WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ActionData;
	WIN_TRUST_SUBJECT_FILE Subject;

	Subject.hFile = hFile;
	Subject.lpPath = pszFileName;

	ActionData.SubjectType = &SubjectPeImage;
	ActionData.Subject = &Subject;
	ActionData.hClientToken = NULL;

	hr = WinVerifyTrust(hwnd, &PublishedSoftware, &ActionData);
	CloseHandle(hFile);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\saveatt.h ===
#ifndef _SAVEATT_H
#define _SAVEATT_H

interface IMimeMessage;

HRESULT HrSaveAttachments(HWND hwnd, IMimeMessage *pMsg, LPWSTR rgchPath, ULONG cchPath, BOOL fShowUnsafe);

#endif // _SAVEATT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\secmgr.cpp ===
/*
 *    s e c m g r . c p p
 *    
 *    Purpose:
 *        Implement security manager callback
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <docobj.h>
#include "dllmain.h"
#include "secmgr.h"
#include "urlmon.h"


#define DEF_SECURITYZONE	URLZONE_UNTRUSTED
/* 
 * Security Manger implementation
 *
 */
CSecManager::CSecManager(IOleCommandTarget *pCmdTarget)
{
    m_cRef=1;
    m_pCmdTarget = pCmdTarget;  // loose reference as it's always around
}

CSecManager::~CSecManager()
{
}

HRESULT CSecManager::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IInternetSecurityManager))
        *lplpObj = (IInternetSecurityManager*) this;
    else
        return E_NOINTERFACE;
        
    AddRef();
    return NOERROR;
}

ULONG CSecManager::AddRef()
{
    return ++m_cRef;
}

ULONG CSecManager::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CSecManager::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
    return E_NOTIMPL;
}

HRESULT CSecManager::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
    return E_NOTIMPL;
}

HRESULT CSecManager::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
    DWORD   dwZone;

    if (pdwZone == NULL)
        return E_INVALIDARG;

    // run our resources in the trusted zone
    if (pwszUrl && !StrCmpNIW(pwszUrl, L"res:", 4))
        dwZone = URLZONE_TRUSTED;
    // run message content in the selected zone
    else
        dwZone = DwGetZone();

    if (dwZone > URLZONE_PREDEFINED_MAX)
        dwZone = DEF_SECURITYZONE;

    *pdwZone = dwZone;
    return S_OK;
}

HRESULT CSecManager::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

HRESULT CSecManager::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
    return INET_E_DEFAULT_ACTION;
}

DWORD CSecManager::DwGetZone()
{
    VARIANTARG  va;
    DWORD       dwZone = DEF_SECURITYZONE;

    if (m_pCmdTarget &&
        m_pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SECURITY_ZONE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK &&
        va.vt == VT_I4)
        dwZone = va.lVal;
    
    return dwZone;
}

HRESULT CreateSecurityManger(IOleCommandTarget *pCmdTarget, LPSECMANAGER *ppSecMgr)
{
	CSecManager	*pSecMgr;

	TraceCall ("CreateSecurityManger");

	pSecMgr = new CSecManager(pCmdTarget);
	if (!pSecMgr)
		return TraceResult(E_OUTOFMEMORY);

	*ppSecMgr = pSecMgr;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\secmgr.h ===
#ifndef _SECMGR_H
#define _SECMGR_H

interface IInternetSecurityManager;

class CSecManager :
    public IInternetSecurityManager
{
public:
    CSecManager(IOleCommandTarget *pCmdTarget);
    virtual ~CSecManager();

    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IInternetSecurityManager
    virtual HRESULT STDMETHODCALLTYPE SetSecuritySite(IInternetSecurityMgrSite *pSite);
    virtual HRESULT STDMETHODCALLTYPE GetSecuritySite(IInternetSecurityMgrSite **ppSite);
    virtual HRESULT STDMETHODCALLTYPE MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
    virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE __RPC_FAR *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);

private:
    ULONG               m_cRef;
    IOleCommandTarget   *m_pCmdTarget;

    DWORD DwGetZone();

};

typedef CSecManager *LPSECMANAGER;

HRESULT CreateSecurityManger(IOleCommandTarget *pCmdTarget, LPSECMANAGER *ppSecMgr);

#endif //_SECMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\spell.cpp ===
/*
 *  spell.c
 *
 *  Implementation of spelling
 *
 *  Owner:  v-brakol
 *          bradk@directeq.com
 */
#include "pch.hxx"
#include "richedit.h"
#include "resource.h"
#include "util.h"
#include <mshtml.h>
#include <mshtmcid.h>
#include "mshtmhst.h"
#include "mshtmdid.h"
#include <docobj.h>
#include "spell.h"
#include "strconst.h"
#include "bodyutil.h"
#include <error.h>
#include "htmlstr.h"
#include "dllmain.h"
#include "msi.h"
#include "lid.h"
#include <tchar.h>
#include "demand.h"

#define GetAddr(var, cast, name)    {if ((var = (cast)GetProcAddress(m_hinstDll, name)) == NULL) \
                                        goto error;}

#define TESTHR(hr) (FAILED(hr) || hr == HR_S_ABORT || hr == HR_S_SPELLCANCEL)
#define SPELLER_GUID            "{CC29EB3F-7BC2-11D1-A921-00A0C91E2AA2}"
#define DICTIONARY_GUID         "{CC29EB3D-7BC2-11D1-A921-00A0C91E2AA2}"
#define CSAPI3T1_GUID           "{CC29EB41-7BC2-11D1-A921-00A0C91E2AA2}"
#ifdef DEBUG
#define SPELLER_DEBUG_GUID      "{CC29EB3F-7BC2-11D1-A921-10A0C91E2AA2}"
#define DICTIONARY_DEBUG_GUID   "{CC29EB3D-7BC2-11D1-A921-10A0C91E2AA2}"
#define CSAPI3T1_DEBUG_GUID     "{CC29EB41-7BC2-11D1-A921-10A0C91E2AA2}"
#endif  // DEBUG

#define MAX_SPELLWORDS   10

typedef BOOL (LPFNENUMLANG)(DWORD_PTR, LPTSTR);
typedef BOOL (LPFNENUMUSERDICT)(DWORD_PTR, LPTSTR);

typedef struct _FILLLANG
    {
    HWND    hwndCombo;
    BOOL    fUnknownFound;
    BOOL    fDefaultFound;
    BOOL    fCurrentFound;
    UINT    lidDefault;
    UINT    lidCurrent;
    } FILLLANG, * LPFILLLANG;

BOOL    TestLangID(LPCTSTR szLangId);
BOOL    GetLangID(IOleCommandTarget* pParentCmdTarget, LPTSTR szLangID, DWORD cchLangId);
WORD    WGetLangID(IOleCommandTarget* pParentCmdTarget);
DWORD   GetSpellingPaths(LPCTSTR szKey, LPTSTR szReturnBuffer, LPTSTR szMdr, UINT cchReturnBufer);
VOID    EnumLanguages(DWORD_PTR, LPFNENUMLANG);
BOOL    FindLangCallback(DWORD_PTR dwLangId, LPTSTR lpszLang);
void    RemoveTrailingSpace(LPTSTR lpszWord);
void    DumpRange(IHTMLTxtRange *pRange);
BOOL    FBadSpellChecker(LPSTR rgchBufDigit);
void    EnableRepeatedWindows(CSpell* pSpell, HWND hwndDlg);
BOOL    GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex, BOOL bTestAvail);
VOID    EnumUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn);
BOOL    GetDefaultUserDictionary(TCHAR *rgchUserDict, int cchBuff);
WORD    GetWCharType(WCHAR wc);
HRESULT OpenDirectory(TCHAR *szDir);

BOOL TestLangID(LPCTSTR szLangId)
{
    // check for new speller
    {
        TCHAR   rgchEngine[MAX_PATH];
        int     cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
        TCHAR   rgchLex[MAX_PATH];
        int     cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

        if (GetNewSpellerEngine((USHORT) StrToInt(szLangId), rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
            return TRUE;
    }

    // use the old code to check for an old speller
    {
        TCHAR       rgchBufKeyTest[cchMaxPathName];
        TCHAR       rgchBufTest[cchMaxPathName];
        TCHAR       szMdr[cchMaxPathName];

        wsprintf(rgchBufKeyTest, c_szRegSpellKeyDef, szLangId);
        if (GetSpellingPaths(rgchBufKeyTest, rgchBufTest, szMdr, sizeof(rgchBufTest)/sizeof(TCHAR)))
            return TRUE;
    }

    return FALSE;
}

/*
 * GetSpellLangID
 *
 * Returns the LangID that should be used as the base for all registry
 * operations
 *
 */
BOOL GetLangID(IOleCommandTarget* pParentCmdTarget, LPTSTR szLangId, DWORD cchLangId)
{
TCHAR   rgchBuf[cchMaxPathName];
TCHAR   rgchBufKey[cchMaxPathName];
BOOL    fRet;
VARIANT va;

    szLangId[0] = 0;

    Assert(pParentCmdTarget);
    if (pParentCmdTarget && pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SPELL_LANGUAGE, 0, NULL, &va)== S_OK)
    {
        TCHAR       rgchLangId[cchMaxPathName];

        if (WideCharToMultiByte (CP_ACP, 0, va.bstrVal, -1,
                                rgchLangId, sizeof(rgchLangId), NULL, NULL))
        {
            strcpy(szLangId, rgchLangId);
        }

        SysFreeString(va.bstrVal);
    }
    
    if (*szLangId == 0)
    {
        wsprintf(szLangId, "%d", GetUserDefaultLangID());
        Assert(lstrlen(szLangId) == 4);
    }

    wsprintf(rgchBufKey, c_szRegSpellKeyDef, szLangId);
    // copy c_szRegSpellProfile to buffer
    lstrcpy(rgchBuf, c_szRegSpellProfile);
    // add key to buffer
    lstrcat(rgchBuf, rgchBufKey);

    // and see if it's legit:
    if(!(fRet = TestLangID(szLangId)))
        {
        // couldn't open it!
        // check for other languages that might be installed...
        szLangId[0] = 0;
        EnumLanguages((DWORD_PTR) szLangId, FindLangCallback);
        if(*szLangId == 0)
            wsprintf(szLangId, "%d", GetUserDefaultLangID());
        }

    fRet = (szLangId[0] != 0) && TestLangID(szLangId);

    return fRet;
}

WORD    WGetLangID(IOleCommandTarget* pParentCmdTarget)
{
    TCHAR       rgchBufDigit[10];
    
    if (!GetLangID(pParentCmdTarget, rgchBufDigit, sizeof(rgchBufDigit)/sizeof(TCHAR)))
        return GetUserDefaultLangID();

    return (WORD) StrToInt(rgchBufDigit);
}

BOOL    FindLangCallback(DWORD_PTR dwLangId, LPTSTR lpszLang)
{
    // dwLangID is long pointer to szLang ID.  Copy it and return FALSE
    lstrcpy((LPTSTR) dwLangId, lpszLang);
    return FALSE;
}

BOOL EnumOldSpellerLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
DWORD   iKey = 0;
FILETIME    ft;
HKEY    hkey = NULL;
LONG    lRet;
TCHAR   szLangId[cchMaxPathName];
DWORD   cchLangId;
BOOL    fContinue;

    // scotts@directeq.com - changed KEY_QUERY_VALUE to KEY_ENUMERATE_SUB_KEYS - 26203
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSpellKeyDefRoot, 0, KEY_ENUMERATE_SUB_KEYS, &hkey) == ERROR_SUCCESS)
        {
        do
            {
            cchLangId = (cchMaxPathName - 1) * sizeof(TCHAR);

            lRet = RegEnumKeyEx(hkey,
                                iKey++,
                                szLangId,
                                &cchLangId,
                                NULL,
                                NULL,
                                NULL,
                                &ft);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;


            // do some quick sanity checking
            if (cchLangId != 4 ||
                !IsCharAlphaNumeric(szLangId[0]) ||
                IsCharAlpha(szLangId[0]))
                {
                fContinue = TRUE;
                }
            else
                fContinue = (!TestLangID(szLangId) || (*pfn)(dwCookie, szLangId));

            } while (fContinue);
        }

    if (hkey)
        RegCloseKey(hkey);

    return fContinue;
}

BOOL EnumNewSpellerLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
    BOOL        fContinue = TRUE;
    DWORD       i;
    UINT        installState;
    UINT        componentState;
    TCHAR       rgchQualifier[MAX_PATH];
    DWORD       cchQualifier;

#ifdef DEBUG
    for(i=0; fContinue; i++)
    {
        cchQualifier = sizeof(rgchQualifier) / sizeof(rgchQualifier[0]);
        componentState = MsiEnumComponentQualifiers(DICTIONARY_DEBUG_GUID, i, rgchQualifier, &cchQualifier, NULL, NULL);

        if (componentState != ERROR_SUCCESS)
            break;

        // find the language ID
        // the string is formatted as 1033\xxxxxx
        // or                         1042
        {
            TCHAR       szLangId[cchMaxPathName];
            TCHAR       *pSlash;

            lstrcpy(szLangId, rgchQualifier);
            pSlash = StrChr(szLangId, '\\');
            if (pSlash)
                *pSlash = 0;

            fContinue = (*pfn)(dwCookie, szLangId);
        }
    }
#endif  // DEBUG

    for(i=0; fContinue; i++)
    {
        cchQualifier = sizeof(rgchQualifier) / sizeof(rgchQualifier[0]);
        componentState = MsiEnumComponentQualifiers(DICTIONARY_GUID, i, rgchQualifier, &cchQualifier, NULL, NULL);

        if (componentState != ERROR_SUCCESS)
            break;

        // find the language ID
        // the string is formatted as 1033\xxxxxx
        // or                         1042
        {
            TCHAR       szLangId[cchMaxPathName];
            TCHAR       *pSlash;

            lstrcpy(szLangId, rgchQualifier);
            pSlash = StrChr(szLangId, '\\');
            if (pSlash)
                *pSlash = 0;

            fContinue = (*pfn)(dwCookie, szLangId);
        }
    }
    
    return fContinue;
}

VOID EnumLanguages(DWORD_PTR dwCookie, LPFNENUMLANG pfn)
{
    EnumNewSpellerLanguages(dwCookie, pfn);
    EnumOldSpellerLanguages(dwCookie, pfn);
}

BOOL EnumOffice9UserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    TCHAR       rgchBuf[cchMaxPathName];
    HKEY        hkey = NULL;
    FILETIME    ft;
    DWORD       iKey = 0;
    LONG        lRet;
    TCHAR       szValue[cchMaxPathName];
    DWORD       cchValue;
    TCHAR       szCustDict[cchMaxPathName];
    DWORD       cchCustDict;
    BOOL        fContinue = TRUE;
    BOOL        fFoundUserDict = FALSE;
    TCHAR       szOffice9Proof[cchMaxPathName]={0};
    
    // SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Custom Dictionaries
    lstrcpy(rgchBuf, c_szRegSpellProfile);
    lstrcat(rgchBuf, c_szRegSpellKeyCustom);

    if(RegOpenKeyEx(HKEY_CURRENT_USER, rgchBuf, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        do
        {
            cchValue = sizeof(szValue) / sizeof(szValue[0]);
            cchCustDict = sizeof(szCustDict) / sizeof(szCustDict[0]);

            lRet = RegEnumValue(hkey,
                                iKey++,
                                szValue,
                                &cchValue,
                                NULL,
                                NULL,
                                (LPBYTE)szCustDict,
                                &cchCustDict);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;

            fFoundUserDict = TRUE;

            // check to see if we have a path
            if (!(StrChr(szCustDict, ':') || StrChr(szCustDict, '\\')))
            {
                TCHAR   szTemp[cchMaxPathName];
                
                if (!strlen(szOffice9Proof))
                {
                    LPITEMIDLIST pidl;

                    if (S_OK == SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl))
                        SHGetPathFromIDList(pidl, szOffice9Proof);
                    else
                    {
                        // if the Shell call fails (as it can on Win9x sometimes) let's get the info
                        // from the registry
                        HKEY hKeyShellFolders;
                        ULONG cchAppData;
                        
                        if(RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegShellFoldersKey, 0, KEY_QUERY_VALUE, &hKeyShellFolders) == ERROR_SUCCESS)
                        {
                            cchAppData = ARRAYSIZE(szOffice9Proof);
                            RegQueryValueEx(hKeyShellFolders, c_szValueAppData, 0, NULL, (LPBYTE)szOffice9Proof, &cchAppData);
                            RegCloseKey(hKeyShellFolders);
                        }
                    }

                    // if this fails then we will try the current path
                }

                lstrcpy(szTemp, szOffice9Proof);
                lstrcat(szTemp, "\\");
                lstrcat(szTemp, c_szSpellOffice9ProofPath);
                lstrcat(szTemp, szCustDict);
                lstrcpy(szCustDict, szTemp);
            }
            
            fContinue = (*pfn)(dwCookie, szCustDict);

            } while (fContinue);
    }

    if (hkey)
        RegCloseKey(hkey);

    return fFoundUserDict;
}

BOOL EnumOfficeUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    TCHAR       rgchBuf[cchMaxPathName];
    HKEY        hkey = NULL;
    FILETIME    ft;
    DWORD       iKey = 0;
    LONG        lRet;
    TCHAR       szValue[cchMaxPathName];
    DWORD       cchValue;
    TCHAR       szCustDict[cchMaxPathName];
    DWORD       cchCustDict;
    BOOL        fFoundUserDict = FALSE;
    BOOL        fContinue = TRUE;

    // SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Custom Dictionaries
    lstrcpy(rgchBuf, c_szRegSpellProfile);
    lstrcat(rgchBuf, c_szRegSpellKeyCustom);

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        do
        {
            cchValue = sizeof(szValue) / sizeof(szValue[0]);
            cchCustDict = sizeof(szCustDict) / sizeof(szCustDict[0]);

            lRet = RegEnumValue(hkey,
                                iKey++,
                                szValue,
                                &cchValue,
                                NULL,
                                NULL,
                                (LPBYTE)szCustDict,
                                &cchCustDict);

            if (lRet != ERROR_SUCCESS || lRet == ERROR_NO_MORE_ITEMS)
                break;

            fFoundUserDict = TRUE;

            fContinue = (*pfn)(dwCookie, szCustDict);

            } while (fContinue);
    }

    if (hkey)
        RegCloseKey(hkey);

    return fFoundUserDict;
}

VOID EnumUserDictionaries(DWORD_PTR dwCookie, LPFNENUMUSERDICT pfn)
{
    // check for Office9 user dictionaries. If we find any
    // we bail.
    if (EnumOffice9UserDictionaries(dwCookie, pfn))
        return;

    EnumOfficeUserDictionaries(dwCookie, pfn);
}

/*
 *  GetSpellingPaths
 *
 *  Purpose:
 *      Function to get Spelling DLL names.
 *
 *  Arguments:
 *      szKey           c_szRegSpellKeyDef (with correct language)
 *      szDefault       c_szRegSpellEmpty
 *      szReturnBuffer  dll filename
 *      szMdr           dictionary filename
 *      cchReturnBufer
 *
 *  Returns:
 *      DWORD
 */
DWORD GetSpellingPaths(LPCTSTR szKey, LPTSTR szReturnBuffer, LPTSTR szMdr, UINT cchReturnBufer)
{
    DWORD           dwRet = 0;
    TCHAR           rgchBuf[cchMaxPathName];
    DWORD           dwType, cbData;
    HKEY            hkey = NULL;
    LPTSTR          szValue;

    szReturnBuffer[0] = 0;
    lstrcpy(rgchBuf, c_szRegSpellProfile);
    lstrcat(rgchBuf, szKey);

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, KEY_QUERY_VALUE, &hkey))
        goto err;

    cbData = cchReturnBufer * sizeof(TCHAR);
    szValue = (LPTSTR) (szMdr ? c_szRegSpellPath : c_szRegSpellPathDict);
    if (ERROR_SUCCESS != SHQueryValueEx(hkey, szValue, 0L, &dwType, (BYTE *) szReturnBuffer, &cbData))
        goto err;

    // Parse off the main dictionary filename
    if(szMdr)
    {
        szMdr[0] = 0;
        cbData = cchReturnBufer * sizeof(TCHAR);
        if (ERROR_SUCCESS != SHQueryValueEx(hkey, c_szRegSpellPathLex, 0L, &dwType, (BYTE *) szMdr, &cbData))
            goto err;
    }

    dwRet = cbData;

err:
    if(hkey)
        RegCloseKey(hkey);
    return dwRet;
}

/*
 *  SpellingDlgProc
 *
 *  Purpose:
 *      Dialog procedure for the Tools.Spelling dialog
 *
 *  Arguments:
 *      HWND        Dialog procedure arguments.
 *      UINT
 *      WPARAM
 *      LPARAM
 *
 *  Returns:
 *      BOOL        TRUE if the message has been processed.
 */
INT_PTR CALLBACK SpellingDlgProc(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam)
{
    CSpell*     pSpell;
    HWND        hwndEdited;
    HWND        hwndSuggest;

    switch (wMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwndDlg, DWLP_USER, lparam);
        pSpell = (CSpell*)lparam;
        pSpell->m_hwndDlg = hwndDlg;

        hwndEdited = GetDlgItem(hwndDlg, EDT_Spell_ChangeTo);
        hwndSuggest = GetDlgItem(hwndDlg, LBX_Spell_Suggest);

        pSpell->m_fEditWasEmpty = TRUE;
        SetDlgItemText(hwndDlg, TXT_Spell_Error, pSpell->m_szErrType);
        SetDlgItemText(hwndDlg, EDT_Spell_WrongWord, pSpell->m_szWrongWord);
        SetWindowText(hwndEdited, pSpell->m_szEdited);

        EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Options), FALSE);
        EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Add), (0 != pSpell->m_rgprflex[1]));
        pSpell->m_fRepeat = (pSpell->m_wsrb.sstat == sstatRepeatWord);
        EnableRepeatedWindows(pSpell, hwndDlg);

        if (!pSpell->m_fRepeat)
            pSpell->FillSuggestLbx();
        else
            ListBox_ResetContent(GetDlgItem(hwndDlg, LBX_Spell_Suggest));

        if (pSpell->m_fSuggestions && !pSpell->m_fNoneSuggested && !pSpell->m_fRepeat)
        {
            EnableWindow(hwndSuggest, TRUE);
            ListBox_SetCurSel(hwndSuggest, 0);
            UpdateEditedFromSuggest(hwndDlg, hwndEdited, hwndSuggest);
            EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), TRUE);

            // Set initial default button to "Change"
            SendMessage(hwndDlg, DM_SETDEFID, PSB_Spell_Change, 0L);
            Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Change), BS_DEFPUSHBUTTON, TRUE);

            EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), FALSE);
        }
        else
        {
            Edit_SetSel(hwndEdited, 0, 32767);  // select the whole thing
            EnableWindow(hwndSuggest, FALSE);
            EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), FALSE);

            // Set initial default button to "Ignore"
            SendMessage(hwndDlg, DM_SETDEFID, PSB_Spell_Ignore, 0L);
            Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Ignore), BS_DEFPUSHBUTTON, TRUE);

            EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), !pSpell->m_fSuggestions && !pSpell->m_fRepeat);
        }

        AthFixDialogFonts(hwndDlg);
        SetFocus(hwndEdited);
        break;

    case WM_DESTROY:
        break;

    case WM_COMMAND:
        return SpellingOnCommand(hwndDlg, wMsg, wparam, lparam);

    }

    return FALSE;
}


void EnableRepeatedWindows(CSpell* pSpell, HWND hwndDlg)
{
    INT ids;

    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Add), (!pSpell->m_fRepeat && (0 != pSpell->m_rgprflex[1])));
    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_IgnoreAll), !pSpell->m_fRepeat);
    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_ChangeAll), !pSpell->m_fRepeat);
    if (pSpell->m_fRepeat)
    {
        SetWindowText(GetDlgItem(hwndDlg, EDT_Spell_ChangeTo), "");
        *pSpell->m_szEdited = 0;
    }

}


BOOL SpellingOnCommand(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam)
{
    CSpell*     pSpell;
    BOOL        fChange;
    BOOL        fAlwaysSuggest;
    BOOL        fUndoing = FALSE;
    HRESULT     hr = 0;

    pSpell = (CSpell*) GetWindowLongPtr(hwndDlg, DWLP_USER);
    Assert(pSpell);

    // Update our replacement word?  Only do this when a button is clicked
    // or a double-click from the suggest listbox, and the word has been modified.
    if ((GET_WM_COMMAND_CMD(wparam, lparam) == BN_CLICKED ||
         GET_WM_COMMAND_CMD(wparam, lparam) == LBN_DBLCLK) &&
        Edit_GetModify(GetDlgItem(hwndDlg, EDT_Spell_ChangeTo)))
    {
        HWND    hwndEditChangeTo;

        hwndEditChangeTo = GetDlgItem(pSpell->m_hwndDlg, EDT_Spell_ChangeTo);
        Edit_SetModify(hwndEditChangeTo, FALSE);
        pSpell->m_fSuggestions = FALSE;
        GetWindowText(hwndEditChangeTo, pSpell->m_szEdited, 512);
    }

    switch(GET_WM_COMMAND_ID(wparam, lparam))
    {
    case LBX_Spell_Suggest:
        if (GET_WM_COMMAND_CMD(wparam, lparam) == LBN_SELCHANGE)
        {
            UpdateEditedFromSuggest(hwndDlg, GetDlgItem(hwndDlg, EDT_Spell_ChangeTo),
                                    GetDlgItem(hwndDlg, LBX_Spell_Suggest));
            return TRUE;
        }
        else if (GET_WM_COMMAND_CMD(wparam, lparam) == LBN_DBLCLK)
        {
            goto ChangeIt;
        }
        else
        {
            return FALSE;
        }

    case EDT_Spell_ChangeTo:
        if (GET_WM_COMMAND_CMD(wparam, lparam) == EN_CHANGE)
        {
            INT     idClearDefault;
            INT     idSetDefault;
            BOOL    fEditModified;


            // We get EN_CHANGE notifications for both a SetWindowText() and user modifications.
            // Look at the dirty flag (only set on user mods) and the state of the suggestions
            // selection to see which button should get the default style.
            fEditModified = Edit_GetModify(GET_WM_COMMAND_HWND(wparam, lparam));
            if (fEditModified || pSpell->m_fSuggestions && !pSpell->m_fNoneSuggested)
            {
                idClearDefault = PSB_Spell_Ignore;
                idSetDefault = PSB_Spell_Change;
            }
            else
            {
                idClearDefault = PSB_Spell_Change;
                idSetDefault = PSB_Spell_Ignore;
            }

            // Enable/disable Suggest button
            EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), fEditModified);

            // Set default button
            Button_SetStyle(GetDlgItem(hwndDlg, idClearDefault), BS_PUSHBUTTON, TRUE);
            SendMessage(hwndDlg, DM_SETDEFID, idSetDefault, 0L);
            Button_SetStyle(GetDlgItem(hwndDlg, idSetDefault), BS_DEFPUSHBUTTON, TRUE);

            // "Change" button title
            if (GetWindowTextLength(GET_WM_COMMAND_HWND(wparam, lparam)) && pSpell->m_fEditWasEmpty)
            {
                pSpell->m_fEditWasEmpty = FALSE;
                LoadString(g_hLocRes, idsSpellChange, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_Change, pSpell->m_szTempBuffer);
                LoadString(g_hLocRes, idsSpellChangeAll, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_ChangeAll, pSpell->m_szTempBuffer);
            }
            else if (GetWindowTextLength(GET_WM_COMMAND_HWND(wparam, lparam)) == 0)
            {
                pSpell->m_fEditWasEmpty = TRUE;
                LoadString(g_hLocRes, idsSpellDelete, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_Change, pSpell->m_szTempBuffer);
                LoadString(g_hLocRes, idsSpellDeleteAll, pSpell->m_szTempBuffer,
                           sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
                SetDlgItemText(hwndDlg, PSB_Spell_ChangeAll, pSpell->m_szTempBuffer);
            }
        }
        return TRUE;

    case PSB_Spell_IgnoreAll:
    {
        PROOFLEX    lexIgnoreAll;

        lexIgnoreAll = pSpell->m_pfnSpellerBuiltInUdr(pSpell->m_pid, lxtIgnoreAlways);
        if (0 != lexIgnoreAll)
        {
            RemoveTrailingSpace(pSpell->m_szWrongWord);
            pSpell->AddToUdrA(pSpell->m_szWrongWord, lexIgnoreAll);
            pSpell->m_fCanUndo = FALSE;
        }
    }
        // scotts@directeq.com - remove the annoying dialog and just break out of here - 34229
        break;

    case PSB_Spell_Ignore:
        // Due to limitations with the spelling engine and our single undo level,
        // we can't allow undo's of Ignore if the error was a Repeated Word.
        if (pSpell->m_wsrb.sstat == sstatRepeatWord)
            pSpell->m_fCanUndo = FALSE;
        else
            pSpell->SpellSaveUndo(PSB_Spell_Ignore);

        // scotts@directeq.com - remove the annoying dialog and just break out of here - 34229
        break;

    case PSB_Spell_ChangeAll:
        if (pSpell->FVerifyThisText(pSpell->m_szEdited, FALSE))
        {
            pSpell->m_fCanUndo = FALSE;
            hr = pSpell->HrReplaceErrorText(TRUE, TRUE);
            break;
        }
        else
        {
            return TRUE;
        }

    case PSB_Spell_Change:
ChangeIt:
        if (pSpell->FVerifyThisText(pSpell->m_szEdited, FALSE))
        {
            pSpell->m_fUndoChange = TRUE;
            pSpell->SpellSaveUndo(PSB_Spell_Change);
            hr = pSpell->HrReplaceErrorText(FALSE, TRUE);
            break;
        }
        else
        {
            return TRUE;
        }

    case PSB_Spell_Add:
        Assert(pSpell->m_rgprflex[1]);
        pSpell->m_fCanUndo = FALSE;
        fChange = FALSE;
        RemoveTrailingSpace(pSpell->m_szWrongWord);
        // scotts@directeq.com - removed the FVerifyThisText that was here - no need
        // to FVerifyThisText if the user is asking us to Add this word - fixes 55587
        pSpell->AddToUdrA(pSpell->m_szWrongWord, pSpell->m_rgprflex[1]);
        if (fChange)
            hr = pSpell->HrReplaceErrorText(FALSE, TRUE);
        break;

    case PSB_Spell_UndoLast:
        pSpell->SpellDoUndo();
        fUndoing = TRUE;
        break;

    case PSB_Spell_Suggest:
        hr = pSpell->HrSpellSuggest();
        if (FAILED(hr))
            goto bail;
        goto loadcache;

    case IDCANCEL:
        pSpell->m_fShowDoneMsg = FALSE;
        EndDialog(hwndDlg, IDCANCEL);
        return TRUE;

    default:
        return FALSE;
    }

    // If no current error, then proceed with checking the rest
    if (SUCCEEDED(hr))
    {
        // Change "Cancel" button to "Close"
        LoadString(g_hLocRes, idsSpellClose, pSpell->m_szTempBuffer,
                   sizeof(pSpell->m_szTempBuffer)/sizeof(TCHAR));
        SetDlgItemText(hwndDlg, IDCANCEL, pSpell->m_szTempBuffer);

        pSpell->m_wsrb.sstat = sstatNoErrors;
        hr = pSpell->HrFindErrors();
        if(FAILED(hr))
            goto bail;

        if(pSpell->m_wsrb.sstat==sstatNoErrors)
        {
            EndDialog(hwndDlg, GET_WM_COMMAND_ID(wparam, lparam));
            return TRUE;
        }

    }

bail:
    if(FAILED(hr))
    {
        EndDialog(hwndDlg, IDCANCEL);
        return TRUE;
    }

    SetDlgItemText(hwndDlg, EDT_Spell_WrongWord, pSpell->m_szWrongWord);
    SetDlgItemText(hwndDlg, TXT_Spell_Error, pSpell->m_szErrType);
    SetDlgItemText(hwndDlg, EDT_Spell_ChangeTo, pSpell->m_szEdited);

    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_UndoLast), pSpell->m_fCanUndo);
    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Add), (0 != pSpell->m_rgprflex[1]));

    pSpell->m_fRepeat = (pSpell->m_wsrb.sstat == sstatRepeatWord);
    EnableRepeatedWindows(pSpell, hwndDlg);

loadcache:
    if (!pSpell->m_fRepeat)
        pSpell->FillSuggestLbx();
    else
        ListBox_ResetContent(GetDlgItem(hwndDlg, LBX_Spell_Suggest));

    EnableWindow(GetDlgItem(hwndDlg, PSB_Spell_Suggest), !pSpell->m_fSuggestions && !pSpell->m_fRepeat);
    if (pSpell->m_fSuggestions && !pSpell->m_fNoneSuggested && !pSpell->m_fRepeat)
    {
        EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), TRUE);
        EnableWindow(GetDlgItem(hwndDlg, LBX_Spell_Suggest), TRUE);
        ListBox_SetCurSel(GetDlgItem(hwndDlg, LBX_Spell_Suggest), 0);
        UpdateEditedFromSuggest(hwndDlg, GetDlgItem(hwndDlg, EDT_Spell_ChangeTo),
                                GetDlgItem(hwndDlg, LBX_Spell_Suggest));
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, TXT_Spell_Suggest), FALSE);
        EnableWindow(GetDlgItem(hwndDlg, LBX_Spell_Suggest), FALSE);
    }

    SendMessage(hwndDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwndDlg, EDT_Spell_ChangeTo), MAKELONG(TRUE,0));

    return TRUE;
}


void RemoveTrailingSpace(LPTSTR lpszWord)
{
    LPTSTR      lpsz;

    lpsz = StrChrI(lpszWord, ' ');
    if(lpsz)
        *lpsz = 0;
}

BOOL GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex, BOOL bTestAvail)
{
    DWORD                           er;
    LPCSTR                          rgpszDictionaryTypes[] = {"Normal", "Consise", "Complete"}; 
    int                             cDictTypes = sizeof(rgpszDictionaryTypes) / sizeof(LPCSTR);
    int                             i;
    TCHAR                           rgchQual[MAX_PATH];
    bool                            fFound = FALSE;
    DWORD                           cch;
    INSTALLUILEVEL                  iuilOriginal;
    
    if (rgchEngine == NULL || rgchLex == NULL)
        return FALSE;

    *rgchEngine = 0;
    *rgchLex = 0;

    wsprintf(rgchQual, "%d\\Normal", lgid);
    cch = cchEngine;

    if (bTestAvail)
    {
        // Explicitly Turn off internal installer UI
        // Eg: A feature is set to "run from CD," and CD is not present - fail silently
        // OE Bug 74697
        iuilOriginal = MsiSetInternalUI(INSTALLUILEVEL_NONE, NULL);
    }

#ifdef DEBUG
    er = MsiProvideQualifiedComponent(SPELLER_DEBUG_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
    if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND))
    {
        cch = cchEngine;
        er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
    }
#else
    er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchEngine, &cch);
#endif

    if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND)) 
    {
        fFound = FALSE;
        goto errorExit;
    }

    // Hebrew has main lex in new speller
        for (i = 0; i < cDictTypes; i++)
        {
            wsprintf(rgchQual, "%d\\%s",  lgid, rgpszDictionaryTypes[i]);
            cch = cchLex;

#ifdef DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_DEBUG_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
            if ((er != ERROR_SUCCESS) && (er != ERROR_FILE_NOT_FOUND))
            {
                cch = cchLex;
                er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
            }
#else   // DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, (bTestAvail ? INSTALLMODE_EXISTING : INSTALLMODE_DEFAULT), rgchLex, &cch);
#endif  // DEBUG

            if ((er == ERROR_SUCCESS) || (er == ERROR_FILE_NOT_FOUND))
            {
                fFound = TRUE;
                break;
            }
        }

errorExit:
    if (bTestAvail)
    {
        // Restore original UI Level
        MsiSetInternalUI(iuilOriginal, NULL);
    }
    return fFound;
}

BOOL FIsNewSpellerInstaller(IOleCommandTarget* pParentCmdTarget)
{
    LANGID langid;
    TCHAR   rgchEngine[MAX_PATH];
    int     cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
    TCHAR   rgchLex[MAX_PATH];
    int     cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

    // first try to load dictionaries for various languages
    langid = WGetLangID(pParentCmdTarget);
    if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
    {
        langid = GetSystemDefaultLangID();
        if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
        {
            langid = 1033;  // bloody cultural imperialists.
            if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex, TRUE))
                return FALSE;
        }
    }

    return TRUE;
}

// scotts@directeq.com - copied from "old" spell code - 32675
/*
 *  FIsSpellingInstalled
 *
 *  Purpose:
 *      Is the spelling stuff installed
 *
 *  Arguments:
 *      none
 *
 *  Returns:
 *      BOOL            Returns TRUE if spelling is installed, else FALSE.
 */
BOOL FIsSpellingInstalled(IOleCommandTarget* pParentCmdTarget)
{
    TCHAR       rgchBufDigit[10];

    if (GetLangID(pParentCmdTarget, rgchBufDigit, sizeof(rgchBufDigit)/sizeof(TCHAR)) && !FBadSpellChecker(rgchBufDigit))
        return true;

    if (FIsNewSpellerInstaller(pParentCmdTarget))
        return true;

    return false;
}

// Does a quick check to see if spelling is available; caches result.
BOOL FCheckSpellAvail(IOleCommandTarget* pParentCmdTarget)
{
// scotts@directeq.com - copied from "old" spell code - 32675
    static int fSpellAvailable = -1;

    if (fSpellAvailable < 0)
        fSpellAvailable = (FIsSpellingInstalled(pParentCmdTarget) ? 1 : 0);

    return (fSpellAvailable > 0);
}

HRESULT CSpell::HrSpellReset()
{
    m_fSpellContinue = FALSE;

    return NOERROR;
}

/*
 *  UlNoteCmdToolsSpelling
 *
 *  Purpose:
 *      An interface layer between the note and core spelling code
 *
 *  Arguments:
 *      HWND            Owning window handle, main window
 *      HWND            Subject line window, checked first, actually.
 *      BOOL            Suppress done message (used when spell-check on send)
 *
 *  Returns:
 *      ULONG           Returns 0 if spelling check was completed, else returns non-zero
 *                      if an error occurred or user cancelled the spell check.
 */
HRESULT CSpell::HrSpellChecking(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg)
{
    HRESULT hr = NOERROR;

    hr = HrSpellReset();
    if (FAILED(hr))
        goto End;

    hr = HrInitRanges(pRangeIgnore, hwndMain, fSuppressDoneMsg);
    if(FAILED(hr))
        goto End;

    hr = HrFindErrors();
    if(FAILED(hr))
        goto End;

    if(m_wsrb.sstat==sstatNoErrors && m_fShowDoneMsg)
        AthMessageBoxW(m_hwndNote, MAKEINTRESOURCEW(idsSpellCaption), MAKEINTRESOURCEW(idsSpellMsgDone), NULL, MB_OK | MB_ICONINFORMATION);

End:
    DeInitRanges();

    return hr;
}


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrBkgrndSpellTimer()
{
    HRESULT       hr=NOERROR;
    LONG          cSpellWords = 0;
    IHTMLTxtRange *pTxtRange=0;
    LONG          cb;
    VARIANT_BOOL  fSuccess;

    if (m_Stack.fEmpty())
        goto error;

    while (!(m_Stack.fEmpty()) && cSpellWords <= MAX_SPELLWORDS)
    {
        m_Stack.HrGetRange(&pTxtRange);
        if (pTxtRange)
        {
            while(cSpellWords <= MAX_SPELLWORDS)
            {
                pTxtRange->collapse(VARIANT_TRUE);
                if (SUCCEEDED(pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess)) && fSuccess==VARIANT_TRUE)
                {
                    HrBkgrndSpellCheck(pTxtRange);
                    cSpellWords++;
                }
                else
                {
                    m_Stack.pop();
                    SafeRelease(pTxtRange);
                    break;
                }

                cb=0;
                if (FAILED(pTxtRange->moveStart((BSTR)c_bstr_Word, 1, &cb)) || cb!=1)
                {
                    m_Stack.pop();
                    SafeRelease(pTxtRange);
                    break;
                }
            }

        }
    }

error:
    SafeRelease(pTxtRange);
    return hr;
}
#endif // BACKGROUNDSPELL

#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrBkgrndSpellCheck(IHTMLTxtRange *pTxtRange)
{
    HRESULT         hr = NOERROR;
    LPSTR           pszText = 0;
    VARIANT_BOOL    fSuccess;

    hr = pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (hr == HR_S_SPELLCONTINUE)
        goto error;

    StripNBSPs(pszText);

    // ignore words with wildcards
    if (StrChr(pszText, '*'))
        goto error;

    RemoveTrailingSpace(pszText);
    hr = HrCheckWord(pszText);
    if(FAILED(hr))
        goto error;

    if(m_wsrb.sstat!=sstatNoErrors && m_wsrb.sstat!=sstatRepeatWord) //found an error.
    {
        // FIgnore should take pTxtRange as the parameter.
        if(FIgnore(pTxtRange))
        {
            m_wsrb.sstat = sstatNoErrors;
            goto error;
        }

        if (HrHasSquiggle(pTxtRange)==S_OK)
        {
            DebugTrace("Spell: Bad word %s\n", pszText);
            goto error;
        }

        //put red squiggle
        HrSetSquiggle(pTxtRange);

    }
    else //if the wrong word is corrected, delete <U> tag.
    {
        if (HrHasSquiggle(pTxtRange)==S_OK)
            HrDeleteSquiggle(pTxtRange);

    }

error:
    SafeMemFree(pszText);   
    return hr;
}
#endif // BACKGROUNDSPELL


#ifdef BACKGROUNDSPELL
//const static CHAR c_szSquiggleFmt[] = "<U style='color:red'>%s</U>";
const static CHAR c_szSquiggleFmt[] = "<SPAN class=badspelling STYLE='text-decoration:underline;color:red'>%s</SPAN>";
HRESULT CSpell::HrSetSquiggle(IHTMLTxtRange *pTxtRange)
{
    CHAR    szBuf[MAX_PATH]={0};
    BSTR    bstr=0;
    HRESULT hr=NOERROR;
    LPSTR   pszText=0;
    INT     nSpaces=0;
    int     i;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (hr == HR_S_SPELLCONTINUE)
        goto error;
    
    hr = HrGetSpaces(pszText, &nSpaces);
    if(FAILED(hr))
        goto error;
    
    RemoveTrailingSpace(pszText);
    wsprintf(szBuf, c_szSquiggleFmt, pszText);
    for(i=0; i<(nSpaces-1); i++)
        lstrcat(szBuf, "&nbsp");
    if (nSpaces>0)
        lstrcat(szBuf, " ");

    HrLPSZToBSTR(szBuf, &bstr);
    hr = pTxtRange->pasteHTML(bstr);
    if(FAILED(hr))
        goto error;

error:
    SafeSysFreeString(bstr);
    SafeMemFree(pszText);
    return hr;
}
#endif // BACKGROUNDSPELL


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrDeleteSquiggle(IHTMLTxtRange *pTxtRange)
{
    CHAR    szBuf[MAX_PATH]={0};
    BSTR    bstr=0;
    HRESULT hr=NOERROR;
    LPSTR   pszText=0;
    INT     nSpaces=0;
    int     i;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (hr == HR_S_SPELLCONTINUE)
        goto error;
    
    hr = HrGetSpaces(pszText, &nSpaces);
    if(FAILED(hr))
        goto error;

    lstrcpy(szBuf, pszText);
    for(i=0; i<(nSpaces-1); i++)
        lstrcat(szBuf, "&nbsp");
    if (nSpaces>0)
        lstrcat(szBuf, " ");
    HrLPSZToBSTR(szBuf, &bstr);
    hr = pTxtRange->pasteHTML(bstr);
    if(FAILED(hr))
        goto error;

error:
    SafeSysFreeString(bstr);
    SafeMemFree(pszText);
    return hr;
}
#endif // BACKGROUNDSPELL

HRESULT CSpell::HrGetSpaces(LPSTR pszText, INT* pnSpaces)
{
    LPSTR p;
    *pnSpaces = 0;
    p = StrChrI(pszText, ' ');
    if(p)
    {
        *pnSpaces = (INT) (&pszText[lstrlen(pszText)] - p);
        Assert(*pnSpaces>=0);
    }
    return NOERROR;
}

HRESULT CSpell::HrInsertMenu(HMENU hmenu, IHTMLTxtRange *pTxtRange)
{
    LPSTR   pch=0;
    LPSTR   pszText=0;
    INT     index=0;
    HRESULT hr;
    VARIANT_BOOL    fSuccess;

    hr = pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

    hr = HrGetText(pTxtRange, &pszText);
    if(FAILED(hr))
        goto error;
    if (pszText==NULL || *pszText=='\0')
    {
        hr = E_FAIL;
        goto error;
    }
        
    strcpy(m_szEdited, pszText);
    HrSpellSuggest();
    pch = m_szSuggest;
    if (*pch == '\0')
    {
        LoadString(g_hLocRes, idsSpellNoSuggestions, m_szTempBuffer,
                   sizeof(m_szTempBuffer)/sizeof(TCHAR));
        InsertMenu(hmenu, (UINT)0, MF_BYPOSITION|MF_STRING, idmSuggest0, m_szTempBuffer);
        EnableMenuItem(hmenu, idmSuggest0, MF_BYCOMMAND|MF_GRAYED);
        //ListBox_AddString(hwndLbx, m_szTempBuffer);
    }
    else
    {
        while(*pch != '\0' && index<5)
        {
            InsertMenu(hmenu, (UINT)index, MF_BYPOSITION|MF_STRING, idmSuggest0 + index, pch);
            index++;
            //ListBox_AddString(hwndLbx, pch);
            while(*pch != '\0')
                pch++;
            pch++;
        }
    }

error:
    SafeMemFree(pszText);
    return hr;
}


const static TCHAR c_szFmt[] = "%s%s";
HRESULT CSpell::HrReplaceBySuggest(IHTMLTxtRange *pTxtRange, INT index)
{
    CHAR    szBuf[MAX_PATH] = {0};
    BSTR    bstr=0;
    BSTR    bstrPut=0;
    LPSTR   pch=0;
    INT     i=0;
    HRESULT hr;

    pch = m_szSuggest;
    while(*pch != '\0' && i<5)
    {
        if (index == i)
        {
            strcpy(szBuf, pch);

            if (SUCCEEDED(pTxtRange->get_text(&bstr)) && bstr)
            {
                LPSTR   pszText = 0;
                if (SUCCEEDED(HrBSTRToLPSZ(CP_ACP, bstr, &pszText)) && pszText)
                {
                    LPSTR   psz;
                    INT     nSpaces=0;
                    psz = StrChrI(pszText, ' ');
                    if(psz)
                    {
                        nSpaces = (INT) (&pszText[lstrlen(pszText)] - psz);
                        Assert(nSpaces>=0);
                        for(int i=0; i<(nSpaces-1); i++)
                            lstrcat(szBuf, "&nbsp;");
                        if (nSpaces>0)
                            lstrcat(szBuf, " ");
                    }
                    hr = HrLPSZToBSTR(szBuf, &bstrPut);

                    SafeMemFree(pszText);
                }
                SafeSysFreeString(bstr);
            }
            if (bstrPut)
            {
                pTxtRange->pasteHTML(bstrPut);
                SafeSysFreeString(bstrPut);
            }
            break;
        }
        i++;
        while(*pch != '\0')
            pch++;
        pch++;
    }

    return NOERROR;
}





HRESULT CSpell::HrFindErrors()
{
    HRESULT hr = NOERROR;

    if(m_State == SEL)
    {
        hr = HrCheckRange(m_pRangeSelExpand);
        // if hr==HR_S_ABORT, quit so as to pass control to dialog procedure which calls HrFindErrors.
        if(TESTHR(hr))
            goto error;

        if(AthMessageBoxW(m_hwndDlg ? m_hwndDlg : m_hwndNote,
                            MAKEINTRESOURCEW(idsSpellCaption),
                            MAKEINTRESOURCEW(idsSpellMsgContinue),
                            NULL, 
                            MB_YESNO | MB_ICONEXCLAMATION ) != IDYES)
        {
            m_fShowDoneMsg = FALSE;
            goto error;
        }

        CleanupState();
    }

    if(m_State == SELENDDOCEND)
    {
        DumpRange(m_pRangeSelEndDocEnd);
        m_fIgnoreScope = TRUE;
        hr = HrCheckRange(m_pRangeSelEndDocEnd);
        m_fIgnoreScope = FALSE;
        if(TESTHR(hr))
            goto error;

        CleanupState();

        hr = HrSpellReset();
        if (FAILED(hr))
            goto error;
    }

    if(m_State == DOCSTARTSELSTART)
    {
        hr = HrCheckRange(m_pRangeDocStartSelStart);
        if(TESTHR(hr))
            goto error;

        CleanupState();
    }

error:
    // save the hr so as to know if something went wrong when dialog procedure calls HrFindErrors.
    m_hr = hr;
    return hr;
}

VOID CSpell::CleanupState()
{
    m_State++;
    SafeRelease(m_pRangeChecking);
}

HRESULT CSpell::HrCheckRange(IHTMLTxtRange* pRange)
{
    HRESULT         hr = NOERROR;
    INT_PTR         nCode;
    LPSTR           pszText = 0;
    VARIANT_BOOL    fSuccess;

    if(m_pRangeChecking == NULL)
    {
        hr = pRange->duplicate(&m_pRangeChecking);
        if(FAILED(hr))
            goto error;

        hr = m_pRangeChecking->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto error;
    }

    while(TRUE)
    {
        SafeMemFree(pszText);

        hr = HrGetNextWordRange(m_pRangeChecking);
        if(FAILED(hr))
            goto error;
        if (hr == HR_S_SPELLBREAK)
            break;
        if (hr == HR_S_SPELLCONTINUE)
            continue;

        // Do we really need it?
        if (!m_fIgnoreScope)
        {
            hr = pRange->inRange(m_pRangeChecking, &fSuccess);
            if(FAILED(hr))
                goto error;
            if(fSuccess != VARIANT_TRUE)
                break;
        }

        // check if we are on the original text of a reply/forward message.
        if(m_pRangeIgnore)
        {
            fSuccess = VARIANT_FALSE;

            m_pRangeIgnore->inRange(m_pRangeChecking, &fSuccess);

            // normally don't spellcheck words in m_pRangeIgnore.
            // but if it's selected, we check it.
            if(fSuccess==VARIANT_TRUE)
            {
                hr = m_pRangeSelExpand->inRange(m_pRangeChecking, &fSuccess);
                if(FAILED(hr))
                    goto error;
                if(fSuccess != VARIANT_TRUE)
                    continue;
            }
        }

tryWordAgain:
        hr = HrGetText(m_pRangeChecking, &pszText);
        if(FAILED(hr))
            goto error;
        if (hr == HR_S_SPELLBREAK)
            break;
        if (hr == HR_S_SPELLCONTINUE)
            continue;

        hr = HrCheckWord(pszText);
        if(FAILED(hr))
            goto error;

        if(m_wsrb.sstat!=sstatNoErrors) //found an error.
        {
            if(FIgnore(m_pRangeChecking))
            {
                m_wsrb.sstat = sstatNoErrors;
                continue;
            }

            // if it contains a period, remove it for processing
            if (StrChr(pszText, '.'))
            {
                BOOL    fResult;
                
                hr = HrStripTrailingPeriod(m_pRangeChecking, &fResult);
                if (FAILED(hr))
                    goto error;

                if (fResult)
                    goto tryWordAgain;
            }

            HrProcessSpellErrors();
            if(!m_hwndDlg) //spellchecking dialog is lauched only once.
            {
                nCode = DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddSpelling), m_hwndNote,
                                      (DLGPROC) SpellingDlgProc, (LPARAM)this);

            }
            if(nCode == -1)
                hr = E_FAIL;
            else if(FAILED(m_hr))
                // something was wrong when dialog calls HrFindErrors.
                // it has higher priority than IDCANCEL.
                hr = m_hr;
            else if(nCode == IDCANCEL)
                hr = HR_S_SPELLCANCEL;
            else
                // we quit here to pass control to the dialog procedure which calls HrFindErrors.
                hr = HR_S_ABORT;
            goto error;
        }

    }

error:
    SafeMemFree(pszText);   

    return hr;
}

HRESULT CSpell::HrGetText(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, LPSTR *ppszText)
{
    HRESULT             hr = NOERROR;
    IHTMLTxtRange       *pTxtRange = NULL;
    BSTR                bstr = NULL;

    if (ppszText == NULL || pRangeStart == NULL || pRangeEnd == NULL)
        return E_INVALIDARG;

    *ppszText = NULL;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    hr = m_pBodyElem->createTextRange(&pTxtRange);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->MoveRangeToPointers(pRangeStart, pRangeEnd, pTxtRange);
    if (FAILED(hr))
        goto error;

    hr = pTxtRange->get_text(&bstr);
    if (FAILED(hr))
        goto error;

    if(bstr==NULL || SysStringLen(bstr)==0)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }

    // never spell check Japanese.
    if(((WORD)*bstr > (WORD)0x3000) && //DBCS
        (GetACP() == 932 || FIgnoreDBCS()))
    {
        hr = HR_S_SPELLCONTINUE;
        goto error;
    }
    
    hr = HrBSTRToLPSZ(CP_ACP, bstr, ppszText);
    if (FAILED(hr))
        goto error;
    if (*ppszText == NULL)
    {
        hr = E_FAIL;
        goto error;
    }
    
error:
    SafeRelease(pTxtRange);
    SafeSysFreeString(bstr);

    return hr;
}

HRESULT CSpell::HrGetText(IHTMLTxtRange* pRange, LPSTR *ppszText)
{
    BSTR        bstr=0;
    HRESULT     hr = NOERROR;
    UINT        uCodePage;

    if (ppszText==NULL || pRange==NULL)
        return E_INVALIDARG;

    *ppszText = 0;

    hr = pRange->get_text(&bstr);
    if(FAILED(hr))
        goto error;
    if(bstr==NULL || SysStringLen(bstr)==0)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }

    // never spell check Japanese.
    if(((WORD)*bstr > (WORD)0x3000) && //DBCS
        (GetACP() == 932 || FIgnoreDBCS()))
    {
        hr = HR_S_SPELLCONTINUE;
        goto error;
    }

    uCodePage = GetCodePage();
    *ppszText = PszToANSI(uCodePage, bstr);
    if (*ppszText == NULL)
    {
        hr = E_FAIL;
        goto error;
    }

error:
    SafeSysFreeString(bstr);
    return hr;
}

HRESULT CSpell::HrStripTrailingPeriod(IHTMLTxtRange* pRange, BOOL* pfResult)
{
    HRESULT             hr = NOERROR;
    IMarkupPointer      *pRangeStart = NULL;
    IMarkupPointer      *pRangeEnd = NULL;
    IMarkupPointer      *pRangeTemp = NULL;
    MARKUP_CONTEXT_TYPE markupContext;
    long                cch;
    OLECHAR             chText[64];
    BOOL                fResult;

    if (pRange==NULL || pfResult == NULL)
        return E_INVALIDARG;

    *pfResult = FALSE;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeStart);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeTemp);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->MovePointersToRange(pRange, pRangeStart, pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = pRangeStart->IsEqualTo(pRangeEnd, &fResult);
    if (FAILED(hr))
        goto error;

    if (fResult)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }
    
    // check for '.' and remove
    {
        hr = pRangeTemp->MoveToPointer(pRangeEnd);
        if (FAILED(hr))
            goto error;
        
        while(TRUE)
        {
            cch = 1;
            hr = pRangeTemp->Left(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            hr = pRangeTemp->IsRightOf(pRangeStart, &fResult);
            if (FAILED(hr))
                goto error;

            if (!fResult)
            {
                hr = HR_S_SPELLBREAK;
                goto error;
            }

            if (markupContext == CONTEXT_TYPE_Text && chText[0] != L'.')
                goto finished;

            cch = 1;
            hr = pRangeTemp->Left(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_Text)
            {
                hr = pRangeEnd->MoveToPointer(pRangeTemp);
                if (FAILED(hr))
                    goto error;

                *pfResult = TRUE;
            }
        }
    }

finished:
    hr = m_pMarkup->MoveRangeToPointers(pRangeStart, pRangeEnd, pRange);
    if (FAILED(hr))
        goto error;

error:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    SafeRelease(pRangeTemp);
    
    return hr;
}

HRESULT CSpell::HrHasWhitespace(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, BOOL *pfResult)
{
    HRESULT             hr = NOERROR;
    LPSTR               pszText = NULL;
    LPSTR               psz;
    
    if (pRangeStart == NULL || pRangeEnd == NULL || pfResult == NULL)
        return E_INVALIDARG;

    *pfResult = FALSE;

    hr = HrGetText(pRangeStart, pRangeEnd, &pszText);
    if (FAILED(hr) || HR_S_SPELLCONTINUE == hr || HR_S_SPELLBREAK == hr)
        goto error;

    Assert(NULL != pszText);
    for(psz = pszText; *psz; psz = CharNext(psz))
    {
        if (IsSpace(psz))
        {
            *pfResult = TRUE;
            break;
        }
    }
        
error:
    SafeMemFree(pszText);

    return hr;
}

HRESULT CSpell::HrGetNextWordRange(IHTMLTxtRange* pRange)
{
    HRESULT             hr = NOERROR;
    IMarkupPointer      *pRangeStart = NULL;
    IMarkupPointer      *pRangeEnd = NULL;
    IMarkupPointer      *pRangeTemp = NULL;
    MARKUP_CONTEXT_TYPE markupContext;
    long                cch;
    OLECHAR             chText[64];
    BOOL                fResult;
    BOOL                fFoundWhite;
    
    if (pRange==NULL)
        return E_INVALIDARG;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeStart);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->CreateMarkupPointer(&pRangeTemp);
    if (FAILED(hr))
        goto error;

    hr = m_pMarkup->MovePointersToRange(pRange, pRangeStart, pRangeEnd);
    if (FAILED(hr))
        goto error;

    hr = pRangeStart->IsEqualTo(pRangeEnd, &fResult);
    if (FAILED(hr))
        goto error;

    if (!fResult)
    {
        do
        {
            hr = pRangeStart->MoveUnit(MOVEUNIT_NEXTWORDBEGIN);
            if (FAILED(hr))
                goto error;

            // make sure beyond the old end
            hr = pRangeStart->IsLeftOf(pRangeEnd, &fResult);
            if (FAILED(hr))
                goto error;
                
        } while(fResult);

        hr = pRangeEnd->MoveToPointer(pRangeStart);
        if (FAILED(hr))
            goto error;
    }
    
    hr = pRangeEnd->MoveUnit(MOVEUNIT_NEXTWORDEND);
    if (FAILED(hr))
        goto error;
    
processNextWord:
    // check to see if we have anything
    hr = pRangeEnd->IsRightOf(pRangeStart, &fResult);
    if (FAILED(hr))
        goto error;

    // if the end is not to the right of the start then we do not have a word
    if (!fResult)
    {
        hr = HR_S_SPELLBREAK;
        goto error;
    }

    // strip preceding puncts or white space
    // words can also be created with just puncts and whitespace
    {
        while(TRUE)
        {
            cch = 1;
            hr = pRangeStart->Right(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            hr = pRangeStart->IsLeftOf(pRangeEnd, &fResult);
            if (FAILED(hr))
                goto error;

            if (!fResult)
            {
                hr = pRangeEnd->MoveUnit(MOVEUNIT_NEXTWORDEND);
                if (FAILED(hr))
                    goto error;

                continue;
            }

            if (markupContext == CONTEXT_TYPE_Text && 0 == ((C1_SPACE | C1_PUNCT) & GetWCharType(chText[0])))
                break;

            cch = 1;
            hr = pRangeStart->Right(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;
        }
    }

    // check for white space and remove
    {
        fFoundWhite = FALSE;

        hr = pRangeTemp->MoveToPointer(pRangeEnd);
        if (FAILED(hr))
            goto error;
            
        while(TRUE)
        {
            cch = 1;
            hr = pRangeTemp->Left(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            hr = pRangeTemp->IsRightOf(pRangeStart, &fResult);
            if (FAILED(hr))
                goto error;

            if (!fResult)
            {
                hr = HR_S_SPELLBREAK;
                goto error;
            }

            if (markupContext == CONTEXT_TYPE_Text)
            {
                if (0 == (C1_SPACE & GetWCharType(chText[0])))
                {
                    if (!fFoundWhite)
                        break;
                    
                    goto finished;
                }

                fFoundWhite = TRUE;
            }

            cch = 1;
            hr = pRangeTemp->Left(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_Text)
            {
                hr = pRangeEnd->MoveToPointer(pRangeTemp);
                if (FAILED(hr))
                    goto error;
            }
        }
    }

    // now look for a period
    {
        hr = pRangeTemp->MoveToPointer(pRangeEnd);
        if (FAILED(hr))
            goto error;
        
        while(TRUE)
        {
            cch = 1;
            hr = pRangeTemp->Right(FALSE, &markupContext, NULL, &cch, chText);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_None)
                goto finished;

            if (markupContext == CONTEXT_TYPE_Text && chText[0] != L'.')
                goto finished;

            cch = 1;
            hr = pRangeTemp->Right(TRUE, NULL, NULL, &cch, NULL);
            if (FAILED(hr))
                goto error;

            if (markupContext == CONTEXT_TYPE_Text && chText[0] == L'.')
            {
                hr = HrHasWhitespace(pRangeStart, pRangeTemp, &fResult);
                if (FAILED(hr))
                    goto error;

                if (fResult)
                    goto finished;              
                    
                hr = pRangeEnd->MoveToPointer(pRangeTemp);
                if (FAILED(hr))
                    goto error;

                // scan ahead for characters
                // need to check for i.e. -- abbreviations
                // it sure would be nice if Trident could do this!!
                {
                    while(TRUE)
                    {
                        cch = 1;
                        hr = pRangeTemp->Right(FALSE, &markupContext, NULL, &cch, chText);
                        if (FAILED(hr))
                            goto error;

                        if (markupContext == CONTEXT_TYPE_None)
                            goto finished;

                        if (markupContext == CONTEXT_TYPE_Text && 0 == (C1_SPACE & GetWCharType(chText[0])))
                            goto finished;

                        cch = 1;
                        hr = pRangeTemp->Right(TRUE, NULL, NULL, &cch, NULL);
                        if (FAILED(hr))
                            goto error;

                        // we found more text
                        // need to check to see if we crossed white space to get here
                        if (markupContext == CONTEXT_TYPE_Text)
                        {
                            hr = pRangeTemp->MoveToPointer(pRangeEnd);
                            if (FAILED(hr))
                                goto error;

                            hr = pRangeTemp->MoveUnit(MOVEUNIT_NEXTWORDEND);
                            if (FAILED(hr))
                                goto finished;

                            hr = HrHasWhitespace(pRangeStart, pRangeTemp, &fResult);
                            if (FAILED(hr))
                                goto error;

                            if (fResult)
                                goto finished;
                                                            
                            pRangeEnd->MoveToPointer(pRangeTemp);
                            if (FAILED(hr))
                                goto error;
                                
                            goto processNextWord;
                        }
                    }
                }
                    
                goto finished;
            }

        }
    }

finished:
    hr = m_pMarkup->MoveRangeToPointers(pRangeStart, pRangeEnd, pRange);
    if (FAILED(hr))
        goto error;

error:
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    SafeRelease(pRangeTemp);
        
    return hr;
}

BOOL CSpell::FIgnore(IHTMLTxtRange *pRangeChecking)
{
    HRESULT                 hr;
    IHTMLAnchorElement      *pAE=0;
    IHTMLElement            *pElemParent=0;
    BOOL                    fRet = FALSE;
    BSTR                    bstr=0;
    IHTMLTxtRange           *pRange=0;
    VARIANT_BOOL            fSuccess;

    if(pRangeChecking == NULL)
        return fRet;

    if(FIgnoreURL())
    {
        hr = pRangeChecking->duplicate(&pRange);
        if(FAILED(hr))
            goto Cleanup;

        hr = pRange->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto Cleanup;

        hr = pRange->expand((BSTR)c_bstr_Character, &fSuccess);
        if(FAILED(hr))
            goto Cleanup;

        // check pRangeChecking if we are on URL
        hr = pRange->parentElement(&pElemParent);
        if(FAILED(hr))
            goto Cleanup;

        hr = pElemParent->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE);
        if(FAILED(hr))
            goto Cleanup;

        hr = pAE->get_href(&bstr);
        if(FAILED(hr))
            goto Cleanup;

        if(bstr != NULL)
        {
            fRet = TRUE;
            goto Cleanup;
        }
    }

Cleanup:
    ReleaseObj(pElemParent);
    ReleaseObj(pAE);
    ReleaseObj(pRange);
    SafeSysFreeString(bstr);
    return fRet;
}

// scotts@directeq.com - can now specify dict index - 53193
HRESULT CSpell::AddToUdrW(WCHAR* pwsz, PROOFLEX lex)
{
    m_pfnSpellerAddUdr(m_pid, lex, pwsz);
    return NOERROR;
}

// scotts@directeq.com - can now specify dict index - 53193
HRESULT CSpell::AddToUdrA(CHAR* psz, PROOFLEX lex)
{
    WCHAR   wszBuf[cchEditBufferMax]={0};
    MultiByteToWideChar(CP_ACP, 0, psz, -1, wszBuf, ARRAYSIZE(wszBuf)-1);
    return AddToUdrW(wszBuf, lex);
}

HRESULT CSpell::HrProcessSpellErrors()
{
    int     idSpellErrorString;
    HRESULT hr = S_OK;

    WideCharToMultiByte(GetCodePage(), 0, m_wsib.pwsz, -1, m_szWrongWord, sizeof(m_szWrongWord)-1, NULL, NULL);

    // Select error word in edit control except for Abbreviation warnings
    if (m_wsrb.sstat != sstatWordConsideredAbbreviation && m_pRangeChecking)
    {
        hr = m_pRangeChecking->select();
        if(FAILED(hr))
            goto End;
    }

    // Process spelling error
    if (m_wsrb.sstat == sstatReturningChangeAlways ||
        m_wsrb.sstat == sstatReturningChangeOnce)
    {
        WideCharToMultiByte(GetCodePage(), 0, m_wsrb.pwsz, -1, m_szEdited, sizeof(m_szEdited)-1, NULL, NULL);

        // "Change always" was returned.  This means we have to do the replacement
        // automatically and then find the next spelling error.
        if (m_wsrb.sstat==sstatReturningChangeAlways)
        {
            FVerifyThisText(m_szEdited, TRUE);
            m_fCanUndo = FALSE; // can't undo automatic replacements
            hr = HrReplaceErrorText(TRUE, FALSE);
            if (FAILED(hr))
                goto End;
            m_wsrb.sstat = sstatNoErrors;
            HrFindErrors();
        }
    }
    else if (m_wsrb.sstat == sstatWordConsideredAbbreviation)
    {
        // An abbreviation was returned.  We need to add it to the IgnoreAlways cache and
        // find the next spelling error.
        AddToUdrW((WCHAR*)m_wsib.pwsz, m_rgprflex[1]);
        m_wsrb.sstat = sstatNoErrors;
        HrFindErrors();

    }
    else
        lstrcpy(m_szEdited, m_szWrongWord);


    // Load the right error description string
    switch (m_wsrb.sstat)
    {
    case sstatUnknownInputWord:
    case sstatReturningChangeOnce:
    case sstatInitialNumeral:
        idSpellErrorString = idsSpellWordNotFound;
        break;
    case sstatRepeatWord:
        idSpellErrorString = idsSpellRepeatWord;
        break;
    case sstatErrorCapitalization:
        idSpellErrorString = idsSpellWordNeedsCap;
        break;
    }

    LoadString(g_hLocRes, idSpellErrorString, m_szErrType,
               sizeof(m_szErrType)/sizeof(TCHAR));

    // Handle suggestions
    m_fSuggestions = FALSE;
#ifdef __WBK__NEVER__
    if (m_wsrb.sstat == sstatReturningChangeOnce)
    {
        // Automatic suggestion of one word
        m_fSuggestions = TRUE;
        m_fNoneSuggested = FALSE;
    }
    else
#endif // __WBK__NEVER__
    {
        // Enumerate suggestion list if requested
        if (m_fAlwaysSuggest)
            hr = HrSpellSuggest();
    }

End:
    return hr;
}


HRESULT CSpell::HrReplaceErrorText(BOOL fChangeAll, BOOL fAddToUdr)
{
    HRESULT     hr=NOERROR;
    WCHAR       wszWrong[cchEditBufferMax]={0};
    WCHAR       wszEdited[cchEditBufferMax]={0};
    int         cwch;
    
    if (fAddToUdr)
    {
        RemoveTrailingSpace(m_szWrongWord);
        
        cwch = MultiByteToWideChar(GetCodePage(), 0, m_szWrongWord, -1, wszWrong, ARRAYSIZE(wszWrong)-1);
        Assert(cwch);
        
        cwch = MultiByteToWideChar(GetCodePage(), 0, m_szEdited, -1, wszEdited, ARRAYSIZE(wszEdited)-1);
        Assert(cwch);
        
        hr = m_pfnSpellerAddChangeUdr(m_pid, fChangeAll ? lxtChangeAlways : lxtChangeOnce, wszWrong, wszEdited);
        if (FAILED(hr))
            goto error;
    }

    hr = HrReplaceSel(m_szEdited);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}


HRESULT CSpell::HrCheckWord(LPCSTR pszWord) 
{
    DWORD               cwchWord;
    PTEC                ptec;
    SPELLERSUGGESTION   sugg;
    
    cwchWord = MultiByteToWideChar(GetCodePage(), 0, pszWord, -1, m_wszIn, ARRAYSIZE(m_wszIn)-1);
    ZeroMemory(&m_wsrb, sizeof(m_wsrb));
    ZeroMemory(&m_wsib, sizeof(m_wsib));
    m_wsib.pwsz     = m_wszIn;
    m_wsib.cch      = cwchWord;

    m_wsib.clex     = m_clex; 
    m_wsib.prglex   = m_rgprflex;
    m_wsib.ichStart = 0;
    m_wsib.cchUse   = cwchWord;
    m_wsrb.pwsz     = m_wszRet;
    m_wsrb.cchAlloc = ARRAYSIZE(m_wszRet);
    m_wsrb.cszAlloc = 1; // we've got space for 1 speller suggestion
    m_wsrb.prgsugg  = &sugg;  

    // scotts@directeq.com - "repeat word" bug fix - 2757, 13573, 56057
    // m_wsib.sstate should only be sstateIsContinued after the first call to this function
    // (e.g., when a new speller session is invoked using F7 or the menu item).
    // This allows the spell code to accurately track "repeat" words.
    if (m_fSpellContinue)
        m_wsib.sstate = sstateIsContinued;
    else
        m_fSpellContinue = TRUE;

    ptec = m_pfnSpellerCheck(m_pid, scmdVerifyBuffer, &m_wsib, &m_wsrb);

    // do we haveinvalid characters, if so return NOERR
    if (ProofMajorErr(ptec) != ptecNoErrors && ProofMinorErr(ptec) == ptecInvalidEntry)
    {
        // force it to be correct
        m_wsrb.sstat = sstatNoErrors;

        return NOERROR;
    }
    
    if (ptec != ptecNoErrors)
        
        return E_FAIL;

    return NOERROR;
}

HRESULT CSpell::HrSpellSuggest()
{
    int                 cchWord;
    WCHAR               wszBuff[cchMaxSuggestBuff]={0};
    WCHAR               wszWord[cchEditBufferMax]={0};
    SPELLERSUGGESTION   rgsugg[20];
    TCHAR              *pchNextSlot=0;
    ULONG               iszSuggestion;
    int                 cchSuggestion;
    SPELLERSUGGESTION  *pSuggestion;
    TCHAR              *pchLim=0;
    PTEC                ptec;
    SPELLERSTATUS       sstat;

    sstat = m_wsrb.sstat;
    cchWord = MultiByteToWideChar(GetCodePage(), 0, m_szEdited, -1, wszWord, ARRAYSIZE(wszWord)-1);
    m_wsib.cch      = cchWord;
    m_wsib.clex     = m_clex; 
    m_wsib.prglex   = m_rgprflex;
    m_wsib.ichStart = 0;
    m_wsib.cchUse   = cchWord;
    m_wsib.pwsz     = wszWord;

    m_wsrb.prgsugg  = rgsugg;
    m_wsrb.cszAlloc = ARRAYSIZE(rgsugg);
    m_wsrb.pwsz     = wszBuff;
    m_wsrb.cchAlloc = ARRAYSIZE(wszBuff);

    ptec = m_pfnSpellerCheck(m_pid, scmdSuggest, &m_wsib, &m_wsrb);
    m_fNoneSuggested = (m_wsrb.csz == 0);

    pchLim = &m_szSuggest[ARRAYSIZE(m_szSuggest)-1];
    pchNextSlot = m_szSuggest;;
    do
    {
        pSuggestion = m_wsrb.prgsugg;
        if (sstatMoreInfoThanBufferCouldHold == m_wsrb.sstat)
        {
            m_wsrb.csz = m_wsrb.cszAlloc;
        }
        for (iszSuggestion = 0; iszSuggestion < m_wsrb.csz; iszSuggestion++)
        {
            cchSuggestion = WideCharToMultiByte(GetCodePage(), 0, pSuggestion->pwsz, -1, 
                                                pchNextSlot, (int) (pchLim-pchNextSlot), NULL, NULL);

            // bradk@directeq.com - raid 29322
            // make sure words do not have trailing spaces
            // only the French speller returns words with trailing spaces
            RemoveTrailingSpace(pchNextSlot);
            cchSuggestion = lstrlen(pchNextSlot)+1;

            pSuggestion++;
            if (cchSuggestion > 0)
                pchNextSlot += cchSuggestion;
            Assert(pchNextSlot <= pchLim);
        }
        ptec = m_pfnSpellerCheck(m_pid, scmdSuggestMore, &m_wsib, &m_wsrb);
    } while (ptec == ptecNoErrors && m_wsrb.sstat!=sstatNoMoreSuggestions);
    *pchNextSlot = '\0';
    m_wsrb.sstat = sstat;
    m_fSuggestions = TRUE;

    return NOERROR;
}


VOID CSpell::FillSuggestLbx()
{
    HWND        hwndLbx;
    INT         isz;
    LPTSTR      sz;
    LPTSTR      pch;

    // Empty contents regardless
    hwndLbx = GetDlgItem(m_hwndDlg, LBX_Spell_Suggest);
    ListBox_ResetContent(hwndLbx);

    // We didn't even try to get any suggestions
    if (!m_fSuggestions)
        return;

    // We tried to get suggestions
    pch = m_szSuggest;
    if (*pch == '\0')
    {
        LoadString(g_hLocRes, idsSpellNoSuggestions, m_szTempBuffer,
                   sizeof(m_szTempBuffer)/sizeof(TCHAR));
        ListBox_AddString(hwndLbx, m_szTempBuffer);
    }
    else
    {
        while(*pch != '\0')
        {
            ListBox_AddString(hwndLbx, pch);
            while(*pch != '\0')
                pch++;
            pch++;
        }
    }

}

VOID UpdateEditedFromSuggest(HWND hwndDlg, HWND hwndEdited, HWND hwndSuggest)
{
    INT     nSel;
    INT     cch;
    LPSTR   szTemp;

    nSel = ListBox_GetCurSel(hwndSuggest);
    cch = ListBox_GetTextLen(hwndSuggest, nSel) + 1;
    if (MemAlloc((LPVOID *) &szTemp, cch))
    {
        ListBox_GetText(hwndSuggest, nSel, szTemp);
        SetWindowText(hwndEdited, szTemp);

        // Clear default button style from "Ignore" button and set default to "Change"
        Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Ignore), BS_PUSHBUTTON, TRUE);
        SendMessage(hwndDlg, DM_SETDEFID, PSB_Spell_Change, 0L);
        Button_SetStyle(GetDlgItem(hwndDlg, PSB_Spell_Change), BS_DEFPUSHBUTTON, TRUE);

        Edit_SetSel(hwndEdited, 0, 32767);  // select the whole thing
        Edit_SetModify(hwndEdited, TRUE);
        MemFree(szTemp);
    }
}


BOOL CSpell::FVerifyThisText(LPSTR szThisText, BOOL /*fProcessOnly*/)
{
    BOOL    fReturn=FALSE;
    HRESULT hr;

    Assert(szThisText);

    hr = HrCheckWord(szThisText);
    if (FAILED(hr))
        goto error;

    switch (m_wsrb.sstat)
    {
    case sstatUnknownInputWord:
    case sstatInitialNumeral:
    case sstatErrorCapitalization:
        if (AthMessageBoxW(m_hwndDlg, MAKEINTRESOURCEW(idsSpellCaption), MAKEINTRESOURCEW(idsSpellMsgConfirm), NULL, MB_YESNO | MB_ICONEXCLAMATION ) == IDYES)
            fReturn = TRUE;
        else
            fReturn = FALSE;
        break;
    default:
        fReturn = TRUE;
        break;
    }

error:
    return fReturn;
}


VOID CSpell::SpellSaveUndo(INT idButton)
{
    HRESULT     hr = NOERROR;

    if(!m_pRangeChecking)
        return;

    SafeRelease(m_pRangeUndoSave);
    m_pRangeChecking->duplicate(&m_pRangeUndoSave);
    if(!m_pRangeUndoSave)
        goto error;

    m_fCanUndo = TRUE;

error:
    return;
}

VOID CSpell::SpellDoUndo()
{
    HRESULT hr = NOERROR;
    IOleCommandTarget* pCmdTarget = NULL;
    CHARRANGE chrg = {0};
    LONG    lMin = 0;

    m_fCanUndo = FALSE;

    if(!m_pRangeUndoSave)
        goto Cleanup;

    SafeRelease(m_pRangeChecking);
    m_pRangeUndoSave->duplicate(&m_pRangeChecking);
    if(!m_pRangeChecking)
        goto Cleanup;


    hr = m_pRangeChecking->collapse(VARIANT_TRUE);
    if(FAILED(hr))
        goto Cleanup;

    if (m_fUndoChange)
    {
        m_fUndoChange = FALSE;
        hr = m_pDoc->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget);
        if(FAILED(hr))  
            goto Cleanup;
    
        hr = pCmdTarget->Exec(&CMDSETID_Forms3,
                           IDM_UNDO,
                           MSOCMDEXECOPT_DONTPROMPTUSER,
                           NULL, NULL);
        if(FAILED(hr))  
            goto Cleanup;
    }

Cleanup:
    ReleaseObj(pCmdTarget);

}


CSpell::CSpell(IHTMLDocument2* pDoc, IOleCommandTarget* pParentCmdTarget, DWORD dwSpellOpt)
{
    HRESULT     hr;
    
    Assert(pDoc);
    m_pDoc = pDoc;
    m_pDoc->AddRef();

    Assert(pParentCmdTarget);
    m_pParentCmdTarget = pParentCmdTarget;
    m_pParentCmdTarget->AddRef();

    m_hwndDlg = NULL;
    m_cRef = 1;
    m_fSpellContinue = FALSE;
    m_fCanUndo = FALSE;
    m_fUndoChange = FALSE;
    m_State = SEL;
    m_pRangeDocStartSelStart = NULL;
    m_pRangeSel = NULL;
    m_pRangeSelExpand = NULL;
    m_pRangeSelEndDocEnd = NULL;
    m_pRangeChecking = NULL;
    m_pRangeUndoSave = NULL;
    m_hr = NOERROR;
    m_hinstDll = NULL;
    ZeroMemory(&m_wsib, sizeof(m_wsib));
    ZeroMemory(&m_wsrb, sizeof(m_wsrb));
    ZeroMemory(&m_pid, sizeof(m_pid));
    m_fIgnoreScope = FALSE;
    m_dwCookieNotify = 0;
    m_dwOpt = dwSpellOpt;

    m_langid = lidUnknown;

    m_clex = 0;
    ZeroMemory(&m_rgprflex, sizeof(m_rgprflex));

    m_pMarkup = NULL;
    m_pBodyElem = NULL;

    m_fCSAPI3T1 = FALSE;
}

CSpell::~CSpell()
{
    CloseSpeller();

    SafeRelease(m_pDoc);
    SafeRelease(m_pParentCmdTarget);

    SafeRelease(m_pMarkup);

    SafeRelease(m_pBodyElem);
}


ULONG CSpell::AddRef()
{
    return ++m_cRef;
}


ULONG CSpell::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


HRESULT CSpell::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)this;

    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch*)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



/////////////////////////////////////////////////////////////////////////////
//
//  IDispatch
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CSpell::GetIDsOfNames(
    REFIID      /*riid*/,
    OLECHAR **  /*rgszNames*/,
    UINT        /*cNames*/,
    LCID        /*lcid*/,
    DISPID *    /*rgDispId*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSpell::GetTypeInfo(
    UINT        /*iTInfo*/,
    LCID        /*lcid*/,
    ITypeInfo **ppTInfo)
{
    if (ppTInfo)
        *ppTInfo=NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CSpell::GetTypeInfoCount(UINT *pctinfo)
{
    if (pctinfo)
        {
        *pctinfo=0;
        return NOERROR;
        }
    else
        return E_POINTER;
}

#ifdef BACKGROUNDSPELL
STDMETHODIMP CSpell::Invoke(
    DISPID          dispIdMember,
    REFIID          /*riid*/,
    LCID            /*lcid*/,
    WORD            wFlags,
    DISPPARAMS FAR* /*pDispParams*/,
    VARIANT *       /*pVarResult*/,
    EXCEPINFO *     /*pExcepInfo*/,
    UINT *          /*puArgErr*/)
{
    IHTMLWindow2        *pWindow=0;
    IHTMLEventObj       *pEvent=0;
    BSTR                bstr=0;
    HRESULT             hr=E_NOTIMPL;
    LONG                lKeyCode=0;
    LONG                cb;


    if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONKEYUP &&
        (wFlags & DISPATCH_METHOD))
    {
        // Order of events:
        // document gives us window gives us event object
        // the event object can tell us which button was clicked
        // event gives us source element gives us ID
        // a couple lstrcmps will tell us which one got hit
        if (!m_pDoc)
            return E_UNEXPECTED;

        m_pDoc->get_parentWindow(&pWindow);
        if (pWindow)
        {
            pWindow->get_event(&pEvent);
            if (pEvent)
            {
                pEvent->get_keyCode(&lKeyCode);
                if (lKeyCode == 32 || lKeyCode == 188/*','*/ || lKeyCode == 190/*'.'*/ || lKeyCode == 185/*':'*/ || lKeyCode == 186/*';'*/)
                {
                    IHTMLTxtRange *pTxtRange=0;
                    VARIANT_BOOL   fSuccess;
                    GetSelection(&pTxtRange);
                    if (pTxtRange)
                    {
                        pTxtRange->move((BSTR)c_bstr_Character, -2, &cb);
                        pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
                        //DumpRange(pRangeDup);
                        //pTxtRange->setEndPoint((BSTR)c_bstr_StartToStart, pRangeDup);
                        //DumpRange(pTxtRange);
                        //pRangeDup->Release();

                        m_Stack.push(pTxtRange);
                        pTxtRange->Release();
                    }
                }
                else if (lKeyCode == 8 /*backspace*/|| lKeyCode == 46/*del*/)
                {
                    IHTMLTxtRange *pTxtRange=0;
                    VARIANT_BOOL   fSuccess;
                    LONG           cb;
                    GetSelection(&pTxtRange);
                    if (pTxtRange)
                    {
                        pTxtRange->expand((BSTR)c_bstr_Word, &fSuccess);
                        if (HrHasSquiggle(pTxtRange)==S_OK)
                        {
                            //DumpRange(pTxtRange);
                            m_Stack.push(pTxtRange);
                        }
                        pTxtRange->Release();
                    }
                }
                pEvent->Release();
            }
            pWindow->Release();
        }
    } 
    else if (dispIdMember == DISPID_HTMLDOCUMENTEVENTS_ONKEYPRESS && (wFlags & DISPATCH_METHOD))
    {
        if (!m_pDoc)
            return E_UNEXPECTED;

        m_pDoc->get_parentWindow(&pWindow);
        if (pWindow)
        {
            pWindow->get_event(&pEvent);
            if (pEvent)
            {
                pEvent->get_keyCode(&lKeyCode);
                if (lKeyCode == 18)// CTRL+R
                {
                    IHTMLTxtRange*          pRangeDoc = NULL;

                    if (m_pBodyElem)
                        m_pBodyElem->createTextRange(&pRangeDoc);

                    if (pRangeDoc)
                    {
                        pRangeDoc->move((BSTR)c_bstr_Character, -1, &cb);
                        m_Stack.push(pRangeDoc);
                        pRangeDoc->Release();
                    }


                }
                pEvent->Release();
            }
            pWindow->Release();
        }
    }




    return hr;
}
#endif // BACKGROUNDSPELL


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrHasSquiggle(IHTMLTxtRange *pTxtRange)
{
    BSTR    bstr=0;
    HRESULT hr;
    LPWSTR  pwszSquiggleStart=0, pwszSquiggleEnd=0, pwszSquiggleAfter=0;

    hr = pTxtRange->get_htmlText(&bstr);
    if(FAILED(hr) || bstr==0 || *bstr==L'\0')
    {
        hr = S_FALSE;
        goto error;
    }

    hr = S_FALSE;
    pwszSquiggleStart = StrStrIW(bstr, L"<SPAN class=badspelling");
    if (pwszSquiggleStart)
    {
        pwszSquiggleEnd = StrStrIW(bstr, L"</SPAN>");
        if (pwszSquiggleEnd)
        {
            pwszSquiggleAfter = pwszSquiggleEnd + 7;
            if (*pwszSquiggleAfter == L' ' || *pwszSquiggleAfter == L'\0' || *pwszSquiggleAfter == L'&')
                hr = S_OK;
        }
    }

error:
    SafeSysFreeString(bstr);
    return hr;
}
#endif // BACKGROUNDSPELL


BOOL CSpell::OpenSpeller()
{
    SpellerParams   params;
    DWORD           dwSel;
    LANGID          langid;
    
    // LoadOldSpeller is called within LoadNewSpeller
    // We should be checking for V1 spellers after failing
    // for the desired V3 speller, then go on to check for
    // default speller and the speller for 1033.
    if (!LoadNewSpeller())
        goto error;

    if (!OpenUserDictionaries())
        goto error;

    dwSel = sobitStdOptions;
    m_fAlwaysSuggest = !!FAlwaysSuggest();
    if (FIgnoreNumber())
        dwSel |= sobitIgnoreMixedDigits;
    else
        dwSel &= ~sobitIgnoreMixedDigits;

    if (FIgnoreUpper())
        dwSel |= sobitIgnoreAllCaps;
    else
        dwSel &= ~sobitIgnoreAllCaps;

    if (m_pfnSpellerSetOptions(m_pid, soselBits, dwSel) != ptecNoErrors)
        goto error;

    return TRUE;

error:
    CloseSpeller();
    
    return FALSE;
}


BOOL FNewer(WORD *pwVerOld, WORD *pwVerNew)
{
    BOOL fOK = FALSE;
    
    Assert(pwVerOld);
    Assert(pwVerNew);

    if (pwVerNew[0] > pwVerOld[0])
        fOK = TRUE;
    else if (pwVerNew[0] == pwVerOld[0])
    {
        if (pwVerNew[1] > pwVerOld[1])
            fOK = TRUE;
        else if (pwVerNew[1] == pwVerOld[1])
        {
            if (pwVerNew[2] > pwVerOld[2])
                fOK = TRUE;
            else if (pwVerNew[2] == pwVerOld[2])
            {
                if (pwVerNew[3] >= pwVerOld[3])
                    fOK = TRUE;
            }
        }
    }

    return fOK;
}

BOOL GetDllVersion(LPTSTR pszDll, WORD *pwVer)
{
    Assert(pszDll);
    Assert(pwVer);

    BOOL fOK = FALSE;
    DWORD dwVerInfoSize, dwVerHnd;
    LPSTR pszInfo, pszVersion, pszT;
    LPWORD pwTrans;
    UINT uLen;
    char szGet[MAX_PATH];
    int i;

    ZeroMemory(pwVer, 4 * sizeof(WORD));

    if (dwVerInfoSize = GetFileVersionInfoSize(pszDll, &dwVerHnd))
    {
        if (pszInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize))
        {
            if (GetFileVersionInfo(pszDll, dwVerHnd, dwVerInfoSize, pszInfo))
            {
                if (VerQueryValue(pszInfo, "\\VarFileInfo\\Translation", (LPVOID*)&pwTrans, &uLen) &&
                    uLen >= (2 * sizeof(WORD)))
                {
                    // set up buffer for calls to VerQueryValue()
                    wsprintf(szGet, "\\StringFileInfo\\%04X%04X\\FileVersion", pwTrans[0], pwTrans[1]);
                    
                    if (VerQueryValue(pszInfo, szGet, (LPVOID *)&pszVersion, &uLen) && uLen)
                    {
                        i = 0;
                        while (*pszVersion)
                        {
                            if ((',' == *pszVersion) || ('.' == *pszVersion))
                                i++;
                            else
                            {
                                pwVer[i] *= 10;
                                pwVer[i] += (*pszVersion - '0');
                            }

                            pszVersion++;
                        }
                                
                        fOK = TRUE;
                    }
                }
            }

            GlobalFree((HGLOBAL)pszInfo);
        }
    }

    return fOK;
}

HINSTANCE LoadCSAPI3T1()
{
    static BOOL s_fInit = FALSE;
    HINSTANCE hinstLocal;

    EnterCriticalSection(&g_csCSAPI3T1);

    // Avoid doing this for every note!
    if (!s_fInit)
    {
        typedef enum
        {
            CSAPI_FIRST,
            CSAPI_DARWIN = CSAPI_FIRST,
            CSAPI_COMMON,
            CSAPI_OE,
            CSAPI_MAX,
        } CSAPISRC;

        BOOL fCheck;
        
        // cb is for BYTE counts, cch for CHARACTER counts
        DWORD cbDllPath;
        DWORD cchDllPath;

        int csapisrc;
        // Info about the dll currently being examined
        TCHAR szDllPath[MAX_PATH];
        WORD wVer[4] = {0};

        // Info about the dll we will ultimately load
        TCHAR szNewestDllPath[MAX_PATH];
        WORD wVerNewest[4] = {0};

        szDllPath[0] = TEXT('\0');
        szNewestDllPath[0] = TEXT('\0');

        // Avoid doing this for every note!
        s_fInit = TRUE;
    
        for (csapisrc = CSAPI_FIRST; csapisrc < CSAPI_MAX; csapisrc++)
        {
            // Assume we can't find the dll using the current method, so there's no need to look at its version
            fCheck = FALSE;
        
            switch (csapisrc)
            {
            // see if Darwin knows where it is
            case CSAPI_DARWIN:
                {    
                    UINT                            installState;

                    cchDllPath = ARRAYSIZE(szDllPath);
#ifdef DEBUG
                    installState = MsiLocateComponent(CSAPI3T1_DEBUG_GUID, szDllPath, &cchDllPath);
                    if (installState != INSTALLSTATE_LOCAL)
                    {
                        cchDllPath = ARRAYSIZE(szDllPath);
                        installState = MsiLocateComponent(CSAPI3T1_GUID, szDllPath, &cchDllPath);
                    }
#else   // DEBUG
                    installState = MsiLocateComponent(CSAPI3T1_GUID, szDllPath, &cchDllPath);
#endif  // DEBUG

                    // Only bother looking at the version if dll is installed
                    fCheck = (INSTALLSTATE_LOCAL == installState);
                }
                break;

            // Is it in Common Files\Microsoft Shared\Proof?
            case CSAPI_COMMON:
                {
                    DWORD           dwType;
                    HKEY            hkey = NULL;
                    LPTSTR          pszEnd;

                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSharedTools, 0, KEY_QUERY_VALUE, &hkey))
                    {
                        cbDllPath = sizeof(szDllPath);
                        if (SHQueryValueEx(hkey, c_szRegSharedToolsPath, 0L, &dwType, szDllPath, &cbDllPath) == ERROR_SUCCESS)
                        {
                            pszEnd = PathAddBackslash(szDllPath);
                            lstrcpy(pszEnd, c_szSpellCSAPI3T1Path);
                            fCheck = TRUE;
                        }

                        RegCloseKey(hkey);
                    }
                }
                break;

            // Is it in the OE directory?
            case CSAPI_OE:
                {
                    DWORD           dwType;
                    HKEY            hkey = NULL;
                    LPTSTR          pszEnd;

                    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
                    {
                        cbDllPath = sizeof(szDllPath);
                        if (SHQueryValueEx(hkey, c_szInstallRoot, 0L, &dwType, szDllPath, &cbDllPath) == ERROR_SUCCESS)
                        {
                            pszEnd = PathAddBackslash(szDllPath);
                            lstrcpy(pszEnd, c_szCSAPI3T1);
                            fCheck = TRUE;
                        }

                        RegCloseKey(hkey);
                    }
                }
                break;
        
            default:
                AssertSz(FALSE, "Unhandled case hit while looking for csapi3t1.dll!");
                break;
            }

            // Figure out the version of the dll if needed
            if (fCheck && GetDllVersion(szDllPath, wVer))
            {
                // If it's newer, remember the new version and the file's location
                if (FNewer(wVerNewest, wVer))
                {
                    CopyMemory(wVerNewest, wVer, sizeof(wVer));
                    lstrcpy(szNewestDllPath, szDllPath);
                }
            }

        }

        // Assuming we found something, try to load it
        if (szNewestDllPath[0])
            g_hinstCSAPI3T1 = LoadLibrary(szNewestDllPath);
    }
    
    hinstLocal = g_hinstCSAPI3T1;
    LeaveCriticalSection(&g_csCSAPI3T1);

    return hinstLocal;
}

BOOL CSpell::LoadOldSpeller()
{
    TCHAR           szLangId[MAX_PATH] = {0};
    TCHAR           rgchBufKeyTest[MAX_PATH] = {0};
    TCHAR           rgchBuf[MAX_PATH] = {0};
    WCHAR           rgchBufW[MAX_PATH] = {0};
    TCHAR           rgchLex[MAX_PATH] = {0};
    WCHAR           rgchLexW[MAX_PATH] = {0};
    WCHAR           rgchUserDictW[MAX_PATH]={0};
    PROOFLEXIN      plxin;
    PROOFLEXOUT     plxout;
    SpellerParams   params;
    LANGID          langid;

    m_hinstDll = LoadCSAPI3T1();
    if (!m_hinstDll)
    {
        m_pfnSpellerCloseLex  = 0;
        m_pfnSpellerTerminate = 0;
        return FALSE;
    }
    
    // We are using the global csapi3t1.dll, so don't free it!
    m_fCSAPI3T1 = TRUE;

    GetAddr(m_pfnSpellerSetDllName, PROOFSETDLLNAME,"SpellerSetDllName");
    GetAddr(m_pfnSpellerVersion,    PROOFVERSION,   "SpellerVersion");
    GetAddr(m_pfnSpellerInit,       PROOFINIT,      "SpellerInit");
    GetAddr(m_pfnSpellerTerminate,  PROOFTERMINATE, "SpellerTerminate");
    GetAddr(m_pfnSpellerSetOptions, PROOFSETOPTIONS,"SpellerSetOptions");
    GetAddr(m_pfnSpellerOpenLex,    PROOFOPENLEX,   "SpellerOpenLex");
    GetAddr(m_pfnSpellerCloseLex,   PROOFCLOSELEX,  "SpellerCloseLex");
    GetAddr(m_pfnSpellerCheck,      SPELLERCHECK,   "SpellerCheck");
    GetAddr(m_pfnSpellerAddUdr,     SPELLERADDUDR,  "SpellerAddUdr");
    GetAddr(m_pfnSpellerBuiltInUdr, SPELLERBUILTINUDR, "SpellerBuiltinUdr");
    GetAddr(m_pfnSpellerAddChangeUdr, SPELLERADDCHANGEUDR, "SpellerAddChangeUdr");

    langid = WGetLangID(m_pParentCmdTarget);
    wsprintf(szLangId, "%d", langid);
    wsprintf(rgchBufKeyTest, c_szRegSpellKeyDef, szLangId);
    GetSpellingPaths(rgchBufKeyTest, rgchBuf, rgchLex, sizeof(rgchBuf)/sizeof(TCHAR));

    if (!*rgchBuf)
        return FALSE;
        
    MultiByteToWideChar(GetCodePage(), 0, rgchBuf, -1, rgchBufW, ARRAYSIZE(rgchBufW)-1);
    m_pfnSpellerSetDllName(rgchBufW, GetCodePage());
    
    params.versionAPI = PROOFTHISAPIVERSION;
    if (m_pfnSpellerInit(&m_pid, &params) != ptecNoErrors)
        return FALSE;

    m_langid = langid;

    // Tell the speller the name of the dictionary.  This requires unicode conversion.
    MultiByteToWideChar(CP_ACP, 0, rgchLex, -1, rgchLexW, ARRAYSIZE(rgchLexW)-1);

    // open the main dict
    plxin.pwszLex       = rgchLexW;
    plxin.fCreate       = FALSE;
    plxin.lxt           = lxtMain;
    plxin.lidExpected   = langid;

    memset(&plxout, 0, sizeof(plxout));
    
    if (m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
        return FALSE;
        
    m_rgprflex[0] = plxout.lex;
    m_clex++;

    return TRUE;

// needed by the GetAddr macro -- bite me!!!!!!
error:
    return FALSE;
}


BOOL CSpell::LoadNewSpeller()
{
    SpellerParams   params;
    LANGID          langid;
    TCHAR           rgchEngine[MAX_PATH];
    int             cchEngine = sizeof(rgchEngine) / sizeof(rgchEngine[0]);
    TCHAR           rgchLex[MAX_PATH];
    int             cchLex = sizeof(rgchLex) / sizeof(rgchLex[0]);

    langid = WGetLangID(m_pParentCmdTarget);
    if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex))
    {
        if (!LoadOldSpeller())
        {
            langid = GetSystemDefaultLangID();
            if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex))
            {
                langid = 1033;  // bloody cultural imperialists.
                if (!GetNewSpellerEngine(langid, rgchEngine, cchEngine, rgchLex, cchLex))
                {
                    return FALSE;
                }
            }
        }
        else
            return TRUE;
    }

    Assert(rgchEngine[0]);  // should be something in the engine name!
    m_hinstDll = LoadLibrary(rgchEngine);
    if (!m_hinstDll)
    {
        m_pfnSpellerCloseLex  = 0;
        m_pfnSpellerTerminate = 0;
        return FALSE;
    }

    // We are not using csapi3t1.dll, so we should free it
    m_fCSAPI3T1 = FALSE;

    GetAddr(m_pfnSpellerVersion,    PROOFVERSION,   "SpellerVersion");
    GetAddr(m_pfnSpellerInit,       PROOFINIT,      "SpellerInit");
    GetAddr(m_pfnSpellerTerminate,  PROOFTERMINATE, "SpellerTerminate");
    GetAddr(m_pfnSpellerSetOptions, PROOFSETOPTIONS,"SpellerSetOptions");
    GetAddr(m_pfnSpellerOpenLex,    PROOFOPENLEX,   "SpellerOpenLex");
    GetAddr(m_pfnSpellerCloseLex,   PROOFCLOSELEX,  "SpellerCloseLex");
    GetAddr(m_pfnSpellerCheck,      SPELLERCHECK,   "SpellerCheck");
    GetAddr(m_pfnSpellerAddUdr,     SPELLERADDUDR,  "SpellerAddUdr");
    GetAddr(m_pfnSpellerBuiltInUdr, SPELLERBUILTINUDR, "SpellerBuiltinUdr");
    GetAddr(m_pfnSpellerAddChangeUdr, SPELLERADDCHANGEUDR, "SpellerAddChangeUdr");

    params.versionAPI = PROOFTHISAPIVERSION;
    if (m_pfnSpellerInit(&m_pid, &params) != ptecNoErrors)
        return FALSE;
    if (m_pfnSpellerSetOptions(m_pid, soselBits, 
            sobitSuggestFromUserLex | sobitIgnoreAllCaps | sobitIgnoreSingleLetter) != ptecNoErrors)
        return FALSE;

    m_langid = langid;

    // Hebrew does not have a main lex
    if ((langid != lidHebrew) || !m_fCSAPI3T1)
    {
        PROOFLEXIN      plxin;
        PROOFLEXOUT     plxout;
        WCHAR           rgchLexW[MAX_PATH]={0};
        
        // Tell the speller the name of the dictionary.  This requires unicode conversion.
        MultiByteToWideChar(CP_ACP, 0, rgchLex, -1, rgchLexW, ARRAYSIZE(rgchLexW)-1);

        // open the main dict
        plxin.pwszLex       = rgchLexW;
        plxin.fCreate       = FALSE;
        plxin.lxt           = lxtMain;
        plxin.lidExpected   = langid; 

        memset(&plxout, 0, sizeof(plxout));
        
        if (m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
            return FALSE;
            
        m_rgprflex[0] = plxout.lex;
        m_clex++;
    }
    
    return TRUE;

// needed by the GetAddr macro -- bite me!!!!!!
error:
    return FALSE;
}

BOOL EnumUserDictCallback(DWORD_PTR dwCookie, LPTSTR lpszDict)
{
    CSpell *pSpell = (CSpell*)dwCookie;
    
    Assert(pSpell);
    return pSpell->OpenUserDictionary(lpszDict);
}

BOOL CSpell::OpenUserDictionary(LPTSTR lpszDict)
{
    PROOFLEXIN  plxin;
    PROOFLEXOUT plxout;
    WCHAR       rgchUserDictW[MAX_PATH]={0};

    // make sure our directory exists
    {
        TCHAR   rgchDictDir[MAX_PATH];

        lstrcpy(rgchDictDir, lpszDict);

        PathRemoveFileSpec(rgchDictDir);
        OpenDirectory(rgchDictDir);
    }

    MultiByteToWideChar(CP_ACP, 0, lpszDict, -1, rgchUserDictW, ARRAYSIZE(rgchUserDictW)-1);

    plxin.pwszLex       = rgchUserDictW;
    plxin.fCreate       = TRUE;
    plxin.lxt           = lxtUser;
    plxin.lidExpected   = m_langid; 

    memset(&plxout, 0, sizeof(plxout));
    
    if ( m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
        return TRUE;
        
    m_rgprflex[m_clex++] = plxout.lex;

    return TRUE;
}

BOOL CSpell::OpenUserDictionaries()
{
    // now open the user dicts
    EnumUserDictionaries((DWORD_PTR)this, EnumUserDictCallback);

    // if only one dict open then we need to create default user dict
    if (m_clex == 1)
    {
        PROOFLEXIN  plxin;
        PROOFLEXOUT plxout;
        TCHAR       rgchUserDict[MAX_PATH]={0};

        if (GetDefaultUserDictionary(rgchUserDict, ARRAYSIZE(rgchUserDict)))
        {
            WCHAR   rgchUserDictW[MAX_PATH];
            
            // make sure our directory exists
            {
                TCHAR   rgchDictDir[MAX_PATH];

                lstrcpy(rgchDictDir, rgchUserDict);

                PathRemoveFileSpec(rgchDictDir);
                OpenDirectory(rgchDictDir);
            }

            MultiByteToWideChar(CP_ACP, 0, rgchUserDict, -1, rgchUserDictW, ARRAYSIZE(rgchUserDictW)-1);

            plxin.pwszLex       = rgchUserDictW;
            plxin.fCreate       = TRUE;
            plxin.lxt           = lxtUser;
            plxin.lidExpected   = m_langid;

            memset(&plxout, 0, sizeof(plxout));

            if (m_pfnSpellerOpenLex(m_pid, &plxin, &plxout) != ptecNoErrors)
                return TRUE;
                
            m_rgprflex[m_clex++] = plxout.lex;
        }
    }
    
    return TRUE;
}


VOID CSpell::CloseSpeller()
{
    SafeRelease(m_pDoc);
    SafeRelease(m_pParentCmdTarget);

    if (m_pfnSpellerCloseLex)
    {
        for(int i=0; i<cchMaxDicts; i++)
        {
            if (m_rgprflex[i])
            {
                m_pfnSpellerCloseLex(m_pid, m_rgprflex[i], TRUE);
                m_rgprflex[i] = NULL;
            }
        }
    }

    if (m_pfnSpellerTerminate)
        m_pfnSpellerTerminate(m_pid, TRUE);

    m_pid = 0;
    
    m_pfnSpellerVersion     = 0;
    m_pfnSpellerInit        = 0;
    m_pfnSpellerTerminate   = 0;
    m_pfnSpellerSetOptions  = 0;
    m_pfnSpellerOpenLex     = 0;
    m_pfnSpellerCloseLex    = 0;
    m_pfnSpellerCheck       = 0;
    m_pfnSpellerAddUdr      = 0; 
    m_pfnSpellerAddChangeUdr= 0; 
    m_pfnSpellerBuiltInUdr  = 0;

    // As long as we are not using the global CSAPI3T1.DLL, free it
    if (m_hinstDll && !m_fCSAPI3T1)
    {
        FreeLibrary(m_hinstDll);
        m_hinstDll = NULL;
    }
}


BOOL CSpell::GetNewSpellerEngine(LANGID lgid, TCHAR *rgchEngine, DWORD cchEngine, TCHAR *rgchLex, DWORD cchLex)
{
    DWORD                           er;
    LPCSTR                          rgpszDictionaryTypes[] = {"Normal", "Consise", "Complete"}; 
    int                             cDictTypes = sizeof(rgpszDictionaryTypes) / sizeof(LPCSTR);
    int                             i;
    TCHAR                           rgchQual[MAX_PATH];
    DWORD                           cch;

    if (rgchEngine == NULL || rgchLex == NULL)
        return FALSE;

    *rgchEngine = 0;
    *rgchLex = 0;
    
    wsprintf(rgchQual, "%d\\Normal", lgid);
    cch = cchEngine;

#ifdef DEBUG
    er = MsiProvideQualifiedComponent(SPELLER_DEBUG_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchEngine, &cch);
    if (er != ERROR_SUCCESS)
    {
        cch = cchEngine;
        er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchEngine, &cch);
    }
#else
    er = MsiProvideQualifiedComponent(SPELLER_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchEngine, &cch);
#endif

    if (er != ERROR_SUCCESS) 
        return FALSE;

    bool fFound = FALSE;

    // Hebrew does not have a lex
    if ((lgid != lidHebrew) || !m_fCSAPI3T1)
    {
        for (i = 0; i < cDictTypes; i++)
        {
            wsprintf(rgchQual, "%d\\%s",  lgid, rgpszDictionaryTypes[i]);
            cch = cchLex;
            
#ifdef DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_DEBUG_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchLex, &cch);
            if (er != ERROR_SUCCESS)
            {
                cch = cchLex;
                er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchLex, &cch);
            }
#else   // DEBUG
            er = MsiProvideQualifiedComponent(DICTIONARY_GUID, rgchQual, INSTALLMODE_DEFAULT, rgchLex, &cch);
#endif  // DEBUG

            if (ERROR_SUCCESS == er)
            {
                fFound = TRUE;
                break;
            }
        }
    }
    return fFound;
}

BOOL GetDefaultUserDictionary(TCHAR *rgchUserDict, int cchBuff)
{
    DWORD           dwType;
    DWORD           cbUserDict;
    HKEY            hkey = NULL;
    BOOL            fFound = FALSE;
    LPTSTR          pszEnd;
    
    if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegSharedTools, 0, KEY_QUERY_VALUE, &hkey))
    {
        cbUserDict = cchBuff * sizeof(TCHAR);
        
        if (SHQueryValueEx(hkey, c_szRegSharedToolsPath, 0L, &dwType, rgchUserDict, &cbUserDict) == ERROR_SUCCESS)
        {
            pszEnd = PathAddBackslash(rgchUserDict);
            if (pszEnd)
            {
                lstrcpy(pszEnd, c_szRegDefCustomDict);

                fFound = TRUE;
            }
        }

        RegCloseKey(hkey);
    }

    // if we where able to create a path to the user dict store it in the regdb
    if (fFound)
    {
        TCHAR   rgchBuf[cchMaxPathName];

        lstrcpy(rgchBuf, c_szRegSpellProfile);
        lstrcat(rgchBuf, c_szRegSpellKeyCustom);

        if(RegCreateKeyEx(HKEY_LOCAL_MACHINE, rgchBuf, 0, rgchBuf, REG_OPTION_NON_VOLATILE, KEY_WRITE, 0, &hkey, NULL) == ERROR_SUCCESS)
        {
            RegSetValueEx(hkey, c_szRegSpellPathDict, 0, REG_SZ, (BYTE *)rgchUserDict, (lstrlen(rgchUserDict) + 1) * sizeof(TCHAR));

            RegCloseKey(hkey);
        }
    }
    
    return fFound;
}

VOID CSpell::DeInitRanges()
{
    VARIANT_BOOL fSuccess;

    if(m_pRangeSel)
        m_pRangeSel->select();

    SafeRelease(m_pRangeDocStartSelStart);
    SafeRelease(m_pRangeSel);
    SafeRelease(m_pRangeSelExpand);
    SafeRelease(m_pRangeSelEndDocEnd);
    SafeRelease(m_pRangeChecking);
    SafeRelease(m_pRangeUndoSave);
    SafeRelease(m_pBodyElem);
    SafeRelease(m_pMarkup);
    m_hwndDlg = NULL;
}


HRESULT CSpell::HrInitRanges(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg)
{
    HRESULT                 hr = NOERROR;
    IDispatch*              pID=0;
    VARIANT_BOOL            fSuccess;
    IHTMLTxtRange*          pRangeDoc = NULL;
    IHTMLSelectionObject*   pSel = NULL;
    BSTR                    bstr = NULL;
    IMarkupPointer          *pRangeStart = NULL;
    IMarkupPointer          *pRangeEnd = NULL;
    IMarkupPointer          *pRangeTemp = NULL;
    MARKUP_CONTEXT_TYPE     markupContext;
    long                    cch;
    OLECHAR                 chText[64];
    BOOL                    fResult;

    Assert(m_pDoc);

    m_hwndNote = hwndMain;
    m_fShowDoneMsg = !fSuppressDoneMsg;

    m_pRangeIgnore = pRangeIgnore;

    hr = _EnsureInited();
    if (FAILED(hr))
        goto error;

    m_pBodyElem->createTextRange(&pRangeDoc);
    if(!pRangeDoc)
    {
        hr = E_FAIL;
        goto error;
    }

    m_pDoc->get_selection(&pSel);
    if(!pSel)
    {
        hr = E_FAIL;
        goto error;
    }

    pSel->createRange(&pID);
    if(!pID)
    {
        hr = E_FAIL;
        goto error;
    }

    pID->QueryInterface(IID_IHTMLTxtRange, (LPVOID *)&m_pRangeSel);
    if(!m_pRangeSel)
    {
        // if the selection is on an image or something rather than text, it fails.
        // So we just start spellchecking from the beginning.
        pRangeDoc->duplicate(&m_pRangeSel);
        if(!m_pRangeSel)
        {
            hr = E_FAIL;
            goto error;
        }

        hr = m_pRangeSel->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto error;
    }

    Assert(m_pRangeSel);
    m_pRangeSel->duplicate(&m_pRangeSelExpand);
    if(!m_pRangeSelExpand)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = m_pRangeSelExpand->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeSel->get_text(&bstr);
    if(FAILED(hr))
        goto error;

    if(!bstr || lstrlenW(bstr) == 0)
    {
        m_State = SELENDDOCEND;
        hr = m_pRangeSelExpand->collapse(VARIANT_TRUE);
        if(FAILED(hr))
            goto error;
    }
    else
        m_State = SEL;

    // make sure we backup over any abbreviations
    // it would be nice if Trident could do this!
    {
        hr = m_pMarkup->CreateMarkupPointer(&pRangeStart);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->CreateMarkupPointer(&pRangeEnd);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->CreateMarkupPointer(&pRangeTemp);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->MovePointersToRange(m_pRangeSelExpand, pRangeStart, pRangeEnd);
        if (FAILED(hr))
            goto error;

        // first check to see if we have a character to the right or a '.'
        // if not it's not an abbreviation
        {
            hr = pRangeTemp->MoveToPointer(pRangeStart);
            if (FAILED(hr))
                goto error;
            
            while(TRUE)
            {
                cch = 1;
                hr = pRangeTemp->Right(FALSE, &markupContext, NULL, &cch, chText);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_None)
                    goto noAbbreviation;

                if (markupContext == CONTEXT_TYPE_Text)
                {
                    WORD    wType;

                    wType = GetWCharType(chText[0]);
                    if ((C1_SPACE & wType) || ((C1_PUNCT & wType) && chText[0] != L'.'))
                        goto noAbbreviation;
                }

                cch = 1;
                hr = pRangeTemp->Right(TRUE, NULL, NULL, &cch, NULL);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_Text)
                {
                    hr = HrHasWhitespace(pRangeStart, pRangeTemp, &fResult);
                    if (FAILED(hr))
                        goto error;

                    if (fResult)
                        goto noAbbreviation;                
                                                
                    break;
                }
            }
        }

        // now look for a period
        {
processNextWord:
            hr = pRangeEnd->MoveToPointer(pRangeStart);
            if (FAILED(hr))
                goto error;

            hr = pRangeTemp->MoveToPointer(pRangeStart);
            if (FAILED(hr))
                goto error;
            
            while(TRUE)
            {
                cch = 1;
                hr = pRangeTemp->Left(FALSE, &markupContext, NULL, &cch, chText);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_None)
                    goto finishedAbbreviation;

                if (markupContext == CONTEXT_TYPE_Text)
                {
                    WORD    wType;

                    wType = GetWCharType(chText[0]);
                    if ((C1_SPACE & wType) || ((C1_PUNCT & wType) && chText[0] != L'.'))
                        goto finishedAbbreviation;
                }

                cch = 1;
                hr = pRangeTemp->Left(TRUE, NULL, NULL, &cch, NULL);
                if (FAILED(hr))
                    goto error;

                if (markupContext == CONTEXT_TYPE_Text && chText[0] == L'.')
                {
                    hr = pRangeTemp->MoveUnit(MOVEUNIT_PREVWORDBEGIN);
                    if (FAILED(hr))
                        goto finishedAbbreviation;

                    hr = HrHasWhitespace(pRangeTemp, pRangeEnd, &fResult);
                    if (FAILED(hr))
                        goto error;

                    if (fResult)
                        goto finishedAbbreviation;
                                                    
                    pRangeStart->MoveToPointer(pRangeTemp);
                    if (FAILED(hr))
                        goto error;
                        
                    goto processNextWord;
                }
            }
        }

finishedAbbreviation:
        hr = m_pMarkup->MovePointersToRange(m_pRangeSelExpand, pRangeTemp, pRangeEnd);
        if (FAILED(hr))
            goto error;

        // check to see if we had a selection
        // if not be sure to set new selection correctly
        hr = pRangeTemp->IsEqualTo(pRangeEnd, &fResult);
        if (FAILED(hr))
            goto error;

        hr = m_pMarkup->MoveRangeToPointers(pRangeStart, fResult ? pRangeStart : pRangeEnd, m_pRangeSelExpand);
        if (FAILED(hr))
            goto error;
noAbbreviation:
        ;
    }

    m_pBodyElem->createTextRange(&m_pRangeSelEndDocEnd);
    if(!m_pRangeSelEndDocEnd)
    {
        hr = E_FAIL;
        goto error;
    }

    m_pRangeSelEndDocEnd->duplicate(&m_pRangeDocStartSelStart);
    if(!m_pRangeDocStartSelStart)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = m_pRangeSelEndDocEnd->setEndPoint((BSTR)c_bstr_StartToEnd, m_pRangeSelExpand);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeSelEndDocEnd->setEndPoint((BSTR)c_bstr_EndToEnd, pRangeDoc);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeDocStartSelStart->setEndPoint((BSTR)c_bstr_StartToStart, pRangeDoc);
    if(FAILED(hr))
        goto error;

    hr = m_pRangeDocStartSelStart->setEndPoint((BSTR)c_bstr_EndToStart, m_pRangeSelExpand);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pRangeDoc);
    ReleaseObj(pID);
    ReleaseObj(pSel);
    SafeSysFreeString(bstr);
    
    SafeRelease(pRangeStart);
    SafeRelease(pRangeEnd);
    SafeRelease(pRangeTemp);

    return hr;
}


HRESULT CSpell::HrReplaceSel(LPSTR szWord)
{
    HRESULT     hr = NOERROR;
    BSTR        bstrGet=0, bstrPut=0;
    INT         cch;
    TCHAR       szBuf[cchEditBufferMax]={0};
    UINT        uCodePage;
    LPSTR       psz;
    BOOL        fSquiggle=FALSE;
    LONG        cb = 0;

    if(!m_pRangeChecking || szWord==NULL)
        return E_INVALIDARG;


    if (*szWord == 0)
    {
        hr = m_pRangeChecking->moveStart((BSTR)c_bstr_Character, -1, &cb);
        //If we failed to movestart, we just delete the word.
        hr = m_pRangeChecking->put_text(L"");
        goto error;
    }

#ifdef BACKGROUNDSPELL
    if (HrHasSquiggle(m_pRangeChecking)==S_OK)
        fSquiggle = TRUE;
#endif // BACKGROUNDSPELL
    
    hr = m_pRangeChecking->get_text(&bstrGet);
    if(!bstrGet || lstrlenW(bstrGet)==0)
        goto error;

    uCodePage = GetCodePage();

    cch = SysStringLen(bstrGet);
    if (!WideCharToMultiByte(uCodePage, 0, bstrGet, -1, szBuf, sizeof(szBuf), NULL, NULL))
    {
        hr = E_FAIL;
        goto error;
    }

    psz = StrChr(szBuf, ' ');
    if(psz)
    {
        TCHAR szPut[cchEditBufferMax]={0};
        wsprintf(szPut, c_szFmt, szWord, psz);
        hr = HrLPSZToBSTR(szPut, &bstrPut);
    }
    else
        hr = HrLPSZToBSTR(szWord, &bstrPut);

    if (FAILED(hr))
        goto error;

    if (!fSquiggle)
        hr = m_pRangeChecking->put_text(bstrPut);
    else
        hr = m_pRangeChecking->pasteHTML(bstrPut);

    if(FAILED(hr))
        goto error;

error:
    if (SUCCEEDED(hr))
        hr = HrUpdateSelection();

    SysFreeString(bstrGet);
    SysFreeString(bstrPut);
    return hr;
}


HRESULT CSpell::GetSelection(IHTMLTxtRange **ppRange)
{
    IHTMLSelectionObject*   pSel = NULL;
    IHTMLTxtRange           *pTxtRange=0;
    IDispatch               *pID=0;
    HRESULT                 hr=E_FAIL;

    if (ppRange == NULL)
        return TraceResult(E_INVALIDARG);

    *ppRange = NULL;

    if(m_pDoc)
        {
        m_pDoc->get_selection(&pSel);
        if (pSel)
            {
            pSel->createRange(&pID);
            if (pID)
                {
                hr = pID->QueryInterface(IID_IHTMLTxtRange, (LPVOID *)ppRange);
                pID->Release();
                }
            pSel->Release();
            }
        }
    return hr;
}


#ifdef BACKGROUNDSPELL
HRESULT CSpell::HrRegisterKeyPressNotify(BOOL fRegister)
{
    IConnectionPointContainer * pCPContainer=0;
    IConnectionPoint *          pCP=0;
    HRESULT                     hr;

    Assert(m_pDoc)

    hr = m_pDoc->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
    if (FAILED(hr))
        goto error;

    hr = pCPContainer->FindConnectionPoint(DIID_HTMLDocumentEvents, &pCP);
    pCPContainer->Release();
    if (FAILED(hr))
        goto error;

    if (fRegister)
        {
        Assert(0==m_dwCookieNotify);
        hr = pCP->Advise(this, &m_dwCookieNotify);
        if (FAILED(hr))
            goto error;
        }
    else
        {
        if (m_dwCookieNotify)
            {
            hr = pCP->Unadvise(m_dwCookieNotify);
            if (FAILED(hr))
                goto error;
            }
        }
error:
    ReleaseObj(pCP);
    return hr;
}
#endif // BACKGROUNDSPELL


HRESULT CSpell::OnWMCommand(int id, IHTMLTxtRange *pTxtRange)
{
    switch (id)
    {
    case idmSuggest0:
    case idmSuggest1:
    case idmSuggest2:
    case idmSuggest3:
    case idmSuggest4:
        HrReplaceBySuggest(pTxtRange, id-idmSuggest0);
        break;
    case idmIgnore:
    case idmIgnoreAll:
    case idmAdd:
#ifdef BACKGROUNDSPELL
        HrDeleteSquiggle(pTxtRange);
#endif // BACKGROUNDSPELL
        break;
    default:
        return S_FALSE;
    }

    return S_OK;
}


HRESULT CSpell::HrUpdateSelection()
{
    HRESULT         hr;
    VARIANT_BOOL    fSuccess;

    SafeRelease(m_pRangeSel);
    m_pRangeSelEndDocEnd->duplicate(&m_pRangeSel);
    if (!m_pRangeSel)
    {
        hr = E_FAIL;
        goto error;
    }
    hr = m_pRangeSel->setEndPoint((BSTR)c_bstr_EndToStart, m_pRangeSelEndDocEnd);
    if (FAILED(hr))
        goto error;

    hr = m_pRangeSel->setEndPoint((BSTR)c_bstr_StartToEnd, m_pRangeDocStartSelStart);
    if (FAILED(hr))
        goto error;

    SafeRelease(m_pRangeSelExpand);
    m_pRangeSel->duplicate(&m_pRangeSelExpand);
    if(!m_pRangeSelExpand)
    {
        hr = E_FAIL;
        goto error;
    }

    hr = m_pRangeSelExpand->expand((BSTR)c_bstr_Word, &fSuccess);
    if(FAILED(hr))
        goto error;

error:
    return hr;
}


BOOL CSpell::FIgnoreNumber()
{
    return (m_dwOpt & MESPELLOPT_IGNORENUMBER);
}

BOOL CSpell::FIgnoreUpper()
{
    return (m_dwOpt & MESPELLOPT_IGNOREUPPER);
}

BOOL CSpell::FIgnoreDBCS()
{
    return (m_dwOpt & MESPELLOPT_IGNOREDBCS);
}

BOOL CSpell::FIgnoreProtect()
{
    return (m_dwOpt & MESPELLOPT_IGNOREPROTECT);
}

BOOL CSpell::FAlwaysSuggest()
{
    return (m_dwOpt & MESPELLOPT_ALWAYSSUGGEST);
}

BOOL CSpell::FCheckOnSend()
{
    return (m_dwOpt & MESPELLOPT_CHECKONSEND);
}

BOOL CSpell::FIgnoreURL()
{
    return (m_dwOpt & MESPELLOPT_IGNOREURL);
}


UINT CSpell::GetCodePage()
{
    UINT        uCodePage;
    TCHAR       szBuf[cchEditBufferMax]={0};

    if (GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE, szBuf, sizeof(szBuf)))
        uCodePage = StrToInt(szBuf);
    else
        uCodePage = CP_ACP;

    return uCodePage;
}


void DumpRange(IHTMLTxtRange *pRange)
{
#ifdef DEBUG
    BSTR        bstrGet=0;

    if (!pRange)
        return;
    pRange->get_text(&bstrGet);
    SysFreeString(bstrGet);
#endif
}



BOOL FBadSpellChecker(LPSTR rgchBufDigit)
{
    TCHAR       rgchBufKey[cchMaxPathName];
    TCHAR       rgchBuf[cchMaxPathName];
    TCHAR       szMdr[cchMaxPathName];
    LPSTR       pszSpell;

    wsprintf(rgchBufKey, c_szRegSpellKeyDef, rgchBufDigit);

    if (!GetSpellingPaths(rgchBufKey, rgchBuf, szMdr, sizeof(rgchBuf)/sizeof(TCHAR)))
        return TRUE;

    pszSpell = PathFindFileNameA(rgchBuf);
    if (!pszSpell)
        return TRUE;

    if (lstrcmpi(pszSpell, "msspell.dll")==0 ||
        lstrcmpi(pszSpell, "mssp32.dll")==0)
        return TRUE;

    // scotts@directeq.com - check that the dict exists (also check the spell dll
    // for good measure) - 42208

    // spell dll must exist
    if (!PathFileExists(rgchBuf))
        return TRUE;

    // main dict must exist
    if (!PathFileExists(szMdr))
        return TRUE;

    return FALSE;
}


#ifdef BACKGROUNDSPELL
CSpellStack::CSpellStack()
{
    m_cRef = 1;
    m_sp = -1;
    ZeroMemory(&m_rgStack, sizeof(CCell)*MAX_SPELLSTACK);
}


CSpellStack::~CSpellStack()
{
    while (m_sp>=0)
    {
        SafeRelease(m_rgStack[m_sp].pTextRange);
        m_sp--;
    }
}


ULONG CSpellStack::AddRef()
{
    return ++m_cRef;
}


ULONG CSpellStack::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CSpellStack::HrGetRange(IHTMLTxtRange   **ppTxtRange)
{
    HRESULT hr;

    Assert(ppTxtRange);
    *ppTxtRange = 0;
    if (m_sp < 0)
        return E_FAIL;

    *ppTxtRange = m_rgStack[m_sp].pTextRange;
    if (*ppTxtRange)
        (*ppTxtRange)->AddRef();

    return NOERROR;
}


HRESULT CSpellStack::push(IHTMLTxtRange *pTxtRange)
{
    HRESULT hr;
    BSTR    bstr=0;

    Assert(m_sp >= -1 && m_sp <= (MAX_SPELLSTACK-2));

    if (pTxtRange == NULL)
        return E_INVALIDARG;

    hr = pTxtRange->get_text(&bstr);
    if (FAILED(hr) || bstr==NULL || *bstr==L'\0' || *bstr==L' ')
    {
        Assert(0);
        goto error;
    }

    m_sp++;
    m_rgStack[m_sp].pTextRange = pTxtRange;
    pTxtRange->AddRef();

error:
    SafeSysFreeString(bstr);
    return NOERROR;
}


HRESULT CSpellStack::pop()
{
    if (m_sp < 0)
        return NOERROR;

    Assert(m_sp>=0 && m_sp<=(MAX_SPELLSTACK-1));

    SafeRelease(m_rgStack[m_sp].pTextRange);
    m_sp--;

    return NOERROR;
}


BOOL CSpellStack::fEmpty()
{
    Assert(m_sp>=-1 && m_sp<=(MAX_SPELLSTACK-1));

    if (m_sp < 0)
        return TRUE;
    else
        return FALSE;
}
#endif // BACKGROUNDSPELL



WORD GetWCharType(WCHAR wc)
{
    BOOL    fResult;
    WORD    wResult;

    fResult = GetStringTypeExWrapW(CP_ACP, CT_CTYPE1, &wc, 1, &wResult);
    if (FALSE == fResult)
        return 0;
    else
        return wResult;
}

/*******************************************************************

  NAME:       OpenDirectory
  
    SYNOPSIS:   checks for existence of directory, if it doesn't exist
    it is created
    
********************************************************************/
HRESULT OpenDirectory(TCHAR *szDir)
{
    TCHAR *sz, ch;
    HRESULT hr;
    
    Assert(szDir != NULL);
    hr = S_OK;
    
    if (!CreateDirectory(szDir, NULL) && ERROR_ALREADY_EXISTS != GetLastError())
    {
        Assert(szDir[1] == _T(':'));
        Assert(szDir[2] == _T('\\'));
        
        sz = &szDir[3];
        
        while (TRUE)
        {
            while (*sz != 0)
            {
                if (!IsDBCSLeadByte(*sz))
                {
                    if (*sz == _T('\\'))
                        break;
                }
                sz = CharNext(sz);
            }
            ch = *sz;
            *sz = 0;
            if (!CreateDirectory(szDir, NULL))
            {
                if (GetLastError() != ERROR_ALREADY_EXISTS)
                {
                    hr = E_FAIL;
                    *sz = ch;
                    break;
                }
            }
            *sz = ch;
            if (*sz == 0)
                break;
            sz++;
        }
    }
    
    return(hr);
}

HRESULT CSpell::_EnsureInited()
{
    HRESULT     hr=S_OK;

    if (m_pMarkup == NULL)
    {
        hr = m_pDoc->QueryInterface(IID_IMarkupServices, (LPVOID *)&m_pMarkup);
        if (FAILED(hr))
            goto error;
    }
    
    if (m_pBodyElem == NULL)
    {
        hr = HrGetBodyElement(m_pDoc, &m_pBodyElem);
        if (FAILED(hr))
            goto error;
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\saveatt.cpp ===
#include <pch.hxx>
#include "resource.h"
#include "dllmain.h"
#include "saveatt.h"
#include "mimeolep.h"
#include "demand.h"
#include "msoert.h"
#include "util.h"
#include "shlwapi.h"
#include "shlwapip.h"


class CSaveAttachDlg
{
public:
    CSaveAttachDlg();
    ~CSaveAttachDlg();

    ULONG AddRef();
    ULONG Release();

    HRESULT Show(HWND hwndOwner, IMimeMessage *pMsg, LPWSTR rgchPath, ULONG cchPath, BOOL fShowUnsafe);
    static INT_PTR CALLBACK ExtDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;
    HWND            m_hwnd,
                    m_hwndList,
                    m_hwndEdit;
    WCHAR           m_rgchPath[MAX_PATH];
    BOOL            m_fShowUnsafe;

    INT_PTR DlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT OnInitDialog(HWND hwnd);
    HRESULT OnDestroy();
    HRESULT OnWMNotfiy(WPARAM wParam, LPARAM lParam);
    HRESULT OnSave();
    HRESULT SaveAttachment(LPWSTR lpszDir, LPATTACHDATA pAttach);

};


CSaveAttachDlg::CSaveAttachDlg()
{
    m_cRef = 1;
    *m_rgchPath = 0;
    m_hwnd = NULL;
    m_hwndList = NULL;
    m_hwndEdit = NULL;
    m_fShowUnsafe = FALSE;
}

CSaveAttachDlg::~CSaveAttachDlg()
{
}

ULONG CSaveAttachDlg::AddRef()
{
    return ++m_cRef;
}

ULONG CSaveAttachDlg::Release()
{
    m_cRef--;
    if (m_cRef==0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}



HRESULT CSaveAttachDlg::Show(HWND hwndOwner, IMimeMessage *pMsg, LPWSTR lpszPath, ULONG cchPath, BOOL fShowUnsafe)
{
    HRESULT     hr;

    // no need to addref as it's a modal-dialog
    m_pMsg = pMsg;
    m_fShowUnsafe = fShowUnsafe;

    if (!PathFileExistsW(lpszPath) || !PathIsDirectoryW(lpszPath))
        HrGetLastOpenFileDirectoryW(ARRAYSIZE(m_rgchPath), m_rgchPath);
    else
    {
        Assert (cchPath <= MAX_PATH);
        StrCpyNW(m_rgchPath, lpszPath, ARRAYSIZE(m_rgchPath));
    }

    // save attachment DialogBox reutrn hresult
    hr =(HRESULT) DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddSaveAttachments), hwndOwner, ExtDlgProc, (LPARAM)this);

    if (lpszPath)
        StrCpyNW(lpszPath, m_rgchPath, cchPath);

    return hr;
}


HRESULT CSaveAttachDlg::OnSave()
{
    HWND            hwndEdit;
    LV_ITEMW        lvi;
    int             cItems,
                    i;
    LPATTACHDATA    pAttach;
    WCHAR           wszDir[MAX_PATH+1],
                    wszErr[MAX_PATH + CCHMAX_STRINGRES],
                    wszFmt[CCHMAX_STRINGRES];
    HCURSOR         hcur;
    HRESULT         hr = S_OK;
    BOOL            fFailures=FALSE;

    wszDir[MAX_PATH] = 0;

    hwndEdit = GetDlgItem(m_hwnd, idcPathEdit);
    AssertSz(hwndEdit, "Should have gotten an hwndEdit");

    GetWindowTextWrapW(hwndEdit, wszDir, MAX_PATH);

    if (!PathIsDirectoryW(wszDir))
    {
        LoadStringWrapW(g_hLocRes, idsErrFolderInvalid, wszFmt, ARRAYSIZE(wszFmt));
        AthwsprintfW(wszErr, ARRAYSIZE(wszErr), wszFmt, wszDir);
        AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSaveAttachments), wszErr, NULL, MB_OK|MB_ICONEXCLAMATION);
        return E_FAIL;
    }
    
    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    cItems = ListView_GetItemCount(m_hwndList);

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_STATE|LVIF_PARAM;
    lvi.stateMask = LVIS_SELECTED;
    for (i = 0; i < cItems; i++)
    {
        lvi.iItem = i;
        SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi));
        if (lvi.state & LVIS_SELECTED)
        {
            pAttach = (LPATTACHDATA)lvi.lParam;
            hr = SaveAttachment(wszDir, pAttach);
            if (hr == MIMEEDIT_E_USERCANCEL)
                break;
            if (FAILED(hr))
                fFailures=TRUE;     // flag error, but keep trying
        }
    }
    
    if (hcur)
        SetCursor(hcur);

    if (fFailures)
        AthMessageBoxW(m_hwnd,  MAKEINTRESOURCEW(idsSaveAttachments), MAKEINTRESOURCEW(idsErrOneOrMoreAttachSaveFailed), NULL, MB_OK|MB_ICONEXCLAMATION);

    StrCpyNW(m_rgchPath, wszDir, MAX_PATH);
    return hr;
}


HRESULT CSaveAttachDlg::SaveAttachment(LPWSTR lpszDir, LPATTACHDATA pAttach)
{
    HRESULT     hr = S_OK;
    WCHAR       wszRes[CCHMAX_STRINGRES],
                wsz[MAX_PATH + CCHMAX_STRINGRES],
                wszPath[MAX_PATH];
    int         id;

    *wszRes = 0;

    Assert (pAttach);

    StrCpyW(wszPath, lpszDir);
    PathAppendW(wszPath, pAttach->szFileName);
    
    if (PathFileExistsW(wszPath))
    {
        LoadStringWrapW(g_hLocRes, idsFileExistWarning, wszRes, ARRAYSIZE(wszRes));
        AthwsprintfW(wsz, ARRAYSIZE(wsz), wszRes, wszPath);
        
        // the file exists, warn the dude
        id = AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSaveAttachments), wsz,  NULL, MB_YESNOCANCEL|MB_DEFBUTTON2|MB_ICONEXCLAMATION);
        if (id == IDCANCEL)
            return MIMEEDIT_E_USERCANCEL;
        else
            if (id == IDNO)
                return S_OK;
    }
    
    return HrSaveAttachToFile(m_pMsg, pAttach->hAttach, wszPath);
}


HRESULT CSaveAttachDlg::OnInitDialog(HWND hwnd)
{
    ULONG           uAttach,
                    cAttach;
    HBODY           *rghAttach;
    LPATTACHDATA    pAttach;
    LV_ITEMW        lvi;
    LV_COLUMNW      lvc;
    HIMAGELIST      hImageList;
    RECT            rc;

    m_hwnd = hwnd;
    CenterDialog(hwnd);
    
    // Set up edit box with passed in Directory
    m_hwndEdit = GetDlgItem(hwnd, idcPathEdit);
    if (!m_hwndEdit)
        return E_FAIL;

    if (m_rgchPath)
        SendMessageWrapW(m_hwndEdit, WM_SETTEXT, 0, (LPARAM)m_rgchPath);
    else
    {
        WCHAR szDir[MAX_PATH];
        HrGetLastOpenFileDirectoryW(ARRAYSIZE(szDir), szDir);
        SendMessageWrapW(m_hwndEdit, WM_SETTEXT, 0, LPARAM(szDir));
    }
    
    m_hwndList = GetDlgItem(hwnd, idcAttachList);
    AssertSz(m_hwndList, "Should have gotten an hwndList");
    
    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_TEXT | LVCF_WIDTH;
    lvc.cx = 0;
    ListView_InsertColumn(m_hwndList, 0, &lvc);
    
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    
    Assert (m_pMsg);
    if (m_pMsg->GetAttachments(&cAttach, &rghAttach)==S_OK)
    {
        hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), FALSE, cAttach, 0);
        ListView_SetImageList(m_hwndList, hImageList, LVSIL_SMALL);
        
        for (uAttach=0; uAttach<cAttach; uAttach++)
        {
            if (HrAttachDataFromBodyPart(m_pMsg, rghAttach[uAttach], &pAttach)==S_OK)
            {
                if (!m_fShowUnsafe && pAttach && !pAttach->fSafe)
                    continue;

                lvi.pszText = pAttach->szDisplay;
                lvi.iImage = ImageList_AddIcon(hImageList, pAttach->hIcon);
                lvi.lParam = (LPARAM)pAttach;
                if (SendMessage(m_hwndList, LVM_INSERTITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)) == -1)
                {
                    // try and keep crusing
                    HrFreeAttachData(pAttach);
                    pAttach=NULL;
                }
            }
        }
        SafeMemFree(rghAttach);
    }
    
    GetClientRect(m_hwndList, &rc);
    ListView_SetColumnWidth(m_hwndList, 0, rc.right);
    ListView_SetExtendedListViewStyle(m_hwndList, LVS_EX_FULLROWSELECT);
    ListView_SelectAll(m_hwndList);
    SetFocus(m_hwndList);
    return S_OK;
}

HRESULT CSaveAttachDlg::OnDestroy()
{
    ULONG       cItems;
    LV_ITEMW    lvi;

    // walk the listview and free up the LPATTACHDATA hanging off each element

    if (m_hwndList && 
        (cItems = ListView_GetItemCount(m_hwndList)))
    {
        ZeroMemory(&lvi, sizeof(lvi));
        lvi.mask = LVIF_PARAM;
        for (lvi.iItem=0; lvi.iItem < (int)cItems; lvi.iItem++)
        {
            if (SendMessage(m_hwndList, LVM_GETITEMW, 0, (LPARAM)(LV_ITEMW*)(&lvi)))
                HrFreeAttachData((LPATTACHDATA)lvi.lParam);
        }
    }
    return S_OK;
}

HRESULT CSaveAttachDlg::OnWMNotfiy(WPARAM wParam, LPARAM lParam)
{
    NM_LISTVIEW    *pnmlv;
    LPNMHDR         pnmh = NULL;
    UINT            uiCode;
    
    if (idcAttachList == wParam)
    {
        pnmh = LPNMHDR(lParam);
        if (LVN_ITEMCHANGED == pnmh->code)
        {
            pnmlv = (NM_LISTVIEW *)pnmh;
            
            // Only do next section if changing selected states
            if ((!!(pnmlv->uOldState & LVIS_SELECTED) != (!!(pnmlv->uNewState & LVIS_SELECTED))))
            {
                // enable button is >0 items selected
                EnableWindow(GetDlgItem(m_hwnd, IDOK), ListView_GetSelectedCount(m_hwndList));
            }
        }
    }
    else if (idcPathEdit == wParam)
    {
        pnmh = LPNMHDR(lParam);
        if (NM_SETFOCUS == pnmh->code)
            SendMessage(m_hwndEdit, EM_SETSEL, 0, -1);
    }
    
    return S_FALSE;
}



INT_PTR CALLBACK CSaveAttachDlg::ExtDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CSaveAttachDlg *pDlg = (CSaveAttachDlg *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pDlg = (CSaveAttachDlg *)lParam;
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
    }

    return pDlg?pDlg->DlgProc(hwndDlg, uMsg, wParam, lParam):FALSE;
}


INT_PTR CSaveAttachDlg::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            if (SUCCEEDED(OnInitDialog(hwndDlg)))
                SHAutoComplete(m_hwndEdit, 0);
            return FALSE;
        }
        
        case WM_DESTROY:
            OnDestroy();
            break;
        
        case WM_NOTIFY:
            OnWMNotfiy(wParam, lParam);
            return 0;
        
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case idcSelectAllAttBtn:
                    ListView_SelectAll(m_hwndList);
                    SetFocus(m_hwndList);
                    return TRUE;
            
                case idcBrowseBtn:
                {
                    WCHAR   wszDir[MAX_PATH];
                    HWND    hwndEdit = GetDlgItem(hwndDlg, idcPathEdit); 
                    
                    GetWindowTextWrapW(hwndEdit, wszDir, ARRAYSIZE(wszDir));
                    if (BrowseForFolderW(g_hLocRes, hwndDlg, wszDir, MAX_PATH, idsPickAtachDir, FALSE))
                        SetWindowTextWrapW(hwndEdit, wszDir);
                    return TRUE;
                }
            
                case IDOK:
                    if (SUCCEEDED(OnSave()))
                        EndDialog(hwndDlg, S_OK);
                    return TRUE;
            
                case IDCANCEL:
                    EndDialog(hwndDlg, MIMEEDIT_E_USERCANCEL);
                    return TRUE;
            }
            break;             
        }
    }
    
    return FALSE;
}


HRESULT HrSaveAttachments(HWND hwnd, IMimeMessage *pMsg, LPWSTR lpszPath, ULONG cchPath, BOOL fShowUnsafe)
{
    CSaveAttachDlg *pDlg;
    HRESULT         hr;

    if (pMsg==NULL)
        return E_INVALIDARG;

    pDlg = new CSaveAttachDlg();
    if (!pDlg)
        return E_OUTOFMEMORY;

    hr = pDlg->Show(hwnd, pMsg, lpszPath, cchPath, fShowUnsafe);

    pDlg->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\spell.h ===
/*
 *  spell.h
 *
 *  Declarations for spelling
 *
 *  Owner:
 *  		v-brakol
 *			bradk@directeq.com
 */

/*
 *  Capone Specific Definitions for the spelling subsystem
 */
#ifndef _SPELL_H
#define _SPELL_H

#include "proofbse.h"
#include "spellapi.h"

#define cchMaxPathName      MAX_PATH
#define cchMaxSuggestBuff   (2048)
#ifdef BACKGROUNDSPELL
#define MAX_SPELLSTACK      (1024)
#endif // BACKGROUNDSPELL
#define sobitStdOptions     (sobitFindRepeatWord)
#define cchMaxDicts			64

class CBody;

// Size of current edit block.  Leave this a small value for the DEBUG
// version to help track down bugs with inter-buffer processing.
#ifdef DEBUG
#define cchEditBufferMax    512
#else
#define cchEditBufferMax    512
#endif

#define chCRSpell           0x0D
#define chLFSpell           0x0A
#define chHyphen            0x2D


// Scode sources
#define FACILITY_MAIL           (0x0100)
#define FACILITY_MAPI           (0x0200)
#define FACILITY_WIN            (0x0300)
#define FACILITY_MASK           (0x0700)

#define MAKE_MAIL_S_SCODE(_str) \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_MAIL, (_str))
#define MAKE_MAIL_E_SCODE(_str) \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str))
#define MAKE_MAIL_X_SCODE(_str) \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str) | CRITICAL_FLAG)

#define MAIL_E_SPELLGENERICSPELL    MAKE_MAIL_E_SCODE(idsErrSpellGenericSpell)
#define MAIL_E_SPELLGENERICLOAD     MAKE_MAIL_E_SCODE(idsErrSpellGenericLoad)
#define MAIL_E_SPELLMAINDICTLOAD    MAKE_MAIL_E_SCODE(idsErrSpellMainDictLoad)
#define MAIL_E_SPELLVERSION         MAKE_MAIL_E_SCODE(idsErrSpellVersion)
#define MAIL_E_SPELLUSERDICT        MAKE_MAIL_E_SCODE(idsErrSpellUserDict)
#define MAIL_E_SPELLUSERDICTLOAD    MAKE_MAIL_E_SCODE(idsErrSpellUserDictLoad)
#define MAIL_E_SPELLUSERDICTOPENRO  MAKE_MAIL_E_SCODE(idsErrSpellUserDictOpenRO)
#define MAIL_E_SPELLUSERDICTSAVE    MAKE_MAIL_E_SCODE(idsErrSpellUserDictSave)
#define MAIL_E_SPELLUSERDICTWORDLEN MAKE_MAIL_E_SCODE(idsErrSpellUserDictWordLen)
#define MAIL_E_SPELLCACHEWORDLEN    MAKE_MAIL_E_SCODE(idsErrSpellCacheWordLen)
#define MAIL_E_SPELLEDIT            MAKE_MAIL_E_SCODE(idsErrSpellEdit)

// the order is important
enum
{
    SEL,
    SELENDDOCEND,
    DOCSTARTSELSTART,
    STATEMAX
};

/*
 *  CSApi Function typedefs.  Note these are *not* Unicode enabled.  Thus need to use
 *  LPSTR and not LPTSTR.
 */

#ifdef BACKGROUNDSPELL
struct CCell
{
    IHTMLTxtRange   *pTextRange;
    ULONG           cb;
};

class CSpellStack
{
public:
    CSpellStack();
    ~CSpellStack();
    ULONG   AddRef();
    ULONG   Release();

    HRESULT HrGetRange(IHTMLTxtRange   **ppTxtRange);
    BOOL    fEmpty();
    HRESULT push(IHTMLTxtRange   *pTxtRange);
    HRESULT pop();

private:
    ULONG   m_cRef;
    int     m_sp; // stack pointer.
    CCell   m_rgStack[MAX_SPELLSTACK];
};
#endif // BACKGROUNDSPELL

class CSpell :
#ifdef BACKGROUNDSPELL
    public IDispatch
#else
	public IUnknown
#endif // BACKGROUNDSPELL
{
public:
    CSpell(IHTMLDocument2* pDoc, IOleCommandTarget* pParentCmdTarget, DWORD dwSpellOpt);
    ~CSpell();

    // IUnknown methods
    ULONG   STDMETHODCALLTYPE AddRef();
    ULONG   STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    // IDispatch methods
#ifdef BACKGROUNDSPELL
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);
#endif // BACKGROUNDSPELL
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
    STDMETHODIMP GetTypeInfoCount(UINT *pctinfo);

	HRESULT HrSpellReset();
    HRESULT HrSpellChecking(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg);


    HRESULT OnWMCommand(int id, IHTMLTxtRange *pTxtRange);
#ifdef BACKGROUNDSPELL
    HRESULT HrHasSquiggle(IHTMLTxtRange *pTxtRange);
#endif // BACKGROUNDSPELL
    HRESULT HrInitRanges(IHTMLTxtRange *pRangeIgnore, HWND hwndMain, BOOL fSuppressDoneMsg);
    VOID    DeInitRanges();

    BOOL    OpenSpeller();
    VOID    CloseSpeller();

	BOOL	OpenUserDictionaries();
    BOOL	OpenUserDictionary(LPTSTR lpszDict);

    HRESULT HrFindErrors();
    HRESULT HrReplaceErrorText(BOOL fChangeAll, BOOL fAddToUdr);
    HRESULT HrSpellSuggest();
    VOID    FillSuggestLbx();
    BOOL    FVerifyThisText(LPSTR szThisText, BOOL fProcessOnly);
    VOID    SpellSaveUndo(INT idButton);
    VOID    SpellDoUndo();
#ifdef BACKGROUNDSPELL
    HRESULT HrBkgrndSpellTimer();
    HRESULT HrBkgrndSpellCheck(IHTMLTxtRange *pTxtRange);
    HRESULT HrSetSquiggle(IHTMLTxtRange *pTxtRange);
    HRESULT HrDeleteSquiggle(IHTMLTxtRange *pTxtRange);
#endif // BACKGROUNDSPELL
    HRESULT HrInsertMenu(HMENU hmenu, IHTMLTxtRange *pTxtRange);
    HRESULT HrReplaceBySuggest(IHTMLTxtRange *pTxtRange, INT index);
#ifdef BACKGROUNDSPELL
    HRESULT HrRegisterKeyPressNotify(BOOL fRegister);
#endif // BACKGROUNDSPELL
    HRESULT AddToUdrW(WCHAR* pwsz, PROOFLEX lex);	// scotts@directeq.com - can now specify dict index - 53193
    HRESULT AddToUdrA(CHAR* psz, PROOFLEX lex);		// scotts@directeq.com - can now specify dict index - 53193
    HRESULT HrCheckWord(LPCSTR pszWord);

    BOOL        m_fSpellSelection: 1,
                m_fUdrReadOnly:    1,
                m_fSuggestions:    1,
                m_fNoneSuggested:  1,
                m_fAlwaysSuggest:  1,
                m_fEditWasEmpty:   1,
                m_fRepeat:         1,
                m_fCanUndo:        1,
                m_fUndoChange:     1,
                m_fShowDoneMsg:    1,
                m_fIgnoreScope:    1,
                m_fSpellContinue:  1,	// scotts@directeq.com - "repeat word" bug fix - 2757, 13573, 56057
                m_junk:            3,
                m_fCSAPI3T1:       1;
                
    HWND        m_hwndDlg;                // the spelling dialog using thie SPELLFO structure
    
    TCHAR       m_szWrongWord[cchEditBufferMax];            // current misspelled word
    TCHAR       m_szEdited[cchEditBufferMax];               // current replacement word

	WCHAR		m_wszIn[cchEditBufferMax];
    WCHAR       m_wszRet[cchEditBufferMax];

    PROOFID             m_pid;
    WSIB                m_wsib;
    WSRB                m_wsrb;

	LANGID				m_langid;

    DWORD				m_clex;
    PROOFLEX            m_rgprflex[cchMaxDicts];

    PROOFVERSION        m_pfnSpellerVersion;
    PROOFINIT           m_pfnSpellerInit;
    PROOFTERMINATE      m_pfnSpellerTerminate;
    PROOFSETOPTIONS     m_pfnSpellerSetOptions;
    PROOFOPENLEX        m_pfnSpellerOpenLex;
    PROOFCLOSELEX       m_pfnSpellerCloseLex;
    SPELLERCHECK        m_pfnSpellerCheck;
    SPELLERADDUDR       m_pfnSpellerAddUdr;
    SPELLERBUILTINUDR   m_pfnSpellerBuiltInUdr;
    SPELLERADDCHANGEUDR m_pfnSpellerAddChangeUdr;
    PROOFSETDLLNAME     m_pfnSpellerSetDllName;

    CHARRANGE           m_chrgCurrent;            // current selection in edit control
    TCHAR               m_szErrType[256];         // string describing type of spelling error
    TCHAR               m_szTempBuffer[256];      // temporary buffer used for LoadString()
    TCHAR               m_szSuggest[cchMaxSuggestBuff];
    IHTMLTxtRange*      m_pRangeChecking;// text range currently checked
    IHTMLTxtRange*      m_pRangeIgnore;// ignore text

private:
    ULONG               m_cRef;
    INT                 m_State;
    IHTMLTxtRange*      m_pRangeDocStartSelStart;//from document start to selection start.
    IHTMLTxtRange*      m_pRangeSel; //from selection start to selection end
    IHTMLTxtRange*      m_pRangeSelExpand; //from selection start to selection end
    IHTMLTxtRange*      m_pRangeSelEndDocEnd;// from selection end to document end
    IHTMLTxtRange*      m_pRangeUndoSave;// from selection end to document end
#ifdef BACKGROUNDSPELL
    CSpellStack         m_Stack;
#endif // BACKGROUNDSPELL
    IHTMLDocument2*     m_pDoc;
    IOleCommandTarget*	m_pParentCmdTarget;

    HINSTANCE   		m_hinstDll;               // spell dll
    HWND       			m_hwndNote;               // body edit field
    LONG        		m_soCur;                  // current spelling options.
    HRESULT     		m_hr;
    DWORD       		m_dwOpt;
    DWORD       		m_dwCookieNotify;

	IMarkupServices*	m_pMarkup;
	IHTMLBodyElement*	m_pBodyElem;

    HRESULT HrGetSel();
    HRESULT HrReplaceSel(LPTSTR szWord);
    HRESULT HrProcessSpellErrors();
    VOID    CleanupState();
    HRESULT HrCheckRange(IHTMLTxtRange* pRange);
    BOOL    FIgnore(IHTMLTxtRange* pRangeChecking);
    BOOL    FIgnoreNumber();
    BOOL    FIgnoreUpper();
    BOOL    FIgnoreDBCS();
    BOOL    FIgnoreProtect();
    BOOL    FAlwaysSuggest();
    BOOL    FCheckOnSend();
    BOOL    FIgnoreURL();
    HRESULT HrGetNextWordRange(IHTMLTxtRange* pRange);
    HRESULT HrGetText(IHTMLTxtRange* pRange, LPSTR *ppszText);
    HRESULT	HrGetText(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, LPSTR *ppszText);
    HRESULT	HrStripTrailingPeriod(IHTMLTxtRange* pRange, BOOL* pfResult);
    HRESULT HrHasWhitespace(IMarkupPointer* pRangeStart, IMarkupPointer* pRangeEnd, BOOL *pfResult);
    HRESULT HrUpdateSelection();
    HRESULT GetSelection(IHTMLTxtRange **ppRange);
    HRESULT HrGetSpaces(LPSTR pszText, INT* pnSpaces);
    BOOL    LoadOldSpeller();
    BOOL    LoadNewSpeller();
    BOOL    GetNewSpellerEngine(LANGID, TCHAR*, DWORD, TCHAR*, DWORD);
    UINT    GetCodePage();
    HRESULT _EnsureInited();
};


INT_PTR CALLBACK SpellingDlgProc(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam);
BOOL    SpellingOnCommand(HWND hwndDlg, UINT wMsg, WPARAM wparam, LPARAM lparam);
VOID    UpdateEditedFromSuggest(HWND, HWND, HWND);

BOOL  FCheckSpellAvail(IOleCommandTarget* pParentCmdTarget);

#endif  // _SPELL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\tags.h ===
/*
 *    t a g s . h
 *    
 *    Purpose:
 *        tag packer abstractions
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */



HRESULT CreateOEImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages);
HRESULT CreateBGImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages);
HRESULT CreateBGSoundCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags);
HRESULT CreateActiveMovieCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\tags.cpp ===
/*
 *    t a g s . c p p
 *    
 *    Purpose:
 *        tag packer abstractions
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "strconst.h"
#include "htmlstr.h"
#include "triutil.h"
#include "oleutil.h"
#include "mhtml.h"
#include "basemht.h"
#include "tags.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  p r o t o t y p e s
 */
HRESULT CreateOEImageTag(IHTMLElement *pElem, IMimeEditTag **ppTag);
HRESULT CreateBGImageTag(IHTMLDocument2 *pDoc, IUnknown *pUnk, DWORD dwType, IMimeEditTag **ppTag);
HRESULT CreateBGSoundTag(IHTMLElement *pElem, IMimeEditTag **ppTag);
HRESULT CreateActiveMovieTag(IUnknown *pUnk, IMimeEditTag **ppTag);

/*
 *  c o n s t a n t s
 */

enum
{
    BGIMAGE_BODYBACKGROUND = 0,
    BGIMAGE_BODYSTYLE,
    BGIMAGE_STYLESHEET,
    BGIMAGE_MAX
};

/*
 *  t y p e d e f s
 */

 
class COEImage :
    public CBaseTag
{
public:

    COEImage();
    virtual ~COEImage();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLElement *pElem);
};

 
class COEImageCollection :
    public CBaseTagCollection
{
public:

    COEImageCollection();
    virtual ~COEImageCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


class CBGImage :
    public CBaseTag
{
public:

    CBGImage();
    virtual ~CBGImage();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLDocument2 *pDoc, IHTMLElement *pElem, DWORD dwType);

private:
    DWORD   m_dwType;
    IHTMLBodyElement        *m_pBody;           // set depending on type
    IHTMLStyle              *m_pStyle;          // set depending on type
    IHTMLRuleStyle          *m_pRuleStyle;      // set depending on type

protected:
    // override CBaseTagCollection
    virtual HRESULT STDMETHODCALLTYPE SetSrc(BSTR bstrSrc);
};

 
class CBGImageCollection :
    public CBaseTagCollection
{
public:

    CBGImageCollection();
    virtual ~CBGImageCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


class CBGSound:
    public CBaseTag
{
public:

    CBGSound();
    virtual ~CBGSound();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLElement *pElem);
};

 
class CBGSoundCollection :
    public CBaseTagCollection
{
public:

    CBGSoundCollection();
    virtual ~CBGSoundCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


class CActiveMovie:
    public CBaseTag
{
public:

    CActiveMovie();
    virtual ~CActiveMovie();

    HRESULT STDMETHODCALLTYPE OnPreSave();
    HRESULT STDMETHODCALLTYPE OnPostSave();

    HRESULT STDMETHODCALLTYPE CanPackage();
    HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);
    
    HRESULT Init(IHTMLElement *pElem);


private:
    IDispatch   *m_pDisp;
    DISPID      m_dispidSrc;

    HRESULT _GetSrc(BSTR *pbstr);
    HRESULT _EnsureDispID();

protected:
    virtual HRESULT STDMETHODCALLTYPE SetSrc(BSTR bstr);

};

 
class CActiveMovieCollection :
    public CBaseTagCollection
{
public:

    CActiveMovieCollection();
    virtual ~CActiveMovieCollection();

protected:
    // override CBaseTagCollection
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc);
};


/* 
 *   F u n c t i o n s
 */


COEImage::COEImage()
{
}


COEImage::~COEImage()
{
}

HRESULT COEImage::Init(IHTMLElement *pElem)
{
    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    HrGetMember(pElem, (BSTR)c_bstr_SRC, VARIANT_FALSE, &m_bstrSrc);
    return CBaseTag::Init(pElem);
}

HRESULT COEImage::OnPreSave()
{
    // set the destination if there is one
    if (m_bstrDest)
        HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrDest);

    return S_OK;
}

HRESULT COEImage::OnPostSave()
{
    // OnPostSave the original SRC attribute
    HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrSrc);
    return S_OK;
}


HRESULT COEImage::CanPackage()
{
    IHTMLImgElement     *pImg;
    BSTR                bstr=NULL;
    HRESULT             hr=S_OK;

    // for an image, make sure that the ready-state has hit 'complete'. If not then the bits
    // have not been fully downloaded
    if (m_pElem && 
        m_pElem->QueryInterface(IID_IHTMLImgElement, (LPVOID *)&pImg)==S_OK)
    {
        pImg->get_readyState(&bstr);   // don't forget trident returns S_OK with bstr==NULL!
        if (bstr)
        {
            if (StrCmpIW(bstr, L"complete")!=0)
                hr = INET_E_DOWNLOAD_FAILURE;
            SysFreeString(bstr);
        }
        pImg->Release();
    }
    return hr;
}

HRESULT COEImage::IsValidMimeType(LPWSTR pszTypeW)
{
    if (pszTypeW &&
        StrCmpNIW(pszTypeW, L"image/", 6)==0)
        return S_OK;
    else
        return S_FALSE;
}

    
    
    
COEImageCollection::COEImageCollection()
{
}


COEImageCollection::~COEImageCollection()
{
}

HRESULT COEImageCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLElementCollection  *pCollect=0;
    IHTMLElement            *pElem;
    ULONG                   uImage;
    HRESULT                 hr;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    hr = HrGetCollectionOf(pDoc, (BSTR)c_bstr_IMG, &pCollect);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    m_cTags = UlGetCollectionCount(pCollect);
    if (m_cTags)
    {
        // allocate an array of COEImage objects
        if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * m_cTags))
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }
        
        ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * m_cTags);

        for (uImage=0; uImage<m_cTags; uImage++)
        {
            if (HrGetCollectionItem(pCollect, uImage, IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
            {
                hr = CreateOEImageTag(pElem, &m_rgpTags[uImage]);
                if (FAILED(hr))
                {
                    pElem->Release();
                    goto error;
                }
                pElem->Release();
            }
        }
    }

error:
    ReleaseObj(pCollect);
    return hr;
}


HRESULT CreateOEImageTag(IHTMLElement *pElem, IMimeEditTag **ppTag)
{
    COEImage    *pImage=0;
    HRESULT     hr;

    if (ppTag == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    // create image
    pImage = new COEImage();
    if (!pImage)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init image with element
    hr = pImage->Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pImage;
    pImage = NULL;

error:
    ReleaseObj(pImage);
    return hr;
}



HRESULT CreateOEImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages)
{
    COEImageCollection *pImages=0;
    HRESULT             hr;

    if (ppImages == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppImages = NULL;

    // create collection
    pImages = new COEImageCollection();
    if (!pImages)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pImages->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppImages = pImages;
    pImages = NULL;

error:
    ReleaseObj(pImages);
    return hr;
}
















CBGImage::CBGImage()
{
    m_dwType = BGIMAGE_BODYBACKGROUND;
    m_pBody = NULL;
    m_pStyle = NULL;
    m_pRuleStyle = NULL;
}


CBGImage::~CBGImage()
{
    SafeRelease(m_pBody);
    SafeRelease(m_pStyle);
    SafeRelease(m_pRuleStyle);
}

HRESULT CBGImage::Init(IHTMLDocument2 *pDoc, IHTMLElement *pElem, DWORD dwType)
{
    BSTR        bstr=NULL,
                bstrSrc=NULL,
                bstrBase=NULL;
    ULONG       cch=0;
    HRESULT     hr;

    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    // tells us what the ITHMLElement actually is (BODY tag or STYLE)
    m_dwType = dwType;

    switch (dwType)
    {
        case BGIMAGE_BODYBACKGROUND:
            if (pElem->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)&m_pBody)==S_OK)
                m_pBody->get_background(&bstrSrc);
            break;
        
        case BGIMAGE_BODYSTYLE:
            pElem->get_style(&m_pStyle);
            if (m_pStyle)
            {
                m_pStyle->get_backgroundImage(&bstr);
                UnWrapStyleSheetUrl(bstr, &bstrSrc);
                SysFreeString(bstr);
            }
            break;

        case BGIMAGE_STYLESHEET:
            if (FindStyleRule(pDoc, L"BODY", &m_pRuleStyle)==S_OK)
            {
                m_pRuleStyle->get_backgroundImage(&bstr);
                UnWrapStyleSheetUrl(bstr, &bstrSrc);
                SysFreeString(bstr);
            }
            break;
        
        default:
            AssertSz(0, "BadType");
    }

    // trident's OM doesn't combine body backgound URLs with the nearest base tag
    // so we have to do this ourselves for background images
    if (bstrSrc &&
        FindNearestBaseUrl(pDoc, pElem, &bstrBase)==S_OK)
    {
        // see how many bytes are required
        UrlCombineW(bstrBase, bstrSrc, NULL, &cch, 0);
        if (cch)
        {
            // allocate the 'combined' string
            bstr = SysAllocStringLen(NULL, cch);
            if (bstr)
            {
                // do the actual combine into the new buffer
                if (!FAILED(UrlCombineW(bstrBase, bstrSrc, bstr, &cch, URL_UNESCAPE)))
                {
                    // use the new 'combined' url instead
                    SysFreeString(bstrSrc);
                    bstrSrc = bstr;
                }
                else
                    SysFreeString(bstr);
            }
        }
        SysFreeString(bstrBase);
    }
    
    // init failed if we get here and have no SRC url
    if (bstrSrc == NULL)
        return TraceResult(E_FAIL);

    m_bstrSrc = bstrSrc;
    bstrSrc = NULL;

    hr = CBaseTag::Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

error:
    SysFreeString(bstrSrc);
    return hr;
}

HRESULT CBGImage::SetSrc(BSTR bstrSrc)
{
    BSTR                    bstr=NULL;

    switch (m_dwType)
    {
        case BGIMAGE_BODYBACKGROUND:
            if (m_pBody)
                m_pBody->put_background(bstrSrc);
            break;
        
        case BGIMAGE_BODYSTYLE:
            if (m_pStyle && 
                WrapStyleSheetUrl(bstrSrc, &bstr)==S_OK)
            {
                m_pStyle->put_backgroundImage(bstr);
                SysFreeString(bstr);
            }
            break;

        case BGIMAGE_STYLESHEET:
            if (m_pRuleStyle && 
                WrapStyleSheetUrl(bstrSrc, &bstr)==S_OK)
            {
                m_pRuleStyle->put_backgroundImage(bstr);
                SysFreeString(bstr);
            }
            break;
        
        default:
            AssertSz(0, "BadType");
    }
    return S_OK;
}

HRESULT CBGImage::OnPreSave()
{
    if (m_bstrDest)
        SetSrc(m_bstrDest);
    return S_OK;
}

HRESULT CBGImage::OnPostSave()
{
    SetSrc(m_bstrSrc);
    return S_OK;
}


HRESULT CBGImage::CanPackage()
{
    return S_OK;
}

HRESULT CBGImage::IsValidMimeType(LPWSTR pszTypeW)
{
    if (pszTypeW &&
        StrCmpNIW(pszTypeW, L"image/", 6)==0)
        return S_OK;
    else
        return S_FALSE;
}

    
    
    
CBGImageCollection::CBGImageCollection()
{
}


CBGImageCollection::~CBGImageCollection()
{
}

HRESULT CBGImageCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLBodyElement        *pBody=NULL;
    IHTMLElement            *pElem;
    IHTMLStyle              *pStyle=NULL;
    IHTMLRuleStyle          *pRuleStyle;
    BSTR                    bstr=NULL;
    HRESULT                 hr;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    /* *
       * there are 3 ways to get a background image:
       *  (in order of precedence that trident renders them)
       * 1. <BODY style="background:">
       * 2. <STYLE> background-image: </STYLE>
       * 3. <BODY background=>
       */

    // allocate an array of at most BGIMAGE_MAX CBGImage objects, we might not use them all
    if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * BGIMAGE_MAX))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }
        
    ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * m_cTags);

    hr = HrGetBodyElement(pDoc, &pBody);
    if (FAILED(hr))
    {
        // this can fail if we are on a page with no BODY tag, eg. a FRAMESET page
        // if there is no body, then we assume there are no BGIMAGES and bail with 0
        // elements in the collection
        hr = S_OK;
        goto error;
    }

    // try <BODY STYLE="background-image:">
    if (pBody->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
    {
        pElem->get_style(&pStyle);
        if (pStyle)
        {
            pStyle->get_backgroundImage(&bstr);
            if (bstr) 
            {
                if (*bstr && StrCmpIW(bstr, L"none")!=0)  // might be "" or "none" - both empty in trident language
                {
                    hr = CreateBGImageTag(pDoc, pBody, BGIMAGE_BODYSTYLE, &m_rgpTags[m_cTags]);
                    if (!FAILED(hr))
                        m_cTags++;
                }
                SysFreeString(bstr);
                bstr = NULL;
            }
            pStyle->Release();
        }
        pElem->Release();
    }

    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // try the <STYLE> tag
    if (FindStyleRule(pDoc, L"BODY", &pRuleStyle)==S_OK)
    {
        pRuleStyle->get_backgroundImage(&bstr);
        if (bstr) 
        {
            if (*bstr && StrCmpIW(bstr, L"none")!=0)  // might be "" or "none" - both empty in trident language
            {
                hr = CreateBGImageTag(pDoc, pBody, BGIMAGE_STYLESHEET, &m_rgpTags[m_cTags]);
                if (!FAILED(hr))
                    m_cTags++;
            }
            SysFreeString(bstr);
        }
        pRuleStyle->Release();
    }

    // try <BODY background=>
    pBody->get_background(&bstr);
    if (bstr) 
    {
        if (*bstr)  // might be ""
        {
            hr = CreateBGImageTag(pDoc, pBody, BGIMAGE_BODYBACKGROUND, &m_rgpTags[m_cTags]);
            if (!FAILED(hr))
                m_cTags++;
        }
        SysFreeString(bstr);
        bstr = NULL;
    }
    
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

error:
    ReleaseObj(pBody);
    return hr;
}




HRESULT CreateBGImageTag(IHTMLDocument2 *pDoc, IUnknown *pUnk, DWORD dwType, IMimeEditTag **ppTag)
{
    CBGImage        *pImage=0;
    IHTMLElement    *pElem=0;
    HRESULT         hr;

    if (ppTag == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    // create image
    pImage = new CBGImage();
    if (!pImage)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // init image with element
    hr = pImage->Init(pDoc, pElem, dwType);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pImage;
    pImage = NULL;

error:
    ReleaseObj(pImage);
    ReleaseObj(pElem);
    return hr;
}



HRESULT CreateBGImageCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppImages)
{
    CBGImageCollection *pImages=0;
    HRESULT             hr;

    if (ppImages == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppImages = NULL;

    // create collection
    pImages = new CBGImageCollection();
    if (!pImages)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pImages->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppImages = pImages;
    pImages = NULL;

error:
    ReleaseObj(pImages);
    return hr;
}






CBGSound::CBGSound()
{
}


CBGSound::~CBGSound()
{
}

HRESULT CBGSound::Init(IHTMLElement *pElem)
{
    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    HrGetMember(pElem, (BSTR)c_bstr_SRC, VARIANT_FALSE, &m_bstrSrc);
    return CBaseTag::Init(pElem);
}

HRESULT CBGSound::OnPreSave()
{
    // set the destination if there is one
    if (m_bstrDest)
        HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrDest);

    return S_OK;
}

HRESULT CBGSound::OnPostSave()
{
    // OnPostSave the original SRC attribute
    HrSetMember(m_pElem, (BSTR)c_bstr_SRC, m_bstrSrc);
    return S_OK;
}


HRESULT CBGSound::CanPackage()
{
    return S_OK;
}

HRESULT CBGSound::IsValidMimeType(LPWSTR pszTypeW)
{
    if (pszTypeW &&
        StrCmpNIW(pszTypeW, L"audio/", 6)==0)
        return S_OK;
    else
        return S_FALSE;
}

    
    
    
CBGSoundCollection::CBGSoundCollection()
{
}


CBGSoundCollection::~CBGSoundCollection()
{
}

HRESULT CBGSoundCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLElementCollection  *pCollect=0;
    IHTMLElement            *pElem;
    ULONG                   uImage;
    HRESULT                 hr;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    hr = HrGetCollectionOf(pDoc, (BSTR)c_bstr_BGSOUND, &pCollect);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    m_cTags = UlGetCollectionCount(pCollect);
    if (m_cTags)
    {
        // allocate an array of COEImage objects
        if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * m_cTags))
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }
        
        ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * m_cTags);

        for (uImage=0; uImage<m_cTags; uImage++)
        {
            if (HrGetCollectionItem(pCollect, uImage, IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
            {
                hr = CreateBGSoundTag(pElem, &m_rgpTags[uImage]);
                if (FAILED(hr))
                {
                    pElem->Release();
                    goto error;
                }
                pElem->Release();
            }
        }
    }

error:
    ReleaseObj(pCollect);
    return hr;
}


HRESULT CreateBGSoundTag(IHTMLElement *pElem, IMimeEditTag **ppTag)
{
    CBGSound    *pSound=0;
    HRESULT     hr;

    if (ppTag == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    // create the sound
    pSound = new CBGSound();
    if (!pSound)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init sound with element
    hr = pSound->Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pSound;
    pSound = NULL;

error:
    ReleaseObj(pSound);
    return hr;
}



HRESULT CreateBGSoundCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags)
{
    CBGSoundCollection *pSounds=0;
    HRESULT             hr;

    if (ppTags == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTags = NULL;

    // create collection
    pSounds = new CBGSoundCollection();
    if (!pSounds)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pSounds->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTags = pSounds;
    pSounds = NULL;

error:
    ReleaseObj(pSounds);
    return hr;
}

























CActiveMovie::CActiveMovie()
{
    m_pDisp = NULL;
    m_dispidSrc = DISPID_UNKNOWN;
}


CActiveMovie::~CActiveMovie()
{
    ReleaseObj(m_pDisp);
}

HRESULT CActiveMovie::Init(IHTMLElement *pElem)
{
    HRESULT hr;

    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    hr = CBaseTag::Init(pElem);
    if (FAILED(hr))
        goto error;

    hr = _GetSrc(&m_bstrSrc);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}

HRESULT CActiveMovie::_EnsureDispID()
{
    IHTMLObjectElement  *pObj;
    IDispatch           *pDisp=NULL;
    HRESULT             hr=E_FAIL;
    LPWSTR              pszW;

    if (m_pDisp && m_dispidSrc != DISPID_UNKNOWN)        // already have IDispatch and DISPID
        return S_OK;

    if (m_pElem->QueryInterface(IID_IHTMLObjectElement, (LPVOID *)&pObj)==S_OK)
    {
        // get the FileName parameter (points to the URL)
        pObj->get_object(&pDisp);
        if (pDisp)
        {
            // get the disp-id of the filename param (cache incase there is > 1)
            pszW = L"FileName";
            pDisp->GetIDsOfNames(IID_NULL, &pszW, 1, NULL, &m_dispidSrc);
    
            if (m_dispidSrc != DISPID_UNKNOWN)
            {
                // we have the DISPID, cache it and the IDispatch pointer
                m_pDisp = pDisp;
                pDisp->AddRef();
                hr = S_OK;
            }
            pDisp->Release();
        }
        pObj->Release();
    }
    return hr;
}

HRESULT CActiveMovie::_GetSrc(BSTR *pbstr)
{
    HRESULT     hr;
    VARIANTARG  v;

    hr = _EnsureDispID();
    if (FAILED(hr))
        goto error;

    hr = GetDispProp(m_pDisp, m_dispidSrc, NULL, &v, NULL);
    if (FAILED(hr))
        goto error;

    *pbstr = v.bstrVal;

error:
    return hr;
}

HRESULT CActiveMovie::SetSrc(BSTR bstr)
{
    HRESULT hr;
    VARIANTARG  v;

    hr = _EnsureDispID();
    if (FAILED(hr))
        goto error;

    v.vt = VT_BSTR;
    v.bstrVal = bstr;

    hr = SetDispProp(m_pDisp, m_dispidSrc, NULL, &v, NULL, DISPATCH_PROPERTYPUT);
    if (FAILED(hr))
        goto error;

error:
    return hr;
}

HRESULT CActiveMovie::OnPreSave()
{
    // set the destination if there is one
    if (m_bstrDest)
        SetSrc(m_bstrDest);

    return S_OK;
}

HRESULT CActiveMovie::OnPostSave()
{
    // OnPostSave the original SRC attribute
    SetSrc(m_bstrSrc);
    return S_OK;
}


HRESULT CActiveMovie::CanPackage()
{
    return S_OK;
}

HRESULT CActiveMovie::IsValidMimeType(LPWSTR pszTypeW)
{
    // allow all mime-types for active-movie controls
    // as many .avi's return appl/octet-stream
    return S_OK;
}

    
CActiveMovieCollection::CActiveMovieCollection()
{
}


CActiveMovieCollection::~CActiveMovieCollection()
{
}

HRESULT CActiveMovieCollection::_BuildCollection(IHTMLDocument2 *pDoc)
{
    IHTMLElementCollection  *pCollect=0;
    IHTMLObjectElement      *pObject;
    ULONG                   uTag;
    HRESULT                 hr;
    ULONG                   cTags;
    BSTR                    bstr=NULL;

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);

    hr = HrGetCollectionOf(pDoc, (BSTR)c_bstr_OBJECT, &pCollect);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    cTags = UlGetCollectionCount(pCollect);
    if (cTags)
    {
        // allocate an array of COEImage objects
        if (!MemAlloc((LPVOID *)&m_rgpTags, sizeof(IMimeEditTag *) * cTags))
        {
            hr = TraceResult(E_OUTOFMEMORY);
            goto error;
        }
        
        ZeroMemory((LPVOID)m_rgpTags, sizeof(IMimeEditTag *) * cTags);

        for (uTag=0; uTag<cTags; uTag++)
        {
            if (HrGetCollectionItem(pCollect, uTag, IID_IHTMLObjectElement, (LPVOID *)&pObject)==S_OK)
            {
                // get the object's class-id
                bstr = 0;
                pObject->get_classid(&bstr);
                if (bstr)
                {
                    // see if it's an active-movie control
                    if (StrCmpIW(bstr, L"CLSID:05589FA1-C356-11CE-BF01-00AA0055595A")==0)
                    {
                        hr = CreateActiveMovieTag(pObject, &m_rgpTags[uTag]);
                        if (FAILED(hr))
                        {
                            SysFreeString(bstr);
                            pObject->Release();
                            goto error;
                        }
                        m_cTags++;
                    }
                    SysFreeString(bstr);
                    bstr = NULL;
                }
                pObject->Release();
            }
        }
    }

error:
    ReleaseObj(pCollect);
    return hr;
}


HRESULT CreateActiveMovieTag(IUnknown *pUnk, IMimeEditTag **ppTag)
{
    CActiveMovie    *pMovie=0;
    IHTMLElement    *pElem=0;
    HRESULT         hr;

    if (ppTag == NULL || pUnk == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTag = NULL;

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // create the sound
    pMovie = new CActiveMovie();
    if (!pMovie)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init sound with element
    hr = pMovie->Init(pElem);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTag = pMovie;
    pMovie = NULL;

error:
    ReleaseObj(pMovie);
    ReleaseObj(pElem);
    return hr;
}



HRESULT CreateActiveMovieCollection(IHTMLDocument2 *pDoc, IMimeEditTagCollection **ppTags)
{
    CActiveMovieCollection *pMovies=0;
    HRESULT             hr;

    if (ppTags == NULL)
        return TraceResult (E_INVALIDARG);
        
    *ppTags = NULL;

    // create collection
    pMovies = new CActiveMovieCollection();
    if (!pMovies)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    // init collection with trident 
    hr = pMovies->Init(pDoc);
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }

    // return the collection
    *ppTags = pMovies;
    pMovies = NULL;

error:
    ReleaseObj(pMovies);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\triutil.cpp ===
/*
 *    t r i u t i l . c p p
 *    
 *    Purpose:
 *        Trident utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include "urlmon.h"
#include "wininet.h"
#include "winineti.h"
#include "mshtml.h"
#include "mshtmcid.h"
#include "mshtmhst.h"
#include "oleutil.h"
#include "triutil.h"
#include "htmlstr.h"
#include "demand.h"
#include "mhtml.h"
#include "mshtmdid.h"
#include "tags.h"

ASSERTDATA

class CDummySite :
        public IOleClientSite,
        public IDispatch
{
    private:
        LONG    m_cRef;
        
    public:
        // *** ctor/dtor methods ***
        CDummySite() : m_cRef(1) {}
        ~CDummySite() {}
        
        // *** IUnknown methods ***
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
        virtual ULONG STDMETHODCALLTYPE AddRef();
        virtual ULONG STDMETHODCALLTYPE Release();

        // IOleClientSite methods.
        virtual HRESULT STDMETHODCALLTYPE SaveObject() { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE ShowObject() { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout() { return E_NOTIMPL; }

        // *** IDispatch ***
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid) { return E_NOTIMPL; }
        virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);
};

/*
 *  t y p e d e f s
 */

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */

HRESULT ClearStyleSheetBackground(IHTMLDocument2 *pDoc);

STDMETHODIMP_(ULONG) CDummySite::AddRef()
{
    return ::InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDummySite::Release()
{
    LONG    cRef = 0;

    cRef = ::InterlockedDecrement(&m_cRef);
    if (0 == cRef)
    {
        delete this;
        return cRef;
    }

    return cRef;
}

STDMETHODIMP CDummySite::QueryInterface(REFIID riid, void ** ppvObject)
{
    HRESULT hr = S_OK;

    // Check the incoming params
    if (NULL == ppvObject)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize outgoing param
    *ppvObject = NULL;
    
    if ((riid == IID_IUnknown) || (riid == IID_IOleClientSite))
    {
        *ppvObject = static_cast<IOleClientSite *>(this);
    }
    else if (riid == IID_IDispatch)
    {
        *ppvObject = static_cast<IDispatch *>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
        goto exit;
    }

    reinterpret_cast<IUnknown *>(*ppvObject)->AddRef();

    hr = S_OK;
    
exit:
    return hr;
}

STDMETHODIMP CDummySite::Invoke(
    DISPID          dispIdMember,
    REFIID          /*riid*/,
    LCID            /*lcid*/,
    WORD            /*wFlags*/,
    DISPPARAMS FAR* /*pDispParams*/,
    VARIANT *       pVarResult,
    EXCEPINFO *     /*pExcepInfo*/,
    UINT *          /*puArgErr*/)
{
    HRESULT             hr = S_OK;

    if (dispIdMember != DISPID_AMBIENT_DLCONTROL)
    {
        hr = E_NOTIMPL;
        goto exit;
    }

    if (NULL == pVarResult)
    {
        hr = E_INVALIDARG;
        goto exit;
    }
    
    // Set the return value
    pVarResult->vt = VT_I4;
    pVarResult->lVal = DLCTL_NO_SCRIPTS | DLCTL_NO_JAVA | DLCTL_NO_RUNACTIVEXCTLS | DLCTL_NO_DLACTIVEXCTLS | DLCTL_NO_FRAMEDOWNLOAD | DLCTL_FORCEOFFLINE;
    
exit:
    return hr;
}

HRESULT HrCreateSyncTridentFromStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv)
{
    HRESULT             hr;
    IOleCommandTarget   *pCmdTarget = NULL;
    CDummySite          *pDummy = NULL;
    IOleClientSite      *pISite = NULL;
    IOleObject          *pIObj = NULL;

    // BUGBUG: this cocreate should also go thro' the same code path as the DocHost one
    // so that if this is the first trident in the process, we keep it's CF around

    hr = CoCreateInstance(CLSID_HTMLDocument, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                            IID_IOleCommandTarget, (LPVOID *)&pCmdTarget);
    if (FAILED(hr))
        goto exit;

    // Create a dummy site
    pDummy = new CDummySite;
    if (NULL == pDummy)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Get the client site interface
    hr = pDummy->QueryInterface(IID_IOleClientSite, (VOID **) &pISite);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Get the OLE object interface from trident
    hr = pCmdTarget->QueryInterface(IID_IOleObject, (VOID **) &pIObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set the client site
    hr = pIObj->SetClientSite(pISite);
    if (FAILED(hr))
    {
        goto exit;
    }

    // force trident to load sync
    pCmdTarget->Exec(&CMDSETID_Forms3, IDM_PERSISTSTREAMSYNC, NULL, NULL, NULL);

    hr = HrIPersistStreamInitLoad(pCmdTarget, pstm);
    if (FAILED(hr))
        goto exit;

    // success let's return the desired interface
    hr = pCmdTarget->QueryInterface(riid, ppv);

exit:
    ReleaseObj(pIObj);
    ReleaseObj(pISite);
    ReleaseObj(pDummy);
    ReleaseObj(pCmdTarget);
    return hr;
}


HRESULT HrGetMember(LPUNKNOWN pUnk, BSTR bstrMember,LONG lFlags, BSTR *pbstr)
{
    IHTMLElement    *pObj;
    HRESULT         hr=E_FAIL;
    VARIANT         rVar;

    if (pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pObj)==S_OK)
        {
        Assert (pObj);

        rVar.vt = VT_BSTR;
        if (!FAILED(pObj->getAttribute(bstrMember, lFlags, &rVar))
            && rVar.vt == VT_BSTR 
            && rVar.bstrVal != NULL)
            {
            hr = S_OK;
            *pbstr = rVar.bstrVal;
            }
        pObj->Release(); 
        }
    return hr;
}



ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect)
{
    ULONG   ulCount=0;

    if (pCollect)
        pCollect->get_length((LONG *)&ulCount);

    return ulCount;
}



HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj)
{
    HRESULT     hr=E_FAIL;
    IDispatch   *pDisp=0;
    VARIANTARG  va1,
                va2;

    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
    va1.lVal = (LONG)uIndex;
    
    pCollect->item(va1, va2, &pDisp);
    if (pDisp)
        {
        hr = pDisp->QueryInterface(riid, ppvObj);
        pDisp->Release();
        }
    return hr;
}

HRESULT HrGetCollectionOf(IHTMLDocument2 *pDoc, BSTR bstrTagName, IHTMLElementCollection **ppCollect)
{
    VARIANT                 v;
    IDispatch               *pDisp=0;
    IHTMLElementCollection  *pCollect=0;
    HRESULT                 hr;
        
    Assert(ppCollect);
    Assert(bstrTagName);
    Assert(pDoc);

    *ppCollect = NULL;

    hr = pDoc->get_all(&pCollect);
    if (pCollect)
        {
        v.vt = VT_BSTR;
        v.bstrVal = bstrTagName;
        pCollect->tags(v, &pDisp);
        if (pDisp)
            {
            hr = pDisp->QueryInterface(IID_IHTMLElementCollection, (LPVOID *)ppCollect);
            pDisp->Release();
            }
        pCollect->Release();
        }
    else if (S_OK == hr)
        hr = E_FAIL;

    return hr;
}

HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue)
{
    IHTMLElement    *pObj;
    HRESULT         hr;
    VARIANT         rVar;

    hr = pUnk->QueryInterface(IID_IHTMLElement, (LPVOID *)&pObj);
    if (!FAILED(hr))
        {
        Assert (pObj);
        rVar.vt = VT_BSTR;
        rVar.bstrVal = bstrValue;
        // if bstrVal is NULL then kill the member
        if (bstrValue)
            hr = pObj->setAttribute(bstrMember, rVar, FALSE);
        else
            hr = pObj->removeAttribute(bstrMember, 0, NULL);
        pObj->Release();
        }
    return hr;
}



HRESULT GetBodyStream(IUnknown *pUnkTrident, BOOL fHtml, LPSTREAM *ppstm)
{
    LPPERSISTSTREAMINIT pStreamInit;
    LPSTREAM            pstm;
    HRESULT             hr;

    Assert(ppstm);
    Assert(pUnkTrident);

    *ppstm=NULL;

    if (fHtml)
        {
        // get the HTML from Trident
        hr = pUnkTrident->QueryInterface(IID_IPersistStreamInit, (LPVOID*)&pStreamInit);
        if (!FAILED(hr))
            {
            hr = MimeOleCreateVirtualStream(&pstm);
            if (!FAILED(hr))
                {
                hr=pStreamInit->Save(pstm, FALSE);
                if (!FAILED(hr))
                    {
                    *ppstm=pstm;
                    pstm->AddRef();
                    }
                pstm->Release();
                }
            pStreamInit->Release();
            }
        }
    else
        {
        hr = HrGetDataStream(pUnkTrident, 
#ifndef WIN16
                        CF_UNICODETEXT, 
#else
                        CF_TEXT,
#endif
                        ppstm);

        }
    return hr;
}



HRESULT HrBindToUrl(LPCSTR pszUrl, LPSTREAM *ppstm)
{
    BYTE                        buf[MAX_CACHE_ENTRY_INFO_SIZE];
    INTERNET_CACHE_ENTRY_INFO  *pCacheInfo = (INTERNET_CACHE_ENTRY_INFO *) buf;
    DWORD                       cInfo = sizeof(buf);
    HRESULT                     hr;

    pCacheInfo->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFO);

    // try to get from the cache
    if (RetrieveUrlCacheEntryFileA(pszUrl, pCacheInfo, &cInfo, 0))
        {
        UnlockUrlCacheEntryFile(pszUrl, 0);
        if (OpenFileStream(pCacheInfo->lpszLocalFileName, OPEN_EXISTING, GENERIC_READ, ppstm)==S_OK)
            return S_OK;
        }

    if (URLOpenBlockingStreamA(NULL, pszUrl, ppstm, 0, NULL)!=S_OK)
        return MIME_E_URL_NOTFOUND;

    return S_OK;
}


HRESULT HrGetStyleTag(IHTMLDocument2 *pDoc, BSTR *pbstr)
{
    IHTMLStyleSheet             *pStyle;
    VARIANTARG                  va1, va2;

    if (pDoc == NULL || pbstr == NULL)
        return E_INVALIDARG;

    *pbstr=NULL;

    if (HrGetStyleSheet(pDoc, &pStyle)==S_OK)
        {
        pStyle->get_cssText(pbstr);
        pStyle->Release();
        }

    return *pbstr ?  S_OK : E_FAIL;
}




HRESULT HrFindUrlInMsg(LPMIMEMESSAGE pMsg, LPSTR lpszUrl, DWORD dwFlags, LPSTREAM *ppstm)
{
    HBODY   hBody=HBODY_ROOT;
    HRESULT hr = E_FAIL;
    LPSTR   lpszFree=0;
        
    if (pMsg && lpszUrl)
    {
         // if it's an MHTML: url then we have to fixup to get the cid:
         if (StrCmpNIA(lpszUrl, "mhtml:", 6)==0 &&
             !FAILED(MimeOleParseMhtmlUrl(lpszUrl, NULL, &lpszFree)))
             lpszUrl = lpszFree;

        if (!(dwFlags & FINDURL_SEARCH_RELATED_ONLY) || MimeOleGetRelatedSection(pMsg, FALSE, &hBody, NULL)==S_OK)
        {
            if (!FAILED(hr = pMsg->ResolveURL(hBody, NULL, lpszUrl, 0, &hBody)) && ppstm)
                hr = pMsg->BindToObject(hBody, IID_IStream, (LPVOID *)ppstm);
        }
    }

    SafeMemFree(lpszFree);
    return hr;
}


HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt)
{
    BYTE    pb[4096];
    LPWSTR  lpszW;
    TCHAR   rgch[MAX_PATH];

    if (!FAILED(pstm->Read(&pb, 4096, NULL)))
        {
        if (!FAILED(FindMimeFromData(NULL, NULL, pb, 4096, NULL, NULL, &lpszW, 0)))
            {
            WideCharToMultiByte(CP_ACP, 0, lpszW, -1, rgch, MAX_PATH, NULL, NULL);
            return MimeOleGetContentTypeExt(rgch, lplpszExt);
            }
        }
    return S_FALSE;
}






HRESULT UnWrapStyleSheetUrl(BSTR bstrStyleUrl, BSTR *pbstrUrl)
{
    LPWSTR      lpszLeftParaW=0, 
                lpszRightParaW=0;
    LPWSTR      pszUrlW;

    // remove 'url()' wrapping from url
    *pbstrUrl = NULL;
    
    if (!bstrStyleUrl)
        return E_FAIL;

    if (StrCmpIW(bstrStyleUrl, L"none")==0)     // 'none' means there isn't one!!!
        return E_FAIL;

    pszUrlW = PszDupW(bstrStyleUrl);
    if (!pszUrlW)
        return TraceResult(E_OUTOFMEMORY);

    if (*pszUrlW != 0)
    {
        lpszLeftParaW = StrChrW(pszUrlW, '(');
        if (lpszLeftParaW)
        {
            lpszRightParaW = StrChrW(lpszLeftParaW, ')');
            if(lpszRightParaW)
            {
                *lpszRightParaW = 0;
                // strcpy same block is ok, as it's a shift down.
                StrCpyW(pszUrlW, ++lpszLeftParaW);
            }
        }
    }
    *pbstrUrl = SysAllocString(pszUrlW);
    MemFree(pszUrlW);
    return *pbstrUrl ? S_OK : E_OUTOFMEMORY;
}

HRESULT WrapStyleSheetUrl(BSTR bstrUrl, BSTR *pbstrStyleUrl)
{
    // simply put 'url()' around the url

    *pbstrStyleUrl = SysAllocStringLen(NULL, SysStringLen(bstrUrl) + 5);
    if (*pbstrStyleUrl == NULL)
        return E_OUTOFMEMORY;

    StrCpyW(*pbstrStyleUrl, L"url(");
    StrCatW(*pbstrStyleUrl, bstrUrl);
    StrCatW(*pbstrStyleUrl, L")");
    return S_OK;
}




/*
 * GetBackgroundImage
 *
 * Trident does not have a very clean OM for getting a background image. You get get the BACKGROUND property on  
 * the <body> tag and/or the background-url propetry in the body's sytle sheet, but neither of these OM methods will
 * combine with any <BASE> url's. So, if the Url is not absolute we have to hunt around for the <BASE> ourselves

    // ugh. This is really disgusting. Trident has no object model for getting a fixed up URL to the background image.
    // it doesn't comine with the base, so the URL is relative and useless to us. We have to do all this work manually.
    // We get a collection of <BASE> tags and find the sourceIndex of the <BODY> tag. We look for the <BASE> tag with the 
    // highest sourceIndex below the body's sourceIndex and comine this guy.
 */

HRESULT GetBackgroundImage(IHTMLDocument2 *pDoc, BSTR *pbstrUrl)
{
    HRESULT                 hr;
    IMimeEditTagCollection  *pCollect;
    IMimeEditTag            *pTag;
    ULONG                   cFetched;
    BSTR                    bstrSrc;

    if (pDoc == NULL || pbstrUrl == NULL)
        return E_INVALIDARG;

    *pbstrUrl = NULL;

    // use the background image collection to get the first background in the precedence order
    if (CreateBGImageCollection(pDoc, &pCollect)==S_OK)
    {
        pCollect->Reset();
        if (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
        {
            pTag->GetSrc(pbstrUrl);
            pTag->Release();
        }
        pCollect->Release();
    }
    return (*pbstrUrl == NULL ? E_FAIL : S_OK);
}



HRESULT SetBackgroundImage(IHTMLDocument2 *pDoc, BSTR bstrUrl)
{
    IMimeEditTagCollection  *pCollect;
    IMimeEditTag            *pTag;
    IHTMLBodyElement        *pBody;
    ULONG                   cFetched;
    BSTR                    bstrSrc;
    HRESULT                 hr = E_FAIL;

    if (pDoc == NULL)
        return E_INVALIDARG;

    // first we use the background image collection to get the 
    // first background in the precedence order if one is present then
    // we use whatever tag this is. If not then we use the body background as that
    // is our prefered client-interop method
    if (CreateBGImageCollection(pDoc, &pCollect)==S_OK)
    {
        pCollect->Reset();
        if (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
        {
            hr = pTag->SetSrc(bstrUrl);
            pTag->Release();
        }
        pCollect->Release();
    }
    
    if (hr == S_OK) // if we found one already
        return S_OK;


    hr = HrGetBodyElement(pDoc, &pBody);
    if (!FAILED(hr))
    {
        hr = pBody->put_background(bstrUrl);
        pBody->Release();
    }
    return hr;
}





HRESULT HrCopyStyleSheets(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest)
{
    IHTMLStyleSheet                 *pStyleSrc=0,
                                    *pStyleDest=0;
    LONG                            lRule=0,
                                    lRules=0;
                
    IHTMLStyleSheetRulesCollection  *pCollectRules=0;
    IHTMLStyleSheetRule             *pRule=0;
    IHTMLRuleStyle                  *pRuleStyle=0;
    BSTR                            bstrSelector=0,
                                    bstrRule=0;

    if (pDocSrc == NULL || pDocDest == NULL)
        return E_INVALIDARG;

    if (HrGetStyleSheet(pDocDest, &pStyleDest)==S_OK)
        {
        // remove all the rules on the destination style sheet
        while (!FAILED(pStyleDest->removeRule(0)));

        if (HrGetStyleSheet(pDocSrc, &pStyleSrc)==S_OK)
            {
            // walk rules collection on source adding to dest
            if (pStyleSrc->get_rules(&pCollectRules)==S_OK)
                 {
                lRules=0;
                pCollectRules->get_length(&lRules);

                for (lRule = 0; lRule < lRules; lRule++)
                    {
                    if (pCollectRules->item(lRule, &pRule)==S_OK)
                        {
                        if (pRule->get_selectorText(&bstrSelector)==S_OK)
                            {
                            if (pRule->get_style(&pRuleStyle)==S_OK)
                                {
                                if (pRuleStyle->get_cssText(&bstrRule)==S_OK)
                                    {
                                    LONG   l;
                                
                                    l=0;
                                    pStyleDest->addRule(bstrSelector, bstrRule, -1, &l);
                                    SysFreeString(bstrRule);
                                    }
                                pRuleStyle->Release();
                                }

                            SysFreeString(bstrSelector);
                            }
                        pRule->Release();
                        }
                    }
                pCollectRules->Release();
                }
            pStyleSrc->Release();
            }
        pStyleDest->Release();
        }   

    return S_OK;
}


HRESULT HrCopyBackground(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest)
{
    HRESULT                     hr;
    IHTMLBodyElement            *pBodySrc=0;
    IHTMLBodyElement            *pBodyDest=0;
    BSTR                        bstrUrl=0;
    VARIANT                     var;
    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    hr = HrGetBodyElement(pDocSrc, &pBodySrc);
    if(FAILED(hr))
        goto error;

    hr = HrGetBodyElement(pDocDest, &pBodyDest);
    if(FAILED(hr))
        goto error;

    GetBackgroundImage(pDocSrc, &bstrUrl);

    hr = pBodyDest->put_background(bstrUrl);
    if(FAILED(hr))
        goto error;

    hr=pBodySrc->get_bgColor(&var);
    if(FAILED(hr))
        goto error;

    hr=pBodyDest->put_bgColor(var);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pBodySrc);
    ReleaseObj(pBodyDest);
    SysFreeString(bstrUrl);
    SysFreeString(var.bstrVal);
    return hr;
}

HRESULT HrRemoveStyleSheets(IHTMLDocument2 *pDoc)
{
    IHTMLStyleSheet         *pStyle=0;
    IHTMLBodyElement            *pBody=0;
                
    if(pDoc == NULL)
        return E_INVALIDARG;

    if (HrGetBodyElement(pDoc, &pBody)==S_OK)
    {
        HrSetMember(pBody, (BSTR)c_bstr_STYLE, NULL);
        HrSetMember(pBody, (BSTR)c_bstr_LEFTMARGIN, NULL);
        HrSetMember(pBody, (BSTR)c_bstr_TOPMARGIN, NULL);
        pBody->Release();
    }

    if(HrGetStyleSheet(pDoc, &pStyle)==S_OK)
    {
        while (!FAILED(pStyle->removeRule(0)));
        pStyle->Release();
    }   

    return S_OK;
}


HRESULT HrRemoveBackground(IHTMLDocument2 *pDoc)
{
    HRESULT                     hr;
    IHTMLBodyElement            *pBody=0;
    VARIANT                     var;
    
    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    hr = HrGetBodyElement(pDoc, &pBody);
    if(FAILED(hr))
        goto error;

    hr = pBody->put_background(NULL);
    if(FAILED(hr))
        goto error;

    hr = pBody->put_bgColor(var);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pBody);
    return hr;
}


HRESULT FindStyleRule(IHTMLDocument2 *pDoc, LPCWSTR pszSelectorW, IHTMLRuleStyle **ppRuleStyle)
{
    IHTMLBodyElement                *pBody;
    IHTMLElement                    *pElem;
    IHTMLStyle                      *pStyleAttrib=0;
    IHTMLStyleSheet                 *pStyleTag=0;
    IHTMLStyleSheetRulesCollection  *pCollectRules=0;
    IHTMLStyleSheetRule             *pRule=0;
    LONG                            lRule=0,
                                    lRules=0;
    BSTR                            bstrSelector=0;
    Assert (pDoc);

    *ppRuleStyle = NULL;

    if (HrGetStyleSheet(pDoc, &pStyleTag)==S_OK)
        {
        pStyleTag->get_rules(&pCollectRules);
        if (pCollectRules)
            {
            pCollectRules->get_length(&lRules);

            for (lRule = 0; lRule < lRules; lRule++)
                {
                pCollectRules->item(lRule, &pRule);
                if (pRule)
                    {
                    pRule->get_selectorText(&bstrSelector);
                    if (bstrSelector)
                        {
                        if (StrCmpIW(bstrSelector, pszSelectorW)==0)
                            pRule->get_style(ppRuleStyle);

                        SysFreeString(bstrSelector);
                        bstrSelector=0;
                        }
                    SafeRelease(pRule);
                    }
                }                
            pCollectRules->Release();
            }
        pStyleTag->Release();
        }

    return *ppRuleStyle ? S_OK : E_FAIL;
}

HRESULT ClearStyleSheetBackground(IHTMLDocument2 *pDoc)
{
    IHTMLBodyElement                *pBody;
    IHTMLElement                    *pElem;
    IHTMLStyle                      *pStyleAttrib=0;
    IHTMLRuleStyle                  *pRuleStyle=0;

    Assert (pDoc);

    if (HrGetBodyElement(pDoc, &pBody)==S_OK)
    {
        if (pBody->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
        {
            // NULL out the style sheet property.
            pElem->get_style(&pStyleAttrib);
            if (pStyleAttrib)
            {
                pStyleAttrib->put_backgroundImage(NULL);
                pStyleAttrib->Release();
            }
            pElem->Release();
        }
        pBody->Release();
    }

    if (FindStyleRule(pDoc, L"BODY", &pRuleStyle)==S_OK)
    {
        pRuleStyle->put_backgroundImage(NULL);
        pRuleStyle->Release();
    }
    return S_OK;

}

HRESULT GetBackgroundSound(IHTMLDocument2 *pDoc, int *pcRepeat, BSTR *pbstrUrl)
{
    IHTMLElementCollection  *pCollect;
    IHTMLBGsound            *pBGSnd;
    VARIANT                 v;
    HRESULT                 hr = E_FAIL;

    TraceCall ("GetBackgroundSound");

    if (pDoc == NULL || pbstrUrl == NULL || pcRepeat == NULL)
        return TraceResult(E_INVALIDARG);
            
    *pbstrUrl = NULL;
    *pcRepeat=1;

    if (!FAILED(HrGetCollectionOf(pDoc, (BSTR)c_bstr_BGSOUND, &pCollect)))
        {
        // get the first BGSOUND in the document
        if (HrGetCollectionItem(pCollect, 0, IID_IHTMLBGsound, (LPVOID *)&pBGSnd)==S_OK)
            {
            pBGSnd->get_src(pbstrUrl);
            if (*pbstrUrl)
                {
                // valid bstr, make sure it's non null
                if (**pbstrUrl)
                    {
                    hr = S_OK;
                    if (pBGSnd->get_loop(&v)==S_OK)
                        {
                        if (v.vt == VT_I4)
                            *pcRepeat = v.lVal;
                        else
                            if (v.vt == VT_BSTR)
                                {
                                // returns a string with "INFINITE"
                                *pcRepeat = -1;
                                SysFreeString(v.bstrVal);
                                }
                            else
                                AssertSz(FALSE, "bad-type from BGSOUND");
                        }
                    }
                else
                    {
                    SysFreeString(*pbstrUrl);
                    *pbstrUrl = NULL;
                    }
                }
            pBGSnd->Release();
            }
        pCollect->Release();
        }

    return hr;
}

HRESULT SetBackgroundSound(IHTMLDocument2 *pDoc, int cRepeat, BSTR bstrUrl)
{
    IHTMLElementCollection  *pCollect;
    IHTMLElement            *pElem;
    IHTMLElement2           *pElem2;
    IHTMLBodyElement        *pBody;
    IHTMLBGsound            *pBGSnd;
    VARIANT                 v;
    int                     count,
                            i;

    TraceCall ("GetBackgroundSound");

    if (pDoc == NULL)
        return TraceResult(E_INVALIDARG);
            
    // remove an existing background sounds
    if (!FAILED(HrGetCollectionOf(pDoc, (BSTR)c_bstr_BGSOUND, &pCollect)))
    {
        count = (int)UlGetCollectionCount(pCollect);
        for (i=0; i<count; i++)
        {
            if (HrGetCollectionItem(pCollect, i, IID_IHTMLElement, (LPVOID *)&pElem)==S_OK)
            {
                pElem->put_outerHTML(NULL);
                pElem->Release();
            }
        }
        pCollect->Release();
    }

    // if we're setting a new one, then insert after the body tag         
    if (bstrUrl && *bstrUrl)
    {
        pElem = NULL;       // trident' OM (returns S_OK with pElem==NULL)
        pDoc->createElement((BSTR)c_bstr_BGSOUND, &pElem);
        if (pElem)
        {
            if (pElem->QueryInterface(IID_IHTMLBGsound, (LPVOID *)&pBGSnd)==S_OK)
            {
                // set the source attribute
                pBGSnd->put_src(bstrUrl);
                
                // set the loop count
                v.vt = VT_I4;
                v.lVal = cRepeat;
                pBGSnd->put_loop(v);

                // insert the tag into the document
                if (HrGetBodyElement(pDoc, &pBody)==S_OK)
                {
                    if (!FAILED(pBody->QueryInterface(IID_IHTMLElement2, (LPVOID *)&pElem2)))
                    {
                        pElem2->insertAdjacentElement((BSTR)c_bstr_AfterBegin, pElem, NULL);
                        pElem2->Release();
                    }
                    pBody->Release();
                }
                
                pBGSnd->Release();
            }
            pElem->Release();
        }
    }
    return S_OK;
}



HRESULT FindNearestBaseUrl(IHTMLDocument2 *pDoc, IHTMLElement *pElemTag, BSTR *pbstrBaseUrl)
{
    IHTMLElementCollection  *pCollect;
    IHTMLElement            *pElem;
    IHTMLBaseElement        *pBase;
    LONG                    lBasePos=0,
                            lBasePosSoFar=0,
                            lIndex=0;
    BSTR                    bstr=NULL,
                            bstrBase=NULL;
    int                     count;

    TraceCall ("FindNearestBaseUrl");

    if (pDoc == NULL || pbstrBaseUrl == NULL || pElemTag == NULL)
        return TraceResult(E_INVALIDARG);
            
    *pbstrBaseUrl = NULL;

    pElemTag->get_sourceIndex(&lIndex);

    if (!FAILED(HrGetCollectionOf(pDoc, (BSTR)c_bstr_BASE, &pCollect)))
    {
        count = (int)UlGetCollectionCount(pCollect);
        for (int i=0; i<count; i++)
        {
            if (!FAILED(HrGetCollectionItem(pCollect, i, IID_IHTMLElement, (LPVOID *)&pElem)))
            {
                pElem->get_sourceIndex(&lBasePos);
                if (lBasePos < lIndex &&
                    lBasePos >= lBasePosSoFar)
                {
                    if (!FAILED(pElem->QueryInterface(IID_IHTMLBaseElement, (LPVOID *)&pBase)))
                    {
                        SysFreeString(bstr);
                        if (pBase->get_href(&bstr)==S_OK && bstr)
                        {
                            SysFreeString(bstrBase);
                            bstrBase = bstr;
                            lBasePosSoFar = lBasePos;
                        }
                        pBase->Release();
                    }
                }
                pElem->Release();
            }
        }
        pCollect->Release();
    }
    
    *pbstrBaseUrl = bstrBase;
    return bstrBase ?  S_OK : TraceResult(E_FAIL);
}


#define CCHMAX_SNIFF_BUFFER 4096

HRESULT SniffStreamForMimeType(LPSTREAM pstm, LPWSTR *ppszType)
{
    BYTE    pb[CCHMAX_SNIFF_BUFFER];
    HRESULT hr = E_FAIL;

    *ppszType = NULL;

    if (!FAILED(pstm->Read(&pb, CCHMAX_SNIFF_BUFFER, NULL)))
        hr = FindMimeFromData(NULL, NULL, pb, CCHMAX_SNIFF_BUFFER, NULL, NULL, ppszType, 0);

    return hr;
}

HRESULT CreateCacheFileFromStream(LPSTR pszUrl, LPSTREAM pstm)
{
    TCHAR		rgchFileName[MAX_PATH];
    HRESULT		hr;
    FILETIME	ft;
    
    rgchFileName[0] = 0;
    
    if (pstm == NULL || pszUrl == NULL)
        return TraceResult(E_INVALIDARG);
    
    if (!CreateUrlCacheEntryA(pszUrl, 0, NULL, rgchFileName, 0))
    {
        hr = TraceResult(E_FAIL);
        goto error;
    }
    
    
    hr = WriteStreamToFile(pstm, rgchFileName, CREATE_ALWAYS, GENERIC_WRITE);    
    if (FAILED(hr))
    {
        TraceResult(hr);
        goto error;
    }
    
    ft.dwLowDateTime = 0;
    ft.dwHighDateTime = 0;
    
    if (!CommitUrlCacheEntryA(	pszUrl, rgchFileName,
								ft, ft,
                                NORMAL_CACHE_ENTRY,
                                NULL, 0, NULL, 0))
    {
        hr = TraceResult(E_FAIL);
        goto error;
    }
    
error:
    return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\util.cpp ===
/*
 *    u t i l  . c p p
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <dllmain.h>
#include <resource.h>
#include "shared.h"
#include "util.h"
#include "mimeolep.h"
#include <icutil.h>
#include <strconst.h>
#include "demand.h"

extern BOOL                g_fCanEditBiDi;

INT_PTR CALLBACK BGSoundDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//NOTE: if *ppstm == NULL, then the stream is created.
//Otherwise it is written to.
HRESULT HrLoadStreamFileFromResourceW(ULONG uCodePage, LPCSTR lpszResourceName, LPSTREAM *ppstm)
{
    HRESULT         hr=E_FAIL;
    HRSRC           hres;
    HGLOBAL         hGlobal;
    LPBYTE          pb;
    DWORD           cb;
    LPWSTR          pszW=0;
    ULONG           cchW;

    if (!ppstm || !lpszResourceName)
        return E_INVALIDARG;
    
    hres = FindResource(g_hLocRes, lpszResourceName, MAKEINTRESOURCE(RT_FILE));
    if (!hres)
        goto error;

    hGlobal = LoadResource(g_hLocRes, hres);
    if (!hGlobal)
        goto error;

    pb = (LPBYTE)LockResource(hGlobal);
    if (!pb)
        goto error;

    cb = SizeofResource(g_hLocRes, hres);
    if (!cb)
        goto error;

    if (!MemAlloc ((LPVOID *)&pszW, sizeof(WCHAR) * (cb + 1)))
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }

    cchW = MultiByteToWideChar(uCodePage, MB_PRECOMPOSED, (LPSTR)pb, cb, pszW, sizeof(WCHAR)*cb);
    if (cchW==0)
        goto error;
    
    if (*ppstm)
        hr = (*ppstm)->Write(pszW, cchW*sizeof(WCHAR), NULL);
    else
        {
        if (SUCCEEDED(hr = MimeOleCreateVirtualStream(ppstm)))
            hr = (*ppstm)->Write (pszW, cchW*sizeof(WCHAR), NULL);
        }

error:  
    SafeMemFree(pszW);
    return hr;
}


//
// REVIEW: We need this function because current version of USER.EXE does
//  not support pop-up only menu.
//
HMENU LoadPopupMenu(UINT id)
{
    HMENU hmenuParent = LoadMenu(g_hLocRes, MAKEINTRESOURCE(id));

    if (hmenuParent) {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
        DestroyMenu(hmenuParent);
        return hpopup;
    }

    return NULL;
}




UINT_PTR TTIdFromCmdId(UINT_PTR idCmd)
{
    if (idCmd >= IDM_FIRST && idCmd <= IDM_LAST)
        idCmd += TT_BASE;
    else
        idCmd = 0;
    return(idCmd);
}

// --------------------
//
// ProcessTooltips:
//
//      This function is used to process tooltips text notification.
//
// --------------------

void ProcessTooltips(LPTOOLTIPTEXTOE lpttt)
{
    if (lpttt->lpszText = MAKEINTRESOURCE(TTIdFromCmdId(lpttt->hdr.idFrom)))
        lpttt->hinst = g_hLocRes;
    else
        lpttt->hinst = NULL;
}


#define DEFAULT_FONTSIZE 2
INT PointSizeToHTMLSize(INT iPointSize)
{
    INT     iHTMLSize;
    // 1 ----- 8
    // 2 ----- 10
    // 3 ----- 12
    // 4 ----- 14
    // 5 ----- 18
    // 6 ----- 24
    // 7 ----- 36

    if(iPointSize>=8 && iPointSize<9)
        iHTMLSize = 1;
    else if(iPointSize>=9 && iPointSize<12)
        iHTMLSize = 2;
    else if(iPointSize>=12 && iPointSize<14)
        iHTMLSize = 3;
    else if(iPointSize>=14 && iPointSize<18)
        iHTMLSize = 4;
    else if(iPointSize>=18 && iPointSize<24)
        iHTMLSize = 5;
    else if(iPointSize>=24 && iPointSize<36)
        iHTMLSize = 6;
    else if(iPointSize>=36)
        iHTMLSize = 7;
    else
        iHTMLSize = DEFAULT_FONTSIZE;

    return iHTMLSize;
}



HRESULT DoBackgroundSoundDlg(HWND hwnd, PBGSOUNDDLG pBGSoundDlg)
{
    if (DialogBoxParamWrapW(g_hLocRes, MAKEINTRESOURCEW(iddBackSound), hwnd, BGSoundDlgProc, (LPARAM)pBGSoundDlg)==IDOK)
        return S_OK;

    return E_FAIL;
}

static const HELPMAP g_rgBGSoundHlp[] =
{
    {ideSoundLoc, 50180},
    {idbtnBrowseSound, 50185},
    {idrbPlayNTimes, 50190},
    {idePlayCount, 50190},
    {IDC_SPIN1, 50190},
    {idrbPlayInfinite, 50195},
    {0, 0}
};

INT_PTR CALLBACK BGSoundDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PBGSOUNDDLG     pBGSoundDlg;
    WCHAR           wsz[10];
    OPENFILENAMEW   ofn;
    WCHAR           wszTitle[CCHMAX_STRINGRES],
                    wszFilter[CCHMAX_STRINGRES],
                    wszFile[MAX_PATH],
                    wszInitialDir[MAX_PATH];
    LPCWSTR         wszMediaDir = L"\\Media";
    LPWSTR          pwszFile = NULL;;
    UINT            rc;

    switch (uMsg)
        {
        case WM_INITDIALOG:
            pBGSoundDlg = (PBGSOUNDDLG)lParam;

            Assert (pBGSoundDlg);
            SendMessage(GetDlgItem(hwnd, ideSoundLoc), EM_SETLIMITTEXT, MAX_PATH-1, 0);
            SendMessage(GetDlgItem(hwnd, idePlayCount), EM_SETLIMITTEXT, 3, 0);
            SetWindowTextWrapW(GetDlgItem(hwnd, ideSoundLoc), pBGSoundDlg->wszUrl);
            AthwsprintfW(wsz, ARRAYSIZE(wsz), L"%d", max(pBGSoundDlg->cRepeat, 1));
            SetWindowTextWrapW(GetDlgItem(hwnd, idePlayCount), wsz);
            CheckRadioButton(hwnd, idrbPlayNTimes, idrbPlayInfinite, pBGSoundDlg->cRepeat==-1 ? idrbPlayInfinite:idrbPlayNTimes);
            SendDlgItemMessage(hwnd, IDC_SPIN1, UDM_SETRANGE, 0, MAKELONG(999, 1));
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);
            break;
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, uMsg, wParam, lParam, g_rgBGSoundHlp);            

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case idrbPlayInfinite:
                case idrbPlayNTimes:
                    EnableWindow(GetDlgItem(hwnd, idePlayCount), LOWORD(wParam)==idrbPlayNTimes);
                    break;

                case idbtnBrowseSound:

                    *wszFile=0;
                    *wszFilter=0;
                    *wszTitle=0;

                    LoadStringWrapW(g_hLocRes, idsFilterAudio, wszFilter, ARRAYSIZE(wszFilter));
                    ReplaceCharsW(wszFilter, L'|', L'\0');
    
                    ZeroMemory(&ofn, sizeof(ofn));
                    ofn.lStructSize = sizeof(ofn);
                    ofn.hwndOwner = hwnd;
                    ofn.lpstrFile = wszFile;
                    ofn.lpstrFilter = wszFilter;

                    LoadStringWrapW(g_hLocRes, idsPickBGSound, wszTitle, ARRAYSIZE(wszTitle));
                    ofn.lpstrTitle = wszTitle;
                    ofn.nMaxFile = ARRAYSIZE(wszFile);
                    ofn.Flags = OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_NONETWORKBUTTON|OFN_NOCHANGEDIR;
                    
                    // begin added for BUG 29778
                    rc = GetWindowsDirectoryWrapW(wszInitialDir, ARRAYSIZE(wszInitialDir));
                    if( rc > ARRAYSIZE(wszInitialDir))
                    {
                        // if cannot copy entire windows dir path then punt and default to desktop
                        *wszInitialDir = 0;
                    }
                    else
                    {
                        if (!StrCatW(wszInitialDir, wszMediaDir))
                        {
                            // punt if can't concat
                            *wszInitialDir = 0;
                        }
                    }

                    ofn.lpstrInitialDir = wszInitialDir;
                    // end added for BUG 29778
                    if (HrAthGetFileNameW(&ofn, TRUE)==S_OK)
                        SetWindowTextWrapW(GetDlgItem(hwnd, ideSoundLoc), wszFile);

                    return TRUE;

                case IDOK:
                    pBGSoundDlg = (PBGSOUNDDLG)GetWindowLongPtr(hwnd, DWLP_USER);

                    GetWindowTextWrapW(GetDlgItem(hwnd, ideSoundLoc), pBGSoundDlg->wszUrl, ARRAYSIZE(pBGSoundDlg->wszUrl));
                    if (!IsValidFileIfFileUrlW(pBGSoundDlg->wszUrl) &&
                        AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsBgSound), MAKEINTRESOURCEW(idsErrBgSoundFileBad), NULL, MB_YESNO|MB_DEFBUTTON2)==IDNO)
                       break;
                    
                    pBGSoundDlg->cRepeat=1;
                    
                    if (IsDlgButtonChecked(hwnd, idrbPlayNTimes))
                        {
                        GetWindowTextWrapW(GetDlgItem(hwnd, idePlayCount), wsz, ARRAYSIZE(wsz));
                        pBGSoundDlg->cRepeat = StrToIntW(wsz);
                        if (pBGSoundDlg->cRepeat <= 0 || pBGSoundDlg->cRepeat > 999)
                            {
                            AthMessageBoxW(hwnd, MAKEINTRESOURCEW(idsBgSound), MAKEINTRESOURCEW(idsErrBgSoundLoopRange), NULL, MB_OK);
                            break;
                            }
                        }                        
                    else
                        pBGSoundDlg->cRepeat=-1;    //infinite

                    // fall thro'

                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;
        }

    return FALSE;
}

static const HELPMAP g_rgFmtParaHlp[] =
{
    {idmFmtLeft, 50200},
    {idmFmtRight, 50200},
    {idmFmtCenter, 50200},
    {idmFmtJustify, 50200},
    {idmFmtNumbers, 50205},
    {idmFmtBullets, 50205},
    {idmFmtBulletsNone, 50205},
    {0, 0}
};

INT_PTR CALLBACK FmtParaDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{

    int                     id, i;
    LPPARAPROP              pParaProp;

    pParaProp = (LPPARAPROP)GetWindowLongPtr(hwnd, DWLP_USER);
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            Assert(lParam!= NULL);
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)lParam);
            pParaProp = (LPPARAPROP)lParam;
            CenterDialog(hwnd);
            // Bug 96520
            // if we are in plain text mode then paragraph format should be set to left
            if(!(pParaProp->group[0].iID))
                pParaProp->group[0].iID = idmFmtLeft;

            CheckRadioButton( hwnd,  idmFmtLeft, idmFmtJustify, pParaProp->group[0].iID);
            CheckRadioButton( hwnd,  idmFmtNumbers, idmFmtBulletsNone, pParaProp->group[1].iID);
            CheckRadioButton( hwnd,  idmFmtBlockDirLTR, idmFmtBlockDirRTL, pParaProp->group[2].iID);
            if (!g_fCanEditBiDi)
            {
                ShowWindow(GetDlgItem(hwnd, idmFmtBlockDirRTL), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, idmFmtBlockDirLTR), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_STATIC1), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_STATIC2), SW_HIDE);
            }
        }
        return(TRUE);
        
        case WM_HELP:
        case WM_CONTEXTMENU:
            return OnContextHelp(hwnd, msg, wParam, lParam, g_rgFmtParaHlp);            

        case WM_COMMAND:
            switch(id=GET_WM_COMMAND_ID(wParam, lParam))
            {
                case idmFmtBlockDirLTR:
                case idmFmtBlockDirRTL:
                // Dir Attribute implies alignment
                    CheckRadioButton( hwnd,  idmFmtLeft, idmFmtRight, id == idmFmtBlockDirLTR ? idmFmtLeft : idmFmtRight);
                   break;
                
                case IDOK:
                for (i = 0; i < 4; i++)
                {
                    if(IsDlgButtonChecked(hwnd, idmFmtLeft + i) == BST_CHECKED)
                    {
                        pParaProp->group[0].bChanged = !(pParaProp->group[0].iID - (idmFmtLeft + i) == 0);
                        pParaProp->group[0].iID = idmFmtLeft + i;
                    }
                }

                for (i = 0; i < 2; i++)
                {
                    if(IsDlgButtonChecked(hwnd, idmFmtNumbers + i) == BST_CHECKED)
                    {
                        pParaProp->group[1].bChanged = !(pParaProp->group[1].iID - (idmFmtNumbers + i) == 0);
                        pParaProp->group[1].iID = idmFmtNumbers + i;
                    }
                }
                // Bullets and Numbers are flip flops, let's force a change if the user selscts none
                // leaving the same previous ID
                if(IsDlgButtonChecked(hwnd, idmFmtBulletsNone) == BST_CHECKED)
                {
                    pParaProp->group[1].bChanged = TRUE;
                }

                if (g_fCanEditBiDi)
                {
                    for (i = 0; i < 2; i++)
                    {
                        if(IsDlgButtonChecked(hwnd, idmFmtBlockDirLTR + i) == BST_CHECKED)
                        {
                            pParaProp->group[2].bChanged = !(pParaProp->group[2].iID - (idmFmtBlockDirLTR + i) == 0);
                            pParaProp->group[2].iID = idmFmtBlockDirLTR + i;
                        }
                    }
                }                
                    // fall thro'

                case IDCANCEL:
                    EndDialog(hwnd, id);
                    break;
            }
            break;
    } 
   return FALSE; 
}

BOOL CanEditBiDi(void)
{
    UINT cNumkeyboards = 0, i;
    HKL* phKeyboadList = NULL;
    BOOL fBiDiKeyBoard = FALSE;

    // Let's check how many keyboard the system has
    cNumkeyboards = GetKeyboardLayoutList(0, phKeyboadList);

    phKeyboadList = (HKL*)LocalAlloc(LPTR, cNumkeyboards * sizeof(HKL));  
    cNumkeyboards = GetKeyboardLayoutList(cNumkeyboards, phKeyboadList);

    for (i = 0; i < cNumkeyboards; i++)
    {
        LANGID LangID = PRIMARYLANGID(LANGIDFROMLCID(LOWORD(phKeyboadList[i])));
        if(  LangID == LANG_ARABIC
           ||LangID == LANG_HEBREW
           ||LangID == LANG_FARSI)
          {
            fBiDiKeyBoard = TRUE;
            break;
          }
    }
   if(phKeyboadList)
   {
       LocalFree((HLOCAL)phKeyboadList);
   }
   return  fBiDiKeyBoard;
}

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap)
{
    if (uMsg == WM_HELP)
    {
        LPHELPINFO lphi = (LPHELPINFO) lParam;
        if (lphi->iContextType == HELPINFO_WINDOW)   // must be for a control
        {
            OEWinHelp ((HWND)lphi->hItemHandle,
                c_szCtxHelpFile,
                HELP_WM_HELP,
                (DWORD_PTR)(LPVOID)rgCtxMap);
        }
        return (TRUE);
    }
    else if (uMsg == WM_CONTEXTMENU)
    {
        OEWinHelp ((HWND) wParam,
            c_szCtxHelpFile,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)rgCtxMap);
        return (TRUE);
    }
    
    Assert(0);
    
    return FALSE;
}

BOOL CALLBACK AthFixDialogFontsProc(HWND hChild, LPARAM lParam){
    HFONT hFont = (HFONT)lParam;

    if(hFont)
        SendMessage(hChild, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE, 0));
    else
        return FALSE;

    return TRUE;
}

HRESULT AthFixDialogFonts(HWND hwndDlg)
{
    HFONT hFont = NULL;

    if(!IsWindow(hwndDlg))
        return E_INVALIDARG;

    if((FAILED(g_lpIFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont))) || (!hFont))
        return E_FAIL;

    EnumChildWindows(hwndDlg, AthFixDialogFontsProc, (LPARAM)hFont);

    return S_OK;
}

//
//  If you are calling this function and you use the result to draw text, you
//  must use a function that supports font substitution (DrawTextWrapW, ExtTextOutWrapW).
//
BOOL GetTextExtentPoint32AthW(HDC hdc, LPCWSTR lpwString, int cchString, LPSIZE lpSize, DWORD dwFlags)
{
    RECT    rect = {0};
    int     rc;

    rc = DrawTextWrapW(hdc, lpwString, cchString, &rect, DT_CALCRECT | dwFlags);
    
    lpSize->cx = rect.right - rect.left + 1;
    lpSize->cy = rect.bottom - rect.top + 1;

    return((BOOL)rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\triutil.h ===
/*
 *    t r i u t i l . c p p
 *    
 *    Purpose:
 *        Trident utilities
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _TRIUTIL_H
#define _TRIUTIL_H

interface IHTMLDocument2;
interface IHTMLElement;
interface IHTMLBodyElement;

HRESULT HrCreateSyncTridentFromStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv);
HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue);
HRESULT HrGetCollectionOf(IHTMLDocument2 *pDoc, BSTR bstrTagName, IHTMLElementCollection **ppCollect);
HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj);
ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect);
HRESULT HrGetMember(LPUNKNOWN pUnk, BSTR bstrMember,LONG lFlags, BSTR *pbstr);
HRESULT GetBodyStream(IUnknown *pUnkTrident, BOOL fHtml, LPSTREAM *ppstm);
HRESULT HrBindToUrl(LPCSTR pszUrl, LPSTREAM *ppstm);


// style sheets
HRESULT HrGetStyleTag(IHTMLDocument2 *pDoc, BSTR *pbstr);
HRESULT HrCopyStyleSheets(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest);
HRESULT HrCopyBackground(IHTMLDocument2 *pDocSrc, IHTMLDocument2 *pDocDest);
HRESULT HrRemoveStyleSheets(IHTMLDocument2 *pDoc);
HRESULT HrRemoveBackground(IHTMLDocument2 *pDoc);
HRESULT FindStyleRule(IHTMLDocument2 *pDoc, LPCWSTR pszSelectorW, IHTMLRuleStyle **ppRuleStyle);

#define FINDURL_SEARCH_RELATED_ONLY     0x01
HRESULT HrFindUrlInMsg(LPMIMEMESSAGE pMsg, LPSTR lpszUrl, DWORD dwFlags, LPSTREAM *ppstm);
HRESULT HrSniffStreamFileExt(LPSTREAM pstm, LPSTR *lplpszExt);

// background images
HRESULT GetBackgroundImage(IHTMLDocument2 *pDoc, BSTR *pbstrUrl);
HRESULT SetBackgroundImage(IHTMLDocument2 *pDoc, BSTR bstrUrl);

// background sound
HRESULT GetBackgroundSound(IHTMLDocument2 *pDoc, int *pcRepeat, BSTR *pbstrUrl);
HRESULT SetBackgroundSound(IHTMLDocument2 *pDoc, int cRepeat, BSTR bstrUrl);

HRESULT UnWrapStyleSheetUrl(BSTR bstrStyleUrl, BSTR *pbstrUrl);
HRESULT WrapStyleSheetUrl(BSTR bstrUrl, BSTR *pbstrStyleUrl);
HRESULT FindNearestBaseUrl(IHTMLDocument2 *pDoc, IHTMLElement *pElemTag, BSTR *pbstrBaseUrl);

HRESULT SniffStreamForMimeType(LPSTREAM pstm, LPWSTR *ppszType);

// cache functions
HRESULT CreateCacheFileFromStream(LPSTR pszUrl, LPSTREAM pstm);

#endif //_TRIUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\viewsrc.h ===
#ifndef _VIEWSRC_
#define _VIEWSRC_

#include "richedit.h"
#include "richole.h"

interface IMimeMessage;

HRESULT ViewSource(HWND hwndParent, IMimeMessage *pMsg);


class CREMenu :
    public IRichEditOleCallback
{
public:
    CREMenu();
    ~CREMenu();

    // *** IUnknown methods ***
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // *** IRichEditOleCallback methods ***
    HRESULT STDMETHODCALLTYPE GetNewStorage (LPSTORAGE FAR *);
    HRESULT STDMETHODCALLTYPE GetInPlaceContext(LPOLEINPLACEFRAME FAR *,LPOLEINPLACEUIWINDOW FAR *,LPOLEINPLACEFRAMEINFO);
    HRESULT STDMETHODCALLTYPE ShowContainerUI(BOOL);
    HRESULT STDMETHODCALLTYPE QueryInsertObject(LPCLSID, LPSTORAGE,LONG);
    HRESULT STDMETHODCALLTYPE DeleteObject(LPOLEOBJECT);
    HRESULT STDMETHODCALLTYPE QueryAcceptData(  LPDATAOBJECT,CLIPFORMAT FAR *, DWORD,BOOL, HGLOBAL);
    HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);
    HRESULT STDMETHODCALLTYPE GetClipboardData(CHARRANGE FAR *, DWORD,LPDATAOBJECT FAR *);
    HRESULT STDMETHODCALLTYPE GetDragDropEffect(BOOL, DWORD,LPDWORD);
    HRESULT STDMETHODCALLTYPE GetContextMenu(WORD, LPOLEOBJECT,CHARRANGE FAR *,HMENU FAR *);

    HRESULT Init(HWND hwndEdit, int idMenu);

private:
    HWND    m_hwndEdit;
    ULONG   m_cRef;
    int     m_idMenu;
};


class CMsgSource:
    public IOleCommandTarget
{
public:
    CMsgSource();
    ~CMsgSource();

    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    HRESULT Init(HWND hwndParent, int id, IOleCommandTarget *pCmdTargetParent);
    HRESULT Show(BOOL fOn, BOOL fColor);
    HRESULT OnWMCommand(HWND hwnd, int id, WORD wCmd);
    HRESULT OnWMNotify(WPARAM wParam, NMHDR* pnmhdr, LRESULT *plRet);
    
    HRESULT Load(IStream *pstm);
    HRESULT Save(IStream **pstm);
    HRESULT SetRect(RECT *prc);
    HRESULT IsDirty();
    HRESULT SetDirty(BOOL fDirty);
    HRESULT OnTimer(WPARAM idTimer);
    HRESULT TranslateAccelerator(LPMSG lpmsg);
    HRESULT HasFocus();
    HRESULT SetFocus();

private:
    ULONG               m_cRef;
    HWND                m_hwnd;
    BOOL                m_fColor,
                        m_fDisabled;
    LPSTR               m_pszLastText;

    IOleCommandTarget   *m_pCmdTargetParent;

    void OnChange();
    void HideSelection(BOOL fHide, BOOL fChangeStyle);
    void GetSel(CHARRANGE *pcr);
    void SetSel(int nStart, int nEnd);
    void GetSelectionCharFormat(CHARFORMAT *pcf);
    void SetSelectionCharFormat(CHARFORMAT *pcf);
    HRESULT _GetText(LPSTR *ppsz);

};




class CViewSource
{
public:

    CViewSource();
    ~CViewSource();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    HRESULT Init(HWND hwndParent, IMimeMessage *pMsg);
    HRESULT Show();

    static INT_PTR CALLBACK _ExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    HWND            m_hwnd,     
                    m_hwndEdit;
    ULONG           m_cRef;
    IMimeMessage    *m_pMsg;

    HRESULT _BoldKids();
    
    INT_PTR    _DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
};


#endif //_VIEWSRC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\util.h ===
#ifndef _UTIL_H
#define _UTIL_H

// #include "msoert.h"

// forward references
typedef struct tagNMTTDISPINFOA NMTTDISPINFOA, FAR *LPNMTTDISPINFOA;
 
#ifndef LPTOOLTIPTEXTOE
#define LPTOOLTIPTEXTOE  LPNMTTDISPINFOA
#endif 


HRESULT HrLoadStreamFileFromResourceW(ULONG uCodePage, LPCSTR lpszResourceName, LPSTREAM *ppstm);
HMENU LoadPopupMenu(UINT id);
void ProcessTooltips(LPTOOLTIPTEXTOE lpttt);
INT PointSizeToHTMLSize(INT iPointSize);

typedef struct BGSOUNDDLG_tag
{
    WCHAR   wszUrl[MAX_PATH];    // we clip this URL to MAX_PATH
    int     cRepeat;

} BGSOUNDDLG, *PBGSOUNDDLG;


typedef struct tagPARAPROP
{
struct {
           INT iID;
           BOOL bChanged;
       }group[3];
} PARAPROP,*LPPARAPROP;

HRESULT DoBackgroundSoundDlg(HWND hwnd, PBGSOUNDDLG pBgSoundDlg);
INT_PTR CALLBACK FmtParaDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CanEditBiDi(void);

// Context-sensitive Help utility.
typedef struct _tagHELPMAP
    {
    DWORD   id; 
    DWORD   hid;
    } HELPMAP, *LPHELPMAP;

BOOL OnContextHelp(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, HELPMAP const * rgCtxMap);

#define AthMessageBox(hwnd, pszT, psz1, psz2, fu) MessageBoxInst(g_hLocRes, hwnd, pszT, psz1, psz2, fu)
#define AthMessageBoxW(hwnd, pwszT, pwsz1, pwsz2, fu) MessageBoxInstW(g_hLocRes, hwnd, pwszT, pwsz1, pwsz2, fu, LoadStringWrapW, MessageBoxWrapW)

#define AthFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags) \
        CchFileTimeToDateTimeW(pft, wszDateTime, cch, dwFlags, \
        GetDateFormatWrapW, GetTimeFormatWrapW, GetLocaleInfoWrapW)

HRESULT AthFixDialogFonts(HWND hwnd);

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\wvtp.h ===
#ifdef __cplusplus

#include <wintrust.h>
// WinVerifyTrust delay load modelled on shell's urlmonp.h

#define DELAY_LOAD_WVT

class Cwvt
{
public:
#ifdef DELAY_LOAD_WVT
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
        HRESULT hres = Init(); \
        if (SUCCEEDED(hres)) { \
            hres = _pfn##_fn _nargs; \
        } \
        return hres;    } \
    HRESULT (STDAPICALLTYPE* _pfn##_fn) _args;

    HRESULT     Init(void);

    BOOL    m_fInited;
    HRESULT m_hrPrev;
    HMODULE m_hMod;
#else
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
            HRESULT hr = ::#_fn _nargs; \
            }

#endif

    DELAYWVTAPI(WinVerifyTrust,
    (HWND hwnd, GUID * ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData));

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\wvt.cpp ===
#include "pch.hxx"
#include "wvtp.h"

#define ADVAPI32 TEXT("advapi32.dll")
#define WINTRUST TEXT("wintrust.dll")

#ifdef DELAY_LOAD_WVT

#ifndef _WVTP_NOCODE_

typedef BOOL
(*PWIN_LOAD_TRUST_PROVIDER)(
    GUID * ActionID
    );

HRESULT
Cwvt::Init(void)
{
    PWIN_LOAD_TRUST_PROVIDER LoadTrustProcAddr;
    BOOL ActionIDFound;
    GUID PublishedSoftware = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID *ActionID = &PublishedSoftware;


    if (m_fInited) {
        return S_OK;
    }

    if (m_hrPrev) {
        return m_hrPrev; //cached copy of prev load failure
    }

    m_hMod = LoadLibrary( ADVAPI32 );

    if (!m_hMod) { // if ADVAPI32 absent then fatal error!
        return (m_hrPrev = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND));
    }

    //
    // See if this module exports WinTrustLoadTrustProvider.  If it does, then
    // call it and see if we can find a trust provider that perform the passed
    // Action.  If so, then extract the addresses of WinVerifyTrust and
    // WinSubmitCertificate from it.
    //
    // If it doesn't, then toss this library and open wintrust.dll, and get the
    // procedures from there.
    //

    LoadTrustProcAddr = (PWIN_LOAD_TRUST_PROVIDER )GetProcAddress(m_hMod, TEXT("WinLoadTrustProvider"));

    ActionIDFound = FALSE;

    if (NULL != LoadTrustProcAddr) {

        //
        // See if we can find a trust provider that implements this ActionID
        //

        ActionIDFound = (*LoadTrustProcAddr)( ActionID );
    }

    if (FALSE == ActionIDFound) {

        //
        // Either we didn't find the routine we needed, or it was there and we didn't
        // have the trust provider we needed.  Regardless of which, free this library
        // and load up the "default" library.
        //

        FreeLibrary( m_hMod );

        m_hMod = LoadLibrary( WINTRUST );

        if (NULL == m_hMod) {
            return (m_hrPrev = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND));
        }
    }


#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) { \
        FreeLibrary(m_hMod); \
        return (m_hrPrev = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)); \
    }

    CHECKAPI(WinVerifyTrust);

    m_fInited = TRUE;
    return S_OK;
}


#endif // _WVTP_NOCODE_
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\addparse.h ===
// -------------------------------------------------------------------------------
// Addparse.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// -------------------------------------------------------------------------------
#ifndef __ADDPARSE_H
#define __ADDPARSE_H

// -------------------------------------------------------------------------------
// Depends
// -------------------------------------------------------------------------------
#include "strconst.h"
#include "wstrpar.h"
#include "bytebuff.h"

// -------------------------------------------------------------------------------
// CAddressParser
// -------------------------------------------------------------------------------
class CAddressParser
{
public:
    // ---------------------------------------------------------------------------
    // CAddressParser Methods
    // ---------------------------------------------------------------------------
    void Init(LPCWSTR pszAddress, ULONG cchAddress);
    HRESULT Next(void);

    // ---------------------------------------------------------------------------
    // Accessors
    // ---------------------------------------------------------------------------
    LPCWSTR PszFriendly(void);
    ULONG  CchFriendly(void);
    LPCWSTR PszEmail(void);
    ULONG  CchEmail(void);

private:
    // ---------------------------------------------------------------------------
    // Private Methods
    // ---------------------------------------------------------------------------
    HRESULT _HrAppendFriendly(void);
    HRESULT _HrAppendUnsure(WCHAR chStart, WCHAR chEnd);
    HRESULT _HrIsEmailAddress(WCHAR chStart, WCHAR chEnd, BOOL *pfIsEmail);
    HRESULT _HrQuotedEmail(WCHAR *pchToken);

private:
    // ---------------------------------------------------------------------------
    // Private Data
    // ---------------------------------------------------------------------------
    CStringParserW      m_cString;          // String Parser
    BYTE                m_rgbStatic1[256];  // Static Used for Friendly
    BYTE                m_rgbStatic2[256];  // Static Used for Email
    CByteBuffer         m_cFriendly;        // Parsed Friendly Name
    CByteBuffer         m_cEmail;           // Email Name
};

#endif // __ADDPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\addparse.cpp ===
// --------------------------------------------------------------------------------
// Addparse.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "addparse.h"
#include "bytebuff.h"
#include "shlwapi.h"
#include <demand.h>     // must be last!

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
static const WCHAR c_wszAddressDelims[] = L"\",<(;";
static const WCHAR c_wszRfc822MustQuote[] = L"()<>,;:\\\"[] ";
static const WCHAR c_wszSpace[] = L" ";
static const WCHAR c_wszEmpty[] = L"";

// --------------------------------------------------------------------------------
// CAddressParser::Init
// --------------------------------------------------------------------------------
void CAddressParser::Init(LPCWSTR pszAddress, ULONG cchAddress)
{
    // Give the byte buffers some static space to reduce memory allocations
    m_cFriendly.Init(m_rgbStatic1, sizeof(m_rgbStatic1));
    m_cEmail.Init(m_rgbStatic2, sizeof(m_rgbStatic2));

    // Init the string parser
    m_cString.Init(pszAddress, cchAddress, PSF_NOTRAILWS | PSF_NOFRONTWS);
}

// --------------------------------------------------------------------------------
// CAddressParser::Next
// --------------------------------------------------------------------------------
HRESULT CAddressParser::Next(void)
{
    // Locals
    HRESULT     hr=S_OK;
    WCHAR       chToken;

    // Reset current Friendlay and Email Buffers
    m_cFriendly.SetSize(0);
    m_cEmail.SetSize(0);

    // Outer Loop
    while(1)
    {
        // Skip White Space
        chToken = m_cString.ChSkipWhite();

        // Done...
        if (L'\0' == chToken)
            break;

        // Parse until we hit a token
        chToken = m_cString.ChParse(c_wszAddressDelims, PSF_ESCAPED | PSF_NOTRAILWS);

        // No data was read
        if (0 == m_cString.CbValue())
        {
            // End of string hit
            if (L'\0' == chToken)
                break;

            // Otherwise, comma or semicolon and we have data
            else if ((L',' == chToken) || (L';' == chToken))
            {
                // If we have data, were done
                if (m_cFriendly.CbData() || m_cEmail.CbData())
                    break;

                // Otherwise, continue
                else
                    continue;
            }
        }

        // Email Addresses are never quoted
        if (L'\"' == chToken)
        {
            // AppendUnsure
            CHECKHR(hr = _HrAppendUnsure(L'\0', L'\0'));

            // Parse parameter value
            chToken = m_cString.ChParse(L'\"', L'\"', PSF_ESCAPED);

            // Raid-47099: We need to parse: "CN=first last/O=xyz> org/C=US"@xyz.innosoft.com
            CHECKHR(hr = _HrQuotedEmail(&chToken));

            // Returns S_OK if it was processed
            if (S_FALSE == hr)
            {
                // Write to Friendly
                CHECKHR(hr = _HrAppendFriendly());
            }
        }

        // Otherwise, < always flushes to email
        else if (L'<' == chToken)
        {
            // AppendUnsure
            CHECKHR(hr = _HrAppendFriendly());

            // Parse parameter value
            chToken = m_cString.ChParse(L">", 0);

            // Didn't find the end bracket
            if (L'>' == chToken)
            {
                // Write Friendly Name
                CHECKHR(hr = m_cEmail.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));
            }

            // Otherwise...
            else
            {
                // Should have an Email Address
                CHECKHR(hr = _HrAppendUnsure(L'<', L'>'));
            }
        }

        // Otherwise
        else
        {
            // AppendUnsure
            CHECKHR(hr = _HrAppendUnsure(L'\0', L'\0'));

            // If right paren, search to end
            if (L'(' == chToken)
            {
                // Parse to ending paren...
                chToken = m_cString.ChParse(L'(', L')', PSF_ESCAPED);

                // AppendUnsure
                CHECKHR(hr = _HrAppendUnsure(L'(', L')'));
            }
        }

        // Done
        if ((L',' == chToken) || (L';' == chToken))
            break;
    }

    // If friendly name has data, append a null, check email and return
    if (m_cFriendly.CbData())
    {
        // Append a Null
        m_cFriendly.Append((LPBYTE)c_wszEmpty, sizeof(WCHAR));

        // If Email is not empty, append a null
        if (m_cEmail.CbData())
            m_cEmail.Append((LPBYTE)c_wszEmpty, sizeof(WCHAR));
    }

    // Otherwise, if email has data, append null and return
    else if (m_cEmail.CbData())
    {
        // If Email is not empty, append a null
        m_cEmail.Append((LPBYTE)c_wszEmpty, sizeof(WCHAR));
    }

    // Are we really done ?
    else if (L'\0' == chToken)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // Skip Commas and semicolons
    if (L',' == chToken)
        m_cString.ChSkip(L",");
    else if (L';' == chToken)
        m_cString.ChSkip(L";");

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrQuotedEmail
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrQuotedEmail(WCHAR *pchToken)
{
    // Locals
    HRESULT hr=S_OK;
    ULONG   cchT=0;
    WCHAR   chDelim;
    BOOL    fSeenAt=FALSE;
    WCHAR   ch;
    WCHAR   szToken[2];

    // Invalid Arg
    Assert(pchToken);

    // We should have some data
    if (0 == m_cString.CbValue())
        return S_OK;

    // Get the character
    ch = m_cString.ChPeekNext(0);

    // Check for DBCS
    if (L'@' != ch)
        return S_FALSE;

    // Look ahead and check for: "CN=first last/O=xyz> org/C=US"@xyz.innosoft.com
    while(1)
    {
        // Get the character
        ch = m_cString.ChPeekNext(cchT);

        // Breaking Character
        if (L'\0' == ch || L' ' == ch || L',' == ch || L';' == ch || L'<' == ch || L'>' == ch || L'(' == ch || L')' == ch)
            break;

        // At Sign?
        if (L'@' == ch)
            fSeenAt = TRUE;

        // Increment
        cchT++;
    }

    // No At Sign
    if (0 == cchT || FALSE == fSeenAt)
        return S_FALSE;

    // Append Email Address
    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

    // Append Email Address
    CHECKHR(hr = m_cEmail.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));

    // Append Email Address
    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

    // Setup szToken
    szToken[0] = (L'\0' == ch) ? L' ' : ch;
    szToken[1] = L'\0';

    // Seek to next space
    ch = m_cString.ChParse(szToken, PSF_NOCOMMENTS);
    Assert(szToken[0] == ch || L'\0' == ch);

    // If there is data
    if (m_cString.CbValue() > 0)
    {
        // Append the Email Address
        CHECKHR(hr = m_cEmail.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));
    }

    // End Token
    *pchToken = szToken[0];

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrIsEmailAddress
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrIsEmailAddress(WCHAR chStart, WCHAR chEnd, BOOL *pfIsEmail)
{
    // Locals
    HRESULT        hr=S_OK;
    WCHAR          chToken;
    CStringParserW cString;

    // Invalid Arg
    Assert(pfIsEmail);

    // Init
    *pfIsEmail = FALSE;

    // Init
    cString.Init(m_cString.PszValue(), m_cString.CchValue(), PSF_NOCOMMENTS | PSF_ESCAPED | PSF_NOTRAILWS | PSF_NOFRONTWS);

    // Parse to the end to remove comments
    if (L'\0' != cString.ChParse(c_wszEmpty) || 0 == cString.CbValue())
        return S_OK;

    // Parse String
    if (NULL == StrChrW(cString.PszValue(), L' '))
    {
        // If in brackets, then its an email address for sure
        if (L'<' == chStart && L'>' == chEnd)
        {
            // Is Email
            *pfIsEmail = TRUE;

            // Write Friendly Name
            CHECKHR(hr = m_cEmail.Append((LPBYTE)cString.PszValue(), cString.CbValue()));
        }

        // Look for the last '@' sign and see if their are escapeable chars before the at sign
        else
        {
            // Locals
            LPWSTR      pszT=(LPWSTR)cString.PszValue();
            LPWSTR      pszLastAt=NULL;
            ULONG       cQuoteBeforeAt=0;
            ULONG       cQuoteAfterAt=0;

            // Raid - 62104: Outlook98 doesn't handle Lotus Domino RFC822 Address Construction
            while(*pszT)
            {
                // Check for '@' sign
                if (L'@' == *pszT)
                {
                    // If we already saw an at sign, move cQuoteAfterAt to cQuoteBeforeAt
                    if (pszLastAt)
                    {
                        cQuoteBeforeAt += cQuoteAfterAt;
                        cQuoteAfterAt = 0;
                    }

                    // Save Last At
                    pszLastAt = pszT;
                }

                // See if *pszT is in c_szRfc822MustQuote
                else if (NULL != StrChrW(c_wszRfc822MustQuote, *pszT))
                {
                    // If we've seen an at sign, track quote after at
                    if (pszLastAt)
                        cQuoteAfterAt++;
                    else
                        cQuoteBeforeAt++;
                }

                // Increment
                pszT++;
            }

            // Only if we saw an '@' sign
            if (NULL != pszLastAt)
            {
                // Is Email
                *pfIsEmail = TRUE;

                // If there were not chars that need quoting...
                if (0 == cQuoteBeforeAt)
                {
                    // Write Friendly Name
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)cString.PszValue(), cString.CbValue()));
                }

                // "Mailroute_TstSCC1[BOFATEST.MRTSTSCC]%SSW%EMAILDOM%BETA"@bankamerica.com
                else
                {
                    // Locals
                    ULONG cbComplete=cString.CbValue();
                    ULONG cbFirstPart=(ULONG)(pszLastAt - cString.PszValue());
                    ULONG cbLastPart=cbComplete - cbFirstPart;

                    // Append Doulbe Quote
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

                    // Append Firt part before last at
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)cString.PszValue(), cbFirstPart));

                    // Append Email Address
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)c_wszDoubleQuote, 2));

                    // Append Firt part before last at
                    CHECKHR(hr = m_cEmail.Append((LPBYTE)pszLastAt, cbLastPart));
                }
            }
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrAppendUnsure
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrAppendUnsure(WCHAR chStart, WCHAR chEnd)
{
    // Locals
    HRESULT     hr=S_OK;
    BOOL        fIsEmail=FALSE;

    // We have data
    if (0 == m_cString.CbValue())
        goto exit;

    // Email is not set yet ?
    if (m_cEmail.CbData() == 0)
    {
        // Is current parsed string an address ?
        CHECKHR(hr = _HrIsEmailAddress(chStart, chEnd, &fIsEmail));
    }

    // Not an Eamil Address
    if (FALSE == fIsEmail && m_cString.CbValue() > 0)
    {
        // Append a space
        if (m_cFriendly.CbData() > 0)
        {
            // Add a space
            CHECKHR(hr = m_cFriendly.Append((LPBYTE)c_wszSpace, sizeof(WCHAR)));

            // Start Character
            if (chStart)
            {
                // Append Start Delimiter
                CHECKHR(hr = m_cFriendly.Append((LPBYTE)&chStart, sizeof(WCHAR)));
            }
        }

        // Otherwise, don't write ending terminator
        else
            chEnd = L'\0';

        // Write Friendly Name
        CHECKHR(hr = m_cFriendly.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));

        // Start Character
        if (chEnd)
        {
            // Append Start Delimiter
            CHECKHR(hr = m_cFriendly.Append((LPBYTE)&chEnd, sizeof(WCHAR)));
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::_HrAppendFriendly
// --------------------------------------------------------------------------------
HRESULT CAddressParser::_HrAppendFriendly(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // We should have some data
    if (0 == m_cString.CbValue())
        return S_OK;

    // Append a space
    if (m_cFriendly.CbData() > 0)
    {
        // Add a space
        CHECKHR(hr = m_cFriendly.Append((LPBYTE)c_wszSpace, sizeof(WCHAR)));
    }

    // Write Friendly Name
    CHECKHR(hr = m_cFriendly.Append((LPBYTE)m_cString.PszValue(), m_cString.CbValue()));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CAddressParser::PszFriendly
// --------------------------------------------------------------------------------
LPCWSTR CAddressParser::PszFriendly(void)
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return c_wszEmpty;
    }

    // Return It
    return (m_cFriendly.CbData() ? (LPCWSTR)m_cFriendly.PbData() : PszEmail());
}

// --------------------------------------------------------------------------------
// CAddressParser::CchFriendly
// --------------------------------------------------------------------------------
ULONG CAddressParser::CchFriendly(void) 
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return 0;
    }

    // Return It
    return (m_cFriendly.CbData() ? (m_cFriendly.CbData() - sizeof(WCHAR)) / sizeof(WCHAR) : CchEmail());
}

// --------------------------------------------------------------------------------
// CAddressParser::PszEmail
// --------------------------------------------------------------------------------
LPCWSTR CAddressParser::PszEmail(void)    
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return c_wszEmpty;
    }

    // Return It
    return (m_cEmail.CbData() ? (LPCWSTR)m_cEmail.PbData() : PszFriendly());
}

// --------------------------------------------------------------------------------
// CAddressParser::CchEmail
// --------------------------------------------------------------------------------
ULONG  CAddressParser::CchEmail(void)    
{ 
    // We should have one or the other
    if (0 == m_cFriendly.CbData() && 0 ==  m_cEmail.CbData())
    {
        AssertSz(FALSE, "This is a bug in CAddressParser, should never have an empty friendly and email.");
        return 0;
    }

    // Return It
    return (m_cEmail.CbData() ? (m_cEmail.CbData() - sizeof(WCHAR)) / sizeof(WCHAR) : CchFriendly());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\addrenum.h ===
// --------------------------------------------------------------------------------
// Addrenum.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ADDRENUM_H
#define __ADDRENUM_H

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes
// --------------------------------------------------------------------------------
class CMimeEnumAddressTypes : public IMimeEnumAddressTypes
{
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CMimeEnumAddressTypes(void);
    ~CMimeEnumAddressTypes(void);

    // ----------------------------------------------------------------------------
    // IUnknown
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IMimeEnumAddressTypes
    // ----------------------------------------------------------------------------
    STDMETHODIMP Next(ULONG cItems, LPADDRESSPROPS prgAdr, ULONG *pcFetched);
    STDMETHODIMP Skip(ULONG cItems);
    STDMETHODIMP Reset(void); 
    STDMETHODIMP Clone(IMimeEnumAddressTypes **ppEnum);
    STDMETHODIMP Count(ULONG *pcItems);

    // ----------------------------------------------------------------------------
    // CMimeEnumAddressTypes
    // ----------------------------------------------------------------------------
    HRESULT HrInit(IMimeAddressTable *pTable, ULONG iItem, LPADDRESSLIST pList, BOOL fDuplicate);

private:
    // ----------------------------------------------------------------------------
    // Private Data
    // ----------------------------------------------------------------------------
	LONG				m_cRef;			// Reference count
    ADDRESSLIST         m_rList;        // Array of addresses
    ULONG               m_iAddress;     // Current Address
    IMimeAddressTable  *m_pTable;       // Point back to original address table
	CRITICAL_SECTION	m_cs;			// Thread safety
};

#endif // __ADDRENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\addressx.cpp ===
// --------------------------------------------------------------------------------
// AddressX.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "AddressX.h"
#include "dllmain.h"
#include "internat.h"
#include "mimeapi.h"
#include "demand.h"

// --------------------------------------------------------------------------------
// EmptyAddressTokenW - Makes sure the pToken is empty
// --------------------------------------------------------------------------------
void EmptyAddressTokenW(LPADDRESSTOKENW pToken)
{
    if (pToken->psz)
        *pToken->psz = L'\0';
    pToken->cch = 0;
}

// --------------------------------------------------------------------------------
// FreeAddressTokenW
// --------------------------------------------------------------------------------
void FreeAddressTokenW(LPADDRESSTOKENW pToken)
{
    if (pToken->psz && pToken->psz != (LPWSTR)pToken->rgbScratch)
        g_pMalloc->Free(pToken->psz);
    ZeroMemory(pToken, sizeof(ADDRESSTOKENW));
}

// --------------------------------------------------------------------------------
// HrSetAddressTokenW
// --------------------------------------------------------------------------------
HRESULT HrSetAddressTokenW(LPCWSTR psz, ULONG cch, LPADDRESSTOKENW pToken)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;
    LPWSTR      pszNew;

    // Invalid Arg
    Assert(psz && psz[cch] == L'\0' && pToken);

    // cbAlloc is big enough
    if ((cch + 1) * sizeof(WCHAR) > pToken->cbAlloc)
    {
        // Use Static
        if (NULL == pToken->psz && ((cch + 1) * sizeof(WCHAR)) < sizeof(pToken->rgbScratch))
        {
            pToken->psz = (LPWSTR)pToken->rgbScratch;
            pToken->cbAlloc = sizeof(pToken->rgbScratch);
        }

        // Otherwise
        else
        {
            // If currently set to scratch, NULL it
            if (pToken->psz == (LPWSTR)pToken->rgbScratch)
            {
                Assert(pToken->cbAlloc == sizeof(pToken->rgbScratch));
                pToken->psz = NULL;
            }

            // Compute Size of new blob
            cbAlloc = ((cch + 1) * sizeof(WCHAR));

            // Realloc New Blob
            CHECKALLOC(pszNew = (LPWSTR)g_pMalloc->Realloc((LPVOID)pToken->psz, cbAlloc));

            // Save
            pToken->psz = pszNew;
            pToken->cbAlloc = cbAlloc;
        }
    }

    // Copy the String
    CopyMemory((LPBYTE)pToken->psz, (LPBYTE)psz, ((cch + 1) * sizeof(WCHAR)));

    // Save the Size
    pToken->cch = cch;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// MimeAddressFree
// --------------------------------------------------------------------------------
void MimeAddressFree(LPMIMEADDRESS pAddress)
{
    Assert(pAddress);
    FreeAddressTokenW(&pAddress->rFriendly);
    FreeAddressTokenW(&pAddress->rEmail);
    SafeMemFree(pAddress->tbSigning.pBlobData);
    SafeMemFree(pAddress->tbEncryption.pBlobData);
    ZeroMemory(pAddress, sizeof(MIMEADDRESS));
}

// --------------------------------------------------------------------------------
// HrCopyAddressData
// --------------------------------------------------------------------------------
HRESULT HrMimeAddressCopy(LPMIMEADDRESS pSource, LPMIMEADDRESS pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // Friendly
    if (!FIsEmptyW(pSource->rFriendly.psz))
    {
        CHECKHR(hr = HrSetAddressTokenW(pSource->rFriendly.psz, pSource->rFriendly.cch, &pDest->rFriendly));
    }

    // Email
    if (!FIsEmptyW(pSource->rEmail.psz))
    {
        CHECKHR(hr = HrSetAddressTokenW(pSource->rEmail.psz, pSource->rEmail.cch, &pDest->rEmail));
    }

    // Copy Signature Blob
    if (pSource->tbSigning.pBlobData)
    {
        CHECKHR(hr = HrCopyBlob(&pSource->tbSigning, &pDest->tbSigning));
    }

    // Copy Encryption Blob
    if (pSource->tbEncryption.pBlobData)
    {
        CHECKHR(hr = HrCopyBlob(&pSource->tbEncryption, &pDest->tbEncryption));
    }

    // Save Other Stuff
    pDest->pCharset = pSource->pCharset;
    pDest->dwCookie = pSource->dwCookie;
    pDest->certstate = pSource->certstate;
    pDest->dwAdrType = pSource->dwAdrType;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// HrCopyAddressProps
// --------------------------------------------------------------------------------
HRESULT HrCopyAddressProps(LPADDRESSPROPS pSource, LPADDRESSPROPS pDest)
{
    // Locals
    HRESULT hr=S_OK;

    // IAP_HADDRESS
    if (ISFLAGSET(pSource->dwProps, IAP_HANDLE))
    {
        pDest->hAddress = pSource->hAddress;
        FLAGSET(pDest->dwProps, IAP_HANDLE);
    }

    // IAP_ENCODING
    if (ISFLAGSET(pSource->dwProps, IAP_ENCODING))
    {
        pDest->ietFriendly = pSource->ietFriendly;
        FLAGSET(pDest->dwProps, IAP_ENCODING);
    }

    // IAP_HCHARSET
    if (ISFLAGSET(pSource->dwProps, IAP_CHARSET))
    {
        pDest->hCharset = pSource->hCharset;
        FLAGSET(pDest->dwProps, IAP_CHARSET);
    }

    // IAP_ADRTYPE
    if (ISFLAGSET(pSource->dwProps, IAP_ADRTYPE))
    {
        pDest->dwAdrType = pSource->dwAdrType;
        FLAGSET(pDest->dwProps, IAP_ADRTYPE);
    }

    // IAP_CERTSTATE
    if (ISFLAGSET(pSource->dwProps, IAP_CERTSTATE))
    {
        pDest->certstate = pSource->certstate;
        FLAGSET(pDest->dwProps, IAP_CERTSTATE);
    }

    // IAP_COOKIE
    if (ISFLAGSET(pSource->dwProps, IAP_COOKIE))
    {
        pDest->dwCookie = pSource->dwCookie;
        FLAGSET(pDest->dwProps, IAP_COOKIE);
    }

    // IAP_FRIENDLYW
    if (ISFLAGSET(pSource->dwProps, IAP_FRIENDLYW))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_FRIENDLYW))
        {
            SafeMemFree(pDest->pszFriendlyW);
            FLAGCLEAR(pDest->dwProps, IAP_FRIENDLYW);
        }

        // Dup
        CHECKALLOC(pDest->pszFriendlyW = PszDupW(pSource->pszFriendlyW));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_FRIENDLYW);
    }

    // IAP_FRIENDLY
    if (ISFLAGSET(pSource->dwProps, IAP_FRIENDLY))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_FRIENDLY))
        {
            SafeMemFree(pDest->pszFriendly);
            FLAGCLEAR(pDest->dwProps, IAP_FRIENDLY);
        }

        // Dup
        CHECKALLOC(pDest->pszFriendly = PszDupA(pSource->pszFriendly));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_FRIENDLY);
    }

    // IAP_EMAIL
    if (ISFLAGSET(pSource->dwProps, IAP_EMAIL))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_EMAIL))
        {
            SafeMemFree(pDest->pszEmail);
            FLAGCLEAR(pDest->dwProps, IAP_EMAIL);
        }

        // Dup
        CHECKALLOC(pDest->pszEmail = PszDupA(pSource->pszEmail));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_EMAIL);
    }

    // IAP_SIGNING_PRINT
    if (ISFLAGSET(pSource->dwProps, IAP_SIGNING_PRINT))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_SIGNING_PRINT))
        {
            SafeMemFree(pDest->tbSigning.pBlobData);
            pDest->tbSigning.cbSize = 0;
            FLAGCLEAR(pDest->dwProps, IAP_SIGNING_PRINT);
        }

        // Dup
        CHECKHR(hr = HrCopyBlob(&pSource->tbSigning, &pDest->tbSigning));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_SIGNING_PRINT);
    }

    // IAP_ENCRYPTION_PRINT
    if (ISFLAGSET(pSource->dwProps, IAP_ENCRYPTION_PRINT))
    {
        // Free pDest Current
        if (ISFLAGSET(pDest->dwProps, IAP_ENCRYPTION_PRINT))
        {
            SafeMemFree(pDest->tbEncryption.pBlobData);
            pDest->tbEncryption.cbSize = 0;
            FLAGCLEAR(pDest->dwProps, IAP_ENCRYPTION_PRINT);
        }

        // Dup
        CHECKHR(hr = HrCopyBlob(&pSource->tbEncryption, &pDest->tbEncryption));

        // Set the Falg
        FLAGSET(pDest->dwProps, IAP_ENCRYPTION_PRINT);
    }

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\addrenum.cpp ===
// --------------------------------------------------------------------------------
// AddrEnum.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "addrenum.h"
#include "olealloc.h"
#include "addressx.h"

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::CMimeEnumAddressTypes
// --------------------------------------------------------------------------------
CMimeEnumAddressTypes::CMimeEnumAddressTypes(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pTable = NULL;
    m_iAddress = 0;
    ZeroMemory(&m_rList, sizeof(ADDRESSLIST));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::~CMimeEnumAddressTypes
// --------------------------------------------------------------------------------
CMimeEnumAddressTypes::~CMimeEnumAddressTypes(void)
{
    g_pMoleAlloc->FreeAddressList(&m_rList);
    SafeRelease(m_pTable);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMimeEnumAddressTypes == riid)
        *ppv = (IMimeEnumAddressTypes *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumAddressTypes::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeEnumAddressTypes::Release(void)
{
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return cRef;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Next
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Next(ULONG cWanted, LPADDRESSPROPS prgAdr, ULONG *pcFetched)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cFetch=0, 
                iAddress=0;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pcFetched)
        *pcFetched = 0;

    // No Internal Formats
    if (NULL == m_rList.prgAdr)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_rList.cAdrs - m_iAddress);
    if (0 == cFetch)
        goto exit;

    // Invalid Arg
    if (NULL == prgAdr)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Copy cWanted
    for (iAddress=0; iAddress<cFetch; iAddress++)
    {
        // Zero
        ZeroMemory(&prgAdr[iAddress], sizeof(ADDRESSPROPS));

        // Copy Props
        CHECKHR(hr = HrCopyAddressProps(&m_rList.prgAdr[m_iAddress], &prgAdr[iAddress]));

        // Next
        m_iAddress++;
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (cFetch == cWanted) ? S_OK : S_FALSE;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Skip
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Skip(ULONG cSkip)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Can we do it...
    if (((m_iAddress + cSkip) >= m_rList.cAdrs) || NULL == m_rList.prgAdr)
    {
        hr = S_FALSE;
        goto exit;
    }

    // Skip
    m_iAddress += cSkip;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Reset
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Reset(void)
{
    EnterCriticalSection(&m_cs);
    m_iAddress = 0;
    LeaveCriticalSection(&m_cs);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Count
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Count(ULONG *pcCount)
{
    // Invalid Arg
    if (NULL == pcCount)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Count
    *pcCount = m_rList.cAdrs;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMimeEnumAddressTypes::Clone(IMimeEnumAddressTypes **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    CMimeEnumAddressTypes *pEnum=NULL;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // Create the clone.
    CHECKALLOC(pEnum = new CMimeEnumAddressTypes);

    // Init
    CHECKHR(hr = pEnum->HrInit(m_pTable, m_iAddress, &m_rList, TRUE));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();

exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMimeEnumAddressTypes::HrInit
// --------------------------------------------------------------------------------
HRESULT CMimeEnumAddressTypes::HrInit(IMimeAddressTable *pTable, ULONG iAddress, LPADDRESSLIST pList, BOOL fDuplicate)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Invalid Arg
    Assert(pTable && pList);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check param
    Assert(m_iAddress == 0 && m_rList.cAdrs == 0 && m_rList.prgAdr == NULL);

    // Empty Enumerator ?
    if (0 == pList->cAdrs)
    {
        Assert(pList->prgAdr == NULL);
        goto exit;
    }

    // No Duplicate ?
    if (FALSE == fDuplicate)
        CopyMemory(&m_rList, pList, sizeof(ADDRESSLIST));

    // Otherwise
    else
    {
        // Allocat an internal array
        CHECKHR(hr = HrAlloc((LPVOID *)&m_rList.prgAdr, sizeof(ADDRESSPROPS) * pList->cAdrs));

        // Copy prgPart
        for (i=0; i<pList->cAdrs; i++)
        {
            // Zero Dest
            ZeroMemory(&m_rList.prgAdr[i], sizeof(ADDRESSPROPS));

            // Copy Address Props
            CHECKHR(hr = HrCopyAddressProps(&pList->prgAdr[i], &m_rList.prgAdr[i]));
        }

        // Save Size and State
        m_rList.cAdrs = pList->cAdrs;
    }

    // Save Current Index
    Assert(iAddress < m_rList.cAdrs);
    m_iAddress = iAddress;

    // Assume the Table
    m_pTable = pTable;
    m_pTable->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\addressx.h ===
// --------------------------------------------------------------------------------
// AddressX.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __ADDRESSX_H
#define __ADDRESSX_H

// -------------------------------------------------------------------------------
// Forward Decls
// -------------------------------------------------------------------------------
typedef struct tagADDRESSGROUP *LPADDRESSGROUP;

// -------------------------------------------------------------------------------
// ADDRESSTOKENW
// -------------------------------------------------------------------------------
typedef struct tagADDRESSTOKENW {
    ULONG               cbAlloc;            // Allocated Size
    ULONG               cch;                // Number of Characters
    LPWSTR              psz;                // Pointer to data
    BYTE                rgbScratch[256];    // Scratch Buffer
} ADDRESSTOKENW, *LPADDRESSTOKENW;

// -------------------------------------------------------------------------------
// ADDRESSTOKENA
// -------------------------------------------------------------------------------
typedef struct tagADDRESSTOKENA {
    ULONG               cbAlloc;            // Allocated Size
    ULONG               cch;                // Number of Characters
    LPSTR               psz;                // Pointer to data
    BYTE                rgbScratch[256];    // Scratch Buffer
} ADDRESSTOKENA, *LPADDRESSTOKENA;

// --------------------------------------------------------------------------------
// MIMEADDRESS
// --------------------------------------------------------------------------------
typedef struct tagMIMEADDRESS *LPMIMEADDRESS;
typedef struct tagMIMEADDRESS {
    DWORD           dwAdrType;              // IAP_ADRTYPE: Address Type
    HADDRESS        hThis;                  // IAP_HADDRESS: Handle of this address
    ADDRESSTOKENW   rFriendly;              // IAP_FRIENDLYW: Friendly Name (Unicode)
    ADDRESSTOKENW   rEmail;                 // IAP_EMAIL: Email Address
    LPINETCSETINFO  pCharset;               // IAP_HCHARSET: Charset used to encode pszFriendly
    CERTSTATE       certstate;              // IAP_CERTSTATE: Certificate State
    THUMBBLOB       tbSigning;              // IAP_SIGNING_PRINT: Thumbprint to be used for signing
    THUMBBLOB       tbEncryption;           // IAP_ENCRYPTION_PRINT: Thumbprint to be used for signing
    DWORD           dwCookie;               // IAP_COOKIE: User-defined cookie
    LPADDRESSGROUP  pGroup;                 // Address group
    LPMIMEADDRESS   pPrev;                  // Linked List
    LPMIMEADDRESS   pNext;                  // Linked List
} MIMEADDRESS;

// --------------------------------------------------------------------------------
// MIMEADDRESS Prototypes
// --------------------------------------------------------------------------------
void MimeAddressFree(LPMIMEADDRESS pAddress);
HRESULT HrMimeAddressCopy(LPMIMEADDRESS pSource, LPMIMEADDRESS pDest);
HRESULT HrCopyAddressProps(LPADDRESSPROPS pSource, LPADDRESSPROPS pDest);
void EmptyAddressTokenW(LPADDRESSTOKENW pToken);
void FreeAddressTokenW(LPADDRESSTOKENA pToken);
HRESULT HrSetAddressTokenW(LPCWSTR psz, ULONG cch, LPADDRESSTOKENW pToken);

#endif // __ADDRESSX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\bindstm.cpp ===
// --------------------------------------------------------------------------------
// BINDSTM.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bindstm.h"
#include "demand.h"

#ifdef DEBUG
//#define DEBUG_DUMP_SOURCE
#endif

// --------------------------------------------------------------------------------
// CBindStream::CBindStream
// --------------------------------------------------------------------------------
CBindStream::CBindStream(IStream *pSource) : m_pSource(pSource)
{
    Assert(pSource);
    m_cRef = 1;
    m_pSource->AddRef();
    m_dwDstOffset = 0;
    m_dwSrcOffset = 0;
#ifdef DEBUG_DUMP_SOURCE
    OpenFileStream("c:\\bindsrc.txt", CREATE_ALWAYS, GENERIC_WRITE, &m_pDebug);
#endif
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CBindStream::CBindStream
// --------------------------------------------------------------------------------
CBindStream::~CBindStream(void)
{
#ifdef DEBUG_DUMP_SOURCE
    m_pDebug->Commit(STGC_DEFAULT);
    m_pDebug->Release();
#endif
    SafeRelease(m_pSource);
    DeleteCriticalSection(&m_cs);
}

// -------------------------------------------------------------------------
// CBindStream::QueryInterface
// -------------------------------------------------------------------------
STDMETHODIMP CBindStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CBindStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindStream::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CBindStream::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindStream::Release(void)
{
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// CBindStream::DebugAssertOffset
// --------------------------------------------------------------------------------
void CBindStream::DebugAssertOffset(void)
{
    // Locals
    DWORD           dw;
    ULARGE_INTEGER  uliSize;
    ULARGE_INTEGER  uliOffset;

    // Validate the size, sizeof m_cDest should always be equal to m_dwSrcOffset
    m_cDest.QueryStat(&uliOffset, &uliSize);

    // Assert Offset
    Assert(uliOffset.HighPart == 0 && m_dwDstOffset == uliOffset.LowPart);

    // Assert Size
    Assert(uliSize.HighPart == 0 && m_dwSrcOffset == uliSize.LowPart);
}

// --------------------------------------------------------------------------------
// CBindStream::DebugDumpDestStream
// --------------------------------------------------------------------------------
void CBindStream::DebugDumpDestStream(LPCSTR pszFile)
{
    // Locals
    IStream *pStream;

    // Open Stream
    if (SUCCEEDED(OpenFileStream((LPSTR)pszFile, CREATE_ALWAYS, GENERIC_WRITE, &pStream)))
    {
        HrRewindStream(&m_cDest);
        HrCopyStream(&m_cDest, pStream, NULL);
        pStream->Commit(STGC_DEFAULT);
        pStream->Release();
    }
    else
        Assert(FALSE);

    // Reset Position of both stream
    HrStreamSeekSet(&m_cDest, m_dwDstOffset);
}
#endif // DEBUG

// --------------------------------------------------------------------------------
// CBindStream::Read
// --------------------------------------------------------------------------------
STDMETHODIMP CBindStream::Read(void HUGEP_16 *pv, ULONG cb, ULONG *pcbRead)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrRead=S_OK;
    ULONG           cbReadDst=0;
    ULONG           cbReadSrc=0;
    ULONG           cbGet;

    // Invalid Arg
    Assert(pv);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Destination offset is less than source offset
    if (m_dwDstOffset < m_dwSrcOffset)
    {
        // Compute amount to get
        cbGet = min(cb, m_dwSrcOffset - m_dwDstOffset);

        // Validate the offsets
#ifdef DEBUG
        DebugAssertOffset();
#endif

        // Read the amount from the destination
        CHECKHR(hr = m_cDest.Read(pv, cbGet, &cbReadDst));

        // Increment offset
        m_dwDstOffset += cbReadDst;
    }

    // If we didn't read cb, try to read some more
    if (cbReadDst < cb && m_pSource)
    {
        // Compute amount to get
        cbGet = cb - cbReadDst;

        // Read the amount from the source
        hrRead = m_pSource->Read((LPBYTE)pv + cbReadDst, cbGet, &cbReadSrc);

        // Raid-43408: MHTML: images don't load on first load over http, but refresh makes them appear
        if (FAILED(hrRead))
        {
            // If I got an E_PENDING with data read, don't fail yet
            if (E_PENDING == hrRead && cbReadSrc > 0)
                hrRead = S_OK;

            // Otherwise, we really failed, might still be an E_PENDING
            else
            {
                TrapError(hrRead);
                goto exit;
            }
        }

        // Debug Dumping
#ifdef DEBUG_DUMP_SOURCE
        SideAssert(SUCCEEDED(m_pDebug->Write(pv, cbReadSrc + cbReadDst, NULL)));
#endif
        // If we read something
        if (cbReadSrc)
        {
            // Increment source offset
            m_dwSrcOffset += cbReadSrc;

            // Write to Dest
            CHECKHR(hr = m_cDest.Write((LPBYTE)pv + cbReadDst, cbReadSrc, NULL));

            // Update Dest offset
            m_dwDstOffset += cbReadSrc;

            // Validate the offsets
#ifdef DEBUG
            DebugAssertOffset();
#endif
        }

        // Check
        Assert(m_dwDstOffset == m_dwSrcOffset);
    }

    // Return pcbRead
    if (pcbRead)
        *pcbRead = cbReadDst + cbReadSrc;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return FAILED(hr) ? hr : hrRead;
}

// --------------------------------------------------------------------------------
// CBindStream::Seek
// --------------------------------------------------------------------------------
STDMETHODIMP CBindStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    ULARGE_INTEGER  uliOffset;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Seek m_cDest
    CHECKHR(hr = m_cDest.Seek(dlibMove, dwOrigin, plibNew));

    // Get the current offset
    m_cDest.QueryStat(&uliOffset, NULL);

    // Update m_dwDstOffset
    m_dwDstOffset = uliOffset.LowPart;

    // Should be less than m_dwSrcOffset
    Assert(m_dwDstOffset <= m_dwSrcOffset);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CBindStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CBindStream::Stat(STATSTG *pStat, DWORD dw)
{
    // Invalid Arg
    if (NULL == pStat)
        return TrapError(E_INVALIDARG);

    // As long as we have m_pSource, the size is pending
    if (m_pSource)
        return TrapError(E_PENDING);

    // ZeroInit
    ZeroMemory(pStat, sizeof(STATSTG));

    // Fill pStat
    pStat->type = STGTY_STREAM;
    m_cDest.QueryStat(NULL, &pStat->cbSize);

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeedit\viewsrc.cpp ===
#include <pch.hxx>
#include "dllmain.h"
#include "demand.h"
#include "resource.h"
#include "viewsrc.h"
#include "util.h"

#define idTimerEditChange   401

/////////////////////////////////////////////////////////////////////////////
// Parsing constants

//	Ignore all <'s and >'s in the following environments:
//	Script				<script> here </script>
//  Denali				<% here %>
//  Comment				<!-- here -->
//  String literal		< ... "here" ... >
//	 (as tag attribute)	< ... 'here' ... >

static enum
{
	ENV_NORMAL	= 0,	// normal
	ENV_COMMENT = 1,	// ignore <'s and >'s
	ENV_QUOTE	= 2,	// " "
	ENV_SCRIPT	= 3,	// " "
	ENV_DENALI	= 4,	// " "
	ENV_QUOTE_SCR= 5,	// " "; string literal in SCRIPT tag
};

static const char	QUOTE_1 = '\'';
static const char	QUOTE_2 = '\"';


HRESULT CALLBACK FreeViewSrcDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt)
{
    // Loop through the data and free it all
    if (pDataObjInfo)
        {
        for (DWORD i = 0; i < celt; i++)
            SafeMemFree(pDataObjInfo[i].pData);
        SafeMemFree(pDataObjInfo);    
        }
    return S_OK;
}


HRESULT ViewSource(HWND hwndParent, IMimeMessage *pMsg)
{
    CViewSource     *pViewSrc=0;
    HRESULT         hr;

    TraceCall("MimeEditViewSource");

    if (!DemandLoadRichEdit())
        return TraceResult(MIMEEDIT_E_LOADLIBRARYFAILURE);


    pViewSrc = new CViewSource();
    if (!pViewSrc)
        return E_OUTOFMEMORY;
            
    hr = pViewSrc->Init(hwndParent, pMsg);
    if (FAILED(hr))
        goto exit;

    hr = pViewSrc->Show();
    if (FAILED(hr))
        goto exit;

    // pViewSrc will maintain it's own refcount and self-destruct on close
exit:
    ReleaseObj(pViewSrc);
    return hr;
}


CViewSource::CViewSource()
{
    m_hwnd = NULL;
    m_hwndEdit = NULL;
    m_pMsg = NULL;
    m_cRef = 1;
}


CViewSource::~CViewSource()
{
    SafeRelease(m_pMsg);
}


ULONG CViewSource::AddRef()
{
    return ++m_cRef;
}

ULONG CViewSource::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CViewSource::Init(HWND hwndParent, IMimeMessage *pMsg)
{
    ReplaceInterface(m_pMsg, pMsg);

    if (!CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(iddMsgSource), hwndParent, CViewSource::_ExtDlgProc, (LPARAM)this))
        return E_OUTOFMEMORY;

    return S_OK;
}


HRESULT CViewSource::Show()
{
    ShowWindow(m_hwnd, SW_SHOW);
    return S_OK;
}


INT_PTR CALLBACK CViewSource::_ExtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CViewSource     *pThis = (CViewSource *)GetWindowLongPtr(hwnd, DWLP_USER);

    if (msg == WM_INITDIALOG)
    {
        pThis = (CViewSource *)lParam;
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
    }

    return pThis ? pThis->_DlgProc(hwnd, msg, wParam, lParam) : FALSE;
}


INT_PTR CViewSource::_DlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPSTREAM        pstm;
    CHARFORMAT      cf;
    BODYOFFSETS     rOffset;
    CREMenu         *pMenu;

    switch(msg)
        {
        case WM_INITDIALOG:
            m_hwnd = hwnd;
            m_hwndEdit=GetDlgItem(hwnd, idcTxtSource);
            DllAddRef();
            AddRef();

            if (m_pMsg && 
                m_pMsg->GetMessageSource(&pstm, 0)==S_OK)
            {
                ZeroMemory((LPVOID)&cf, sizeof(CHARFORMAT));
                cf.cbSize = sizeof(CHARFORMAT);
                cf.dwMask = CFM_SIZE|CFM_COLOR|CFM_FACE|CFM_BOLD|
                            CFM_ITALIC|CFM_UNDERLINE|CFM_STRIKEOUT;
                lstrcpy(cf.szFaceName, "Courier New");
                cf.yHeight = 200;
                cf.crTextColor = 0;
                cf.dwEffects |= CFE_AUTOCOLOR;
                cf.bPitchAndFamily = FIXED_PITCH;
                cf.yOffset = 0;
                SendMessage(m_hwndEdit, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
                SendMessage(m_hwndEdit, EM_SETBKGNDCOLOR, 0, (LONG)GetSysColor(COLOR_3DFACE));
                SendMessage(m_hwndEdit, EM_SETLIMITTEXT, 0, 0x100000);

                pMenu = new CREMenu();
                if (pMenu)
                {
                    pMenu->Init(m_hwndEdit, idmrCtxtViewSrc);
                    SendMessage(m_hwndEdit, EM_SETOLECALLBACK, 0, (LPARAM)pMenu);
                    pMenu->Release();
                }

                RicheditStreamIn(m_hwndEdit, pstm, SF_TEXT);
                _BoldKids();
                pstm->Release();
            }
            PostMessage(m_hwndEdit, EM_SETSEL, 0, 0);
            return TRUE;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case idmCopy:
                    SendMessage(m_hwndEdit, WM_COPY, 0, 0);
                    return TRUE;

                case idmSelectAll:
                    Edit_SetSel(m_hwndEdit, 0, -1);
                    return TRUE;
            }
            break;

        case WM_SIZE:
            SetWindowPos(m_hwndEdit,0,0,0,
                    LOWORD(lParam), HIWORD(lParam),SWP_NOACTIVATE|SWP_NOZORDER);
            break;

        case WM_DESTROY:
            DllRelease();
            Release();
            break;

        case WM_CLOSE:
            DestroyWindow(hwnd);
            break;
        }

    return FALSE;
}



HRESULT CViewSource::_BoldKids()
{
    HBODY       hBody;
    FINDBODY    fb={0};
    CHARFORMAT  cf;
    BODYOFFSETS rOffset;

    ZeroMemory((LPVOID)&cf, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_BOLD|CFM_ITALIC;

    // bold the root
    m_pMsg->GetBodyOffsets(HBODY_ROOT, &rOffset);
    Edit_SetSel(m_hwndEdit, 0, rOffset.cbBodyStart);
    cf.dwEffects=CFE_BOLD;
    SendMessage(m_hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    // bold the kids
    if (m_pMsg->FindFirst(&fb, &hBody)==S_OK)
        {
        do
            {
            // italic the boundaries and bold the headers
            m_pMsg->GetBodyOffsets(hBody, &rOffset);
            
            Edit_SetSel(m_hwndEdit, rOffset.cbBoundaryStart, rOffset.cbHeaderStart);
            cf.dwEffects=CFE_ITALIC;
            SendMessage(m_hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

            Edit_SetSel(m_hwndEdit, rOffset.cbHeaderStart, rOffset.cbBodyStart);
            cf.dwEffects=CFE_BOLD;
            SendMessage(m_hwndEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
            
            }
        while (m_pMsg->FindNext(&fb, &hBody)==S_OK);
        }
    return S_OK;
}



CREMenu::CREMenu()
{
    m_hwndEdit = NULL;
    m_cRef = 1;
}


CREMenu::~CREMenu()
{
}


ULONG CREMenu::AddRef()
{
    return ++m_cRef;
}

ULONG CREMenu::Release()
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }
    return m_cRef;
}

HRESULT CREMenu::QueryInterface(REFIID riid, LPVOID FAR * lplpObj)
{
    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (void*)(IUnknown*)this;
    else if (IsEqualIID(riid, IID_IRichEditOleCallback))
        *lplpObj = (void*)(IRichEditOleCallback*)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CREMenu::Init(HWND hwndEdit, int idMenu)
{
    m_hwndEdit = hwndEdit;
    m_idMenu = idMenu;
    return S_OK;
}

HRESULT CREMenu::GetNewStorage (LPSTORAGE FAR * ppstg)
{
    return E_NOTIMPL;
}

HRESULT CREMenu::GetInPlaceContext( LPOLEINPLACEFRAME *lplpFrame, LPOLEINPLACEUIWINDOW *lplpDoc, 
                                        LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    return E_NOTIMPL;
}

HRESULT CREMenu::ShowContainerUI(BOOL fShow)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::QueryInsertObject(LPCLSID lpclsid, LPSTORAGE lpstg, LONG cp)
{
    return E_NOTIMPL;
}

HRESULT CREMenu::DeleteObject(LPOLEOBJECT lpoleobj)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::QueryAcceptData(   LPDATAOBJECT pdataobj, CLIPFORMAT *pcfFormat,  DWORD reco, 
                                        BOOL fReally,  HGLOBAL hMetaPict)
{
    *pcfFormat = CF_TEXT;
    return S_OK;
}


HRESULT CREMenu::ContextSensitiveHelp(BOOL fEnterMode)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::GetClipboardData(CHARRANGE *pchrg, DWORD reco, LPDATAOBJECT *ppdataobj)
{
    HRESULT     hr;
    DATAOBJINFO *pDataInfo=NULL;
    FORMATETC   fetc;
    TEXTRANGE   txtRange;
    CHARRANGE   chrg;
    LONG        cchStart=0,
                cchEnd=0,
                cchMax=0,
                cchLen=0;
    LPSTR       pszData=0;    

    *ppdataobj = NULL;

    if (pchrg)
    {
        chrg = *pchrg;
        
        cchMax = (LONG) SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);

        // validate the range
        chrg.cpMin = max(0, chrg.cpMin);
        chrg.cpMin = min(cchMax, chrg.cpMin);
        
        if(chrg.cpMax < 0 || chrg.cpMax > cchMax)
            chrg.cpMax = cchMax;
    }
    else
    {
        // if no charrange, then get the current selection
        SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&cchStart, (LPARAM)&cchEnd);
        chrg.cpMin = cchStart;
        chrg.cpMax = cchEnd;
    }
    
    if (chrg.cpMin >= chrg.cpMax)
    {
        *ppdataobj = NULL;
        return chrg.cpMin == chrg.cpMax ? NOERROR : E_INVALIDARG;
    }


    cchLen = chrg.cpMax - chrg.cpMin;

    if (!MemAlloc((LPVOID *)&pszData, cchLen+1))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    txtRange.chrg = chrg;
    txtRange.lpstrText = pszData;

    SendMessage(m_hwndEdit, EM_GETTEXTRANGE, 0, (LPARAM)&txtRange);

    if (!MemAlloc((LPVOID*)&pDataInfo, sizeof(DATAOBJINFO)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    
    SETDefFormatEtc(pDataInfo->fe, CF_TEXT, TYMED_HGLOBAL);
    
    pDataInfo->cbData = cchLen+1;
    pDataInfo->pData = pszData;

    hr = CreateDataObject(pDataInfo, 1, (PFNFREEDATAOBJ)FreeViewSrcDataObj, ppdataobj);
    if (FAILED(hr))
        goto error;

    pDataInfo = NULL;   // freed by dataobject
    pszData = NULL;

error:
    SafeMemFree(pszData);
    SafeMemFree(pDataInfo);
    return hr;
}

HRESULT CREMenu::GetDragDropEffect(BOOL fDrag,  DWORD grfKeyState, LPDWORD pdwEffect)
{
	return E_NOTIMPL;
}

HRESULT CREMenu::GetContextMenu(WORD seltype, LPOLEOBJECT pOleObject, CHARRANGE *pchrg, HMENU *phMenu)
{
    HMENU           hMenu;

    if (!(hMenu=LoadPopupMenu(m_idMenu)))
        return E_OUTOFMEMORY;

    if (SendMessage(m_hwndEdit, EM_SELECTIONTYPE, 0, 0)==SEL_EMPTY)
    {
        EnableMenuItem(hMenu, idmCopy, MF_GRAYED|MF_BYCOMMAND);
        EnableMenuItem(hMenu, idmCut, MF_GRAYED|MF_BYCOMMAND);
    }

    if (GetWindowLong(m_hwndEdit, GWL_STYLE) & ES_READONLY)
    {
        EnableMenuItem(hMenu, idmCut, MF_GRAYED|MF_BYCOMMAND);
        EnableMenuItem(hMenu, idmPaste, MF_GRAYED|MF_BYCOMMAND);
    }

    *phMenu=hMenu;
    return S_OK;
}





ULONG CMsgSource::AddRef()
{
    return ++m_cRef;
};

ULONG CMsgSource::Release()
{
    m_cRef--;
    if (m_cRef == 0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


CMsgSource::CMsgSource()
{
    m_hwnd = 0;
    m_cRef = 1;
    m_fColor=0;
    m_fDisabled=0;
    m_pCmdTargetParent=0;
    m_pszLastText = 0;
}

CMsgSource::~CMsgSource()
{
    SafeMemFree(m_pszLastText);
}


HRESULT CMsgSource::Init(HWND hwndParent, int id, IOleCommandTarget *pCmdTargetParent)
{
    CHARFORMAT  cf;
    CREMenu     *pMenu;

    DemandLoadRichEdit();

    m_hwnd = CreateWindowEx(WS_EX_CLIENTEDGE,
                                "RICHEDIT", 
                                NULL,
                                WS_CHILD|WS_TABSTOP|ES_MULTILINE|ES_SAVESEL|ES_WANTRETURN|WS_VSCROLL|ES_AUTOVSCROLL,
                                0, 0, 0, 0,
                                hwndParent, 
                                (HMENU)IntToPtr(id), 
                                g_hLocRes, 
                                NULL);
    if (!m_hwnd)
        return E_FAIL;

    ZeroMemory((LPVOID)&cf, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_SIZE|CFM_COLOR|CFM_FACE|CFM_BOLD|
                CFM_ITALIC|CFM_UNDERLINE|CFM_STRIKEOUT;
    lstrcpy(cf.szFaceName, "Courier New");
    cf.yHeight = 200;
    cf.crTextColor = 0;
    cf.dwEffects |= CFE_AUTOCOLOR;
    cf.bPitchAndFamily = FIXED_PITCH;
    cf.bCharSet = DEFAULT_CHARSET;
    cf.yOffset = 0;
    SendMessage(m_hwnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
    SendMessage(m_hwnd, EM_SETEVENTMASK, 0, ENM_KEYEVENTS|ENM_CHANGE|ENM_SELCHANGE|ENM_UPDATE);
    SendMessage(m_hwnd, EM_SETOPTIONS, ECOOP_OR, ECO_SELECTIONBAR);

    pMenu = new CREMenu();
    if (pMenu)
    {
        pMenu->Init(m_hwnd, idmrCtxtViewSrc);
        SendMessage(m_hwnd, EM_SETOLECALLBACK, 0, (LPARAM)pMenu);
        pMenu->Release();
    }

    m_pCmdTargetParent = pCmdTargetParent;  // loose reference, as parent never changes
    return S_OK;
}

HRESULT CMsgSource::Show(BOOL fOn, BOOL fColor)
{
    ShowWindow(m_hwnd, fOn?SW_SHOW:SW_HIDE);
    m_fDisabled = !fColor;
    return S_OK;
}

    
HRESULT CMsgSource::Load(IStream *pstm)
{
    RicheditStreamIn(m_hwnd, pstm, SF_TEXT);
    Edit_SetModify(m_hwnd, FALSE);
    return S_OK;
}

HRESULT CMsgSource::IsDirty()
{
    return Edit_GetModify(m_hwnd) ? S_OK : S_FALSE;
}


HRESULT CMsgSource::Save(IStream **ppstm)
{
    if (MimeOleCreateVirtualStream(ppstm)!=S_OK)
        return E_FAIL;

    RicheditStreamOut(m_hwnd, *ppstm, SF_TEXT);
    return S_OK;
}

HRESULT CMsgSource::SetRect(RECT *prc)
{
    SetWindowPos(m_hwnd, 0, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOACTIVATE|SWP_NOZORDER);
    return S_OK;
}

HRESULT CMsgSource::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}


HRESULT CMsgSource::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   uCmd;

    if (pguidCmdGroup == NULL)
        {
        for (uCmd=0;uCmd<cCmds; uCmd++)
            {
            prgCmds[uCmd].cmdf = 0;
            
            if (GetFocus() == m_hwnd)
                {
                switch (prgCmds[uCmd].cmdID)
                    {
                    case OLECMDID_CUT:
                    case OLECMDID_COPY:
                        if (SendMessage(m_hwnd, EM_SELECTIONTYPE, 0, 0)!=SEL_EMPTY)
                            prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;

                    case OLECMDID_SELECTALL:
                        prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;

                    case OLECMDID_UNDO:
                        if (SendMessage(m_hwnd, EM_CANUNDO, 0, 0))
                            prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;

                    case OLECMDID_PASTE:
                        if (SendMessage(m_hwnd, EM_CANPASTE, 0, 0))
                            prgCmds[uCmd].cmdf = MSOCMDF_ENABLED;
                        break;
                    }
                }
            }
        return S_OK;
        }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEdit))
            {
            // disable all these commands
            for (uCmd=0; uCmd < cCmds; uCmd++)
                {
                // bail if we see MECMDID_SHOWSOURCETABS and goto default handler
                if (prgCmds[uCmd].cmdID == MECMDID_SHOWSOURCETABS)
                    return OLECMDERR_E_UNKNOWNGROUP;

                prgCmds[uCmd].cmdf = 0;
                }
            return S_OK;
            }
        else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_Forms3))
            {
            // disable all these commands
            for (uCmd=0; uCmd < cCmds; uCmd++)
                {
                prgCmds[uCmd].cmdf = 0;
                }
            return S_OK;
            }

    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CMsgSource::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    if (pguidCmdGroup == NULL)
        {
        switch (nCmdID)
            {
            case OLECMDID_CUT:
                SendMessage(m_hwnd, WM_CUT, 0, 0);
                return S_OK;

            case OLECMDID_COPY:
                SendMessage(m_hwnd, WM_COPY, 0, 0);
                return S_OK;

            case OLECMDID_PASTE:
                SendMessage(m_hwnd, WM_PASTE, 0, 0);
                return S_OK;

            case OLECMDID_SELECTALL:
                SendMessage(m_hwnd, EM_SETSEL, 0, -1);
                return S_OK;

            case OLECMDID_UNDO:
                SendMessage(m_hwnd, EM_UNDO, 0, 0);
                return S_OK;
            
            default:
                return OLECMDERR_E_NOTSUPPORTED;
            }
        }
    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CMsgSource::OnWMNotify(WPARAM wParam, NMHDR* pnmhdr, LRESULT *plRet)
{
    MSGFILTER   *pmf;

    *plRet = 0;

    if (pnmhdr->hwndFrom != m_hwnd)
        return S_FALSE;

    switch (pnmhdr->code)
    {
        case EN_MSGFILTER:
        {
            // if we get a control-tab, then richedit snags this and inserts a
            // tab char, we hook the wm_keydown and never pass to richedit
            if (((MSGFILTER *)pnmhdr)->msg == WM_KEYDOWN &&
                ((MSGFILTER *)pnmhdr)->wParam == VK_TAB && 
                (GetKeyState(VK_CONTROL) & 0x8000))
            {
                *plRet = TRUE;
                return S_OK;
            }
        }
        break;

        case EN_SELCHANGE:
        {
            if (m_pCmdTargetParent)
                m_pCmdTargetParent->Exec(NULL, OLECMDID_UPDATECOMMANDS, NULL, NULL, NULL);
            return S_OK;
        }

    }

    return S_FALSE;
}

static HACCEL   g_hAccelSrc=0;

HRESULT CMsgSource::TranslateAccelerator(LPMSG lpmsg)
{
    MSG msg;

    if (GetFocus() != m_hwnd)
        return S_FALSE;

    if (!g_hAccelSrc)   // cache this as NT4 SP3 leaks internal accerator tables
        g_hAccelSrc = LoadAccelerators(g_hLocRes, MAKEINTRESOURCE(idacSrcView));

    // see if it one of ours
    if (::TranslateAcceleratorWrapW(GetParent(m_hwnd), g_hAccelSrc, &msg))
        return S_OK;


    // insert tabs
    if (lpmsg->message == WM_KEYDOWN &&
        lpmsg->wParam == VK_TAB &&
        !(GetKeyState(VK_CONTROL) & 0x8000) &&
        !(GetKeyState(VK_SHIFT) & 0x8000))
        {
        Edit_ReplaceSel(m_hwnd, TEXT("\t"));
        return S_OK;
        }

    return S_FALSE;
}


HRESULT CMsgSource::OnWMCommand(HWND hwnd, int id, WORD wCmd)
{
    if (GetFocus() == m_hwnd)
    {
        // context menu commands
        switch (id)
        {
            case idmTab:
                Edit_ReplaceSel(m_hwnd, TEXT("\t"));
                return S_OK;

            case idmCopy:
                SendMessage(m_hwnd, WM_COPY, 0, 0);
                return S_OK;

            case idmPaste:
                SendMessage(m_hwnd, WM_PASTE, 0, 0);
                return S_OK;

            case idmCut:
                SendMessage(m_hwnd, WM_CUT, 0, 0);
                return S_OK;

            case idmUndo:
                SendMessage(m_hwnd, EM_UNDO, 0, 0);
                return S_OK;

            case idmSelectAll:
                SendMessage(m_hwnd, EM_SETSEL, 0, -1);
                return S_OK;

        }
    }

    if (hwnd != m_hwnd) // not our window
        return S_FALSE;

    if (wCmd == EN_CHANGE)
    {
        OnChange();
        return S_OK;
    }

    return S_FALSE;
}




HRESULT CMsgSource::HasFocus()
{
    return GetFocus() == m_hwnd ? S_OK : S_FALSE;
}

HRESULT CMsgSource::SetFocus()
{
    ::SetFocus(m_hwnd);
    return S_OK;
}


void CMsgSource::OnChange() 
{
	// batch up the change commands with a timer
    if (!m_fColor)
	    {
        KillTimer(GetParent(m_hwnd), idTimerEditChange);
		SetTimer(GetParent(m_hwnd), idTimerEditChange, 200, NULL);
	    }
}


HRESULT CMsgSource::OnTimer(WPARAM idTimer)
{
	CHARFORMAT	cf;
	int 		inTag = 0;
	BOOL		pastTag = FALSE;
	COLORREF	crTag = RGB(0x80, 0, 0x80);
	COLORREF	crInTag = RGB(0xFF, 0, 0);
	COLORREF	crNormal = RGB(0, 0, 0);
	COLORREF	crLiteral = RGB(0, 0, 0xFF);
	COLORREF	crHere;
	COLORREF	crLast = crNormal;
	int			i, n;
	int			nChange=0;
	BOOL		bHidden = FALSE;
	CHARRANGE	cr;
	int			ignoreTags = ENV_NORMAL;
	char		quote_1 = QUOTE_1;
	char		quote_2 = QUOTE_2;
    BOOL        fRestoreScroll=FALSE,
                fShowProgress=FALSE;
    DWORD       dwStartTime = GetTickCount();
    HCURSOR     hCur = NULL;
    DWORD       dwProgress=0,
                dwTmp;
    VARIANTARG  va;
    TCHAR       rgch[CCHMAX_STRINGRES],
                rgchFmt[CCHMAX_STRINGRES];
    LPSTR       pszText=0;
    int         cch;
    BOOL        fSetTimer=FALSE;

	// Save modificationness
	BOOL bModified = Edit_GetModify(m_hwnd);
		
    if (idTimer!=idTimerEditChange)
        return S_FALSE;

	// Kill outstanding timer
	KillTimer(GetParent(m_hwnd), idTimerEditChange);

	//
	// If the user is mousing around (say for scrolling) then don't drag down
	// his performance!
	//
	if (GetCapture())
	    {
		SetTimer(GetParent(m_hwnd), idTimerEditChange, 200, NULL);
		return S_OK;
	    }
	
    // Turn off the color syntax
	if (m_fDisabled)
	    {
		// Already all one color

		m_fColor = TRUE;

		// Save current selection and hide
		GetSel(&cr);
        HideSelection(TRUE, FALSE);
		bHidden = TRUE;
		
		SetSel(0, -1); // select all
		GetSelectionCharFormat(&cf);
		cf.dwMask = CFM_COLOR;
		cf.dwEffects = 0;
		cf.crTextColor = crNormal;
		SetSelectionCharFormat(&cf);
	    }
	else
	    { 
        // Start color fiddling
		// Get text, find the change
        
        if (_GetText(&pszText)!=S_OK)
            return E_FAIL;

		const char* start = (const char*)pszText;
		const char* old = (const char*) m_pszLastText;
		const char* s;

        for (s = start; *s && old && *old && *s == *old; s++, old++)
			continue;

		// If no change, nothing to do
		if (*s == 0)
        {
			MemFree(pszText);
            return S_OK;
        }

		// Otherwise, track place where we'll start to examine colors for changes
		nChange = (int) (s - start);
		
		// Only examine 2000 chars at a time
		if (lstrlen(s) > 2000)
		{
            // Reset timer to process other characters
            fSetTimer = TRUE;
			
            // Truncate text so we only examine limited amount
			cch  = lstrlen(pszText);
			cch = min(cch, nChange + 2000);
			pszText[cch] = 0;
			start = (const char*)pszText;
		}
		
        SafeMemFree(m_pszLastText);
        m_pszLastText = pszText;

		m_fColor = TRUE;

		// Workaround for scrolling bug in REC 1.0
		if (GetFocus() == m_hwnd)
        {
            SendMessage(m_hwnd, EM_SETOPTIONS, ECOOP_XOR, ECO_AUTOVSCROLL);
            // BUGBUG: richedit1.0 on NT4 will remove the WS_VISIBLE bit when XORing ECO_AUTOVSCROLL
            // call show window after this to esure that the visible bit is displayed
            ShowWindow(m_hwnd, SW_SHOW);
            fRestoreScroll=TRUE;
        }

		const char* range = start;
		for (s = start; *s; s++)
		{
            // if we've been going for >2 seconds then show an hourglass and 
            // start showing progress
            if (hCur == NULL &&
                GetTickCount() >= dwStartTime + 2000)
            {
                hCur = SetCursor(LoadCursor(NULL, IDC_WAIT));
                if (m_pCmdTargetParent)
                {
                    fShowProgress=TRUE;
                    *rgchFmt=NULL;
                    LoadString(g_hLocRes, idsColorSourcePC, rgchFmt, ARRAYSIZE(rgchFmt));
                }
            }

            if (fShowProgress)
            {
                dwTmp = (DWORD) ((((s - start))*100)/cch);
                if (dwTmp > dwProgress)
                {
                    // did overall percentage change, if so update statusbar
                    dwProgress = dwTmp;

                    wsprintf(rgch, rgchFmt, dwProgress);
                    va.vt = VT_BSTR;
                    if (HrLPSZToBSTR(rgch, &va.bstrVal)==S_OK)
                    {
                        m_pCmdTargetParent->Exec(NULL, OLECMDID_SETPROGRESSTEXT, 0, &va, NULL);
                        SysFreeString(va.bstrVal);
                    }
                }
            }

            // entering/leaving string literal in tag
			if (inTag && (*s == quote_1 || *s == quote_2))
			{
				if (ignoreTags == ENV_QUOTE ||
					ignoreTags == ENV_QUOTE_SCR) //leaving
				{
					ignoreTags = (ignoreTags == ENV_QUOTE) ?
								ENV_NORMAL : ENV_SCRIPT;
					quote_1 = QUOTE_1;
					quote_2 = QUOTE_2;
				}
				else if (ignoreTags == ENV_NORMAL) // entering
				{
					ignoreTags = ENV_QUOTE;
					quote_1 = quote_2 = *s;
				}
				else if (ignoreTags == ENV_SCRIPT) // entering
				{
					ignoreTags = ENV_QUOTE_SCR;
					quote_1 = quote_2 = *s;
				}
			}
			// Update leaving tag
			else if (*s == '>')
			{
				switch (ignoreTags) // end of env?
				{
				case ENV_DENALI:
					if (s-1>=start && *(s-1) == '%')
						ignoreTags = ENV_NORMAL;
					break;
				
                case ENV_COMMENT:
					if (s-2>=start && *(s-1) == '-' && *(s-2) == '-')
						ignoreTags = ENV_NORMAL;
					break;
				
                case ENV_SCRIPT:
					if (s-7>=start &&
						StrCmpNIA(s-7, "/SCRIPT", 7)==0)
					{
						ignoreTags = ENV_NORMAL;
						// Color </SCRIPT> properly
						pastTag = TRUE;
						inTag = 0;
						s-=8;
					}
					else // end of <script ...>
						inTag = 0;
					break;
				
                default: // <SCRIPT> (no attribs)
					if (inTag && s-7>=start &&
						StrCmpNIA(s-7, "<SCRIPT", 7)==0)
					{
						ignoreTags = ENV_SCRIPT;
						pastTag = TRUE;
						inTag = 0;
					}
				}
				if (ignoreTags == ENV_NORMAL)
				{
					pastTag = TRUE;
					inTag--;
					if (inTag < 0)
						inTag = 0;
				}
			}

			// Check color
			crHere = inTag ? 
				(pastTag ? 
					(  (*s != '\"' &&
						(ignoreTags == ENV_QUOTE ||	ignoreTags == ENV_QUOTE_SCR)
						) ?
						 crLiteral : crInTag  )
					: crTag)
				: crNormal;

			// If different from last, need to update previous range
			if (crHere != crLast)
			{
				i = (int) (range - start);
				n = (int)(s - range);

				if (i+n >= nChange)
				{
					if (!bHidden)
					{
						// Save current selection and hide
						GetSel(&cr);
						HideSelection(TRUE, FALSE);
						bHidden = TRUE;
					}

					SetSel(i, i+n);
					GetSelectionCharFormat(&cf);
					// If color over range varies or doesn't match, need to apply color
					if ((cf.dwMask & CFM_COLOR) == 0 || cf.crTextColor != crLast)
					{
						cf.dwMask = CFM_COLOR;
						cf.dwEffects = 0;
						cf.crTextColor = crLast;
						SetSelectionCharFormat(&cf);
					}
				}

				// Reset range
				range = s;
				crLast = crHere;
			}

			// Now update entering tag
			if (*s == '<' && ignoreTags == ENV_NORMAL)
			{
				inTag++;
				if (inTag == 1)
					pastTag = FALSE;
			}
			else if (inTag && !pastTag && isspace(*s))
			{
				pastTag = TRUE;
				if (s-1 >= start && *(s-1) == '%')
					ignoreTags = ENV_DENALI;
				else if (s-3 >= start && *(s-1) == '-' 
					&& *(s-2) == '-' && *(s-3) == '!')
					ignoreTags = ENV_COMMENT;
				else if (inTag && s-7>=start &&
						StrCmpNIA(s-7, "<SCRIPT", 7)==0)
					ignoreTags = ENV_SCRIPT;
			}
		}

        // Make sure last range is right
		i = (int) (range - start);
		n = (int) (s - range);

		if (i+n >= nChange)
		{
			if (!bHidden)
			{
				// Save current selection and hide
				GetSel(&cr);
				HideSelection(TRUE, FALSE);
				bHidden = TRUE;
			}
			SetSel(i, i+n);
			GetSelectionCharFormat(&cf);
			// If color over range varies or doesn't match, need to apply color
			if ((cf.dwMask & CFM_COLOR) == 0 || cf.crTextColor != crLast)
			{
				cf.dwMask = CFM_COLOR;
				cf.dwEffects = 0;
				cf.crTextColor = crLast;
				SetSelectionCharFormat(&cf);
			}
		}
		// Workaround for scrolling bug in REC 1.0
		if (fRestoreScroll)
        {
            // BUGBUG: richedit1.0 on NT4 will remove the WS_VISIBLE bit when ORing ECO_AUTOVSCROLL
            // call show window after this to esure that the visible bit is displayed
			SendMessage(m_hwnd, EM_SETOPTIONS, ECOOP_OR, ECO_AUTOVSCROLL);
            ShowWindow(m_hwnd, SW_SHOW);
        }
	} // End color fiddling

	// Restore selection visibility
	if (bHidden)
	{
		SetSel(cr.cpMin, cr.cpMax);
		HideSelection(FALSE, FALSE);
	}
	
	// Restore modificationness
	if (!bModified)
		Edit_SetModify(m_hwnd, bModified);

    if (fShowProgress)
    {
        va.vt = VT_BSTR;
        va.bstrVal=NULL;
        m_pCmdTargetParent->Exec(NULL, OLECMDID_SETPROGRESSTEXT, 0, &va, NULL);
    }

    if (hCur)
        SetCursor(hCur);

    m_fColor = FALSE;
    if (fSetTimer)
        SetTimer(GetParent(m_hwnd), idTimerEditChange, 200, NULL);
    return S_OK;
}

void CMsgSource::HideSelection(BOOL fHide, BOOL fChangeStyle)
{
    SendMessage(m_hwnd, EM_HIDESELECTION, fHide, fChangeStyle);
}

void CMsgSource::GetSel(CHARRANGE *pcr)
{
    SendMessage(m_hwnd, EM_EXGETSEL, 0, (LPARAM)pcr);
}

void CMsgSource::SetSel(int nStart, int nEnd)
{
    SendMessage(m_hwnd, EM_SETSEL, nStart, nEnd);
}

extern BOOL                g_fCanEditBiDi;
void CMsgSource::GetSelectionCharFormat(CHARFORMAT *pcf)
{
    pcf->cbSize = sizeof(CHARFORMAT);
    pcf->dwMask = CFM_BOLD|CFM_COLOR|CFM_FACE|CFM_ITALIC|CFM_OFFSET|CFM_PROTECTED|CFM_SIZE|CFM_STRIKEOUT|CFM_UNDERLINE;

    SendMessage(m_hwnd, EM_GETCHARFORMAT, TRUE, (LPARAM)pcf);

    // On BiDi win9x, DEFAULT_CHARSET is treated as ANSI !!
    // need to reassign charset (Arabic for Arabic and Hebrew for Hebrew)
    if(g_fCanEditBiDi && (!pcf->bCharSet || pcf->bCharSet == DEFAULT_CHARSET))
    {
        // The best way to determine the OS language is from system font charset
        LOGFONT        lfSystem;
        static BYTE    lfCharSet = 0 ; // RunOnce
        if(!lfCharSet && GetObject(GetStockObject(SYSTEM_FONT), sizeof(lfSystem), (LPVOID)& lfSystem))
        {
            if (lfSystem.lfCharSet == ARABIC_CHARSET
                || lfSystem.lfCharSet == HEBREW_CHARSET)
            {
                lfCharSet = lfSystem.lfCharSet; // Arabic/Hebrew charset for Arabic/Hebrew OS
            }
        }
        pcf->bCharSet = lfCharSet;
    }
 }


void CMsgSource::SetSelectionCharFormat(CHARFORMAT *pcf)
{
    pcf->cbSize = sizeof(CHARFORMAT);
    
    SendMessage(m_hwnd, EM_SETCHARFORMAT, TRUE, (LPARAM)pcf);
}


HRESULT CMsgSource::SetDirty(BOOL fDirty)
{
    Edit_SetModify(m_hwnd, fDirty);
    return S_OK;
}



HRESULT CMsgSource::_GetText(LPSTR *ppsz)
{
    LPSTR   psz;
    int     cch;

    *ppsz = 0;

    cch = GetWindowTextLength(m_hwnd);
        
    if (!MemAlloc((LPVOID *)&psz, sizeof(TCHAR) * cch+1))
        return E_OUTOFMEMORY;

    *psz = 0;
    GetWindowText(m_hwnd, psz, cch);
    *ppsz = psz;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\bindstm.h ===
// --------------------------------------------------------------------------------
// BINDSTM.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BINDSTM_H
#define __BINDSTM_H

// --------------------------------------------------------------------------------
// Depends
// --------------------------------------------------------------------------------
#include "vstream.h"

// --------------------------------------------------------------------------------
// CBindStream
// --------------------------------------------------------------------------------
class CBindStream : public IStream
{
public:
    // -------------------------------------------------------------------------
    // Construction
    // -------------------------------------------------------------------------
    CBindStream(IStream *pSource);
    ~CBindStream(void);

    // -------------------------------------------------------------------------
    // IUnknown
    // -------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // -------------------------------------------------------------------------
    // IStream
    // -------------------------------------------------------------------------
    STDMETHODIMP Read(void HUGEP_16 *, ULONG, ULONG *);
    STDMETHODIMP Seek(LARGE_INTEGER, DWORD, ULARGE_INTEGER *);
    STDMETHODIMP Stat(STATSTG *, DWORD);
    STDMETHODIMP Write(const void HUGEP_16 *, ULONG, ULONG *) {
        return TrapError(STG_E_ACCESSDENIED); }
    STDMETHODIMP SetSize(ULARGE_INTEGER) {
        return E_NOTIMPL; }
    STDMETHODIMP CopyTo(LPSTREAM, ULARGE_INTEGER, ULARGE_INTEGER *, ULARGE_INTEGER *) {
        return E_NOTIMPL; }
    STDMETHODIMP Commit(DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Revert(void) {
        return E_NOTIMPL; }
    STDMETHODIMP LockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER, ULARGE_INTEGER, DWORD) {
        return E_NOTIMPL; }
    STDMETHODIMP Clone(LPSTREAM *) {
        return E_NOTIMPL; }

    // -------------------------------------------------------------------------
    // CBindStream Methods
    // -------------------------------------------------------------------------
    void HandsOffSource(void) {
        EnterCriticalSection(&m_cs);
        SafeRelease(m_pSource);
        LeaveCriticalSection(&m_cs);
    }

    // -------------------------------------------------------------------------
    // CBindStream Debug Methods
    // -------------------------------------------------------------------------
#ifdef DEBUG
    void DebugDumpDestStream(LPCSTR pszFile);
#endif

private:
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
#ifdef DEBUG
    void DebugAssertOffset(void);
#endif

private:
    // -------------------------------------------------------------------------
    // Private Data
    // -------------------------------------------------------------------------
    LONG             m_cRef;            // Reference count
    CVirtualStream   m_cDest;           // The Destination Stream
    IStream         *m_pSource;         // The Source Stream
    DWORD            m_dwDstOffset;     // CBindStream Offset
    DWORD            m_dwSrcOffset;     // Source Offset
#ifdef DEBUG
    IStream         *m_pDebug;
#endif
    CRITICAL_SECTION m_cs;              // Critical Section for m_pStream
};

#endif // __BINDSTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\binhex.cpp ===
// --------------------------------------------------------------------------------
// Binxhex.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
//
// Copied from \\tdsrc\src1911\mapi\src\imail2\decoder.cpp
// Copied from \\tdsrc\src1911\mapi\src\imail2\encoder.cpp
// Copied from \\tdsrc\src1911\mapi\src\imail2\_encoder.h
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "binhex.h"
#include <shlwapi.h>

// --------------------------------------------------------------------------------
// Module data
// --------------------------------------------------------------------------------
#ifdef MAC
const CHAR szBINHEXHDRLINE[] = "(This file must be converted with BinHex 4.0)\n\r\n\r";
#else   // !MAC
const CHAR szBINHEXHDRLINE[] = "(This file must be converted with BinHex 4.0)\r\n\r\n";
#endif  // MAC
const ULONG cbBINHEXHDRLINE = lstrlen( szBINHEXHDRLINE );
static BOOL g_bCreatorTypeInit = FALSE;    // TRUE ->array initialized
sCreatorType * g_lpCreatorTypes    = NULL;     // ptr.to Creator-Type pairs
static int g_cCreatorTypes     = 0;        // # of Creator-Type pairs

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
void CalcCRC16(LPBYTE lpbBuff, ULONG cBuff, WORD * wCRC);
BOOL bIsMacFile(DWORD dwCreator, DWORD dwType);
VOID ReadCreatorTypes(void);

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::CBinhexEncoder
//
// Description:
//                  Ctor
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
CBinhexEncoder::CBinhexEncoder(void)
{
	m_fConfigured = FALSE;
    m_cbLineLength = cbLineLengthUnlimited;
    m_cbLeftOnLastLine = m_cbLineLength;
    m_cMaxLines = 0;
    m_cLines = 0;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::~CBinhexEncoder
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
CBinhexEncoder::~CBinhexEncoder( void )
{
#if defined (DEBUG) && defined (BINHEX_TRACE)

    if ( m_lpstreamEncodeRLE )
    {
        m_lpstreamEncodeRLE->Commit( 0 );
        m_lpstreamEncodeRLE->Release();
    }

    if ( m_lpstreamEncodeRAW )
    {
        m_lpstreamEncodeRAW->Commit( 0 );
        m_lpstreamEncodeRAW->Release();
    }
#endif
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrConfig
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrConfig( IN CB cbLineLength, IN C cMaxLines,
        IN void * pvParms )
{
    // Is this a repeat call?

    if (m_fConfigured)
    {
        return ERROR_ALREADY_INITIALIZED;
    }

    // Objects of this class may have pvParms point to a various additional
    // configuration values to consider when encoding.

    if ( pvParms == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    m_cbLineLength          = cbLineLength;
    m_lpmacbinHdr           = (LPMACBINARY)pvParms;
    m_ulAccum               = 0;
    m_cAccum                = 0;
    m_cbRepeat              = 0;
    m_bRepeat               = BINHEX_INVALID;
    m_wCRC                  = 0;
    m_cbFork                = 0;
    m_cbLeftInFork          = 0;
    m_eBinHexStateEnc       = sHEADER;
    m_cbProduced            = 0;
    m_cbConsumed            = 0;
    m_pbWrite               = NULL;
    m_cbLeftInOutputBuffer  = 0;
    m_cbLeftInInputBuffer   = 0;
    m_bPrev                 = BINHEX_INVALID;
    m_cbWrite               = 0;
    m_cbLine                = 0;
    m_fHandledx90           = FALSE;
    m_cbPad                 = 0;

#if defined (DEBUG) && defined (BINHEX_TRACE)
{
    CHAR        szFilePath[MAX_PATH];
    CHAR        szPath[MAX_PATH];
    ULONG       ulDirLen            = 0;
    HRESULT     hr                  = hrSuccess;

    ulDirLen = GetPrivateProfileString( "IMAIL2 ITP",
                                        "InboundFilePath",
                                        "",
                                        (LPSTR) szFilePath,
                                        sizeof( szFilePath ),
                                        "mapidbg.ini");

    if ( ulDirLen ==  0 )
    {
        // Default to %TEMP%\IMAIL

        ulDirLen = GetTempPath( sizeof( szFilePath ), szFilePath );

        AssertSz( ulDirLen < sizeof( szFilePath), "Temp directory name too long" );

        memcpy( szFilePath + ulDirLen, "imail", lstrlen( "imail" ) + 1 );
        ulDirLen += lstrlen( "imail" );
    }

    // Open stream on file for input file

    lstrcat( szFilePath, "\\" );
    lstrcpy( szPath, szFilePath );
    lstrcat( szFilePath,  "enc_rle.rpt" );

    hr = OpenStreamOnFile( MAPIAllocateBuffer, MAPIFreeBuffer,
            STGM_READWRITE | STGM_CREATE,
            szFilePath, NULL, &m_lpstreamEncodeRLE );

    if ( hr )
        AssertSz( FALSE, "Debug encode stream failed to initialize\n" );

    lstrcpy (szFilePath, szPath );
    lstrcat( szFilePath,  "enc_raw.rpt" );

    hr = OpenStreamOnFile( MAPIAllocateBuffer, MAPIFreeBuffer,
            STGM_READWRITE | STGM_CREATE,
            szFilePath, NULL, &m_lpstreamEncodeRAW );

    if ( hr )
        AssertSz( FALSE, "Debug encode stream failed to initialize\n" );
}
#endif

    m_fConfigured   = fTrue;

    return ERROR_SUCCESS;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrEmit
// Description:
//
// Parameters:
// Returns:
// Effects:
//
// Notes:
//      Handle Data Fork
//      Resource fork.
//
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrEmit( IN PB pbRead, IN OUT CB * pcbRead, OUT PB pbWrite,
        IN OUT CB * pcbWrite )
{
    HRESULT     hr                      = ERROR_SUCCESS;
    CB          cbHeader                = 0;
    CB          cbToProcess;
    CB          cbInputCheckPoint       = 0;
    CB          cbOut;
    CB          cb;
    BYTE        rgbHeader[ cbMIN_BINHEX_HEADER_SIZE + 64 ];

    m_cbConsumed            = 0;
    m_cbProduced            = 0;
    m_cbLeftInOutputBuffer  = 0;
    m_cbLeftInInputBuffer   = 0;


    // Have to be initialized first

    if ( !m_fConfigured )
    {
        return ERROR_BAD_COMMAND;
    }

    // Handle common 'bad parameter' errors

    if ( !pbRead || !pbWrite || !pcbRead || !pcbWrite )
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Repeated calls after maximum number of output lines were generated
    // will not go through

    if ( FMaxLinesReached() )
    {
        *pcbRead = *pcbWrite = 0;
        return ERROR_SUCCESS;
    }

    // If line length is unlimited, set m_cbLeftOnLastLine to be equal to
    // the length of the input buffer

    if ( !FLineLengthLimited() )
    {
        m_cbLeftOnLastLine = *pcbWrite;
    }

    m_pbWrite = pbWrite;
    m_cbWrite = *pcbWrite;

    while ( TRUE )
    {
        m_cbLeftInInputBuffer  = *pcbRead - m_cbConsumed;
        m_cbLeftInOutputBuffer = *pcbWrite - m_cbProduced;

        // If we have room in the output buffer keep going if in sEnd and no input left

        if ( 0 == m_cbLeftInOutputBuffer || (0 == m_cbLeftInInputBuffer && sEND != m_eBinHexStateEnc) )
        {
                goto Cleanup;
        }

        switch ( m_eBinHexStateEnc )
        {
            case sHEADER:
            {
                // Output BinHex Header line

                CopyMemory( pbWrite, szBINHEXHDRLINE, cbBINHEXHDRLINE );
                m_cbProduced += cbBINHEXHDRLINE;
                m_cLines += 2;

                // Output leading ':'

                m_pbWrite[m_cbProduced++] = ':';
                ++m_cbLine;

                // Output MACBIN Header; Header filename length

                rgbHeader[cbHeader++] = m_lpmacbinHdr->cchFileName;

                // Header filename

                CopyMemory( rgbHeader + cbHeader, m_lpmacbinHdr->rgchFileName, m_lpmacbinHdr->cchFileName );
                cbHeader += m_lpmacbinHdr->cchFileName;

                // Null terminate filename

                rgbHeader[cbHeader++] = '\0';

                // Macfile TYPE

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->dwType, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                // Macfile CREATOR

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->dwCreator, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                // Macfile FLAGS

                rgbHeader[cbHeader++] = m_lpmacbinHdr->bFinderFlags;
                rgbHeader[cbHeader++] = m_lpmacbinHdr->bFinderFlags2;

                // Macfile Fork lengths

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->lcbDataFork, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                CopyMemory( rgbHeader + cbHeader, (LPBYTE)&m_lpmacbinHdr->lcbResourceFork, sizeof(DWORD) );
                cbHeader += sizeof(DWORD);

                // Calculate the binhex header CRC

                CalcCRC16( rgbHeader, cbHeader, &m_wCRC );
                CalcCRC16( (LPBYTE)&wZero, sizeof(WORD), &m_wCRC );

                rgbHeader[cbHeader++] = HIBYTE( m_wCRC );
                rgbHeader[cbHeader++] = LOBYTE( m_wCRC );

                // BinHex the header into pbWrite.  The initial assumption is that
                // the buffer is going to big enough to encode the header.
                // Output goes into m_pbWrite.

                cbOut = 0;
                hr = HrBinHexBuffer( rgbHeader, cbHeader, &cbOut );

                // setup for the data fork

                m_eBinHexStateEnc = sDATA;
                m_cbFork = NATIVE_LONG_FROM_BIG( (LPBYTE)&m_lpmacbinHdr->lcbDataFork );
                m_cbLeftInFork = m_cbFork;
                m_wCRC = 0;
            }

                break;

            case sDATA:
            {
                // determine how much we can process

                cbToProcess = m_cbLeftInFork < m_cbLeftInInputBuffer ? m_cbLeftInFork : m_cbLeftInInputBuffer;
                cbInputCheckPoint = m_cbConsumed;

                hr = HrBinHexBuffer( pbRead + cbInputCheckPoint, cbToProcess, &m_cbConsumed );

                CalcCRC16( pbRead + cbInputCheckPoint, m_cbConsumed - cbInputCheckPoint, &m_wCRC );

                m_cbLeftInFork -= m_cbConsumed - cbInputCheckPoint;

                // flush output buffer

                if ( hr )
                    goto Cleanup;

                if ( !m_cbLeftInFork )
                {
                    // write out the last CRC

                    CalcCRC16( (LPBYTE)&wZero, sizeof(WORD), &m_wCRC );

                    cbHeader = 0;

                    rgbHeader[cbHeader++] = HIBYTE( m_wCRC );
                    rgbHeader[cbHeader++] = LOBYTE( m_wCRC );

                    cbOut = 0;
                    hr = HrBinHexBuffer( rgbHeader, 2, &cbOut );

                    // discard padding

                    if ( m_cbFork % 128 )
                    {
                        cb = 128 - ( m_cbFork % 128 );

                        if ( *pcbRead - m_cbConsumed < cb )
                        {
                            DebugTrace( "Note: Support refilling input buffer to remove padding for Data\n" );

                            // need to pull in more data

                            m_cbPad = cb - (*pcbRead - m_cbConsumed);
                            m_cbConsumed -= (*pcbRead - m_cbConsumed);
                        }
                        else
                        {
                            m_cbConsumed = cb;
                        }
                    }

                    // Set up for resource for if there is one and  reset counters

                    m_cbFork = NATIVE_LONG_FROM_BIG( (LPBYTE)&m_lpmacbinHdr->lcbResourceFork );
                    m_cbLeftInFork = m_cbFork;

                    if ( !m_cbFork )
                    {
                        // handle 0 byte resource fork

                        m_eBinHexStateEnc = sEND;

                        // write out crc for 0 length

                        cbOut = 0;
                        hr = HrBinHexBuffer( (LPBYTE)&wZero, sizeof(WORD), &cbOut );
                    }
                    else
                    {
                        m_eBinHexStateEnc = sRESOURCE;
                    }

                    m_wCRC = 0;
                }
            }
                break;

            case sRESOURCE:
            {
                if ( m_cbPad )
                {
                    m_cbConsumed -= m_cbPad;
                    m_cbPad = 0;
                }

                // determine how much we can process

                cbToProcess = m_cbLeftInFork < m_cbLeftInInputBuffer ? m_cbLeftInFork : m_cbLeftInInputBuffer;
                cbInputCheckPoint = m_cbConsumed;

                hr = HrBinHexBuffer( pbRead + cbInputCheckPoint, cbToProcess, &m_cbConsumed );

                CalcCRC16( pbRead + cbInputCheckPoint, m_cbConsumed - cbInputCheckPoint, &m_wCRC );

                m_cbLeftInFork -= m_cbConsumed - cbInputCheckPoint;

                // flush output buffer

                if ( hr )
                    goto Cleanup;

                if ( !m_cbLeftInFork )
                {
                    // write out the last CRC

                    CalcCRC16( (LPBYTE)&wZero, sizeof(WORD), &m_wCRC );

                    cbHeader = 0;

                    rgbHeader[cbHeader++] = HIBYTE( m_wCRC );
                    rgbHeader[cbHeader++] = LOBYTE( m_wCRC );

                    cbOut = 0;
                    hr = HrBinHexBuffer( rgbHeader, 2, &cbOut );

                    // discard padding

                    if ( m_cbFork % 128 )
                    {
                        cb = 128 - ( m_cbFork % 128 );

                        if ( *pcbRead - m_cbConsumed < cb )
                        {
                            DebugTrace( "Note: Support refilling input buffer to remove padding for Resource\n" );

                            // need to pull in more data

                            m_cbPad = cb - (*pcbRead - m_cbConsumed);
                            m_cbConsumed -= (*pcbRead - m_cbConsumed);
                        }
                        else
                        {
                            m_cbConsumed = cb;
                        }
                    }

                    // set up to terminate

                    m_eBinHexStateEnc = sEND;
                }
            }
                break;

            case sEND:
            {
                if ( m_cbPad )
                {
                    m_cbConsumed -= m_cbPad;
                    m_cbPad = 0;
                }

                if ( (*pcbWrite - m_cbProduced) == 0 )
                    break;

                // flush out any repeated chars

                if ( m_cbRepeat )
                {
                    if ( m_cbRepeat > 1 )
                    {
                        // bump up the repeat count so it reflects actual number of chars to repeat.

                        m_cbRepeat++;

                        // encode the repeat code char
                        // note that we've already emitted the char that we're supplying
                        // the repeat info for.

                        hr = HrBinHexByte( BINHEX_REPEAT );
                        m_bPrev = BINHEX_REPEAT;

                        Assert( m_cbRepeat <= 255 );

                        // encode repeat count

                        hr = HrBinHexByte( (BYTE)(m_cbRepeat) );
                        m_bPrev = (BYTE)(m_cbRepeat);
                    }
                    else
                    {
                        hr = HrBinHexByte( m_bRepeat );
                        m_bPrev = m_bRepeat;
                    }
                }

                // check to see if we have bits in the accumulator

                if ( m_cAccum )
                {
                    switch( m_cAccum )
                    {
                        case 1:
                            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x03) << 4)];
                            break;

                        case 2:
                            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x0f) << 2)];
                            break;

                        case 3:
                            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[m_bCurr & 0x3f];
                            break;

                        default:
                            AssertSz( FALSE, "HrBinHexByte: bad shift state\n" );
                            hr = ERROR_INVALID_PARAMETER;
                            goto Cleanup;
                    }
                }

                // tack on terminating ':'

                m_pbWrite[m_cbProduced++] = ':';
                m_cbConsumed = *pcbRead;

                // probably not so we would have to flush the
                // bits out.

                goto Cleanup;
            }
        }
    }

Cleanup:

    if (hr == ERROR_SUCCESS || hr == ERROR_MORE_DATA)
    {
        // Check that at least some processing was done.
        // Also this error is returned if we've exhausted the output
        // buffer.

        if ( (m_cbProduced == 0) || (m_cbLeftInInputBuffer > m_cbLeftInOutputBuffer)
            || (0 == m_cbLeftInOutputBuffer && sEND == m_eBinHexStateEnc) )
        {
            hr = ERROR_INSUFFICIENT_BUFFER;
        }
        else if ( m_cbConsumed < *pcbRead )
        {
            // Was all input processed?
            // Note that it is okay to encode only part of the input buffer
            // if maximum number of output lines was exceeded.

            hr = ERROR_MORE_DATA;
        }
    }

    // Report the new sizes to the caller.

    Assert( m_cbConsumed <= *pcbRead );
    Assert( m_cbProduced <= *pcbWrite );

    *pcbRead  = m_cbConsumed;
    *pcbWrite = m_cbProduced;

    return hr;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrBinHexBuffer
//
// Description:
//                  Output goes into m_pbWrite
//
// Parameters:
// Returns:
// Effects:
// Notes:
//
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrBinHexBuffer( IN LPBYTE lpbIn, IN CB cbIn, CB * lpcbConsumed )
{
    HRESULT     hr          = ERROR_SUCCESS;
    BOOL        fEndRepeat  = FALSE;
    CB          cbInUsed        = 0;

#if defined (DEBUG) && defined (BINHEX_TRACE)
    CB          cbOrigCbIn = cbIn;
#endif

    while ( cbIn && m_cbProduced + 5 < m_cbWrite )
    {
        // process the next char in input buffer

        m_bCurr = lpbIn[cbInUsed++];
        --cbIn;

        // check to see if we've seen this char before.  Don't repeat
        // if we just added a literal 0x90.

        if ( m_bCurr == m_bPrev && !m_fHandledx90 )
        {
            // m_cbRepeat is the count of  repeat chars after the initial char.
            // e.g., if there are two repeating chars, m_cbRepeat will be 1.
            // Note that we've already emitted the char after which to add the repeat
            // code and count.

            if ( m_cbRepeat < 254 )
            {
                m_cbRepeat++;
                m_bRepeat = m_bCurr;
                continue;
            }
        }

        m_fHandledx90 = FALSE;

        // we were counting repeating characters and the run stopped.

        if ( m_cbRepeat > 1 )
        {
            // set up to emit the run length encoding

            fEndRepeat = TRUE;
        }

        // Are we in repeat mode...

        if ( m_cbRepeat > 1 && fEndRepeat == TRUE )
        {
            // bump up the repeat count so it reflects actual number of chars to repeat.

            m_cbRepeat++;

            // if we're repeating 0x90 tack on the trailing 0x00

            if ( m_bRepeat == BINHEX_REPEAT )
            {
                hr = HrBinHexByte( '\0' );
            }

            // encode the repeat code char
            // note that we've already emitted the char that we're supplying
            // the repeat info for.

            hr = HrBinHexByte( BINHEX_REPEAT );

            Assert( m_cbRepeat <= 255 );

            // encode repeat count

            hr = HrBinHexByte( (BYTE)(m_cbRepeat) );

            fEndRepeat = FALSE;
            m_cbRepeat = 0;
        }
        else if ( m_cbRepeat )      // check if we've got two chars to encode.
        {
            // encode the one char since we've already emitted
            // the first one.

            hr = HrBinHexByte( m_bRepeat );

            if ( m_bRepeat == BINHEX_REPEAT )
            {
                hr = HrBinHexByte( '\0' );
            }

            m_cbRepeat = 0;
        }

        // special handling for 0x90 chars in stream but 0x90 can repeat

        if ( m_bCurr == BINHEX_REPEAT && m_bPrev != BINHEX_REPEAT )
        {
            hr = HrBinHexByte( BINHEX_REPEAT );

            hr = HrBinHexByte( '\0' );

            m_fHandledx90 = TRUE;

            continue;
        }

        // encode the char

        hr = HrBinHexByte( m_bCurr );

        if ( hr )
            goto exit;
    }

    // Check if we filled the output buffer

    if ( cbIn && m_cbProduced + 5 >= m_cbWrite )
    {
        hr = ERROR_INSUFFICIENT_BUFFER;
    }

exit:

#if defined (DEBUG) && defined (BINHEX_TRACE)
    m_lpstreamEncodeRAW->Write( lpbIn, cbOrigCbIn - cbIn, NULL );
#endif

    *lpcbConsumed += cbInUsed;

    return hr;
}

//-----------------------------------------------------------------------------
// Name:            CBinhexEncoder::HrBinHexByte
// Description:
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:9/5/1996
//-----------------------------------------------------------------------------
HRESULT CBinhexEncoder::HrBinHexByte( IN BYTE b )
{
    HRESULT     hr      = ERROR_SUCCESS;

#if defined (DEBUG) & defined (BINHEX_TRACE)
    hr = m_lpstreamEncodeRLE->Write( &b, 1, NULL );
#endif

    switch( m_cAccum++ )
    {
        case 0:
            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[b >> 2];
            ++m_cbLine;
            break;

        case 1:
            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x03) << 4) | (b >> 4)];
            ++m_cbLine;
            break;

        case 2:
            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[((m_bPrev & 0x0f) << 2) | (b >> 6)];
            ++m_cbLine;

            if ( m_cbLine >= 64 )
            {
                m_pbWrite[m_cbProduced++] = chCR;
                m_pbWrite[m_cbProduced++] = chLF;
                m_cbLine = 0;
                ++m_cLines;
            }

            m_pbWrite[m_cbProduced++] = g_rgchBinHex8to6[b & 0x3f];
            ++m_cbLine;
            m_cAccum = 0;
            break;

        default:
            AssertSz( FALSE, "HrBinHexByte: bad shift state\n" );
            hr = ERROR_INVALID_PARAMETER;
            goto exit;
    }

    if ( m_cbLine >= 64 )
    {
        m_pbWrite[m_cbProduced++] = chCR;
        m_pbWrite[m_cbProduced++] = chLF;
        m_cbLine = 0;
        ++m_cLines;
    }

    m_bPrev = b;

exit:

    return hr;
}

//-----------------------------------------------------------------------------
//
//  CBinhexDecoder class implementation
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Name:            CalcCRC16
// Description:
//                      Used to calculate a 16 bit CRC using the
//                      CCITT polynomial 0x1021.
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:7/30/1996
//-----------------------------------------------------------------------------
void CalcCRC16( LPBYTE lpbBuff, ULONG cBuff, WORD * wCRC )
{
    LPBYTE  lpb;
    BYTE    b;
    WORD    uCRC;
    WORD    fWrap;
    ULONG   i;

    uCRC = *wCRC;

    for ( lpb = lpbBuff; lpb < lpbBuff + cBuff; lpb++ )
    {
        b = *lpb;

        for ( i = 0; i < 8; i++ )
        {
            fWrap = uCRC & 0x8000;
            uCRC = (uCRC << 1) | (b >> 7);

            if ( fWrap )
            {
                uCRC = uCRC ^ 0x1021;
            }

            b = b << 1;
        }
    }

    *wCRC = uCRC;
}

//-----------------------------------------------------------------------------
// Name:            bIsMacFile
// Description:
//
// Parameters:
// Returns:
//                  FALSE: if the given dwCreator/dwType matches one of the
//                  pairs in g_lpCreatorTypes;
//
//                  TRUE:  otherwise
//
// Effects:
// Notes:
// Revision:
//                  Initial:10/15/1996
//-----------------------------------------------------------------------------
BOOL bIsMacFile(DWORD dwCreator, DWORD dwType)
{
    BOOL    bRet            = TRUE;
    int     i;
    char    szCreator[5]    = { 0 };
    char    szType[5]       = { 0 };

    if ( dwType == 0 && dwCreator == 0 )
    {
        bRet = FALSE;
        goto exit;
    }

    if ( g_bCreatorTypeInit != TRUE )
    {
        ReadCreatorTypes();
    }

    if ( g_lpCreatorTypes == NULL )
        goto exit;

    // Convert dwCreator & dwType to strings

    CopyMemory( szCreator, &dwCreator, 4 );
    CopyMemory( szType, &dwType, 4 );

    for ( i = 0; i < g_cCreatorTypes; i ++ )
    {
        if ( g_lpCreatorTypes[i].szCreator[0] == 0 && g_lpCreatorTypes[i].szType[0] == 0 )
        {
            bRet = FALSE;
            break;
        }
        else if ( g_lpCreatorTypes[i].szCreator[0] == 0 && lstrcmpi( g_lpCreatorTypes[i].szType, szType ) == 0 )
        {
            bRet = FALSE;
            break;
        }
        else if( g_lpCreatorTypes[i].szType[0] == 0 && lstrcmpi( g_lpCreatorTypes[i].szCreator, szCreator ) == 0 )
        {
            bRet = FALSE;
            break;
        }
        else if( lstrcmpi( g_lpCreatorTypes[i].szCreator, szCreator ) == 0 && lstrcmpi( g_lpCreatorTypes[i].szType, szType  ) == 0 )
        {
            bRet = FALSE;
            break;
        }
    }

exit:
    return bRet ;
}

//-----------------------------------------------------------------------------
// Name:            ReadCreatorTypes
//
// Description:
//
//              Read "NonMacCreatorTypes" registry key (REG_MULTI_SZ type)
//              from the registry & build an array of Creator-Type pairs
//
// Parameters:
// Returns:
// Effects:
// Notes:
// Revision:
//                  Initial:10/15/1996
//-----------------------------------------------------------------------------
VOID ReadCreatorTypes( VOID )
{
#ifdef MAC
    g_bCreatorTypeInit = TRUE;
#else   // !MAC
    DWORD   dwStatus;
    DWORD   dwType;
    DWORD   cbData;
    char *  lpData      = NULL;
    char *  lpCurrent   = NULL;
    char *  lpNext      = NULL;
    int     i;
    LONG    lRet;
    HKEY    hKey = 0;
    SCODE   sc          = S_OK;

    g_bCreatorTypeInit = TRUE;

    // Open IMC parameter registry

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\MSExchangeIS\\ParametersSystem\\InternetContent",
            0, KEY_READ, &hKey );

    if ( lRet != ERROR_SUCCESS )
        goto exit;

    // read the registry key

    dwStatus = RegQueryValueEx( hKey, "NonMacCreatorTypes", 0, &dwType, (LPBYTE)NULL, &cbData );

    if ( dwStatus != ERROR_SUCCESS      // key missing
      || dwType   != REG_MULTI_SZ       // wrong type
      || cbData   <= 4 )                // invalid size
    {
        goto exit;
    }

    if (FAILED(HrAlloc((LPVOID *)&lpData, cbData)))
        goto exit;

    ZeroMemory( (LPVOID)lpData, cbData );

    dwStatus = RegQueryValueEx( hKey, "NonMacCreatorTypes", NULL, &dwType, (LPBYTE)lpData, &cbData );

    if ( dwStatus != ERROR_SUCCESS )
      goto exit;

    // Determine # of pairs read:

    g_cCreatorTypes = 0;

    for ( i= 0; i < (LONG)cbData-1; i++ )
    {
      if ( lpData[i] == '\0' )
        g_cCreatorTypes ++;
    }

    if (FAILED(HrAlloc((LPVOID *)&g_lpCreatorTypes, sizeof(sCreatorType) * g_cCreatorTypes)))
        goto exit;

    ZeroMemory( (LPVOID)g_lpCreatorTypes, sizeof(sCreatorType) * g_cCreatorTypes );

    // Build the Creator-Type array

    lpCurrent = lpData;

    i = 0;
    while ( lpCurrent < (lpData + cbData -1) )
    {
        lpNext = StrChr( lpCurrent, ':' );

        if( lpNext == NULL )
        {
            //no ':' found; skip to next string

            lpCurrent = StrChr( lpCurrent, '\0' ) + 1;
            continue;
        }

        *lpNext = '\0';
        if ( StrChr( lpCurrent, '*' ) == NULL )
            CopyMemory( &g_lpCreatorTypes[i].szCreator, lpCurrent, MIN(4, lpNext-lpCurrent) );

        lpCurrent = lpNext + 1;

        lpNext = StrChr( lpCurrent, '\0' );

        if ( lpNext == NULL )
            break;

        if ( StrChr( lpCurrent, '*' ) == NULL )
        {
            CopyMemory( &g_lpCreatorTypes[i].szType, lpCurrent, MIN( 4, lpNext-lpCurrent) );
        }

        lpCurrent = lpNext + 1;
        i++;
    }

    g_cCreatorTypes = i;

exit:

    if ( hKey != 0 )
        RegCloseKey( hKey );

    SafeMemFree(lpData);

    if ( g_cCreatorTypes == 0  && g_lpCreatorTypes != NULL )
    {
        SafeMemFree(g_lpCreatorTypes);
    }
#endif  // !MAC
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\booktre2.cpp ===
// --------------------------------------------------------------------------------
// BookTree.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "booktree.h"
#include "stmlock.h"
#include "ibdylock.h"
#include "resource.h"
#include "vstream.h"
#include "ixputil.h"
#include "olealloc.h"
#include "smime.h"
#include "objheap.h"
#include "internat.h"
#include "icoint.h"
#include "ibdystm.h"
#include "symcache.h"
#include "urlmon.h"
#include "mhtmlurl.h"
#ifndef MAC
#include "shlwapi.h"
#include "shlwapip.h"
#endif  // !MAC
#include "inetstm.h"
#ifndef MAC
#include "imnxport.h"
#endif  // !MAC
#include "msgmon.h"
#include "bookbody.h"
#include <demand.h>
#include "mimeapi.h"
#include "strconst.h"
#include "bindstm.h"

// --------------------------------------------------------------------------------
// _IsMultiPart
// --------------------------------------------------------------------------------
inline BOOL _IsMultiPart(LPTREENODEINFO pNode)
{ 
    return pNode->pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK; 
}

// --------------------------------------------------------------------------------
// BINDASSERTARGS
// --------------------------------------------------------------------------------
#define BINDASSERTARGS(_bindstate, _fBoundary) \
    Assert(m_pBindNode && m_pBindNode->pBody && m_pBindNode->pContainer && _bindstate == m_pBindNode->bindstate && (FALSE == _fBoundary || ISVALIDSTRINGA(&m_pBindNode->rBoundary)))

// --------------------------------------------------------------------------------
// Used in IMimeMessageTree::ToMultipart
// --------------------------------------------------------------------------------
static LPCSTR g_rgszToMultipart[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
    PIDTOSTR(PID_HDR_CNTDESC),
    PIDTOSTR(PID_HDR_CNTDISP),
    PIDTOSTR(PID_HDR_CNTXFER),
    PIDTOSTR(PID_HDR_CNTID),
    PIDTOSTR(PID_HDR_CNTBASE),
    PIDTOSTR(PID_HDR_CNTLOC)
};

// --------------------------------------------------------------------------------
// Used in IMimeMessage::AttachObject IID_IMimeBody
// --------------------------------------------------------------------------------
static LPCSTR g_rgszAttachBody[] = {
    PIDTOSTR(PID_HDR_CNTTYPE),
    PIDTOSTR(PID_HDR_CNTDESC),
    PIDTOSTR(PID_HDR_CNTDISP),
    PIDTOSTR(PID_HDR_CNTXFER),
    PIDTOSTR(PID_HDR_CNTID),
    PIDTOSTR(PID_HDR_CNTBASE),
    PIDTOSTR(PID_HDR_CNTLOC)
};

// --------------------------------------------------------------------------------
// Default Tree Options
// --------------------------------------------------------------------------------
static const TREEOPTIONS g_rDefTreeOptions = {
    DEF_CLEANUP_TREE_ON_SAVE,       // OID_CLEANUP_TREE_ON_SAVE
    DEF_HIDE_TNEF_ATTACHMENTS,      // OID_HIDE_TNEF_ATTACHMENTS
    DEF_ALLOW_8BIT_HEADER,          // OID_ALLOW_8BIT_HEADER
    DEF_GENERATE_MESSAGE_ID,        // OID_GENERATE_MESSAGE_ID
    DEF_WRAP_BODY_TEXT,             // OID_WRAP_BODY_TEXT
    DEF_CBMAX_HEADER_LINE,          // OID_CBMAX_HEADER_LINE
    DEF_CBMAX_BODY_LINE,            // OID_CBMAX_BODY_LINE
    SAVE_RFC1521,                   // OID_SAVE_FORMAT
    NULL,                           // hCharset
    CSET_APPLY_UNTAGGED,            // csetapply
    DEF_TRANSMIT_TEXT_ENCODING,     // OID_TRANSMIT_TEXT_ENCODING
    DEF_XMIT_PLAIN_TEXT_ENCODING,   // OID_XMIT_PLAIN_TEXT_ENCODING
    DEF_XMIT_HTML_TEXT_ENCODING,    // OID_XMIT_HTML_TEXT_ENCODING
    0,                              // OID_SECURITY_ENCODE_FLAGS
    DEF_HEADER_RELOAD_TYPE_TREE     // OID_HEADER_REALOD_TYPE
};

// --------------------------------------------------------------------------------
// Text Type Information Array
// --------------------------------------------------------------------------------
static const TEXTTYPEINFO g_rgTextInfo[] = {
    { TXT_PLAIN,    STR_SUB_PLAIN,      0 },
    { TXT_HTML,     STR_SUB_HTML,       5 }
};


// --------------------------------------------------------------------------------
// CWebBookContentTree::_UnlinkTreeNode
// --------------------------------------------------------------------------------
void CWebBookContentTree::_UnlinkTreeNode(LPTREENODEINFO pNode)
{
    // Locals
    LPTREENODEINFO  pPrev; 
    LPTREENODEINFO  pNext;
    LPTREENODEINFO  pParent;

    // Check Params
    Assert(pNode);

    // Set Next and Previous
    pParent = pNode->pParent;
    pPrev = pNode->pPrev;
    pNext = pNode->pNext;

    // If pPrev
    if (pPrev)
        pPrev->pNext = pNext;
    else if (pParent)
        pParent->pChildHead = pNext;

    // If pNext
    if (pNext)
        pNext->pPrev = pPrev;
    else if (pParent)
        pParent->pChildTail = pPrev;

    // Delete Children on Parent
    if (pParent)
        pParent->cChildren--;

    // Cleanup pNode
    pNode->pParent = NULL;
    pNode->pNext = NULL;
    pNode->pPrev = NULL;
    pNode->pChildHead = NULL;
    pNode->pChildTail = NULL;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::CountBodies
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::CountBodies(HBODY hParent, boolean fRecurse, ULONG *pcBodies)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pcBodies)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *pcBodies = 0;

    // No Parent ?
    if (NULL == hParent || HBODY_ROOT == hParent)
    {
        // Is there a root..
        if (NULL == m_pRootNode)
            goto exit;

        // Use Root
        pNode = m_pRootNode;
    }

    // Otherwise, get parent...
    else
    {
        // Validate handle
        if (_FIsValidHandle(hParent) == FALSE)
        {
            hr = TrapError(MIME_E_INVALID_HANDLE);
            goto exit;
        }

        // Cast
        pNode = _PNodeFromHBody(hParent);
    }

    // Include the root
    (*pcBodies)++;

    // Count the children...
    _CountChildrenInt(pNode, fRecurse, pcBodies);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_CountChildrenInt
// --------------------------------------------------------------------------------
void CWebBookContentTree::_CountChildrenInt(LPTREENODEINFO pParent, BOOL fRecurse, ULONG *pcChildren)
{
    // Locals
    LPTREENODEINFO pNode;

    // check params
    Assert(pParent && pcChildren);

    // Loop through bodies
    for (ULONG i=0; i<m_rTree.cNodes; i++)
    {
        // Readability
        pNode = m_rTree.prgpNode[i];

        // Empty..
        if (NULL == pNode)
            continue;

        // pNode is Parent...
        if (pParent == pNode->pParent)
        {
            // Increment Count
            (*pcChildren)++;

            // Free Children...
            if (fRecurse && _IsMultiPart(pNode))
                _CountChildrenInt(pNode, fRecurse, pcChildren);
        }
    }
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::FindFirst
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::FindFirst(LPFINDBODY pFindBody, LPHBODY phBody)
{
    // Invalid Arg
    if (NULL == pFindBody)
        return TrapError(E_INVALIDARG);

    // Init Find
    pFindBody->dwReserved = 0;

    // Find Next
    return FindNext(pFindBody, phBody);
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::FindNext
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::FindNext(LPFINDBODY pFindBody, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == pFindBody || NULL == phBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phBody = NULL;

    // Loop
    for (i=pFindBody->dwReserved; i<m_rTree.cNodes; i++)
    {
        // If delete
        pNode = m_rTree.prgpNode[i];

        // Empty
        if (NULL == pNode)
            continue;

        // Compare content type
        if (pNode->pContainer->IsContentType(pFindBody->pszPriType, pFindBody->pszSubType) == S_OK)
        {
            // Save Index of next item to search
            pFindBody->dwReserved = i + 1;
            *phBody = pNode->hBody;
            goto exit;
        }
    }

    // Error
    pFindBody->dwReserved = m_rTree.cNodes; 
    hr = MIME_E_NOT_FOUND;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::ToMultipart
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::ToMultipart(HBODY hBody, LPCSTR pszSubType, LPHBODY phMultipart)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pNode;
    LPTREENODEINFO      pNew=NULL;
    LPTREENODEINFO      pParent;
    LPTREENODEINFO      pNext; 
    LPTREENODEINFO      pPrev;

    // check params
    if (NULL == hBody || NULL == pszSubType)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phMultipart)
        *phMultipart = NULL;

    // Get the body from hBody
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // We better have a root
    Assert(m_pRootNode);

    // If pNode does not have a parent...
    if (NULL == pNode->pParent)
    {
        // pNode must be the root ?
        Assert(m_pRootNode == pNode);

        // Create Object
        //N duplicated
        CHECKHR(hr = _HrCreateTreeNode(&pNew));

        // Set pNode First and Last...
        pNew->pChildHead = m_pRootNode;
        pNew->pChildTail = m_pRootNode;
        m_pRootNode->pParent = pNew;

        // Set Children Count
        pNew->cChildren = 1;

        // Set new root
        m_pRootNode = pNew;

        // Return New Multipart Handle
        if (phMultipart)
            *phMultipart = pNew->hBody;

        // Swap Property Sets...
        Assert(m_pRootNode != pNode);
        m_pRootNode->pBody->SwitchContainers(pNode->pBody);

        // Copy Some Props Across
        CHECKHR(hr = m_pRootNode->pBody->MoveProps(ARRAYSIZE(g_rgszToMultipart), g_rgszToMultipart, pNode->pBody));
    }

    // Otherwise, create a body that takes the place of pNode
    else
    {
        // Create a body object
        CHECKHR(hr = _HrCreateTreeNode(&pNew));

        // DON'T FAIL FROM HERE TO END OF FUNCTION
        // Return New Multipart Handle
        if (phMultipart)
            *phMultipart = pNew->hBody;

        // Assume the position of pNode
        pNew->pParent = pNode->pParent;
        pNew->pPrev = pNode->pPrev;
        pNew->pNext = pNode->pNext;
        pNew->pChildHead = pNode;
        pNew->pChildTail = pNode;
        pNew->cChildren = 1;

        // Set pParnet
        pParent = pNode->pParent;

        // Fix up parent head and child
        if (pParent->pChildHead == pNode)
            pParent->pChildHead = pNew;
        if (pParent->pChildTail == pNode)
            pParent->pChildTail = pNew;

        // Set pNode Parent
        pNode->pParent = pNew;

        // Fixup pNext and pPrev
        pNext = pNode->pNext;
        pPrev = pNode->pPrev;
        if (pNext)
            pNext->pPrev = pNew;
        if (pPrev)
            pPrev->pNext = pNew;

        // Clear pNext and pPrev
        pNode->pNext = NULL;
        pNode->pPrev = NULL;
    }

    // Change this nodes content type
    CHECKHR(hr = pNew->pContainer->SetProp(SYM_ATT_PRITYPE, STR_CNT_MULTIPART));
    CHECKHR(hr = pNew->pContainer->SetProp(SYM_ATT_SUBTYPE, pszSubType));

    pNode->pBody->CopyOptionsTo(pNew->pBody);

exit:
    // Create Worked
    _PostCreateTreeNode(hr, pNew);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrNodeFromHandle
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrNodeFromHandle(HBODY hBody, LPTREENODEINFO *ppBody)
{
    // Invalid Arg
    Assert(hBody && ppBody);

    // Root ?
    if ((HBODY)HBODY_ROOT == hBody)
    {
        // No Root
        if (NULL == m_pRootNode)
            return MIME_E_NO_DATA;

        // Otherwise, use root
        *ppBody = m_pRootNode;
    }

    // Otherwise
    else
    {
        // Validate handle
        if (_FIsValidHandle(hBody) == FALSE)
            return TrapError(MIME_E_INVALID_HANDLE);

        // Get Node
        *ppBody = _PNodeFromHBody(hBody);
    }

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::IsBodyType
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::IsBodyType(HBODY hBody, IMSGBODYTYPE bodytype)
{
    // Locals
    HRESULT           hr=S_OK;
    LPTREENODEINFO    pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pBody->IsType(bodytype);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::IsContentType
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::IsContentType(HBODY hBody, LPCSTR pszPriType, LPCSTR pszSubType)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->IsContentType(pszPriType, pszSubType);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::QueryBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::QueryBodyProp(HBODY hBody, LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->GetProp(pszName, dwFlags, pValue);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::SetBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::SetBodyProp(HBODY hBody, LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->SetProp(pszName, dwFlags, pValue);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::DeleteBodyProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::DeleteBodyProp(HBODY hBody, LPCSTR pszName)
{
    // Locals
    HRESULT         hr=S_OK;
    LPTREENODEINFO  pNode;

    // check params
    if (NULL == hBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get body
    CHECKHR(hr = _HrNodeFromHandle(hBody, &pNode));

    // Call into body object
    hr = pNode->pContainer->DeleteProp(pszName);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_FIsUuencodeBegin
// --------------------------------------------------------------------------------
BOOL CWebBookContentTree::_FIsUuencodeBegin(LPPROPSTRINGA pLine, LPSTR *ppszFileName)
{
    // Locals
    ULONG i;

    // check params
    Assert(ISVALIDSTRINGA(pLine));

    // Length must be at least 11 to accomodate "begin 666 " and the first character of a filename.
    if (pLine->cchVal < 11)
        return FALSE;
    
    // First 6 characters must be "begin ", or we're not a valid line.
    if (StrCmpN(pLine->pszVal, "begin ", 6) != 0)
        return FALSE;
    
    // Check characters 6-8 for valid Unix filemode. They must all be digits between 0 and 7.
    for (i=6; i<pLine->cchVal; i++)
    {
        if (pLine->pszVal[i] < '0' || pLine->pszVal[i] > '7')
            break;
    }
    
    // Not a begin line
    if (pLine->pszVal[i] != ' ')
        return FALSE;

    // Get File Name
    if (ppszFileName)
    {
        *ppszFileName = PszDupA(pLine->pszVal + i + 1);
        ULONG cbLine = lstrlen (*ppszFileName);
        StripCRLF(*ppszFileName, &cbLine);
    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_GetMimeBoundaryType
// --------------------------------------------------------------------------------
BOUNDARYTYPE CWebBookContentTree::_GetMimeBoundaryType(LPPROPSTRINGA pLine, LPPROPSTRINGA pBoundary)
{
    // Locals
    BOUNDARYTYPE boundary=BOUNDARY_NONE;
    CHAR         ch;
    ULONG        cchLine=pLine->cchVal;
    LPSTR        psz1, psz2;

    // Check Params
    Assert(ISVALIDSTRINGA(pBoundary) && ISVALIDSTRINGA(pLine));

    // Check First two chars of the line
    if ('-' != pLine->pszVal[0] || '-' != pLine->pszVal[1])
        goto exit;

    // Removes trailing white spaces
    while(pLine->cchVal > 0)
    {
        // Get the last character
        ch = *(pLine->pszVal + (pLine->cchVal - 1));

        // No LWSP or CRLF
        if (' ' != ch && '\t' != ch && chCR != ch && chLF != ch)
            break;

        // Decrement Length
        pLine->cchVal--;
    }

    // Decrement two for --
    pLine->cchVal -= 2;

    // Checks line length against boundary length
    if (pLine->cchVal != pBoundary->cchVal && pLine->cchVal != pBoundary->cchVal + 2)
        goto exit;

    // Compare the line with the boundary
    if (StrCmpN(pLine->pszVal + 2, pBoundary->pszVal, (size_t)pBoundary->cchVal) == 0)
    {
        // BOUNDARY_MIMEEND
        if ((pLine->cchVal > pBoundary->cchVal) && (pLine->pszVal[pBoundary->cchVal+2] == '-') && (pLine->pszVal[pBoundary->cchVal+3] == '-'))
            boundary = BOUNDARY_MIMEEND;

        // BOUNDARY_MIMENEXT
        else if (pLine->cchVal == pBoundary->cchVal)
            boundary = BOUNDARY_MIMENEXT;
    }

exit:
    // Relace the Length
    pLine->cchVal = cchLine;

    // Done
    return boundary;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrGetDefaultBase
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrGetDefaultBase(HBODY hRelated, LPSTR *ppszBase)
{
    // Locals
    HRESULT     hr=S_OK;
    HBODY       hBase=NULL;
    PROPVARIANT rVariant;

    // Init
    *ppszBase = NULL;

    // Get the text/html body
    if (FAILED(GetTextBody(TXT_HTML, IET_BINARY, NULL, &hBase)))
        hBase = hRelated;

    // No Base
    if (NULL == hBase)
    {
        hr = E_FAIL;
        goto exit;
    }

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = NULL;

    // Get Content-Base first, and then try Content-Location
    if (FAILED(GetBodyProp(hBase, PIDTOSTR(PID_HDR_CNTBASE), NOFLAGS, &rVariant)))
    {
        // Try Content-Location
        if (FAILED(GetBodyProp(hBase, PIDTOSTR(PID_HDR_CNTLOC), NOFLAGS, &rVariant)))
            rVariant.pszVal = NULL;
    }

    // Set pszBase
    *ppszBase = rVariant.pszVal;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::ResolveURL
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::ResolveURL(HBODY hRelated, LPCSTR pszBase, LPCSTR pszURL, 
    DWORD dwFlags, LPHBODY phBody)
{
    // Locals
    HRESULT             hr=S_OK;
    LPTREENODEINFO      pRelated;
    RESOLVEURLINFO      rInfo;
    HBODY               hBody=NULL;
    PROPSTRINGA         rBaseUrl;
    LPSTR               pszFree=NULL;

    // InvalidArg
    if (NULL == pszURL)
        return TrapError(E_INVALIDARG);

    // Init
    if (phBody)
        *phBody = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If hRelated is NULL, find the first multipart/related
    if (NULL == hRelated)
    {
        // Find the Related
        if (FAILED(MimeOleGetRelatedSection(this, FALSE, &hRelated, NULL)))
        {
            // Use Root
            hRelated = m_pRootNode->hBody;
        }
    }

    // Get Default Base
    if (NULL == pszBase && SUCCEEDED(_HrGetDefaultBase(hRelated, &pszFree)))
        pszBase = pszFree;

    // Get a Body from the Handle
    CHECKHR(hr = _HrNodeFromHandle(hRelated, &pRelated));

    // Setup Resolve URL Info
    ZeroMemory(&rInfo, sizeof(RESOLVEURLINFO));
    rInfo.pszBase = pszBase;
    rInfo.pszURL = pszURL;
    rInfo.fIsCID = (StrCmpNI(pszURL, c_szCID, lstrlen(c_szCID)) == 0) ? TRUE : FALSE;

    // Recurse the Tree
    CHECKHR(hr = _HrRecurseResolveURL(pRelated, &rInfo, &hBody));

    // Not found
    if (NULL == hBody)
    {
        hr = TrapError(MIME_E_NOT_FOUND);
        goto exit;
    }

    // Return It ?
    if (phBody)
        *phBody = hBody;

    // Mark as Resolved ?
    if (ISFLAGSET(dwFlags, URL_RESOLVE_RENDERED))
    {
        // Defref the body
        LPTREENODEINFO pNode = _PNodeFromHBody(hBody);

        // Set Rendered
        PROPVARIANT rVariant;
        rVariant.vt = VT_UI4;
        rVariant.ulVal = TRUE;

        // Set the Property
        SideAssert(SUCCEEDED(pNode->pContainer->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Cleanup
    SafeMemFree(pszFree);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrRecurseResolveURL
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrRecurseResolveURL(LPTREENODEINFO pNode, LPRESOLVEURLINFO pInfo, LPHBODY phBody)
{
    // Locals
    HRESULT           hr=S_OK;
    LPTREENODEINFO    pChild;

    // Invalid Arg
    Assert(pNode && pInfo && phBody);

    // We must have not found the body yet ?
    Assert(NULL == *phBody);

    // If this is a multipart item, lets search it's children
    if (_IsMultiPart(pNode))
    {
        // Loop Children
        for (pChild=pNode->pChildHead; pChild!=NULL; pChild=pChild->pNext)
        {
            // Check body
            Assert(pChild->pParent == pNode);

            // Bind the body table for this dude
            CHECKHR(hr = _HrRecurseResolveURL(pChild, pInfo, phBody));

            // Done
            if (NULL != *phBody)
                break;
        }
    }

    // Get Character Set Information
    else 
    {
        // Ask the container to do the resolution
        if (SUCCEEDED(pNode->pContainer->HrResolveURL(pInfo)))
        {
            // Cool we found the body, we resolved the URL
            *phBody = pNode->hBody;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetProp(pszName, dwFlags, pValue);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::SetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->SetProp(pszName, dwFlags, pValue);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::DeleteProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::DeleteProp(LPCSTR pszName)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->DeleteProp(pszName);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::QueryProp
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetAddressTable
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetAddressTable(IMimeAddressTable **ppTable)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->BindToObject(IID_IMimeAddressTable, (LPVOID *)ppTable);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetSender
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetSender(LPADDRESSPROPS pAddress)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetSender(pAddress);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetAddressTypes
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetAddressTypes(DWORD dwAdrTypes, DWORD dwProps, LPADDRESSLIST pList)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetTypes(dwAdrTypes, dwProps, pList);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetAddressFormat
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetAddressFormat(DWORD dwAdrType, ADDRESSFORMAT format, LPSTR *ppszFormat)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->GetFormat(dwAdrType, format, ppszFormat);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::EnumAddressTypes
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::EnumAddressTypes(DWORD dwAdrTypes, DWORD dwProps, IMimeEnumAddressTypes **ppEnum)
{
    EnterCriticalSection(&m_cs);
    Assert(m_pRootNode && m_pRootNode->pContainer);
    HRESULT hr = m_pRootNode->pContainer->EnumTypes(dwAdrTypes, dwProps, ppEnum);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrGetTextTypeInfo
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrGetTextTypeInfo(DWORD dwTxtType, LPTEXTTYPEINFO *ppTextInfo)
{
    // Invalid Arg
    Assert(ppTextInfo);

    // Init
    *ppTextInfo = NULL;

    // Locate the text type
    for (ULONG i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
    {
        // Desired Text Type
        if (g_rgTextInfo[i].dwTxtType == dwTxtType)
        {
            // Found It
            *ppTextInfo = (LPTEXTTYPEINFO)&g_rgTextInfo[i];
            return S_OK;
        }
    }

    // Un-identified text type
    if (NULL == *ppTextInfo)
        return TrapError(MIME_E_INVALID_TEXT_TYPE);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetTextBody
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, 
    IStream **ppStream, LPHBODY phBody)
{
    // Locals
    HRESULT              hr=S_OK;
    HRESULT              hrFind;
    LPTEXTTYPEINFO       pTextInfo=NULL;
    FINDBODY             rFind;
    IMimeBody           *pBody=NULL;
    PROPVARIANT          rStart;
    PROPVARIANT          rVariant;
    HBODY                hAlternativeParent;
    HBODY                hFirst=NULL;
    HBODY                hChild;
    HBODY                hBody=NULL;
    HBODY                hRelated;
    IStream             *pstmHtml=NULL;
    CWebBookContentBody *pEnriched=NULL;
    HCHARSET             hCharset;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;
    if (ppStream)
        *ppStream = NULL;

    // Init
    MimeOleVariantInit(&rStart);

    // Get the Text Info
    CHECKHR(hr = _HrGetTextTypeInfo(dwTxtType, &pTextInfo));

    // MimeHTML
    if (SUCCEEDED(MimeOleGetRelatedSection(this, FALSE, &hRelated, NULL)))
    {
        // Get start= parameter
        if (SUCCEEDED(GetBodyProp(hRelated, STR_PAR_START, 0, &rStart)))
        {
            // Resolve this URL
            ResolveURL(hRelated, NULL, rStart.pszVal, 0, &hBody);
        }
    }

    // Still haven't found a text body ?
    if (NULL == hBody)
    {
            // Loop through the text/subtypes of the tree
            ZeroMemory(&rFind, sizeof(FINDBODY));
            rFind.pszPriType = (LPSTR)STR_CNT_TEXT;
            rFind.pszSubType = (LPSTR)pTextInfo->pszSubType;

            // Find First
            if (FAILED(FindFirst(&rFind, &hBody)))
            {
            // If we were looking for HTML, lets try to find some text/enriched
            if (ISFLAGSET(dwTxtType, TXT_HTML))
            {
                // Enriched
                rFind.pszSubType = (LPSTR)STR_SUB_ENRICHED;

                // Try to find the first text/enriched body
                if (FAILED(FindFirst(&rFind, &hBody)))
                {
                    hr = TrapError(MIME_E_NOT_FOUND);
                    goto exit;
                }
            }

            // Not Found
            else
            {
                hr = TrapError(MIME_E_NOT_FOUND);
                goto exit;
            }
        }

        // Save hFirst
        hFirst = hBody;

        // Continue searching as long as the text body is marked as an attachment
        while (IsBodyType(hBody, IBT_ATTACHMENT) == S_OK)
        {
            // Find the Next Body
            if (FAILED(FindNext(&rFind, &hBody)))
            {
                // Locals
                ULONG cBodies;

                // Count Bodies
                CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

                // Raid 43444: Inbox Direct messages showing as attachments
                if (cBodies == 1)
                {
                    // Defreference First node found
                    LPTREENODEINFO pFirst = _PNodeFromHBody(hFirst);

                    // Inline or Disposition is not set
                    if (pFirst->pContainer->QueryProp(PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_INLINE, FALSE, FALSE) == S_OK || 
                        pFirst->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTDISP)) == S_FALSE)
                    {
                        hBody = hFirst;
                        break;
                    }
                }

                // Otherwise, we didn't find anything
                hr = TrapError(MIME_E_NOT_FOUND);
                goto exit;
            }
        }

        // Validate the hBody
        // Assert(IsContentType(hBody, STR_CNT_TEXT, pTextInfo->pszSubType) == S_OK);
        //Assert(QueryBodyProp(hBody, PIDTOSTR(PID_HDR_CNTDISP), STR_DIS_ATTACHMENT, FALSE, FALSE) == S_FALSE);
    }

    // Get the stream...
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // If Empty...
    if (pBody->IsType(IBT_EMPTY) == S_OK)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // User Wants the Data
    if (ppStream)
    {
        // If content-type is text/enriched, convert to html
        if (pBody->IsContentType(STR_CNT_TEXT, STR_SUB_ENRICHED) == S_OK)
        {
            // Better be asking for html
            Assert(ISFLAGSET(dwTxtType, TXT_HTML));

            // Get Data
            CHECKHR(hr = pBody->GetData(IET_DECODED, ppStream));

            // Get the Charset
            if (FAILED(pBody->GetCharset(&hCharset)))
                hCharset = g_pDefBodyCset ? g_pDefBodyCset->hCharset : NULL;

            // Create new virtual stream
            CHECKHR(hr = MimeOleCreateVirtualStream(&pstmHtml));

            // Make sure rewound
            CHECKHR(hr = HrRewindStream(*ppStream));

            // Convert
            CHECKHR(hr = MimeOleConvertEnrichedToHTML(MimeOleGetWindowsCP(hCharset), *ppStream, pstmHtml));

            // Make sure rewound
            CHECKHR(hr = HrRewindStream(pstmHtml));

            // Allocate pEnriched
            CHECKALLOC(pEnriched = new CWebBookContentBody(NULL, NULL));

            // Init
            CHECKHR(hr = pEnriched->InitNew());

            // Put pstmHtml into pEnriched
            CHECKHR(hr = pEnriched->SetData(IET_DECODED, STR_CNT_TEXT, STR_SUB_HTML, IID_IStream, (LPVOID)pstmHtml));

            // Get and set the charset
            if (hCharset)
                pEnriched->SetCharset(hCharset, CSET_APPLY_ALL);

            // Release *ppStream
            (*ppStream)->Release();

            // Get Data
            CHECKHR(hr = pEnriched->GetData(ietEncoding, ppStream));
        }

        // Otherwise, non-text enriched case
        else
        {
            // Get Data
            CHECKHR(hr = pBody->GetData(ietEncoding, ppStream));
        }
    }

    // Rendered
    rVariant.vt = VT_UI4;
    rVariant.ulVal = TRUE;

    // Lets set the resourl flag
    SideAssert(SUCCEEDED(pBody->SetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

    // Raid-45116: new text attachment contains message body on Communicator inline image message
    if (FAILED(GetBody(IBL_PARENT, hBody, &hAlternativeParent)))
        hAlternativeParent = NULL;

    // Try to find an alternative parent...
    while(hAlternativeParent)
    {
        // If multipart/alternative, were done
        if (IsContentType(hAlternativeParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
            break;

        // Get Next Parent
        if (FAILED(GetBody(IBL_PARENT, hAlternativeParent, &hAlternativeParent)))
            hAlternativeParent = NULL;
    }

    // Get Parent
    if (hAlternativeParent)
    {
        // Resolve all first level children
        hrFind = GetBody(IBL_FIRST, hAlternativeParent, &hChild);
        while(SUCCEEDED(hrFind) && hChild)
        {
            // Set Resolve Property
            SideAssert(SUCCEEDED(SetBodyProp(hChild, PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)));

            // Find Next
            hrFind = GetBody(IBL_NEXT, hChild, &hChild);
        }
    }

    // Return the hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeRelease(pBody); 
    SafeRelease(pstmHtml);
    SafeRelease(pEnriched);
    MimeOleVariantFree(&rStart);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::SetTextBody
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::SetTextBody(DWORD dwTxtType, ENCODINGTYPE ietEncoding, 
    HBODY hAlternative, IStream *pStream, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK,
                    hrFind;
    HBODY           hRoot,
                    hBody,
                    hTextBody=NULL,
                    hSection,
                    hParent,
                    hPrevious, 
                    hInsertAfter;
    LPTEXTTYPEINFO  pTextInfo=NULL;
    BOOL            fFound,
                    fFoundInsertLocation;
    DWORD           dwWeightBody;
    ULONG           i;
    IMimeBody      *pBody;
    PROPVARIANT     rVariant;

    // Invalid Arg
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Get the Text Info
    CHECKHR(hr = _HrGetTextTypeInfo(dwTxtType, &pTextInfo));

    // Raid-45369: message from Eudora Pro comes in .txt attachment which is lost when forwarded.
    // If hAlternative is NULL, then this means that the client wants to replace all text bodies
    // with this new text body. If hAlternative is not NULL, then the client has already inserted
    // a text body and created a alternative section, no more deleting.
    if (NULL == hAlternative)
    {
        // Loop through the text type
        for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
        {
            // Get the Current Text Body Associated with this type
            if (SUCCEEDED(GetTextBody(g_rgTextInfo[i].dwTxtType, IET_BINARY, NULL, &hBody)))
            {
                // If the parent of hBody is an alternative section, delete the alternative
                if (SUCCEEDED(GetBody(IBL_PARENT, hBody, &hParent)) && IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
                {
                    // Delete multipart/alternative
                    hBody = hParent;
                }

                // Not if hBody is equal to hAlternative
                if (hBody != hAlternative)
                {
                    // Delete the multipart/alternative section
                    CHECKHR(hr = DeleteBody(hBody, 0));

                    // Done
                    break;
                }
            }
        }
    }

    // Get Root
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // If only one body..
    if (IsBodyType(hRoot, IBT_EMPTY) == S_OK)
    {
        // Just use the root
        hTextBody = hRoot;
    }

    // Otherwise, if not inserting an alternative body, we must need a multipart/mixed or multipart/related section
    else if (NULL == hAlternative)
    {
        // Better not be an alternative section
        Assert(FAILED(MimeOleGetAlternativeSection(this, &hSection, NULL)));

        // If there is a related section use it
        if (FAILED(MimeOleGetRelatedSection(this, FALSE, &hSection, NULL)))
        {
            // Find or Create a multipart/mixed section
            CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hSection, NULL));
        }

        // Insert an element at the head of this section...
        CHECKHR(hr = InsertBody(IBL_FIRST, hSection, &hTextBody));
    }

    // Otherwise, if inserting an alternative body
    else if (hAlternative != NULL)
    {
        // Verify pBody is STR_CNT_TEXT
        Assert(IsContentType(hAlternative, STR_CNT_TEXT, NULL) == S_OK);

        // Get hAlternative's parent
        if (FAILED(GetBody(IBL_PARENT, hAlternative, &hParent)))
            hParent = NULL;

        // If hAlternative is the root
        if (hRoot == hAlternative || NULL == hParent || IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_FALSE)
        {
            // Convert this body to a multipart/alternative
            CHECKHR(hr = ToMultipart(hAlternative, STR_SUB_ALTERNATIVE, &hSection));
        }

        // Otherwise, hSection is equal to hParent
        else
            hSection = hParent;

        // We better have an alternative section now...
        Assert(IsContentType(hSection, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK);

        // Init Search
        hPrevious = NULL;
        fFound = FALSE;
        fFoundInsertLocation = FALSE;
        dwWeightBody = 0;
        hInsertAfter = NULL;

        // Lets enum the children of rLayout.hAlternative and verify that hAlternative is still a child...and decide what alternative body to insert after
        hrFind = GetBody(IBL_FIRST, hSection, &hBody);
        while(SUCCEEDED(hrFind) && hBody)
        {
            // Default dwWeightBody
            dwWeightBody = 0xffffffff;

            // Get Weight of hBody
            for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
            {
                // Compare Content Type
                if (IsContentType(hBody, STR_CNT_TEXT, g_rgTextInfo[i].pszSubType) == S_OK)
                {
                    dwWeightBody = g_rgTextInfo[i].dwWeight;
                    break;
                }
            }

            // Get Alternative Weight of the body we are inserting
            if (pTextInfo->dwWeight <= dwWeightBody && FALSE == fFoundInsertLocation)
            {
                fFoundInsertLocation = TRUE;
                hInsertAfter = hPrevious;
            }

            // Is this the alternative brother...
            if (hAlternative == hBody)
                fFound = TRUE;

            // Set hPrev
            hPrevious = hBody;

            // Find Next
            hrFind = GetBody(IBL_NEXT, hBody, &hBody);
        }

        // If we didn't find hAlternative, we're hosed
        if (FALSE == fFound)
        {
            Assert(FALSE);
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // If no after was found... insert first..
        if (NULL == hInsertAfter)
        {
            // BODY_LAST_CHILD
            if (pTextInfo->dwWeight > dwWeightBody)
            {
                // Insert a new body...
                CHECKHR(hr = InsertBody(IBL_LAST, hSection, &hTextBody));
            }

            // BODY_FIRST_CHILD
            else
            {
                // Insert a new body...
                CHECKHR(hr = InsertBody(IBL_FIRST, hSection, &hTextBody));
            }
        }

        // Otherwise insert after hInsertAfter
        else
        {
            // Insert a new body...
            CHECKHR(hr = InsertBody(IBL_NEXT, hInsertAfter, &hTextBody));
        }
    }

    // Open the object
    Assert(hTextBody);
    CHECKHR(hr = BindToObject(hTextBody, IID_IMimeBody, (LPVOID *)&pBody));

    // Set the root...
    CHECKHR(hr = pBody->SetData(ietEncoding, STR_CNT_TEXT, pTextInfo->pszSubType, IID_IStream, (LPVOID)pStream));

    // Release This
    SafeRelease(pBody);

    // Set multipart/related; type=...
    if (SUCCEEDED(GetBody(IBL_PARENT, hTextBody, &hParent)))
    {
        // If parent is multipart/related, set type
        if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_RELATED) == S_OK)
        {
            // Get Parent
            CHECKHR(hr = BindToObject(hParent, IID_IMimeBody, (LPVOID *)&pBody));

            // type = text/plain
            if (ISFLAGSET(dwTxtType, TXT_PLAIN))
            {
                // Setup Variant
                rVariant.vt = VT_LPSTR;
                rVariant.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;

                // Set the Properyt
                CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
            }

            // type = text/plain
            else if (ISFLAGSET(dwTxtType, TXT_HTML))
            {
                // Setup Variant
                rVariant.vt = VT_LPSTR;
                rVariant.pszVal = (LPSTR)STR_MIME_TEXT_HTML;

                // Set the Properyt
                CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
            }
            else
                AssertSz(FALSE, "UnKnown dwTxtType passed to IMimeMessage::SetTextBody");
        }

        // Otherwise, if hParent is multipart/alternative
        else if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_ALTERNATIVE) == S_OK)
        {
            // Set multipart/related; type=...
            if (SUCCEEDED(GetBody(IBL_PARENT, hParent, &hParent)))
            {
                // If parent is multipart/related, set type
                if (IsContentType(hParent, STR_CNT_MULTIPART, STR_SUB_RELATED) == S_OK)
                {
                    // Get Parent
                    CHECKHR(hr = BindToObject(hParent, IID_IMimeBody, (LPVOID *)&pBody));

                    // Setup Variant
                    rVariant.vt = VT_LPSTR;
                    rVariant.pszVal = (LPSTR)STR_MIME_MPART_ALT;

                    // Set the Properyt
                    CHECKHR(hr = pBody->SetProp(STR_PAR_TYPE, 0, &rVariant));
                }
            }
        }
    }

    // Set body handle
    if (phBody)
        *phBody = hTextBody;

exit:
    // Cleanup
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::AttachObject
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::AttachObject(REFIID riid, void *pvObject, LPHBODY phBody)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody,
                    hMixed;
    IMimeBody      *pBody=NULL;
    PROPVARIANT     rVariant;

    // Invalid Arg
    if (NULL == pvObject || FALSE == FBODYSETDATAIID(riid))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Get Mixed Section
    CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hMixed, NULL));

    // Append a child to the mixed part...
    CHECKHR(hr = InsertBody(IBL_LAST, hMixed, &hBody));

    // Bind to the Body Object
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // Set Data Object
    CHECKHR(hr = pBody->SetData(IET_BINARY, NULL, NULL, riid, pvObject));

    // Setup Variant
    rVariant.vt = VT_LPSTR;
    rVariant.pszVal = (LPSTR)STR_DIS_ATTACHMENT;

    // Mark as Attachment
    CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTDISP), 0, &rVariant));

    // Return hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::AttachFile
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::AttachFile(LPCSTR pszFilePath, IStream *pstmFile, LPHBODY phBody)
{
    // Locals
    HRESULT     hr=S_OK;
    IStream    *pstmTemp=NULL;
    LPSTR       pszCntType=NULL,
                pszSubType=NULL,
                pszFName=NULL;
    HBODY       hBody;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (phBody)
        *phBody = NULL;

    // Did the user give me a file stream
    if (NULL == pstmFile)
    {
        // Get File Stream
        CHECKHR(hr = OpenFileStream((LPSTR)pszFilePath, OPEN_EXISTING, GENERIC_READ, &pstmTemp));

        // Set The File Stream
        pstmFile = pstmTemp;
    }

    // Attach as object
    CHECKHR(hr = AttachObject(IID_IStream, (LPVOID)pstmFile, &hBody));

    // Get mime file info
    hr = MimeOleGetFileInfo((LPSTR)pszFilePath, &pszCntType, &pszSubType, NULL, &pszFName, NULL);

    // Failure
    if (FAILED(hr) && NULL == pszFName)
    {
        Assert(FALSE);
        hr = TrapError(hr);
        goto exit;
    }

    // Success
    hr = S_OK;

    // Attachment FileName
    if (pszFName)
    {
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszFName;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_FILENAME), 0, &rVariant));
    }

    // ContentType
    if (pszCntType && pszSubType)
    {
        // PriType
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszCntType;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_PRITYPE), 0, &rVariant));

        // SubType
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszSubType;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_ATT_SUBTYPE), 0, &rVariant));
    }

    // Otherwise, default content type
    else
    {
        // Default to text/plain
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = (LPSTR)STR_MIME_TEXT_PLAIN;
        CHECKHR(hr = SetBodyProp(hBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Return hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeRelease(pstmTemp);
    SafeMemFree(pszCntType);
    SafeMemFree(pszSubType);
    SafeMemFree(pszFName);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetAttachments
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach)
{
    // Locals
    HRESULT     hr=S_OK;
    LPHBODY     prghBody=NULL;
    ULONG       cAlloc=0;
    ULONG       cCount=0;
    ULONG       i;
    PROPVARIANT rVariant;

    // Invalid Arg
    if (NULL == pcAttach)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pprghAttach)
        *pprghAttach = NULL;
    *pcAttach = 0;

    // Setup Variant
    rVariant.vt = VT_UI4;

    // Walk through the tree and look for unrendered bodies
    for (i=0; i<m_rTree.cNodes; i++)
    {
        // Better have it
        if (NULL == m_rTree.prgpNode[i])
            continue;

        // Not a multipart
        if (_IsMultiPart(m_rTree.prgpNode[i]))
            continue;

        // Raid-44193: reply to multipart/digest message yields  text attachment
        if (m_rTree.prgpNode[i]->pBody->IsType(IBT_EMPTY) == S_OK)
            continue;

        // PID_ATT_RENDERED
        if (FAILED(m_rTree.prgpNode[i]->pContainer->GetProp(PIDTOSTR(PID_ATT_RENDERED), 0, &rVariant)) || FALSE == rVariant.ulVal)
        {
            // Realloc
            if (cCount + 1 > cAlloc)
            {
                // Realloc
                CHECKHR(hr = HrRealloc((LPVOID *)&prghBody, sizeof(HBODY) * (cAlloc + 10)));

                // Increment cAlloc
                cAlloc += 10;
            }

            // Insert the hBody
            prghBody[cCount] = m_rTree.prgpNode[i]->hBody;

            // Increment Count
            cCount++;
        }
    }

    // Done
    *pcAttach = cCount;

    // Return hBody Array
    if (pprghAttach)
    {
        *pprghAttach = prghBody;
        prghBody = NULL;
    }


exit:
    // Cleanup
    SafeMemFree(prghBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

#if 0
// --------------------------------------------------------------------------------
// CWebBookContentTree::GetAttachments
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetAttachments(ULONG *pcAttach, LPHBODY *pprghAttach)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cBodies;
    LPHBODY     prghBody=NULL;
    HBODY       hRoot;

    // Invalid Arg
    if (NULL == pcAttach)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    if (pprghAttach)
        *pprghAttach = NULL;
    *pcAttach = 0;

    // Count the number of items in the tree
    CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

    // No Data
    if (0 == cBodies)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // Get the root body
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // Allocate an array that can old the handle to all text items
    CHECKALLOC(prghBody = (LPHBODY)g_pMalloc->Alloc(sizeof(HBODY) * cBodies));

    // Zero Init
    ZeroMemory(prghBody, sizeof(HBODY) * cBodies);

    // Get Content
    CHECKHR(hr = _HrEnumeratAttachments(hRoot, pcAttach, prghBody));

    // Return this array
    if (pprghAttach && *pcAttach > 0)
    {
        *pprghAttach = prghBody;
        prghBody = NULL;
    }

exit:
    // Cleanup
    SafeMemFree(prghBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrEnumeratAttachments
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrEnumeratAttachments(HBODY hBody, ULONG *pcBodies, LPHBODY prghBody)
{
    // Locals
    HRESULT     hr=S_OK,
                hrFind;
    HBODY       hChild;
    ULONG       i;

    // multipart/alternative
    if (IsContentType(hBody, STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // Is Alternative
        if (IsContentType(hBody, NULL, STR_SUB_ALTERNATIVE) == S_OK)
        {
            // Get First Child
            hrFind = GetBody(IBL_FIRST, hBody, &hChild);
            while(SUCCEEDED(hrFind) && NULL != hChild)
            {
                // If this text type is support by the client, then 
                for (i=0; i<ARRAYSIZE(g_rgTextInfo); i++)
                {
                    // text/XXXX
                    if (IsContentType(hChild, STR_CNT_TEXT, g_rgTextInfo[i].pszSubType) == S_OK)
                        goto exit;
                }

                // Next Child
                hrFind = GetBody(IBL_NEXT, hChild, &hChild);
            }
        }

        // Get First Child
        hrFind = GetBody(IBL_FIRST, hBody, &hChild);
        while(SUCCEEDED(hrFind) && hChild)
        {
            // Bind the body table for this dude
            CHECKHR(hr = _HrEnumeratAttachments(hChild, pcBodies, prghBody));

            // Next Child
            hrFind = GetBody(IBL_NEXT, hChild, &hChild);
        }
    }

    // Otherwise, is it an attachment
    else if (IsBodyType(hBody, IBT_ATTACHMENT) == S_OK)
    {
        // Insert as an attachment
        prghBody[(*pcBodies)] = hBody;
        (*pcBodies)++;
    }

exit:
    // Done
    return hr;
}
#endif

// --------------------------------------------------------------------------------
// CWebBookContentTree::AttachURL
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::AttachURL(LPCSTR pszBase, LPCSTR pszURL, DWORD dwFlags, 
    IStream *pstmURL, LPSTR *ppszCIDURL, LPHBODY phBody)
{
    // Locals
    HRESULT           hr=S_OK;
    HBODY             hRoot,
                      hBody=NULL,
                      hSection;
    CHAR              szCID[CCHMAX_CID];
    LPSTR             pszFree=NULL;
    LPSTR             pszBaseFree=NULL;
    IMimeBody        *pBody=NULL;
    LPWSTR            pwszUrl=NULL;
    IMimeWebDocument *pWebDocument=NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the Root Body
    CHECKHR(hr = GetBody(IBL_ROOT, NULL, &hRoot));

    // multipart/mixed
    if (ISFLAGSET(dwFlags, URL_ATTACH_INTO_MIXED))
    {
        // Get Mixed Section
        CHECKHR(hr = MimeOleGetMixedSection(this, TRUE, &hSection, NULL));
    }

    // multipart/related
    else
    {
        // Get Mixed Section
        CHECKHR(hr = MimeOleGetRelatedSection(this, TRUE, &hSection, NULL));
    }

    // Get Default Base
    if (NULL == pszBase && SUCCEEDED(_HrGetDefaultBase(hSection, &pszBaseFree)))
        pszBase = pszBaseFree;

    // Append a child to the mixed part...
    CHECKHR(hr = InsertBody(IBL_LAST, hSection, &hBody));

    // Bind to IMimeBody
    CHECKHR(hr = BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody));

    // If I have a stream
    if (pstmURL)
    {
        // Set the data
        CHECKHR(hr = pBody->SetData(IET_BINARY, NULL, NULL, IID_IStream, (LPVOID)pstmURL));
    }

    // Otherwise, Set the content type
    else
    {
        // Create a WebDocument
        CHECKHR(hr = MimeOleCreateWebDocument(pszBase, pszURL, &pWebDocument));

        // Set Web Document on the body object
        CHECKHR(hr = pBody->SetData(IET_BINARY, NULL, NULL, IID_IMimeWebDocument, (LPVOID)pWebDocument));
    }

    // URL_ATTACH_SET_CNTTYPE
    if (ISFLAGSET(dwFlags, URL_ATTACH_SET_CNTTYPE))
    {
        // Locals
        LPSTR pszCntType=(LPSTR)STR_MIME_APPL_STREAM;
        PROPVARIANT rVariant;

        // Get the Content Type from the Url
        if (SUCCEEDED(MimeOleContentTypeFromUrl(pszBase, pszURL, &pszFree)))
            pszCntType = pszFree;

        // Setup the Variant
        rVariant.vt = VT_LPSTR;
        rVariant.pszVal = pszCntType;

        // Set the Content Type
        CHECKHR(hr = pBody->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), 0, &rVariant));
    }

    // Set Content-Base
    if (pszBase && pszBase != pszBaseFree)
    {
        // Set Base
        CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTBASE), 0, pszBase));
    }

    // User Wants a CID: URL Back
    if (ISFLAGSET(dwFlags, URL_ATTACH_GENERATE_CID))
    {
        // Generate CID
        CHECKHR(hr = MimeOleGenerateCID(szCID, CCHMAX_CID, FALSE));

        // Set the Body Property
        CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTID), 0, szCID));

        // User Wants CID Back...
        if (ppszCIDURL)
            {
            CHECKALLOC(MemAlloc((LPVOID *)ppszCIDURL, lstrlen(szCID) + 5));
            lstrcpy(*ppszCIDURL, "cid:");
            lstrcat(*ppszCIDURL, szCID);
            }
    }
    else
    {
        // Setup Content-Location
        CHECKHR(hr = MimeOleSetPropA(pBody, PIDTOSTR(PID_HDR_CNTLOC), 0, pszURL));
    }

    // Return the hBody
    if (phBody)
        *phBody = hBody;

exit:
    // Cleanup
    SafeMemFree(pszFree);
    SafeMemFree(pszBaseFree);
    SafeMemFree(pwszUrl);
    SafeRelease(pBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::SplitMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::SplitMessage(ULONG cbMaxPart, IMimeMessageParts **ppParts)
{
    EnterCriticalSection(&m_cs);
    HRESULT hr = MimeOleSplitMessage(this, cbMaxPart, ppParts);
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::EnumFormatEtc
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppEnum)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cFormat=0;
    DATAOBJINFO     rgFormat[CFORMATS_IDATAOBJECT];
    ULONG           cBodies;
    IEnumFORMATETC *pEnum=NULL;
    DWORD           dwFlags;

    // Invalid Arg
    if (NULL == ppEnum)
        return TrapError(E_INVALIDARG);
    if (DATADIR_SET == dwDirection)
        return TrapError(E_NOTIMPL);
    else if (DATADIR_GET != dwDirection)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *ppEnum = NULL;

    // No Data...
    CHECKHR(hr = CountBodies(NULL, TRUE, &cBodies));

    // If there are bodies...
    if (cBodies)
    {
        // I can always give CF_INETMSG now...
        SETDefFormatEtc(rgFormat[cFormat].fe, CF_INETMSG, TYMED_ISTREAM |  TYMED_HGLOBAL);
        cFormat++;

        // Get Some Flags
        dwFlags = DwGetFlags();

        // Get the HTML body stream
        if (ISFLAGSET(dwFlags, IMF_HTML))
        {
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_HTML, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;
        }

        // Get the TEXT body stream
        if (ISFLAGSET(dwFlags, IMF_PLAIN))
        {
            SETDefFormatEtc(rgFormat[cFormat].fe, CF_TEXT, TYMED_ISTREAM |  TYMED_HGLOBAL);
            cFormat++;
        }
    }

    // Create the enumerator
    CHECKHR(hr = CreateEnumFormatEtc(GetInner(), cFormat, rgFormat, NULL, &pEnum));

    // Set Return
    *ppEnum = pEnum;
    (*ppEnum)->AddRef();
    
exit:
    // Cleanup
    SafeRelease(pEnum);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetCanonicalFormatEtc
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetCanonicalFormatEtc(FORMATETC *pFormatIn, FORMATETC *pFormatOut)
{
    // E_INVALIDARG
    if (NULL == pFormatOut)
        return E_INVALIDARG;

    // Target device independent
    pFormatOut->ptd = NULL;

    // Done
    return DATA_S_SAMEFORMATETC;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetData
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetData(FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pstmData=NULL;
    BOOL            fFreeGlobal=FALSE;

    // E_INVALIDARG
    if (NULL == pFormat || NULL == pMedium)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // TYMED_ISTREAM
    if (ISFLAGSET(pFormat->tymed, TYMED_ISTREAM))
    {
        // RAID-30041: vstreams do not currenlty handle the CopyTo call correctly and OLE
        // seems to fail quietly. I'm switching this back to HGLOBAL stream until ricg fixes
        // the virtual stream object.
        if (FAILED(CreateStreamOnHGlobal(NULL, TRUE, &pstmData)))
        //if (FAILED(MimeOleCreateVirtualStream(&pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Get data object source
        if (FAILED(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData)))
            goto exit;

        // Set pmedium
        pMedium->tymed = TYMED_ISTREAM;
        pMedium->pstm = pstmData;
        pstmData->AddRef();
    }

    // TYMED_HGLOBAL
    else if (ISFLAGSET(pFormat->tymed, TYMED_HGLOBAL))
    {
        fFreeGlobal = TRUE;

        // don't have the stream release the global
        if (FAILED(CreateStreamOnHGlobal(NULL, FALSE, &pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }
        
        // Get data object source
        if (FAILED(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData)))
            goto exit;

        // Create HGLOBAL from stream
        if (FAILED(GetHGlobalFromStream(pstmData, &pMedium->hGlobal)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Set pmedium type
        pMedium->tymed = TYMED_HGLOBAL;
        // Release the strema
        pstmData->Release();
        pstmData = NULL;
        fFreeGlobal = FALSE;
    }

    // Bad Medium Type
    else
    {
        hr = TrapError(DV_E_TYMED);
        goto exit;
    }

exit:
    // Cleanup
    if (pstmData)
    {
        if (fFreeGlobal)
        {
            // we may fail had have to free the hglobal
            HGLOBAL hGlobal;

            // Free the underlying HGLOBAL
            if (SUCCEEDED(GetHGlobalFromStream(pstmData, &hGlobal)))
                GlobalFree(hGlobal);
        }

        // Release the Stream
        pstmData->Release();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetDataHere
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetDataHere(FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTREAM        pstmData=NULL;
    ULONG           cb;
    LPVOID          pv=NULL;

    // E_INVALIDARG
    if (NULL == pFormat || NULL == pMedium)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // TYMED_ISTREAM
    if (ISFLAGSET(pFormat->tymed, TYMED_ISTREAM))
    {
        // No dest stream...
        if (NULL == pMedium->pstm)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set pmedium
        pMedium->tymed = TYMED_ISTREAM;

        // Get the data
        CHECKHR(hr = _HrDataObjectGetSource(pFormat->cfFormat, pMedium->pstm));
    }

    // TYMED_HGLOBAL
    else if (ISFLAGSET(pFormat->tymed, TYMED_HGLOBAL))
    {
        // No dest stream...
        if (NULL == pMedium->hGlobal)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Set pmedium type
        pMedium->tymed = TYMED_HGLOBAL;

        // Create a place to store the data
        if (FAILED(MimeOleCreateVirtualStream(&pstmData)))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Get data object source
        CHECKHR(hr = _HrDataObjectGetSource(pFormat->cfFormat, pstmData));

        // Get Size
        CHECKHR(hr = HrGetStreamSize(pstmData, &cb));

        // Is it big enought ?
        if (cb > GlobalSize(pMedium->hGlobal))
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Lock the hglobal
        pv = GlobalLock(pMedium->hGlobal);
        if (NULL == pv)
        {
            hr = TrapError(STG_E_MEDIUMFULL);
            goto exit;
        }

        // Copy the Data
        CHECKHR(hr = HrCopyStreamToByte(pstmData, (LPBYTE)pv, NULL));

        // Unlock it
        GlobalUnlock(pMedium->hGlobal);
    }

    // Bad Medium Type
    else
    {
        hr = TrapError(DV_E_TYMED);
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pstmData);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrDataObjectWriteHeader
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrDataObjectWriteHeader(LPSTREAM pStream, UINT idsHeader, LPSTR pszData)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szRes[255];

    // Invalid Arg
    Assert(idsHeader && pStream && pszData);

    // Load Localized Header Name
    LoadString(g_hLocRes, idsHeader, szRes, ARRAYSIZE(szRes));

    // Write Header Name
    CHECKHR(hr = pStream->Write(szRes, lstrlen(szRes), NULL));

    // Write space
    CHECKHR(hr = pStream->Write(c_szColonSpace, lstrlen(c_szColonSpace), NULL));

    // Write Data
    CHECKHR(hr = pStream->Write(pszData, lstrlen(pszData), NULL));

    // Final CRLF
    CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrDataObjectGetHeader
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrDataObjectGetHeader(LPSTREAM pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPVARIANT     rVariant;

    // Init
    MimeOleVariantInit(&rVariant);

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_FROM), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeader(pStream, IDS_FROM, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_TO), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeader(pStream, IDS_TO, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_CC), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeader(pStream, IDS_CC, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_LPSTR;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), 0, &rVariant)))
    {
        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeader(pStream, IDS_SUBJECT, rVariant.pszVal));

        // Free It
        MimeOleVariantFree(&rVariant);
    }

    // Init Variant
    rVariant.vt = VT_FILETIME;

    // Get address table from header...
    if (SUCCEEDED(GetBodyProp(HBODY_ROOT, PIDTOSTR(PID_ATT_RECVTIME), 0, &rVariant)))
    {
        // Locals
        CHAR szDate[255];

        // Convert to user friendly date format
        CchFileTimeToDateTimeSz(&rVariant.filetime, szDate, ARRAYSIZE(szDate), DTM_NOSECONDS | DTM_LONGDATE);

        // Write it
        CHECKHR(hr = _HrDataObjectWriteHeader(pStream, IDS_DATE, szDate));
    }

    // Final CRLF
    CHECKHR(hr = pStream->Write(g_szCRLF, lstrlen(g_szCRLF), NULL));

exit:
    // Cleanup
    MimeOleVariantFree(&rVariant);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrDataObjectGetSource
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrDataObjectGetSource(CLIPFORMAT cfFormat, LPSTREAM pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTREAM    pstmSrc=NULL;

    // Invalid Arg
    Assert(pStream);

    // text body
    if (CF_TEXT == cfFormat)
    {
        // Get Plain Text Source
        CHECKHR(hr = GetTextBody(TXT_PLAIN, IET_BINARY, &pstmSrc, NULL));
    }

    // HTML Body
    else if (CF_HTML == cfFormat)
    {
        // Get HTML Text Source
        CHECKHR(hr = GetTextBody(TXT_HTML, IET_BINARY, &pstmSrc, NULL));
    }

    // Raw Message Stream
    else if (CF_INETMSG == cfFormat)
    {
        // Get source
        CHECKHR(hr = GetMessageSource(&pstmSrc, COMMIT_ONLYIFDIRTY));
    }

    // Format not handled
    else
    {
        hr = DV_E_FORMATETC;
        goto exit;
    }

    // No Data
    if (NULL == pstmSrc)
    {
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // Rewind Source
    CHECKHR(hr = HrRewindStream(pstmSrc));

    // If TEXT, put in friendly header
    if (CF_TEXT == cfFormat)
    {
        CHECKHR(hr = _HrDataObjectGetHeader(pStream));
    }

    // Copy Source to destination
    CHECKHR(hr = HrCopyStream(pstmSrc, pStream, NULL));

    // Commit
    CHECKHR(hr = pStream->Commit(STGC_DEFAULT));

    // Rewind it
    CHECKHR(hr = HrRewindStream(pStream));

exit:
    // Cleanup
    SafeRelease(pstmSrc);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::QueryGetData
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::QueryGetData(FORMATETC *pFormat)
{
    // Invalid Arg
    if (NULL == pFormat)
        return TrapError(E_INVALIDARG);

    // Bad Medium
    if (!(TYMED_ISTREAM & pFormat->tymed) && !(TYMED_HGLOBAL & pFormat->tymed))
        return DV_E_TYMED;

    // Bad format
    if ((CF_TEXT    != pFormat->cfFormat) &&
        (CF_HTML    != pFormat->cfFormat) &&
        (CF_INETMSG != pFormat->cfFormat))
        return DV_E_FORMATETC;

    // Success
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::OnStartBinding
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::OnStartBinding(DWORD dwReserved, IBinding *pBinding)
{
    // Locals
    HBODY hBody;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // I Should not have a current binding
    Assert(NULL == m_pBinding);

    // Remove Bind Finished Flag
    FLAGCLEAR(m_dwState, TREESTATE_BINDDONE);

    // Assume the Binding
    if (pBinding)
    {
        // Assume It
        m_pBinding = pBinding;
        m_pBinding->AddRef();
    }

    // Get the Root Body
    Assert(m_pRootNode);

    // Current Bind Result
    m_hrBind = S_OK;

    // Bind to that object
    m_pBindNode = m_pRootNode;

    // Set Bound Start
    m_pBindNode->boundary = BOUNDARY_ROOT;

    // Set Node Bind State
    m_pBindNode->bindstate = BINDSTATE_PARSING_HEADER;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetPriority
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetPriority(LONG *plPriority)
{
    // Normal Priority
    *plPriority = THREAD_PRIORITY_NORMAL;

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::OnLowResource
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::OnLowResource(DWORD reserved)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If we have a binding operation, try to abort it
    if (m_pBinding)
        m_pBinding->Abort();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pszStatusText)
{
    // Debuging
    //DebugTrace("CWebBookContentTree::OnProgress - %d of %d Bytes\n", ulProgress, ulProgressMax);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::OnStopBinding
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::OnStopBinding(HRESULT hrResult, LPCWSTR pszError)
{
    // Locals
    FINDBODY    rFind;
    HBODY       hMixed;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release the Binding Object
    SafeRelease(m_pBinding);

    // Bind Finished
    FLAGSET(m_dwState, TREESTATE_BINDDONE);

    // No m_pInternet Object ?
    if (NULL == m_pInternet)
    {
        m_hrBind = TrapError(E_FAIL);
        goto exit;
    }

    // It must be fully available
    m_pInternet->SetFullyAvailable(TRUE);

    // Make sure we have read all the way to the end of the stream
    m_pInternet->HrReadToEnd();

    // Keep Saving Total
    m_cbMessage = m_pInternet->DwGetOffset();

#ifdef DEBUG
    STATSTG rStat;
    SideAssert(SUCCEEDED(m_pStmLock->Stat(&rStat, STATFLAG_NONAME)));
#ifdef MAC
    if ((0 == rStat.cbSize.LowPart) && (rStat.cbSize.LowPart != m_cbMessage))
        DebugTrace("CWebBookContentTree Size Difference m_pStmLock::Stat = %d, m_cbMessage = %d\n", rStat.cbSize.LowPart, m_cbMessage);
#else   // !MAC
    if (rStat.cbSize.QuadPart != m_cbMessage)
        DebugTrace("CWebBookContentTree Size Difference m_pStmLock::Stat = %d, m_cbMessage = %d\n", rStat.cbSize.QuadPart, m_cbMessage);
#endif  // MAC        
#endif

    // Terminate current parsing state
    if (m_pBindNode)
    {
        // Set Error
        if (SUCCEEDED(m_hrBind))
            m_hrBind = TrapError(E_FAIL);

        // Mark remaining bodies as incomplete
        while(m_pBindNode)
        {
            // Must not be complete
            FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

            // Must not have found the end
            Assert(0 == m_pBindNode->cbBodyEnd);

            // cbBodyEnd
            m_pBindNode->cbBodyEnd = m_cbMessage;

            // Pop the stack
            m_pBindNode = m_pBindNode->pBindParent;
        }
    }

    // Check hrResult
    if (FAILED(hrResult) && SUCCEEDED(m_hrBind))
        m_hrBind = hrResult;

#ifndef MAC
    // DispatchBindRequest
    _ProcessPendingUrlRequests();
#endif  // !MAC

    // Bind Node Better be Null
    m_pBindNode = NULL;

    // Release the Internet Stream Object
    SafeRelease(m_pInternet);

    // If we have a bind stream...
    if (m_pStmBind)
    {
#ifdef DEBUG
        // m_pStmBind->DebugDumpDestStream("d:\\binddst.txt");
#endif
        // Get hands off source
        m_pStmBind->HandsOffSource();

        // Release, m_pStmLock should still have this object
        SideAssert(m_pStmBind->Release() > 0);

        // Don't release it again
        m_pStmBind = NULL;
    }

    // Only do this if the client doesn't support inlining multiple text bodies, such as Outlook Express
    if (FALSE == g_rDefTreeOptions.fCanInlineText)
    {
        // Raid 53456: mail: We should be displaying the plain text portion and making enriched text an attachment for attached msg
        // Raid 53470: mail:  We are not forwarding the attachment in the attached message
        // I am going to find the first multipart/mixed section, then find the first text/plain body, and then 
        // mark all of the text/*, non-attachment bodies after that as attachments
        ZeroMemory(&rFind, sizeof(FINDBODY));
        rFind.pszPriType = (LPSTR)STR_CNT_MULTIPART;
        rFind.pszSubType = (LPSTR)STR_SUB_MIXED;

        // Find First
        if (SUCCEEDED(FindFirst(&rFind, &hMixed)))
        {
            // Locals
            HRESULT     hrFind;
            HBODY       hChild;
            HBODY       hTextBody=NULL;

            // Loop through the children
            hrFind = GetBody(IBL_FIRST, hMixed, &hChild);
            while(SUCCEEDED(hrFind) && hChild)
            {
                // Not an attachment
                if (S_FALSE == IsBodyType(hChild, IBT_ATTACHMENT))
                {
                    // Is text/plain
                    if (S_OK == IsContentType(hChild, STR_CNT_TEXT, STR_SUB_PLAIN))
                    {
                        hTextBody = hChild;
                        break;
                    }

                    // Is text/html
                    if (S_OK == IsContentType(hChild, STR_CNT_TEXT, STR_SUB_HTML))
                    {
                        hTextBody = hChild;
                        break;
                    }
                }

                // Find Next
                hrFind = GetBody(IBL_NEXT, hChild, &hChild);
            }

            // If we found a text body
            if (hTextBody)
            {
                // Locals
                PROPVARIANT rAttachment;

                // Setup the variant
                rAttachment.vt = VT_LPSTR;
                rAttachment.pszVal = (LPSTR)STR_DIS_ATTACHMENT;

                // Loop through the children
                hrFind = GetBody(IBL_FIRST, hMixed, &hChild);
                while(SUCCEEDED(hrFind) && hChild)
                {
                    // Is text/*
                    if (hChild != hTextBody && S_OK == IsContentType(hChild, STR_CNT_TEXT, NULL) && S_FALSE == IsBodyType(hChild, IBT_ATTACHMENT))
                    {
                        // Mark as attachment
                        SetBodyProp(hChild, PIDTOSTR(PID_HDR_CNTDISP), 0, &rAttachment);
                    }

                    // Find Next
                    hrFind = GetBody(IBL_NEXT, hChild, &hChild);
                }
            }
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return m_hrBind;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::GetBindInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::GetBindInfo(DWORD *grfBINDF, BINDINFO *pBindInfo)
{
#ifdef MAC
    return E_FAIL;
#else   // !MAC
    // Setup the BindInfo
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;

    // Done
    return S_OK;
#endif  // MAC
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrInitializeStorage
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrInitializeStorage(IStream *pStream)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwOffset;

    // Invalid Arg
    Assert(pStream && NULL == m_pInternet && NULL == m_pStmLock && NULL == m_pStmBind);

    // TREESTATE_BINDUSEFILE
    if (ISFLAGSET(m_dwState, TREESTATE_BINDUSEFILE))
    {
        // Create a Binding Stream
        CHECKALLOC(m_pStmBind = new CBindStream(pStream));

        // Set pStmSource
        pStream = (IStream *)m_pStmBind;
    }

    // $$BUGBUG$$ Urlmon fails on getting the current position of a stream
    if (FAILED(HrGetStreamPos(pStream, &dwOffset)))
        dwOffset = 0;

    // Create a ILockBytes
    CHECKALLOC(m_pStmLock = new CStreamLockBytes(pStream));

    // Create a Text Stream
    CHECKALLOC(m_pInternet = new CInternetStream);

    // Initialize the TextStream
    m_pInternet->InitNew(dwOffset, m_pStmLock);

exit:
    // Failure
    if (FAILED(hr))
    {
        SafeRelease(m_pStmLock);
        SafeRelease(m_pInternet);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::OnDataAvailable
// --------------------------------------------------------------------------------
STDMETHODIMP CWebBookContentTree::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pFormat, STGMEDIUM *pMedium)
{
    // Locals
    HRESULT         hr=S_OK;

    // No Storage Medium
    if (NULL == pMedium || TYMED_ISTREAM != pMedium->tymed || NULL == pMedium->pstm)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Trace
    // DebugTrace("CWebBookContentTree::OnDataAvailable - Nodes=%d, m_pBindNode=%0x, dwSize = %d\n", m_rTree.cNodes, m_pBindNode, dwSize);

    // Do I have an internal lock bytes yet ?
    if (NULL == m_pStmLock)
    {
        // InitializeStorage
        CHECKHR(hr = _HrInitializeStorage(pMedium->pstm));

        // Assume not fully available
        if (BINDSTATUS_ENDDOWNLOADDATA == grfBSCF)
            m_pInternet->SetFullyAvailable(TRUE);
        else
            m_pInternet->SetFullyAvailable(FALSE);
    }

    // Done downloading the data
    else if (BINDSTATUS_ENDDOWNLOADDATA == grfBSCF)
        m_pInternet->SetFullyAvailable(TRUE);

    // If we are in a failed read state
    if (SUCCEEDED(m_hrBind))
    {
        // State Pumper
        while(m_pBindNode)
        {
            // Execute current - could return E_PENDING
            hr = ((this->*m_rgBindStates[m_pBindNode->bindstate])());

            // Failure
            if (FAILED(hr))
            {
                // E_PENDING
                if (E_PENDING == hr)
                    goto exit;

                // Otherwise, set m_hrBind
                m_hrBind = hr;

                // Done
                break;
            }
        }
    }

    // If m_hrBind has failed, read until endof stream
    if (FAILED(m_hrBind))
    {
        // Read to the end of the internet stream
        CHECKHR(hr = m_pInternet->HrReadToEnd());
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrBindParsingHeader
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrBindParsingHeader(void)
{
    // Locals
    HRESULT     hr=S_OK;
    MIMEVARIANT rVariant;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_PARSING_HEADER, FALSE);

    // Load the Current Body with the header
    CHECKHR(hr = m_pBindNode->pContainer->Load(m_pInternet));

    // End of the Header
    m_pBindNode->cbBodyStart = m_pInternet->DwGetOffset();

    // Multipart ?
    if (_IsMultiPart(m_pBindNode))
    {
        // Setup the variant
        rVariant.type = MVT_STRINGA;

        // Get the boundary String
        CHECKHR(hr = m_pBindNode->pContainer->GetProp(SYM_PAR_BOUNDARY, 0, &rVariant));

        // Set PropStringA
        m_pBindNode->rBoundary.pszVal = rVariant.rStringA.pszVal;
        m_pBindNode->rBoundary.cchVal = rVariant.rStringA.cchVal;

        // Free this boundary later
        FLAGCLEAR(m_pBindNode->dwState, NODESTATE_BOUNDNOFREE);

        // Modify Bind Parser State
        m_pBindNode->bindstate = BINDSTATE_FINDING_MIMEFIRST;
    }

    // Otherwise
    else
    {
        // Message In a Message
        if (m_pBindNode->pContainer->IsContentType(STR_CNT_MESSAGE, NULL) == S_OK)
        {
            // We are parsing a message attachment
            FLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE);
        }

        // Otherwise, if parent and parent is a multipart/digest
        else if (m_pBindNode->pParent && m_pBindNode->pParent->pContainer->IsContentType(STR_CNT_MULTIPART, STR_SUB_DIGEST) == S_OK &&
                 m_pBindNode->pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTTYPE)) == S_FALSE)
        {
            // Change the Content Type
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MSG_RFC822);

            // This is a message
            FLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE);
        }

        // If parsing a body inside of a parent multipart section
        if (m_pBindNode->pParent && !ISFLAGSET(m_pBindNode->pParent->dwType, NODETYPE_FAKEMULTIPART))
        {
            // Find Next Mime Part
            m_pBindNode->bindstate = BINDSTATE_FINDING_MIMENEXT;
        }

        // Otherwise, Reading Body and Looking for a uuencode begin boundary
        else
        {
            // Search for nested uuencoded block of data
            m_pBindNode->bindstate = BINDSTATE_FINDING_UUBEGIN;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_OnFoundNodeEnd
// --------------------------------------------------------------------------------
void CWebBookContentTree::_OnFoundNodeEnd(DWORD cbBoundaryStart, HRESULT hrBind /* =S_OK */)
{
    if (cbBoundaryStart < 2 || cbBoundaryStart == m_pBindNode->cbBodyStart)
        m_pBindNode->cbBodyEnd = m_pBindNode->cbBodyStart;
    else
        m_pBindNode->cbBodyEnd = cbBoundaryStart - 2;

    // This node is finished binding
    _BindNodeComplete(m_pBindNode, hrBind);

    // POP the stack
    m_pBindNode = m_pBindNode->pBindParent;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_OnFoundMultipartEnd
// --------------------------------------------------------------------------------
void CWebBookContentTree::_OnFoundMultipartEnd(void)
{
    // Set m_pBindNode which is a multipart, end
    m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

    // This node is finished binding
    _BindNodeComplete(m_pBindNode, S_OK);

    // Finished with the multipart, pop it off the stack
    m_pBindNode = m_pBindNode->pBindParent;

    // If I still have a bind node, it should now be looking for a mime first boundary
    if (m_pBindNode)
    {
        // New Bind State
        m_pBindNode->bindstate = BINDSTATE_FINDING_MIMEFIRST;
    }
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrBindFindingMimeFirst
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrBindFindingMimeFirst(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_MIMEFIRST, TRUE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // Is MimeBoundary
        boundary = _GetMimeBoundaryType(&rLine, &m_pBindNode->rBoundary);
    }

    // BOUNDARY_MIMENEXT
    if (BOUNDARY_MIMENEXT == boundary)
    {
        // MultipartMimeNext
        CHECKHR(hr = _HrMultipartMimeNext(cbBoundaryStart));
    }

    // RAID-38241: Mail:  some attached files not getting parsed from Communicator to OE
    // RAID-31255: multipart/mixed with single child which is multipart/alternative
    else if (BOUNDARY_MIMEEND == boundary)
    {
        // Finished with a multipart
        if (_IsMultiPart(m_pBindNode))
            _OnFoundMultipartEnd();

        // Found end of current node
        else
            _OnFoundNodeEnd(cbBoundaryStart);
    }

    else
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Get Offset
        DWORD dwOffset = m_pInternet->DwGetOffset();

        // Convert to a text part only if we read more than two bytes from body start
        if (dwOffset > m_pBindNode->cbBodyStart && dwOffset - m_pBindNode->cbBodyStart > 2)
            m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN);

        // Boundary Mismatch
        hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

        // This node is finished binding
        _OnFoundNodeEnd(dwOffset, hr);

        // Done
        goto exit;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrMultipartMimeNext
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrMultipartMimeNext(DWORD cbBoundaryStart)
{
    // Locals
    HRESULT         hr=S_OK;
    HBODY           hBody;
    LPTREENODEINFO  pChild;

    // Get the Root Body
    CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

    // Bind to that object
    pChild = _PNodeFromHBody(hBody);

    // Align the stack correctly
    pChild->pBindParent = m_pBindNode;

    // Setup Offset Information
    pChild->boundary = BOUNDARY_MIMENEXT;
    pChild->cbBoundaryStart = cbBoundaryStart;
    pChild->cbHeaderStart = m_pInternet->DwGetOffset();

    // Assume the Boundary
    pChild->rBoundary.pszVal = m_pBindNode->rBoundary.pszVal;
    pChild->rBoundary.cchVal = m_pBindNode->rBoundary.cchVal;

    // Don't Free this string...
    FLAGSET(pChild->dwState, NODESTATE_BOUNDNOFREE);

    // New State for parent
    m_pBindNode->bindstate = BINDSTATE_FINDING_MIMENEXT;

    // Set New Current Node
    m_pBindNode = pChild;

    // Change State
    m_pBindNode->bindstate = BINDSTATE_PARSING_HEADER;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrBindFindingMimeNext
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrBindFindingMimeNext(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_MIMENEXT, TRUE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // Next or Ending Mime Boundary
        boundary = _GetMimeBoundaryType(&rLine, &m_pBindNode->rBoundary);
    }

    // Not found
    if (BOUNDARY_NONE == boundary)
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Boundary Mismatch
        hr = TrapError(MIME_E_BOUNDARY_MISMATCH);

        // This node is finished binding
        _OnFoundNodeEnd(m_pInternet->DwGetOffset(), hr);

        // Done
        goto exit;
    }

    // Compute Ending Offset
    _OnFoundNodeEnd(cbBoundaryStart);
   
    // If BOUNDARY_MIMEEND
    if (BOUNDARY_MIMEEND == boundary)
    {
        // OnFoundMultipartEnd
        _OnFoundMultipartEnd();
    }

    // BOUNDARY_MIMENEXT
    else
    {
        // MultipartMimeNext
        CHECKHR(hr = _HrMultipartMimeNext(cbBoundaryStart));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrBindFindingUuencodeBegin
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrBindFindingUuencodeBegin(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbBoundaryStart;
    PROPSTRINGA     rLine;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;
    LPTREENODEINFO  pChild;
    LPSTR           pszFileName=NULL;
    HBODY           hBody;
    BOOL            fAddTextBody=FALSE;
    ULONG           cbTextBodyStart=0;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_UUBEGIN, FALSE);

    // Sit and Spin
    while(1)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // If not parsing a message
        if (!ISFLAGSET(m_pBindNode->dwState, NODESTATE_MESSAGE))
        {
            // Is uuencode begine line
            if (_FIsUuencodeBegin(&rLine, &pszFileName) == TRUE)
            {
                boundary = BOUNDARY_UUBEGIN;
                break;
            }
        }
    }

    // No Boundary
    if (BOUNDARY_NONE == boundary)
    {
        // Body Offset Information
        m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

        // This node is finished binding
        _BindNodeComplete(m_pBindNode, S_OK);

        // Pop the parsing Stack
        m_pBindNode = m_pBindNode->pBindParent;
    }

    // Otherwise, if we hit a uuencode boundary
    else
    {
        // If not a fake multipart yet...
        if (!ISFLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART))
        {
            // Its a faked multipart
            FLAGSET(m_pBindNode->dwType, NODETYPE_FAKEMULTIPART);

            // Free current content type
            CHECKHR(hr = m_pBindNode->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MPART_MIXED));

            // Modify this dudes bound start
            Assert(m_pBindNode->boundary == BOUNDARY_ROOT);

            // Set the parse state
            m_pBindNode->bindstate = BINDSTATE_FINDING_UUBEGIN;
        }

        // ------------------------------------------------------------------------------------
        // \/ \/ \/ Raid 41599 - lost/munged attachments on forward/uuencode \/ \/ \/

        // If root node and body size is greater than sizeof(crlf)
        if (NULL == m_pBindNode->pChildTail && cbBoundaryStart - m_pBindNode->cbBodyStart > 2)
        {
            // Validate bind node
            Assert(m_pRootNode == m_pBindNode && m_pBindNode->cChildren == 0);

            // Set artificial text body start
            cbTextBodyStart = m_pBindNode->cbBodyStart;

            // Yes, add artificial text body
            fAddTextBody = TRUE;
        }

        // Otherwise, if last child parsed had an ending boundary of UUEND, and body size is greater than sizeof(crlf)
        else if (m_pBindNode->pChildTail)
        {
            // De-ref Last Child
            pChild = m_pBindNode->pChildTail;

            // Artificial text body start
            cbTextBodyStart = pChild->cbBodyEnd;

            // AddTextBody ? lstrlen(end\r\n) = 5
            if (BOUNDARY_UUBEGIN == pChild->boundary && !ISFLAGSET(pChild->dwType, NODETYPE_INCOMPLETE))
                cbTextBodyStart += 5;

            // Otherwise, what was the ending boundary
            else
                AssertSz(FALSE, "I should have only seen and uuencoded ending boundary.");

            // Space between last body end and boundary start is greater than sizeof(crlf)
            if (cbBoundaryStart > cbTextBodyStart && cbBoundaryStart - cbTextBodyStart > 2)
                fAddTextBody = TRUE;
        }

        // /\ /\ /\ Raid 41599 - lost/munged attachments on forward/uuencode /\ /\ /\
        // ------------------------------------------------------------------------------------

        // Create Root Body Node
        CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

        // Bind to that object
        pChild = _PNodeFromHBody(hBody);

        // Fixup the STack
        pChild->pBindParent = m_pBindNode;

        // Enough text to create a text/plain body ?
        if (fAddTextBody)
        {
            // This body should assume the new text offsets
            CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_TEXT_PLAIN));

            // Set Encoding
            CHECKHR(hr = pChild->pContainer->SetProp(SYM_HDR_CNTXFER, STR_ENC_7BIT));

            // Set Offsets
            pChild->boundary = BOUNDARY_NONE;
            pChild->cbBoundaryStart = cbTextBodyStart;
            pChild->cbHeaderStart = cbTextBodyStart;
            pChild->cbBodyStart = cbTextBodyStart;
            pChild->cbBodyEnd = cbBoundaryStart;

            // This node is finished binding
            _BindNodeComplete(pChild, S_OK);

            // Create Root Body Node
            CHECKHR(hr = InsertBody(IBL_LAST, m_pBindNode->hBody, &hBody));

            // Bind to that object
            pChild = _PNodeFromHBody(hBody);

            // Fixup the STack
            pChild->pBindParent = m_pBindNode;
        }

        // Set Offsets
        pChild->boundary = BOUNDARY_UUBEGIN;
        pChild->cbBoundaryStart = cbBoundaryStart;
        pChild->cbHeaderStart = cbBoundaryStart;
        pChild->cbBodyStart = m_pInternet->DwGetOffset();

        // Update m_pBindNode
        Assert(m_pBindNode->bindstate == BINDSTATE_FINDING_UUBEGIN);
        m_pBindNode = pChild;

        // Default Node Content Type
        _HrComputeDefaultContent(m_pBindNode, pszFileName);

        // New Node BindState
        m_pBindNode->bindstate = BINDSTATE_FINDING_UUEND;
    }

exit:
    // Cleanup
    SafeMemFree(pszFileName);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_HrBindFindingUuencodeEnd
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::_HrBindFindingUuencodeEnd(void)
{
    // Locals
    HRESULT         hr=S_OK;
    PROPSTRINGA     rLine;
    DWORD           cbBoundaryStart;
    BOUNDARYTYPE    boundary=BOUNDARY_NONE;

    // Invalid Arg
    BINDASSERTARGS(BINDSTATE_FINDING_UUEND, FALSE);

    // Sit and Spin
    while(BOUNDARY_NONE == boundary)
    {
        // Mark Boundary Start
        cbBoundaryStart = m_pInternet->DwGetOffset();

        // Read a line
        CHECKHR(hr = m_pInternet->HrReadLine(&rLine));

        // Zero bytes read, were done, but this should not happen, we should find a boundary first
        if (0 == rLine.cchVal)
            break;

        // UU Encode End
        if (StrCmpN(rLine.pszVal, "end", 3) == 0)
        {
            // UUENCODE end line
            boundary = BOUNDARY_UUEND;

            // Skip the first three chars
            rLine.pszVal += 3;

            // Make sure there is only space after the word end
            while (*rLine.pszVal)
            {
                // LWSP or CRLF
                if (' ' != *rLine.pszVal && '\t' != *rLine.pszVal && chCR != *rLine.pszVal && chLF != *rLine.pszVal)
                {
                    // Oops, this isn't the end
                    boundary = BOUNDARY_NONE;

                    // Done
                    break;
                }

                // Next Char
                rLine.pszVal++;
            }
        }
    }

    // Incomplete
    if (BOUNDARY_UUEND != boundary)
    {
        // Incomplete Body
        FLAGSET(m_pBindNode->dwType, NODETYPE_INCOMPLETE);

        // Adjust body start to boundary start
        m_pBindNode->cbBodyStart = m_pBindNode->cbBoundaryStart;

        // Body End
        m_pBindNode->cbBodyEnd = m_pInternet->DwGetOffset();

        // This node is finished binding
        _BindNodeComplete(m_pBindNode, S_OK);

        // Pop the tree
        m_pBindNode = m_pBindNode->pBindParent;

        // Done
        goto exit;
    }

    // Get the offset
    m_pBindNode->cbBodyEnd = cbBoundaryStart;

    // POP the stack
    m_pBindNode = m_pBindNode->pBindParent;

    // Should now be looking for next uubegin
    Assert(m_pBindNode ? m_pBindNode->bindstate == BINDSTATE_FINDING_UUBEGIN : TRUE);
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_BindNodeComplete
// --------------------------------------------------------------------------------
void CWebBookContentTree::_BindNodeComplete(LPTREENODEINFO pNode, HRESULT hrResult)
{
#ifdef MAC
    return;
#else   // !MAC
    // Locals
    HRESULT         hr=S_OK;
    LPURLREQUEST    pRequest;
    LPURLREQUEST    pNext;

    // The bind for this node is complete
    pNode->bindstate = BINDSTATE_COMPLETE;

    // Save the bind result
    pNode->hrBind = hrResult;

    // If pNode has not been bound yet, lets do it
    if (!ISFLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE))
    {
        // Bind it to the tree
        hr = pNode->pBody->HrBindToTree(m_pStmLock, pNode);

        // If HrBindToTree failed
        if (SUCCEEDED(pNode->hrBind) && FAILED(hr))
            pNode->hrBind = hr;

        // Process the bind Request Table
        _ProcessPendingUrlRequests();
    }

    // Init the Loop
    pRequest = pNode->pResolved;

    // Loop
    while(pRequest)
    {
        // Set Next
        pNext = pRequest->m_pNext;

        // OnComplete
        pRequest->OnComplete(pNode->hrBind);

        // Unlink this pending request
        _RelinkUrlRequest(pRequest, &pNode->pResolved, &m_pComplete);

        // Set pRequest
        pRequest = pNext;
    }

#endif  // MAC
}

#ifndef MAC
// --------------------------------------------------------------------------------
// CWebBookContentTree::HrRegisterRequest
// --------------------------------------------------------------------------------
HRESULT CWebBookContentTree::HrActiveUrlRequest(LPURLREQUEST pRequest)
{
    // Invalid Arg
    if (NULL == pRequest)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Check State
    Assert(m_rRootUrl.pszVal);

    // AddRef the Request
    pRequest->GetInner()->AddRef();

    // Put the Request into the pending list
    _LinkUrlRequest(pRequest, &m_pPending);

    // Process Pending Url Requests
    _ProcessPendingUrlRequests();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_ProcessPendingUrlRequests
// --------------------------------------------------------------------------------
void CWebBookContentTree::_ProcessPendingUrlRequests(void)
{
    // Locals
    LPURLREQUEST pRequest=m_pPending;
    LPURLREQUEST pNext;
    HBODY        hBody;

    // Loop the request
    while(pRequest)
    {
        // Set Next
        pNext = pRequest->m_pNext;

        // Try to resolve the request
        if (FALSE == _FResolveUrlRequest(pRequest) && ISFLAGSET(m_dwState, TREESTATE_BINDDONE))
        {
            // Not found, use default protocol
            pRequest->OnComplete(E_FAIL);

            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);
        }

        // Next
        pRequest = pNext;
    }
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_FResolveUrlRequest
// --------------------------------------------------------------------------------
BOOL CWebBookContentTree::_FResolveUrlRequest(LPURLREQUEST pRequest)
{
    // Locals
    BOOL            fResolved=FALSE;
    HBODY           hBody=NULL;
    LPTREENODEINFO  pNode;
    LPWSTR          pwszCntType=NULL;
    IStream        *pStream=NULL;

    // Is this the root request ?
    if (NULL == pRequest->m_pszBodyUrl)
    {
        // Do I have a user supplied root data stream...I assume its html
        if (m_pRootStm)
        {
            // Use client driven root html stream
#ifndef WIN16
            pRequest->OnComplete(L"text/html", m_pRootStm, this, NULL);
#else
            pRequest->OnComplete("text/html", m_pRootStm, this, NULL);
#endif // !WIN16

            // Unlink this pending request
            _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

            // Done
            fResolved = TRUE;
            goto exit;
        }

        // Otherwise, try to resolve the text/html body
        else if (FAILED(GetTextBody(TXT_HTML, IET_BINARY, NULL, &hBody)))
            goto exit;
    }

    // Otherwise, look for the Url
    else if (FAILED(ResolveURL(NULL, NULL, pRequest->m_pszBodyUrl, URL_RESOLVE_RENDERED, &hBody)))
        goto exit;

    // We better have a body handle by now
    Assert(_FIsValidHandle(hBody) && pRequest);

    // Dereference the body
    pNode = _PNodeFromHBody(hBody);

    // Get the Content Type
    MimeOleGetPropW(pNode->pBody, PIDTOSTR(PID_HDR_CNTTYPE), 0, &pwszCntType);

    // Get the BodyStream
    if (FAILED(pNode->pBody->GetData(IET_BINARY, &pStream)))
        goto exit;

    // Complete
    if (BINDSTATE_COMPLETE == pNode->bindstate)
    {
        // OnComplete
        pRequest->OnComplete(pwszCntType, pStream, this, pNode->hBody);

        // Unlink this pending request
        _RelinkUrlRequest(pRequest, &m_pPending, &m_pComplete);

        // Resolved
        fResolved = TRUE;
        goto exit;
    }

    // Otherwise, start binding
    else if (ISFLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE))
    {
        // Should have pNode->pLockBytes
        Assert(pNode->pLockBytes);

        // Relink Request into the Node
        _RelinkUrlRequest(pRequest, &m_pPending, &pNode->pResolved);

        // Feed the current amount of data read into the binder
        pRequest->OnBinding(pwszCntType, pStream, this, pNode->hBody);

        // Resolved
        fResolved = TRUE;
        goto exit;
    }

exit:
    // Cleanup
    SafeRelease(pStream);
    SafeMemFree(pwszCntType);

    // Done
    return fResolved;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_UnlinkUrlRequest
// --------------------------------------------------------------------------------
void CWebBookContentTree::_RelinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppSource, 
    LPURLREQUEST *ppDest)
{
    // Unlink this pending request
    _UnlinkUrlRequest(pRequest, ppSource);

    // Link the bind request into pNode
    _LinkUrlRequest(pRequest, ppDest);
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_UnlinkUrlRequest
// --------------------------------------------------------------------------------
void CWebBookContentTree::_UnlinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead)
{
    // Invalid Arg
    Assert(pRequest && ppHead);

    // Debug make sure pRequest is part of *ppHead chain
#ifdef DEBUG
    for(LPURLREQUEST pCurr=*ppHead; pCurr!=NULL; pCurr=pCurr->m_pNext)
        if (pCurr == pRequest)
            break;
    AssertSz(pCurr, "pRequest is not part of *ppHead linked list");
#endif

    // Fixup Previous and Next
    LPURLREQUEST pNext = pRequest->m_pNext;
    LPURLREQUEST pPrev = pRequest->m_pPrev;

    // Fixup Links
    if (pNext)
        pNext->m_pPrev = pPrev;
    if (pPrev)
        pPrev->m_pNext = pNext;

    // Fixup ppHead
    if (pRequest == *ppHead)
    {
        Assert(pPrev == NULL);
        *ppHead = pNext;
    }

    // Set Next and Prev
    pRequest->m_pNext = NULL;
    pRequest->m_pPrev = NULL;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_LinkUrlRequest
// --------------------------------------------------------------------------------
void CWebBookContentTree::_LinkUrlRequest(LPURLREQUEST pRequest, LPURLREQUEST *ppHead)
{
    // Invalid Arg
    Assert(pRequest && ppHead);

    // Is the head set
    if (NULL != *ppHead)
    {
        // Set Next
        pRequest->m_pNext = *ppHead;

        // Set Previous
        (*ppHead)->m_pPrev = pRequest;
    }

    // Set the head
    (*ppHead) = pRequest;
}

// --------------------------------------------------------------------------------
// CWebBookContentTree::_ReleaseUrlRequestList
// --------------------------------------------------------------------------------
void CWebBookContentTree::_ReleaseUrlRequestList(LPURLREQUEST *ppHead)
{
    // Locals
    LPURLREQUEST pCurr;
    LPURLREQUEST pNext;

    // Invalid Arg
    Assert(ppHead);

    // Init
    pCurr = *ppHead;

    // Loop the Elements
    while(pCurr)
    {
        // Set Next
        pNext = pCurr->m_pNext;

        // Free pCurr
        pCurr->GetInner()->Release();

        // Next
        pCurr = pNext;
    }

    // Done
    *ppHead = NULL;
}
#endif  // !MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\binhex.h ===
// --------------------------------------------------------------------------------
// Binxhex.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __BINHEX_H
#define __BINHEX_H

// ---------------------------------------------------------------------------------------
// MACBINARY Header
// ---------------------------------------------------------------------------------------

// Byte packing
#pragma pack(1)
typedef struct
{
    BYTE    bMustBeZero1;
    BYTE    cchFileName;
    char    rgchFileName[63];
    DWORD   dwType;
    DWORD   dwCreator;
    BYTE    bFinderFlags;
    BYTE    bMustBeZero2;
    WORD    xIcon;
    WORD    yIcon;
    WORD    wFileID;
    BYTE    fProtected;
    BYTE    bMustBeZero3;
    DWORD   lcbDataFork;
    DWORD   lcbResourceFork;
    DWORD   dwCreationDate;
    DWORD   dwModificationDate;
    union
    {
        struct
        {
            WORD    cbGetInfo;
            BYTE    bFinderFlags2;
            BYTE    wGap[14];
            DWORD   lcbUnpacked;
            WORD    cbSecondHeader;
            BYTE    bVerMacBin2;
            BYTE    bMinVerMacBin2;
            WORD    wCRC;
        };
        struct
        {
            WORD    wDummy;
            BYTE    bByte101ToByte125[25];

        };
        BYTE    Reserved[27];
    };
    WORD    wMachineID;
} MACBINARY, *LPMACBINARY;
#pragma pack()

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
// Non Mac Creator Types

typedef struct _screatortype
{
    char  szCreator[5];
    char  szType[5];
} sCreatorType;

extern sCreatorType * g_lpCreatorTypes;

// --------------------------------------------------------------------------------
// MAPI Types
// --------------------------------------------------------------------------------
typedef ULONG		 CB;		//	Count of bytes
typedef ULONG		 C;		    //	Count
typedef LPBYTE		 PB;		//	pointer to bytes

// --------------------------------------------------------------------------------
// Defines
// --------------------------------------------------------------------------------
#define BINHEX_INVALID              0x7f
#define BINHEX_REPEAT               0x90
#define XXXX                        BINHEX_INVALID
#define MIN(a,b)	                ( (a) > (b) ? (b) : (a) )
#define hrSuccess                   S_OK

// Uncomment for Binhex debugging support
// #define BINHEX_TRACE 1

#if defined(_X86_) || defined(_AMD64_) || defined(_IA64_)

// host is little endian

#define NATIVE_LONG_FROM_BIG(lpuch)  ( (*(unsigned char *) (lpuch))      << 24 \
                                     | (*(unsigned char *)((lpuch) + 1)) << 16 \
                                     | (*(unsigned char *)((lpuch) + 2)) << 8  \
                                     | (*(unsigned char *)((lpuch) + 3)))
#elif defined(_MPPC_)
#define NATIVE_LONG_FROM_BIG(lpuch)  (*(unsigned long *) (lpuch))
#else
    #error "Must define NATIVE_LONG_FROM_BIG for this architecture!"
#endif

// --------------------------------------------------------------------------------
// Constants
// --------------------------------------------------------------------------------
const CB cbLineLengthUnlimited	    = 0;
const CB cbMIN_BINHEX_HEADER_SIZE   = 21;
const WORD  wZero                   = 0;

// --------------------------------------------------------------------------------
// g_rgchBinHex8to6
// --------------------------------------------------------------------------------
const CHAR g_rgchBinHex8to6[] =
    "!\"#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr";

// --------------------------------------------------------------------------------
// g_rgchBinHex6to8
// --------------------------------------------------------------------------------
const CHAR g_rgchBinHex6to8[] =
{
    // 0x00

    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,

    // 0x20

    XXXX, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, XXXX, XXXX,

    // 0x30

    0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, XXXX,
    0x14, 0x15, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,

    // 0x40

    0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D,
    0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, XXXX,

    // 0x50

    0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, XXXX,
    0x2C, 0x2D, 0x2E, 0x2F, XXXX, XXXX, XXXX, XXXX,

    // 0x60

    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, XXXX,
    0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, XXXX, XXXX,

    // 0x70

    0x3D, 0x3E, 0x3F, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,

    // 0x80

    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
    XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX, XXXX,
};

// --------------------------------------------------------------------------------
// BINHEX post processing data
// --------------------------------------------------------------------------------
typedef struct _sbinhexreturndata
{
	MACBINARY 	    macbinHdr;
	BOOL		    fIsMacFile;
} BINHEXRETDATA;

//-----------------------------------------------------------------------------
// Apple Macintosh BinHex 4.0 encoder class.
//-----------------------------------------------------------------------------

class CBinhexEncoder
{
public:
    CBinhexEncoder(void);
    ~CBinhexEncoder(void);

    HRESULT HrConfig(IN CB cbLineLength, IN C cMaxLines, IN void * pvParms);
    HRESULT HrEmit(IN PB pbRead, IN OUT CB * pcbRead, OUT PB pbWrite, IN OUT CB * pcbWrite);

private:

    // Binhex's the supplied buffer into m_pbWrite, modified m_cbProduced

    HRESULT HrBinHexBuffer( LPBYTE lpbIn, CB cbIn, CB * lpcbConsumed );

    // Binhex byte and outputs to m_pbWrite

    HRESULT HrBinHexByte( BYTE b );

	// Did we generate the maximum number of output lines?
	virtual	BOOL	FMaxLinesReached(void)
		{ return (m_cMaxLines > 0 && m_cLines >= m_cMaxLines); }

	// Are we operating under restricted line length?
	virtual	BOOL	FLineLengthLimited(void)
		{ return m_cbLineLength != cbLineLengthUnlimited; }

    LPMACBINARY m_lpmacbinHdr;              // pointer to passed in Mac Binary header
    ULONG       m_ulAccum;                  // acculator to store chars when converting from 6bytes to 8 bytes.
    ULONG       m_cAccum;                   // count of characters accumulated (0 - 3)
    BYTE        m_bRepeat;                  // repeat char
    CB          m_cbRepeat;                 // amount to repeat
    BYTE        m_bPrev;                    // Previous byte processed
    BYTE        m_bCurr;                    // current byte being processed;
    WORD        m_wCRC;                     // CRC used for data or Resource forks
    CB          m_cbLine;                   // Number of chars currently encoded for a line of output
    CB          m_cbFork;                   // Size of fork to process
    CB          m_cbLeftInFork;             // How much of current fork we've processed.
    CB          m_cbProduced;               // number of chars produces after decoding and RLE expansion
    CB          m_cbLeftInOutputBuffer;     // number of bytes left in passed in Output buffer
    CB          m_cbConsumed;               // number of bytes used from passed in input buffer
    CB          m_cbLeftInInputBuffer;      // number of bytes in passed in Input buffer
    CB          m_cbWrite;                  // number of bytes written out to output buffer
    LPBYTE      m_pbWrite;                  // pointer to output buffer.
    BOOL        m_fHandledx90;              // flag to preserve literal x90 processing across buffer resets.
    CB          m_cbPad;                    // byte count of padding across buffer refreshes.
    CB          m_cbLineLength;             // Maximum length of output line
    BOOL        m_fConfigured;              // Has HrConfig been called successfully?
    CB		    m_cbLeftOnLastLine;	        // Number of bytes left on last line of output
    C		    m_cMaxLines;		        // Maximum number of output lines requested
    C		    m_cLines;			        // Lines of output generated

    // Encoding states

    enum _BinHexStateEnc
    {
        sHEADER, sDATA, sRESOURCE, sEND
    } m_eBinHexStateEnc;

#if defined (DEBUG) && defined (BINHEX_TRACE)
    LPSTREAM m_lpstreamEncodeRLE;           // trace of Run Length encoding of the raw source data
    LPSTREAM m_lpstreamEncodeRAW;           // trace of raw data before RLE has been applied
#endif
};

#endif // __BINHEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\outlookexpress\inetcomm\mimeole\bookbody.cpp ===
// --------------------------------------------------------------------------------
// BookBody.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bookbody.h"
#include "dllmain.h"
#include "ibdylock.h"
#include "stmlock.h"
#include "ibdystm.h"
#include "resource.h"
#include "smime.h"
#include "objheap.h"
#include "internat.h"
#include "urlmon.h"
#include "symcache.h"
#include "booktree.h"
#include <demand.h>
#include "mimeapi.h"
#include <shlwapi.h>
#include "webdocs.h"

// --------------------------------------------------------------------------------
// ASSERTINIT
// --------------------------------------------------------------------------------
#define ASSERTINIT \
    AssertSz(m_pContainer, "Object is being used before a call to InitNew")

// --------------------------------------------------------------------------------
// Default Body Options
// --------------------------------------------------------------------------------
static const BODYOPTIONS g_rDefBodyOptions = {
    IET_UNKNOWN,                // OID_TRANSMIT_BODY_FORMAT
    DEF_CBMAX_BODY_LINE,        // OID_CBMAX_BODY_LINE
    DEF_WRAP_BODY_TEXT,         // OID_WRAP_BODY_TEXT
    DEF_BODY_REMOVE_NBSP,       // OID_BODY_REMOVE_NBSP
    DEF_DBCS_ESCAPE_IS_8BIT,    // OID_DBCS_ESCAPE_IS_8BIT
    DEF_HIDE_TNEF_ATTACHMENTS,  // OID_HIDE_TNEF_ATTACHMENTS
    MST_NONE,                   // OID_SECURITY_TYPE
    NULL,                       // OID_SECURITY_ALG_HASH and OID_SECURITY_ALG_HASH_RG
    { 0, NULL },                // OID_SECURITY_ALG_BULK
    NULL,                       // OID_SECURITY_CERT_SIGNING and OID_SECURITY_CERT_SIGNING_RG
    0,                          // OID_SECURITY_CERT_DECRYPTION
    NULL,                       // OID_SECURITY_HCERTSTORE and OID_SECURITY_HCERTSTORE_RG
    { 0, NULL },                // OID_SECURITY_SEARCHSTORES
    0,
    NULL,                       // OID_SECURITY_RG_IASN
#ifdef SMIME_V3
    NULL,                       // OID_SECURITY_AUTHATTR and OID_SECURITY_AUTHATTR_RG
    NULL,                       // OID_SECURITY_UNAUTHATTR and OID_SECURITY_UNAUTHATTR_RG
    NULL,                       // OID_SECURITY_UNPROTECTATTR_RG
#else  // !SMIME_V3
    NULL,                       // OID_SECURITY_SYMCAPS and OID_SECURITY_SYMCAPS_RG
    NULL,                       // OID_SECURITY_AUTHATTR and OID_SECURITY_AUTHATTR_RG
    NULL,                       // OID_SECURITY_UNAUTHATTR and OID_SECURITY_UNAUTHATTR_RG
    NULL,                       // OID_SECURITY_SIGNTIME and OID_SECURITY_SIGNTIME_RG
#endif // SMIME_V3
    NULL,                       // OID_SECURITY_USER_VALIDITY and OID_SECURITY_USER_VALIDITY_RG
    NULL,                       // OID_SECURITY_RO_MSG_VALIDITY and OID_SECURITY_RO_MSG_VALIDITY_RG
    0,                          // OID_SECURITY_HCRYPTPROV
    0,                          // OID_SECURITY_ENCODE_FLAGS
    FALSE,                      // OID_SECURITY_CERT_INCLUDED
    // This is NULL b/c default is generated at runtime
    NULL,                       // OID_SECURITY_HWND_OWNER
    // Base64 is the recommended value in the S/MIME spec
    IET_BASE64,                 // OID_SECURITY_REQUESTED_CTE
#ifdef SMIME_V3
    NULL,                       // OID_SECURITY_RECEIPT_RG
    NULL,                       // OID_SECURITY_MESSAGE_HASH_RG
    NULL,                       // OID_SECURITY_KEY_PROMPT
#endif // SMIME_V3
    DEF_SHOW_MACBINARY,         // OID_SHOW_MACBINARY
    DEF_SUPPORT_EXTERNAL_BODY,  // OID_SUPPORT_EXTERNAL_BODY
    0,                          // cSecurityLayers (size of arrays of
                                //     OID_SECURITY_ALG_HASH
                                //     OID_SECURITY_CERT_SIGNING
                                //     OID_SECURITY_HCERTSTORE
                                //     OID_SECURITY_SYMCAPS
                                //     OID_SECURITY_AUTHATTR
                                //     OID_SECURITY_UNAUTHATTR
                                //     OID_SECURITY_SIGNTIME
                                //     OID_SECURITY_USER_VALIDITY
                                //     OID_SECURITY_RO_MSG_VALIDITY)
    FALSE,                      // OID_NOSECURITY_ON_SAVE
#ifdef SMIME_V3
    0, 0, NULL,                 // cRecipients/rgRecipients
#endif // SMIME_V3
    NULL,                       // OID_SECURITY_ENCRYPT_CERT_BAG
};

static const BLOB blobNULL = {0, NULL};

HRESULT HrCopyBlobArray(LPCBLOB pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
HRESULT HrCopyDwordArray(LPDWORD pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
HRESULT HrCopyIntoUlonglongArray(ULARGE_INTEGER * pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
HRESULT HrCopyFiletimeArray(LPFILETIME pIn, ULONG cEntries, PROPVARIANT FAR * pvOut);
DWORD MergeDWORDFlags(LPDWORD rgdw, ULONG cEntries);
extern HRESULT HrGetLastError(void);
extern BOOL FIsMsasn1Loaded();


// --------------------------------------------------------------------------------
// WebBookContentBody_CreateInstance
// --------------------------------------------------------------------------------
HRESULT WebBookContentBody_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CMessageBody *pNew = new CMessageBody(NULL, pUnkOuter);
    if (NULL == pNew)
        return TrapError(E_OUTOFMEMORY);

    // Return the Innter
    *ppUnknown = pNew->GetInner();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::CMessageBody
// --------------------------------------------------------------------------------
CMessageBody::CMessageBody(LPTREENODEINFO pNode, IUnknown *pUnkOuter)
    : m_pNode(pNode), CPrivateUnknown(pUnkOuter)
{
    DllAddRef();
    m_cRef = 1;
    m_dwState = 0;
    m_pszDisplay = NULL;
    m_ietEncoding = IET_BINARY;
    m_ietPrevious = IET_UNKNOWN;
    m_pCharset = CIntlGlobals::GetDefBodyCset();
    m_pCsetTagged = NULL;
    m_pContainer = NULL;
    m_cbExternal = 0xFFFFFFFF;
    ZeroMemory(&m_rStorage, sizeof(BODYSTORAGE));
    CopyMemory(&m_rOptions, &g_rDefBodyOptions, sizeof(BODYOPTIONS));
    // (t-erikne) need to get this default at run time
    m_rOptions.hwndOwner = HWND_DESKTOP;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::~CMessageBody
// --------------------------------------------------------------------------------
CMessageBody::~CMessageBody(void)
{
    SafeRelease(m_pContainer);
    SafeMemFree(m_pszDisplay);
    SafeRelease(m_rStorage.pUnkRelease);

    // Clear out the options
    _FreeOptions();

    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CMessageBody::PrivateQueryInterface
// --------------------------------------------------------------------------------
HRESULT CMessageBody::PrivateQueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);

    // Init
    *ppv = NULL;

    // Find IID
    if (IID_IMimeBody == riid)
        *ppv = (IMimeBody *)this;
    else if (IID_IMimeBodyW == riid)
        *ppv = (IMimeBodyW *)this;
    else if (IID_IMimePropertySet == riid)
        *ppv = (IMimePropertySet *)this;
    else if (IID_IPersist == riid)
        *ppv = (IPersist *)this;
    else if (IID_IPersistStreamInit == riid)
        *ppv = (IPersistStreamInit *)this;
    else if (IID_CMessageBody == riid)
        *ppv = (CMessageBody *)this;
#ifdef SMIME_V3
    else if (IID_IMimeSecurity2 == riid)
        *ppv = (IMimeSecurity2 *) this;
#endif
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::RevokeTreeNode
// --------------------------------------------------------------------------------
void CMessageBody::RevokeTreeNode(void)
{
    EnterCriticalSection(&m_cs);
    m_pNode = NULL;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::HrBindToTree
// --------------------------------------------------------------------------------
HRESULT CMessageBody::HrBindToTree(CStreamLockBytes *pStmLock, LPTREENODEINFO pNode)
{
    // Locals
    HRESULT             hr=S_OK;
    HCHARSET            hCharset=NULL;
    IStream             *pstmBody=NULL;
    ASSERTINIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Invalid Arg
    Assert(pNode && NULL == pNode->pLockBytes && pStmLock && m_pNode == pNode);

    // Create the body lock bytes
    CHECKALLOC(pNode->pLockBytes = new CBodyLockBytes(pStmLock, pNode));

    // Just assume it
    m_rStorage.riid = IID_ILockBytes;
    m_rStorage.pLockBytes = (ILockBytes *)pNode->pLockBytes;
    m_rStorage.pUnkRelease = m_rStorage.pLockBytes;
    m_rStorage.pUnkRelease->AddRef();

    // Test for binhex
    if (S_FALSE == m_pContainer->IsPropSet(PIDTOSTR(PID_HDR_CNTXFER)) && m_pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_BINHEX) == S_OK)
    {
        // Locals
        PROPVARIANT     rVariant;

        // Setup the variant
        rVariant.vt = VT_LPSTR;

        // If there is a filename, lets re-compute the content-type
        if (SUCCEEDED(m_pContainer->GetProp(PIDTOSTR(PID_ATT_FILENAME), 0, &rVariant)))
        {
            // Locals
            LPSTR       pszCntType;
            LPSTR       pszSubType;

            // Get mime file information
            if (SUCCEEDED(MimeOleGetFileInfo(rVariant.pszVal, &pszCntType, &pszSubType, NULL, NULL, NULL)))
            {
                // ContentType
                if (pszCntType && pszSubType)
                {
                    CHECKHR(hr = m_pContainer->SetProp(PIDTOSTR(PID_ATT_PRITYPE), pszCntType));
                    CHECKHR(hr = m_pContainer->SetProp(PIDTOSTR(PID_ATT_SUBTYPE), pszSubType));
                }

                // application/octet-stream
                else
                {
                    CHECKHR(hr = m_pContainer->SetProp(PIDTOSTR(PID_HDR_CNTTYPE), STR_MIME_APPL_STREAM));
                }

                // Cleanup
                SafeMemFree(pszCntType);
                SafeMemFree(pszSubType);
            }

            // Clenaup
            SafeMemFree(rVariant.pszVal);
        }

        // Set the Content-Transfer-Encoding to binhex
        m_pContainer->SetProp(PIDTOSTR(PID_HDR_CNTXFER), STR_ENC_BINHEX40);

        // The encoding type better be binhex
        Assert(m_pContainer->GetEncodingType() == IET_BINHEX40);
    }

    // Otherwise, test for message/external-body
    else if (m_rOptions.fExternalBody && S_OK == m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_EXTERNAL))
    {
        // Bind to External-Body
        _BindToExternalBody();
    }

    // Save The Format
    m_ietPrevious = m_ietEncoding = m_pContainer->GetEncodingType();

    // Raid 2215: Map a CTE of binary to 8bit so that it gets decoded correctly from the internet character set
    if (IET_BINARY == m_ietEncoding)
    {
        // Switch to 8bit because ibdystm.cpp will not do the charset translation right if the source is binary...
        m_ietEncoding = IET_8BIT;
    }

    // LateTnef Check
    if (ISFLAGSET(pNode->dwState, NODESTATE_VERIFYTNEF))
    {
        // Get the data stream
        if (SUCCEEDED(GetData(IET_BINARY, &pstmBody)))
        {
            // If TNEF, apply content type...
            if (MimeOleIsTnefStream(pstmBody) == S_OK)
            {
                // application/ms-tnef
                CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPLY_MSTNEF));
            }
        }

        // Clear the flag
        FLAGCLEAR(pNode->dwState, NODESTATE_VERIFYTNEF);
    }

    // If I'm a message with crypto mime types, say I'm "secure"
    if (IsSecureContentType(m_pContainer))
    {
        // TREENODE_SECURE
        FLAGSET(m_dwState, BODYSTATE_SECURE);
    }

    // If the Header was tagged with a charset, use that charset
    if (m_pContainer->IsState(COSTATE_CSETTAGGED) == S_OK)
    {
        // Get Internal Character Set
        if (SUCCEEDED(m_pContainer->GetCharset(&hCharset)))
        {
            // Get Pointer
            SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_pCharset)));

            // Save this as m_pCsetTagged
            m_pCsetTagged = m_pCharset;
        }

        // I was tagged with a charset
        FLAGSET(m_dwState, BODYSTATE_CSETTAGGED);
    }

    // Bound to tree
    FLAGSET(pNode->dwState, NODESTATE_BOUNDTOTREE);

exit:
    // Cleanup
    SafeRelease(pstmBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageBody::_BindToExternalBody
// ---------------------------------------------------------------------------
void CMessageBody::_BindToExternalBody(void)
{
    // Locals
    HRESULT             hr=S_OK;
    LPSTR               pszAccessType=NULL;
    LPSTR               pszUrl=NULL;
    IStream             *pstmBody=NULL;
    DWORD               cbSize=0xFFFFFFFF;
    CMimeWebDocument    *pWebDoc=NULL;

    // Get par:content-type:access-type
    CHECKHR(hr = m_pContainer->GetProp(STR_PAR_ACCESSTYPE, &pszAccessType));

    // Handle Access-Types that I know about
    if (lstrcmpi(pszAccessType, "X-URL") == 0)
    {
        // Locals
        PROPVARIANT rSize;

        // Get par:content-type:xurl
        CHECKHR(hr = m_pContainer->GetProp(STR_PAR_XURL, &pszUrl));

        // Create the WebDoc
        CHECKALLOC(pWebDoc = new CMimeWebDocument);

        // Initialize It
        CHECKHR(hr = pWebDoc->HrInitialize(NULL, pszUrl));

        // Setup Variant
        rSize.vt = VT_UI4;

        // Get par:content-type:size
        if (SUCCEEDED(m_pContainer->GetProp(STR_PAR_SIZE, 0, &rSize)))
            cbSize = rSize.ulVal;
    }

    // If we have a webdocument...
    if (pWebDoc)
    {
        // Get the Body Data
        if (SUCCEEDED(GetData(IET_BINARY, &pstmBody)))
        {
            // Locals
            PROPVARIANT rOption;

            // Setup the option variant
            rOption.vt = VT_UI4;
            rOption.ulVal = RELOAD_HEADER_REPLACE;

            // Set special option since I'm realoding the header...
            CHECKHR(hr = m_pContainer->SetOption(OID_HEADER_RELOAD_TYPE, &rOption));

            // Load this body into the container
            CHECKHR(hr = m_pContainer->Load(pstmBody));

            // Reset the option variant
            rOption.vt = VT_UI4;
            rOption.ulVal = DEF_HEADER_RELOAD_TYPE_PROPSET;

            // Set special option since I'm realoding the header...
            CHECKHR(hr = m_pContainer->SetOption(OID_HEADER_RELOAD_TYPE, &rOption));
        }

        // SetData
        CHECKHR(hr = SetData(IET_BINARY, NULL, NULL, IID_IMimeWebDocument, (LPVOID)pWebDoc));

        // Create a External Body Info Structure: MUST BE SET AFTER CALL TO SETDATA
        FLAGSET(m_dwState, BODYSTATE_EXTERNAL);

        // Set Size: MUST BE SET AFTER CALL TO SETDATA
        m_cbExternal = cbSize;
    }

exit:
    // Cleanup
    SafeMemFree(pszAccessType);
    SafeMemFree(pszUrl);
    SafeRelease(pstmBody);
    SafeRelease(pWebDoc);

    // Done
    return;
}

#if 0
// ---------------------------------------------------------------------------
// CMessageBody::UseOriginalCharset
// ---------------------------------------------------------------------------
void CMessageBody::UseOriginalCharset(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // We should have m_pCsetTagged
    Assert(m_pCsetTagged);

    // Set the Charset
    if (m_pCsetTagged)
        SetCharset(m_pCsetTagged->hCharset, CSET_APPLY_ALL);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}
#endif

// ---------------------------------------------------------------------------
// CMessageBody::SetDisplayName
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetDisplayName(LPCSTR pszDisplayName)
{
    LPWSTR  pwszDispName;
    HRESULT hr = S_OK;

    Assert(pszDisplayName);

    IF_NULLEXIT(pwszDispName = PszToUnicode(CP_ACP, pszDisplayName));

    hr = SetDisplayNameW(pwszDispName);

exit:
    MemFree(pwszDispName);

    return hr;
}

#define DisplayMaxLen 64

STDMETHODIMP CMessageBody::SetDisplayNameW(LPCWSTR pszDisplayName)
{
    // Locals
    HRESULT         hr=S_OK;
    WCHAR           szSize[30],
                    szScratch[30],
                    szBuf[MAX_PATH];
    ULONG           cbSize=0,
                    cAlloc,
                    cLen;
    ASSERTINIT;

    // check params
    if (NULL == pszDisplayName)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Free current display name
    SafeMemFree(m_pszDisplay);

    // Get Data Size...
    GetEstimatedSize(IET_BINARY, &cbSize);

    // Format the Size
    StrFormatByteSizeW(cbSize, szScratch, ARRAYSIZE(szScratch));
    StrCpyW(szSize, L"(");
    StrCatW(szSize, szScratch);
    StrCatW(szSize, L")");

    cLen = lstrlenW(pszDisplayName);
    if (cLen+1 > ARRAYSIZE(szBuf))
        cLen = ARRAYSIZE(szBuf) - 1;
    StrCpyNW(szBuf, pszDisplayName, cLen+1);
    PathStripPathW(szBuf);
    cLen = lstrlenW(szBuf);
    if (cLen > DisplayMaxLen)
    {
        WCHAR szBuf2[MAX_PATH];
        WCHAR *szExt;
        szExt = PathFindExtensionW(szBuf);
        if (*szExt)
        {
            int cExt = lstrlenW(szExt);
            if (cExt < DisplayMaxLen-3)
            {
                WCHAR szExt2[DisplayMaxLen];
                StrCpyW(szExt2, szExt);
                PathCompactPathExW(szBuf2, szBuf, DisplayMaxLen-cExt, 0);
                StrCatW(szBuf2, szExt2);
            }
            else
                PathCompactPathExW(szBuf2, szBuf, DisplayMaxLen, 0);
        }
        else
        {
            PathCompactPathExW(szBuf2, szBuf, DisplayMaxLen, 0);
        }
        StrCpyW(szBuf, szBuf2);
    }

    // Size to allocate: filename.dat (x)\0
    cAlloc = lstrlenW(szBuf) + lstrlenW(szSize) + 2;

    // Dup the display name
    CHECKALLOC(m_pszDisplay = PszAllocW(cAlloc));

    // Format the Display Name
    StrCpyW(m_pszDisplay, szBuf);
    StrCatW(m_pszDisplay, L" ");
    StrCatW(m_pszDisplay, szSize);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageBody::GetDisplayName
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetDisplayName(LPSTR *ppszDisplayName)
{
    LPWSTR  pwszDispName = NULL;
    HRESULT hr;

    Assert(ppszDisplayName);

    *ppszDisplayName = NULL;

    IF_FAILEXIT(hr = GetDisplayNameW(ppszDisplayName ? &pwszDispName : NULL));

    IF_NULLEXIT(*ppszDisplayName = PszToANSI(CP_ACP, pwszDispName));

exit:
    MemFree(pwszDispName);
    return TraceResult(hr);
}

STDMETHODIMP CMessageBody::GetDisplayNameW(LPWSTR *ppszDisplayName)
{
    // Locals
    HRESULT         hr=S_OK;
    ASSERTINIT;

    // check params
    if (NULL == ppszDisplayName)
        return TrapError(E_INVALIDARG);

    // Init
    *ppszDisplayName = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Do I have an internal displayname ?
    if (NULL == m_pszDisplay)
    {
        LPSTR   pszVal = NULL;
        LPWSTR  pwszVal = NULL;

        // Use m_pszURL first
        if (IID_IMimeWebDocument == m_rStorage.riid && SUCCEEDED(m_rStorage.pWebDocument->GetURL(&pszVal)))
            SetDisplayName(pszVal);

        // Raid-38681 - mail:file name is incorrect when attaching renamed saved message
        // Raid-18813 - Single Bodies messages can have a filename and a subject.
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_ATT_FILENAME, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        // If I'm an message/rfc822
        else if (m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_RFC822) == S_OK && FExtractRfc822Subject(&pwszVal))
            SetDisplayNameW(pwszVal);

        // Parent is multipart/digest
        else if (m_pNode && m_pNode->pParent && m_pNode->pParent->pBody && m_pNode->pParent->pBody->IsContentType(STR_CNT_MULTIPART, STR_SUB_DIGEST) == S_OK && FExtractRfc822Subject(&pwszVal))
            SetDisplayNameW(pwszVal);

        // Use Subject
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_HDR_SUBJECT, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        // Use Generated File Name...
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_ATT_GENFNAME, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        // Content Description
        else if (SUCCEEDED(m_pContainer->GetPropW(SYM_HDR_CNTDESC, &pwszVal)) && pwszVal)
            SetDisplayNameW(pwszVal);

        SafeMemFree(pszVal);
        SafeMemFree(pwszVal);
    }

    // If there is a display name now, then dup it.
    if (m_pszDisplay)
        CHECKALLOC(*ppszDisplayName = PszDupW(m_pszDisplay));
    else
        hr = MIME_E_NO_DATA;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ---------------------------------------------------------------------------
// CMessageBody::FExtractRfc822Subject
// ---------------------------------------------------------------------------
BOOL CMessageBody::FExtractRfc822Subject(LPWSTR *ppwszVal)
{
    // Locals
    HRESULT           hr=S_OK;
    IStream          *pstmData=NULL;
    IMimePropertySet *pPropertySet=NULL;
    PROPVARIANT       rSubject;
    ASSERTINIT;

    // Invalid Arg
    Assert(ppwszVal);

    // Init
    MimeOleVariantInit(&rSubject);
    *ppwszVal = NULL;

    // Get the data
    CHECKHR(hr = GetData(IET_BINARY, &pstmData));

    // Lets create a header
    CHECKHR(hr = MimeOleCreatePropertySet(NULL, &pPropertySet));

    // Parse the header
    CHECKHR(hr = pPropertySet->Load(pstmData));

    // Init Variant
    rSubject.vt = VT_LPWSTR;

    // Get the subject and set the display name
    CHECKHR(hr = pPropertySet->GetProp(PIDTOSTR(PID_HDR_SUBJECT), 0, &rSubject));

    // Raid-38681 - mail:file name is incorrect when attaching renamed saved message
    if (FIsEmptyW(rSubject.pwszVal))
    {
        SafeMemFree(rSubject.pwszVal);
        goto exit;
    }

    // Set this subject on my self so that STR_ATT_GENFNAME works
    m_pContainer->SetProp(PIDTOSTR(PID_HDR_CNTDESC), 0, &rSubject);

    // Return It
    *ppwszVal = rSubject.pwszVal;

exit:
    // Cleanup
    SafeRelease(pstmData);
    SafeRelease(pPropertySet);

    // Done
    return (NULL == *ppwszVal) ? FALSE : TRUE;
}

// ---------------------------------------------------------------------------
// CMessageBody::SetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetOption(const TYPEDID oid, LPCPROPVARIANT pValue)
{
    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    return InternalSetOption(oid, pValue, FALSE, FALSE);
}

// ---------------------------------------------------------------------------
// CMessageBody::InternalSetOption
// ---------------------------------------------------------------------------
HRESULT CMessageBody::InternalSetOption(const TYPEDID oid, LPCPROPVARIANT pValue, BOOL fInternal, BOOL fNoDirty)
{
    // Locals
#ifdef SMIME_V3
    DWORD       cb;
#endif // SMIME_V3
    HRESULT     hr=S_OK;
    DWORD       i;
    ASSERTINIT;
    CAPROPVARIANT capv;
    CAUL        caul;
    CAUH        cauh;
    CAFILETIME  cafiletime;
#ifdef SMIME_V3
    BYTE                rgb[50];
#endif // SMIME_V3

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    case OID_SUPPORT_EXTERNAL_BODY:
        if (m_rOptions.fExternalBody != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fExternalBody = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SHOW_MACBINARY:
        if (m_rOptions.fShowMacBin != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fShowMacBin = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;


    case OID_CBMAX_BODY_LINE:
        if (pValue->ulVal < MIN_CBMAX_BODY_LINE || pValue->ulVal > MAX_CBMAX_BODY_LINE)
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.cbMaxLine != pValue->ulVal)
        {
            m_rOptions.cbMaxLine = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_TRANSMIT_BODY_ENCODING:
        if (FALSE == FIsValidBodyEncoding((ENCODINGTYPE)pValue->ulVal))
        {
            hr = TrapError(MIME_E_INVALID_OPTION_VALUE);
            goto exit;
        }
        if (m_rOptions.ietTransmit != (ENCODINGTYPE)pValue->ulVal)
        {
            m_rOptions.ietTransmit = (ENCODINGTYPE)pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_WRAP_BODY_TEXT:
        if (m_rOptions.fWrapText != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fWrapText = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        if (m_rOptions.fHideTNEF != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fHideTNEF = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_DBCS_ESCAPE_IS_8BIT:
        if (m_rOptions.fDBCSEscape8 != (pValue->boolVal ? TRUE : FALSE))
        {
            m_rOptions.fDBCSEscape8 = pValue->boolVal ? TRUE : FALSE;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_TYPE:
        if (m_rOptions.ulSecurityType != pValue->ulVal)
        {
            m_rOptions.ulSecurityType = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_ALG_HASH: // innermost signing algorithm
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (CompareBlob(&m_rOptions.rgblobHash[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobHash[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobHash[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_ALG_HASH_RG: // signing algorithms
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobHash, fNoDirty);
        break;

    case OID_SECURITY_ALG_BULK:
        if (CompareBlob(&m_rOptions.blobBulk, &pValue->blob))
            {
            ReleaseMem(m_rOptions.blobBulk.pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.blobBulk);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

#ifndef _WIN64
    case OID_SECURITY_CERT_SIGNING:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgpcCertSigning[0] != (PCCERT_CONTEXT)pValue->ulVal)
        {
            if (m_rOptions.rgpcCertSigning[0])
                 CertFreeCertificateContext(m_rOptions.rgpcCertSigning[0]);
            m_rOptions.rgpcCertSigning[0] = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->ulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG: // signing algorithms
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            caul = pValue->caul;
            Assert(caul.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
            if (m_rOptions.cSigners != caul.cElems && 0 != m_rOptions.cSigners)
            {
                hr = E_INVALIDARG;
            }
            else
            {
                for (i = 0; i < caul.cElems; i++) {
                    if (m_rOptions.rgpcCertSigning[i] != (PCCERT_CONTEXT)caul.pElems[i])
                    {
                        if (m_rOptions.rgpcCertSigning[i])
                             CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);
                        m_rOptions.rgpcCertSigning[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT)caul.pElems[i]);
                        if (!fNoDirty)
                            FLAGSET(m_dwState, BODYSTATE_DIRTY);
                    }
                }
            }
        break;

    case OID_SECURITY_CERT_DECRYPTION:
        if (m_rOptions.pcCertDecryption != (PCCERT_CONTEXT)pValue->ulVal)
            {
            if (m_rOptions.pcCertDecryption)
                CertFreeCertificateContext(m_rOptions.pcCertDecryption);
            m_rOptions.pcCertDecryption = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->ulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT:
#ifdef SMIME_V3
        for (i=0; i<pValue->caul.cElems; i++)
        {
            CMS_RECIPIENT_INFO          info = {0};
            info.pccert = (PCCERT_CONTEXT) pValue->caul.pElems[i];
            hr = AddRecipient((i == 0) ? SMIME_RECIPIENT_REPLACE_ALL : 0, 1, &info);
            if (FAILED(hr))
            {
                break;
            }
        }
        if (SUCCEEDED(hr) && !fNoDirty)
            FLAGSET(m_dwState, BODYSTATE_DIRTY);
#else  // !SMIME_V3
        if (SUCCEEDED(hr = _CAULToCERTARRAY(pValue->caul, &m_rOptions.caEncrypt)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
#endif // !SMIME_V3
        break;

    case OID_SECURITY_HCERTSTORE:
        CertCloseStore(m_rOptions.hCertStore, 0);
        if (pValue->ulVal)
            m_rOptions.hCertStore = CertDuplicateStore((HCERTSTORE)pValue->ulVal);
        else
            m_rOptions.hCertStore = NULL;
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG:
        CertCloseStore(m_rOptions.hstoreEncrypt, 0);
        if (pValue->ulVal)
            m_rOptions.hstoreEncrypt = CertDuplicateStore((HCERTSTORE) pValue->ulVal);
        else
            m_rOptions.hstoreEncrypt = NULL;
        break;

    case OID_SECURITY_RG_CERT_BAG:
        if (SUCCEEDED(hr = _CAULToCertStore(pValue->caul, &m_rOptions.hCertStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_SEARCHSTORES:
        if (SUCCEEDED(hr = _CAULToSTOREARRAY(pValue->caul, &m_rOptions.saSearchStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_RG_IASN:
        //N TODO: OID_SECURITY_RG_IASN
        if (fInternal)
            {
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    // 2 Key implementation
    case OID_SECURITY_2KEY_CERT_BAG:
        {
            hr = S_OK;
            //  Create a new store if needed
            if (m_rOptions.hCertStore == NULL)
            {
                m_rOptions.hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
            }

            if (m_rOptions.hCertStore == NULL)
            {
                hr = HrGetLastError();
            }

            for (i=0; i < (pValue->caul).cElems; i++)
            {
                if (!CertAddCertificateContextToStore(m_rOptions.hCertStore,
                                              (PCCERT_CONTEXT) IntToPtr((pValue->caul).pElems[i]),
                                              CERT_STORE_ADD_ALWAYS, NULL))
                {
                    hr = HrGetLastError();
                }
            }
            if(hr == S_OK)
            {
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }

        }
        break;

    case OID_SECURITY_HCRYPTPROV:
        if (m_rOptions.hCryptProv != pValue->ulVal)
            {
            if (m_rOptions.hCryptProv)
                CryptReleaseContext(m_rOptions.hCryptProv, 0);
            m_rOptions.hCryptProv = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

#else // _WIN64
    case OID_SECURITY_CERT_SIGNING_64:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgpcCertSigning[0] != (PCCERT_CONTEXT)pValue->pulVal)
        {
            if (m_rOptions.rgpcCertSigning[0])
                 CertFreeCertificateContext(m_rOptions.rgpcCertSigning[0]);
            m_rOptions.rgpcCertSigning[0] = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->pulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG_64: // signing algorithms
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            cauh = pValue->cauh;
            Assert(cauh.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
            if (m_rOptions.cSigners != cauh.cElems && 0 != m_rOptions.cSigners)
            {
                hr = E_INVALIDARG;
            } else {
                for (i = 0; i < cauh.cElems; i++)
                {
                    PCCERT_CONTEXT pCert = *(PCCERT_CONTEXT *) (&(cauh.pElems[i]));

                    if (m_rOptions.rgpcCertSigning[i] != (PCCERT_CONTEXT)(pCert))
                    {
                        if (m_rOptions.rgpcCertSigning[i])
                             CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);
                        m_rOptions.rgpcCertSigning[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT)(pCert));
                        if (!fNoDirty)
                            FLAGSET(m_dwState, BODYSTATE_DIRTY);
                    }
                }
            }
        break;

    case OID_SECURITY_CERT_DECRYPTION_64:
        if (m_rOptions.pcCertDecryption != (PCCERT_CONTEXT)pValue->pulVal)
            {
            if (m_rOptions.pcCertDecryption)
                CertFreeCertificateContext(m_rOptions.pcCertDecryption);
            m_rOptions.pcCertDecryption = CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->pulVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT_64:
#ifdef SMIME_V3
        for (i=0; i<pValue->cauh.cElems; i++)
        {
            CMS_RECIPIENT_INFO          info = {0};
            info.pccert = *((PCCERT_CONTEXT*) &(pValue->cauh.pElems[i]));
            hr = AddRecipient((i == 0) ? SMIME_RECIPIENT_REPLACE_ALL : 0, 1, &info);
            if (FAILED(hr))
            {
                break;
            }
        }
        if (SUCCEEDED(hr) && !fNoDirty)
            FLAGSET(m_dwState, BODYSTATE_DIRTY);
#else  // !SMIME_V3
        if (SUCCEEDED(hr = _CAUHToCERTARRAY(pValue->cauh, &m_rOptions.caEncrypt)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
#endif // !SMIME_V3
        break;

    case OID_SECURITY_HCERTSTORE_64:
        CertCloseStore(m_rOptions.hCertStore, 0);
        if (pValue->pulVal)
            m_rOptions.hCertStore = CertDuplicateStore((HCERTSTORE)pValue->pulVal);
        else
            m_rOptions.hCertStore = NULL;
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG_64:
        CertCloseStore(m_rOptions.hstoreEncrypt, 0);
        if (pValue->pulVal)
            m_rOptions.hstoreEncrypt = CertDuplicateStore((HCERTSTORE) pValue->pulVal);
        else
            m_rOptions.hstoreEncrypt = NULL;
        break;

    case OID_SECURITY_RG_CERT_BAG_64:
        if (SUCCEEDED(hr = _CAUHToCertStore(pValue->cauh, &m_rOptions.hCertStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_SEARCHSTORES_64:
        if (SUCCEEDED(hr = _CAUHToSTOREARRAY(pValue->cauh, &m_rOptions.saSearchStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_RG_IASN_64:
        //N TODO: OID_SECURITY_RG_IASN
        if (fInternal)
            {
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    // 2 Key implementation
    case OID_SECURITY_2KEY_CERT_BAG_64:
        {
            hr = S_OK;
            //  Create a new store if needed
            if (m_rOptions.hCertStore == NULL)
            {
                m_rOptions.hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
            }

            if (m_rOptions.hCertStore == NULL)
            {
                hr = HrGetLastError();
            }

            for (i=0; i < (pValue->cauh).cElems; i++)
            {
                if (!CertAddCertificateContextToStore(m_rOptions.hCertStore,
                                              *((PCCERT_CONTEXT *) (&((pValue->cauh).pElems[i]))),
                                              CERT_STORE_ADD_ALWAYS, NULL))
                {
                    hr = HrGetLastError();
                }
            }
            if(hr == S_OK)
            {
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }

        }
        break;

    case OID_SECURITY_HCRYPTPROV_64:
        if (m_rOptions.hCryptProv != (((HCRYPTPROV) (pValue->pulVal))))
            {
            if (m_rOptions.hCryptProv)
                CryptReleaseContext(m_rOptions.hCryptProv, 0);
            m_rOptions.hCryptProv = (HCRYPTPROV) pValue->pulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

#endif //_WIN64

    case OID_SECURITY_CRL:
        if (m_rOptions.hCertStore == NULL)
        {
            m_rOptions.hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                                                  X509_ASN_ENCODING,
                                                  NULL, 0, NULL);
            if (m_rOptions.hCertStore == NULL)
            {
                hr = HrGetLastError();
                break;
            }
        }
        if (!CertAddEncodedCRLToStore(m_rOptions.hCertStore, X509_ASN_ENCODING,
                                      pValue->blob.pBlobData,
                                      pValue->blob.cbSize,
                                      CERT_STORE_ADD_ALWAYS, NULL))
        {
            hr = HrGetLastError();
        }
        else if (!fNoDirty)
        {
            FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

   case OID_SECURITY_SYMCAPS:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
       hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                            szOID_RSA_SMIMECapabilities,
                            pValue->blob.cbSize, pValue->blob.pBlobData);
#else  // !SMIME_V3
        if (CompareBlob(&m_rOptions.rgblobSymCaps[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobSymCaps[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobSymCaps[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SYMCAPS_RG: // symetric capabilities
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->capropvar.cElems; i++)
        {
            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                szOID_RSA_SMIMECapabilities,
                                pValue->capropvar.pElems[i].blob.cbSize,
                                pValue->capropvar.pElems[i].blob.pBlobData);

           if (FAILED(hr))
               break;
       }
#else  // !SMIME_V3
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobSymCaps, fNoDirty);
#endif // SMIME_V3
        break;

    case OID_SECURITY_AUTHATTR:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
        hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                             NULL, pValue->blob.cbSize, pValue->blob.pBlobData);
#else  // !SMIME_V3
        if (CompareBlob(&m_rOptions.rgblobAuthAttr[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobAuthAttr[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobAuthAttr[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_AUTHATTR_RG: // authenticated attributes
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->capropvar.cElems; i++)
        {
            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                 NULL, pValue->capropvar.pElems[i].blob.cbSize,
                                 pValue->capropvar.pElems[i].blob.pBlobData);
            if (FAILED(hr))
                break;
        }
#else  // !SMIME_V3
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobAuthAttr, fNoDirty);
#endif // SMIME_V3
        break;


    case OID_SECURITY_UNAUTHATTR:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
        hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][0],
                             NULL, pValue->blob.cbSize, pValue->blob.pBlobData);
#else  // !SMIME_V3
        if (CompareBlob(&m_rOptions.rgblobUnauthAttr[0], &pValue->blob))
            {
            ReleaseMem(m_rOptions.rgblobUnauthAttr[0].pBlobData);
            hr = HrCopyBlob(&pValue->blob, &m_rOptions.rgblobUnauthAttr[0]);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_UNAUTHATTR_RG: // unauthenticated attributes
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->capropvar.cElems; i++)
        {
            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][i],
                                 NULL, pValue->capropvar.pElems[i].blob.cbSize,
                                 pValue->capropvar.pElems[i].blob.pBlobData);
            if (FAILED(hr))
                break;
        }
#else  // !SMIME_V3
        hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobUnauthAttr, fNoDirty);
#endif // SMIME_V3
        break;


    case OID_SECURITY_SIGNTIME:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
#ifdef SMIME_V3
        if ((pValue->filetime.dwLowDateTime == 0) &&
            (pValue->filetime.dwHighDateTime == 0))
        {
            hr = DeleteAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED, 0,
                                 szOID_RSA_signingTime);
        }
        else
        {
            cb = sizeof(rgb);
            if (!CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                     &pValue->filetime, 0, NULL,
                                     rgb, &cb))
            {
                hr = HrGetLastError();
                break;
            }

            hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                                 szOID_RSA_signingTime, cb, rgb);
        }
#else  // !SMIME_V3
        if (CompareFileTime(&m_rOptions.rgftSigning[0], (FILETIME FAR*)&pValue->filetime))
            {
            CopyMemory(&m_rOptions.rgftSigning[0], &pValue->filetime, sizeof(FILETIME));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SIGNTIME_RG: // signing times
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
#ifdef SMIME_V3
        for (i=0; i<pValue->cafiletime.cElems; i++)
        {
            if ((pValue->cafiletime.pElems[i].dwLowDateTime == 0) &&
            (pValue->cafiletime.pElems[i].dwHighDateTime == 0))
            {
                hr = DeleteAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED, 0,
                                     szOID_RSA_signingTime);
            }
            else
            {
                cb = sizeof(rgb);
                if (!CryptEncodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                         &pValue->cafiletime.pElems[i], 0, NULL,
                                         rgb, &cb))
                {
                    hr = HrGetLastError();
                    break;
                }

                hr = _HrSetAttribute(0, &m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                  szOID_RSA_signingTime, cb, rgb);
            }
        }
#else  // !SMIME_V3
        cafiletime = pValue->cafiletime;
        Assert(cafiletime.cElems == m_rOptions.cSigners);
        if (m_rOptions.cSigners != cafiletime.cElems)
        {
            hr = E_INVALIDARG;
        } else {
            for (i = 0; i < cafiletime.cElems; i++)
            {
                if (CompareFileTime(&m_rOptions.rgftSigning[i], (FILETIME FAR*)&cafiletime.pElems[i]))
                {
                    CopyMemory(&m_rOptions.rgftSigning[i], &cafiletime.pElems[i], sizeof(FILETIME));
                    if (!fNoDirty)
                        FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
#endif // SMIME_V3
        break;

    case OID_SECURITY_USER_VALIDITY:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgulUserDef[0] != pValue->ulVal)
            {
            m_rOptions.rgulUserDef[0] = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_USER_VALIDITY_RG: // user validity flags
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
        caul = pValue->caul;
        Assert(caul.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
        if (m_rOptions.cSigners != caul.cElems && 0 != m_rOptions.cSigners)
        {
            hr = E_INVALIDARG;
        } else {
            for (i = 0; i < caul.cElems; i++)
            {
                if (m_rOptions.rgulUserDef[i] != caul.pElems[i])
                {
                    m_rOptions.rgulUserDef[i] = caul.pElems[i];
                    if (!fNoDirty)
                        FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
        break;

    case OID_SECURITY_RO_MSG_VALIDITY:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (fInternal)
            {
            if (m_rOptions.rgulROValid[0] != pValue->ulVal)
                {
                m_rOptions.rgulROValid[0] = pValue->ulVal;
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    case OID_SECURITY_RO_MSG_VALIDITY_RG:  // message validity flags
        if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
        {
            break;
        }
        caul = pValue->caul;
        Assert(caul.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
        if (m_rOptions.cSigners != caul.cElems && 0 != m_rOptions.cSigners)
        {
            hr = E_INVALIDARG;
        }
        else
        {
            for (i = 0; i < caul.cElems; i++)
            {
                if (m_rOptions.rgulROValid[i] != caul.pElems[i])
                {
                    m_rOptions.rgulROValid[i] = caul.pElems[i];
                    if (!fNoDirty)
                        FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        if (m_rOptions.ulEncodeFlags != pValue->ulVal)
            {
            m_rOptions.ulEncodeFlags = pValue->ulVal;
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_CERT_INCLUDED:
        if (fInternal)
            {
            if (m_rOptions.fCertWithMsg != pValue->boolVal)
                {
                m_rOptions.fCertWithMsg = pValue->boolVal;
                if (!fNoDirty)
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

#ifndef _WIN64
    case OID_SECURITY_HWND_OWNER:
        m_rOptions.hwndOwner = HWND(pValue->ulVal);
        break;
#endif

    case OID_SECURITY_REQUESTED_CTE:
        if (m_rOptions.ietRequested != pValue->lVal)
            {
            m_rOptions.ietRequested = ENCODINGTYPE(pValue->lVal);
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_SIGNATURE_COUNT:
        // M00BUG - I just found out that if lVal >0 but lVal < m_rOptions.cSigners
        //      then we don't do any adjustments to handle this case.
        if (pValue->lVal == 0)
            {
            if (m_rOptions.cSigners)
                {
                // OID_SECURITY_ALG_HASH
                SafeMemFree(m_rOptions.rgblobHash[0].pBlobData);


                // OID_SECURITY_CERT_SIGNING
                for (i = 0; i < m_rOptions.cSigners; i++)
                    {
                    CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);

#ifdef SMIME_V3
                    //  Attributes
                    SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i]);
                    SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][i]);

                    // OID_SECURITY_RECEIPT_RG
                    SafeMemFree(m_rOptions.rgblobReceipt[i].pBlobData);
                    // OID_SECURITY_MESSAGE_HASH_RG
                    SafeMemFree(m_rOptions.rgblobMsgHash[i].pBlobData);
                    // OID_SECURITY_KEY_PROMPT
                    SafeMemFree(m_rOptions.pwszKeyPrompt);
#else // !SMIME_V3
                    // OID_SECURITY_SYMCAPS
                    SafeMemFree(m_rOptions.rgblobSymCaps[i].pBlobData);

                    // OID_SECURITY_AUTHATTR
                    SafeMemFree(m_rOptions.rgblobAuthAttr[i].pBlobData);

                    // OID_SECURITY_UNAUTHATTR
                    SafeMemFree(m_rOptions.rgblobUnauthAttr[i].pBlobData);
#endif // SMIME_V3
                    }

                // OID_SECURITY_HCERTSTORE
                CertCloseStore(m_rOptions.hCertStore, 0);
                m_rOptions.hCertStore = NULL;

                _FreeLayerArrays();
                m_rOptions.cSigners = 0;
                }
            }
        else if (m_rOptions.cSigners <= pValue->ulVal)
            {
                hr = _HrEnsureBodyOptionLayers(pValue);
            }
        break;

#ifdef SMIME_V3
    case OID_SECURITY_RECEIPT_RG:
        if (fInternal)
            {
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobReceipt, fNoDirty);
            }
        else
            hr = MIME_E_READ_ONLY;
        break;

    case OID_SECURITY_MESSAGE_HASH_RG:
        if (fInternal)
            {
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
                {
                break;
                }
            hr = _CompareCopyBlobArray(pValue, &m_rOptions.rgblobMsgHash, fNoDirty);
            }
        else
            hr = MIME_E_READ_ONLY;
        break;

    case OID_SECURITY_KEY_PROMPT:
        if ((m_rOptions.pwszKeyPrompt == NULL) ||
            (pValue->pwszVal == NULL) ||
            (lstrcmpW(m_rOptions.pwszKeyPrompt,pValue->pwszVal) != 0))
            {
            SafeMemFree(m_rOptions.pwszKeyPrompt);
            if (pValue->pwszVal != NULL)
                {
                m_rOptions.pwszKeyPrompt = PszDupW(pValue->pwszVal);
                if (NULL == m_rOptions.pwszKeyPrompt)
                    hr = E_OUTOFMEMORY;
                }
            }
        break;

#endif // SMIME_V3

    case OID_NOSECURITY_ONSAVE:
        m_rOptions.fNoSecurityOnSave = !!pValue->boolVal;
        break;
#ifdef _WIN65
// (YST) This was checked in by BriMo at 01/22/99
    case OID_SECURITY_CERT_SIGNING2:
        if (FAILED(hr = _HrEnsureBodyOptionLayers(1)))
        {
            break;
        }
        if (m_rOptions.rgpcCertSigning[0] != *(PCCERT_CONTEXT *)(&(pValue->uhVal)))
        {
            if (m_rOptions.rgpcCertSigning[0])
                 CertFreeCertificateContext(m_rOptions.rgpcCertSigning[0]);
            m_rOptions.rgpcCertSigning[0] = CertDuplicateCertificateContext(*(PCCERT_CONTEXT *)(&(pValue->uhVal)));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG2: // signing algorithms
            if (FAILED(hr = _HrEnsureBodyOptionLayers(pValue)))
            {
                break;
            }
            cauh = pValue->cauh;
            Assert(cauh.cElems == m_rOptions.cSigners || 0 == m_rOptions.cSigners);
            if (m_rOptions.cSigners != cauh.cElems && 0 != m_rOptions.cSigners)
            {
                hr = E_INVALIDARG;
            } else {
                for (i = 0; i < cauh.cElems; i++)
                {
                    if (m_rOptions.rgpcCertSigning[i] != (PCCERT_CONTEXT)(cauh.pElems[i]))
                    {
                        if (m_rOptions.rgpcCertSigning[i])
                             CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);
                        m_rOptions.rgpcCertSigning[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT )(cauh.pElems[i]));
                        if (!fNoDirty)
                            FLAGSET(m_dwState, BODYSTATE_DIRTY);
                    }
                }
            }
        break;

    case OID_SECURITY_CERT_DECRYPTION2:
        if (m_rOptions.pcCertDecryption != *(PCCERT_CONTEXT *)(&(pValue->uhVal)))
            {
            if (m_rOptions.pcCertDecryption)
                CertFreeCertificateContext(m_rOptions.pcCertDecryption);
            m_rOptions.pcCertDecryption = CertDuplicateCertificateContext(*(PCCERT_CONTEXT *)(&(pValue->uhVal)));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT2:
        if (SUCCEEDED(hr = _CAUHToCERTARRAY(pValue->cauh, &m_rOptions.caEncrypt)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_HCERTSTORE2:
        CertCloseStore(m_rOptions.hCertStore, 0);
        if (pValue->ulVal)
            m_rOptions.hCertStore = CertDuplicateStore(*(HCERTSTORE *)(&(pValue->uhVal)));
        else
            m_rOptions.hCertStore = NULL;
        break;

    case OID_SECURITY_RG_CERT_BAG2:
        if (SUCCEEDED(hr = _CAUHToCertStore(pValue->cauh, &m_rOptions.hCertStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_SEARCHSTORES2:
        if (SUCCEEDED(hr = _CAUHToSTOREARRAY(pValue->cauh, &m_rOptions.saSearchStore)))
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
        break;

    case OID_SECURITY_RG_IASN2:
        //N TODO: OID_SECURITY_RG_IASN2
        if (fInternal)
            {
            }
        else
            {
            hr = MIME_E_READ_ONLY;
            }
        break;

    case OID_SECURITY_HCRYPTPROV2:
        if (m_rOptions.hCryptProv != *(HCRYPTPROV *)(&(pValue->uhVal)))
            {
            if (m_rOptions.hCryptProv)
                CryptReleaseContext(m_rOptions.hCryptProv, 0);
            m_rOptions.hCryptProv = *(HCRYPTPROV *)(&(pValue->uhVal));
            if (!fNoDirty)
                FLAGSET(m_dwState, BODYSTATE_DIRTY);
            }
        break;
// End of BriMo checkin
#endif // _WIN65

#ifdef _WIN64
    case OID_SECURITY_HWND_OWNER_64:
        m_rOptions.hwndOwner = (HWND)(pValue->pulVal);
        break;
#endif // _WIN64

    default:
        hr = m_pContainer->SetOption(oid, pValue);
        break;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return TrapError(hr);
}

// ---------------------------------------------------------------------------
// CMessageBody::GetOption
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetOption(const TYPEDID oid, LPPROPVARIANT pValue)
{
    // Locals
    DWORD               cb;
    HRESULT             hr=S_OK;
    DWORD               i;
    LPBYTE              pb;
    ASSERTINIT;
    ULONG iLayer;
#ifdef SMIME_V3
    CRYPT_ATTRIBUTE UNALIGNED *pattr;
#endif // SMIME_V3

#ifdef _WIN64
    void UNALIGNED *pv = NULL;
    PCCERT_CONTEXT pTmpCert = NULL;
    PCCERT_CONTEXT      pcCert = NULL;
#endif // _WIN64
    CRYPT_ATTR_BLOB UNALIGNED *pVal = NULL;

    // check params
    if (NULL == pValue)
        return TrapError(E_INVALIDARG);

    pValue->vt = TYPEDID_TYPE(oid);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Optid
    switch(oid)
    {
    case OID_SUPPORT_EXTERNAL_BODY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fExternalBody;
        break;

    case OID_SHOW_MACBINARY:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fShowMacBin;
        break;

    case OID_CBMAX_BODY_LINE:
        pValue->ulVal = m_rOptions.cbMaxLine;
        break;

    case OID_TRANSMIT_BODY_ENCODING:
        pValue->ulVal = (ULONG)m_rOptions.ietTransmit;
        break;

    case OID_WRAP_BODY_TEXT:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fWrapText;
        break;

    case OID_HIDE_TNEF_ATTACHMENTS:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fHideTNEF;
        break;

    case OID_DBCS_ESCAPE_IS_8BIT:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fDBCSEscape8;
        break;

    case OID_SECURITY_TYPE:
        pValue->ulVal = m_rOptions.ulSecurityType;
        break;

    case OID_SECURITY_ALG_HASH:
        if (m_rOptions.cSigners)
        {
            hr = HrCopyBlob(&m_rOptions.rgblobHash[0], &pValue->blob);
        }
        else
        {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
        break;

    case OID_SECURITY_ALG_HASH_RG:
        hr = HrCopyBlobArray(m_rOptions.rgblobHash, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_ALG_BULK:
        hr = HrCopyBlob(&m_rOptions.blobBulk, &pValue->blob);
        break;

#ifndef _WIN64
    case OID_SECURITY_CERT_SIGNING:
        if (m_rOptions.cSigners)
            pValue->ulVal = (ULONG)CertDuplicateCertificateContext(m_rOptions.rgpcCertSigning[0]);
         else
            pValue->ulVal = 0;  // ?
        break;

    case OID_SECURITY_CERT_SIGNING_RG:
        hr = HrCopyDwordArray((ULONG*)m_rOptions.rgpcCertSigning, m_rOptions.cSigners, pValue);
        // Duplicate the certs in place.
        for (iLayer = 0; iLayer < m_rOptions.cSigners; iLayer++)
        {
            pValue->caul.pElems[iLayer] = (ULONG)CertDuplicateCertificateContext((PCCERT_CONTEXT)pValue->caul.pElems[iLayer]);
        }
        break;

    case OID_SECURITY_CERT_DECRYPTION:

        pValue->ulVal = (ULONG)CertDuplicateCertificateContext(m_rOptions.pcCertDecryption);
        break;

#ifndef SMIME_V3
    case OID_SECURITY_RG_CERT_ENCRYPT:
        hr = _CERTARRAYToCAUL(m_rOptions.caEncrypt, &pValue->caul);
        break;
#endif // !SMIEM_V3

    case OID_SECURITY_HCERTSTORE:
        pValue->ulVal = 0;
        if (m_rOptions.hCertStore)
            pValue->ulVal = (ULONG)CertDuplicateStore(m_rOptions.hCertStore);
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG:
        pValue->ulVal = 0;
        if (m_rOptions.hstoreEncrypt != NULL)
            pValue->ulVal = (ULONG) CertDuplicateStore(m_rOptions.hstoreEncrypt);
        break;

    case OID_SECURITY_RG_CERT_BAG:
        hr = _CertStoreToCAUL(m_rOptions.hCertStore, &pValue->caul);
        break;

    case OID_SECURITY_SEARCHSTORES:
        hr = _STOREARRAYToCAUL(m_rOptions.saSearchStore, &pValue->caul);
        break;

    case OID_SECURITY_RG_IASN:
        Assert(FALSE);
        //N TODO: OID_SECURITY_RG_IASN
        break;

    case OID_SECURITY_HCRYPTPROV:
        pValue->ulVal = m_rOptions.hCryptProv;
        m_rOptions.hCryptProv = NULL;   // read-once
        break;

#else //_WIN64
    case OID_SECURITY_CERT_SIGNING_64:
        if (m_rOptions.cSigners)
            pValue->pulVal = (ULONG *)CertDuplicateCertificateContext(m_rOptions.rgpcCertSigning[0]);
        else 
            pValue->pulVal = 0;  // ?
        break;

    case OID_SECURITY_CERT_SIGNING_RG_64:
        hr = HrCopyIntoUlonglongArray((ULARGE_INTEGER *)m_rOptions.rgpcCertSigning, m_rOptions.cSigners, pValue);
        // Duplicate the certs in place.
        if(m_rOptions.cSigners > 0)
        {
          for (iLayer = 0; iLayer < m_rOptions.cSigners; iLayer++)
          {
            pv = (void*) (&(pValue->cauh.pElems[iLayer]));
            pTmpCert = *((PCCERT_CONTEXT *) pv);
                        pcCert = CertDuplicateCertificateContext(pTmpCert);
            pValue->cauh.pElems[iLayer] = *((ULARGE_INTEGER *)(&(pcCert)));
          }
        }
        break;

    case OID_SECURITY_CERT_DECRYPTION_64:
        pValue->pulVal = (ULONG *)CertDuplicateCertificateContext(m_rOptions.pcCertDecryption);
        break;

#ifndef SMIME_V3
    case OID_SECURITY_RG_CERT_ENCRYPT_64:
        hr = _CERTARRAYToCAUH(m_rOptions.caEncrypt, &pValue->cauh);
        break;
#endif // !SMIEM_V3

    case OID_SECURITY_HCERTSTORE_64:
        pValue->pulVal = 0;
        if (m_rOptions.hCertStore)
            pValue->pulVal = (ULONG *)CertDuplicateStore(m_rOptions.hCertStore);
        break;

    case OID_SECURITY_ENCRYPT_CERT_BAG_64:
        pValue->pulVal = 0;
        if (m_rOptions.hstoreEncrypt != NULL)
            pValue->pulVal = (ULONG *) CertDuplicateStore(m_rOptions.hstoreEncrypt);
        break;

    case OID_SECURITY_RG_CERT_BAG_64:
        hr = _CertStoreToCAUH(m_rOptions.hCertStore, &pValue->cauh);
        break;

    case OID_SECURITY_SEARCHSTORES_64:
        hr = _STOREARRAYToCAUH(m_rOptions.saSearchStore, &pValue->cauh);
        break;

    case OID_SECURITY_RG_IASN_64:
        Assert(FALSE);
        //N TODO: OID_SECURITY_RG_IASN
        break;

    case OID_SECURITY_HCRYPTPROV_64:
        pValue->pulVal = (ULONG *) (m_rOptions.hCryptProv);
        m_rOptions.hCryptProv = NULL;   // read-once
        break;

#endif //_WIN64

    case OID_SECURITY_CRL:
        //        hr = HrCopyBlob(&m_rOptions.blobCRL, &pValue->blob);
        Assert(FALSE);
        // M00BUG -- MUST IMPLEMENT THIS
        break;

    case OID_SECURITY_SYMCAPS:
#ifdef SMIME_V3
        pattr = _FindAttribute(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                               szOID_RSA_SMIMECapabilities, 0);
        if (pattr != NULL)
        {
            pVal = &(pattr->rgValue[0]);

            Assert(pattr->cValue == 1);
            if (!MemAlloc((LPVOID UNALIGNED *) &pValue->blob.pBlobData,
                          pVal->cbData))
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            pValue->blob.cbSize = pVal->cbData;
            memcpy(pValue->blob.pBlobData, pVal->pbData,
                   pVal->cbData);
        }
        else {
            pValue->blob.cbSize = 0;
            pValue->blob.pBlobData = NULL;
        }
        pValue->vt = VT_BLOB;
#else  // !SMIME_V3
        if (m_rOptions.cSigners)
        {
            hr = HrCopyBlob(&m_rOptions.rgblobSymCaps[0], &pValue->blob);
        } else {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SYMCAPS_RG:
#ifdef SMIME_V3
        hr = _HrGetAttrs(m_rOptions.cSigners, m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED],
                         szOID_RSA_SMIMECapabilities, pValue);
#else  // !SMIME_V3
        hr = HrCopyBlobArray(m_rOptions.rgblobSymCaps, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_AUTHATTR:
        if (m_rOptions.cSigners)
        {
#ifdef SMIME_V3
            memset(pValue, 0, sizeof(*pValue));
            pValue->vt = VT_BLOB;
            if ((m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0] != NULL) &&
                !CryptEncodeObjectEx(X509_ASN_ENCODING,
                                     szOID_Microsoft_Attribute_Sequence,
                                     m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0],
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &pValue->blob.pBlobData,
                                     &pValue->blob.cbSize))
            {
                hr = HrGetLastError();
            }
#else  // !SMIME_V3
            hr = HrCopyBlob(&m_rOptions.rgblobAuthAttr[0], &pValue->blob);
#endif // SMIME_V3
        }
        else
        {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
        break;

    case OID_SECURITY_AUTHATTR_RG:
#ifdef SMIME_V3
        hr = _HrGetAttrs(m_rOptions.cSigners, m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED], NULL, pValue);
#else  // !SMIME_V3
        hr = HrCopyBlobArray(m_rOptions.rgblobAuthAttr, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_UNAUTHATTR:
        if (m_rOptions.cSigners)
        {
#ifdef SMIME_V3
            memset(pValue, 0, sizeof(*pValue));
            pValue->vt = VT_BLOB;
            if ((m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][0] != NULL) &&
                !CryptEncodeObjectEx(X509_ASN_ENCODING,
                                     szOID_Microsoft_Attribute_Sequence,
                                     m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][0],
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &pValue->blob.pBlobData,
                                     &pValue->blob.cbSize))
            {
                hr = HrGetLastError();
            }
#else  // !SMIME_V3
            hr = HrCopyBlob(&m_rOptions.rgblobUnauthAttr[0], &pValue->blob);
#endif // SMIME_V3
        } else {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
        break;

    case OID_SECURITY_UNAUTHATTR_RG:
#ifdef SMIME_V3
        hr = _HrGetAttrs(m_rOptions.cSigners, m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED], NULL, pValue);
#else  // !SMIME_V3
        hr = HrCopyBlobArray(m_rOptions.rgblobUnauthAttr, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_SIGNTIME:
#ifdef SMIME_V3
        pattr = _FindAttribute(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][0], szOID_RSA_signingTime, 0);

        pValue->vt = VT_FILETIME;

        if (pattr == NULL)
        {
            pValue->filetime.dwLowDateTime = 0;
            pValue->filetime.dwHighDateTime = 0;
        }
        else
        {
            cb = sizeof(pValue->filetime);
            Assert(pattr->cValue == 1);
            pVal = &(pattr->rgValue[0]);
            if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                     pVal->pbData,
                                     pVal->cbData,
                                     0, NULL, &pValue->filetime, &cb))
            {
                hr = HrGetLastError();
                break;
            }
        }
#else  // !SMIME_V3
        if (m_rOptions.cSigners)
        {
            CopyMemory(&pValue->filetime, &m_rOptions.rgftSigning[0], sizeof(FILETIME));
        }
        else
        {
            hr = HrCopyBlob(&blobNULL, &pValue->blob);
        }
#endif // SMIME_V3
        break;

    case OID_SECURITY_SIGNTIME_RG:
#ifdef SMIME_V3
        pValue->vt = VT_VECTOR | VT_VARIANT;
        pValue->capropvar.cElems = m_rOptions.cSigners;
        if (m_rOptions.cSigners > 0)
        {
            hr = HrAlloc((LPVOID *) &pValue->capropvar.pElems,
                         m_rOptions.cSigners * sizeof(PROPVARIANT));
            if (FAILED(hr))
            {
                break;
            }
            memset(pValue->capropvar.pElems, 0, m_rOptions.cSigners * sizeof(PROPVARIANT));
            for (i=0; i<m_rOptions.cSigners; i++)
            {
                pValue->capropvar.pElems[i].vt = VT_FILETIME;

                pattr = _FindAttribute(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i],
                                       szOID_RSA_signingTime, 0);
                if (pattr != NULL)
                {
                    cb = sizeof(pValue->filetime);
                    Assert(pattr->cValue == 1);

                    pVal = &(pattr->rgValue[0]);
                    if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_CHOICE_OF_TIME,
                                             pVal->pbData,
                                             pVal->cbData, 0, NULL,
                                             &pValue->capropvar.pElems[i].filetime,
                                             &cb))
                    {
                        hr = GetLastError();
                        MemFree(pValue->capropvar.pElems);
                        pValue->capropvar.pElems = NULL;
                        break;
                    }
                }
            }
        }
#else  // !SMIME_V3
        hr = HrCopyFiletimeArray(m_rOptions.rgftSigning, m_rOptions.cSigners, pValue);
#endif // SMIME_V3
        break;

    case OID_SECURITY_USER_VALIDITY:
        if (m_rOptions.cSigners)
        {
            pValue->ulVal = m_rOptions.rgulUserDef[0];
        } else {
            pValue->ulVal = 0;
        }
        break;

    case OID_SECURITY_USER_VALIDITY_RG:
        hr = HrCopyDwordArray(m_rOptions.rgulUserDef, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_RO_MSG_VALIDITY:
        if (m_rOptions.cSigners)
        {
            pValue->ulVal = m_rOptions.rgulROValid[0];
        } else {
            pValue->ulVal = 0;
        }
        break;

    case OID_SECURITY_RO_MSG_VALIDITY_RG:
        hr = HrCopyDwordArray(m_rOptions.rgulROValid, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_ENCODE_FLAGS:
        pValue->ulVal = m_rOptions.ulEncodeFlags;
        break;

    case OID_SECURITY_CERT_INCLUDED:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fCertWithMsg;
        break;

#ifndef _WIN64
    case OID_SECURITY_HWND_OWNER:
        pValue->ulVal = ULONG(m_rOptions.hwndOwner);
        break;
#endif  // _WIN64

    case OID_SECURITY_REQUESTED_CTE:
        pValue->lVal = m_rOptions.ietRequested;
        break;

    case OID_SECURITY_SIGNATURE_COUNT:
        pValue->ulVal = ULONG(m_rOptions.cSigners);
        break;

#ifdef SMIME_V3
    case OID_SECURITY_RECEIPT_RG:
        hr = HrCopyBlobArray(m_rOptions.rgblobReceipt, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_MESSAGE_HASH_RG:
        hr = HrCopyBlobArray(m_rOptions.rgblobMsgHash, m_rOptions.cSigners, pValue);
        break;

    case OID_SECURITY_KEY_PROMPT:
        ZeroMemory(&(pValue->pwszVal), sizeof(pValue->pwszVal));
        if (m_rOptions.pwszKeyPrompt != NULL)
                {
            pValue->pwszVal = PszDupW(m_rOptions.pwszKeyPrompt);
            if (NULL == pValue->pwszVal)
                hr = E_OUTOFMEMORY;
                }
        break;
#endif // SMIME_V3

    case OID_NOSECURITY_ONSAVE:
        pValue->boolVal = (VARIANT_BOOL) !!m_rOptions.fNoSecurityOnSave;
        break;

#ifdef _WIN65
// BriMo checkin at 01/22/99
    case OID_SECURITY_CERT_SIGNING2:
        if (m_rOptions.cSigners)
        {
            PCCERT_CONTEXT      pcCert = CertDuplicateCertificateContext(m_rOptions.rgpcCertSigning[0]);
            pValue->uhVal = *(ULARGE_INTEGER *)(&(pcCert));
        } else {
                ZeroMemory(&(pValue->uhVal), sizeof(pValue->uhVal));
        }
        break;

    case OID_SECURITY_CERT_SIGNING_RG2:
        hr = HrCopyIntoUlonglongArray((ULARGE_INTEGER *)m_rOptions.rgpcCertSigning, m_rOptions.cSigners, pValue);
        // Duplicate the certs in place.
        for (iLayer = 0; iLayer < m_rOptions.cSigners; iLayer++)
        {
                        PCCERT_CONTEXT  pcCert = CertDuplicateCertificateContext((PCCERT_CONTEXT)(pValue->cauh.pElems[iLayer]));
            pValue->cauh.pElems[iLayer] = *(ULARGE_INTEGER *)(&(pcCert));
        }
        break;

    case OID_SECURITY_CERT_DECRYPTION2:
                {
                        PCCERT_CONTEXT  pcCert = CertDuplicateCertificateContext(m_rOptions.pcCertDecryption);
            pValue->uhVal = *(ULARGE_INTEGER *)(&(pcCert));
                }
        break;

    case OID_SECURITY_RG_CERT_ENCRYPT2:
        hr = _CERTARRAYToCAUH(m_rOptions.caEncrypt, &pValue->cauh);
        break;

    case OID_SECURITY_HCERTSTORE2:
        ZeroMemory(&(pValue->uhVal), sizeof(pValue->uhVal));
        if (m_rOptions.hCertStore)
                {
                        HCERTSTORE      hCertStore = CertDuplicateStore(m_rOptions.hCertStore);

            pValue->uhVal = *(ULARGE_INTEGER *)(&(hCertStore));
                }
        break;

    case OID_SECURITY_RG_CERT_BAG2:
        hr = _CertStoreToCAUH(m_rOptions.hCertStore, &pValue->cauh);
        break;

    case OID_SECURITY_SEARCHSTORES2:
        hr = _STOREARRAYToCAUH(m_rOptions.saSearchStore, &pValue->cauh);
        break;

    case OID_SECURITY_RG_IASN2:
        Assert(FALSE);
        //N TODO: OID_SECURITY_RG_IASN
        break;

    case OID_SECURITY_HCRYPTPROV2:
        pValue->uhVal = *(ULARGE_INTEGER *)(&(m_rOptions.hCryptProv));
        m_rOptions.hCryptProv = NULL;   // read-once
        break;
// End of BriMo check-in
#endif // _WIN65

#ifdef _WIN64
    case OID_SECURITY_HWND_OWNER_64:
        pValue->pulVal = (ULONG *)(m_rOptions.hwndOwner);
        break;
#endif _WIN64

    default:
        hr = m_pContainer->GetOption(oid, pValue);
        break;
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::InitNew(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release Lock Bytes
    EmptyData();

    // These flags are based on the data objects
    m_dwState = 0;

    // Change Size
    m_cbExternal = 0xFFFFFFFF;

    // Have I Created my property set yet ?
    if (NULL == m_pContainer)
    {
        // Create Init
        CHECKALLOC(m_pContainer = new CMimePropertyContainer);
    }

    // Reset the property set
    CHECKHR(hr = m_pContainer->InitNew());

    // Reset m_pCsetTagged
    m_pCsetTagged = NULL;

    // Reset Options
    _FreeOptions();

    // Reset to default options (this is probably a bug)
    CopyMemory(&m_rOptions, &g_rDefBodyOptions, sizeof(BODYOPTIONS));

    // (t-erikne) need to get this default at run time
    m_rOptions.hwndOwner = HWND_DESKTOP;

    // Reset Charset
    m_pCharset = CIntlGlobals::GetDefBodyCset();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::EmptyData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::EmptyData(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Free current display name
    SafeMemFree(m_pszDisplay);

    // Do I have Data
    SafeRelease(m_rStorage.pUnkRelease);

    // Zero
    ZeroMemory(&m_rStorage, sizeof(BODYSTORAGE));

    // Removed CSETTAGGED state
    FLAGCLEAR(m_dwState, BODYSTATE_CSETTAGGED);
    FLAGCLEAR(m_dwState, BODYSTATE_EXTERNAL);

    // Change Size
    m_cbExternal = 0xFFFFFFFF;

    // Reset Encoding
    m_ietEncoding = IET_7BIT;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetState
// --------------------------------------------------------------------------------
void CMessageBody::SetState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGSET(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::ClearState
// --------------------------------------------------------------------------------
void CMessageBody::ClearState(DWORD dwState)
{
    EnterCriticalSection(&m_cs);
    FLAGCLEAR(m_dwState, dwState);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::ClearDirty
// --------------------------------------------------------------------------------
void CMessageBody::ClearDirty(void)
{
    ASSERTINIT;
    EnterCriticalSection(&m_cs);
    FLAGCLEAR(m_dwState, BODYSTATE_DIRTY);
    m_pContainer->ClearState(COSTATE_DIRTY);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::IsType
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::IsType(IMSGBODYTYPE type)
{
    // Locals
    HRESULT         hr;
    STATSTG         rStat;
    ASSERTINIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Handle Type
    if (IBT_SECURE == type)
    {
        // Is Secure Flag Set
        hr = (ISFLAGSET(m_dwState, BODYSTATE_SECURE)) ? S_OK : S_FALSE;
    }

    // Charset Tagged
    else if (IBT_CSETTAGGED == type)
    {
        hr = ISFLAGSET(m_dwState, BODYSTATE_CSETTAGGED) ? S_OK : S_FALSE;
    }

    // Is this an attachment
    else if (IBT_ATTACHMENT == type)
    {
        // If container returns IMF_ATTACHMENTS, it must be an attachment
        DWORD dw = m_pContainer->DwGetMessageFlags(m_rOptions.fHideTNEF);
        hr = (ISFLAGSET(dw, IMF_ATTACHMENTS) || ISFLAGSET(dw, IMF_HASVCARD)) ? S_OK : S_FALSE;
    }

    // Was AUTOATTACH
    else if (IBT_AUTOATTACH == type)
    {
        hr = (m_pNode && ISFLAGSET(m_pNode->dwState, NODESTATE_AUTOATTACH)) ? S_OK : S_FALSE;
    }

    // Is the body empty
    else if (IBT_EMPTY == type)
    {
        // Body is not empty if it is a multipart with children
        if (m_pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK && m_pNode && m_pNode->cChildren > 0)
            hr = S_FALSE;
        else if (m_rStorage.pUnkRelease)
            hr = S_FALSE;
        else
            hr = S_OK;
    }

    // Error
    else
    {
        hr = TrapError(MIME_E_INVALID_BODYTYPE);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::IsDirty
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::IsDirty(void)
{
    ASSERTINIT;
    EnterCriticalSection(&m_cs);
    HRESULT hr = (ISFLAGSET(m_dwState, BODYSTATE_DIRTY) || m_pContainer->IsDirty() == S_OK) ? S_OK : S_FALSE;
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetOffsets
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetOffsets(LPBODYOFFSETS pOffsets)
{
    // Locals
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    if (NULL == pOffsets)
        return TrapError(E_INVALIDARG);

    // Init
    ZeroMemory(pOffsets, sizeof(BODYOFFSETS));

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not Bound
    if (NULL == m_pNode || (0 == m_pNode->cbBodyStart && 0 == pOffsets->cbBodyEnd))
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // Get Offset Info
    pOffsets->cbBoundaryStart = m_pNode->cbBoundaryStart;
    pOffsets->cbHeaderStart = m_pNode->cbHeaderStart;
    pOffsets->cbBodyStart = m_pNode->cbBodyStart;
    pOffsets->cbBodyEnd = m_pNode->cbBodyEnd;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetEstimatedSize
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetEstimatedSize(ENCODINGTYPE ietEncoding, ULONG *pcbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbSize=0;
    STATSTG         rStat;
    DOCCONVTYPE     dctConvert;
    ILockBytes     *plb=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pcbSize)
        return TrapError(E_INVALIDARG);
    if (ietEncoding >= IET_UNKNOWN)
        return TrapError(MIME_E_INVALID_ENCODINGTYPE);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If external..
    if (ISFLAGSET(m_dwState, BODYSTATE_EXTERNAL) && TRUE == m_rOptions.fExternalBody && 0xFFFFFFFF != m_cbExternal)
    {
        *pcbSize = m_cbExternal;
        goto exit;
    }

    // No internal lockbytes yet ?
    CHECKHR(hr = HrGetLockBytes(&plb));

    // Query m_pLockBytes Size
    CHECKHR(hr = plb->Stat(&rStat, STATFLAG_NONAME));
    cbSize = (ULONG)rStat.cbSize.QuadPart;

    // Otheriwse
    if (IET_CURRENT != ietEncoding)
    {
        // Compute ietEncoding type...
        dctConvert = g_rgConversionMap[m_pContainer->GetEncodingType()].rgDestType[ietEncoding];

        // Handle Conversion type
        if (DCT_ENCODE == dctConvert)
            cbSize = (ULONG)((cbSize * 4) / 3);
        else if (DCT_DECODE == dctConvert)
            cbSize = (ULONG)((cbSize * 3) / 4);
    }

    // Set Return Size
    *pcbSize = cbSize;

exit:
    // Cleanup
    SafeRelease(plb);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SaveToFile
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SaveToFile(ENCODINGTYPE ietEncoding, LPCSTR pszFilePath)
{
    // Locals
    HRESULT     hr=S_OK;
    LPWSTR      pszFilePathW=NULL;

    // Trace
    TraceCall("CMessageBody::SaveToFile");

    // Convert
    IF_NULLEXIT(pszFilePathW = PszToUnicode(CP_ACP, pszFilePath));

    // Do it as unicode
    IF_FAILEXIT(hr = SaveToFileW(ietEncoding, pszFilePathW));

exit:
    // Cleanup
    MemFree(pszFilePathW);

    // Done
    return(hr);
}

// --------------------------------------------------------------------------------
// CMessageBody::SaveToFileW
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SaveToFileW(ENCODINGTYPE ietEncoding, LPCWSTR pszFilePath)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    LPSTREAM        pstmFile=NULL,
                    pstmBody=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pszFilePath)
        return TrapError(E_INVALIDARG);
    if (ietEncoding >= IET_UNKNOWN)
        return TrapError(MIME_E_INVALID_ENCODINGTYPE);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call Get Data
    CHECKHR(hr = GetData(ietEncoding, &pstmBody));

    // Open File Stream
    CHECKHR(hr = OpenFileStreamW((LPWSTR)pszFilePath, CREATE_ALWAYS, GENERIC_WRITE, &pstmFile));

    // Copy Stream
    CHECKHR(hr = _HrCopyDataStream(pstmBody, pstmFile));
    if (S_OK != hr)
        hrWarnings = TrapError(hr);

    // Commit
    CHECKHR(hr = pstmFile->Commit(STGC_DEFAULT));

exit:
    // Cleanup
    SafeRelease(pstmFile);
    SafeRelease(pstmBody);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetData(ENCODINGTYPE ietEncoding, IStream **ppStream)
{
    // Locals
    HRESULT         hr=S_OK;
    BODYSTREAMINIT  rStreamInit;
    CBodyStream    *pBodyStream=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == ppStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init StreamInit
    ZeroMemory(&rStreamInit, sizeof(BODYSTREAMINIT));

    // Initialzie
    rStreamInit.ietExternal = ietEncoding;
    rStreamInit.ietInternal = m_ietEncoding;
    rStreamInit.fRemoveNBSP = m_rOptions.fRemoveNBSP;
    rStreamInit.pCharset    = m_pCharset;

    // Create a new body stream...
    CHECKALLOC(pBodyStream = new CBodyStream());

    // Initialize the body stream
    CHECKHR(hr = pBodyStream->HrInitialize(&rStreamInit, this));

    // Set return
    *ppStream = (IStream *)pBodyStream;
    (*ppStream)->AddRef();

exit:
    // Cleanup
    SafeRelease(pBodyStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetDataHere
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetDataHere(ENCODINGTYPE ietEncoding, IStream *pStream)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    IStream    *pBodyStream=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get the body stream
    CHECKHR(hr = GetData(ietEncoding, &pBodyStream));

    // Copy Stream
    CHECKHR(hr = _HrCopyDataStream(pBodyStream, pStream));
    if (S_OK != hr)
        hrWarnings = TrapError(hr);

exit:
    // Cleanup
    SafeRelease(pBodyStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_HrCopyDataStream
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_HrCopyDataStream(IStream *pstmSource, IStream *pstmDest)
{
    // Locals
    HRESULT     hr=S_OK;
    HRESULT     hrWarnings=S_OK;
    BYTE        rgBuffer[4096];
    ULONG       cbRead;

    // Invalid Arg
    Assert(pstmSource && pstmDest);

    // Loop for ever
    while(1)
    {
        // Read a buffer
        CHECKHR(hr = pstmSource->Read(rgBuffer, 4096, &cbRead));
        if (S_OK != hr)
            hrWarnings = TrapError(hr);

        // Done
        if (0 == cbRead)
            break;

        // Write It
        CHECKHR(hr = pstmDest->Write(rgBuffer, cbRead, NULL));
    }

exit:
    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::HrGetLockBytes
// --------------------------------------------------------------------------------
HRESULT CMessageBody::HrGetLockBytes(ILockBytes **ppLockBytes)
{
    // Locals
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    Assert(ppLockBytes);

    // Init
    *ppLockBytes = NULL;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No Data
    if (NULL == m_rStorage.pUnkRelease)
    {
        hr = TrapError(MIME_E_NO_DATA);
        goto exit;
    }

    // IID_ILockBytes
    if (IID_ILockBytes == m_rStorage.riid)
    {
        // AddRef It
        *ppLockBytes = m_rStorage.pLockBytes;
        (*ppLockBytes)->AddRef();
    }

    // IID_IMimeWebDocument
    else if (IID_IMimeWebDocument == m_rStorage.riid)
    {
        // BindToStorage
        CHECKHR(hr = m_rStorage.pWebDocument->BindToStorage(IID_ILockBytes, (LPVOID *)ppLockBytes));

        // Lets Cache ppLockBytes
        SafeRelease(m_rStorage.pUnkRelease);

        // Assume the lock bytes
        m_rStorage.pLockBytes = (*ppLockBytes);
        m_rStorage.pLockBytes->AddRef();

        // Set pUnkRelease
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;

        // Set Storage Id
        m_rStorage.riid = IID_ILockBytes;
    }

    // Big Problem
    else
        Assert(FALSE);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetData
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetData(ENCODINGTYPE ietEncoding, LPCSTR pszPriType, LPCSTR pszSubType,
    REFIID riid, LPVOID pvObject)
{
    // Locals
    HRESULT         hr=S_OK;
    IStream        *pStream=NULL;
    ASSERTINIT;

    // Parameter Check
    if (NULL == pvObject || ietEncoding >= IET_UNKNOWN || FALSE == FBODYSETDATAIID(riid))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If multipart...
    if (m_pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK)
    {
        // RAID-29817: Only fail if there are children
        if (m_pNode && m_pNode->cChildren > 0)
        {
            hr = TrapError(MIME_E_MULTIPART_NO_DATA);
            goto exit;
        }

        // Lets adjust the Content-Type to application/octet-stream now so that things don't get confused
        CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_APPL_STREAM));
    }

    // Release current m_pLockBytes
    EmptyData();

    // IID_IStream
    if (IID_IStream == riid)
    {
        // New CBodyLockBytes
        CHECKALLOC(m_rStorage.pLockBytes = new CStreamLockBytes((IStream *)pvObject));

        // Set m_rStorage type
        m_rStorage.riid = IID_ILockBytes;
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;
    }

    // IID_ILockBytes
    else if (IID_ILockBytes == riid)
    {
        // Just assume it
        m_rStorage.pLockBytes = (ILockBytes *)pvObject;
        m_rStorage.pLockBytes->AddRef();

        // Set m_rStorage type
        m_rStorage.riid = IID_ILockBytes;
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;
    }

    // IID_IMimeBody
    else if (IID_IMimeBody == riid)
    {
        // CopyTo
        CHECKHR(hr = ((IMimeBody *)pvObject)->CopyTo(this));
    }

    // IID_IMimeMessage
    else if (IID_IMimeMessage == riid)
    {
        // Locals
        IMimePropertySet *pProps;
        IMimeMessage *pMessage=(IMimeMessage *)pvObject;

        // Get the message source
        CHECKHR(hr = pMessage->GetMessageSource(&pStream, 0));

        // New CBodyLockBytes
        CHECKALLOC(m_rStorage.pLockBytes = new CStreamLockBytes(pStream));

        // Set m_rStorage type
        m_rStorage.riid = IID_ILockBytes;
        m_rStorage.pUnkRelease = m_rStorage.pLockBytes;

        // Set Content Type message/rfc822
        CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTTYPE, STR_MIME_MSG_RFC822));

        // Get Root Property Container
        if (SUCCEEDED(pMessage->BindToObject(HBODY_ROOT, IID_IMimePropertySet, (LPVOID *)&pProps)))
        {
            // Locals
            MIMEPROPINFO rPropInfo;

            // I don't actualy want any props, just want to know if its set
            rPropInfo.dwMask = 0;

            // News Message ?
            if (SUCCEEDED(pProps->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUPS), &rPropInfo)) ||
                SUCCEEDED(pProps->GetPropInfo(PIDTOSTR(PID_HDR_XNEWSRDR), &rPropInfo)) ||
                SUCCEEDED(pProps->GetPropInfo(PIDTOSTR(PID_HDR_NEWSGROUP), &rPropInfo)))
                m_pContainer->SetState(COSTATE_RFC822NEWS);
            else
                m_pContainer->ClearState(COSTATE_RFC822NEWS);

            // Release
            pProps->Release();
        }
    }

    // IID_IMimeWebDocument
    else if (IID_IMimeWebDocument == riid)
    {
        // Just assume it
        m_rStorage.pWebDocument = (IMimeWebDocument *)pvObject;
        m_rStorage.pWebDocument->AddRef();

        // Set m_rStorage type
        m_rStorage.riid = IID_IMimeWebDocument;
        m_rStorage.pUnkRelease = m_rStorage.pWebDocument;
    }

    // Save The Format
    m_ietEncoding = ietEncoding;

    // Save Format per bert
    if (g_rgEncodingMap[ietEncoding].pszName)
        CHECKHR(hr = m_pContainer->SetProp(SYM_HDR_CNTXFER, g_rgEncodingMap[ietEncoding].pszName));

    // Set PriType
    if (pszPriType)
        CHECKHR(hr = m_pContainer->SetProp(SYM_ATT_PRITYPE, pszPriType));

    // Set SubType
    if (pszSubType)
        CHECKHR(hr = m_pContainer->SetProp(SYM_ATT_SUBTYPE, pszSubType));

    // Assume The User is now controlling the Character Set Properties of this body
    FLAGCLEAR(m_dwState, BODYSTATE_CSETTAGGED);

    // We are now dirty
    FLAGSET(m_dwState, BODYSTATE_DIRTY);

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

STDMETHODIMP CMessageBody::SetDataW(ENCODINGTYPE ietEncoding, LPCWSTR pwszPriType, LPCWSTR pwszSubType,
    REFIID riid, LPVOID pvObject)
{
    return TraceResult(E_NOTIMPL);
}

// --------------------------------------------------------------------------------
// CMessageBody::CopyTo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::CopyTo(IMimeBody *pBodyIn)
{
    // Locals
    HRESULT         hr=S_OK;
    LPMESSAGEBODY   pBody=NULL;
    LPCONTAINER     pContainer=NULL;

    // Invalid Arg
    if (NULL == pBodyIn)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // QI for Private CMessageBody
    CHECKHR(hr = pBodyIn->QueryInterface(IID_CMessageBody, (LPVOID *)&pBody));

    // Thread Safety
    EnterCriticalSection(&pBody->m_cs);

    // Copy Data Over
    pBody->m_dwState = m_dwState;

    // Release Current Data
    pBody->EmptyData();

    // Copy body props
    CHECKHR(hr = m_pContainer->Clone(&pContainer));

    // Release the Bodies' Current Container
    SafeRelease(pBody->m_pContainer);

    // Reset the Container
    pBody->m_pContainer = pContainer;

    // Assume new container in pNode
    if (pBody->m_pNode)
        pBody->m_pNode->pContainer = pContainer;

    // Copy Display Name
    if (m_pszDisplay)
        CHECKALLOC(pBody->m_pszDisplay = PszDupW(m_pszDisplay));

    // Copy Options

    // BUGBUG: This is pretty iffy.  BODYOPTIONS contains pointers, each of which should
    // be duplicated.  Caller beware!

    CopyMemory(&pBody->m_rOptions, &m_rOptions, sizeof(BODYOPTIONS));

    // Current Encoding
    pBody->m_ietEncoding = m_ietEncoding;

    // Charset
    pBody->m_pCharset = m_pCharset;

    // If we have data
    if (m_rStorage.pUnkRelease)
    {
        // IID_ILockBytes
        if (IID_ILockBytes == m_rStorage.riid)
        {
            pBody->m_rStorage.pLockBytes = m_rStorage.pLockBytes;
            pBody->m_rStorage.pLockBytes->AddRef();
            pBody->m_rStorage.pUnkRelease = pBody->m_rStorage.pLockBytes;
            pBody->m_rStorage.riid = IID_ILockBytes;
        }

        // IID_IMimeWebDocument
        else if (IID_IMimeWebDocument == m_rStorage.riid)
        {
            pBody->m_rStorage.pWebDocument = m_rStorage.pWebDocument;
            pBody->m_rStorage.pWebDocument->AddRef();
            pBody->m_rStorage.pUnkRelease = pBody->m_rStorage.pWebDocument;
            pBody->m_rStorage.riid = IID_IMimeWebDocument;
        }

        // Big Problem
        else
            Assert(FALSE);
    }

exit:
    // Release Thread Safety
    if (pBody)
        LeaveCriticalSection(&pBody->m_cs);

    // Cleanup
    SafeRelease(pBody);
    SafeRelease(pContainer);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetCurrentEncoding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetCurrentEncoding(ENCODINGTYPE ietEncoding)
{
    // Parameter Check
    if (ietEncoding >= IET_UNKNOWN)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set the current encoding
    m_ietEncoding = ietEncoding;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetCurrentEncoding
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetCurrentEncoding(ENCODINGTYPE *pietEncoding)
{
    // Invalid Arg
    if (NULL == pietEncoding)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Set Return
    *pietEncoding = m_ietEncoding;

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetTransmitInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetTransmitInfo(LPTRANSMITINFO pTransmit)
{
    // Locals
    HRESULT         hr=S_OK;
    HRESULT         hrWarnings=S_OK;
    ULONG           cbRead,
                    cbLine=0,
                    cEscapeChars=0,
                    i;
    BYTE            rgBuffer[4096];
    LPSTREAM        pStream=NULL;
    BYTE            bPrev='\0';
    BOOL            fBadEOL=FALSE;
    ASSERTINIT;

    // Parmaeters
    if (NULL == pTransmit)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    ZeroMemory(pTransmit, sizeof(TRANSMITINFO));

    // Set the current code page
    pTransmit->ietCurrent = m_ietEncoding;

    // Init Format
    pTransmit->ietXmitMime = IET_7BIT;
    pTransmit->ietXmit822  = IET_7BIT;

    // Don't call for multipart types...
    if (m_pContainer->IsContentType(STR_CNT_MULTIPART, NULL) == S_OK)
    {
        Assert(FALSE);
        hr = TrapError(MIME_E_MULTIPART_NO_DATA);
        goto exit;
    }

    // Lets a binary stream of the data
    CHECKHR(hr = GetData(IET_INETCSET, &pStream));

    // Scan It
    while(1)
    {
        // Read a buffer
        CHECKHR(hr = pStream->Read(rgBuffer, sizeof(rgBuffer), &cbRead));
        if (S_OK != hr)
            hrWarnings = TrapError(hr);

        // Done
        if (0 == cbRead)
            break;

        // Scan the buffer
        for (i=0; i<cbRead; i++, cbLine++)
        {
            // If End of line, reset line length
            if (chLF == rgBuffer[i])
            {
                // Count lines
                pTransmit->cLines++;
                cbLine = 0;

                // Raid-41839: x-bitmap images are not correctly transferred via Schotzie
                // Don't write out lines that end with only a \n, not legal
                if (chCR != bPrev)
                    fBadEOL = TRUE;
            }

            // Line too long
            if (cbLine > pTransmit->cbLongestLine)
                pTransmit->cbLongestLine++;

            // Tests for extended and control characters
            if (IS_EXTENDED(rgBuffer[i]))
            {
                // Count Extneded
                pTransmit->cExtended++;

                // Count Escape Characters
                if (0x1B == rgBuffer[i])
                    cEscapeChars++;
            }

            // Save Previous
            bPrev = rgBuffer[i];
        }

        // Increment Total
        pTransmit->cbSize += cbRead;
    }

    // No Data ?
    if (0 == pTransmit->cbSize)
    {
        pTransmit->ulPercentExt = 0;
        goto exit;
    }

    // RAID-22542: FE-J:Athena:mail:sending mail with text/plain  has Content-transfer-encording:8bit
    if (FALSE == m_rOptions.fDBCSEscape8 && cEscapeChars > 0 && m_pCharset && g_pInternat->IsDBCSCharset(m_pCharset->hCharset) == S_OK)
    {
        // Subtract the Number of EscapeChars off of the number of extended chars
        Assert(cEscapeChars <= pTransmit->cExtended);
        pTransmit->cExtended -= cEscapeChars;
    }

    if (IET_UNKNOWN == m_rOptions.ietTransmit)
    {
        // More than 25% extended characters
        pTransmit->ulPercentExt = ((pTransmit->cExtended * 100) / pTransmit->cbSize);

        // Raid-41839: x-bitmap images are not correctly transferred via Schotzie
        // More than 17 percent extended
        if (pTransmit->ulPercentExt > 17)
        {
            pTransmit->ietXmitMime = IET_BASE64;
            pTransmit->ietXmit822  = IET_UUENCODE;
        }

        // Some Extended Characters or line longer than max
        else if (pTransmit->cExtended || pTransmit->cbLongestLine > m_rOptions.cbMaxLine || TRUE == fBadEOL)
        {
            pTransmit->ietXmitMime = IET_QP;
            pTransmit->ietXmit822  = IET_7BIT;
        }

        // Otherwise, 7bit
        else
        {
            pTransmit->ietXmitMime = IET_7BIT;
            pTransmit->ietXmit822  = IET_7BIT;
        }
    }
    else
    {
        // the client specifically set this option, so honor it
        pTransmit->ietXmitMime = m_rOptions.ietTransmit;

        // we may need to fixup ietXmit822 if the XmitMime
        // option does not make sense for it
        switch (m_rOptions.ietTransmit)
        {
            case IET_BASE64:
                pTransmit->ietXmit822 = IET_UUENCODE;
                break;
            case IET_QP:
                pTransmit->ietXmit822 = IET_7BIT;
                break;
            default:
                pTransmit->ietXmit822 = m_rOptions.ietTransmit;
                break;
        }
    }

exit:
    // Cleanup
    SafeRelease(pStream);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return (hr == S_OK) ? hrWarnings : hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SwitchContainers
// --------------------------------------------------------------------------------
void CMessageBody::SwitchContainers(CMessageBody *pBody)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);
    EnterCriticalSection(&pBody->m_cs);

    // Invalid Arg
    Assert(pBody && pBody->m_pContainer && m_pContainer && m_pNode && pBody->m_pNode);

    // Simple Varialbe Swap
    LPCONTAINER pTemp = m_pContainer;
    m_pNode->pContainer = m_pContainer = pBody->m_pContainer;
    pBody->m_pNode->pContainer = pBody->m_pContainer = pTemp;

    // Thread Safety
    LeaveCriticalSection(&pBody->m_cs);
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CMessageBody::GetHandle
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetHandle(LPHBODY phBody)
{
    // Local
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    if (NULL == phBody)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Init
    *phBody = NULL;

    // Not Bound...
    if (NULL == m_pNode || NULL == m_pNode->hBody)
    {
        hr = MIME_E_NO_DATA;
        goto exit;
    }

    // Set Handle
    *phBody = m_pNode->hBody;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetClassID
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetClassID(CLSID *pClassID)
{
    ASSERTINIT;

    // Parmaeters
    if (NULL == pClassID)
        return TrapError(E_INVALIDARG);

    // Copy Class Id
    CopyMemory(pClassID, &IID_IMimeBody, sizeof(CLSID));

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetSizeMax
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetSizeMax(ULARGE_INTEGER* pcbSize)
{
    // Locals
    HRESULT hr=S_OK;
    ULONG   cbSize;
    ASSERTINIT;

    // Get The Size
    CHECKHR(hr = GetEstimatedSize(IET_BINARY, &cbSize));

    // Return the Size
    pcbSize->QuadPart = cbSize;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::Load
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::Load(LPSTREAM pStream)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Load(pStream));
}

// ---------------------------------------------------------------------------
// CMessageBody::Load
// ---------------------------------------------------------------------------
HRESULT CMessageBody::Load(CInternetStream *pInternet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Load(pInternet));
}

// --------------------------------------------------------------------------------
// CMessageBody::Save
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::Save(LPSTREAM pStream, BOOL fClearDirty)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Save(pStream, fClearDirty));
}

// --------------------------------------------------------------------------------
// CMessageBody::IsContentType
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::IsContentType(LPCSTR pszPriType, LPCSTR pszSubType)
{
    ASSERTINIT;
    return TrapError(m_pContainer->IsContentType(pszPriType, pszSubType));
}

// --------------------------------------------------------------------------------
// CMessageBody::GetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetCharset(LPHCHARSET phCharset)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetCharset(phCharset));
}

// --------------------------------------------------------------------------------
// CMessageBody::SetCharset
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetCharset(HCHARSET hCharset, CSETAPPLYTYPE applytype)
{
    // Locals
    HRESULT hr=S_OK;
    ASSERTINIT;

    // Invalid Arg
    if (NULL == hCharset)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Lookiup Charset Info
    if (FALSE == g_pInternat->FIsValidHandle(hCharset))
    {
        hr = TrapError(MIME_E_INVALID_HANDLE);
        goto exit;
    }

    // If I'm already tagged with a charset, and applytype is CSET_APPLY_UNTAGGED, then leave
    if (ISFLAGSET(m_dwState, BODYSTATE_SKIPCSET) == TRUE && CSET_APPLY_UNTAGGED == applytype)
        goto exit;

    // Pass it into the property set
    CHECKHR(hr = m_pContainer->SetCharset(hCharset, applytype));

    // If I'm already tagged with a charset, and applytype is CSET_APPLY_UNTAGGED, then leave
    if (ISFLAGSET(m_dwState, BODYSTATE_CSETTAGGED) == TRUE && CSET_APPLY_UNTAGGED == applytype)
        goto exit;

    // Save the character set...
    SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_pCharset)));

    // Mark as Tagged
    if (CSET_APPLY_TAG_ALL == applytype)
    {
        // Mark the body as being tagged with a charset

        // Get Internal Character Set
        if (SUCCEEDED(m_pContainer->GetCharset(&hCharset)))
        {
            // Get Pointer
            SideAssert(SUCCEEDED(g_pInternat->HrOpenCharset(hCharset, &m_pCharset)));

            // Save this as m_pCsetTagged
            m_pCsetTagged = m_pCharset;
        }

        // I was tagged with a charset
        FLAGSET(m_dwState, BODYSTATE_CSETTAGGED);

        // Mark the charset as explicitly set
        FLAGSET(m_dwState, BODYSTATE_SKIPCSET);
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetProp(pszName, dwFlags, pValue));
}

// ---------------------------------------------------------------------------
// CMessageBody::AppendProp
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::AppendProp(LPCSTR pszName, DWORD dwFlags, LPPROPVARIANT pValue)
{
    ASSERTINIT;
    return TrapError(m_pContainer->AppendProp(pszName, dwFlags, pValue));
}

// --------------------------------------------------------------------------------
// CMessageBody::SetProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetProp(LPCSTR pszName, DWORD dwFlags, LPCPROPVARIANT pValue)
{
    ASSERTINIT;
    return TrapError(m_pContainer->SetProp(pszName, dwFlags, pValue));
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteProp
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::DeleteProp(LPCSTR pszName)
{
    ASSERTINIT;
    return TrapError(m_pContainer->DeleteProp(pszName));
}

// ---------------------------------------------------------------------------
// CMessageBody::QueryProp
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::QueryProp(LPCSTR pszName, LPCSTR pszCriteria, boolean fSubString, boolean fCaseSensitive)
{
    ASSERTINIT;
    return TrapError(m_pContainer->QueryProp(pszName, pszCriteria, fSubString, fCaseSensitive));
}

// --------------------------------------------------------------------------------
// CMessageBody::Clone
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::Clone(IMimePropertySet **ppPropertySet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->Clone(ppPropertySet));
}

// --------------------------------------------------------------------------------
// CMessageBody::BindToObject
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::BindToObject(REFIID riid, void **ppvObject)
{
    // Locals
    HRESULT     hr=S_OK;
    ASSERTINIT;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // IID_IStream
    if (IID_IStream == riid)
    {
        // Get Data...
        CHECKHR(hr = GetData(IET_INETCSET, (IStream **)ppvObject));
    }

    // IID_IUnicodeStream
    else if (IID_IUnicodeStream == riid)
    {
        // Get Data...
        CHECKHR(hr = GetData(IET_UNICODE, (IStream **)ppvObject));
    }

    // IID_IMimeMessage... (returns message/rfc822 or message/partial bodies)
    else if (IID_IMimeMessage == riid)
    {
        // Better be message/rfc822 or message/partial...
        if (m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_RFC822) == S_OK ||
            m_pContainer->IsContentType(STR_CNT_MESSAGE, STR_SUB_PARTIAL) == S_OK)
        {
            // Locals
            LPSTREAM        pstmMsg=NULL;
            IMimeMessage   *pMessage=NULL;

            // Create a message object
            CHECKHR(hr = MimeOleCreateMessage(NULL, &pMessage));

            // Get the body stream...
            hr = GetData(IET_BINARY, &pstmMsg);
            if (FAILED(hr))
            {
                pMessage->Release();
                TrapError(hr);
                goto exit;
            }

            // Load the message...
            hr = pMessage->Load(pstmMsg);
            if (FAILED(hr))
            {
                pstmMsg->Release();
                pMessage->Release();
                TrapError(hr);
                goto exit;
            }

            // Return the message
            *ppvObject = pMessage;
            ((IUnknown *)*ppvObject)->AddRef();

            // Cleanup
            SafeRelease(pstmMsg);
            SafeRelease(pMessage);
        }

        // Otherwise, fail
        else
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
    }

    // Otheriwse, do a normal QI of the body/property set
    else if (SUCCEEDED(QueryInterface(riid, ppvObject)))
        goto exit;

    // Otherwise, try to do a bindtoobject on the container
    else if (SUCCEEDED(m_pContainer->BindToObject(riid, ppvObject)))
        goto exit;

    // Not Found
    else
        hr = TrapError(MIME_E_NOT_FOUND);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteExcept
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::DeleteExcept(ULONG cNames, LPCSTR *prgszName)
{
    ASSERTINIT;
    return TrapError(m_pContainer->DeleteExcept(cNames, prgszName));
}

// ---------------------------------------------------------------------------
// CMessageBody::GetParameters
// ---------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetParameters(LPCSTR pszName, ULONG *pcParams, LPMIMEPARAMINFO *pprgParam)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetParameters(pszName, pcParams, pprgParam));
}

// --------------------------------------------------------------------------------
// CMessageBody::CopyProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::CopyProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->CopyProps(cNames, prgszName, pPropSet));
}

// --------------------------------------------------------------------------------
// CMessageBody::MoveProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::MoveProps(ULONG cNames, LPCSTR *prgszName, IMimePropertySet *pPropSet)
{
    ASSERTINIT;
    return TrapError(m_pContainer->MoveProps(cNames, prgszName, pPropSet));
}

// --------------------------------------------------------------------------------
// CMessageBody::GetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::GetPropInfo(LPCSTR pszName, LPMIMEPROPINFO pInfo)
{
    ASSERTINIT;
    return TrapError(m_pContainer->GetPropInfo(pszName, pInfo));
}

// --------------------------------------------------------------------------------
// CMessageBody::SetPropInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::SetPropInfo(LPCSTR pszName, LPCMIMEPROPINFO pInfo)
{
    ASSERTINIT;
    return TrapError(m_pContainer->SetPropInfo(pszName, pInfo));
}

// --------------------------------------------------------------------------------
// CMessageBody::EnumProps
// --------------------------------------------------------------------------------
STDMETHODIMP CMessageBody::EnumProps(DWORD dwFlags, IMimeEnumProperties **ppEnum)
{
    ASSERTINIT;
    return TrapError(m_pContainer->EnumProps(dwFlags, ppEnum));
}

// --------------------------------------------------------------------------------
// CMessageBody::DwGetFlags
// --------------------------------------------------------------------------------
DWORD CMessageBody::DwGetFlags(BOOL fHideTnef)
{
    DWORD dwFlags = 0;
    ASSERTINIT;

    dwFlags |= m_pContainer->DwGetMessageFlags(fHideTnef);

    // if it isn't x-pkcs7-mime, we already know the flags, so no need for the call
    // check the flag first b/c it is cheap
    if (dwFlags & IMF_SECURE &&
        (S_OK == m_pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_XPKCS7MIME) ||
        S_OK == m_pContainer->IsContentType(STR_CNT_APPLICATION, STR_SUB_PKCS7MIME)))
        dwFlags |= _GetSecureTypeFlags();
    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMessageBody::_GetSecureTypeFlags
// --------------------------------------------------------------------------------
DWORD CMessageBody::_GetSecureTypeFlags()
{
    DWORD           dwSecType;
    DWORD           dwFlags;

    // if the data isn't ASN.1, then this call should fail
    if (SUCCEEDED(TrapError(CSMime::StaticGetMessageType(m_rOptions.hwndOwner,
        (IMimeBody *)this, &dwSecType))))
        {
        dwFlags = IMF_SECURE;
        if (MST_THIS_SIGN & dwSecType)
            dwFlags |= IMF_SIGNED;
        if (MST_THIS_ENCRYPT & dwSecType)
            dwFlags |= IMF_ENCRYPTED;
        }
    else
        dwFlags = 0;

    return dwFlags;
}

// --------------------------------------------------------------------------------
// CMessageBody::CopyOptionsTo
// --------------------------------------------------------------------------------
void CMessageBody::CopyOptionsTo(CMessageBody *pBody, BOOL fNewOnwer /*=FALSE*/)
{
    // Locals
    ENCODINGTYPE ietTransmit;
    ASSERTINIT;

    // Valid State
    Assert(pBody);

    // critsec both bodies since we are using information on both
    EnterCriticalSection(&m_cs);
    EnterCriticalSection(&pBody->m_cs);

    // Copy Body Options
    pBody->m_rOptions = m_rOptions;

    // Raid 33207 - Preserve transmit body encoding
    ietTransmit = m_rOptions.ietTransmit;

    // If pBody->m_rOptions is the new owner, then clear my structure
    CopyMemory(&m_rOptions, &g_rDefBodyOptions, sizeof(BODYOPTIONS));

    // Raid 33207 - Restore transmit body encoding
    m_rOptions.ietTransmit = ietTransmit;

    LeaveCriticalSection(&pBody->m_cs);
    LeaveCriticalSection(&m_cs);
}

#ifndef _WIN64
// -----------------------------------------------------------------------------
// CMessageBody::_CAULToCertStore
// -----------------------------------------------------------------------------

HRESULT CMessageBody::_CAULToCertStore(const CAUL caul, HCERTSTORE * phcertstor)
{
    DWORD               i;

    //  Release the old store -- we don't want it anymore

    if (*phcertstor != NULL)
    {
        CertCloseStore(*phcertstor, 0);
        *phcertstor = NULL;
    }

    //  Create a new store if needed
    if (*phcertstor == NULL)
    {
        *phcertstor = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
    }

    if (*phcertstor == NULL)
    {
        return HrGetLastError();
    }

    for (i=0; i<caul.cElems; i++)
    {
        if (!CertAddCertificateContextToStore(*phcertstor,
                                              (PCCERT_CONTEXT) caul.pElems[i],
                                              CERT_STORE_ADD_ALWAYS, NULL))
        {
            return HrGetLastError();
        }
    }
    return S_OK;
}
#endif // _WIN64

// -----------------------------------------------------------------------------
// CMessageBody::_CertStoreToCAUL
// -----------------------------------------------------------------------------

HRESULT CMessageBody::_CertStoreToCAUL(const HCERTSTORE hcertstor, CAUL * pcaul)
{
    DWORD               cCerts = 0;
    PCCERT_CONTEXT      pccert = NULL;
    PCCERT_CONTEXT *    rgpccert;

    if (hcertstor != NULL)
    {
        while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
        {
            cCerts += 1;
        }
    }

    if (cCerts == 0)
    {
        pcaul->pElems = NULL;
        pcaul->cElems = 0;
        return S_OK;
    }

    pcaul->pElems = (ULONG *) g_pMalloc->Alloc(cCerts*sizeof(PCCERT_CONTEXT *));
    if (pcaul->pElems == NULL)
    {
        return TrapError(E_OUTOFMEMORY);
    }

    rgpccert = (PCCERT_CONTEXT *) pcaul->pElems;
    while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
    {
        *rgpccert = CertDuplicateCertificateContext(pccert);
        rgpccert++;
    }

    pcaul->cElems = cCerts;
    return S_OK;
}

#ifndef SMIME_V3
// --------------------------------------------------------------------------------
// CMessageBody::_CAULToCERTARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAULToCERTARRAY(const CAUL caul, CERTARRAY *pca)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&pca->rgpCerts, caul.cElems*sizeof(PCCERT_CONTEXT))))
    {
        for (i = 0; i < pca->cCerts; i++)
            CertFreeCertificateContext(pca->rgpCerts[i]);

        pca->cCerts = caul.cElems;
        for (i = 0; i < caul.cElems; i++)
            pca->rgpCerts[i] = CertDuplicateCertificateContext((PCCERT_CONTEXT)caul.pElems[i]);
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_CERTARRAYToCAUL
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CERTARRAYToCAUL(const CERTARRAY ca, CAUL *pcaul)
{
    // Locals
    HRESULT         hr = S_OK;
    register DWORD  i;

    if (ca.cCerts)
    {
        if ((pcaul->pElems = (ULONG*)(PCCERT_CONTEXT*)g_pMalloc->Alloc(ca.cCerts*sizeof(PCCERT_CONTEXT))))
        {
            pcaul->cElems = ca.cCerts;
            for (i = 0; i < ca.cCerts; i++)
                pcaul->pElems[i] = (ULONG)CertDuplicateCertificateContext(ca.rgpCerts[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcaul->pElems = NULL;
        pcaul->cElems = 0;
    }

    // Done
    return hr;
}
#endif // !SMIEM_V3

#ifndef _WIN64
// --------------------------------------------------------------------------------
// CMessageBody::_CAULToSTOREARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAULToSTOREARRAY(const CAUL caul, STOREARRAY *psa)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&psa->rgStores, caul.cElems*sizeof(HCERTSTORE))))
    {
        for (i = 0; i < psa->cStores; i++)
            CertCloseStore(psa->rgStores[i], 0);

        psa->cStores = caul.cElems;
        for (i = 0; i < caul.cElems; i++)
            psa->rgStores[i] = CertDuplicateStore((HCERTSTORE)caul.pElems[i]);
    }

    // Done
    return hr;
}
#endif // _WIN64

#ifndef _WIN64
// --------------------------------------------------------------------------------
// CMessageBody::_STOREARRAYToCAUL
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_STOREARRAYToCAUL(const STOREARRAY sa, CAUL *pcaul)
{
    // Locals
    HRESULT         hr = S_OK;
    register DWORD  i;

    if (sa.cStores)
    {
        if ((pcaul->pElems = (ULONG*)(HCERTSTORE*)g_pMalloc->Alloc(sa.cStores*sizeof(HCERTSTORE))))
        {
            pcaul->cElems = sa.cStores;
            for (i = 0; i < sa.cStores; i++)
                pcaul->pElems[i] = (ULONG)CertDuplicateStore(sa.rgStores[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcaul->pElems = NULL;
        pcaul->cElems = 0;
    }

    // Done
    return hr;
}
#endif // _WIN64

// -----------------------------------------------------------------------------
// CMessageBody::_CAUHToCertStore
// -----------------------------------------------------------------------------
HRESULT CMessageBody::_CAUHToCertStore(const CAUH cauh, HCERTSTORE * phcertstor)
{
    DWORD               i;

#ifndef NEED             // This prevent us from send 2 certificates.
    //  Release the old store -- we don't want it anymore

    if (*phcertstor != NULL)
    {
        CertCloseStore(*phcertstor, 0);
        *phcertstor = NULL;
    }
#endif

    //  Create a new store if needed
    if (*phcertstor == NULL)
    {
        *phcertstor = CertOpenStore(CERT_STORE_PROV_MEMORY, X509_ASN_ENCODING,
                                    NULL, 0, NULL);
    }

    if (*phcertstor == NULL)
    {
        return HrGetLastError();
    }

    for (i=0; i<cauh.cElems; i++)
    {
        if (!CertAddCertificateContextToStore(*phcertstor,
                                              *(PCCERT_CONTEXT *) (&(cauh.pElems[i])),
                                              CERT_STORE_ADD_ALWAYS, NULL))
        {
            return HrGetLastError();
        }
    }
    return S_OK;
}

// -----------------------------------------------------------------------------
// CMessageBody::_CertStoreToCAUH
// -----------------------------------------------------------------------------

HRESULT CMessageBody::_CertStoreToCAUH(const HCERTSTORE hcertstor, CAUH * pcauh)
{
    DWORD               cCerts = 0;
    PCCERT_CONTEXT      pccert = NULL;
    PCCERT_CONTEXT *    rgpccert;

    if (hcertstor != NULL)
    {
        while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
        {
            cCerts += 1;
        }
    }

    if (cCerts == 0)
    {
        pcauh->pElems = NULL;
        pcauh->cElems = 0;
        return S_OK;
    }

    pcauh->pElems = (ULARGE_INTEGER *) g_pMalloc->Alloc(cCerts*sizeof(PCCERT_CONTEXT *));
    if (pcauh->pElems == NULL)
    {
        return TrapError(E_OUTOFMEMORY);
    }

    rgpccert = (PCCERT_CONTEXT *) pcauh->pElems;
    while ((pccert = CertEnumCertificatesInStore(hcertstor, pccert)) != NULL)
    {
        *rgpccert = CertDuplicateCertificateContext(pccert);
        rgpccert++;
    }

    pcauh->cElems = cCerts;
    return S_OK;
}

#ifdef _WIN65
// --------------------------------------------------------------------------------
// CMessageBody::_CAUHToCERTARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAUHToCERTARRAY(const CAUH cauh, CERTARRAY *pca)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&pca->rgpCerts, cauh.cElems*sizeof(PCCERT_CONTEXT))))
    {
        for (i = 0; i < pca->cCerts; i++)
            CertFreeCertificateContext(pca->rgpCerts[i]);

        pca->cCerts = cauh.cElems;
        for (i = 0; i < cauh.cElems; i++)
            pca->rgpCerts[i] = CertDuplicateCertificateContext(*(PCCERT_CONTEXT *)(&(cauh.pElems[i])));
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_CERTARRAYToCAUH
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CERTARRAYToCAUH(const CERTARRAY ca, CAUH *pcauh)
{
    // Locals
    HRESULT                             hr = S_OK;
    register DWORD              i;
    PCCERT_CONTEXT *    rgpccert = NULL;

    if (ca.cCerts)
    {
        if ((pcauh->pElems = (ULARGE_INTEGER *)g_pMalloc->Alloc(ca.cCerts*sizeof(PCCERT_CONTEXT))))
        {
            pcauh->cElems = ca.cCerts;
                        rgpccert = *(PCCERT_CONTEXT **)(&(pcauh->pElems));
            for (i = 0; i < ca.cCerts; i++)
                rgpccert[i] = CertDuplicateCertificateContext(ca.rgpCerts[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcauh->pElems = NULL;
        pcauh->cElems = 0;
    }

    // Done
    return hr;
}
#endif // _WIN65

// --------------------------------------------------------------------------------
// CMessageBody::_CAUHToSTOREARRAY
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_CAUHToSTOREARRAY(const CAUH cauh, STOREARRAY *psa)
{
    // Locals
    HRESULT         hr;
    register DWORD  i;

    if (SUCCEEDED(hr = HrRealloc((void**)&psa->rgStores, cauh.cElems*sizeof(HCERTSTORE))))
    {
        for (i = 0; i < psa->cStores; i++)
            CertCloseStore(psa->rgStores[i], 0);

        psa->cStores = cauh.cElems;
        for (i = 0; i < cauh.cElems; i++)
            psa->rgStores[i] = CertDuplicateStore(*(HCERTSTORE *)(&(cauh.pElems[i])));
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::_STOREARRAYToCAUH
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_STOREARRAYToCAUH(const STOREARRAY sa, CAUH *pcauh)
{
    // Locals
    HRESULT         hr = S_OK;
    register DWORD  i;
        HCERTSTORE *    rgStores = NULL;

    if (sa.cStores)
    {
        if ((pcauh->pElems = (ULARGE_INTEGER *)g_pMalloc->Alloc(sa.cStores*sizeof(HCERTSTORE))))
        {
            pcauh->cElems = sa.cStores;
                        rgStores = *(HCERTSTORE **)(&(pcauh->pElems));
            for (i = 0; i < sa.cStores; i++)
                rgStores[i] = CertDuplicateStore(sa.rgStores[i]);
        }
        else
            hr = TrapError(E_OUTOFMEMORY);
    }
    else
    {
        pcauh->pElems = NULL;
        pcauh->cElems = 0;
    }

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CMessageBody::_FreeOptions
// --------------------------------------------------------------------------------
void CMessageBody::_FreeOptions()
{
    DWORD i;

    if (m_rOptions.cSigners)
    {
        // OID_SECURITY_ALG_HASH
        SafeMemFree(m_rOptions.rgblobHash[0].pBlobData);

        // OID_SECURITY_CERT_SIGNING
        for (i = 0; i < m_rOptions.cSigners; i++)
        {
            CertFreeCertificateContext(m_rOptions.rgpcCertSigning[i]);

#ifdef SMIME_V3
            //  Attributes
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][i]);
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED][i]);

            // OID_SECURITY_RECEIPT_RG
            SafeMemFree(m_rOptions.rgblobReceipt[i].pBlobData);
            // OID_SECURITY_MESSAGE_HASH_RG
            SafeMemFree(m_rOptions.rgblobMsgHash[i].pBlobData);
            // OID_SECURITY_KEY_PROMPT
            SafeMemFree(m_rOptions.pwszKeyPrompt);
#else  // !SMIME_V3
            // OID_SECURITY_SYMCAPS
            SafeMemFree(m_rOptions.rgblobSymCaps[i].pBlobData);

            // OID_SECURITY_AUTHATTR
            SafeMemFree(m_rOptions.rgblobAuthAttr[i].pBlobData);

            // OID_SECURITY_UNAUTHATTR
            SafeMemFree(m_rOptions.rgblobUnauthAttr[i].pBlobData);
#endif // SMIME_V3
        }

        // OID_SECURITY_HCERTSTORE
        CertCloseStore(m_rOptions.hCertStore, 0);

        _FreeLayerArrays();

        if (m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNPROTECTED] != NULL) {
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNPROTECTED][0]);
            SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNPROTECTED]);
        }
    }

    // OID_SECURITY_ALG_BULK
    SafeMemFree(m_rOptions.blobBulk.pBlobData);

    // OID_SECURITY_CERT_DECRYPTION
    if (m_rOptions.pcCertDecryption)
        CertFreeCertificateContext(m_rOptions.pcCertDecryption);

#ifdef SMIME_V3
    if (m_rOptions.rgRecipients != 0)
    {
        for (i=0; i<m_rOptions.cRecipients; i++)
        {
            FreeRecipientInfoContent(&m_rOptions.rgRecipients[i]);
        }
    }
    SafeMemFree(m_rOptions.rgRecipients);
    m_rOptions.cRecipients = 0;
    m_rOptions.cRecipsAllocated = 0;
#else  // SMIME_V3
    // OID_SECURITY_RG_CERT_ENCRYPT
    for (i=0; i<m_rOptions.caEncrypt.cCerts; i++)
        CertFreeCertificateContext(m_rOptions.caEncrypt.rgpCerts[i]);
    SafeMemFree(m_rOptions.caEncrypt.rgpCerts);
#endif // !SMIEM_V3

    // OID_SECURITY_SEARCHSTORES
    for (i=0; i<m_rOptions.saSearchStore.cStores; i++)
        CertCloseStore(m_rOptions.saSearchStore.rgStores[i], 0);
    SafeMemFree(m_rOptions.saSearchStore.rgStores);

    // OID_SECURITY_RG_IASN
    // nyi

    // OID_SECURITY_HCRYPTPROV
    if (m_rOptions.hCryptProv)
        CryptReleaseContext(m_rOptions.hCryptProv, 0);

    return;
}

#ifdef _WIN64
#define REALLOC_AND_INIT_OPTION(Option)                                                 \
    if (FAILED(hr = HrRealloc((void**)&Option, LcbAlignLcb(ulLayers * sizeof(*Option))))) {          \
        goto exit;                                                                      \
    }                                                                                   \
    ZeroMemory(&Option[m_rOptions.cSigners], LcbAlignLcb((ulLayersNew) * sizeof(*Option)));
#else
#define REALLOC_AND_INIT_OPTION(Option)                                                 \
    if (FAILED(hr = HrRealloc((void**)&Option, ulLayers * sizeof(*Option)))) {          \
        goto exit;                                                                      \
    }                                                                                   \
    ZeroMemory(&Option[m_rOptions.cSigners], (ulLayersNew) * sizeof(*Option));
#endif //_WIN64
// --------------------------------------------------------------------------------
// CMessageBody::_HrEnsureBodyOptionLayers
// --------------------------------------------------------------------------------
HRESULT CMessageBody::_HrEnsureBodyOptionLayers(ULONG ulLayers)
{
    HRESULT hr = S_OK;
    ULONG ulLayersNew = ulLayers - m_rOptions.cSigners;

    if (m_rOptions.cSigners < ulLayers)
    {
        // Time to grow the arrays
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobHash);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgpcCertSigning);
#ifdef SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED]);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED]);
#else  // !SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobSymCaps);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobAuthAttr);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobUnauthAttr);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgftSigning);
#endif // SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgulUserDef);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgulROValid);
#ifdef SMIME_V3
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobReceipt);
        REALLOC_AND_INIT_OPTION(m_rOptions.rgblobMsgHash);
#endif // SMIME_V3

        m_rOptions.cSigners = ulLayers;
    }

exit:
    return(hr);
}


HRESULT CMessageBody::_HrEnsureBodyOptionLayers(LPCPROPVARIANT ppv)
{
    CAUL * pcaul = (CAUL *)&ppv->caul;

    return(_HrEnsureBodyOptionLayers(pcaul->cElems));
}

// --------------------------------------------------------------------------------
// CMessageBody::_HrEnsureBodyOptionLayers
// --------------------------------------------------------------------------------
void CMessageBody::_FreeLayerArrays(void)
{
    if (m_rOptions.cSigners)
    {
        SafeMemFree(m_rOptions.rgblobHash);
        SafeMemFree(m_rOptions.rgpcCertSigning);
#ifdef SMIME_V3
        SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED]);
        SafeMemFree(m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_UNSIGNED]);
#else  // !SMIME_V3
        SafeMemFree(m_rOptions.rgblobSymCaps);
        SafeMemFree(m_rOptions.rgblobAuthAttr);
        SafeMemFree(m_rOptions.rgblobUnauthAttr);
        SafeMemFree(m_rOptions.rgftSigning);
#endif // SMIME_V3
        SafeMemFree(m_rOptions.rgulUserDef);
        SafeMemFree(m_rOptions.rgulROValid);
#ifdef SMIME_V3
        SafeMemFree(m_rOptions.rgblobReceipt);
        SafeMemFree(m_rOptions.rgblobMsgHash);
#endif // SMIME_V3
        m_rOptions.cSigners = 0;
    }
}


HRESULT CMessageBody::_CompareCopyBlobArray(const PROPVARIANT FAR * pvSource, BLOB FAR * FAR * prgblDestination, BOOL fNoDirty)
{
    HRESULT hr = S_OK;
    ULONG i;
    BOOL fReplace;
    CAPROPVARIANT capropvar = pvSource->capropvar;
    ULONG ulSize = capropvar.cElems;

    Assert(ulSize == m_rOptions.cSigners);
    Assert(*prgblDestination);

    if (ulSize == m_rOptions.cSigners)
    {
        for (i = 0; i < ulSize; i++)
        {
            if ((*prgblDestination)[i].pBlobData)
            {
                if (fReplace = CompareBlob(&(*prgblDestination)[i], (BLOB FAR *)&capropvar.pElems[i]))
                {
                    ReleaseMem((VOID FAR *)(*prgblDestination)[i].pBlobData);
                }
            } else {
                fReplace = TRUE;
            }

            if (fReplace)
            {
                if (FAILED(hr = HrCopyBlob(&(capropvar.pElems[i].blob), &(*prgblDestination)[i])))
                {
                    goto exit;
                }

                if (!fNoDirty)
                {
                    FLAGSET(m_dwState, BODYSTATE_DIRTY);
                }
            }
        }
    } else {
        hr = E_INVALIDARG;
    }
exit:
    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyBlobArray
//
// Allocate a new propvariant blob array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyBlobArray(LPCBLOB pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    // Locals
    HRESULT hr = S_OK;
    CAPROPVARIANT * pcapropvar;
    PROPVARIANT * ppv;
    ULONG i;

    pvOut->vt = VT_VECTOR | VT_VARIANT;
    pcapropvar = &pvOut->capropvar;
    pcapropvar->cElems = cEntries;

    if (cEntries)
    {
        Assert(pIn && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&ppv, cEntries * sizeof(PROPVARIANT))))
        {
            goto exit;
        }

        pcapropvar->pElems = ppv;

        // Fill in the array of BLOBs
        for (i = 0; i < cEntries; i++)
        {
            ppv[i].vt = VT_BLOB;
            // HrCopyBlob allocates memory for the blob data.
            if (FAILED(hr = HrCopyBlob((BLOB FAR *)&pIn[i] , &ppv[i].blob)))
            {
                goto exit;
            }
        }
    } else {
        pcapropvar->pElems = NULL;
    }
exit:
    // BUGBUG: Should clean up allocations on failure

    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyArray
//
// Allocate a new array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyArray(LPBYTE pIn, ULONG cEntries, PROPVARIANT FAR * pvOut, ULONG cbElement)
{
    // Locals
    HRESULT hr = S_OK;
    BYTE * pb;
    ULONG i;
    ULONG cbArray = cEntries * cbElement;
    CAUL * pcaul = &pvOut->caul;

    pcaul->cElems = cEntries;

    if (cEntries)
    {
        Assert(pIn && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&pb, cbArray)))
        {
            goto exit;
        }

        pcaul->pElems = (PULONG)pb;

        // Fill in the array of BLOBs
        memcpy(pb, pIn, cbArray);
    } else {
        pcaul->pElems = NULL;
    }
exit:
    // BUGBUG: Should clean up allocations on failure

    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyDwordArray
//
// Allocate a new dword array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyDwordArray(LPDWORD pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    pvOut->vt = VT_VECTOR | VT_UI4;
    return(HrCopyArray((LPBYTE)pIn, cEntries, pvOut, sizeof(DWORD)));
}

// --------------------------------------------------------------------------------
// HrCopyIntoUlonglongArray
//
// Allocate a new Ulonglong array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyIntoUlonglongArray(ULARGE_INTEGER *pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    // Locals
    HRESULT hr = S_OK;
    ULARGE_INTEGER * pullBuff;
    CAUH * pcauh = &pvOut->cauh;

    pvOut->vt = VT_VECTOR | VT_UI8;
    pcauh->cElems = cEntries;

    if (cEntries)
    {
        Assert(pIn && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&pullBuff, cEntries * sizeof(ULARGE_INTEGER *))))
        {
            goto exit;
        }

        pcauh->pElems = (ULARGE_INTEGER *) pullBuff;

        // Fill in the array of BLOBs
        for (; cEntries > 0; cEntries--, pullBuff++, pIn++)
        {
            *pullBuff = *pIn;
        }
    }
    else
    {
        pcauh->pElems = NULL;
    }
exit:
    // BUGBUG: Should clean up allocations on failure

    return(hr);
}


// --------------------------------------------------------------------------------
// HrCopyFiletimeArray
//
// Allocate a new filetime array, copy the original to it.
// --------------------------------------------------------------------------------
HRESULT HrCopyFiletimeArray(LPFILETIME pIn, ULONG cEntries, PROPVARIANT FAR * pvOut)
{
    pvOut->vt = VT_VECTOR | VT_FILETIME;
    return(HrCopyArray((LPBYTE)pIn, cEntries, pvOut, sizeof(FILETIME)));
}


// --------------------------------------------------------------------------------
// MergeDWORDFlags
//
// Merge the flags from an array of DWORDs into one DWORD
// --------------------------------------------------------------------------------
DWORD MergeDWORDFlags(LPDWORD rgdw, ULONG cEntries)
{
    DWORD dwReturn = 0;

    for (ULONG i = 0; i < cEntries; i++)
    {
        dwReturn |= rgdw[i];
    }

    return(dwReturn);
}

#ifdef SMIME_V3

// --------------------------------------------------------------------------------
// CMessageBody::Encode
// --------------------------------------------------------------------------------

HRESULT CMessageBody::Encode(HWND hwnd, DWORD dwFlags)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageBody::Decode
// --------------------------------------------------------------------------------

HRESULT CMessageBody::Decode(HWND hwnd, DWORD dwFlags, IMimeSecurityCallback * pCallback)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetRecipientCount
// --------------------------------------------------------------------------------

HRESULT CMessageBody::GetRecipientCount(DWORD dwFlags, DWORD * pdwRecipCount)
{
    Assert(dwFlags == 0);
    if (dwFlags != 0) return E_INVALIDARG;
    *pdwRecipCount = m_rOptions.cRecipients;
    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessageBody::AddRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageBody::AddRecipient(DWORD dwFlags, DWORD cRecipData,
                                   PCMS_RECIPIENT_INFO precipData)
{
    DWORD       cbExtra;
    DWORD       dw;
    DWORD       dwCaps;
    HRESULT     hr;
    DWORD       i;

    Assert((dwFlags & ~(SMIME_RECIPIENT_REPLACE_ALL)) == 0);
    if ((dwFlags & (~SMIME_RECIPIENT_REPLACE_ALL)) != 0) return E_INVALIDARG;

    //
    //  Query capabilities
    //

    CHECKHR(hr = CapabilitiesSupported(&dwCaps));

    //
    //  Start by running the verification code on the structures.
    //

    for (i=0; i<cRecipData; i++)
    {
        switch(precipData[i].dwRecipientType)
        {
            //
            //  If you tell use that you don't know whats going on, then you must
            //  1. Give us a certificate
            //  2. If you don't specify an alg, we must recognize the alg in the cert
            //

        case CMS_RECIPIENT_INFO_TYPE_UNKNOWN:
            if (precipData[i].pccert == NULL)
            {
                hr = E_INVALIDARG;
                goto exit;
            }
            if (precipData[i].KeyEncryptionAlgorithm.pszObjId == NULL)
            {
                hr = _HrMapPublicKeyAlg(&precipData[i].pccert->pCertInfo->SubjectPublicKeyInfo,
                                        &dw, NULL);
                if (FAILED(hr))
                {
                    goto exit;
                }

                if (dw == CMS_RECIPIENT_INFO_TYPE_KEYTRANS) {
                    ;
                }
                else if (dw == CMS_RECIPIENT_INFO_TYPE_KEYAGREE) {
                    if (!(dwCaps & SMIME_SUPPORT_KEY_AGREE)) {
                        return MIME_E_SECURITY_NOTIMPLEMENTED;
                    }
                }
                else {
                    return E_INVALIDARG;
                }
            }
            break;

        //
        //  We have no requirements here.
        //
        case CMS_RECIPIENT_INFO_TYPE_KEYTRANS:
            break;

        case CMS_RECIPIENT_INFO_TYPE_KEYAGREE:
            if (!(dwCaps & SMIME_SUPPORT_KEY_AGREE)) {
                return MIME_E_SECURITY_NOTIMPLEMENTED;
            }
            break;

        //
        //  If you give use a mail list key, you must also tell us the
        //      public key identifier and the mail list key or we are going
        //      to fail big time
        //

        case CMS_RECIPIENT_INFO_TYPE_MAIL_LIST:
            if (!(dwCaps & SMIME_SUPPORT_MAILLIST)) {
                return MIME_E_SECURITY_NOTIMPLEMENTED;
            }
            if ((precipData[i].dwU1 != CMS_RECIPIENT_INFO_PUBKEY_PROVIDER) ||
                (precipData[i].dwU3 != CMS_RECIPIENT_INFO_KEYID_KEY_ID))
            {
                hr = E_INVALIDARG;
                goto exit;
            }
            break;

        default:
            Assert(FALSE);
            hr = E_INVALIDARG;
            goto exit;
        }
    }

    //
    //

    if (dwFlags & SMIME_RECIPIENT_REPLACE_ALL)
    {
        for (i=0; i<m_rOptions.cRecipients; i++)
        {
            FreeRecipientInfoContent(&m_rOptions.rgRecipients[i]);
        }
        m_rOptions.cRecipients = 0;
    }

    //

    Assert(m_rOptions.cRecipients <= m_rOptions.cRecipsAllocated);
    if (m_rOptions.cRecipients >= m_rOptions.cRecipsAllocated)
    {
        hr = HrRealloc((LPVOID *) &m_rOptions.rgRecipients,
                       (m_rOptions.cRecipsAllocated+cRecipData+5)*sizeof(CMS_RECIPIENT_INFO));
        if (FAILED(hr))
        {
            goto exit;
        }
        m_rOptions.cRecipsAllocated += 5 + cRecipData;
    }

    //
    //  Do the actual copy of the data
    //

    CHECKHR(hr = _HrCopyRecipInfos(cRecipData, precipData,
                                   &m_rOptions.rgRecipients[m_rOptions.cRecipients]));

    m_rOptions.cRecipients += cRecipData;
    hr = S_OK;

exit:
    return hr;
}

// ------------------------------------------------------------------------------
// CMessageBody::_HrMapPublicKeyAlg
// ------------------------------------------------------------------------------

HRESULT CMessageBody::_HrMapPublicKeyAlg(CERT_PUBLIC_KEY_INFO * pkey, DWORD * pdw,
                                         CRYPT_ALGORITHM_IDENTIFIER ** ppalg)
{
    HRESULT     hr = E_INVALIDARG;

    static      CRYPT_ALGORITHM_IDENTIFIER      rgAlgs[] = {
        {szOID_RSA_RSA, {0, 0}},
        {szOID_RSA_SMIMEalgESDH, {0, 0}}
    };

    if (lstrcmp(pkey->Algorithm.pszObjId, szOID_RSA_RSA) == 0)
    {
        *pdw = CMS_RECIPIENT_INFO_TYPE_KEYTRANS;
        if (ppalg != NULL)
        {
            *ppalg = &rgAlgs[0];
        }
        hr = S_OK;
    }
    else if (lstrcmp(pkey->Algorithm.pszObjId, szOID_ANSI_X942_DH) == 0)
    {
        *pdw = CMS_RECIPIENT_INFO_TYPE_KEYAGREE;
        if (ppalg != NULL)
        {
            *ppalg = &rgAlgs[1];
        }
        hr = S_OK;
    }
    else {
        *pdw = CMS_RECIPIENT_INFO_TYPE_UNKNOWN;
    }
    return hr;
}

// ------------------------------------------------------------------------------
// CMessageBody::_HrCopyRecipInfos
// ------------------------------------------------------------------------------

HRESULT CMessageBody::_HrCopyRecipInfos(DWORD cItems,
                                        const CMS_RECIPIENT_INFO * precipSrc,
                                        PCMS_RECIPIENT_INFO precipDst)
{
    DWORD       cb;
    DWORD                               dw;
    HRESULT     hr;
    DWORD       i;
    CRYPT_ALGORITHM_IDENTIFIER *        palg;

    memset(precipDst, 0, cItems*sizeof(*precipDst));

    for (i=0; i<cItems; i++, precipSrc++, precipDst++)
    {
        //
        //  Now copy over the information
        //

        precipDst->dwRecipientType = precipSrc->dwRecipientType;

        if (precipSrc->pccert != NULL)
        {
            precipDst->pccert = CertDuplicateCertificateContext(
                                            (PCCERT_CONTEXT) precipSrc->pccert);
        }

        //  Move over the key encryption alg if it exists

        if (precipSrc->KeyEncryptionAlgorithm.pszObjId != NULL)
        {
            CHECKHR(hr = HrCopyOID(precipSrc->KeyEncryptionAlgorithm.pszObjId,
                                   &precipDst->KeyEncryptionAlgorithm.pszObjId));
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->KeyEncryptionAlgorithm.Parameters,
                                             &precipDst->KeyEncryptionAlgorithm.Parameters));
        }
        else {
            //
            //  If the data does not exist, then we need to create the data
            //  from scratch.  We do this by pulling information out of the
            //  certificate and create the algorithm information about this.
            //
            //  Maps RSA->RSA; DH -> smimeAlgESDH
            //

            Assert(precipSrc->pccert != NULL);
            hr = _HrMapPublicKeyAlg(&precipDst->pccert->pCertInfo->SubjectPublicKeyInfo,
                                    &dw, &palg);
            Assert(hr == S_OK);
            precipDst->dwRecipientType = dw;

            CHECKHR(hr = HrCopyCryptAlgorithm(palg, &precipDst->KeyEncryptionAlgorithm));
        }

        //
        //  Move over the aux encryption info if it exists.  The length has already
        //      been copied over
        //

        if (precipSrc->cbKeyEncryptionAuxInfo != 0)
        {
            CHECKHR(hr = HrAlloc(&precipDst->pvKeyEncryptionAuxInfo,
                                 precipSrc->cbKeyEncryptionAuxInfo));
        }

        //
        //  Copy over the subject key id information
        //

        precipDst->dwU1 = precipSrc->dwU1;
        switch (precipSrc->dwU1)
        {
        case CMS_RECIPIENT_INFO_PUBKEY_CERTIFICATE:
            if (precipDst->dwRecipientType == CMS_RECIPIENT_INFO_TYPE_KEYTRANS)
            {
                precipDst->dwU1 = CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS;

                CHECKHR(hr = HrCopyCryptBitBlob(
                           &precipSrc->pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey,
                           &precipDst->u1.SubjectPublicKey));

            }
            else if (precipDst->dwRecipientType == CMS_RECIPIENT_INFO_TYPE_KEYAGREE)
            {
                precipDst->dwU1 = CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE;

                CHECKHR(hr = HrCopyCryptBitBlob(
                           &precipSrc->pccert->pCertInfo->SubjectPublicKeyInfo.PublicKey,
                           &precipDst->u1.u3.SubjectPublicKey));

                // precipDst->u1.u3.UserKeyingMaterial = NULL;

                CHECKHR(hr = HrCopyCryptAlgorithm(
                           &precipSrc->pccert->pCertInfo->SubjectPublicKeyInfo.Algorithm,
                           &precipDst->u1.u3.EphemeralAlgorithm));
            }
            else {
                hr = E_INVALIDARG;
                goto exit;
            }
            break;

        case CMS_RECIPIENT_INFO_PUBKEY_KEYTRANS:
            CHECKHR(hr = HrCopyCryptBitBlob(&precipSrc->u1.SubjectPublicKey,
                                            &precipDst->u1.SubjectPublicKey));
            break;

        case CMS_RECIPIENT_INFO_PUBKEY_EPHEMERAL_KEYAGREE:
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->u1.u3.UserKeyingMaterial,
                                             &precipDst->u1.u3.UserKeyingMaterial));
            CHECKHR(hr = HrCopyCryptAlgorithm(&precipSrc->u1.u3.EphemeralAlgorithm,
                                              &precipDst->u1.u3.EphemeralAlgorithm));
            CHECKHR(hr = HrCopyCryptBitBlob(&precipSrc->u1.u3.SubjectPublicKey,
                                            &precipDst->u1.u3.SubjectPublicKey));
            break;

        case CMS_RECIPIENT_INFO_PUBKEY_STATIC_KEYAGREE:
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->u1.u4.UserKeyingMaterial,
                                             &precipDst->u1.u4.UserKeyingMaterial));
            if (!CryptContextAddRef(precipSrc->u1.u4.hprov, 0, 0))
            {
                hr = HrGetLastError();
                goto exit;
            }
            precipDst->u1.u4.hprov = precipSrc->u1.u4.hprov;
            precipDst->u1.u4.dwKeySpec = precipSrc->u1.u4.dwKeySpec;
            CHECKHR(hr = HrCopyCertId(&precipSrc->u1.u4.senderCertId,
                                      &precipDst->u1.u4.senderCertId));
            CHECKHR(hr = HrCopyCryptBitBlob(&precipSrc->u1.u4.SubjectPublicKey,
                                            &precipDst->u1.u4.SubjectPublicKey));
            break;

            // hprov & hkey are already copied over
        case CMS_RECIPIENT_INFO_PUBKEY_PROVIDER:
            if (!CryptContextAddRef(precipDst->u1.u2.hprov, 0, 0))
            {
                hr = HrGetLastError();
                goto exit;
            }
            precipDst->u1.u2.hprov = precipSrc->u1.u2.hprov;
            if (!CryptDuplicateKey(precipSrc->u1.u2.hkey, 0, 0,
                                   &precipDst->u1.u2.hkey))
            {
                hr = HrGetLastError();
                goto exit;
            }
            precipDst->u1.u2.hkey = precipSrc->u1.u2.hkey;
            break;
        }

        precipDst->dwU3 = precipSrc->dwU3;
        switch (precipSrc->dwU3)
        {
        case CMS_RECIPIENT_INFO_KEYID_CERTIFICATE:
            precipDst->dwU3 = CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL;
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->pccert->pCertInfo->Issuer,
                                             &precipDst->u3.IssuerSerial.Issuer));
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->pccert->pCertInfo->SerialNumber,
                                             &precipDst->u3.IssuerSerial.SerialNumber));
            break;

        case CMS_RECIPIENT_INFO_KEYID_ISSUERSERIAL:
            CHECKHR(hr = HrCopyCryptDataBlob( &precipSrc->u3.IssuerSerial.Issuer,
                                              &precipDst->u3.IssuerSerial.Issuer));
            CHECKHR(hr = HrCopyCryptDataBlob( &precipSrc->u3.IssuerSerial.SerialNumber,
                                              &precipDst->u3.IssuerSerial.SerialNumber));
            break;

        case CMS_RECIPIENT_INFO_KEYID_KEY_ID:
            CHECKHR(hr = HrCopyCryptDataBlob(&precipSrc->u3.KeyId, &precipDst->u3.KeyId));
            break;
        }

        precipDst->filetime = precipSrc->filetime;
        if (precipSrc->pOtherAttr != NULL)
        {
            Assert(FALSE);
        }
    }

    hr = S_OK;
exit:
    return hr;
}


// ------------------------------------------------------------------------------
// CMessageBody::GetRecipient
// ------------------------------------------------------------------------------

HRESULT CMessageBody::GetRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients, PCMS_RECIPIENT_INFO pRecipData)
{
    DWORD                       cbAlloc;
    HRESULT                     hr;
    LPBYTE                      pb;
    PCMS_RECIPIENT_INFO         precip;

    if (iRecipient+cRecipients > m_rOptions.cRecipients)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    precip = &m_rOptions.rgRecipients[iRecipient];

    //
    //  Copy the buffer
    //

    CHECKHR(hr = _HrCopyRecipInfos(cRecipients, precip, pRecipData));
    hr = S_OK;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteRecipient
// --------------------------------------------------------------------------------

HRESULT CMessageBody::DeleteRecipient(DWORD dwFlags, DWORD iRecipient, DWORD cRecipients)
{
    return E_FAIL;
}

// --------------------------------------------------------------------------------
// CMessageBody::GetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageBody::GetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   DWORD iInstance, LPCSTR pszObjId,
                                   CRYPT_ATTRIBUTE ** ppattr)
{
    DWORD               cb;
    HRESULT             hr;
    DWORD               i;
    DWORD               i1;
    PCRYPT_ATTRIBUTE    pattr = NULL;
    PCRYPT_ATTRIBUTES   pattrs;
    PCRYPT_ATTRIBUTE    pattrSrc;
    LPBYTE              pb;
    LPBLOB              pblob;

    //
    //  Start with some simple parameter checks
    //

    if ( // (iAttribSet < SMIME_ATTRIBUTE_SET_SIGNED) ||
        (iAttribSet > SMIME_ATTRIBUTE_SET_UNPROTECTED))
    {
        return E_INVALIDARG;
    }

    if (dwFlags & ~(SMIME_RECIPIENT_REPLACE_ALL))
    {
        return E_INVALIDARG;
    }

    if (iAttribSet == SMIME_ATTRIBUTE_SET_UNPROTECTED)
    {
        if ((iSigner != 0) || !g_FSupportV3)
            return E_INVALIDARG;
        if (m_rOptions.rgrgpattrs[iAttribSet] == NULL)
            return S_FALSE;
    }
    else if (iSigner >= m_rOptions.cSigners)
    {
        return E_INVALIDARG;
    }

    //
    //  Special case of getting every single attribute on record
    //

    if (pszObjId == NULL) {
        if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                 szOID_Microsoft_Attribute_Sequence,
                                 m_rOptions.rgrgpattrs[iAttribSet][iSigner],
                                 0, NULL, NULL, &cb))
        {
            hr = HrGetLastError();
            goto exit;
        }

        if (!MemAlloc((LPVOID *) &pattr, cb + sizeof(CRYPT_ATTRIBUTE) +
                      sizeof(CRYPT_ATTR_BLOB))) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pattr->cValue = 1;
        pattr->rgValue = (PCRYPT_ATTR_BLOB) &pattr[1];
        pb = (LPBYTE) &pattr->rgValue[1];

        pattr->pszObjId = NULL;
        pattr->rgValue[0].pbData = pb;
        pattr->rgValue[0].cbData = cb;

        if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                 szOID_Microsoft_Attribute_Sequence,
                                 m_rOptions.rgrgpattrs[iAttribSet][iSigner],
                                 0, NULL, pb, &cb))
        {
            hr = HrGetLastError();
            goto exit;
        }

        *ppattr = pattr;
        pattr = NULL;
        hr = S_OK;
        goto exit;
    }

    //
    //

    pattrSrc = _FindAttribute(m_rOptions.rgrgpattrs[iAttribSet][iSigner], pszObjId,
                           iInstance);
    if (pattrSrc != NULL)
    {
#ifdef _WIN64
        cb = sizeof(CRYPT_ATTRIBUTE) + LcbAlignLcb(strlen(pszObjId) + 1);
#else
        cb = sizeof(CRYPT_ATTRIBUTE) + strlen(pszObjId) + 1;
#endif 
        for (i1=0; i1<pattrSrc->cValue; i1++)
        {
            cb += sizeof(CRYPT_ATTR_BLOB);
#ifdef _WIN64
            cb += LcbAlignLcb(pattrSrc->rgValue[i1].cbData);
#else
            cb += pattrSrc->rgValue[i1].cbData;
#endif 
        }

        if (!MemAlloc((LPVOID *) &pattr, cb))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pattr->cValue = pattrSrc->cValue;
        pattr->rgValue = (PCRYPT_ATTR_BLOB) &pattr[1];
        pb = (LPBYTE) &pattr->rgValue[pattrSrc->cValue];

        pattr->pszObjId = (LPSTR) pb;
        cb = strlen(pszObjId)+1;
        memcpy(pattr->pszObjId, pszObjId, cb);
#ifdef _WIN64
		pb += LcbAlignLcb(cb);
#else
        pb += cb;
#endif //_WIN64

        for (i1=0; i1<pattrSrc->cValue; i1++)
        {
            pattr->rgValue[i1].pbData = pb;
            pattr->rgValue[i1].cbData = pattrSrc->rgValue[i1].cbData;
            memcpy(pb, pattrSrc->rgValue[i1].pbData,
                   pattrSrc->rgValue[i1].cbData);
#ifdef _WIN64
            pb += LcbAlignLcb(pattrSrc->rgValue[i1].cbData);
#else
            pb += pattrSrc->rgValue[i1].cbData;
#endif //_WIN64
        }

        *ppattr = pattr;
        pattr = NULL;
        hr = S_OK;
    }
    else {
        hr = S_FALSE;
    }

exit:
    if (pattr != NULL)          MemFree(pattr);
    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::SetAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageBody::SetAttribute(DWORD dwFlags, DWORD iSigner, DWORD iAttribSet,
                                   const CRYPT_ATTRIBUTE * pattr)
{
    HRESULT     hr;
    DWORD       i;

    //
    //  Start with some simple parameter checks
    //

    if (// (iAttribSet < SMIME_ATTRIBUTE_SET_SIGNED) ||
        (iAttribSet > SMIME_ATTRIBUTE_SET_UNPROTECTED))
    {
        return E_INVALIDARG;
    }

    if (dwFlags & ~(SMIME_ATTR_ADD_TO_EXISTING |
                    SMIME_ATTR_ADD_IF_NOT_EXISTS))
    {
        return E_INVALIDARG;
    }

    if (iAttribSet == SMIME_ATTRIBUTE_SET_UNPROTECTED) {
        if ((iSigner != 0) || !g_FSupportV3)
            return E_INVALIDARG;

        if (m_rOptions.rgrgpattrs[iAttribSet] == NULL) {
            if (!MemAlloc((LPVOID *) &m_rOptions.rgrgpattrs[iAttribSet],
                          sizeof(LPVOID))) {
                return E_OUTOFMEMORY;
            }

            m_rOptions.rgrgpattrs[iAttribSet][0] = NULL;
        }
    }
    else if ((iSigner >= m_rOptions.cSigners) && (iSigner != (DWORD) -1))
    {
        return E_INVALIDARG;
    }

    //
    //  Now make the correct utility call to put things right
    //

    Assert(pattr->cValue == 1);

    if (iSigner == (DWORD) -1)
    {
        Assert(iAttribSet != SMIME_ATTRIBUTE_SET_UNPROTECTED);

        for (i=0; i<m_rOptions.cSigners; i++)
        {
            hr = _HrSetAttribute(dwFlags, &m_rOptions.rgrgpattrs[iAttribSet][i],
                                 pattr->pszObjId, pattr->rgValue[0].cbData,
                                 pattr->rgValue[0].pbData);
            if (FAILED(hr))
            {
                break;
            }
        }
    }
    else {
        hr = _HrSetAttribute(dwFlags, &m_rOptions.rgrgpattrs[iAttribSet][iSigner],
                             pattr->pszObjId, pattr->rgValue[0].cbData,
                             pattr->rgValue[0].pbData);
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CMessageBody::DeleteAttribute
// --------------------------------------------------------------------------------

HRESULT CMessageBody::DeleteAttribute(DWORD dwFlags, DWORD iSigner,
                                      DWORD iAttribSet, DWORD iInstance,
                                      LPCSTR pszObjId)
{
    UINT                i;
    PCRYPT_ATTRIBUTE    pattr;
    PCRYPT_ATTRIBUTES   pattrs;

    //
    //  Start with some simple parameter checks
    //

    if (// (iAttribSet < SMIME_ATTRIBUTE_SET_SIGNED) ||
        (iAttribSet > SMIME_ATTRIBUTE_SET_UNPROTECTED))
    {
        return E_INVALIDARG;
    }

    if (dwFlags & ~(SMIME_RECIPIENT_REPLACE_ALL))
    {
        return E_INVALIDARG;
    }

    if (iAttribSet == SMIME_ATTRIBUTE_SET_UNPROTECTED) {
        if ((iSigner != 0) || !g_FSupportV3)
            return E_INVALIDARG;
        if (m_rOptions.rgrgpattrs[iAttribSet] == NULL)
            return S_OK;
    }
    else if (iSigner >= m_rOptions.cSigners)
    {
        return E_INVALIDARG;
    }

    //

    pattrs = m_rOptions.rgrgpattrs[iAttribSet][iSigner];

    pattr = _FindAttribute(pattrs, pszObjId, iInstance);
    if (pattr != NULL)
    {
        i = (UINT) (pattr - &pattrs->rgAttr[0]);
        Assert( (0 <= ((int) i)) && (((int) i) < pattrs->cAttr));
        memcpy(pattr, pattr+1, (pattrs->cAttr - i - 1) * sizeof(CRYPT_ATTRIBUTE));
        pattrs->cAttr -= 1;
    }
    else {
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CMessageBody::_SetNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD       cb;
    HRESULT     hr = S_OK;
    DWORD       i;
    LPBYTE      pb;

    if (pnames->rgNames != NULL)
    {
        MemFree(pnames->rgNames);
        pnames->rgNames = NULL;
        pnames->cNames = 0;
    }

    for (i=0, cb=cNames*sizeof(CERT_NAME_BLOB); i<cNames; i++)
#ifdef _WIN64
		cb += LcbAlignLcb(rgNames[i].cbData);
#else
        cb += rgNames[i].cbData;
#endif //_WIN64

    CHECKHR(hr = HrAlloc((LPVOID *)&pnames->rgNames, cb));

    pb = (LPBYTE) &pnames->rgNames[cNames];
    for (i=0; i<cNames; i++)
    {
        pnames->rgNames[i].pbData = pb;
        pnames->rgNames[i].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb(rgNames[i].cbData);
#else
        pb += rgNames[i].cbData;
#endif //_WIN64
    }

    pnames->cNames = cNames;
exit:
    return hr;
}

HRESULT CMessageBody::_MergeNames(ReceiptNames * pnames, DWORD cNames, CERT_NAME_BLOB * rgNames)
{
    DWORD               cb;
    HRESULT             hr = S_OK;
    DWORD               i;
    DWORD               i1;
    LPBYTE              pb;
    CERT_NAME_BLOB *    p;

    for (i=0, cb=0; i<pnames->cNames; i++)
#ifdef _WIN64
        cb += LcbAlignLcb(pnames->rgNames[i].cbData);
#else
        cb += pnames->rgNames[i].cbData;
#endif //_WIN64

    for (i=0; i<cNames; i++)
#ifdef _WIN64
        cb += LcbAlignLcb(rgNames[i].cbData);
#else
        cb += rgNames[i].cbData;
#endif //_WIN64

    CHECKHR(hr = HrAlloc((LPVOID *)&p, cb + (pnames->cNames + cNames) *
                                  sizeof(CERT_NAME_BLOB)));

    pb = (LPBYTE) &p[pnames->cNames + cNames];
    for (i=0, i1=0; i<pnames->cNames; i++, i1++)
    {
        p[i1].pbData = pb;
        p[i1].cbData = pnames->rgNames[i].cbData;
        memcpy(pb, pnames->rgNames[i].pbData, pnames->rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb(pnames->rgNames[i].cbData);
#else
        pb += pnames->rgNames[i].cbData;
#endif //_WIN64
    }

    for (i=0; i<pnames->cNames; i++, i1++)
    {
        p[i1].pbData = pb;
        p[i1].cbData = rgNames[i].cbData;
        memcpy(pb, rgNames[i].pbData, rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb(rgNames[i].cbData);
#else
        pb += rgNames[i].cbData;
#endif //_WIN64
    }

    MemFree(pnames->rgNames);
    pnames->rgNames = p;
    pnames->cNames = i1;

exit:
    return hr;
}

/////////////////////////////////////////////////////////////////////////

//--------------------------------------------------------------------------------
// CMessageBody::_GetReceiptRequest
//--------------------------------------------------------------------------------
HRESULT CMessageBody::_GetReceiptRequest(DWORD dwFlags,
                                         PSMIME_RECEIPT_REQUEST *ppreq,
                                         ReceiptNames *pReceiptsTo,
                                         DWORD *pcbReceipt,
                                         LPBYTE *ppbReceipt,
                                         DWORD *pcbMsgHash,
                                         LPBYTE *ppbMsgHash)
{
    DWORD                       cb;
    DWORD                       cbMLHistory = 0;
    DWORD                       cbMsgHash = 0;
    DWORD                       cbReceipt = 0;
    DWORD                       cSendersList = 0;
    DWORD                       dwReciptsFrom;
    HRESULT                     hr = S_OK;
    DWORD                       i;
    DWORD                       iAttr;
    DWORD                       iSigner;
    PCRYPT_ATTRIBUTES           pattrs = NULL;
    LPBYTE                      pb;
    LPBYTE                      pbMLHistory = NULL;
    LPBYTE                      pbMsgHash = NULL;
    LPBYTE                      pbReceipt = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    ReceiptNames                receiptsTo = {0, NULL};
    CERT_NAME_BLOB              *rgSendersList = NULL;
    PROPVARIANT                 var;

    *ppreq = NULL;
    if (pReceiptsTo != NULL)
    {
        pReceiptsTo->cNames = 0;
        pReceiptsTo->rgNames = NULL;
    }
    if (pcbReceipt != NULL) *pcbReceipt = 0;
    if (ppbReceipt != NULL) *ppbReceipt = NULL;
    Assert(((pcbReceipt == NULL) && (ppbReceipt == NULL)) ||
           ((pcbReceipt != NULL) && (ppbReceipt != NULL)));
    if (pcbMsgHash != NULL) *pcbMsgHash = 0;
    if (ppbMsgHash != NULL) *ppbMsgHash = NULL;
    Assert(((pcbMsgHash == NULL) && (ppbMsgHash == NULL)) ||
           ((pcbMsgHash != NULL) && (ppbMsgHash != NULL)));

    //
    //  If this is the bottom layer then
    //      find and Decode Receipt Request
    //      Set ReceiptsTo from the request
    //  if not then
    //          check lower layers
    //          if mlExpansion in this layer? No -- Skip to next layer
    //          Receipt for First Tier only? Yes - return S_FALSE
    //          Policy override on mlExpansion?
    //              None - return S_FALSE
    //  return S_OK

    // If this is not the bottom layer then look for MLHistory
    if (IsContentType(STR_CNT_MULTIPART, "y-security") == S_OK)
    {
        Assert(m_pNode->cChildren == 1);

        hr = m_pNode->pChildHead->pBody->_GetReceiptRequest(
                                        dwFlags,
                                        &preq,
                                        (pReceiptsTo) ? &receiptsTo : NULL,
                                        (pcbReceipt) ? &cbReceipt : NULL,
                                        (ppbReceipt) ? &pbReceipt : NULL,
                                        (pcbMsgHash) ? &cbMsgHash : NULL,
                                        (ppbMsgHash) ? &pbMsgHash : NULL);
        if (hr)
            goto exit;

        //
        //  Walk through each signer's  authenticated attributes processing the
        //  relevant attribute.
        //

        for (iSigner=0; iSigner<m_rOptions.cSigners; iSigner++)
        {
            //
            //  Walk through each attribute looking for
            //      a Mail List expansion history
            //

            pattrs = m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][iSigner];
            for (iAttr=0; iAttr<pattrs->cAttr; iAttr++)
            {
                if (lstrcmp(pattrs->rgAttr[iAttr].pszObjId,
                            szOID_SMIME_MLExpansion_History) == 0)
                {
                    //
                    //  If receipts are from first tier only and we are at
                    //     this layer then we are not first tier by definition.
                    //
                    if (preq->ReceiptsFrom.AllOrFirstTier == SMIME_RECEIPTS_FROM_FIRST_TIER)
                    {
                        hr = S_FALSE;
                        goto exit;
                    }

                    if (cbMLHistory == 0)
                    {
                        CHECKHR(hr = HrAlloc((LPVOID *)&pbMLHistory,
                                             pattrs->rgAttr[iAttr].rgValue[0].cbData));
                        memcpy(pbMLHistory,pattrs->rgAttr[iAttr].rgValue[0].pbData,
                               pattrs->rgAttr[iAttr].rgValue[0].cbData);
                        cbMLHistory = pattrs->rgAttr[iAttr].rgValue[0].cbData;
                    }
                    else if ((pattrs->rgAttr[iAttr].rgValue[0].cbData != cbMLHistory) ||
                             (memcmp(pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                     pbMLHistory, cbMLHistory)))
                    {
                        // Hey, all MLHistorys should match
                         hr = S_FALSE;
                        goto exit;
                    }
                    break;
                }
            }
        }

        // Decode and respect the MLHistory
        if (cbMLHistory != 0)
        {
            PSMIME_ML_EXPANSION_HISTORY     pmlhist = NULL;

            //
            //  Crack the attribute
            //

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                     szOID_SMIME_MLExpansion_History,
                                     pbMLHistory,
                                     cbMLHistory,
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptDecodeAlloc, &pmlhist, &cb))
                goto GeneralFail;

            PSMIME_MLDATA     pMLData = &pmlhist->rgMLData[pmlhist->cMLData-1];

            switch( pMLData->dwPolicy)
            {
                //  No receipt is to be returned
                case SMIME_MLPOLICY_NONE:
                    hr = S_FALSE;
                    SafeMemFree(pmlhist);
                    goto exit;

                //  Return receipt to a new list
                case SMIME_MLPOLICY_INSTEAD_OF:
                    if (pReceiptsTo != NULL)
                        _SetNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;

                case SMIME_MLPOLICY_IN_ADDITION_TO:
                    if (pReceiptsTo != NULL)
                        _MergeNames(&receiptsTo, pMLData->cNames, pMLData->rgNames);
                    break;

                case SMIME_MLPOLICY_NO_CHANGE:
                    break;

                default:
                    SafeMemFree(pmlhist);
                    goto GeneralFail;
            }

            SafeMemFree(pmlhist);
        }
    }
    else
    {
        // Else this is the bottom layer so look for receipt request

        //
        //  Walk through each signer's  authenticated attributes processing the
        //  two relevant attributes.
        //

        for (iSigner=0; iSigner<m_rOptions.cSigners; iSigner++)
        {
            // Check if receipt was created for this signer if not then
            // it's signature must have been bad or it had not request
            if (m_rOptions.rgblobReceipt[iSigner].cbSize == 0)
                continue;

            // if we have a receipt we should also have a message hash
            if (m_rOptions.rgblobMsgHash[iSigner].cbSize == 0)
            {
                Assert(FALSE);
                continue;
            }

            if (m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][iSigner] == NULL)
            {
                // Hey how did we get a receipt without any attributes
                Assert(FALSE);
                goto GeneralFail;
            }

            pattrs = m_rOptions.rgrgpattrs[SMIME_ATTRIBUTE_SET_SIGNED][iSigner];

            //
            //  Walk through each attribute looking for the receipt request
            //

            for (iAttr=0; iAttr<pattrs->cAttr; iAttr++)
            {
                if (lstrcmp(pattrs->rgAttr[iAttr].pszObjId,
                           szOID_SMIME_MLExpansion_History) == 0)
                {
                    // We are at the bottom so we should not have found a ML History
                    hr = S_FALSE;
                    goto exit;
                }
                if (lstrcmp(pattrs->rgAttr[iAttr].pszObjId,
                           szOID_SMIME_Receipt_Request) == 0)
                {
                    //
                    // Crack the contents of the receipt request
                    //

                    if (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                                             szOID_SMIME_Receipt_Request,
                                             pattrs->rgAttr[iAttr].rgValue[0].pbData,
                                             pattrs->rgAttr[iAttr].rgValue[0].cbData,
                                             CRYPT_DECODE_ALLOC_FLAG,
                                             &CryptDecodeAlloc, &preq, &cb) ||
                        (preq->cReceiptsTo == 0))
                        goto GeneralFail;

                    //
                    //  Initialize the ReceiptsTo list
                    //

                    if (pReceiptsTo != NULL)
                        _SetNames(&receiptsTo, preq->cReceiptsTo, preq->rgReceiptsTo);

                    if (ppbReceipt != NULL)
                    {
                        CHECKHR(hr = HrAlloc((LPVOID *)&pbReceipt,
                                             m_rOptions.rgblobReceipt[iSigner].cbSize));
                        memcpy(pbReceipt,m_rOptions.rgblobReceipt[iSigner].pBlobData,
                               m_rOptions.rgblobReceipt[iSigner].cbSize);
                    }
                    if (pcbReceipt != NULL) cbReceipt = m_rOptions.rgblobReceipt[iSigner].cbSize;

                    if (ppbMsgHash != NULL)
                    {
                        CHECKHR(hr = HrAlloc((LPVOID *)&pbMsgHash,
                                             m_rOptions.rgblobMsgHash[iSigner].cbSize));
                        memcpy(pbMsgHash,m_rOptions.rgblobMsgHash[iSigner].pBlobData,
                               m_rOptions.rgblobMsgHash[iSigner].cbSize);
                    }
                    if (pcbMsgHash != NULL) cbMsgHash = m_rOptions.rgblobMsgHash[iSigner].cbSize;
                    break;
                }
            }
        }

        if (preq == NULL)
        {
            // We are at the bottom so we should have found a receipt request
            hr = S_FALSE;
            goto exit;
        }
    }

    *ppreq = preq;
    preq = NULL;
    if (pReceiptsTo != NULL)
    {
        pReceiptsTo->cNames = receiptsTo.cNames;
        pReceiptsTo->rgNames = receiptsTo.rgNames;
        receiptsTo.cNames = 0;
        receiptsTo.rgNames = NULL;
    }
    if (pcbReceipt != NULL)
    {
        *pcbReceipt = cbReceipt;
        cbReceipt = 0;
    }
    if (ppbReceipt != NULL)
    {
        *ppbReceipt = pbReceipt;
        pbReceipt = NULL;
    }
    if (pcbMsgHash != NULL)
    {
        *pcbMsgHash = cbMsgHash;
        cbMsgHash = 0;
    }
    if (ppbMsgHash != NULL)
    {
        *ppbMsgHash = pbMsgHash;
        pbMsgHash = NULL;
    }

exit:
    SafeMemFree(preq);
    SafeMemFree(receiptsTo.rgNames);
    SafeMemFree(pbReceipt);
    SafeMemFree(pbMsgHash);
    SafeMemFree(pbMLHistory);
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto exit;
}

//--------------------------------------------------------------------------------
// CMessageBody::CreateReceipt
//--------------------------------------------------------------------------------

HRESULT CMessageBody::CreateReceipt(DWORD dwFlags, DWORD cbFromNames,
                                    const BYTE *pbFromNames, DWORD cSignerCertificates,
                                    PCCERT_CONTEXT *rgSignerCertificates,
                                    IMimeMessage ** ppMimeMessageReceipt)
{
    CRYPT_ATTRIBUTE             attrMsgHash;
    DWORD                       cb;
    DWORD                       cbEncodedMsgHash = 0;
    DWORD                       cbMsgHash = 0;
    DWORD                       cbReceipt = 0;
    DWORD                       cLayers;
    DWORD                       dwReceiptsFrom;
    BOOL                        fAddedAddress = FALSE;
    HRESULT                     hr;
    DWORD                       i;
    DWORD                       i1;
    DWORD                       i2;
    DWORD                       iLayer;
    LPBYTE                      pbEncodedMsgHash = NULL;
    LPBYTE                      pbMsgHash = NULL;
    LPBYTE                      pbReceipt = NULL;
    IMimeAddressTable *         pmatbl = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeMessage *              pmm = NULL;
    IMimeSecurity2 *            pms = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    LPSTREAM                    pstm = NULL;
    ReceiptNames                receiptsTo = {0, NULL};
    PROPVARIANT                 var;
    CRYPT_ATTR_BLOB             valMsgHash;


    hr = _GetReceiptRequest(dwFlags,
                            &preq,
                            &receiptsTo,
                            &cbReceipt,
                            &pbReceipt,
                            &cbMsgHash,
                            &pbMsgHash);
    if (hr)
        goto exit;

    //
    //  Am I on the ReceiptsFrom List --
    //

    if (preq->ReceiptsFrom.cNames != 0)
    {
        BOOL    fFoundMe = FALSE;
        CERT_ALT_NAME_INFO *    pname2 = NULL;

        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                 pbFromNames,
                                 cbFromNames,
                                 CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptDecodeAlloc, &pname2, &cb))
            goto GeneralFail;

        for (i=0; !fFoundMe && (i<preq->ReceiptsFrom.cNames); i++)
        {
            CERT_ALT_NAME_INFO *    pname = NULL;

            if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                     preq->ReceiptsFrom.rgNames[i].pbData,
                                     preq->ReceiptsFrom.rgNames[i].cbData,
                                     CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptDecodeAlloc, &pname, &cb))
                goto GeneralFail;

            for (i1=0; i1<pname->cAltEntry; i1++)
            {
                for (i2=0; i2<pname2->cAltEntry; i2++)
                {
                    if (pname->rgAltEntry[i1].dwAltNameChoice !=
                        pname2->rgAltEntry[i2].dwAltNameChoice)
                        continue;

                    switch (pname->rgAltEntry[i1].dwAltNameChoice)
                    {
                        case CERT_ALT_NAME_RFC822_NAME:
                            if (lstrcmpiW(pname->rgAltEntry[i1].pwszRfc822Name,
                                          pname2->rgAltEntry[i2].pwszRfc822Name) == 0)
                            {
                                fFoundMe = TRUE;
                                goto FoundMe;
                            }
                    }
                }
            }

        FoundMe:
            SafeMemFree(pname);
        }

        SafeMemFree(pname2);
        if (!fFoundMe)
        {
            hr = S_FALSE;
            goto exit;
        }
    }

    //  Create a stream object to hold the receipt and put the receipt into the
    //  stream -- this supplies the body of the receipt message.

    CHECKHR(hr = MimeOleCreateVirtualStream(&pstm));
    CHECKHR(hr = pstm->Write(pbReceipt, cbReceipt, NULL));

    CHECKHR(hr = MimeOleCreateMessage(NULL, &pmm));
    CHECKHR(hr = pmm->BindToObject(HBODY_ROOT, IID_IMimeBody, (LPVOID *) &pmb));
    CHECKHR(hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms));
    CHECKHR(hr = pmb->SetData(IET_BINARY, "OID", szOID_SMIME_ContentType_Receipt,
                      IID_IStream, pstm));

    //
    //  Address the receipt back to the receipients
    //

    CHECKHR(hr = pmm->GetAddressTable(&pmatbl));

    for (i=0; i<receiptsTo.cNames; i++)
    {
        CERT_ALT_NAME_INFO *    pname = NULL;

        if (!CryptDecodeObjectEx(X509_ASN_ENCODING, X509_ALTERNATE_NAME,
                                 receiptsTo.rgNames[i].pbData,
                                 receiptsTo.rgNames[i].cbData,
                                 CRYPT_ENCODE_ALLOC_FLAG,
                                 &CryptDecodeAlloc, &pname, &cb))
            goto GeneralFail;

        for (i1=0; i1<pname->cAltEntry; i1++)
        {
            int     cch;
            TCHAR   rgch[256];

            if (pname->rgAltEntry[i1].dwAltNameChoice == CERT_ALT_NAME_RFC822_NAME)
            {
                cch = WideCharToMultiByte(CP_ACP, 0,
                                          pname->rgAltEntry[i1].pwszRfc822Name,
                                          -1, rgch, sizeof(rgch), NULL, NULL);
                if (cch > 0)
                {
                    CHECKHR(hr = pmatbl->AppendRfc822(IAT_TO, IET_DECODED,
                                              rgch));
                    fAddedAddress = TRUE;
                }
                break;
            }
        }
        SafeMemFree(pname);
    }

    if (!fAddedAddress)
    {
        hr = S_FALSE;
        goto exit;
    }

    var.vt = VT_UI4;
    var.ulVal = MST_CLASS_SMIME_V1 | MST_THIS_BLOBSIGN;
    CHECKHR(hr = pmb->SetOption(OID_SECURITY_TYPE, &var));

#ifndef _WIN64
    var.vt = (VT_VECTOR | VT_UI4);
    var.caul.cElems = cSignerCertificates;
    var.caul.pElems = (DWORD *) rgSignerCertificates;
    CHECKHR(hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING_RG, &var));
#else
    var.vt = (VT_VECTOR | VT_UI8);
    var.cauh.cElems = cSignerCertificates;
    var.cauh.pElems = (ULARGE_INTEGER *) rgSignerCertificates;
    CHECKHR(hr = pmb->SetOption(OID_SECURITY_CERT_SIGNING_RG_64, &var));
#endif

    //
    //  Setup the authorized attribute block so that
    //  we can get the correct information transfered.  At present we
    //  are only looking at one item to be included here.
    //  1.  The Message Hash of the message requesting the receipt

    valMsgHash.cbData = cbMsgHash;
    valMsgHash.pbData = pbMsgHash;
    if (!CryptEncodeObjectEx(X509_ASN_ENCODING, X509_OCTET_STRING,
                            &valMsgHash, CRYPT_ENCODE_ALLOC_FLAG,
                            &CryptEncodeAlloc, &pbEncodedMsgHash, &cbEncodedMsgHash))
        goto GeneralFail;

    attrMsgHash.pszObjId = szOID_SMIME_Msg_Sig_Digest;
    attrMsgHash.cValue = 1;
    attrMsgHash.rgValue = &valMsgHash;
    valMsgHash.cbData = cbEncodedMsgHash;
    valMsgHash.pbData = pbEncodedMsgHash;
    CHECKHR(hr = pms->SetAttribute(0, -1, SMIME_ATTRIBUTE_SET_SIGNED, &attrMsgHash));

    hr = S_OK;
    *ppMimeMessageReceipt = pmm;
    pmm->AddRef();

exit:
    SafeMemFree(preq);
    SafeMemFree(receiptsTo.rgNames);
    SafeMemFree(pbEncodedMsgHash);
    SafeMemFree(pbMsgHash);
    SafeMemFree(pbReceipt);
    if (pstm != NULL)           pstm->Release();
    if (pmatbl != NULL)         pmatbl->Release();
    if (pmb != NULL)            pmb->Release();
    if (pms != NULL)            pms->Release();
    if (pmm != NULL)            pmm->Release();
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto exit;
}

//--------------------------------------------------------------------------------
// CMessageBody::GetReceiptSendersList
//--------------------------------------------------------------------------------
HRESULT CMessageBody::GetReceiptSendersList(DWORD dwFlags, DWORD *pcSendersList,
                                            CERT_NAME_BLOB  * *rgSendersList)
{
    DWORD                       cb;
    HRESULT                     hr;
    DWORD                       i;
    LPBYTE                      pb;
    PSMIME_RECEIPT_REQUEST      preq = NULL;

    hr = _GetReceiptRequest(dwFlags,
                            &preq,
                            NULL, NULL, NULL, NULL, NULL);
    if (hr)
        goto exit;

    if (preq->ReceiptsFrom.cNames == 0)
    {
        *rgSendersList = NULL;
        *pcSendersList = preq->ReceiptsFrom.cNames;
        goto exit;
    }

    cb = 0;
    for (i =0; i < preq->ReceiptsFrom.cNames; i++)
#ifdef _WIN64
        cb += sizeof(CERT_NAME_BLOB) + LcbAlignLcb(preq->ReceiptsFrom.rgNames[i].cbData);
#else
        cb += sizeof(CERT_NAME_BLOB) + preq->ReceiptsFrom.rgNames[i].cbData;
#endif // _WIN64
    CHECKHR(hr = HrAlloc((LPVOID *)rgSendersList, cb));
    *pcSendersList = preq->ReceiptsFrom.cNames;
    pb = (LPBYTE)*rgSendersList + (sizeof(CERT_NAME_BLOB) * (*pcSendersList));

    for (i =0; i < preq->ReceiptsFrom.cNames; i++)
    {
        (*rgSendersList)[i].cbData = preq->ReceiptsFrom.rgNames[i].cbData;
        (*rgSendersList)[i].pbData = pb;
        memcpy(pb, preq->ReceiptsFrom.rgNames[i].pbData, preq->ReceiptsFrom.rgNames[i].cbData);
#ifdef _WIN64
        pb += LcbAlignLcb((*rgSendersList)[i].cbData);
#else
        pb += (*rgSendersList)[i].cbData;
#endif // _WIN64
    }

exit:
    SafeMemFree(preq);
    return hr;

}

// --------------------------------------------------------------------------------
// CMessageBody::VerifyReceipt
//
// Assumes the passed in pMimeMessageReceipt has been decoded and
//     it's signature verified.
//
// This function verifies that the values in the Receipt content are
//     identical to those i the original sigendData signerInfo that
//     requested the receipt and that the message hash of the original message
//     is identical to the msgSigDigest sigend Attribute of the receipt
//
// --------------------------------------------------------------------------------
HRESULT CMessageBody::VerifyReceipt(DWORD dwFlags,
                                    IMimeMessage * pMimeMessageReceipt)
{
    PCRYPT_ATTRIBUTE            pattrMsgHash = NULL;
    PCRYPT_ATTRIBUTE            pattrMsgHash2 = NULL;
    DWORD                       cb;
    DWORD                       cbMsgHash = 0;
    DWORD                       cbData;
    HRESULT                     hr;
    DWORD                       iReceiptSigner;
    DWORD                       iSigner;
    LPBYTE                      pb;
    LPBYTE                      pbData = NULL;
    PCRYPT_ATTR_BLOB            pblobMsgHash = NULL;
    IMimeBody *                 pmb = NULL;
    IMimeSecurity2 *            pms = NULL;
    PSMIME_RECEIPT_REQUEST      preq = NULL;
    PSMIME_RECEIPT              pSecReceipt = NULL;
    LPSTREAM                    pstm = NULL;
    STATSTG                     statstg;
    PROPVARIANT                 var;

    // If this is not the bottom layer then ask child to verify receipt
    if (IsContentType(STR_CNT_MULTIPART, "y-security") == S_OK)
    {
        Assert(m_pNode->cChildren == 1);

        hr = m_pNode->pChildHead->pBody->VerifyReceipt(
                                        dwFlags,
                                        pMimeMessageReceipt);
        goto exit;
    }

    CHECKHR(hr = pMimeMessageReceipt->BindToObject(HBODY_ROOT, IID_IMimeBody,
                                            (LPVOID *) &pmb));
    CHECKHR(hr = pmb->QueryInterface(IID_IMimeSecurity2, (LPVOID *) &pms));
    CHECKHR(hr = pmb->GetData(IET_BINARY, &pstm));
    CHECKHR(hr = pstm->Stat(&statstg,STATFLAG_NONAME));

    Assert(statstg.cbSize.HighPart == 0);

    CHECKHR(hr = HrAlloc((LPVOID *)&pbData, statstg.cbSize.LowPart));
    CHECKHR(hr = pstm->Read(pbData, statstg.cbSize.LowPart, &cbData));

    // Check if receipt is the receipt we expect
    for (iSigner=0; iSigner<m_rOptions.cSigners; iSigner++)
    {
        if ((m_rOptions.rgblobReceipt[iSigner].cbSize == cbData) &&
             !memcmp(m_rOptions.rgblobReceipt[iSigner].pBlobData,pbData,cbData))
            break;
    }

    // check if we found a matching receipt
    if (iSigner == m_rOptions.cSigners)
    {
        hr = MIME_E_SECURITY_RECEIPT_NOMATCHINGRECEIPTBODY;
        goto exit;
    }

    if (!CryptDecodeObjectEx(X509_ASN_ENCODING, szOID_SMIME_ContentType_Receipt,
                             pbData,
                             cbData,
                             CRYPT_ENCODE_ALLOC_FLAG, &CryptDecodeAlloc,
                             &pSecReceipt, &cb))
        goto GeneralFail;

    //
    // Get the first signatures MsgSigDigest
    //
    CHECKHR(hr = pms->GetAttribute(0, 0, SMIME_ATTRIBUTE_SET_SIGNED,
                                   0, szOID_SMIME_Msg_Sig_Digest,
                                   &pattrMsgHash));

    if ((hr == S_FALSE) ||
        (!CryptDecodeObjectEx(X509_ASN_ENCODING,
                              X509_OCTET_STRING,
                              pattrMsgHash->rgValue[0].pbData,
                              pattrMsgHash->rgValue[0].cbData,
                              CRYPT_DECODE_ALLOC_FLAG,
                              &CryptDecodeAlloc, &pblobMsgHash, &cbMsgHash)))
    {
        hr = MIME_E_SECURITY_RECEIPT_MSGHASHMISMATCH;
        goto exit;
    }

    if ((m_rOptions.rgblobMsgHash[iSigner].cbSize != pblobMsgHash->cbData) ||
         memcmp(m_rOptions.rgblobMsgHash[iSigner].pBlobData,
                pblobMsgHash->pbData, pblobMsgHash->cbData))
    {
        hr = MIME_E_SECURITY_RECEIPT_MSGHASHMISMATCH;
        goto exit;
    }

    CHECKHR(hr = pmb->GetOption(OID_SECURITY_SIGNATURE_COUNT, &var));
    for (iReceiptSigner = 1; iReceiptSigner < var.ulVal; iReceiptSigner++)
    {
        CHECKHR(hr = pms->GetAttribute(0, iReceiptSigner, SMIME_ATTRIBUTE_SET_SIGNED,
                                       0, szOID_SMIME_Msg_Sig_Digest,
                                       &pattrMsgHash2));

        if ((hr == S_FALSE) ||
            (pattrMsgHash->rgValue[0].cbData != pattrMsgHash2->rgValue[0].cbData) ||
             memcmp(pattrMsgHash->rgValue[0].pbData,
                    pattrMsgHash2->rgValue[0].pbData,
                    pattrMsgHash->rgValue[0].cbData))
        {
            hr = MIME_E_SECURITY_RECEIPT_MSGHASHMISMATCH;
            goto exit;
        }

        SafeMemFree(pattrMsgHash2);
    }

exit:
    SafeMemFree(pblobMsgHash);
    SafeMemFree(pbData);
    SafeMemFree(pSecReceipt);
    SafeMemFree(pattrMsgHash);
    SafeMemFree(pattrMsgHash2);
    if (pstm != NULL)           pstm->Release();
    if (pmb != NULL)            pmb->Release();
    if (pms != NULL)            pms->Release();
    return hr;

GeneralFail:
    hr = E_FAIL;
    goto exit;
}

// --------------------------------------------------------------------------------
// CMessageBody::CapabilitiesSupported
// --------------------------------------------------------------------------------

HRESULT CMessageBody::CapabilitiesSupported(DWORD * pdwFlags)
{
    //  Assume no capabilities
    *pdwFlags = 0;

    //  If we have msasn1.dll on the system, then we can support labels
    if (FIsMsasn1Loaded())  *pdwFlags |= SMIME_SUPPORT_LABELS;

    //  If we have a correct crypt32, then we can support receipts & key agreement

    DemandLoadCrypt32();
    if (g_FSupportV3 && FIsMsasn1Loaded())
        *pdwFlags |= SMIME_SUPPORT_RECEIPTS;

    if (g_FSupportV3)
        *pdwFlags |= SMIME_SUPPORT_KEY_AGREE;

    //  If we have a correct advapi32, then we can support maillist keys
    DemandLoadAdvApi32();
    if (VAR_CryptContextAddRef != MY_CryptContextAddRef)
        *pdwFlags |= SMIME_SUPPORT_MAILLIST;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CMessage::_HrGetAttrs
//
// Utility function to retrieve attributes
// --------------------------------------------------------------------------------

HRESULT CMessageBody::_HrGetAttrs(DWORD cSigners, PCRYPT_ATTRIBUTES * rgpattrs,
                                  LPCSTR pszObjId, PROPVARIANT FAR * pvOut)
{
    // Locals
    CRYPT_ATTRIBUTES    attrs;
    HRESULT             hr = S_OK;
    DWORD               i;
    DWORD               i1;
    CRYPT_ATTRIBUTES UNALIGNED *pattrs;
    CAPROPVARIANT UNALIGNED *pcapropvar;
    PROPVARIANT *ppv = NULL;

    pvOut->vt = VT_VECTOR | VT_VARIANT;
    pcapropvar = &pvOut->capropvar;
    pcapropvar->cElems = cSigners;

    if (cSigners > 0)
    {
        Assert(rgpattrs && pvOut);

        // Allocate the array of VT_BLOB propvariants
        if (FAILED(hr = HrAlloc((LPVOID *)&ppv, cSigners * sizeof(PROPVARIANT))))
        {
            goto exit;
        }
        memset(ppv, 0, cSigners * sizeof(PROPVARIANT));

        pcapropvar->pElems = ppv;

        // Fill in the array of BLOBs
        for (i = 0; i < cSigners; i++)
        {
            ppv[i].vt = VT_BLOB;
            // HrCopyBlob allocates memory for the blob data.
            if (rgpattrs[i] == NULL)
                continue;

            if (pszObjId == NULL)
            {
                pattrs = rgpattrs[i];
            }
            else
            {
                pattrs = NULL;
                for (i1=0; i1<rgpattrs[i]->cAttr; i1++)
                {
                    if (lstrcmp(rgpattrs[i]->rgAttr[i1].pszObjId, pszObjId) == NULL)
                    {
                        pattrs = &attrs;
                        attrs.cAttr = 1;
                        attrs.rgAttr = &rgpattrs[i]->rgAttr[i1];
                        break;
                    }
                }
                if (pattrs == NULL)
                    continue;
            }

            if (!CryptEncodeObjectEx(X509_ASN_ENCODING,
                                     szOID_Microsoft_Attribute_Sequence,
                                     pattrs, CRYPT_ENCODE_ALLOC_FLAG,
                                     &CryptEncodeAlloc, &ppv[i].blob.pBlobData,
                                     &ppv[i].blob.cbSize))
            {
                hr = HrGetLastError();
                goto exit;
            }
        }
    } else {
        pcapropvar->pElems = NULL;
    }

    hr = S_OK;
exit:
    if (FAILED(hr) && (ppv != NULL))
    {
        for (i=0; i<c