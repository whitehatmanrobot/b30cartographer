   bb.pptlBrush = pptlBrush;
    bb.rop4      = rop4;
    bb.pco       = pco;
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        bb.pco = bb.pmdev->pco;

    vIntersect(&bb.pco->rclBounds, prclDst, &bb.rclBounds);
    rclOriginalBounds = bb.pco->rclBounds;

    sizlDst.cx = bb.rclBounds.right - bb.rclBounds.left;
    sizlDst.cy = bb.rclBounds.bottom - bb.rclBounds.top;

    // This really should never happen, but we'll be paranoid:

    if ((sizlDst.cx <= 0) || (sizlDst.cy <= 0))
        return(TRUE);

    // Compute delta from source to destination:

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    // Figure out the size of a board:

    sizlBoard.cx = bb.pmdev->pmbUpperLeft->rcl.right;
    sizlBoard.cy = bb.pmdev->pmbUpperLeft->rcl.bottom;

    // We use temporary bitmaps as intermediaries for copying from one
    // board to another.  Note that it is much more efficient to allocate
    // on the fly, rather than keeping a dedicated bitmap around that
    // would have to be swapped in and out.

    // When the destination is close to the source, we can accomplish
    // most of the blt using screen-to-screen copies, and will need
    // only two small temporary bitmaps to temporarily hold the bits
    // that must be transferred from one board to another:

    if ((abs(dx) < (sizlBoard.cx >> 1)) && (abs(dy) < (sizlBoard.cy >> 1)))
    {
        // Create a temporary bitmap for the horizontal delta only if
        // the blt actually spans boards in the x-direction:

        if ((dx != 0) && (prclUnion->right > pmbUnion->rcl.right))
        {
            sizl.cx = min(sizlDst.cx, abs(dx));
            sizl.cy = min(sizlDst.cy, sizlBoard.cy - abs(dy));

            hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso1 = EngLockSurface(hsurf0);
            if (pso1 == NULL)
                return(FALSE);

            // Can use same temporary bitmap for section '3':

            pso3 = pso1;
        }

        // Similarly for the vertical delta:

        if ((dy != 0) && (prclUnion->bottom > pmbUnion->rcl.bottom))
        {
            sizl.cx = min(sizlDst.cx, sizlBoard.cx - abs(dx));
            sizl.cy = min(sizlDst.cy, abs(dy));

            hsurf1 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                             0, NULL);
            pso2 = EngLockSurface(hsurf1);
            if (pso2 == NULL)
            {
                b = FALSE;
                goto OuttaHere;
            }
        }
    }
    else
    {
        // Make the bitmap the size of a board, or the size of the
        // destination rectangle, which ever is smaller:

        sizl.cx = min(sizlDst.cx, sizlBoard.cx);
        sizl.cy = min(sizlDst.cy, sizlBoard.cy);

        hsurf0 = (HSURF) EngCreateBitmap(sizl, 0, bb.pmdev->iBitmapFormat,
                                         0, NULL);
        pso0 = EngLockSurface(hsurf0);
        if (pso0 == NULL)
            return(FALSE);

        pso1 = pso0;
        pso2 = pso0;
        pso3 = pso0;
    }

    if ((dx <= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the left:

        // Find the board containing the upper-left corner of the destination:

        pmbDst = bb.pmdev->pmbUpperLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left = pmbDst->rcl.left - dx;
        rclStart.top  = pmbDst->rcl.top  - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to left side of next lower row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else if ((dx >= 0) && (dy >= 0))
    {
        // Move the rectangle down and to the right:

        // Find the board containing the lower-right corner of the destination:

        pmbDst = bb.pmdev->pmbLowerRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to go up to right side of next upper row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }
    else if ((dx >= 0) && (dy <= 0))
    {
        // Move the rectangle up and to the right:

        // Find the board containing the upper-right corner of the destination:

        pmbDst = bb.pmdev->pmbUpperRight;
        while (pmbDst->rcl.left >= bb.rclBounds.right)
            pmbDst = pmbDst->pmbLeft;
        while (pmbDst->rcl.bottom <= bb.rclBounds.top)
            pmbDst = pmbDst->pmbDown;

        // Find the upper-right of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.right = pmbDst->rcl.right - dx;
        rclStart.top   = pmbDst->rcl.top   - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.left >= rclStart.right)
            pmbSrc = pmbSrc->pmbLeft;
        while (pmbSrc->rcl.bottom <= rclStart.top)
            pmbSrc = pmbSrc->pmbDown;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbLeft);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbDown);
            if (pmbSrc->pmbDown != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbDown->pmbLeft);

            if (pmbDst->rcl.left > bb.rclBounds.left)
            {
                // Move left in the row of boards:

                pmbDst = pmbDst->pmbLeft;
                pmbSrc = pmbSrc->pmbLeft;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.bottom >= bb.rclBounds.bottom)
                    break;

                // Nope, have to go down to right side of next lower row:

                while (pmbDst->rcl.right < bb.rclBounds.right)
                {
                    pmbDst = pmbDst->pmbRight;
                    pmbSrc = pmbSrc->pmbRight;
                }

                pmbDst = pmbDst->pmbDown;
                pmbSrc = pmbSrc->pmbDown;
            }
        }
    }
    else
    {
        // Move the rectangle down and to the left:

        // Find the board containing the lower-left corner of the destination:

        pmbDst = bb.pmdev->pmbLowerLeft;
        while (pmbDst->rcl.right <= bb.rclBounds.left)
            pmbDst = pmbDst->pmbRight;
        while (pmbDst->rcl.top >= bb.rclBounds.bottom)
            pmbDst = pmbDst->pmbUp;

        // Find the lower-left of the four source boards' rectangles which
        // can potentially overlap our destination board's rectangle:

        rclStart.left   = pmbDst->rcl.left   - dx;
        rclStart.bottom = pmbDst->rcl.bottom - dy;

        pmbSrc = pmbDst;
        while (pmbSrc->rcl.right <= rclStart.left)
            pmbSrc = pmbSrc->pmbRight;
        while (pmbSrc->rcl.top >= rclStart.bottom)
            pmbSrc = pmbSrc->pmbUp;

        while (TRUE)
        {
            b &= bBoardCopy(&bb, pso0, pmbDst, pmbSrc);
            b &= bBoardCopy(&bb, pso1, pmbDst, pmbSrc->pmbRight);
            b &= bBoardCopy(&bb, pso2, pmbDst, pmbSrc->pmbUp);
            if (pmbSrc->pmbUp != NULL)
                b &= bBoardCopy(&bb, pso3, pmbDst, pmbSrc->pmbUp->pmbRight);

            if (pmbDst->rcl.right < bb.rclBounds.right)
            {
                // Move right in the row of boards:

                pmbDst = pmbDst->pmbRight;
                pmbSrc = pmbSrc->pmbRight;
            }
            else
            {
                // We may be all done:

                if (pmbDst->rcl.top <= bb.rclBounds.top)
                    break;

                // Nope, have to up down to left side of next upper row:

                while (pmbDst->rcl.left > bb.rclBounds.left)
                {
                    pmbDst = pmbDst->pmbLeft;
                    pmbSrc = pmbSrc->pmbLeft;
                }

                pmbDst = pmbDst->pmbUp;
                pmbSrc = pmbSrc->pmbUp;
            }
        }
    }

    bb.pco->rclBounds = rclOriginalBounds;

OuttaHere:

    // In one case, pso0 == pso1 == pso2 == pso3, and we don't want to
    // unlock the same surface twice:

    if (pso1 != pso2)
        EngUnlockSurface(pso1);

    EngUnlockSurface(pso2);
    EngDeleteSurface(hsurf0);
    EngDeleteSurface(hsurf1);

    return(b);
}

/******************************Public*Routine******************************\
* ULONG MulGetModes
*
\**************************************************************************/

ULONG MulGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG ulRet;

    ulRet = DrvGetModes(hDriver, cjSize, pdm);

    return(ulRet);
}

/******************************Public*Routine******************************\
* BOOL bQueryMultiBoards
*
* Performs the minimal initialization required to ask the miniport
* if we'll be supporting multiple boards.
*
\**************************************************************************/

BOOL bQueryMultiBoards(
HANDLE      hDriver,            // Input
DEVMODEW*   pdm,                // Input and Output -- updates some fields
SIZEL*      pszlBoardArray,     // Output
SIZEL*      pszlScreen,         // Output
ULONG*      pulMode)            // Output
{
    VIDEO_MODE_INFORMATION  VideoModeInformation;
    ULONG                   ulBoardId;
    ULONG                   ReturnedDataLength;
    SIZEL                   szlBoardArray;
    MULTI_BOARD*            pmb;
    DWORD                   cModes;
    PVIDEO_MODE_INFORMATION pVideoBuffer;
    PVIDEO_MODE_INFORMATION pVideoTemp;
    DWORD                   cbModeSize;

    // Figure out the requested virtual desktop size:

    if (!bSelectMode(hDriver,
                     pdm,
                     &VideoModeInformation,
                     &ulBoardId))
    {
        DISPDBG((0, "bQueryMultiBoards -- Failed bSelectMode"));
        goto ReturnFailure0;
    }

    *pulMode = VideoModeInformation.ModeIndex;

    // Call the miniport via a public IOCTL to set the graphics mode.
    // The MGA miniport requires that we do this before calling
    // MTX_QUERY_BOARD_ARRAY:

    if (EngDeviceIoControl(hDriver,
                         IOCTL_VIDEO_SET_CURRENT_MODE,
                         &VideoModeInformation.ModeIndex,   // Input
                         sizeof(DWORD),
                         NULL,                              // Output
                         0,
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bQueryMultiBoards - Failed VIDEO_SET_CURRENT_MODE"));
        goto ReturnFailure0;
    }

    // Now that we've set the mode, we can query the MGA miniport
    // via a private IOCTL to find out how many boards there will be.

    if (EngDeviceIoControl(hDriver,
                         IOCTL_VIDEO_MTX_QUERY_BOARD_ARRAY,
                         NULL,                              // Input
                         0,
                         pszlBoardArray,                    // Output
                         sizeof(SIZEL),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bQueryMultiBoards -- Failed MTX_QUERY_BOARD_ARRAY"));
        goto ReturnFailure0;
    }

    // Convert the devmode so that it is no longer a request for
    // the entire virtual desktop dimension, but is now a request
    // for the resolution of each board:

    pdm->dmPelsWidth /= pszlBoardArray->cx;
    pdm->dmPelsHeight /= pszlBoardArray->cy;

    // Remember some stuff about the mode:

    pszlScreen->cx = VideoModeInformation.VisScreenWidth / pszlBoardArray->cx;
    pszlScreen->cy = VideoModeInformation.VisScreenHeight / pszlBoardArray->cy;

    DISPDBG((1, "Board array: %li x %li",
             pszlBoardArray->cx, pszlBoardArray->cy));

    return(TRUE);

ReturnFailure0:

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL bInitializeGeometry
*
* Initializes all our multi-board data structures describing the
* geometry of the multiple board configuration.
*
\**************************************************************************/

BOOL bInitializeGeometry(
MDEV*   pmdev,
LONG    cxBoards,
LONG    cyBoards,
LONG    cxScreen,
LONG    cyScreen)
{
    LONG            cBoards;
    LONG            i;
    LONG            x;
    LONG            y;
    MULTI_BOARD*    apmb;
    MULTI_BOARD*    pmb;

    // Create all of our multi-board structures:

    cBoards = cxBoards * cyBoards;

    pmdev->cBoards  = cBoards;
    pmdev->cxBoards = cxBoards;
    pmdev->cyBoards = cyBoards;

    // Allocate and initialize the linked list of structures for every
    // board:

    apmb = EngAllocMem(FL_ZERO_MEMORY, cBoards * sizeof(MULTI_BOARD), ALLOC_TAG);
    if (apmb == NULL)
    {
        DISPDBG((0, "bInitializeGeometry -- Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    for (pmb = apmb + 1, i = 1; i < cBoards; pmb++, i++)
    {
        // The first board's 'iBoard' is already set to zero...

        (pmb)->iBoard = i;
        (pmb - 1)->pmbNext = pmb;
    }

    pmdev->pmb           = apmb;
    pmdev->pmbUpperLeft  = &apmb[0];
    pmdev->pmbUpperRight = &apmb[cxBoards - 1];
    pmdev->pmbLowerLeft  = &apmb[cBoards - cxBoards];
    pmdev->pmbLowerRight = &apmb[cBoards - 1];

    // Now set the neighbor pointers.  If there is no neighbor for
    // a board, the neighbor pointer must be set to NULL (note that
    // we rely on the zero initialization to take care of this):

    i = 0;

    for (x = 1; x <= cxBoards; x++)
    {
        for (y = 1; y <= cyBoards; y++)
        {
            if (x > 1)
                apmb[i].pmbLeft  = &apmb[i - 1];
            if (y > 1)
                apmb[i].pmbUp    = &apmb[i - cxBoards];
            if (x < cxBoards)
                apmb[i].pmbRight = &apmb[i + 1];
            if (y < cyBoards)
                apmb[i].pmbDown  = &apmb[i + cxBoards];

            apmb[i].rcl.right  = x * cxScreen;
            apmb[i].rcl.left   = x * cxScreen - cxScreen;
            apmb[i].rcl.bottom = y * cyScreen;
            apmb[i].rcl.top    = y * cyScreen - cyScreen;

            i++;
        }
    }

    return(TRUE);

ReturnFailure0:

    DISPDBG((0, "Failed bInitializeGeometry"));

    return(FALSE);
}

/******************************Public*Routine******************************\
* DHPDEV MulEnablePDEV
*
\**************************************************************************/

DHPDEV MulEnablePDEV(
DEVMODEW*   pdm,            // Contains data pertaining to requested mode
PWSTR       pwszLogAddr,    // Logical address
ULONG       cPat,           // Count of standard patterns
HSURF*      phsurfPatterns, // Buffer for standard patterns
ULONG       cjCaps,         // Size of buffer for device caps 'pdevcaps'
ULONG*      pdevcaps,       // Buffer for device caps, also known as 'gdiinfo'
ULONG       cjDevInfo,      // Number of bytes in device info 'pdi'
DEVINFO*    pdi,            // Device information
HDEV        hdev,           // HDEV, used for callbacks
PWSTR       pwszDeviceName, // Device name
HANDLE      hDriver)        // Kernel driver handle
{
    MDEV*        pmdev;                 // Multi-board PDEV
    PDEV*        ppdev;                 // Per-board PDEV
    MULTI_BOARD* pmb;
    DEVMODEW     dm;                    // Local copy of requested devmode
    SIZEL        szlBoardArray;         // Configuration of boards
    SIZEL        szlScreen;             // Resolution of each screen
    ULONG        ulMode;

    // Future versions of NT had better supply 'devcaps' and 'devinfo'
    // structures that are the same size or larger than the current
    // structures:

    if ((cjCaps < sizeof(GDIINFO)) || (cjDevInfo < sizeof(DEVINFO)))
    {
        DISPDBG((0, "MulEnablePDEV -- Buffer size too small"));
        goto ReturnFailure0;
    }

    // Make a local copy of the DEVMODE that we can modify.  We need
    // to do this because it will, for example, contain a request
    // for 2048x768, and we want to convert it to 1024x768:

    dm = *pdm;

    if (!bQueryMultiBoards(hDriver,
                           &dm,
                           &szlBoardArray,
                           &szlScreen,
                           &ulMode))
    {
        DISPDBG((0, "MulEnablePDEV -- Failed bQueryMultiBoards"));
        goto ReturnFailure0;
    }

    // Note that we depend on the zero initialization:

    pmdev = (MDEV*) EngAllocMem(FL_ZERO_MEMORY, sizeof(MDEV), ALLOC_TAG);
    if (pmdev == NULL)
    {
        DISPDBG((0, "MulEnablePDEV -- Failed EngAllocMem"));
        goto ReturnFailure0;
    }

    // Remember some stuff:

    pmdev->hDriver = hDriver;
    pmdev->ulMode  = ulMode;

    if (!bInitializeGeometry(pmdev,
                             szlBoardArray.cx,
                             szlBoardArray.cy,
                             szlScreen.cx,
                             szlScreen.cy))
    {
        DISPDBG((0, "MulEnablePDEV -- Failed bInitializeGeometry"));
        goto ReturnFailure1;
    }

    // For every board, we'll create our own PDEV.

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // Initialize each board and create a surface to go with it:

        MAKE_BOARD_CURRENT(pmdev, pmb);

        ppdev = (PDEV*) DrvEnablePDEV(&dm,          pwszLogAddr,
                                      cPat,         phsurfPatterns,
                                      cjCaps,       pdevcaps,
                                      cjDevInfo,    pdi,
                                      hdev,         pwszDeviceName,
                                      hDriver);
        if (ppdev == NULL)
            goto ReturnFailure1;

        pmb->ppdev = ppdev;

        // The PDEV sometimes needs to know its board number, and some
        // other stuff:

        ppdev->iBoard = pmb->iBoard;
        ppdev->ulMode = pmdev->ulMode;
    }

    // Get a copy of what functions we're supposed to hook, sans
    // HOOK_STRETCHBLT because I can't be bothered to write its
    // MulStretchBlt function.  First, choose a board, any board:

    pmb = pmdev->pmbLowerLeft;

    pmdev->flHooks       = pmb->ppdev->flHooks & ~HOOK_STRETCHBLT;
    pmdev->iBitmapFormat = pmb->ppdev->iBitmapFormat;

    // Adjust the stuff we return back to GDI.
    //
    // NOTE: By Setting 'DesktopHorzRes' and 'DesktopVertRes' to the
    //       size of the virtual desktop, but keeping 'HorzRes' and
    //       'VertRes' as the size of the individual screens, we
    //       get dialogs centered on the one primary screen, but
    //       windows can be dragged to any screen.

    // ((GDIINFO*) pdevcaps)->ulDesktopHorzRes  *= pmdev->cxBoards;
    // ((GDIINFO*) pdevcaps)->ulDesktopVertRes  *= pmdev->cyBoards;
    // ((GDIINFO*) pdevcaps)->ulHorzSize        *= pmdev->cxBoards;
    // ((GDIINFO*) pdevcaps)->ulVertSize        *= pmdev->cyBoards;

    return((DHPDEV) pmdev);

ReturnFailure1:
    MulDisablePDEV((DHPDEV) pmdev);

ReturnFailure0:
    DISPDBG((0, "Failed MulEnablePDEV"));

    return(0);
}

/******************************Public*Routine******************************\
* VOID MulCompletePDEV
*
\**************************************************************************/

VOID MulCompletePDEV(
DHPDEV dhpdev,
HDEV   hdev)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;
    pmdev->hdev = hdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        DrvCompletePDEV((DHPDEV) pmb->ppdev, hdev);
    }
}

/******************************Public*Routine******************************\
* HSURF MulEnableSurface
*
\**************************************************************************/

HSURF MulEnableSurface(DHPDEV dhpdev)
{
    MDEV*         pmdev;
    FLONG         flStatus;
    MULTI_BOARD*  pmb;
    SIZEL         sizlVirtual;
    HSURF         hsurfBoard;               // Gnarly, dude!
    SURFOBJ*      psoBoard;
    DSURF*        pdsurfBoard;
    HSURF         hsurfVirtual;
    CLIPOBJ*      pco;

    pmdev = (MDEV*) dhpdev;

    flStatus = (FLONG) -1;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        MAKE_BOARD_CURRENT(pmdev, pmb);

        hsurfBoard = DrvEnableSurface((DHPDEV) pmb->ppdev);
        if (hsurfBoard == 0)
            goto ReturnFailure;

        pmb->hsurf = hsurfBoard;

        // Every time we draw on a particular board, we'll refer to it
        // using this surface:

        psoBoard = EngLockSurface(hsurfBoard);
        if (psoBoard == NULL)
            goto ReturnFailure;

        pmb->pso = psoBoard;

        // There are a few things in the board's data instances that we
        // have to modify:

        pdsurfBoard = (DSURF*) psoBoard->dhsurf;

        // This is how we change 'xOffset' and 'yOffset' for each
        // individual board 'pdev':

        pdsurfBoard->poh->x = -pmb->rcl.left;
        pdsurfBoard->poh->y = -pmb->rcl.top;

        // This is sort of sleazy.  Whenever we pass a call on to a board's
        // Drv function using 'pmb->pso', it has to be able to retrieve
        // its own PDEV pointer from 'dhpdev':

        pmb->pso->dhpdev = (DHPDEV) pmb->ppdev;

        // Accumulate all the flags:

        flStatus &= pmb->ppdev->flStatus;
    }

    // We may encounter a rare situation where one of the boards does
    // not have enough memory for the allocation of a brush cache in
    // off-screen memory.  The current method of handling this situation
    // is to look at 'ppdev->flStatus' in DrvRealizeBrush, and fail it
    // if no brush cache has been allocated.  With multiple boards,
    // that has to be converted to a check to see if brush caches have
    // been allocated for all boards.  We accomplish this by turning off
    // the brush cache flag for every 'pdev'.
    //
    // (We could add extra logic to our pattern routines to handle some
    // boards having a brush cache, and some not, but it's not worth
    // slowing down the common case.)

    if (!(flStatus & STAT_BRUSH_CACHE))
    {
        for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
        {
            pmb->ppdev->flStatus &= ~STAT_BRUSH_CACHE;
        }
    }

    // Now create the surface which the engine will use to refer to our
    // entire multi-board virtual screen:

    sizlVirtual.cx = pmdev->pmbLowerRight->rcl.right;
    sizlVirtual.cy = pmdev->pmbLowerRight->rcl.bottom;

    hsurfVirtual = EngCreateDeviceSurface((DHSURF) pmdev, sizlVirtual,
                                          pmdev->iBitmapFormat);
    if (hsurfVirtual == 0)
        goto ReturnFailure;

    pmdev->hsurf = hsurfVirtual;

    if (!EngAssociateSurface(hsurfVirtual, pmdev->hdev, pmdev->flHooks))
        goto ReturnFailure;

    // Create a temporary clip object that we can use when a drawing
    // operation spans multiple boards:

    pco = EngCreateClip();
    if (pco == NULL)
        goto ReturnFailure;

    pmdev->pco = pco;

    pmdev->pco->iDComplexity      = DC_RECT;
    pmdev->pco->iMode             = TC_RECTANGLES;
    pmdev->pco->rclBounds.left    = 0;
    pmdev->pco->rclBounds.top     = 0;
    pmdev->pco->rclBounds.right   = pmdev->pmbLowerRight->rcl.right;
    pmdev->pco->rclBounds.bottom  = pmdev->pmbLowerRight->rcl.bottom;

    return(hsurfVirtual);

ReturnFailure:
    MulDisableSurface((DHPDEV) pmdev);

    DISPDBG((0, "Failed MulEnableSurface"));

    return(0);
}

/******************************Public*Routine******************************\
* BOOL MulStrokePath
*
\**************************************************************************/

BOOL MulStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;
    FLOAT_LONG   elStyleState;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;
        elStyleState = pla->elStyleState;

        b = TRUE;
        do {
            // For each board, make sure the style state gets reset and
            // the path enumeration gets restarted:

            pla->elStyleState = elStyleState;
            PATHOBJ_vEnumStart(ppo);

            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvStrokePath(pmb->pso, ppo, pco, pxo, pbo, pptlBrush, pla,
                                   mix);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL MulFillPath
*
\**************************************************************************/

BOOL MulFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    RECTFX       rcfxBounds;
    RECTL        rclBounds;
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    // Get the path bounds and make it lower-right exclusive:

    PATHOBJ_vGetBounds(ppo, &rcfxBounds);

    rclBounds.left   = (rcfxBounds.xLeft   >> 4);
    rclBounds.top    = (rcfxBounds.yTop    >> 4);
    rclBounds.right  = (rcfxBounds.xRight  >> 4) + 2;
    rclBounds.bottom = (rcfxBounds.yBottom >> 4) + 2;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }
    else
    {
        if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
        {
            // If the CLIPOBJ doesn't have at least DC_RECT complexity,
            // substitute one that does:

            pco = pmdev->pco;
        }

        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            // Make sure we restart the path enumeration if need be:

            PATHOBJ_vEnumStart(ppo);
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvFillPath(pmb->pso, ppo, pco, pbo, pptlBrush, mix,
                                 flOptions);
            }

        } while (bNextBoard(&rclBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL MulBitBlt
*
\**************************************************************************/

BOOL MulBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    LONG         xOffset;
    LONG         yOffset;
    RECTL        rclDstBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, psoMask, pco, pxlo,
                                        &rclDst, pptlSrc, pptlMask, pbo,
                                        pptlBrush, rop4, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(pmb->pso, psoSrc, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoSrc->dhpdev;

        // rclBounds is the source rectangle:

        rclBounds.left   = pptlSrc->x;
        rclBounds.top    = pptlSrc->y;
        rclBounds.right  = pptlSrc->x + (rclDst.right - rclDst.left);
        rclBounds.bottom = pptlSrc->y + (rclDst.bottom - rclDst.top);

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                          pptlSrc, pptlMask, pbo, pptlBrush, rop4);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            // Offset to transform from source rectangle to destination
            // rectangle:

            xOffset = rclDst.left - pptlSrc->x;
            yOffset = rclDst.top  - pptlSrc->y;

            b = TRUE;
            do {
                // Since the screen is the source, but the clip bounds applies
                // to the destination, we have to convert our board clipping
                // information to destination coordinates:

                rclDstBounds.left   = pmb->rcl.left   + xOffset;
                rclDstBounds.right  = pmb->rcl.right  + xOffset;
                rclDstBounds.top    = pmb->rcl.top    + yOffset;
                rclDstBounds.bottom = pmb->rcl.bottom + yOffset;

                if (bIntersect(&rclOriginalBounds, &rclDstBounds, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvBitBlt(psoDst, pmb->pso, psoMask, pco, pxlo, &rclDst,
                                   pptlSrc, pptlMask, pbo, pptlBrush, rop4);
                }

            } while (bNextBoard(&rclBounds, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }

    return(b);
}

/******************************Public*Routine******************************\
* VOID MulDisablePDEV
*
* Note: May be called before MulEnablePDEV successfully completed!
*
\**************************************************************************/

VOID MulDisablePDEV(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        if (pmb->ppdev != NULL)
        {
            GO_BOARD(pmdev, pmb);
            DrvDisablePDEV((DHPDEV) pmb->ppdev);
        }
    }

    EngFreeMem(pmdev->pmb);      // Undo 'bInitializeGeometry' allocation

    EngFreeMem(pmdev);
}

/******************************Public*Routine******************************\
* VOID MulDisableSurface
*
* Note: May be called before MulEnableSurface successfully completed!
*
\**************************************************************************/

VOID MulDisableSurface(DHPDEV dhpdev)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;

    pmdev = (MDEV*) dhpdev;

    if (pmdev->pco != NULL)
        EngDeleteClip(pmdev->pco);

    EngDeleteSurface(pmdev->hsurf);

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        EngUnlockSurface(pmb->pso);

        DrvDisableSurface((DHPDEV) pmb->ppdev);
    }
}

/******************************Public*Routine******************************\
* VOID MulAssertMode
*
\**************************************************************************/

BOOL MulAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    MDEV*         pmdev;
    MULTI_BOARD*  pmb;

    pmdev = (MDEV*) dhpdev;

    if (!bEnable)
    {
        // When switching to full-screen mode, PatBlt blackness over
        // all the inactive screens (otherwise it looks goofy when
        // the desktop is frozen on the inactive screens and the user
        // can't do anything with it):

        for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
        {
            GO_BOARD(pmdev, pmb);
            DrvBitBlt(pmb->pso, NULL, NULL, NULL, NULL, &pmb->rcl, NULL,
                      NULL, NULL, NULL, 0);
        }
    }

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);
        DrvAssertMode((DHPDEV) pmb->ppdev, bEnable);
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* VOID MulMovePointer
*
\**************************************************************************/

VOID MulMovePointer(
SURFOBJ* pso,
LONG     x,
LONG     y,
RECTL*   prcl)
{
    MDEV*        pmdev;
    MULTI_BOARD* pmbPointer;
    RECTL        rclPointer;

    pmdev     = (MDEV*) pso->dhpdev;
    pmbPointer = pmdev->pmbPointer;

    if (pmbPointer != NULL)
    {
        // The most common case is when the pointer is moved to a spot
        // on the same board:

        if ((x >= pmbPointer->rcl.left)  &&
            (x <  pmbPointer->rcl.right) &&
            (y >= pmbPointer->rcl.top)   &&
            (y <  pmbPointer->rcl.bottom))
        {
            GO_BOARD(pmdev, pmbPointer);
            DrvMovePointer(pmbPointer->pso, x, y, prcl);

            return;
        }

        // Tell the old board to erase its cursor:

        GO_BOARD(pmdev, pmbPointer);
        DrvMovePointer(pmbPointer->pso, -1, -1, NULL);
    }

    if (x == -1)
    {
        pmdev->pmbPointer = NULL;

        return;
    }

    // Find the new board and tell it to draw its new cursor:

    rclPointer.left   = x;
    rclPointer.right  = x;
    rclPointer.top    = y;
    rclPointer.bottom = y;

    bFindBoard(pmdev, &rclPointer, &pmbPointer);

    GO_BOARD(pmdev, pmbPointer);
    DrvMovePointer(pmbPointer->pso, x, y, prcl);

    pmdev->pmbPointer = pmbPointer;
}

/******************************Public*Routine******************************\
* ULONG MulSetPointerShape
*
\**************************************************************************/

ULONG MulSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    ULONG        ulRet;
    RECTL        rclPointer;
    MULTI_BOARD* pmbPointer;             // Board on which cursor is visible
    BOOL         b;

    pmdev = (MDEV*) pso->dhpdev;

    // Find out which board that the cursor is visible on, if any:

    pmbPointer = NULL;
    if (x != -1)
    {
        rclPointer.left   = x;
        rclPointer.right  = x;
        rclPointer.top    = y;
        rclPointer.bottom = y;

        b = bFindBoard(pmdev, &rclPointer, &pmbPointer);

        ASSERTDD(b, "Woah, couldn't find what board the pointer was on?");
    }

    pmdev->pmbPointer = pmbPointer;

    ulRet = SPS_ACCEPT_NOEXCLUDE;

    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        // Send the new shape down to every board, and at the same
        // time check to see if each board will support the pointer by
        // creating it as hidden on every one.

        GO_BOARD(pmdev, pmb);

        if (DrvSetPointerShape(pmb->pso, psoMask, psoColor, pxlo,
                               xHot, yHot, -1, y, NULL, fl)
                               != SPS_ACCEPT_NOEXCLUDE)
        {
            // Oh no, one of the boards won't support this pointer.  We'll
            // have to ask GDI to simulate for all boards:

            ulRet = SPS_DECLINE;
        }
    }

    if ((ulRet == SPS_ACCEPT_NOEXCLUDE) && (pmbPointer != NULL))
    {
        // All boards accepted the hardware pointer, so show it on the
        // appropriate board.  If 'pmbPointer' is NULL, we're not being
        // asked to show the pointer at all.

        GO_BOARD(pmdev, pmbPointer);

        DrvMovePointer(pmbPointer->pso, x, y, NULL);
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* ULONG MulDitherColor
*
\**************************************************************************/

ULONG MulDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    PDEV* ppdev;
    ULONG ulRet;

    // Let the first board's driver do the dithering:

    ppdev = ((MDEV*) dhpdev)->pmb->ppdev;
    ulRet = DrvDitherColor((DHPDEV) ppdev, iMode, rgb, pul);

    return(ulRet);
}

/******************************Public*Routine******************************\
* ULONG MulSetPalette
*
\**************************************************************************/

BOOL MulSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    MULTI_BOARD* pmb;
    MDEV*        pmdev;
    BOOL         bRet = TRUE;

    // Notify all boards of the palette change:

    pmdev = (MDEV*) dhpdev;
    for (pmb = pmdev->pmb; pmb != NULL; pmb = pmb->pmbNext)
    {
        GO_BOARD(pmdev, pmb);

        MAKE_BOARD_CURRENT(pmdev, pmb);

        bRet &= DrvSetPalette((DHPDEV) pmb->ppdev, ppalo, fl, iStart, cColors);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL MulCopyBits
*
\**************************************************************************/

BOOL MulCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL         bFromScreen;
    BOOL         bToScreen;
    MDEV*        pmdev;
    MULTI_BOARD* pmb;
    RECTL        rclOriginalBounds;
    BOOL         b;
    RECTL        rclBounds;
    RECTL        rclDst;

    bFromScreen = ((psoSrc != NULL) && (psoSrc->iType == STYPE_DEVICE));
    bToScreen   = ((psoDst != NULL) && (psoDst->iType == STYPE_DEVICE));

    // We copy the prclDst rectangle here because sometimes GDI will
    // simply point prclDst to the same rectangle in pco->rclBounds,
    // and we'll be mucking with pco->rclBounds...

    rclDst = *prclDst;

    if (bToScreen && bFromScreen)
    {
        ///////////////////////////////////////////////////////////////
        // Screen-to-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;

        // rclBounds is the union of the source and destination rectangles:

        rclBounds.left   = min(rclDst.left, pptlSrc->x);
        rclBounds.top    = min(rclDst.top,  pptlSrc->y);
        rclBounds.right  = max(rclDst.right,
                               pptlSrc->x + (rclDst.right - rclDst.left));
        rclBounds.bottom = max(rclDst.bottom,
                               pptlSrc->y + (rclDst.bottom - rclDst.top));

        if (bFindBoard(pmdev, &rclBounds, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, pmb->pso, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            return(bBitBltBetweenBoards(psoDst, psoSrc, NULL, pco, pxlo,
                                        &rclDst, pptlSrc, NULL, NULL,
                                        NULL, 0x0000cccc, &rclBounds, pmb));
        }
    }
    else if (bToScreen)
    {
        ///////////////////////////////////////////////////////////////
        // To-screen
        ///////////////////////////////////////////////////////////////

        pmdev = (MDEV*) psoDst->dhpdev;
        if (bFindBoard(pmdev, &rclDst, &pmb))
        {
            GO_BOARD(pmdev, pmb);
            b = DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst, pptlSrc);
        }
        else
        {
            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                // If the CLIPOBJ doesn't have at least DC_RECT complexity,
                // substitute one that does:

                pco = pmdev->pco;
            }

            rclOriginalBounds = pco->rclBounds;

            b = TRUE;
            do {
                if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
                {
                    GO_BOARD(pmdev, pmb);
                    b &= DrvCopyBits(pmb->pso, psoSrc, pco, pxlo, &rclDst,
                                     pptlSrc);
                }

            } while (bNextBoard(&rclDst, &pmb));

            // Restore the original clip bounds:

            pco->rclBounds = rclOriginalBounds;
        }
    }
    else
    {
        ///////////////////////////////////////////////////////////////
        // From-screen
        ///////////////////////////////////////////////////////////////

        // This rarely happens, so save some code space:

        return(MulBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst,
                              pptlSrc, NULL, NULL, NULL, 0x0000cccc));
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL MulTextOut
*
\**************************************************************************/

BOOL MulTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    MDEV*          pmdev;
    MULTI_BOARD*   pmb;
    RECTL          rclOriginalBounds;
    BYTE           fjOriginalOptions;
    BOOL           b;
    RECTL*         prclBounds;
    FONT_CONSUMER* pfcArray;

    pmdev = (MDEV*) pso->dhpdev;

    // In keeping with our philosophy for multiple board support, we handle
    // multiple consumers of the same font at this level.  We do this by
    // monitoring pfo->pvConsumer, and the first time a board sets the
    // field, we take control of pfo->pvConsumer.  We use it to allocate
    // a pvConsumer array where we can keep track of every board's
    // individual pvConsumer.

    pfcArray = pfo->pvConsumer;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    bFindBoard(pmdev, prclBounds, &pmb);

    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        // If the CLIPOBJ doesn't have at least DC_RECT complexity,
        // substitute one that does:

        pco = pmdev->pco;
    }

    rclOriginalBounds = pco->rclBounds;
    fjOriginalOptions = pco->fjOptions;

    // OR in the OC_BANK_CLIP flag to let GDI know that we may be calling
    // EngTextOut multiple times with the same parameters (EngTextOut
    // is destructive in that it modifies that parameters passed to it,
    // unless this bit is set):

    pco->fjOptions |= OC_BANK_CLIP;

    b = TRUE;
    do {
        if (pfcArray != NULL)
            pfo->pvConsumer = pfcArray->apvc[pmb->iBoard].pvConsumer;

        // Make sure we restart the glyph enumeration if need be:

        STROBJ_vEnumStart(pstro);
        if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
        {
            GO_BOARD(pmdev, pmb);
            b &= DrvTextOut(pmb->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                            pboFore, pboOpaque, pptlOrg, mix);
        }

        if (pfcArray != NULL)
        {
            // Copy the pvConsumer, in case the last DrvTextOut changed
            // it:

            pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;
        }
        else
        {
            if (pfo->pvConsumer != NULL)
            {
                // The board allocated a new consumer, so create our array
                // to keep track of consumers for every board:

                pfcArray = (FONT_CONSUMER*) EngAllocMem(FL_ZERO_MEMORY,
                             sizeof(FONT_CONSUMER), ALLOC_TAG);
                if (pfcArray == NULL)
                    DrvDestroyFont(pfo);
                else
                {
                    pfcArray->cConsumers = pmdev->cBoards;
                    pfcArray->apvc[pmb->iBoard].pvConsumer = pfo->pvConsumer;

                }
            }
        }
    } while (bNextBoard(prclBounds, &pmb));

    // Restore the original clip bounds:

    pco->rclBounds = rclOriginalBounds;
    pco->fjOptions = fjOriginalOptions;

    // Make sure we restore/set the font's pvConsumer:

    pfo->pvConsumer = pfcArray;

    return(b);
}

/******************************Public*Routine******************************\
* VOID MulDestroyFont
*
\**************************************************************************/

VOID MulDestroyFont(FONTOBJ *pfo)
{
    FONT_CONSUMER* pfcArray;
    LONG           i;
    PVOID          pvConsumer;

    if (pfo->pvConsumer != NULL)
    {
        pfcArray = pfo->pvConsumer;
        for (i = 0; i < pfcArray->cConsumers; i++)
        {
            pvConsumer = pfcArray->apvc[i].pvConsumer;
            if (pvConsumer != NULL)
            {
                pfo->pvConsumer = pvConsumer;
                DrvDestroyFont(pfo);
            }
        }

        EngFreeMem(pfcArray);
        pfo->pvConsumer = NULL;
    }

}

/******************************Public*Routine******************************\
* BOOL MulPaint
*
\**************************************************************************/

BOOL MulPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix)
{
    MDEV*        pmdev;
    RECTL        rclOriginalBounds;
    MULTI_BOARD* pmb;
    BOOL         b;

    pmdev = (MDEV*) pso->dhpdev;
    if (bFindBoard(pmdev, &pco->rclBounds, &pmb))
    {
        GO_BOARD(pmdev, pmb);
        b = DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
    }
    else
    {
        rclOriginalBounds = pco->rclBounds;

        b = TRUE;
        do {
            if (bIntersect(&rclOriginalBounds, &pmb->rcl, &pco->rclBounds))
            {
                GO_BOARD(pmdev, pmb);
                b &= DrvPaint(pmb->pso, pco, pbo, pptlBrush, mix);
            }

        } while (bNextBoard(&rclOriginalBounds, &pmb));

        // Restore the original clip bounds:

        pco->rclBounds = rclOriginalBounds;
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL MulRealizeBrush
*
\**************************************************************************/

BOOL MulRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    MDEV*        pmdev;
    BOOL         b;

    pmdev = (MDEV*) psoTarget->dhpdev;

    // DrvRealizeBrush is only ever called from within a Drv function.
    // 'psoTarget' points to our multi-board surface, but we have to point
    // it to the surface of the board for which the DrvBitBlt call was made.

    b = DrvRealizeBrush(pbo, pmdev->pmbCurrent->pso, psoPattern, psoMask,
                        pxlo, iHatch);

    return(b);
}

#endif // MULTI_BOARDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\palette.c ===
/******************************Module*Header*******************************\
* Module Name: palette.c
*
* Palette support.
*
* Copyright (c) 1992-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

// Global Table defining the 20 Window default colours.  For 256 colour
// palettes the first 10 must be put at the beginning of the palette
// and the last 10 at the end of the palette.

PALETTEENTRY gapalBase[20] =
{
    { 0,   0,   0,   0 },       // 0
    { 0x80,0,   0,   0 },       // 1
    { 0,   0x80,0,   0 },       // 2
    { 0x80,0x80,0,   0 },       // 3
    { 0,   0,   0x80,0 },       // 4
    { 0x80,0,   0x80,0 },       // 5
    { 0,   0x80,0x80,0 },       // 6
    { 0xC0,0xC0,0xC0,0 },       // 7
    { 192, 220, 192, 0 },       // 8
    { 166, 202, 240, 0 },       // 9
    { 255, 251, 240, 0 },       // 10
    { 160, 160, 164, 0 },       // 11
    { 0x80,0x80,0x80,0 },       // 12
    { 0xFF,0,   0   ,0 },       // 13
    { 0,   0xFF,0   ,0 },       // 14
    { 0xFF,0xFF,0   ,0 },       // 15
    { 0   ,0,   0xFF,0 },       // 16
    { 0xFF,0,   0xFF,0 },       // 17
    { 0,   0xFF,0xFF,0 },       // 18
    { 0xFF,0xFF,0xFF,0 },       // 19
};

/******************************Public*Routine******************************\
* BOOL bInitializePalette
*
* Initializes default palette for PDEV.
*
\**************************************************************************/

BOOL bInitializePalette(
PDEV*    ppdev,
DEVINFO* pdi)
{
    PALETTEENTRY*   ppal;
    PALETTEENTRY*   ppalTmp;
    ULONG           ulLoop;
    BYTE            jRed;
    BYTE            jGre;
    BYTE            jBlu;
    HPALETTE        hpal;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Allocate our palette:

        ppal = (PALETTEENTRY*)EngAllocMem(FL_ZERO_MEMORY,
                        (sizeof(PALETTEENTRY) * 256), ALLOC_TAG);
        if (ppal == NULL)
            goto ReturnFalse;

        ppdev->pPal = ppal;

        // Generate 256 (8*8*4) RGB combinations to fill the palette.
        // This is initializing a 3-3-2 palette.

        jRed = 0;
        jGre = 0;
        jBlu = 0;

        ppalTmp = ppal;

        for (ulLoop = 256; ulLoop != 0; ulLoop--)
        {
            ppalTmp->peRed   = (jRed) | (jRed >> 3) | (jRed >> 6);
            ppalTmp->peGreen = (jGre) | (jGre >> 3) | (jGre >> 6);
            ppalTmp->peBlue  = (jBlu) | (jBlu >> 2) | (jBlu >> 4) | (jBlu >> 6);
            ppalTmp->peFlags = 0;

            ppalTmp++;

            if (!(jBlu += 64))
                if (!(jGre += 32))
                    jRed += 32;
        }

        {
            // We're going to be a palette-managed device.
            // Fill in Windows reserved colours from the WIN 3.0 DDK
            // The Window Manager reserved the first and last 10 colours for
            // painting windows borders and for non-palette managed applications.

            for (ulLoop = 0; ulLoop < 10; ulLoop++)
            {
                // First 10

                ppal[ulLoop]       = gapalBase[ulLoop];

                // Last 10

                ppal[246 + ulLoop] = gapalBase[ulLoop+10];
            }

            // Create handle for palette.

            hpal = EngCreatePalette(PAL_INDEXED, 256, (ULONG*) ppal, 0, 0, 0);
        }
    }
    else
    {
        DISPDBG((1, "flRed: %lx flGreen: %lx flBlue: %lx",
                    ppdev->flRed, ppdev->flGreen, ppdev->flBlue));

        hpal = EngCreatePalette(PAL_BITFIELDS, 0, NULL,
                                ppdev->flRed, ppdev->flGreen, ppdev->flBlue);
    }

    ppdev->hpalDefault = hpal;
    pdi->hpalDefault   = hpal;

    if (hpal == 0)
        goto ReturnFalse;

    return(TRUE);

ReturnFalse:

    DISPDBG((0, "Failed bInitializePalette"));
    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vUninitializePalette
*
* Frees resources allocated by bInitializePalette.
*
* Note: In an error case, this may be called before bInitializePalette.
*
\**************************************************************************/

VOID vUninitializePalette(PDEV* ppdev)
{
    // Delete the default palette if we created one:

    if (ppdev->hpalDefault != 0)
        EngDeletePalette(ppdev->hpalDefault);

    if (ppdev->pPal != (PALETTEENTRY*) NULL)
        EngFreeMem(ppdev->pPal);
}

/******************************Public*Routine******************************\
* BOOL bEnablePalette
*
* Initialize the hardware's 8bpp palette registers.
*
\**************************************************************************/

BOOL bEnablePalette(PDEV* ppdev)
{
    BYTE        ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT pScreenClut;
    ULONG       ulReturnedDataLength;
    ULONG       cColors;
    PVIDEO_CLUTDATA pScreenClutData;

    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        // Fill in pScreenClut header info:

        pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
        pScreenClut->NumEntries = 256;
        pScreenClut->FirstEntry = 0;

        // Copy colours in:

        cColors = 256;
        pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

        while(cColors--)
        {
            pScreenClutData[cColors].Red =    ppdev->pPal[cColors].peRed >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Green =  ppdev->pPal[cColors].peGreen >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue =   ppdev->pPal[cColors].peBlue >>
                                              ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }

        // Set palette registers:

        if (EngDeviceIoControl(ppdev->hDriver,
                             IOCTL_VIDEO_SET_COLOR_REGISTERS,
                             pScreenClut,
                             MAX_CLUT_SIZE,
                             NULL,
                             0,
                             &ulReturnedDataLength))
        {
            DISPDBG((0, "Failed bEnablePalette"));
            return(FALSE);
        }
    }

    DISPDBG((5, "Passed bEnablePalette"));

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisablePalette
*
* Undoes anything done in bEnablePalette.
*
\**************************************************************************/

VOID vDisablePalette(
PDEV*   ppdev)
{
    // Nothin' to do
}

/******************************Public*Routine******************************\
* VOID vAssertModePalette
*
* Sets/resets the palette in preparation for full-screen/graphics mode.
*
\**************************************************************************/

VOID vAssertModePalette(
PDEV*   ppdev,
BOOL    bEnable)
{
    // USER immediately calls DrvSetPalette after switching out of
    // full-screen, so we don't have to worry about resetting the
    // palette here.
}

/******************************Public*Routine******************************\
* BOOL DrvSetPalette
*
* DDI entry point for manipulating the palette.
*
\**************************************************************************/

BOOL DrvSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BYTE            ajClutSpace[MAX_CLUT_SIZE];
    PVIDEO_CLUT     pScreenClut;
    PVIDEO_CLUTDATA pScreenClutData;
    PDEV*           ppdev;

    UNREFERENCED_PARAMETER(fl);

    ppdev = (PDEV*) dhpdev;

    // Fill in pScreenClut header info:

    pScreenClut             = (PVIDEO_CLUT) ajClutSpace;
    pScreenClut->NumEntries = (USHORT) cColors;
    pScreenClut->FirstEntry = (USHORT) iStart;

    pScreenClutData = (PVIDEO_CLUTDATA) (&(pScreenClut->LookupTable[0]));

    if (cColors != PALOBJ_cGetColors(ppalo, iStart, cColors,
                                     (ULONG*) pScreenClutData))
    {
        DISPDBG((0, "DrvSetPalette failed PALOBJ_cGetColors\n"));
        return (FALSE);
    }

    // Set the high reserved byte in each palette entry to 0.
    // Do the appropriate palette shifting to fit in the DAC.

    if (ppdev->cPaletteShift)
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Red >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Green >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Blue >>= ppdev->cPaletteShift;
            pScreenClutData[cColors].Unused = 0;
        }
    }
    else
    {
        while(cColors--)
        {
            pScreenClutData[cColors].Unused = 0;
        }
    }

    // Set palette registers

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_SET_COLOR_REGISTERS,
                         pScreenClut,
                         MAX_CLUT_SIZE,
                         NULL,
                         0,
                         &cColors))
    {
        DISPDBG((0, "DrvSetPalette failed EngDeviceIoControl\n"));
        return (FALSE);
    }

    return(TRUE);

}

/******************************Public*Routine******************************\
* BOOL DrvIcmSetDeviceGammaRamp
*
* DDI entry point for manipulating the device gamma ramp.
*
\**************************************************************************/

BOOL DrvIcmSetDeviceGammaRamp(
DHPDEV  dhpdev,
ULONG   iFormat,
PVOID   lpRamp)
{
    PDEV *ppdev = (PDEV*) dhpdev;

    if (ppdev->ulBoardId != MGA_STORM)
    {
        DISPDBG((0, "DrvIcmSetDeviceGammaRamp failed since not Millenium.\n"));
        return (FALSE);
    }

    if (iFormat == IGRF_RGB_256WORDS)
    {
        BYTE ajGammaRampData[(sizeof(VIDEO_COLOR_LUT_DATA) - 1)
                             + (sizeof(VIDEO_LUT_RGB256WORDS))];
        PVIDEO_COLOR_LUT_DATA pVideoColorLutData 
             = (PVIDEO_COLOR_LUT_DATA) ajGammaRampData;
        ULONG ulRet;

        // fill up VIDEO_COLOR_LUT_DATA structure.

        pVideoColorLutData->Length = sizeof(VIDEO_LUT_RGB256WORDS);
        pVideoColorLutData->LutDataFormat 
             = VIDEO_COLOR_LUT_DATA_FORMAT_RGB256WORDS;

        RtlCopyMemory(&(pVideoColorLutData->LutData[0]),
                      lpRamp,
                      sizeof(VIDEO_LUT_RGB256WORDS));

        // Set color loop up table.

        if (EngDeviceIoControl(ppdev->hDriver,
                               IOCTL_VIDEO_SET_COLOR_LUT_DATA,
                               pVideoColorLutData,
                               sizeof(ajGammaRampData),
                               NULL,
                               0,
                               &ulRet))
        {
            DISPDBG((0, "DrvIcmSetDeviceGammaRamp failed EngDeviceIoControl\n"));
            return (FALSE);
        }
    }
    else
    {
        DISPDBG((0, "DrvIcmSetDeviceGammaRamp failed unknown ramp format\n"));
        return (FALSE);
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\pointer.c ===
/******************************Module*Header*******************************\
* Module Name: pointer.c
*
* This module contains the hardware pointer support for the display
* driver.
*
* Copyright (c) 1993-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

#define BT485_CURSOR_SIZE       64
#define BT482_CURSOR_SIZE       32
#define VIEWPOINT_CURSOR_SIZE   64
#define VIEWPOINT_OUT           (VIEWPOINT_CURSOR_SIZE/2-1-VIEWPOINT_CURSOR_SIZE)
#define TVP3026_CURSOR_SIZE     64
#define TVP3026_OUT             (TVP3026_CURSOR_SIZE-TVP3026_CURSOR_SIZE)

#define OLD_TVP_SHIFT           2
#define NEW_TVP_SHIFT           0

BYTE Plane0LUT[] =  { 0x00, 0x01, 0x04, 0x05,
                      0x10, 0x11, 0x14, 0x15,
                      0x40, 0x41, 0x44, 0x45,
                      0x50, 0x51, 0x54, 0x55 };

BYTE Plane1LUT[] =  { 0x00, 0x02, 0x08, 0x0a,
                      0x20, 0x22, 0x28, 0x2a,
                      0x80, 0x82, 0x88, 0x8a,
                      0xa0, 0xa2, 0xa8, 0xaa };

/****************************************************************************\
* SetBt48xPointerShape
\****************************************************************************/

ULONG SetBt48xPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    ULONG   i;
    ULONG   j;
    ULONG   cxMask;
    ULONG   cyMask;
    ULONG   cMaskDimension;
    LONG    lDelta;
    PDEV*   ppdev;
    BYTE*   pjBase;
    UCHAR   ucTemp;
    UCHAR   ucByteWidth;
    UCHAR   ucOldCR;
    UCHAR   ucOldCmdRegA;
    BYTE*   pjAND;
    BYTE*   pjXOR;
    LONG    cjWidth;
    LONG    cjSkip;
    LONG    cjWidthRemainder;
    LONG    cyHeightRemainder;
    LONG    cjHeightRemainder;

    ppdev  = (PDEV*) pso->dhpdev;
    pjBase = ppdev->pjBase;

    // Figure out the dimensions of the masks:

    cMaskDimension = (ppdev->RamDacFlags == RAMDAC_BT482) ? 32 : 64;

    // Get the bitmap dimensions.

    cxMask = psoMsk->sizlBitmap.cx;
    cyMask = psoMsk->sizlBitmap.cy >> 1; // Height includes AND and XOR masks

    // Set up pointers to the AND and XOR masks.

    lDelta = psoMsk->lDelta;
    pjAND  = psoMsk->pvScan0;
    pjXOR  = pjAND + (cyMask * lDelta);

    // Do some other download setup:

    cjWidth           = cxMask >> 3;
    cjSkip            = lDelta - cjWidth;
    cjWidthRemainder  = (cMaskDimension / 8) - cjWidth;

    // Don't bother blanking the bottom part of the cursor if it is
    // already blank:

    cyHeightRemainder = min(ppdev->cyPointerHeight, (LONG) cMaskDimension)
                      - cyMask;
    cyHeightRemainder = max(cyHeightRemainder, 0);
    cjHeightRemainder = cyHeightRemainder * (cMaskDimension / 8);
    ppdev->cyPointerHeight = cyMask;

    DrvMovePointer(pso, -1, -1, NULL);  // Disable the H/W cursor

    if ((ppdev->RamDacFlags == RAMDAC_BT485) ||
        (ppdev->RamDacFlags == RAMDAC_PX2085))
    {
        // Set the cursor for 64 X 64, and set the 2 MSB's for the cursor
        // RAM addr to 0.
        // First get access to Command Register 3

        // Prepare to download AND mask to Bt485
        // Clear bit 7 of CR0 so we can access CR3

        ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG0);
        ucTemp |= 0x80;
        CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG0, ucTemp);

        // Turn on bit 0 to address register

        CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_WRITE, 1);

        ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG3);
        ucTemp &= 0xF8;                 // CR3 bit2=1  (64x64 cursor)
        ucTemp |= 0x06;                 // CR3 bit1-bit0=10 (AND mask)
        CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG3, ucTemp);

        // Start at address 0x200 (AND mask)

        CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_WRITE, 0);

        // Down load the AND mask:

        for (j = cyMask; j != 0; j--)
        {
            for (i = cjWidth; i != 0; i--)
            {
                CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_DATA, *pjAND++);
            }

            pjAND += cjSkip;

            for (i = cjWidthRemainder; i != 0; i--)
            {
                pjBase = ppdev->pjBase;     // Compiler work-around
                CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_DATA, 0xff);
            }
        }

        for (j = cjHeightRemainder; j != 0; j--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_DATA, 0xff);
        }

        // Prepare to download XOR mask to Bt485
        // Clear bit 7 of CR0 so we can access CR3

        ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG0);
        ucTemp |= 0x80;
        CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG0, ucTemp);

        // Turn on bit 0 to address register

        CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_WRITE, 1);

        ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG3);
        ucTemp &= 0xF8;                 // CR3 bit2=1  (64x64 cursor)
        ucTemp |= 0x04;                 // CR3 bit1-bit0=00 (XOR mask)
        CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG3, ucTemp);

        // Start at address 0x200 (AND mask)

        CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_WRITE, 0);

        // Down load the XOR mask

        for (j = cyMask; j != 0; j--)
        {
            for (i = cjWidth; i != 0; i--)
            {
                CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_DATA, *pjXOR++);
            }

            pjXOR += cjSkip;

            for (i = cjWidthRemainder; i != 0; i--)
            {
                pjBase = ppdev->pjBase;     // Compiler work-around
                CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_DATA, 0);
            }
        }

        for (j = cjHeightRemainder; j != 0; j--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_DATA, 0);
        }
    }
    else    // Download to Bt482
    {
        // Prepare to download AND mask to Bt482
        // Store current REGA value, select extended registers

        ucOldCmdRegA = CP_READ_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA);
        CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA,
                                ucOldCmdRegA | BT482_EXTENDED_REG_SELECT);

        CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_REG);
        ucOldCR = CP_READ_REGISTER_BYTE(pjBase + BT482_PEL_MASK);
        CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, ucOldCR | BT482_CURSOR_RAM_SELECT);

        CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, 0x80);

        for (j = cyMask; j != 0; j--)
        {
            for (i = cjWidth; i != 0; i--)
            {
                CP_WRITE_REGISTER_BYTE(pjBase + BT482_OVRLAY_REGS, *pjAND++);
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);    // Need 600us delay
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);
            }

            pjAND += cjSkip;

            for (i = cjWidthRemainder; i != 0; i--)
            {
                pjBase = ppdev->pjBase;     // Compiler work-around
                CP_WRITE_REGISTER_BYTE(pjBase + BT482_OVRLAY_REGS, 0xff);
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);    // Need 600us delay
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);
            }
        }

        for (j = cjHeightRemainder; j != 0; j--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_OVRLAY_REGS, 0xff);
            CP_READ_REGISTER_BYTE(pjBase + HST_REV);    // Need 600us delay
            CP_READ_REGISTER_BYTE(pjBase + HST_REV);
        }

        // Prepare to download XOR mask to Bt482

        CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, 0x00);

        for (j = cyMask; j != 0; j--)
        {
            for (i = cjWidth; i != 0; i--)
            {
                CP_WRITE_REGISTER_BYTE(pjBase + BT482_OVRLAY_REGS, *pjXOR++);
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);    // Need 600us delay
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);
            }

            pjXOR += cjSkip;

            for (i = cjWidthRemainder; i != 0; i--)
            {
                pjBase = ppdev->pjBase;     // Compiler work-around
                CP_WRITE_REGISTER_BYTE(pjBase + BT482_OVRLAY_REGS, 0);
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);    // Need 600us delay
                CP_READ_REGISTER_BYTE(pjBase + HST_REV);
            }
        }

        for (j = cjHeightRemainder; j != 0; j--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_OVRLAY_REGS, 0);
            CP_READ_REGISTER_BYTE(pjBase + HST_REV);    // Need 600us delay
            CP_READ_REGISTER_BYTE(pjBase + HST_REV);
        }

        // Restore old Cursor Regsister and Command Register A values

        CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_REG);
        CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, ucOldCR);
        CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA, ucOldCmdRegA);
    }

    // Set the position of the cursor (and enable it)

    DrvMovePointer(pso, x, y, NULL);

    return(SPS_ACCEPT_NOEXCLUDE);
}

/****************************************************************************\
* SetViewPointPointerShape -
\****************************************************************************/

ULONG SetViewPointPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    ULONG   i;
    ULONG   j;
    ULONG   cxAND;
    ULONG   cyAND;
    ULONG   cxRemaining;
    ULONG   cyRemaining;
    BYTE*   pjAND;
    BYTE*   pjXOR;
    LONG    lDelta;
    PDEV*   ppdev;
    BYTE*   pjBase;
    BYTE    ViewPointTranspMask;

    ppdev  = (PDEV*) pso->dhpdev;
    pjBase = ppdev->pjBase;

    // The ViewPoint requires that the AND mask (plane 1) and the XOR mask
    // (plane 0) be interleaved on a bit-by-bit basis:
    //
    //      Plane1/AND:   F E D C B A 9 8
    //      Plane0/XOR:   7 6 5 4 3 2 1 0
    //
    // will be downloaded as: "B 3 A 2 9 1 8 0" and "F 7 E 6 D 5 C 4".
    // The fastest way to do that is probably to use a lookup table:
    //
    //      Plane1:     "B A 9 8" --> "B - A - 9 - 8 -"
    //      Plane0:     "3 2 1 0" --> "- 3 - 2 - 1 - 0"
    //                         OR --> "B 3 A 2 9 1 8 0"

    // Get the bitmap dimensions.
    // This assumes that the cursor width is an integer number of bytes!

    cxAND = psoMsk->sizlBitmap.cx / 8;
    cxRemaining = 2 * ((VIEWPOINT_CURSOR_SIZE/8) - cxAND);
    cyAND = psoMsk->sizlBitmap.cy / 2;
    cyRemaining = VIEWPOINT_CURSOR_SIZE - cyAND;

    // Set up pointers to the AND and XOR masks.

    pjAND  = psoMsk->pvScan0;
    lDelta = psoMsk->lDelta;
    pjXOR  = pjAND + (cyAND * lDelta);

    if (ppdev->bHwPointerActive)
    {
        // The hardware cursor is currently enabled.
        // Disable it.

        CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_CTL);
        CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, VIEWPOINT_CURSOR_OFF);

        // Signal that the cursor is disabled.

        ppdev->bHwPointerActive = FALSE;
    }

    // The effect of this is to make the pointer pixels transparent.

    ViewPointTranspMask = 0xaa;

    // Setup for downloading the pointer masks.

    CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_RAM_LSB);
    CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, 0);
    CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_RAM_MSB);
    CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, 0);
    CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_RAM_DATA);

    // Build and copy the interleaved mask.

    for (i = 0; i < cyAND; i++)
    {
        // Copy over a line of the interleaved mask.

        for (j = 0; j < cxAND; j++)
        {
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA,
                    (Plane1LUT[pjAND[j] >> 4] | Plane0LUT[pjXOR[j] >> 4]));
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA,
                    (Plane1LUT[pjAND[j] & 0x0f] | Plane0LUT[pjXOR[j] & 0x0f]));
        }

        // Copy over transparent bytes for the remaining of the line.

        for (j = (VIEWPOINT_CURSOR_SIZE/8) - (psoMsk->sizlBitmap.cx >> 3);
             j != 0;
             j--)
        {
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, ViewPointTranspMask);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, ViewPointTranspMask);
        }

        // Point to the next line of the source masks.

        pjAND += lDelta;
        pjXOR += lDelta;
    }

    // Copy over transparent bytes for the remaining of the mask.

    for (i = 0; i < cyRemaining; i++)
    {
        for (j = (VIEWPOINT_CURSOR_SIZE/8);
             j != 0;
             j--)
        {
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, ViewPointTranspMask);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, ViewPointTranspMask);
        }
    }

    // Set the position of the cursor (and enable it).

    DrvMovePointer(pso, x, y, NULL);

    return(SPS_ACCEPT_NOEXCLUDE);
}

/****************************************************************************\
* MilSetTVP3026PointerShape -
\****************************************************************************/

ULONG MilSetTVP3026PointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    ULONG   i;
    ULONG   j;
    ULONG   cxMask;
    ULONG   cyMask;
    ULONG   cMaskDimension;
    LONG    lDelta;
    PDEV*   ppdev;
    BYTE*   pjBase;
    UCHAR   ucTemp;
    UCHAR   ucByteWidth;
    UCHAR   ucOldCR;
    UCHAR   ucOldCmdRegA;
    BYTE*   pjAND;
    BYTE*   pjXOR;
    LONG    cjWidth;
    LONG    cjSkip;
    LONG    cjWidthRemainder;
    LONG    cyHeightRemainder;
    LONG    cyNextBank;
    BYTE    jData;
    ULONG   UlTvpIndirectIndex;
    ULONG   UlTvpIndexedData;
    ULONG   UlTvpCurAddrWr;
    ULONG   UlTvpCurData;

    // The old MGA chips had direct register offsets that were multiples of
    // four, while the new Millenium uses increments of one.  So, we define the
    // offsets as increments of one and shift for the older boards.

    // No scaling (shifting) of offsets

    // Note that the compiler is kind enough to recognize that these are
    // constant declarations:

    UlTvpIndirectIndex = TVP3026_INDIRECT_INDEX(NEW_TVP_SHIFT);
    UlTvpIndexedData   = TVP3026_INDEXED_DATA(NEW_TVP_SHIFT);
    UlTvpCurAddrWr     = TVP3026_CUR_ADDR_WR(NEW_TVP_SHIFT);
    UlTvpCurData       = TVP3026_CUR_DATA(NEW_TVP_SHIFT);

    ppdev  = (PDEV*) pso->dhpdev;
    pjBase = ppdev->pjBase;

    // Get the bitmap dimensions.

    cxMask = psoMsk->sizlBitmap.cx;
    cyMask = psoMsk->sizlBitmap.cy >> 1; // Height includes AND and XOR masks

    // Set up pointers to the AND and XOR masks.

    lDelta = psoMsk->lDelta;
    pjAND  = psoMsk->pvScan0;
    pjXOR  = pjAND + (cyMask * lDelta);

    // Do some other download setup:

    cjWidth           = cxMask >> 3;
    cjSkip            = lDelta - cjWidth;
    cjWidthRemainder  = (64 / 8) - cjWidth;

    // Don't bother blanking the bottom part of the cursor if it is
    // already blank:

    cyHeightRemainder = min(ppdev->cyPointerHeight, (LONG) 64)
                      - cyMask;
    cyHeightRemainder = max(cyHeightRemainder, 0);
    ppdev->cyPointerHeight = cyMask;

    // Disable the cursor, access bytes 200-2FF of cursor RAM.

    ppdev->bHwPointerActive = FALSE;

    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex, TVP3026_I_CUR_CTL);
    jData = CP_READ_REGISTER_BYTE(pjBase + UlTvpIndexedData)
          & ~(TVP3026_D_CURSOR_RAM_MASK | TVP3026_D_CURSOR_MASK);

    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                           jData | TVP3026_D_CURSOR_RAM_10);
    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);

    // Down load the AND mask:

    cyNextBank = 32;
    for (j = cyMask; j != 0; j--)
    {
        for (i = cjWidth; i != 0; i--)
        {
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, *pjAND++);
        }

        pjAND += cjSkip;

        for (i = cjWidthRemainder; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0xff);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 300-3FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_11);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    for (j = cyHeightRemainder; j != 0; j--)
    {
        for (i = 8; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0xff);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 300-3FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_11);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    // Access bytes 00-FF of cursor RAM.

    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                           TVP3026_I_CUR_CTL);
    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                           jData | TVP3026_D_CURSOR_RAM_00);
    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);

    // Down load the XOR mask

    cyNextBank = 32;
    for (j = cyMask; j != 0; j--)
    {
        for (i = cjWidth; i != 0; i--)
        {
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, *pjXOR++);
        }

        pjXOR += cjSkip;

        for (i = cjWidthRemainder; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 100-1FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_01);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    for (j = cyHeightRemainder; j != 0; j--)
    {
        for (i = 8; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 100-1FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_01);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    // Set the position of the cursor (and enable it)

    DrvMovePointer(pso, x, y, NULL);

    return(SPS_ACCEPT_NOEXCLUDE);
}

/****************************************************************************\
* MgaSetTVP3026PointerShape -
\****************************************************************************/

ULONG MgaSetTVP3026PointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    ULONG   i;
    ULONG   j;
    ULONG   cxMask;
    ULONG   cyMask;
    ULONG   cMaskDimension;
    LONG    lDelta;
    PDEV*   ppdev;
    BYTE*   pjBase;
    UCHAR   ucTemp;
    UCHAR   ucByteWidth;
    UCHAR   ucOldCR;
    UCHAR   ucOldCmdRegA;
    BYTE*   pjAND;
    BYTE*   pjXOR;
    LONG    cjWidth;
    LONG    cjSkip;
    LONG    cjWidthRemainder;
    LONG    cyHeightRemainder;
    LONG    cyNextBank;
    BYTE    jData;
    ULONG   UlTvpIndirectIndex;
    ULONG   UlTvpIndexedData;
    ULONG   UlTvpCurAddrWr;
    ULONG   UlTvpCurData;

    // The old MGA chips had direct register offsets that were multiples of
    // four, while the new Millenium uses increments of one.  So, we define the
    // offsets as increments of one and shift for the older boards.

    // No scaling (shifting) of offsets

    // Note that the compiler is kind enough to recognize that these are
    // constant declarations:

    UlTvpIndirectIndex = TVP3026_INDIRECT_INDEX(OLD_TVP_SHIFT);
    UlTvpIndexedData   = TVP3026_INDEXED_DATA(OLD_TVP_SHIFT);
    UlTvpCurAddrWr     = TVP3026_CUR_ADDR_WR(OLD_TVP_SHIFT);
    UlTvpCurData       = TVP3026_CUR_DATA(OLD_TVP_SHIFT);

    ppdev  = (PDEV*) pso->dhpdev;
    pjBase = ppdev->pjBase;

    // Get the bitmap dimensions.

    cxMask = psoMsk->sizlBitmap.cx;
    cyMask = psoMsk->sizlBitmap.cy >> 1; // Height includes AND and XOR masks

    // Set up pointers to the AND and XOR masks.

    lDelta = psoMsk->lDelta;
    pjAND  = psoMsk->pvScan0;
    pjXOR  = pjAND + (cyMask * lDelta);

    // Do some other download setup:

    cjWidth           = cxMask >> 3;
    cjSkip            = lDelta - cjWidth;
    cjWidthRemainder  = (64 / 8) - cjWidth;

    // Don't bother blanking the bottom part of the cursor if it is
    // already blank:

    cyHeightRemainder = min(ppdev->cyPointerHeight, (LONG) 64)
                      - cyMask;
    cyHeightRemainder = max(cyHeightRemainder, 0);
    ppdev->cyPointerHeight = cyMask;

    // Disable the cursor, access bytes 200-2FF of cursor RAM.

    ppdev->bHwPointerActive = FALSE;

    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex, TVP3026_I_CUR_CTL);
    jData = CP_READ_REGISTER_BYTE(pjBase + UlTvpIndexedData)
          & ~(TVP3026_D_CURSOR_RAM_MASK | TVP3026_D_CURSOR_MASK);

    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                           jData | TVP3026_D_CURSOR_RAM_10);
    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);

    // Down load the AND mask:

    cyNextBank = 32;
    for (j = cyMask; j != 0; j--)
    {
        for (i = cjWidth; i != 0; i--)
        {
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, *pjAND++);
        }

        pjAND += cjSkip;

        for (i = cjWidthRemainder; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0xff);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 300-3FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_11);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    for (j = cyHeightRemainder; j != 0; j--)
    {
        for (i = 8; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0xff);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 300-3FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_11);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    // Access bytes 00-FF of cursor RAM.

    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                           TVP3026_I_CUR_CTL);
    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                           jData | TVP3026_D_CURSOR_RAM_00);
    CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);

    // Down load the XOR mask

    cyNextBank = 32;
    for (j = cyMask; j != 0; j--)
    {
        for (i = cjWidth; i != 0; i--)
        {
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, *pjXOR++);
        }

        pjXOR += cjSkip;

        for (i = cjWidthRemainder; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 100-1FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_01);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    for (j = cyHeightRemainder; j != 0; j--)
    {
        for (i = 8; i != 0; i--)
        {
            pjBase = ppdev->pjBase;     // Compiler work-around
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurData, 0);
        }

        if (--cyNextBank == 0)
        {
            // Access bytes 100-1FF of cursor RAM.

            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndirectIndex,
                                   TVP3026_I_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpIndexedData,
                                   jData | TVP3026_D_CURSOR_RAM_01);
            CP_WRITE_REGISTER_BYTE(pjBase + UlTvpCurAddrWr, 0);
        }
    }

    // Set the position of the cursor (and enable it)

    DrvMovePointer(pso, x, y, NULL);

    return(SPS_ACCEPT_NOEXCLUDE);
}

/****************************************************************************\
* DrvSetPointerShape
\****************************************************************************/

ULONG DrvSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMsk,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prcl,
FLONG       fl)
{
    PDEV*   ppdev;
    LONG    cx;
    LONG    cy;
    LONG    cMax;
    ULONG   ulRet;

    ppdev = (PDEV*) pso->dhpdev;

    // Because our DAC pointers usually flash when we set them, we'll
    // always decline animated pointers:

    if (fl & (SPS_ANIMATESTART | SPS_ANIMATEUPDATE))
    {
        goto HideAndDecline;
    }

    //
    // Bug: 412974. we have HW cursor corruption. Disable it by declining.
    //
    goto HideAndDecline;

    // We're not going to handle any colour pointers, pointers that
    // are larger than our hardware allows, or flags that we don't
    // understand.
    //
    // (Note that the spec says we should decline any flags we don't
    // understand, but we'll actually be declining if we don't see
    // the only flag we *do* understand...)
    //
    // Our old documentation says that 'psoMsk' may be NULL, which means
    // that the pointer is transparent.  Well, trust me, that's wrong.
    // I've checked GDI's code, and it will never pass us a NULL psoMsk:

    cx = psoMsk->sizlBitmap.cx;        // Note that 'sizlBitmap.cy' accounts
    cy = psoMsk->sizlBitmap.cy >> 1;   //   for the double height due to the
                                       //   inclusion of both the AND masks
                                       //   and the XOR masks.  For now, we're
                                       //   only interested in the true
                                       //   pointer dimensions, so we divide
                                       //   by 2.

    cMax = (ppdev->RamDacFlags == RAMDAC_BT482) ? BT482_CURSOR_SIZE : 64;

    if ((psoColor != NULL) ||
        (cx > cMax)        ||       // Hardware pointer is cMax by cMax
        (cy > cMax)        ||       //   pixels
        (cx & 7)           ||       // To simplify download routines, handle
                                    //   only byte-aligned widths
        !(fl & SPS_CHANGE))         // Must have this flag set
    {
        goto HideAndDecline;
    }

    // Save the hot spot in the pdev.

    ppdev->ptlHotSpot.x = xHot;
    ppdev->ptlHotSpot.y = yHot;

    // Program the monochrome hardware pointer.

    switch (ppdev->RamDacFlags)
    {
    case RAMDAC_BT485:
    case RAMDAC_BT482:
    case RAMDAC_PX2085:
        ulRet = SetBt48xPointerShape(pso, psoMsk, psoColor,
                                     pxlo, xHot, yHot, x, y, prcl, fl);
        break;

    case RAMDAC_VIEWPOINT:
        ulRet = SetViewPointPointerShape(pso, psoMsk, psoColor,
                                         pxlo, xHot, yHot, x, y, prcl, fl);
        break;

    case RAMDAC_TVP3026:
    case RAMDAC_TVP3030:
        if (ppdev->ulBoardId == MGA_STORM)
        {
            ulRet = MilSetTVP3026PointerShape(pso, psoMsk, psoColor,
                                              pxlo, xHot, yHot, x, y, prcl, fl);
        }
        else
        {
            ulRet = MgaSetTVP3026PointerShape(pso, psoMsk, psoColor,
                                              pxlo, xHot, yHot, x, y, prcl, fl);
        }
        break;

    default:
        ulRet = SPS_DECLINE;
        break;
    }

    return(ulRet);

HideAndDecline:

    // Since we're declining the new pointer, GDI will simulate it via
    // DrvCopyBits calls.  So we should really hide the old hardware
    // pointer if it's visible.  We can get DrvMovePointer to do this
    // for us:

    DrvMovePointer(pso, -1, -1, NULL);

    return(SPS_DECLINE);
}

/****************************************************************************\
* DrvMovePointer
*
\****************************************************************************/

VOID DrvMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)
{
    PDEV*   ppdev;
    OH*     poh;
    BYTE*   pjBase;
    UCHAR   ucTemp;
    UCHAR   ucOldCmdRegA;
    ULONG   ulDacScale;

    ppdev  = (PDEV*) pso->dhpdev;
    poh    = ((DSURF*) pso->dhsurf)->poh;
    pjBase = ppdev->pjBase;

    // Convert the pointer's position from relative to absolute
    // coordinates (this is only significant for multiple board
    // support).

    x += poh->x;
    y += poh->y;

    // If x is -1 after the offset then take down the cursor.

    if (x == -1)
    {
        if (!(ppdev->bHwPointerActive))
        {
            // The hardware cursor is disabled already.

            return;
        }

        // Disable the cursor.

        // We will set the cursor position outside the display to prevent
        // flickering when switching from software to hardware cursor.

        switch (ppdev->RamDacFlags)
        {
        case RAMDAC_BT485:

            // Disable the cursor, then fall through.

            ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG2);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG2, ucTemp & 0xfc);

        case RAMDAC_PX2085:

            // Set the cursor position outside the display.

            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_X_LOW,  0);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_X_HIGH, 0);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_Y_LOW,  0);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_Y_HIGH, 0);
            break;

        case RAMDAC_BT482:

            ucOldCmdRegA = CP_READ_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA, BT482_EXTENDED_REG_SELECT);

            // Set the cursor position outside the display.

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_X_LOW_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, 0);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_X_HIGH_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, 0);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_Y_LOW_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, 0);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_Y_HIGH_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, 0);

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_CURSOR_RAM_WRITE, CURS_REG);
            ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT482_PEL_MASK);
            ucTemp &= ~(BT482_CURSOR_OP_DISABLED | BT482_CURSOR_FIELDS);
            ucTemp |= BT482_CURSOR_DISABLED;
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, ucTemp);

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA, ucOldCmdRegA);
            break;

        case RAMDAC_VIEWPOINT:

            // Set the cursor position outside the display.

            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_X_LSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, VIEWPOINT_OUT & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_X_MSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, (VIEWPOINT_OUT >> 8));
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_Y_LSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, VIEWPOINT_OUT & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_Y_MSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, (VIEWPOINT_OUT >> 8));

            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, VIEWPOINT_CURSOR_OFF);
            break;

        case RAMDAC_TVP3026:
        case RAMDAC_TVP3030:

            // Set the cursor position outside the display.

            if (ppdev->ulBoardId == MGA_STORM)
            {
                ulDacScale = 0;
            }
            else
            {
                ulDacScale = 2;
            }

            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_X_LSB(ulDacScale),TVP3026_OUT & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_X_MSB(ulDacScale),(TVP3026_OUT >> 8));
            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_Y_LSB(ulDacScale),TVP3026_OUT & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_Y_MSB(ulDacScale),(TVP3026_OUT >> 8));

            // Disable the cursor.

            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDIRECT_INDEX(ulDacScale),TVP3026_I_CUR_CTL);
            ucTemp = CP_READ_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(ulDacScale));
            ucTemp &= ~TVP3026_D_CURSOR_MASK;
            ucTemp |= TVP3026_D_CURSOR_OFF;
            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(ulDacScale),ucTemp);
            break;

        default:
            break;
        }

        // Signal that the hardware cursor is not currently enabled.

        ppdev->bHwPointerActive = FALSE;
        return;
    }
    else
    {
        // Calculate the actual (x,y) coordinate to send to Bt48x RamDac

        x -= ppdev->ptlHotSpot.x;       // Adjust the (x,y) coordinate
        y -= ppdev->ptlHotSpot.y;       //    considering the hot-spot

        x += ppdev->szlPointerOverscan.cx;
        y += ppdev->szlPointerOverscan.cy;

        switch(ppdev->RamDacFlags)
        {
        case RAMDAC_BT485:
        case RAMDAC_PX2085:

            x += BT485_CURSOR_SIZE;         // Bt48x origin is at the bottom
            y += BT485_CURSOR_SIZE;

            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_X_LOW,  x & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_X_HIGH, x >> 8);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_Y_LOW,  y & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_Y_HIGH, y >> 8);

            // Enable the cursor... We have a flag in the pdev
            // to indicate whether the cursor is already enabled.

            // We cannot read vsyncsts anymore, so we do it differently.
            // The code for disabling the hardware cursor set its
            // position to (0, 0), so any flickering should be less
            // obvious.

            if (!(ppdev->bHwPointerActive))
            {
                // The hardware cursor is disabled.
                ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG2);
                ucTemp|=0x02;
                CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG2, ucTemp);
            }
            break;

        case RAMDAC_VIEWPOINT:

            x += VIEWPOINT_CURSOR_SIZE/2-1; // Viewpoint origin is at the center
            y += VIEWPOINT_CURSOR_SIZE/2-1;

            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_X_LSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA,  x & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_X_MSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA,  x >> 8);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_Y_LSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA,  y & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_Y_MSB);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA,  y >> 8);

            // Enable the cursor... We have a flag in the pdev
            // to indicate whether the cursor is already enabled.

            // We cannot read vsyncsts anymore, so we do it differently.
            // The code for disabling the hardware cursor set its
            // position to (0, 0), so any flickering should be less
            // obvious.

            if (!(ppdev->bHwPointerActive))
            {
                // The hardware cursor is disabled.

                CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_CTL);
                CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, VIEWPOINT_CURSOR_ON);
            }
            break;

        case RAMDAC_BT482:

            x += BT482_CURSOR_SIZE;         // Bt48x origin is at the bottom
            y += BT482_CURSOR_SIZE;

            ucOldCmdRegA = CP_READ_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA,
                                ucOldCmdRegA | BT482_EXTENDED_REG_SELECT);

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_X_LOW_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, x & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_X_HIGH_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, x >> 8);

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_Y_LOW_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, y & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PALETTE_RAM_WRITE, CURS_Y_HIGH_REG);
            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, y >> 8);

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA, ucOldCmdRegA);

            // Enable the Bt482 Cursor.
            // We cannot read vsyncsts anymore, so we do it differently.
            // The code for disabling the hardware cursor set its
            // position to (0, 0), so any flickering should be less
            // obvious.

            if (!(ppdev->bHwPointerActive))
            {
                // The hardware cursor is disabled.

                ucOldCmdRegA = CP_READ_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA);
                CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA, BT482_EXTENDED_REG_SELECT);

                CP_WRITE_REGISTER_BYTE(pjBase + BT482_CURSOR_RAM_WRITE, CURS_REG);
                ucTemp = CP_READ_REGISTER_BYTE(pjBase + BT482_PEL_MASK);
                ucTemp &= ~(BT482_CURSOR_OP_DISABLED | BT482_CURSOR_FIELDS);
                ucTemp |= BT482_CURSOR_WINDOWS;
                CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, ucTemp);

                CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA, ucOldCmdRegA);
            }
            break;

        case RAMDAC_TVP3026:
        case RAMDAC_TVP3030:

            if (ppdev->ulBoardId == MGA_STORM)
            {
                ulDacScale = 0;
            }
            else
            {
                ulDacScale = 2;
            }

            x += TVP3026_CURSOR_SIZE;
            y += TVP3026_CURSOR_SIZE;

            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_X_LSB(ulDacScale), x & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_X_MSB(ulDacScale), x >> 8);
            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_Y_LSB(ulDacScale), y & 0xff);
            CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_CUR_Y_MSB(ulDacScale), y >> 8);

            // Enable the cursor... We have a flag in the pdev
            // to indicate whether the cursor is already enabled.

            // We cannot read vsyncsts anymore, so we do it differently.
            // The code for disabling the hardware cursor set its
            // position to (0, 0), so any flickering should be less
            // obvious.

            if (!(ppdev->bHwPointerActive))
            {
                // The hardware cursor is disabled.

                CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDIRECT_INDEX(ulDacScale),TVP3026_I_CUR_CTL);
                ucTemp = CP_READ_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(ulDacScale));
                ucTemp &= ~TVP3026_D_CURSOR_MASK;
                ucTemp |= TVP3026_D_CURSOR_ON;
                CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(ulDacScale),ucTemp);
            }
            break;

        default:
            break;

        }

        // Signal that the hardware cursor is enabled.

        ppdev->bHwPointerActive = TRUE;
    }
}

/******************************Public*Routine******************************\
* VOID vDisablePointer
*
\**************************************************************************/

VOID vDisablePointer(
PDEV*   ppdev)
{
    // Nothing to do, really
}

/******************************Public*Routine******************************\
* VOID vAssertModePointer
*
\**************************************************************************/

VOID vAssertModePointer(
PDEV*   ppdev,
BOOL    bEnable)
{
    BYTE*   pjBase;
    BYTE    byte;
    BYTE    Bt48xCmdReg0;
    BYTE    Bt48xCmdReg1;
    BYTE    Bt48xCmdReg2;
    BYTE    Bt48xCmdReg3;

    if (bEnable)
    {
        pjBase = ppdev->pjBase;

        ppdev->bHwPointerActive = FALSE;

        ppdev->cyPointerHeight = 1024;  // A large number to ensure that the
                                        //   entire pointer is downloaded
                                        //   the first time

        switch (ppdev->RamDacFlags)
        {
        case RAMDAC_BT482:

            // Make sure our copy of RegA doesn't allow access to extended
            // registers.

            byte = CP_READ_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA);
            Bt48xCmdReg0 = byte & ~BT482_EXTENDED_REG_SELECT;

            // Get access to extended registers.

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA,
                                   Bt48xCmdReg0 | BT482_EXTENDED_REG_SELECT);

            // Record contents of RegB.

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_CURSOR_RAM_WRITE, COMMAND_B_REG);
            Bt48xCmdReg1 = CP_READ_REGISTER_BYTE(pjBase + BT482_PEL_MASK);

            // Make sure our copy of Cursor Reg has the cursor disabled
            // and the cursor color palette selected.

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_CURSOR_RAM_WRITE, CURS_REG);
            byte = CP_READ_REGISTER_BYTE(pjBase + BT482_PEL_MASK);
            Bt48xCmdReg2 = (byte & ~(BT482_CURSOR_FIELDS |
                                     BT482_CURSOR_RAM_SELECT)) |
                                    (BT482_CURSOR_DISABLED |
                                     BT482_CURSOR_COLOR_PALETTE_SELECT);

            // Disable the cursor, and prepare to access the cursor palette.

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_PEL_MASK, Bt48xCmdReg2);

            // Cursor colors have been set by IOCTL_VIDEO_SET_CURRENT_MODE.

            // We don't need access to extended registers any more, for now.

            CP_WRITE_REGISTER_BYTE(pjBase + BT482_COMMAND_REGA, Bt48xCmdReg0);

            // Our color palette will be set later, by the miniport.

            break;

        case RAMDAC_BT485:
        case RAMDAC_PX2085:

            // Make sure our copy of Reg0 doesn't allow access to Reg3.

            byte = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG0);

            // There seems to be a problem with unselecting Command 3
            // Bt48xCmdReg0 = byte & ~BT485_REG3_SELECT;

            Bt48xCmdReg0 = byte;

            Bt48xCmdReg1 = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG1);

            // Make sure our copy of Reg2 has the cursor disabled.

            byte = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG2);
            Bt48xCmdReg2 = (byte & ~BT485_CURSOR_FIELDS) |
                                    BT485_CURSOR_DISABLED;
            // Disable the cursor.

            CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG2, Bt48xCmdReg2);

            // Access and record contents of Reg3.

            CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG0, Bt48xCmdReg0 |
                                                    BT485_REG3_SELECT);
            CP_WRITE_REGISTER_BYTE(pjBase + BT485_CURSOR_RAM_WRITE, 1);
            byte = CP_READ_REGISTER_BYTE(pjBase + BT485_COMMAND_REG3);

            // Make sure our copy of Reg3 has the 64x64 cursor selected
            // and the 2MSBs for the 64x64 cursor set to zero.

            Bt48xCmdReg3 = byte | BT485_CURSOR_64X64 &
                                 ~BT485_CURSOR_64X64_FIELDS;

            // Make sure we start out using the 64x64 cursor, and record
            // the pointer size so that we know which one we're using.

            CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG3, Bt48xCmdReg3);

            // There seems to be a problem with unselecting Command 3
            // We don't need to access Reg3 any more, for now.

            CP_WRITE_REGISTER_BYTE(pjBase + BT485_COMMAND_REG0, Bt48xCmdReg0);

            // Cursor colors have been set by IOCTL_VIDEO_SET_CURRENT_MODE.
            // Our color palette will be set later, by the miniport.

            break;

        case RAMDAC_VIEWPOINT:

            // Disable the cursor.

            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_INDEX, VPOINT_CUR_CTL);
            CP_WRITE_REGISTER_BYTE(pjBase + VIEWPOINT_DATA, VIEWPOINT_CURSOR_OFF);

            // Cursor colors have been set by IOCTL_VIDEO_SET_CURRENT_MODE.
            // Our color palette will be set later, by the miniport.

            break;

        case RAMDAC_TVP3026:
        case RAMDAC_TVP3030:

            // Disable the cursor.

            if (ppdev->ulBoardId == MGA_STORM)
            {
                CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDIRECT_INDEX(NEW_TVP_SHIFT), TVP3026_I_CUR_CTL);
                byte = CP_READ_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(NEW_TVP_SHIFT));
                byte &= ~TVP3026_D_CURSOR_MASK;
                byte |= TVP3026_D_CURSOR_OFF;
                CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(NEW_TVP_SHIFT), byte);
            }
            else
            {
                CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDIRECT_INDEX(OLD_TVP_SHIFT), TVP3026_I_CUR_CTL);
                byte = CP_READ_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(OLD_TVP_SHIFT));
                byte &= ~TVP3026_D_CURSOR_MASK;
                byte |= TVP3026_D_CURSOR_OFF;
                CP_WRITE_REGISTER_BYTE(pjBase + TVP3026_INDEXED_DATA(OLD_TVP_SHIFT), byte);
            }

            // Cursor colors have been set by IOCTL_VIDEO_SET_CURRENT_MODE.
            // Our color palette will be set later, by the miniport.

            break;
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bEnablePointer
*
\**************************************************************************/

BOOL bEnablePointer(
PDEV*   ppdev)
{
    RAMDAC_INFO VideoPointerAttr;
    ULONG       ReturnedDataLength;

    // Query the MGA miniport about the hardware pointer, using a private
    // IOCTL:

    if (EngDeviceIoControl(ppdev->hDriver,
                         IOCTL_VIDEO_MTX_QUERY_RAMDAC_INFO,
                         NULL,                      // Input
                         0,
                         &VideoPointerAttr,
                         sizeof(RAMDAC_INFO),
                         &ReturnedDataLength))
    {
        DISPDBG((0, "bEnablePointer -- failed MTX_QUERY_RAMDAC_INFO"));
        return(FALSE);
    }

    ppdev->RamDacFlags           = VideoPointerAttr.Flags & RAMDAC_FIELDS;
    ppdev->szlPointerOverscan.cx = VideoPointerAttr.OverScanX;
    ppdev->szlPointerOverscan.cy = VideoPointerAttr.OverScanY;

    // Initialize the pointer:

    vAssertModePointer(ppdev, TRUE);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\precomp.h ===
/******************************Module*Header*******************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1994-1996 Microsoft Corporation
\**************************************************************************/

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>
#include <mcdrv.h>
#include <gl\gl.h>
#include <math.h>

#include "lines.h"
#include "debug.h"
#include "driver.h"
#include "hw.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\i386\hw.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: hw.inc
;
; All the hardware specific driver file stuff.  Mirrors some of 'hw.h'.
;
; Copyright (c) 1993-1995 Microsoft Corporation
;----------------------------------------------------------------------------;

; The following is used to define the MGA memory map.

; MGA map

SrcWin          equ 00000h
IntReg          equ 01c00h
DstWin          equ 02000h
ExtDev          equ 03c00h

; Internal registers

DwgReg          equ 00000h
StartDwgReg     equ 00100h
HstReg          equ 00200h
VgaReg          equ 00300h

; External devices

RamDac          equ 00000h
Dubic           equ 00080h
Viwic           equ 00100h
ClkGen          equ 00180h
ExpDev          equ 00200h

; TITAN registers

DWGCTL          equ 00000h
MACCESS         equ 00004h
MCTLWTST        equ 00008h
DST0            equ 00010h
DST1            equ 00014h
ZMSK            equ 00018h
PLNWT           equ 0001Ch
BCOL            equ 00020h
FCOL            equ 00024h
SRCBLT          equ 0002Ch
SRC0            equ 00030h
SRC1            equ 00034h
SRC2            equ 00038h
SRC3            equ 0003Ch
XYSTRT          equ 00040h
XYEND           equ 00044h
SHIFT           equ 00050h
SGN             equ 00058h
LEN             equ 0005Ch
AR0             equ 00060h
AR1             equ 00064h
AR2             equ 00068h
AR3             equ 0006Ch
AR4             equ 00070h
AR5             equ 00074h
AR6             equ 00078h
PITCH           equ 0008Ch
YDST            equ 00090h
YDSTORG         equ 00094h
CYTOP           equ 00098h
CYBOT           equ 0009Ch
CXLEFT          equ 000A0h
CXRIGHT         equ 000A4h
FXLEFT          equ 000A8h
FXRIGHT         equ 000ACh
XDST            equ 000B0h
ALU_DR0         equ 000C0h
ALU_DR1         equ 000C4h
ALU_DR2         equ 000C8h
ALU_DR3         equ 000CCh
ALU_DR4         equ 000D0h
ALU_DR5         equ 000D4h
ALU_DR6         equ 000D8h
ALU_DR7         equ 000DCh
ALU_DR8         equ 000E0h
ALU_DR9         equ 000E4h
ALU_DR10        equ 000E8h
ALU_DR11        equ 000ECh
ALU_DR12        equ 000F0h
ALU_DR13        equ 000F4h
ALU_DR14        equ 000F8h
ALU_DR15        equ 000FCh

; Host registers

SRCPAGE         equ 00000h
DSTPAGE         equ 00004h
BYTACCDATA      equ 00008h
ADRGEN          equ 0000Ch
FIFOSTATUS      equ 00010h
STATUS          equ 00014h
ICLEAR          equ 00018h
IEN             equ 0001Ch
RST             equ 00040h
TESTBIT         equ 00044h
REV             equ 00048h
CONFIG_REG      equ 00050h
OPMODE          equ 00054h
CRTC_CTRL       equ 0005Ch
VCOUNT          equ 00060h

; Bt485

BT485_PAL_OR_CURS_RAM_WRITE     equ 00000h
BT485_COLOR_PAL_DATA            equ 00004h
BT485_PIXEL_MASK                equ 00008h
BT485_PAL_OR_CURS_RAM_READ      equ 0000Ch
BT485_OVS_OR_CURS_COLOR_WRITE   equ 00010h
BT485_OVS_OR_CURS_COLOR_DATA    equ 00014h
BT485_COMMAND_0                 equ 00018h
BT485_OVS_OR_CURS_COLOR_READ    equ 0001Ch
BT485_COMMAND_1                 equ 00020h
BT485_COMMAND_2                 equ 00024h
BT485_COMMAND_3_OR_STATUS       equ 00028h
BT485_CURS_RAM_ARRAY            equ 0002Ch
BT485_CURS_X_LOW                equ 00030h
BT485_CURS_X_HIGH               equ 00034h
BT485_CURS_Y_LOW                equ 00038h
BT485_CURS_Y_HIGH               equ 0003Ch

; Bt482
BT482_PAL_OR_CURS_RAM_WRITE     equ 00000h
BT482_COLOR_PAL_DATA            equ 00004h
BT482_PIXEL_MASK                equ 00008h
BT482_PAL_OR_CURS_RAM_READ      equ 0000Ch
BT482_OVS_OR_CURS_COLOR_WRITE   equ 00010h
BT482_OVS_OR_CURS_COLOR_DATA    equ 00014h
BT482_COMMAND_A                 equ 00018h
BT482_OVS_OR_CURS_COLOR_READ    equ 0001Ch

; ViewPoint

VPOINT_PAL_ADDR_WRITE           equ 00000h
VPOINT_PAL_COLOR                equ 00004h
VPOINT_PIX_READ_MASK            equ 00008h
VPOINT_PAL_ADDR_READ            equ 0000ch
VPOINT_RESERVED_4               equ 00010h
VPOINT_RESERVED_5               equ 00014h
VPOINT_INDEX                    equ 00018h
VPOINT_DATA                     equ 0001ch

; Dubic

DUB_SEL         equ 00080h
NDX_PTR         equ 00081h
DUB_DATA        equ 00082h
LASER           equ 00083h
MOUSE0          equ 00084h
MOUSE1          equ 00085h
MOUSE2          equ 00086h
MOUSE3          equ 00087h

; Index within NDX_PTR to access the following registers through DUB_DATA

DUB_CTL     equ 000h
KEY_COL     equ 001h
KEY_MSK     equ 002h
DBX_MIN     equ 003h
DBX_MAX     equ 004h
DBY_MIN     equ 005h
DBY_MAX     equ 006h
OVS_COL     equ 007h
CUR_X       equ 008h
CUR_Y       equ 009h
DUB_CTL2    equ 00Ah
DUB_UnDef   equ 00Bh
CUR_COL0    equ 00Ch
CUR_COL1    equ 00Dh
CRC_CTL     equ 00Eh
CRC_DAT     equ 00Fh


; **************************************************************************
; Titan registers:  fields definitions

; DWGCTRL - Drawing Control Register

opcode_LINE_OPEN        equ 000000000h
opcode_AUTOLINE_OPEN    equ 000000001h
opcode_LINE_CLOSE       equ 000000002h
opcode_AUTOLINE_CLOSE   equ 000000003h
opcode_AUTO             equ 000000001h
opcode_TRAP             equ 000000004h
opcode_RESERVED_1       equ 000000005h
opcode_RESERVED_2       equ 000000006h
opcode_RESERVED_3       equ 000000007h
opcode_BITBLT           equ 000000008h
opcode_ILOAD            equ 000000009h
opcode_IDUMP            equ 00000000ah
opcode_RESERVED_4       equ 00000000bh
opcode_RESERVED_5       equ 00000000ch
opcode_RESERVED_6       equ 00000000dh
opcode_RESERVED_7       equ 00000000eh
opcode_RESERVED_8       equ 00000000fh

atype_RPL               equ 000000000h
atype_RSTR              equ 000000010h
atype_ANTI              equ 000000020h
atype_ZI                equ 000000030h

blockm_ON               equ 000000040h
blockm_OFF              equ 000000000h

linear_XY_BITBLT        equ 000000000h
linear_LINEAR_BITBLT    equ 000000080h

bop_BLACK               equ 000000000h  ; 0             0
bop_BLACKNESS           equ 000000000h  ; 0             0
bop_NOTMERGEPEN         equ 000010000h  ; DPon      ~(D | S)
bop_MASKNOTPEN          equ 000020000h  ; DPna       D & ~S
bop_NOTCOPYPEN          equ 000030000h  ; Pn        ~S
bop_MASKPENNOT          equ 000040000h  ; PDna      (~D) &  S
bop_NOT                 equ 000050000h  ; Dn        ~D
bop_XORPEN              equ 000060000h  ; DPx        D ^  S
bop_NOTMASKPEN          equ 000070000h  ; DPan      ~(D & S)
bop_MASKPEN             equ 000080000h  ; DPa         D &  S
bop_NOTXORPEN           equ 000090000h  ; DPxn       ~(D ^ S)
bop_NOP                 equ 0000a0000h  ; D           D
bop_MERGENOTPEN         equ 0000b0000h  ; DPno        D | ~S
bop_COPYPEN             equ 0000c0000h  ; P           S
bop_SRCCOPY             equ 0000c0000h  ; P           S
bop_MERGEPENNOT         equ 0000d0000h  ; PDno      (~D)| S
bop_MERGEPEN            equ 0000e0000h  ; DPo         D |  S
bop_WHITE               equ 0000f0000h  ; 1             1
bop_WHITENESS           equ 0000f0000h  ; 1             1

trans_0                 equ 000000000h
trans_1                 equ 000100000h
trans_2                 equ 000200000h
trans_3                 equ 000300000h
trans_4                 equ 000400000h
trans_5                 equ 000500000h
trans_6                 equ 000600000h
trans_7                 equ 000700000h
trans_8                 equ 000800000h
trans_9                 equ 000900000h
trans_10                equ 000a00000h
trans_11                equ 000b00000h
trans_12                equ 000c00000h
trans_13                equ 000d00000h
trans_14                equ 000e00000h
trans_15                equ 000f00000h

alphadit_FOREGROUND     equ 000000000h
alphadit_RED            equ 001000000h

bltmod_BMONO            equ 000000000h
bltmod_BPLAN            equ 002000000h
bltmod_BFCOL            equ 004000000h
bltmod_BUCOL            equ 006000000h

zdrwen_NO_DEPTH         equ 000000000h
zdrwen_DEPTH            equ 002000000h

zlte_LESS_THEN          equ 000000000h
zlte_LESS_THEN_OR_EQUAL equ 004000000h

afor_DATA_ALU           equ 000000000h
afor_FORE_COL           equ 008000000h

hbgr_SRC_RGB            equ 000000000h
hbgr_SRC_BGR            equ 008000000h
hbgr_SRC_EG3            equ 000000000h
hbgr_SRC_WINDOWS        equ 008000000h

abac_OLD_DATA           equ 000000000h
abac_BG_COLOR           equ 010000000h

hcprs_SRC_32_BPP        equ 000000000h
hcprs_SRC_24_BPP        equ 010000000h

pattern_OFF             equ 000000000h
pattern_ON              equ 020000000h

transc_BIT                      equ 0h  ; bit #30
transc_BG_OPAQUE        equ 000000000h
transc_BG_TRANSP        equ 040000000h

; MACCESS - Memory Access Register

pwidth_PW8              equ 000000000h
pwidth_PW16             equ 000000001h
pwidth_PW32             equ 000000002h
pwidth_RESERVED         equ 000000003h

fbc_SBUF                equ 000000000h
fbc_RESERVED            equ 000000004h
fbc_DBUFA               equ 000000008h
fbc_DBUFB               equ 00000000ch

; MCTLWTST - Memory Control Wait State Register

; DST0, DST1 - Destination in Register

; ZMASK - Z Mask Control Register

; PLNWT - Plane Write Mask

plnwt_MASK_8BPP         equ 0ffffffffh
plnwt_MASK_16BPP        equ 0ffffffffh
plnwt_MASK_24BPP        equ 000ffffffh
plnwt_ALL               equ 0ffffffffh
plnwt_FREE              equ 0ff000000h
plnwt_RED               equ 000ff0000h
plnwt_GREEN             equ 00000ff00h
plnwt_BLUE              equ 0000000ffh

; BCOL - Background Color

; FCOL - ForeGround Color

; SRCBLT - Source Register for Blit

; SRC0, SRC1, SRC2, SRC3 - Source Register

; XYSTART - X Y Start Address

; XYEND - X Y End Address

; SHIFT - Funnel Shifter Control Register

funoff_MASK             equ 0ffc0ffffh
funoff_RED_TO_FREE      equ 000380000h      ;  -8
funoff_GREEN_TO_FREE    equ 000300000h      ; -16
funoff_BLUE_TO_FREE     equ 000280000h      ; -24
funoff_FREE_TO_RED      equ 000080000h      ;   8
funoff_FREE_TO_GREEN    equ 000100000h      ;  16
funoff_FREE_TO_BLUE     equ 000180000h      ;  24

funoff_X_TO_FREE_STEP   equ 000080000h
funoff_FREE_TO_X_STEP   equ 000080000h

; SGN - Sign Register

sdydxl_MAJOR_Y          equ 000000000h
sdydxl_MAJOR_X          equ 000000001h
scanleft_LEFT           equ 000000001h
scanleft_RIGHT          equ 000000000h
sdxl_ADD                equ 000000000h
sdxl_SUB                equ 000000002h
sdy_ADD                 equ 000000000h
sdy_SUB                 equ 000000004h
sdxr_INC                equ 000000000h
sdxr_DEC                equ 000000020h
scanleft_LEFT_TO_RIGHT  equ 000000000h
scanleft_RIGHT_TO_LEFT  equ 000000001h
sdy_TOP_TO_BOTTOM       equ 000000000h
sdy_BOTTOM_TO_TOP       equ 000000004h

DRAWING_DIR_TBLR        equ y_TOP_TO_BOTTOM+scanleft_RIGHT  ; 0x00
DRAWING_DIR_TBRL        equ y_TOP_TO_BOTTOM+scanleft_LEFT   ; 0x01
DRAWING_DIR_BTLR        equ y_BOTTOM_TO_TOP+scanleft_RIGHT  ; 0x04
DRAWING_DIR_BTRL        equ y_BOTTOM_TO_TOP+scanleft_LEFT   ; 0x05

; LEN - length register

; AR0
ARX_BIT_MASK            equ 00001ffffh

; AR1

; AR2

; AR3

; AR4

; AR5

; AR6

; PITCH - Memory Pitch

iy_512                  equ 000000200h
iy_640                  equ 000000280h
iy_768                  equ 000000300h
iy_800                  equ 000000320h
iy_1024                 equ 000000400h
iy_1152                 equ 000000480h
iy_1280                 equ 000000500h
iy_1536                 equ 000000600h
iy_1600                 equ 000000640h
ylin_LINEARIZE          equ 000000000h
ylin_LINEARIZE_NOT      equ 000008000h
iy_MASK                 equ 000001fe0h

; YDST - Y Address Register

; YDSTORG - memory origin register

; YTOP - Clipper Y Top Boundary

; YBOT - Clipper Y Bottom Boundary

; CXLEFT - Clipper X Minimum Boundary

; CXRIGHT - Clipper X Maximum Boundary

; FXLEFT - X Address Register (Left)

; FXRIGHT - X Address Register (Right)

; XDST - X Destination Address Register

; DR0

; DR1

; DR2

; DR3

; DR4

; DR5

; DR6

; DR7

; DR8

; DR9

; DR10

; DR11

; DR12

; DR13

; DR14

; DR15

; **************************************************************************
; Host registers:  fields definitions

; SRCPAGE - Source Page Register

; DSTPAGE - Destination Page Register

; BYTEACCDATA - Byte Accumulator Data

; ADRGEN - Address Generator Register

; FIFOSTATUS - Bus FIFO Status Register

fifocount_MASK          equ 00000007fh
bfull_MASK              equ 000000100h
bempty_MASK             equ 000000200h
byteaccaddr_MASK        equ 0007f0000h
addrgenstate_MASK       equ 03f000000h

; STATUS - Status Register

bferrists_MASK          equ 000000001h
dmatcists_MASK          equ 000000002h
pickists_MASK           equ 000000004h
vsyncsts_MASK           equ 000000008h
byteflag_MASK           equ 000000f00h
dwgengsts_MASK          equ 000010000h

; ICLEAR - Interrupt Clear Register

bferriclr_OFF           equ 000000000h
bferriclr_ON            equ 000000001h
dmactciclr_OFF          equ 000000000h
dmactciclr_ON           equ 000000002h
pickiclr_OFF            equ 000000000h
pickiclr_ON             equ 000000004h

; IEN - Interrupt Enable Register

bferrien_OFF            equ 000000000h
bferrien_ON             equ 000000001h
dmactien_OFF            equ 000000000h
dmactien_ON             equ 000000002h
pickien_OFF             equ 000000000h
pickien_ON              equ 000000004h
vsyncien_OFF            equ 000000000h
vsyncien_ON             equ 000000008h

; RST - Reset Register

softreset               equ 000000001h

; TEST - Test Register

vgatest                 equ 000000001h
robitwren               equ 000000100h

; REV - Revision Register

; CONFIG_REG - Configuration Register

; OPMODE - Operating Mode Register

OPMODE_OTHER_INFO       equ 0fffffff0h
pseudodma_OFF           equ 000000000h
pseudodma_ON            equ 000000001h
dmaact_OFF              equ 000000000h
dmaact_ON               equ 000000002h
dmamod_GENERAL_PURPOSE  equ 000000000h
dmamod_BLIT_WRITE       equ 000000004h
dmamod_VECTOR_WRITE     equ 000000008h
dmamod_BLIT_READ        equ 00000000ch

; CRTC_CTRL - CRTC Control

; VCOUNT - VCOUNT Register

; COLOR PATTERN

PATTERN_PITCH           equ 0

; DMA

DMAWINSIZE              equ 1024 / 4       ; 7k in DWORDS

; FIFO

FIFOSIZE                equ 0
INTEL_PAGESIZE          equ 1024           ; 4k bytes per page
INTEL_PAGESIZE_DW       equ 1024/4         ; 1k dwords per page

; Accelerator flags

NO_CACHE            equ 0
SIGN_CACHE          equ 1   ; 1 is also the nb of registers affected
ARX_CACHE           equ 2
PATTERN_CACHE       equ 4   ; 4 is also the nb of registers affected


; MGA Rop definitions

MGA_BLACKNESS           equ 00000h      ; 0             0
MGA_NOTMERGEPEN         equ 00001h      ; DPon      ~(D | S)
MGA_MASKNOTPEN          equ 00002h      ; DPna       D & ~S
MGA_NOTCOPYPEN          equ 00003h      ; Pn        ~S
MGA_MASKPENNOT          equ 00004h      ; PDna      (~D) &  S
MGA_NOT                 equ 00005h      ; Dn        ~D
MGA_XORPEN              equ 00006h      ; DPx        D ^  S
MGA_NOTMASKPEN          equ 00007h      ; DPan      ~(D & S)
MGA_MASKPEN             equ 00008h      ; DPa         D &  S
MGA_NOTXORPEN           equ 00009h      ; DPxn       ~(D ^ S)
MGA_NOP                 equ 0000ah      ; D           D
MGA_MERGENOTPEN         equ 0000bh      ; DPno        D | ~S
MGA_SRCCOPY             equ 0000ch      ; P           S
MGA_MERGEPENNOT         equ 0000dh      ; PDno      (~D)| S
MGA_MERGEPEN            equ 0000eh      ; DPo         D |  S
MGA_WHITENESS           equ 0000fh      ; 1             1


; Special MCTLWTST value for IDUMPs

IDUMP_MCTLWTST          equ 0c4001000h


; **************************************************************************
; Explicit register offsets.

DMAWND                      equ SrcWin
SRCWND                      equ SrcWin
DSTWND                      equ DstWin

DWG_DWGCTL                  equ IntReg+DwgReg+DWGCTL
DWG_MACCESS                 equ IntReg+DwgReg+MACCESS
DWG_MCTLWTST                equ IntReg+DwgReg+MCTLWTST
DWG_DST0                    equ IntReg+DwgReg+DST0
DWG_DST1                    equ IntReg+DwgReg+DST1
DWG_ZMSK                    equ IntReg+DwgReg+ZMSK
DWG_PLNWT                   equ IntReg+DwgReg+PLNWT
DWG_BCOL                    equ IntReg+DwgReg+BCOL
DWG_FCOL                    equ IntReg+DwgReg+FCOL
DWG_SRCBLT                  equ IntReg+DwgReg+SRCBLT
DWG_SRC0                    equ IntReg+DwgReg+SRC0
DWG_SRC1                    equ IntReg+DwgReg+SRC1
DWG_SRC2                    equ IntReg+DwgReg+SRC2
DWG_SRC3                    equ IntReg+DwgReg+SRC3
DWG_XYSTRT                  equ IntReg+DwgReg+XYSTRT
DWG_XYEND                   equ IntReg+DwgReg+XYEND
DWG_SHIFT                   equ IntReg+DwgReg+SHIFT
DWG_SGN                     equ IntReg+DwgReg+SGN
DWG_LEN                     equ IntReg+DwgReg+LEN
DWG_AR0                     equ IntReg+DwgReg+AR0
DWG_AR1                     equ IntReg+DwgReg+AR1
DWG_AR2                     equ IntReg+DwgReg+AR2
DWG_AR3                     equ IntReg+DwgReg+AR3
DWG_AR4                     equ IntReg+DwgReg+AR4
DWG_AR5                     equ IntReg+DwgReg+AR5
DWG_AR6                     equ IntReg+DwgReg+AR6
DWG_PITCH                   equ IntReg+DwgReg+PITCH
DWG_YDST                    equ IntReg+DwgReg+YDST
DWG_YDSTORG                 equ IntReg+DwgReg+YDSTORG
DWG_CYTOP                   equ IntReg+DwgReg+CYTOP
DWG_CYBOT                   equ IntReg+DwgReg+CYBOT
DWG_CXLEFT                  equ IntReg+DwgReg+CXLEFT
DWG_CXRIGHT                 equ IntReg+DwgReg+CXRIGHT
DWG_FXLEFT                  equ IntReg+DwgReg+FXLEFT
DWG_FXRIGHT                 equ IntReg+DwgReg+FXRIGHT
DWG_XDST                    equ IntReg+DwgReg+XDST
DWG_DR0                     equ IntReg+DwgReg+DR0
DWG_DR1                     equ IntReg+DwgReg+DR1
DWG_DR2                     equ IntReg+DwgReg+DR2
DWG_DR3                     equ IntReg+DwgReg+DR3
DWG_DR4                     equ IntReg+DwgReg+DR4
DWG_DR5                     equ IntReg+DwgReg+DR5
DWG_DR6                     equ IntReg+DwgReg+DR6
DWG_DR7                     equ IntReg+DwgReg+DR7
DWG_DR8                     equ IntReg+DwgReg+DR8
DWG_DR9                     equ IntReg+DwgReg+DR9
DWG_DR10                    equ IntReg+DwgReg+DR10
DWG_DR11                    equ IntReg+DwgReg+DR11
DWG_DR12                    equ IntReg+DwgReg+DR12
DWG_DR13                    equ IntReg+DwgReg+DR13
DWG_DR14                    equ IntReg+DwgReg+DR14
DWG_DR15                    equ IntReg+DwgReg+DR15

HST_SRCPAGE                 equ IntReg+HstReg+SRCPAGE
HST_DSTPAGE                 equ IntReg+HstReg+DSTPAGE
HST_BYTACCDATA              equ IntReg+HstReg+BYTACCDATA
HST_ADRGEN                  equ IntReg+HstReg+ADRGEN
HST_FIFOSTATUS              equ IntReg+HstReg+FIFOSTATUS
HST_STATUS                  equ IntReg+HstReg+STATUS
HST_ICLEAR                  equ IntReg+HstReg+ICLEAR
HST_IEN                     equ IntReg+HstReg+IEN
HST_RST                     equ IntReg+HstReg+RST
HST_TEST                    equ IntReg+HstReg+TEST
HST_REV                     equ IntReg+HstReg+REV
HST_CONFIG_REG              equ IntReg+HstReg+CONFIG_REG
HST_OPMODE                  equ IntReg+HstReg+OPMODE
HST_CRTC_CTRL               equ IntReg+HstReg+CRTC_CTRL
HST_VCOUNT                  equ IntReg+HstReg+VCOUNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\strips.c ===
/******************************Module*Header*******************************\
* Module Name: Strips.c
*
* These are the line rendering routines of last resort, and are called
* by 'bLines' when a line is clipped or otherwise cannot be drawn
* directly by the hardware.
*
* We take advantage of the MGA's point-to-point vector drawing capability
* to draw the strips.  The MGA can automatically exclude the last pixel,
* which makes our routines a little simpler.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

/******************************Public*Routine******************************\
* VOID vStripSolidHorizontal
*
* Draws left-to-right x-major near-horizontal lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x, y));
        x += *pStrips++;
        CP_START(pjBase, DWG_XYEND, PACKXY(x, y));
        y += yDir;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vStripSolidVertical
*
* Draws left-to-right y-major near-vertical lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x, y));
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        CP_START(pjBase, DWG_XYEND, PACKXY(x, y));
        x++;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vStripSolidDiagonalHorizontal
*
* Draws left-to-right x-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidDiagonalHorizontal(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x, y));
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        CP_START(pjBase, DWG_XYEND, PACKXY(x, y));
        y -= yDir;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vStripSolidDiagonalVertical
*
* Draws left-to-right y-major near-diagonal lines using radial lines.
*
\**************************************************************************/

VOID vStripSolidDiagonalVertical(
PDEV*       ppdev,
STRIP*      pStrip,
LINESTATE*  pLineState)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    yDir;
    LONG*   pStrips;
    LONG    cStrips;
    LONG    i;

    pjBase = ppdev->pjBase;

    x = pStrip->ptlStart.x + ppdev->xOffset;
    y = pStrip->ptlStart.y + ppdev->yOffset;

    yDir    = (pStrip->flFlips & FL_FLIP_V) ? -1 : 1;
    pStrips = pStrip->alStrips;
    cStrips = pStrip->cStrips;

    for (i = cStrips; i != 0; i--)
    {
        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x, y));
        x += *pStrips;
        y += (yDir > 0) ? *pStrips : -*pStrips;
        pStrips++;
        CP_START(pjBase, DWG_XYEND, PACKXY(x, y));
        x--;
    }

    pStrip->ptlStart.x = x - ppdev->xOffset;
    pStrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vStripStyledHorizontal
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles x-major lines that run left-to-right,
* and are comprised of horizontal strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledHorizontal(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjBase = ppdev->pjBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 90 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 270 degrees, and the major
        // direction is 0 (it's a left-to-right x-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x + ppdev->xOffset;
                                    // x position of start of first strip
    y       = pstrip->ptlStart.y + ppdev->yOffset;
                                    // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        x += cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new scan and need a new strip:

        y += dy;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x, y));
        x += cThis;
        CP_START(pjBase, DWG_XYEND, PACKXY(x, y));

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->xOffset;
    pstrip->ptlStart.y = y - ppdev->yOffset;
}

/******************************Public*Routine******************************\
* VOID vStripStyledVertical
*
* Takes the list of strips that define the pixels that would be lit for
* a solid line, and breaks them into styling chunks according to the
* styling information that is passed in.
*
* This particular routine handles y-major lines that run left-to-right,
* and are comprised of vertical strips.  It draws the dashes using
* short-stroke vectors.
*
* The performance of this routine could be improved significantly if
* anyone cared enough about styled lines improve it.
*
\**************************************************************************/

VOID vStripStyledVertical(
PDEV*       ppdev,
STRIP*      pstrip,
LINESTATE*  pls)
{
    BYTE*   pjBase;
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;

    pjBase = ppdev->pjBase;

    if (pstrip->flFlips & FL_FLIP_V)
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 90 (it's a left-to-right y-major line going up):

        dy = -1;
    }
    else
    {
        // The minor direction of the line is 0 degrees, and the major
        // direction is 270 (it's a left-to-right y-major line going down):

        dy = 1;
    }

    cStrips = pstrip->cStrips;      // Total number of strips we'll do
    plStrip = pstrip->alStrips;     // Points to current strip
    x       = pstrip->ptlStart.x + ppdev->xOffset;
                                    // x position of start of first strip
    y       = pstrip->ptlStart.y + ppdev->yOffset;
                                    // y position of start of first strip

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pls->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pls->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if (bIsGap)
        goto SkipAGap;
    else
        goto OutputADash;

PrepareToSkipAGap:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip:

    if (cStrip != 0)
        goto SkipAGap;

    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if (cStyle == 0)
            goto PrepareToOutputADash;
    }

PrepareToOutputADash:

    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:

    bIsGap = ~bIsGap;
    pls->psp++;
    if (pls->psp > pls->pspEnd)
        pls->psp = pls->pspStart;

    cStyle = *pls->psp;

    // If 'cStrip' is zero, we also need a new strip.

    if (cStrip != 0)
    {
        // There's more to be done in the current strip:

        goto OutputADash;
    }

    // We've finished with the current strip:

    while (TRUE)
    {
        // Each time we loop, we move to a new column and need a new strip:

        x++;

        plStrip++;
        cStrips--;
        if (cStrips == 0)
            goto AllDone;

        cStrip = *plStrip;

    OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_XYSTRT, PACKXY(x, y));
        y += (dy > 0) ? cThis : -cThis;
        CP_START(pjBase, DWG_XYEND, PACKXY(x, y));

        if (cStyle == 0)
            goto PrepareToSkipAGap;
    }

AllDone:

    // Update our state variables so that the next line can continue
    // where we left off:

    pls->spRemaining   = cStyle;
    pls->ulStyleMask   = bIsGap;
    pstrip->ptlStart.x = x - ppdev->xOffset;
    pstrip->ptlStart.y = y - ppdev->yOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Copyright (c) 1993-1996 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"

#define STRETCH_MAX_EXTENT 32767

typedef DWORDLONG ULONGLONG;

/******************************Public*Routine******************************\
* VOID vMgaDirectStretch8Narrow
*
* Hardware assisted stretchblt at 8bpp when the width is 7 or less, for
* old MGAs.
*
\**************************************************************************/

VOID vMgaDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    ULONG   ulDstScan;
    BYTE*   pjDstScan;

    PDEV*   ppdev       = pStrBlt->ppdev;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    yDst        = pStrBlt->YDstStart;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    ulDstScan = ppdev->ulYDstOrg + (yDst + ppdev->yOffset) * ppdev->cxMemory
                                 + (xDst + ppdev->xOffset);

    pjDstScan = ppdev->pjBase + SRCWND + (ulDstScan & 31);

    // We can't touch the frame buffer while the accelerator is doing
    // any drawing:

    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
    WAIT_NOT_BUSY(pjBase);

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDst;
        BYTE*  pjDstEndNarrow;

        CP_WRITE_REGISTER(pjBase + HST_DSTPAGE, ulDstScan);
        ulDstScan += ppdev->cxMemory;       // Increment to next scan

        pjDst   = pjDstScan;
        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        pjDstEndNarrow = pjDst + WidthX;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;

    } while (--yCount);
}

/******************************Public*Routine******************************\
* VOID vMilDirectStretch8Narrow
*
* Hardware assisted stretchblt at 8bpp when the width is 7 or less, for
* Millenniums.
*
\**************************************************************************/

VOID vMilDirectStretch8Narrow(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    ULONG   ulDstScan;
    BYTE*   pjDstScan;

    PDEV*   ppdev       = pStrBlt->ppdev;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    yDst        = pStrBlt->YDstStart;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    ULONG   yInt        = 0;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    ulDstScan = ppdev->ulYDstOrg + (yDst + ppdev->yOffset) * ppdev->cxMemory
                                 + (xDst + ppdev->xOffset);

    pjDstScan = ppdev->pjScreen;

    // We can't touch the frame buffer while the accelerator is doing
    // any drawing:

    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
    WAIT_NOT_BUSY(pjBase);

    do {

        ULONG  yTmp = yAccum + yFrac;
        BYTE   jSrc0;
        BYTE*  pjDst;
        BYTE*  pjDstEndNarrow;

        pjDst   = pjDstScan + ulDstScan;
        ulDstScan += ppdev->cxMemory;       // Increment to next scan

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        pjDstEndNarrow = pjDst + WidthX;

        do {
            jSrc0    = *pjSrc;
            xTmp     = xAccum + xFrac;
            pjSrc    = pjSrc + xInt + (xTmp < xAccum);
            *pjDst++ = jSrc0;
            xAccum   = xTmp;
        } while (pjDst != pjDstEndNarrow);

        pjSrcScan += yInt;

        if (yTmp < yAccum)
        {
            pjSrcScan += pStrBlt->lDeltaSrc;
        }

        yAccum = yTmp;

    } while (--yCount);
}

/******************************Public*Routine******************************\
* VOID vMilDirectStretch8
*
* Hardware assisted stretchblt at 8bpp when the width is 8 or more,
* for Millenniums.
*
\**************************************************************************/

VOID vMilDirectStretch8(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    BYTE*   pjDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    BYTE*   pjOldScan;
    LONG    cyDuplicate;
    LONG    xDuplicate;
    LONG    yDuplicate;
    LONG    lDuplicate;
    ULONG   yInt;

    PDEV*   ppdev       = pStrBlt->ppdev;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    cxMemory    = ppdev->cxMemory;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc;
    BYTE*   pjDst       = pStrBlt->pjDstScan + xDst;
    LONG    yDst        = pStrBlt->YDstStart;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = (ULONG)((ULONG_PTR)pjDst & 0x03);
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)((ULONG_PTR)(pjDst + WidthX) & 0x03);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - WidthX;
    LONG    lDeltaDst   = pStrBlt->lDeltaDst;
    LONG    lDeltaSrc   = pStrBlt->lDeltaSrc;

    WidthXAln = WidthX - EndAln - ((- (LONG) StartAln) & 0x03);

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    yDuplicate = yDst + ppdev->yOffset - 1;
    xDuplicate = xDst + ppdev->xOffset + ppdev->ulYDstOrg;

    START_DIRECT_ACCESS_STORM(ppdev, pjBase);

    do {
        BYTE    jSrc0,jSrc1,jSrc2,jSrc3;
        ULONG   yTmp;

        pjSrc   = pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        switch (StartAln) {
        case 1:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        }

        pjDstEnd  = pjDst + WidthXAln;

        while (pjDst != pjDstEnd)
        {
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            jSrc1 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt;
            if (xAccum < xTmp)
                pjSrc++;

            jSrc2 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            jSrc3 = *pjSrc;
            xAccum = xTmp + xFrac;
            pjSrc = pjSrc + xInt;
            if (xAccum < xTmp)
                pjSrc++;

            ulDst = (jSrc3 << 24) | (jSrc2 << 16) | (jSrc1 << 8) | jSrc0;

            *(PULONG)pjDst = ulDst;
            pjDst += 4;
        }

        switch (EndAln) {
        case 3:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 2:
            jSrc0 = *pjSrc;
            xTmp = xAccum + xFrac;
            pjSrc = pjSrc + xInt;
            if (xTmp < xAccum)
                pjSrc++;

            *pjDst++ = jSrc0;
            xAccum = xTmp;
        case 1:
            jSrc0 = *pjSrc;
            *pjDst++ = jSrc0;
        }

        // Now count the number of duplicate scans:

        pjDst += lDstStride;
        yDuplicate++;
        cyDuplicate = -1;
        pjOldScan = pjSrcScan;
        do {
            cyDuplicate++;
            pjSrcScan += yInt;

            yTmp = yAccum + yFrac;
            if (yTmp < yAccum)
            {
                pjSrcScan += lDeltaSrc;
            }
            yAccum = yTmp;
            yCount--;

        } while ((yCount != 0) && (pjSrcScan == pjOldScan));

        // Duplicate the scan 'cyDuplicate' times with one blt:

        if (cyDuplicate != 0)
        {
            lDuplicate = yDuplicate * cxMemory + xDuplicate;

            CHECK_FIFO_SPACE(pjBase, 4);
            CP_WRITE(pjBase, DWG_AR3, lDuplicate);
            CP_WRITE(pjBase, DWG_AR0, lDuplicate + WidthX - 1);
            CP_WRITE(pjBase, DWG_DWGCTL, opcode_BITBLT      |
                                         atype_RPL          |
                                         blockm_OFF         |
                                         bltmod_BFCOL       |
                                         pattern_OFF        |
                                         transc_BG_OPAQUE   |
                                         bop_SRCCOPY        |
                                         shftzero_ZERO      |
                                         sgnzero_ZERO);
            CP_START(pjBase, DWG_YDSTLEN, ((yDuplicate + 1) << yval_SHIFT) |
                                          cyDuplicate);

            yDuplicate += cyDuplicate;
            pjDst += cyDuplicate * lDeltaDst;
        }
    } while (yCount != 0);

    END_DIRECT_ACCESS_STORM(ppdev, pjBase);
}

/******************************Public*Routine******************************\
* VOID vMilDirectStretch16
*
* Hardware assisted stretchblt at 16bpp, for Millenniums.
*
\**************************************************************************/

VOID vMilDirectStretch16(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    USHORT* pusSrc;
    USHORT* pusDstEnd;
    LONG    WidthXAln;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;
    LONG    xDuplicate;
    LONG    yDuplicate;
    LONG    lDuplicate;
    LONG    yInt;

    PDEV*   ppdev       = pStrBlt->ppdev;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    cxMemory    = ppdev->cxMemory;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = (pStrBlt->pjSrcScan) + xSrc * 2;
    USHORT* pusDst      = (USHORT*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart;
    LONG    yCount      = pStrBlt->YDstCount;
    ULONG   StartAln    = ((ULONG)((ULONG_PTR)pusDst & 0x02)) >> 1;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   EndAln      = (ULONG)(((ULONG_PTR)(pusDst + WidthX) & 0x02) >> 1);
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 2 * WidthX;
    LONG    lDeltaDst   = pStrBlt->lDeltaDst;
    LONG    lDeltaSrc   = pStrBlt->lDeltaSrc;

    WidthXAln = WidthX - EndAln - StartAln;

    yInt = pStrBlt->lDeltaSrc * (LONG)(pStrBlt->ulYDstToSrcIntCeil);

    yDuplicate = yDst + ppdev->yOffset - 1;
    xDuplicate = xDst + ppdev->xOffset + ppdev->ulYDstOrg;

    START_DIRECT_ACCESS_STORM(ppdev, pjBase);

    // Loop stretching each scan line

    do {
        USHORT  usSrc0,usSrc1;
        ULONG   yTmp;

        pusSrc  = (USHORT*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        if (StartAln)
        {
            usSrc0    = *pusSrc;
            xTmp      = xAccum + xFrac;
            pusSrc    = pusSrc + xInt;
            if (xTmp < xAccum)
                pusSrc++;

            *pusDst++ = usSrc0;
            xAccum    = xTmp;
        }

        pusDstEnd = pusDst + WidthXAln;

        while (pusDst != pusDstEnd)
        {
            usSrc0 = *pusSrc;
            xTmp   = xAccum + xFrac;
            pusSrc = pusSrc + xInt;
            if (xTmp < xAccum)
                pusSrc++;

            usSrc1 = *pusSrc;
            xAccum = xTmp + xFrac;
            pusSrc = pusSrc + xInt;
            if (xAccum < xTmp)
                pusSrc++;

            ulDst = (ULONG)((usSrc1 << 16) | usSrc0);

            *(ULONG*)pusDst = ulDst;
            pusDst+=2;
        }

        if (EndAln)
        {
            usSrc0    = *pusSrc;
            *pusDst++ = usSrc0;
        }

        // Now count the number of duplicate scans:

        pusDst = (USHORT*) ((BYTE*) pusDst + lDstStride);
        yDuplicate++;
        cyDuplicate = -1;
        pjOldScan = pjSrcScan;
        do {
            cyDuplicate++;
            pjSrcScan += yInt;

            yTmp = yAccum + yFrac;
            if (yTmp < yAccum)
            {
                pjSrcScan += lDeltaSrc;
            }
            yAccum = yTmp;
            yCount--;

        } while ((yCount != 0) && (pjSrcScan == pjOldScan));

        // Duplicate the scan 'cyDuplicate' times with one blt:

        if (cyDuplicate != 0)
        {
            lDuplicate = yDuplicate * cxMemory + xDuplicate;

            CHECK_FIFO_SPACE(pjBase, 4);
            CP_WRITE(pjBase, DWG_AR3, lDuplicate);
            CP_WRITE(pjBase, DWG_AR0, lDuplicate + WidthX - 1);
            CP_WRITE(pjBase, DWG_DWGCTL, opcode_BITBLT      |
                                         atype_RPL          |
                                         blockm_OFF         |
                                         bltmod_BFCOL       |
                                         pattern_OFF        |
                                         transc_BG_OPAQUE   |
                                         bop_SRCCOPY        |
                                         shftzero_ZERO      |
                                         sgnzero_ZERO);
            CP_START(pjBase, DWG_YDSTLEN, ((yDuplicate + 1) << yval_SHIFT) |
                                          cyDuplicate);

            yDuplicate += cyDuplicate;
            pusDst = (USHORT*) ((BYTE*) pusDst + cyDuplicate * lDeltaDst);
        }
    } while (yCount != 0);

    END_DIRECT_ACCESS_STORM(ppdev, pjBase);
}

/******************************Public*Routine******************************\
* VOID vMilDirectStretch24
*
* Hardware assisted stretchblt at 24bpp, for Millenniums.
*
* We use the data-transfer register so that we don't have to worry about
* funky alignments.
*
\**************************************************************************/

VOID vMilDirectStretch24(
STR_BLT* pStrBlt)
{
    BYTE*   pjSrc;
    LONG    lAddress;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    i;
    LONG    cyDuplicate;
    LONG    xDuplicate;
    LONG    yDuplicate;
    LONG    lDuplicate;
    BYTE*   pjOldScan;
    LONG    xDstLeft;
    LONG    xDstRight;
    LONG    xDstRightFast;
    LONG    yDstTop;
    LONG    cyBreak;
    LONG    iBreak;

    PDEV*   ppdev       = pStrBlt->ppdev;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    cxMemory    = ppdev->cxMemory;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + pStrBlt->XSrcStart * 3;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - pStrBlt->XDstStart;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil * 3;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDeltaSrc   = pStrBlt->lDeltaSrc;
    ULONG   yInt        = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    ULONG   ulXFracAccumulator = pStrBlt->ulXFracAccumulator;

    yDstTop       = ppdev->yOffset + pStrBlt->YDstStart;
    xDstLeft      = ppdev->xOffset + pStrBlt->XDstStart;
    xDstRight     = ppdev->xOffset + pStrBlt->XDstEnd - 1;  // Note inclusive
    xDstRightFast = (((xDstRight * 3) + 2) | 0x40) / 3;

    // Figure out how many scans we can duplicate before we hit the first
    // WRAM boundary:

    cyBreak = 0xffff;
    for (iBreak = 0; iBreak < ppdev->cyBreak; iBreak++)
    {
        if (ppdev->ayBreak[iBreak] >= yDstTop)
        {
            cyBreak = ppdev->ayBreak[iBreak] - yDstTop;
            break;
        }
    }

    ppdev->HopeFlags = SIGN_CACHE;

    CHECK_FIFO_SPACE(pjBase, 6);

    CP_WRITE(pjBase, DWG_FXBNDRY, (xDstRight  << bfxright_SHIFT) | xDstLeft);
    CP_WRITE(pjBase, DWG_AR5,     cxMemory);
    CP_WRITE(pjBase, DWG_AR3,     0);
    CP_WRITE(pjBase, DWG_AR0,     WidthX - 1);
    CP_WRITE(pjBase, DWG_YDST,    yDstTop);
    CP_WRITE(pjBase, DWG_CXRIGHT, xDstRight);   // For fast-blt work-around

    yDuplicate = yDstTop - 1;
    xDuplicate = xDstLeft + ppdev->ulYDstOrg;

    do {
        CHECK_FIFO_SPACE(pjBase, 2);

        CP_WRITE(pjBase, DWG_DWGCTL, opcode_ILOAD     |
                                     atype_RPL        |
                                     blockm_OFF       |
                                     pattern_OFF      |
                                     transc_BG_OPAQUE |
                                     bop_SRCCOPY      |
                                     bltmod_BFCOL     |
                                     shftzero_ZERO    |
                                     sgnzero_ZERO);
        CP_START(pjBase, DWG_LEN, 1);

        // Make sure the MGA is ready to take the data:

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

        pjSrc  = pjSrcScan;
        xAccum = ulXFracAccumulator;

        i = WidthX;
        while (TRUE)
        {
            ulDst  = *(pjSrc);              // Pixel 0
            ulDst |= *(pjSrc + 1) << 8;
            ulDst |= *(pjSrc + 2) << 16;
            if (--i == 0)
                break;
            pjSrc += xInt;
            xTmp   = xAccum + xFrac;
            if (xTmp < xAccum)
                pjSrc += 3;

            ulDst |= *(pjSrc) << 24;        // Pixel 1
            CP_WRITE_SRC(pjBase, ulDst);
            ulDst  = *(pjSrc + 1);
            ulDst |= *(pjSrc + 2) << 8;
            if (--i == 0)
                break;
            pjSrc += xInt;
            xAccum = xTmp + xFrac;
            if (xAccum < xTmp)
                pjSrc += 3;

            ulDst |= *(pjSrc) << 16;        // Pixel 2
            ulDst |= *(pjSrc + 1) << 24;
            CP_WRITE_SRC(pjBase, ulDst);
            ulDst  = *(pjSrc + 2);
            if (--i == 0)
                break;
            pjSrc += xInt;
            xTmp   = xAccum + xFrac;
            if (xTmp < xAccum)
                pjSrc += 3;

            ulDst |= *(pjSrc) << 8;         // Pixel 3
            ulDst |= *(pjSrc + 1) << 16;
            ulDst |= *(pjSrc + 2) << 24;
            if (--i == 0)
                break;
            CP_WRITE_SRC(pjBase, ulDst);
            pjSrc += xInt;
            xAccum = xTmp + xFrac;
            if (xAccum < xTmp)
                pjSrc += 3;
        }

        // Write out the remainder of the scan:

        CP_WRITE_SRC(pjBase, ulDst);

        // Now count the number of duplicate scans:

        cyBreak--;
        yDuplicate++;
        cyDuplicate = -1;
        pjOldScan = pjSrcScan;
        do {
            cyDuplicate++;
            pjSrcScan += yInt;

            yTmp = yAccum + yFrac;
            if (yTmp < yAccum)
            {
                pjSrcScan += lDeltaSrc;
            }
            yAccum = yTmp;
            yCount--;

        } while ((yCount != 0) && (pjSrcScan == pjOldScan));

        // Duplicate the scan 'cyDuplicate' times with one blt:

        if (cyDuplicate != 0)
        {
            lDuplicate = (yDuplicate * cxMemory) + xDuplicate;
            yDuplicate += cyDuplicate;

            CHECK_FIFO_SPACE(pjBase, 8);
            CP_WRITE(pjBase, DWG_AR3, lDuplicate);
            CP_WRITE(pjBase, DWG_AR0, lDuplicate + WidthX - 1);

            cyBreak -= cyDuplicate;
            if (cyBreak >= 0)
            {
                // We haven't crossed a WRAM boundary, so we can use a
                // WRAM-WRAM blt to duplicate the scan:

                CP_WRITE(pjBase, DWG_DWGCTL,  opcode_FBITBLT     |
                                              atype_RPL          |
                                              blockm_OFF         |
                                              bltmod_BFCOL       |
                                              pattern_OFF        |
                                              transc_BG_OPAQUE   |
                                              bop_NOP            |
                                              shftzero_ZERO      |
                                              sgnzero_ZERO);
                CP_WRITE(pjBase, DWG_FXRIGHT, xDstRightFast);
                CP_START(pjBase, DWG_LEN,     cyDuplicate);
                CP_WRITE(pjBase, DWG_FXRIGHT, xDstRight);
            }
            else
            {
                CP_WRITE(pjBase, DWG_DWGCTL, opcode_BITBLT      |
                                             atype_RPL          |
                                             blockm_OFF         |
                                             bltmod_BFCOL       |
                                             pattern_OFF        |
                                             transc_BG_OPAQUE   |
                                             bop_SRCCOPY        |
                                             shftzero_ZERO      |
                                             sgnzero_ZERO);
                CP_START(pjBase, DWG_LEN, cyDuplicate);

                iBreak++;
                if (iBreak >= ppdev->cyBreak)
                {
                    // That was the last break we have to worry about:

                    cyBreak = 0xffff;
                }
                else
                {
                    cyBreak += ppdev->ayBreak[iBreak]
                             - ppdev->ayBreak[iBreak - 1];
                }
            }

            CP_WRITE(pjBase, DWG_AR3, 0);
            CP_WRITE(pjBase, DWG_AR0, WidthX - 1);
        }
    } while (yCount != 0);

    CHECK_FIFO_SPACE(pjBase, 1);
    CP_WRITE(pjBase, DWG_CXRIGHT, ppdev->cxMemory - 1);
}

/******************************Public*Routine******************************\
* VOID vMilDirectStretch32
*
* Hardware assisted stretchblt at 32bpp, for Millenniums.
*
\**************************************************************************/

VOID vMilDirectStretch32(
STR_BLT* pStrBlt)
{
    BYTE*   pjOldScan;
    ULONG*  pulSrc;
    ULONG*  pulDstEnd;
    ULONG   ulDst;
    ULONG   xAccum;
    ULONG   xTmp;
    ULONG   yTmp;
    LONG    cyDuplicate;
    LONG    xDuplicate;
    LONG    yDuplicate;
    LONG    lDuplicate;
    ULONG   yInt;

    PDEV*   ppdev       = pStrBlt->ppdev;
    BYTE*   pjBase      = ppdev->pjBase;
    LONG    cxMemory    = ppdev->cxMemory;
    LONG    xDst        = pStrBlt->XDstStart;
    LONG    xSrc        = pStrBlt->XSrcStart;
    BYTE*   pjSrcScan   = pStrBlt->pjSrcScan + xSrc * 4;
    ULONG*  pulDst      = (ULONG*)(pStrBlt->pjDstScan) + xDst;
    LONG    yDst        = pStrBlt->YDstStart;
    LONG    yCount      = pStrBlt->YDstCount;
    LONG    WidthX      = pStrBlt->XDstEnd - xDst;
    ULONG   xInt        = pStrBlt->ulXDstToSrcIntCeil;
    ULONG   xFrac       = pStrBlt->ulXDstToSrcFracCeil;
    ULONG   yAccum      = pStrBlt->ulYFracAccumulator;
    ULONG   yFrac       = pStrBlt->ulYDstToSrcFracCeil;
    LONG    lDstStride  = pStrBlt->lDeltaDst - 4*WidthX;
    LONG    lDeltaDst   = pStrBlt->lDeltaDst;
    LONG    lDeltaSrc   = pStrBlt->lDeltaSrc;

    yInt = pStrBlt->lDeltaSrc * pStrBlt->ulYDstToSrcIntCeil;

    yDuplicate = yDst + ppdev->yOffset - 1;
    xDuplicate = xDst + ppdev->xOffset + ppdev->ulYDstOrg;

    START_DIRECT_ACCESS_STORM(ppdev, pjBase);

    do {
        ULONG   ulSrc;
        ULONG   yTmp;

        pulSrc  = (ULONG*) pjSrcScan;
        xAccum  = pStrBlt->ulXFracAccumulator;

        pulDstEnd  = pulDst + WidthX;

        while (pulDst != pulDstEnd)
        {
            ulSrc  = *pulSrc;
            xTmp   = xAccum + xFrac;
            pulSrc = pulSrc + xInt;
            if (xTmp < xAccum)
                pulSrc++;

            *(ULONG*)pulDst = ulSrc;
            pulDst++;
            xAccum = xTmp;
        }

        // Now count the number of duplicate scans:

        pulDst = (ULONG*) ((BYTE*) pulDst + lDstStride);
        yDuplicate++;
        cyDuplicate = -1;
        pjOldScan = pjSrcScan;
        do {
            cyDuplicate++;
            pjSrcScan += yInt;

            yTmp = yAccum + yFrac;
            if (yTmp < yAccum)
            {
                pjSrcScan += lDeltaSrc;
            }
            yAccum = yTmp;
            yCount--;

        } while ((yCount != 0) && (pjSrcScan == pjOldScan));

        // Duplicate the scan 'cyDuplicate' times with one blt:

        if (cyDuplicate != 0)
        {
            lDuplicate = yDuplicate * cxMemory + xDuplicate;

            CHECK_FIFO_SPACE(pjBase, 4);
            CP_WRITE(pjBase, DWG_AR3, lDuplicate);
            CP_WRITE(pjBase, DWG_AR0, lDuplicate + WidthX - 1);
            CP_WRITE(pjBase, DWG_DWGCTL, opcode_BITBLT      |
                                         atype_RPL          |
                                         blockm_OFF         |
                                         bltmod_BFCOL       |
                                         pattern_OFF        |
                                         transc_BG_OPAQUE   |
                                         bop_SRCCOPY        |
                                         shftzero_ZERO      |
                                         sgnzero_ZERO);
            CP_START(pjBase, DWG_YDSTLEN, ((yDuplicate + 1) << yval_SHIFT) |
                                          cyDuplicate);

            yDuplicate += cyDuplicate;
            pulDst = (ULONG*) ((BYTE*) pulDst + cyDuplicate * lDeltaDst);
        }
    } while (yCount != 0);

    END_DIRECT_ACCESS_STORM(ppdev, pjBase);
}

/******************************Public*Routine******************************\
*
* Routine Description:
*
*   StretchBlt using integer math. Must be from one surface to another
*   surface of the same format.
*
* Arguments:
*
*   ppdev           -   PDEV for device
*   prclDst         -   Pointer to rectangle of Dst extents
*   pvSrc           -   Pointer to start of Src bitmap
*   lDeltaSrc       -   Bytes from start of Src scan line to start of next
*   prclSrc         -   Pointer to rectangle of Src extents
*   prclClip        -   Clip Dest to this rect
*
* Return Value:
*
*   Status
*
\**************************************************************************/

VOID vStretchDIB(
PDEV*   ppdev,
RECTL*  prclDst,
VOID*   pvSrc,
LONG    lDeltaSrc,
RECTL*  prclSrc,
RECTL*  prclClip)
{
    STR_BLT StrBlt;
    ULONG   XSrcToDstIntFloor;
    ULONG   XSrcToDstFracFloor;
    ULONG   ulXDstToSrcIntCeil;
    ULONG   ulXDstToSrcFracCeil;
    ULONG   YSrcToDstIntFloor;
    ULONG   YSrcToDstFracFloor;
    ULONG   ulYDstToSrcIntCeil;
    ULONG   ulYDstToSrcFracCeil;
    LONG    SrcIntScan;
    LONG    DstDeltaScanEnd;
    ULONG   ulXFracAccumulator;
    ULONG   ulYFracAccumulator;
    LONG    LeftClipDistance;
    LONG    TopClipDistance;
    BOOL    bStretch;

    union {
        LARGE_INTEGER   large;
        ULONGLONG       li;
    } liInit;

    PFN_DIRSTRETCH      pfnStr;

    //
    // Calculate exclusive start and end points:
    //

    LONG    WidthDst  = prclDst->right  - prclDst->left;
    LONG    HeightDst = prclDst->bottom - prclDst->top;
    LONG    WidthSrc  = prclSrc->right  - prclSrc->left;
    LONG    HeightSrc = prclSrc->bottom - prclSrc->top;

    LONG    XSrcStart = prclSrc->left;
    LONG    XSrcEnd   = prclSrc->right;
    LONG    XDstStart = prclDst->left;
    LONG    XDstEnd   = prclDst->right;
    LONG    YSrcStart = prclSrc->top;
    LONG    YSrcEnd   = prclSrc->bottom;
    LONG    YDstStart = prclDst->top;
    LONG    YDstEnd   = prclDst->bottom;

    //
    // Validate parameters:
    //

    ASSERTDD(pvSrc != (VOID*)NULL, "Bad source bitmap pointer");
    ASSERTDD(prclDst != (RECTL*)NULL, "Bad destination rectangle");
    ASSERTDD(prclSrc != (RECTL*)NULL, "Bad source rectangle");
    ASSERTDD((WidthDst > 0) && (HeightDst > 0) &&
             (WidthSrc > 0) && (HeightSrc > 0),
             "Can't do mirroring or empty rectangles here");
    ASSERTDD((WidthDst  <= STRETCH_MAX_EXTENT) &&
             (HeightDst <= STRETCH_MAX_EXTENT) &&
             (WidthSrc  <= STRETCH_MAX_EXTENT) &&
             (HeightSrc <= STRETCH_MAX_EXTENT), "Stretch exceeds limits");
    ASSERTDD(prclClip != NULL, "Bad clip rectangle");

    //
    // Calculate X Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*WidthSrc)/WidthDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*WidthSrc -1) / WidthDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liWidthSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = WidthSrc - 1;
        liWidthSrc = liInit.li;

        liQuo = liWidthSrc / (ULONGLONG) WidthDst;

        ulXDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulXDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulXDstToSrcFracCeil + 1;

        ulXDstToSrcIntCeil += (ulTemp < ulXDstToSrcFracCeil);
        ulXDstToSrcFracCeil = ulTemp;
    }

    //
    // Calculate Y Dst to Src mapping
    //
    //
    // dst->src =  ( CEIL( (2k*HeightSrc)/HeightDst) ) / 2k
    //
    //          =  ( FLOOR(  (2k*HeightSrc -1) / HeightDst) + 1) / 2k
    //
    // where 2k = 2 ^ 32
    //

    {
        ULONGLONG   liHeightSrc;
        ULONGLONG   liQuo;
        ULONG       ulTemp;

        //
        // Work around a compiler bug dealing with the assignment
        // 'liHeightSrc = (((LONGLONG)HeightSrc) << 32) - 1':
        //

        liInit.large.LowPart = (ULONG) -1;
        liInit.large.HighPart = HeightSrc - 1;
        liHeightSrc = liInit.li;

        liQuo = liHeightSrc / (ULONGLONG) HeightDst;

        ulYDstToSrcIntCeil  = (ULONG)(liQuo >> 32);
        ulYDstToSrcFracCeil = (ULONG)liQuo;

        //
        // Now add 1, use fake carry:
        //

        ulTemp = ulYDstToSrcFracCeil + 1;

        ulYDstToSrcIntCeil += (ulTemp < ulYDstToSrcFracCeil);
        ulYDstToSrcFracCeil = ulTemp;
    }

    //
    // Now clip Dst in X, and/or calc src clipping effect on dst
    //
    // adjust left and right edges if needed, record
    // distance adjusted for fixing the src
    //

    if (XDstStart < prclClip->left)
    {
        XDstStart = prclClip->left;
    }

    if (XDstEnd > prclClip->right)
    {
        XDstEnd = prclClip->right;
    }

    //
    // Check for totally clipped out destination:
    //

    if (XDstEnd <= XDstStart)
    {
        return;
    }

    LeftClipDistance = XDstStart - prclDst->left;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulXDstToSrcFracCeil >> 1) | (ulXDstToSrcIntCeil << 31);
        ulTempInt  = (ulXDstToSrcIntCeil >> 1);

        XSrcStart += ulTempInt;
        ulXFracAccumulator = ulTempFrac;

        if (LeftClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulXDstToSrcFracCeil, LeftClipDistance);

            ulTmp = ulXFracAccumulator;
            ulXFracAccumulator += (ULONG) (ullFraction);
            if (ulXFracAccumulator < ulTmp)
                XSrcStart++;

            XSrcStart += (ulXDstToSrcIntCeil * LeftClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Now clip Dst in Y, and/or calc src clipping effect on dst
    //
    // adjust top and bottom edges if needed, record
    // distance adjusted for fixing the src
    //

    if (YDstStart < prclClip->top)
    {
        YDstStart = prclClip->top;
    }

    if (YDstEnd > prclClip->bottom)
    {
        YDstEnd = prclClip->bottom;
    }

    //
    // Check for totally clipped out destination:
    //

    if (YDstEnd <= YDstStart)
    {
        return;
    }

    TopClipDistance = YDstStart - prclDst->top;

    {
        ULONG   ulTempInt;
        ULONG   ulTempFrac;

        //
        // Calculate displacement for .5 in destination and add:
        //

        ulTempFrac = (ulYDstToSrcFracCeil >> 1) | (ulYDstToSrcIntCeil << 31);
        ulTempInt  = ulYDstToSrcIntCeil >> 1;

        YSrcStart += (LONG)ulTempInt;
        ulYFracAccumulator = ulTempFrac;

        if (TopClipDistance != 0)
        {
            ULONGLONG ullFraction;
            ULONG     ulTmp;

            ullFraction = UInt32x32To64(ulYDstToSrcFracCeil, TopClipDistance);

            ulTmp = ulYFracAccumulator;
            ulYFracAccumulator += (ULONG) (ullFraction);
            if (ulYFracAccumulator < ulTmp)
                YSrcStart++;

            YSrcStart += (ulYDstToSrcIntCeil * TopClipDistance)
                       + (ULONG) (ullFraction >> 32);
        }
    }

    //
    // Warm up the hardware if doing an expanding stretch in 'y':
    //

    bStretch = (HeightDst > HeightSrc);
    if (bStretch)
    {
        BYTE* pjBase = ppdev->pjBase;
        LONG xOffset = ppdev->xOffset;

        CHECK_FIFO_SPACE(pjBase, 6);

        CP_WRITE(pjBase, DWG_DWGCTL,  opcode_BITBLT + atype_RPL + blockm_OFF +
                                      bltmod_BFCOL + pattern_OFF +
                                      transc_BG_OPAQUE + bop_SRCCOPY);
        CP_WRITE(pjBase, DWG_SHIFT,   0);
        CP_WRITE(pjBase, DWG_SGN,     0);
        CP_WRITE(pjBase, DWG_AR5,     ppdev->cxMemory);
        CP_WRITE(pjBase, DWG_FXLEFT,  XDstStart + xOffset);
        CP_WRITE(pjBase, DWG_FXRIGHT, XDstEnd + xOffset - 1);

        ppdev->HopeFlags = SIGN_CACHE;
    }

    //
    // Fill out blt structure, then call format-specific stretch code
    //

    StrBlt.ppdev     = ppdev;
    StrBlt.XDstEnd   = XDstEnd;
    StrBlt.YDstStart = YDstStart;
    StrBlt.YDstCount = YDstEnd - YDstStart;

    if (StrBlt.YDstCount > 0)
    {
        //
        // Caclulate starting scan line address.  Since the inner loop
        // routines are format dependent, they must add XDstStart/XSrcStart
        // to pjDstScan/pjSrcScan to get the actual starting pixel address.
        //

        StrBlt.pjSrcScan = (BYTE*) pvSrc + (YSrcStart * lDeltaSrc);
        StrBlt.pjDstScan = ppdev->pjScreen
                         + (ppdev->yOffset + YDstStart) * ppdev->lDelta
                         + (ppdev->xOffset + ppdev->ulYDstOrg) * ppdev->cjPelSize;

        StrBlt.lDeltaSrc           = lDeltaSrc;
        StrBlt.XSrcStart           = XSrcStart;
        StrBlt.XDstStart           = XDstStart;
        StrBlt.lDeltaDst           = ppdev->lDelta;
        StrBlt.ulXDstToSrcIntCeil  = ulXDstToSrcIntCeil;
        StrBlt.ulXDstToSrcFracCeil = ulXDstToSrcFracCeil;
        StrBlt.ulYDstToSrcIntCeil  = ulYDstToSrcIntCeil;
        StrBlt.ulYDstToSrcFracCeil = ulYDstToSrcFracCeil;
        StrBlt.ulXFracAccumulator  = ulXFracAccumulator;
        StrBlt.ulYFracAccumulator  = ulYFracAccumulator;

        if (ppdev->ulBoardId == MGA_STORM)
        {
            if (ppdev->iBitmapFormat == BMF_8BPP)
            {
                if ((XDstEnd - XDstStart) < 7)
                    pfnStr = vMilDirectStretch8Narrow;
                else
                    pfnStr = vMilDirectStretch8;
            }
            else if (ppdev->iBitmapFormat == BMF_16BPP)
            {
                pfnStr = vMilDirectStretch16;
            }
            else if (ppdev->iBitmapFormat == BMF_24BPP)
            {
                pfnStr = vMilDirectStretch24;
            }
            else
            {
                ASSERTDD(ppdev->iBitmapFormat == BMF_32BPP, "Expected 32bpp");

                pfnStr = vMilDirectStretch32;
            }
        }
        else
        {
            #if defined(_X86_)
            {
                if (ppdev->iBitmapFormat == BMF_8BPP)
                {
                    if ((XDstEnd - XDstStart) < 7)
                        pfnStr = vMgaDirectStretch8Narrow;
                    else
                        pfnStr = vMgaDirectStretch8;
                }
                else
                {
                    ASSERTDD(ppdev->iBitmapFormat == BMF_16BPP, "Expected 16bpp");

                    pfnStr = vMgaDirectStretch16;
                }
            }
            #endif
        }

        (*pfnStr)(&StrBlt);
    }
}

/******************************Public*Routine******************************\
* BOOL DrvStretchBlt
*
\**************************************************************************/

BOOL DrvStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    DSURF*   pdsurfSrc;
    DSURF*   pdsurfDst;
    PDEV*    ppdev;
    OH*      poh;
    SURFOBJ* psoDstNew;
    SURFOBJ* psoSrcNew;
    BOOL     bPunt = FALSE;
    BOOL     bRet;

    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be a device surface, and not a DIB:

    ppdev = (PDEV*) psoDst->dhpdev;
    pdsurfDst = (DSURF*) psoDst->dhsurf;
    pdsurfSrc = (DSURF*) psoSrc->dhsurf;

    poh             = pdsurfDst->poh;
    ppdev->xOffset  = poh->x;
    ppdev->yOffset  = poh->y;

    // It's quicker for GDI to do a StretchBlt when the source surface
    // is not a device-managed surface, because then it can directly
    // read the source bits without having to allocate a temporary
    // buffer and call DrvCopyBits to get a copy that it can use.

    if (ppdev->ulBoardId == MGA_STORM)
    {
        psoDstNew = psoDst;

        if (psoSrc->iType != STYPE_BITMAP)
        {
            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            if (pdsurfSrc->dt == DT_SCREEN)
            {
                // The source is a device bitmap that is currently stored
                // in device memory.

                psoSrcNew = psoSrc;
                bPunt = TRUE;
            }
            else
            {
                ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

                // The source was a device bitmap that we just converted
                // to a DIB:

                psoSrcNew = pdsurfSrc->pso;
            }
        }
        else
        {
            psoSrcNew = psoSrc;
        }
    }
    else
    {
        psoDstNew = psoDst;

        if (psoSrc->iType == STYPE_DEVBITMAP)
        {
            pdsurfSrc = (DSURF*) psoSrc->dhsurf;
            if (pdsurfSrc->dt == DT_SCREEN)
            {
                // The source is a device bitmap that is currently stored
                // in device memory.

                psoSrcNew = psoSrc;
                bPunt = TRUE;
            }
            else
            {
                ASSERTDD(pdsurfSrc->dt == DT_DIB, "Can only handle DIB DFBs here");

                // The source was a device bitmap that we just converted
                // to a DIB:

                psoSrcNew = pdsurfSrc->pso;
            }
        }
        else
        {
            psoSrcNew = psoSrc;
        }

        // With the old MGA's, we have fast stretch code only for 8bpp and
        // 16bpp:

        if (ppdev->iBitmapFormat > BMF_16BPP)
        {
            bPunt = TRUE;
        }

        // With the old MGA's, we have fast stretch code only for x86:

        #if !defined(_X86_)
        {
            bPunt = TRUE;
        }
        #endif
    }

    if (pdsurfDst->dt == DT_DIB)
    {
        // The destination was a device bitmap that we just converted
        // to a DIB:

        psoDstNew = pdsurfDst->pso;
        bPunt = TRUE;
    }

    if (!bPunt)
    {
        RECTL       rclClip;
        RECTL*      prclClip;
        ULONG       cxDst;
        ULONG       cyDst;
        ULONG       cxSrc;
        ULONG       cySrc;
        BOOL        bMore;
        CLIPENUM    ce;
        LONG        c;
        LONG        i;

        if ((psoSrcNew->iType == STYPE_BITMAP) &&
            (psoMsk == NULL) &&
            ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL)) &&
            ((psoSrcNew->iBitmapFormat == ppdev->iBitmapFormat)))
        {
            cxDst = prclDst->right - prclDst->left;
            cyDst = prclDst->bottom - prclDst->top;
            cxSrc = prclSrc->right - prclSrc->left;
            cySrc = prclSrc->bottom - prclSrc->top;

            // Our 'vStretchDIB' routine requires that the stretch be
            // non-inverting, within a certain size, to have no source
            // clipping, and to have no empty rectangles (the latter is the
            // reason for the '- 1' on the unsigned compare here):

            if (((cxSrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cySrc - 1) < STRETCH_MAX_EXTENT)         &&
                ((cxDst - 1) < STRETCH_MAX_EXTENT)         &&
                ((cyDst - 1) < STRETCH_MAX_EXTENT)         &&
                (prclSrc->left   >= 0)                     &&
                (prclSrc->top    >= 0)                     &&
                (prclSrc->right  <= psoSrcNew->sizlBitmap.cx) &&
                (prclSrc->bottom <= psoSrcNew->sizlBitmap.cy))
            {
                // Our snazzy routine only does COLORONCOLOR.  But for
                // stretching blts, BLACKONWHITE and WHITEONBLACK are also
                // equivalent to COLORONCOLOR:

                if ((iMode == COLORONCOLOR) ||
                    ((iMode < COLORONCOLOR) && (cxSrc <= cxDst) && (cySrc <= cyDst)))
                {
                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rclClip.left   = LONG_MIN;
                        rclClip.top    = LONG_MIN;
                        rclClip.right  = LONG_MAX;
                        rclClip.bottom = LONG_MAX;
                        prclClip = &rclClip;

                    StretchSingleClipRect:

                        vStretchDIB(ppdev,
                                    prclDst,
                                    psoSrcNew->pvScan0,
                                    psoSrcNew->lDelta,
                                    prclSrc,
                                    prclClip);

                        return(TRUE);
                    }
                    else if (pco->iDComplexity == DC_RECT)
                    {
                        prclClip = &pco->rclBounds;
                        goto StretchSingleClipRect;
                    }
                    else
                    {
                        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                        do {
                            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

                            c = cIntersect(prclDst, ce.arcl, ce.c);

                            if (c != 0)
                            {
                                for (i = 0; i < c; i++)
                                {
                                    vStretchDIB(ppdev,
                                                prclDst,
                                                psoSrcNew->pvScan0,
                                                psoSrcNew->lDelta,
                                                prclSrc,
                                                &ce.arcl[i]);
                                }
                            }

                        } while (bMore);

                        return(TRUE);
                    }
                }
            }
        }
    }

    // GDI is nice enough to handle the cases where 'psoDst' and/or 'psoSrc'
    // are device-managed surfaces, but it ain't gonna be fast...

    if (ppdev->ulBoardId == MGA_STORM)
    {
        START_DIRECT_ACCESS_STORM(ppdev, ppdev->pjBase);
    }
    else
    {
        START_DIRECT_ACCESS_MGA(ppdev, ppdev->pjBase);
    }

    bRet = EngStretchBlt(psoDstNew, psoSrcNew, psoMsk, pco, pxlo, pca, pptlHTOrg,
                         prclDst, prclSrc, pptlMsk, iMode);

    if (ppdev->ulBoardId == MGA_STORM)
    {
        END_DIRECT_ACCESS_STORM(ppdev, ppdev->pjBase);
    }
    else
    {
        END_DIRECT_ACCESS_MGA(ppdev, ppdev->pjBase);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\i386\str.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: str.asm
;
; Contains the x86 'Asm' versions of some inner-loop routines for the
; partially hardware accelerated StretchBlt.
;
; Copyright (c) 1994-1995 Microsoft Corporation
;-----------------------------------------------------------------------;

        .386

        .model  small,c

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include stdcall.inc             ;calling convention cmacros
        include i386\strucs.inc
        include i386\hw.inc
        .list

        .data

;
;  stack based params and local variables
;

STACK_STRUC             struc

; Feel free to add any local variables here:

sp_TempXFrac            dd      ?
sp_YCarry               dd      ?
sp_LeftCase             dd      ?
sp_RightCase            dd      ?
sp_pjSrcScan            dd      ?
sp_SrcIntStep           dd      ?
sp_XCount               dd      ?
sp_yDst                 dd      ?
sp_cxMemory             dd      ?
sp_pjDst                dd      ?
sp_ulDst                dd      ?
sp_pjBase               dd      ?
sp_ulYDstOrg            dd      ?
sp_XWidthLessOne        dd      ?


; Don't add any fields below here without modifying PROC_MEM_SIZE!

sp_ebp                  dd      ?
sp_esi                  dd      ?
sp_edi                  dd      ?
sp_ebx                  dd      ?
sp_RetAddr              dd      ?
sp_pSTR_BLT             dd      ?   ; If adding parameters, adjust 'ret' value!
STACK_STRUC             ends

PROC_MEM_SIZE           equ     6 * 4

;
; Make sure this STR_BLT matches that declared in driver.h!
;

STR_BLT                 struc
str_ppdev               dd      ?
str_pjSrcScan           dd      ?
str_lDeltaSrc           dd      ?
str_XSrcStart           dd      ?
str_pjDstScan           dd      ?   ; Unused by MGA
str_lDeltaDst           dd      ?   ; Unused by MGA
str_XDstStart           dd      ?
str_XDstEnd             dd      ?
str_YDstStart           dd      ?
str_YDstCount           dd      ?
str_ulXDstToSrcIntCeil  dd      ?
str_ulXDstToSrcFracCeil dd      ?
str_ulYDstToSrcIntCeil  dd      ?
str_ulYDstToSrcFracCeil dd      ?
str_ulXFracAccumulator  dd      ?
str_ulYFracAccumulator  dd      ?
STR_BLT                 ends

        .code

;---------------------------Public-Routine------------------------------;
; VOID vMgaDirectStretch8(pStrBlt)
;
; NOTE: This routine doesn't handle cases where the blt stretch starts
;       and ends in the same destination dword!  vDirectStretchNarrow
;       is expected to have been called for that case.
;
; Stretch blt 8 -> 8
;-----------------------------------------------------------------------;

        public vMgaDirectStretch8@4

vMgaDirectStretch8@4 proc near

        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        add     ecx,[eax].pdev_yOffset                  ; convert to abs coordinate
        mov     [esp].sp_yDst,ecx                       ; save current y coordinate
        mov     ebx,[eax].pdev_ulYDstOrg
        mov     edx,[eax].pdev_cxMemory
        mov     edi,[eax].pdev_pjBase
        mov     [esp].sp_ulYDstOrg,ebx                  ; local copy of ulYDstOrg
        mov     [esp].sp_cxMemory,edx                   ; local copy of stride
        mov     [esp].sp_pjBase,edi                     ; local copy of pjBase

        imul    ecx,edx                                 ; yDst * cxMemory
        add     ecx,[ebp].str_XDstStart
        add     ecx,[eax].pdev_xOffset
        add     ecx,[eax].pdev_ulYDstOrg
        mov     [esp].sp_ulDst,ecx                      ; ulDst = ulYDstOrg
                                                        ;  + (yDstStart * cxMemory)
                                                        ;  + (XDstStart + xOffset)
        and     ecx,31
        add     ecx,SRCWND
        add     ecx,edi
        mov     [esp].sp_pjDst,ecx                      ; pjDst = (ulDst & 31)
                                                        ;  + pjBase + SRCWND

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        add     esi,[ebp].str_XSrcStart                 ; add starting Src Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,4                                   ; calc left bytes = (4 - LeftCase) & 0x03
        sub     edx,[ebp].str_XDstStart
        and     edx,3                                   ; left edge bytes
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels (4-LeftCase)&0x03
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        mov     eax,ecx                                 ; ending dst addr
        and     eax,3                                   ; calc right edge case
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count
        lea     ebx,[ecx - 1]                           ; calc width less one
        mov     [esp].sp_XWidthLessOne,ebx              ; save it
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,2                                   ; convert from byte to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

@@:     cmp     byte ptr [edi+HST_FIFOSTATUS],FIFOSIZE
        jb      @b                                      ; CHECK_FIFO_SPACE(32)

@@:     test    byte ptr [edi+HST_STATUS+2],(dwgengsts_MASK shr 16)
        jnz     @b                                      ; WAIT_NOT_BUSY()

        mov     edx,[esp].sp_ulDst

NextScan:

        ; edx = current destination offset
        ; esi = pointer to source pixel

        mov     [edi+HST_DSTPAGE],edx                   ; CP_WRITE(HST_DSTPAGE, ulDst)

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edi,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,[esp].sp_pjDst                      ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

@@:
        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec left count
        jne     @B                                      ; repeat until done

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length

@@:
        mov     dl,[esi]                                ; get a source pixel edx = ???0
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = ??10
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16                                  ; edx = 10??

        add     edi,ebx                                 ; step fraction
        mov     dl,[esi]                                ; get a source pixel edx = 10?2
        adc     esi,eax                                 ; add integer and carry

        add     edi,ebx                                 ; step fraction
        mov     dh,[esi]                                ; get source pixel edx = 0132
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16                                  ; edx = 3210

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

@@:
        mov     dl,[esi]                                ; fetch pixel
        mov     [ebp],dl                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        inc     ebp                                     ; step 1 in dest
        dec     ecx                                     ; dec right count
        jnz     @b                                      ; repeat until done

EndScanLine:

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp
        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        inc     [esp].sp_yDst                           ; one scan further down in dst

        mov     edi,[esp].sp_pjBase
        mov     edx,[esp].sp_ulDst
        add     edx,[esp].sp_cxMemory
        mov     [esp].sp_ulDst,edx                      ; ulDst += cxMemory

        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the MGA we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; edx = ulDst, current offset from start of frame buffer to next scan
        ; esi = current pjSrcScan
        ; edi = pjBase
        ; ebp = pSTR_BLT
        ;

        xor     ecx,ecx                                 ; number of times scan is to be
                                                        ;  duplicated
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        mov     eax,[esp].sp_cxMemory
        imul    eax,ecx
        add     eax,edx
        mov     [esp].sp_ulDst,eax                      ; ulDst += cxMemory * cyDuplicate

        mov     eax,[esp].sp_yDst
        mov     [edi+DWG_YDST],eax
        mov     [edi+DWG_LEN],ecx
        add     ecx,eax
        mov     [esp].sp_yDst,ecx                       ; add duplicate count to y

        sub     edx,[esp].sp_cxMemory
        mov     [edi+DWG_AR3],edx
        add     edx,[esp].sp_XWidthLessOne
        mov     [edi+DWG_AR0+StartDwgReg],edx

        ; Unfortunately, if we try to write to the frame buffer at the
        ; same time that the MGA is doing the screen-to-screen blt, we
        ; will get garbage on the screen.  Consequently, we always
        ; wait for idle before writing on the frame buffer:

@@:     cmp     byte ptr [edi+HST_FIFOSTATUS],FIFOSIZE
        jb      @b                                      ; CHECK_FIFO_SPACE(32)

@@:     test    byte ptr [edi+HST_STATUS+2],(dwgengsts_MASK shr 16)
        jnz     @b                                      ; WAIT_NOT_BUSY()

        mov     edx,[esp].sp_ulDst

        ; edx = current destination offset
        ; esi = pointer to source pixel

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan

Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vMgaDirectStretch8@4 endp

;---------------------------Public-Routine------------------------------;
; VOID vMgaDirectStretch16(pStrBlt)
;
; Stretch blt 16 -> 16
;-----------------------------------------------------------------------;

        public vMgaDirectStretch16@4

vMgaDirectStretch16@4 proc near

        ;
        ; use ebp as general register, use esp for parameter and local access
        ; save ebp,ebx,esi,edi
        ;

        push    ebx
        push    edi
        push    esi
        push    ebp

        sub     esp,(size STACK_STRUC) - PROC_MEM_SIZE  ; make room for local variables

        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp

        ;
        ; load up some stack-based parameters to be used by our scan
        ; duplicator when doing vertical stretches
        ;

        mov     eax,[ebp].str_ppdev
        mov     ecx,[ebp].str_YDstStart                 ; get start y coordinate
        add     ecx,[eax].pdev_yOffset                  ; convert to abs coordinate
        mov     [esp].sp_yDst,ecx                       ; save current y coordinate
        mov     ebx,[eax].pdev_ulYDstOrg
        mov     edx,[eax].pdev_cxMemory
        mov     edi,[eax].pdev_pjBase
        mov     [esp].sp_ulYDstOrg,ebx                  ; local copy of ulYDstOrg
        mov     [esp].sp_cxMemory,edx                   ; local copy of stride
        mov     [esp].sp_pjBase,edi                     ; local copy of pjBase

        imul    ecx,edx                                 ; yDst * cxMemory
        add     ecx,[ebp].str_XDstStart
        add     ecx,[eax].pdev_xOffset
        add     ecx,[eax].pdev_ulYDstOrg
        mov     [esp].sp_ulDst,ecx                      ; ulDst = ulYDstOrg
                                                        ;  + (yDstStart * cxMemory)
                                                        ;  + (XDstStart + xOffset)
        add     ecx,ecx
        and     ecx,31
        add     ecx,SRCWND
        add     ecx,edi
        mov     [esp].sp_pjDst,ecx                      ; pjDst = (ulDst & 31)
                                                        ;  + pjBase + SRCWND

        ;
        ; calc starting addressing parameters
        ;

        mov     esi,[ebp].str_pjSrcScan                 ; load src DIB pointer
        add     esi,[ebp].str_XSrcStart
        add     esi,[ebp].str_XSrcStart                 ; add 2 * starting Src Pixel
        mov     [esp].sp_pjSrcScan,esi                  ; save scan line start pointer
        mov     eax,[ebp].str_ulYDstToSrcIntCeil        ; number of src scan lines to step
        mul     [ebp].str_lDeltaSrc                     ; calc scan line int lines to step
        mov     [esp].sp_SrcIntStep,eax                 ; save int portion of Y src step
        mov     edx,[ebp].str_XDstStart
        and     edx,1
        mov     [esp].sp_LeftCase,edx                   ; save left edge case pixels (4-LeftCase)&0x03
        mov     ecx,[ebp].str_XDstEnd                   ; load x end
        mov     eax,ecx
        and     eax,1
        mov     [esp].sp_RightCase,eax                  ; save right edge case
        sub     ecx,[ebp].str_XDstStart                 ; calc x count
        lea     ebx,[ecx - 1]                           ; calc width less one
        mov     [esp].sp_XWidthLessOne,ebx              ; save it
        sub     ecx,eax                                 ; sub right edge from XCount
        sub     ecx,edx                                 ; sub left edge from XCount
        shr     ecx,1                                   ; convert from pixels to DWORD count
        mov     [esp].sp_XCount,ecx                     ; save DWORD count
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get x frac
        mov     [esp].sp_TempXFrac,ebx                  ; save x frac to a esp based location

@@:     cmp     byte ptr [edi+HST_FIFOSTATUS],FIFOSIZE
        jb      @b                                      ; CHECK_FIFO_SPACE(32)

@@:     test    byte ptr [edi+HST_STATUS+2],(dwgengsts_MASK shr 16)
        jnz     @b                                      ; WAIT_NOT_BUSY()

        mov     edx,[esp].sp_ulDst

NextScan:

        ; edx = current destination offset
        ; esi = pointer to source pixel

        add     edx,edx                                 ; convert pixels to bytes
        mov     [edi+HST_DSTPAGE],edx                   ; CP_WRITE(HST_DSTPAGE, ulDst)

        mov     eax,[ebp].str_ulXDstToSrcIntCeil        ; get src integer step for step in dst
        mov     ebx,[ebp].str_ulXDstToSrcFracCeil       ; get src frac step for step in dst
        mov     edi,[ebp].str_ulXFracAccumulator        ; put it in edx as tmp

        mov     ebp,[esp].sp_pjDst                      ; get dst pointer to ebp

        ;
        ; Can't directly access pSTR_BLT variables through ebp
        ;

        mov     ecx,[esp].sp_LeftCase

        ; eax = integer step in source
        ; ebx = fractional step in source
        ; ecx = left edge case
        ; edx = free for pixel data
        ; esi = pointer to source pixel
        ; edi = fractional accumulator
        ; ebp = pointer to dest pixel

        ;
        ; divide 'esi' by 2 so that we can always dereference it by
        ; [2*esi] -- this allows us to still use an 'add with carry'
        ; to jump to the next pixel
        ;

        shr     esi,1

        ;
        ; first do the left side to align dwords
        ;

        test    ecx,ecx
        jz      DwordAligned

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

DwordAligned:

        mov     ecx,[esp].sp_XCount                     ; get run length
        test    ecx,ecx
        jz      TrailingBytes                           ; watch for zero dword case

@@:
        mov     dx,[2*esi]                              ; get a source pixel
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add integer and carry

        shl     edx,16

        add     edi,ebx                                 ; step fraction
        mov     dx,[2*esi]                              ; get source pixel
        adc     esi,eax                                 ; add integer and carry

        ror     edx,16

        mov     [ebp],edx                               ; write everything to dest

        add     ebp,4                                   ; increment dest pointer by 1 dword
        dec     ecx                                     ; decrement count
        jnz     @b                                      ; do more pixels

TrailingBytes:

        ;
        ; now do the right side trailing bytes
        ;

        mov     ecx,[esp].sp_RightCase
        test    ecx,ecx
        jz      EndScanLine

        mov     dx,[2*esi]                              ; fetch pixel
        mov     [ebp],dx                                ; write it out
        add     edi,ebx                                 ; step fraction
        adc     esi,eax                                 ; add in integer and possible carry
        add     ebp,2                                   ; step 1 in dest

EndScanLine:

        mov     edi,ebp                                 ; get dst pointer back
        mov     ebp,[esp].sp_pSTR_BLT                   ; load pSTR_BLT into ebp
        mov     esi,[esp].sp_pjSrcScan                  ; load src scan start addr
        mov     ebx,esi                                 ; save a copy
        mov     eax,[ebp].str_ulYFracAccumulator        ; get .32 part of Y pointer
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        add     esi,[esp].sp_SrcIntStep                 ; step int part
        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan addr
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      Done                                    ; no more scans

        inc     [esp].sp_yDst                           ; one scan further down in dst

        mov     edi,[esp].sp_pjBase
        mov     edx,[esp].sp_ulDst
        add     edx,[esp].sp_cxMemory
        mov     [esp].sp_ulDst,edx                      ; ulDst += cxMemory

        cmp     esi,ebx                                 ; is src scan same as before?
        jne     NextScan                                ; if so, fall through to dupe scan

        ;--------------------------------------------------------------------
        ; The source scan is the same one used for the previous destination
        ; scan, so we can simply use the hardware to copy the previous
        ; destination scan.
        ;
        ; Since on the MGA we can set up a 'rolling blt' to copy one scan
        ; line to several scans in a single command, we will count up how
        ; many times this scan should be duplicated.  If your hardware
        ; cannot do a rolling blt, simply issue a new blt command for
        ; every time the scan should be duplicated.
        ;
        ; eax = ulYFracAccumulator
        ; ebx = original pjSrcScan
        ; edx = ulDst, current offset from start of frame buffer to next scan
        ; esi = current pjSrcScan
        ; edi = pjBase
        ; ebp = pSTR_BLT
        ;

        xor     ecx,ecx                                 ; number of times scan is to be
                                                        ;  duplicated
AnotherDuplicate:

        inc     ecx                                     ; one scan further down
        dec     [ebp].str_YDstCount                     ; decrement scan count
        jz      OutputDuplicates                        ; no more scans
        add     eax,[ebp].str_ulYDstToSrcFracCeil       ; add in fractional step
        jnc     @f
        add     esi,[ebp].str_lDeltaSrc                 ; step one extra in src
@@:     add     esi,[esp].sp_SrcIntStep                 ; step int part
        cmp     esi,ebx                                 ; is src scan same as before?
        je      AnotherDuplicate

OutputDuplicates:

        mov     [esp].sp_pjSrcScan,esi                  ; save starting scan address
        mov     [ebp].str_ulYFracAccumulator,eax        ; save Y accumulator

        mov     eax,[esp].sp_cxMemory
        imul    eax,ecx
        add     eax,edx
        mov     [esp].sp_ulDst,eax                      ; ulDst += cxMemory * cyDuplicate

        mov     eax,[esp].sp_yDst
        mov     [edi+DWG_YDST],eax
        mov     [edi+DWG_LEN],ecx
        add     ecx,eax
        mov     [esp].sp_yDst,ecx                       ; add duplicate count to y

        sub     edx,[esp].sp_cxMemory
        mov     [edi+DWG_AR3],edx
        add     edx,[esp].sp_XWidthLessOne
        mov     [edi+DWG_AR0+StartDwgReg],edx

        ; Unfortunately, if we try to write to the frame buffer at the
        ; same time that the MGA is doing the screen-to-screen blt, we
        ; will get garbage on the screen.  Consequently, we always
        ; wait for idle before writing on the frame buffer:

@@:     cmp     byte ptr [edi+HST_FIFOSTATUS],FIFOSIZE
        jb      @b                                      ; CHECK_FIFO_SPACE(32)

@@:     test    byte ptr [edi+HST_STATUS+2],(dwgengsts_MASK shr 16)
        jnz     @b                                      ; WAIT_NOT_BUSY()

        mov     edx,[esp].sp_ulDst

        ; edx = current destination offset
        ; esi = pointer to source pixel

        cmp     [ebp].str_YDstCount,0                   ; we might be all done
        jne     NextScan

Done:

        add     esp,(size STACK_STRUC) - PROC_MEM_SIZE
        pop     ebp
        pop     esi
        pop     edi
        pop     ebx

        ret     4

vMgaDirectStretch16@4 endp

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\textout.c ===
/******************************Module*Header*******************************\
* Module Name: textout.c
*
* We cache off-screen glyphs linearly in off-screen memory.
*
* Copyright (c) 1992-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

//////////////////////////////////////////////////////////////////////////

BYTE gajBit[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
                                // Converts bit index to set bit

RECTL grclMax = { 0, 0, 0x10000, 0x10000 };
                                // Maximal clip rectangle for trivial clipping

// Array used for getting the mirror image of bytes:

BYTE gajFlip[] =
{
    0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
    0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
    0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
    0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
    0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
    0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
    0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
    0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
    0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
    0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
    0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
    0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
    0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
    0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
    0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
    0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
    0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
    0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
    0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
    0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
    0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
    0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
    0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
    0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
    0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
    0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
    0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
    0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
    0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
    0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
    0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
    0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF,
};

/******************************Public*Routine******************************\
* VOID vClipSolid
*
* Fills the specified rectangle with the specified colour, honouring
* the requested clipping.
*
\**************************************************************************/

VOID vClipSolid(
PDEV*       ppdev,
RECTL*      prcl,
ULONG       iColor,
CLIPOBJ*    pco)
{
    BOOL            bMore;              // Flag for clip enumeration
    CLIPENUM        ce;                 // Clip enumeration object
    LONG            c;                  // Count of non-empty rectangles
    RBRUSH_COLOR    rbc;                // For passing colour to vFillSolid

    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

    // Scan through all the clip rectangles, looking for intersects
    // of fill areas with region rectangles:

    rbc.iSolidColor = iColor;

    do {
        // Get a batch of region rectangles:

        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (VOID*) &ce);

        c = cIntersect(prcl, ce.arcl, ce.c);

        if (c != 0)
            ppdev->pfnFillSolid(ppdev, c, ce.arcl, 0xf0f0, rbc, NULL);

    } while (bMore);
}

/******************************Public*Routine******************************\
* VOID vExpandGlyph
*
\**************************************************************************/

VOID vExpandGlyph(
PDEV*   ppdev,
BYTE*   pj,             // Can be unaligned
LONG    lSkip,
LONG    cj,
LONG    cy,
BOOL    bHwBug)
{
    BYTE*               pjBase;
    ULONG*              pulDma;
    LONG                cFifo;
    LONG                cd;
    ULONG UNALIGNED*    pulSrc;
    LONG                cEdgeCases;
    LONG                i;
    ULONG               ul;

    ASSERTDD((bHwBug == 1) || (bHwBug == 0), "Expect binary bHwBug");

    pjBase = ppdev->pjBase;
    pulDma = (ULONG*) (pjBase + DMAWND);
    cd     = cj >> 2;
    pulSrc = (ULONG UNALIGNED*) pj;

    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
    BLT_WRITE_ON(ppdev, pjBase);

    // Make sure we have room for very first write that accounts for
    // the hardware bug:

    cFifo = FIFOSIZE - 1;
    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

    // If we have to work around the hardware bug, we usually have to have
    // two FIFO entries open for the work-around write, and for the last
    // edge write:

    cEdgeCases = 1 + bHwBug;

    switch (cj & 3)
    {
    case 0:
        cEdgeCases = bHwBug;                    // No last edge write

        do {
            if (bHwBug)
                CP_WRITE_DMA(ppdev, pulDma, 0); // Account for hardware bug

            for (i = cd; i != 0; i--)
            {
                if (--cFifo < 0)
                {
                    cFifo = FIFOSIZE - 1;
                    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                }
                CP_WRITE_DMA(ppdev, pulDma, *pulSrc++);
            }

            if ((cFifo -= cEdgeCases) < 0)
            {
                cFifo = FIFOSIZE - 1;
                CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
            }
            pulSrc = (ULONG UNALIGNED*) ((BYTE*) pulSrc + lSkip);

        } while (--cy != 0);
        break;

    case 1:
        do {
            if (bHwBug)
                CP_WRITE_DMA(ppdev, pulDma, 0); // Account for hardware bug

            for (i = cd; i != 0; i--)
            {
                if (--cFifo < 0)
                {
                    cFifo = FIFOSIZE - 1;
                    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                }
                CP_WRITE_DMA(ppdev, pulDma, *pulSrc++);
            }

            if ((cFifo -= cEdgeCases) < 0)
            {
                cFifo = FIFOSIZE - 2;
                CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
            }
            CP_WRITE_DMA(ppdev, pulDma, *((BYTE*) pulSrc));
            pulSrc = (ULONG UNALIGNED*) ((BYTE*) pulSrc + lSkip + 1);

        } while (--cy != 0);
        break;

    case 2:
        do {
            if (bHwBug)
                CP_WRITE_DMA(ppdev, pulDma, 0); // Account for hardware bug

            for (i = cd; i != 0; i--)
            {
                if (--cFifo < 0)
                {
                    cFifo = FIFOSIZE - 1;
                    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                }
                CP_WRITE_DMA(ppdev, pulDma, *pulSrc++);
            }

            if ((cFifo -= cEdgeCases) < 0)
            {
                cFifo = FIFOSIZE - 2;
                CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
            }
            CP_WRITE_DMA(ppdev, pulDma, *((WORD UNALIGNED *) pulSrc));
            pulSrc = (ULONG UNALIGNED*) ((BYTE*) pulSrc + lSkip + 2);

        } while (--cy != 0);
        break;

    case 3:
        do {
            if (bHwBug)
                CP_WRITE_DMA(ppdev, pulDma, 0); // Account for hardware bug

            for (i = cd; i != 0; i--)
            {
                if (--cFifo < 0)
                {
                    cFifo = FIFOSIZE - 1;
                    CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
                }
                CP_WRITE_DMA(ppdev, pulDma, *pulSrc++);
            }

            if ((cFifo -= cEdgeCases) < 0)
            {
                cFifo = FIFOSIZE - 2;
                CHECK_FIFO_SPACE(pjBase, FIFOSIZE);
            }
            ul = *((WORD UNALIGNED *) pulSrc) | (*(((BYTE*) pulSrc) + 2) << 16);
            CP_WRITE_DMA(ppdev, pulDma, ul);
            pulSrc = (ULONG UNALIGNED*) ((BYTE*) pulSrc + lSkip + 3);

        } while (--cy != 0);
        break;
    }

    BLT_WRITE_OFF(ppdev, pjBase);
}

/******************************Public*Routine******************************\
* VOID vMgaGeneralText
*
\**************************************************************************/

VOID vMgaGeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjBase;
    LONG        xOffset;
    LONG        yOffset;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        cx;
    LONG        cy;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        lDelta;
    LONG        cj;
    BYTE*       pjGlyph;
    BOOL        bHwBug;
    LONG        xAlign;

    pjBase       = ppdev->pjBase;
    xOffset      = ppdev->xOffset;
    yOffset      = ppdev->yOffset;
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &grclMax;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;
              pjGlyph = pgb->aj;

              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                CHECK_FIFO_SPACE(pjBase, 7);
                CP_WRITE(pjBase, DWG_LEN,     cyGlyph);
                CP_WRITE(pjBase, DWG_YDST,    yOffset + ptlOrigin.y);
                CP_WRITE(pjBase, DWG_FXLEFT,  xOffset + ptlOrigin.x);
                CP_WRITE(pjBase, DWG_FXRIGHT, xOffset + ptlOrigin.x + cxGlyph - 1);

                bHwBug = (cxGlyph >= 128);

                if (!bHwBug)
                {
                  CP_WRITE(pjBase, DWG_SHIFT, 0);
                  CP_WRITE(pjBase, DWG_AR3,   0);
                  CP_START(pjBase, DWG_AR0,   cxGlyph - 1);
                }
                else
                {
                  CP_WRITE(pjBase, DWG_AR3,   8);
                  CP_WRITE(pjBase, DWG_AR0,   cxGlyph + 31);
                  CP_START(pjBase, DWG_SHIFT, (24 << 16));
                }

                vExpandGlyph(ppdev, pjGlyph, 0, (cxGlyph + 7) >> 3, cyGlyph, bHwBug);
              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                  CHECK_FIFO_SPACE(pjBase, 7);
                  CP_WRITE(pjBase, DWG_LEN,     cy);
                  CP_WRITE(pjBase, DWG_YDST,    yOffset + yTop);
                  CP_WRITE(pjBase, DWG_FXLEFT,  xOffset + xLeft);
                  CP_WRITE(pjBase, DWG_FXRIGHT, xOffset + xRight - 1);

                  xAlign = (xLeft - ptlOrigin.x) & 31;

                  bHwBug = (cx >= 128) && (xAlign <= 15);

                  if (!bHwBug)
                  {
                    CP_WRITE(pjBase, DWG_SHIFT, 0);
                    CP_WRITE(pjBase, DWG_AR3,   xAlign);
                    CP_START(pjBase, DWG_AR0,   xAlign + cx - 1);
                  }
                  else
                  {
                    CP_WRITE(pjBase, DWG_AR3,   xAlign + 8);
                    CP_WRITE(pjBase, DWG_AR0,   xAlign + cx + 31);
                    CP_START(pjBase, DWG_SHIFT, (24 << 16));
                  }

                  lDelta   = (cxGlyph + 7) >> 3;
                  pjGlyph += (yTop - ptlOrigin.y) * lDelta
                          + (((xLeft - ptlOrigin.x) >> 3) & ~3);
                  cj = (xAlign + cx + 7) >> 3;

                  vExpandGlyph(ppdev, pjGlyph, lDelta - cj, cj, cy, bHwBug);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);
}

/******************************Public*Routine******************************\
* VOID vMilGeneralText
*
\**************************************************************************/

VOID vMilGeneralText(
PDEV*     ppdev,
STROBJ*   pstro,
CLIPOBJ*  pco)
{
    BYTE*       pjBase;
    LONG        xOffset;
    LONG        yOffset;
    BYTE        iDComplexity;
    BOOL        bMoreGlyphs;
    ULONG       cGlyphOriginal;
    ULONG       cGlyph;
    GLYPHPOS*   pgpOriginal;
    GLYPHPOS*   pgp;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    CLIPENUM    ce;
    RECTL*      prclClip;
    ULONG       ulCharInc;
    LONG        cxGlyph;
    LONG        cyGlyph;
    LONG        cx;
    LONG        cy;
    LONG        xLeft;
    LONG        yTop;
    LONG        xRight;
    LONG        yBottom;
    LONG        lDelta;
    LONG        cj;
    BYTE*       pjGlyph;
    BOOL        bHwBug;
    LONG        xAlign;
    BOOL        bClipSet;

    pjBase       = ppdev->pjBase;
    xOffset      = ppdev->xOffset;
    yOffset      = ppdev->yOffset;
    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
    bClipSet     = FALSE;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        ulCharInc = pstro->ulCharInc;

        if (iDComplexity != DC_COMPLEX)
        {
            // We could call 'cEnumStart' and 'bEnum' when the clipping is
            // DC_RECT, but the last time I checked, those two calls took
            // more than 150 instructions to go through GDI.  Since
            // 'rclBounds' already contains the DC_RECT clip rectangle,
            // and since it's such a common case, we'll special case it:

            bMore = FALSE;
            ce.c  = 1;

            if (iDComplexity == DC_TRIVIAL)
                prclClip = &grclMax;
            else
                prclClip = &pco->rclBounds;

            goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;
            pgb    = pgp->pgdf->pgb;

            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              cxGlyph = pgb->sizlBitmap.cx;
              cyGlyph = pgb->sizlBitmap.cy;
              pjGlyph = pgb->aj;

              if ((prclClip->left   <= ptlOrigin.x) &&
                  (prclClip->top    <= ptlOrigin.y) &&
                  (prclClip->right  >= ptlOrigin.x + cxGlyph) &&
                  (prclClip->bottom >= ptlOrigin.y + cyGlyph))
              {
                //-----------------------------------------------------
                // Unclipped glyph

                if (bClipSet)
                {
                    // A clipped glyph was just drawn.
                    CHECK_FIFO_SPACE(pjBase, 2);
                    CP_WRITE(pjBase, DWG_CXLEFT,  0);
                    CP_WRITE(pjBase, DWG_CXRIGHT, (ppdev->cxMemory - 1));
                    bClipSet = FALSE;
                }

                CHECK_FIFO_SPACE(pjBase, 4);

                CP_WRITE(pjBase, DWG_FXBNDRY,
                    ((xOffset + ptlOrigin.x + cxGlyph - 1) << bfxright_SHIFT) |
                    ((xOffset + ptlOrigin.x) & bfxleft_MASK));

                // ylength_MASK not is needed since coordinates are within range

                CP_WRITE(pjBase, DWG_YDSTLEN,
                    ((yOffset + ptlOrigin.y) << yval_SHIFT) |
                    (cyGlyph));
                CP_WRITE(pjBase, DWG_AR3, 0);
                CP_START(pjBase, DWG_AR0, (cxGlyph - 1));

                vExpandGlyph(ppdev, pjGlyph, 0, (cxGlyph + 7) >> 3, cyGlyph, FALSE);
              }
              else
              {
                //-----------------------------------------------------
                // Clipped glyph

                // Find the intersection of the glyph rectangle
                // and the clip rectangle:

                xLeft   = max(prclClip->left,   ptlOrigin.x);
                yTop    = max(prclClip->top,    ptlOrigin.y);
                xRight  = min(prclClip->right,  ptlOrigin.x + cxGlyph);
                yBottom = min(prclClip->bottom, ptlOrigin.y + cyGlyph);

                // Check for trivial rejection:

                if (((cx = xRight - xLeft) > 0) &&
                    ((cy = yBottom - yTop) > 0))
                {
                    // We have to set the clipping rectangle.
                    CHECK_FIFO_SPACE(pjBase, 6);
                    CP_WRITE(pjBase, DWG_CXLEFT,  (xOffset + xLeft));
                    CP_WRITE(pjBase, DWG_CXRIGHT, (xOffset + xRight - 1));
                    bClipSet = TRUE;

                    xAlign = (xLeft - ptlOrigin.x) & 0x7;
                    xLeft -= xAlign;
                    cx    += xAlign;

                    CP_WRITE(pjBase, DWG_FXBNDRY,
                        ((xOffset + xRight - 1) << bfxright_SHIFT) |
                        ((xOffset + xLeft) & bfxleft_MASK));

                    // ylength_MASK not is needed since coordinates are within range

                    CP_WRITE(pjBase, DWG_YDSTLEN,
                        ((yOffset + yTop) << yval_SHIFT) |
                        (cy));

                    CP_WRITE(pjBase, DWG_AR3, 0);
                    CP_START(pjBase, DWG_AR0, (cx - 1));

                    // Send the bits to the DMA window.
                    lDelta   = (cxGlyph + 7) >> 3;
                    pjGlyph += (yTop - ptlOrigin.y) * lDelta
                            + ((xLeft - ptlOrigin.x) >> 3);
                    cj = (cx + 7) >> 3;

                  vExpandGlyph(ppdev, pjGlyph, lDelta - cj, cj, cy, FALSE);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;
              pgb = pgp->pgdf->pgb;

              if (ulCharInc == 0)
              {
                ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
              }
              else
              {
                ptlOrigin.x += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

    if (bClipSet)
    {
        // Clear the clipping registers.
        CHECK_FIFO_SPACE(pjBase, 2);
        CP_WRITE(pjBase, DWG_CXLEFT,  0);
        CP_WRITE(pjBase, DWG_CXRIGHT, (ppdev->cxMemory - 1));
    }
}

/******************************Public*Routine******************************\
* CACHEDFONT* pcfAllocateCachedFont()
*
* Initializes our font data structure.
*
\**************************************************************************/

CACHEDFONT* pcfAllocateCachedFont(
PDEV*   ppdev)
{
    CACHEDFONT*     pcf;
    CACHEDGLYPH**   ppcg;
    LONG            i;

    pcf = EngAllocMem(FL_ZERO_MEMORY, sizeof(CACHEDFONT), ALLOC_TAG);

    if (pcf != NULL)
    {
        // Insert this node into the doubly-linked cached-font list hanging
        // off the PDEV:

        pcf->pcfNext              = ppdev->cfSentinel.pcfNext;
        pcf->pcfPrev              = &ppdev->cfSentinel;
        ppdev->cfSentinel.pcfNext = pcf;
        pcf->pcfNext->pcfPrev     = pcf;

        // Note that we rely on FL_ZERO_MEMORY to zero 'pgaChain' and
        // 'cjAlloc':

        pcf->cgSentinel.hg = HGLYPH_SENTINEL;

        // Initialize the hash table entries to all point to our sentinel:

        for (ppcg = &pcf->apcg[0], i = GLYPH_HASH_SIZE; i != 0; i--, ppcg++)
        {
            *ppcg = &pcf->cgSentinel;
        }
    }

    return(pcf);
}

/******************************Public*Routine******************************\
* VOID vFreeCachedFont()
*
* Frees all memory associated with the cache we kept for this font.
*
\**************************************************************************/

VOID vFreeCachedFont(
CACHEDFONT* pcf)
{
    GLYPHALLOC* pga;
    GLYPHALLOC* pgaNext;

    // Remove this node from our cached-font linked-list:

    pcf->pcfPrev->pcfNext = pcf->pcfNext;
    pcf->pcfNext->pcfPrev = pcf->pcfPrev;

    // Free all glyph position allocations associated with this font:

    pga = pcf->pgaChain;
    while (pga != NULL)
    {
        pgaNext = pga->pgaNext;
        EngFreeMem(pga);
        pga = pgaNext;
    }

    EngFreeMem(pcf);
}

/******************************Public*Routine******************************\
* VOID vBlowGlyphCache()
*
\**************************************************************************/

VOID vBlowGlyphCache(
PDEV*   ppdev)
{
    CACHEDFONT*     pcfSentinel;
    CACHEDFONT*     pcf;
    GLYPHALLOC*     pga;
    GLYPHALLOC*     pgaNext;
    CACHEDGLYPH**   ppcg;
    LONG            i;

    ASSERTDD(ppdev->flStatus & STAT_GLYPH_CACHE, "No glyph cache to be blown");

    // Reset our current glyph variables:

    ppdev->ulGlyphCurrent = ppdev->ulGlyphStart;

    ///////////////////////////////////////////////////////////////////

    // Now invalidate all active cached fonts:

    pcfSentinel = &ppdev->cfSentinel;
    for (pcf = pcfSentinel->pcfNext; pcf != pcfSentinel; pcf = pcf->pcfNext)
    {
        // Reset all the hash table entries to point to the cached-font
        // sentinel.  This effectively resets the cache for this font:

        for (ppcg = &pcf->apcg[0], i = GLYPH_HASH_SIZE; i != 0; i--, ppcg++)
        {
            *ppcg = &pcf->cgSentinel;
        }

        // We may as well free all glyph position allocations for this font:

        pga = pcf->pgaChain;
        while (pga != NULL)
        {
            pgaNext = pga->pgaNext;
            EngFreeMem(pga);
            pga = pgaNext;
        }

        pcf->pgaChain = NULL;
        pcf->cjAlloc  = 0;
    }
}

/******************************Public*Routine******************************\
* VOID vTrimAndPackGlyph
*
\**************************************************************************/

VOID vTrimAndPackGlyph(
BYTE*   pjBuf,          // Note: Routine may touch preceding byte!
BYTE*   pjGlyph,
LONG*   pcxGlyph,
LONG*   pcyGlyph,
POINTL* pptlOrigin)
{
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    LONG    cAlign;
    LONG    lDelta;
    BYTE*   pj;
    BYTE    jBit;
    LONG    cjSrcWidth;
    LONG    lSrcSkip;
    LONG    lDstSkip;
    LONG    cRem;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;
    BYTE    jSrc;

    ///////////////////////////////////////////////////////////////
    // Trim the glyph

    cyGlyph   = *pcyGlyph;
    cxGlyph   = *pcxGlyph;
    ptlOrigin = *pptlOrigin;
    cAlign    = 0;

    lDelta = (cxGlyph + 7) >> 3;

    // Trim off any zero rows at the bottom of the glyph:

    pj = pjGlyph + cyGlyph * lDelta;    // One past last byte in glyph
    while (cyGlyph > 0)
    {
        i = lDelta;
        do {
            if (*(--pj) != 0)
                goto Done_Bottom_Trim;
        } while (--i != 0);

        // The entire last row has no lit pixels, so simply skip it:

        cyGlyph--;
    }

    ASSERTDD(cyGlyph == 0, "cyGlyph should only be zero here");

    // We found a space character.  Set both dimensions to zero, so
    // that it's easy to special-case later:

    cxGlyph = 0;

Done_Bottom_Trim:

    // If cxGlyph != 0, we know that the glyph has at least one non-zero
    // row and column.  By exploiting this knowledge, we can simplify our
    // end-of-loop tests, because we don't have to check to see if we've
    // decremented either 'cyGlyph' or 'cxGlyph' to zero:

    if (cxGlyph != 0)
    {
        // Trim off any zero rows at the top of the glyph:

        pj = pjGlyph;                       // First byte in glyph
        while (TRUE)
        {
            i = lDelta;
            do {
                if (*(pj++) != 0)
                    goto Done_Top_Trim;
            } while (--i != 0);

            // The entire first row has no lit pixels, so simply skip it:

            cyGlyph--;
            ptlOrigin.y++;
            pjGlyph = pj;
        }

Done_Top_Trim:

        // Trim off any zero columns at the right edge of the glyph:

        while (TRUE)
        {
            j    = cxGlyph - 1;

            pj   = pjGlyph + (j >> 3);      // Last byte in first row of glyph
            jBit = gajBit[j & 0x7];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Right_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire last column has no lit pixels, so simply skip it:

            cxGlyph--;
        }

Done_Right_Trim:

        // Trim off any zero columns at the left edge of the glyph:

        while (TRUE)
        {
            pj   = pjGlyph;                 // First byte in first row of glyph
            jBit = gajBit[cAlign];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Left_Trim;

                pj += lDelta;
            } while (--i != 0);

            // The entire first column has no lit pixels, so simply skip it:

            ptlOrigin.x++;
            cxGlyph--;
            cAlign++;
            if (cAlign >= 8)
            {
                cAlign = 0;
                pjGlyph++;
            }
        }
    }

Done_Left_Trim:

    ///////////////////////////////////////////////////////////////
    // Pack the glyph

    cjSrcWidth  = (cxGlyph + cAlign + 7) >> 3;
    lSrcSkip    = lDelta - cjSrcWidth;
    lDstSkip    = ((cxGlyph + 7) >> 3) - cjSrcWidth - 1;
    cRem        = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8

    pjSrc       = pjGlyph;
    pjDst       = pjBuf;

    // Zero the buffer, because we're going to 'or' stuff into it:

    memset(pjBuf, 0, (cxGlyph * cyGlyph + 7) >> 3);

    // cAlign used to indicate which bit in the first byte of the unpacked
    // glyph was the first non-zero pixel column.  Now, we flip it to
    // indicate which bit in the packed byte will receive the next non-zero
    // glyph bit:

    cAlign = (-cAlign) & 0x7;
    if (cAlign > 0)
    {
        // It would be bad if our trimming calculations were wrong, because
        // we assume any bits to the left of the 'cAlign' bit will be zero.
        // As a result of this decrement, we will 'or' those zero bits into
        // whatever byte precedes the glyph bits array:

        pjDst--;

        ASSERTDD((*pjSrc >> cAlign) == 0, "Trimmed off too many bits");
    }

    for (i = cyGlyph; i != 0; i--)
    {
        for (j = cjSrcWidth; j != 0; j--)
        {
            // Note that we may modify a byte past the end of our
            // destination buffer, which is why we reserved an
            // extra byte:

            jSrc = *pjSrc;
            *(pjDst)     |= (jSrc >> (cAlign));
            *(pjDst + 1) |= (jSrc << (8 - cAlign));
            pjSrc++;
            pjDst++;
        }

        pjSrc  += lSrcSkip;
        pjDst  += lDstSkip;
        cAlign += cRem;

        if (cAlign >= 8)
        {
            cAlign -= 8;
            pjDst++;
        }
    }

    ///////////////////////////////////////////////////////////////
    // Return results

    *pcxGlyph   = cxGlyph;
    *pcyGlyph   = cyGlyph;
    *pptlOrigin = ptlOrigin;
}

/******************************Public*Routine******************************\
* VOID vPackGlyph
*
\**************************************************************************/

VOID vPackGlyph(
BYTE*   pjBuf,
BYTE*   pjGlyph,
LONG    cxGlyph,
LONG    cyGlyph)
{
    LONG    cjSrcWidth;
    BYTE    jSrc;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    cAlign;
    LONG    i;
    LONG    j;
    LONG    cRem;

    ///////////////////////////////////////////////////////////////
    // Pack the glyph:

    cjSrcWidth = (cxGlyph + 7) >> 3;
    cRem       = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8
    cAlign     = 0;

    pjSrc  = pjGlyph;
    pjDst  = pjBuf;
    *pjDst = 0;                 // Have to zero very first byte

    i = cyGlyph;
    do {
        j = cjSrcWidth;
        do {
            jSrc = *pjSrc;

            *(pjDst) |= (jSrc >> (cAlign));

            // Note that we may modify a byte past the end of our
            // destination buffer, which is why we reserved an
            // extra byte:

            *(pjDst + 1) = (jSrc << (8 - cAlign));

            pjSrc++;
            pjDst++;

        } while (--j != 0);

        pjDst--;
        cAlign += cRem;
        if (cAlign >= 8)
        {
            cAlign -= 8;
            pjDst++;
        }

    } while (--i != 0);
}

/******************************Public*Routine******************************\
* BOOL bPutGlyphInCache
*
* Figures out where to be a glyph in off-screen memory, copies it
* there, and fills in any other data we'll need to display the glyph.
*
* This routine is rather device-specific, and will have to be extensively
* modified for other display adapters.
*
* Returns TRUE if successful; FALSE if there wasn't enough room in
* off-screen memory.
*
\**************************************************************************/

BOOL bPutGlyphInCache(
PDEV*           ppdev,
CACHEDGLYPH*    pcg,
GLYPHBITS*      pgb)
{
    BYTE*   pjBase;
    BYTE*   pjGlyph;
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    BYTE*   pjSrc;
    ULONG*  pulSrc;
    ULONG*  pulDst;
    LONG    i;
    LONG    cPels;
    ULONG   ulGlyphThis;
    ULONG   ulGlyphNext;
    ULONG   ul;
    ULONG   ulStart;
    BYTE    ajBuf[MAX_GLYPH_SIZE + 4];  // Leave room at end for scratch space

    pjBase = ppdev->pjBase;

    pjGlyph   = pgb->aj;
    cyGlyph   = pgb->sizlBitmap.cy;
    cxGlyph   = pgb->sizlBitmap.cx;
    ptlOrigin = pgb->ptlOrigin;

    vTrimAndPackGlyph(&ajBuf[0], pjGlyph, &cxGlyph, &cyGlyph, &ptlOrigin);

    ASSERTDD(((cyGlyph * cxGlyph + 7) / 8 + 1) <= sizeof(ajBuf),
             "Overran end of temporary glyph storage");

    ///////////////////////////////////////////////////////////////
    // Find spot for glyph in off-screen memory

    cPels       = cyGlyph * cxGlyph;            // Note that this may be zero
    ulGlyphThis = ppdev->ulGlyphCurrent;
    ulGlyphNext = ulGlyphThis + ((cPels + 31) & ~31);   // Dword aligned

    if (ulGlyphNext >= ppdev->ulGlyphEnd)
    {
        // There's isn't enough free room in the off-screen cache for another
        // glyph.  Let the caller know that it should call 'vBlowGlyphCache'
        // to free up space.
        //
        // First, make sure that this glyph will fit in the cache when it's
        // empty, too:

        ASSERTDD(ppdev->ulGlyphStart + cPels < ppdev->ulGlyphEnd,
            "Glyph can't fit in empty cache -- where's the higher-level check?");

        return(FALSE);
    }

    // Remember where the next glyph goes:

    ppdev->ulGlyphCurrent = ulGlyphNext;

    ///////////////////////////////////////////////////////////////
    // Initialize the glyph fields

    // Note that cxLessOne and ulLinearEnd will be invalid for a
    // 'space' character, so the rendering routine had better watch
    // for a height of zero:

    pcg->ptlOrigin     = ptlOrigin;
    pcg->cy            = cyGlyph;
    pcg->cxLessOne     = cxGlyph - 1;
    pcg->ulLinearStart = ulGlyphThis;
    pcg->ulLinearEnd   = ulGlyphThis + cPels - 1;

    ///////////////////////////////////////////////////////////////
    // Download the glyph

    ulStart = ulGlyphThis >> 3;

    // Copy the bit flipped glyph to off-screen:

    if (ppdev->ulBoardId == MGA_STORM)
    {
        pulSrc = (ULONG*) ajBuf;
        pulDst = (ULONG*) (ppdev->pjScreen + ulStart);

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

        START_DIRECT_ACCESS_STORM(ppdev, pjBase);

        for (i = (cPels + 31) >> 5; i != 0; i--)
        {
            *pulDst++ = *pulSrc++;
        }

        END_DIRECT_ACCESS_STORM(ppdev, pjBase);
    }
    else
    {
        pjSrc  = ajBuf;
        pulDst = (ULONG*) (ppdev->pjBase + SRCWND + (ulStart & 31));

        if (ppdev->iBitmapFormat != BMF_8BPP)
        {
            // We have to set the plane write mask even when using direct
            // access.  It doesn't matter at 8bpp:

            CHECK_FIFO_SPACE(pjBase, 1);
            CP_WRITE(pjBase, DWG_PLNWT, plnwt_ALL);
        }

        CHECK_FIFO_SPACE(pjBase, FIFOSIZE);

        WAIT_NOT_BUSY(pjBase);

        CP_WRITE(pjBase, HST_DSTPAGE, ulStart);

        START_DIRECT_ACCESS_MGA_NO_WAIT(ppdev, pjBase);

        for (i = (cPels + 31) >> 5; i != 0; i--)
        {
            ul  = gajFlip[*pjSrc++];
            ul |= gajFlip[*pjSrc++] << 8;
            ul |= gajFlip[*pjSrc++] << 16;
            ul |= gajFlip[*pjSrc++] << 24;

            // The '0' specifies a zero offset from pointer 'pulDst':

            CP_WRITE_DIRECT(pulDst, 0, ul);

            pulDst++;
        }

        END_DIRECT_ACCESS_MGA(ppdev, pjBase);

        if (ppdev->iBitmapFormat != BMF_8BPP)
        {
            // Restore the plane write mask:

            CHECK_FIFO_SPACE(pjBase, 1);
            CP_WRITE(pjBase, DWG_PLNWT, ppdev->ulPlnWt);
        }
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* CACHEDGLYPH* pcgNew()
*
* Creates a new CACHEDGLYPH structure for keeping track of the glyph in
* off-screen memory.  bPutGlyphInCache is called to actually put the glyph
* in off-screen memory.
*
* This routine should be reasonably device-independent, as bPutGlyphInCache
* will contain most of the code that will have to be modified for other
* display adapters.
*
\**************************************************************************/

CACHEDGLYPH* pcgNew(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp)
{
    GLYPHALLOC*     pga;
    CACHEDGLYPH*    pcg;
    LONG            cjCachedGlyph;
    HGLYPH          hg;
    LONG            iHash;
    CACHEDGLYPH*    pcgFind;

Restart:

    // First, calculate the amount of storage we'll need for this glyph:

    cjCachedGlyph = sizeof(CACHEDGLYPH);

    if (cjCachedGlyph > pcf->cjAlloc)
    {
        // Have to allocate a new glyph allocation structure:

        pga = EngAllocMem(FL_ZERO_MEMORY, GLYPH_ALLOC_SIZE, ALLOC_TAG);
        if (pga == NULL)
        {
            // It's safe to return at this time because we haven't
            // fatally altered any of our data structures:

            return(NULL);
        }

        // Add this allocation to the front of the allocation linked list,
        // so that we can free it later:

        pga->pgaNext  = pcf->pgaChain;
        pcf->pgaChain = pga;

        // Now we've got a chunk of memory where we can store our cached
        // glyphs:

        pcf->pcgNew  = &pga->acg[0];
        pcf->cjAlloc = GLYPH_ALLOC_SIZE - (sizeof(*pga) - sizeof(pga->acg[0]));
    }

    pcg = pcf->pcgNew;

    // We only need to ensure 'dword' alignment of the next structure:

    pcf->pcgNew   = (CACHEDGLYPH*) ((BYTE*) pcg + cjCachedGlyph);
    pcf->cjAlloc -= cjCachedGlyph;

    ///////////////////////////////////////////////////////////////
    // Insert the glyph, in-order, into the list hanging off our hash
    // bucket:

    hg = pgp->hg;

    pcg->hg = hg;
    iHash   = GLYPH_HASH_FUNC(hg);
    pcgFind = pcf->apcg[iHash];

    if (pcgFind->hg > hg)
    {
        pcf->apcg[iHash] = pcg;
        pcg->pcgNext     = pcgFind;
    }
    else
    {
        // The sentinel will ensure that we never fall off the end of
        // this list:

        while (pcgFind->pcgNext->hg < hg)
            pcgFind = pcgFind->pcgNext;

        // 'pcgFind' now points to the entry to the entry after which
        // we want to insert our new node:

        pcg->pcgNext     = pcgFind->pcgNext;
        pcgFind->pcgNext = pcg;
    }

    ///////////////////////////////////////////////////////////////
    // Download the glyph into off-screen memory:

    if (!bPutGlyphInCache(ppdev, pcg, pgp->pgdf->pgb))
    {
        // If there was no more room in off-screen memory, blow the
        // glyph cache and start over.  Note that this assumes that
        // the glyph will fit in the cache when the cache is completely
        // empty.

        vBlowGlyphCache(ppdev);
        goto Restart;
    }

    return(pcg);
}

/******************************Public*Routine******************************\
* BOOL bMgaCachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching for the MGA.
*
\**************************************************************************/

BOOL bMgaCachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjBase;
    LONG            xOffset;
    LONG            yOffset;
    CHAR            cFifo;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            cy;
    LONG            x;
    LONG            y;

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    cFifo   = 0;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext;         // Traverse collision list, if any

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);

            cFifo = 0;                  // Have to reset count
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        cy = pcg->cy;
        if (cy != 0)
        {
            x = pgp->ptl.x + pcg->ptlOrigin.x + xOffset;
            y = pgp->ptl.y + pcg->ptlOrigin.y + yOffset;

            // We get a little tricky here and try to amortize the cost of
            // the read for checking the FIFO count on the MGA.  Doing so
            // gave us a 6% and 14% win on 21pt and 16pt text, respectively,
            // on a P90:

            cFifo -= 6;
            if (cFifo < 0)
            {
                do {
                    cFifo = GET_FIFO_SPACE(pjBase) - 6;
                } while (cFifo < 0);
            }

            CP_WRITE(pjBase, DWG_LEN,     cy);
            CP_WRITE(pjBase, DWG_YDST,    y);
            CP_WRITE(pjBase, DWG_FXLEFT,  x);
            CP_WRITE(pjBase, DWG_FXRIGHT, x + pcg->cxLessOne);
            CP_WRITE(pjBase, DWG_AR3,     pcg->ulLinearStart);
            CP_START(pjBase, DWG_AR0,     pcg->ulLinearEnd);
        }
    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bMilCachedProportionalText
*
* Draws proportionally spaced glyphs via glyph caching for the Millennium.
*
\**************************************************************************/

BOOL bMilCachedProportionalText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph)
{
    BYTE*           pjBase;
    LONG            xOffset;
    LONG            yOffset;
    CHAR            cFifo;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            cy;
    LONG            x;
    LONG            y;

    pjBase  = ppdev->pjBase;
    xOffset = ppdev->xOffset;
    yOffset = ppdev->yOffset;
    cFifo   = 0;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext;         // Traverse collision list, if any

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);

            cFifo = 0;                  // Have to reset count
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        cy = pcg->cy;
        if (cy != 0)
        {
            x = pgp->ptl.x + pcg->ptlOrigin.x + xOffset;
            y = pgp->ptl.y + pcg->ptlOrigin.y + yOffset;

            cFifo -= 4;
            if (cFifo < 0)
            {
                do {
                    cFifo = GET_FIFO_SPACE(pjBase) - 4;
                } while (cFifo < 0);
            }

            CP_WRITE(pjBase, DWG_YDSTLEN, (y << yval_SHIFT) | cy);
            CP_WRITE(pjBase, DWG_FXBNDRY, ((x + pcg->cxLessOne) << bfxright_SHIFT) |
                                          x);
            CP_WRITE(pjBase, DWG_AR3,     pcg->ulLinearStart);
            CP_START(pjBase, DWG_AR0,     pcg->ulLinearEnd);
        }
    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bCachedFixedText
*
* Draws fixed spaced glyphs via glyph caching.
*
\**************************************************************************/

BOOL bCachedFixedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp,
LONG        cGlyph,
ULONG       ulCharInc)
{
    BYTE*           pjBase;
    LONG            xGlyph;
    LONG            yGlyph;
    CHAR            cFifo;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            cy;
    LONG            x;
    LONG            y;

    pjBase = ppdev->pjBase;
    xGlyph = ppdev->xOffset + pgp->ptl.x;
    yGlyph = ppdev->yOffset + pgp->ptl.y;
    cFifo  = 0;

    do {
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext;         // Traverse collision list, if any

        if (pcg->hg > hg)
        {
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.

            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
                return(FALSE);

            cFifo = 0;                  // Have to reset count
        }

        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:

        cy = pcg->cy;
        if (cy != 0)
        {
            x = xGlyph + pcg->ptlOrigin.x;
            y = yGlyph + pcg->ptlOrigin.y;

            cFifo -= 6;
            if (cFifo < 0)
            {
                do {
                    cFifo = GET_FIFO_SPACE(pjBase) - 6;
                } while (cFifo < 0);
            }

            CP_WRITE(pjBase, DWG_LEN,     cy);
            CP_WRITE(pjBase, DWG_YDST,    y);
            CP_WRITE(pjBase, DWG_FXLEFT,  x);
            CP_WRITE(pjBase, DWG_FXRIGHT, x + pcg->cxLessOne);
            CP_WRITE(pjBase, DWG_AR3,     pcg->ulLinearStart);
            CP_START(pjBase, DWG_AR0,     pcg->ulLinearEnd);
        }

        xGlyph += ulCharInc;

    } while (pgp++, --cGlyph != 0);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bCachedClippedText
*
* Draws clipped text via glyph caching.
*
\**************************************************************************/

BOOL bCachedClippedText(
PDEV*       ppdev,
CACHEDFONT* pcf,
STROBJ*     pstro,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjBase;
    LONG            xOffset;
    LONG            yOffset;
    CHAR            cFifo;
    BOOL            bMoreGlyphs;
    ULONG           cGlyphOriginal;
    ULONG           cGlyph;
    BOOL            bClipSet;
    GLYPHPOS*       pgpOriginal;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            cy;
    BOOL            bMore;
    CLIPENUM        ce;
    RECTL*          prclClip;
    ULONG           ulCharInc;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
             "Don't expect trivial clipping in this function");

    bRet      = TRUE;
    pjBase    = ppdev->pjBase;
    xOffset   = ppdev->xOffset;
    yOffset   = ppdev->yOffset;
    ulCharInc = pstro->ulCharInc;

    do {
      if (pstro->pgp != NULL)
      {
        // There's only the one batch of glyphs, so save ourselves
        // a call:

        pgpOriginal    = pstro->pgp;
        cGlyphOriginal = pstro->cGlyphs;
        bMoreGlyphs    = FALSE;
      }
      else
      {
        bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyphOriginal, &pgpOriginal);
      }

      if (cGlyphOriginal > 0)
      {
        if (pco->iDComplexity == DC_RECT)
        {
          // We could call 'cEnumStart' and 'bEnum' when the clipping is
          // DC_RECT, but the last time I checked, those two calls took
          // more than 150 instructions to go through GDI.  Since
          // 'rclBounds' already contains the DC_RECT clip rectangle,
          // and since it's such a common case, we'll special case it:

          bMore    = FALSE;
          ce.c     = 1;
          prclClip = &pco->rclBounds;

          goto SingleRectangle;
        }

        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

        do {
          bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

          for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
          {

          SingleRectangle:

            // We don't always simply set the clipping rectangle here
            // because it may actually end up that no text intersects
            // this clip rectangle, so it would be for naught.  This
            // actually happens a lot when using NT's analog clock set
            // to always-on-top, with a round shape:

            bClipSet = FALSE;

            pgp    = pgpOriginal;
            cGlyph = cGlyphOriginal;

            // We can't yet convert to absolute coordinates by adding
            // in 'xOffset' or 'yOffset' here because we have yet to
            // compare the coordinates to 'prclClip':

            xGlyph = pgp->ptl.x;
            yGlyph = pgp->ptl.y;

            // Loop through all the glyphs for this rectangle:

            while (TRUE)
            {
              hg  = pgp->hg;
              pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

              while (pcg->hg < hg)
                pcg = pcg->pcgNext;

              if (pcg->hg > hg)
              {
                // This will hopefully not be the common case (that is,
                // we will have a high cache hit rate), so if I were
                // writing this in Asm I would have this out-of-line
                // to avoid the jump around for the common case.
                // But the Pentium has branch prediction, so what the
                // heck.

                pcg = pcgNew(ppdev, pcf, pgp);
                if (pcg == NULL)
                {
                  bRet = FALSE;
                  goto AllDone;
                }
                cFifo = 0;                  // Have to reset count
              }

              // Space glyphs are trimmed to a height of zero, and we don't
              // even have to touch the hardware for them:

              cy = pcg->cy;
              if (cy != 0)
              {
                y      = pcg->ptlOrigin.y + yGlyph;
                x      = pcg->ptlOrigin.x + xGlyph;
                xRight = pcg->cxLessOne + x;

                // Do trivial rejection:

                if ((prclClip->right  > x) &&
                    (prclClip->bottom > y) &&
                    (prclClip->left   <= xRight) &&
                    (prclClip->top    < y + cy))
                {
                  // Lazily set the hardware clipping:

                  if (!bClipSet)
                  {
                    bClipSet = TRUE;
                    vSetClipping(ppdev, prclClip);
                    cFifo = 0;              // Have to initialize count
                  }

                  cFifo -= 6;
                  if (cFifo < 0)
                  {
                      do {
                          cFifo = GET_FIFO_SPACE(pjBase) - 6;
                      } while (cFifo < 0);
                  }

                  CP_WRITE(pjBase, DWG_LEN,     cy);
                  CP_WRITE(pjBase, DWG_YDST,    yOffset + y);
                  CP_WRITE(pjBase, DWG_FXLEFT,  xOffset + x);
                  CP_WRITE(pjBase, DWG_FXRIGHT, xOffset + xRight);
                  CP_WRITE(pjBase, DWG_AR3,     pcg->ulLinearStart);
                  CP_START(pjBase, DWG_AR0,     pcg->ulLinearEnd);
                }
              }

              if (--cGlyph == 0)
                break;

              // Get ready for next glyph:

              pgp++;

              if (ulCharInc == 0)
              {
                xGlyph = pgp->ptl.x;
                yGlyph = pgp->ptl.y;
              }
              else
              {
                xGlyph += ulCharInc;
              }
            }
          }
        } while (bMore);
      }
    } while (bMoreGlyphs);

AllDone:

    vResetClipping(ppdev);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DrvTextOut
*
\**************************************************************************/

BOOL DrvTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,    // If we had set GCAPS_HORIZSTRIKE, we would have
                        //   to fill these extra rectangles (it is used
                        //   largely for underlines).  It's not a big
                        //   performance win (GDI will call our DrvBitBlt
                        //   to draw the extra rectangles).
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlBrush,    // Always unused, unless GCAPS_ARBRUSHOPAQUE set
MIX       mix)          // Always a copy mix (0x0d0d)
{
    PDEV*           ppdev;
    LONG            xOffset;
    LONG            yOffset;
    DSURF*          pdsurf;
    OH*             poh;
    BYTE*           pjBase;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    CACHEDFONT*     pcf;
    RECTL           rclOpaque;

    pdsurf = (DSURF*) pso->dhsurf;
    if (pdsurf->dt != DT_DIB)
    {
      poh            = pdsurf->poh;
      ppdev          = (PDEV*) pso->dhpdev;
      xOffset        = poh->x;
      yOffset        = poh->y;
      ppdev->xOffset = xOffset;
      ppdev->yOffset = yOffset;

      // The DDI spec says we'll only ever get foreground and background
      // mixes of R2_COPYPEN:

      ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");

      pjBase = ppdev->pjBase;

      iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

      if (prclOpaque != NULL)
      {
        ////////////////////////////////////////////////////////////
        // Opaque Initialization
        ////////////////////////////////////////////////////////////

        if (iDComplexity == DC_TRIVIAL)
        {

        DrawOpaqueRect:

            if (ppdev->ulBoardId == MGA_STORM)
            {
                CHECK_FIFO_SPACE(pjBase, 4);
                if (ppdev->iBitmapFormat == BMF_24BPP)
                {
                    CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP + atype_RPL + blockm_OFF +
                                                  pattern_OFF + transc_BG_OPAQUE +
                                                  arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                                                  solid_SOLID + bop_SRCCOPY);
                }
                else
                {
                    CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP + atype_RPL + blockm_ON +
                                                  pattern_OFF + transc_BG_OPAQUE +
                                                  arzero_ZERO + sgnzero_ZERO + shftzero_ZERO +
                                                  solid_SOLID + bop_SRCCOPY);
                }
                CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, pboOpaque->iSolidColor));
                ppdev->HopeFlags = (SIGN_CACHE | ARX_CACHE | PATTERN_CACHE);

                CP_WRITE(pjBase, DWG_FXBNDRY,
                                (((prclOpaque->right + xOffset) << bfxright_SHIFT) |
                                 ((prclOpaque->left  + xOffset) & bfxleft_MASK)));

                // ylength_MASK not is needed since coordinates are within range

                CP_START(pjBase, DWG_YDSTLEN,
                                (((prclOpaque->top    + yOffset  ) << yval_SHIFT) |
                                 ((prclOpaque->bottom - prclOpaque->top))));
            }
            else
            {
                CHECK_FIFO_SPACE(pjBase, 15);

                CP_WRITE(pjBase, DWG_DWGCTL, opcode_TRAP + atype_RPL + blockm_ON +
                                              pattern_OFF + transc_BG_OPAQUE +
                                              bop_SRCCOPY);

                CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, pboOpaque->iSolidColor));

                if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
                {
                    CP_WRITE(pjBase, DWG_SGN, 0);
                }

                if (!(GET_CACHE_FLAGS(ppdev, ARX_CACHE)))
                {
                    CP_WRITE(pjBase, DWG_AR1, 0);
                    CP_WRITE(pjBase, DWG_AR2, 0);
                    CP_WRITE(pjBase, DWG_AR4, 0);
                    CP_WRITE(pjBase, DWG_AR5, 0);
                }

                if (!(GET_CACHE_FLAGS(ppdev, PATTERN_CACHE)))
                {
                    CP_WRITE(pjBase, DWG_SRC0, 0xFFFFFFFF);
                    CP_WRITE(pjBase, DWG_SRC1, 0xFFFFFFFF);
                    CP_WRITE(pjBase, DWG_SRC2, 0xFFFFFFFF);
                    CP_WRITE(pjBase, DWG_SRC3, 0xFFFFFFFF);
                }

                ppdev->HopeFlags = (SIGN_CACHE | ARX_CACHE | PATTERN_CACHE);

                CP_WRITE(pjBase, DWG_FXLEFT,  prclOpaque->left   + xOffset);
                CP_WRITE(pjBase, DWG_FXRIGHT, prclOpaque->right  + xOffset);
                CP_WRITE(pjBase, DWG_LEN,     prclOpaque->bottom - prclOpaque->top);
                CP_START(pjBase, DWG_YDST,    prclOpaque->top    + yOffset);
            }
        }
        else if (iDComplexity == DC_RECT)
        {
            if (bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque))
            {
                prclOpaque = &rclOpaque;
                goto DrawOpaqueRect;
            }
        }
        else
        {
            vClipSolid(ppdev, prclOpaque, pboOpaque->iSolidColor, pco);
        }
      }

      ////////////////////////////////////////////////////////////
      // Transparent Initialization
      ////////////////////////////////////////////////////////////

      // Initialize the hardware for transparent text:

      CHECK_FIFO_SPACE(pjBase, 4);

      CP_WRITE(pjBase, DWG_FCOL, COLOR_REPLICATE(ppdev, pboFore->iSolidColor));

      if (!(GET_CACHE_FLAGS(ppdev, SIGN_CACHE)))
      {
        CP_WRITE(pjBase, DWG_SGN, 0);
      }

      if ((pfo->cxMax <= GLYPH_CACHE_CX) &&
          ((pstro->rclBkGround.bottom - pstro->rclBkGround.top) <= GLYPH_CACHE_CY) &&
          (ppdev->flStatus & STAT_GLYPH_CACHE))
      {
        // Complete setup for transparent monochrome expansions from
        // off-screen memory, using block mode if possible:

        CP_WRITE(pjBase, DWG_DWGCTL, ppdev->ulTextControl);
        CP_WRITE(pjBase, DWG_SHIFT,  0);

        ppdev->HopeFlags = SIGN_CACHE;

        pcf = (CACHEDFONT*) pfo->pvConsumer;

        if (pcf == NULL)
        {
          pcf = pcfAllocateCachedFont(ppdev);
          if (pcf == NULL)
            return(FALSE);

          pfo->pvConsumer = pcf;
        }

        // Use our glyph cache:

        if (iDComplexity == DC_TRIVIAL)
        {
          do {
            if (pstro->pgp != NULL)
            {
              // There's only the one batch of glyphs, so save ourselves
              // a call:

              pgp         = pstro->pgp;
              cGlyph      = pstro->cGlyphs;
              bMoreGlyphs = FALSE;
            }
            else
            {
              bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
            }

            if (cGlyph > 0)
            {
              if (pstro->ulCharInc == 0)
              {
                if (ppdev->ulBoardId == MGA_STORM)
                {
                  if (!bMilCachedProportionalText(ppdev, pcf, pgp, cGlyph))
                    return(FALSE);
                }
                else
                {
                  if (!bMgaCachedProportionalText(ppdev, pcf, pgp, cGlyph))
                    return(FALSE);
                }
              }
              else
              {
                if (!bCachedFixedText(ppdev, pcf, pgp, cGlyph, pstro->ulCharInc))
                  return(FALSE);
              }
            }
          } while (bMoreGlyphs);
        }
        else
        {
          if (!bCachedClippedText(ppdev, pcf, pstro, pco))
            return(FALSE);
        }
      }
      else
      {
        DISPDBG((4, "Text too big to cache: %li x %li",
            pfo->cxMax, pstro->rclBkGround.bottom - pstro->rclBkGround.top));

        // Complete setup for transparent monochrome expansions from the CPU:

        CP_WRITE(pjBase, DWG_DWGCTL, (opcode_ILOAD + atype_RPL + blockm_OFF +
                                         bop_SRCCOPY + trans_0 + bltmod_BMONO +
                                         pattern_OFF + hbgr_SRC_WINDOWS +
                                         transc_BG_TRANSP));

        if (!(GET_CACHE_FLAGS(ppdev, ARX_CACHE)))
        {
          CP_WRITE(pjBase, DWG_AR5, 0);
        }

        ppdev->HopeFlags = SIGN_CACHE;

        if (ppdev->ulBoardId == MGA_STORM)
        {
            vMilGeneralText(ppdev, pstro, pco);
        }
        else
        {
            vMgaGeneralText(ppdev, pstro, pco);
        }
      }
    }
    else
    {
      // We're drawing to a DFB we've converted to a DIB, so just call GDI
      // to handle it:

      return(EngTextOut(pdsurf->pso, pstro, pfo, pco, prclExtra, prclOpaque,
                        pboFore, pboOpaque, pptlBrush, mix));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DrvDestroyFont
*
* Note: Don't forget to export this call in 'enable.c', otherwise you'll
*       get some pretty big memory leaks!
*
* We're being notified that the given font is being deallocated; clean up
* anything we've stashed in the 'pvConsumer' field of the 'pfo'.
*
\**************************************************************************/

VOID DrvDestroyFont(
FONTOBJ*    pfo)
{
    CACHEDFONT* pcf;

    pcf = pfo->pvConsumer;
    if (pcf != NULL)
    {
        vFreeCachedFont(pcf);
        pfo->pvConsumer = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL bEnableText
*
* Performs the necessary setup for the text drawing subcomponent.
*
\**************************************************************************/

BOOL bEnableText(
PDEV*   ppdev)
{
    OH*         poh;
    CACHEDFONT* pcfSentinel;
    LONG        cShift;
    LONG        cFactor;

    if (ppdev->ulBoardId == MGA_STORM)
    {
        if (ppdev->iBitmapFormat == BMF_24BPP)
        {
            ppdev->ulTextControl = opcode_BITBLT + atype_RPL + blockm_OFF +
                                   bop_SRCCOPY + trans_0 + bltmod_BMONOWF +
                                   pattern_OFF + hbgr_SRC_EG3 +
                                   transc_BG_TRANSP + linear_LINEAR_BITBLT;
        }
        else
        {
            ppdev->ulTextControl = opcode_BITBLT + atype_RPL + blockm_ON +
                                   bop_SRCCOPY + trans_0 + bltmod_BMONOWF +
                                   pattern_OFF + hbgr_SRC_EG3 +
                                   transc_BG_TRANSP + linear_LINEAR_BITBLT;
        }
    }
    else
    {
        ppdev->ulTextControl = opcode_BITBLT + atype_RPL + blockm_ON +
                               bop_SRCCOPY + trans_0 + bltmod_BMONO +
                               pattern_OFF + hbgr_SRC_EG3 +
                               transc_BG_TRANSP + linear_LINEAR_BITBLT;
    }

    poh = pohAllocate(ppdev,
                      NULL,
                      ppdev->cxMemory,
                      GLYPH_CACHE_HEIGHT / ppdev->cjPelSize,
                      FLOH_MAKE_PERMANENT);
    if (poh != NULL)
    {
        ppdev->flStatus |= STAT_GLYPH_CACHE;

        // Initialize our doubly-linked cached font list:

        pcfSentinel = &ppdev->cfSentinel;
        pcfSentinel->pcfNext = pcfSentinel;
        pcfSentinel->pcfPrev = pcfSentinel;

        // Setup the display adapter specific glyph data.
        //
        // The linear addresses are computed as bit addresses:

        cFactor = ppdev->cjHwPel * 8;

        ppdev->ulGlyphStart
            = (ppdev->ulYDstOrg + poh->y * ppdev->cxMemory) * cFactor;

        ppdev->ulGlyphCurrent = ppdev->ulGlyphStart;

        ppdev->ulGlyphEnd
            = (ppdev->ulYDstOrg + (poh->y + poh->cy) * ppdev->cxMemory) * cFactor;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDisableText
*
* Performs the necessary clean-up for the text drawing subcomponent.
*
\**************************************************************************/

VOID vDisableText(PDEV* ppdev)
{
    // Here we free any stuff allocated in 'bEnableText'.
}

/******************************Public*Routine******************************\
* VOID vAssertModeText
*
* Disables or re-enables the text drawing subcomponent in preparation for
* full-screen entry/exit.
*
\**************************************************************************/

VOID vAssertModeText(
PDEV*   ppdev,
BOOL    bEnable)
{
    // Our off-screen glyph cache will get destroyed when we switch to
    // full-screen:

    if (!bEnable)
    {
        if (ppdev->flStatus & STAT_GLYPH_CACHE)
        {
            vBlowGlyphCache(ppdev);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\i386\strucs.inc ===
;---------------------------- Include File Header ---------------------------;
; Module Name: strucs.inc
;
; Most of these definitions are pulled straight from winddi.h.  We have
; to copy these here because we don't have any good 'h2inc' C-include-to-
; Asm-include program for NT.
;
; Copyright (c) 1993-1995 Microsoft Corporation
;----------------------------------------------------------------------------;

BMF_1BPP            equ     1
BMF_4BPP            equ     2
BMF_8BPP            equ     3
BMF_16BPP           equ     4
BMF_24BPP           equ     5
BMF_32BPP           equ     6

;-----------------------------------------------------------------------;
; POINTL is used for points with a range of +/- 2G.
;-----------------------------------------------------------------------;

POINTL              STRUC
ptl_x               DD      0
ptl_y               DD      0
POINTL              ENDS

;-----------------------------------------------------------------------;
; SIZEL is used for extents with a range of +/- 2G
;-----------------------------------------------------------------------;

SIZEL               STRUC
sizl_cx             DD      0
sizl_cy             DD      0
SIZEL               ENDS

;-----------------------------------------------------------------------;
; Definition of a rectangle
;-----------------------------------------------------------------------;

RECTL               struc           ; /* rcl */
xLeft               dd      ?
yTop                dd      ?
xRight              dd      ?
yBottom             dd      ?
RECTL               ends

;-----------------------------------------------------------------------;
; Definition of the physical device data structure
;
; NOTE: Changes to this structure must be reflected in driver.h!
;-----------------------------------------------------------------------;

PDEV                struc           ; /* pdev, ppdev */
pdev_xOffset            dd  ?
pdev_yOffset            dd  ?
pdev_cxMemory           dd  ?
pdev_cyMemory           dd  ?
pdev_pjBase             dd  ?
pdev_pjScreen           dd  ?
pdev_lDelta             dd  ?
pdev_ulYDstOrg          dd  ?
PDEV                ends

;-----------------------------------------------------------------------;
; Macro to do a simple RET, with no stack stuff, in a proc.
;-----------------------------------------------------------------------;

PLAIN_RET macro
        db      0c3h
        endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\bind.h ===
/*****************************************************************************
*
*   file name:   bind.h
*
******************************************************************************/

#ifndef BIND_H  /* useful for header inclusion check, used by DDK */ 
#define BIND_H


#if 0   /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

/* BDL should be enabled by __HC303__ only & not by High C 1.73 ???
 *      __HIGHC__ is not automatically enabled by HIGH C3.03
 *  Verify if this is correct.
 */

#ifdef __HIGHC__  

pragma Off(Args_in_regs_for_locals);

#endif

#else

#ifdef __HC303__

#ifdef __ANSI_C__
#define _REGS     REGS

/*** Configuration for compatibility with ASM ***/
#pragma Off(Args_in_regs_for_locals);
#else
/*** Configuration for compatibility with ASM ***/
pragma Off(Args_in_regs_for_locals);
#endif /* __ANSI_C__ */

#endif /* __HC303__ */

#endif /* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */


#ifdef WINDOWS_NT
    #include "video.h"

    #define _itoa       itoa
    #define _strnicmp   strnicmp
    #define _inp(a)     VideoPortReadPortUchar((PUCHAR)(a))
    #define _outp(a, d) VideoPortWritePortUchar((PUCHAR)(a), (d))
    #define _stat       stat
    #define inpw(a)     VideoPortReadPortUshort((PUSHORT)(a))
    #define outpw(a, d) VideoPortWritePortUshort((PUSHORT)(a), (d))
    #define indw(a)     VideoPortReadPortUlong((PULONG)(a))
    #define outdw(a, d) VideoPortWritePortUlong((PULONG)(a), (d))
    #define HANDLE      word
    #define WORD        word
#endif  /* #ifdef WINDOWS_NT */


#ifndef XGXENV_H  /* 
                   * Avoids multiple redefinitions, bind.h should always
                   * be placed above xgxenv.h
                   */

/* data type */

typedef int             bool;           /* boolean */
typedef unsigned char   byte;           /* 8-bit datum */
typedef unsigned short  word;           /* 16-bit datum */
typedef short           sword;          /* 16-bit datum */
typedef unsigned long   dword;          /* 32-bit datum */
typedef long            sdword;         /* 32-bit datum */

#endif /* XGXENV_H */


/*** RGB color ***/
typedef dword   mtxRGB;     /* red 0-7, green 8-15, blue 16-23 */

/*** RGB color mask ***/
typedef dword   mtxRGBMASK; /* red 0-7, green 8-15, blue 16-23 */


#define PUBLIC
#define PRIVATE         static

#define FALSE           0
#define TRUE            1
#define DONT_CARE       0

#define ZOOMx1          0x00010001      /* no zoom */
#define SIZDW_BUFFER    8100            /* size of posting buffer */


#define mtxVGA          0
#define mtxADV_MODE     1
#define mtxRES_NTSC     2
#define mtxRES_PAL      3

#define mtxFAIL         0
#define mtxOK           1
#define MAXCLIPRECT     10


/*** MGA PRODUCT TYPE ***/

#define  MGA_ULTIMA              1
#define  MGA_ULTIMA_VAFC         2
#define  MGA_ULTIMA_PLUS         3
#define  MGA_ULTIMA_PLUS_200     4
#define  MGA_IMPRESSION_PLUS     5
#define  MGA_IMPRESSION_PLUS_200 6
#define  MGA_IMPRESSION          7
#define  MGA_IMPRESSION_PRO      8
#define  MGA_IMPRESSION_LTE      9

typedef dword           mtxCL;          /* CL I.D. */
typedef dword           mtxRC;          /* RC I.D. */
typedef dword           mtxLSDB;        /* LSDB I.D. */

/*
 *  Cursor definition
 */
typedef struct {
    word    Width;
    word    Height;
    word    Pitch;
    word    Format;
    dword  *Data;
} PixMap;


/*
 *  CursorInfo
 */
typedef struct {
    word    MaxWidth;
    word    MaxHeight;
    word    MaxDepth;
    word    MaxColors;
    word    CurWidth;
    word    CurHeight;
    sword   cHotSX;
    sword   cHotSY;
    sword   HotSX;
    sword   HotSY;
} CursorInfo;


/*
 *  Offscreen memory
 */
typedef struct {
    word    Type;       /* bit 0 : 0 = normal off screen memory */
                        /*         1 = z-buffer memory */
                        /* bit 1 : 0 = vram            */
                        /*         1 = dram            */
                        /* bit 2 : 0 = supports block mode */
                        /*         1 = no block mode */
                        /* bit 3 - 15 : reserved */
    word    XStart;     /* x origin of off screen memory area in pixels */
    word    YStart;     /* y origin of off screen memory area in pixels */
    word    Width;      /* off screen width in pixels */
    word    Height;     /* off screen height in pixels */
    dword   SafePlanes; /* off screen safe memory planes */
    word    ZXStart;    /* precise z-buffer start offset in pixels on YStart. */
                        /* Valid only for z-buffer memory type offscreens ... */
                        /* useful for direct z-buffer access manipulations.   */
} OffScrData;


/*
 *  HwModeData
 */
typedef struct {
    word    DispWidth;  /* maximum display width  in pixels */
    word    DispHeight; /* maximum display height in pixels */
    byte    DispType;   /* bit 0 : 0 = non interlaced,   1 = interlaced */
                        /* bit 1 : 0 = normal operation, 1 = TV_MODE */
                        /* bit 2 : 0 = normal operation, 1 = LUT mode */
                        /* bit 3 : 0 = normal operation, 1 = 565 mode */
                        /* bit 4 : 0 = normal operation, 1 = DB mode */
                        /* bit 5 : 0 = normal operation, 1 = monitor limited */
                        /* bit 6 : 0 = normal operation, 1 = hw limited */
                        /* bit 7 : 0 = normal operation, 1 = not displayable */
    byte    ZBuffer;    /* z-buffer available in this mode */
    word    PixWidth;   /* pixel width */
    dword   NumColors;  /* number of simultaneously displayable colors */
    word    FbPitch;    /* frame buffer pitch in pixels */
    byte    NumOffScr;  /* number of off screen areas */
    OffScrData *pOffScr;   /* pointer to off screen area information */
} HwModeData;


/*
 *  HwData
 */
typedef struct {
    dword       MapAddress;     /* Memory map address */
    dword       ProductType;    
                                /* 0 - 15 : Product platform    */
                                /*          11xx: ISA bus       */           
                                /*          101x: VL bus        */           
                                /*          100x: MCA bus       */           
                                /*          011x: PCI bus       */           
                                /* 16 - 31: Product ID          */
                                /*          0001: MGA_ULTIMA              */
                                /*          0010: MGA_ULTIMA_VAFC         */
                                /*          0011: MGA_ULTIMA_PLUS         */
                                /*          0100: MGA_ULTIMA_PLUS_200     */
                                /*          0101: MGA_IMPRESSION_PLUS     */
                                /*          0110: MGA_IMPRESSION_PLUS_200 */
                                /*          0111: MGA_IMPRESSION          */
                                /*          1000: MGA_IMPRESSION_PRO      */
                                /*          1001: MGA_IMPRESSION_LTE      */
    dword       ProductRev;     /* 4 bit revision codes as follows */
                                /* 0  - 3  : pcb   revision */
                                /* 4  - 7  : Titan revision */
                                /*           (0=TITAN, 1=ATLAS, 2=ATHENA) */
                                /* 8  - 11 : Dubic revision */
                                /*   12    : VideoPro board 0=absent 1=present */
                                /* 13 - 31 : all 1's indicating no other device
                                             present */
    dword       ShellRev;       /* Shell revision */
    dword       BindingRev;     /* Binding revision */

    byte        VGAEnable;      /* 0 = vga disabled, 1 = vga enabled */
    byte        Sync;           /* relects the hardware straps  */
    byte        Device8_16;     /* relects the hardware straps */

    byte        PortCfg;       /* 0-Disabled, 1-Mouse Port, 2-Laser Port */
    byte        PortIRQ;       /* IRQ level number, -1 = interrupts disabled */
    word        MouseMap;      /* Mouse I/O map base if PortCfg = Mouse Port */
                               /* else don't care */
    byte        MouseIRate;    /* Mouse interrupt rate in Hz */
    byte        DacType;       /* 0  = BT482     */
                               /* 1  = VIEWPOINT */
                               /* 2  = BT485     */
                               /* 7  = PX2085    */
                               /* 9  = TVP3026   */
                               /* 92 = SIERRA    */
                               /* 93 = CHAMELEON */
    HwModeData *pCurrentHwMode;         /* Pointer to HwMode */
    HwModeData *pCurrentDisplayMode;    /* Pointer to display mode */
    CursorInfo  cursorInfo;
    dword       VramAvail;          /* VRAM memory available on board in bytes */
    dword       DramAvail;          /* DRAM memory available on board in bytes */
    word        CurrentOverScanX;   /* Left overscan in pixels */
    word        CurrentOverScanY;   /* Top overscan in pixels */
    dword       YDstOrg;            /* Offset physique de la memoire */
    dword       CurrentZoomFactor;
    dword       CurrentXStart;
    dword       CurrentYStart;

  #ifdef WINDOWS_NT
    HwModeData *pHwMode;                /* Pointer to HwMode */
    UCHAR      *BaseAddress;            /* Board base address */
    word        ConfigSpace;            /* Board config space */
    UCHAR      *ConfigSpaceAddress;
  #endif
} HwData;




/*** Prototypes ***/

#ifndef _WATCOM_DLL32
   HwData *mtxCheckHwAll(void);
   bool mtxSelectHw(HwData *pHardware);
   HwModeData *mtxGetHwModes(void);
   word mtxGetRefreshRates(HwModeData *pHwModeSelect);
   word ConvBitToFreq (word BitFreq);
   bool mtxSelectHwMode(HwModeData *pHwMode);
   bool mtxSetDisplayMode(HwModeData *pHwMode, dword Zoom);
   void mtxSetDisplayStart(dword x, dword y);
   dword mtxGetMgaSel(void);
   void mtxGetInfo(HwModeData **_pCurHwMode, HwModeData **_pCurDispMode,
                   byte **_InitBuffer, byte **_VideoBuffer);
   bool mtxSetLUT(word index, mtxRGB color);
   void mtxClose(void);
#endif




/*----------------------------------------------------*/
/* XG3 products : support declarations for sxciio.h */
/*----------------------------------------------------*/

#define mtxPBWAIT       1               /* Wait flag */

typedef struct {
    dword   Left;
    dword   Top;
    dword   Right;
    dword   Bottom;
} mtxRect;


#define MAXCLIPRECT   10

typedef struct {
    dword   Count;                        /* number of clipping rectangles */
    dword   Reserved;                     /* reserved field, set to 0x0 */
    dword   Reserved1;                    /* origin of clip list, set to 0x0 */
    dword   Reserved2;                    /* origin of clip list, set to 0x0 */
    mtxRect Rects[MAXCLIPRECT];           /* max. clip rects */
    mtxRect Bounds;                       /* bounding rectangle */
} mtxClipList;


/*** Prototypes ***/

#ifndef _WATCOM_DLL32
   dword mtxAllocCL (word Nb_Rect);
   dword mtxAllocLSDB (word Nb_Light);
   dword mtxAllocRC (dword *Reserved);
   dword *mtxAllocBuffer (dword Nb_dword);
   bool mtxFreeBuffer (dword *ptr);
   bool mtxFreeCL (dword ptr);
   bool mtxFreeLSDB (dword ptr);
   bool mtxFreeRC (dword ptr);
   dword mtxGetBlockSize (void);
   bool mtxPostBuffer (dword *ptr, dword length, dword flags);
   bool mtxSyncBuffer (dword *ptr);
   bool mtxSetCL(dword RCid, dword CLid, mtxClipList *CL);
   void mtxSetRC (dword RCid);
   bool mtxCursorSetShape(PixMap *);
   void mtxCursorSetColors(mtxRGB, mtxRGB, mtxRGB, mtxRGB);
   void mtxCursorEnable(word);
   void mtxCursorSetHotSpot(word, word);
   void mtxCursorMove(word, word);
   CursorInfo *mtxCursorGetInfo();
#endif



/*----------------------------------------------------*/
/* XG3 products : support declarations for graphics.h */
/*----------------------------------------------------*/

#define mtxRES_1280    0    /* 1280 x 1024 Resolution */
#define mtxRES_1024    1    /* 1024 x  768 Resolution */
#define mtxRES_VIDEO   2    /*  640 x  480 Interlaced Resolution */
#define mtxRES_MAX    -1    /* Find largest resolution */


#define NTSC_UNDER    1     /* screen type */
#define PAL_UNDER     2
#define NTSC_OVER     3
#define PAL_OVER      4

#define mtxPASSTHRU   0     /* Passthru mode ; mtxPASSTHRU = mtxVGA */
#define mtxADV_MODE   1     /* Advanced mode */

/*** Raster operation ***/
typedef dword               mtxROP;
#define mtxCLEAR            ((mtxROP)0x00000000)   /* 0 */
#define mtxNOR              ((mtxROP)0x11111111)   /* NOT src AND NOT dst */
#define mtxANDINVERTED      ((mtxROP)0x22222222)   /* NOT src AND dst */
#define mtxREPLACEINVERTED  ((mtxROP)0x33333333)   /* NOT src */
#define mtxANDREVERSE       ((mtxROP)0x44444444)   /* src AND NOT dst */
#define mtxINVERT           ((mtxROP)0x55555555)   /* NOT dst */
#define mtxXOR              ((mtxROP)0x66666666)   /* src XOR dst */
#define mtxNAND             ((mtxROP)0x77777777)   /* NOT src OR NOT dst */
#define mtxAND              ((mtxROP)0x88888888)   /* src AND dst */
#define mtxEQUIV            ((mtxROP)0x99999999)   /* NOT src XOR dst */
#define mtxNOOP             ((mtxROP)0xAAAAAAAA)   /* dst */
#define mtxORINVERTED       ((mtxROP)0xBBBBBBBB)   /* NOT src OR dst */
#define mtxREPLACE          ((mtxROP)0xCCCCCCCC)   /* src */
#define mtxORREVERSE        ((mtxROP)0xDDDDDDDD)   /* src OR NOT dst */
#define mtxOR               ((mtxROP)0xEEEEEEEE)   /* src OR dst */
#define mtxSET              ((mtxROP)0xFFFFFFFF)   /* 1 */



typedef struct {                    /* Configuration structure */
    word    Width;                  /* screen width */
    word    Height;                 /* screen height */
    dword   Colors;                 /* # of colors */
    word    PhysPixelSize;          /* number of bits needed per pixel */
    byte    DacSize;                /* dac size */
    byte    Luts;                   /* # of lut on board */
    word    FbWidth;                /* frame buffer width */
    word    FbHeight;               /* frame buffer height */
    word    FbPitch;                /* size of scan line */
    word    OffScreenX;             /* offscreen x location */
    word    OffScreenY;             /* offscreen y location */
    word    OffScreenWidth;         /* offscreen width */
    word    OffScreenHeight;        /* offscreen height */
    dword   OffScreenPlanes;        /* safe planes to write to mask */
    byte    Name[32];               /* Board name */
    byte    BindingId[32];          /* binding id */
    byte    ShellId[32];            /* shell id */
} mtxCONFIG;


/*** prototypes ***/

#ifndef _WATCOM_DLL32

#ifndef __DDK_SRC__  /*  - - - - - - - - - - - - - - - - - - - - - - - - - - */

   word mtxGetVideoMode (void);
   void   mtxSetFgColor (mtxRGB color);
   mtxRGB mtxGetFgColor (void);
   void  mtxSetOp (dword Op);
   dword    mtxGetOp (void);
   void mtxScLine (sword x1, sword y1, sword x2, sword y2);
   void mtxScPixel (sword s, sword y);
   bool mtxScClip (word left, word top, word right, word bottom);
   void mtxScFilledRect (sword left, sword top, sword right, sword bottom);
   bool mtxCheckHw (void);
   bool mtxInit(bool dualscreen,short resolution_id,bool clear_flag, mtxCONFIG *config);
   bool mtxReset (void);
   void mtxSetVideoMode (word mode);
   extern void mtxMemScBitBlt(word dstx, word dsty, word width, word height,
                               word plane, dword *src);
   extern void mtxScMemBitBlt(word srcx, word srcy, word width, word height,
                               word plane, dword *dst);
   extern void mtxScScBitBlt (sword srcx, sword srcy, sword dstx, sword dsty,
                               word width, word height, sword plane);

#else /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/* this will be cleaned up, quick and dirty solution for now */

   void mtxSetVideoMode (word mode);
   word mtxGetVideoMode (void);

#ifndef GRPROTO_H
   void   mtxSetFgColor (mtxRGB color);
   mtxRGB mtxGetFgColor (void);
   void  mtxSetOp (dword Op);
   dword	mtxGetOp (void);
   void mtxScLine (sword x1, sword y1, sword x2, sword y2);
   void mtxScPixel (sword s, sword y);

/***   bool mtxScClip (word left, word top, word right, word bottom);  ***/
/*** for DDK compatibility ***/
void mtxSetClipRect (
   	word xLeft, word yTop,
   	word xRight, word yBottom
);

/*** macro for mtxScClip calls to mtxSetClipRect and evaluates to mtxOK ***/
#define mtxScClip( x, t, y, b ) ( \
	mtxSetClipRect( (x), (t), (y), (b) ), \
	mtxOK \
)

/*** NOTE: underscores will be removed in final DDK version from common
 ***       SDK and DDK function names 
 ***/
#define _mtxScClip( x, t, y, b ) ( \
	mtxSetClipRect( (x), (t), (y), (b) ), \
	mtxOK \
)

   void mtxScFilledRect (sword left, sword top, sword right, sword bottom);
#endif /* GRPROTO_H */

   bool mtxCheckHw (void);
   bool mtxInit(bool dualscreen,short resolution_id,bool clear_flag, mtxCONFIG *config);
   bool mtxReset (void);

#ifndef BLTPROTO_H
   extern void mtxMemScBitBlt(word dstx, word dsty, word width, word height,
                               word plane, dword *src);
   extern void mtxScMemBitBlt(word srcx, word srcy, word width, word height,
                               word plane, dword *dst);
   extern void mtxScScBitBlt (sword srcx, sword srcy, sword dstx, sword dsty,
                               word width, word height, sword plane);
#endif /* BLTPROTO_H */

#endif /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


#endif




#endif /* BIND_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\disp\thunk.c ===
/******************************Module*Header*******************************\
* Module Name: thunk.c
*
* This module exists solely for testing, to make it is easy to instrument
* all the driver's Drv calls.
*
* Note that most of this stuff will only be compiled in a checked (debug)
* build.
*
* Copyright (c) 1993-1996 Microsoft Corporation
* Copyright (c) 1993-1996 Matrox Electronic Systems, Ltd.
\**************************************************************************/

#include "precomp.h"

////////////////////////////////////////////////////////////////////////////

#if DBG

// This entire module is only enabled for Checked builds

#define SYNCH_ENTER()   0   // do nothing
#define SYNCH_LEAVE()   0   // do nothing

////////////////////////////////////////////////////////////////////////////

BOOL gbNull = FALSE;    // Set to TRUE with the debugger to test the speed
                        //   of NT with an inifinitely fast display driver
                        //   (actually, almost infinitely fast since we're
                        //   not hooking all the calls we could be)


DHPDEV DbgEnablePDEV(
DEVMODEW*   pDevmode,
PWSTR       pwszLogAddress,
ULONG       cPatterns,
HSURF*      ahsurfPatterns,
ULONG       cjGdiInfo,
ULONG*      pGdiInfo,
ULONG       cjDevInfo,
DEVINFO*    pDevInfo,
HDEV        hdev,
PWSTR       pwszDeviceName,
HANDLE      hDriver)
{
    DHPDEV bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvEnablePDEV"));

    bRet = DrvEnablePDEV(
                pDevmode,
                pwszLogAddress,
                cPatterns,
                ahsurfPatterns,
                cjGdiInfo,
                pGdiInfo,
                cjDevInfo,
                pDevInfo,
                hdev,
                pwszDeviceName,
                hDriver);

    DISPDBG((6, "<< DrvEnablePDEV"));
    SYNCH_LEAVE();

    return(bRet);
}

VOID DbgCompletePDEV(
DHPDEV dhpdev,
HDEV  hdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DrvCompletePDEV"));

    DrvCompletePDEV(
                dhpdev,
                hdev);

    DISPDBG((6, "<< DrvCompletePDEV"));
    SYNCH_LEAVE();
}

VOID DbgDisablePDEV(DHPDEV dhpdev)
{
    PDEV* ppdev;
    BOOL bNeedSync;
    ppdev = (PDEV*) dhpdev;

    bNeedSync = ppdev->bEnabled;

    //
    // If a PDEV has not been disabled by DrvAssertMode
    // then this call is synchronized as access to the
    // hardware may occur.  If the PDEV has been disabled
    // by DrvAssertMode then access to the hardware is not
    // allowed (all hardware access needs to be done in the
    // DrvAssertMode handling) and synchronization is not done
    // as drawing may be occurring in a different PDEV.
    //

    if (bNeedSync)
    {
        SYNCH_ENTER();
    }

    DISPDBG((5, ">> DrvDisable"));

    DrvDisablePDEV(dhpdev);

    DISPDBG((6, "<< DrvDisable"));

    if (bNeedSync)
    {
        SYNCH_LEAVE();
    }
}

HSURF DbgEnableSurface(DHPDEV dhpdev)
{
    HSURF h;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvEnableSurface"));

    h = DrvEnableSurface(dhpdev);

    DISPDBG((6, "<< DrvEnableSurface"));
    SYNCH_LEAVE();

    return(h);
}

VOID DbgDisableSurface(DHPDEV dhpdev)
{
    PDEV* ppdev;
    BOOL bNeedSync;
    ppdev = (PDEV*) dhpdev;

    bNeedSync = ppdev->bEnabled;

    //
    // If a PDEV has not been disabled by DrvAssertMode
    // then this call is synchronized as access to the
    // hardware may occur.  If the PDEV has been disabled
    // by DrvAssertMode then access to the hardware is not
    // allowed (all hardware access needs to be done in the
    // DrvAssertMode handling) and synchronization is not done
    // as drawing may be occurring in a different PDEV.
    //

    if (bNeedSync)
    {
        SYNCH_ENTER();
    }

    DISPDBG((5, ">> DrvDisableSurface"));

    DrvDisableSurface(dhpdev);

    DISPDBG((6, "<< DrvDisableSurface"));

    if (bNeedSync)
    {
        SYNCH_LEAVE();
    }
}

BOOL  DbgAssertMode(
DHPDEV dhpdev,
BOOL   bEnable)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvAssertMode"));

    b = DrvAssertMode(dhpdev,bEnable);

    DISPDBG((6, "<< DrvAssertMode"));
    SYNCH_LEAVE();

    return (b);
}

BOOL DbgOffset(
SURFOBJ*    pso,
LONG        x,
LONG        y,
FLONG       fl)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvOffset"));

    b = DrvOffset(pso,x,y,fl);

    DISPDBG((6, "<< DrvOffset"));
    SYNCH_LEAVE();

    return (b);
}

//
// We do not SYNCH_ENTER since we have not initalized the driver.
// We just want to get the list of modes from the miniport.
//

ULONG DbgGetModes(
HANDLE    hDriver,
ULONG     cjSize,
DEVMODEW* pdm)
{
    ULONG u;

    DISPDBG((5, ">> DrvGetModes"));

    u = DrvGetModes(
                hDriver,
                cjSize,
                pdm);

    DISPDBG((6, "<< DrvGetModes"));

    return(u);
}

VOID DbgMovePointer(SURFOBJ *pso,LONG x,LONG y,RECTL *prcl)
{
    if (gbNull)
        return;

    // Note: Because we set GCAPS_ASYNCMOVE, we don't want to do a
    //       SYNCH_ENTER/LEAVE here.

    DISPDBG((5, ">> DrvMovePointer"));

    DrvMovePointer(pso,x,y,prcl);

    DISPDBG((6, "<< DrvMovePointer"));
}

ULONG DbgSetPointerShape(
SURFOBJ*  pso,
SURFOBJ*  psoMask,
SURFOBJ*  psoColor,
XLATEOBJ* pxlo,
LONG      xHot,
LONG      yHot,
LONG      x,
LONG      y,
RECTL*    prcl,
FLONG     fl)
{
    ULONG u;

    if (gbNull)
        return(SPS_ACCEPT_NOEXCLUDE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSetPointerShape"));

    u = DrvSetPointerShape(
                pso,
                psoMask,
                psoColor,
                pxlo,
                xHot,
                yHot,
                x,
                y,
                prcl,
                fl);

    DISPDBG((6, "<< DrvSetPointerShape"));
    SYNCH_LEAVE();

    return(u);
}

ULONG DbgDitherColor(
DHPDEV dhpdev,
ULONG  iMode,
ULONG  rgb,
ULONG* pul)
{
    ULONG u;

    if (gbNull)
        return(DCR_DRIVER);

    //
    // No need to Synchronize Dither color.
    //

    DISPDBG((5, ">> DrvDitherColor"));

    u = DrvDitherColor(
                dhpdev,
                iMode,
                rgb,
                pul);

    DISPDBG((6, "<< DrvDitherColor"));

    return(u);
}

BOOL DbgSetPalette(
DHPDEV  dhpdev,
PALOBJ* ppalo,
FLONG   fl,
ULONG   iStart,
ULONG   cColors)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvSetPalette"));

    u = DrvSetPalette(
                dhpdev,
                ppalo,
                fl,
                iStart,
                cColors);

    DISPDBG((6, "<< DrvSetPalette"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvCopyBits"));

    u = DrvCopyBits(
                psoDst,
                psoSrc,
                pco,
                pxlo,
                prclDst,
                pptlSrc);

    DISPDBG((6, "<< DrvCopyBits"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMask,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMask,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvBitBlt"));

    u = DrvBitBlt(
                psoDst,
                psoSrc,
                psoMask,
                pco,
                pxlo,
                prclDst,
                pptlSrc,
                pptlMask,
                pbo,
                pptlBrush,
                rop4);

    DISPDBG((6, "<< DrvBitBlt"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgTextOut(
SURFOBJ*  pso,
STROBJ*   pstro,
FONTOBJ*  pfo,
CLIPOBJ*  pco,
RECTL*    prclExtra,
RECTL*    prclOpaque,
BRUSHOBJ* pboFore,
BRUSHOBJ* pboOpaque,
POINTL*   pptlOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvTextOut"));

    u = DrvTextOut(
                pso,
                pstro,
                pfo,
                pco,
                prclExtra,
                prclOpaque,
                pboFore,
                pboOpaque,
                pptlOrg,
                mix);

    DISPDBG((6, "<< DrvTextOut"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrushOrg,
LINEATTRS* plineattrs,
MIX        mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvStrokePath"));

    u = DrvStrokePath(
                pso,
                ppo,
                pco,
                pxo,
                pbo,
                pptlBrushOrg,
                plineattrs,
                mix);

    DISPDBG((6, "<< DrvStrokePath"));
    SYNCH_LEAVE();

    return(u);
}


BOOL DbgLineTo(
SURFOBJ*    pso,
CLIPOBJ*    pco,
BRUSHOBJ*   pbo,
LONG        x1,
LONG        y1,
LONG        x2,
LONG        y2,
RECTL*      prclBounds,
MIX         mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvLineTo"));

    u = DrvLineTo(
                pso,
                pco,
                pbo,
                x1,
                y1,
                x2,
                y2,
                prclBounds,
                mix);

    DISPDBG((6, "<< DrvLineTo done"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix,
FLONG     flOptions)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvFillPath"));

    u = DrvFillPath(pso,
                ppo,
                pco,
                pbo,
                pptlBrushOrg,
                mix,
                flOptions);

    DISPDBG((6, "<< DrvFillPath"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgPaint(
SURFOBJ*  pso,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrushOrg,
MIX       mix)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvPaint"));

    u = DrvPaint(
                pso,
                pco,
                pbo,
                pptlBrushOrg,
                mix);

    DISPDBG((6, "<< DrvPaint"));
    SYNCH_LEAVE();

    return(u);
}

BOOL DbgRealizeBrush(
BRUSHOBJ* pbo,
SURFOBJ*  psoTarget,
SURFOBJ*  psoPattern,
SURFOBJ*  psoMask,
XLATEOBJ* pxlo,
ULONG     iHatch)
{
    BOOL u;

    // Note: The only time DrvRealizeBrush is called by GDI is when we've
    //       called BRUSHOBJ_pvGetRbrush in the middle of a DrvBitBlt
    //       call, and GDI had to call us back.  Since we're still in the
    //       middle of DrvBitBlt, synchronization has already taken care of.
    //       For the same reason, this will never be called when 'gbNull'
    //       is TRUE, so it doesn't even make sense to check gbNull...

    DISPDBG((5, ">> DrvRealizeBrush"));

    u = DrvRealizeBrush(
                pbo,
                psoTarget,
                psoPattern,
                psoMask,
                pxlo,
                iHatch);

    DISPDBG((6, "<< DrvRealizeBrush"));

    return(u);
}

HBITMAP DbgCreateDeviceBitmap(DHPDEV dhpdev, SIZEL sizl, ULONG iFormat)
{
    HBITMAP hbm;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvCreateDeviceBitmap"));

    hbm = DrvCreateDeviceBitmap(dhpdev, sizl, iFormat);

    DISPDBG((6, "<< DrvCreateDeviceBitmap"));
    SYNCH_LEAVE();

    return(hbm);
}

VOID DbgDeleteDeviceBitmap(DHSURF dhsurf)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DrvDeleteDeviceBitmap"));

    DrvDeleteDeviceBitmap(dhsurf);

    DISPDBG((6, "<< DrvDeleteDeviceBitmap"));
    SYNCH_LEAVE();
}

VOID DbgDestroyFont(FONTOBJ* pfo)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DrvDestroyFont"));

    DrvDestroyFont(pfo);

    DISPDBG((6, "<< DrvDestroyFont"));
    SYNCH_LEAVE();
}

BOOL DbgStretchBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMask,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMask,
ULONG               iMode)
{
    BOOL u;

    if (gbNull)
        return(TRUE);

    SYNCH_ENTER();
    DISPDBG((5, "DrvStretchBlt"));

    #if SYNCHRONIZEACCESS_WORKS
    {
        // Our DrvStretchBlt routine calls back to EngStretchBlt, which
        // calls back to our DrvCopyBits routine -- so we have to be
        // re-entrant for synchronization...

        SYNCH_LEAVE();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    u = DrvStretchBlt(psoDst, psoSrc, psoMask, pco, pxlo, pca, pptlHTOrg,
                      prclDst, prclSrc, pptlMask, iMode);

    #if SYNCHRONIZEACCESS_WORKS
    {
        SYNCH_ENTER();
    }
    #endif // SYNCHRONIZEACCESS_WORKS

    DISPDBG((6, "DrvStretchBlt done"));
    SYNCH_LEAVE();

    return(u);
}


ULONG DbgEscape(
SURFOBJ*    pso,
ULONG       iEsc,
ULONG       cjIn,
VOID*       pvIn,
ULONG       cjOut,
VOID*       pvOut)
{
    ULONG u;

    if (gbNull)
        return(TRUE);

    // Most escapes are not synchronized by GDI...

    DISPDBG((5, "DrvEscape"));

    u = DrvEscape(pso,
                  iEsc,
                  cjIn,
                  pvIn,
                  cjOut,
                  pvOut);

    DISPDBG((6, "DrvEscape done"));

    return(u);
}

BOOL DbgResetPDEV(
DHPDEV dhpdevOld,
DHPDEV dhpdevNew)
{
    BOOL bRet;

    SYNCH_ENTER();
    DISPDBG((5, ">> DrvResetPDEV"));

    bRet = DrvResetPDEV(dhpdevOld, dhpdevNew);

    DISPDBG((6, "<< DrvResetPDEV"));
    SYNCH_LEAVE();

    return(bRet);
}

BOOL DbgGetDirectDrawInfo(
DHPDEV          dhpdev,
DD_HALINFO*     pHalInfo,
DWORD*          lpdwNumHeaps,
VIDEOMEMORY*    pvmList,
DWORD*          lpdwNumFourCC,
DWORD*          lpdwFourCC)
{
    BOOL b;

    DISPDBG((5, ">> DbgQueryDirectDrawInfo"));

    b = DrvGetDirectDrawInfo(dhpdev,
                             pHalInfo,
                             lpdwNumHeaps,
                             pvmList,
                             lpdwNumFourCC,
                             lpdwFourCC);

    DISPDBG((6, "<< DbgQueryDirectDrawInfo"));

    return(b);
}

BOOL DbgEnableDirectDraw(
DHPDEV                  dhpdev,
DD_CALLBACKS*           pCallBacks,
DD_SURFACECALLBACKS*    pSurfaceCallBacks,
DD_PALETTECALLBACKS*    pPaletteCallBacks)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgEnableDirectDraw"));

    b = DrvEnableDirectDraw(dhpdev,
                            pCallBacks,
                            pSurfaceCallBacks,
                            pPaletteCallBacks);

    DISPDBG((6, "<< DbgEnableDirectDraw"));
    SYNCH_LEAVE();

    return(b);
}

VOID DbgDisableDirectDraw(
DHPDEV      dhpdev)
{
    SYNCH_ENTER();
    DISPDBG((5, ">> DbgDisableDirectDraw"));

    DrvDisableDirectDraw(dhpdev);

    DISPDBG((6, "<< DbgDisableDirectDraw"));
    SYNCH_LEAVE();
}

BOOL DbgIcmSetDeviceGammaRamp(
DHPDEV      dhpdev,
ULONG       iFormat,
LPVOID      lpRamp)
{
    BOOL b;

    SYNCH_ENTER();
    DISPDBG((5, ">> DbgIcmSetDeviceGammaRamp"));

    b = DrvIcmSetDeviceGammaRamp(dhpdev,iFormat,lpRamp);

    DISPDBG((6, "<< DbgIcmSetDeviceGammaRamp"));
    SYNCH_LEAVE();

    return (b);
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\caddi.h ===
/*/****************************************************************************
*          name: caddi.h
*
*   description: This file contains all the definitions related to the CADDI
*                interface as specified in CADDI 1.10. As CADDI is coded partly
*                in C and in ASM the permitted definitions are simple #define.
*
*      designed: 
* last modified: $Author: unknown $, $Date: 94/11/24 11:51:39 $
*
*       version: $Id: CADDI.H 1.19 94/11/24 11:51:39 unknown Exp $
*
******************************************************************************/

/******************************************************************************

 This file only contains #defines in order to be use by C ans ASM programs.
 (for ASM a simple script translates #define in EQU). The format is 

 "structure_name"_"field_name" there is also a ..._S  definition for each.

 NOTE: _S  is given in bytes

       31 CHARACTERS MAXIMUM for a name

 As our convention defines a type name in upper case and a field name in lower
 case (with first letter of names in upper case) this will be respected here.

 Ex. in C typedef struct { float Type, COLOR3 AmbientCol} AMBIENT_LIGHT;

 #define AMBIENT_LIGHT_Type              0
 #define AMBIENT_LIGHT_Type_S            FLOAT_S 
 #define AMBIENT_LIGHT_AmbientCol        (AMBIENT_LIGHT_Type + FLOAT_S)
 #define AMBIENT_LIGHT_AmbientCol_S      COLOR3_S 
 #define AMBIENT_LIGHT_S                 (AMBIENT_LIGHT_AmbientCol + COLOR3_S)

******************************************************************************/                                        

/******************************************************************************

 CADDI data structures definitions as per CADDI specification 1.10

*/
// also in defbind.h
#define CHAR_S          1
#define SHORT_S         2
#define LONG_S          4
#define FLOAT_S         4
#define UINTPTR_S  (sizeof(UINT_PTR))

#define RECT_Left                      0
#define RECT_Left_S                    LONG_S    
#define RECT_Top                       (RECT_Left + LONG_S)
#define RECT_Top_S                     LONG_S    
#define RECT_Right                     (RECT_Top + LONG_S)
#define RECT_Right_S                   LONG_S    
#define RECT_Bottom                    (RECT_Right + LONG_S)
#define RECT_Bottom_S                  LONG_S    
#define RECT_S                         (RECT_Bottom + LONG_S)

#define IPOINT2_Packed_xy              0
#define IPOINT2_Packed_xy_S            LONG_S    
#define IPOINT2_S                      (IPOINT2_Packed_xy + LONG_S)

#define IPOINT2_32_X                   0
#define IPOINT2_32_X_S                 LONG_S    
#define IPOINT2_32_Y                   (IPOINT2_32_X + LONG_S)
#define IPOINT2_32_Y_S                 LONG_S    
#define IPOINT2_32_S                   (IPOINT2_32_Y + LONG_S)

#define NFLOAT_S                       FLOAT_S    
#define IFLOAT_S                       FLOAT_S    

#define MATRIX4_M                      0
#define MATRIX4_M_S                    (16 * FLOAT_S)

#define MATRIX4_M11                    MATRIX4_M
#define MATRIX4_M12                    (MATRIX4_M11 + FLOAT_S)
#define MATRIX4_M13                    (MATRIX4_M12 + FLOAT_S)
#define MATRIX4_M14                    (MATRIX4_M13 + FLOAT_S)
#define MATRIX4_M21                    (MATRIX4_M14 + FLOAT_S)
#define MATRIX4_M22                    (MATRIX4_M21 + FLOAT_S)
#define MATRIX4_M23                    (MATRIX4_M22 + FLOAT_S)
#define MATRIX4_M24                    (MATRIX4_M23 + FLOAT_S)
#define MATRIX4_M31                    (MATRIX4_M24 + FLOAT_S)
#define MATRIX4_M32                    (MATRIX4_M31 + FLOAT_S)
#define MATRIX4_M33                    (MATRIX4_M32 + FLOAT_S)
#define MATRIX4_M34                    (MATRIX4_M33 + FLOAT_S)
#define MATRIX4_M41                    (MATRIX4_M34 + FLOAT_S)
#define MATRIX4_M42                    (MATRIX4_M41 + FLOAT_S)
#define MATRIX4_M43                    (MATRIX4_M42 + FLOAT_S)
#define MATRIX4_M44                    (MATRIX4_M43 + FLOAT_S)

#define MATRIX4_S                      (MATRIX4_M + (16 * FLOAT_S))

#define POINT3_X                       0
#define POINT3_X_S                     FLOAT_S    
#define POINT3_Y                       (POINT3_X + FLOAT_S)
#define POINT3_Y_S                     FLOAT_S    
#define POINT3_Z                       (POINT3_Y + FLOAT_S)
#define POINT3_Z_S                     FLOAT_S    
#define POINT3_S                       (POINT3_Z + FLOAT_S)

#define NORM3_X                        0
#define NORM3_X_S                      NFLOAT_S    
#define NORM3_Y                        (NORM3_X + NFLOAT_S)
#define NORM3_Y_S                      NFLOAT_S    
#define NORM3_Z                        (NORM3_Y + NFLOAT_S)
#define NORM3_Z_S                      NFLOAT_S    
#define NORM3_S                        (NORM3_Z + NFLOAT_S)

#define COLOR3_Red                     0
#define COLOR3_Red_S                   NFLOAT_S    
#define COLOR3_Green                   (COLOR3_Red + NFLOAT_S)
#define COLOR3_Green_S                 NFLOAT_S    
#define COLOR3_Blue                    (COLOR3_Green + NFLOAT_S)
#define COLOR3_Blue_S                  NFLOAT_S    
#define COLOR3_S                       (COLOR3_Blue + NFLOAT_S)

#define COLORI_Index                   0
#define COLORI_Index_S                 LONG_S    
#define COLORI_Reserved1               (COLORI_Index + LONG_S)
#define COLORI_Reserved1_S             LONG_S    
#define COLORI_Reserved2               (COLORI_Reserved1 + LONG_S)
#define COLORI_Reserved2_S             LONG_S    
#define COLORI_S                       (COLORI_Reserved2 + LONG_S)

#define CLIPLIST_Count                 0
#define CLIPLIST_Count_S               LONG_S    
#define CLIPLIST_Reserved0             (CLIPLIST_Count + LONG_S)
#define CLIPLIST_Reserved0_S           LONG_S    
#define CLIPLIST_Reserved1             (CLIPLIST_Reserved0 + LONG_S)
#define CLIPLIST_Reserved1_S           LONG_S    
#define CLIPLIST_Reserved2             (CLIPLIST_Reserved1 + LONG_S)
#define CLIPLIST_Reserved2_S           LONG_S    
#define CLIPLIST_Rects                 (CLIPLIST_Reserved2 + LONG_S)
#define CLIPLIST_Rects_S               RECT_S
#define CLIPLIST_Bounds_S              RECT_S
#define CLIPLIST_S                     (CLIPLIST_Rects + RECT_S + RECT_S)

#define NULL_LIGHT_Type                0
#define NULL_LIGHT_Type_S              FLOAT_S    
#define NULL_LIGHT_S                   (NULL_LIGHT_Type + FLOAT_S)

#define AMBIENT_LIGHT_Type             0
#define AMBIENT_LIGHT_Type_S           FLOAT_S    
#define AMBIENT_LIGHT_AmbientCol       (AMBIENT_LIGHT_Type + FLOAT_S)
#define AMBIENT_LIGHT_AmbientCol_S     COLOR3_S    
#define AMBIENT_LIGHT_S                (AMBIENT_LIGHT_AmbientCol + COLOR3_S)

#define DIRECTIONAL_LIGHT_Type               0
#define DIRECTIONAL_LIGHT_Type_S             FLOAT_S    
#define DIRECTIONAL_LIGHT_DiffuseCol         (DIRECTIONAL_LIGHT_Type + FLOAT_S)
#define DIRECTIONAL_LIGHT_DiffuseCol_S       COLOR3_S    
#define DIRECTIONAL_LIGHT_SpecularCol        (DIRECTIONAL_LIGHT_DiffuseCol + COLOR3_S)
#define DIRECTIONAL_LIGHT_SpecularCol_S      COLOR3_S    
#define DIRECTIONAL_LIGHT_Direction          (DIRECTIONAL_LIGHT_SpecularCol + COLOR3_S)
#define DIRECTIONAL_LIGHT_Direction_S        NORM3_S    
#define DIRECTIONAL_LIGHT_S                  (DIRECTIONAL_LIGHT_Direction + NORM3_S)

#define POSITIONAL_LIGHT_Type                0
#define POSITIONAL_LIGHT_Type_S              FLOAT_S    
#define POSITIONAL_LIGHT_DiffuseCol          (POSITIONAL_LIGHT_Type + FLOAT_S)
#define POSITIONAL_LIGHT_DiffuseCol_S        COLOR3_S    
#define POSITIONAL_LIGHT_SpecularCol         (POSITIONAL_LIGHT_DiffuseCol + COLOR3_S)
#define POSITIONAL_LIGHT_SpecularCol_S       COLOR3_S    
#define POSITIONAL_LIGHT_Position            (POSITIONAL_LIGHT_SpecularCol + COLOR3_S)
#define POSITIONAL_LIGHT_Position_S          POINT3_S    
#define POSITIONAL_LIGHT_AttGlobal           (POSITIONAL_LIGHT_Position + POINT3_S)
#define POSITIONAL_LIGHT_AttGlobal_S         NFLOAT_S    
#define POSITIONAL_LIGHT_AttDist             (POSITIONAL_LIGHT_AttGlobal + NFLOAT_S)
#define POSITIONAL_LIGHT_AttDist_S           NFLOAT_S    
#define POSITIONAL_LIGHT_S                   (POSITIONAL_LIGHT_AttDist + NFLOAT_S)

#define SPOT_LIGHT_Type                0
#define SPOT_LIGHT_Type_S              FLOAT_S    
#define SPOT_LIGHT_DiffuseCol          (SPOT_LIGHT_Type + FLOAT_S)
#define SPOT_LIGHT_DiffuseCol_S        COLOR3_S    
#define SPOT_LIGHT_SpecularCol         (SPOT_LIGHT_DiffuseCol + COLOR3_S)
#define SPOT_LIGHT_SpecularCol_S       COLOR3_S    
#define SPOT_LIGHT_Position            (SPOT_LIGHT_SpecularCol + COLOR3_S)
#define SPOT_LIGHT_Position_S          POINT3_S    
#define SPOT_LIGHT_Direction           (SPOT_LIGHT_Position + POINT3_S)
#define SPOT_LIGHT_Direction_S         NORM3_S    
#define SPOT_LIGHT_AttGlobal           (SPOT_LIGHT_Direction + NORM3_S)
#define SPOT_LIGHT_AttGlobal_S         NFLOAT_S    
#define SPOT_LIGHT_AttDist             (SPOT_LIGHT_AttGlobal + NFLOAT_S)
#define SPOT_LIGHT_AttDist_S           NFLOAT_S    
#define SPOT_LIGHT_ConeExp             (SPOT_LIGHT_AttDist + NFLOAT_S)
#define SPOT_LIGHT_ConeExp_S           IFLOAT_S    
#define SPOT_LIGHT_CosMaxIAngle        (SPOT_LIGHT_ConeExp + IFLOAT_S)
#define SPOT_LIGHT_CosMaxIAngle_S      NFLOAT_S    
#define SPOT_LIGHT_CosAttIAngle        (SPOT_LIGHT_CosMaxIAngle + NFLOAT_S)
#define SPOT_LIGHT_CosAttIAngle_S      NFLOAT_S    
#define SPOT_LIGHT_S                   (SPOT_LIGHT_CosAttIAngle + NFLOAT_S)

/*****************************************************************************/

/******************************************************************************

 CADDI opcodes definitions as per CADDI specification 1.10

*/

/*** CADDI General Opcodes ***/

#define CLEAR                       0x0004
#define DONE                        0x0001
#define INITRC                      0x0E00
#define NOOP                        0x0501
#define SETBUFFERCONFIGURATION      0x0300
#define SETBGCOLOR                  0x1800
#define SETCLIPLIST                 0x0500
#define SETENDPOINT                 0x1700
#define SETFGCOLOR                  0x0402
#define SETFILLPATTERN              0x1600
#define SETLINESTYLE                0x0502
#define SETLOGICOP                  0x0800
#define SETTRANSPARENCY             0x1400
#define SETTRIVIALIN                0x1300
#define SYNC                        0x0301
#define SETOUTLINE                  0x1900
#define SETPLANEMASK                0x0900
#define SETASYNCHROUNOUSSWAP        0x1a00
#define SETLINESTYLEOFFSET          0x0600

/*** CADDI Screen Opcodes ***/

#define RENDERSCPOLYLINE            0x0304
#define RENDERSCPOLYGON             0x0404
#define SPANLINE                    0x0204

/*** CADDI 2D Opcodes ***/

#define RENDER2DMULTIPOLYLINE       0x0602
#define RENDER2DMULTIPOLYLINE32     0x0a02
#define RENDER2DPOLYGON             0x0302
#define RENDER2DPOLYGON32           0x0902
#define SET2DVIEWPORT               0x0002
#define SET2DWINDOW                 0x0102
#define SET2DWINDOW32               0x0702

/*** CADDI 3D Opcodes ***/

#define CHANGEMATRIX                0x0000
#define RENDERPOLYLINE              0x0103
#define RENDERPOLYQUAD              0x0203
#define SETCLIP3D                   0x0400
#define SETLIGHTSOURCES             0x0700
#define SETRENDERDATA               0x1000
#define SETRENDERMODE               0x0A00
#define SETSURFACEATTR              0x1100
#define SETVIEWER                   0x0B00
#define SETZBUFFER                  0x0c00
#define TRIANGLE                    0x0503
#define RENDERPOLYTRIANGLE          0x0303


/*****************************************************************************/

/******************************************************************************

 CADDI opcodes structure definitions as per CADDI specification 1.10

*/

#define CLEAR_Opcode                   0
#define CLEAR_Opcode_S                 SHORT_S    
#define CLEAR_ClearMode                (CLEAR_Opcode + SHORT_S)
#define CLEAR_ClearMode_S              SHORT_S    
#define CLEAR_RcId                     (CLEAR_ClearMode + SHORT_S)
#define CLEAR_RcId_S                   LONG_S    
#define CLEAR_ClearColor               (CLEAR_RcId + LONG_S)
#define CLEAR_ClearColor_S             COLOR3_S    
#define CLEAR_ClearDepth               (CLEAR_ClearColor + COLOR3_S)
#define CLEAR_ClearDepth_S             NFLOAT_S    
#define CLEAR_S                        (CLEAR_ClearDepth + NFLOAT_S)

#define DONE_Opcode                    0
#define DONE_Opcode_S                  SHORT_S    
#define DONE_Null                      (DONE_Opcode + SHORT_S)
#define DONE_Null_S                    CHAR_S    
#define DONE_Reserved                  (DONE_Null + CHAR_S)
#define DONE_Reserved_S                CHAR_S
#define DONE_S                         (DONE_Reserved + CHAR_S)

#define INITRC_Opcode                  0
#define INITRC_Opcode_S                SHORT_S    
#define INITRC_Null                    (INITRC_Opcode + SHORT_S)
#define INITRC_Null_S                  SHORT_S    
#define INITRC_RcId                    (INITRC_Null + SHORT_S)
#define INITRC_RcId_S                  LONG_S    
#define INITRC_S                       (INITRC_RcId + LONG_S)

#define NOOP_Opcode                    0
#define NOOP_Opcode_S                  SHORT_S    
#define NOOP_Len                       (NOOP_Opcode + SHORT_S)
#define NOOP_Len_S                     SHORT_S    
#define NOOP_RcId                      (NOOP_Len + SHORT_S)
#define NOOP_RcId_S                    LONG_S    
#define NOOP_Data                      (NOOP_RcId + LONG_S)
#define NOOP_Data_S                    LONG_S

#define SETBUFFERCONF_Opcode           0
#define SETBUFFERCONF_Opcode_S         SHORT_S    
#define SETBUFFERCONF_BcDisplayMode    (SETBUFFERCONF_Opcode + SHORT_S)
#define SETBUFFERCONF_BcDisplayMode_S  CHAR_S    
#define SETBUFFERCONF_BcDrawMode       (SETBUFFERCONF_BcDisplayMode + CHAR_S)
#define SETBUFFERCONF_BcDrawMode_S     CHAR_S    
#define SETBUFFERCONF_RcId             (SETBUFFERCONF_BcDrawMode + CHAR_S)
#define SETBUFFERCONF_RcId_S           LONG_S    
#define SETBUFFERCONF_S                (SETBUFFERCONF_RcId + LONG_S)

#define SETBGCOLOR_Opcode              0
#define SETBGCOLOR_Opcode_S            SHORT_S    
#define SETBGCOLOR_Null                (SETBGCOLOR_Opcode + SHORT_S)
#define SETBGCOLOR_Null_S              SHORT_S    
#define SETBGCOLOR_RcId                (SETBGCOLOR_Null + SHORT_S)
#define SETBGCOLOR_RcId_S              LONG_S    
#define SETBGCOLOR_BgColor             (SETBGCOLOR_RcId + LONG_S)
#define SETBGCOLOR_BgColor_S           COLOR3_S    
#define SETBGCOLOR_S                   (SETBGCOLOR_BgColor + COLOR3_S)

#define SETCLIPLIST_Opcode             0
#define SETCLIPLIST_Opcode_S           SHORT_S    
#define SETCLIPLIST_LenClipList        (SETCLIPLIST_Opcode + SHORT_S)
#define SETCLIPLIST_LenClipList_S      SHORT_S    
#define SETCLIPLIST_RcId               (SETCLIPLIST_LenClipList + SHORT_S)
#define SETCLIPLIST_RcId_S             LONG_S    
#define SETCLIPLIST_DestId             (SETCLIPLIST_RcId + LONG_S)
#define SETCLIPLIST_DestId_S           LONG_S    
#define SETCLIPLIST_ClipList           (SETCLIPLIST_DestId + LONG_S)

#define SETENDPOINT_Opcode             0
#define SETENDPOINT_Opcode_S           SHORT_S    
#define SETENDPOINT_EndPoint           (SETENDPOINT_Opcode + SHORT_S)
#define SETENDPOINT_EndPoint_S         SHORT_S    
#define SETENDPOINT_RcId               (SETENDPOINT_EndPoint + SHORT_S)
#define SETENDPOINT_RcId_S             LONG_S    
#define SETENDPOINT_S                  (SETENDPOINT_RcId + LONG_S)

#define SETFGCOLOR_Opcode              0
#define SETFGCOLOR_Opcode_S            SHORT_S    
#define SETFGCOLOR_Null                (SETFGCOLOR_Opcode + SHORT_S)
#define SETFGCOLOR_Null_S              SHORT_S    
#define SETFGCOLOR_RcId                (SETFGCOLOR_Null + SHORT_S)
#define SETFGCOLOR_RcId_S              LONG_S    
#define SETFGCOLOR_FgColor             (SETFGCOLOR_RcId + LONG_S)
#define SETFGCOLOR_FgColor_S           COLOR3_S    
#define SETFGCOLOR_S                   (SETFGCOLOR_FgColor + COLOR3_S)

#define SETFILLPATTERN_Opcode          0
#define SETFILLPATTERN_Opcode_S        SHORT_S    
#define SETFILLPATTERN_PattMode        (SETFILLPATTERN_Opcode + SHORT_S)
#define SETFILLPATTERN_PattMode_S      SHORT_S    
#define SETFILLPATTERN_RcId            (SETFILLPATTERN_PattMode + SHORT_S)
#define SETFILLPATTERN_RcId_S          LONG_S    
#define SETFILLPATTERN_FillPatt        (SETFILLPATTERN_RcId + LONG_S)
#define SETFILLPATTERN_FillPatt_S      (8 * CHAR_S)
#define SETFILLPATTERN_S               (SETFILLPATTERN_FillPatt + (8 * CHAR_S))

#define SETLINESTYLE_Opcode            0
#define SETLINESTYLE_Opcode_S          SHORT_S    
#define SETLINESTYLE_LSMode            (SETLINESTYLE_Opcode + SHORT_S)
#define SETLINESTYLE_LSMode_S          SHORT_S    
#define SETLINESTYLE_RcId              (SETLINESTYLE_LSMode + SHORT_S)
#define SETLINESTYLE_RcId_S            LONG_S    
#define SETLINESTYLE_LineStyle         (SETLINESTYLE_RcId + LONG_S)
#define SETLINESTYLE_LineStyle_S       LONG_S    
#define SETLINESTYLE_S                 (SETLINESTYLE_LineStyle + LONG_S)

#define SETLOGICOP_Opcode              0
#define SETLOGICOP_Opcode_S            SHORT_S    
#define SETLOGICOP_LogicOp             (SETLOGICOP_Opcode + SHORT_S)
#define SETLOGICOP_LogicOp_S           SHORT_S    
#define SETLOGICOP_RcId                (SETLOGICOP_LogicOp + SHORT_S)
#define SETLOGICOP_RcId_S              LONG_S    
#define SETLOGICOP_S                   (SETLOGICOP_RcId + LONG_S)

#define SETTRANSPARENCY_Opcode         0
#define SETTRANSPARENCY_Opcode_S       SHORT_S    
#define SETTRANSPARENCY_TranspMode     (SETTRANSPARENCY_Opcode + SHORT_S)
#define SETTRANSPARENCY_TranspMode_S   SHORT_S    
#define SETTRANSPARENCY_RcId           (SETTRANSPARENCY_TranspMode + SHORT_S)
#define SETTRANSPARENCY_RcId_S         LONG_S    
#define SETTRANSPARENCY_S              (SETTRANSPARENCY_RcId + LONG_S)

#define SETTRIVIALIN_Opcode            0
#define SETTRIVIALIN_Opcode_S          SHORT_S    
#define SETTRIVIALIN_TrivMode          (SETTRIVIALIN_Opcode + SHORT_S)
#define SETTRIVIALIN_TrivMode_S        SHORT_S    
#define SETTRIVIALIN_RcId              (SETTRIVIALIN_TrivMode + SHORT_S)
#define SETTRIVIALIN_RcId_S            LONG_S    
#define SETTRIVIALIN_S                 (SETTRIVIALIN_RcId + LONG_S)

#define SYNC_Opcode                    0
#define SYNC_Opcode_S                  SHORT_S    
#define SYNC_Null                      (SYNC_Opcode + SHORT_S)
#define SYNC_Null_S                    CHAR_S    
#define SYNC_Reserved                  (SYNC_Null + CHAR_S)
#define SYNC_Reserved_S                CHAR_S    
#define SYNC_RcId                      (SYNC_Reserved + CHAR_S)
#define SYNC_RcId_S                    LONG_S    
#define SYNC_S                         (SYNC_RcId + LONG_S)

#define RENDERSCPOLYLINE_Opcode        0
#define RENDERSCPOLYLINE_Opcode_S      SHORT_S    
#define RENDERSCPOLYLINE_Npts          (RENDERSCPOLYLINE_Opcode + SHORT_S)
#define RENDERSCPOLYLINE_Npts_S        SHORT_S    
#define RENDERSCPOLYLINE_RcId          (RENDERSCPOLYLINE_Npts + SHORT_S)
#define RENDERSCPOLYLINE_RcId_S        LONG_S    
#define RENDERSCPOLYLINE_Points        (RENDERSCPOLYLINE_RcId + LONG_S)
#define RENDERSCPOLYLINE_Points_S      IPOINT2_S    
                                          
#define RENDERSCPOLYGON_Opcode         0
#define RENDERSCPOLYGON_Opcode_S       SHORT_S    
#define RENDERSCPOLYGON_Npts           (RENDERSCPOLYGON_Opcode + SHORT_S)
#define RENDERSCPOLYGON_Npts_S         SHORT_S    
#define RENDERSCPOLYGON_RcId           (RENDERSCPOLYGON_Npts + SHORT_S)
#define RENDERSCPOLYGON_RcId_S         LONG_S    
#define RENDERSCPOLYGON_Points         (RENDERSCPOLYGON_RcId + LONG_S)
#define RENDERSCPOLYGON_Points_S       IPOINT2_S    
                                       
#define RENDER2DMPOLYLINE_Opcode       0
#define RENDER2DMPOLYLINE_Opcode_S     SHORT_S    
#define RENDER2DMPOLYLINE_Npts         (RENDER2DMPOLYLINE_Opcode + SHORT_S)
#define RENDER2DMPOLYLINE_Npts_S       SHORT_S    
#define RENDER2DMPOLYLINE_RcId         (RENDER2DMPOLYLINE_Npts + SHORT_S)
#define RENDER2DMPOLYLINE_RcId_S       LONG_S    
#define RENDER2DMPOLYLINE_Data         (RENDER2DMPOLYLINE_RcId + LONG_S)
#define RENDER2DMPOLYLINE_Data_S       LONG_S    

#define RENDER2DMPOLYLINE32_Opcode     0
#define RENDER2DMPOLYLINE32_Opcode_S   SHORT_S    
#define RENDER2DMPOLYLINE32_Npts       (RENDER2DMPOLYLINE32_Opcode + SHORT_S)
#define RENDER2DMPOLYLINE32_Npts_S     SHORT_S    
#define RENDER2DMPOLYLINE32_RcId       (RENDER2DMPOLYLINE32_Npts + SHORT_S)
#define RENDER2DMPOLYLINE32_RcId_S     LONG_S    
#define RENDER2DMPOLYLINE32_Data       (RENDER2DMPOLYLINE32_RcId + LONG_S)
#define RENDER2DMPOLYLINE32_Data_S     LONG_S    

#define RENDER2DPOLYGON_Opcode         0
#define RENDER2DPOLYGON_Opcode_S       SHORT_S    
#define RENDER2DPOLYGON_Npts           (RENDER2DPOLYGON_Opcode + SHORT_S)
#define RENDER2DPOLYGON_Npts_S         SHORT_S    
#define RENDER2DPOLYGON_RcId           (RENDER2DPOLYGON_Npts + SHORT_S)
#define RENDER2DPOLYGON_RcId_S         LONG_S    
#define RENDER2DPOLYGON_Points         (RENDER2DPOLYGON_RcId + LONG_S)
#define RENDER2DPOLYGON_Points_S       IPOINT2_S    

#define RENDER2DPOLYGON32_Opcode       0
#define RENDER2DPOLYGON32_Opcode_S     SHORT_S    
#define RENDER2DPOLYGON32_Npts         (RENDER2DPOLYGON32_Opcode + SHORT_S)
#define RENDER2DPOLYGON32_Npts_S       SHORT_S    
#define RENDER2DPOLYGON32_RcId         (RENDER2DPOLYGON32_Npts + SHORT_S)
#define RENDER2DPOLYGON32_RcId_S       LONG_S    
#define RENDER2DPOLYGON32_Points       (RENDER2DPOLYGON32_RcId + LONG_S)
#define RENDER2DPOLYGON32_Points_S     IPOINT2_32_S    

#define SET2DVIEWPORT_Opcode           0
#define SET2DVIEWPORT_Opcode_S         SHORT_S    
#define SET2DVIEWPORT_Null             (SET2DVIEWPORT_Opcode + SHORT_S)
#define SET2DVIEWPORT_Null_S           SHORT_S    
#define SET2DVIEWPORT_RcId             (SET2DVIEWPORT_Null + SHORT_S)
#define SET2DVIEWPORT_RcId_S           LONG_S    
#define SET2DVIEWPORT_Corner1          (SET2DVIEWPORT_RcId + LONG_S)
#define SET2DVIEWPORT_Corner1_S        IPOINT2_S    
#define SET2DVIEWPORT_Corner2          (SET2DVIEWPORT_Corner1 + IPOINT2_S)
#define SET2DVIEWPORT_Corner2_S        IPOINT2_S    
#define SET2DVIEWPORT_S                (SET2DVIEWPORT_Corner2 + IPOINT2_S)

#define SET2DWINDOW_Opcode             0
#define SET2DWINDOW_Opcode_S           SHORT_S    
#define SET2DWINDOW_Null               (SET2DWINDOW_Opcode + SHORT_S)
#define SET2DWINDOW_Null_S             SHORT_S    
#define SET2DWINDOW_RcId               (SET2DWINDOW_Null + SHORT_S)
#define SET2DWINDOW_RcId_S             LONG_S    
#define SET2DWINDOW_Corner1            (SET2DWINDOW_RcId + LONG_S)
#define SET2DWINDOW_Corner1_S          IPOINT2_S    
#define SET2DWINDOW_Corner2            (SET2DWINDOW_Corner1 + IPOINT2_S)
#define SET2DWINDOW_Corner2_S          IPOINT2_S    
#define SET2DWINDOW_S                  (SET2DWINDOW_Corner2 + IPOINT2_S)

#define SET2DWINDOW32_Opcode           0
#define SET2DWINDOW32_Opcode_S         SHORT_S    
#define SET2DWINDOW32_Null             (SET2DWINDOW32_Opcode + SHORT_S)
#define SET2DWINDOW32_Null_S           SHORT_S    
#define SET2DWINDOW32_RcId             (SET2DWINDOW32_Null + SHORT_S)
#define SET2DWINDOW32_RcId_S           LONG_S    
#define SET2DWINDOW32_Corner1          (SET2DWINDOW32_RcId + LONG_S)
#define SET2DWINDOW32_Corner1_S        IPOINT2_32_S    
#define SET2DWINDOW32_Corner2          (SET2DWINDOW32_Corner1 + IPOINT2_32_S)
#define SET2DWINDOW32_Corner2_S        IPOINT2_32_S    
#define SET2DWINDOW32_S                (SET2DWINDOW32_Corner2 + IPOINT2_32_S)

#define CHANGEMATRIX_Opcode            0
#define CHANGEMATRIX_Opcode_S          SHORT_S    
#define CHANGEMATRIX_MatrixNo          (CHANGEMATRIX_Opcode + SHORT_S)
#define CHANGEMATRIX_MatrixNo_S        SHORT_S    
#define CHANGEMATRIX_RcId              (CHANGEMATRIX_MatrixNo + SHORT_S)
#define CHANGEMATRIX_RcId_S            LONG_S    
#define CHANGEMATRIX_Operation         (CHANGEMATRIX_RcId + LONG_S)
#define CHANGEMATRIX_Operation_S       SHORT_S    
#define CHANGEMATRIX_Mode              (CHANGEMATRIX_Operation + SHORT_S)
#define CHANGEMATRIX_Mode_S            SHORT_S    
#define CHANGEMATRIX_Source            (CHANGEMATRIX_Mode + SHORT_S)
#define CHANGEMATRIX_Source_S          MATRIX4_S    
#define CHANGEMATRIX_S                 (CHANGEMATRIX_Source + MATRIX4_S)

#define RENDERPOLYLINE_Opcode          0
#define RENDERPOLYLINE_Opcode_S        SHORT_S    
#define RENDERPOLYLINE_LenVertexList   (RENDERPOLYLINE_Opcode + SHORT_S)
#define RENDERPOLYLINE_LenVertexList_S SHORT_S    
#define RENDERPOLYLINE_RcId            (RENDERPOLYLINE_LenVertexList + SHORT_S)
#define RENDERPOLYLINE_RcId_S          LONG_S    
#define RENDERPOLYLINE_VertexList      (RENDERPOLYLINE_RcId + LONG_S)

#define RENDERPOLYQUAD_Opcode          0
#define RENDERPOLYQUAD_Opcode_S        SHORT_S    
#define RENDERPOLYQUAD_LenTileList     (RENDERPOLYQUAD_Opcode + SHORT_S)
#define RENDERPOLYQUAD_LenTileList_S   SHORT_S    
#define RENDERPOLYQUAD_RcId            (RENDERPOLYQUAD_LenTileList + SHORT_S)
#define RENDERPOLYQUAD_RcId_S          LONG_S    
#define RENDERPOLYQUAD_TileList        (RENDERPOLYQUAD_RcId + LONG_S)

#define SETCLIP3D_Opcode               0
#define SETCLIP3D_Opcode_S             SHORT_S    
#define SETCLIP3D_Clip3DPlanes         (SETCLIP3D_Opcode + SHORT_S)
#define SETCLIP3D_Clip3DPlanes_S       SHORT_S    
#define SETCLIP3D_RcId                 (SETCLIP3D_Clip3DPlanes + SHORT_S)
#define SETCLIP3D_RcId_S               LONG_S    
#define SETCLIP3D_S                    (SETCLIP3D_RcId + LONG_S)

#define SETLIGHTSOURCES_Opcode         0
#define SETLIGHTSOURCES_Opcode_S       SHORT_S    
#define SETLIGHTSOURCES_LenLSDB        (SETLIGHTSOURCES_Opcode + SHORT_S)
#define SETLIGHTSOURCES_LenLSDB_S      SHORT_S    
#define SETLIGHTSOURCES_RcId           (SETLIGHTSOURCES_LenLSDB + SHORT_S)
#define SETLIGHTSOURCES_RcId_S         LONG_S    
#define SETLIGHTSOURCES_LSDBId         (SETLIGHTSOURCES_RcId + LONG_S)
#define SETLIGHTSOURCES_LSDBId_S       LONG_S    
#define SETLIGHTSOURCES_LSDB           (SETLIGHTSOURCES_LSDBId + LONG_S)
#define SETLIGHTSOURCES_LSDB_S         FLOAT_S    
                                       
#define SETRENDERDATA_Opcode           0
#define SETRENDERDATA_Opcode_S         SHORT_S    
#define SETRENDERDATA_Null             (SETRENDERDATA_Opcode + SHORT_S)
#define SETRENDERDATA_Null_S           SHORT_S    
#define SETRENDERDATA_RcId             (SETRENDERDATA_Null + SHORT_S)
#define SETRENDERDATA_RcId_S           LONG_S    
#define SETRENDERDATA_OptData          (SETRENDERDATA_RcId + LONG_S)
#define SETRENDERDATA_OptData_S        LONG_S    
#define SETRENDERDATA_Reserved0        (SETRENDERDATA_OptData + LONG_S)
#define SETRENDERDATA_Reserved0_S      NORM3_S    
#define SETRENDERDATA_Reserved1        (SETRENDERDATA_Reserved0 + NORM3_S)
#define SETRENDERDATA_Reserved1_S      COLOR3_S    
#define SETRENDERDATA_Reserved2        (SETRENDERDATA_Reserved1 + COLOR3_S)
#define SETRENDERDATA_Reserved2_S      NORM3_S    
#define SETRENDERDATA_S                (SETRENDERDATA_Reserved2 + NORM3_S)

#define SETRENDERMODE_Opcode           0
#define SETRENDERMODE_Opcode_S         SHORT_S    
#define SETRENDERMODE_RenderMode       (SETRENDERMODE_Opcode + SHORT_S)
#define SETRENDERMODE_RenderMode_S     SHORT_S    
#define SETRENDERMODE_RcId             (SETRENDERMODE_RenderMode + SHORT_S)
#define SETRENDERMODE_RcId_S           LONG_S    
#define SETRENDERMODE_S                (SETRENDERMODE_RcId + LONG_S)

#define SETSURFACEATTR_Opcode          0
#define SETSURFACEATTR_Opcode_S        SHORT_S    
#define SETSURFACEATTR_Translucidity   (SETSURFACEATTR_Opcode + SHORT_S)
#define SETSURFACEATTR_Translucidity_S CHAR_S
#define SETSURFACEATTR_Null            (SETSURFACEATTR_Translucidity + CHAR_S)
#define SETSURFACEATTR_Null_S          CHAR_S    
#define SETSURFACEATTR_RcId            (SETSURFACEATTR_Null + CHAR_S)
#define SETSURFACEATTR_RcId_S          LONG_S    
#define SETSURFACEATTR_SurfEmission    (SETSURFACEATTR_RcId + LONG_S)
#define SETSURFACEATTR_SurfEmission_S  COLOR3_S    
#define SETSURFACEATTR_SurfAmbient     (SETSURFACEATTR_SurfEmission + COLOR3_S)
#define SETSURFACEATTR_SurfAmbient_S   COLOR3_S    
#define SETSURFACEATTR_SurfDiffuse     (SETSURFACEATTR_SurfAmbient + COLOR3_S)
#define SETSURFACEATTR_SurfDiffuse_S   COLOR3_S    
#define SETSURFACEATTR_SurfSpecular    (SETSURFACEATTR_SurfDiffuse + COLOR3_S)
#define SETSURFACEATTR_SurfSpecular_S  COLOR3_S    
#define SETSURFACEATTR_SurfSpecExp     (SETSURFACEATTR_SurfSpecular + COLOR3_S)
#define SETSURFACEATTR_SurfSpecExp_S   IFLOAT_S    
#define SETSURFACEATTR_S               (SETSURFACEATTR_SurfSpecExp + IFLOAT_S)

#define SETVIEWER_Opcode               0
#define SETVIEWER_Opcode_S             SHORT_S    
#define SETVIEWER_ViewMode             (SETVIEWER_Opcode + SHORT_S)
#define SETVIEWER_ViewMode_S           SHORT_S    
#define SETVIEWER_RcId                 (SETVIEWER_ViewMode + SHORT_S)
#define SETVIEWER_RcId_S               LONG_S    
#define SETVIEWER_ViewerPosition       (SETVIEWER_RcId + LONG_S)
#define SETVIEWER_ViewerPosition_S     POINT3_S    
#define SETVIEWER_ViewerDirection      (SETVIEWER_ViewerPosition + POINT3_S)
#define SETVIEWER_ViewerDirection_S    NORM3_S
#define SETVIEWER_S                    (SETVIEWER_ViewerDirection + NORM3_S)

#define SETZBUFFER_Opcode              0
#define SETZBUFFER_Opcode_S            SHORT_S
#define SETZBUFFER_ZMode               (SETZBUFFER_Opcode + SHORT_S)
#define SETZBUFFER_ZMode_S             SHORT_S
#define SETZBUFFER_RcId                (SETZBUFFER_ZMode + SHORT_S)
#define SETZBUFFER_RcId_S              LONG_S
#define SETZBUFFER_ZFunction           (SETZBUFFER_RcId + LONG_S)
#define SETZBUFFER_ZFunction_S         LONG_S
#define SETZBUFFER_S                   (SETZBUFFER_ZFunction + LONG_S)

#define SETOUTLINE_Opcode              0
#define SETOUTLINE_Opcode_S            SHORT_S    
#define SETOUTLINE_Outline             (SETOUTLINE_Opcode + SHORT_S)
#define SETOUTLINE_Outline_S           SHORT_S    
#define SETOUTLINE_RcId                (SETOUTLINE_Outline + SHORT_S)
#define SETOUTLINE_RcId_S              LONG_S    
#define SETOUTLINE_S                   (SETOUTLINE_RcId + LONG_S)

#define SPANLINE_Opcode                0
#define SPANLINE_Opcode_S              SHORT_S
#define SPANLINE_Null                  (SPANLINE_Opcode + SHORT_S)
#define SPANLINE_Null_S                SHORT_S
#define SPANLINE_RcId                  (SPANLINE_Null + SHORT_S)
#define SPANLINE_RcId_S                LONG_S
#define SPANLINE_YPosition             (SPANLINE_RcId + LONG_S)
#define SPANLINE_YPosition_S           LONG_S
#define SPANLINE_XLeft                 (SPANLINE_YPosition + LONG_S)
#define SPANLINE_XLeft_S               LONG_S
#define SPANLINE_XRight                (SPANLINE_XLeft + LONG_S)
#define SPANLINE_XRight_S              LONG_S
#define SPANLINE_ZLeft                 (SPANLINE_XRight + LONG_S)
#define SPANLINE_ZLeft_S               LONG_S
#define SPANLINE_ZRight                (SPANLINE_ZLeft + LONG_S)
#define SPANLINE_ZRight_S              LONG_S
#define SPANLINE_RGBLeft               (SPANLINE_ZRight + LONG_S)
#define SPANLINE_RGBLeft_S             COLOR3_S
#define SPANLINE_RGBRight              (SPANLINE_RGBLeft + COLOR3_S)
#define SPANLINE_RGBRight_S            COLOR3_S
#define SPANLINE_S                     (SPANLINE_RGBRight + COLOR3_S)

#define TRIANGLE_Opcode                0
#define TRIANGLE_Opcode_S              SHORT_S
#define TRIANGLE_Null                  (TRIANGLE_Opcode + SHORT_S)
#define TRIANGLE_Null_S                SHORT_S
#define TRIANGLE_RcId                  (TRIANGLE_Null + SHORT_S)
#define TRIANGLE_RcId_S                LONG_S
#define TRIANGLE_Vertex0_XYZ           (TRIANGLE_RcId + LONG_S)
#define TRIANGLE_Vertex0_XYZ_S         POINT3_S
#define TRIANGLE_Vertex0_RGB           (TRIANGLE_Vertex0_XYZ + POINT3_S)
#define TRIANGLE_Vertex0_RGB_S         COLOR3_S
#define TRIANGLE_Vertex1_XYZ           (TRIANGLE_Vertex0_RGB + COLOR3_S)
#define TRIANGLE_Vertex1_XYZ_S         POINT3_S
#define TRIANGLE_Vertex1_RGB           (TRIANGLE_Vertex1_XYZ + POINT3_S)
#define TRIANGLE_Vertex1_RGB_S         COLOR3_S
#define TRIANGLE_Vertex2_XYZ           (TRIANGLE_Vertex1_RGB + COLOR3_S)
#define TRIANGLE_Vertex2_XYZ_S         POINT3_S
#define TRIANGLE_Vertex2_RGB           (TRIANGLE_Vertex2_XYZ + POINT3_S)
#define TRIANGLE_Vertex2_RGB_S         COLOR3_S
#define TRIANGLE_S                     (TRIANGLE_Vertex2_RGB + COLOR3_S)

#define RENDERPOLYTRI_Opcode           0
#define RENDERPOLYTRI_Opcode_S         SHORT_S    
#define RENDERPOLYTRI_LenTileList      (RENDERPOLYTRI_Opcode + SHORT_S)
#define RENDERPOLYTRI_LenTileList_S    SHORT_S    
#define RENDERPOLYTRI_RcId             (RENDERPOLYTRI_LenTileList + SHORT_S)
#define RENDERPOLYTRI_RcId_S           LONG_S    
#define RENDERPOLYTRI_TileList         (RENDERPOLYTRI_RcId + LONG_S)

#define SETPLANEMASK_Opcode            0
#define SETPLANEMASK_Opcode_S          SHORT_S    
#define SETPLANEMASK_Mode              (SETPLANEMASK_Opcode + SHORT_S)
#define SETPLANEMASK_Mode_S            SHORT_S    
#define SETPLANEMASK_RcId              (SETPLANEMASK_Mode + SHORT_S)
#define SETPLANEMASK_RcId_S            LONG_S    
#define SETPLANEMASK_PlaneMask         (SETPLANEMASK_RcId + LONG_S)
#define SETPLANEMASK_PlaneMask_S       LONG_S    
#define SETPLANEMASK_S                 (SETPLANEMASK_PlaneMask + LONG_S)

#define SETASYNCHRONOUSSWAP_Opcode     0
#define SETASYNCHRONOUSSWAP_Opcode_S   SHORT_S    
#define SETASYNCHRONOUSSWAP_Mode       (SETASYNCHRONOUSSWAP_Opcode + SHORT_S)
#define SETASYNCHRONOUSSWAP_Mode_S     SHORT_S    
#define SETASYNCHRONOUSSWAP_RcId       (SETASYNCHRONOUSSWAP_Mode + SHORT_S)
#define SETASYNCHRONOUSSWAP_RcId_S     LONG_S    
#define SETASYNCHRONOUSSWAP_S          (SETASYNCHRONOUSSWAP_RcId + LONG_S)

#define SETLINESTYLEOFFSET_Opcode      0
#define SETLINESTYLEOFFSET_Opcode_S    SHORT_S    
#define SETLINESTYLEOFFSET_Offset      (SETLINESTYLEOFFSET_Opcode + SHORT_S)
#define SETLINESTYLEOFFSET_Offset_S    SHORT_S    
#define SETLINESTYLEOFFSET_RcId        (SETLINESTYLEOFFSET_Offset + SHORT_S)
#define SETLINESTYLEOFFSET_RcId_S      LONG_S    
#define SETLINESTYLEOFFSET_S           (SETLINESTYLEOFFSET_RcId + LONG_S)


/*****************************************************************************/


/******************************************************************************

 CADDI miscellaneous definitions as per CADDI specification 1.10

*/

/*** Light type definitions FLOAT ***/

#define NULL_LIGHT_TYPE          0.0
#define AMBIENT_LIGHT_TYPE       1.0
#define DIRECTIONAL_LIGHT_TYPE   2.0
#define POSITIONAL_LIGHT_TYPE    3.0
#define SPOT_LIGHT_TYPE          4.0

/*** Clear defines ***/

#define DISPLAY_AND_Z_MODE       0x0
#define DISPLAY_ONLY_MODE        0x1
#define Z_ONLY_MODE              0x2

#define Z_NEAR                   0.0
#define Z_FAR                    1.0

/*** SetBufferConfiguration defines ***/

#define TC_FULL_DEPTH_MODE       0
#define TC_BUF_A_MODE            1
#define TC_BUF_B_MODE            2

/*** SetEndPoint defines **/

#define ENDPOINT_DISABLE         0
#define ENDPOINT_ENABLE          1

/*** SetFillPattern defines ***/

#define PATTERN_DISABLE          0
#define PATTERN_ENABLE           1

/*** SetLineStyle defines ***/

#define LINESTYLE_DISABLE        0
#define LINESTYLE_ENABLE         1

/*** SetLogicOp defines ***/

#define ROP_CLEAR                0x0
#define ROP_NOR                  0x1
#define ROP_ANDINVERTED          0x2
#define ROP_REPLACEINVERTED      0x3
#define ROP_ANDREVERSE           0x4
#define ROP_INVERT               0x5
#define ROP_XOR                  0x6
#define ROP_NAND                 0x7
#define ROP_AND                  0x8
#define ROP_EQUIV                0x9
#define ROP_NOOP                 0xa
#define ROP_ORINVERTED           0xb
#define ROP_REPLACE              0xc
#define ROP_ORREVERSE            0xd
#define ROP_OR                   0xe
#define ROP_SET                  0xf

/*** SetTransparency defines ***/

#define TRANSPARENCY_DISABLE     0
#define TRANSPARENCY_ENABLE      1

/*** SetTrivialIn defines ***/

#define TRIVIALIN_DISABLE        0
#define TRIVIALIN_ENABLE         1

/*** Sync defines ***/

#define SYNC_SPECIAL_RC          -1

/*** RenderScPolygon and Render2DPloygon defines ***/

#define POLYGON_IS_TRIANGLE      3
#define POLYGON_IS_QUAD          4

/*** ChangeMatrix defines ***/

#define MW_MATRIX                0
#define WV_MATRIX                1
#define VS_MATRIX                2

#define REPLACE_MATRIX           0

/*** SetClip3D defines ***/

#define CLIP_LEFT                0x01
#define CLIP_TOP                 0x02
#define CLIP_RIGHT               0x04
#define CLIP_BOTTOM              0x08
#define CLIP_FRONT               0x10
#define CLIP_BACK                0x20
#define CLIP_ALL                 0x3f

/*** SetRenderData defines ***/

#define OptData_SPECIFIED_A      0
#define OptData_SPECIFIED_M      0x0000ffff

#define VERTEX_NORMAL_SPECIFIED  0x00000001
#define VERTEX_COLOR_SPECIFIED   0x00000002
#define FACE_NORMAL_SPECIFIED    0x00000100
#define FACE_COLOR_SPECIFIED     0x00000200

#define OptData_MASK_A           16
#define OptData_MASK_M           0xffff0000

#define VERTEX_NORMAL_MASK       0x00010000
#define VERTEX_COLOR_MASK        0x00020000
#define FACE_NORMAL_MASK         0x01000000
#define FACE_COLOR_MASK          0x02000000

/*** SetRenderMode defines ***/

#define RenderMode_FACE_A        0
#define RenderMode_FACE_M        0x00ff

#define WIREFRAME_MODE           0
#define CONTOUR_MODE             6
#define HIDDEN_LINE_MODE         7
#define FLAT_MODE                8
#define GOURAUD_MODE             9

#define SOLID_GENERAL_MODE         10
#define WIREFRAME_GENERAL_MODE     11
#define SOLID_GENERAL_CONTOUR_MODE 12
#define WIREFRAME_HIDDEN_MODE      13
#define FAST_CONTOUR_MODE          14

#define RenderMode_LINE_A        8
#define RenderMode_LINE_M        0xff00

/*** SetViewer defines ***/

#define INFINITE_VIEWER          0
#define LOCAL_VIEWER             1

/*** SetZBuffer defines ***/

#define ZBUFFER_DISABLE          0
#define ZBUFFER_ENABLE           1

#define ZBUFFER_LT_FUNC          0
#define ZBUFFER_LTE_FUNC         1

/*** DMA related defines ***/

#define DMA_DISABLE              0
#define DMA_ENABLE               1

#define DMA_TYPE_ISA             0
#define DMA_TYPE_B               1
#define DMA_TYPE_C               2

#define DMA_WIDTH_16             0
#define DMA_WIDTH_32             1

/*** SetOutline defines ***/

#define OUTLINE_DISABLE          0
#define OUTLINE_ENABLE           1

/*** SetPlaneMask defines ***/

#define SETPLANEMASK_REPLACE     0
#define SETPLANEMASK_AND         1

/*****************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\ddc.c ===
/**************************************************************************\

$Header: $

$Log: $

\**************************************************************************/

#include "switches.h"

#if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE))

#ifndef WINDOWS_NT
    #include <dos.h>
#endif

    #include "bind.h"
    #include "defbind.h"
    #include "edid.h"

#ifdef WINDOWS_NT
    BOOLEAN bGetIdentifier(dword dwIdentifier, byte* romAddr, long* StartIndex);

  #if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,ReportDDCcapabilities)
    #pragma alloc_text(PAGE,ReadEdid)
    #pragma alloc_text(PAGE,InDDCTable)
    #pragma alloc_text(PAGE,bGetIdentifier)
  #endif

    #define PCI_BIOS_BASE       0x000e0000
    #define PCI_BIOS_LENGTH     0x00020000

    extern  PUCHAR setmgaselNoV(dword MgaSel, dword phyadr, dword limit);
    extern  PVOID   pMgaDeviceExtension;

    // I'm having trouble compiling...
    dword   CLMFarCall[2];
    dword   CLMCallAddress;

#endif  /* #ifdef WINDOWS_NT */

#ifdef _WINDOWS_DLL16
    #include "windows.h"
#endif

#define   DEBUG                  0
#define   COMPAQ                 0
#define   BIOSCOMPAQ        0xFF000

byte SupportDDC = FALSE;
EDID DataEdid;

byte     whichBios;
byte     BiosEntry[6];
byte     DataEdidFarPtr[6];
dword    physicalAddr;
dword    lenghtService;
dword    OffsetEntryPoint;

VesaSet VesaParam[15] = {            
/*00*/{  640,  480, 75, 0,  31500,  640, 16,  64, 120, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0 ,
                            31500,  640, 16,  64, 120, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0 ,
                            31500,  640, 16,  64, 120, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0},                              
/*01*/{  640,  480, 72, 0,  31500,  640, 24,  40, 128, 0,  480,  9,  3, 28, 0, 0, 0, 0, 0 ,
                            31500,  640, 24,  40, 128, 0,  480,  9,  3, 28, 0, 0, 0, 0, 0 ,
                            31500,  640, 24,  40, 128, 0,  480,  9,  3, 28, 0, 0, 0, 0, 0},
/*02*/{  640,  480, 60, 0,  25175,  640, 16,  96,  48, 0,  480, 11,  2, 32, 0, 0, 0, 0, 0 ,
                            25175,  640, 16,  96,  48, 0,  480, 11,  2, 32, 0, 0, 0, 0, 0 ,
                            25175,  640, 16,  96,  48, 0,  480, 11,  2, 32, 0, 0, 0, 0, 0},
/*03*/{  800,  600, 75, 0,  49500,  800, 16,  80, 160, 1,  600,  1,  3, 21, 0, 0, 0, 1, 1 ,
                            49500,  800, 32,  64, 160, 1,  600,  1,  3, 21, 0, 0, 0, 1, 1 ,
                            49500,  800, 32,  64, 160, 1,  600,  1,  3, 21, 0, 0, 0, 1, 1}, 
/*04*/{  800,  600, 72, 0,  50000,  800, 56, 120,  64, 0,  600, 37,  6, 23, 0, 0, 0, 1, 1 ,
                            50000,  800, 56, 120,  64, 0,  600, 37,  6, 23, 0, 0, 0, 1, 1 ,
                            50000,  800, 56, 120,  64, 0,  600, 37,  6, 23, 0, 0, 0, 1, 1},
/*05*/{  800,  600, 60, 0,  40000,  800, 40, 128,  88, 0,  600,  1,  4, 23, 0, 0, 0, 1, 1 ,
                            40000,  800, 40, 128,  88, 0,  600,  1,  4, 23, 0, 0, 0, 1, 1 ,
                            40000,  800, 32, 128,  88, 0,  600,  1,  4, 23, 0, 0, 0, 1, 1},
/*06*/{  800,  600, 56, 0,  37800,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 ,
                            37800,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 ,
                            37800,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1},
/*07*/{ 1024,  768, 75, 0,  78750, 1024, 16,  96, 176, 1,  768,  1,  3, 28, 0, 0, 0, 1, 1 ,
                            78750, 1024, 16,  96, 176, 1,  768,  1,  3, 28, 0, 0, 0, 1, 1 ,
                            78750, 1024, 16,  96, 176, 1,  768,  1,  3, 28, 0, 0, 0, 1, 1},
/*08*/{ 1024,  768, 70, 0,  75000, 1024, 24, 136, 144, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 ,
                            75000, 1024, 32, 128, 144, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 ,
                            75000, 1024, 40, 128, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0},
/*09*/{ 1024,  768, 60, 0,  65000, 1024, 24, 136, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 ,
                            65000, 1024, 24, 136, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 ,
                            65000, 1024, 32, 136, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0},
/*10*/{ 1024,  768, 87, 0,  44900, 1024, 32, 128,  64, 0,  384,  1,  4, 21, 0, 0, 1, 1, 1 ,
                            44900, 1024, 32, 128,  64, 0,  384,  1,  4, 21, 0, 0, 1, 1, 1 ,
                            44900, 1024, 32, 128,  64, 0,  384,  1,  4, 21, 0, 0, 1, 1, 1},
/*11*/{ 1280, 1024, 75, 0, 135600, 1280, 16, 144, 248, 1, 1024,  2,  3, 37, 0, 0, 0, 1, 1 ,
                           135600, 1280, 32, 128, 256, 1, 1024,  2,  3, 37, 0, 0, 0, 1, 1 ,
                           135600, 1280, 32, 128, 256, 1, 1024,  2,  3, 37, 0, 0, 0, 1, 1},
      {(word)-1}
};


#ifdef  OS2
    extern int pDdcInfoLen;
#endif//!OS2

byte ReportDDCcapabilities(void)
{

#ifdef  OS2
    if(pDdcInfoLen)
        return (TRUE);
    else
	    return (FALSE);
#else//!OS2

#if (USE_DDC_CODE)
    PUCHAR  romAddr = 0;
    PUCHAR  BiosAddr;
    long    StartIndex;
    SHORT   wNumPages;
#else
   volatile byte _Far* BiosAddr;
   union  _REGS r;
#endif

   word i,j;
   byte SupportFunction,DisplayCapabilities;
   dword sel;
   char *BiosId[] = { {"COMPAQ"}, {"OTHERS"} };

   whichBios = 0;
   SupportFunction = 0;

#if (USE_DDC_CODE)
   // getmgasel() always returns 0 on WinNT, and it does not matter.
   sel = getmgasel();
#else
   if ((sel = getmgasel()) != 0)
#endif
      {
      /* search for a particular BIOS */
#if (USE_DDC_CODE)
      if ((BiosAddr = setmgaselNoV(sel, BIOSCOMPAQ, 1)) != NULL)
#else
      if ((BiosAddr = setmgasel(sel, BIOSCOMPAQ, 1)) != NULL)
#endif
      {
         for(i = 0x0FEA, j = 0; i < 0x0FF0 ; i++, j++)
            {
            if (*(BiosAddr + i) != BiosId[0][j])
               {
               whichBios = 1;
               break;
               }
            }
      }

   #if (USE_DDC_CODE)
      VideoPortFreeDeviceBase(pMgaDeviceExtension, BiosAddr);
   #endif

      /* Verify the DDC capabilities */
      switch (whichBios)
         {
         case COMPAQ:
            {

   #if (USE_DDC_CODE)
                sel = getmgasel();
                if ((romAddr = setmgaselNoV(sel, PCI_BIOS_BASE, 0x20)) == NULL)
                {
                    return(FALSE);
                }

                StartIndex = 0;
                if (!bGetIdentifier('MLC$', romAddr, &StartIndex))
                {
                    // We didn't find anything!
                    VideoPortFreeDeviceBase(pMgaDeviceExtension, romAddr);
                    return(FALSE);
                }
                else
                {
                    wNumPages = (SHORT)(lenghtService / (4*1024));
                    wNumPages = (wNumPages != 0) ? wNumPages : 1;
                    CLMCallAddress = (dword)setmgaselNoV(sel, physicalAddr,
                                                                wNumPages);
                    if (CLMCallAddress == (dword)NULL)
                    {
                        DisplayCapabilities = FALSE;
                    }
                    else
                    {
                        CLMFarCall[0] = CLMCallAddress + OffsetEntryPoint;
                        // We know this is for Compaq.
                        _asm
                        {
                            xor     ebx,ebx
                            lea     eax, CLMFarCall
                            mov     bx, cs
                            mov     [eax+4], ebx
                            mov     eax, 0xe813
                            mov     bx, 0x0100
                            call    fword ptr CLMFarCall
                            jc      NoCaps
                            test    ah, ah
                            jnz     NoCaps
                            and     bl, bh
                            test    bl, 0x02
                            jz      NoCaps
                            mov     DisplayCapabilities, TRUE
                            jmp     AllSet

                        NoCaps:
                            mov     DisplayCapabilities, FALSE

                        AllSet:
                        }
                        VideoPortFreeDeviceBase(pMgaDeviceExtension,
                                                    (PUCHAR)CLMCallAddress);
                    }
                    VideoPortFreeDeviceBase(pMgaDeviceExtension, romAddr);
                }
   #else        /* #if (USE_DDC_CODE) */

      #ifdef __WATCOMC__
            r.w.ax = 0xe813;
      #else
            r.x.ax = 0xe813;
      #endif
            r.h.bh = 0x01;
            r.h.bl = 0x00;
         
            _int86(0x15, &r, &r);

      /*** INT 15h function supported ***/
      #ifdef __WATCOMC__
            if (!r.w.cflag && !r.h.ah)
      #else
            if (!r.x.cflag && !r.h.ah)
      #endif
               SupportFunction = TRUE;
            else
               SupportFunction = FALSE;

        /*** System and monitor support DDC2 ***/
            if((r.h.bh & 0x02) && (r.h.bl & 0x02) && SupportFunction)
               DisplayCapabilities = TRUE;
            else
               DisplayCapabilities = FALSE;

   #endif  /* #if (USE_DDC_CODE) */

            break;
            }

         default:
            {
            DisplayCapabilities = FALSE;
            break;
            }
         } /* end case */
      } /* end if */

#if DEBUG
   printf ("\n SupportFunction = %d",SupportFunction);
   printf ("\n whichBios = %d",whichBios);
   getch();
#endif

   return (DisplayCapabilities);
#endif//!OS2 & else
}

#ifdef _WINDOWS_DLL16

byte ReadEdid(void)
   {
   union  REGS    r;
   struct SREGS   s = {0};
   RealIntStruct  regReel = {0};
   dword          lineaireDosMem;
   word           i, sel, seg;
   byte           _far *ddcData;
   EDID           *DataEdidPtr;
   
   /* Allocate a dos memory bloc of 128 bytes */
   lineaireDosMem = GlobalDosAlloc(128);
   if (!lineaireDosMem)
      return 0;

   seg = lineaireDosMem >> 16;
   sel = lineaireDosMem & 0xffff;

   regReel.eax = 0xe813;
   regReel.ebx = 00;
   regReel.ds  = seg;
   regReel.esi = 0;
   regReel.sp = 0;
   regReel.ss = 0;

   r.x.ax = 0x300;
   r.x.bx = 0x115;
   r.x.cx = 0x00;
   r.x.di = OFFSETOF(&regReel);
   s.es = SELECTOROF(&regReel);
   int86x(0x31, &r, &r, &s);

   if ( !r.x.cflag )
      {
      DataEdidPtr = &DataEdid;
      ddcData = (byte _far *)MAKELP(sel, 0);
      for (i = 0; i < 128; i++)
          *(((byte *) DataEdidPtr) + i) = ddcData[i];

         if( DataEdid.established_timings.est_timings_I & 0x20 ) 
            VesaParam[2].Support = TRUE; /* 640X480X60Hz */
         if( DataEdid.established_timings.est_timings_I & 0x08 )
            VesaParam[1].Support = TRUE; /* 640X480X72Hz */
         if( DataEdid.established_timings.est_timings_I & 0x04 )
            VesaParam[0].Support = TRUE; /* 640X480X75Hz */
         if( DataEdid.established_timings.est_timings_I & 0x02 )
            VesaParam[6].Support = TRUE; /* 800X600X56Hz */
         if( DataEdid.established_timings.est_timings_I & 0x01 )
            VesaParam[5].Support = TRUE; /* 800X600X60Hz */
         if( DataEdid.established_timings.est_timings_II & 0x80 )
            VesaParam[4].Support = TRUE; /* 800X600X72Hz */
         if( DataEdid.established_timings.est_timings_II & 0x40 )
            VesaParam[3].Support = TRUE; /* 800X600X75Hz */
         if( DataEdid.established_timings.est_timings_II & 0x10 )
            VesaParam[10].Support = TRUE;/* 1024X768X87Hz I */
         if( DataEdid.established_timings.est_timings_II & 0x08 )
            VesaParam[9].Support = TRUE; /* 1024X768X60Hz */
         if( DataEdid.established_timings.est_timings_II & 0x04 )
            VesaParam[8].Support = TRUE;/* 1024X768X70Hz */
         if( DataEdid.established_timings.est_timings_II & 0x02 )
            VesaParam[7].Support = TRUE; /* 1024X768X75Hz */
         if( DataEdid.established_timings.est_timings_II & 0x01 )
            VesaParam[11].Support = TRUE;/* 1280X1024X75Hz */
      }

   GlobalDosFree( sel );

   if (!r.x.cflag)
      return (1);
   return (0);
}

#else   /* #ifdef _WINDOWS_DLL16 */

byte ReadEdid(void)
{
#ifndef OS2             //[nPhung] 13-Dec-1994

#ifndef WINDOWS_NT
   dword    bios32add;
   volatile byte _far *romAddr = 0;
   int      i,j,sum;
#endif

   dword    sel;

   /* Search for Bios32 Service Directory */
   byte find = 0;

#if (USE_DDC_CODE)
    long    StartIndex;
    SHORT   wNumPages;
    PUCHAR  romAddr = 0;

    StartIndex = 0;

    sel = getmgasel();
    if ((romAddr = setmgaselNoV(sel, PCI_BIOS_BASE, 0x20)) == NULL)
        return(FALSE);

    do
    {
        if (!bGetIdentifier('MLC$', romAddr, &StartIndex))
        {
            // We went through the whole region.
            VideoPortFreeDeviceBase(pMgaDeviceExtension, romAddr);
            return(FALSE);
        }
        else
        {
            wNumPages = (SHORT)(lenghtService / (4*1024));
            wNumPages = (wNumPages != 0) ? wNumPages : 1;
            CLMCallAddress = (dword)setmgaselNoV(sel, physicalAddr, wNumPages);
            if (CLMCallAddress != (dword)NULL)
            {
                CLMFarCall[0] = CLMCallAddress + OffsetEntryPoint;

                _asm
                {
                    xor     ebx, ebx
                    lea     eax, CLMFarCall
                    mov     bx, cs
                    mov     [eax+4], ebx
                    mov     ax, 0xe813;
                    mov     bx, 0
                    lea     esi, DataEdid
                    call    fword ptr CLMFarCall
                    mov     find, al
                }
                VideoPortFreeDeviceBase(pMgaDeviceExtension,
                                                    (PUCHAR)CLMCallAddress);
            }
        }
    } while (find == 0);

    VideoPortFreeDeviceBase(pMgaDeviceExtension, romAddr);

#else   /* #if (USE_DDC_CODE) */

   if ((sel = getmgasel()) != 0)
      {
      romAddr = setmgasel(sel,0xe0000,0x20);
      for (i = 0; (i < 0x20000) && !find; i += 2 )
        {
        if ( (romAddr[i+0] == '_') &&
             (romAddr[i+1] == '3') &&
             (romAddr[i+2] == '2') &&
             (romAddr[i+3] == '_') 
           )
           {
           sum = 0;
           for (j = 0; j < 16; j++) 
              sum += romAddr[i+j];

           if (sum & 0xff)
              {
              find = 0;
              continue;
              }

           bios32add  = (dword)romAddr[i+7] << 24;
           bios32add |= (dword)romAddr[i+6] << 16;
           bios32add |= (dword)romAddr[i+5] <<  8;
           bios32add |= (dword)romAddr[i+4];

           if (!GetDDCIdentifier(bios32add))
              {
              switch (whichBios)
                  {
                  case COMPAQ:
                     {
                     find = GetCPQDDCDataEdid();
                     break;
                     }
                  default:
                     {
                     find = 0;
                     break;
                     }
                  } /* end switch */

              }

           }
        }/* end for */
      }

#endif  /* #if (USE_DDC_CODE) */

   if (find)

#else   //this is OS2       //[nPhung] 13-Dec-1994

   if(pDdcInfoLen)          //[nPhung] 13-Dec-1994

#endif  // !OS2 and else    //[nPhung] 13-Dec-1994
      {
      if( DataEdid.established_timings.est_timings_I & 0x20 ) 
         VesaParam[2].Support = TRUE; /* 640X480X60Hz */
      if( DataEdid.established_timings.est_timings_I & 0x08 )
         VesaParam[1].Support = TRUE; /* 640X480X72Hz */
      if( DataEdid.established_timings.est_timings_I & 0x04 )
         VesaParam[0].Support = TRUE; /* 640X480X75Hz */
      if( DataEdid.established_timings.est_timings_I & 0x02 )
         VesaParam[6].Support = TRUE; /* 800X600X56Hz */
      if( DataEdid.established_timings.est_timings_I & 0x01 )
         VesaParam[5].Support = TRUE; /* 800X600X60Hz */
      if( DataEdid.established_timings.est_timings_II & 0x80 )
         VesaParam[4].Support = TRUE; /* 800X600X72Hz */
      if( DataEdid.established_timings.est_timings_II & 0x40 )
         VesaParam[3].Support = TRUE; /* 800X600X75Hz */
      if( DataEdid.established_timings.est_timings_II & 0x10 )
         VesaParam[10].Support = TRUE;/* 1024X768X87Hz I */
      if( DataEdid.established_timings.est_timings_II & 0x08 )
         VesaParam[9].Support = TRUE; /* 1024X768X60Hz */
      if( DataEdid.established_timings.est_timings_II & 0x04 )
         VesaParam[8].Support = TRUE;/* 1024X768X70Hz */
      if( DataEdid.established_timings.est_timings_II & 0x02 )
         VesaParam[7].Support = TRUE; /* 1024X768X75Hz */
      if( DataEdid.established_timings.est_timings_II & 0x01 )
         VesaParam[11].Support = TRUE;/* 1280X1024X75Hz */

#ifdef  OS2
      return TRUE;
      }
   return FALSE;

#else   //!OS2

      }

 #if DEBUG
   printf ("\n find = %d",find);
   getch();
 #endif

   return (find);

#endif  //OS2
}

#endif  /* #ifdef _WINDOWS_DLL16 */

byte InDDCTable(dword DispWidth)
{
   int i;

   for (i = 0; VesaParam[i].DispWidth != (word) -1; i++)
      {
      if (VesaParam[i].DispWidth == DispWidth)
         {
         for (; VesaParam[i].DispWidth == DispWidth; i++)
            {
            if (VesaParam[i].Support)
               return TRUE;
            }
         return FALSE;
         }
      }

   return FALSE;
}

#if (USE_DDC_CODE)

BOOLEAN bGetIdentifier(dword dwIdentifier, UCHAR* romAddr, long* StartIndex)
{
    dword   bios32add, biosFarCall[2];
    long    i, j, sum;
    byte    RetValue;

    for (i = *StartIndex; i < PCI_BIOS_LENGTH; i += 2 )
    {
        if ((romAddr[i+0] == '_') &&
            (romAddr[i+1] == '3') &&
            (romAddr[i+2] == '2') &&
            (romAddr[i+3] == '_') 
           )
        {
            sum = 0;
            for (j = 0; j < 16; j++) 
                sum += romAddr[i+j];

            if (sum & 0xff)
            {
                continue;
            }

            bios32add  = (dword)romAddr[i+7] << 24;
            bios32add |= (dword)romAddr[i+6] << 16;
            bios32add |= (dword)romAddr[i+5] <<  8;
            bios32add |= (dword)romAddr[i+4];

            bios32add = (dword)setmgaselNoV( 0, bios32add, 2);
            if (bios32add == (dword)NULL)
            {
                RetValue = 0x80;
            }
            else
            {
                biosFarCall[0] = bios32add;

                // We can call bios32add directly, no need to fudge around with
                // selectors and access rights.

                _asm
                {
                    // Load the registers.
                    xor     ebx,ebx
                    lea     eax, biosFarCall
                    mov     bx, cs
                    mov     [eax+4], ebx
                    mov     eax, dwIdentifier
                    mov     ebx, 0
                    call    fword ptr biosFarCall
                    mov     physicalAddr, ebx
                    mov     lenghtService, ecx
                    mov     OffsetEntryPoint, edx
                    mov     RetValue, al            // 0x00, 0x80, or 0x81
                }
                VideoPortFreeDeviceBase(pMgaDeviceExtension, (PUCHAR)bios32add);
            }
            if (!RetValue)
            {
                *StartIndex = i;
                return(TRUE);
            }
        }           // if ((romAddr[i+0] == '_') && ...
    }               // for (i = 0; i < PCI_BIOS_LENGTH; i += 2 )
    *StartIndex = PCI_BIOS_LENGTH;
    return(FALSE);
}

#endif  /* #if (USE_DDC_CODE) */

#endif  /* #if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE)) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\defbind.h ===
/*****************************************************************************
*
*   file name:   defbind.h
*
******************************************************************************/

#ifdef __HC303__

#ifdef __ANSI_C__
#define _REGS     REGS

/*** Configuration for compatibility with ASM ***/
#pragma Off(Args_in_regs_for_locals);
#else
/*** Configuration for compatibility with ASM ***/
pragma Off(Args_in_regs_for_locals);
#endif /* __ANSI_C__ */

#endif /* __HC303__ */

#ifdef __HC173__

#ifdef __ANSI_C__
#define _REGS     REGS

/*** Optimizations turned off ***/
#pragma Off(Optimize_xjmp);
#pragma Off(Optimize_fp);
#pragma Off(Auto_reg_alloc);
#pragma Off(Postpone_arg_pops);
#else
/*** Optimizations turned off ***/
pragma Off(Optimize_xjmp);
pragma Off(Optimize_fp);
pragma Off(Auto_reg_alloc);
pragma Off(Postpone_arg_pops);
#endif /* __ANSI_C__ */

#endif /* __HC173__ */



#ifdef HIGHC162
    #define _itoa     itoa
    #define _strnicmp strnicmp
    #define _REGS     REGS
    #define _int86    int86
    #define _inp      inp
    #define _outp     outp
    #define _stat     stat

#ifdef SCRAP
   struct WORDREGS {
      unsigned int ax;
      unsigned int bx;
      unsigned int cx;
      unsigned int dx;
      unsigned int si;
      unsigned int di;
      unsigned int cflag;
   };


   struct BYTEREGS {
      unsigned char al, ah, xax[sizeof(int)-2];
      unsigned char bl, bh, xbx[sizeof(int)-2];
      unsigned char cl, ch, xcx[sizeof(int)-2];
      unsigned char dl, dh, xdx[sizeof(int)-2];
   };

   union REGS {
      struct WORDREGS x;
      struct BYTEREGS h;
      struct BYTEREGS l;
   };

   struct SREGS {
      unsigned short int es;
      unsigned short int cs;
      unsigned short int ss;
      unsigned short int ds;
   };
#endif


    typedef unsigned int size_t;
    extern char * itoa(int, char *, int);
    extern int strnicmp(const char *__s1, const char *__s2, size_t __n);
/*    extern int int86(int ,union REGS *, union REGS *); */
    extern int inp(unsigned int);
    extern int outp(unsigned int ,int );
     extern stat(char *, struct stat *);

#endif



#ifdef __WATCOMC__
   #define _itoa     itoa
   #define _strnicmp strnicmp
   #define _REGS     REGS
   #define _int86    int386
   #define _inp      inp
   #define _outp     outp
   #define _stat     stat
   #define _Far      _far
#endif

#ifdef __MICROSOFTC600__
   #define _itoa     itoa
   #define _strnicmp strnicmp
   #define _REGS     REGS
   #define _int86    int86
   #define _inp      inp
   #define _outp     outp
   #define _stat     stat
   #define _Far      far
#endif


#ifdef WINDOWS
    #define _itoa     itoa
    #define _strnicmp strnicmp
    #define _int86    int86
    #define _inp      inp
    #define _outp     outp
    #define _stat     stat
    #define _REGS     REGS
    #define HANDLE    word
    #define WORD      word
typedef char _Far       *LPSTR;

#endif

#ifdef OS2

    #define _itoa     itoa
    #define _strnicmp strnicmp
    #define HANDLE    word
    #define WORD      word

#endif


#ifdef WINDOWS_NT

#define _REGS   REGS

struct EXTDREGS {
    unsigned long reax;
    unsigned long rebx;
    unsigned long recx;
    unsigned long redx;
    unsigned long resi;
    unsigned long redi;
    unsigned long recflag;
};

struct WORDREGS {
    unsigned short ax;
    unsigned short axh;
    unsigned short bx;
    unsigned short bxh;
    unsigned short cx;
    unsigned short cxh;
    unsigned short dx;
    unsigned short dxh;
    unsigned short si;
    unsigned short sih;
    unsigned short di;
    unsigned short dih;
    unsigned short cflag;
    unsigned short cflagh;
};


struct BYTEREGS {
    unsigned char al, ah, xax[sizeof(long)-2];
    unsigned char bl, bh, xbx[sizeof(long)-2];
    unsigned char cl, ch, xcx[sizeof(long)-2];
    unsigned char dl, dh, xdx[sizeof(long)-2];
};

union REGS {
    struct EXTDREGS e;
    struct WORDREGS x;
    struct BYTEREGS h;
};

#endif  /* #ifdef WINDOWS_NT */


/* RAMDAC type definition */
/*** BEN a revoir ***/
#define BT482      0
#define BT484      90
#define BT485      2
#define SIERRA     92
#define CHAMELEON 93
#define VIEWPOINT  1
#define TVP3026    9
#define PX2085     7

#define TITAN_ID        0xA2681700
#define NB_BOARD_MAX             7
#define NB_CRTC_PARAM           34
#define BINDING_REV              1

#define TITAN_CHIP     0
#define ATLAS_CHIP     1
#define ATHENA_CHIP    2

/* Buffer between the binding and CADDI (400 dword) */
#define BUF_BIND_SIZE      400 

#define BLOCK_SIZE      262144      /* 1M of memory (value in dword) */
#define MOUSE_PORT           1


// also in caddi.h
#define CHAR_S   1
#define SHORT_S  2
#define LONG_S   4
#define FLOAT_S  4
#define UINTPTR_S  (sizeof(UINT_PTR))



/*** MGA PRODUCT ID ***/

#define  MGA_ULT_1M     1
#define  MGA_ULT_2M     2
#define  MGA_IMP_3M     3
#define  MGA_IMP_3M_Z   4
#define  MGA_PRO_4M5    5
#define  MGA_PRO_4M5_Z  6
#define  MGA_PCI_2M     7
#define  MGA_PCI_4M     8




/*******************************************************/
/*** DEFINITIONS FOR MGA.INF ***/

#define VERSION_NUMBER 102

#define BIT8            0
#define BIT16           1
#define BITNARROW16     2

#define MONITOR_NA     -1
#define MONITOR_NI      0
#define MONITOR_I       1

#define NUMBER_BOARD_MAX    7
#define NUMBER_OF_RES   8
#define NUMBER_OF_ZOOM  3
#define RES640          0
#define RES800          1
#define RES1024         2
#define RES1152         3
#define RES1280         4
#define RES1600         5
#define RESNTSC         6
#define RESPAL          7

/* DISPLAY SUPPORT */
# define DISP_SUPPORT_I                 0x01    /* interlace */
# define DISP_SUPPORT_NA                0xa0  /* monitor  limited */
# define DISP_SUPPORT_HWL               0xc0  /* hardware limited */
# define DISP_NOT_SUPPORT               0x80 





typedef struct
 {
 word  FbPitch;
 byte  DispType;
 byte  NumOffScr;
 OffScrData *pOffScr; /* pointer to off screen area information */
 }HwModeInterlace;



#ifdef __HIGHC__

/** USE packed (i.e. non aligned struct members)
*** because in mvtovid.c we access the struct
*** as an array. Highc1.73 do not aligned members
*** by default but Highc3.03 DO !!!!!!
**/

typedef _packed struct{    
   char name[26];          
   unsigned long valeur;   
   }vid;                   
                           
#else

typedef struct{
   char name[26];
   unsigned long valeur;
   }vid;

#endif



/*******************************************************/


/* VGA REGISTERS */

#define VGA_SEQ_CLOCKING_MODE     0x1

#define VGA_CRTC_INDEX                    0x3d4
#define VGA_CRTC_DATA                     0x3d5

#define VGA_HORIZONTAL_DISPLAY_ENABLE_END 0x01
#define VGA_START_ADDRESS_LOW             0x0d
#define VGA_START_ADDRESS_HIGH            0x0c

#define VGA_AUXILIARY_INDEX             0x3de
#define VGA_AUXILIARY_DATA              0x3df

#define VGA_VERTICAL_RETRACE_END        0x11
#define VGA_CPU_PAGE_SELECT             0x09
#define VGA_CRTC_EXTENDED_ADDRESS       0x0a
#define VGA_32K_VIDEO_RAM_PAGE_SELECT   0x0c
#define VGA_INTERLACE_SUPPORT_REGISTER  0x0d


typedef struct
   {
   char         IdString[32];           /* "Matrox MGA Setup file" */
   short        Revision;               /* .inf file revision */

   short        BoardPtr[NUMBER_BOARD_MAX]; /* offset of board wrt start of file */
                                        /* -1 = board not there */
   }header;

typedef struct
   {
   dword        MapAddress;             /* board address */
   short        BitOperation8_16;       /* BIT8, BIT16, BITNARROW16 */
   char         DmaEnable;              /* 0 = enable ; 1 = disable */
   char         DmaChannel;             /* channel number. 0 = disabled */
   char         DmaType;                /* 0 = ISA, 1 = B, 2 = C */
   char         DmaXferWidth;           /* 0 = 16, 1 = 32 */
   char         MonitorName[64];        /* as in MONITORM.DAT file */
   short        MonitorSupport[NUMBER_OF_RES];     /* NA, NI, I */
   short        NumVidparm;             /* up to 24 vidparm structures */
   }general_info;

/* vidparm VideoParam[]; */


typedef struct
   {
   long         PixClock;
   short        HDisp;
   short        HFPorch;
   short        HSync;
   short        HBPorch;
   short        HOvscan;
   short        VDisp;
   short        VFPorch;
   short        VSync;
   short        VBPorch;
   short        VOvscan;
   short        OvscanEnable;
   short        InterlaceEnable;
   short        HsyncPol;                /* 0 : Negative   1 : Positive */
   short        VsyncPol;                /* 0 : Negative   1 : Positive */
   }Vidset;


typedef struct
   {
   short        Resolution;             /* RES640, RES800 ... RESPAL */
   short        PixWidth;               /* 8, 16, 32 */
   Vidset       VidsetPar[NUMBER_OF_ZOOM]; /* for zoom X1, X2, X4 */
   }Vidparm;





typedef struct {
   dword length;
   dword hw_diagnostic_result;
   dword sw_diagnostic_result;
   dword shell_id;
   dword shell_id_extension;
   dword shell_version;
   dword shell_version_extension;
   dword shell_start_address;
   dword shell_end_address;
   dword comm_req_type;
   dword comm_req_base_addr_offset;
   dword comm_req_length;
   dword comm_req_wrptr_addr_offset;
   dword comm_req_rdptr_addr_offset;
   dword comm_inq_type;
   dword comm_inq_base_addr_offset;
   dword comm_inq_length;
   dword comm_inq_wrptr_addr_offset;
   dword comm_inq_rdptr_addr_offset;
   dword size_rc;
   dword size_light_type_0;
   dword size_light_type_1;
   dword size_light_type_2;
   dword size_light_type_3;
   dword size_light_type_4;
   dword high_resolution_visible_width;
   dword high_resolution_visible_height;
   dword ntsc_underscan_visible_width;
   dword ntsc_underscan_visible_height;
   dword pal_underscan_visible_width;
   dword pal_underscan_visible_height;
   dword ntsc_overscan_visible_width;
   dword ntsc_overscan_visible_height;
   dword pal_overscan_visible_width;
   dword pal_overscan_visible_height;
   byte  *end_string;
   } SYSPARMS;




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\def.h ===
/*/****************************************************************************
*          name: def.h
*
*   description: This file contains all the software definitions related to the
*                internal structure of CADDI. As CADDI is coded partly in C
*                and in ASM the permitted definitions are simple #define .
*
*      designed: Bart Simpson
* last modified: $Author: abouchar $, $Date: 94/07/28 16:41:06 $
*
*       version: $Id: DEF.H 1.39 94/07/28 16:41:06 abouchar Exp $
*
******************************************************************************/


/*** 31 characters MAXIMUM per name ***/


/******************************************************************************

 RC structure definition (each group represent a dword multiple)

 ****** The RC size MUST BE a multiple of dword ******

*/

#define RC_FLAG_ENDPOINT_M          0x00000001
#define RC_FLAG_ENDPOINT_A          0
#define RC_FLAG_PATTMODE_M          0x00000002
#define RC_FLAG_PATTMODE_A          1
#define RC_FLAG_LSMODE_M            0x00000004
#define RC_FLAG_LSMODE_A            2
#define RC_FLAG_TRANSPMODE_M        0x00000008
#define RC_FLAG_TRANSPMODE_A        3
#define RC_FLAG_TRIVMODE_M          0x00000010
#define RC_FLAG_TRIVMODE_A          4
#define RC_FLAG_MULTICLIP_M         0x00000020
#define RC_FLAG_MULTICLIP_A         5
#define RC_FLAG_VIEWMODE_M          0x00000040
#define RC_FLAG_VIEWMODE_A          6
#define RC_FLAG_ZMODE_M             0x00000080
#define RC_FLAG_ZMODE_A             7
#define RC_FLAG_2D32_M              0x00000100
#define RC_FLAG_2D32_A              8
#define RC_FLAG_ITOPTIMIZE_M        0x00000200
#define RC_FLAG_ITOPTIMIZE_A        9
#define RC_FLAG_WOPTIMIZE_M         0x00000400
#define RC_FLAG_WOPTIMIZE_A         10
#define RC_FLAG_OUTLINE_M           0x00000800
#define RC_FLAG_OUTLINE_A           11
#define RC_FLAG_ASYNCHRONOUSSWAP_M  0x00001000
#define RC_FLAG_ASYNCHRONOUSSWAP_A  12
#define RC_FLAG_NONORMALFLIP_M      0x00002000
#define RC_FLAG_NONORMALFLIP_A      13


#define RC_Flag                     0
#define RC_Flag_S                   LONG_S    

#define RC_BcDisplayMode            (RC_Flag + LONG_S)
#define RC_BcDisplayMode_S          CHAR_S    
#define RC_BcDrawMode               (RC_BcDisplayMode + CHAR_S)
#define RC_BcDrawMode_S             CHAR_S    

#define RC_DB_BcDrawMode            (RC_BcDrawMode + CHAR_S)
#define RC_DB_BcDrawMode_S          CHAR_S    

#define RC_Clip3DPlanes             (RC_DB_BcDrawMode + CHAR_S)
#define RC_Clip3DPlanes_S           CHAR_S    
#define RC_3DClipcodeMask           (RC_Clip3DPlanes + CHAR_S)
#define RC_3DClipcodeMask_S         CHAR_S

#define RC_BgColor                  (RC_3DClipcodeMask + CHAR_S)
#define RC_BgColor_S                LONG_S    

#define RC_ClipList                 (RC_BgColor + LONG_S)
#define RC_ClipList_S               LONG_S    

#define RC_Screen_ClipList          (RC_ClipList + LONG_S)
#define RC_Screen_ClipList_S        LONG_S    
#define RC_OffScreen_ClipList       (RC_Screen_ClipList + LONG_S)
#define RC_OffScreen_ClipList_S     LONG_S    

#define RC_FgColor                  (RC_OffScreen_ClipList + LONG_S)
#define RC_FgColor_S                LONG_S    

#define RC_FillPatt                 (RC_FgColor + LONG_S)
#define RC_FillPatt_S               (4 * LONG_S)

#define RC_LineStyle                (RC_FillPatt + (4 * LONG_S))
#define RC_LineStyle_S              LONG_S    

#define RC_LSDB                     (RC_LineStyle + LONG_S)
#define RC_LSDB_S                   LONG_S
#define RC_LSKB                     (RC_LSDB + LONG_S)
#define RC_LSKB_S                   LONG_S

#define RC_LogicOp                  (RC_LSKB + LONG_S)
#define RC_LogicOp_S                LONG_S    

#define RC_OptData                  (RC_LogicOp + LONG_S)
#define RC_OptData_S                SHORT_S    
#define RC_OptDataMask              (RC_OptData + SHORT_S)
#define RC_OptDataMask_S            SHORT_S    

#define RC_SurfEmission             (RC_OptDataMask + SHORT_S)
#define RC_SurfEmission_S           COLOR3_S    
#define RC_SurfAmbient              (RC_SurfEmission + COLOR3_S)
#define RC_SurfAmbient_S            COLOR3_S    
#define RC_SurfDiffuse              (RC_SurfAmbient + COLOR3_S)
#define RC_SurfDiffuse_S            COLOR3_S    
#define RC_SurfSpecular             (RC_SurfDiffuse + COLOR3_S)
#define RC_SurfSpecular_S           COLOR3_S    
#define RC_SurfSpecExp              (RC_SurfSpecular + COLOR3_S)
#define RC_SurfSpecExp_S            IFLOAT_S    

#define RC_ViewVector               (RC_SurfSpecExp + IFLOAT_S)
#define RC_ViewVector_S             NORM3_S    
#define RC_ViewPosition             (RC_ViewVector + NORM3_S)
#define RC_ViewPosition_S           POINT3_S

#define RC_ViewportYmin             (RC_ViewPosition + POINT3_S)
#define RC_ViewportYmin_S           SHORT_S    
#define RC_ViewportXmin             (RC_ViewportYmin + SHORT_S)
#define RC_ViewportXmin_S           SHORT_S    
#define RC_ViewportXmax             (RC_ViewportXmin + SHORT_S)
#define RC_ViewportXmax_S           SHORT_S    
#define RC_ViewportYmax             (RC_ViewportXmax + SHORT_S)
#define RC_ViewportYmax_S           SHORT_S    

#define RC_WindowYmin               (RC_ViewportYmax + SHORT_S)
#define RC_WindowYmin_S             LONG_S
#define RC_WindowXmin               (RC_WindowYmin + LONG_S)
#define RC_WindowXmin_S             LONG_S    
#define RC_WindowYmax               (RC_WindowXmin + LONG_S)
#define RC_WindowYmax_S             LONG_S    
#define RC_WindowXmax               (RC_WindowYmax + LONG_S)
#define RC_WindowXmax_S             LONG_S    

#define RC_MW                       (RC_WindowXmax + LONG_S)
#define RC_MW_S                     MATRIX4_S    
#define RC_WV                       (RC_MW + MATRIX4_S)
#define RC_WV_S                     MATRIX4_S    
#define RC_VS                       (RC_WV + MATRIX4_S)
#define RC_VS_S                     MATRIX4_S    

#define RC_Composite                (RC_VS + MATRIX4_S)
#define RC_Composite_S              MATRIX4_S
#define RC_InvTpose                 (RC_Composite + MATRIX4_S)
#define RC_InvTpose_S               MATRIX4_S

#define RC_ClearColor               (RC_InvTpose + MATRIX4_S)
#define RC_ClearColor_S             LONG_S    
#define RC_PlaneWrMask              (RC_ClearColor + LONG_S)
#define RC_PlaneWrMask_S            LONG_S    

#define RC_FgColorRGB24             (RC_PlaneWrMask + LONG_S)
#define RC_FgColorRGB24_S           LONG_S
#define RC_BgColorRGB24             (RC_FgColorRGB24 + LONG_S)
#define RC_BgColorRGB24_S           LONG_S
#define RC_ClearColorRGB24          (RC_BgColorRGB24 + LONG_S)
#define RC_ClearColorRGB24_S        LONG_S

#define RC_FaceRenderMode           (RC_ClearColorRGB24 + LONG_S)
#define RC_FaceRenderMode_S         CHAR_S    
#define RC_LineRenderMode           (RC_FaceRenderMode + CHAR_S)
#define RC_LineRenderMode_S         CHAR_S    
#define RC_Translucidity            (RC_LineRenderMode + CHAR_S)
#define RC_Translucidity_S          CHAR_S
#define RC_Free1                    (RC_Translucidity + CHAR_S)
#define RC_Free1_S                  CHAR_S

#define RC_LineStyleOffset          (RC_Free1 + CHAR_S)
#define RC_LineStyleOffset_S        LONG_S

#define RC_Free2                    (RC_LineStyleOffset + CHAR_S)
#define RC_Free2_S                  (2*LONG_S)

#define RC_PlaneWrMask24            (RC_Free2 + (2*LONG_S))
#define RC_PlaneWrMask24_S          LONG_S

#define RC_ZFunction                (RC_PlaneWrMask24 + LONG_S)
#define RC_ZFunction_S              LONG_S

#define RC_2DScaleX                 (RC_ZFunction + LONG_S)
#define RC_2DScaleX_S               LONG_S
#define RC_2DScaleY                 (RC_2DScaleX + LONG_S)
#define RC_2DScaleY_S               LONG_S

#define RC_ClearDepth               (RC_2DScaleY + LONG_S)
#define RC_ClearDepth_S             LONG_S

#define RC_BoundingBoxXY            (RC_ClearDepth + LONG_S)
#define RC_BoundingBoxXY_S          RECT_S

#define RC_S                        (RC_BoundingBoxXY + RECT_S)

/******************************************************************************

 SystemConfig structure definition

*/

#define SYSCONF_PWidth              0
#define SYSCONF_PWidth_S            CHAR_S
#define SYSCONF_ScreenWidth         (SYSCONF_PWidth + CHAR_S)
#define SYSCONF_ScreenWidth_S       SHORT_S
#define SYSCONF_ScreenHeight        (SYSCONF_ScreenWidth + SHORT_S)
#define SYSCONF_ScreenHeight_S      SHORT_S
#define SYSCONF_ZBufferFlag         (SYSCONF_ScreenHeight + SHORT_S)
#define SYSCONF_ZBufferFlag_S       CHAR_S
#define SYSCONF_ZinDRAMFlag         (SYSCONF_ZBufferFlag + CHAR_S)
#define SYSCONF_ZinDRAMFlag_S       CHAR_S
#define SYSCONF_ZBufferHwAddr       (SYSCONF_ZinDRAMFlag + CHAR_S)
#define SYSCONF_ZBufferHwAddr_S     LONG_S
#define SYSCONF_FBM                 (SYSCONF_ZBufferHwAddr + LONG_S)
#define SYSCONF_FBM_S               CHAR_S
#define SYSCONF_DBWinXOffset        (SYSCONF_FBM + CHAR_S)
#define SYSCONF_DBWinXOffset_S      SHORT_S
#define SYSCONF_DBWinYOffset        (SYSCONF_DBWinXOffset + SHORT_S)
#define SYSCONF_DBWinYOffset_S      SHORT_S
#define SYSCONF_ZTagFlag            (SYSCONF_DBWinYOffset + SHORT_S)
#define SYSCONF_ZTagFlag_S          CHAR_S
#define SYSCONF_LUTMode             (SYSCONF_ZTagFlag + CHAR_S)
#define SYSCONF_LUTMode_S           CHAR_S
#define SYSCONF_565Mode             (SYSCONF_LUTMode + CHAR_S)
#define SYSCONF_565Mode_S           CHAR_S
#define SYSCONF_DB_SideSide         (SYSCONF_565Mode + CHAR_S)
#define SYSCONF_DB_SideSide_S       CHAR_S
#define SYSCONF_DB_FrontBack        (SYSCONF_DB_SideSide + CHAR_S)
#define SYSCONF_DB_FrontBack_S      CHAR_S
#define SYSCONF_DST0                (SYSCONF_DB_FrontBack + CHAR_S)
#define SYSCONF_DST0_S              LONG_S
#define SYSCONF_DST1                (SYSCONF_DST0 + LONG_S)
#define SYSCONF_DST1_S              LONG_S
#define SYSCONF_DACType             (SYSCONF_DST1 + LONG_S)
#define SYSCONF_DACType_S           LONG_S
#define SYSCONF_YDSTORG             (SYSCONF_DACType + LONG_S)
#define SYSCONF_YDSTORG_S           LONG_S
#define SYSCONF_DB_YDSTORG          (SYSCONF_YDSTORG + LONG_S)
#define SYSCONF_DB_YDSTORG_S        LONG_S

#define SYSCONF_S                   (SYSCONF_DB_YDSTORG + LONG_S)


/******************************************************************************

 InitBuffer structure definition

 (BINDING used it to communicate with CaddiInit and MGASysInit)

*/

#ifndef WINDOWS_NT

#define INITBUF_PWidth               0
#define INITBUF_PWidth_S             CHAR_S
#define INITBUF_ScreenWidth          (INITBUF_PWidth + CHAR_S)
#define INITBUF_ScreenWidth_S        SHORT_S
#define INITBUF_ScreenHeight         (INITBUF_ScreenWidth + SHORT_S)
#define INITBUF_ScreenHeight_S       SHORT_S
#define INITBUF_MgaOffset            (INITBUF_ScreenHeight + SHORT_S)
#define INITBUF_MgaOffset_S          LONG_S
#define INITBUF_MgaSegment           (INITBUF_MgaOffset + LONG_S)
#define INITBUF_MgaSegment_S         SHORT_S
#define INITBUF_ZBufferFlag          (INITBUF_MgaSegment + SHORT_S)
#define INITBUF_ZBufferFlag_S        CHAR_S
#define INITBUF_ZinDRAMFlag          (INITBUF_ZBufferFlag + CHAR_S)
#define INITBUF_ZinDRAMFlag_S        CHAR_S
#define INITBUF_ZBufferHwAddr        (INITBUF_ZinDRAMFlag + CHAR_S)
#define INITBUF_ZBufferHwAddr_S      LONG_S
#define INITBUF_FBM                  (INITBUF_ZBufferHwAddr + LONG_S)
#define INITBUF_FBM_S                CHAR_S
#define INITBUF_16                   (INITBUF_FBM + CHAR_S)
#define INITBUF_16_S                 CHAR_S
#define INITBUF_ZTagFlag             (INITBUF_16 + CHAR_S)
#define INITBUF_ZTagFlag_S           CHAR_S
#define INITBUF_DMAEnable            (INITBUF_ZTagFlag + INITBUF_ZTagFlag_S)
#define INITBUF_DMAEnable_S          CHAR_S
#define INITBUF_DMAChannel           (INITBUF_DMAEnable + INITBUF_DMAEnable_S)
#define INITBUF_DMAChannel_S         CHAR_S
#define INITBUF_DMAType              (INITBUF_DMAChannel + INITBUF_DMAChannel_S)
#define INITBUF_DMAType_S            CHAR_S
#define INITBUF_DMAXferWidth         (INITBUF_DMAType + INITBUF_DMAType_S)
#define INITBUF_DMAXferWidth_S       CHAR_S
#define INITBUF_LUTMode              (INITBUF_DMAXferWidth + INITBUF_DMAXferWidth_S)
#define INITBUF_LUTMode_S            CHAR_S
#define INITBUF_565Mode              (INITBUF_LUTMode + INITBUF_LUTMode_S)
#define INITBUF_565Mode_S            CHAR_S
#define INITBUF_DB_SideSide          (INITBUF_565Mode + INITBUF_565Mode_S)
#define INITBUF_DB_SideSide_S        CHAR_S
#define INITBUF_DB_FrontBack         (INITBUF_DB_SideSide + INITBUF_DB_SideSide_S)
#define INITBUF_DB_FrontBack_S       CHAR_S
#define INITBUF_DST0                 (INITBUF_DB_FrontBack + INITBUF_DB_FrontBack_S)
#define INITBUF_DST0_S               LONG_S
#define INITBUF_DST1                 (INITBUF_DST0 + INITBUF_DST0_S)
#define INITBUF_DST1_S               LONG_S
#define INITBUF_DACType              (INITBUF_DST1 + INITBUF_DST1_S)
#define INITBUF_DACType_S            LONG_S
#define INITBUF_YDSTORG              (INITBUF_DACType + INITBUF_DACType_S)
#define INITBUF_YDSTORG_S            LONG_S
#define INITBUF_DB_YDSTORG           (INITBUF_YDSTORG + INITBUF_YDSTORG_S)
#define INITBUF_DB_YDSTORG_S         LONG_S
#define INITBUF_ChipSet              (INITBUF_DB_YDSTORG + INITBUF_DB_YDSTORG_S)
#define INITBUF_ChipSet_S            CHAR_S
#define INITBUF_DubicPresent         (INITBUF_ChipSet + INITBUF_ChipSet_S)
#define INITBUF_DubicPresent_S       CHAR_S

#define INITBUF_S                    (INITBUF_DubicPresent + INITBUF_DubicPresent_S)

#else   /* #ifndef WINDOWS_NT */
// On Windows NT, we want to align every field properly.

#define INITBUF_PWidth               0                                  // 0
#define INITBUF_PWidth_S             CHAR_S
#define INITBUF_ScreenWidth          (INITBUF_PWidth + CHAR_S + CHAR_S) // 2
#define INITBUF_ScreenWidth_S        SHORT_S
#define INITBUF_ScreenHeight         (INITBUF_ScreenWidth + SHORT_S)    // 4
#define INITBUF_ScreenHeight_S       SHORT_S
#define INITBUF_MgaOffset            (INITBUF_ScreenHeight + SHORT_S + SHORT_S)
                                                                        // 8
#define INITBUF_MgaOffset_S          UINTPTR_S
#define INITBUF_MgaSegment           (INITBUF_MgaOffset + UINTPTR_S)    // 12 or 16
#define INITBUF_MgaSegment_S         SHORT_S
#define INITBUF_ZBufferFlag          (INITBUF_MgaSegment + SHORT_S)     // 14 or 18
#define INITBUF_ZBufferFlag_S        CHAR_S
#define INITBUF_ZinDRAMFlag          (INITBUF_ZBufferFlag + CHAR_S)     // 15 or 19
#define INITBUF_ZinDRAMFlag_S        CHAR_S
#define INITBUF_ZBufferHwAddr        (INITBUF_ZinDRAMFlag + CHAR_S)     // 16 or 20
#define INITBUF_ZBufferHwAddr_S      LONG_S
#define INITBUF_FBM                  (INITBUF_ZBufferHwAddr + LONG_S)   // 20 or 24
#define INITBUF_FBM_S                CHAR_S
#define INITBUF_16                   (INITBUF_FBM + CHAR_S)             // 21 or 25
#define INITBUF_16_S                 CHAR_S
#define INITBUF_ZTagFlag             (INITBUF_16 + CHAR_S)              // 22 or 26
#define INITBUF_ZTagFlag_S           CHAR_S
#define INITBUF_DMAEnable            (INITBUF_ZTagFlag + INITBUF_ZTagFlag_S)
                                                                        // 23 or 27
#define INITBUF_DMAEnable_S          CHAR_S
#define INITBUF_DMAChannel           (INITBUF_DMAEnable + INITBUF_DMAEnable_S)
                                                                        // 24 or 28
#define INITBUF_DMAChannel_S         CHAR_S
#define INITBUF_DMAType              (INITBUF_DMAChannel + INITBUF_DMAChannel_S)
                                                                        // 25 or 29
#define INITBUF_DMAType_S            CHAR_S
#define INITBUF_DMAXferWidth         (INITBUF_DMAType + INITBUF_DMAType_S)
                                                                        // 26 or 30
#define INITBUF_DMAXferWidth_S       CHAR_S
#define INITBUF_LUTMode              (INITBUF_DMAXferWidth + INITBUF_DMAXferWidth_S)
                                                                        // 27 or 31
#define INITBUF_LUTMode_S            CHAR_S
#define INITBUF_565Mode              (INITBUF_LUTMode + INITBUF_LUTMode_S)
                                                                        // 28 or  32
#define INITBUF_565Mode_S            CHAR_S
#define INITBUF_DB_SideSide          (INITBUF_565Mode + INITBUF_565Mode_S)
                                                                        // 29 or  33
#define INITBUF_DB_SideSide_S        CHAR_S
#define INITBUF_DB_FrontBack         (INITBUF_DB_SideSide + INITBUF_DB_SideSide_S)
                                                                        // 30 or  34
#define INITBUF_DB_FrontBack_S       CHAR_S
#define INITBUF_DST0                 (INITBUF_DB_FrontBack + INITBUF_DB_FrontBack_S + CHAR_S)
                                                                        // 32 or  35
#define INITBUF_DST0_S               LONG_S
#define INITBUF_DST1                 (INITBUF_DST0 + INITBUF_DST0_S)    // 36 or  40
#define INITBUF_DST1_S               LONG_S
#define INITBUF_DACType              (INITBUF_DST1 + INITBUF_DST1_S)    // 40 or  44
#define INITBUF_DACType_S            LONG_S
#define INITBUF_YDSTORG              (INITBUF_DACType + INITBUF_DACType_S)
                                                                        // 44 or 48
#define INITBUF_YDSTORG_S            LONG_S
#define INITBUF_DB_YDSTORG           (INITBUF_YDSTORG + INITBUF_YDSTORG_S)
                                                                        // 48 or 52
#define INITBUF_DB_YDSTORG_S         LONG_S
#define INITBUF_ChipSet              (INITBUF_DB_YDSTORG + INITBUF_DB_YDSTORG_S)
                                                                        // 52 or 56
#define INITBUF_ChipSet_S            CHAR_S
#define INITBUF_DubicPresent         (INITBUF_ChipSet + INITBUF_ChipSet_S)
                                                                        // 53 or 57
#define INITBUF_DubicPresent_S       CHAR_S

#define INITBUF_S                    (INITBUF_DubicPresent + INITBUF_DubicPresent_S + SHORT_S)
                                                                        // 56 or 60 must include padding on a dword address!
#endif  /* #ifndef WINDOWS_NT */

/******************************************************************************

 CurrentENVSystem definitions

*/

#define ENVSystemID_CADDI           0
#define ENVSystemID_BINDING         1

#define ENVSystem_LAST              0
#define ENVSystem_TITAN             1

/******************************************************************************

 CurrentEnvOpcode definitions

*/

#define ENVOPC_BLITMEMSC_PLAN       0x0000ffff      /* binding use -1 opcode */
#define ENVOPC_BLITMEMSC_POLY       0x0001ffff      /* binding use -1 opcode */
#define ENVOPC_BLITSCSC_PLAN        0x0002ffff      /* binding use -1 opcode */
#define ENVOPC_BLITSCSC_POLY        0x0003ffff      /* binding use -1 opcode */
#define ENVOPC_BLITSCMEM_PLAN       0x0004ffff      /* binding use -1 opcode */
#define ENVOPC_BLITSCMEM_POLY       0x0005ffff      /* binding use -1 opcode */
#define ENVOPC_BLITMEMSC_EXP        0x0006ffff      /* binding use -1 opcode */
#define ENVOPC_BLITMEMSC_DITHER     0x0007ffff      /* binding use -1 opcode */

#define ENVOPC_RPQUAD_GOURAUD       (RENDERPOLYQUAD + (0x0 * 65536))
#define ENVOPC_RPQUAD_FLAT          (RENDERPOLYQUAD + (0x1 * 65536))
#define ENVOPC_RPQUAD_WIREFRAMENZ   (RENDERPOLYQUAD + (0x2 * 65536))
#define ENVOPC_RPQUAD_WIREFRAMEZ    (RENDERPOLYQUAD + (0x3 * 65536))
#define ENVOPC_RPQUAD_SOLID_GENERAL (RENDERPOLYQUAD + (0x4 * 65536))
#define ENVOPC_RPQUAD_S_GEN_CONTOUR (RENDERPOLYQUAD + (0x5 * 65536))
#define ENVOPC_RPQUAD_WFRAME_HIDDEN (RENDERPOLYQUAD + (0x6 * 65536))

#define ENVOPC_RPTRIANGLE_GOURAUD       (RENDERPOLYTRIANGLE + (0x0 * 65536))
#define ENVOPC_RPTRIANGLE_FLAT          (RENDERPOLYTRIANGLE + (0x1 * 65536))
#define ENVOPC_RPTRIANGLE_WIREFRAMENZ   (RENDERPOLYTRIANGLE + (0x2 * 65536))
#define ENVOPC_RPTRIANGLE_WIREFRAMEZ    (RENDERPOLYTRIANGLE + (0x3 * 65536))
#define ENVOPC_RPTRIANGLE_SOLID_GENERAL (RENDERPOLYTRIANGLE + (0x4 * 65536))
#define ENVOPC_RPTRIANGLE_S_GEN_CONTOUR (RENDERPOLYTRIANGLE + (0x5 * 65536))
#define ENVOPC_RPTRIANGLE_WFRAME_HIDDEN (RENDERPOLYTRIANGLE + (0x6 * 65536))

#define ENVOPC_SPANLINE             (SPANLINE + (0x0 * 65536))

#define ENVOPC_R3DPLINE_SURFDIFF    (RENDERPOLYLINE + (0x0 * 65536))

#define ENVOPC_TRI_GOURAUD          (TRIANGLE + (0x0 * 65536))
#define ENVOPC_TRI_FLAT             (TRIANGLE + (0x1 * 65536))

/******************************************************************************

 Clear Work Space definitions

*/

#define CLEARWS_DWGCTL_ZI           0
#define CLEARWS_DWGCTL_ZI_S         LONG_S
#define CLEARWS_DWGCTL_I            (CLEARWS_DWGCTL_ZI + LONG_S)
#define CLEARWS_DWGCTL_I_S          LONG_S
#define CLEARWS_DWGCTL_Z            (CLEARWS_DWGCTL_I + LONG_S)
#define CLEARWS_DWGCTL_Z_S          LONG_S
#define CLEARWS_S                   (CLEARWS_DWGCTL_Z + LONG_S)

/******************************************************************************

 LSKB light structure definitions

*/

#define LSKB_NullType               0
#define LSKB_NullType_S             LONG_S
#define LSKB_Null_S                 (LSKB_NullType + LONG_S)   

#define LSKB_AmbK1                  0
#define LSKB_AmbK1_S                COLOR3_S
#define LSKB_Amb_S                  (LSKB_AmbK1 + COLOR3_S)

#define LSKB_DirType                0
#define LSKB_DirType_S              LONG_S
#define LSKB_DirVector              (LSKB_DirType + LONG_S)
#define LSKB_DirVector_S            NORM3_S
#define LSKB_DirK2                  (LSKB_DirVector + NORM3_S)
#define LSKB_DirK2_S                COLOR3_S
#define LSKB_DirSpecFlag            (LSKB_DirK2 + COLOR3_S)
#define LSKB_DirSpecFlag_S          LONG_S
#define LSKB_DirK4                  (LSKB_DirSpecFlag + LONG_S)
#define LSKB_DirK4_S                NORM3_S
#define LSKB_DirSpecExp             (LSKB_DirK4 + NORM3_S)
#define LSKB_DirSpecExp_S           IFLOAT_S
#define LSKB_DirK3                  (LSKB_DirSpecExp + IFLOAT_S)
#define LSKB_DirK3_S                COLOR3_S
#define LSKB_Dir_S                  (LSKB_DirK3 + COLOR3_S)

#define LSKB_PosType                0
#define LSKB_PosType_S              LONG_S
#define LSKB_PosPosition            (LSKB_PosType + LONG_S)
#define LSKB_PosPosition_S          POINT3_S
#define LSKB_PosLA2                 (LSKB_PosPosition + POINT3_S)
#define LSKB_PosLA2_S               NFLOAT_S
#define LSKB_PosLA1                 (LSKB_PosLA2 + NFLOAT_S)
#define LSKB_PosLA1_S               NFLOAT_S
#define LSKB_PosK2                  (LSKB_PosLA1 + NFLOAT_S)
#define LSKB_PosK2_S                COLOR3_S
#define LSKB_PosSpecExp             (LSKB_PosK2 + COLOR3_S)
#define LSKB_PosSpecExp_S           IFLOAT_S
#define LSKB_PosK3                  (LSKB_PosSpecExp + IFLOAT_S)
#define LSKB_PosK3_S                COLOR3_S
#define LSKB_PosSpecFlag            (LSKB_PosK3 + COLOR3_S)
#define LSKB_PosSpecFlag_S          LONG_S
#define LSKB_Pos_S                  (LSKB_PosSpecFlag + LONG_S)

#define LSKB_SpotType               0
#define LSKB_SpotType_S             LONG_S
#define LSKB_SpotPosition           (LSKB_SpotType + LONG_S)
#define LSKB_SpotPosition_S         POINT3_S
#define LSKB_SpotLA2                (LSKB_SpotPosition + POINT3_S)
#define LSKB_SpotLA2_S              NFLOAT_S
#define LSKB_SpotLA1                (LSKB_SpotLA2 + NFLOAT_S)
#define LSKB_SpotLA1_S              NFLOAT_S
#define LSKB_SpotK2                 (LSKB_SpotLA1 + NFLOAT_S)
#define LSKB_SpotK2_S               COLOR3_S
#define LSKB_SpotSpecExp            (LSKB_SpotK2 + COLOR3_S)
#define LSKB_SpotSpecExp_S          IFLOAT_S
#define LSKB_SpotK3                 (LSKB_SpotSpecExp + IFLOAT_S)
#define LSKB_SpotK3_S               COLOR3_S
#define LSKB_SpotSpecFlag           (LSKB_SpotK3 + COLOR3_S)
#define LSKB_SpotSpecFlag_S         LONG_S
#define LSKB_SpotVector             (LSKB_SpotSpecFlag + LONG_S)
#define LSKB_SpotVector_S           NORM3_S
#define LSKB_SpotK6                 (LSKB_SpotVector + NORM3_S)
#define LSKB_SpotK6_S               COLOR3_S
#define LSKB_SpotK5                 (LSKB_SpotK6 + COLOR3_S)
#define LSKB_SpotK5_S               COLOR3_S
#define LSKB_SpotConeExp            (LSKB_SpotK5 + COLOR3_S)
#define LSKB_SpotConeExp_S          IFLOAT_S
#define LSKB_Spot_S                 (LSKB_SpotConeExp + IFLOAT_S)

/******************************************************************************

 LightWS structure definition

*/

#define LIGHTWS_VV_OK_M             0x00000001
#define LIGHTWS_VV_OK_A             0

#define LIGHTWS_Flags               0
#define LIGHTWS_Flags_S             LONG_S
#define LIGHTWS_LSV                 (LIGHTWS_Flags + LONG_S)
#define LIGHTWS_LSV_S               NORM3_S
#define LIGHTWS_MOD_LSV             (LIGHTWS_LSV + NORM3_S)
#define LIGHTWS_MOD_LSV_S           FLOAT_S
#define LIGHTWS_VV                  (LIGHTWS_MOD_LSV + FLOAT_S)
#define LIGHTWS_VV_S                NORM3_S
#define LIGHTWS_TmpRGBDiffuse       (LIGHTWS_VV + NORM3_S)
#define LIGHTWS_TmpRGBDiffuse_S     COLOR3_S
#define LIGHTWS_TmpRGBSpecular      (LIGHTWS_TmpRGBDiffuse + COLOR3_S)
#define LIGHTWS_TmpRGBSpecular_S    COLOR3_S
#define LIGHTWS_Tmp                 (LIGHTWS_TmpRGBSpecular + COLOR3_S)
#define LIGHTWS_Tmp_S               FLOAT_S
#define LIGHTWS_C                   (LIGHTWS_Tmp + FLOAT_S)
#define LIGHTWS_C_S                 FLOAT_S
#define LIGHTWS_S                   (LIGHTWS_C + FLOAT_S)

/******************************************************************************

 Vertex Cache structure definition

*/

#define VERTEXCACHE_NWorld_INV_M    0x00000001  /*** Need to be bit 0 ***/
#define VERTEXCACHE_NWorld_INV_A    0           /*** Need to be bit 0 ***/
#define VERTEXCACHE_PWORLD_OK_M     0x00000002
#define VERTEXCACHE_PWORLD_OK_A     1
#define VERTEXCACHE_SCoord_OK_M     0x00000004
#define VERTEXCACHE_SCoord_OK_A     2
#define VERTEXCACHE_Clipcode_OK_M   0x00000008
#define VERTEXCACHE_Clipcode_OK_A   3

/*** NOTE: SCoord and RGB MUST be in that order ***/

#define VERTEXCACHE_PWorld          0
#define VERTEXCACHE_PWorld_S        POINT3_S
#define VERTEXCACHE_NWorld          (VERTEXCACHE_PWorld + POINT3_S)
#define VERTEXCACHE_NWorld_S        NORM3_S
#define VERTEXCACHE_SCoord          (VERTEXCACHE_NWorld + NORM3_S)
#define VERTEXCACHE_SCoord_S        ((2*LONG_S)+FLOAT_S)
#define VERTEXCACHE_RGB             (VERTEXCACHE_SCoord + ((2*LONG_S)+FLOAT_S))
#define VERTEXCACHE_RGB_S           COLOR3_S
#define VERTEXCACHE_Flags           (VERTEXCACHE_RGB + COLOR3_S)
#define VERTEXCACHE_Flags_S         LONG_S
#define VERTEXCACHE_VCoord          (VERTEXCACHE_Flags + LONG_S)
#define VERTEXCACHE_VCoord_S        (4 * FLOAT_S)
#define VERTEXCACHE_PClipcode       (VERTEXCACHE_VCoord + (4 * FLOAT_S))
#define VERTEXCACHE_PClipcode_S     CHAR_S
#define VERTEXCACHE_Clipcode        (VERTEXCACHE_PClipcode + CHAR_S)
#define VERTEXCACHE_Clipcode_S      (CHAR_S + (2*CHAR_S))  /*** PAD up to a DWORD ***/
#define VERTEXCACHE_Color           (VERTEXCACHE_Clipcode + (CHAR_S + (2*CHAR_S)))
#define VERTEXCACHE_Color_S         COLOR3_S
#define VERTEXCACHE_S               (VERTEXCACHE_Color + COLOR3_S)


/******************************************************************************

 Info fields about hardware configuration returned byAGetMGAConfiguration()

*/

#define Info_Dac_M                  0x0000000f
#define Info_Dac_A                  0

#define Info_Dac_BT481              0x0     /*** Masquer pour conserver DACTYPE ***/
#define Info_Dac_BT482              0x4
#define Info_Dac_ATT                0x8
#define Info_Dac_ATT2050            0xa
#define Info_Dac_Sierra             0xc
#define Info_Dac_ViewPoint          0x1
#define Info_Dac_BT484              0x2
#define Info_Dac_BT485              0x6
#define Info_Dac_Chameleon          0x3
#define Info_Dac_PX2085             0x7
#define Info_Dac_TVP3026            0x9

/******************************************************************************

 Video Buffer used to intialise the VIDEO related hardware

*/

#ifndef WINDOWS_NT

#define VIDEOBUF_ALW                0
#define VIDEOBUF_ALW_S              CHAR_S
#define VIDEOBUF_Interlace          (VIDEOBUF_ALW + CHAR_S)
#define VIDEOBUF_Interlace_S        CHAR_S
#define VIDEOBUF_VideoDelay         (VIDEOBUF_Interlace + CHAR_S)
#define VIDEOBUF_VideoDelay_S       CHAR_S
#define VIDEOBUF_VsyncPol           (VIDEOBUF_VideoDelay + CHAR_S)
#define VIDEOBUF_VsyncPol_S         CHAR_S
#define VIDEOBUF_HsyncPol           (VIDEOBUF_VsyncPol + CHAR_S)
#define VIDEOBUF_HsyncPol_S         CHAR_S
#define VIDEOBUF_HsyncDelay         (VIDEOBUF_HsyncPol + CHAR_S)
#define VIDEOBUF_HsyncDelay_S       CHAR_S
#define VIDEOBUF_Srate              (VIDEOBUF_HsyncDelay + CHAR_S)
#define VIDEOBUF_Srate_S            CHAR_S
#define VIDEOBUF_LaserScl           (VIDEOBUF_Srate + CHAR_S)
#define VIDEOBUF_LaserScl_S         CHAR_S
#define VIDEOBUF_OvsColor           (VIDEOBUF_LaserScl + CHAR_S)
#define VIDEOBUF_OvsColor_S         LONG_S
#define VIDEOBUF_Pedestal           (VIDEOBUF_OvsColor + LONG_S)
#define VIDEOBUF_Pedestal_S         CHAR_S
#define VIDEOBUF_LvidInitFlag       VIDEOBUF_Pedestal             /*** Bit 7 de Pedestal ***/
#define VIDEOBUF_DBWinXOffset       (VIDEOBUF_Pedestal + CHAR_S)
#define VIDEOBUF_DBWinXOffset_S     SHORT_S
#define VIDEOBUF_DBWinYOffset       (VIDEOBUF_DBWinXOffset + SHORT_S)
#define VIDEOBUF_DBWinYOffset_S     SHORT_S
#define VIDEOBUF_PCLK               (VIDEOBUF_DBWinYOffset + SHORT_S)
#define VIDEOBUF_PCLK_S             LONG_S
#define VIDEOBUF_CRTC               (VIDEOBUF_PCLK + LONG_S)
#define VIDEOBUF_CRTC_S             (CHAR_S * 29)
#define VIDEOBUF_S                  (VIDEOBUF_CRTC + (CHAR_S * 29))

#else   /* #ifndef WINDOWS_NT */
// On Windows NT, we want to align every field properly.

#define VIDEOBUF_ALW                0                                   // 0
#define VIDEOBUF_ALW_S              CHAR_S
#define VIDEOBUF_Interlace          (VIDEOBUF_ALW + CHAR_S)             // 1
#define VIDEOBUF_Interlace_S        CHAR_S
#define VIDEOBUF_VideoDelay         (VIDEOBUF_Interlace + CHAR_S)       // 2
#define VIDEOBUF_VideoDelay_S       CHAR_S
#define VIDEOBUF_VsyncPol           (VIDEOBUF_VideoDelay + CHAR_S)      // 3
#define VIDEOBUF_VsyncPol_S         CHAR_S
#define VIDEOBUF_HsyncPol           (VIDEOBUF_VsyncPol + CHAR_S)        // 4
#define VIDEOBUF_HsyncPol_S         CHAR_S
#define VIDEOBUF_HsyncDelay         (VIDEOBUF_HsyncPol + CHAR_S)        // 5
#define VIDEOBUF_HsyncDelay_S       CHAR_S
#define VIDEOBUF_Srate              (VIDEOBUF_HsyncDelay + CHAR_S)      // 6
#define VIDEOBUF_Srate_S            CHAR_S
#define VIDEOBUF_LaserScl           (VIDEOBUF_Srate + CHAR_S)           // 7
#define VIDEOBUF_LaserScl_S         CHAR_S
#define VIDEOBUF_OvsColor           (VIDEOBUF_LaserScl + CHAR_S)        // 8
#define VIDEOBUF_OvsColor_S         LONG_S
#define VIDEOBUF_Pedestal           (VIDEOBUF_OvsColor + LONG_S)        // 12
#define VIDEOBUF_Pedestal_S         CHAR_S
#define VIDEOBUF_LvidInitFlag       VIDEOBUF_Pedestal             /*** Bit 7 de Pedestal ***/
                                                                        // 12
#define VIDEOBUF_DBWinXOffset       (VIDEOBUF_Pedestal + CHAR_S+CHAR_S) // 14
#define VIDEOBUF_DBWinXOffset_S     SHORT_S
#define VIDEOBUF_DBWinYOffset       (VIDEOBUF_DBWinXOffset + SHORT_S)   // 16
#define VIDEOBUF_DBWinYOffset_S     SHORT_S
#define VIDEOBUF_PCLK               (VIDEOBUF_DBWinYOffset + SHORT_S + SHORT_S)
                                                                        // 20
#define VIDEOBUF_PCLK_S             LONG_S
#define VIDEOBUF_CRTC               (VIDEOBUF_PCLK + LONG_S)            // 24
#define VIDEOBUF_CRTC_S             (CHAR_S * 29)
#define VIDEOBUF_S                  (VIDEOBUF_CRTC + (CHAR_S * 29) + (CHAR_S * 3))
                                                                        // 56  must include padding on a dword address!

#endif  /* #ifndef WINDOWS_NT */

/******************************************************************************

 Masks for setting the planes in the 3D clipcode

 coordinate:  W   X   Y   Z
      plane:  x  + - + - + -
 bit number:  7  5 4 3 2 1 0

       inside the plane -> 0
      outside the plane -> 1

      bits 6 is don't care.


      !!!! bit 7 indicate that the point has a  negative W. In that case
           the other bits will be set in the 4D clipping function prior
           to enter the REAL world (x,y,z) clipping section.
*/

#define CLIPCODE_WNEG_M             0x080
#define CLIPCODE_WNEG_A             7 
#define CLIPCODE_XPLUS_M            0x020
#define CLIPCODE_XPLUS_A            5
#define CLIPCODE_XMINUS_M           0x010
#define CLIPCODE_XMINUS_A           4
#define CLIPCODE_YPLUS_M            0x008
#define CLIPCODE_YPLUS_A            3
#define CLIPCODE_YMINUS_M           0x004
#define CLIPCODE_YMINUS_A           2
#define CLIPCODE_ZPLUS_M            0x002
#define CLIPCODE_ZPLUS_A            1
#define CLIPCODE_ZMINUS_M           0x001
#define CLIPCODE_ZMINUS_A           0

/******************************************************************************

 Masks for setting the planes in the 3D pseudo clipcode

 coordinate:  X Y Z
 bit number:  2 1 0

       inside -> 0
      outside -> 1

*/

#define PCLIPCODE_X_M               0x04
#define PCLIPCODE_X_A               2
#define PCLIPCODE_Y_M               0x02
#define PCLIPCODE_Y_A               1
#define PCLIPCODE_Z_M               0x01
#define PCLIPCODE_Z_A               0

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\edid.h ===
/******  EDID.H  ******/

typedef struct
   {
   word         DispWidth;
   word         DispHeight;
   word         RefreshRate;
   bool         Support;
   Vidset       VideoSet;
   } VesaSet;

typedef struct
   {
   dword    edi;
   dword    esi;
   dword    ebp;
   dword    res;
   dword    ebx;
   dword    edx;
   dword    ecx;
   dword    eax;
   word     flag;
   word     es;
   word     ds;
   word     fs;
   word     gs;
   word     ip;
   word     cs;
   word     sp;
   word     ss;
   } RealIntStruct;

typedef struct
  {
  word pixel_clock;
  byte h_active;
  byte h_blanking;
  byte ratio_hor;
  byte v_active;
  byte v_blanking;
  byte ratio_vert;
  byte h_sync_offset;
  byte h_sync_pulse_width;
  byte ratio_sync;
  byte mix;
  byte h_image_size;
  byte v_image_size;
  byte ratio_image_size;
  byte h_border;
  byte v_border;
  byte flags;

  } DET_TIM;

#ifdef WINDOWS_NT
#pragma pack(1)
#endif

typedef struct
  {
  byte  header[8];
  struct
     {
     word  id_manufacture_name;
     word  id_product_code;
     dword id_serial_number;
     byte  week_of_manufacture;
     byte  year_of_manufacture;
     } product_id;
  struct
     {
     byte version;
     byte revision;
     } edid_ver_rev;
  struct
     {
     byte video_input_definition;
     byte max_h_image_size;
     byte max_v_image_size;
     byte display_transfer_charac;
     byte feature_support_dpms;
     } features;
  struct
     {
     byte red_green_low_bits;
     byte blue_white_low_bits;
     byte redx;
     byte redy;
     byte greenx;
     byte greeny;
     byte bluex;
     byte bluey;
     byte whitex;
     byte whitey;
     } color_char;
  struct
     {
     byte est_timings_I;
     byte est_timings_II;
     byte man_res_timings;
     } established_timings;
  word standard_timing_id[8];
  
  DET_TIM detailed_timing[4];

  byte extension_flag;
  byte checksum;

  } EDID;

#ifdef WINDOWS_NT
#pragma pack( )
#endif

extern byte SupportDDC;
extern VesaSet VesaParam[15];
extern EDID DataEdid;

extern bool IsCOMPAQDDCSupport(void);
extern bool callInt15(byte *dest);
extern bool FindCOMPAQBIOS(void);
extern byte InDDCTable(dword DispWidth);
extern byte ReportDDCcapabilities(void);
extern byte ReadEdid(void);
#if !defined(_WINDOWS_DLL16)
extern word GetDDCIdentifier(dword bios32add);
extern word GetCPQDDCDataEdid(void);
#endif

#ifndef WINDOWS_NT
extern volatile byte _Far *setmgasel(dword MgaSel, dword phyadr, dword limit);
#endif

extern dword getmgasel(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\cnvinfo.c ===
/******************************************************************************
*          name: cnvinfo.c
*
*   description: Routines to convert old mga.inf format to the current
*                revision
*
*      designed: Christian Toutant
* last modified: $Author:
*
*       version: $Id: 
*
*
* char *       mtxConvertMgaInf( char *)
*
******************************************************************************/
#include "switches.h"
#include <stdlib.h>
#include <string.h>
#include "bind.h"
#include "defbind.h"
#include "defoldv.h"

/* Prototypes */
word findInfoPrec(header *hdr, word i);
void cnvBrdInfo_101(general_info *dst, general_info_101 *src);
word sizeOfBoard(header *hdr, word i);
char *convertRev101(char *dst, char *src);
char *mtxConvertMgaInf( char *inf );

#ifdef WINDOWS_NT
#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,findInfoPrec)
    #pragma alloc_text(PAGE,cnvBrdInfo_101)
    #pragma alloc_text(PAGE,sizeOfBoard)
    #pragma alloc_text(PAGE,convertRev101)
    #pragma alloc_text(PAGE,mtxConvertMgaInf)
#endif
#endif  /* #ifdef WINDOWS_NT */

extern char DefaultVidset[];

# define GENERAL_INFO(h, i)     ( (general_info *) ( (char *)h + ((header *)h)->BoardPtr[i] ) )
# define GENERAL_INFO101(h, i)  ( (general_info_101 *) ( (char *)h + ((header *)h)->BoardPtr[i] ) )

#ifdef WINDOWS_NT
    extern  ULONG   ulNewInfoSize;
    extern  PVOID   pMgaDeviceExtension;

    PVOID   AllocateSystemMemory(ULONG NumberOfBytes);
#endif  /* #ifdef WINDOWS_NT */

/*----------------------------------------------------------------------------
|          name: findInfoPrec
|
|   description: check if a previous board pointer have the same offset
|                
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: header *hdr  header for search
|                word    i    current board pointer
|      modifies: none
|         calls: 
|       returns: word index of previous board whit the same offset
|                     or NUMBER_BOARD_MAX if no found.
|                       
-----------------------------------------------------------------------------*/
word findInfoPrec(header *hdr, word i)
{
   word j;
   for (j = 0; j < i; j++)
      if (hdr->BoardPtr[i] == hdr->BoardPtr[j]) return j;
   return NUMBER_BOARD_MAX;
}

/*----------------------------------------------------------------------------
|          name: cnvBrdInfo_101
|
|   description: convert general_info ver 101 to general_info ver 102 (current)
|                
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: general_info     *dst  pointer to destination general_info (v.102)
|                general_info_101 *src  pointer to source      general_info (v.101)
|      modifies: none
|         calls: 
|       returns: bool
|
|note : This function must be change when we pass to ver 103. The conversion
|       will be from v. 101 to v. 103.
-----------------------------------------------------------------------------*/
void cnvBrdInfo_101(general_info *dst, general_info_101 *src)
{
   word i, j;
   Vidparm_101 *srcVidParm;
   Vidparm     *dstVidParm;

   dst->MapAddress       = src->MapAddress       ;
   dst->BitOperation8_16 = src->BitOperation8_16 ;     
   dst->DmaEnable        = src->DmaEnable        ;     
   dst->DmaChannel       = src->DmaChannel       ;     
   dst->DmaType          = src->DmaType          ;     
   dst->DmaXferWidth     = src->DmaXferWidth     ;     
   dst->NumVidparm       = src->NumVidparm       ;
   strncpy(dst->MonitorName, src->MonitorName, 64);
   for (i = 0; i < NUMBER_OF_RES; i++)
      dst->MonitorSupport[i] = src->MonitorSupport[i];

   srcVidParm = (Vidparm_101 *)(((char *)src) + sizeof(general_info_101));
   dstVidParm = (Vidparm*)(((char *)dst) + sizeof(general_info));
   for (i = 0; i < src->NumVidparm; i++)
      {
      dstVidParm[i].Resolution = srcVidParm[i].Resolution;
      dstVidParm[i].PixWidth = srcVidParm[i].PixWidth;

      for (j = 0; j < 3; j++)
         {
         dstVidParm[i].VidsetPar[j].PixClock       = srcVidParm[i].VidsetPar[j].PixClock;  
         dstVidParm[i].VidsetPar[j].HDisp          = srcVidParm[i].VidsetPar[j].HDisp   ;
         dstVidParm[i].VidsetPar[j].HFPorch        = srcVidParm[i].VidsetPar[j].HFPorch ; 
         dstVidParm[i].VidsetPar[j].HSync          = srcVidParm[i].VidsetPar[j].HSync   ;
         dstVidParm[i].VidsetPar[j].HBPorch        = srcVidParm[i].VidsetPar[j].HBPorch ; 
         dstVidParm[i].VidsetPar[j].HOvscan        = srcVidParm[i].VidsetPar[j].HOvscan ; 
         dstVidParm[i].VidsetPar[j].VDisp          = srcVidParm[i].VidsetPar[j].VDisp   ;
         dstVidParm[i].VidsetPar[j].VFPorch        = srcVidParm[i].VidsetPar[j].VFPorch ; 
         dstVidParm[i].VidsetPar[j].VSync          = srcVidParm[i].VidsetPar[j].VSync   ;
         dstVidParm[i].VidsetPar[j].VBPorch        = srcVidParm[i].VidsetPar[j].VBPorch ; 
         dstVidParm[i].VidsetPar[j].VOvscan        = srcVidParm[i].VidsetPar[j].VOvscan ; 
         dstVidParm[i].VidsetPar[j].OvscanEnable   = srcVidParm[i].VidsetPar[j].OvscanEnable;  
         dstVidParm[i].VidsetPar[j].InterlaceEnable= srcVidParm[i].VidsetPar[j].InterlaceEnable;  
         dstVidParm[i].VidsetPar[j].HsyncPol       = 0;
         dstVidParm[i].VidsetPar[j].VsyncPol       = 0;
         }
      }
}

/*----------------------------------------------------------------------------
|          name: sizeOfBoard
|
|   description: calculate the size of memory for one board (without the
|                size of the header).
|                
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: header *hdr   header info
|                word    index of the board to calculate.
|      modifies: none
|         calls: 
|       returns: word size needed for the ith board or 0 if no
|                          board.
|
|note : This function must be change when we pass to ver 103. The size
|       will be for v. 103.
|                       
-----------------------------------------------------------------------------*/
word sizeOfBoard(header *hdr, word i)
{
   word sizeBoard, j;

   /* if no board, return size of 0 */
   if ( hdr->BoardPtr[i] == (short)-1 ) return 0;

   /* if a board farther have the same address data, return the
      good size only for the last one and 0 for the other
   */
   for (j = i + 1 ; j < NUMBER_BOARD_MAX; j++)
      if (hdr->BoardPtr[i] == hdr->BoardPtr[j]) return 0;

   /* calculate the size of this board */
   sizeBoard  = sizeof(general_info);


   sizeBoard += sizeof(Vidparm) * GENERAL_INFO101(hdr, i)->NumVidparm;

   return sizeBoard;
}


/*----------------------------------------------------------------------------
|          name: convertRev101
|
|   description: convert from mga.inf v.101 to mga.inf v.102
|                
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: char *dst    pointer to memory destination for new mga.inf
|                             enough must be allocated.
|                char *src    pointer to the mga.inf v.101
|      modifies: none
|         calls: 
|       returns: pointer to the destination mga.inf pointer
|
|note : This function must be change when we pass to ver 103. The conversion
|       will be from v. 101 to v. 103.
|                       
-----------------------------------------------------------------------------*/

char *convertRev101(char *dst, char *src)
{
   word i, j, brdPtr;
   header  *srcHdr, *dstHdr;

   srcHdr = (header *)src;
   dstHdr = (header *)dst;
   brdPtr = sizeof(header);

   for (i = 0; i < NUMBER_BOARD_MAX; i ++)
      {
      if (srcHdr->BoardPtr[i] == (short)-1)
         dstHdr->BoardPtr[i] = -1;
      else
         {
         if ( (j = findInfoPrec(srcHdr, i)) < NUMBER_BOARD_MAX )
            dstHdr->BoardPtr[i] =  dstHdr->BoardPtr[j];
         else
            {
            dstHdr->BoardPtr[i] = brdPtr;
            cnvBrdInfo_101( GENERAL_INFO(dstHdr, i),GENERAL_INFO101(srcHdr, i) );
            brdPtr += sizeOfBoard(srcHdr, i);
            }
         }
      }
   return dst;
}



/*----------------------------------------------------------------------------
|          name: mtxConvertMgaInf
|
|   description: convert a old mga.inf definition to the current one.
|                this function allocate memory for the new mga.inf and
|                free the memory of the old one.
|                
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: char *inf pointer to the old mga.inf
|      modifies: free memory pointed by inf.
|         calls: 
|       returns: pointer to the new mga.inf or 0 if error in conversion.
|                note: the memory pointer by inf is free also if an error
|                      occur.
|                       
-----------------------------------------------------------------------------*/
char *mtxConvertMgaInf( char *inf )
{
    char *newInfo;
    word size_newInfo, i;
    word rev;
    header *hdr = (header *)inf;

    rev = hdr->Revision;
    size_newInfo = sizeof(header);
    for (i = 0; i < NUMBER_BOARD_MAX; i ++)
    {
        switch(rev)
        {
            case 101:
                if (
                    (hdr->BoardPtr[i] != -1) &&
                    (GENERAL_INFO101(hdr, i)->NumVidparm < 0)
                   )
                {
                #ifndef WINDOWS_NT
                    /* In Windows NT, inf points to RequestPacket.InputBuffer:
                         don't free it! */
                    free ( inf );
                #endif
                    return DefaultVidset;
                }

                size_newInfo += sizeOfBoard(hdr, i);
                break;

            default:
                #ifndef WINDOWS_NT
                    /* In Windows NT, inf points to RequestPacket.InputBuffer:
                            don't free it! */
                    free( inf );
                #endif
                    return DefaultVidset;
        }
    }

#ifdef WINDOWS_NT
    if ((newInfo = (PUCHAR)AllocateSystemMemory(size_newInfo)) == (PUCHAR)NULL)
    {
        /* Not enough memory */
        return DefaultVidset;
    }
#else
    if ( (newInfo = (char *)malloc(size_newInfo)) == (char *)0 )
    {
        /* Not enough memory */
        free( inf );
        return DefaultVidset;
    }
#endif  /* #ifdef WINDOWS_NT */

    hdr = (header *)newInfo;
    hdr->Revision = (short)VERSION_NUMBER;
    strncpy(hdr->IdString, ((header *)inf)->IdString, 32);
   
    switch(rev)
    {
        case 101:
                newInfo = convertRev101(newInfo, inf);
                break;

        default:
            #ifdef WINDOWS_NT
                VideoPortReleaseBuffer(pMgaDeviceExtension, newInfo);
            #else
                free(newInfo);
            #endif
                return DefaultVidset;
                break;
    }

#ifdef WINDOWS_NT
    /* We want to know the size of our new buffer in IOCTL_VIDEO_MTX_INITIALIZE_MGA */
    ulNewInfoSize = (ULONG) size_newInfo;
#endif

#ifndef WINDOWS_NT
    /* In Windows NT, inf points to RequestPacket.InputBuffer: don't free it! */
    free ( inf );
#endif

    return newInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\clock.c ===
/* ======================================================================= */
/*
/* Filename             : CLOCK.C
/* Creation             : Dominique Leblanc 92/10/26
/*
/*
/* This file contains the different routines to program the ICD2061
/* oscillator for the MGA family.
/*
/* Modifications List:
/*          D.L. 92/11/30: modification for a limited condition of
/*                         searching for an exact frequency.
/*
/* Bart Simpson: Adaptation for CADDI
/*
/* ======================================================================= */

#include "switches.h"
#include "g3dstd.h"
#include "caddi.h"
#include "def.h"
#include "mga.h"
#include "global.h"
#include "proto.h"
#include "mgai_c.h"
#include "mgai.h"

#ifdef WINDOWS_NT

#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,setFrequence)
    #pragma alloc_text(PAGE,programme_clock)
    #pragma alloc_text(PAGE,dummyCallDelai)
    #pragma alloc_text(PAGE,programme_reg_icd)
    #pragma alloc_text(PAGE,send_unlock)
    #pragma alloc_text(PAGE,send_data)
    #pragma alloc_text(PAGE,send_full_clock)
    #pragma alloc_text(PAGE,send_start)
    #pragma alloc_text(PAGE,send_0)
    #pragma alloc_text(PAGE,send_1)
    #pragma alloc_text(PAGE,send_stop)
    #pragma alloc_text(PAGE,setTVP3026Freq)
#endif

#if defined(ALLOC_PRAGMA)
    #pragma data_seg("PAGE")
#endif

#include "video.h"

#endif  /* #ifdef WINDOWS_NT */

static volatile BYTE _Far * pDevice;

typedef unsigned char   byte;
typedef unsigned short  word;
typedef unsigned long   dword;


/* this keep mclk f(vco) value to use with jitter VCLK=MCLK output value. */
/* updated by function <ProgrammeClock> in module mtxinit.c */
extern void delay_us(dword delai);

extern long  presentMclk[];     /* MCLK currently in use (module mtxinit.c) */
extern byte  iBoard;   /* index of current selected board (module mtxinit.c)*/

typedef struct
{
   short p;
   short q;
   short m;
   short i;
   long  trueFout;
   long  fvco;         /* for jitter problem, keep osc. value */
   long  ppmError;
} ST_RESULTAT;


static ST_RESULTAT    result;
static byte init_misc;



typedef union
{
   byte var8;
   byte byte;
   byte octet;

   struct
   {
      byte enable_color   : 1;  /* 1=COLOR:0x3D?, 0=MONO:0x3B? */
      byte enable_RAM     : 1;
      byte cs0            : 1;
      byte cs1            : 1;
      byte reserved       : 1;
      byte page_select    : 1;
      byte h_pol          : 1;
      byte v_pol          : 1;

   } bit;

   struct
   {
      byte unused         : 2;
      byte pgmclk         : 1;
      byte pgmdata        : 1;
      byte reserved       : 4;

   } clock_bit;

   struct
   {
      byte unused         : 2;
      byte select         : 2;
      byte reserved       : 4;

   } sel_reg_output;

} ST_MISC_OUTPUT;


#define MISC_OUTPUT_WRITE   0x03C2
#define MISC_OUTPUT_READ    0x03CC
#define NBRE_M_POSSIBLE    7


static ST_MISC_OUTPUT        misc;


typedef union
{
   dword var32;
   dword dmot;
   dword ulong;


   struct
   {
      dword q_prime       :  7;
      dword m_diviseur    :  3;
      dword p_prime       :  7;
      dword index_field   :  4;
      dword unused        : 11;

   } bit;

} ST_REG_PROGRAM_DATA;



ST_REG_PROGRAM_DATA reg_clock[4] = { { 0x5A8BCL }, /* REG0 video 1 */
                                     { 0x960ACL }, /* REG1 video 2 */
                                     { 0x960ACL }, /* REG2 video 3 */
                                     { 0xD44A3L }, /* MREG memory  */
                                   };


static long diviseur_m [ NBRE_M_POSSIBLE ] =
{
   1,       /* 0 */
   2,       /* 1 */
   4,       /* 2 */
   8,       /* 3 */
   16,      /* 4 */
   32,      /* 5 */
   64,      /* 6 */
   /* 64,   /* 7 */ /* we don't use this case in our calculations */
};



/* static long limites_i [ NBRE_I_POSSIBLE ] = old see below */
static long limites_i [] =
{/* min,       max,    I */
  50000L,      /* 47500000     0  */
  51000L,      /* 47500000     1  */
  53200L,      /* 52200000     2  */
  58500L,      /* 56300000     3  */
  60700L,      /* 61900000     4  */
  64400L,      /* 65000000     5  */
  66800L,      /* 68100000     6  */
  73500L,      /* 82300000     7  */
  75600L,      /* 86000000     8  */
  80900L,      /* 88000000     9  */
  83200L,      /* 90500000    10  */
  91500L,      /* 95000000    11  */
 100000L,      /*  1.0E+08    12  */
 120000L,      /*  1.2E+08    13  */
 /* 120000000L,      /*             14  */
};
#define NBRE_I_POSSIBLE     ( (sizeof(limites_i)) / (sizeof(long)) )


/* old frequency & keep default value (power up)
 * there is output frequency value f(o)
 */

long old_fr_reg[4] = { { 25175L }, /* REG0 video 1 */
                       { 28322L }, /* REG1 video 2 */
                       { 28322L }, /* REG2 video 3 */
                       { 32500L }, /* MREG memory  */
               };






/**************** LIST OF REGISTERS OF ICD2061 ************************/

#define NBRE_REG_ICD2061    6
#define VIDEO_CLOCK_1       0
#define VIDEO_CLOCK_2       1
#define VIDEO_CLOCK_3       2
#define MEMORY_CLOCK        3
#define POWERDWN_REG        4
#define CONTROL_ICD2061     6


static long fref;




/**************************** list of routines in this file *************/

dword programme_clock ( short reg, short p, short q, short m, short i );
void programme_reg_icd ( volatile BYTE _Far * pDeviceParam, short reg, dword data );
static void send_unlock ( void );
static void send_data ( short reg, dword data );
static void send_full_clock ( void );
static void send_start ( void );
static void send_0 ( void );
static void send_1 ( void );
static void send_stop ( void );
static byte selectIcdOutputReg ( long reg );
static void LowerVCO(long Fout, byte pll, byte pwidth, dword fvcomax, byte dac_rev1);


/*** Temporary delay to be put after each acces to programable register ***/
void dummyCallDelai()
{
   byte TmpByte;

   mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), TmpByte);
}



/***************************************************************************/
/*/ setFrequence ( volatile BYTE _Far *pDeviceParam, long fout, long reg )
 *
 * For a given frequency, determines the best values to put for the
 * programming of the ICD2061.
 * Programs the register.
 * If outgoing frequency is 0, this function only chooses the output register.
 *
 * Problemes :
 * Concu     : Dominique Leblanc:92/10/29
 *
 * Parametres: [0]-frequency output.
 *             [1]-register (0, 1, 2 ou 3) which will be used
 *                 (the register 3 MCLK cannot be used as output
 *
 * Returns   : programmed frequency (or 0)
 *
 */

long setFrequence ( volatile BYTE _Far *pDeviceParam, long fout, long reg )
{
   short i;


   long p, q, m;
   short index;
   short i_find;

   long old_frequency;
   long fvco, trueFout, desiredFout;
   long fdivise;
   long ppmError;
   long bestError;
   long ftmp;



   fref = 1431818;     /* frequence XTAL */


   pDevice = pDeviceParam;

   mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_R), init_misc);
   misc.var8 = init_misc;





   /* special condition: if VCLK is a multiple of MCLK,
    * use special programming multiple VCLK=MCLK
    */

   if ( reg != MEMORY_CLOCK )
   {

      /*
       * 4&3rd case include in same one "for(i=0;...
       *            at place of check1(), and for(i=1;...)"
       *
       * 4rd case: MCLK is soo far as VCLK (.5%)
       * look for jither problems if both oscillator clock are same or
       * closer one from the other, change video frequency to
       * use MCLK redirection.
       * 3rd case: MCLK is multiple of VCLK
       * if mclk is multiple of mclk, divide vclk
       * ex. mclk=50MHz, vclk=25MHz,
       *     vclk(fvco)=mclk(fvco)
       *     mclk==> 50mhz,
       *     vclk==> 50mhz/2
       */
      i_find = NO;
      for ( i = 0 ; ( i < NBRE_M_POSSIBLE && i_find == NO ) ; i++ )
      {
         ftmp = ( fout * 1000L ) * diviseur_m[i];

         if ( ( ftmp >= ( presentMclk[iBoard] - (presentMclk[iBoard]/200) ) ) &&
              ( ftmp <= ( presentMclk[iBoard] + (presentMclk[iBoard]/200) ) )    )
         {
            i_find = YES;     /* MCLK is multiple of VCLK */
            index  = i;       /* keep divisor value       */
         }
      }

      if ( i_find == YES )
      {
         old_frequency   = old_fr_reg[reg];
         old_fr_reg[reg] = fout / 1000L;



         /*
         * We program VCLK since it use same MCLK fvco origin.
         * We reprogram only I value in register to use MCLK on
         * VCLCK, and m divisor (see ICD2061A for more details).
         */
         /*****  putMclkOnVclk ( reg, index ); *****/
         reg_clock[reg].bit.m_diviseur  = index;
         reg_clock[reg].bit.index_field = 0xF;  /* MCLK fvco value */

         programme_reg_icd (pDevice, (short)reg, reg_clock[reg].var32);

         dummyCallDelai();

         selectIcdOutputReg ( reg );
         return ( old_frequency );        /* QUIT */
      }
   }


   /***************************************************/
   /*
   /* MUST ONLY PROGRAM THE REGISTER
   /*
   /***************************************************/


   if ( fout == 0L )
   {

      switch ( reg )
      {
         case VIDEO_CLOCK_1:
         case VIDEO_CLOCK_2:
               misc.sel_reg_output.select = (byte)reg;
               mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);
               break;

         case VIDEO_CLOCK_3:
               misc.sel_reg_output.select = 3;
               mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);
               break;

         default:
               /* par defaut, (si on a modifie MCLK), on restore VCLK
                * initial
                */
               mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), init_misc);
               break;
      }

      return ( NO );
   }



   /***************************************************/
   /*
   /* MUST CALCULATE A FREQUENCY
   /*
   /***************************************************/



   desiredFout = fout;

   index = 0;
   bestError = 99999999;         /* dummy start number */

   for ( m = 0 ; m < NBRE_M_POSSIBLE ; m++ ) /* for all possible divisors */
   {

      fdivise = diviseur_m[m];

      fvco    = fdivise * desiredFout;

      if ((fvco < 40000) || (fvco > 120000))
          continue;


      for ( q = 3 ; q <= 129 ; q++ )
      {

         if ( ((fref/q) < 20000) || ((fref/q) > 100000))
            continue;


         p = ((q * fvco * 100) / (2 * fref)) + 1;


         if (p < 4 || p > 130)
            continue;

         /**************************************************
          * now that we have all our values
          * we determine the true f(output), and its error.
          */

         trueFout  = (2 * fref * p) / (q * fdivise * 100) ;


         if (trueFout > desiredFout)
            ppmError = trueFout - desiredFout;
         else
            ppmError = desiredFout - trueFout;



         if ( ppmError < bestError )
         {
            /***************************************************
             *
             * HO!!! this result is better than the preceding one
             *
             */

            i_find = -1;
            for ( i = 0 ; i < NBRE_I_POSSIBLE ; i++ )
            {

               if ( ( fvco >= limites_i[i] ) && ( fvco <= limites_i[i+1] ) )
                  i_find = i;
            }


            if ( i_find != -1 )
            {
               index = 0;   /* reset result table */

               result.p = (short)p;
               result.q = (short)q;
               result.m = (short)m;
               result.i = i_find;
               result.trueFout = trueFout;
               result.fvco     = fout;       /* keep real value */
               result.ppmError = ppmError;

               index++;                      /* find a good value */

               bestError = ppmError;         /* reset reference erreur */
            }
         }
      }
   }


   if ( index == 0 )
   {
      /* restore valeur de depart */

      /* outb ( MISC_OUTPUT_WRITE , init_misc );   */

      mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), init_misc);

   }
   else
   {

      programme_clock ( (short)reg,  result.p,
                                     result.q,
                                     result.m,
                                     result.i );



      selectIcdOutputReg ( reg );


      /* SAVE PRESENT FREQUENCY in kHz */
      old_frequency = old_fr_reg[reg];   /* RETURN VALUE */
      old_fr_reg[reg] = fout / 1000L;
   }

   dummyCallDelai();

   return (old_frequency);
}




/* ======================================================================= */

/*/
 * NAME: selectIcdOutputReg ( long reg )
 *
 * Select desired output register.
 *
 */

static byte selectIcdOutputReg ( long reg )
{

   /********************************************/
   /*
   /*   PROGRAMME CS : clock output select
   /*
   /********************************************/

   switch ( reg )
   {
      case VIDEO_CLOCK_1:
      case VIDEO_CLOCK_2:
         misc.sel_reg_output.select = (byte)reg;
         mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);
         break;

      case VIDEO_CLOCK_3:
         misc.sel_reg_output.select = 3;
         mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);
         break;


      default:    /*** MEMORY CLOCK ***/
         /*
          * if we modify MCLK, restore VCLK initial value
          */
         mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), init_misc);
         presentMclk[iBoard] = result.fvco;
         break;
   }


   dummyCallDelai();

   return ( misc.var8 );
}





/* ======================================================================= */
/*/
 * NAME: programme_clock ( short p, short q, short m, short reg )
 *
 * Program the clock of the programmable oscillator for the desired
 * frequency.
 *
 */

dword programme_clock ( short reg, short p, short q, short m, short i )
{
   reg_clock [ reg ].var32 = 0;
   reg_clock [ reg ].bit.q_prime     = q - 2;
   reg_clock [ reg ].bit.m_diviseur  = m;
   reg_clock [ reg ].bit.p_prime     = p - 3;
   reg_clock [ reg ].bit.index_field = i;

   programme_reg_icd ( pDevice, reg, reg_clock [ reg ].var32 );

   dummyCallDelai();

   return ( reg_clock [ reg ] .var32 );
}


/* ======================================================================= */
/*/
 * NAME: programme_reg_icd ( volatile BYTE _Far *pDeviceParam, short reg, dword data )
 *
 * This routine permits the serial programming of the programmable oscillator
 * (ICD2061).  It uses the following communication protocol
 *  (from HARDWARE SPECs):
 *
 *
 *      ^  .                          .       .        .        .       .
 *      |  .                          .       .        .        .       .
 *      |  .   _   _   _   _   _     ___     ____     ____     ___     _._
 * CLK  |_____| |_| |_| |_| |_| |___| . |___| .  |___| .  |___| . |___| .
 *      |  .                          .       .        .        .       .
 *      |  .                          .       .        .        .       .
 *      |  . _____________________    .       . ___    .     ___________._
 * DATA |___|                     |____________|   |________|   .       .
 *      +----------------------------------------------------------------->
 *      |  .  unlock sequence         . start . send 0 . send 1 . stop  .
 *      |  .                          .  bit  .        .        . bit   .
 *      |
 *
 *
 *
 * Parameters: [0] - reg: address of internal register of the ICD2061 (3 bits).
 *             [1] - data: data to write in reg (21 bits).
 *
 */


void programme_reg_icd ( volatile BYTE _Far *pDeviceParam, short reg, dword data )
{
   pDevice = pDeviceParam;

   send_unlock ();
   send_start ();
   send_data ( reg, data );
   send_stop  ();
}


/* ======================================================================= */
/*/
 * NAME: send_unlock ( void )
 *
 * Send unlock sequence
 *
 */

static void send_unlock ( void )
{
   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   send_full_clock ();
   send_full_clock ();
   send_full_clock ();
   send_full_clock ();
   send_full_clock ();
}


/* ======================================================================= */
/*/
 * NAME: send_data ( void )
 *
 * Sends 21 bits of data + 3 bits for the register.
 *
 */

static void send_data ( short reg, dword data )
{
   short i;

   for ( i = 0 ; i < 21 ; i++ )
   {
      if ( ( data & 1 ) == 1 )
         send_1 ();
      else
         send_0 ();

      data >>= 1;
   }

   for ( i = 0 ; i < 3 ; i++ )
   {
      if ( ( reg & 1 ) == 1 )
         send_1 ();
      else
         send_0 ();

      reg  >>= 1;
   }
}


/* ======================================================================= */
/*/
 * NAME: send_full_clock ( void )
 *
 * Toggle one full clock (used only by send_unlock()").
 *
 */

static void send_full_clock ( void )
{
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

/*** delay to be sure to respect the programming setup time of the ICD2061 */
   dummyCallDelai();

   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

/*** delay to be sure to respect the programming setup time of the ICD2061 */
   dummyCallDelai();
 }


/* ======================================================================= */
/*/
 * NAME: send_start ( void )
 *
 * Send start sequence
 *
 */

static void send_start ( void )
{
   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   send_full_clock ();

   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();
 }


/* ======================================================================= */
/*/
 * NAME: send_0 ( void )
 *
 * Send data bit 0 (protocol "MANCHESTER").
 *
 */

static void send_0 ( void )
{
   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();
}


/* ======================================================================= */
/*/
 * NAME: send_1 ( void )
 *
 * Send data bit 1 (protocol "MANCHESTER").
 *
 */

static void send_1 ( void )
{
   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();
 }



/* ======================================================================= */
/*/
 * NAME: send_stop ( void )
 *
 * Send stop sequence
 *
 */

static void send_stop ( void )
{
   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 0;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 1;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();

   misc.clock_bit.pgmdata = 0;
   misc.clock_bit.pgmclk  = 1;
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

   dummyCallDelai();
 }


/* ======================================================================= */






/***************************************************************************/

/*/ setTVP3026Freq ( volatile byte _Far *pDeviceParam, long desiredFout, long reg, word pWidth )
 *
 * Calculate best value to obtain a frequency output.
 * This routine program and select the register.
 * If fout is 0, just toggle to the desired
 * output register.
 *
 * Problems :
 * Designed : Patrick Servais:94/04/08
 *
 * Parameters: [0]-desired output frequency (in kHz).
 *                 (0 -> select desired register)
 *             [1]-register (0, 1, 2 ou 3) to prgram and select.
 *                 (the MCLOCK register (3) can be reprogrammable, but
 *                 is always available for output - no selection is permit).
 *
 * Call      :
 *
 * Used      :
 * Modify    : Benoit Leblanc
 *
 * Return    : old frequency value
 *
 * List of modifications :
 *
 */



long setTVP3026Freq ( volatile byte _Far *pDeviceParam, long fout, long reg, byte pWidth )
{
   word i;
   short p, pixel_p, pixel_n, q, n, bestN;
   int   m, pixel_m, bestM, tmp;
   short index;
   short val;
   long  old_frequency, z;
   long fvco, fTemp, trueFout, desiredFout;
   long ppmError;
   long bestError;
   byte init_misc, dac_rev1;
   byte tmpByte, saveByte;
   word pixelWidth;
   dword power;
   dword config200Mhz, fvcoMax;






   switch(pWidth)
      {
      case 0:
         pixelWidth = 8;
         break;
      case 1:
         pixelWidth = 16;
         break;
      case 2:
         pixelWidth = 32;
         break;
      }
   /* Hard to 16*/

   pDevice = pDeviceParam;

   mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), 0x01); /* Silicon revision */
   mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
   if (tmpByte >= 0x10)
      dac_rev1 = 1;
   else
      dac_rev1 = 0;


   /* Read 200Mhz straps saved in config register */
   mgaReadDWORD(*(pDevice+TITAN_OFFSET + TITAN_CONFIG), config200Mhz);
   if (config200Mhz & 0x00000004)
      {
      fvcoMax = (dword)220000000; /* 200Mhz support */
      }
   else
      {
      fvcoMax = (dword)175000000; /* 200Mhz not support */
      }


   mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_R), init_misc);
   misc.var8 = init_misc;

   /***************************************************/
   /*
   /* CALCULATE FREQUENCY
   /*
   /***************************************************/


   bestError = 99999999;    /* dummy start number */

   fref = 14318180;         /* frequence clock ref */

   index = 0;
   bestError = 5000000;

   desiredFout = fout * 1000;    /* Scale it from KHz to Hz */

   if ((dword) desiredFout>= (fvcoMax >> 1))
      p = 0;
   else if ((dword) desiredFout>=(fvcoMax >> 2))
           p = 1;
        else if ((dword) desiredFout>=(fvcoMax >> 3))
                p = 2;
             else
                p = 3;


   power = 1;
   for(i=0; i<p; i++)
      power = power * 2;

   for ( n=1;n<=63;n++ )
      {

      m = (650 - (((((dword)desiredFout*10)/fref) * ((65-n) * power)) / 8)) / 10;

      fTemp = fref / (65-n);
      fvco = fTemp * 8 * (65-m);
      trueFout = fvco / power;

      if (trueFout < desiredFout)
         ppmError = desiredFout - trueFout;
      else
         ppmError = trueFout - desiredFout;

      if ((ppmError < bestError) &&
          (m > 0) && (m <= 63) &&
          (fTemp > 500000) &&
          ((dword)fvco >= (fvcoMax >> 1) ) && (fvco <= (dword)220000000))
         {
         index = 1;

         bestError = ppmError;
         bestM = m;
         bestN = n;
         }
      }


   m = bestM;
   n = bestN;
   fTemp = fref / (65-n);
   fvco = fTemp * 8 * (65-m);

   {
   dword num;

   num = ((65 - m)*10) / (65-n);
   num = num * 8 * fref;

   trueFout = (num / power) / 10;
   }

   if ( index == 0 )    /* no solution find */
   {
      /*  ***ERROR: setFrequence() NONE RESULT (IMPOSSIBLE?!?) */
      /* restore valeur de depart */

      old_frequency = 0L;                    /* ERREUR RETURN */

      mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), init_misc);
   }
   else
   {

       /**********************************************************************
       *
       * SET THE DESIRED FREQUENCY OUTPUT REGISTER
       *
       */
      switch ( reg )
      {

         case VIDEO_CLOCK_3:  /* NOTE 1: header */

            misc.sel_reg_output.select = 3;  /* NOTE 1: header */
            mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), misc.var8);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte & 0xfc);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA );
            if (dac_rev1)
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0xc0) );
            else
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0x80) );
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (m&0x3f) );
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((p&0x03)|0xf0) );

            tmp = 0;
            do
            {
               tmp += 1;
               delay_us(10);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA);
               mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
               tmpByte &= 0x40;
            } while((tmpByte != 0x40) && (tmp < 5000));

            if((tmp == 5000) && (fout < 1100000) && (fvcoMax == 220000000))
               LowerVCO(fout, 0, pWidth, fvcoMax, dac_rev1);


            /* searching for loop clock parameters */

            n = 65 - ((4*64)/pixelWidth);  /* 64 is the Pixel bus Width */
            m = 0x3d;
            z = ((65L-n)*2750L)/(fout/1000);

            q = 0;
            p = 3;
            if (z <= 200)
               p = 0;
            else if (z <= 400)
                     p = 1;
                  else if (z <= 800)
                           p = 2;
                        else if (z <=1600)
                              p = 3;
                           else
                              q = (short)(z/1600);

            if (dac_rev1)
               n |= 0xc0;
            else
               n |= 0x80;

            if ((dac_rev1 == 0) && (fout <= 175000))
               p |= 0xb0;
            else
               p |= 0xf0;

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MCLK_CTL);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
            val = tmpByte;
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((val&0xf8)|q) | 0x20);


            if ((pWidth == TITAN_PWIDTH_PW24) && (dac_rev1))
               {
               if (desiredFout >= 50000000)
                  {n = 0xf9; p = 0xf9; m=0x3e;}
               else
                  {n = 0xf9; p = 0xfb; m=0x3e;}
               }
            else if ((pWidth == TITAN_PWIDTH_PW24) && (dac_rev1 == 0))
               {
               if (desiredFout >= 50000000)
                  {n = 0xb9; p = 0xf9; m=0x3e;}
               else
                  {n = 0xb9; p = 0xfb; m=0x3e;}
               }

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte & 0xcf);

/* DAT Patrick Servais, on ajoute ce qui suis */
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_LOAD_CLK_DATA);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0);
            delay_us(100L);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0);
            delay_us(100L);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0);
            delay_us(100L);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte & 0xcf);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_LOAD_CLK_DATA);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)n);
            delay_us(100L);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)m);
            delay_us(100L);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)p);
            delay_us(100L);

            tmp = 0;
            do
            {
               tmp += 1;
               delay_us(10);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_LOAD_CLK_DATA);
               mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
               tmpByte &= 0x40;
            } while((tmpByte != 0x40) && (tmp < 5000));

            if(tmp == 5000)
               LowerVCO(fout, 1, pWidth, fvcoMax, dac_rev1);

            old_frequency = old_fr_reg[reg];   /* RETURN VALUE */
            old_fr_reg[reg] = trueFout / 1000L;
                  /* SAVE PRESENT FREQUENCY in kHz */
            break;


         /*******************************************************************
          *
          * the programmation line is used to modify register internal value
          * of TVP3026, and to select output video register (with internal
          * muxer) at the end of programmation.  For the system clock
          * MCLOCK programmation, at the end, we put on programmation line
          * the initial value of the video register.
          *
          */
         case MEMORY_CLOCK:
            /* par defaut, (si on a modifie MCLK), on restore VCLK
               * initial
               */
            mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_R), saveByte);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xfc);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), pixel_n);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xfd);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), pixel_m);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xfe);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), pixel_p);

            /*------------*/
            /* 1st step   */
            /*------------*/

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xfc);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA);
            if (dac_rev1)
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0xc0));
            else
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0x80));
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (m&0x3f));
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((p&0x03)|0xb0));

            do
            {
               delay_us(1);
               mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
               tmpByte &= 0x40;
            } while(tmpByte != 0x40);

            /*------------*/
            /* 2d step    */
            /*------------*/

            /* Select programmable clock */
            mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), 0x0f);

            delay_us(2000);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xff);
            do
            {
               delay_us(1);
               mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
               tmpByte &= 0x40;
            } while(tmpByte != 0x40);

            /* Select internal pclk instead of external pclk0 */
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_CLK_SEL);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 5);

            /*------------*/
            /* 3rd step   */
            /*------------*/

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MCLK_CTL);
            mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), val);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (val&0xe7));
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (val&0xe7)|0x08);

            /*------------*/
            /* 4th step   */
            /*------------*/

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xf3);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MEM_CLK_DATA);
            if (dac_rev1)
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0xc0));
            else
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0x80));
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (m&0x3f));
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((p&0x03)|0xb0));

            delay_us(3500);
            do
            {
               delay_us(1);
               mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
               tmpByte &= 0x40;
            } while(tmpByte != 0x40);

            /*------------*/
            /* 5th step   */
            /*------------*/

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MCLK_CTL);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (val&0xe7)|0x10);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (val&0xe7)|0x18);

            /*------------*/
            /* 6th step   */
            /*------------*/

            /* Restore clock select */
            mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), saveByte);

            /* Reselect external pclk0 */
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_CLK_SEL);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 7);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xfc);

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)pixel_n);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)pixel_m);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)pixel_p);

            do
            {
               delay_us(1);
               mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
               tmpByte &= 0x40;
            } while(tmpByte != 0x40);

            old_fr_reg[reg] = trueFout / 1000L;   /* SAVE PRESENT FREQUENCY */

            break;

         default:

                  /***ERROR: REGISTER ICD UNKNOWN: */
            old_frequency = 0L;                    /* ERROR RETURN */
            break;
      }

 }

     /* wait 10ms before quit....this is not suppose
     * to necessary outside of the programmation
     * register, but, well, we are not too secure
     */
   dummyCallDelai();
/*   delay ( 10 ); */

   return ( old_frequency );

}

void LowerVCO(long Fout, byte pll, byte pwidth, dword vcomax, byte dacrev1)
{
   word i;
   short p, q, n, bestN;
   int   m, bestM;
   short val;
   long  z;
   long fvco, fvco_l, fTemp, trueFout, desiredFout;
   long ppmError;
   long bestError;
   byte tmpByte;
   word pixelwidth, div_ratio;
   dword power;
   dword fvcomax;

   switch(pwidth)
      {
      case 0:
         pixelwidth = 8;
         div_ratio  = 8;
         break;
      case 1:
         pixelwidth = 16;
         div_ratio  = 4;
         break;
      case 2:
         pixelwidth = 32;
         div_ratio  = 2;
         break;
      }

   desiredFout = Fout * 1000;    /* Scale it from KHz to Hz */

 switch(pll)
 {
 case 0:

   fvcomax = (dword)175000000;  /* Patch pour eviter la Deadzone */

   bestError = 99999999;    /* dummy start number */

   fref = 14318180;         /* frequence clock ref */

   if ((dword)desiredFout>= (fvcomax >> 1))
      p = 0;
   else if ((dword)desiredFout>=(fvcomax >> 2))
           p = 1;
        else if ((dword)desiredFout>=(fvcomax >> 3))
                p = 2;
             else
                p = 3;

   power = 1;
   for(i=0; i<p; i++)
      power = power * 2;

   for ( n=40;n<=62;n++ )
      {

      m = (650 - (((((dword)desiredFout*10)/fref) * ((65-n) * power)) / 8)) / 10;

      fTemp = fref / (65 - n);
      fvco = fTemp * 8 * (65 - m);
      trueFout = fvco / power;

      if (trueFout < desiredFout)
         ppmError = desiredFout - trueFout;
      else
         ppmError = trueFout - desiredFout;

      if ((ppmError < bestError) &&
          (m > 0) && (m <= 63) &&
          (fTemp > 500000) &&
          ((dword)fvco >= (fvcomax >> 1) ) && (fvco <= (dword)220000000))
         {
         bestError = ppmError;
         bestM = m;
         bestN = n;
         }
      }

   m = bestM;
   n = bestN;

   {
   dword num;

   num = ((65 - m)*10) / (65-n);
   num = num * 8 * fref;

   trueFout = (num / power) / 10;
   }

     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
     mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte & 0xfc);

     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA );
     if (dacrev1)
        mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0xc0) );
     else
        mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((n&0x3f)|0x80) );
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (m&0x3f) );
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((p&0x03)|0xf0) );


     do
     {
        delay_us(10);
        mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PIX_CLK_DATA);
        mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
        tmpByte &= 0x40;
     } while(tmpByte != 0x40);

 break;

 case 1:

     /* searching for loop clock parameters */

     n = 65 - ((4*64)/pixelwidth);  /* 64 is the Pixel bus Width */
     m = 0x3d;
     z = ((65L-(long)n)*2750L)/(Fout/1000);

     q = 0;
     p = 3;
     if (z <= 200)
        p = 0;
     else if (z <= 400)
              p = 1;
           else if (z <= 800)
                    p = 2;
                 else if (z <=1600)
                       p = 3;
                    else
                       q = (short)(z/1600);

/* Patch: si vco du loop clock pll est > 180 MHz, on le divise par deux */
/*        pour ne plus qu'il soit dans la dead zone */

     div_ratio = div_ratio * 10;
     if (pwidth == TITAN_PWIDTH_PW24)
        div_ratio = 80/3;              /* meilleurs precision */

     fvco_l = ((Fout/div_ratio) << p) * (2*(q+1)) * 10;

     if ((p > 0) && (fvco_l > 180000))
        p = p-1;

     if (dacrev1)
        n |= 0xc0;
     else
        n |= 0x80;

     if ((dacrev1 == 0) && (Fout <= 175000))
        p |= 0xb0;
     else
        p |= 0xf0;

     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MCLK_CTL);
     mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
     val = tmpByte;
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), ((val&0xf8)|q) | 0x20);


     if ((pwidth == TITAN_PWIDTH_PW24) && (dacrev1))
        {
        if (desiredFout >= 50000000)
           {n = 0xf9; p = 0xf9; m=0x3e;}
        else
           {n = 0xf9; p = 0xfb; m=0x3e;}
        }
     else if ((pwidth == TITAN_PWIDTH_PW24) && (dacrev1 == 0))
        {
        if (desiredFout >= 50000000)
           {n = 0xb9; p = 0xf9; m=0x3e;}
        else
           {n = 0xb9; p = 0xfb; m=0x3e;}
        }

     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_PLL_ADDR);
     mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), tmpByte & 0xcf);

     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_LOAD_CLK_DATA);
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)n);
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)m);
     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (byte)p);


     break;
 }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\defoldv.h ===
/*/****************************************************************************
*          name: bind.h
*
*   description: This file contains all the definitions related to the
*                old mga.inf file 
*
*      designed: 
* last modified: $Author: ctoutant $, 
*
*       version: $Id: 
*
******************************************************************************/


typedef struct
   {
   dword        MapAddress;             /* board address */
   short        BitOperation8_16;       /* BIT8, BIT16, BITNARROW16 */
   char         DmaEnable;              /* 0 = enable ; 1 = disable */
   char         DmaChannel;             /* channel number. 0 = disabled */
   char         DmaType;                /* 0 = ISA, 1 = B, 2 = C */
   char         DmaXferWidth;           /* 0 = 16, 1 = 32 */
   char         MonitorName[64];        /* as in MONITORM.DAT file */
   short        MonitorSupport[NUMBER_OF_RES];     /* NA, NI, I */
   short        NumVidparm;             /* up to 24 vidparm structures */
   }general_info_101;

/* vidparm VideoParam[]; */


typedef struct
   {
   long         PixClock;
   short        HDisp;
   short        HFPorch;
   short        HSync;
   short        HBPorch;
   short        HOvscan;
   short        VDisp;
   short        VFPorch;
   short        VSync;
   short        VBPorch;
   short        VOvscan;
   short        OvscanEnable;
   short        InterlaceEnable;
   }Vidset_101;


typedef struct
   {
   short        Resolution;             /* RES640, RES800 ... RESPAL */
   short        PixWidth;               /* 8, 16, 32 */
   Vidset_101   VidsetPar[NUMBER_OF_ZOOM]; /* for zoom X1, X2, X4 */
   }Vidparm_101;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mctlwtst.c ===
/*/****************************************************************************
*          name: GetMGAMctlwtst
*
*   description: Return the appropriate mctlwtst value according to the
*                current board configuration.
*
*      designed: Bart Simpson, february 15, 1993
* last modified: $Author: bleblanc $, $Date: 94/05/10 12:00:31 $
*
*       version: $Id: MCTLWTST.C 1.4 94/05/10 12:00:31 bleblanc Exp $
*
*    parameters: DWORD DST0, DWORD DST1
*      modifies: -
*         calls: -
*       returns: DWORD mctlwtst
******************************************************************************/

#include "switches.h"
#include "g3dstd.h"

#include "caddi.h"
#include "def.h"
#include "mga.h"

#include "global.h"
#include "proto.h"

#ifdef WINDOWS_NT
#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,GetMGAMctlwtst)
#endif

#if defined(ALLOC_PRAGMA)
    #pragma data_seg("PAGE")
#endif
#endif  /* #ifdef WINDOWS_NT */

DWORD GetMGAMctlwtst(DWORD DST0, DWORD DST1)
   {
   DWORD Value;

   Value = 0xc4001110;  /*** 80 ns. ***/

   return (Value);
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\g3dstd.h ===
/*/****************************************************************************
*    func. name:    g3dstd.h
*
*   description:    Definition des types standards de G3D_SOFT
*
*      designed:    Bart Simpson        15 avril 1992
* last modified:
*
*       version: $Id: G3DSTD.H 1.3 94/08/22 05:23:19 bleblanc Exp $
*
******************************************************************************/


#define FAIL              0
#define OK              1
#define NO              0
#define YES             1
#define FALSE               0
#define TRUE                1

#ifdef WINDOWS_NT
  typedef SHORT           BOOL;
  typedef UCHAR           BYTE;           /*  8-bit datum */
  typedef CHAR            SBYTE;
  typedef USHORT          WORD;           /* 16-bit datum */
  typedef SHORT           SWORD;          /* 16-bit datum */
  typedef ULONG           DWORD;          /* 32-bit datum */
  typedef LONG            SDWORD;         /* 32-bit datum */

  #define   _Far
  #define   NO_FLOAT            1
#else
  typedef void            VOID;

  typedef int             BOOL;
  typedef unsigned char   BYTE;           /*  8-bit datum */
  typedef char            SBYTE;
  typedef unsigned short  WORD;           /* 16-bit datum */
  typedef short           SWORD;          /* 16-bit datum */
  typedef unsigned long   DWORD;          /* 32-bit datum */
  typedef long            SDWORD;         /* 32-bit datum */
#endif  /* #ifdef WINDOWS_NT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\lut.c ===
/*/****************************************************************************
*          name: SetMGALut
*
*   description: Keep the Current LUT, Update it on request and send it to the
*                RAMDAC.
*
*      designed: Bart Simpson, february 11, 1993
* last modified: $Author: bleblanc $, $Date: 94/06/20 10:53:50 $
*
*       version: $Id: LUT.C 1.14 94/06/20 10:53:50 bleblanc Exp $
*
*    parameters: Far BYTE* pDevice, BYTE* pLUT, BYTE PWidth
*      modifies: -
*         calls: -
*       returns: -
******************************************************************************/

#include "switches.h"
#include "g3dstd.h"

#include "caddi.h"
#include "def.h"
#include "mga.h"

#include "global.h"
#include "proto.h"

#include "mgai.h"

#ifdef WINDOWS_NT
#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,SetMGALUT)
#endif

#if defined(ALLOC_PRAGMA)
    #pragma data_seg("PAGE")
#endif

#include "video.h"

#endif  /* #ifdef WINDOWS_NT */

static BYTE MGALUT[256] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
                            10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                            20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
                            30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
                            40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
                            50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
                            60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
                            70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
                            80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
                            90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
                            100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
                            110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
                            120, 121, 122, 123, 124, 125, 126, 127, 128, 129,
                            130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
                            140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
                            150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
                            160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
                            170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
                            180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
                            190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
                            200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
                            210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
                            220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
                            230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
                            240, 241, 242, 243, 244, 245, 246, 247, 248, 249,
                            250, 251, 252, 253, 254, 255};


VOID SetMGALUT(volatile BYTE _Far *pDevice, BYTE* pLUT, BYTE PWidth, BYTE ModeType)
   {
   DWORD DST0, DST1, Info;
   WORD i;

   if (pLUT != (BYTE*)0)   /*** Update Local LUT ***/
      {
      for (i = 0; i < 256; i++)
         {
         MGALUT[i] = *(pLUT + i);
         }
      }

   /*** Get System Configuration ***/

   GetMGAConfiguration(pDevice, &DST0, &DST1, &Info);

   /*** Send The LUT to the RAMDAC ***/

   switch (Info & (DWORD)Info_Dac_M)
      {
      case (DWORD)Info_Dac_ATT:
         break;

      case (DWORD)Info_Dac_Sierra:
         break;

      case (DWORD)Info_Dac_BT481:
      case (DWORD)Info_Dac_BT482:

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_WADR_PAL), 0x00);

         for (i = 0; i < 256; i++)   /*** This is a 3:3:2 (RGB) LUT ***/
            {
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_COL_PAL), MGALUT[(((i>>5)&7)*0x2492)>>8]);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_COL_PAL), MGALUT[(((i>>2)&7)*0x2492)>>8]);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_COL_PAL), MGALUT[(i&3)*85]);
            }

         break;

      case (DWORD)Info_Dac_BT484:
      case (DWORD)Info_Dac_BT485:
      case (DWORD)Info_Dac_PX2085:
      case (DWORD)Info_Dac_ATT2050:

         switch (PWidth)
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_WADR_PAL), 0x00);

               for (i = 0; i < 256; i++)   /*** This is a 3:3:2 (RGB) LUT ***/
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[(((i>>5)&7)*0x2492)>>8]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[(((i>>2)&7)*0x2492)>>8]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[(i&3)*85]);
                  }

               break;

            case 15:
            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_WADR_PAL), 0x00);

               if(! (ModeType&0x08))   /*** ! M565 ***/
                  {
                  for (i = 0; i < 256; i++)   /*** This is a 5:5:5 (RGB) LUT contigously indexed ***/
                     {
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[((i&0x1f)*0x0842)>>8]);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[((i&0x1f)*0x0842)>>8]);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[((i&0x1f)*0x0842)>>8]);
                     }
                  }
               else
                  {
                  for (i = 0; i < 256; i++)   /*** This is a 5:6:5 (RGB) LUT contigously indexed ***/
                     {
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[((i&0x1f)*0x0842)>>8]);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[((i&0x3f)*0x0410)>>8]);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[((i&0x1f)*0x0842)>>8]);
                     }
                  }

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_WADR_PAL), 0x00);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), 0);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), 0);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), 0);
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_WADR_PAL), 0x00);

               for (i = 0; i < 256; i++)
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[i]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[i]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), MGALUT[i]);
                  }
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_WADR_PAL), 0x00);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), 0);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), 0);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_PAL), 0);
               break;
            }

         break;

      case (DWORD)Info_Dac_Chameleon:      /*** UNKNOWN ***/
         break;

      case (DWORD)Info_Dac_TVP3026:

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_WADR_PAL), 0);


         if( (ModeType&0x10))   /*** DB Front-Back ***/
            {

            for (i = 0; i < 256; i++)   /*** This is a 3:3:2 (RGB) LUT ***/
               {
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[(((i>>5)&7)*0x2492)>>8]);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[(((i>>2)&7)*0x2492)>>8]);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[(i&3)*85]);
               }
            }
         else
            {
            switch (PWidth)
               {
               case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
                  for (i = 0; i < 256; i++)   /*** This is a 3:3:2 (RGB) LUT ***/
                     {
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[(((i>>5)&7)*0x2492)>>8]);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[(((i>>2)&7)*0x2492)>>8]);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[(i&3)*85]);
                     }
                  break;


               case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               case (BYTE)(TITAN_PWIDTH_PW24 >> TITAN_PWIDTH_A):
               case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
                  {
                  int  err, count;
                  BYTE r, g, b;
                  err = 0; count = 0;
                  do
                     {
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_WADR_PAL), 0);
                     for (i = 0; i < 256; i++)
                        {
                        mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[i]);
                        mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[i]);
                        mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), MGALUT[i]);
                        }

                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_RADR_PAL), 0);
                     for (i = 0; i < 256; i++)
                        {
                        mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), r);
                        mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), g);
                        mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_COL_PAL), b);
                        err = err || (r != MGALUT[i]);
                        err = err || (g != MGALUT[i]);
                        err = err || (b != MGALUT[i]);
                        if (err) break;
                        }
                     count++;
                     } while ( err && (count < 5000) );
                  }
                  break;

               }
            }
         break;


      case (DWORD)Info_Dac_ViewPoint:      
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_WADR_PAL), 0x00);


         switch (PWidth)
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):

               for (i = 0; i < 256; i++)   /*** This is a 3:3:2 (RGB) LUT ***/
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[(((i>>5)&7)*0x2492)>>8]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[(((i>>2)&7)*0x2492)>>8]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[(i&3)*85]);
                  }

               break;

            case 15:
            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):

               for (i = 0; i < 256; i++)
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[i]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[i]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[i]);
                  }
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):

               for (i = 0; i < 256; i++)
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[i]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[i]);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_COL_PAL), MGALUT[i]);
                  }
               break;
            }

         break;
      }
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mga.c ===
/**************************************************************************\

$Header: o:\src/RCS/MGA.C 1.10 94/03/02 04:46:47 jyharbec Exp $

$Log:   MGA.C $
 * Revision 1.10  94/03/02  04:46:47  jyharbec
 * Modification for PCI to default to board 0.
 *
 * Revision 1.9  94/02/28  04:04:36  jyharbec
 * Code for 5-6-5 driver;
 * Setting cursor colors for ViewPoint.
 *
 * Revision 1.8  94/01/05  12:03:32  jyharbec
 * New service IOCTL_VIDEO_MTX_QUERY_HW_DATA.
 *
 * Revision 1.7  93/12/20  11:42:36  jyharbec
 * Modified S3 to MGA in debug message text.
 *
 * Revision 1.6  93/11/04  04:50:04  dlee
 * Modified for Alpha.
 *
 * Revision 1.5  93/10/15  11:30:00  jyharbec
 * Added service IOCTL_VIDEO_MTX_QUERY_BOARD_ID.
 *
 * Revision 1.4  93/10/06  05:39:59  jyharbec
 * Modifications required to update MGA.INF file to current version.
 *
 * Revision 1.3  93/09/23  11:42:49  jyharbec
 * Modification to IOCTL_VIDEO_MTX_QUERY_RAMDAC_INFO to include Overscan.
 *
 * Revision 1.2  93/09/01  13:29:07  jyharbec
 * Take into account DISPTYPE_UNUSABLE from HwModeData structures.
 *
 * Revision 1.1  93/08/27  12:37:09  jyharbec
 * Initial revision
 *

\**************************************************************************/

/****************************************************************************\
* MODULE: MGA.C
*
* DESCRIPTION: This module contains the code that implements the MGA miniport
*              driver. [Based on S3.C (Mar 1,1993) from  Windows-NT DDK]
*
* Copyright (c) 1990-1992  Microsoft Corporation
* Copyright (c) 1993  Matrox Electronic Systems Ltd.
*
* History:
*   23AUG93 - Added check for micro-channel adapter in FindAdapter
*
\****************************************************************************/

#include "switches.h"
#include <string.h>
#include "bind.h"
#include "sxci.h"
#include "mga.h"
#include "defbind.h"
#include "mga_nt.h"

//
// New entry points added for NT 5.0.
//

#if (_WIN32_WINNT >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
MgaSetPower50(
    PMGA_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
MgaGetPower50(
    PMGA_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    );

//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
MgaGetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    );
#endif  // _WIN32_WINNT >= 500

// From MTXINIT.C;  it should be in some header file.
#define BOARD_MGA_RESERVED   0x07


VIDEO_MODE_INFORMATION CommonVideoModeInformation =
{
    sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
    0,                          // *Mode index used in setting the mode
    1280,                       // *X Resolution, in pixels
    1024,                       // *Y Resolution, in pixels
    1024,                       // *Screen stride
    1,                          // Number of video memory planes
    8,                          // *Number of bits per plane
    1,                          // Screen Frequency, in Hertz
    330,                        // Horizontal size of screen in millimeters
    240,                        // Vertical size of screen in millimeters
    8,                          // Number Red pixels in DAC
    8,                          // Number Green pixels in DAC
    8,                          // Number Blue pixels in DAC
    0x00000000,                 // *Mask for Red Pixels in non-palette modes
    0x00000000,                 // *Mask for Green Pixels in non-palette modes
    0x00000000,                 // *Mask for Blue Pixels in non-palette modes
    0,                          // *Mode description flags.
    1280,                       // *Video Memory Bitmap Width
    1024                        // *Video Memory Bitmap Height
};

#if NB_BOARD_MAX > 7
    #error Error! Modify MultiModes array!
#endif

UCHAR  MgaBusType[]   = { 0, 0, 0, 0, 0, 0, 0, 0 };

// Nb of modes supported by  1, 2, 3, 4, 5, 6, 7 boards.
USHORT MultiModes[]   = { 0, 1, 2, 2, 3, 2, 4, 2 };

USHORT SingleWidths[] = { 640, 768, 800, 1024, 1152, 1280, 1600, 0xffff};
USHORT SingleHeights[]= { 480, 576, 600,  768,  882, 1024, 1200, 0xffff};

// MGA communication access ranges.
VIDEO_ACCESS_RANGE MgaDriverCommonAccessRange[] =
{
//   {0x00000400, 0x00000000, 0x000000AB, 0, 0, 1}, // BIOS Communication Area
     {0x000003B4, 0x00000000, 0x00000002, 1, 0, 1}, // 0 Titan VGA & CRTC
     {0x000003BA, 0x00000000, 0x00000001, 1, 0, 1}, // 1
     {0x000003C0, 0x00000000, 0x00000010, 1, 0, 1}, // 2
     {0x000003D4, 0x00000000, 0x00000008, 1, 0, 1}, // 3
     {0x000003DE, 0x00000000, 0x00000002, 1, 0, 1}, // 4
  #if USE_SETUP_VGA
     {0x000046E8, 0x00000000, 0x00000002, 1, 0, 1}, // 5
     {0x00000410, 0x00000000, 0x00000001, 0, 0, 1}, // 6
     {0x00000449, 0x00000000, 0x0000001e, 0, 0, 1}, // 7
     {0x00000484, 0x00000000, 0x00000007, 0, 0, 1}, // 8
     {0x000004A8, 0x00000000, 0x00000004, 0, 0, 1}, // 9
     {0x000A0000, 0x00000000, 0x00010000, 0, 0, 1}  // 10
     //{0x000B8000, 0x00000000, 0x00008000, 0, 0, 1}  // 11
  #else
     {0x000046E8, 0x00000000, 0x00000002, 1, 0, 1}  // 5
  #endif
};

// MGA windows access ranges.
VIDEO_ACCESS_RANGE MgaDriverAccessRange[] =
{
     {0x000C8000, 0x00000000, 0x00004000, 0, 0, 0}, // Command window 0
     {0x0000C000, 0x00000000, 0x00000100, 1, 0, 0}, // Config space 0
     {0x00000000, 0x00000000, 0x00004000, 0, 0, 0}, // Command window 1
     {0x0000C000, 0x00000000, 0x00000100, 1, 0, 0}, // Config space 1
     {0x00000000, 0x00000000, 0x00004000, 0, 0, 0}, // Command window 2
     {0x0000C000, 0x00000000, 0x00000100, 1, 0, 0}, // Config space 2
     {0x00000000, 0x00000000, 0x00004000, 0, 0, 0}, // Command window 3
     {0x0000C000, 0x00000000, 0x00000100, 1, 0, 0}, // Config space 3
     {0x00000000, 0x00000000, 0x00004000, 0, 0, 0}, // Command window 4
     {0x0000C000, 0x00000000, 0x00000100, 1, 0, 0}, // Config space 4
     {0x00000000, 0x00000000, 0x00004000, 0, 0, 0}, // Command window 5
     {0x0000C000, 0x00000000, 0x00000100, 1, 0, 0}, // Config space 5
     {0x00000000, 0x00000000, 0x00004000, 0, 0, 0}, // Command window 6
     {0x0000C000, 0x00000000, 0x00000100, 1, 0, 0}  // Config space 6
};

#if (!USE_VP_GET_ACCESS_RANGES)
VIDEO_ACCESS_RANGE MgaDriverSupplAccessRange[] =
{
     {0x00000CF8, 0x00000000, 0x00000008, 1, 0, 1}
   //{0x000E0000, 0x00000000, 0x00020000, 1, 0, 1}
};
#endif

#define NUM_MGA_COMMON_ACCESS_RANGES \
            (sizeof(MgaDriverCommonAccessRange) / sizeof(VIDEO_ACCESS_RANGE))
#define NUM_MGA_ACCESS_RANGES        \
            (sizeof(MgaDriverAccessRange) / sizeof(VIDEO_ACCESS_RANGE))

#if (!USE_VP_GET_ACCESS_RANGES)
#define NUM_MGA_SUPPL_ACCESS_RANGES  \
            (sizeof(MgaDriverSupplAccessRange) / sizeof(VIDEO_ACCESS_RANGE))
#else
#define NUM_MGA_SUPPL_ACCESS_RANGES  0
#endif

#define NUM_ALL_ACCESS_RANGES        \
                            (NUM_MGA_COMMON_ACCESS_RANGES + NUM_MGA_ACCESS_RANGES + NUM_MGA_SUPPL_ACCESS_RANGES)

INTERFACE_TYPE  NtInterfaceType;

HwData  *pMgaBoardData;

ULONG   ulNewInfoSize;
PUCHAR  pucNewInfo;
PUCHAR  pMgaBiosVl;

extern PVOID    pMgaDeviceExtension;
extern word     mtxVideoMode;
extern byte     NbBoard;
extern dword    MgaSel;

extern PVOID    pMgaBaseAddr;
extern HwData   Hw[NB_BOARD_MAX+1];
extern byte     iBoard;
extern char    *mgainf;
extern char     DefaultVidset[];
extern dword    ProductMGA[NB_BOARD_MAX];

// Board number conversion macro.
// In the user-mode drivers, boards are numbered sequentially starting from 0
// at the upper left corner and going from left to right and then top to
// bottom.  In the miniport driver, we might want to start from the lower
// left corner.

#if 1
    // Same numbering convention as the user-mode driver.
    #define CONVERT_BOARD_NUMBER(n) n = n
#else
    // Starting from lower left instead of upper left corner.
    #define CONVERT_BOARD_NUMBER(n) n = ((pCurMulti->MulArrayHeight - 1) *  \
                                            pCurMulti->MulArrayWidth) - n + \
                                            2*(n % pCurMulti->MulArrayWidth)
#endif


// Function Prototypes
//
// Functions that start with 'Mga' are entry points for the OS port driver.

#ifdef MGA_WINNT35
BOOLEAN
MgaResetHw(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );
#endif

VP_STATUS
MgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    );

BOOLEAN
MgaInitialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
MgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

VP_STATUS
MgaInitModeList(
    PMGA_DEVICE_EXTENSION MgaDeviceExtension);

VP_STATUS
MgaSetColorLookup(
    PMGA_DEVICE_EXTENSION MgaDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    );

VOID MgaSetCursorColour(
    PMGA_DEVICE_EXTENSION MgaDeviceExtension,
    ULONG ulFgColour,
    ULONG ulBgColour);

// For WinNT 3.5
// Code NOT to be made pageable:
//       SetVgaEn();
//   setVgaMode();
//   restoreVga();
//   checkCursorEn();
//   mtxCheckVgaEn();
//       mtxMapVLBSpace();
//   mtxUnMapVLBSpace();
//   mtxIsVLB();
//   isPciBus();
//   wideToIsa();
//   blankEcran();
//   delay_us();
//   _inp(); (macro)
//   _outp(); (macro)

//   rdDubicDReg();
//   rdDubicIReg();
//   rdDacReg();
//   rdTitanReg();
//   mgaReadDWORD(); (macro)
//   mgaReadBYTE(); (macro)

//   wrDubicDReg();
//   wrDubicIReg();
//   wrDacReg();
//   wrTitanReg();
//   mgaWriteBYTE(); (macro)
//   mgaWriteDWORD(); (macro)

// Data NOT to be made pageable:
//  Hw (in mtxinit.c)
//  pMgaBaseAddr (in mtxinit.c)
//  iBoard (in mtxinit.c)
//      mtxVideoMode (in mtxinit.c)
//  pMgaDeviceExtension (in mtxinit.c)
//  isVLBFlag (in mtxvideo.c)
//  cursorStat (in mtxvideo.c)
//  saveBitOperation (in mtxvideo.c)

#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,DriverEntry)
    #pragma alloc_text(PAGE,MgaFindAdapter)
    #pragma alloc_text(PAGE,MgaInitialize)
    #pragma alloc_text(PAGE,MgaStartIO)
    #pragma alloc_text(PAGE,MgaInitModeList)
    //#pragma alloc_text(PAGE,MgaSetColorLookup)
    #pragma alloc_text(PAGE,MgaSetCursorColour)

#if (_WIN32_WINNT >= 500)
#pragma alloc_text(PAGE_COM, MgaSetPower50)
#pragma alloc_text(PAGE_COM, MgaGetPower50)
#pragma alloc_text(PAGE_COM, MgaGetVideoChildDescriptor)

#endif  // _WIN32_WINNT >= 500
#endif

//#if defined(ALLOC_PRAGMA)
//    #pragma data_seg("PAGE")
//#endif

// External function prototypes
  extern volatile byte _Far *setmgasel(dword MgaSel, dword phyadr, dword limit);

bool    MapBoard(void);
char    *adjustDefaultVidset();
PVOID   AllocateSystemMemory(ULONG NumberOfBytes);
char    *mtxConvertMgaInf( char * );
void    SetVgaEn();
char    *selectMgaInfoBoard();

#if USE_SETUP_VGA
void    setupVga(void);
void    restoreVga();
#endif

/****************************************************************************\
* ULONG
* DriverEntry (
*     PVOID Context1,
*       PVOID Context2)
*
* DESCRIPTION:
*   Installable driver initialization entry point.
*   This entry point is called directly by the I/O system.
*
* ARGUMENTS:
*   Context1 - First context value passed by the operating system. This is
*       the value with which the miniport driver calls VideoPortInitialize().
*
*   Context2 - Second context value passed by the operating system. This is
*       the value with which the miniport driver calls VideoPortInitialize().
*
* RETURNS:
*   Status from VideoPortInitialize()
*
\****************************************************************************/
ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )
{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    ULONG   isaStatus, eisaStatus, microChannelStatus, pciStatus, minStatus;
    ULONG   i, j;
    HwData  TempHw;

    VideoDebugPrint((1, "MGA.SYS!DriverEntry\n"));
    //DbgBreakPoint();

    // Zero out structure.
    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA)) ;

    // Specify sizes of structure and extension.
    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    // Set entry points.
    hwInitData.HwFindAdapter =  MgaFindAdapter;
    hwInitData.HwInitialize =   MgaInitialize;
    //hwInitData.HwInterrupt =    NULL;
    hwInitData.HwStartIO =      MgaStartIO;

#ifdef MGA_WINNT35
    hwInitData.HwResetHw =      MgaResetHw;
    //hwInitData.HwTimer =        NULL;
#endif

#if (_WIN32_WINNT >= 500)

    //
    // Set new entry points added for NT 5.0.
    //

    hwInitData.HwSetPowerState = MgaSetPower50;
    hwInitData.HwGetPowerState = MgaGetPower50;
    hwInitData.HwGetVideoChildDescriptor = MgaGetVideoChildDescriptor;

#endif // _WIN32_WINNT >= 500

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(MGA_DEVICE_EXTENSION);

    // Always start with parameters for device0 in this case.
    //hwInitData.StartingDeviceNumber = 0;

    // This device only supports the internal bus type. So return the status
    // value directly to the operating system.

    // I think that each VPInitialize call will itself call MgaFindAdapter,
    // provided that the specified AdapterInterfaceType makes sense for the
    // hardware.  MgaFindAdapter will call MapBoard.  We can't be sure that
    // the last call to MapBoard will find all the boards, so we'll have to
    // accumulate the boards found, making sure that we don't record the
    // same board twice.

//#if (defined(MGA_WINNT35) && defined(MGA_ALPHA))
    NbBoard = 0;
//#endif

    hwInitData.AdapterInterfaceType = PCIBus;
    pciStatus = VideoPortInitialize(Context1,
                                    Context2,
                                    &hwInitData,
                                    NULL);

    hwInitData.AdapterInterfaceType = Isa;
    isaStatus = VideoPortInitialize(Context1,
                                    Context2,
                                    &hwInitData,
                                    NULL);

    hwInitData.AdapterInterfaceType = Eisa;
    eisaStatus = VideoPortInitialize(Context1,
                                     Context2,
                                     &hwInitData,
                                     NULL);

    hwInitData.AdapterInterfaceType = MicroChannel;
    microChannelStatus = VideoPortInitialize(Context1,
                                     Context2,
                                     &hwInitData,
                                     NULL);

    // We should have found all our boards at this point.  We want to
    // reorder the Hw array so that the PCI boards are the first ones.
    // The MgaBusType array was initialized to MGA_BUS_INVALID.

    for (i = 0; i < NbBoard; i++)
    {
        // The only possibilities are MGA_BUS_PCI and MGA_BUS_ISA.
        if (MgaBusType[i] == MGA_BUS_ISA)
        {
            // We found an ISA board.  Look for a PCI board.
            for (j = i+1; j < NbBoard; j++)
            {
                if (MgaBusType[j] == MGA_BUS_PCI)
                {
                    // We found a PCI board, exchange them.
                    TempHw = Hw[j];
                    Hw[j] = Hw[i];
                    Hw[i] = TempHw;
                    MgaBusType[i] = MGA_BUS_PCI;
                    MgaBusType[j] = MGA_BUS_ISA;
                    MgaDriverAccessRange[i*2].RangeStart.LowPart = Hw[i].MapAddress;
                    MgaDriverAccessRange[i*2+1].RangeStart.LowPart = Hw[i].ConfigSpace;
                    MgaDriverAccessRange[j*2].RangeStart.LowPart = Hw[j].MapAddress;
                    MgaDriverAccessRange[j*2+1].RangeStart.LowPart = Hw[j].ConfigSpace;
                    break;
                }
            }
        }
    }

    // Return the smallest of isaStatus, eisaStatus, pciStatus, and
    // microChannelStatus.
    minStatus = (isaStatus < eisaStatus) ? isaStatus : eisaStatus;
    if (microChannelStatus < minStatus)
        minStatus = microChannelStatus;
    if (pciStatus < minStatus)
        minStatus = pciStatus;
    return(minStatus);

}   // end DriverEntry()


#ifdef MGA_WINNT35

/****************************************************************************\
* VOID
* MgaResetHw(VOID)
*
* DESCRIPTION:
*
*     This function is called when the machine needs to bugchecks (go back
*     to the blue screen).
*
*     This function should reset the video adapter to a character mode,
*     or at least to a state from which an int 10 can reset the card to
*     a character mode.
*
*     This routine CAN NOT call int10.
*     It can only call Read\Write Port\Register functions from the port driver.
*
*     The function must also be completely in non-paged pool since the IO\MM
*     subsystems may have crashed.
*
* ARGUMENTS:
*
*     HwDeviceExtension - Supplies the miniport driver's adapter storage.
*
*     Columns - Number of columns in the requested mode.
*
*     Rows - Number of rows in the requested mode.
*
* RETURN VALUE:
*
*     The return value determines if the mode was completely programmed (TRUE)
*     or if an int10 should be done by the HAL to complete the modeset (FALSE).
*
\****************************************************************************/

BOOLEAN MgaResetHw(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )
{
    PMGA_DEVICE_EXTENSION   MgaDeviceExtension;

    VideoDebugPrint((1, "MGA.SYS!MgaResetHw\n"));

    // There is nothing to be done to reset the board if the one that
    // went into hi-res was not VGA-enabled to start with.  However it
    // will look nicer if we clear the screen.  If the board was VGA-
    // enabled, we put it back into text mode, or as near as we can get.

    pMgaDeviceExtension =
    MgaDeviceExtension = (PMGA_DEVICE_EXTENSION)HwDeviceExtension;

    pMgaBaseAddr = MgaDeviceExtension->KernelModeMappedBaseAddress[0];

    // Make the cursor disappear.
    mtxCursorEnable(0);

    if (Hw[0].VGAEnable)
    {
        SetVgaEn();

#if USE_SETUP_VGA
        setupVga();
        restoreVga();
#endif

        mtxVideoMode = mtxPASSTHRU;
    }

    // Let the caller execute the Int10.
    return(FALSE);
}
#endif


/****************************************************************************\
* FIND_ADAPTER_STATUS
* MgaFindAdapter(
*     PVOID HwDeviceExtension,
*     PVOID HwContext,
*     PWSTR ArgumentString,
*     PVIDEO_PORT_CONFIG_INFO ConfigInfo,
*     PUCHAR Again
*     )
*
* DESCRIPTION:
*
*     This routine is called to determine if the adapter for this driver
*     is present in the system.
*     If it is present, the function fills out some information describing
*     the adapter.
*
* ARGUMENTS:
*
*     HwDeviceExtension - Supplies the miniport driver's adapter storage. This
*         storage is initialized to zero before this call.
*
*     HwContext - Supplies the context value which was passed to
*         VideoPortInitialize(). Must be NULL for PnP drivers.
*
*     ArgumentString - Suuplies a NULL terminated ASCII string. This string
*         originates from the user.
*
*     ConfigInfo - Returns the configuration information structure which is
*         filled by the miniport driver. This structure is initialized with
*         any knwon configuration information (such as SystemIoBusNumber) by
*         the port driver. Where possible, drivers should have one set of
*         defaults which do not require any supplied configuration information.
*
*     Again - Indicates if the miniport driver wants the port driver to call
*         its VIDEO_HW_FIND_ADAPTER function again with a new device extension
*         and the same config info. This is used by the miniport drivers which
*         can search for several adapters on a bus.
*
* RETURN VALUE:
*
*     This routine must return:
*
*     VP_RETURN_FOUND - Indicates a host adapter was found and the
*         configuration information was successfully determined.
*
*     VP_RETURN_ERROR - Indicates a host adapter was found but there was an
*         error obtaining the configuration information. If possible an error
*         should be logged.
*
*     VP_RETURN_BAD_CONFIG - Indicates the supplied configuration was invalid.
*
*     VP_RETURN_NOT_FOUND - Indicates no host adapter was found for the
*         supplied configuration information.
*
\****************************************************************************/
VP_STATUS
MgaFindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

{
    PMGA_DEVICE_EXTENSION MgaDeviceExtension;
    VIDEO_ACCESS_RANGE AllAccessRanges[NUM_ALL_ACCESS_RANGES+1];
    VP_STATUS   status;
    ULONG       i, j, SetBiosVl;
    //ULONG       PreNbBoards;

    VideoDebugPrint((1, "MGA.SYS!MgaFindAdapter\n"));

    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).

    if (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO))
    {
        return ERROR_INVALID_PARAMETER;
    }

    pMgaDeviceExtension =
    MgaDeviceExtension  = HwDeviceExtension;

    // Set some global variable saying which bus we'll be exploring.
    NtInterfaceType = ConfigInfo->AdapterInterfaceType;

    // Get access ranges for our I/O.
    // Check to see if there is a hardware resource conflict.
    // Register all we'll need for now, unless we already did it.
    for (i = 0; i < NUM_MGA_COMMON_ACCESS_RANGES; i++)
    {
        AllAccessRanges[i] = MgaDriverCommonAccessRange[i];
    }

#if (!USE_VP_GET_ACCESS_RANGES)

    for (i = 0; i < NUM_MGA_SUPPL_ACCESS_RANGES; i++)
    {
        AllAccessRanges[i + NUM_MGA_COMMON_ACCESS_RANGES] =
                                                MgaDriverSupplAccessRange[i];
    }
#endif

    status = VideoPortVerifyAccessRanges(MgaDeviceExtension,
                                     (ULONG)(NUM_MGA_COMMON_ACCESS_RANGES +
                                             NUM_MGA_SUPPL_ACCESS_RANGES),
                                     AllAccessRanges);
    if (status != NO_ERROR)
    {
        VideoDebugPrint((1, "MGA.SYS!MgaFindAdapter: Access Range conflict\n"));
        return status;
    }

    for (i=0; i < NUM_MGA_COMMON_ACCESS_RANGES; i++)
    {
        if ((MgaDeviceExtension->MappedAddress[i] =
                VideoPortGetDeviceBase(
                    MgaDeviceExtension,
                    MgaDriverCommonAccessRange[i].RangeStart,
                    MgaDriverCommonAccessRange[i].RangeLength,
                    MgaDriverCommonAccessRange[i].RangeInIoSpace)) == NULL)
        {
            VideoDebugPrint((1, "MGA.SYS!MgaFindAdapter failed to map port addresses\n"));
            return(ERROR_INVALID_PARAMETER);
        }
    }

    // Search for MGA boards installed in the system.
    // On x86, the first call to MapBoard should have found all the boards.
    if (NbBoard != 0)
    {
        return(ERROR_DEV_NOT_EXIST);
    }

    if (!MapBoard())
    {
        VideoDebugPrint((1, "MGA.SYS!MgaFindAdapter failed MapBoard\n"));
        return(ERROR_DEV_NOT_EXIST);
    }

    //PreNbBoards = (ULONG)NbBoard;
    ////if (!MapBoard())
    //if (!MapBoard() || (PreNbBoards == (ULONG)NbBoard))
    //{
    //    VideoDebugPrint((1, "MGA.SYS!MgaFindAdapter failed MapBoard\n"));
    //    return(ERROR_DEV_NOT_EXIST);
    //}

    SetBiosVl = 0;
    // Fill out RangeStart portion of VIDEO_ACCESS_RANGE structure
    // with the mapping of the MGA boards found.
    for (i = 0; i < (ULONG)NbBoard; i++)
    {
        MgaDriverAccessRange[i*2].RangeStart.LowPart = Hw[i].MapAddress;
        if (Hw[i].MapAddress == 0xAC000)
        {
            // Make sure that this is shareable.
            MgaDriverAccessRange[i*2].RangeShareable = 1;

            // We'll also need access to 4 pages for BIOS_VL.
            SetBiosVl = 1;
        }

        MgaDriverAccessRange[i*2+1].RangeStart.LowPart = Hw[i].ConfigSpace;
        if (Hw[i].ConfigSpace == 0)
        {
            // This board doesn't require access to config space.
            MgaDriverAccessRange[i*2+1].RangeLength = 0;
            MgaDriverAccessRange[i*2+1].RangeInIoSpace = 0;
        }

        // Also make sure that the pHwMode field is set to 0.
        Hw[i].pHwMode = NULL;
    }

    // Register all we'll need.
    j = NUM_MGA_SUPPL_ACCESS_RANGES + NUM_MGA_COMMON_ACCESS_RANGES;
    for (i = 0; i < (ULONG)NbBoard*2; i++)
    {
        if (MgaDriverAccessRange[i].RangeStart.LowPart != 0)
        {
            AllAccessRanges[j] = MgaDriverAccessRange[i];
            j++;
        }
    }

    if (SetBiosVl == 1)
    {
        // Add one more range.
        AllAccessRanges[j] = MgaDriverAccessRange[0];
        AllAccessRanges[j].RangeStart.LowPart = 0xc0000;
        AllAccessRanges[j].RangeShareable = 1;
        j++;
        pMgaBiosVl = (PUCHAR)setmgasel(MgaSel, 0xc0000, 4);
    }

    //status = VideoPortVerifyAccessRanges(MgaDeviceExtension,
    //                                     (ULONG) (NbBoard +
    //                                            NUM_MGA_SUPPL_ACCESS_RANGES +
    //                                            NUM_MGA_COMMON_ACCESS_RANGES),
    //                                     AllAccessRanges);
    //if (status != NO_ERROR)
    //{
    //    VideoDebugPrint((1, "MGA.SYS!MgaFindAdapter: Access Range conflict\n"));
    //    return status;
    //}
    VideoPortVerifyAccessRanges(MgaDeviceExtension,
                                j,
                                AllAccessRanges);

    // Special limitation:
    // The user-mode driver used by Microsoft doesn't allow for multiple
    // boards, so we'll make certain that only one board is considered here:
    NbBoard = 1;

    // Intel and Alpha both support VideoPortInt10.
    MgaDeviceExtension->bUsingInt10 = TRUE;

    // Clear out the Emulator entries and the state size since this driver
    // is not VGA compatible and does not support them.
    ConfigInfo->NumEmulatorAccessEntries = 0;
    ConfigInfo->EmulatorAccessEntries = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    // BUGBUG: Andrea, why do I have to do this. Faking out a VGA.

    if (!(MgaDeviceExtension->bUsingInt10))
    {
        ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x00000000;
        ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
        ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00000000;
    }
    else
    {
        // !!! This should be removed or looked into some more.
        // These values are set to the same values as a VGA to try and
        // work around some memory mapping issues in the port driver.
        ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
        ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
        ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;
    }

    ConfigInfo->HardwareStateSize = 0;

    // Let's try to build a list of modes right here.  We'll use the
    // default vidset for now, but we may change our mind later and
    // build a different list.
    iBoard = 0;
    mgainf = adjustDefaultVidset();

    // Call the service.
    MgaInitModeList(MgaDeviceExtension);

    // If an error occurred, pMgaDeviceExtension->NumberOfSuperModes will
    // be zero;  otherwise, it will be the appropriate number of modes.

    // Indicate we do not wish to be called over
    *Again = 0;

    // Indicate a successful completion status.
    return NO_ERROR;

}   // end MgaFindAdapter()


/****************************************************************************\
* BOOLEAN
* MgaInitialize(
*     PVOID HwDeviceExtension
*     )
*
*
* DESCRIPTION:
*
*     This routine does one time initialization of the device.
*
* ARGUMENTS:
*
*     HwDeviceExtension - Supplies a pointer to the miniport's device extension.
*
* RETURN VALUE:
*
*     Always returns TRUE since this routine can never fail.
*
\****************************************************************************/
BOOLEAN
MgaInitialize(
    PVOID HwDeviceExtension
    )

{
    UNREFERENCED_PARAMETER(HwDeviceExtension);

    VideoDebugPrint((1, "MGA.SYS!MgaInitialize\n"));

    // We would like to do some work here, but we have to wait until we get
    // the contents of the MGA.INF file.  Since MGA.INF has to be opened by
    // the user-mode driver, this work will be done by a special
    // INITIALIZE_MGA service of MgaStartIO.

    // Some day, we might want to write an application that will update the
    // registry instead of a file.  We would then be able to do our work here.

    return (TRUE);

}   // end MgaInitialize()


/****************************************************************************\
* BOOLEAN
* MgaStartIO(
*     PVOID HwDeviceExtension,
*     PVIDEO_REQUEST_PACKET RequestPacket
*     )
*
* Routine Description:
*
*     This routine is the main execution routine for the miniport driver. It
*     acceptss a Video Request Packet, performs the request, and then returns
*     with the appropriate status.
*
* Arguments:
*
*     HwDeviceExtension - Supplies a pointer to the miniport's device
*         extension.
*
*     RequestPacket - Pointer to the video request packet. This structure
*         contains all the parameters passed to the VideoIoControl function.
*
* Return Value:
*
\****************************************************************************/
BOOLEAN
MgaStartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

{
    PMGA_DEVICE_EXTENSION       MgaDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION     modeInformation;
    PVIDEO_MEMORY_INFORMATION   memoryInformation;
    PVIDEO_CLUT                 pclutBuffer;
    PVIDEO_PUBLIC_ACCESS_RANGES publicAccessRanges;
    PRAMDAC_INFO                pVideoPointerAttributes;

    HwModeData  *pMgaDispMode;
    OffScrData  *pMgaOffScreenData;
    MULTI_MODE  *pCurMulti;
    PWSTR       pwszChip, pwszDAC, pwszAdapterString;
    PUCHAR      pucInBuffer, pucOutBuffer;
    PVOID       pCurBaseAddr;

    VIDEO_CLUT  clutBufferOne;
    VP_STATUS   status;

    ULONG       ZoomFactor;
    ULONG       i, n;
    ULONG       ulWindowLength, ulSizeOfBuffer;
    ULONG       CurrentResNbBoards, ModeInit;
    ULONG       cbChip, cbDAC, cbAdapterString, AdapterMemorySize;

    USHORT      j;
    USHORT      MaxWidth, MaxHeight, usTemp;
    UCHAR       iCurBoard;
    UCHAR       ucTemp;

    //DbgBreakPoint();

    VideoDebugPrint((1, "MGA.SYS!MgaStartIO\n"));

    pMgaDeviceExtension = MgaDeviceExtension;

    // Switch on the IoContolCode in the RequestPacket.  It indicates which
    // function must be performed by the driver.

    switch (RequestPacket->IoControlCode)
    {
        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_INITIALIZE_MGA
        |
        |   This will normally be the first call made to MgaStartIO.  We do
        |   here what we should have done in MgaInitialize, but couldn't.
        |   We first determine if we'll be using the default vidset or the
        |   contents of some MGA.INF file.  If the file is an older version,
        |   we will send back a non-zero FileInfoSize, so that the user-mode
        |   driver can call us with MTX_GET_UPDATED_INF to get an updated
        |   version.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_INITIALIZE_MGA:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_INITIALIZE_MGA\n"));
        //DbgBreakPoint();

    #if 1
        status = NO_ERROR;
        pucInBuffer = (PUCHAR)(RequestPacket->InputBuffer);
        ulSizeOfBuffer = RequestPacket->InputBufferLength;
        ulNewInfoSize = 0;
        iBoard = 0;
        mgainf = adjustDefaultVidset();
        pucNewInfo = mgainf;
        *(PULONG)(RequestPacket->OutputBuffer) = ulNewInfoSize;
        RequestPacket->StatusBlock->Information = sizeof(ULONG);
        break;

    #else
        status = NO_ERROR;
        pucInBuffer = (PUCHAR)(RequestPacket->InputBuffer);
        ulSizeOfBuffer = RequestPacket->InputBufferLength;

        // We may have to update the current MGA.INF file later.
        // For now, assume that we won't.  If the call to mtxConvertMgaInf
        // is required and successful, this will be changed.
        ulNewInfoSize = 0;

        iBoard = 0;

        // Check to see if we are to use the default vidset.
        if ((pucInBuffer == NULL) ||
            (ulSizeOfBuffer == 0))
        {
            // The user-mode driver tells us to use the default.
            mgainf = adjustDefaultVidset();
        }
        else
        {
            // The user-mode driver sends us the actual file contents.
            if ( ((header *)pucInBuffer)->Revision != (short)VERSION_NUMBER)
            {
                // The file is an older version, convert it to current format.
                // The returned value can be DefaultVidset, NULL, or a pointer
                // to a character buffer allocated by the conversion routine.

                if ( !(mgainf = mtxConvertMgaInf(pucInBuffer)) ||
                      (mgainf == DefaultVidset) )
                {
                    // The returned value was NULL or DefaultVidset.
                    mgainf = adjustDefaultVidset();
                }
            }
            else
            {
                // The file is in the current format.
                // Allocate memory for the input buffer.

                mgainf = (PUCHAR)AllocateSystemMemory(ulSizeOfBuffer);
                if (mgainf == NULL)
                {
                    // The memory allocation failed, use the default set.
                    mgainf = adjustDefaultVidset();
                }
                else
                {
                    // The memory allocation was successful, copy the buffer.
                    VideoPortMoveMemory(mgainf, pucInBuffer, ulSizeOfBuffer);
                }
            }

            // At this point, mgainf points to DefaultVidset or to the
            // MGA.INF information, in the current version format.
            if (mgainf != DefaultVidset)
            {
                // We are not looking at the default vidset.
                if ((selectMgaInfoBoard() == NULL) ||
                    (strncmp(mgainf, "Matrox MGA Setup file", 21) != 0))
                {
                    // The MGA.INF file is incomplete or corrupted.
                    VideoDebugPrint((1, "MGA.SYS!MgaStartIO - Incomplete MGA.INF file, using default\n"));

                    // Either memory was allocated for the input buffer, or
                    // memory was allocated by mtxConvertMgaInf.  Free it.
                    VideoPortReleaseBuffer(pMgaDeviceExtension, mgainf);

                    // Make sure that we won't try to update MGA.INF.
                    ulNewInfoSize = 0;

                    // And use the default set.
                    mgainf = adjustDefaultVidset();
                }
            }
        }

        // At this point, mgainf points to DefaultVidset or to the
        // validated MGA.INF information, in the current version format.

        // Record the mgainf value, in case we need it later.
        pucNewInfo = mgainf;

        // Set the length of the file to be updated.
        *(PULONG)(RequestPacket->OutputBuffer) = ulNewInfoSize;

        // And don't forget to set this to the appropriate length!
        RequestPacket->StatusBlock->Information = sizeof(ULONG);

        break;      // end MTX_INITIALIZE_MGA
    #endif          // #if 0


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_INIT_MODE_LIST
        |
        |   This will normally be the second or third call made to MgaStartIO.
        |   We call mtxCheckHwAll() and we fill in our MgaDeviceExtension
        |   structure with mode information for each board we found.  From
        |   this, we build a series of MULTI_MODE structures describing each
        |   'super-mode', starting at MgaDeviceExtension->pSuperModes, and
        |   we set the total number of supported modes in
        |   MgaDeviceExtension->NumberOfSuperModes.
        |
        |   The miniport driver builds a default list of modes (using the
        |   default vidset) at HwFindAdapter time.  The default list will
        |   be discarded when the user-mode driver calls INIT_MODE_LIST
        |   explicitly.  When the BASEVIDEO driver calls QUERY_NUM_AVAIL_MODES
        |   without first calling INIT_MODE_LIST, the default list will be
        |   used.
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_INIT_MODE_LIST:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_INIT_MODE_LIST\n"));
        //DbgBreakPoint();

        status = MgaInitModeList(MgaDeviceExtension);
        break;      // end MTX_INIT_MODE_LIST


        /*------------------------------------------------------------------*\
        | Special service:  MTX_GET_UPDATED_INF
        |
        |   This service will be called if a non-zero file size was returned
        |   by MTX_INITIALIZE_MGA.  It will return the updated MGA.INF
        |   contents to the user-mode driver.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_GET_UPDATED_INF:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_GET_UPDATED_INF\n"));
        //DbgBreakPoint();

        if (ulNewInfoSize == 0)
        {
            status = NO_ERROR;
            break;
        }

        pucOutBuffer = (PUCHAR)(RequestPacket->OutputBuffer);
        ulSizeOfBuffer = RequestPacket->OutputBufferLength;

        if (ulSizeOfBuffer < ulNewInfoSize)
        {
            // Not enough room reserved for the file contents.
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            // We should be able to copy our data.
            VideoPortMoveMemory(pucOutBuffer, pucNewInfo, ulNewInfoSize);

            // And don't forget to set this to the appropriate length!
            RequestPacket->StatusBlock->Information = ulNewInfoSize;

            status = NO_ERROR;
        }

        break;  // end MTX_GET_UPDATED_INF


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES
        |
        |   The MGA user-mode drivers will call this very early in their
        |   initialization sequence, probably right after MTX_INITIALIZE_MGA.
        |   This will return the number of video modes supported by the
        |   adapter by filling out a VIDEO_NUM_MODES structure.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - QUERY_NUM_AVAIL_MODES\n"));
        //DbgBreakPoint();

        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there).

        // If the buffer passed in is not large enough return an appropriate
        // error code.
        if (RequestPacket->OutputBufferLength <
                    (RequestPacket->StatusBlock->Information =
                                                    sizeof(VIDEO_NUM_MODES)))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            if (MgaDeviceExtension->NumberOfSuperModes == 0)
            {
                // No modes are listed so far, try to make up the list.
                iBoard = 0;
                if (mgainf == NULL)
                {
                    // No vidset yet, use the default one.
                    mgainf = adjustDefaultVidset();
                }

                // Call the service.
                MgaInitModeList(MgaDeviceExtension);

                // If an error occurred, NumberOfSuperModes will be zero;
                // otherwise, it will be the appropriate number of modes.
            }

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                                    MgaDeviceExtension->NumberOfSuperModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->
                        ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }
        break;      // end QUERY_NUM_AVAIL_MODES


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_QUERY_AVAIL_MODES
        |
        |   The MGA user-mode drivers will call this very early in their
        |   initialization sequence, just after QUERY_NUM_AVAIL_MODES.
        |   This will return return information about each video mode
        |   supported by the adapter (including modes that require more than
        |   one board if more than one are present) by filling out an array
        |   of VIDEO_MODE_INFORMATION structures.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - QUERY_AVAIL_MODES\n"));
        //DbgBreakPoint();

        if (RequestPacket->OutputBufferLength <
                    (RequestPacket->StatusBlock->Information =
                                MgaDeviceExtension->NumberOfSuperModes *
                                            sizeof(VIDEO_MODE_INFORMATION)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            modeInformation = RequestPacket->OutputBuffer;

            // Fill in a VIDEO_MODE_INFORMATION struc for each available mode.
            pCurMulti = MgaDeviceExtension->pSuperModes;
            if (pCurMulti == NULL)
            {
                status = ERROR_DEV_NOT_EXIST;
                break;
            }

            for (i = 0; i < MgaDeviceExtension->NumberOfSuperModes; i++)
            {
                // Fill in common values that apply to all modes
                modeInformation[i] = CommonVideoModeInformation;

                // Fill in mode specific informations
                modeInformation[i].ModeIndex      = pCurMulti->MulModeNumber;
                modeInformation[i].VisScreenWidth = pCurMulti->MulWidth;
                modeInformation[i].VisScreenHeight= pCurMulti->MulHeight;
                modeInformation[i].ScreenStride   =
                             pCurMulti->MulWidth * pCurMulti->MulPixWidth / 8;
                modeInformation[i].BitsPerPlane   = pCurMulti->MulPixWidth;
                modeInformation[i].Frequency      = pCurMulti->MulRefreshRate;

                // XMillimeter and YMillimeter will be modified by the user-
                // mode driver.

                // If we're in TrueColor mode, then set RGB masks
                if ((modeInformation[i].BitsPerPlane == 32) ||
                    (modeInformation[i].BitsPerPlane == 24))
                {
                    // This makes 32 bpp look like 24 to the display driver
                    modeInformation[i].BitsPerPlane   = 24;

                    modeInformation[i].RedMask   = 0x00FF0000;
                    modeInformation[i].GreenMask = 0x0000FF00;
                    modeInformation[i].BlueMask  = 0x000000FF;
                    modeInformation[i].AttributeFlags =
                                    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
                }
                else if (modeInformation[i].BitsPerPlane == 16)
                {
                    modeInformation[i].AttributeFlags =
                                    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
                    if (pCurMulti->MulHwModes[0]->DispType & DISPTYPE_M565)
                    {
                        modeInformation[i].RedMask   = 0x0000F800;
                        modeInformation[i].GreenMask = 0x000007E0;
                        modeInformation[i].BlueMask  = 0x0000001F;
                    }
                    else
                    {
                        modeInformation[i].RedMask   = 0x00007C00;
                        modeInformation[i].GreenMask = 0x000003E0;
                        modeInformation[i].BlueMask  = 0x0000001F;
                        modeInformation[i].AttributeFlags |= VIDEO_MODE_555;
                        modeInformation[i].BitsPerPlane = 15;
                    }
                }
                else
                {
                    modeInformation[i].AttributeFlags =
                                    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS |
                                    VIDEO_MODE_PALETTE_DRIVEN |
                                    VIDEO_MODE_MANAGED_PALETTE;
                }

                if (pCurMulti->MulHwModes[0]->ZBuffer)
                {
                    // This is a 3D mode.
                    modeInformation[i].AttributeFlags |= VIDEO_MODE_3D;
                }

                // Number of boards involved in the current super-mode.
                CurrentResNbBoards = pCurMulti->MulArrayWidth *
                                                    pCurMulti->MulArrayHeight;
                // For each of them...
                for (n = 0; n < CurrentResNbBoards; n++)
                {
                    // Point to the mode information structure.
                    pMgaDispMode = pCurMulti->MulHwModes[n];

                    // For now, don't disclose whether we're interlaced.
                    //if (pMgaDispMode->DispType & TYPE_INTERLACED)
                    //{
                    //    modeInformation[i].AttributeFlags |=
                    //                                VIDEO_MODE_INTERLACED;
                    //}

                    // Figure out the width and height of the video memory bitmap
                    MaxWidth  = pMgaDispMode->DispWidth;
                    MaxHeight = pMgaDispMode->DispHeight;
                    pMgaOffScreenData = pMgaDispMode->pOffScr;
                    for (j = 0; j < pMgaDispMode->NumOffScr; j++)
                    {
                        if ((usTemp=(pMgaOffScreenData[j].XStart +
                                    pMgaOffScreenData[j].Width)) > MaxWidth)
                            MaxWidth=usTemp;

                        if ((usTemp=(pMgaOffScreenData[j].YStart +
                                    pMgaOffScreenData[j].Height)) > MaxHeight)
                            MaxHeight=usTemp;
                    }

                    modeInformation[i].VideoMemoryBitmapWidth = MaxWidth;
                    modeInformation[i].VideoMemoryBitmapHeight= MaxHeight;
                }
                pCurMulti++;
            }
            status = NO_ERROR;
        }
        break;      // end QUERY_AVAIL_MODES


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_SET_CURRENT_MODE
        |
        |   The MGA user-mode drivers will probably call this service right
        |   after QUERY_AVAIL_MODES.  This will set the adapter to the mode
        |   specified by VIDEO_MODE.  If more than one board are involved
        |   in the mode, each one will be set to the appropriate mode.  We
        |   want to take care not to re-program the mode already current.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_SET_CURRENT_MODE:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - SET_CURRENT_MODE\n"));
        //DbgBreakPoint();

        ModeInit = *(ULONG *)(RequestPacket->InputBuffer);
        if (MgaDeviceExtension->SuperModeNumber == ModeInit)
        {
            // The requested mode is already the current mode
            status = NO_ERROR;
            break;
        }

        // Save the current board, because this service will modify it.
        iCurBoard = iBoard;
        pCurBaseAddr = pMgaBaseAddr;

        // Check to see if we have a valid ModeNumber.
        if (ModeInit >= MgaDeviceExtension->NumberOfSuperModes)
        {
            // If the mode number is invalid, choose the first one.
            ModeInit = 0;
        }

        MgaDeviceExtension->SuperModeNumber = ModeInit;

        // Point to the appropriate MULTI_MODE structure.
        pCurMulti = &MgaDeviceExtension->pSuperModes[ModeInit];
        if (pCurMulti == NULL)
        {
            status = ERROR_DEV_NOT_EXIST;
            break;
        }

    #if DBG
        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - Requested mode: %u\n", ModeInit));
        VideoDebugPrint((1, "ModeNumber  Width Height  PW   X   Y  n mo    pHwMode\n"));
        VideoDebugPrint((1, "0x%08x % 6d % 6d % 3d % 3d % 3d\n",
                                                    pCurMulti->MulModeNumber,
                                                    pCurMulti->MulWidth,
                                                    pCurMulti->MulHeight,
                                                    pCurMulti->MulPixWidth,
                                                    pCurMulti->MulArrayWidth,
                                                    pCurMulti->MulArrayHeight));

        j = pCurMulti->MulArrayWidth * pCurMulti->MulArrayHeight;
        for (n = 0; n < j; n++)
        {
            VideoDebugPrint((1, "                                      %d %02x 0x%08x\n",
                                        pCurMulti->MulBoardNb[n],
                                        pCurMulti->MulBoardMode[n],
                                        pCurMulti->MulHwModes[n]));
        }
        //DbgBreakPoint();
    #endif

        // Use info for the first board to set a few Registry values.
        iBoard = pCurMulti->MulBoardNb[0];

        switch((Hw[iBoard].ProductRev >> 4) & 0x0000000f)
        {
            case TITAN_CHIP:    pwszChip = L"MGA (A2681700)";
                                cbChip = sizeof(L"MGA (A2681700)");
                                break;

            case ATLAS_CHIP:    pwszChip = L"MGA (A2681701)";
                                cbChip = sizeof(L"MGA (A2681701)");
                                break;

            case ATHENA_CHIP:   pwszChip = L"MGA (A2681702)";
                                cbChip = sizeof(L"MGA (A2681702)");
                                break;

            default:            pwszChip = L"MGA (Unspecified)";
                                cbChip = sizeof(L"MGA (Unspecified)");
                                break;
        }

        switch(Hw[iBoard].DacType)
        {
            case BT482:         pwszDAC = L"Brooktree Bt482";
                                cbDAC = sizeof(L"Brooktree Bt482");
                                break;

            case BT485:         pwszDAC = L"Brooktree Bt485";
                                cbDAC = sizeof(L"Brooktree Bt485");
                                break;

            case PX2085:        pwszDAC = L"Cirrus Logic PX2085";
                                cbDAC = sizeof(L"Cirrus Logic PX2085");
                                break;

            case VIEWPOINT:     pwszDAC = L"TI TVP3020";
                                cbDAC = sizeof(L"TI TVP3020");
                                break;

            case TVP3026:       pwszDAC = L"TI TVP3026";
                                cbDAC = sizeof(L"TI TVP3026");
                                break;

            default:            pwszDAC = L"Unknown";
                                cbDAC = sizeof(L"Unknown");
                                break;
        }

        AdapterMemorySize = Hw[iBoard].VramAvail + Hw[iBoard].DramAvail;

        if ((Hw[iBoard].ProductType & 0x0f) == BOARD_MGA_RESERVED)
        {
            MgaDeviceExtension->BoardId = TYPE_QVISION_PCI;

            // This is a Compaq board.
            if (Hw[iBoard].DacType == PX2085)
            {
                pwszAdapterString = L"QVision 2000";
                cbAdapterString = sizeof(L"QVision 2000");
            }
            else if (Hw[iBoard].DacType == TVP3026)
            {
                pwszAdapterString = L"QVision 2000+";
                cbAdapterString = sizeof(L"QVision 2000+");
            }
            else
            {
                MgaDeviceExtension->BoardId = TYPE_QVISION_ISA;
                pwszAdapterString = L"Compaq Unknown";
                cbAdapterString = sizeof(L"Compaq Unknown");
            }
        }
        else
        {
            MgaDeviceExtension->BoardId = TYPE_MATROX;

            switch(Hw[iBoard].ProductType >> 16)
            {
                case MGA_ULTIMA:    pwszAdapterString = L"Ultima";
                                    cbAdapterString = sizeof(L"Ultima");
                                    break;

                case MGA_ULTIMA_VAFC:
                                    pwszAdapterString = L"Ultima VAFC";
                                    cbAdapterString = sizeof(L"Ultima VAFC");
                                    break;

                case MGA_ULTIMA_PLUS:
                                    pwszAdapterString = L"Ultima Plus";
                                    cbAdapterString = sizeof(L"Ultima Plus");
                                    break;

                case MGA_ULTIMA_PLUS_200:
                                    pwszAdapterString = L"Ultima Plus 200";
                                    cbAdapterString = sizeof(L"Ultima Plus 200");
                                    break;

                case MGA_IMPRESSION_PLUS:
                                    pwszAdapterString = L"Impression Plus";
                                    cbAdapterString = sizeof(L"Impression Plus");
                                    break;

                case MGA_IMPRESSION_PLUS_200:
                                    pwszAdapterString = L"Impression Plus 200";
                                    cbAdapterString = sizeof(L"Impression Plus 200");
                                    break;

                case MGA_IMPRESSION:
                                    pwszAdapterString = L"Impression";
                                    cbAdapterString = sizeof(L"Impression");
                                    break;

                case MGA_IMPRESSION_PRO:
                                    pwszAdapterString = L"Impression PRO";
                                    cbAdapterString = sizeof(L"Impression PRO");
                                    break;

                case MGA_IMPRESSION_LTE:
                                    pwszAdapterString = L"Impression Lite";
                                    cbAdapterString = sizeof(L"Impression Lite");
                                    break;

                default:            pwszAdapterString = L"Unknown";
                                    cbAdapterString = sizeof(L"Unknown");
                                    break;
            }
        }

        VideoPortSetRegistryParameters(MgaDeviceExtension,
                                       L"HardwareInformation.ChipType",
                                       pwszChip,
                                       cbChip);

        VideoPortSetRegistryParameters(MgaDeviceExtension,
                                       L"HardwareInformation.DacType",
                                       pwszDAC,
                                       cbDAC);

        VideoPortSetRegistryParameters(MgaDeviceExtension,
                                       L"HardwareInformation.MemorySize",
                                       &AdapterMemorySize,
                                       sizeof(ULONG));

        VideoPortSetRegistryParameters(MgaDeviceExtension,
                                       L"HardwareInformation.AdapterString",
                                       pwszAdapterString,
                                       cbAdapterString);

        // Number of boards involved in the current super-mode.
        CurrentResNbBoards = pCurMulti->MulArrayWidth *
                                                    pCurMulti->MulArrayHeight;
        // For each of them...
        for (n = 0; n < CurrentResNbBoards; n++)
        {
            // Point to the mode information structure.
            pMgaDispMode = pCurMulti->MulHwModes[n];

            // Make the board current.
            iBoard = pCurMulti->MulBoardNb[n];
            pMgaBaseAddr = MgaDeviceExtension->KernelModeMappedBaseAddress[iBoard];

            // If the board is mapped at 0x000AC000, we must set the
            // MAP SEL 1 bit of the VGA MISC register to have the TITAN
            // mapped.
            if (Hw[iBoard].MapAddress == 0x000AC000)
            {
                // Select VGA MISC register (Index 6)
                        VideoPortWritePortUchar(TITAN_GCTL_ADDR_PORT, (UCHAR) 6);
                            ucTemp = VideoPortReadPortUchar(TITAN_GCTL_DATA_PORT) | 0x08;
                        VideoPortWritePortUchar(TITAN_GCTL_DATA_PORT, ucTemp);
            }

            // Reset all Titan host registers
            VideoPortWriteRegisterUlong((PULONG)((PUCHAR)pMgaBaseAddr +
                                                TITAN_OFFSET + TITAN_RST), 1);
            VideoPortStallExecution(2000);
            VideoPortWriteRegisterUlong((PULONG)((PUCHAR)pMgaBaseAddr +
                                                TITAN_OFFSET + TITAN_RST), 0);

            // Set the graphics mode from the available hardware modes.
            mtxSelectHwMode(pMgaDispMode);

            // Select the display mode.
            // Pass the frequency in the last byte of the ZOOM factor
            ZoomFactor = (pCurMulti->MulRefreshRate << 24) | ZOOM_X1;
            mtxSetDisplayMode(pMgaDispMode, ZoomFactor);

            // Set the cursor colors to white and black.
            MgaSetCursorColour(MgaDeviceExtension, 0xFFFFFF, 0x000000);

            // Set the MCtlWtSt register.
            VideoPortWriteRegisterUlong((PULONG)((PUCHAR)pMgaBaseAddr +
                        TITAN_OFFSET + TITAN_MCTLWTST), (ULONG)MCTLWTST_STD);
        }
        // Restore the current board to what it used to be.
        iBoard = iCurBoard;
        pMgaBaseAddr = pCurBaseAddr;

        // At this point, the RAMDAC should be okay, but it looks
        // like it's not quite ready to accept data, particularly
        // on VL boards.  Adding a delay seems to fix things.
        VideoPortStallExecution(100);   // Microseconds

        status = NO_ERROR;

        break;      // end SET_CURRENT_MODE


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_QUERY_BOARD_ARRAY
        |
        |   The MGA user-mode drivers will probably call this service after
        |   the mode has been set by SET_CURRENT_MODE.  The user-mode drivers
        |   have to know how the boards are arrayed to make up the display
        |   surface, so that they know which board to address when writing
        |   to a specific (x, y) position.  The miniport driver knows this,
        |   since it has just set the mode.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_QUERY_BOARD_ARRAY:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_QUERY_BOARD_ARRAY\n"));
        //DbgBreakPoint();

        // If the buffer passed in is not large enough return an appropriate
        // error code.
        if (RequestPacket->OutputBufferLength <
                    (RequestPacket->StatusBlock->Information = sizeof(SIZEL)))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            if(MgaDeviceExtension->SuperModeNumber == 0xFFFFFFFF)
            {
                // No mode has been selected yet, so we don't know...
                status = ERROR_DEV_NOT_EXIST;
            }
            else
            {
                ModeInit = MgaDeviceExtension->SuperModeNumber;

                // Point to the appropriate MULTI_MODE structure.
                pCurMulti = &MgaDeviceExtension->pSuperModes[ModeInit];
                if (pCurMulti == NULL)
                {
                    status = ERROR_DEV_NOT_EXIST;
                    break;
                }

                ((SIZEL*)RequestPacket->OutputBuffer)->cx =
                                                    pCurMulti->MulArrayWidth;
                ((SIZEL*)RequestPacket->OutputBuffer)->cy =
                                                    pCurMulti->MulArrayHeight;
                status = NO_ERROR;
            }
        }

        break;  // end MTX_QUERY_BOARD_ARRAY


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_MAKE_BOARD_CURRENT
        |
        |   The MGA user-mode drivers will call this service whenever a
        |   miniport operation need be executed on a particular board, as
        |   opposed to every single board involved in the current mode.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_MAKE_BOARD_CURRENT:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_MAKE_BOARD_CURRENT\n"));
        //DbgBreakPoint();

        n = *(ULONG *)(RequestPacket->InputBuffer);

        // Check to see if we have a valid board number.
        i = MgaDeviceExtension->SuperModeNumber;
        if (i == 0xFFFFFFFF)
        {
            status = ERROR_DEV_NOT_EXIST;
            break;
        }

        pCurMulti = &MgaDeviceExtension->pSuperModes[i];
        if (pCurMulti == NULL)
        {
            status = ERROR_DEV_NOT_EXIST;
            break;
        }

        if (n >= (ULONG)(pCurMulti->MulArrayWidth * pCurMulti->MulArrayHeight))
        {
            status = ERROR_DEV_NOT_EXIST;
        }
        else
        {
            // Make the board current.
            CONVERT_BOARD_NUMBER(n);
            iBoard = pCurMulti->MulBoardNb[n];
            pMgaBaseAddr = MgaDeviceExtension->KernelModeMappedBaseAddress[iBoard];
            status = NO_ERROR;
        }

        break;  // end MTX_MAKE_BOARD_CURRENT


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_QUERY_BOARD_ID
        |
        |   This service returns the board type information to the user-mode
        |   driver.  A call to MTX_MAKE_BOARD_CURRENT must have been made
        |   previously to set which board is to be queried.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_QUERY_BOARD_ID:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_QUERY_BOARD_ID\n"));
        //DbgBreakPoint();

        if (RequestPacket->OutputBufferLength < sizeof(ULONG))
        {
            // Not enough room reserved for the board ID.
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            *((PULONG)(RequestPacket->OutputBuffer)) = ProductMGA[iBoard];

            // And don't forget to set this to the appropriate length!
            RequestPacket->StatusBlock->Information = sizeof(ULONG);

            status = NO_ERROR;
        }

        break;  // end MTX_QUERY_BOARD_ID


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_QUERY_HW_DATA
        |
        |   This service returns hardware information about the current
        |   board by filling out a HW_DATA structure.  A call to
        |   MTX_MAKE_BOARD_CURRENT must have been made previously to set
        |   which board is to be queried.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_QUERY_HW_DATA:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_QUERY_HW_DATA\n"));
        //DbgBreakPoint();

        // Check if we have a sufficient output buffer
        if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(HW_DATA)))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            register PHW_DATA    pUserModeHwData;
            register HwData     *pMiniportHwData;

            pUserModeHwData = RequestPacket->OutputBuffer;
            pMiniportHwData = &Hw[iBoard];

            pUserModeHwData->MapAddress  = pMiniportHwData->MapAddress;
            pUserModeHwData->ProductType = pMiniportHwData->ProductType;
            pUserModeHwData->ProductRev  = pMiniportHwData->ProductRev;
            pUserModeHwData->ShellRev    = pMiniportHwData->ShellRev;
            pUserModeHwData->BindingRev  = pMiniportHwData->BindingRev;
            pUserModeHwData->VGAEnable   = pMiniportHwData->VGAEnable;
            pUserModeHwData->Sync        = pMiniportHwData->Sync;
            pUserModeHwData->Device8_16  = pMiniportHwData->Device8_16;
            pUserModeHwData->PortCfg     = pMiniportHwData->PortCfg;
            pUserModeHwData->PortIRQ     = pMiniportHwData->PortIRQ;
            pUserModeHwData->MouseMap    = pMiniportHwData->MouseMap;
            pUserModeHwData->MouseIRate  = pMiniportHwData->MouseIRate;
            pUserModeHwData->DacType     = pMiniportHwData->DacType;

            pUserModeHwData->cursorInfo.MaxWidth  =
                                    pMiniportHwData->cursorInfo.MaxWidth;
            pUserModeHwData->cursorInfo.MaxHeight =
                                    pMiniportHwData->cursorInfo.MaxHeight;
            pUserModeHwData->cursorInfo.MaxDepth  =
                                    pMiniportHwData->cursorInfo.MaxDepth;
            pUserModeHwData->cursorInfo.MaxColors =
                                    pMiniportHwData->cursorInfo.MaxColors;
            pUserModeHwData->cursorInfo.CurWidth  =
                                    pMiniportHwData->cursorInfo.CurWidth;
            pUserModeHwData->cursorInfo.CurHeight =
                                    pMiniportHwData->cursorInfo.CurHeight;
            pUserModeHwData->cursorInfo.cHotSX    =
                                    pMiniportHwData->cursorInfo.cHotSX;
            pUserModeHwData->cursorInfo.cHotSY    =
                                    pMiniportHwData->cursorInfo.cHotSY;
            pUserModeHwData->cursorInfo.HotSX     =
                                    pMiniportHwData->cursorInfo.HotSX;
            pUserModeHwData->cursorInfo.HotSY     =
                                    pMiniportHwData->cursorInfo.HotSY;

            pUserModeHwData->VramAvail        = pMiniportHwData->VramAvail;
            pUserModeHwData->DramAvail        = pMiniportHwData->DramAvail;
            pUserModeHwData->CurrentOverScanX = pMiniportHwData->CurrentOverScanX;
            pUserModeHwData->CurrentOverScanY = pMiniportHwData->CurrentOverScanY;
            pUserModeHwData->YDstOrg          = pMiniportHwData->YDstOrg;

            status = NO_ERROR;
        }

        break;  // end MTX_QUERY_HW_DATA


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_QUERY_NUM_OFFSCREEN_BLOCKS
        |
        |   This service returns the number of offscreen memory areas
        |   available for the requested super-mode.  A call to
        |   MTX_MAKE_BOARD_CURRENT must have been made previously to set
        |   which board is to be queried.
        |
        |   Input:  A pointer to a VIDEO_MODE_INFORMATION structure, as
        |           returned by a QUERY_AVAIL_MODES request.
        |
        |   Output: A pointer to a VIDEO_NUM_OFFSCREEN_BLOCKS structure, as
        |           defined below.
        |
        |   The calling routine will have allocated the memory for the
        |   VIDEO_NUM_OFFSCREEN_BLOCKS structure.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_QUERY_NUM_OFFSCREEN_BLOCKS:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_QUERY_NUM_OFFSCREEN_BLOCKS\n"));
        //DbgBreakPoint();

        // Verify that input & output buffers are the correct sizes
        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_NUM_OFFSCREEN_BLOCKS))) ||
             (RequestPacket->InputBufferLength <
                                            sizeof(VIDEO_MODE_INFORMATION)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            PVIDEO_NUM_OFFSCREEN_BLOCKS pVideoNumOffscreenBlocks =
                                                RequestPacket->OutputBuffer;

            // Get the super-mode number the user-mode driver is asking about.
            modeInformation = RequestPacket->InputBuffer;
            ModeInit = modeInformation->ModeIndex;

            // Point to the appropriate MULTI_MODE structure.
            pCurMulti = &MgaDeviceExtension->pSuperModes[ModeInit];
            if (pCurMulti == NULL)
            {
                status = ERROR_DEV_NOT_EXIST;
                break;
            }

            // Look for the current board.
            i = 0;
            while ((i < NB_BOARD_MAX) && (pCurMulti->MulBoardNb[i] != iBoard))
                i++;

            // Point to the appropriate hw mode.
            pMgaDispMode = pCurMulti->MulHwModes[i];

            // Fill out NumBlocks.
            pVideoNumOffscreenBlocks->NumBlocks = pMgaDispMode->NumOffScr;

            // Fill out OffScreenBlockLength.
            pVideoNumOffscreenBlocks->OffscreenBlockLength =
                                                    sizeof(OFFSCREEN_BLOCK);

            status = NO_ERROR;
        }
        break;  // end MTX_QUERY_NUM_OFFSCREEN_BLOCKS


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_QUERY_OFFSCREEN_BLOCKS
        |
        |   This service returns a description of each offscreen memory area
        |   available for the requested super-mode.  A call to
        |   MTX_MAKE_BOARD_CURRENT must have been made previously to set
        |   which board is to be queried.
        |
        |   Input:  A pointer to a VIDEO_MODE_INFORMATION structure, as
        |           returned by a QUERY_AVAIL_MODES request.
        |
        |   Output: A pointer to the first of a series of OFFSCREEN_BLOCK
        |           structures, as defined below.
        |
        |   The calling routine will have allocated the memory for the
        |   OFFSCREEN_BLOCK structures.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_QUERY_OFFSCREEN_BLOCKS:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_QUERY_OFFSCREEN_BLOCKS\n"));
        //DbgBreakPoint();

        // Verify that the input buffer is the correct size.
        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE_INFORMATION))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            UCHAR NumOffScrBlocks;
            OffScrData  *pOffScrDataArray;
            POFFSCREEN_BLOCK pOffscreenBlockArray =
                                                RequestPacket->OutputBuffer;

            // Get the super-mode number the user-mode driver is asking about.
            modeInformation = RequestPacket->InputBuffer;
            ModeInit = modeInformation->ModeIndex;

            // Point to the appropriate MULTI_MODE structure.
            pCurMulti = &MgaDeviceExtension->pSuperModes[ModeInit];
            if (pCurMulti == NULL)
            {
                status = ERROR_DEV_NOT_EXIST;
                break;
            }

            // Look for the current board.
            i = 0;
            while ((i < NB_BOARD_MAX) && (pCurMulti->MulBoardNb[i] != iBoard))
                i++;

            // Point to the appropriate hw mode.
            pMgaDispMode = pCurMulti->MulHwModes[i];

            NumOffScrBlocks = pMgaDispMode->NumOffScr;

            // Verify that the output buffer is the correct size.
            if (RequestPacket->OutputBufferLength <
                            (RequestPacket->StatusBlock->Information =
                                NumOffScrBlocks * sizeof(OFFSCREEN_BLOCK)))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                // Fill the OFFSCREEN_BLOCK structures
                pOffScrDataArray = pMgaDispMode->pOffScr;
                for (i = 0; i < NumOffScrBlocks; i++)
                {
                    pOffscreenBlockArray[i].Type  =pOffScrDataArray[i].Type;
                    pOffscreenBlockArray[i].XStart=pOffScrDataArray[i].XStart;
                    pOffscreenBlockArray[i].YStart=pOffScrDataArray[i].YStart;
                    pOffscreenBlockArray[i].Width =pOffScrDataArray[i].Width;
                    pOffscreenBlockArray[i].Height=pOffScrDataArray[i].Height;
                    pOffscreenBlockArray[i].SafePlanes =
                                                pOffScrDataArray[i].SafePlanes;
                    pOffscreenBlockArray[i].ZOffset    =
                                                pOffScrDataArray[i].ZXStart;
                }
                status = NO_ERROR;
            }
        }
        break;  // end MTX_QUERY_OFFSCREEN_BLOCKS


        /*------------------------------------------------------------------*\
        | Special service:  IOCTL_VIDEO_MTX_QUERY_RAMDAC_INFO
        |
        |   This service returns information about the type and capabilities
        |   of the installed ramdac by filling out a RAMDAC_INFO structure.
        |   A call to MTX_MAKE_BOARD_CURRENT must have been made previously
        |   to set which board is to be queried.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MTX_QUERY_RAMDAC_INFO:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MTX_QUERY_RAMDAC_INFO\n"));
        //DbgBreakPoint();

        // Check if we have a sufficient output buffer
        if (RequestPacket->OutputBufferLength <
                            (RequestPacket->StatusBlock->Information =
                                                        sizeof(RAMDAC_INFO)))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            pVideoPointerAttributes=RequestPacket->OutputBuffer;

            pVideoPointerAttributes->Flags = RAMDAC_NONE;
            pVideoPointerAttributes->OverScanX =
                                            Hw[iBoard].CurrentOverScanX;
            pVideoPointerAttributes->OverScanY =
                                            Hw[iBoard].CurrentOverScanY;

            if (Hw[iBoard].DacType == DacTypeBT482)
            {
                pVideoPointerAttributes->Flags =  VIDEO_MODE_MONO_POINTER | RAMDAC_BT482;
                pVideoPointerAttributes->Width =  32;
                pVideoPointerAttributes->Height = 32;
            }

            if (Hw[iBoard].DacType == DacTypeBT485)
            {
                pVideoPointerAttributes->Flags =  VIDEO_MODE_MONO_POINTER | RAMDAC_BT485;
                pVideoPointerAttributes->Width =  64;
                pVideoPointerAttributes->Height = 64;
            }

            if (Hw[iBoard].DacType == DacTypePX2085)
            {
                pVideoPointerAttributes->Flags =  VIDEO_MODE_MONO_POINTER | RAMDAC_PX2085;
                pVideoPointerAttributes->Width =  64;
                pVideoPointerAttributes->Height = 64;
            }

            if (Hw[iBoard].DacType == DacTypeVIEWPOINT)
            {
                pVideoPointerAttributes->Flags =  VIDEO_MODE_MONO_POINTER | RAMDAC_VIEWPOINT;
                pVideoPointerAttributes->Width =  64;
                pVideoPointerAttributes->Height = 64;
            }

            if (Hw[iBoard].DacType == DacTypeTVP3026)
            {
                pVideoPointerAttributes->Flags =  VIDEO_MODE_MONO_POINTER | RAMDAC_TVP3026;
                pVideoPointerAttributes->Width =  64;
                pVideoPointerAttributes->Height = 64;
            }
            status = NO_ERROR;
        }
        break;  // end MTX_QUERY_RAMDAC_INFO


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES
        |
        |   This service will return the address ranges used by the user-mode
        |   drivers to program the video hardware directly, by filling out
        |   a VIDEO_PUBLIC_ACCESS_RANGES structure.  A call to
        |   MTX_MAKE_BOARD_CURRENT must have been made previously to set
        |   which board is to be accessed.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - QUERY_PUBLIC_ACCESS_RANGES\n"));
        //DbgBreakPoint();

        // Make sure the output buffer is big enough.
        if (RequestPacket->OutputBufferLength <
                        (RequestPacket->StatusBlock->Information =
                                        sizeof(VIDEO_PUBLIC_ACCESS_RANGES)))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            // Fill out the VIDEO_PUBLIC_ACCESS_RANGES buffer.
            publicAccessRanges = RequestPacket->OutputBuffer;

            ulWindowLength = MgaDriverAccessRange[iBoard*2].RangeLength;
            publicAccessRanges->InIoSpace =
                                MgaDriverAccessRange[iBoard*2].RangeInIoSpace;
            publicAccessRanges->MappedInIoSpace =
                                MgaDriverAccessRange[iBoard*2].RangeInIoSpace;
            publicAccessRanges->VirtualAddress =
                                (PVOID) NULL;       // Any virtual address

            status = VideoPortMapMemory(
                                MgaDeviceExtension,
                                MgaDriverAccessRange[iBoard*2].RangeStart,
                                &ulWindowLength,
                                &(publicAccessRanges->InIoSpace),
                                &(publicAccessRanges->VirtualAddress)
                                );

            MgaDeviceExtension->UserModeMappedBaseAddress[iBoard] =
                                        publicAccessRanges->VirtualAddress;

        }
        break;  // end QUERY_PUBLIC_ACCESS_RANGES


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_SET_COLOR_REGISTERS
        |
        |   This service sets the adapter's color registers to the specified
        |   RGB values.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - SET_COLOR_REGISTERS\n"));
        //DbgBreakPoint();

        if ((ModeInit = MgaDeviceExtension->SuperModeNumber) == 0xFFFFFFFF)
        {
            status = ERROR_DEV_NOT_EXIST;
            break;
        }

        pclutBuffer = RequestPacket->InputBuffer;

        // Save the current board, because this service will modify it.
        iCurBoard = iBoard;
        pCurBaseAddr = pMgaBaseAddr;

        status = NO_ERROR;

        // Point to the appropriate MULTI_MODE structure.
        pCurMulti = &MgaDeviceExtension->pSuperModes[ModeInit];
        if (pCurMulti == NULL)
        {
            status = ERROR_DEV_NOT_EXIST;
            break;
        }

        // Number of boards involved in the current super-mode.
        CurrentResNbBoards = pCurMulti->MulArrayWidth *
                                                    pCurMulti->MulArrayHeight;
        // For each of them...
        for (n = 0; n < CurrentResNbBoards; n++)
        {
            // Point to the mode information structure.
            pMgaDispMode = pCurMulti->MulHwModes[n];

            // Make the board current.
            iBoard = pCurMulti->MulBoardNb[n];
            pMgaBaseAddr = MgaDeviceExtension->KernelModeMappedBaseAddress[iBoard];

            status |= MgaSetColorLookup(MgaDeviceExtension,
                                   (PVIDEO_CLUT) RequestPacket->InputBuffer,
                                   RequestPacket->InputBufferLength);
        }
        // Restore the current board to what it used to be.
        iBoard = iCurBoard;
        pMgaBaseAddr = pCurBaseAddr;

        break;  // end SET_COLOR_REGISTERS


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES
        |
        |   This service will release the address ranges used by the user-mode
        |   drivers to program the video hardware.  In the S3 code, and in
        |   the DDK reference, it is said that the input buffer should
        |   contain an array of VIDEO_PUBLIC_ACCESS_RANGES to be released.
        |   However, I did not get anything in the input buffer when I traced
        |   through the code.  Instead, I have observed that SET_CURRENT_MODE
        |   had been called, so that there is a current valid mode.  We will
        |   simply free the access ranges not required by the current mode.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - FREE_PUBLIC_ACCESS_RANGES\n"));
        //DbgBreakPoint();

        // Make sure the input buffer is big enough.
        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            // The input buffer is not large enough.

            // Assume all will be right.
            status = NO_ERROR;

            ModeInit = MgaDeviceExtension->SuperModeNumber;
            if(ModeInit == 0xFFFFFFFF)
            {
                // No mode has been selected yet, so we'll free everything.
                // For every board...
                for (i = 0; i< NbBoard; i++)
                {
                    if (MgaDeviceExtension->UserModeMappedBaseAddress[i])
                    {
                        // This board has a non-null user-mode base address.
                        // Fill out the VIDEO_PUBLIC_ACCESS_RANGES buffer.
                        publicAccessRanges=RequestPacket->OutputBuffer;

                        publicAccessRanges->InIoSpace = 0;       // Not in I/O space
                        publicAccessRanges->MappedInIoSpace = 0; // Not in I/O space
                        publicAccessRanges->VirtualAddress =
                            MgaDeviceExtension->UserModeMappedBaseAddress[i];

                        status |= VideoPortUnmapMemory(
                                            MgaDeviceExtension,
                                            publicAccessRanges->VirtualAddress,
                                            0);

                        // Reset the user-mode base address.
                        MgaDeviceExtension->UserModeMappedBaseAddress[i] = 0;
                    }
                }
            }
            else
            {
                // We know our current mode.
                // Point to the appropriate MULTI_MODE structure.
                pCurMulti = &MgaDeviceExtension->pSuperModes[ModeInit];
                if (pCurMulti == NULL)
                {
                    status = ERROR_DEV_NOT_EXIST;
                    break;
                }

                // Number of boards involved in the current super-mode.
                CurrentResNbBoards = pCurMulti->MulArrayWidth *
                                                    pCurMulti->MulArrayHeight;
                // For every board...
                for (i = 0; i< NbBoard; i++)
                {
                    // Check whether it's used by the current mode.
                    n = 0;
                    while ((n < CurrentResNbBoards) &&
                                            (pCurMulti->MulBoardNb[n] != i))
                        n++;
                    if ((n == CurrentResNbBoards) &&
                        (MgaDeviceExtension->UserModeMappedBaseAddress[i]))
                    {
                        // We went through the list, the board is not in use,
                        // and the board has a non-null user-mode base address.
                        // Fill out the VIDEO_PUBLIC_ACCESS_RANGES buffer.
                        publicAccessRanges=RequestPacket->OutputBuffer;

                        publicAccessRanges->InIoSpace = 0;       // Not in I/O space
                        publicAccessRanges->MappedInIoSpace = 0; // Not in I/O space
                        publicAccessRanges->VirtualAddress =
                            MgaDeviceExtension->UserModeMappedBaseAddress[i];

                        status |= VideoPortUnmapMemory(
                                            MgaDeviceExtension,
                                            publicAccessRanges->VirtualAddress,
                                            0);

                        // Reset the user-mode base address.
                        MgaDeviceExtension->UserModeMappedBaseAddress[i] = 0;
                    }
                }
            }
        }
        else
        {
            // The input buffer is large enough, use it.
            status = VideoPortUnmapMemory(MgaDeviceExtension,
                                          ((PVIDEO_MEMORY)
                                           (RequestPacket->InputBuffer))->
                                                    RequestedVirtualAddress,
                                          0);
        }
        break;  // end FREE_PUBLIC_ACCESS_RANGES


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_MAP_VIDEO_MEMORY
        |
        |   This service maps the frame buffer and VRAM into the virtual
        |   address space of the requestor.  For now, we'll just return NULL
        |   addresses and lengths.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_MAP_VIDEO_MEMORY:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - MAP_VIDEO_MEMORY\n"));
        //DbgBreakPoint();

        if ( (RequestPacket->OutputBufferLength <
              (RequestPacket->StatusBlock->Information =
                                     sizeof(VIDEO_MEMORY_INFORMATION))) ||
             (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            memoryInformation = RequestPacket->OutputBuffer;

            memoryInformation->VideoRamBase = 0;
            memoryInformation->VideoRamLength = 0;
            memoryInformation->FrameBufferBase = 0;
            memoryInformation->FrameBufferLength = 0;
            status = NO_ERROR;
        }

        break;  // end MAP_VIDEO_MEMORY

        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_UNMAP_VIDEO_MEMORY
        |
        |   This service releases mapping of the frame buffer and VRAM from
        |   the virtual address space of the requestor.  For now, we'll just
        |   do nothing.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - UNMAP_VIDEO_MEMORY\n"));
        //DbgBreakPoint();

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY))
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            status = NO_ERROR;
        }
        break;


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_QUERY_CURRENT_MODE
        |
        |   This service returns information about the current video mode
        |   by filling out a VIDEO_MODE_INFORMATION structure.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - QUERY_CURRENT_MODE\n"));
        //DbgBreakPoint();

        if (RequestPacket->OutputBufferLength <
                        (RequestPacket->StatusBlock->Information =
                                            sizeof(VIDEO_MODE_INFORMATION)) )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            modeInformation = RequestPacket->OutputBuffer;

            // Fill in a VIDEO_MODE_INFORMATION struc for the mode indicated
            // by MgaDeviceExtension->SuperModeNumber

            i = MgaDeviceExtension->SuperModeNumber;
            if (i == 0xFFFFFFFF)
            {
                status = ERROR_DEV_NOT_EXIST;
                break;
            }

            pCurMulti = &MgaDeviceExtension->pSuperModes[i];
            if (pCurMulti == NULL)
            {
                status = ERROR_DEV_NOT_EXIST;
                break;
            }

            // Fill in common values that apply to all modes.
            *modeInformation=CommonVideoModeInformation;

            // Fill in mode specific informations.
            modeInformation->ModeIndex      = pCurMulti->MulModeNumber;
            modeInformation->VisScreenWidth = pCurMulti->MulWidth;
            modeInformation->VisScreenHeight= pCurMulti->MulHeight;
            modeInformation->ScreenStride   =
                             pCurMulti->MulWidth * pCurMulti->MulPixWidth / 8;
            modeInformation->BitsPerPlane   = pCurMulti->MulPixWidth;
            modeInformation->Frequency      = pCurMulti->MulRefreshRate;

            // If we're in TrueColor mode, then set RGB masks
            if ((modeInformation[i].BitsPerPlane == 32) ||
                (modeInformation[i].BitsPerPlane == 24))
            {
                modeInformation[i].RedMask   = 0x00FF0000;
                modeInformation[i].GreenMask = 0x0000FF00;
                modeInformation[i].BlueMask  = 0x000000FF;
                modeInformation[i].AttributeFlags =
                                    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
            }
            else if (modeInformation[i].BitsPerPlane == 16)
            {
                modeInformation[i].AttributeFlags =
                                    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
                if (pCurMulti->MulHwModes[0]->DispType & DISPTYPE_M565)
                {
                    modeInformation[i].RedMask   = 0x0000F800;
                    modeInformation[i].GreenMask = 0x000007E0;
                    modeInformation[i].BlueMask  = 0x0000001F;
                }
                else
                {
                    modeInformation[i].RedMask   = 0x00007C00;
                    modeInformation[i].GreenMask = 0x000003E0;
                    modeInformation[i].BlueMask  = 0x0000001F;
                    modeInformation[i].AttributeFlags |= VIDEO_MODE_555;
                    modeInformation[i].BitsPerPlane = 15;
                }
            }
            else
            {
                modeInformation[i].AttributeFlags =
                                    VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS |
                                    VIDEO_MODE_PALETTE_DRIVEN |
                                    VIDEO_MODE_MANAGED_PALETTE;
            }

            if (pCurMulti->MulHwModes[0]->ZBuffer)
            {
                // This is a 3D mode.
                modeInformation[i].AttributeFlags |= VIDEO_MODE_3D;
            }

            // Number of boards involved in the current super-mode.
            CurrentResNbBoards = pCurMulti->MulArrayWidth *
                                                    pCurMulti->MulArrayHeight;
            // For each of them...
            for (n = 0; n < CurrentResNbBoards; n++)
            {
                // Point to the mode information structure.
                pMgaDispMode = pCurMulti->MulHwModes[n];

                // For now, don't disclose whether we're interlaced.
                //if (pMgaDispMode->DispType & TYPE_INTERLACED)
                //{
                //    modeInformation[i].AttributeFlags |=
                //                                VIDEO_MODE_INTERLACED;
                //}

                // Figure out the width and height of the video memory bitmap
                MaxWidth  = pMgaDispMode->DispWidth;
                MaxHeight = pMgaDispMode->DispHeight;
                pMgaOffScreenData = pMgaDispMode->pOffScr;
                for (j = 0; j < pMgaDispMode->NumOffScr; j++)
                {
                    if ((usTemp=(pMgaOffScreenData[j].XStart +
                                pMgaOffScreenData[j].Width)) > MaxWidth)
                        MaxWidth=usTemp;

                    if ((usTemp=(pMgaOffScreenData[j].YStart +
                                pMgaOffScreenData[j].Height)) > MaxHeight)
                        MaxHeight=usTemp;
                }

                modeInformation[i].VideoMemoryBitmapWidth = MaxWidth;
                modeInformation[i].VideoMemoryBitmapHeight= MaxHeight;
            }
            status = NO_ERROR;
        }
        break;  // end QUERY_CURRENT_MODE


        /*------------------------------------------------------------------*\
        | Required service:  IOCTL_VIDEO_RESET_DEVICE
        |
        |   This service resets the video hardware to the default mode, to
        |   which it was initialized at system boot.
        |
        \*------------------------------------------------------------------*/
    case IOCTL_VIDEO_RESET_DEVICE:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - RESET_DEVICE\n"));
        //DbgBreakPoint();

        if ((ModeInit = MgaDeviceExtension->SuperModeNumber) == 0xFFFFFFFF)
        {
            // RESET has been done already.
            status = NO_ERROR;
            break;
        }

        // Save the current board, because this service will modify it.
        iCurBoard = iBoard;
        pCurBaseAddr = pMgaBaseAddr;

        // Point to the appropriate MULTI_MODE structure.
        pCurMulti = &MgaDeviceExtension->pSuperModes[ModeInit];
        if (pCurMulti == NULL)
        {
            status = ERROR_DEV_NOT_EXIST;
            break;
        }

        // Number of boards involved in the current super-mode.
        CurrentResNbBoards = pCurMulti->MulArrayWidth *
                                                    pCurMulti->MulArrayHeight;
        // For each of them...
        for (n = 0; n < CurrentResNbBoards; n++)
        {
            // Point to the mode information structure.
            pMgaDispMode = pCurMulti->MulHwModes[n];

            // Make the board current.
            iBoard = pCurMulti->MulBoardNb[n];
            pMgaBaseAddr = MgaDeviceExtension->KernelModeMappedBaseAddress[iBoard];

            // Disable the hardware cursor.
            mtxCursorEnable(0);

            if(Hw[iBoard].VGAEnable)
            {
                // This board is VGA-enabled, reset it to VGA.
                mtxSetVideoMode(mtxPASSTHRU);
            }
            else
            {
                // This board is not VGA-enabled.
                // Just clear the screen, it will look nicer.
                clutBufferOne.NumEntries = 1;
                clutBufferOne.LookupTable[0].RgbLong = 0;

                for (j = 0; j <= VIDEO_MAX_COLOR_REGISTER; j++)
                {
                    clutBufferOne.FirstEntry = j;
                    MgaSetColorLookup(MgaDeviceExtension,
                                      &clutBufferOne,
                                      sizeof(VIDEO_CLUT));
                }
                // Make the cursor disappear.
                // MgaSetCursorColour(MgaDeviceExtension, 0, 0);
            }
        }
        // Signal that no mode is currently selected.
        MgaDeviceExtension->SuperModeNumber = 0xFFFFFFFF;

        if (MgaDeviceExtension->pSuperModes != (PMULTI_MODE) NULL)
        {
            // Free our allocated memory.
            VideoPortReleaseBuffer(pMgaDeviceExtension, MgaDeviceExtension->pSuperModes);
            MgaDeviceExtension->pSuperModes = (PMULTI_MODE) NULL;
        }

        MgaDeviceExtension->NumberOfSuperModes = 0;

        // Memory might have been allocated for mgainf.
        if (mgainf != DefaultVidset)
        {
            VideoPortReleaseBuffer(pMgaDeviceExtension, mgainf);

            // And use the default set.
            mgainf = adjustDefaultVidset();
        }

        // Restore the current board to what it used to be.
        iBoard = iCurBoard;
        pMgaBaseAddr = pCurBaseAddr;

        status = NO_ERROR;

        break;  // end IOCTL_VIDEO_RESET_DEVICE


#if 0
    case IOCTL_VIDEO_SAVE_HARDWARE_STATE:
        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - SAVE_HARDWARE_STATE\n"));
        status = ERROR_INVALID_FUNCTION;
        break;


    case IOCTL_VIDEO_RESTORE_HARDWARE_STATE:
        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - RESTORE_HARDWARE_STATE\n"));
        status = ERROR_INVALID_FUNCTION;
        break;

    case IOCTL_VIDEO_ENABLE_VDM:
        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - ENABLE_VDM\n"));
        status = ERROR_INVALID_FUNCTION;
        break;
#endif

        /*------------------------------------------------------------------*\
        |   If we get here, an invalid IoControlCode was specified.
        \*------------------------------------------------------------------*/
    default:

        VideoDebugPrint((1, "MGA.SYS!MgaStartIO - Invalid service\n"));
        status = ERROR_INVALID_FUNCTION;
        break;
   }

    RequestPacket->StatusBlock->Status = status;
    return TRUE;

}   // end MgaStartIO()


/*--------------------------------------------------------------------------*\
| VP_STATUS
| MgaInitModeList(
|     PMGA_DEVICE_EXTENSION MgaDeviceExtension)
|
| Routine Description:
|
|     This routine builds the list of modes available for the detected boards.
|
| Arguments:
|
|     HwDeviceExtension - Pointer to the miniport driver's device extension.
|
| Return Value:
|
|     NO_ERROR, ERROR_DEV_NOT_EXIST, or ERROR_NOT_ENOUGH_MEMORY.
|
\*--------------------------------------------------------------------------*/
VP_STATUS
MgaInitModeList(
    PMGA_DEVICE_EXTENSION MgaDeviceExtension)
{
    HwModeData  *pMgaDispMode, *pMgaModeData, *pCurrentMgaModeData;
    HwModeData  *Mga2dMode[16], *Mga3dMode[16];
    MULTI_MODE  *pCurMulti;
    PULONG      pulModeFlags;
    ULONG       ulNb2DRefreshRates, ulNb3DRefreshRates, ulNbRefreshRates;
    ULONG       VGABoard, VGABoardBit, ModePixDepth, ulModeListOffset,
                NbSuperModes, ResTag, ModeInit;
    ULONG       CurrentResFlags, CurrentFlag,
                CurrentResWidth, CurrentResHeight, CurrentRefreshRate,
                CurrentResNbBoards, CurrentResNbBoards3D, CurrentPixWidth;
    ULONG       i, k, m, n, ir, ja, i2d, i3d;
    VP_STATUS   status;
    USHORT      j;
    USHORT      us2DRefreshRates, us3DRefreshRates, usRefreshRates;
    UCHAR       ValidBoard[NB_BOARD_MAX];
    UCHAR       ucTestFlags, ucRefreshBit;
    UCHAR       ucMask;
    BOOLEAN     bSupported2dMode, bSupported3dMode;

    // Assume we won't have any problem.
    status = NO_ERROR;

    // Check whether we've already built a mode list.  MgaDeviceExtension
    // is assumed to have been zeroed out when it was first given us.
    if (MgaDeviceExtension->NumberOfSuperModes != 0)
    {
        if (MgaDeviceExtension->pSuperModes != (PMULTI_MODE) NULL)
        {
            // Free our allocated memory.
            VideoPortReleaseBuffer(pMgaDeviceExtension, 
                                   MgaDeviceExtension->pSuperModes);
            MgaDeviceExtension->pSuperModes = (PMULTI_MODE) NULL;
        }

        // Memory might have been allocated for mgainf.  It's all right,
        // we'll want to use the current mgainf.
    }

    // Just in case we leave early...
    MgaDeviceExtension->NumberOfSuperModes = 0;

    // Get information on all the MGA boards currently installed in the
    // system.
    if ((pMgaBoardData = mtxCheckHwAll()) == NULL)
    {
        // mtxCheckHwAll should always return success, since MapBoard has
        // already been executed.
        // BUGBUG - if it never occurs, then this code isn't needed.
        //          a better answer would be to code an ASSERT() and
        //          write code that would handle the failure anyways
        VideoDebugPrint((1, "MGA.SYS!MGAStartIO failed mtxCheckHwAll\n"));
        status = ERROR_DEV_NOT_EXIST;
        return(status);
    }
    else
    {
        // There may be several MGA boards installed.  Look at all of
        // them, and map their physical addresses into kernel space.
        // While we're at it, find out if any of our boards is VGA enabled.
        VGABoard = (ULONG)-1;
        VGABoardBit = 0;

        // No mode has been selected yet, so make this invalid.
        MgaDeviceExtension->SuperModeNumber = 0xFFFFFFFF;
        MgaDeviceExtension->pSuperModes = (PMULTI_MODE) NULL;

        // We don't care whether the mode is interlaced or not, because
        // the only modes that we'll get will be selected according to
        // the monitor capabilities through the mga.inf file.
        ucMask = (UCHAR)(~DISPTYPE_INTERLACED);

        // pMgaBoardData is really the address of Hw[0].
        for (i = 0; i < NbBoard; i++)
        {
            MgaDeviceExtension->NumberOfModes[i] = 0;
            MgaDeviceExtension->NumberOfValidModes[i] = 0;
            MgaDeviceExtension->ModeFlags2D[i] = 0;
            MgaDeviceExtension->ModeFlags3D[i] = 0;

            // Make it clean:  initialize the ModeList to an invalid mode.
            for (j = 0; j < 64; j++)
            {
                MgaDeviceExtension->ModeList[i][j] = 0xFF;
            }

            if (mtxSelectHw(&Hw[i]) == mtxFAIL)
            {
                // mtxSelectHw should always return success, since
                // MapBoard has already been executed.
                // BUGBUG - if it never occurs, then this code isn't needed.
                //          a better answer would be to code an ASSERT() and
                //          write code that would handle the failure anyways
                VideoDebugPrint((1, "MGA.SYS!MGAStartIO failed mtxSelectHw for board %d\n", i));
                MgaDeviceExtension->KernelModeMappedBaseAddress[i] =
                                                        (PVOID)0xffffffff;
                continue;
            }

            // MGA board i has been selected.
            //VideoDebugPrint((1, "MGA.SYS!MGAStartIO mapped board %d at 0x%x\n", i, pMgaBaseAddr));
            //DbgPrint("MGA.SYS!MGAStartIO mapped board %d at 0x%x\n", i, pMgaBaseAddr);
            MgaDeviceExtension->KernelModeMappedBaseAddress[i] =
                                                            pMgaBaseAddr;
            if (Hw[i].VGAEnable)
            {
                VGABoard = i;
                VGABoardBit = 1 << i;
            }

            // Set up the test flags.  TITAN always supports
            // double-buffering, while Atlas and Athena use different
            // modes.
            if ((Hw[i].ProductRev & 0x000000F0) == 0)
            {
                // This is TITAN.
                ucTestFlags = DISPTYPE_DB;
            }
            else
            {
                // This is not TITAN.
                ucTestFlags = 0;
            }

            // Get information on all the hardware modes available for
            // the current MGA board.
            if ((pMgaModeData = mtxGetHwModes()) == NULL)
            {
                // This case never occurs.
                // BUGBUG - if it never occurs, then this code isn't needed.
                //          a better answer would be to code an ASSERT() and
                //          write code that would handle the failure anyways
                VideoDebugPrint((1, "MGA.SYS!MGAStartIO failed mtxGetHwModes for board %d\n", i));
                continue;
            }

            // Store it in the DeviceExtension structure.
            MgaDeviceExtension->pMgaHwModes[i] = pMgaModeData;

            // Modes we may want to support:
            //
            // 2D modes -------------------------------------------------
            // 8bpp, LUT
            //      DispType = 14, ZBuffer = 0, PixWidth =  8 (Titan)
            //      DispType =  4, ZBuffer = 0, PixWidth =  8 (others)
            // 16bpp, 565
            //      DispType =  8, ZBuffer = 0, PixWidth = 16
            // 24bpp
            //      DispType =  0, ZBuffer = 0, PixWidth = 24 (Storm only)
            // 32bpp
            //      DispType = 10, ZBuffer = 0, PixWidth = 32 (Titan)
            //      DispType =  0, ZBuffer = 0, PixWidth = 32 (others)
            //
            // 3D modes -------------------------------------------------
            // 8bpp, no LUT
            //      DispType = 10, ZBuffer = 1, PixWidth =  8
            // 16bpp, 555
            //      DispType = 10, ZBuffer = 1, PixWidth = 16 (Mga or Storm)
            //   OR
            // 16bpp, 565
            //      DispType = 18, ZBuffer = 1, PixWidth = 16 (Storm only)
            // 24bpp
            //      DispType = 10, ZBuffer = 1, PixWidth = 24 (Storm only)
            // 32bpp
            //      DispType = 10, ZBuffer = 1, PixWidth = 32

            // Calculate the number of available modes for this board.
            // *IMPORTANT* We assume the last entry in the HwMode
            //             array has DispWidth equal to -1.

            // NEW!
            // We do not want to support 16bpp modes here.  We'll
            // support 5-5-5 modes, but the trick is that some of
            // them will be 3D modes, and the other ones will be 2D.
            // We have to examine the list for these.

            i2d = 0;
            i3d = 0;
            for (pCurrentMgaModeData = pMgaModeData;
                 pCurrentMgaModeData->DispWidth != (word)-1;
                 pCurrentMgaModeData++)
            {
                if (pCurrentMgaModeData->PixWidth == 16)
                {
                    if (pCurrentMgaModeData->ZBuffer)
                    {
                        // 16bpp, Z buffer.
                        if ((pCurrentMgaModeData->DispType & ucMask) ==
                                                    DISPTYPE_DB)
                        {
                            Mga3dMode[i3d] = pCurrentMgaModeData;
                            i3d++;
                        }
                    }
                    else
                    {
                        // 16bpp, no Z buffer.
                        if ((pCurrentMgaModeData->DispType & ucMask) ==
                                                    ucTestFlags)
                        {
                            Mga2dMode[i2d] = pCurrentMgaModeData;
                            i2d++;
                        }
                    }
                }
            }

            for (m = 0; m < i2d; m++)
            {
                // Examine one of the 2D modes.
                bSupported2dMode = TRUE;
                pCurrentMgaModeData = Mga2dMode[m];
                CurrentResWidth  = pCurrentMgaModeData->DispWidth;
                CurrentResHeight = pCurrentMgaModeData->DispHeight;

                // Look for a similar 3D mode.
                for (k = 0; k < i3d; k++)
                {
                    pCurrentMgaModeData = Mga3dMode[k];
                    if ((pCurrentMgaModeData->DispWidth == CurrentResWidth ) &&
                        (pCurrentMgaModeData->DispHeight== CurrentResHeight))
                    {
                        // The current 2D mode is simlar to a 3D mode,
                        // we want to reject this 2D mode.
                        bSupported2dMode = FALSE;
                        break;
                    }
                }
                if (bSupported2dMode == TRUE)
                {
                    // We want to keep this one, so remove it from the
                    // checklist.
                    Mga2dMode[m] = 0;
                }
            }

            for (pCurrentMgaModeData = pMgaModeData;
                 pCurrentMgaModeData->DispWidth != (word)-1;
                 pCurrentMgaModeData++)
            {
                // Update the total number of modes supported.
                MgaDeviceExtension->NumberOfModes[i]++;

                for (m = 0; m < i2d; m++)
                {
                    if (pCurrentMgaModeData == Mga2dMode[m])
                    {
                        // This one is on our black list, reject it.
                        goto IML_END_OF_LOOP;
                    }
                }

                // Assume this mode won't be supported.
                bSupported2dMode = FALSE;
                bSupported3dMode = FALSE;

                // Update the number of valid modes supported.
                ModePixDepth = pCurrentMgaModeData->PixWidth;
                switch (ModePixDepth)
                {
                    case 8: if (pCurrentMgaModeData->ZBuffer)
                            {
                                // 8bpp, Z buffer.
                                // We don't support any of these.
                            }
                            else
                            {
                                // 8bpp, no Z buffer.
                                if ((pCurrentMgaModeData->DispType & ucMask) ==
                                            (ucTestFlags | DISPTYPE_LUT))
                                {
                                    bSupported2dMode = TRUE;
                                }
                            }
                            break;

                    case 16:if (pCurrentMgaModeData->ZBuffer)
                            {
                                // 16bpp, Z buffer.
                                if ((pCurrentMgaModeData->DispType & ucMask) ==
                                                            DISPTYPE_DB)
                                {
                                    bSupported3dMode = TRUE;
                                }
                            }
                            else
                            {
                                // 16bpp, no Z buffer.
                                //if ((pCurrentMgaModeData->DispType & ucMask) ==
                                //                            DISPTYPE_M565)
                                if ((pCurrentMgaModeData->DispType & ucMask) ==
                                                            ucTestFlags)
                                {
                                    bSupported2dMode = TRUE;
                                }
                            }
                            break;

                    case 24:if (pCurrentMgaModeData->ZBuffer)
                            {
                                // 24bpp, Z buffer.
                                // We don't support any of these.
                            }
                            else
                            {
                                // 24bpp, no Z buffer.
                                // We don't support any of these.
                            }
                            break;

                    case 32:if (pCurrentMgaModeData->ZBuffer)
                            {
                                // 32bpp, Z buffer.
                                // We don't support any of these.
                            }
                            else
                            {
                                // 32bpp, no Z buffer.
                                if ((pCurrentMgaModeData->DispType & ucMask) ==
                                                            ucTestFlags)
                                {
                                    bSupported2dMode = TRUE;
                                }
                            }
                            break;

                    default:
                            break;
                }
                if ((bSupported2dMode == FALSE) &&
                    (bSupported3dMode == FALSE))
                {
                    // We don't support this mode, get out.
                    continue;
                }

                if (bSupported2dMode)
                    ulModeListOffset = 0;
                else
                    ulModeListOffset = 32;

                // We can do something with the current mode.
                switch(pCurrentMgaModeData->DispWidth)
                {
                    case 640:   ResTag = BIT_640;
                                break;

                    case 768:   ResTag = BIT_768;
                                break;

                    case 800:   ResTag = BIT_800;
                                break;

                    case 1024:  ResTag = BIT_1024;
                                break;

                    case 1152:  ResTag = BIT_1152;
                                break;

                    case 1280:  ResTag = BIT_1280;
                                break;

                    case 1600:  ResTag = BIT_1600;
                                break;

                    default:    ResTag = BIT_INVALID;
                }

                // Record the HW mode to be used for this mode.
                // ModePixDepth is either 8, 16, 24, or 32.
                if (ResTag != BIT_INVALID)
                {
                    // We know this hardware mode is correct.  Now find
                    // out how many refresh rates this mode supports.
                    usRefreshRates = mtxGetRefreshRates(pCurrentMgaModeData);
                    for (j = 0; j < 16; j++)
                    {
                        if (usRefreshRates & (1 << j))
                        {
                            MgaDeviceExtension->NumberOfValidModes[i]++;
                        }
                    }

                    MgaDeviceExtension->
                      ModeList[i][ResTag+ModePixDepth+ulModeListOffset-8]
                      = (UCHAR)(MgaDeviceExtension->NumberOfModes[i] - 1);
                    MgaDeviceExtension->
                      ModeFreqs[i][ResTag+ModePixDepth+ulModeListOffset-8]
                      = usRefreshRates;
                }

                // Make up the resolution tag from the bit field.
                ResTag = 1 << ResTag;

                // Shift the resolution tag into its pixel-depth field.
                ResTag <<= (ModePixDepth - 8);

                // Record the resolution/pixel-depth flag.
                if (bSupported2dMode)
                    MgaDeviceExtension->ModeFlags2D[i] |= ResTag;
                else
                    MgaDeviceExtension->ModeFlags3D[i] |= ResTag;
        IML_END_OF_LOOP:
                ;
            }
        }

        // We have recorded information for each of our boards in the
        // MgaDeviceExtension structure.  For each board, we have set:
        //
        //  NumberOfModes[n]        The number of available modes
        //  NumberOfValidModes[n]   The number of modes supported by the
        //                            user-mode drivers
        //  ModeFlags2D[n]          The bit flags describing the supported
        //                            2D modes
        //  ModeFlags3D[n]          The bit flags describing the supported
        //                            3D modes
        //  KernelModeMappedBaseAddress[n]
        //                          The board's registers window mapping,
        //                            returned when VideoPortGetDeviceBase
        //                            is called with Hw[n].MapAddress
        //  pMgaHwModes[n]          The pointer to an array of HwModeData
        //                            structures describing available modes
        //  ModeList[n][64]         A list of hardware modes corresponding
        //                            to the ModeFlags bits
        //

        //DbgBreakPoint();

    #if DBG
        // Display it so that we can see if it makes sense...
        VideoDebugPrint((1, "# NbModes NbValid  ModeFlg2D  ModeFlg3D   BaseAddr   pHwModes ModeList\n"));
        for (i = 0; i < NbBoard; i++)
        {
            VideoDebugPrint((1, "%d % 7d % 7d 0x%08x 0x%08x 0x%08x\n",i,
                        MgaDeviceExtension->NumberOfModes[i],
                        MgaDeviceExtension->NumberOfValidModes[i],
                        MgaDeviceExtension->ModeFlags2D[i],
                        MgaDeviceExtension->ModeFlags3D[i],
                        MgaDeviceExtension->KernelModeMappedBaseAddress[i],
                        MgaDeviceExtension->pMgaHwModes[i]));

            for (j = 0; j < 64; j+=8)
            {
                VideoDebugPrint((1, "                                                   %02x %02x %02x %02x %02x %02x %02x %02x\n",
                                MgaDeviceExtension->ModeList[i][j],
                                MgaDeviceExtension->ModeList[i][j+1],
                                MgaDeviceExtension->ModeList[i][j+2],
                                MgaDeviceExtension->ModeList[i][j+3],
                                MgaDeviceExtension->ModeList[i][j+4],
                                MgaDeviceExtension->ModeList[i][j+5],
                                MgaDeviceExtension->ModeList[i][j+6],
                                MgaDeviceExtension->ModeList[i][j+7]));
            }
        }
    #endif  // #if DBG

        // Now for the fun part:  find out the resolutions and
        // combinations of resolutions that we can support.

        // First, run through the ModeFlags to determine how many modes
        // we can make up from the single-board modes.

        // For each bit in our ModeFlags...
        NbSuperModes = 0;
        for (i = 0; i < 32; i++)
        {
            // Find out which boards, if any, support this mode.
            CurrentResNbBoards = 0;
            CurrentResNbBoards3D = 0;
            for (n = 0; n < (ULONG)NbBoard; n++)
            {
                ulNb2DRefreshRates = 0;
                ulNb3DRefreshRates = 0;
                us2DRefreshRates = MgaDeviceExtension->ModeFreqs[n][i];
                us3DRefreshRates = MgaDeviceExtension->ModeFreqs[n][i+32];
                for (j = 0; j < 16; j++)
                {
                    if (us2DRefreshRates & (1 << j))
                    {
                        ulNb2DRefreshRates++;
                    }
                    if (us3DRefreshRates & (1 << j))
                    {
                        ulNb3DRefreshRates++;
                    }
                }

                if ((MgaDeviceExtension->ModeFlags2D[n] >> i) & 1)
                {
                    // The mode is supported by the current board.
                    CurrentResNbBoards++;
                    NbSuperModes += (ulNb2DRefreshRates *
                                        MultiModes[CurrentResNbBoards]);
                }

                if ((MgaDeviceExtension->ModeFlags3D[n] >> i) & 1)
                {
                    // The mode is supported by the current board.
                    CurrentResNbBoards3D++;
                    NbSuperModes += (ulNb3DRefreshRates *
                                        MultiModes[CurrentResNbBoards3D]);
                }
            }
        }

        if (NbSuperModes == 0)
        {
            // We did not find any mode!
            status = ERROR_DEV_NOT_EXIST;
            return(status);
        }

        // Now, allocate some memory to hold the new structures.
        MgaDeviceExtension->pSuperModes =
        pCurMulti = (MULTI_MODE*)
                AllocateSystemMemory(NbSuperModes*sizeof(MULTI_MODE));

        if (pCurMulti == NULL)
        {
            // The memory allocation failed.  We won't be able to use
            // our supermode list, so we'll fall back on the single-
            // board code.
            NbSuperModes = 0;
            status = ERROR_NOT_ENOUGH_MEMORY;
            return(status);
        }

        // And we're ready to go!
        ModeInit = 0x00000000;

        pulModeFlags = &MgaDeviceExtension->ModeFlags2D[0];
        ulModeListOffset = 0;

    MTX_INIT_MODE_LIST_LOOP:
        // For each bit in our ModeFlags...
        for (i = 0; i < 32; i++)
        {
            // Find out which boards, if any, support this
            // resolution/pixel-depth.
            CurrentResNbBoards = 0;
            CurrentResFlags = 0;
            k = 0;
            for (n = 0; n < (ULONG)NbBoard; n++)
            {
                CurrentFlag = (pulModeFlags[n] >> i) & 1;
                CurrentResNbBoards += CurrentFlag;
                if (CurrentFlag)
                {
                    // This one is valid.
                    usRefreshRates = MgaDeviceExtension->
                                        ModeFreqs[n][i+ulModeListOffset];
                    CurrentResFlags |= (1 << n);
                    ValidBoard[k++] = (UCHAR)n;
                }
            }

            // Nothing to do if no boards support this combination.
            if (CurrentResNbBoards == 0)
                continue;

            // At least one board supports this resolution/pixel-depth.
            CurrentResWidth = (ULONG)SingleWidths[i%8];
            CurrentResHeight = (ULONG)SingleHeights[i%8];
            CurrentPixWidth = (i/8 + 1)*8;

            ulNbRefreshRates = 0;
            for (j = 0; j < 16; j++)
            {
                if (usRefreshRates & (1 << j))
                {
                    ulNbRefreshRates++;
                }
            }

            ucRefreshBit = 0;
            for (ir = 0; ir < ulNbRefreshRates; ir++)
            {
                while ((usRefreshRates & 1) == 0)
                {
                    usRefreshRates >>= 1;
                    ucRefreshBit++;
                }

                CurrentRefreshRate = (ULONG)ConvBitToFreq(ucRefreshBit);
                usRefreshRates >>= 1;
                ucRefreshBit++;

                // Set the 1x1 display.
                pCurMulti->MulArrayWidth = 1;
                pCurMulti->MulArrayHeight = 1;
                pCurMulti->MulWidth = CurrentResWidth;
                pCurMulti->MulHeight = CurrentResHeight;
                pCurMulti->MulPixWidth = CurrentPixWidth;
                pCurMulti->MulRefreshRate = CurrentRefreshRate;

                // For 1x1, select the VGA-enabled board, if possible.
                if (CurrentResFlags & VGABoardBit)
                {
                    // The VGA-enabled board supports this resolution.
                    pCurMulti->MulBoardNb[0] = (UCHAR)VGABoard;
                }
                else
                {
                    // Otherwise, pick board 0.
                    pCurMulti->MulBoardNb[0] = ValidBoard[0];
                }

                n = pCurMulti->MulBoardNb[0];
                pCurMulti->MulBoardMode[0] =
                                MgaDeviceExtension->ModeList[n]
                                                    [i+ulModeListOffset];

                // Record a pointer to the HwModeData structure.
                pMgaDispMode = MgaDeviceExtension->pMgaHwModes[n];
                pCurMulti->MulHwModes[0] =
                                &pMgaDispMode[pCurMulti->MulBoardMode[0]];

                pCurMulti->MulModeNumber = ModeInit++;
                pCurMulti++;

                if (CurrentResNbBoards == 1)
                    continue;

                // At least two boards support this resolution/pixel-depth.
                // For each number of boards up to the maximum...
                for (k = 2; k <= CurrentResNbBoards; k++)
                {
                    // For each integer up to the maximum...
                    for (m = 1; m <= CurrentResNbBoards; m++)
                    {
                        if ((k % m) == 0)
                        {
                            // We can get a (k/m, m) desktop.
                            pCurMulti->MulArrayHeight = (USHORT)m;
                            pCurMulti->MulHeight = m*CurrentResHeight;

                            pCurMulti->MulArrayWidth = (USHORT)(k/m);
                            pCurMulti->MulWidth = pCurMulti->MulArrayWidth *
                                                        CurrentResWidth;

                            pCurMulti->MulPixWidth = CurrentPixWidth;
                            pCurMulti->MulRefreshRate = CurrentRefreshRate;

                            // Select the boards we'll be using.
                            // Select the VGA-enabled board as the first
                            // board, if possible.  Except for that, we
                            // won't try to place the boards in any
                            // consistent way for now.

                            if (CurrentResFlags & VGABoardBit)
                            {
                                // The VGA-enabled board supports this mode.
                                pCurMulti->MulBoardNb[0] = (UCHAR)VGABoard;

                                ja = 0;
                                for (j = 1; j < k; j++)
                                {
                                    if (ValidBoard[ja] == VGABoard)
                                        ja++;
                                    pCurMulti->MulBoardNb[j] =
                                                        ValidBoard[ja];
                                    ja++;
                                }
                            }
                            else
                            {
                                // The VGA-enabled board won't be involved.
                                for (j = 0; j < k; j++)
                                {
                                    pCurMulti->MulBoardNb[j] =
                                                            ValidBoard[j];
                                }
                            }

                            // For each board...
                            for (j = 0; j < k; j++)
                            {
                                // Record the hardware mode the board
                                // would use.
                                n = pCurMulti->MulBoardNb[j];
                                pCurMulti->MulBoardMode[j] =
                                        MgaDeviceExtension->ModeList[n]
                                                    [i+ulModeListOffset];

                                // Record a ptr to the HwModeData structure.
                                pMgaDispMode =
                                    MgaDeviceExtension->pMgaHwModes[n];
                                pCurMulti->MulHwModes[j] =
                                    &pMgaDispMode[pCurMulti->MulBoardMode[j]];
                            }

                            pCurMulti->MulModeNumber = ModeInit++;
                            pCurMulti++;
                        }   // If it's a valid desktop...
                    }   // For each integer up to the maximum...
                }   // For each number of boards up to the maximum...
            } // For the number of Refresh...
        }   // For each bit in our ModeFlags...

        if (pulModeFlags == &MgaDeviceExtension->ModeFlags2D[0])
        {
            // We just looked at the 2D modes, now look at the 3D modes.
            pulModeFlags = &MgaDeviceExtension->ModeFlags3D[0];
            ulModeListOffset = 32;
            goto MTX_INIT_MODE_LIST_LOOP;
        }

        MgaDeviceExtension->NumberOfSuperModes = NbSuperModes;

        // At this point, we have a table of 'super-modes' (which includes
        // all the regular modes also).  All the modes in this table are
        // supported, and each of them is unique.  MgaDeviceExtension->
        // pSuperModes points to the start of the mode list.  Each entry
        // in the list holds:
        //
        //  MulModeNumber   A unique mode Id
        //  MulWidth        The total width for this mode
        //  MulHeight       The total height for this mode
        //  MulPixWidth     The pixel depth for this mode
        //  MulArrayWidth   The number of boards arrayed along X
        //  MulArrayHeight  The number of boards arrayed along Y
        //  MulBoardNb[n]   The board numbers of the required boards
        //  MulBoardMode[n] The mode required from each board
        //  *MulHwModes[n]  The pointers to the required HwModeData
        //
        // Moreover, MgaDeviceExtension->NumberOfSuperModes holds the
        // number of entries in the list.

        //DbgBreakPoint();

    #if DBG
        // Now display our results...
        VideoDebugPrint((1, "ModeNumber  Width Height  PW   X   Y  n mo    pHwMode\n"));

        pCurMulti = MgaDeviceExtension->pSuperModes;
        for (i = 0; i < NbSuperModes; i++)
        {
            VideoDebugPrint((1, "0x%08x % 6d % 6d % 3d % 3d % 3d\n",
                                                pCurMulti->MulModeNumber,
                                                pCurMulti->MulWidth,
                                                pCurMulti->MulHeight,
                                                pCurMulti->MulPixWidth,
                                                pCurMulti->MulArrayWidth,
                                                pCurMulti->MulArrayHeight));

            j = pCurMulti->MulArrayWidth * pCurMulti->MulArrayHeight;
            for (n = 0; n < j; n++)
            {
                VideoDebugPrint((1, "                                      %d %02x 0x%08x\n",
                                            pCurMulti->MulBoardNb[n],
                                            pCurMulti->MulBoardMode[n],
                                            pCurMulti->MulHwModes[n]));
            }
            pCurMulti++;
        }
    #endif  // #if DBG
    }

    return(status);
}

/*--------------------------------------------------------------------------*\
| VP_STATUS
| MgaSetColorLookup(
|     PMGA_DEVICE_EXTENSION MgaDeviceExtension,
|     PVIDEO_CLUT ClutBuffer,
|     ULONG ClutBufferSize
|     )
|
| Routine Description:
|
|     This routine sets a specified portion of the color lookup table settings.
|
| Arguments:
|
|     HwDeviceExtension - Pointer to the miniport driver's device extension.
|
|     ClutBufferSize - Length of the input buffer supplied by the user.
|
|     ClutBuffer - Pointer to the structure containing the color lookup table.
|
| Return Value:
|
|     None.
|
\*--------------------------------------------------------------------------*/
VP_STATUS
MgaSetColorLookup(
    PMGA_DEVICE_EXTENSION MgaDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )

{
    ULONG   ulVal;
    PUCHAR  pucPaletteDataReg, pucPaletteWriteReg;
    LONG    i, m, n, lNumEntries;

//    DbgBreakPoint();

    // Check if the size of the data in the input buffer is large enough.
    if ( (ClutBufferSize < sizeof(VIDEO_CLUT) - sizeof(ULONG)) ||
         (ClutBufferSize < sizeof(VIDEO_CLUT) +
                     (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)) ) )
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Check to see if the parameters are valid.
    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
                                            VIDEO_MAX_COLOR_REGISTER + 1) )
    {
        return ERROR_INVALID_PARAMETER;
    }

    pucPaletteDataReg =
            (PUCHAR)MgaDeviceExtension->KernelModeMappedBaseAddress[iBoard] +
                                                                PALETTE_DATA;

    pucPaletteWriteReg=
            (PUCHAR)MgaDeviceExtension->KernelModeMappedBaseAddress[iBoard] +
                                                            PALETTE_RAM_WRITE;

    // Set CLUT registers directly on the hardware.
    VideoPortWriteRegisterUchar(pucPaletteWriteReg,
                                            (UCHAR)ClutBuffer->FirstEntry);
    n = 0;
    m = (LONG)ClutBuffer->NumEntries;

    if (pMgaBoardData[iBoard].DacType == DacTypeTVP3026)
    {
        // TVP3026 cursor is very touchy.
#define TVP3026_PAL_BATCH_SIZE  64

        m = TVP3026_PAL_BATCH_SIZE;
        lNumEntries = (LONG)ClutBuffer->NumEntries;

        while ((lNumEntries -= 64) > 0)
        {
            // Wait for VSYNC.
            do
            {
                ulVal = VideoPortReadRegisterUlong((PULONG)
                        ((PUCHAR)pMgaBaseAddr + TITAN_OFFSET + TITAN_STATUS));
            } while (!(ulVal & TITAN_VSYNCSTS_M));

            for (i = n; i < m; i++)
            {
                VideoPortWriteRegisterUchar(pucPaletteDataReg,
                            (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Red);
                VideoPortWriteRegisterUchar(pucPaletteDataReg,
                            (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Green);
                VideoPortWriteRegisterUchar(pucPaletteDataReg,
                            (UCHAR) ClutBuffer->LookupTable[i].RgbArray.Blue);
            }
            n += TVP3026_PAL_BATCH_SIZE;
            m += TVP3026_PAL_BATCH_SIZE;
        }
        m += lNumEntries;

        // Wait for VSYNC.
        do
        {
            ulVal = VideoPortReadRegisterUlong((PULONG)
                        ((PUCHAR)pMgaBaseAddr + TITAN_OFFSET + TITAN_STATUS));
        } while (!(ulVal & TITAN_VSYNCSTS_M));
    }

    for (i = n; i < m; i++)
    {
        VideoPortWriteRegisterUchar(pucPaletteDataReg,
                            ((UCHAR) ClutBuffer->LookupTable[i].RgbArray.Red));
        VideoPortWriteRegisterUchar(pucPaletteDataReg,
                            ((UCHAR) ClutBuffer->LookupTable[i].RgbArray.Green));
        VideoPortWriteRegisterUchar(pucPaletteDataReg,
                            ((UCHAR) ClutBuffer->LookupTable[i].RgbArray.Blue));
    }

    return NO_ERROR;

}   // end MgaSetColorLookup()


VOID MgaSetCursorColour(
    PMGA_DEVICE_EXTENSION MgaDeviceExtension,
    ULONG ulFgColour,
    ULONG ulBgColour)
{
    PUCHAR  pucCursorDataReg, pucCursorWriteReg;
    PUCHAR  pucCmdRegA, pucPixRdMaskReg;
    UCHAR   ucOldCmdRegA, ucOldRdMask;

    VideoDebugPrint((1, "MGA.SYS!MgaSetCursorColour\n"));
//    DbgBreakPoint();

    switch(pMgaBoardData[iBoard].DacType)
    {
        case DacTypeBT485:
        case DacTypePX2085:
            // Set cursor colour for Bt485.
            pucCursorDataReg = (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                                RAMDAC_OFFSET + BT485_COL_OVL;

            pucCursorWriteReg= (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                                RAMDAC_OFFSET + BT485_WADR_OVL;

            VideoPortWriteRegisterUchar(pucCursorWriteReg, 1);

            // Set Background Colour
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>8 & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>16 & 0xFF));

            // Set Foreground Colour
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>8 & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>16 & 0xFF));
            break;

        case DacTypeBT482:
            // Set cursor colour for Bt482.
            pucCursorDataReg = (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                            RAMDAC_OFFSET + BT482_COL_OVL;

            pucCmdRegA  = (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                            RAMDAC_OFFSET + BT482_CMD_REGA;

            pucPixRdMaskReg = (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                            RAMDAC_OFFSET + BT482_PIX_RD_MSK;

            ucOldCmdRegA = VideoPortReadRegisterUchar(pucCmdRegA);
            VideoPortWriteRegisterUchar(pucCmdRegA,
                                (UCHAR) (ucOldCmdRegA | BT482_EXT_REG_EN));

            VideoPortWriteRegisterUchar((PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                            RAMDAC_OFFSET + BT482_WADR_PAL,
                                                            BT482_CUR_REG);

            ucOldRdMask = VideoPortReadRegisterUchar(pucPixRdMaskReg);
            VideoPortWriteRegisterUchar(pucPixRdMaskReg, 0);

            VideoPortWriteRegisterUchar((PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                            RAMDAC_OFFSET + BT482_WADR_OVL,
                                                                        0x11);
            // Set Colour 1
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>8 & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>16 & 0xFF));

            // Set Colour 2
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>8 & 0xFF));
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>16 & 0xFF));

            // Restore old read mask and command register values
            VideoPortWriteRegisterUchar((PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                            RAMDAC_OFFSET + BT482_WADR_PAL,
                                                            BT482_CUR_REG);

            VideoPortWriteRegisterUchar(pucPixRdMaskReg, ucOldRdMask);
            VideoPortWriteRegisterUchar(pucCmdRegA, ucOldCmdRegA);
            break;

        case DacTypeVIEWPOINT:
            // Set cursor colour for ViewPoint
            pucCursorDataReg = (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                                RAMDAC_OFFSET + VPOINT_DATA;
            pucCursorWriteReg= (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                                RAMDAC_OFFSET + VPOINT_INDEX;

            // Set Background Colour
            VideoPortWriteRegisterUchar(pucCursorWriteReg,VPOINT_CUR_COL0_RED);
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorWriteReg,VPOINT_CUR_COL0_GREEN);
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>8 & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorWriteReg,VPOINT_CUR_COL0_BLUE);
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>16 & 0xFF));

            // Set Foreground Colour
            VideoPortWriteRegisterUchar(pucCursorWriteReg,VPOINT_CUR_COL1_RED);
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorWriteReg,VPOINT_CUR_COL1_GREEN);
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>8 & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorWriteReg,VPOINT_CUR_COL1_BLUE);
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>16 & 0xFF));
            break;

        case DacTypeTVP3026:
            // Set cursor colour for TVP3026
            pucCursorDataReg = (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                        RAMDAC_OFFSET + TVP3026_CUR_COL_DATA;
            pucCursorWriteReg= (PUCHAR)MgaDeviceExtension->
                                KernelModeMappedBaseAddress[iBoard] +
                                        RAMDAC_OFFSET + TVP3026_CUR_COL_ADDR;

            // Set Background Colour
            VideoPortWriteRegisterUchar(pucCursorWriteReg,1);
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>8 & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulBgColour>>16 & 0xFF));

            // Set Foreground Colour
            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>8 & 0xFF));

            VideoPortWriteRegisterUchar(pucCursorDataReg,
                                                (UCHAR)(ulFgColour>>16 & 0xFF));
            break;

        default:
            break;
    }
}


#if (_WIN32_WINNT >= 500)

//
// Routine to set a desired DPMS power management state.
//
VP_STATUS
MgaSetPower50(
    PMGA_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}

//
// Routine to retrieve possible DPMS power management states.
//
VP_STATUS
MgaGetPower50(
    PMGA_DEVICE_EXTENSION phwDeviceExtension,
    ULONG HwDeviceId,
    PVIDEO_POWER_MANAGEMENT pVideoPowerMgmt
    )
{
    if ((pVideoPowerMgmt->PowerState == VideoPowerOn) ||
        (pVideoPowerMgmt->PowerState == VideoPowerHibernate)) {

        return NO_ERROR;

    } else {

        return ERROR_INVALID_FUNCTION;
    }
}


//
// Routine to retrieve the Enhanced Display ID structure via DDC
//
ULONG
MgaGetVideoChildDescriptor(
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,
    PVOID pvChildDescriptor,
    PULONG pHwId,
    PULONG pUnused
    )
{
    PMGA_DEVICE_EXTENSION pHwDeviceExtension = HwDeviceExtension;
    ULONG                Status;

    ASSERT(pHwDeviceExtension != NULL && pMoreChildren != NULL);

    VideoDebugPrint((2, "mga.SYS mgaGetVideoChildDescriptor: *** Entry point ***\n"));

    //
    // Determine if the graphics adapter in the system supports
    // DDC2 (our miniport only supports DDC2, not DDC1). This has
    // the side effect (assuming both monitor and card support
    // DDC2) of switching the monitor from DDC1 mode (repeated
    // "blind" broadcast of EDID clocked by the vertical sync
    // signal) to DDC2 mode (query/response not using any of the
    // normal video lines - can transfer information rapidly
    // without first disrupting the screen by switching into
    // a pseudo-mode with a high vertical sync frequency).
    //
    // Since we must support hot-plugging of monitors, and our
    // routine to obtain the EDID structure via DDC2 assumes that
    // the monitor is in DDC2 mode, we must make this test each
    // time this entry point is called.
    //

    switch (ChildEnumInfo->ChildIndex) {
    case 0:

        //
        // Case 0 is used to enumerate devices found by the ACPI firmware.
        //
        // Since we do not support ACPI devices yet, we must return failure.
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case 1:
        //
        // We do not support monitor enumeration
        //

        Status = ERROR_NO_MORE_DEVICES;
        break;

    case DISPLAY_ADAPTER_HW_ID:
        {

        PUSHORT     pPnpDeviceDescription = NULL;
        ULONG       stringSize = sizeof(L"*PNPXXXX");

        //
        // Special ID to handle return legacy PnP IDs for root enumerated
        // devices.
        //

        *pChildType = VideoChip;
        *pHwId      = DISPLAY_ADAPTER_HW_ID;

        //
        //  Figure out which card type and set pPnpDeviceDescription at
        //  associated string.
        //

        if (pHwDeviceExtension->BoardId == TYPE_QVISION_PCI)
            pPnpDeviceDescription = L"*PNP0919";
        else
            pPnpDeviceDescription = L"*PNP0918";

        //
        //  Now just copy the string into memory provided.
        //

        if (pPnpDeviceDescription)
            memcpy(pvChildDescriptor, pPnpDeviceDescription, stringSize);

        Status = ERROR_MORE_DATA;
        break;
        }

    default:

        Status = ERROR_NO_MORE_DEVICES;
        break;
    }


    return Status;
}

#endif  // _WIN32_WINNT >= 500
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\getcfg.c ===
/*/****************************************************************************
*          name: GetMGAConfiguration
*
*   description: This function will read the strappings of the specified MGA
*                device from the Titan DSTi1-0 registers (with the PATCH).
*                Also this function will return a DAC id and some other
*                relevent informations.
*
*      designed: Bart Simpson, february 10, 1993
* last modified: $Author: ctoutant $, $Date: 94/06/14 13:05:50 $
*
*       version: $Id: GETCFG.C 1.17 94/06/14 13:05:50 ctoutant Exp $
*
*    parameters: _Far BYTE *pMGA, DWORD* DST1, DWORD* DST0, DWORD* Info
*      modifies: *DST1, *DST0, *Info
*         calls: -
*       returns: DST0, DST1, Info
*
*
* NOTE: DST1, DST0 are in Titan format.
*
*       Info is 0x uuuu uuuu uuuu uuuu uuuu uuuu uuuu dddd
*
*            dddd : 2 MSB are DAC extended id
*                   2 LSB are DAC DUBIC id
*
*            0000 : BT481
*            0100 : BT482
*            1000 : ATT
*            1100 : Sierra
*
*            0001 : ViewPoint
*
*            0010 : BT484
*            0110 : BT485
*
*            0111 : PX2085
*
*            0011 : Chameleon
*
******************************************************************************/


#define DEBUG_OUTPUT 0

#include "switches.h"
#include "g3dstd.h"

#include "caddi.h"
#include "def.h"
#include "mga.h"

#include "global.h"
#include "proto.h"

#include "mgai.h"

#if DEBUG_OUTPUT
extern VOID printf();
#endif

#ifdef WINDOWS_NT

#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,GetMGAConfiguration)
#endif

#if defined(ALLOC_PRAGMA)
    #pragma data_seg("PAGE")
#endif

#include "video.h"

#endif  /* #ifdef WINDOWS_NT */


VOID GetMGAConfiguration(volatile BYTE _Far *pDevice, DWORD *DST0, DWORD *DST1, DWORD *Info)
{
 DWORD TmpDword;
 BYTE  reg0, TmpByte, TmpByte1, TmpByte2, FifoCount;
 BYTE  DacDetected;
 static DWORD DST0Cache, DST1Cache, InfoCache;
 static BOOL CacheFlag=FALSE;


 if (0)
    {
    *DST0 = DST0Cache;
    *DST1 = DST1Cache;
    *Info = InfoCache;
    }
 else
    {
      { DWORD Opmode, SrcPage;

      /*** Apply the patch procedure to get the straps in the DST1 and DST0 ***/

      /** Wait until the FIFO is empty, Then we're sure that the Titan
      *** is ready to process the DATA transfers.
      **/

      FifoCount = 0;
      while (FifoCount < 32)
         mgaReadBYTE(*(pDevice + TITAN_OFFSET+TITAN_FIFOSTATUS),FifoCount);

      /* Wait for the drawing engine to be idle */
      mgaPollBYTE(*(pDevice + TITAN_OFFSET + TITAN_STATUS + 2),0x00,0x01);


      mgaReadDWORD(*(pDevice + TITAN_OFFSET + TITAN_OPMODE),  Opmode);
      mgaReadDWORD(*(pDevice + TITAN_OFFSET + TITAN_SRCPAGE), SrcPage);

      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_OPMODE),   Opmode & ~((DWORD)TITAN_FBM_M | (DWORD)TITAN_PSEUDODMA_M));
      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_MCTLWTST), 0xffffffff);
      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_SRCPAGE),  0x00f80000);

      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      mgaReadDWORD(*(pDevice + SRC_WIN_OFFSET), TmpDword);
      TmpDword = TmpDword;

      mgaReadDWORD(*(pDevice + TITAN_OFFSET + TITAN_DST0), (*DST0));
      mgaReadDWORD(*(pDevice + TITAN_OFFSET + TITAN_DST1), (*DST1));

      /*** Reset Opmode with pseudo-dma off first and then to its previous state ***/

      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_OPMODE),   Opmode & ~((DWORD)TITAN_PSEUDODMA_M));
      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_OPMODE),   Opmode);
      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_MCTLWTST), GetMGAMctlwtst(*DST0, *DST1));
      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_SRCPAGE),  SrcPage);
      }


   #if DEBUG_OUTPUT
   printf ("DST0=%lx, DST1=%lx\n", *DST0, *DST1);
   #endif




      /** Because the Titan DSTi0-1 spec has changed after the binding
      *** developpement (i.e. the rambank[0] bit has moved from bit 0 of DST0
      *** to bit 3 of DST1) we duplicate the DST1[3] to DST0[24] because the
      *** binding has nothing to do with the new VGA BANK 0 bit
      **/
   
      /*** Clear bit rambank 0 ***/
      (*DST0) &= ~((DWORD)0x1 << TITAN_DST0_RAMBANK_A);

      /*** DUPLICATE ***/
      (*DST0) |= ((((*DST1) & (DWORD)TITAN_DST1_RAMBANK0_M) >> TITAN_DST1_RAMBANK0_A) << TITAN_DST0_RAMBANK_A);


      /***** DETECT DAC TYPE *****/
      mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), TmpByte2);
      mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX),VPOINT_ID);
      mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), TmpByte);
      if (TmpByte == 0x20)
         DacDetected = (BYTE)Info_Dac_ViewPoint;
      else
       {
       mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX),TmpByte2);
       mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX),TVP3026_ID);
       mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), TmpByte);
       if (TmpByte == 0x26)
          DacDetected = (BYTE)Info_Dac_TVP3026;
       else
         {
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_WADR_PAL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_PIX_RD_MSK), 0xff);
         mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + BT485_STATUS), TmpByte);

         if ((TmpByte & (BYTE)ATT20C505_ID_M) == (BYTE)ATT20C505_ID)
            DacDetected = (BYTE)Info_Dac_ATT2050;
         else
            {
/*** BEN TEST SPECIAL NE VEUT PAS ENTRER DANS CE IF ***/            
            if ((TmpByte & (BYTE)BT485_ID_M) == (BYTE)0x77)
/*            if ((TmpByte & (BYTE)BT485_ID_M) == (BYTE)BT485_ID) */
               DacDetected = (BYTE)Info_Dac_BT485;
            else
               if ((TmpByte & (BYTE)BT484_ID_M) == (BYTE)BT484_ID)
                  DacDetected = (BYTE)Info_Dac_BT484;
               else
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CUR_XLOW),0x00);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_WADR_OVL),0x55);
                  mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CUR_XLOW), TmpByte);
                  if (TmpByte == 0x55)
                     DacDetected = (BYTE)Info_Dac_BT482;    /* SIERRA */
                  else
                     {
                     /*** Procedure to detect CL_PX2085 ***/
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG0),0x82);

                     /*** Set index register ***/
                     mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + BT485_STATUS),TmpByte2);
                     TmpByte = TmpByte2 & 0x0f;
                     TmpByte |= 0x40;
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_STATUS),TmpByte);

                     mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG0),reg0);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG0),0x02);

                     /*** Set direct register ***/
                     mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + BT485_STATUS),TmpByte1);
                     TmpByte = TmpByte & 0x0f;
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_STATUS),TmpByte);

                     mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG0),TmpByte);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_STATUS),TmpByte1);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG0),reg0);
                     mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_STATUS),TmpByte2);

                     if(TmpByte == 0x82)
                        DacDetected = (BYTE)Info_Dac_PX2085;
                     else
                        DacDetected = (BYTE)Info_Dac_BT485;    /* other DAC same as BT485 */


                     }
                  }
            }
         }

       }

      *Info = (DWORD)DacDetected;

      DST0Cache = *DST0;
      DST1Cache = *DST1;
      InfoCache = *Info;
      CacheFlag = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\fixed.c ===
/*/****************************************************************************
*          name: fixed.c
*
*   description: 
*
*      designed: Benoit Leblanc
* last modified: $Author: bleblanc $, $Date: 94/06/23 13:00:39 $
*
*       version: $Id: fixed.c 1.2 94/06/23 13:00:39 bleblanc Exp $
*
*
* void mtxSetDisplayStart(dword x, dword y)
* void AdjustDBWindow(void)
*
******************************************************************************/

#include "switches.h"

#ifdef WINDOWS_NT

    #if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,mtxSetDisplayStart)
    #endif

#endif    /* #ifdef WINDOWS_NT */

#ifdef OS2
    #include <os2.h>
    #pragma intrinsic(strcat, strcpy)
#endif


#ifdef WINDOWS
   #include "windows.h"               
#endif


#include "bind.h"
#include "defbind.h"
#include "sxci.h"
#include "def.h"
#include "mga.h"
#include "mgai_c.h"
#include "mgai.h"


#ifdef _WINDOWS_DLL16

   /*** Definition for pool memory ***/
   #define PAN_X            0
   #define PAN_Y            1
   #define PAN_DISP_WIDTH   2
   #define PAN_DISP_HEIGHT  3
   #define DB_SCALE         4
   #define PAN_BOUND_LEFT   5
   #define PAN_BOUND_TOP    6
   #define PAN_BOUND_RIGHT  7
   #define PAN_BOUND_BOTTOM 8


   extern   word NbSxciLoaded;
   extern word FAR *pDllMem;
   void AdjustDBWindow(void);
#endif


#ifdef WINDOWS_NT
   PUCHAR   pMgaBaseAddr;
#else
   extern volatile byte _Far *pMgaBaseAddr;
#endif

extern byte iBoard;
extern HwData Hw[NB_BOARD_MAX+1];
extern dword ProductMGA[NB_BOARD_MAX];
extern byte VideoBuf[NB_BOARD_MAX][VIDEOBUF_S];


/*----------------------------------------------------------
* mtxSetDisplayStart
*
* Set the display start address
*
* This function sets the video display start address. This is
* useful for scrolling and panning within the frame buffer.
* Although any X coordinate will be accepted by this function,
* it will be rounded to the nearest 16-pixel boundary (this
* 16 pixel boundary is a hardware restriction). There is no
* restriction on the y coordinate values that can be used as
* the video display start.
* It is up to the user to be sure that he remains within the
* limits of the available frame buffer.
*
*----------------------------------------------------------*/

void mtxSetDisplayStart(dword x, dword y)
{
   byte ValExt;
   dword Addr, PhysAddr;
   dword StartBank=0;
   byte ByteCount, TmpByte, DUB_SEL;
   dword TmpDword;


   Hw[iBoard].CurrentXStart = x;
   Hw[iBoard].CurrentYStart = y;

   /* PACK PIXEL */
   if (Hw[iBoard].pCurrentHwMode->PixWidth == 24) /* PACK PIXEL */
      x = ((x * 3) >> 2) + (Hw[iBoard].YDstOrg >> 2);
   else
      x = x + Hw[iBoard].YDstOrg;

   {
   word PixByte;

   if (Hw[iBoard].pCurrentHwMode->PixWidth == 24) /* PACK PIXEL */
      PixByte = 32;
   else
      PixByte = Hw[iBoard].pCurrentHwMode->PixWidth;

   if(PixByte == 15)
      PixByte = 16;
   PixByte /= 8;

   if (Hw[iBoard].pCurrentHwMode->PixWidth == 24) /* PACK PIXEL */
      PhysAddr = ((y * ((Hw[iBoard].pCurrentHwMode->FbPitch * 3) >> 2)) + x) * PixByte;
   else
      PhysAddr = ((y * Hw[iBoard].pCurrentHwMode->FbPitch) + x) * PixByte;
   }

   switch (ProductMGA[iBoard])
      {
      case MGA_ULT_1M:
      case MGA_ULT_2M:
      case MGA_PCI_2M:
         StartBank = 0;
         break;

      case MGA_IMP_3M:
         if (PhysAddr < 2097152)
            StartBank = 0;
         else if (PhysAddr < 3145728)
            StartBank = 1;
         break;

      case MGA_IMP_3M_Z:
         if (PhysAddr < 524288)
            StartBank = 0;
         else if (PhysAddr < 2621440)
            StartBank = 1;
         break;

      case MGA_PRO_4M5:
      case MGA_PRO_4M5_Z:
         if (PhysAddr < 2097152)
            StartBank = 0;
         else if (PhysAddr < 4194304)
            StartBank = 1;
         else if (PhysAddr < 6291456)
            StartBank = 2;
         break;

      case MGA_PCI_4M:
         if (PhysAddr < 2097152)
            StartBank = 0;
         else
            StartBank = 1;
         break;

      default:
         StartBank = 0;
      }



      /*** ACCESS TO DUBIC : We program the start bank ***/

      /*** ----- DUBIC PATCH Disable mouse IRQ and proceed ------ ***/
      mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
      mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
      mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), 0x00);
      /*** ------------------------------------------------------ ***/

      mgaWriteBYTE(*(pMgaBaseAddr+DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DUB_CTL);
      for (TmpDword = 0, ByteCount = 0; ByteCount <= 3; ByteCount++)
         {
         mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), TmpByte);
         TmpDword |= ((dword)TmpByte << (8 * ByteCount));
         }

      TmpDword &= ~DUBIC_START_BK_M;
      TmpDword |= StartBank << DUBIC_START_BK_A;

      mgaWriteBYTE(*(pMgaBaseAddr+DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DUB_CTL);
      for (ByteCount = 0; ByteCount <= 3; ByteCount++)
         {
         TmpByte = (byte)(TmpDword >> (8 * ByteCount));
         mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), TmpByte);
         }

      /*** ----- DUBIC PATCH ReEnable mouse IRQ ----------------- ***/
      mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
      mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
      /*** ------------------------------------------------------ ***/



   /* Adjusting x to 16-bit boundary */
      if (Hw[iBoard].pCurrentHwMode->PixWidth != 24) /* PACK PIXEL */
         x = x & 0xfffffff0;

#ifdef _WINDOWS_DLL16
   if(NbSxciLoaded)
      {
      *(pDllMem+PAN_X) = (word)x;
      *(pDllMem+PAN_Y) = (word)y;

      AdjustDBWindow();
      }
#endif

   if (Hw[iBoard].pCurrentHwMode->PixWidth == 24)
      Addr = (y * ( ((Hw[iBoard].pCurrentHwMode->DispWidth * 3) >> 2) / 8)) + (x/8);
   else
      Addr = (y * (Hw[iBoard].pCurrentHwMode->DispWidth / 8)) + (x/8);


   mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + VGA_CRTC_INDEX), VGA_START_ADDRESS_LOW);

   mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + VGA_CRTC_DATA), (byte)Addr);

   mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + VGA_CRTC_INDEX), VGA_START_ADDRESS_HIGH);

   mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + VGA_CRTC_DATA), (byte)(Addr >> 8));

   mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + VGA_AUXILIARY_INDEX), VGA_CRTC_EXTENDED_ADDRESS);

   mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + VGA_AUXILIARY_DATA), ValExt);

   ValExt = (ValExt & 0xfc) | ((byte)((Addr&0x00030000) >> 16));

   mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + VGA_AUXILIARY_DATA), ValExt);
}




#ifdef _WINDOWS_DLL16 
/* IFDEF ADDED BY C. Toutant */

/*----------------------------------------------------------
* AdjustDBWindow
*
* Adjust the double buffering window
*
*----------------------------------------------------------*/

void AdjustDBWindow(void)
{
short DBXMin,DBXMax,DBYMin,DBYMax;
WORD PorchX, PorchY;
bool OutFlag;
byte DUB_SEL;
word Width, Height;
word xPan, yPan;
word Scale;
static word Cpt3Times;
word BoxLeft, BoxTop, BoxRight, BoxBottom;


   OutFlag = FALSE;

   xPan = *(pDllMem+PAN_X);
   yPan = *(pDllMem+PAN_Y);


   BoxLeft   = *(pDllMem+PAN_BOUND_LEFT)   - *(pDllMem+PAN_X);
   BoxTop    = *(pDllMem+PAN_BOUND_TOP)    - *(pDllMem+PAN_Y);
   BoxRight  = *(pDllMem+PAN_BOUND_RIGHT)  - *(pDllMem+PAN_X);
   BoxBottom = *(pDllMem+PAN_BOUND_BOTTOM) - *(pDllMem+PAN_Y);


   Scale = *(pDllMem+DB_SCALE);


   Width = *(pDllMem+PAN_DISP_WIDTH) / Scale;
   Height = *(pDllMem+PAN_DISP_HEIGHT) / Scale;


   PorchX = *((WORD*)(VideoBuf[iBoard] + VIDEOBUF_DBWinXOffset)) / Scale;
   PorchY = *((WORD*)(VideoBuf[iBoard] + VIDEOBUF_DBWinYOffset)) / Scale;


   DBXMin = BoxLeft + PorchX;
   if((short)DBXMin < (short)PorchX)
      DBXMin = PorchX;
   if((short)DBXMin > (short)PorchX + Width)
      OutFlag = TRUE;


   DBXMax = BoxRight + PorchX;
   if((short)DBXMax < (short)PorchX)
      OutFlag = TRUE;
   if((short)DBXMax > (short)(PorchX + Width))
       DBXMax = PorchX + Width;


   DBYMin = BoxTop + PorchY;
   if((short)DBYMin < (short)PorchY)
      DBYMin = PorchY;
   if((short)DBYMin > (short)(PorchY + Height))
      OutFlag = TRUE;


   DBYMax = BoxBottom + PorchY;
   if((short)DBYMax < (short)PorchY)
      OutFlag = TRUE;
   if((short)DBYMax > (short)(PorchY + Height))
      DBYMax = PorchY + Height;



   DBYMin = DBYMin * Scale;
   DBYMax = DBYMax * Scale;


   if(OutFlag == TRUE)
      {
      DBXMin = 0;
      DBYMin = 0;
      DBXMax = 0;
      DBYMax = 0;
      }


   /*** ----- DUBIC PATCH Disable mouse IRQ and proceed ------ ***/
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
   mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), 0x00);
   /*** ------------------------------------------------------ ***/


   /*** WRITE ***/

   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DBX_MIN);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)DBXMin);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)(DBXMin >> 8));

   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DBY_MIN);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)DBYMin);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)(DBYMin >> 8));

   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DBX_MAX);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)DBXMax);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)(DBXMax >> 8));

   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DBY_MAX);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)DBYMax);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), (BYTE)(DBYMax >> 8));


   /*** ----- DUBIC PATCH ReEnable mouse IRQ ----------------- ***/
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
   /*** ------------------------------------------------------ ***/

}
#endif  /* #ifdef _WINDOWS_DLL16 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\enc_reg.h ===
typedef struct 
   {
   byte dencReg[DENC_NBRE_REG];
   word psgReg[PSG_NBRE_REG];
   byte dacReg[DAC_NBRE_REG];
   byte adcReg[ADC_NBRE_REG];
   word boardCtrlReg;
   word boardIdReg;
   } EncReg;

EncReg ntsc8_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x71 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xf2 , 0x00 , 0x1c , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x020c , 0x0206 , 0x0025 , 0x0021 , 0x030b , 
    0x02f2 , 0x0072 , 0x0048 , 0x0000 , 0x0009 , 0x0000 , 0x0300 , 0x030b , 
    0x0062 , 0x0013 , 0x0023 , 0x0205 , 0x0049 , 0x0283 , 0x0124 
    },
    {
    0x01 , 0xff , 0xff , 0x01 , 0x01 , 0xff , 0x82 , 0x01 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xc4 , 0x00 , 0xfc 
    },
    0x04607,
    0x00058
};

EncReg ntsc16_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x70 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xf2 , 0x00 , 0x1c , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x020c , 0x0206 , 0x0025 , 0x0021 , 0x030b , 
    0x02f2 , 0x0072 , 0x0046 , 0x0000 , 0x0009 , 0x0000 , 0x0300 , 0x030b , 
    0x0062 , 0x0013 , 0x0023 , 0x0205 , 0x00d4 , 0x02fa , 0x0015 
    },
    {
    0x00 , 0xff , 0xff , 0x00 , 0x00 , 0xff , 0x82 , 0x00 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xc4 , 0x00 , 0xfc 
    },
    0x04607,
    0x00058
};


EncReg ntsc32_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x70 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xf2 , 0x00 , 0x1c , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x020c , 0x0206 , 0x0025 , 0x0021 , 0x030b , 
    0x02f2 , 0x0072 , 0x0044 , 0x0000 , 0x0009 , 0x0000 , 0x0300 , 0x030b , 
    0x0062 , 0x0013 , 0x0023 , 0x0205 , 0x01fa , 0x02ed , 0x0008 
    },
    {
    0x00 , 0xff , 0xff , 0x00 , 0x00 , 0xff , 0x82 , 0x00 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xc4 , 0x00 , 0xfc 
    },
    0x04607,
    0x00058
};


 EncReg ntsca_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x71 , 0x21 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0x1b , 0x00 , 0x1c , 0x00 
    },
    {
    0x01c2 , 0x0010 , 0x0003 , 0x020c , 0x0206 , 0x0025 , 0x0021 , 0x030b , 
    0x02f2 , 0x0072 , 0x0040 , 0x0000 , 0x0009 , 0x0000 , 0x0300 , 0x030b , 
    0x002b , 0x0093 , 0x0026 , 0x0205 , 0x0057 , 0x01e8 , 0x0089 
    },
    {
    0x00 , 0xff , 0xff , 0x00 , 0x00 , 0xff , 0x82 , 0x00 , 
    0x00 , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xcc , 0x00 , 0xfc 
    },
    0x04606,
    0x00058
};


/* ----- Mode PAL */

EncReg pal8_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x70 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xf2 , 0x00 , 0x12 , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x0270 , 0x026b , 0x002a , 0x0026 , 0x03af , 
    0x0399 , 0x0099 , 0x004f , 0x0000 , 0x0009 , 0x0000 , 0x03a0 , 0x03af , 
    0x0062 , 0x0013 , 0x0023 , 0x0269 , 0x0124 , 0x01c4 , 0x001c 
    },
    {
    0x00 , 0xff , 0xff , 0x00 , 0x00 , 0xff , 0x82 , 0x00 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xc4 , 0x00 , 0xfc 
    },
    0x04605,
    0x00058
};

EncReg pal16_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x70 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xf2 , 0x00 , 0x12 , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x0270 , 0x026b , 0x002a , 0x0026 , 0x03af , 
    0x0399 , 0x0099 , 0x004d , 0x0000 , 0x0009 , 0x0000 , 0x03a0 , 0x03af , 
    0x0062 , 0x0013 , 0x0023 , 0x0269 , 0x0037 , 0x02f4 , 0x014a 
    },
    {
    0x00 , 0xff , 0xff , 0x00 , 0x00 , 0xff , 0x82 , 0x00 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xc4 , 0x00 , 0xfc 
    },
    0x04605,
    0x00058
};


EncReg pal32_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x71 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xf2 , 0x00 , 0x12 , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x0270 , 0x026b , 0x002a , 0x0026 , 0x03af , 
    0x0399 , 0x0099 , 0x004b , 0x0000 , 0x0009 , 0x0000 , 0x03a0 , 0x03af , 
    0x0062 , 0x0013 , 0x0023 , 0x0269 , 0x0253 , 0x02ac , 0x0102 
    },
    {
    0x00 , 0xff , 0xff , 0x00 , 0x00 , 0xff , 0x82 , 0x00 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xc4 , 0x00 , 0xfc 
    },
    0x04605,
    0x00058
};


EncReg pala_0 = {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x70 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xf2 , 0x00 , 0x12 , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x0270 , 0x026b , 0x002a , 0x0026 , 0x03af , 
    0x0399 , 0x0099 , 0x0046 , 0x0000 , 0x0009 , 0x0000 , 0x03a0 , 0x03af , 
    0x004b , 0x0013 , 0x0023 , 0x0269 , 0x01aa , 0x0120 , 0x014e 
    },
    {
    0x00 , 0xff , 0xff , 0x00 , 0x00 , 0xff , 0x82 , 0x00 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x48 
    },
    {
    0x31 , 0xc4 , 0x00 , 0xfc 
    },
    0x0464c,
    0x00058
};


EncReg ntsc_1= {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x70 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xef , 0x00 , 0x1c , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x020c , 0x0200 , 0x0021 , 0x001c , 0x030b , 
    0x02e8 , 0x0068 , 0x003b , 0x0000 , 0x003b , 0x0000 , 0x0300 , 0x0058 , 
    0x0067 , 0x02e8 , 0x0021 , 0x0200 , 0x015f , 0x0147 , 0x016a 
    },
    {
    0x01 , 0xfe , 0xff , 0x01 , 0x01 , 0xff , 0x82 , 0x01 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x00 
    },
    {
    0x31 , 0xd0 , 0x00 , 0xfc 
    },
    0x04e4b,
    0x00059
};


EncReg  pal_1= {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x70 , 0x30 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0x20 , 0x00 , 0x12 , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x0270 , 0x026a , 0x002b , 0x0026 , 0x03af , 
    0x037a , 0x007a , 0x002d , 0x0000 , 0x0032 , 0x0004 , 0x03a0 , 0x004a , 
    0x0079 , 0x037a , 0x002b , 0x026a , 0x0043 , 0x0199 , 0x01c6 
    },
    {
    0x01 , 0xfe , 0xff , 0x01 , 0x01 , 0xff , 0x82 , 0x01 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x00 
    },
    {
    0x31 , 0xd0 , 0x00 , 0xfc 
    },
    0x04e49,
    0x00059
};


EncReg ntsca_1= {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x71 , 0x35 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0xef , 0x00 , 0x1c , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x020c , 0x0200 , 0x0021 , 0x001c , 0x030b , 
    0x02e8 , 0x0068 , 0x0037 , 0x0000 , 0x003b , 0x0000 , 0x0300 , 0x0058 , 
    0x0067 , 0x02e8 , 0x0021 , 0x0200 , 0x01dc , 0x0167 , 0x0006 
    },
    {
    0x01 , 0xfe , 0xff , 0x01 , 0x01 , 0xff , 0x82 , 0x01 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x00 
    },
    {
    0x31 , 0xd0 , 0x00 , 0xfc 
    },
    0x04e4a,
    0x00059
};

EncReg pala_1= {
    {
    0x55 , 0xff , 0x00 , 0x00 , 0x71 , 0x30 , 
    0x52 , 0x3f , 0x10 , 0x00 , 0x00 , 0x00 , 
    0x20 , 0x00 , 0x12 , 0x00 
    },
    {
    0x01c2 , 0x0000 , 0x0003 , 0x0270 , 0x026a , 0x002b , 0x0026 , 0x03af , 
    0x037a , 0x007a , 0x0029 , 0x0000 , 0x0032 , 0x0004 , 0x03a0 , 0x004a , 
    0x0079 , 0x037a , 0x002b , 0x026a , 0x0057 , 0x02ed , 0x0145 
    },
    {
    0x01 , 0xfe , 0xff , 0x01 , 0x01 , 0xff , 0x82 , 0x01 , 
    0x0c , 0x20 , 0x48 , 0xea , 0x31 , 0x0c , 0xfc , 0x0c , 
    0x00 
    },
    {
    0x31 , 0xd0 , 0x00 , 0xfc 
    },
    0x04e48,
    0x00059
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\global.h ===
/*/****************************************************************************
*          name: global.h
*
*   description: Contains all the "extern" variables declarations
*
*      designed: g3d_soft
* last modified: $Author: bleblanc $, $Date: 94/11/09 10:45:44 $
*
*       version: $Id: GLOBAL.H 1.18 94/11/09 10:45:44 bleblanc Exp $
*
******************************************************************************/

/*** Declare the TARGET for mgai ***/

#include "mgai_c.h"

/*** Definition of macro _Far ***/
#ifdef __WATCOMC__
#define _Far _far
#endif

/*** Configuration for compatibility with ASM ***/

#ifdef __HC303__

#ifdef __ANSI_C__
/*** Configuration for compatibility with ASM ***/
#pragma Off(Args_in_regs_for_locals);
#else
/*** Configuration for compatibility with ASM ***/
pragma Off(Args_in_regs_for_locals);
#endif

#endif

#ifdef __HC173__

#ifdef __ANSI_C__
/*** Optimizations turned off ***/
#pragma Off(Optimize_xjmp);
#pragma Off(Optimize_fp);
#pragma Off(Auto_reg_alloc);
#pragma Off(Postpone_arg_pops);
#else
/*** Optimizations turned off ***/
pragma Off(Optimize_xjmp);
pragma Off(Optimize_fp);
pragma Off(Auto_reg_alloc);
pragma Off(Postpone_arg_pops);
#endif

#endif


#ifndef __DDK_SRC__  /* - - - - - - - - - - - - - - - - - - - - - - - - -  */


/*** OPCODES ***/

extern VOID (*(*(*OpGroupTable[])[])())();

/*** DECODER for functions setENV??? ***/

extern BYTE    *pCurrentRC;               /*** Ptr to the current RC ***/
extern WORD    CurrentOpcode;
extern BYTE    *pCurrentBuffer;           /*** Ptr to current input buffer **/
extern BYTE    *pBufferError;

/*** ENVIRONNEMENT ***/

extern BYTE    *pCurrentEnvRC;
extern DWORD   CurrentEnvOpcode;
extern BYTE    CurrentEnvSystem[32];

/*** MGA MAPPING ***/

extern volatile BYTE _Far *pMgaBaseAddress;

extern DWORD MgaOffset;
extern WORD MgaSegment;

/*** SystemConfig ***/

extern BYTE SystemConfig[];

/*** InitRC ***/

extern BYTE DefaultRC[];
extern BYTE DefaultClipList[];
extern BYTE DefaultLSDB[];

/*** General ***/

extern DWORD CacheMaccess;
extern DWORD CacheYDstOrg;

extern BYTE  *pDefaultClipRect;
extern BYTE  *pClipRectList;
extern BYTE  *pRC_DBWindowOwner;
extern WORD  ZMSK_Default;
extern WORD  ZMSK_Specific3D;
extern BYTE  VertexCache[];
extern BYTE  PseudoDMA;

/*** ClearWS ***/

extern BYTE ClearWS[];
extern BYTE LightWS[];


#else /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

#ifdef __MICROSOFTC600__
      #define _Far far
#endif


/*** ENVIRONNEMENT ***/

extern BYTE    CurrentEnvSystem[32];



/*** MGA MAPPING ***/

/* from INIT_DDK.C or GLOBAL.ASM */
extern volatile BYTE _Far *pMgaBaseAddress;


/*** SystemConfig ***/

extern BYTE SystemConfig[];


/*** General ***/

extern DWORD CacheMaccess;


#endif /*  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mgai_c.h ===
#define MGA_INTERFACE_MGA TRUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mgainfo.c ===
/**************************************************************************\

$Header:$

$Log:$

\**************************************************************************/

#include "switches.h"

#ifdef WINDOWS_NT

    #if defined(ALLOC_PRAGMA)
    #pragma data_seg("PAGE")
    #endif

UCHAR DefaultVidset[] = {

#else   /* #ifdef WINDOWS_NT */

char DefaultVidset[] = {

#endif  /* #ifdef WINDOWS_NT */

0x4d, 0x61, 0x74, 0x72, 0x6f, 0x78, 0x20, 0x4d, 0x47, 0x41, 0x20, 0x53,
0x65, 0x74, 0x75, 0x70, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x00, 0x96, 0x80,
0x00, 0x00, 0x00, 0x00, 0x63, 0x34, 0x94, 0x80, 0x66, 0x00, 0x30, 0x00,
0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00,
0x00, 0xc0, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x75,
0x6c, 0x74, 0x69, 0x2d, 0x66, 0x72, 0x65, 0x71, 0x20, 0x75, 0x70, 0x20,
0x74, 0x6f, 0x20, 0x31, 0x36, 0x30, 0x30, 0x20, 0x58, 0x20, 0x31, 0x32,
0x30, 0x30, 0x20, 0x40, 0x36, 0x30, 0x48, 0x7a, 0x20, 0x6f, 0x6e, 0x20,
0x2f, 0x32, 0x2b, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x19, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x21, 0x24, 0x94, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x08, 0x00,
0x6c, 0x6b, 0x00, 0x00, 0x80, 0x02, 0x20, 0x00, 0x60, 0x00, 0x60, 0x00,
0x00, 0x00, 0xe0, 0x01, 0x08, 0x00, 0x06, 0x00, 0x24, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x00, 0x00, 0x10, 0x00, 0x6c, 0x6b, 0x00, 0x00, 0x80, 0x02, 0x20, 0x00,
0x60, 0x00, 0x60, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x08, 0x00, 0x06, 0x00,
0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x20, 0x00, 0x6c, 0x6b, 0x00, 0x00,
0x80, 0x02, 0x20, 0x00, 0x60, 0x00, 0x60, 0x00, 0x00, 0x00, 0xe0, 0x01,
0x08, 0x00, 0x06, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x08, 0x00,
0x34, 0x9e, 0x00, 0x00, 0x20, 0x03, 0x20, 0x00, 0x80, 0x00, 0x80, 0x00,
0x00, 0x00, 0x58, 0x02, 0x02, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x01, 0x00, 0x10, 0x00, 0x34, 0x9e, 0x00, 0x00, 0x20, 0x03, 0x20, 0x00,
0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x58, 0x02, 0x02, 0x00, 0x04, 0x00,
0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x20, 0x00, 0x34, 0x9e, 0x00, 0x00,
0x20, 0x03, 0x20, 0x00, 0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x58, 0x02,
0x02, 0x00, 0x04, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x08, 0x00,
0xe8, 0xfd, 0x00, 0x00, 0x00, 0x04, 0x20, 0x00, 0x80, 0x00, 0xa0, 0x00,
0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x06, 0x00, 0x1d, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x02, 0x00, 0x10, 0x00, 0xe8, 0xfd, 0x00, 0x00, 0x00, 0x04, 0x20, 0x00,
0x80, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x06, 0x00,
0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x20, 0x00, 0xe8, 0xfd, 0x00, 0x00,
0x00, 0x04, 0x20, 0x00, 0x80, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x03,
0x03, 0x00, 0x06, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x08, 0x00,
0x74, 0x3a, 0x01, 0x00, 0x80, 0x04, 0x20, 0x00, 0x80, 0x00, 0xa0, 0x00,
0x00, 0x00, 0x72, 0x03, 0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x03, 0x00, 0x10, 0x00, 0x74, 0x3a, 0x01, 0x00, 0x80, 0x04, 0x20, 0x00,
0x80, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x72, 0x03, 0x04, 0x00, 0x08, 0x00,
0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x20, 0x00, 0x74, 0x3a, 0x01, 0x00,
0x80, 0x04, 0x20, 0x00, 0x80, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x72, 0x03,
0x04, 0x00, 0x08, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x08, 0x00,
0xb0, 0xad, 0x01, 0x00, 0x00, 0x05, 0x20, 0x00, 0x80, 0x00, 0x20, 0x01,
0x00, 0x00, 0x00, 0x04, 0x03, 0x00, 0x03, 0x00, 0x1a, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x04, 0x00, 0x10, 0x00, 0xb0, 0xad, 0x01, 0x00, 0x00, 0x05, 0x20, 0x00,
0x80, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x04, 0x03, 0x00, 0x03, 0x00,
0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x04, 0x00, 0x20, 0x00, 0xb0, 0xad, 0x01, 0x00,
0x00, 0x05, 0x20, 0x00, 0x80, 0x00, 0x20, 0x01, 0x00, 0x00, 0x00, 0x04,
0x03, 0x00, 0x03, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x08, 0x00,
0x60, 0x61, 0x02, 0x00, 0x40, 0x06, 0x20, 0x00, 0xa0, 0x00, 0x00, 0x01,
0x00, 0x00, 0xb0, 0x04, 0x0a, 0x00, 0x08, 0x00, 0x30, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x05, 0x00, 0x10, 0x00, 0x60, 0x61, 0x02, 0x00, 0x40, 0x06, 0x20, 0x00,
0xa0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xb0, 0x04, 0x0a, 0x00, 0x08, 0x00,
0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x05, 0x00, 0x20, 0x00, 0x60, 0x61, 0x02, 0x00,
0x40, 0x06, 0x20, 0x00, 0xa0, 0x00, 0x00, 0x01, 0x00, 0x00, 0xb0, 0x04,
0x0a, 0x00, 0x08, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x08, 0x00,
0xe2, 0x5f, 0x00, 0x00, 0x80, 0x02, 0x18, 0x00, 0x40, 0x00, 0x30, 0x00,
0x00, 0x00, 0xe0, 0x01, 0x06, 0x00, 0x07, 0x00, 0x20, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x06, 0x00, 0x10, 0x00, 0xe2, 0x5f, 0x00, 0x00, 0x80, 0x02, 0x18, 0x00,
0x40, 0x00, 0x30, 0x00, 0x00, 0x00, 0xe0, 0x01, 0x06, 0x00, 0x07, 0x00,
0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x06, 0x00, 0x20, 0x00, 0xe2, 0x5f, 0x00, 0x00,
0x80, 0x02, 0x18, 0x00, 0x40, 0x00, 0x30, 0x00, 0x00, 0x00, 0xe0, 0x01,
0x06, 0x00, 0x07, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x08, 0x00,
0x3c, 0x73, 0x00, 0x00, 0x00, 0x03, 0x18, 0x00, 0x48, 0x00, 0x50, 0x00,
0x00, 0x00, 0x40, 0x02, 0x07, 0x00, 0x07, 0x00, 0x23, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0x07, 0x00, 0x10, 0x00, 0x3c, 0x73, 0x00, 0x00, 0x00, 0x03, 0x18, 0x00,
0x48, 0x00, 0x50, 0x00, 0x00, 0x00, 0x40, 0x02, 0x07, 0x00, 0x07, 0x00,
0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0x07, 0x00, 0x20, 0x00, 0x3c, 0x73, 0x00, 0x00,
0x00, 0x03, 0x18, 0x00, 0x48, 0x00, 0x50, 0x00, 0x00, 0x00, 0x40, 0x02,
0x07, 0x00, 0x07, 0x00, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mgai.h ===
/*/****************************************************************************
*          name: mgai.h
*
*   description: Description des MACROS d'interface a MGA
*
*      designed: Alain Bouchard,  2 juillet 1992
* last modified: $Author: ctoutant $, $Date: 93/12/15 14:36:39 $
*
*       version: $Id: MGAI.H 1.11 93/12/15 14:36:39 ctoutant Exp $
*
******************************************************************************/

#ifdef MGA_INTERFACE_IN

void mgaInitSimulation_in        (unsigned long);
void mgaSetSimulationModel_in    (unsigned long);
void mgaCloseSimulation_in       (void);
void mgaSuspendSimulation_in     (void);
void mgaResumeSimulation_in      (void);

void mgaWriteDWORD_in            (unsigned long, unsigned long);
void mgaWriteWORD_in             (unsigned long, unsigned short);
void mgaWriteBYTE_in             (unsigned long, unsigned char);

void mgaPollDWORD_in             (unsigned long, unsigned long,  unsigned long);
void mgaPollWORD_in              (unsigned long, unsigned short, unsigned short);
void mgaPollBYTE_in              (unsigned long, unsigned char,  unsigned char);

static volatile unsigned char _Far *mgaiFarPtr;

#define mgaInitSimulation(m)     mgaInitSimulation_in((m))
#define mgaSetSimulationModel(m) mgaSetSimulationModel_in((m))
#define mgaCloseSimulation()     mgaCloseSimulation_in()
#define mgaSuspendSimulation()   mgaSuspendSimulation_in()
#define mgaResumeSimulation()    mgaResumeSimulation_in()

#define mgaWriteDWORD(a, d)      mgaiFarPtr = &((a)); \
                                 mgaWriteDWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d))
#define mgaWriteWORD(a, d)       mgaiFarPtr = &((a)); \
                                 mgaWriteWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o,  (d))
#define mgaWriteBYTE(a, d)       mgaiFarPtr = &((a)); \
                                 mgaWriteBYTE_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o,  (d))

#define mgaReadDWORD(a, d)
#define mgaReadWORD(a, d)
#define mgaReadBYTE(a, d)

#define mgaPollDWORD(a, d, m)    mgaiFarPtr = &((a)); \
                                 mgaPollDWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d), (m))
#define mgaPollWORD(a, d, m)     mgaiFarPtr = &((a)); \
                                 mgaPollWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o,  (d), (m))
#define mgaPollBYTE(a, d, m)     mgaiFarPtr = &((a)); \
                                 mgaPollBYTE_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o,  (d), (m))

#endif


/*****************************************************************************/

#ifdef MGA_INTERFACE_EMA

void mgaInitSimulation_ema       (unsigned long);
void mgaCloseSimulation_ema      (void);
void mgaSuspendSimulation_ema    (void);
void mgaResumeSimulation_ema     (void);

void mgaWriteDWORD_ema           (unsigned long, unsigned long);

static volatile unsigned char _Far *mgaiFarPtr;

#define mgaInitSimulation(m)     mgaInitSimulation_ema((m))
#define mgaSetSimulationModel(m) 
#define mgaCloseSimulation()     mgaCloseSimulation_ema()
#define mgaSuspendSimulation()   mgaSuspendSimulation_ema()
#define mgaResumeSimulation()    mgaResumeSimulation_ema()

#define mgaWriteDWORD(a, d)      mgaiFarPtr = &((a)); \
                                 mgaWriteDWORD_ema(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d))
#define mgaWriteWORD(a, d)
#define mgaWriteBYTE(a, d)

#define mgaReadDWORD(a, d)
#define mgaReadWORD(a, d)
#define mgaReadBYTE(a, d)

#define mgaPollDWORD(a, d, m) 
#define mgaPollWORD(a, d, m)  
#define mgaPollBYTE(a, d, m)  

#endif

/*****************************************************************************/

#ifdef MGA_INTERFACE_EMGA

void mgaInitSimulation_emga      (unsigned long);
void mgaCloseSimulation_emga     (void);
void mgaSuspendSimulation_emga   (void);
void mgaResumeSimulation_emga    (void);

void mgaWriteDWORD_emga          (unsigned long, unsigned long);
void mgaReadDWORD_emga           (unsigned long, unsigned long*);

static volatile unsigned char _Far *mgaiFarPtr;

#define mgaInitSimulation(m)     mgaInitSimulation_emga((m))
#define mgaSetSimulationModel(m) 
#define mgaCloseSimulation()     mgaCloseSimulation_emga()
#define mgaSuspendSimulation()   mgaCloseSimulation_emga()
#define mgaResumeSimulation()    mgaCloseSimulation_emga()

#define mgaWriteDWORD(a, d)      mgaiFarPtr = &((a)); \
                                 mgaWriteDWORD_emga(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d))
#define mgaWriteWORD(a, d)
#define mgaWriteBYTE(a, d)

#define mgaReadDWORD(a, d)       mgaiFarPtr = &((a)); \
                                 mgaReadDWORD_emga(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, &(d))
#define mgaReadWORD(a, d)
#define mgaReadBYTE(a, d)

#define mgaPollDWORD(a, d, m) 
#define mgaPollWORD(a, d, m)  
#define mgaPollBYTE(a, d, m)  

#endif

/*****************************************************************************/

#ifdef MGA_INTERFACE_MGA

#define mgaInitSimulation(m)
#define mgaSetSimulationModel(m)
#define mgaCloseSimulation()
#define mgaSuspendSimulation()
#define mgaResumeSimulation()


/* --------------- Debug Write macro echoes ----------------------------- */
#define MACRO_ECHO 0

#ifndef WINDOWS_NT

#if !(MACRO_ECHO)  /* silent, optimized operation */

#define mgaWriteDWORD(a, d)      *((volatile unsigned long  _Far *) &((a))) = (d)
#define mgaWriteWORD(a, d)       *((volatile unsigned short _Far *) &((a))) = (d)
#define mgaWriteBYTE(a, d)       *((volatile unsigned char  _Far *) &((a))) = (d)

#else    /* verbose operation */

#include <stdio.h>
extern FILE *mgaFileOut;

#define mgaWriteDWORD(a, d) { \
   \
   auto volatile unsigned long  _Far *__FarPtr = (volatile unsigned long  _Far *) &((a)); \
   \
   *((volatile unsigned long _Far *) &((a))) = (d); \
   if (mgaFileOut != NULL) { \
      fprintf(mgaFileOut, "selector:offset= 0x%x:", ((struct {unsigned long o; short s;}*) &__FarPtr )->s  ); \
      fprintf(mgaFileOut, "0x%lx",((struct {unsigned long o; short s;}*)  &__FarPtr )->o ); \
      fprintf(mgaFileOut, "     Write DWORD = 0x%lx\n", (d) ); \
   } \
   else { \
      printf("selector:offset= 0x%x:", ((struct {unsigned long o; short s;}*) &__FarPtr )->s  ); \
      printf("0x%lx   ",((struct {unsigned long o; short s;}*)  &__FarPtr )->o ); \
      printf("Write DWORD = 0x%lx\n", (d) ); \
   } \
}
#define mgaWriteWORD(a, d)  { \
   \
   auto volatile unsigned short _Far *__FarPtr = (volatile unsigned short _Far *) &((a)); \
   \
   *((volatile unsigned short _Far *) &((a))) = (d); \
   if (mgaFileOut != NULL) { \
      fprintf(mgaFileOut, "selector:offset= 0x%x", ((struct {unsigned long o; short s;}*) &__FarPtr )->s  ); \
      fprintf(mgaFileOut, ":0x%lx",((struct {unsigned long o; short s;}*)  &__FarPtr )->o ); \
      fprintf(mgaFileOut, "   Write WORD = 0x%hx\n", (d) ); \
   } \
   else { \
      printf("selector:offset= 0x%x", ((struct {unsigned long o; short s;}*) &__FarPtr )->s  ); \
      printf(":0x%lx  ",((struct {unsigned long o; short s;}*)  &__FarPtr )->o ); \
      printf("Write WORD = 0x%hx\n", (d) ); \
   } \
}
#define mgaWriteBYTE(a, d)   { \
   \
   auto volatile unsigned char  _Far *__FarPtr = (volatile unsigned char _Far *) &((a)); \
   \
   *((volatile unsigned char _Far *) &((a))) = (d); \
   if (mgaFileOut != NULL) { \
      fprintf(mgaFileOut, "selector:offset= 0x%x", ((struct {unsigned long o; short s;}*) &__FarPtr )->s  ); \
      fprintf(mgaFileOut, ":0x%lx",((struct {unsigned long o; short s;}*)  &__FarPtr )->o ); \
      fprintf(mgaFileOut, " Write BYTE = 0x%x\n", (d) ); \
   } \
   else { \
      printf("selector:offset= 0x%x", ((struct {unsigned long o; short s;}*) &__FarPtr )->s  ); \
      printf(":0x%lx  ",((struct {unsigned long o; short s;}*)  &__FarPtr )->o ); \
      printf("Write BYTE = 0x%x\n", (d) ); \
   } \
}


#endif  /* #if !(MACRO_ECHO) */
/* ----------- end Debug Write macro echoes ----------------------------- */

#else   /* #ifndef WINDOWS_NT */

/* [dlee] On the DEC Alpha, we can't use *pointer to access h/w registers */
/*	#if !MGA_ALPHA */ /* ORIGINAL VERSION CAUSED WARNING */

#if !defined(MGA_ALPHA)   /* __DDK_SRC__ */

#define mgaWriteDWORD(a, d)      *((volatile unsigned long  _Far *) &((a))) = (d)
#define mgaWriteWORD(a, d)       *((volatile unsigned short _Far *) &((a))) = (d)
#define mgaWriteBYTE(a, d)       *((volatile unsigned char  _Far *) &((a))) = (d)

#define mgaReadDWORD(a, d)       (d) = *((volatile unsigned long  _Far *) &((a)))
#define mgaReadWORD(a, d)        (d) = *((volatile unsigned short _Far *) &((a)))
#define mgaReadBYTE(a, d)        (d) = *((volatile unsigned char  _Far *) &((a)))

#define mgaPollDWORD(a, d, m)    while ((*((volatile unsigned long  _Far *) &((a))) & (m)) != (((d)) & ((m))))
#define mgaPollWORD(a, d, m)     while ((*((volatile unsigned short _Far *) &((a))) & (m)) != (((d)) & ((m))))
#define mgaPollBYTE(a, d, m)     while ((*((volatile unsigned char  _Far *) &((a))) & (m)) != (((d)) & ((m))))

#else   /* #if !defined(MGA_ALPHA) */

#define mgaWriteDWORD(a, d)      VideoPortWriteRegisterUlong((PULONG) &((a)), (d))
#define mgaWriteWORD(a, d)       VideoPortWriteRegisterUshort((PUSHORT) &((a)), (d))
#define mgaWriteBYTE(a, d)       VideoPortWriteRegisterUchar((PUCHAR) &((a)), (UCHAR)(d))

#define mgaReadDWORD(a, d)       (d) = VideoPortReadRegisterUlong((PULONG) &((a)))
#define mgaReadWORD(a, d)        (d) = VideoPortReadRegisterUshort((PUSHORT) &((a)))
#define mgaReadBYTE(a, d)        (d) = VideoPortReadRegisterUchar((PUCHAR) &((a)))

#define mgaPollDWORD(a, d, m)    while ((VideoPortReadRegisterUlong((PULONG) &((a))) & (m)) != (((d)) & ((m))))
#define mgaPollWORD(a, d, m)     while ((VideoPortReadRegisterUshort((PUSHORT) &((a))) & (m)) != (((d)) & ((m))))
#define mgaPollBYTE(a, d, m)     while ((VideoPortReadRegisterUchar((PUCHAR) &((a))) & (m)) != (((d)) & ((m))))

#endif  /* #if !defined(MGA_ALPHA) */

#endif  /* #ifndef WINDOWS_NT */

#endif

/*****************************************************************************/

#ifdef MGA_INTERFACE_EMGA_IN

void mgaInitSimulation_emga      (unsigned long);
void mgaSetSimulationModel_in    (unsigned long);
void mgaCloseSimulation_emga     (void);
void mgaSuspendSimulation_emga   (void);
void mgaResumeSimulation_emga    (void);

void mgaWriteDWORD_emga          (unsigned long, unsigned long);
void mgaReadDWORD_emga           (unsigned long, unsigned long*);

void mgaInitSimulation_in        (unsigned long);
void mgaCloseSimulation_in       (void);
void mgaSuspendSimulation_in     (void);
void mgaResumeSimulation_in      (void);

void mgaWriteDWORD_in            (unsigned long, unsigned long);

static volatile unsigned char _Far *mgaiFarPtr;

#define mgaInitSimulation(m)     mgaInitSimulation_emga((m)); \
                                 mgaInitSimulation_in((m))

#define mgaSetSimulationModel(m) mgaSetSimulationModel_in((m))

#define mgaCloseSimulation()     mgaCloseSimulation_emga(); \
                                 mgaCloseSimulation_in()

#define mgaSuspendSimulation()   mgaSuspendSimulation_emga(); \
                                 mgaSuspendSimulation_in()

#define mgaResumeSimulation()    mgaResumeSimulation_emga(); \
                                 mgaResumeSimulation_in()

#define mgaWriteDWORD(a, d)      mgaiFarPtr = &((a)); \
                                 mgaWriteDWORD_emga(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d)); \
                                 mgaWriteDWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d))

#define mgaWriteWORD(a, d)       mgaiFarPtr = &((a)); \
                                 mgaWriteWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d))

#define mgaWriteBYTE(a, d)       mgaiFarPtr = &((a)); \
                                 mgaWriteBYTE_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d))

#define mgaReadDWORD(a, d)       mgaiFarPtr = &((a)); \
                                 mgaReadDWORD_emga(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, &(d))
#define mgaReadWORD(a, d)
#define mgaReadBYTE(a, d)

#define mgaPollDWORD(a, d, m)    mgaiFarPtr = &((a)); \
                                 mgaPollDWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o, (d), (m))

#define mgaPollWORD(a, d, m)     mgaiFarPtr = &((a)); \
                                 mgaPollWORD_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o,  (d), (m))

#define mgaPollBYTE(a, d, m)     mgaiFarPtr = &((a)); \
                                 mgaPollBYTE_in(((struct {unsigned long o; short s;}*) &mgaiFarPtr)->o,  (d), (m))

#endif

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mga.h ===
/*/****************************************************************************
*          name: mga.h
*
*   description: This file contains all the definitions related to the MGA
*                hardware. As CADDI is coded partly in C and in ASM the
*                permitted definitions are simple #define .
*
*      designed: 
* last modified: $Author: ctoutant $, $Date: 94/06/10 09:38:20 $
*
*       version: $Id: MGA.H 1.29 94/06/10 09:38:20 ctoutant Exp $
*
******************************************************************************/

/*****************************************************************************

 ADDRESSING SECTION:

 This section contains all the definitions to access a ressource on the MGA.
 The way to build an address is divided in three parts:
 
    mga_base_address + device_offset + register_offset

    mga_base_address: Where is mapped the MGA in the system,
    device_offset:    The offset of the device (i.e. Titan) in the MGA space,
    register_offset:  The offset of the register in the device space.

 Base addresses and Offsets are in BYTE units as 80x86 physical addresses.

*/

#define MGA_ISA_BASE_1        0xac000
#define MGA_ISA_BASE_2        0xc8000
#define MGA_ISA_BASE_3        0xcc000
#define MGA_ISA_BASE_4        0xd0000
#define MGA_ISA_BASE_5        0xd4000
#define MGA_ISA_BASE_6        0xd8000
#define MGA_ISA_BASE_7        0xdc000

/*** #define MGA_WIDEBUS_BASE_1 ***/

#define TITAN_OFFSET          0x1c00
#define SRC_WIN_OFFSET        0x0000
#define PSEUDO_DMA_WIN_OFFSET 0x0000
#define DST_WIN_OFFSET        0x2000
#define RAMDAC_OFFSET         0x3c00      /*** BYTE ACCESSES ONLY ***/
#define DUBIC_OFFSET          0x3c80      /*** BYTE ACCESSES ONLY ***/
#define VIWIC_OFFSET          0x3d00      /*** BYTE ACCESSES ONLY ***/
#define CLKGEN_OFFSET         0x3d80      /*** BYTE ACCESSES ONLY ***/
#define EXPDEV_OFFSET         0x3e00      /*** BYTE ACCESSES ONLY ***/

/*** As per Titan (Drawing Engine) specification 1.0 ***/

#define TITAN_DRAWING_ENGINE_RANGE        0x1ff

#define TITAN_GO              0x100

#define TITAN_DWGCTL          0x000
#define TITAN_MACCESS         0x004
#define TITAN_MCTLWTST        0x008
#define TITAN_DST0            0x010
#define TITAN_DST1            0x014
#define TITAN_ZMSK            0x018
#define TITAN_PLNWT           0x01C
#define TITAN_BCOL            0x020
#define TITAN_FCOL            0x024
#define TITAN_SRCBLT          0x02C
#define TITAN_SRC0            0x030
#define TITAN_SRC1            0x034
#define TITAN_SRC2            0x038
#define TITAN_SRC3            0x03C
#define TITAN_XYSTRT          0x040
#define TITAN_XYEND           0x044
#define TITAN_SHIFT           0x050
#define TITAN_SGN             0x058
#define TITAN_LEN             0x05C
#define TITAN_AR0             0x060
#define TITAN_AR1             0x064
#define TITAN_AR2             0x068
#define TITAN_AR3             0x06C
#define TITAN_AR4             0x070
#define TITAN_AR5             0x074
#define TITAN_AR6             0x078
#define TITAN_PITCH           0x08C
#define TITAN_YDST            0x090
#define TITAN_YDSTORG         0x094
#define TITAN_YTOP            0x098
#define TITAN_YBOT            0x09C
#define TITAN_CXLEFT          0x0A0
#define TITAN_CXRIGHT         0x0A4
#define TITAN_FXLEFT          0x0A8
#define TITAN_FXRIGHT         0x0AC
#define TITAN_XDST            0x0B0
#define TITAN_DR0             0x0C0
#define TITAN_DR1             0x0C4
#define TITAN_DR2             0x0C8
#define TITAN_DR3             0x0CC
#define TITAN_DR4             0x0D0
#define TITAN_DR5             0x0D4
#define TITAN_DR6             0x0D8
#define TITAN_DR7             0x0DC
#define TITAN_DR8             0x0E0
#define TITAN_DR9             0x0E4
#define TITAN_DR10            0x0E8
#define TITAN_DR11            0x0EC
#define TITAN_DR12            0x0F0
#define TITAN_DR13            0x0F4
#define TITAN_DR14            0x0F8
#define TITAN_DR15            0x0FC
                               
/*** As per Titan (Host Interface Non-VGA) specification 0.2 ***/
                              
#define TITAN_SRCPAGE         0x200
#define TITAN_DSTPAGE         0x204             
#define TITAN_BYTACCDATA      0x208             
#define TITAN_ADRGEN          0x20c
#define TITAN_FIFOSTATUS      0x210
#define TITAN_STATUS          0x214
#define TITAN_ICLEAR          0x218
#define TITAN_IEN             0x21c
#define TITAN_RST             0x240
#define TITAN_TEST            0x244
#define TITAN_REV             0x248
#define TITAN_CONFIG          0x250
#define TITAN_OPMODE          0x254
#define TITAN_CRT_CTRL        0x25c
#define TITAN_VCOUNT          0x260

/*** As per Titan (Host Interface VGA/CRTC) specification 0.2 ***/

#define TITAN_0_CRTC_ADDR     0x3b4
#define TITAN_0_CRTC_DATA     0x3b5
#define TITAN_0_MISC_ISTAT1   0x3ba
#define TITAN_0_FEAT_CTL_W    0x3ba
#define TITAN_ATTR_ADDR       0x3c0
#define TITAN_ATTR_DATA       0x3c1
#define TITAN_MISC_ISTAT0     0x3c2
#define TITAN_MISC_OUT_W      0x3c2
#define TITAN_VGA_SUBSYS      0x3c3
#define TITAN_SEQ_ADDR        0x3c4
#define TITAN_SEQ_DATA        0x3c5
#define TITAN_DAC_STATUS      0x3c7
#define TITAN_ATTR_DATA_W     0x3c5
#define TITAN_FEAT_CTL_R      0x3ca
#define TITAN_MISC_OUT_R      0x3cc
#define TITAN_GCTL_ADDR       0x3ce
#define TITAN_GCTL_DATA       0x3cf
#define TITAN_1_CRTC_ADDR     0x3d4
#define TITAN_1_CRTC_DATA     0x3d5
#define TITAN_1_MISC_ISTAT1   0x3da
#define TITAN_1_FEAT_CTL_W    0x3da
#define TITAN_AUX_ADDR        0x3de
#define TITAN_AUX_DATA        0x3df

/*** As per Dubic specification 0.2 ***/

#define DUBIC_DUB_SEL         0x00        /*** BYTE ACCESSES ONLY ***/
#define DUBIC_NDX_PTR         0x04        /*** BYTE ACCESSES ONLY ***/
#define DUBIC_DATA            0x08        /*** BYTE ACCESSES ONLY ***/
#define DUBIC_DUB_MOUS        0x0c        /*** BYTE ACCESSES ONLY ***/
#define DUBIC_MOUSE0          0x10        /*** BYTE ACCESSES ONLY ***/
#define DUBIC_MOUSE1          0x14        /*** BYTE ACCESSES ONLY ***/
#define DUBIC_MOUSE2          0x18        /*** BYTE ACCESSES ONLY ***/
#define DUBIC_MOUSE3          0x1c        /*** BYTE ACCESSES ONLY ***/


/*****************************************************************************/

/*****************************************************************************

 DUBIC INDEX TO REGISTERS (NDX_PTR)

 These are the index values to access the Dubic indexed registers via NDX_PTR

*/

/*** As per Dubic specification 0.2 ***/

#define DUBIC_DUB_CTL         0x00
#define DUBIC_KEY_COL         0x01
#define DUBIC_KEY_MSK         0x02
#define DUBIC_DBX_MIN         0x03
#define DUBIC_DBX_MAX         0x04
#define DUBIC_DBY_MIN         0x05
#define DUBIC_DBY_MAX         0x06
#define DUBIC_OVS_COL         0x07
#define DUBIC_CUR_X           0x08
#define DUBIC_CUR_Y           0x09
#define DUBIC_DUB_CTL2        0x0A
#define DUBIC_CUR_COL0        0x0c
#define DUBIC_CUR_COL1        0x0d
#define DUBIC_CRC_CTL         0x0e
#define DUBIC_CRC_DAT         0x0f

/*****************************************************************************/

/* DUBIC FIELDS */

#define DUBIC_DB_SEL_M         0x00000001
#define DUBIC_DB_SEL_A          0
#define DUBIC_DB_SEL_DBA        0x00000000
#define DUBIC_DB_SEL_DBB        0x00000001

#define DUBIC_DB_EN_M           0x00000002
#define DUBIC_DB_EN_A           1
#define DUBIC_DB_EN_OFF         0x00000000
#define DUBIC_DB_EN_ON          0x00000002

#define DUBIC_IMOD_M          0x0000000c
#define DUBIC_IMOD_A          2
#define DUBIC_IMOD_32         0x00000000
#define DUBIC_IMOD_16         0x00000004
#define DUBIC_IMOD_8          0x00000008

#define DUBIC_LVID_M          0x00000070
#define DUBIC_LVID_A          4
#define DUBIC_LVID_OFF        0x00000000
#define DUBIC_LVID_COL_EQ     0x00000010
#define DUBIC_LVID_COL_GE     0x00000020
#define DUBIC_LVID_COL_LE     0x00000030
#define DUBIC_LVID_DB         0x00000040
#define DUBIC_LVID_COL_EQ_DB  0x00000050
#define DUBIC_LVID_COL_GE_DB  0x00000060
#define DUBIC_LVID_COL_LE_DB  0x00000070

#define DUBIC_FBM_M           0x00000380
#define DUBIC_FBM_A           7

#define DUBIC_START_BK_M      0x00000c00
#define DUBIC_START_BK_A      10

#define DUBIC_VSYNC_POL_M     0x00001000
#define DUBIC_VSYNC_POL_A     12

#define DUBIC_HSYNC_POL_M     0x00002000
#define DUBIC_HSYNC_POL_A     13

#define DUBIC_DACTYPE_M       0x0000c000
#define DUBIC_DACTYPE_A       14

#define DUBIC_INT_EN_M        0x00010000
#define DUBIC_INT_EN_A        16

#define DUBIC_GENLOCK_M       0x00040000
#define DUBIC_GENLOCK_A       18

#define DUBIC_BLANK_SEL_M     0x00080000
#define DUBIC_BLANK_SEL_A     19

#define DUBIC_SYNC_DEL_M      0x00f00000
#define DUBIC_SYNC_DEL_A      20

#define DUBIC_VGA_EN_M        0x01000000
#define DUBIC_VGA_EN_A        24

#define DUBIC_SRATE_M         0x7e000000
#define DUBIC_SRATE_A         25

#define DUBIC_BLANKDEL_M      0x80000000
#define DUBIC_BLANKDEL_A      31

#define DUBIC_CSYNCEN_M       0x00000001
#define DUBIC_CSYNCEN_A       0

#define DUBIC_SYNCEN_M        0x00000002
#define DUBIC_SYNCEN_A        1

#define DUBIC_LASEREN_M       0x00000004
#define DUBIC_LASEREN_A       2

#define DUBIC_LASERSCL_M      0x00000018
#define DUBIC_LASERSCL_A      3

#define DUBIC_LVIDFIELD_M     0x00000020
#define DUBIC_LVIDFIELD_A     5

#define DUBIC_CLKSEL_M        0x00000040
#define DUBIC_CLKSEL_A        6

#define DUBIC_LDCLKEN_M       0x00000080
#define DUBIC_LDCLKEN_A       7


/*****************************************************************************

 TITAN Drawing Engine field masks and values as per Titan specification 1.0

*/

#define TITAN_OPCOD_M                        0x0000000f
#define TITAN_OPCOD_A                        0
#define TITAN_OPCOD_LINE_OPEN                0x00000000
#define TITAN_OPCOD_AUTOLINE_OPEN            0x00000001
#define TITAN_OPCOD_LINE_CLOSE               0x00000002
#define TITAN_OPCOD_AUTOLINE_CLOSE           0x00000003
#define TITAN_OPCOD_TRAP                     0x00000004
#define TITAN_OPCOD_BITBLT                   0x00000008
#define TITAN_OPCOD_ILOAD                    0x00000009
#define TITAN_OPCOD_IDUMP                    0x0000000a

#define TITAN_ATYPE_M                        0x00000030
#define TITAN_ATYPE_A                        4
#define TITAN_ATYPE_RPL                      0x00000000
#define TITAN_ATYPE_RSTR                     0x00000010
#define TITAN_ATYPE_ANTI                     0x00000020
#define TITAN_ATYPE_ZI                       0x00000030

#define TITAN_BLOCKM_M                       0x00000040
#define TITAN_BLOCKM_A                       6
#define TITAN_BLOCKM_OFF                     0x00000000
#define TITAN_BLOCKM_ON                      0x00000040

#define TITAN_LINEAR_M                       0x00000080
#define TITAN_LINEAR_A                       7
#define TITAN_LINEAR_OFF                     0x00000000
#define TITAN_LINEAR_ON                      0x00000080  /*** spec 2.5 ***/

#define TITAN_BOP_M                          0x000f0000
#define TITAN_BOP_A                          16
#define TITAN_BOP_CLEAR                      0x00000000
#define TITAN_BOP_NOT_D_OR_S                 0x00010000
#define TITAN_BOP_D_AND_NOTS                 0x00020000
#define TITAN_BOP_NOTS                       0x00030000
#define TITAN_BOP_NOTD_AND_S                 0x00040000
#define TITAN_BOP_NOTD                       0x00050000
#define TITAN_BOP_D_XOR_S                    0x00060000
#define TITAN_BOP_NOT_D_AND_S                0x00070000
#define TITAN_BOP_D_AND_S                    0x00080000
#define TITAN_BOP_NOT_D_XOR_S                0x00090000
#define TITAN_BOP_D                          0x000a0000
#define TITAN_BOP_D_OR_NOTS                  0x000b0000
#define TITAN_BOP_S                          0x000c0000
#define TITAN_BOP_NOTD_OR_S                  0x000d0000
#define TITAN_BOP_D_OR_S                     0x000e0000
#define TITAN_BOP_SET                        0x000f0000

#define TITAN_TRANS_M                        0x00f00000
#define TITAN_TRANS_A                        20

#define TITAN_ALPHADIT_M                     0x01000000
#define TITAN_ALPHADIT_A                     24
#define TITAN_ALPHADIT_FCOL                  0x00000000
#define TITAN_ALPHADIT_RED                   0x01000000

#define TITAN_BLTMOD_M                       0x06000000
#define TITAN_BLTMOD_A                       25
#define TITAN_BLTMOD_BMONO                   0x00000000
#define TITAN_BLTMOD_BPLAN                   0x02000000
#define TITAN_BLTMOD_BFCOL                   0x04000000
#define TITAN_BLTMOD_BUCOL                   0x06000000

#define TITAN_ZDRWEN_M                       0x02000000
#define TITAN_ZDRWEN_A                       25
#define TITAN_ZDRWEN_OFF                     0x00000000
#define TITAN_ZDRWEN_ON                      0x02000000

#define TITAN_ZLTE_M                         0x04000000
#define TITAN_ZLTE_A                         26
#define TITAN_ZLTE_LT                        0x00000000
#define TITAN_ZLTE_LTE                       0x04000000

#define TITAN_TRANSC_M                       0x40000000   /* spec 2.2 */
#define TITAN_TRANSC_A                       30
#define TITAN_TRANSC_OPAQUE                  0x00000000
#define TITAN_TRANSC_TRANSPARENT             0x40000000

#define TITAN_AFOR_M                         0x08000000
#define TITAN_AFOR_A                         27
#define TITAN_AFOR_ALU                       0x00000000
#define TITAN_AFOR_FCOL                      0x08000000

#define TITAN_HBGR_M                         0x08000000
#define TITAN_HBGR_A                         27

#define TITAN_ABAC_M                         0x10000000
#define TITAN_ABAC_A                         28
#define TITAN_ABAC_DEST                      0x00000000
#define TITAN_ABAC_BCOL                      0x10000000

#define TITAN_HCPRS_M                        0x10000000
#define TITAN_HCPRS_A                        28
#define TITAN_HCPRS_SRC32                    0x00000000
#define TITAN_HCPRS_SRC24                    0x10000000

#define TITAN_PATTERN_M                      0x20000000
#define TITAN_PATTERN_A                      29
#define TITAN_PATTERN_OFF                    0x00000000
#define TITAN_PATTERN_ON                     0x20000000

#define TITAN_PWIDTH_M                       0x00000003
#define TITAN_PWIDTH_A                       0
#define TITAN_PWIDTH_PW8                     0x00000000
#define TITAN_PWIDTH_PW16                    0x00000001
/* PACK PIXEL */
#define TITAN_PWIDTH_PW24                    0x00000012
#define TITAN_PWIDTH_PW32                    0x00000002
#define TITAN_PWIDTH_PW32I                   0x00000003

#define TITAN_FBC_M                          0x0000000c
#define TITAN_FBC_A                          2
#define TITAN_FBC_SBUF                       0x00000000
#define TITAN_FBC_DBUFA                      0x00000008
#define TITAN_FBC_DBUFB                      0x0000000c

#define TITAN_ZCOL_M                         0x0000000f
#define TITAN_ZCOL_A                         0

#define TITAN_PLNZMSK_M                      0x000000f0
#define TITAN_PLNZMSK_A                      4

#define TITAN_ZTEN_M                         0x00000100
#define TITAN_ZTEN_A                         8
#define TITAN_ZTEN_OFF                       0x00000000
#define TITAN_ZTEN_ON                        0x00000100

#define TITAN_ZCOLBLK_M                      0x00000200
#define TITAN_ZCOLBLK_A                      9

#define TITAN_FUNCNT_M                       0x0000007f
#define TITAN_FUNCNT_A                       0
#define TITAN_X_OFF_M                        0x0000000f
#define TITAN_X_OFF_A                        0
#define TITAN_Y_OFF_M                        0x00000070
#define TITAN_Y_OFF_A                        4
#define TITAN_FUNOFF_M                       0x003f0000
#define TITAN_FUNOFF_A                       16

#define TITAN_SDYDXL_M                       0x00000001
#define TITAN_SDYDXL_A                       0
#define TITAN_SDYDXL_Y_MAJOR                 0x00000000
#define TITAN_SDYDXL_X_MAJOR                 0x00000001

#define TITAN_SCANLEFT_M                     0x00000001
#define TITAN_SCANLEFT_A                     0
#define TITAN_SCANLEFT_OFF                   0x00000000
#define TITAN_SCANLEFT_ON                    0x00000001

#define TITAN_SDXL_M                         0x00000002
#define TITAN_SDXL_A                         1
#define TITAN_SDXL_POS                       0x00000000
#define TITAN_SDXL_NEG                       0x00000002

#define TITAN_SDY_M                          0x00000004
#define TITAN_SDY_A                          2
#define TITAN_SDY_POS                        0x00000000
#define TITAN_SDY_NEG                        0x00000004

#define TITAN_SDXR_M                         0x00000020
#define TITAN_SDXR_A                         5
#define TITAN_SDXR_POS                       0x00000000
#define TITAN_SDXR_NEG                       0x00000020

#define TITAN_YLIN_M                         0x00008000
#define TITAN_YLIN_A                         15

#define TITAN_AR0_M                          0x0003ffff
                                             
/*****************************************************************************/

/*****************************************************************************

 TITAN HostInterface field masks and values as per Host Interface spec 0.20

*/

#define TITAN_FIFOCOUNT_M                    0x0000007f
#define TITAN_FIFOCOUNT_A                    0

#define TITAN_BFULL_M                        0x00000100
#define TITAN_BFULL_A                        8

#define TITAN_BEMPTY_M                       0x00000200
#define TITAN_BEMPTY_A                       9

#define TITAN_BYTEACCADDR_M                  0x007f0000
#define TITAN_BYTEACCADDR_A                  16

#define TITAN_ADDRGENSTATE_M                 0x3f000000
#define TITAN_ADDRGENSTATE_A                 24

#define TITAN_BFERRISTS_M                    0x00000001
#define TITAN_BFERRISTS_A                    0

#define TITAN_DMATCISTS_M                    0x00000002
#define TITAN_DMATCISTS_A                    1

#define TITAN_PICKISTS_M                     0x00000004
#define TITAN_PICKISTS_A                     2

#define TITAN_VSYNCSTS_M                     0x00000008
#define TITAN_VSYNCSTS_A                     3
#define TITAN_VSYNCSTS_SET                          0x00000008
#define TITAN_VSYNCSTS_CLR                          0x00000000

#define TITAN_BYTEFLAG_M                     0x00000f00
#define TITAN_BYTEFLAG_A                     8

#define TITAN_DWGENGSTS_M                    0x00010000
#define TITAN_DWGENGSTS_A                    16
#define TITAN_DWGENGSTS_BUSY                 0x00010000
#define TITAN_DWGENGSTS_IDLE                 0x00000000

#define TITAN_BFERRICLR_M                    0x00000001
#define TITAN_BFERRICLR_A                    0

#define TITAN_DMATCICLR_M                    0x00000002
#define TITAN_DMATCICLR_A                    1

#define TITAN_PICKICLR_M                     0x00000004
#define TITAN_PICKICLR_A                     2

#define TITAN_BFERRIEN_M                     0x00000001
#define TITAN_BFERRIEN_A                     0

#define TITAN_DMATCIEN_M                     0x00000002
#define TITAN_DMATCIEN_A                     1

#define TITAN_PICKIEN_M                      0x00000004
#define TITAN_PICKIEN_A                      2

#define TITAN_VSYNCIEN_M                     0x00000008
#define TITAN_VSYNCIEN_A                     3

#define TITAN_SOFTRESET_M                    0x00000001
#define TITAN_SOFTRESET_A                    0
#define TITAN_SOFTRESET_SET                  0x00000001
#define TITAN_SOFTRESET_CLR                  0x00000000

#define TITAN_VGATEST_M                      0x00000001
#define TITAN_VGATEST_A                      0

#define TITAN_ROBITWREN_M                    0x00000100
#define TITAN_ROBITWREN_A                    8

#define TITAN_CHIPREV_M                      0x0000000f
#define TITAN_CHIPREV_A                      0


#define TITAN_NODUBIC_M                      0x00000010
#define TITAN_NODUBIC_A                      4


#define TITAN_CONFIG_M                       0x00000003   /*** BYTE ACCESS ONLY ***/
#define TITAN_CONFIG_A                       0
#define TITAN_CONFIG_8                       0x00000000
#define TITAN_CONFIG_16                      0x00000001
#define TITAN_CONFIG_16N                     0x00000003

#define TITAN_DRIVERDY_M                     0x00000100
#define TITAN_DRIVERDY_A                     8

#define TITAN_BIOSEN_M                       0x00000200
#define TITAN_BIOSEN_A                       9

#define TITAN_VGAEN_M                        0x00000400
#define TITAN_VGAEN_A                        10

#define TITAN_LEVELIRQ_M                     0x00000800
#define TITAN_LEVELIRQ_A                     11

#define TITAN_EXPDEV_M                       0x00010000
#define TITAN_EXPDEV_A                       16

#define TITAN_MAPSEL_M                       0x07000000
#define TITAN_MAPSEL_A                       24
#define TITAN_MAPSEL_DISABLED                0x00000000
#define TITAN_MAPSEL_BASE_1                  0x01000000
#define TITAN_MAPSEL_BASE_2                  0x02000000
#define TITAN_MAPSEL_BASE_3                  0x03000000
#define TITAN_MAPSEL_BASE_4                  0x04000000
#define TITAN_MAPSEL_BASE_5                  0x05000000
#define TITAN_MAPSEL_BASE_6                  0x06000000
#define TITAN_MAPSEL_BASE_7                  0x07000000

#define TITAN_POSEIDON_M                     0x08000000
#define TITAN_POSEIDON_A                     27

#define TITAN_PCI_M                          0x08000000
#define TITAN_PCI_A                          27
#define TITAN_ISA_M                          0x10000000
#define TITAN_ISA_A                          28
#define TITAN_ISA_ISA_BUS                    0x10000000
#define TITAN_ISA_WIDE_BUS                   0x00000000

#define TITAN_PSEUDODMA_M                    0x00000001
#define TITAN_PSEUDODMA_A                    0

#define TITAN_DMAACT_M                       0x00000002
#define TITAN_DMAACT_A                       1

#define TITAN_DMAMOD_M                       0x0000000c
#define TITAN_DMAMOD_A                       2
#define TITAN_DMAMOD_GENERAL_WR              0x00000000
#define TITAN_DMAMOD_BLIT_WR                 0x00000004
#define TITAN_DMAMOD_VECTOR_WR               0x00000008
#define TITAN_DMAMOD_BLIT_RD                 0x0000000c

#define TITAN_NOWAIT_M                       0x00000010
#define TITAN_NOWAIT_A                       4

#define TITAN_MOUSEEN_M                      0x00000100
#define TITAN_MOUSEEN_A                      8

#define TITAN_MOUSEMAP_M                     0x00000200
#define TITAN_MOUSEMAP_A                     9

#define TITAN_ZTAGEN_M                       0x00000400
#define TITAN_ZTAGEN_A                       10

#define TITAN_VBANK0_M                       0x00000800
#define TITAN_VBANK0_A                       11

#define TITAN_RFHCNT_M                       0x000f0000
#define TITAN_RFHCNT_A                       16

#define TITAN_FBM_M                          0x00f00000
#define TITAN_FBM_A                          20

#define TITAN_HYPERPG_M                      0x03000000
#define TITAN_HYPERPG_A                      24
#define TITAN_HYPERPG_NOHYPER                0x00000000
#define TITAN_HYPERPG_SELHYPER               0x01000000
#define TITAN_HYPERPG_ALLHYPER               0x02000000
#define TITAN_HYPERPG_RESERVED               0x03000000

#define TITAN_TRAM_M                         0x04000000
#define TITAN_TRAM_A                         26
#define TITAN_TRAM_256X8                     0x00000000
#define TITAN_TRAM_256X16                    0x04000000

#define TITAN_CRTCBPP_M                      0x00000003
#define TITAN_CRTCBPP_A                      0
#define TITAN_CRTCBPP_8                      0x00000000
#define TITAN_CRTCBPP_16                     0x00000001
#define TITAN_CRTCBPP_32                     0x00000002

#define TITAN_ALW_M                          0x00000004
#define TITAN_ALW_A                          2

#define TITAN_INTERLACE_M                    0x00000018
#define TITAN_INTERLACE_A                    3
#define TITAN_INTERLACE_OFF                  0x00000000
#define TITAN_INTERLACE_768                  0x00000008
#define TITAN_INTERLACE_1024                 0x00000010
#define TITAN_INTERLACE_1280                 0x00000018

#define TITAN_VIDEODELAY0_M                  0x00000020
#define TITAN_VIDEODELAY0_A                  5
#define TITAN_VIDEODELAY1_M                  0x00000200
#define TITAN_VIDEODELAY1_A                  9
#define TITAN_VIDEODELAY2_M                  0x00000400
#define TITAN_VIDEODELAY2_A                  10

#define TITAN_VSCALE_M                       0x00030000
#define TITAN_VSCALE_A                       16

#define TITAN_SYNCDEL_M                      0x000C0000
#define TITAN_SYNCDEL_A                      18

#define TITAN_DST0_RESERVED1_M               0x0000ffff
#define TITAN_DST0_RESERVED1_A               0
#define TITAN_DST0_PCBREV_M                  0x000f0000
#define TITAN_DST0_PCBREV_A                  16
#define TITAN_DST0_BLKMODE_M                 0x00080000
#define TITAN_DST0_BLKMODE_A                 19  
#define TITAN_DST0_PRODUCT_M                 0x00f00000
#define TITAN_DST0_PRODUCT_A                 20
#define TITAN_DST0_RAMBANK_M                 0xff000000
#define TITAN_DST0_RAMBANK_A                 24
#define TITAN_DST1_RAMBANK_M                 0x00000001
#define TITAN_DST1_RAMBANK_A                 0
#define TITAN_DST1_RAMBANK0_M                0x00000008
#define TITAN_DST1_RAMBANK0_A                3
#define TITAN_DST1_RAMSPEED_M                0x00000006
#define TITAN_DST1_RAMSPEED_A                1
#define TITAN_DST1_RESERVED1_M               0x0007fff8
#define TITAN_DST1_RESERVED1_A               3

#define TITAN_DST1_200MHZ_M                  0x00010000
#define TITAN_DST1_200MHZ_A                  16
#define TITAN_DST1_NOMUXES_M                 0x00020000
#define TITAN_DST1_NOMUXES_A                 17
#define TITAN_DST1_ABOVE1280_M               0x00000010
#define TITAN_DST1_ABOVE1280_A               4

#define TITAN_DST1_HYPERPG_M                 0x00180000
#define TITAN_DST1_HYPERPG_A                 19
#define TITAN_DST1_EXPDEV_M                  0x00200000
#define TITAN_DST1_EXPDEV_A                  21
#define TITAN_DST1_TRAM_M                    0x00400000
#define TITAN_DST1_TRAM_A                    22
#define TITAN_DST1_RESERVED2_M               0xff800000
#define TITAN_DST1_RESERVED2_A               23


/*****************************************************************************

 RAMDAC rgisters

*/

/*** DIRECT ***/
#define BT481_WADR_PAL          0x00
#define BT481_RADR_PAL          0x0c
#define BT481_WADR_OVL          0x10
#define BT481_RADR_OVL          0x1c
#define BT481_COL_PAL           0x04
#define BT481_COL_OVL           0x14
#define BT481_PIX_RD_MSK        0x08
#define BT481_CMD_REGA          0x18
/*** INDIRECT ***/
#define BT481_RD_MSK                0x00
#define BT481_OVL_MSK           0x01
#define BT481_CMD_REGB          0x02
#define BT481_CUR_REG           0x03
#define BT481_CUR_XLOW          0x04
#define BT481_CUR_XHI           0x05
#define BT481_CUR_YLOW          0x06
#define BT481_CUR_YHI           0x07

/*** DIRECT ***/
#define BT482_WADR_PAL          0x00
#define BT482_RADR_PAL          0x0c
#define BT482_WADR_OVL          0x10
#define BT482_RADR_OVL          0x1c
#define BT482_COL_PAL           0x04
#define BT482_COL_OVL           0x14
#define BT482_PIX_RD_MSK        0x08
#define BT482_CMD_REGA          0x18
/*** INDIRECT ***/
#define BT482_RD_MSK                0x00
#define BT482_OVL_MSK           0x01
#define BT482_CMD_REGB          0x02
#define BT482_CUR_REG           0x03
#define BT482_CUR_XLOW          0x04
#define BT482_CUR_XHI           0x05
#define BT482_CUR_YLOW          0x06
#define BT482_CUR_YHI           0x07
/* Bt482 FIELDS */
#define BT482_EXT_REG_M         0x01
#define BT482_EXT_REG_A         0x00
#define BT482_EXT_REG_EN        0x01
#define BT482_EXT_REG_DIS       0x00
#define BT482_CUR_SEL_M         0x20
#define BT482_CUR_SEL_A         0x05
#define BT482_CUR_SEL_INT       0x00
#define BT482_CUR_SEL_EXT       0x20
#define BT482_DISP_MODE_M       0x10
#define BT482_DISP_MODE_A       0x04
#define BT482_DISP_MODE_I       0x10
#define BT482_DISP_MODE_NI      0x00
#define BT482_CUR_CR3_M         0x08
#define BT482_CUR_CR3_A         0x03
#define BT482_CUR_CR3_RAM       0x08
#define BT482_CUR_CR3_PAL       0x00
#define BT482_CUR_EN_M          0x04
#define BT482_CUR_EN_A          0x02
#define BT482_CUR_EN_ON         0x00
#define BT482_CUR_EN_OFF        0x04
#define BT482_CUR_MODE_M        0x03
#define BT482_CUR_MODE_A        0x00
#define BT482_CUR_MODE_DIS      0x00
#define BT482_CUR_MODE_1        0x01
#define BT482_CUR_MODE_2        0x02
#define BT482_CUR_MODE_3        0x03
/* Bt482 ADRESSE OFFSET FOR EXT. REG. */
#define BT482_OFF_CUR_COL       0x11



/*** DIRECT ***/
#define BT484_WADR_PAL          0x00
#define BT484_RADR_PAL          0x0c
#define BT484_WADR_OVL          0x10
#define BT484_RADR_OVL          0x1c
#define BT484_COL_PAL           0x04
#define BT484_COL_OVL           0x14
#define BT484_PIX_RD_MSK        0x08
#define BT484_CMD_REG0          0x18
#define BT484_CMD_REG1          0x20
#define BT484_CMD_REG2          0x24
#define BT484_STATUS                0x28
#define BT484_CUR_RAM           0x2c
#define BT484_CUR_XLOW          0x30
#define BT484_CUR_XHI           0x34
#define BT484_CUR_YLOW          0x38
#define BT484_CUR_YHI           0x3c


#define BT485_WADR_PAL          0x00
#define BT485_RADR_PAL          0x0c
#define BT485_WADR_OVL          0x10
#define BT485_RADR_OVL          0x1c
#define BT485_COL_PAL           0x04
#define BT485_COL_OVL           0x14
#define BT485_PIX_RD_MSK        0x08
#define BT485_CMD_REG0          0x18
#define BT485_CMD_REG1          0x20
#define BT485_CMD_REG2          0x24
#define BT485_STATUS                0x28
#define BT485_CUR_RAM           0x2c
#define BT485_CUR_XLOW          0x30
#define BT485_CUR_XHI           0x34
#define BT485_CUR_YLOW          0x38
#define BT485_CUR_YHI           0x3c
#define BT485_CMD_REG3          0x28


/*****************************************************************************/

/* Bt485 FIELDS */

/* Command register 0 */
#define BT485_IND_REG3_M        0x80
#define BT485_IND_REG3_A        0x07
#define BT485_IND_REG3_EN       0x80
#define BT485_IND_REG3_DIS      0x00

/* Command register 2 */
#define BT485_DISP_MODE_M       0x08
#define BT485_DISP_MODE_A       0x03
#define BT485_DISP_MODE_I       0x08
#define BT485_DISP_MODE_NI      0x00
#define BT485_CUR_MODE_M        0x03
#define BT485_CUR_MODE_A        0x00
#define BT485_CUR_MODE_DIS      0x00
#define BT485_CUR_MODE_1        0x01
#define BT485_CUR_MODE_2        0x02
#define BT485_CUR_MODE_3        0x03

/* Command register 3 (indirecte) */
#define BT485_CUR_SEL_M         0x04
#define BT485_CUR_SEL_A         0x02
#define BT485_CUR_SEL_32        0x00
#define BT485_CUR_SEL_64        0x04
#define BT485_CUR_MSB_M         0x03
#define BT485_CUR_MSB_A         0x00
#define BT485_CUR_MSB_00        0x00
#define BT485_CUR_MSB_01        0x01
#define BT485_CUR_MSB_10        0x02
#define BT485_CUR_MSB_11        0x03

/* Bt485 ADR OFFSET FOR EXT. reg cmd3 */
#define BT485_OFF_CUR_COL       0x01




#define BT484_ID_M            0xc0
#define BT484_ID              0x40
#define BT485_ID_M            0xc0
#define BT485_ID              0x80
#define ATT20C505_ID_M        0x70
#define ATT20C505_ID          0x50

/*****************************************************************************/

/*** VIEWPOINT REGISTER DIRECT ***/

#define VPOINT_WADR_PAL         0x00
#define VPOINT_COL_PAL          0x04
#define VPOINT_PIX_RD_MSK       0x08
#define VPOINT_RADR_PAL         0x0c


#define VPOINT_INDEX               0x18
#define VPOINT_DATA            0x1c


/*** VIEWPOINT REGISTER INDIRECT ***/

#define VPOINT_CUR_XLOW       0x00
#define VPOINT_CUR_XHI        0x01
#define VPOINT_CUR_YLOW       0x02
#define VPOINT_CUR_YHI        0x03
#define VPOINT_SPRITE_X       0x04
#define VPOINT_SPRITE_Y       0x05
#define VPOINT_CUR_CTL        0x06
#define VPOINT_CUR_RAM_LSB    0x08
#define VPOINT_CUR_RAM_MSB    0x09
#define VPOINT_CUR_RAM_DATA   0x0a
#define VPOINT_WIN_XSTART_LSB 0x10
#define VPOINT_WIN_XSTART_MSB 0x11
#define VPOINT_WIN_XSTOP_LSB  0x12
#define VPOINT_WIN_XSTOP_MSB  0x13
#define VPOINT_WIN_YSTART_LSB 0x14
#define VPOINT_WIN_YSTART_MSB 0x15
#define VPOINT_WIN_YSTOP_LSB  0x16
#define VPOINT_WIN_YSTOP_MSB  0x17
#define VPOINT_MUX_CTL1       0x18
#define VPOINT_MUX_CTL2       0x19
#define VPOINT_INPUT_CLK      0x1a
#define VPOINT_OUTPUT_CLK     0x1b
#define VPOINT_PAL_PAGE       0x1c
#define VPOINT_GEN_CTL        0x1d
#define VPOINT_OVS_RED        0x20
#define VPOINT_OVS_GREEN      0x21
#define VPOINT_OVS_BLUE       0x22
#define VPOINT_CUR_COL0_RED   0x23
#define VPOINT_CUR_COL0_GREEN 0x24
#define VPOINT_CUR_COL0_BLUE  0x25
#define VPOINT_CUR_COL1_RED   0x26
#define VPOINT_CUR_COL1_GREEN 0x27
#define VPOINT_CUR_COL1_BLUE  0x28
#define VPOINT_AUX_CTL        0x29
#define VPOINT_GEN_IO_CTL     0x2a
#define VPOINT_GEN_IO_DATA    0x2b
#define VPOINT_KEY_RED_LOW    0x32
#define VPOINT_KEY_RED_HI     0x33
#define VPOINT_KEY_GREEN_LOW  0x34
#define VPOINT_KEY_GREEN_HI   0x35
#define VPOINT_KEY_BLUE_LOW   0x36
#define VPOINT_KEY_BLUE_HI    0x37
#define VPOINT_KEY_CTL        0x38
#define VPOINT_SENSE_TEST     0x3a
#define VPOINT_TEST_DATA      0x3b
#define VPOINT_CRC_LSB        0x3c
#define VPOINT_CRC_MSB        0x3d
#define VPOINT_CRC_CTL        0x3e
#define VPOINT_ID             0x3f
#define VPOINT_RESET          0xff


/*** ATT20C510 REGISTER DIRECT ***/

#define ATT20C510_WR1           0x00
#define ATT20C510_RMR           0x08
#define ATT20C510_RD1           0x0c
#define ATT20C510_WR2           0x10
#define ATT20C510_CR0           0x18
#define ATT20C510_RD2           0x1c
#define ATT20C510_CR1           0x20
#define ATT20C510_CR2           0x24
#define ATT20C510_ST            0x28
#define ATT20C510_XLOW          0x30
#define ATT20C510_XHIGH         0x34
#define ATT20C510_YLOW          0x38
#define ATT20C510_YHIGH         0x3c


/*** ATT20C510 REGISTER INDIRECT ***/

#define ATT20C510_CR3           0x01
#define ATT20C510_CR4           0x02
#define ATT20C510_TEST          0x03
#define ATT20C510_CR5           0x04
#define ATT20C510_MIR           0x05
#define ATT20C510_DIR           0x06
#define ATT20C510_CC0           0x07
#define ATT20C510_CC1           0x08

/** Clock **/
#define ATT20C510_AA0           0x40
#define ATT20C510_AA1           0x41
#define ATT20C510_AA2           0x42

#define ATT20C510_AB0           0x44
#define ATT20C510_AB1           0x45
#define ATT20C510_AB2           0x46

#define ATT20C510_AD0           0x4c
#define ATT20C510_AD1           0x4d
#define ATT20C510_AD2           0x4e

#define ATT20C510_BC0           0x58
#define ATT20C510_BC1           0x59
#define ATT20C510_BC2           0x5a


/*****************************************************************************/

/*** TVP3026 REGISTER DIRECT ***/

#define TVP3026_WADR_PAL        0x00
#define TVP3026_COL_PAL         0x04
#define TVP3026_PIX_RD_MSK      0x08
#define TVP3026_RADR_PAL        0x0c
#define TVP3026_CUR_COL_ADDR  0x10
#define TVP3026_CUR_COL_DATA  0x14

#define TVP3026_CUR_XLOW      0x30
#define TVP3026_CUR_XHI       0x34
#define TVP3026_CUR_YLOW      0x38
#define TVP3026_CUR_YHI       0x3c

#define TVP3026_INDEX           0x00
#define TVP3026_DATA               0x28

#define TVP3026_CUR_RAM       0x2c


/*** TVP3026 REGISTER INDIRECT ***/

#define TVP3026_SILICON_REV    0x01
#define TVP3026_CURSOR_CTL     0x06
#define TVP3026_LATCH_CTL      0x0f
#define TVP3026_TRUE_COLOR_CTL 0x18
#define TVP3026_MUX_CTL        0x19
#define TVP3026_CLK_SEL        0x1a
#define TVP3026_PAL_PAGE       0x1c
#define TVP3026_GEN_CTL        0x1d
#define TVP3026_MISC_CTL       0x1e
#define TVP3026_GEN_IO_CTL     0x2a
#define TVP3026_GEN_IO_DATA    0x2b
#define TVP3026_PLL_ADDR       0x2c
#define TVP3026_PIX_CLK_DATA   0x2d
#define TVP3026_MEM_CLK_DATA   0x2e
#define TVP3026_LOAD_CLK_DATA  0x2f

#define TVP3026_KEY_RED_LOW    0x32
#define TVP3026_KEY_RED_HI     0x33
#define TVP3026_KEY_GREEN_LOW  0x34
#define TVP3026_KEY_GREEN_HI   0x35
#define TVP3026_KEY_BLUE_LOW   0x36
#define TVP3026_KEY_BLUE_HI    0x37
#define TVP3026_KEY_CTL        0x38
#define TVP3026_MCLK_CTL       0x39
#define TVP3026_SENSE_TEST     0x3a
#define TVP3026_TEST_DATA      0x3b
#define TVP3026_CRC_LSB        0x3c
#define TVP3026_CRC_MSB        0x3d
#define TVP3026_CRC_CTL        0x3e
#define TVP3026_ID             0x3f
#define TVP3026_RESET          0xff


/*****************************************************************************/

/******* ProductType *******/
#define BOARD_MGA_RESERVED   0x07
#define BOARD_MGA_VL         0x0a
#define BOARD_MGA_VL_M       0x0e

#ifdef OS2

    #define _Far far

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxcurs.c ===
/*/****************************************************************************
*          name: mtxcurs.c
*
*   description: routines that manage hardware cursor (in RAMDAC)
*
*      designed: Christian Toutant
* last modified: $Author: bleblanc $, $Date: 94/11/09 10:50:57 $
*
*       version: $Id: MTXCURS.C 1.23 94/11/09 10:50:57 bleblanc Exp $
*
*    parameters: -
*      modifies: -
*         calls: -
*       returns: -
******************************************************************************/

#ifdef OS2  /* nPhung Tue 23-Aug-1994 10:41:33 */
	#include <stdlib.h>
	#include <string.h>
	#include <stdio.h>
	#include <dos.h>
	#include <time.h>
#endif

#include "switches.h"
#include "mga.h"
#include "bind.h"
#include "defbind.h"
#ifndef __DDK_SRC__
  #include "sxci.h"
#endif
#include "mgai_c.h"
#include "mgai.h"

/* Prototypes */
static void wrDacReg(word reg, int dat);
static void rdDacReg(word reg, byte *dat);
static bool toBitPlane(PixMap *pPixMap);
static bool charge482(PixMap *pPixMap);
static bool charge485(PixMap *pPixMap);
bool chargeVIEWPOINT(PixMap *pPixMap);
static bool chargeTVP3026(PixMap *pPixMap);
static bool shiftCursorTVP3026(word o);
bool mtxCursorSetShape(PixMap *pPixMap);
void mtxCursorSetColors(mtxRGB color00, mtxRGB color01, mtxRGB color10, mtxRGB color11);
void mtxCursorEnable(word mode);
void mtxCursorSetHotSpot(word Dx, word Dy);
void mtxCursorMove(word X, word Y);
CursorInfo * mtxCursorGetInfo();

#ifdef WINDOWS_NT
#if defined(ALLOC_PRAGMA)
//    #pragma alloc_text(PAGE,wrDacReg)
//    #pragma alloc_text(PAGE,rdDacReg)
    #pragma alloc_text(PAGE,toBitPlane)
    #pragma alloc_text(PAGE,charge482)
    #pragma alloc_text(PAGE,charge485)
    #pragma alloc_text(PAGE,chargeVIEWPOINT)
    #pragma alloc_text(PAGE,chargeTVP3026)
    #pragma alloc_text(PAGE,shiftCursorTVP3026)
    #pragma alloc_text(PAGE,mtxCursorSetShape)
    #pragma alloc_text(PAGE,mtxCursorSetColors)
//    #pragma alloc_text(PAGE,mtxCursorEnable)
    #pragma alloc_text(PAGE,mtxCursorSetHotSpot)
    #pragma alloc_text(PAGE,mtxCursorMove)
    #pragma alloc_text(PAGE,mtxCursorGetInfo)
#endif

PVOID   AllocateSystemMemory(ULONG NumberOfBytes);

#endif  /* #ifdef WINDOWS_NT */

/*-------  extern global variables */

extern  volatile byte _Far* pMgaBaseAddr;
extern HwData Hw[];
extern byte iBoard;



/*--------------- Static internal variables */

static byte planData[1024] = {0};       /* Maximum cursor 64 X 64 X 2 */

/* The cursor in TVP3026 rev x can not go out of visible display */
static byte* planTVP[NB_BOARD_MAX] = {planData,0,0,0,0,0,0};
static byte  revTVP[NB_BOARD_MAX]  = {0xff,0xff,0xff,0xff,0xff,0xff,0xff};
static word  currentTVPDelta[NB_BOARD_MAX] = {0};


/********  Local Definition ****************/

static void wrDacReg(word reg, int dat)
{
    mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + (reg)), (byte)dat);
}

static void rdDacReg(word reg, byte *dat)
{
    mgaReadBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + (reg)), *dat);
}


/*--------------------------------------------------------------------------*/


static bool toBitPlane(PixMap *pPixMap)
{
    word plan1 = (pPixMap->Width == 32) ? 128 : 512;
    word i, pos, pixels;

    switch(pPixMap->Format)
    {
        case 0x0102 :
            for(i = 0; i < plan1; i++)
            {
                pixels = ((word *)pPixMap->Data)[i];
                planData[i] = pixels & 0x01;
                pixels >>= 1;
                planData[plan1 + i] = pixels & 0x01;
                pixels >>= 1;
                for (pos = 1; pos < 8; pos++)
                {
                    planData[i] <<= 1;
                    planData[plan1 + i] <<= 1;
                    planData[i] |= pixels & 0x01;
                    pixels >>= 1;
                    planData[plan1 + i] |= pixels & 0x01;
                    pixels >>= 1;
                }
            }

        default:
            return mtxFAIL;
    }

}

/*----------------------------------------------------
Non documented  : If we have a NULL Data buffer,
                      The initialisation will be done without
                      modifying the CURSOR RAM DATA.
                      pPixMap->Height == 0 -> cursor disable
                      pPixMap->Height != 0 -> cursor enable
-----------------------------------------------------*/
static bool charge482(PixMap *pPixMap)
{
    byte     reg_cur;
    int i;

    if (!pPixMap->Data) return mtxOK;

   /*--- Prepare access to RAM of cursor */
   toBitPlane(pPixMap);
    /*-- Permits the access to Extented register */
    wrDacReg(BT482_WADR_PAL, BT482_CUR_REG); /* points on Cursor register */
    /* Select Cursor RAM */
    rdDacReg(BT482_PIX_RD_MSK, &reg_cur);
    wrDacReg(BT482_PIX_RD_MSK, reg_cur | BT482_CUR_CR3_RAM);

    wrDacReg(BT482_WADR_PAL, 0); /* address RAM cursor to 0 */
    /* ----------- Transfer */
    for(i = 0; i < 0x100; i++)
        wrDacReg(BT482_COL_OVL, planData[i]);
    /*------------ */
    /* Reset original value in the registers */
    wrDacReg(BT482_WADR_PAL, BT482_CUR_REG);/* points to Cursor register */
    /* replace original in cursor reg. */
/*   reg_cur &= ~(BT482_CUR_CR3_RAM | BT482_CUR_EN_M);*/
    wrDacReg(BT482_PIX_RD_MSK, reg_cur); /* restore Cursor register */
    return mtxOK;
}

/*----------------------------------------------------
Non documente  : Si nous avons un buffer Data Null,
                      L'initialisation se fera sans modifier
                      le CURSOR RAM DATA.
                      pPixMap->Height == 0 -> cursor disable
                      pPixMap->Height != 0 -> cursor enable
-----------------------------------------------------*/
static bool charge485(PixMap *pPixMap)
{
    byte     reg_0, reg_3, tmpByte, reg_cur;
    bool valeurRetour = mtxOK;
    int i;

   /* Hide CURSOR */
    rdDacReg(BT485_CMD_REG2, &reg_cur);
    reg_0 = reg_cur & ~BT485_CUR_MODE_M;
    wrDacReg(BT485_CMD_REG2, reg_0 | BT485_CUR_MODE_DIS);

    i = ((pPixMap->Width == 32) ? 128 : 512) << 1;

    if (pPixMap->Data)  toBitPlane(pPixMap);

    /* Permits the access to command register 3 */
    rdDacReg(BT485_CMD_REG0, &reg_0);
    wrDacReg(BT485_CMD_REG0, reg_0 | BT485_IND_REG3_M);
    /* read command register 3 */
    wrDacReg(BT485_WADR_PAL, 1);    /* address RAM cursor to 1 */
    rdDacReg(BT485_CMD_REG3, &reg_3);

    switch(pPixMap->Width)
    {
        case 32:
            reg_3 &= ~(BT485_CUR_SEL_M | BT485_CUR_MSB_M); /* 32x32 cursor */
            /* write to command register 3 */
            wrDacReg(BT485_WADR_PAL, 1);    /* address RAM cursor to 1 */
            wrDacReg(BT485_CMD_REG3, reg_3);

            if (!pPixMap->Data) break; /* If Data empty, no Load */
            do
                {
                   wrDacReg(BT485_WADR_PAL, 0);  /* address RAM cursor to 0 */
                   for(i = 0; i < 0x100; i++)
                        wrDacReg(BT485_CUR_RAM, planData[i]);
                rdDacReg(BT485_WADR_PAL, &tmpByte);
                   } while (  tmpByte != 0 ) ;

            break;

            case 64:
                reg_3 |= BT485_CUR_SEL_M;       /* 64x64 cursor */
                reg_3 &= ~BT485_CUR_MSB_M;      /* Adr 10:9 Cur Ram = 0. */
                if (!pPixMap->Data) /* If Data empty, no Load */
                    {
                    wrDacReg(BT485_CMD_REG3, reg_3);
                    break;
                    }


                /* Transfer 1st 256 bytes */

                if (!pPixMap->Data) /* If Data empty, no Load */
                    {
                    wrDacReg(BT485_CMD_REG3, reg_3);
                    break;
                    }

                /*--- Write to command register 3 */
                wrDacReg(BT485_WADR_PAL, 1);    /* address RAM cursor to 1 */
                wrDacReg(BT485_CMD_REG3, reg_3);    /* MSB Adr 10:9 Cur Ram = 0. */
                do
                    {
                        wrDacReg(BT485_WADR_PAL, 0);/* address RAM cursor to 0 */
                        for(i = 0; i < 0x100; i++)
                             wrDacReg(BT485_CUR_RAM, planData[i]);
                    rdDacReg(BT485_WADR_PAL, &tmpByte);
                       } while (  tmpByte != 0 ) ;

                /* Transfer 2nd 256 bytes                 */
                /* MSB Adr 10:9 Cur Ram = 1.                      */
                /*--- Write to command register 3         */
                wrDacReg(BT485_WADR_PAL, 1);    /* address RAM cursor to 1 */
                wrDacReg(BT485_CMD_REG3, reg_3 | BT485_CUR_MSB_01);

                do
                    {
                        wrDacReg(BT485_WADR_PAL, 0);        /* address RAM cursor to 0 */
                        for(i = 0; i < 0x100; i++)
                             wrDacReg(BT485_CUR_RAM, planData[0x100 + i]);
                    rdDacReg(BT485_WADR_PAL, &tmpByte);
                       } while (  tmpByte != 0 ) ;

                /* Transfer 3rd 256 bytes START second PLAN         */
                /* MSB Adr 10:9 Cur Ram = 2.                                  */
                /*--- Write to command register 3                     */
                wrDacReg(BT485_WADR_PAL, 1);    /* address RAM cursor to 1 */
                wrDacReg(BT485_CMD_REG3, reg_3 | BT485_CUR_MSB_10);
                do
                    {
                        wrDacReg(BT485_WADR_PAL, 0);        /* address RAM cursor to 0 */
                        for(i = 0; i < 0x100; i++)
                             wrDacReg(BT485_CUR_RAM, planData[0x200 + i]);
                    rdDacReg(BT485_WADR_PAL, &tmpByte);
                       } while (  tmpByte != 0 ) ;

                /* Transfer 4th 256 bytes */
                /* MSB Adr 10:9 Cur Ram = 3. */
                /*--- Write to command register 3         */
                wrDacReg(BT485_WADR_PAL, 1);    /* address RAM cursor to 1 */
                wrDacReg(BT485_CMD_REG3, reg_3 | BT485_CUR_MSB_11);


                do
                    {
                        wrDacReg(BT485_WADR_PAL, 0);        /* address RAM cursor to 0 */
                       for(i = 0; i < 0x100; i++)
                             wrDacReg(BT485_CUR_RAM, planData[0x300 + i]);
                    rdDacReg(BT485_WADR_PAL, &tmpByte);
                       } while (  tmpByte != 0 ) ;

                /* access register 3 */
                wrDacReg(BT485_WADR_PAL, 1);    /* address RAM cursor to 1 */
                wrDacReg(BT485_CMD_REG3, reg_3);    /* MSB's adr = 00 */
                    break;

                default:
                    valeurRetour = mtxFAIL;
                    break;
        }
        wrDacReg(BT485_CMD_REG0, reg_0);    /* Restore command register 3 */

      /* Restore CURSOR MODE */
       wrDacReg(BT485_CMD_REG2, reg_cur);

        return valeurRetour;
}

/*----------------------------------------------------
Non documented  : If we have a NULL Data buffer,
                      The initialisation will be done without
                      modifying the CURSOR RAM DATA.
                      pPixMap->Height == 0 -> cursor disable
                      pPixMap->Height != 0 -> cursor enable
-----------------------------------------------------*/
bool chargeVIEWPOINT(PixMap *pPixMap)
{
   word i, j, pixels, pitch;
   byte cur_ctl;
    if (pPixMap->Data)
    {
    if ((pPixMap->Height > 64) || (pPixMap->Width  > 64))
       return mtxFAIL;

    wrDacReg(VPOINT_INDEX, VPOINT_CUR_CTL);
    rdDacReg(VPOINT_DATA, &cur_ctl);
    wrDacReg(VPOINT_DATA, 0x10);
    pitch = pPixMap->Width >> 2;
    /* Cursor ram adress to 0 */
    wrDacReg(VPOINT_INDEX, VPOINT_CUR_RAM_LSB);
    wrDacReg(VPOINT_DATA, 0);
    wrDacReg(VPOINT_INDEX, VPOINT_CUR_RAM_MSB);
    wrDacReg(VPOINT_DATA, 0);

    wrDacReg(VPOINT_INDEX, VPOINT_CUR_RAM_DATA);
    for (i = 0; i < pPixMap->Height; i++)
        {
        for (j = 0; j < pitch; j++)
            {
            pixels = ((byte *)pPixMap->Data)[i * pitch + j];
            wrDacReg(VPOINT_DATA, (pixels << 6) |
                                  ((pixels << 2) & 0x30) |
                                  ((pixels >> 2) & 0x0c) |
                                  ((pixels  >> 6) & 0x3)
                    );
            }
        for (; j < 16; j++)
            {
            wrDacReg(VPOINT_DATA, 0);
            }
        }

    for (; i < 64; i++)
        for (j = 0; j < 16; j++)
            {
            wrDacReg(VPOINT_DATA, 0);
            }

    /* Hot Spot Max */
    wrDacReg(VPOINT_INDEX, VPOINT_SPRITE_X);
    wrDacReg(VPOINT_DATA, pPixMap->Width - 1);
    wrDacReg(VPOINT_INDEX, VPOINT_SPRITE_Y);
    wrDacReg(VPOINT_DATA, pPixMap->Height - 1);
    wrDacReg(VPOINT_INDEX, VPOINT_CUR_CTL);
    wrDacReg(VPOINT_DATA, cur_ctl);
   }
   /* Restore Cursor control  */
   return mtxFAIL;
}



/*----------------------------------------------------
Non documented  : If we have a NULL Data buffer,
                      The initialisation will be done without
                      modifying the CURSOR RAM DATA.
                      pPixMap->Height == 0 -> cursor disable
                      pPixMap->Height != 0 -> cursor enable
-----------------------------------------------------*/
static bool chargeTVP3026(PixMap *pPixMap)
{
   byte reg1, curCtl, curPos[4];
    bool valeurRetour = mtxOK;
    int i;

    if (pPixMap->Data)
      toBitPlane(pPixMap);

    if (!pPixMap->Data) /* If Data Empty, no Load */
      return(mtxFAIL);


   /* Hide cursor */
    rdDacReg(TVP3026_CUR_XLOW, &curPos[0]);
    rdDacReg(TVP3026_CUR_XHI , &curPos[1]);
    rdDacReg(TVP3026_CUR_YLOW, &curPos[2]);
    rdDacReg(TVP3026_CUR_YHI , &curPos[3]);
    wrDacReg(TVP3026_CUR_XLOW, 0x00 );
    wrDacReg(TVP3026_CUR_XHI , 0x00 );
    wrDacReg(TVP3026_CUR_YLOW, 0x00 );
    wrDacReg(TVP3026_CUR_YHI , 0x00 );

/* update TVP Revision */
    wrDacReg(TVP3026_INDEX, TVP3026_SILICON_REV);
    rdDacReg(TVP3026_DATA,  &revTVP[iBoard]);

    switch(pPixMap->Width)
       {
        case 32:
          /* Transfer 1st 256 bytes */

          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
          rdDacReg(TVP3026_DATA, &curCtl);
         reg1 = curCtl & 0xf0;                /* CCR[3:2] = 00 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);

          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
          for(i = 0; i < 128; i+=4)
            {
              wrDacReg(TVP3026_CUR_RAM, planData[i]);
              wrDacReg(TVP3026_CUR_RAM, planData[i+1]);
              wrDacReg(TVP3026_CUR_RAM, planData[i+2]);
              wrDacReg(TVP3026_CUR_RAM, planData[i+3]);
              wrDacReg(TVP3026_CUR_RAM, 0);
              wrDacReg(TVP3026_CUR_RAM, 0);
              wrDacReg(TVP3026_CUR_RAM, 0);
              wrDacReg(TVP3026_CUR_RAM, 0);
            }


          /* Transfer 2nd 256 bytes */

         reg1 = reg1 | 0x04;                /* CCR[3:2] = 01 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);
          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
         for(i=0; i<256; i++)
              wrDacReg(TVP3026_CUR_RAM, 0);


          /* Transfer 3rd 256 bytes (Start of second PLAN)  */

         reg1 = reg1 & 0xf0;
         reg1 = reg1 | 0x08;                /* CCR[3:2] = 10 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);

          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
          for(i = 128; i < 256; i+=4)
            {
              wrDacReg(TVP3026_CUR_RAM, planData[i]);
              wrDacReg(TVP3026_CUR_RAM, planData[i+1]);
              wrDacReg(TVP3026_CUR_RAM, planData[i+2]);
              wrDacReg(TVP3026_CUR_RAM, planData[i+3]);
              wrDacReg(TVP3026_CUR_RAM, 0);
              wrDacReg(TVP3026_CUR_RAM, 0);
              wrDacReg(TVP3026_CUR_RAM, 0);
              wrDacReg(TVP3026_CUR_RAM, 0);
            }

          /* Transfer 4th 256 bytes */

         reg1 = reg1 | 0x0c;                /* CCR[3:2] = 11 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);
          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
         for(i=0; i<256; i++)
              wrDacReg(TVP3026_CUR_RAM, 0);

         break;

      case 64:

          /* Transfer 1st 256 bytes */

          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
          rdDacReg(TVP3026_DATA, &curCtl);
         reg1 = curCtl & 0xf0;                /* CCR[3:2] = 00 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);

          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
          for(i = 0; i < 0x100; i++)
              wrDacReg(TVP3026_CUR_RAM, planData[i]);


          /* Transfer 2nd 256 bytes */

         reg1 = reg1 | 0x04;                /* CCR[3:2] = 01 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);

          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
          for(i = 0; i < 0x100; i++)
              wrDacReg(TVP3026_CUR_RAM, planData[0x100+i]);


          /* Transfer 3rd 256 bytes (Start of second PLAN)  */

         reg1 = reg1 & 0xf0;
         reg1 = reg1 | 0x08;                /* CCR[3:2] = 10 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);

          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
          for(i = 0; i < 0x100; i++)
              wrDacReg(TVP3026_CUR_RAM, planData[0x200+i]);


          /* Transfer 4th 256 bytes */

         reg1 = reg1 | 0x0c;                /* CCR[3:2] = 11 */
          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
         wrDacReg(TVP3026_DATA, reg1);

          wrDacReg(TVP3026_WADR_PAL, 0);      /* address RAM cursor to 0 */
          for(i = 0; i < 0x100; i++)
              wrDacReg(TVP3026_CUR_RAM, planData[0x300+i]);
         break;
      }

   /* Fix bug TVP3026 rev x */
   if (currentTVPDelta[iBoard])
      shiftCursorTVP3026(currentTVPDelta[iBoard]);

   /* Display cursor */
   wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
   wrDacReg(TVP3026_DATA, curCtl);
    wrDacReg(TVP3026_CUR_XLOW, curPos[0]);
    wrDacReg(TVP3026_CUR_XHI , curPos[1]);
    wrDacReg(TVP3026_CUR_YLOW, curPos[2]);
    wrDacReg(TVP3026_CUR_YHI , curPos[3]);
   if (iBoard)
      {
      if (!planTVP[iBoard])
         {
      #ifndef WINDOWS_NT
         if ( (planTVP[iBoard] = (byte *)malloc( 1024 )) == (byte *)0)
      #else
         if ( (planTVP[iBoard] = (PUCHAR)AllocateSystemMemory(1024)) == NULL)
      #endif
            return mtxFAIL;
         }
      for (i = 0; i < 1024; i++)
         (planTVP[iBoard])[i] = planData[i];
      }
    return valeurRetour;
}


/***************************************************************************
Function    : shiftCursorTVP3026
description : shift right Cursor ram data by o.
parametres  : word o // shift value
retourne    : aucune
*****************************************************************************/
/*
planTVP[board] hold cursor data ram

---- 32 bits plan 0
        _______________________________________________________________
         col00 | col01 | col02 | col03 | col04 | col05 | col06 | col07 |
       | ---------------------------------------------------------------
row 00 | p[00] | p[01] | p[02] | p[03] |   00  |   00  |   00  |   00  |
row 01 | p[04] | p[05] | p[06] | p[07] |   00  |   00  |   00  |   00  |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
row 20 | p[7c] | p[7d] | p[7e] | p[7f] |   00  |   00  |   00  |   00  |
row 21 |   00  |   00  |   00  |   00  |   00  |   00  |   00  |   00  |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
row 3f |   00  |   00  |   00  |   00  |   00  |   00  |   00  |   00  |
       |________________________________________________________________

---- 32 bits plan 1
        _______________________________________________________________
         col00 | col01 | col02 | col03 | col04 | col05 | col06 | col07 |
       | ---------------------------------------------------------------
row 00 | p[80] | p[81] | p[82] | p[83] |   00  |   00  |   00  |   00  |
row 01 | p[84] | p[85] | p[86] | p[87] |   00  |   00  |   00  |   00  |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
row 20 | p[fc] | p[fd] | p[fe] | p[ff] |   00  |   00  |   00  |   00  |
row 21 |   00  |   00  |   00  |   00  |   00  |   00  |   00  |   00  |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
row 3f |   00  |   00  |   00  |   00  |   00  |   00  |   00  |   00  |
       |________________________________________________________________



---- 64 bits plan 0
        _______________________________________________________________
         col00 | col01 | col02 | col03 | col04 | col05 | col06 | col07 |
       | ---------------------------------------------------------------
row 00 | p[00] | p[01] | p[02] | p[03] | p[04] | p[05] | p[06] | p[07] |
row 01 | p[08] | p[09] | p[0a] | p[0b] | p[0c] | p[0d] | p[0e] | p[0f] |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
row 3f | p[1f8]| p[1f9]| p[1fa]| p[1fb]| p[1fc]| p[1fd]| p[1fe]| p[1ff]|
       |________________________________________________________________

---- 63 bits plan 1
        _______________________________________________________________
       |  col00 | col01 | col02 | col03 | col04 | col05 | col06 | col07|
       | ---------------------------------------------------------------
row 00 | p[200]| p[201]| p[202]| p[203]| p[204]| p[205]| p[206]| p[207]|
row 01 | p[208]| p[209]| p[20a]| p[20b]| p[20c]| p[20d]| p[20e]| p[20f]|
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |   .   |
row 3f | p[3f8]| p[3f9]| p[3fa]| p[3fb]| p[3fc]| p[3fd]| p[3fe]| p[3ff]|
       |________________________________________________________________


*/
static bool shiftCursorTVP3026(word o)
{
   byte reg1, regCtl, curPos[4];
    int i, j, r_o;
   dword plan[2];
   dword plan32;
   byte  *planByte = (byte *)plan;

   /* If an error occur in memory alloc */
   if (!planTVP[iBoard])
      return mtxFAIL;

   /* Hide cursor */
   /* I use this way to minimize noise problem when we acces the index
      register
   */
    rdDacReg(TVP3026_CUR_XLOW, &curPos[0]);
    rdDacReg(TVP3026_CUR_XHI , &curPos[1]);
    rdDacReg(TVP3026_CUR_YLOW, &curPos[2]);
    rdDacReg(TVP3026_CUR_YHI , &curPos[3]);
    wrDacReg(TVP3026_CUR_XLOW, 0x00 );
    wrDacReg(TVP3026_CUR_XHI , 0x00 );
    wrDacReg(TVP3026_CUR_YLOW, 0x00 );
    wrDacReg(TVP3026_CUR_YHI , 0x00 );

   r_o = (int)32 - (int)o;
    /* Transfer 1st 256 bytes */
    wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
    rdDacReg(TVP3026_DATA, &regCtl);
   reg1 = regCtl & 0xf0;                /* CCR[3:2] = 00 */
    wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
   wrDacReg(TVP3026_DATA, reg1);

    wrDacReg(TVP3026_WADR_PAL, 0);    /* address RAM cursor to 0 */
    for(j = 0; j < 256; j+=8)
      {
       if (Hw[iBoard].cursorInfo.CurWidth == 32) /* only 128 bytes */
         i = j >> 1;
      else
         i = j;

      plan[0] = plan[1] = 0;

      /* read first 32 bytes */
      /* display
         | byte 0 | byte1 | byte2 | byte 3 |
         byte 0 have to be the hi part of the dword
      */
      ((byte *)&plan32)[3] = (planTVP[iBoard])[i];
      ((byte *)&plan32)[2] = (planTVP[iBoard])[i+1];
      ((byte *)&plan32)[1] = (planTVP[iBoard])[i+2];
      ((byte *)&plan32)[0] = (planTVP[iBoard])[i+3];
      if (o)
         {
         if (r_o > 0)   /* => o < 32 bits */
            {
            plan[0] = plan32 >> o;     /* left  part of slice */
            plan[1] = plan32 << r_o;   /* right part of slice */

             if (Hw[iBoard].cursorInfo.CurWidth == 64) /* complete right slice */
               {
               ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
               ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
               ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
               ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
               plan[1] |= plan32 >> o;
               }
            }
         else /* o > 32 bits => left slice is empty */
            {
            plan[1] = plan32 >> (-r_o); /* right slice */
            }
         }
      else /* no shift, put back data */
         {
         plan[0] = plan32;
          if (Hw[iBoard].cursorInfo.CurWidth == 64)
            {
            ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
            ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
            ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
            ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
            plan[1] = plan32;
            }

         }
      /* Write to slice (hi part of each slice first */
       wrDacReg(TVP3026_CUR_RAM, planByte[3]);
       wrDacReg(TVP3026_CUR_RAM, planByte[2]);
       wrDacReg(TVP3026_CUR_RAM, planByte[1]);
       wrDacReg(TVP3026_CUR_RAM, planByte[0]);
       wrDacReg(TVP3026_CUR_RAM, planByte[7]);
       wrDacReg(TVP3026_CUR_RAM, planByte[6]);
       wrDacReg(TVP3026_CUR_RAM, planByte[5]);
       wrDacReg(TVP3026_CUR_RAM, planByte[4]);
      }


    /* Transfer 3rd 256 bytes (Start of second PLAN)  */

   reg1 = reg1 & 0xf0;
   reg1 = reg1 | 0x08;                /* CCR[3:2] = 10 */
    wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
   wrDacReg(TVP3026_DATA, reg1);

    wrDacReg(TVP3026_WADR_PAL, 0);    /* address RAM cursor to 0 */
    for(j = 256; j < 512; j+=8)
      {
       if (Hw[iBoard].cursorInfo.CurWidth == 32)
         i = j >> 1;
      else
         i = j + 256;

      plan[0] = plan[1] = 0;
      ((byte *)&plan32)[3] = (planTVP[iBoard])[i];
      ((byte *)&plan32)[2] = (planTVP[iBoard])[i+1];
      ((byte *)&plan32)[1] = (planTVP[iBoard])[i+2];
      ((byte *)&plan32)[0] = (planTVP[iBoard])[i+3];
      if (o)
         {
         if (r_o > 0)
            {
            plan[0] = plan32 >> o;
            plan[1] = plan32 << r_o;
             if (Hw[iBoard].cursorInfo.CurWidth == 64)
               {
               ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
               ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
               ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
               ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
               plan[1] |= plan32 >> o;
               }
            }
         else
            {
            plan[1] = plan32 >> (-r_o);
            }
         }
      else
         {
         plan[0] = plan32;
          if (Hw[iBoard].cursorInfo.CurWidth == 64)
            {
            ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
            ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
            ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
            ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
            plan[1] = plan32;
            }
         }


       wrDacReg(TVP3026_CUR_RAM, planByte[3]);
       wrDacReg(TVP3026_CUR_RAM, planByte[2]);
       wrDacReg(TVP3026_CUR_RAM, planByte[1]);
       wrDacReg(TVP3026_CUR_RAM, planByte[0]);
       wrDacReg(TVP3026_CUR_RAM, planByte[7]);
       wrDacReg(TVP3026_CUR_RAM, planByte[6]);
       wrDacReg(TVP3026_CUR_RAM, planByte[5]);
       wrDacReg(TVP3026_CUR_RAM, planByte[4]);

      }


   if (Hw[iBoard].cursorInfo.CurWidth == 64)
      {
       /* Transfer 2nd 256 bytes */
      reg1 = reg1 & 0xf0;
      reg1 = reg1 | 0x04;                /* CCR[3:2] = 01 */
       wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
      wrDacReg(TVP3026_DATA, reg1);
      wrDacReg(TVP3026_WADR_PAL, 0);    /* address RAM cursor to 0 */
    for(i = 256; i < 512; i+=8)
         {
         plan[0] = plan[1] = 0;
         ((byte *)&plan32)[3] = (planTVP[iBoard])[i];
         ((byte *)&plan32)[2] = (planTVP[iBoard])[i+1];
         ((byte *)&plan32)[1] = (planTVP[iBoard])[i+2];
         ((byte *)&plan32)[0] = (planTVP[iBoard])[i+3];
         if (o)
            {
            if (r_o > 0)
               {
               plan[0] = plan32 >> o;
               plan[1] = plan32 << r_o;
               ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
               ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
               ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
               ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
               plan[1] |= plan32 >> o;
               }
            else
               {
               plan[1] = plan32 >> (-r_o);
               }
            }
         else
            {
            plan[0] = plan32;
            ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
            ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
            ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
            ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
            plan[1] = plan32;
            }


       wrDacReg(TVP3026_CUR_RAM, planByte[3]);
       wrDacReg(TVP3026_CUR_RAM, planByte[2]);
       wrDacReg(TVP3026_CUR_RAM, planByte[1]);
       wrDacReg(TVP3026_CUR_RAM, planByte[0]);
       wrDacReg(TVP3026_CUR_RAM, planByte[7]);
       wrDacReg(TVP3026_CUR_RAM, planByte[6]);
       wrDacReg(TVP3026_CUR_RAM, planByte[5]);
       wrDacReg(TVP3026_CUR_RAM, planByte[4]);
         }


       /* Transfer 4th 256 bytes */

      reg1 = reg1 & 0xf0;
      reg1 = reg1 | 0x0c;                /* CCR[3:2] = 11 */
       wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
      wrDacReg(TVP3026_DATA, reg1);
       wrDacReg(TVP3026_WADR_PAL, 0);    /* address RAM cursor to 0 */

    for(i = 768; i < 1024; i+=8)
         {
         plan[0] = plan[1] = 0;
         ((byte *)&plan32)[3] = (planTVP[iBoard])[i];
         ((byte *)&plan32)[2] = (planTVP[iBoard])[i+1];
         ((byte *)&plan32)[1] = (planTVP[iBoard])[i+2];
         ((byte *)&plan32)[0] = (planTVP[iBoard])[i+3];
         if (o)
            {
            if (r_o > 0)
               {
               plan[0] = plan32 >> o;
               plan[1] = plan32 << r_o;
               ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
               ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
               ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
               ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
               plan[1] |= plan32 >> o;
               }
            else
               {
               plan[1] = plan32 >> (-r_o);
               }
            }
         else
            {
            plan[0] = plan32;
            ((byte *)&plan32)[3] = (planTVP[iBoard])[i+4];
            ((byte *)&plan32)[2] = (planTVP[iBoard])[i+5];
            ((byte *)&plan32)[1] = (planTVP[iBoard])[i+6];
            ((byte *)&plan32)[0] = (planTVP[iBoard])[i+7];
            plan[1] = plan32;
            }


       wrDacReg(TVP3026_CUR_RAM, planByte[3]);
       wrDacReg(TVP3026_CUR_RAM, planByte[2]);
       wrDacReg(TVP3026_CUR_RAM, planByte[1]);
       wrDacReg(TVP3026_CUR_RAM, planByte[0]);
       wrDacReg(TVP3026_CUR_RAM, planByte[7]);
       wrDacReg(TVP3026_CUR_RAM, planByte[6]);
       wrDacReg(TVP3026_CUR_RAM, planByte[5]);
       wrDacReg(TVP3026_CUR_RAM, planByte[4]);
         }

      }

   /* Display cursor */
    wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
    wrDacReg(TVP3026_DATA, regCtl);
    wrDacReg(TVP3026_CUR_XLOW, curPos[0]);
    wrDacReg(TVP3026_CUR_XHI , curPos[1]);
    wrDacReg(TVP3026_CUR_YLOW, curPos[2]);
    wrDacReg(TVP3026_CUR_YHI , curPos[3]);

   return mtxOK;
}


/***************************************************************************
Function        : mtxCursorShape
description : Defines the cursor shape and size
parameters  : PixMap *pPixMap   // pointer to a PixMap structure
returns     : mtxFAIL if function fails
                  mtxGood if function complete

*****************************************************************************/
bool mtxCursorSetShape(PixMap *pPixMap)
{
    if (pPixMap->Data)
        switch (pPixMap->Width)
        {
            case 32:
                Hw[iBoard].cursorInfo.HotSX = 32 + Hw[iBoard].CurrentOverScanX;
                Hw[iBoard].cursorInfo.HotSY = 32 + Hw[iBoard].CurrentOverScanY;
                Hw[iBoard].cursorInfo.CurWidth = 32;
                Hw[iBoard].cursorInfo.CurHeight = 32;
                break;

            case 64:
                Hw[iBoard].cursorInfo.HotSX = 64 + Hw[iBoard].CurrentOverScanX;
                Hw[iBoard].cursorInfo.HotSY = 64 + Hw[iBoard].CurrentOverScanY;
                Hw[iBoard].cursorInfo.CurWidth = 64;
                Hw[iBoard].cursorInfo.CurHeight = 64;
                break;

            default: return mtxFAIL;
        }

    /* Verify if bitmap square (we support 32 x 32 and 64 x 64) */
    if ( pPixMap->Data && (pPixMap->Width != pPixMap->Height))
        return mtxFAIL;

    switch(Hw[iBoard].DacType)
    {
        case BT482:
            if ( pPixMap->Width != 32) return mtxFAIL; /*32 x 32 only */
            charge482(pPixMap);
            break;

        case BT485:
        case PX2085:
            charge485(pPixMap);
            break;

        case VIEWPOINT:
            chargeVIEWPOINT(pPixMap);
            break;

      case TVP3026:
            chargeTVP3026(pPixMap);
            break;


        default:    return mtxFAIL;
    }
    /* Hot spot by defaut = 0, 0 */
    Hw[iBoard].cursorInfo.cHotSX = 0;
    Hw[iBoard].cursorInfo.cHotSY = 0;
    return mtxOK;
}


/***************************************************************************
Function    : mtxCursorColors
description : Definition of the cursor color
parameters  : mtxRGB color1, color2     // Definition of the two colors
returns     : none
*****************************************************************************/
void mtxCursorSetColors(mtxRGB color00, mtxRGB color01, mtxRGB color10, mtxRGB color11)
{
    word i;
    byte  reg_cur;
    switch(Hw[iBoard].DacType)
    {
        case BT482:
            wrDacReg(BT482_WADR_PAL, BT482_CUR_REG); /* points on Cursor register */
            /* Select Cursor RAM */
            rdDacReg(BT482_PIX_RD_MSK, &reg_cur);
            wrDacReg(BT482_PIX_RD_MSK, 0);


            wrDacReg(BT482_WADR_OVL, 0x11); /* address col cursor */
            /* color 1 */
            for (i = 0; i < 24; i += 8)
                wrDacReg(BT482_COL_OVL, (color10 >> i) & 0xff);

            /* color 2 */
            for (i = 0; i < 24; i += 8)
                wrDacReg(BT482_COL_OVL, (color11 >> i) & 0xff);

            /* Reset original value in the registers */
            wrDacReg(BT482_WADR_PAL, BT482_CUR_REG);/* points to Cursor register */
            /* replace originale dans cursor reg. */
/*         reg_cur &= ~(BT482_CUR_CR3_RAM | BT482_CUR_EN_M);*/
            wrDacReg(BT482_PIX_RD_MSK, reg_cur);  /* restore Cursor register */
            break;

        case BT485:
        case PX2085:
            wrDacReg(BT485_WADR_OVL, BT485_OFF_CUR_COL); /* address col cursor */
            /* color 1 */
            for (i = 0; i < 24; i += 8)
                wrDacReg(BT485_COL_OVL, (color10 >> i) & 0xff);

            /* color 2 */
            for (i = 0; i < 24; i += 8)
                wrDacReg(BT485_COL_OVL, (color11 >> i) & 0xff);

            break;

        case VIEWPOINT:
            /* Cursor Color 0 */
            wrDacReg(VPOINT_INDEX, VPOINT_CUR_COL0_RED);
            wrDacReg(VPOINT_DATA, color10 & 0xff);
            wrDacReg(VPOINT_INDEX, VPOINT_CUR_COL0_GREEN);
            wrDacReg(VPOINT_DATA, (color10 >> 8) & 0xff);
            wrDacReg(VPOINT_INDEX, VPOINT_CUR_COL0_BLUE);
            wrDacReg(VPOINT_DATA, (color10 >> 16) & 0xff);

            /* Cursor Color 1 */
            wrDacReg(VPOINT_INDEX, VPOINT_CUR_COL1_RED);
            wrDacReg(VPOINT_DATA, color11 & 0xff);
            wrDacReg(VPOINT_INDEX, VPOINT_CUR_COL1_GREEN);
            wrDacReg(VPOINT_DATA, (color11 >> 8) & 0xff);
            wrDacReg(VPOINT_INDEX, VPOINT_CUR_COL1_BLUE);
            wrDacReg(VPOINT_DATA, (color11 >> 16) & 0xff);
            break;


      case TVP3026:
            rdDacReg(TVP3026_CUR_COL_ADDR, &reg_cur);
         reg_cur = reg_cur & 0xf3;
         reg_cur = reg_cur | 0x01;   /* [1:0]=01  : cursor color 0 */
/*        wrDacReg(TVP3026_CUR_COL_ADDR, reg_cur); */
          wrDacReg(TVP3026_CUR_COL_ADDR, 01);

         /* Cursor Color 0 */
         wrDacReg(TVP3026_CUR_COL_DATA, color10 & 0xff);
         wrDacReg(TVP3026_CUR_COL_DATA, (color10 >> 8) & 0xff);
         wrDacReg(TVP3026_CUR_COL_DATA, (color10 >> 16) & 0xff);

         /* Cursor Color 1 */
         wrDacReg(TVP3026_CUR_COL_DATA, color11 & 0xff);
         wrDacReg(TVP3026_CUR_COL_DATA, (color11 >> 8) & 0xff);
         wrDacReg(TVP3026_CUR_COL_DATA, (color11 >> 16) & 0xff);
         break;


    }
}


/***************************************************************************
Function    : mtxCursorEnable
description : Enable/disable the cursor
parameter   : mode  0 = disable, 1 = enable, others = reserved
returns     :

*****************************************************************************/
void mtxCursorEnable(word mode)
{
    byte reg_cur;

    switch(Hw[iBoard].DacType)
    {

        case BT482:
            /*-- Permits access to the Extented register */
            wrDacReg(BT482_WADR_PAL, BT482_CUR_REG); /* points to Cursor register */

            rdDacReg(BT482_PIX_RD_MSK, &reg_cur);
            reg_cur &= ~(BT482_CUR_MODE_M | BT482_CUR_EN_M);
            switch(mode)
            {
                case 0:
                    /* disable cursor */
                    wrDacReg(BT482_PIX_RD_MSK, reg_cur | BT482_CUR_MODE_DIS);
                    break;


                case 1:
                    /* enable cursor */
                    wrDacReg(BT482_PIX_RD_MSK, reg_cur | BT482_CUR_MODE_3);
                    break;
            }
            break;

        case BT485:
        case PX2085:
            rdDacReg(BT485_CMD_REG2, &reg_cur);
            reg_cur &= ~BT485_CUR_MODE_M;
            switch(mode)
            {
                case 0:
                    wrDacReg(BT485_CMD_REG2, reg_cur | BT485_CUR_MODE_DIS);
                    break;

                case 1:
                    wrDacReg(BT485_CMD_REG2, reg_cur | BT485_CUR_MODE_3);
                    break;
            }
            break;

        case VIEWPOINT:
             wrDacReg(VPOINT_INDEX, VPOINT_CUR_CTL);
            if (mode)
               wrDacReg(VPOINT_DATA, 0x50);
            else
               wrDacReg(VPOINT_DATA, 0x10);
            break;


      case TVP3026:

         /* get cursor location */
/*
            rdDacReg(TVP3026_CUR_XLOW, &curPos[0]);
            rdDacReg(TVP3026_CUR_XHI , &curPos[1]);
            rdDacReg(TVP3026_CUR_YLOW, &curPos[2]);
            rdDacReg(TVP3026_CUR_YHI , &curPos[3]);
*/
         /* put cursor out of display */
/*
            wrDacReg(TVP3026_CUR_XLOW, 0x00);
            wrDacReg(TVP3026_CUR_XHI , 0x00);
            wrDacReg(TVP3026_CUR_YLOW, 0x00);
            wrDacReg(TVP3026_CUR_YHI , 0x00);
*/

          wrDacReg(TVP3026_INDEX, TVP3026_CURSOR_CTL);
          rdDacReg(TVP3026_DATA, &reg_cur);

         if(mode)
            {
/*** BEN TEST ***/
            reg_cur = reg_cur | 0x03;    /* CCR[3:2] = 11  X-Windows cursor */
            }
         else
            reg_cur = reg_cur & 0xfc;    /* CCR[1:0] = 00  cursor off */

         wrDacReg(TVP3026_DATA, reg_cur);

         /* restore cursor location */
/*
            wrDacReg(TVP3026_CUR_XLOW, curPos[0]);
            wrDacReg(TVP3026_CUR_XHI , curPos[1]);
            wrDacReg(TVP3026_CUR_YLOW, curPos[2]);
            wrDacReg(TVP3026_CUR_YHI , curPos[3]);
*/
         break;

    }
}


/***************************************************************************
Function    : mtxCursorSetHotSpot
description : Defines the position of the cursor with respect to xy
                  (0,0) corresponding to top left hand corner
parameters  : x, y offset with respect to top left hand corner < size of cursor
returns     :

*****************************************************************************/
void mtxCursorSetHotSpot(word Dx, word Dy)
{
    Hw[iBoard].cursorInfo.cHotSX = Dx;
    Hw[iBoard].cursorInfo.cHotSY = Dy;
   Hw[iBoard].cursorInfo.HotSX = (Hw[iBoard].cursorInfo.CurWidth  + Hw[iBoard].CurrentOverScanX)  - Dx;
    Hw[iBoard].cursorInfo.HotSY = (Hw[iBoard].cursorInfo.CurHeight + Hw[iBoard].CurrentOverScanY)  - Dy;
}


/***************************************************************************
Function    : mtxCursorMove
description : move the HotSpot to the position x, y
parameters  : x, y new position
returns     :

*****************************************************************************/
void mtxCursorMove(word X, word Y)
{
    word xp, yp;



    xp = X + Hw[iBoard].cursorInfo.HotSX;
    yp = Y + Hw[iBoard].cursorInfo.HotSY;

    switch(Hw[iBoard].DacType)
    {
        case BT482:
            /*-- Permits access to the Extented register */

            /* Cursor X Low Register */
            wrDacReg(BT482_WADR_PAL, BT482_CUR_XLOW);
            wrDacReg(BT482_PIX_RD_MSK, xp & 0xff);

            /* Cursor X High Register */
            wrDacReg(BT482_WADR_PAL, BT482_CUR_XHI);
            wrDacReg(BT482_PIX_RD_MSK, xp >> 8);

            /* Cursor Y Low Register */
            wrDacReg(BT482_WADR_PAL, BT482_CUR_YLOW);
            wrDacReg(BT482_PIX_RD_MSK, yp & 0xff);

            /* Cursor Y High Register */
            wrDacReg(BT482_WADR_PAL, BT482_CUR_YHI);
            wrDacReg(BT482_PIX_RD_MSK, yp >> 8);

            break;

        case BT485:
        case PX2085:
            wrDacReg(BT485_CUR_XLOW, xp & 0xff);
            wrDacReg(BT485_CUR_XHI, xp >> 8);
            wrDacReg(BT485_CUR_YLOW, yp & 0xff);
            wrDacReg(BT485_CUR_YHI, yp >> 8);
            break;


        case VIEWPOINT:
         wrDacReg(VPOINT_INDEX, VPOINT_CUR_XLOW);
         wrDacReg(VPOINT_DATA, xp & 0xff);
         wrDacReg(VPOINT_INDEX, VPOINT_CUR_XHI);
         wrDacReg(VPOINT_DATA, xp >> 8);
         wrDacReg(VPOINT_INDEX, VPOINT_CUR_YLOW);
         wrDacReg(VPOINT_DATA, yp & 0xff);
         wrDacReg(VPOINT_INDEX, VPOINT_CUR_YHI);
         wrDacReg(VPOINT_DATA, yp >> 8);
            break;

      case TVP3026:
         {
         int delta;

         if(Hw[iBoard].cursorInfo.CurWidth == 32)
            {
            yp += 32;
            xp += 32;
            }

         /* Patch for TVP3026 rev 2 the cursor can not go out of */
         /* visible space                                        */

         if ( revTVP[iBoard] <= 2 )
            {
            delta = (int)xp - (int)(Hw[iBoard].pCurrentDisplayMode->DispWidth - 2);
            if (delta < 0) delta = 0;
            if (delta < 64)
               {
               xp -= (word)delta;
               if (delta != currentTVPDelta[iBoard])
                  {
                  currentTVPDelta[iBoard] = (word)delta;
                  shiftCursorTVP3026((word)delta);
                  }
               }
            }
         wrDacReg(TVP3026_CUR_XLOW, xp & 0xff);
         wrDacReg(TVP3026_CUR_XHI, xp >> 8);
         wrDacReg(TVP3026_CUR_YLOW, yp & 0xff);
         wrDacReg(TVP3026_CUR_YHI, yp >> 8);
         }
            break;

    }
}


/***************************************************************************
Function    : mtxCursorGetInfo
description : returns a pointer containing the information describing
                  the type of cursor that the current RamDac supports
parameters  :
returns     : CursorInfo *

*****************************************************************************/
CursorInfo * mtxCursorGetInfo()
{

    return (CursorInfo *)&Hw[iBoard].cursorInfo;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mga_nt.h ===
/**************************************************************************\

$Header: o:\src/RCS/MGA_NT.H 1.8 94/01/05 12:05:07 jyharbec Exp $

$Log:   MGA_NT.H $
 * Revision 1.8  94/01/05  12:05:07  jyharbec
 * New CURSOR_INFO, HW_DATA structures, new QUERY_HW_DATA service definition.
 *
 * Revision 1.7  93/12/14  03:53:00  jyharbec
 * Define 46E8 in VIDEO_ACCESS_RANGE.
 *
 * Revision 1.6  93/11/04  06:14:53  dlee
 * Modified for Alpha
 *
 * Revision 1.5  93/10/15  11:30:59  jyharbec
 * Added definitions for ViewPoint and IOCTL_VIDEO_MTX_QUERY_BOARD_ID.
 *
 * Revision 1.4  93/10/06  05:41:00  jyharbec
 * *** empty log message ***
 *
 * Revision 1.3  93/09/23  11:42:22  jyharbec
 * New structure definition: RAMDAC_INFO.
 *
 * Revision 1.2  93/09/01  13:28:30  jyharbec
 * Added #defines for DispType fields.
 *
 * Revision 1.1  93/08/27  12:37:16  jyharbec
 * Initial revision
 *

\**************************************************************************/

/****************************************************************************\
* MODULE: MGA_NT.H
*
* DESCRIPTION: This module contains the definitions for the MGA miniport
*              driver. [Based on S3.H (Mar 1,1993) from  Windows-NT DDK]
*
* Copyright (c) 1990-1992  Microsoft Corporation
* Copyright (c) 1993  Matrox Electronic Systems Inc.
\****************************************************************************/

// Bit definitions for HwModeData.DispType

#define     DISPTYPE_INTERLACED     0x01
#define     DISPTYPE_TV             0x02
#define     DISPTYPE_LUT            0x04
#define     DISPTYPE_M565           0x08
#define     DISPTYPE_DB             0x10
#define     DISPTYPE_MON_LIMITED    0x20
#define     DISPTYPE_HW_LIMITED     0x40
#define     DISPTYPE_UNDISPLAYABLE  0x80

#define     DISPTYPE_UNUSABLE       (DISPTYPE_TV           |  \
                                     DISPTYPE_MON_LIMITED  |  \
                                     DISPTYPE_HW_LIMITED   |  \
                                     DISPTYPE_UNDISPLAYABLE)

#define MGA_BUS_INVALID     0
#define MGA_BUS_PCI         1
#define MGA_BUS_ISA         2

// We can support 8, 16, 24, or 32bpp displays, at any of a number of
// resolutions.  A compact way to encode this information would be to
// use a dword and lots of bit fields.  Bits 0-6 would code for a
// given resolution, while bit 7 would be invalid.  Shifting these bits
// by 0, 8, 16, or 24 would code for 8, 16, 24, or 32 bpp:

#define BIT_640              0
#define BIT_768              1
#define BIT_800              2
#define BIT_1024             3
#define BIT_1152             4
#define BIT_1280             5
#define BIT_1600             6
#define BIT_INVALID         32

#define MODE_8BPP_SHIFT      0
#define MODE_16BPP_SHIFT     8
#define MODE_24BPP_SHIFT    16
#define MODE_32BPP_SHIFT    24

// Definitions for AttributeFlags field of VIDEO_MODE_INFORMATION structure.
#define VIDEO_MODE_555      0x80000000
#define VIDEO_MODE_3D       0x40000000

typedef struct  tagSIZEL
{
    LONG cx;
    LONG cy;
} SIZEL, *PSIZEL;

// Our 'SuperMode' structure for multi-board support.
// This describes the supermode, which boards will be involved in supporting
// it, and which mode of each board will be required.

typedef struct _MULTI_MODE
{
    ULONG   MulModeNumber;                // unique mode Id
    ULONG   MulWidth;                     // total width of mode
    ULONG   MulHeight;                    // total height of mode
    ULONG   MulPixWidth;                  // pixel depth of mode
    ULONG   MulRefreshRate;               // refresh rate of mode
    USHORT  MulArrayWidth;                // number of boards arrayed along X
    USHORT  MulArrayHeight;               // number of boards arrayed along Y
    UCHAR   MulBoardNb[NB_BOARD_MAX];     // board numbers of required boards
    USHORT  MulBoardMode[NB_BOARD_MAX];   // mode required from each board
    HwModeData *MulHwModes[NB_BOARD_MAX]; // pointers to required HwModeData
} MULTI_MODE, *PMULTI_MODE;

typedef enum {
    TYPE_QVISION_PCI,
    TYPE_QVISION_ISA,
    TYPE_MATROX
    }   BOARD_TYPE;

/*--------------------------------------------------------------------------*\
| HW_DEVICE_EXTENSION
|
| Define device extension structure. This is device dependant/private
| information.
|
\*--------------------------------------------------------------------------*/
typedef struct _MGA_DEVICE_EXTENSION {
    ULONG   SuperModeNumber;                // Current mode number
    ULONG   NumberOfSuperModes;             // Total number of modes
    PMULTI_MODE pSuperModes;                // Array of super-modes structures
                                            // For each board:
    ULONG   NumberOfModes[NB_BOARD_MAX];    // Number of available modes
    ULONG   NumberOfValidModes[NB_BOARD_MAX];
                                            // Number of valid modes
    ULONG   ModeFlags2D[NB_BOARD_MAX];      // 2D modes supported by each board
    ULONG   ModeFlags3D[NB_BOARD_MAX];      // 3D modes supported by each board
    USHORT  ModeFreqs[NB_BOARD_MAX][64];    // Refresh rates bit fields
    UCHAR   ModeList[NB_BOARD_MAX][64];     // Valid hardware modes list
    HwModeData *pMgaHwModes[NB_BOARD_MAX];  // Array of mode information structs.
    BOOLEAN bUsingInt10;                    // May need this later
    PVOID   KernelModeMappedBaseAddress[NB_BOARD_MAX];
                                            // Kern-mode virt addr base of MGA regs
    PVOID   UserModeMappedBaseAddress[NB_BOARD_MAX];
                                            // User-mode virt addr base of MGA regs
    PVOID   MappedAddress[20];              // NUM_MGA_COMMON_ACCESS_RANGES elements
    BOARD_TYPE BoardId;
} MGA_DEVICE_EXTENSION, *PMGA_DEVICE_EXTENSION;

#define TITAN_SEQ_ADDR_PORT   (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c4 - 0x3c0))
#define TITAN_SEQ_DATA_PORT   (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c5 - 0x3c0))
#define TITAN_GCTL_ADDR_PORT  (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3ce - 0x3c0))
#define TITAN_GCTL_DATA_PORT  (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3cf - 0x3c0))
#define TITAN_1_CRTC_ADDR_PORT (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3d4 - 0x3d4))
#define TITAN_1_CRTC_DATA_PORT (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3d5 - 0x3d4))
//#define ADDR_46E8_PORT        (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[5]) + (0x46e8 - 0x46e8))
#define ADDR_46E8_PORT        0x46e8


/*--------------------------------------------------------------------------*\
| Structure definitions
\*--------------------------------------------------------------------------*/

typedef struct _VIDEO_NUM_OFFSCREEN_BLOCKS
{
    ULONG       NumBlocks;              // number of offscreen blocks
    ULONG       OffscreenBlockLength;   // size of OFFSCREEN_BLOCK structure
} VIDEO_NUM_OFFSCREEN_BLOCKS, *PVIDEO_NUM_OFFSCREEN_BLOCKS;

typedef struct _OFFSCREEN_BLOCK
{
    ULONG       Type;           // N_VRAM, N_DRAM, Z_VRAM, or Z_DRAM
    ULONG       XStart;         // X origin of offscreen memory area
    ULONG       YStart;         // Y origin of offscreen memory area
    ULONG       Width;          // offscreen width, in pixels
    ULONG       Height;         // offscreen height, in pixels
    ULONG       SafePlanes;     // offscreen available planes
    ULONG       ZOffset;        // Z start offset, if any Z
} OFFSCREEN_BLOCK, *POFFSCREEN_BLOCK;

typedef struct _RAMDAC_INFO
{
    ULONG       Flags;          // Ramdac type
    ULONG       Width;          // Maximum cursor width
    ULONG       Height;         // Maximum cursor height
    ULONG       OverScanX;      // X overscan
    ULONG       OverScanY;      // Y overscan
} RAMDAC_INFO, *PRAMDAC_INFO;

// These structures are used with IOCTL_VIDEO_MTX_QUERY_HW_DATA.  They should
// be kept more or less in sync with the CursorInfo and HwData structures.

typedef struct _CURSOR_INFO
{
    ULONG   MaxWidth;
    ULONG   MaxHeight;
    ULONG   MaxDepth;
    ULONG   MaxColors;
    ULONG   CurWidth;
    ULONG   CurHeight;
    LONG    cHotSX;
    LONG    cHotSY;
    LONG    HotSX;
    LONG    HotSY;
} CURSOR_INFO, *PCURSOR_INFO;

typedef struct _HW_DATA
{
    ULONG       StructLength;   /* Structure length in bytes */
    ULONG       MapAddress;     /* Memory map address */
    ULONG       MapAddress2;    /* Physical base address, frame buffer */
    ULONG       RomAddress;     /* Physical base address, flash EPROM */
    ULONG       ProductType;    /* MGA Ultima ID, MGA Impression ID, ... */
    ULONG       ProductRev;     /* 4 bit revision codes as follows */
                                /* 0  - 3  : pcb   revision */
                                /* 4  - 7  : Titan revision */
                                /* 8  - 11 : Dubic revision */
                                /* 12 - 31 : all 1's indicating no other device
                                             present */
    ULONG       ShellRev;       /* Shell revision */
    ULONG       BindingRev;     /* Binding revision */

    ULONG       MemAvail;       /* Frame buffer memory in bytes */
    UCHAR       VGAEnable;      /* 0 = vga disabled, 1 = vga enabled */
    UCHAR       Sync;           /* relects the hardware straps  */
    UCHAR       Device8_16;     /* relects the hardware straps */

    UCHAR       PortCfg;        /* 0-Disabled, 1-Mouse Port, 2-Laser Port */
    UCHAR       PortIRQ;        /* IRQ level number, -1 = interrupts disabled */
    ULONG       MouseMap;       /* Mouse I/O map base if PortCfg = Mouse Port else don't care */
    UCHAR       MouseIRate;     /* Mouse interrupt rate in Hz */
    UCHAR       DacType;        /* 0 = BT482, 3 = BT485 */
    CURSOR_INFO cursorInfo;
    ULONG       VramAvail;      /* VRAM memory available on board in bytes */
    ULONG       DramAvail;      /* DRAM memory available on board in bytes */
    ULONG       CurrentOverScanX; /* Left overscan in pixels */
    ULONG       CurrentOverScanY; /* Top overscan in pixels */
    ULONG       YDstOrg;          /* Physical offset of display start */
    ULONG       YDstOrg_DB;     /* Starting offset for double buffer */
    ULONG       CurrentZoomFactor;
    ULONG       CurrentXStart;
    ULONG       CurrentYStart;
    ULONG       CurrentPanXGran;    /* X Panning granularity */
    ULONG       CurrentPanYGran;    /* Y Panning granularity */
    ULONG       Features;           /* Bit 0: 0 = DDC monitor not available */
                                    /*        1 = DDC monitor available     */
    UCHAR       Reserved[64];

    ULONG       MgaBase1;           /* MGA control aperture */
    ULONG       MgaBase2;           /* Direct frame buffer */
    ULONG       RomBase;            /* BIOS flash EPROM */
    ULONG       PresentMCLK;
} HW_DATA, *PHW_DATA;

/*--------------------------------------------------------------------------*\
| Constant definitions
\*--------------------------------------------------------------------------*/
#define VIDEO_MAX_COLOR_REGISTER  0xFF  // Highest DAC color register index.

// MGA Register Map
#define PALETTE_RAM_WRITE   (RAMDAC_OFFSET + 0)
#define PALETTE_DATA        (RAMDAC_OFFSET + 4)

// RamDacs
#define DacTypeBT482        BT482
#define DacTypeBT484        BT484
#define DacTypeBT485        BT485
#define DacTypeSIERRA       SIERRA
#define DacTypeCHAMELEON    CHAMELEON
#define DacTypeVIEWPOINT    VIEWPOINT
#define DacTypeTVP3026      TVP3026
#define DacTypePX2085       PX2085
#define RAMDAC_NONE         0x0000
#define RAMDAC_BT482        0x1000
#define RAMDAC_BT485        0x2000
#define RAMDAC_VIEWPOINT    0x3000
#define RAMDAC_TVP3026      0x4000
#define RAMDAC_PX2085       0x5000

#define ZOOM_X1                 0x00010001

#define MCTLWTST_STD            0xC0001010

#define TYPE_INTERLACED         0x01


/*--------------------------------------------------------------------------*\
| Private I/O request control codes
\*--------------------------------------------------------------------------*/
#define COMMON_FLAG 0x80000000
#define CUSTOM_FLAG 0x00002000

#define IOCTL_VIDEO_MTX_QUERY_NUM_OFFSCREEN_BLOCKS                        \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_OFFSCREEN_BLOCKS                            \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_INITIALIZE_MGA                                                                    \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x802, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_RAMDAC_INFO                                 \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_GET_UPDATED_INF                                   \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_BOARD_ID                                    \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_HW_DATA                                     \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_QUERY_BOARD_ARRAY                                 \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_MAKE_BOARD_CURRENT                                \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MTX_INIT_MODE_LIST                                    \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxfont.h ===
byte CharSet16[] =
{   0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 0   */
    0x00,0x00,0x7E,0x81,0xA5,0x81,0x81,0xBD,0x99,0x81,0x81,0x7E,0x00,0x00,0x00,0x00, /* ---- 1   */
    0x00,0x00,0x7E,0xFF,0xDB,0xFF,0xFF,0xC3,0xE7,0xFF,0xFF,0x7E,0x00,0x00,0x00,0x00, /* ---- 2   */
    0x00,0x00,0x00,0x00,0x6C,0xFE,0xFE,0xFE,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00, /* ---- 3   */
    0x00,0x00,0x00,0x00,0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00,0x00, /* ---- 4   */
    0x00,0x00,0x00,0x18,0x3C,0x3C,0xE7,0xE7,0xE7,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- 5   */
    0x00,0x00,0x00,0x18,0x3C,0x7E,0xFF,0xFF,0x7E,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- 6   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 7   */
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC3,0xC3,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /* ---- 8   */
    0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x42,0x42,0x66,0x3C,0x00,0x00,0x00,0x00,0x00, /* ---- 9   */
    0xFF,0xFF,0xFF,0xFF,0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF,0xFF,0xFF,0xFF,0xFF, /* ---- 10  */
    0x00,0x00,0x1E,0x0E,0x1A,0x32,0x78,0xCC,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00, /* ---- 11  */
    0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3C,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- 12  */
    0x00,0x00,0x3F,0x33,0x3F,0x30,0x30,0x30,0x30,0x70,0xF0,0xE0,0x00,0x00,0x00,0x00, /* ---- 13  */
    0x00,0x00,0x7F,0x63,0x7F,0x63,0x63,0x63,0x63,0x67,0xE7,0xE6,0xC0,0x00,0x00,0x00, /* ---- 14  */
    0x00,0x00,0x00,0x18,0x18,0xDB,0x3C,0xE7,0x3C,0xDB,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- 15  */
    0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFE,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00, /* ---- 16  */
    0x00,0x02,0x06,0x0E,0x1E,0x3E,0xFE,0x3E,0x1E,0x0E,0x06,0x02,0x00,0x00,0x00,0x00, /* ---- 17  */
    0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00,0x00, /* ---- 18  */
    0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00,0x00, /* ---- 19  */
    0x00,0x00,0x7F,0xDB,0xDB,0xDB,0x7B,0x1B,0x1B,0x1B,0x1B,0x1B,0x00,0x00,0x00,0x00, /* ---- 20  */
    0x00,0x7C,0xC6,0x60,0x38,0x6C,0xC6,0xC6,0x6C,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00, /* ---- 21  */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFE,0xFE,0xFE,0x00,0x00,0x00,0x00, /* ---- 22  */
    0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x7E,0x3C,0x18,0x7E,0x00,0x00,0x00,0x00, /* ---- 23  */
    0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- 24  */
    0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00,0x00, /* ---- 25  */
    0x00,0x00,0x00,0x00,0x00,0x18,0x0C,0xFE,0x0C,0x18,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 26  */
    0x00,0x00,0x00,0x00,0x00,0x30,0x60,0xFE,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 27  */
    0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xFE,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 28  */
    0x00,0x00,0x00,0x00,0x00,0x28,0x6C,0xFE,0x6C,0x28,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 29  */
    0x00,0x00,0x00,0x00,0x10,0x38,0x38,0x7C,0x7C,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00, /* ---- 30  */
    0x00,0x00,0x00,0x00,0xFE,0xFE,0x7C,0x7C,0x38,0x38,0x10,0x00,0x00,0x00,0x00,0x00, /* ---- 31  */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ----     */
    0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- !   */
    0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- "   */
    0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00, /* ---- #   */
    0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00,0x00, /* ---- $   */
    0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x60,0xC6,0x86,0x00,0x00,0x00,0x00, /* ---- %   */
    0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- &   */
    0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- '   */
    0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00, /* ---- (   */
    0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00, /* ---- )   */
    0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- *   */
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- +   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00, /* ---- ,   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- -   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- .   */
    0x00,0x00,0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00, /* ---- /   */
    0x00,0x00,0x38,0x6C,0xC6,0xC6,0xD6,0xD6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00, /* ---- 0   */
    0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00, /* ---- 1   */
    0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC0,0xC6,0xFE,0x00,0x00,0x00,0x00, /* ---- 2   */
    0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 3   */
    0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00, /* ---- 4   */
    0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 5   */
    0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 6   */
    0x00,0x00,0xFE,0xC6,0x06,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00, /* ---- 7   */
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 8   */
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x06,0x0C,0x78,0x00,0x00,0x00,0x00, /* ---- 9   */
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00, /* ---- :   */
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00, /* ---- ;   */
    0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00, /* ---- <   */
    0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- =   */
    0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00, /* ---- >   */
    0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- ?   */
    0x00,0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00,0x00, /* ---- @   */
    0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- A   */
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0xFC,0x00,0x00,0x00,0x00, /* ---- B   */
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00,0x00, /* ---- C   */
    0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00,0x00, /* ---- D   */
    0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00, /* ---- E   */
    0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, /* ---- F   */
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0xC6,0x66,0x3A,0x00,0x00,0x00,0x00, /* ---- G   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- H   */
    0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- I   */
    0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00,0x00, /* ---- J   */
    0x00,0x00,0xE6,0x66,0x66,0x6C,0x78,0x78,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00,0x00, /* ---- K   */
    0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00,0x00, /* ---- L   */
    0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- M   */
    0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- N   */
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- O   */
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, /* ---- P   */
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00, /* ---- Q   */
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00, /* ---- R   */
    0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0x06,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- S   */
    0x00,0x00,0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- T   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- U   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00,0x00, /* ---- V   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00, /* ---- W   */
    0x00,0x00,0xC6,0xC6,0x6C,0x7C,0x38,0x38,0x7C,0x6C,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- X   */
    0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- Y   */
    0x00,0x00,0xFE,0xC6,0x86,0x0C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00,0x00, /* ---- Z   */
    0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00, /* ---- [   */
    0x00,0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x06,0x02,0x00,0x00,0x00,0x00, /* ---- \   */
    0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00, /* ---- ]   */
    0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- ^   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00, /* ---- _   */
    0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- `   */
    0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- a   */
    0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00, /* ---- b   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- c   */
    0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- d   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- e   */
    0x00,0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, /* ---- f   */
    0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00, /* ---- g   */
    0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0xE6,0x00,0x00,0x00,0x00, /* ---- h   */
    0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- i   */
    0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00, /* ---- j   */
    0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00,0x00, /* ---- k   */
    0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- l   */
    0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00, /* ---- m   */
    0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00, /* ---- n   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- o   */
    0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00, /* ---- p   */
    0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00, /* ---- q   */
    0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0x60,0xF0,0x00,0x00,0x00,0x00, /* ---- r   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x60,0x38,0x0C,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- s   */
    0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00,0x00, /* ---- t   */
    0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- u   */
    0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00, /* ---- v   */
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00, /* ---- w   */
    0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00, /* ---- x   */
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00, /* ---- y   */
    0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00, /* ---- z   */
    0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00, /* ---- {   */
    0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- |   */
    0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00, /* ---- }   */
    0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- ~   */
    0x00,0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00, /* ---- 127 */
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x0C,0x06,0x7C,0x00,0x00, /* ---- 128 */
    0x00,0x00,0xCC,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 129 */
    0x00,0x0C,0x18,0x30,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 130 */
    0x00,0x10,0x38,0x6C,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 131 */
    0x00,0x00,0xCC,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 132 */
    0x00,0x60,0x30,0x18,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 133 */
    0x00,0x38,0x6C,0x38,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 134 */
    0x00,0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x66,0x3C,0x0C,0x06,0x3C,0x00,0x00,0x00, /* ---- 135 */
    0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 136 */
    0x00,0x00,0xC6,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 137 */
    0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xFE,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 138 */
    0x00,0x00,0x66,0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- 139 */
    0x00,0x18,0x3C,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- 140 */
    0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- 141 */
    0x00,0xC6,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- 142 */
    0x38,0x6C,0x38,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- 143 */
    0x18,0x30,0x60,0x00,0xFE,0x66,0x60,0x7C,0x60,0x60,0x66,0xFE,0x00,0x00,0x00,0x00, /* ---- 144 */
    0x00,0x00,0x00,0x00,0x00,0xCC,0x76,0x36,0x7E,0xD8,0xD8,0x6E,0x00,0x00,0x00,0x00, /* ---- 145 */
    0x00,0x00,0x3E,0x6C,0xCC,0xCC,0xFE,0xCC,0xCC,0xCC,0xCC,0xCE,0x00,0x00,0x00,0x00, /* ---- 146 */
    0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 147 */
    0x00,0x00,0xC6,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 148 */
    0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 149 */
    0x00,0x30,0x78,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 150 */
    0x00,0x60,0x30,0x18,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 151 */
    0x00,0x00,0xC6,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00, /* ---- 152 */
    0x00,0xC6,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 153 */
    0x00,0xC6,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 154 */
    0x00,0x18,0x18,0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- 155 */
    0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0x60,0xE6,0xFC,0x00,0x00,0x00,0x00, /* ---- 156 */
    0x00,0x00,0x66,0x66,0x3C,0x18,0x7E,0x18,0x7E,0x18,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- 157 */
    0x00,0xF8,0xCC,0xCC,0xF8,0xC4,0xCC,0xDE,0xCC,0xCC,0xCC,0xC6,0x00,0x00,0x00,0x00, /* ---- 158 */
    0x00,0x0E,0x1B,0x18,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x18,0xD8,0x70,0x00,0x00, /* ---- 159 */
    0x00,0x18,0x30,0x60,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 160 */
    0x00,0x0C,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, /* ---- 161 */
    0x00,0x18,0x30,0x60,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 162 */
    0x00,0x18,0x30,0x60,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00,0x00, /* ---- 163 */
    0x00,0x00,0x76,0xDC,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00, /* ---- 164 */
    0x76,0xDC,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- 165 */
    0x00,0x3C,0x6C,0x6C,0x3E,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 166 */
    0x00,0x38,0x6C,0x6C,0x38,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 167 */
    0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x60,0xC0,0xC6,0xC6,0x7C,0x00,0x00,0x00,0x00, /* ---- 168 */
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00, /* ---- 169 */
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,0x00, /* ---- 170 */
    0x00,0xC0,0xC0,0xC2,0xC6,0xCC,0x18,0x30,0x60,0xDC,0x86,0x0C,0x18,0x3E,0x00,0x00, /* ---- 171 */
    0x00,0xC0,0xC0,0xC2,0xC6,0xCC,0x18,0x30,0x66,0xCE,0x9E,0x3E,0x06,0x06,0x00,0x00, /* ---- 172 */
    0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x18,0x3C,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00, /* ---- 173 */
    0x00,0x00,0x00,0x00,0x00,0x36,0x6C,0xD8,0x6C,0x36,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 174 */
    0x00,0x00,0x00,0x00,0x00,0xD8,0x6C,0x36,0x6C,0xD8,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 175 */
    0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44, /* ---- 176 */
    0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA, /* ---- 177 */
    0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77, /* ---- 178 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 179 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 180 */
    0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 181 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 182 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 183 */
    0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 184 */
    0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 185 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 186 */
    0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 187 */
    0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 188 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 189 */
    0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 190 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 191 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 192 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 193 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 194 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 195 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 196 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 197 */
    0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 198 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 199 */
    0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 200 */
    0x00,0x00,0x00,0x00,0x00,0x3F,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 201 */
    0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 202 */
    0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 203 */
    0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 204 */
    0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 205 */
    0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 206 */
    0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 207 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 208 */
    0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 209 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 210 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 211 */
    0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 212 */
    0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 213 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 214 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 215 */
    0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 216 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 217 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 218 */
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /* ---- 219 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /* ---- 220 */
    0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0, /* ---- 221 */
    0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F, /* ---- 222 */
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 223 */
    0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0xD8,0xD8,0xD8,0xDC,0x76,0x00,0x00,0x00,0x00, /* ---- 224 */
    0x00,0x00,0x78,0xCC,0xCC,0xCC,0xD8,0xCC,0xC6,0xC6,0xC6,0xCC,0x00,0x00,0x00,0x00, /* ---- 225 */
    0x00,0x00,0xFE,0xC6,0xC6,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00, /* ---- 226 */
    0x00,0x00,0x00,0x00,0xFE,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00, /* ---- 227 */
    0x00,0x00,0x00,0xFE,0xC6,0x60,0x30,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00,0x00, /* ---- 228 */
    0x00,0x00,0x00,0x00,0x00,0x7E,0xD8,0xD8,0xD8,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00, /* ---- 229 */
    0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xC0,0x00,0x00,0x00, /* ---- 230 */
    0x00,0x00,0x00,0x00,0x76,0xDC,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- 231 */
    0x00,0x00,0x00,0x7E,0x18,0x3C,0x66,0x66,0x66,0x3C,0x18,0x7E,0x00,0x00,0x00,0x00, /* ---- 232 */
    0x00,0x00,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00,0x00, /* ---- 233 */
    0x00,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x6C,0x6C,0x6C,0xEE,0x00,0x00,0x00,0x00, /* ---- 234 */
    0x00,0x00,0x1E,0x30,0x18,0x0C,0x3E,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00, /* ---- 235 */
    0x00,0x00,0x00,0x00,0x00,0x7E,0xDB,0xDB,0xDB,0x7E,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 236 */
    0x00,0x00,0x00,0x03,0x06,0x7E,0xDB,0xDB,0xF3,0x7E,0x60,0xC0,0x00,0x00,0x00,0x00, /* ---- 237 */
    0x00,0x00,0x1C,0x30,0x60,0x60,0x7C,0x60,0x60,0x60,0x30,0x1C,0x00,0x00,0x00,0x00, /* ---- 238 */
    0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00, /* ---- 239 */
    0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00, /* ---- 240 */
    0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0xFF,0x00,0x00,0x00,0x00, /* ---- 241 */
    0x00,0x00,0x00,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,0x7E,0x00,0x00,0x00,0x00, /* ---- 242 */
    0x00,0x00,0x00,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,0x7E,0x00,0x00,0x00,0x00, /* ---- 243 */
    0x00,0x00,0x0E,0x1B,0x1B,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 244 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xD8,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00, /* ---- 245 */
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x7E,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00, /* ---- 246 */
    0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 247 */
    0x00,0x38,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 248 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 249 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 250 */
    0x00,0x0F,0x0C,0x0C,0x0C,0x0C,0x0C,0xEC,0x6C,0x6C,0x3C,0x1C,0x00,0x00,0x00,0x00, /* ---- 251 */
    0x00,0xD8,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 252 */
    0x00,0x70,0xD8,0x30,0x60,0xC8,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 253 */
    0x00,0x00,0x00,0x00,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x00,0x00,0x00,0x00,0x00, /* ---- 254 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  /* -----255 */
};

byte CharSet14[] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 0   */
    0x00,0x00,0x7E,0x81,0xA5,0x81,0x81,0xBD,0x99,0x81,0x7E,0x00,0x00,0x00, /* ---- 1   */
    0x00,0x00,0x7E,0xFF,0xDB,0xFF,0xFF,0xC3,0xE7,0xFF,0x7E,0x00,0x00,0x00, /* ---- 2   */
    0x00,0x00,0x00,0x6C,0xFE,0xFE,0xFE,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00, /* ---- 3   */
    0x00,0x00,0x00,0x10,0x38,0x7C,0xFE,0x7C,0x38,0x10,0x00,0x00,0x00,0x00, /* ---- 4   */
    0x00,0x00,0x18,0x3C,0x3C,0xE7,0xE7,0xE7,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- 5   */
    0x00,0x00,0x18,0x3C,0x7E,0xFF,0xFF,0x7E,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- 6   */
    0x00,0x00,0x00,0x00,0x00,0x18,0x3C,0x3C,0x18,0x00,0x00,0x00,0x00,0x00, /* ---- 7   */
    0xFF,0xFF,0xFF,0xFF,0xFF,0xE7,0xC3,0xC3,0xE7,0xFF,0xFF,0xFF,0xFF,0xFF, /* ---- 8   */
    0x00,0x00,0x00,0x00,0x3C,0x66,0x42,0x42,0x66,0x3C,0x00,0x00,0x00,0x00, /* ---- 9   */
    0xFF,0xFF,0xFF,0xFF,0xC3,0x99,0xBD,0xBD,0x99,0xC3,0xFF,0xFF,0xFF,0xFF, /* ---- 10  */
    0x00,0x00,0x1E,0x0E,0x1A,0x32,0x78,0xCC,0xCC,0xCC,0x78,0x00,0x00,0x00, /* ---- 11  */
    0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x18,0x7E,0x18,0x18,0x00,0x00,0x00, /* ---- 12  */
    0x00,0x00,0x3F,0x33,0x3F,0x30,0x30,0x30,0x70,0xF0,0xE0,0x00,0x00,0x00, /* ---- 13  */
    0x00,0x00,0x7F,0x63,0x7F,0x63,0x63,0x63,0x67,0xE7,0xE6,0xC0,0x00,0x00, /* ---- 14  */
    0x00,0x00,0x18,0x18,0xDB,0x3C,0xE7,0x3C,0xDB,0x18,0x18,0x00,0x00,0x00, /* ---- 15  */
    0x00,0x00,0x80,0xC0,0xE0,0xF8,0xFE,0xF8,0xE0,0xC0,0x80,0x00,0x00,0x00, /* ---- 16  */
    0x00,0x00,0x02,0x06,0x0E,0x3E,0xFE,0x3E,0x0E,0x06,0x02,0x00,0x00,0x00, /* ---- 17  */
    0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00, /* ---- 18  */
    0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00, /* ---- 19  */
    0x00,0x00,0x7F,0xDB,0xDB,0xDB,0x7B,0x1B,0x1B,0x1B,0x1B,0x00,0x00,0x00, /* ---- 20  */
    0x00,0x7C,0xC6,0x60,0x38,0x6C,0xC6,0xC6,0x6C,0x38,0x0C,0xC6,0x7C,0x00, /* ---- 21  */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xFE,0xFE,0x00,0x00,0x00, /* ---- 22  */
    0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x7E,0x3C,0x18,0x7E,0x00,0x00, /* ---- 23  */
    0x00,0x00,0x18,0x3C,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00, /* ---- 24  */
    0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x3C,0x18,0x00,0x00,0x00, /* ---- 25  */
    0x00,0x00,0x00,0x00,0x18,0x0C,0xFE,0x0C,0x18,0x00,0x00,0x00,0x00,0x00, /* ---- 26  */
    0x00,0x00,0x00,0x00,0x30,0x60,0xFE,0x60,0x30,0x00,0x00,0x00,0x00,0x00, /* ---- 27  */
    0x00,0x00,0x00,0x00,0x00,0xC0,0xC0,0xC0,0xFE,0x00,0x00,0x00,0x00,0x00, /* ---- 28  */
    0x00,0x00,0x00,0x00,0x28,0x6C,0xFE,0x6C,0x28,0x00,0x00,0x00,0x00,0x00, /* ---- 29  */
    0x00,0x00,0x00,0x10,0x38,0x38,0x7C,0x7C,0xFE,0xFE,0x00,0x00,0x00,0x00, /* ---- 30  */
    0x00,0x00,0x00,0xFE,0xFE,0x7C,0x7C,0x38,0x38,0x10,0x00,0x00,0x00,0x00, /* ---- 31  */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ----     */
    0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00, /* ---- !   */
    0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- "   */
    0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00, /* ---- #   */
    0x18,0x18,0x7C,0xC6,0xC2,0xC0,0x7C,0x06,0x86,0xC6,0x7C,0x18,0x18,0x00, /* ---- $   */
    0x00,0x00,0x00,0x00,0xC2,0xC6,0x0C,0x18,0x30,0x66,0xC6,0x00,0x00,0x00, /* ---- %   */
    0x00,0x00,0x38,0x6C,0x6C,0x38,0x76,0xDC,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- &   */
    0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- '   */
    0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00, /* ---- (   */
    0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00, /* ---- )   */
    0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00, /* ---- *   */
    0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00, /* ---- +   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00, /* ---- ,   */
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- -   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00, /* ---- .   */
    0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00,0x00,0x00,0x00, /* ---- /   */
    0x00,0x00,0x7C,0xC6,0xCE,0xDE,0xF6,0xE6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 0   */
    0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00, /* ---- 1   */
    0x00,0x00,0x7C,0xC6,0x06,0x0C,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00, /* ---- 2   */
    0x00,0x00,0x7C,0xC6,0x06,0x06,0x3C,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00, /* ---- 3   */
    0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x1E,0x00,0x00,0x00, /* ---- 4   */
    0x00,0x00,0xFE,0xC0,0xC0,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00,0x00,0x00, /* ---- 5   */
    0x00,0x00,0x38,0x60,0xC0,0xC0,0xFC,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 6   */
    0x00,0x00,0xFE,0xC6,0x06,0x0C,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00, /* ---- 7   */
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 8   */
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7E,0x06,0x06,0x0C,0x78,0x00,0x00,0x00, /* ---- 9   */
    0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- :   */
    0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00, /* ---- ;   */
    0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00, /* ---- <   */
    0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00, /* ---- =   */
    0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00, /* ---- >   */
    0x00,0x00,0x7C,0xC6,0xC6,0x0C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00, /* ---- ?   */
    0x00,0x00,0x7C,0xC6,0xC6,0xDE,0xDE,0xDE,0xDC,0xC0,0x7C,0x00,0x00,0x00, /* ---- @   */
    0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00,0x00,0x00, /* ---- A   */
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0xFC,0x00,0x00,0x00, /* ---- B   */
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC0,0xC2,0x66,0x3C,0x00,0x00,0x00, /* ---- C   */
    0x00,0x00,0xF8,0x6C,0x66,0x66,0x66,0x66,0x66,0x6C,0xF8,0x00,0x00,0x00, /* ---- D   */
    0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x62,0x66,0xFE,0x00,0x00,0x00, /* ---- E   */
    0x00,0x00,0xFE,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0xF0,0x00,0x00,0x00, /* ---- F   */
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xDE,0xC6,0x66,0x3A,0x00,0x00,0x00, /* ---- G   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00, /* ---- H   */
    0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- I   */
    0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00,0x00,0x00, /* ---- J   */
    0x00,0x00,0xE6,0x66,0x6C,0x6C,0x78,0x6C,0x6C,0x66,0xE6,0x00,0x00,0x00, /* ---- K   */
    0x00,0x00,0xF0,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xFE,0x00,0x00,0x00, /* ---- L   */
    0x00,0x00,0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00, /* ---- M   */
    0x00,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0xC6,0x00,0x00,0x00, /* ---- N   */
    0x00,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00, /* ---- O   */
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0xF0,0x00,0x00,0x00, /* ---- P   */
    0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x0C,0x0E,0x00,0x00, /* ---- Q   */
    0x00,0x00,0xFC,0x66,0x66,0x66,0x7C,0x6C,0x66,0x66,0xE6,0x00,0x00,0x00, /* ---- R   */
    0x00,0x00,0x7C,0xC6,0xC6,0x60,0x38,0x0C,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- S   */
    0x00,0x00,0x7E,0x7E,0x5A,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- T   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- U   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x10,0x00,0x00,0x00, /* ---- V   */
    0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xD6,0xFE,0x7C,0x6C,0x00,0x00,0x00, /* ---- W   */
    0x00,0x00,0xC6,0xC6,0x6C,0x38,0x38,0x38,0x6C,0xC6,0xC6,0x00,0x00,0x00, /* ---- X   */
    0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- Y   */
    0x00,0x00,0xFE,0xC6,0x8C,0x18,0x30,0x60,0xC2,0xC6,0xFE,0x00,0x00,0x00, /* ---- Z   */
    0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00, /* ---- [   */
    0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x06,0x02,0x00,0x00,0x00, /* ---- \   */
    0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00, /* ---- ]   */
    0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- ^   */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00, /* ---- _   */
    0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- `   */
    0x00,0x00,0x00,0x00,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- a   */
    0x00,0x00,0xE0,0x60,0x60,0x78,0x6C,0x66,0x66,0x66,0x7C,0x00,0x00,0x00, /* ---- b   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC0,0xC0,0xC6,0x7C,0x00,0x00,0x00, /* ---- c   */
    0x00,0x00,0x1C,0x0C,0x0C,0x3C,0x6C,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- d   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00, /* ---- e   */
    0x00,0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0xF0,0x00,0x00,0x00, /* ---- f   */
    0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0x7C,0x0C,0xCC,0x78,0x00, /* ---- g   */
    0x00,0x00,0xE0,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0xE6,0x00,0x00,0x00, /* ---- h   */
    0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- i   */
    0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00, /* ---- j   */
    0x00,0x00,0xE0,0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00,0x00,0x00, /* ---- k   */
    0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- l   */
    0x00,0x00,0x00,0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00, /* ---- m   */
    0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00, /* ---- n   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- o   */
    0x00,0x00,0x00,0x00,0x00,0xDC,0x66,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00, /* ---- p   */
    0x00,0x00,0x00,0x00,0x00,0x76,0xCC,0xCC,0xCC,0x7C,0x0C,0x0C,0x1E,0x00, /* ---- q   */
    0x00,0x00,0x00,0x00,0x00,0xDC,0x76,0x66,0x60,0x60,0xF0,0x00,0x00,0x00, /* ---- r   */
    0x00,0x00,0x00,0x00,0x00,0x7C,0xC6,0x70,0x1C,0xC6,0x7C,0x00,0x00,0x00, /* ---- s   */
    0x00,0x00,0x10,0x30,0x30,0xFC,0x30,0x30,0x30,0x36,0x1C,0x00,0x00,0x00, /* ---- t   */
    0x00,0x00,0x00,0x00,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- u   */
    0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00, /* ---- v   */
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xD6,0xFE,0x6C,0x00,0x00,0x00, /* ---- w   */
    0x00,0x00,0x00,0x00,0x00,0xC6,0x6C,0x38,0x38,0x6C,0xC6,0x00,0x00,0x00, /* ---- x   */
    0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0xF8,0x00, /* ---- y   */
    0x00,0x00,0x00,0x00,0x00,0xFE,0xCC,0x18,0x30,0x66,0xFE,0x00,0x00,0x00, /* ---- z   */
    0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x0E,0x00,0x00,0x00, /* ---- {   */
    0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x00,0x00,0x00, /* ---- |   */
    0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x70,0x00,0x00,0x00, /* ---- }   */
    0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- ~   */
    0x00,0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00, /* ---- 127 */
    0x00,0x00,0x3C,0x66,0xC2,0xC0,0xC0,0xC2,0x66,0x3C,0x0C,0x06,0x7C,0x00, /* ---- 128 */
    0x00,0x00,0xCC,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 129 */
    0x00,0x0C,0x18,0x30,0x00,0x7C,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00, /* ---- 130 */
    0x00,0x10,0x38,0x6C,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 131 */
    0x00,0x00,0xCC,0xCC,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 132 */
    0x00,0x60,0x30,0x18,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 133 */
    0x00,0x38,0x6C,0x38,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 134 */
    0x00,0x00,0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x0C,0x06,0x3C,0x00,0x00, /* ---- 135 */
    0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00, /* ---- 136 */
    0x00,0x00,0xCC,0xCC,0x00,0x7C,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00, /* ---- 137 */
    0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xFE,0xC0,0xC6,0x7C,0x00,0x00,0x00, /* ---- 138 */
    0x00,0x00,0x66,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- 139 */
    0x00,0x18,0x3C,0x66,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- 140 */
    0x00,0x60,0x30,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- 141 */
    0x00,0xC6,0xC6,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00,0x00,0x00, /* ---- 142 */
    0x38,0x6C,0x38,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00,0x00,0x00, /* ---- 143 */
    0x18,0x30,0x60,0x00,0xFE,0x66,0x60,0x7C,0x60,0x66,0xFE,0x00,0x00,0x00, /* ---- 144 */
    0x00,0x00,0x00,0x00,0xCC,0x76,0x36,0x7E,0xD8,0xD8,0x6E,0x00,0x00,0x00, /* ---- 145 */
    0x00,0x00,0x3E,0x6C,0xCC,0xCC,0xFE,0xCC,0xCC,0xCC,0xCE,0x00,0x00,0x00, /* ---- 146 */
    0x00,0x10,0x38,0x6C,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 147 */
    0x00,0x00,0xC6,0xC6,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 148 */
    0x00,0x60,0x30,0x18,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 149 */
    0x00,0x30,0x78,0xCC,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 150 */
    0x00,0x60,0x30,0x18,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 151 */
    0x00,0x00,0xC6,0xC6,0x00,0xC6,0xC6,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00, /* ---- 152 */
    0x00,0xC6,0xC6,0x38,0x6C,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00, /* ---- 153 */
    0x00,0xC6,0xC6,0x00,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 154 */
    0x00,0x18,0x18,0x3C,0x66,0x60,0x60,0x66,0x3C,0x18,0x18,0x00,0x00,0x00, /* ---- 155 */
    0x00,0x38,0x6C,0x64,0x60,0xF0,0x60,0x60,0x60,0xE6,0xFC,0x00,0x00,0x00, /* ---- 156 */
    0x00,0x00,0x66,0x66,0x3C,0x18,0x7E,0x18,0x7E,0x18,0x18,0x00,0x00,0x00, /* ---- 157 */
    0x00,0xF8,0xCC,0xCC,0xF8,0xC4,0xCC,0xDE,0xCC,0xCC,0xC6,0x00,0x00,0x00, /* ---- 158 */
    0x00,0x0E,0x1B,0x18,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0xD8,0x70,0x00, /* ---- 159 */
    0x00,0x18,0x30,0x60,0x00,0x78,0x0C,0x7C,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 160 */
    0x00,0x0C,0x18,0x30,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00, /* ---- 161 */
    0x00,0x18,0x30,0x60,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 162 */
    0x00,0x18,0x30,0x60,0x00,0xCC,0xCC,0xCC,0xCC,0xCC,0x76,0x00,0x00,0x00, /* ---- 163 */
    0x00,0x00,0x76,0xDC,0x00,0xDC,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00, /* ---- 164 */
    0x76,0xDC,0x00,0xC6,0xE6,0xF6,0xFE,0xDE,0xCE,0xC6,0xC6,0x00,0x00,0x00, /* ---- 165 */
    0x00,0x3C,0x6C,0x6C,0x3E,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 166 */
    0x00,0x38,0x6C,0x6C,0x38,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 167 */
    0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x60,0xC6,0xC6,0x7C,0x00,0x00,0x00, /* ---- 168 */
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0xC0,0xC0,0xC0,0x00,0x00,0x00,0x00, /* ---- 169 */
    0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0x06,0x06,0x00,0x00,0x00,0x00, /* ---- 170 */
    0x00,0xC0,0xC0,0xC6,0xCC,0xD8,0x30,0x60,0xDC,0x86,0x0C,0x18,0x3E,0x00, /* ---- 171 */
    0x00,0xC0,0xC0,0xC6,0xCC,0xD8,0x30,0x66,0xCE,0x9E,0x3E,0x06,0x06,0x00, /* ---- 172 */
    0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x3C,0x3C,0x3C,0x18,0x00,0x00,0x00, /* ---- 173 */
    0x00,0x00,0x00,0x00,0x36,0x6C,0xD8,0x6C,0x36,0x00,0x00,0x00,0x00,0x00, /* ---- 174 */
    0x00,0x00,0x00,0x00,0xD8,0x6C,0x36,0x6C,0xD8,0x00,0x00,0x00,0x00,0x00, /* ---- 175 */
    0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44, /* ---- 176 */
    0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x55,0xAA, /* ---- 177 */
    0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77,0xDD,0x77, /* ---- 178 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 179 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 180 */
    0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 181 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xF6,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 182 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 183 */
    0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0xF8,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 184 */
    0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 185 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 186 */
    0x00,0x00,0x00,0x00,0x00,0xFE,0x06,0xF6,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 187 */
    0x36,0x36,0x36,0x36,0x36,0xF6,0x06,0xFE,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 188 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFE,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 189 */
    0x18,0x18,0x18,0x18,0x18,0xF8,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 190 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 191 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 192 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 193 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 194 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 195 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 196 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 197 */
    0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 198 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 199 */
    0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3F,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 200 */
    0x00,0x00,0x00,0x00,0x00,0x3F,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 201 */
    0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 202 */
    0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 203 */
    0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 204 */
    0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 205 */
    0x36,0x36,0x36,0x36,0x36,0xF7,0x00,0xF7,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 206 */
    0x18,0x18,0x18,0x18,0x18,0xFF,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 207 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 208 */
    0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0xFF,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 209 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 210 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3F,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 211 */
    0x18,0x18,0x18,0x18,0x18,0x1F,0x18,0x1F,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 212 */
    0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x1F,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 213 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 214 */
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xFF,0x36,0x36,0x36,0x36,0x36,0x36, /* ---- 215 */
    0x18,0x18,0x18,0x18,0x18,0xFF,0x18,0xFF,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 216 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xF8,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 217 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 218 */
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /* ---- 219 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF, /* ---- 220 */
    0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0, /* ---- 221 */
    0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,0x0F, /* ---- 222 */
    0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 223 */
    0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0xD8,0xD8,0xDC,0x76,0x00,0x00,0x00, /* ---- 224 */
    0x00,0x00,0x00,0x00,0x7C,0xC6,0xFC,0xC6,0xC6,0xFC,0xC0,0xC0,0x40,0x00, /* ---- 225 */
    0x00,0x00,0xFE,0xC6,0xC6,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0x00,0x00,0x00, /* ---- 226 */
    0x00,0x00,0x00,0x00,0xFE,0x6C,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00, /* ---- 227 */
    0x00,0x00,0xFE,0xC6,0x60,0x30,0x18,0x30,0x60,0xC6,0xFE,0x00,0x00,0x00, /* ---- 228 */
    0x00,0x00,0x00,0x00,0x00,0x7E,0xD8,0xD8,0xD8,0xD8,0x70,0x00,0x00,0x00, /* ---- 229 */
    0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x7C,0x60,0x60,0xC0,0x00,0x00, /* ---- 230 */
    0x00,0x00,0x00,0x00,0x76,0xDC,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00, /* ---- 231 */
    0x00,0x00,0x7E,0x18,0x3C,0x66,0x66,0x66,0x3C,0x18,0x7E,0x00,0x00,0x00, /* ---- 232 */
    0x00,0x00,0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x6C,0x38,0x00,0x00,0x00, /* ---- 233 */
    0x00,0x00,0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x6C,0x6C,0xEE,0x00,0x00,0x00, /* ---- 234 */
    0x00,0x00,0x1E,0x30,0x18,0x0C,0x3E,0x66,0x66,0x66,0x3C,0x00,0x00,0x00, /* ---- 235 */
    0x00,0x00,0x00,0x00,0x00,0x7E,0xDB,0xDB,0x7E,0x00,0x00,0x00,0x00,0x00, /* ---- 236 */
    0x00,0x00,0x03,0x06,0x7E,0xDB,0xDB,0xF3,0x7E,0x60,0xC0,0x00,0x00,0x00, /* ---- 237 */
    0x00,0x00,0x1C,0x30,0x60,0x60,0x7C,0x60,0x60,0x30,0x1C,0x00,0x00,0x00, /* ---- 238 */
    0x00,0x00,0x00,0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00, /* ---- 239 */
    0x00,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0xFE,0x00,0x00,0x00,0x00, /* ---- 240 */
    0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0xFF,0x00,0x00,0x00, /* ---- 241 */
    0x00,0x00,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,0x7E,0x00,0x00,0x00, /* ---- 242 */
    0x00,0x00,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,0x7E,0x00,0x00,0x00, /* ---- 243 */
    0x00,0x00,0x0E,0x1B,0x1B,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18, /* ---- 244 */
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xD8,0xD8,0x70,0x00,0x00,0x00, /* ---- 245 */
    0x00,0x00,0x00,0x18,0x18,0x00,0x7E,0x00,0x18,0x18,0x00,0x00,0x00,0x00, /* ---- 246 */
    0x00,0x00,0x00,0x00,0x76,0xDC,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00, /* ---- 247 */
    0x00,0x38,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 248 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 249 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 250 */
    0x00,0x0F,0x0C,0x0C,0x0C,0x0C,0x0C,0xEC,0x6C,0x3C,0x1C,0x00,0x00,0x00, /* ---- 251 */
    0x00,0xD8,0x6C,0x6C,0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 252 */
    0x00,0x70,0xD8,0x30,0x60,0xC8,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00, /* ---- 253 */
    0x00,0x00,0x00,0x00,0x7C,0x7C,0x7C,0x7C,0x7C,0x7C,0x00,0x00,0x00,0x00, /* ---- 254 */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  /* -----255 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxinit.c ===
/*/****************************************************************************
*          name: mtxinit.c
*
*   description: Routines to initialise MGA board
*
*      designed: Benoit Leblanc
* last modified: $Author: ctoutant $, $Date: 94/09/28 13:22:46 $
*
*       version: $Id: MTXINIT.C 1.91 94/09/28 13:22:46 ctoutant Exp $
*
*
* HwData *     mtxCheckHwAll(void)
* bool         mtxSelectHw(HwData *pHardware)
* HwModeData * mtxGetHwModes(void)
* bool         mtxSelectHwMode(HwModeData *pHwModeSelect)
* bool         mtxSetDisplayMode(HwModeData *pDisplayModeSelect, dword Zoom)
*
* dword        mtxGetMgaSel(void)
* void         mtxGetInfo(HwModeData *pCurHwMode, HwModeData *pCurDispMode,
*                         byte *InitBuffer, byte *VideoBuffer)
* bool         mtxSetLUT(word index, mtxRGB color)
* void         mtxClose(void)
*
******************************************************************************/

#include "switches.h"

#ifdef WINDOWS_NT
    #if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,mtxCheckHwAll)
    #pragma alloc_text(PAGE,mtxSelectHw)
    #pragma alloc_text(PAGE,mtxGetHwModes)
    #pragma alloc_text(PAGE,mtxSelectHwMode)
    #pragma alloc_text(PAGE,mtxSetDisplayMode)
    #pragma alloc_text(PAGE,overScan)
    #pragma alloc_text(PAGE,mapPciVl)
    #pragma alloc_text(PAGE,MapBoard)
    #pragma alloc_text(PAGE,adjustDefaultVidset)
    #pragma alloc_text(PAGE,selectMgaInfoBoard)
    #pragma alloc_text(PAGE,UpdateHwModeTable)
//    #pragma alloc_text(PAGE,mtxGetMgaSel)
    #pragma alloc_text(PAGE,mtxGetInfo)
    #pragma alloc_text(PAGE,InitHwStruct)
    #pragma alloc_text(PAGE,mtxSetLUT)
    #pragma alloc_text(PAGE,mtxClose)
    #endif

    //Not to be paged out:
    //  Hw
    //  pMgaBaseAddr
    //  iBoard
    //  mtxVideoMode
    //  pMgaDeviceExtension
    //#if defined(ALLOC_PRAGMA)
    //#pragma data_seg("PAGE")
    //#endif

#else   /* #ifdef WINDOWS_NT */

    #include <stdlib.h>
    #include <string.h>
    #include <stdio.h>
    #include <dos.h>
    #include <time.h>

#endif  /* #ifdef WINDOWS_NT */

#ifdef OS2
    #include <os2.h>
    #pragma intrinsic(strcat, strcpy)
#endif

#ifdef WINDOWS
   #include "windows.h"
#endif

#include "bind.h"
#include "defbind.h"
#include "sxci.h"
#include "def.h"
#include "mga.h"
#include "mgai_c.h"
#include "mgai.h"
#include "caddi.h"
#include "mtxpci.h"
#include "mtxvpro.h"
#include "vidfile.h"

#if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE))
/*********** DDC CODE ****************/
#include "edid.h"
/*********** DDC CODE ****************/
#endif

/* Externals from mgainfo.c (which used to be mgainfo.h) */
/* #include "mgainfo.h"  */  /* Default video parameters */
#ifdef WINDOWS_NT
    extern  UCHAR DefaultVidset[];
    extern  word configSpace;
#else
    extern  char DefaultVidset[];
#endif

/* Externals from tables.c (which used to be tables.h) */
/* #include "tables.h" */
extern  OffScrData OffScrFBM_000_A[];
extern  OffScrData iOffScrFBM_000_A[];
extern  OffScrData OffScrFBM_010_A[];
extern  OffScrData iOffScrFBM_010_A[];
extern  OffScrData OffScrFBM_010_B[];
extern  OffScrData iOffScrFBM_010_B[];
extern  OffScrData OffScrFBM_011_A[];
extern  OffScrData iOffScrFBM_011_A[];
extern  OffScrData OffScrFBM_101_B[];
extern  OffScrData iOffScrFBM_101_B[];
extern  OffScrData OffScrFBM_111_A[];
extern  OffScrData iOffScrFBM_111_A[];
extern  OffScrData OffAth2[];
extern  OffScrData iOffAth2[];
extern  OffScrData OffAth4[];
extern  OffScrData iOffAth4[];
extern  HwModeData HwModesFBM_000_A[21];
extern  HwModeInterlace iHwModesFBM_000_A[21];
extern  HwModeData HwModesFBM_010_A[34];
extern  HwModeInterlace iHwModesFBM_010_A[34];
extern  HwModeData HwModesFBM_010_B[48];
extern  HwModeInterlace iHwModesFBM_010_B[48];
extern  HwModeData HwModesFBM_011_A[55];
extern  HwModeInterlace iHwModesFBM_011_A[55];
extern  HwModeData HwModesFBM_101_B[8];
extern  HwModeInterlace iHwModesFBM_101_B[8];
extern  HwModeData HwModesFBM_111_A[15];
extern  HwModeInterlace iHwModesFBM_111_A[15];
extern  HwModeData ModesAth2[63];
extern  HwModeInterlace iModesAth2[63];
extern  HwModeData ModesAth4[98];
extern  HwModeInterlace iModesAth4[98];



#ifdef _WINDOWS_DLL16

   /*** Definition for pool memory ***/
   #define PAN_X            0
   #define PAN_Y            1
   #define PAN_DISP_WIDTH   2
   #define PAN_DISP_HEIGHT  3
   #define DB_SCALE         4
   #define PAN_BOUND_LEFT   5
   #define PAN_BOUND_TOP    6
   #define PAN_BOUND_RIGHT  7
   #define PAN_BOUND_BOTTOM 8


   HINSTANCE hsxci=0;
   HINSTANCE huser=0;
   typedef long (FAR PASCAL *FARPROC2)();
   static FARPROC2 fp1;
   word NbSxciLoaded=0;
   word FAR *pDllMem;
#endif


#ifdef PRINT_DEBUG
    extern int debug_printf( char *fmt, ... );
    extern void openDebugfFile(char *s);
    extern void reOpenDebugfFile();
    extern void closeDebugfFile(char *s);
    extern void imprimeBuffer(byte *InitBuf, byte *VideoBuf);
#endif

dword MgaSel;

#ifdef WINDOWS_NT

    extern  INTERFACE_TYPE  NtInterfaceType;
    extern  UCHAR   MgaBusType[];

    #define MGA_BUS_INVALID     0
    #define MGA_BUS_PCI         1
    #define MGA_BUS_ISA         2

    ULONG   PciSlot;
    PVOID   pMgaDeviceExtension;
    PUCHAR  pMgaBaseAddr;
    PUCHAR  pciBiosRoutine;
    PUCHAR  pMgaPciIo, pMgaPciConfigSpace;

    #define PCI_LEN         0x00000004
    #define CONFIG_SPACE    0x0000c000
    #define CONFIG_LEN      0x00000100

    VIDEO_ACCESS_RANGE MgaPciCseAccessRange =
                        {PCI_CSE, 0x00000000, PCI_LEN, 1, 0, 1};

    VIDEO_ACCESS_RANGE MgaPciConfigAccessRange =
                        {CONFIG_SPACE, 0x00000000, CONFIG_LEN, 1, 0, 1};

    VIDEO_ACCESS_RANGE VideoProAccessRange =
                        {0x00000240, 0x00000000, 0x20, 1, 1, 1};

    typedef struct _MULTI_MODE
    {
        ULONG   MulModeNumber;                // unique mode Id
        ULONG   MulWidth;                     // total width of mode
        ULONG   MulHeight;                    // total height of mode
        ULONG   MulPixWidth;                  // pixel depth of mode
        ULONG   MulRefreshRate;               // refresh rate of mode
        USHORT  MulArrayWidth;                // number of boards arrayed along X
        USHORT  MulArrayHeight;               // number of boards arrayed along Y
        UCHAR   MulBoardNb[NB_BOARD_MAX];     // board numbers of required boards
        USHORT  MulBoardMode[NB_BOARD_MAX];   // mode required from each board
        HwModeData *MulHwModes[NB_BOARD_MAX]; // pointers to required HwModeData
    } MULTI_MODE, *PMULTI_MODE;


    /*--------------------------------------------------------------------------*\
    | HW_DEVICE_EXTENSION
    |
    | Define device extension structure. This is device dependant/private
    | information.
    |
    \*--------------------------------------------------------------------------*/
    typedef struct _MGA_DEVICE_EXTENSION {
        ULONG   SuperModeNumber;                // Current mode number
        ULONG   NumberOfSuperModes;             // Total number of modes
        PMULTI_MODE pSuperModes;                // Array of super-modes structures
                                                // For each board:
        ULONG   NumberOfModes[NB_BOARD_MAX];    // Number of available modes
        ULONG   NumberOfValidModes[NB_BOARD_MAX];
                                                // Number of valid modes
        ULONG   ModeFlags2D[NB_BOARD_MAX];      // 2D modes supported by each board
        ULONG   ModeFlags3D[NB_BOARD_MAX];      // 3D modes supported by each board
        USHORT  ModeFreqs[NB_BOARD_MAX][64];    // Refresh rates bit fields
        UCHAR   ModeList[NB_BOARD_MAX][64];     // Valid hardware modes list
        HwModeData *pMgaHwModes[NB_BOARD_MAX];  // Array of mode information structs.
        BOOLEAN bUsingInt10;                    // May need this later
        PVOID   KernelModeMappedBaseAddress[NB_BOARD_MAX];
                                                // Kern-mode virt addr base of MGA regs
        PVOID   UserModeMappedBaseAddress[NB_BOARD_MAX];
                                                // User-mode virt addr base of MGA regs
        PVOID   MappedAddress[];                // NUM_MGA_COMMON_ACCESS_RANGES elements
    } MGA_DEVICE_EXTENSION, *PMGA_DEVICE_EXTENSION;

    //#define ADDR_46E8_PORT        (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[5]) + (0x46e8 - 0x46e8))
    #define ADDR_46E8_PORT        0x46e8

#else   /* #ifdef WINDOWS_NT */

    volatile byte _Far *pMgaBaseAddr;

#endif  /* #ifdef WINDOWS_NT */

/* Global parameters */
byte  iBoard=0;          /* index of current selected board */
byte  NbBoard=0;         /* total board detected */

bool CheckHwAllDone=FALSE;
bool SpecialModeOn = FALSE;
/*VIDEOPRO*/
bool VAFCconnector;
extern bool initVideoMode(word mode, byte pwidth);
extern bool initVideoPro(byte mode, byte dactype);

#ifdef OS2
    word mtxVideoMode = mtxPASSTHRU;
#else
    word mtxVideoMode;
#endif

long setTVP3026Freq ( volatile byte _Far *pDeviceParam, long fout, long reg, byte pWidth );

#ifndef __DDK_SRC__
extern dword BindingRC[NB_BOARD_MAX];
extern dword BindingCL[NB_BOARD_MAX];
#endif

#if( !defined(_WINDOWS_DLL16) && !defined(INIT_ONLY))
#ifndef OS2
   dword _Far *BufBind;
   SYSPARMS *sp;

#ifndef __DDK_SRC__
   byte* CaddiInit(byte *InitBuf, byte *VideoBuf);
#else
   byte* InitDDK(byte *InitBuf, byte *VideoBuf);
   byte* ReInitDDK(byte *InitBuf, byte *VideoBuf);
#endif


   void setTVP3026(volatile byte _Far *pDevice, long fout_voulue, long reg, word pWidth);

#endif
#endif

HwData Hw[NB_BOARD_MAX+1];
dword  presentMclk[NB_BOARD_MAX+1] = {0}; /* MCLK currently in use */
dword   Dst0, Dst1;

dword ProductMGA[NB_BOARD_MAX];
HwModeData *FirstMode[NB_BOARD_MAX];

byte InitBuf[NB_BOARD_MAX][INITBUF_S]   = {0};
byte VideoBuf[NB_BOARD_MAX][VIDEOBUF_S] = {0};
extern dword crtcTab[NB_CRTC_PARAM];
extern vid vidtab[24];
char *mgainf = (char *)0;

/*** PROTOTYPES ***/

bool MapBoard(void);
static void overScan(void);
void UpdateHwModeTable (char *,HwModeData *,HwModeInterlace *,bool);
bool ProgrammeClock(byte Chip, dword Dst1, dword InfoDac);
extern dword getmgasel(void);
extern programme_reg_icd ( volatile byte _Far *pDevice, short reg, dword data );
#if 0
extern word detectVideoBoard(void);
#endif

void mtxMapVLBSpace();
bool mtxSetVLB(dword sel);
bool mtxIsVLBBios ();
void delay_us(dword delai);

#ifndef WINDOWS_NT
void setPciOptionReg();
#endif

#ifdef WINDOWS_NT

    extern  PUCHAR setmgasel(dword MgaSel, dword phyadr, dword limit);
    extern  PVOID  AllocateSystemMemory(ULONG NumberOfBytes);
    extern  BOOLEAN bConflictDetected(ULONG ulAddressToVerify);
    extern  PUCHAR pciBiosCallAddr();

#else   /* #ifdef WINDOWS_NT */

    #ifdef OS2
        extern  volatile byte _Far *setmgasel(dword MgaSel, dword phyadr, word limit);
        extern  HWIsSelected(dword,  dword , dword, dword, byte);
    #else
        extern  volatile byte _Far *setmgasel(dword MgaSel, dword phyadr, dword limit);
    #endif

#endif  /* #ifdef WINDOWS_NT */

extern void GetMGAConfiguration(volatile byte _Far *pMgaBaseAddr,
                            dword *Dst0, dword *Dst1, dword *InfoHardware);
extern void MGASysInit(byte *);

#ifdef OS2
    extern char *selectMgaInfoBoard();
#else
    char *selectMgaInfoBoard();
#endif

extern bool loadVidPar(dword Zoom, HwModeData *HwMode, HwModeData *DisplayMode);
extern void calculCrtcParam(void);
extern void MoveToVideoBuffer(byte *vidtab, byte *crtcTab, byte *VideoBuf);
extern void MGAVidInit(byte *, byte *);
dword mtxGetMgaSel(void);
bool mtxLectureMgaInf(void);
bool InitHwStruct(byte CurBoard, HwModeData *pHwModeData, word sizeArray,
                                    dword VramAvailable, dword DramAvailable);
extern char *mtxConvertMgaInf( char * );


#ifdef _WINDOWS_DLL16
   extern void FAR *memalloc(dword size);
   extern dword memfree(void FAR **mem);
   extern void AdjustDBWindow(void);
#endif


#ifdef WINDOWS
   dword ValMSec;

   int   _Far pascal LibMain(HANDLE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpszCmdLine)
      {
      if (wHeapSize > 0)
         UnlockData(0);

      return 1;
      }
#endif



/*-----------------------------------------------------
* mtxCheckHwAll
*
* This function returns the pointer to an array of MGA
* hardware devices found in the system
*
* Return value:
*   >0 = Pointer to HwData structure
*    0 = Error ; No MGA device found
*-----------------------------------------------------*/

HwData * mtxCheckHwAll(void)
{
    dword   TmpDword;
    byte    Board, TmpByte, DUB_SEL, ChipSet;
    dword   PcbRev, TitanRev, DubRev;
    dword   RamBanks;
    dword   InfoHardware;
    void    *pMgaInfo;
    bool    dacSupportHires;

#ifndef WINDOWS_NT
    byte    i;

    // Modified for Windows NT:
    // Since we can't open files in the kernel-mode driver, MGA.INF
    // is read in the user-mode driver instead; so, prior to calling
    // _mtxCheckHwAll, mgainf already points to MGA.INF data and
    // all the MGA boards have been mapped already...so we don't have
    // to call MapBoard or mtxLectureMgaInf here.

    if (! CheckHwAllDone)
    {
        /*** Figure number of iteration in one tick (55 millisecond) ***/
    #ifdef WINDOWS
        {
            dword _Far *tick = MAKELP(0x40, 0x6c);
            dword t;

            _asm{ pushf
                  sti  }   /* enable the interrupt because of a hang bug */
            ValMSec = 0;
            t = *tick + 1;

            while(t > *tick);

            t++;
            while(t > *tick)
                ValMSec++;
            _asm  popf
        }
    #endif

    #ifdef PRINT_DEBUG
        openDebugfFile("\\SXCIEXT.LOG");
        debug_printf(" ---- Premier appel CheckHwAll\n");
    #endif

        if (! MapBoard())
        {
        #ifdef PRINT_DEBUG
            debug_printf("MapBoard Fail\n");
        #endif
            return(mtxFAIL);
        }
    }

#ifdef PRINT_DEBUG
    else
    {
        reOpenDebugfFile();
        debug_printf(" ---- appel (pas le premier) CheckHwAll\n");
    }
#endif

    if (! mtxLectureMgaInf())
    {
    #ifdef PRINT_DEBUG
        closeDebugfFile("mtxLectureMgaInf Fail");
    #endif
        return(mtxFAIL);
    }

#endif  /* #ifndef WINDOWS_NT */

    /* Initialize Hw[] structure for each board */
    for (Board=0; Board<NbBoard; Board++)
    {

#if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE))
/*********** DDC COMPAQ CODE ****************/

      if (NbBoard == 1)
         if (ReportDDCcapabilities())
            SupportDDC = (byte)ReadEdid();

/*********** DDC COMPAQ CODE ****************/
#endif

    #ifdef PRINT_DEBUG
        {
            debug_printf("BOARD No %d\n", Board);
        }
    #endif
        if (! mtxSelectHw(&Hw[Board]))
        {
        #ifdef PRINT_DEBUG
            closeDebugfFile("mtxSelectHw Fail");
        #endif
            return(mtxFAIL);
        }
        mtxMapVLBSpace();
        pMgaInfo = selectMgaInfoBoard();
        if (! pMgaInfo)
        {
        #ifdef PRINT_DEBUG
            closeDebugfFile("selectMgaInfoBoard Fail");
        #endif
            return(mtxFAIL);
        }

        /* Initialize according to Vgaen switch (strapping conf.) */

        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CONFIG),TmpDword);
        if (TmpDword&TITAN_VGAEN_M)
            Hw[Board].VGAEnable = 1;
        else
            {
            Hw[Board].VGAEnable = 0;
            if (! CheckHwAllDone)
               {
               /*----- SoftReset (need for PCI IMPRSESSION+ with high freq --*/
               mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_SET);
               delay_us(2);
               mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_CLR);
               delay_us(2);
               }
            }

#if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE))
/*********** DDC COMPAQ CODE ****************/

      if (SupportDDC && Hw[0].VGAEnable)
         Hw[0].PortCfg = 0x01;

      if (SupportDDC && (!Hw[0].VGAEnable || mgainf != DefaultVidset))
         SupportDDC = FALSE;

/*********** DDC COMPAQ CODE ****************/
#endif

        if (TmpDword&0x00000001)
            Hw[Board].Device8_16 = 1;      /* mode 16-bit */
        else
            Hw[Board].Device8_16 = 0;      /* mode 8-bit */

      #ifdef WINDOWS_NT
        if ((Hw[iBoard].pHwMode != NULL) &&
            (NbBoard > 1))
        {
            // pHwMode has been initialized to NULL in MgaFindAdapter.
            // If it's not NULL here, it means we've been here before.
            // If we have more than one board, then InitHwStruct has allocated
            // memory for pHwMode, and we'll release it here.

            VideoPortReleaseBuffer(pMgaDeviceExtension, Hw[iBoard].pHwMode);
            Hw[iBoard].pHwMode = NULL;
        }
      #endif

        Hw[iBoard].pCurrentHwMode = NULL;
        Hw[iBoard].pCurrentDisplayMode = NULL;
        Hw[iBoard].CurrentZoomFactor = 0;
        Hw[iBoard].CurrentXStart = 0;
        Hw[iBoard].CurrentYStart = 0;
        mtxSetVideoMode(mtxADV_MODE);

        GetMGAConfiguration(pMgaBaseAddr, &Dst0, &Dst1, &InfoHardware);

    #ifdef PRINT_DEBUG
        {
            debug_printf("DST0 = 0x%08lx, DST1 = 0x%08lx InfoHardware = 0x%x\n", Dst0, Dst1, InfoHardware);
        }
    #endif

        /* Verify if DAC support resolution above 1280 */
        dacSupportHires = !(Dst1 & TITAN_DST1_ABOVE1280_M); /* Test bit Above1280 */

        Hw[Board].ProductType = (Dst0 & TITAN_DST0_PRODUCT_M) >> TITAN_DST0_PRODUCT_A;

        PcbRev = (Dst0 & TITAN_DST0_PCBREV_M) >> TITAN_DST0_PCBREV_A;

        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_REV), TitanRev);
        TitanRev = (TitanRev & 0x000000ff) << 4;
        DubRev = 0 << 8;

        if( ((TitanRev >> 4) & 0x0000000f) < ATHENA_CHIP)
            PcbRev = 0xf - (PcbRev & 0xf);   /* 4 bits for TITAN and ATLAS */
        else
            PcbRev = 7  - (PcbRev & 0x7);    /* 3 bits for ATHENA */

        Hw[Board].ProductRev = PcbRev+TitanRev+DubRev;

#if 0
        /*** status presence of the VideoPro board ***/
        if( detectVideoBoard() )
            Hw[Board].ProductRev |= 0x1000;      /* Set bit 12 to 1 */
        else
            Hw[Board].ProductRev &= 0xffffefff;  /* Set bit 12 to 0 */
#endif
        if( ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) == ATHENA_CHIP)
        {

            /*------ Strap added for ATHENA ------------------------------*/
            mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpDword);


            /** BEN we add this condition to fix bug shift left **/
            /* For Impression Lite we force regular operation */
            if ((Dst1 & TITAN_DST1_ABOVE1280_M) && (Dst1 & TITAN_DST1_200MHZ_M) &&
                  ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) == ATHENA_CHIP )
               {
                TmpDword = TmpDword & 0xfffffffb;  /* bit 2=0: Board supports regular (135MHz/170MHz) operation */
               }
            else
               {
               if((Dst1 & TITAN_DST1_200MHZ_M) >> TITAN_DST1_200MHZ_A)
                  TmpDword = TmpDword & 0xfffffffb;  /* bit 2=0: Board supports regular (135MHz/170MHz) operation */
               else
                  TmpDword = TmpDword | 0x00000004;  /* bit 2=1: Board supports 200MHz operation */
               }

            mgaWriteDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpDword);

            if (
                ( (InfoHardware == Info_Dac_ViewPoint) ||
                  (InfoHardware == Info_Dac_TVP3026)
                ) &&
                (TmpDword & 0x00000004)
               )    /* support 200MHz */
                dacSupportHires = 1;
            else
                dacSupportHires = 0;
            /*------ Strap added for ATHENA ------------------------------*/

            /*** BEN I add this condition to prevent to program NOMUX for
                  board MGA-PCI/2+ and MGA-VLB/2+ because the bit NOMUX
                  is used to set the clock ***/
            if (
                (InfoHardware == Info_Dac_BT485)   ||
                (InfoHardware == Info_Dac_ATT2050) ||
                (InfoHardware == Info_Dac_PX2085)
               )
            {
                /*------ Strap added for ATHENA --------------------------*/
                mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpDword);

                if((Dst1 & TITAN_DST1_NOMUXES_M) >> TITAN_DST1_NOMUXES_A)
                    TmpDword = TmpDword & 0xffffffdf;  /* bit 5=0: */
                else
                    TmpDword = TmpDword | 0x00000020;  /* bit 5=1: */

                mgaWriteDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpDword);
                /*------ Strap added for ATHENA --------------------------*/
            }
        }

/*** BEN open issue */
        Hw[Board].ShellRev = 0;
        Hw[Board].BindingRev = BINDING_REV;


        /*** ----- DUBIC PATCH Disable mouse IRQ and proceed ------ ***/
        mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
        mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
        mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), 0x00);
        /*** ------------------------------------------------------ ***/

        mgaWriteBYTE(*(pMgaBaseAddr+DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DUB_CTL2);
        mgaReadBYTE(*(pMgaBaseAddr+DUBIC_OFFSET + DUBIC_DATA), TmpByte);


        /*** ----- DUBIC PATCH ReEnable mouse IRQ ----------------- ***/
        mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
        mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
        /*** ------------------------------------------------------ ***/

        Hw[Board].Sync = TmpByte & 0x1;

#if 0
        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_OPMODE), TmpDword);
        if (TmpDword & 0x00000100)
            Hw[Board].PortCfg = 1;     /* Mouse enable */
        else if (TmpByte & 0x04)
            Hw[Board].PortCfg = 2;     /* Laser enable */
        else
            Hw[Board].PortCfg = 0;     /* Port disable */
#endif

        /* Interrupt number for the mouse or the laser port */
        mgaReadBYTE(*(pMgaBaseAddr+DUBIC_OFFSET + DUBIC_DUB_SEL), TmpByte);
        TmpByte = (TmpByte & 0x18) >> 3;
        switch (TmpByte)
        {
            case 0:
                    Hw[Board].PortIRQ = (byte)-1;
                    break;
            case 1:
                    Hw[Board].PortIRQ = 3;
                    break;
            case 2:
                    Hw[Board].PortIRQ = 4;
                    break;
            case 3:
                    Hw[Board].PortIRQ = 5;
                    break;
        }

        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_OPMODE),TmpDword);
        if (TmpDword & TITAN_MOUSEMAP_M)
            Hw[Board].MouseMap = 0x238;
        else
            Hw[Board].MouseMap = 0x23c;

        mgaReadBYTE(*(pMgaBaseAddr+DUBIC_OFFSET + DUBIC_DUB_SEL), TmpByte);
        TmpByte = (TmpByte & 0x70) >> 5;
        switch (TmpByte)
        {
            case 0:
                    Hw[Board].MouseIRate = 0;
                    break;
            case 1:
                    Hw[Board].MouseIRate = 25;
                    break;
            case 2:
                    Hw[Board].MouseIRate = 50;
                    break;
            case 3:
                    Hw[Board].MouseIRate = 100;
                    break;
            case 4:
                    Hw[Board].MouseIRate = 200;
                    break;
        }


        /*Hw[Board].DacType = InfoHardware & 0x00000003; */

        /*** BEN Temporary translate code ***/
#if 0
        /*VIDEOPRO*/
        VAFCconnector = 0;
#endif
        switch(InfoHardware)
        {
            case Info_Dac_BT481:
            case Info_Dac_BT482:
                    Hw[Board].DacType = BT482;
                    break;

            case Info_Dac_Sierra:
                    Hw[Board].DacType = SIERRA;
                    break;

            case Info_Dac_ViewPoint:
                    Hw[Board].DacType = VIEWPOINT;
                    break;

            case Info_Dac_TVP3026:
                    Hw[Board].DacType = TVP3026;
                    break;

            case Info_Dac_BT484:
                    Hw[Board].DacType = BT484;
                    break;

            case Info_Dac_BT485:
            case Info_Dac_ATT2050:
                    Hw[Board].DacType = BT485;
                    break;

            case Info_Dac_Chameleon:
                    Hw[Board].DacType = CHAMELEON;
                    break;

            case Info_Dac_PX2085:
#if 0
                    /*VIDEOPRO*/
                    VAFCconnector = 1;
#endif
                #ifndef WINDOWS_NT
                    Hw[Board].DacType = BT485;
                #else
                    Hw[Board].DacType = PX2085;
                #endif  /* #ifndef WINDOWS_NT */

                    break;

            default:
                    return(mtxFAIL);
        }

    #ifdef PRINT_DEBUG
        {
            debug_printf("Dactype[%d] = %x\n", Board, Hw[Board].DacType);
        }
    #endif

        /*** Cursor info init ***/
        switch(Hw[Board].DacType)
        {
            case BT482:
                    Hw[Board].cursorInfo.MaxWidth  = 32;
                    Hw[Board].cursorInfo.MaxHeight = 32;
                    Hw[Board].cursorInfo.MaxDepth  = 2;
                    Hw[Board].cursorInfo.MaxColors = 2;
                    break;

            case BT485:
            case PX2085:
            case VIEWPOINT:
                    Hw[Board].cursorInfo.MaxWidth  = 64;
                    Hw[Board].cursorInfo.MaxHeight = 64;
                    Hw[Board].cursorInfo.MaxDepth  = 2;
                    Hw[Board].cursorInfo.MaxColors = 2;
                    break;

            case TVP3026:
                    Hw[Board].cursorInfo.MaxWidth  = 64;
                    Hw[Board].cursorInfo.MaxHeight = 64;
                    Hw[Board].cursorInfo.MaxDepth  = 2;
                    Hw[Board].cursorInfo.MaxColors = 3;
                    break;

            default:
                    Hw[Board].cursorInfo.MaxWidth  = 0;
                    Hw[Board].cursorInfo.MaxHeight = 0;
                    Hw[Board].cursorInfo.MaxDepth  = 0;
                    Hw[Board].cursorInfo.MaxColors = 0;
                    break;

        }

        Hw[Board].cursorInfo.CurWidth  = 0;
        Hw[Board].cursorInfo.CurHeight = 0;
        Hw[Board].cursorInfo.HotSX     = 0;
        Hw[Board].cursorInfo.HotSY     = 0;



        /* Form Rambank value */
        RamBanks = ((Dst1 & TITAN_DST1_RAMBANK_M) << 8L) |
                   ((Dst0 & 0xfe000000) >> 24L) |
                   ((Dst1 & TITAN_DST1_RAMBANK0_M) >> TITAN_DST1_RAMBANK0_A);


        /*** Check the ZTAG bit ***/
        if (RamBanks & (dword)0x40)
            *((byte*) (InitBuf[Board] + INITBUF_ZTagFlag)) = TRUE;
        else
            *((byte*) (InitBuf[Board] + INITBUF_ZTagFlag)) = FALSE;

        RamBanks = RamBanks & 0x1bf;    /* Mask le ZTAG et bits dont care */

    #ifdef PRINT_DEBUG
        {
            debug_printf("RamBank = %x\n", RamBanks);
        }
    #endif

        switch((Hw[iBoard].ProductRev >> 4) & 0x0000000f)
        {
            case TITAN_CHIP:
                    ChipSet = TITAN_CHIP;
                    break;

            case ATLAS_CHIP:
                    ChipSet = ATLAS_CHIP;

                    /* Check if VLB2 board */
                    mgaReadDWORD(*(pMgaBaseAddr+0x2000),TmpDword);
                    if (TmpDword == (dword)0x0518102b)     /* ID Matrox */
                        mgaWriteBYTE(*(pMgaBaseAddr+0x2040),0x01);  /* Program option reg */
               #ifndef WINDOWS_NT
                    else /* PCI bus */
                        /* If PCI disable PCI posted write feature
                           if system use Ares chipset */
                        disPostedWFeature();
                        break;
               #endif   /* #ifndef WINDOWS_NT */

            case ATHENA_CHIP:
                    ChipSet = ATHENA_CHIP;

                    /*** BEN se programme maintenant par le clock synthetiser ***/
                    /* Check if VLB2 board */
                    mgaReadDWORD(*(pMgaBaseAddr+0x2000),TmpDword);
                    if (TmpDword == (dword)0x0518102b)     /* ID Matrox */
                        mgaWriteBYTE(*(pMgaBaseAddr+0x2040),0x01);  /* Program option reg */
                    break;
        }

        /*** Define ProductMGA ***/

        if (RamBanks == (dword)0x001 && ChipSet == TITAN_CHIP)
            ProductMGA[Board] = MGA_ULT_1M;

        else if (RamBanks == (dword)0x004 && ChipSet == TITAN_CHIP)
            ProductMGA[Board] = MGA_ULT_2M;

        else if (RamBanks == (dword)0x005 && ChipSet == TITAN_CHIP)
            ProductMGA[Board] = MGA_IMP_3M;

        else if (RamBanks == (dword)0x025 && ChipSet == TITAN_CHIP)
            ProductMGA[Board] = MGA_IMP_3M_Z;

        else if (RamBanks == (dword)0x09C && ChipSet == TITAN_CHIP)
            ProductMGA[Board] = MGA_PRO_4M5;

        else if (RamBanks == (dword)0x13C && ChipSet == TITAN_CHIP)
            ProductMGA[Board] = MGA_PRO_4M5_Z;

        else if (RamBanks == (dword)0x004 && (ChipSet == ATLAS_CHIP || ChipSet == ATHENA_CHIP))
            ProductMGA[Board] = MGA_PCI_2M;

        else if (RamBanks == (dword)0x005 && (ChipSet == ATLAS_CHIP || ChipSet == ATHENA_CHIP))
            ProductMGA[Board] = MGA_PCI_4M;

        else
        {
    #ifdef PRINT_DEBUG
            closeDebugfFile("RamBanks Inconnue");
    #endif
            return(mtxFAIL);
        }

        /*** Define Product type for external use ***/
        if( ChipSet == TITAN_CHIP )
        {
            if( ProductMGA[Board]==MGA_ULT_1M || ProductMGA[Board]==MGA_ULT_2M )
                Hw[Board].ProductType |= (dword)MGA_ULTIMA<<16;

            else if( ProductMGA[Board]==MGA_PRO_4M5 || ProductMGA[Board]==MGA_PRO_4M5_Z )
                Hw[Board].ProductType |= (dword)MGA_IMPRESSION_PRO<<16;

            else
                Hw[Board].ProductType |= (dword)MGA_IMPRESSION<<16;
        }
        else if( ChipSet == ATLAS_CHIP )
        {
            if( InfoHardware == Info_Dac_PX2085 )
                Hw[Board].ProductType |= (dword)MGA_ULTIMA_VAFC<<16;

            else if( (Dst1 & TITAN_DST1_200MHZ_M) && !(Dst1 & TITAN_DST1_ABOVE1280_M))
                Hw[Board].ProductType |= (dword)MGA_ULTIMA_PLUS_200<<16;

            else if( InfoHardware == Info_Dac_ViewPoint )
                Hw[Board].ProductType |= (dword)MGA_ULTIMA_PLUS<<16;

            else
                Hw[Board].ProductType |= (dword)MGA_ULTIMA<<16;

        }
        else  /* Athena */
        {
            if ((Dst1 & TITAN_DST1_ABOVE1280_M) && (Dst1 & TITAN_DST1_200MHZ_M))
               Hw[Board].ProductType |= (dword)MGA_IMPRESSION_LTE<<16;

            else if( InfoHardware == Info_Dac_TVP3026)
               Hw[Board].ProductType |= (dword)MGA_IMPRESSION_PLUS<<16;

            else if( InfoHardware == Info_Dac_ViewPoint )
               Hw[Board].ProductType |= (dword)MGA_ULTIMA_PLUS<<16;

            else
               Hw[Board].ProductType |= (dword)MGA_ULTIMA<<16;

        }

    #ifdef PRINT_DEBUG
        {
            debug_printf("ProductMGA[%d] = %x\n", Board, ProductMGA[Board]);
        }
    #endif

        if(! ProgrammeClock(ChipSet, Dst1, InfoHardware))
            return(mtxFAIL);

        switch (ProductMGA[Board])
        {
            case MGA_ULT_1M:
                if(!(InitHwStruct(Board, HwModesFBM_000_A,
                                        sizeof(HwModesFBM_000_A), 1048576, 0)))
                {
                #ifdef PRINT_DEBUG
                    closeDebugfFile("MGA_ULT_1M : InitHwStruct Fail");
                #endif
                    return(mtxFAIL);
                }
                UpdateHwModeTable (pMgaInfo, FirstMode[Board],
                                        iHwModesFBM_000_A, dacSupportHires);
                break;

            case MGA_ULT_2M:
                if(!(InitHwStruct(Board, HwModesFBM_010_A,
                                        sizeof(HwModesFBM_010_A), 2097152, 0)))
                {
                #ifdef PRINT_DEBUG
                    closeDebugfFile("MGA_ULT_2M : InitHwStruct Fail");
                #endif
                    return(mtxFAIL);
                }
                UpdateHwModeTable (pMgaInfo, FirstMode[Board],
                                        iHwModesFBM_010_A, dacSupportHires);
                break;

            case MGA_IMP_3M:
                if(!(InitHwStruct(Board, HwModesFBM_010_B,
                                        sizeof(HwModesFBM_010_B), 3145728, 0)))
                {
                #ifdef PRINT_DEBUG
                    closeDebugfFile("MGA_IMP_3M : InitHwStruct Fail");
                #endif
                    return(mtxFAIL);
                }
                UpdateHwModeTable (pMgaInfo, FirstMode[Board],
                                        iHwModesFBM_010_B, dacSupportHires);
                break;

            case MGA_IMP_3M_Z:
                if(!(InitHwStruct(Board, HwModesFBM_011_A,
                                    sizeof(HwModesFBM_011_A), 3145728, 2097152)))
                {
                #ifdef PRINT_DEBUG
                    closeDebugfFile("MGA_IMP_3M_Z : InitHwStruct Fail");
                #endif
                    return(mtxFAIL);
                }
                UpdateHwModeTable (pMgaInfo, FirstMode[Board],
                                        iHwModesFBM_011_A, dacSupportHires);
                break;

            case MGA_PRO_4M5:
                if(!(InitHwStruct(Board, HwModesFBM_101_B,
                                    sizeof(HwModesFBM_101_B), 4718592, 0)))
                {
                #ifdef PRINT_DEBUG
                    closeDebugfFile("MGA_PRO_4M5 : InitHwStruct Fail");
                #endif
                    return(mtxFAIL);
                }
                UpdateHwModeTable (pMgaInfo, FirstMode[Board],
                                        iHwModesFBM_101_B, dacSupportHires);
                break;

            case MGA_PRO_4M5_Z:
                if(!(InitHwStruct(Board, HwModesFBM_111_A,
                                sizeof(HwModesFBM_111_A), 4718592, 4194304)))
                {
                #ifdef PRINT_DEBUG
                    closeDebugfFile("MGA_PRO_4M5_Z : InitHwStruct Fail");
                #endif
                    return(mtxFAIL);
                }
                UpdateHwModeTable (pMgaInfo, FirstMode[Board],
                                    iHwModesFBM_111_A, dacSupportHires);
                break;

            case MGA_PCI_2M:
                if(!(InitHwStruct(Board, ModesAth2,
                                            sizeof(ModesAth2), 2097152, 0)))
                    return(mtxFAIL);
                UpdateHwModeTable (pMgaInfo, FirstMode[Board], iModesAth2,
                                                            dacSupportHires);
                break;

            case MGA_PCI_4M:
                if(!(InitHwStruct(Board, ModesAth4,
                                            sizeof(ModesAth4), 4194304, 0)))
                    return(mtxFAIL);
                UpdateHwModeTable (pMgaInfo, FirstMode[Board], iModesAth4,
                                                            dacSupportHires);
                break;

            default:
                {
                #ifdef PRINT_DEBUG
                    closeDebugfFile("Produit Inconnue");
                #endif
                    return(mtxFAIL);
                }
        }

        if (Hw[Board].VGAEnable == 1)
            mtxSetVideoMode(mtxVGA);

    #ifdef WINDOWS_NT
        // Do not free this now, since we do not use setmgasel in mtxSelectHw.
        // VideoPortFreeDeviceBase(pMgaDeviceExtension, pMgaBaseAddr);
    #endif
    }  /*** for loop Board... ***/

    /* Set the OPTION register for ATLAS PCI */
#ifndef WINDOWS_NT
    setPciOptionReg();
#endif

    /* Indicates end of array */
    Hw[Board].MapAddress = (dword)-1;

    /* Default initialisation */
    Hw[iBoard].pCurrentDisplayMode = Hw[iBoard].pCurrentHwMode;

#if( !defined( _WINDOWS_DLL16) && !defined(OS2) && !defined(INIT_ONLY))
#ifndef WINDOWS_NT

    if (! CheckHwAllDone)
    {
        /* Allocate a static buffer for the command (C-Binding -> CADDI) */
#ifndef __DDK_SRC__
        BufBind = mtxAllocBuffer(BUF_BIND_SIZE);
#endif
        /* Allocate a static RC and a clip list for each MGA device */
        for (i=0; Hw[i].MapAddress != (dword)-1 ; i++)
        {
            if (! mtxSelectHw(&Hw[i]))
            {
            #ifdef PRINT_DEBUG
                closeDebugfFile("mtxSelectHw(&Hw[]) == 0\n");
            #endif
                return(mtxFAIL);
            }
#ifndef __DDK_SRC__
            BindingRC[i] = (dword)NULL;
	 /***
     ***  _tDDK_STATE needs to be NULL'ed here if you want the DDK
     ***  to behave exactly like the SDK
     ***/
#endif
            if (!mtxSelectHwMode(Hw[iBoard].pCurrentHwMode))
            {
            #ifdef PRINT_DEBUG
                closeDebugfFile("mtxSelectHwMode(Hw[].pCurrentHwMode == 0");
            #endif
                return(mtxFAIL);
            }

#ifndef __DDK_SRC__
            BindingRC[i] = (dword)mtxAllocRC(NULL);
            BindingCL[i] = (dword)mtxAllocCL(1);
#endif
            mtxSetVideoMode(mtxVGA);
        }
    }

#endif  /* #ifndef WINDOWS_NT */
#endif  /* #if( !defined( _WINDOWS_DLL16) && !defined(OS2))... */

    CheckHwAllDone = TRUE;

#ifdef PRINT_DEBUG
    closeDebugfFile("Sortie Ok CheckHwAll");
#endif
    return(&Hw[0]);
}








/*------------------------------------------------
* mtxSelectHw
*
* Select the MGA device to be used for subsequent
* drawing operations
*
* Return:
*   mtxOK   : Hardware select successful
*   mtxFAIL : Hardware select failure
*------------------------------------------------*/

bool mtxSelectHw(HwData *pHardware)
{
    HwData  *pScanHwData;
    bool    FlagFoundHwData;


    /*** VALIDATE pHardware and set iBoard ***/

    FlagFoundHwData = FALSE;
    iBoard  = 0;

    for (pScanHwData = &Hw[0]; pScanHwData->MapAddress != (dword)-1;
                                                    pScanHwData++, iBoard++)
    {
        if (pScanHwData == pHardware)
        {
            FlagFoundHwData = TRUE;
            break;
        }
    }

    if (! FlagFoundHwData)
        return(mtxFAIL);

#ifdef WINDOWS_NT
    pMgaBaseAddr = Hw[iBoard].BaseAddress;
#else
    pMgaBaseAddr = setmgasel(MgaSel, Hw[iBoard].MapAddress, 4);
#endif

#ifdef OS2
    HWIsSelected(ProductMGA[iBoard], Hw[iBoard].ProductType,
            Hw[iBoard].ProductRev, Hw[iBoard].MapAddress, Hw[iBoard].DacType);
#endif

#if( !defined(WINDOWS) && !defined(OS2) && !defined(WINDOWS_NT) && !defined(INIT_ONLY))
#ifndef __DDK_SRC__
   CaddiReInit(InitBuf[iBoard], VideoBuf[iBoard]);
#else
   ReInitDDK(InitBuf[iBoard], VideoBuf[iBoard]);
#endif
#endif

    return(mtxOK);
}



/*------------------------------------------------------
* mtxGetHwModes
*
* This function returns a pointer to a list of hardware
* modes available for the current MGA device
* as selected by mtxSelectHw()
*
* Return:
*   HwModes  = 0 : MGA device not found
*   HwModes != 0 : Pointer to HwModes array
*------------------------------------------------------*/

HwModeData *mtxGetHwModes(void)
{
    if (NbBoard == 0)
        return(0);
    return(FirstMode[iBoard]);
}


/*------------------------------------------------------
* mtxGetRefreshRates
*
* This function returns a word that contains a bit field
* of possible frequency for a specific resolution and
* pixel depth.
*
* Return:
*------------------------------------------------------*/

word mtxGetRefreshRates(HwModeData *pHwModeSelect)
{
 word FreqRes,i;

 for (FreqRes = 0,i = 0; ResParam[i].DispWidth != (word) -1; i++)
    {
     if ((ResParam[i].DispWidth == pHwModeSelect->DispWidth) && (ResParam[i].PixDepth == pHwModeSelect->PixWidth))
        {
         switch (ResParam[i].RefreshRate)
            {
			  // bit  0:  43 Hz interlaced
              // bit  1:  56 Hz
              // bit  2:  60 Hz
              // bit  3:  66 Hz
              // bit  4:  70 Hz
              // bit  5:  72 Hz
              // bit  6:  75 Hz
              // bit  7:  76 Hz
              // bit  8:  80 Hz
              // bit  9:  85 Hz
              // bit 10:  90 Hz
              // bit 11: 100 Hz
              // bit 12: 120 Hz

             case 43:
	             FreqRes |= 0x0001;
		         break;
	         case 56:
	             FreqRes |= 0x0002;
		         break;
	         case 60:
	             FreqRes |= 0x0004;
		         break;
	         case 66:
	             FreqRes |= 0x0008;
		         break;
	         case 70:
	             FreqRes |= 0x0010;
		         break;
	         case 72:
	             FreqRes |= 0x0020;
		         break;
	         case 75:
	             FreqRes |= 0x0040;
		         break;
	         case 76:
	             FreqRes |= 0x0080;
		         break;
	         case 80:
	             FreqRes |= 0x0100;
		         break;
	         case 85:
	             FreqRes |= 0x0200;
		         break;
	         case 90:
	             FreqRes |= 0x0400;
		         break;
	         case 100:
	             FreqRes |= 0x0800;
		         break;
	         case 120:
	             FreqRes |= 0x1000;
		         break;
            }
         }
    }

 return(FreqRes);
}

/*----------------------------------------------------------
* mtxSelectHwMode
*
* Select from the list of available hardware modes returned
* by mtxGetHwModes()
*
* Return:
*   mtxOK   : HwMode select successfull
*   mtxFAIL : HwMode select failure
*
*----------------------------------------------------------*/

bool mtxSelectHwMode(HwModeData *pHwModeSelect)
{
    bool            FlagFindMode;
    byte            TmpByte;
    HwModeData      *pScanHwMode;
    general_info    *generalInfo;
    dword           DST0, DST1, Info;

    generalInfo = (general_info *)selectMgaInfoBoard();

    FlagFindMode = FALSE;

    for ( pScanHwMode = FirstMode[iBoard]; pScanHwMode->DispWidth != (word)-1;
                                                             pScanHwMode++)
    {
        if (pScanHwMode == pHwModeSelect)
        {
            FlagFindMode = TRUE;
            break;
        }
    }

    if (NbBoard == 0 || FlagFindMode == FALSE)
        return(mtxFAIL);

    Hw[iBoard].pCurrentHwMode = NULL;
    Hw[iBoard].pCurrentDisplayMode = NULL;
    mtxSetVideoMode(mtxADV_MODE);

    Hw[iBoard].pCurrentHwMode = pHwModeSelect;

    if(pHwModeSelect->DispType & 0x04)     /* LUT mode */
    {
        *((byte*) (InitBuf[iBoard] + INITBUF_LUTMode))  = TRUE;
    }
    else
    {
        *((byte*) (InitBuf[iBoard] + INITBUF_LUTMode))  = FALSE;
    }

    /* Initialize a init buffer for CADDI */
    if (pHwModeSelect->PixWidth == 24) /* PACK PIXEL */
        *((byte*) (InitBuf[iBoard] + INITBUF_PWidth)) = 0x12;
    else
        *((byte*) (InitBuf[iBoard] + INITBUF_PWidth)) =
                                                pHwModeSelect->PixWidth >> 4;

    *((word*) (InitBuf[iBoard] + INITBUF_ScreenWidth)) =
                                                pHwModeSelect->FbPitch;
    *((word*) (InitBuf[iBoard] + INITBUF_ScreenHeight)) =
                                                pHwModeSelect->DispHeight;

#ifdef WINDOWS_NT
    *((UINT_PTR*)(InitBuf[iBoard] + INITBUF_MgaOffset)) = (UINT_PTR)pMgaBaseAddr;
#else
  #ifdef __WATCOMC__
    #ifdef  __WATCOM_PHAR__   /* Watcom & Phar Lap */
      *((dword*)(InitBuf[iBoard] + INITBUF_MgaOffset))    = 0;
    #else /* Watcom & Rational */
      *((dword*)(InitBuf[iBoard] + INITBUF_MgaOffset))    = (dword)pMgaBaseAddr;;
    #endif
  #elif __MICROSOFTC600__
     *((dword*)(InitBuf[iBoard] + INITBUF_MgaOffset))    = (dword)pMgaBaseAddr;;
  #else /* High C & Phar Lap */
     *((dword*)(InitBuf[iBoard] + INITBUF_MgaOffset))    = 0;
  #endif
    *((word*) (InitBuf[iBoard] + INITBUF_MgaSegment)) = MgaSel >> 16;
#endif  /* #ifdef WINDOWS_NT */

    /* Default setting */
    *((byte*) (InitBuf[iBoard] + INITBUF_ZBufferFlag))  = FALSE;
    *((byte*) (InitBuf[iBoard] + INITBUF_ZinDRAMFlag))  = FALSE;
    *((dword*)(InitBuf[iBoard] + INITBUF_ZBufferHwAddr)) = 0;

    switch(generalInfo->BitOperation8_16)
    {
        case BIT8:
                *((byte*)(InitBuf[iBoard] + INITBUF_16)) = 2;
                break;

        case BIT16:
                *((byte*)(InitBuf[iBoard] + INITBUF_16)) = 1;
                break;

        case BITNARROW16:
                *((byte*)(InitBuf[iBoard] + INITBUF_16)) = 3;
                break;

        default:
                *((byte*)(InitBuf[iBoard] + INITBUF_16)) = 0;
                break;
    }

    /* If on top of VGA, we must program in 16bit narrow absolutely */

    if ((Hw[iBoard].ProductType &  BOARD_MGA_VL_M) == BOARD_MGA_VL)
    {
        *((byte*)(InitBuf[iBoard] + INITBUF_16)) = 2;    /* 8-bit mode */
    }
    else
    {
        if (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
            *((byte*)(InitBuf[iBoard] + INITBUF_16)) = 1;
    }

    /* Transfer DMA informations from mga.inf */
    *((byte*) (InitBuf[iBoard] + INITBUF_DMAEnable))  = (byte)generalInfo->DmaEnable;
    *((byte*) (InitBuf[iBoard] + INITBUF_DMAChannel)) = (byte)generalInfo->DmaChannel;
    *((byte*) (InitBuf[iBoard] + INITBUF_DMAType))    = (byte)generalInfo->DmaType;
    *((byte*) (InitBuf[iBoard] + INITBUF_DMAXferWidth)) = (byte)generalInfo->DmaXferWidth;

    /* Special case for MGA_IMP_3M_Z at 1024x768x32: we act like an MGA_IMP_3M */
    if (ProductMGA[iBoard] == MGA_IMP_3M_Z &&
        pHwModeSelect->DispWidth == 1024 &&
        pHwModeSelect->PixWidth  == 32)
    {
        ProductMGA[iBoard] = MGA_IMP_3M;
        SpecialModeOn = TRUE;
    }

    /* Reset to the real value of FBM when the flag is on and this is not the
        special mode  */
    if (SpecialModeOn == TRUE && (pHwModeSelect->DispWidth != 1024 ||
                                  pHwModeSelect->PixWidth  != 32))
    {
        ProductMGA[iBoard] = MGA_IMP_3M_Z;
        SpecialModeOn = FALSE;
    }

    switch (ProductMGA[iBoard])
    {
        case MGA_ULT_1M:
                *((byte*) (InitBuf[iBoard] + INITBUF_FBM)) = 0;
                break;

        case MGA_ULT_2M:
        case MGA_IMP_3M:
        case MGA_PCI_4M:
                *((byte*) (InitBuf[iBoard] + INITBUF_FBM)) = 2;
                break;

        case MGA_IMP_3M_Z:
                *((byte*) (InitBuf[iBoard] + INITBUF_FBM)) = 3;
                break;

        case MGA_PRO_4M5:
                *((byte*) (InitBuf[iBoard] + INITBUF_FBM)) = 5;
                break;

        case MGA_PRO_4M5_Z:
                *((byte*) (InitBuf[iBoard] + INITBUF_FBM)) = 7;
                break;

        case MGA_PCI_2M:
                if (pHwModeSelect->ZBuffer)
                    *((byte*) (InitBuf[iBoard] + INITBUF_FBM)) = 10;
                else
                    *((byte*) (InitBuf[iBoard] + INITBUF_FBM)) = 2;
                break;

        default:
                return(mtxFAIL);
    }

    if (pHwModeSelect->ZBuffer)
    {
        switch (ProductMGA[iBoard])
        {
            case MGA_IMP_3M:    /* We can do Z-buffer in VRAM */
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZBufferFlag)) = TRUE;
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZinDRAMFlag)) = FALSE;
                    *((dword*)(InitBuf[iBoard] + INITBUF_ZBufferHwAddr)) =
                                                                    0x200000;
                    break;

            case MGA_IMP_3M_Z:
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZBufferFlag)) = TRUE;
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZinDRAMFlag)) = TRUE;
                    *((dword*)(InitBuf[iBoard] + INITBUF_ZBufferHwAddr)) =
                                                                    0x400000;
                    break;

            case MGA_PRO_4M5_Z:
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZBufferFlag)) = TRUE;
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZinDRAMFlag)) = TRUE;
                    *((dword*)(InitBuf[iBoard] + INITBUF_ZBufferHwAddr)) =
                                                                    0x600000;
                    break;

            case MGA_PCI_4M:
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZBufferFlag)) = TRUE;
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZinDRAMFlag)) = FALSE;
                    *((dword*)(InitBuf[iBoard] + INITBUF_ZBufferHwAddr)) =
                                                                    0x200000;
                    break;

            case MGA_PCI_2M:
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZBufferFlag)) = TRUE;
                    *((byte*) (InitBuf[iBoard] + INITBUF_ZinDRAMFlag)) = FALSE;
                    *((dword*)(InitBuf[iBoard] + INITBUF_ZBufferHwAddr)) =
                                                                    0x100000;
                    break;
        }
    }

    /* This blank is used before setting TITAN_FBM bit */
    /* (done in GetMGAConfiguration and MGASysInit) */
    /* Blank the screen */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_ADDR), 0x01);
    mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
    TmpByte |= 0x20;           /* screen off */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);

    GetMGAConfiguration(pMgaBaseAddr, &DST0, &DST1, &Info);

    *((dword*) (InitBuf[iBoard] + INITBUF_DST0)) = DST0;
    *((dword*) (InitBuf[iBoard] + INITBUF_DST1)) = DST1;
    *((dword*) (InitBuf[iBoard] + INITBUF_DACType)) = Info;

    /** Default setting **/
    *((byte*) (InitBuf[iBoard] + INITBUF_DB_SideSide))  = FALSE;
    *((byte*) (InitBuf[iBoard] + INITBUF_DB_FrontBack)) = FALSE;

    /*** CALCULATION OF YDSTORG FOR MGA_PCI_4M ***/
    if (ProductMGA[iBoard] == MGA_PCI_4M)
    {
        {
            dword NbBytes, PixelTransit, lines, offset;
            dword Width, Height, PixelWidth, FbPitch;

            if (pHwModeSelect->PixWidth == 24) /* PACK PIXEL */
            {
                Width = (dword)((pHwModeSelect->DispWidth * 3)  >> 2);
                FbPitch = (dword)(pHwModeSelect->FbPitch * 3) >> 2;
                PixelWidth = 4;
            }
            else
            {
                Width = (dword)pHwModeSelect->DispWidth;
                PixelWidth = (dword)((pHwModeSelect->PixWidth)/8);
                FbPitch = (dword)pHwModeSelect->FbPitch;
            }
            Height = (dword)pHwModeSelect->DispHeight;
            NbBytes = Width * Height * PixelWidth;
            if (NbBytes > (dword)2097152)
            {
                PixelTransit = (dword)2097152 / PixelWidth;
                lines = (dword)(PixelTransit / FbPitch);
                offset = (PixelTransit - (FbPitch * lines)) * PixelWidth;

                if (pHwModeSelect->PixWidth == 24) /* PACK PIXEL */
                    *((dword*) (InitBuf[iBoard] + INITBUF_YDSTORG)) = offset;
                else
                    *((dword*) (InitBuf[iBoard] + INITBUF_YDSTORG)) =
                                                        offset / PixelWidth;
            }
            else
            {
                *((dword*) (InitBuf[iBoard] + INITBUF_YDSTORG)) = 0;
            }
        }
    }
    else
    {
        *((dword*) (InitBuf[iBoard] + INITBUF_YDSTORG)) = 0;
    }


    /*--------------------------------------------------------------*/
    /** If Double Buffering mode (software) **/

    if((pHwModeSelect->DispType & 0x10) &&     /* DB mode */
      !(pHwModeSelect->DispType & 0x04) )     /* not LUT mode */
    {
        /* Check for exception case: DB mode 16 bit with Z for PCI/2M */
        if( (ProductMGA[iBoard]==MGA_PCI_2M) &&
            pHwModeSelect->ZBuffer &&
            pHwModeSelect->PixWidth == 8 &&
            Hw[iBoard].DacType == TVP3026)
        {
            *((dword*) (InitBuf[iBoard] + INITBUF_DB_YDSTORG)) =
                             *((dword*) (InitBuf[iBoard] + INITBUF_YDSTORG));

            *((byte*) (InitBuf[iBoard] + INITBUF_DB_FrontBack))  = TRUE;
            /** Caddi has to work in 16-bit **/
            *((byte*) (InitBuf[iBoard] + INITBUF_PWidth)) = 16 >> 4;
        }
        else
        {
            if(ProductMGA[iBoard]==MGA_PCI_2M)
            {
                *((dword*) (InitBuf[iBoard] + INITBUF_DB_YDSTORG)) =
                         (dword)((dword)pHwModeSelect->DispWidth *
                                 (dword)pHwModeSelect->DispHeight);
            }
            else
            {
                if (pHwModeSelect->ZBuffer && pHwModeSelect->PixWidth==8)
                {
                    /*** Must start on a boundary of 1M (for Z buffer alignment) ***/
                    *((dword*) (InitBuf[iBoard] + INITBUF_DB_YDSTORG)) =
                                    0x100000 / (pHwModeSelect->PixWidth / 8);
                }
                else
                {
                    *((dword*) (InitBuf[iBoard] + INITBUF_DB_YDSTORG)) =
                              (dword)((dword)pHwModeSelect->DispWidth *
                                      (dword)pHwModeSelect->DispHeight);
                }
            }

            *((byte*) (InitBuf[iBoard] + INITBUF_DB_SideSide))  = TRUE;
        }
    }
    else
    {
        *((dword*) (InitBuf[iBoard] + INITBUF_DB_YDSTORG)) =
                              *((dword*) (InitBuf[iBoard] + INITBUF_YDSTORG));
    }

    /*--------------------------------------------------------------*/


    /* To communicate the information to WINDOWS */
    Hw[iBoard].YDstOrg = *((dword*) (InitBuf[iBoard] + INITBUF_YDSTORG));

    /*** Program YDSTORG ***/
    mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_YDSTORG), Hw[iBoard].YDstOrg );

    switch((Hw[iBoard].ProductRev >> 4) & 0x0000000f)
    {
        case TITAN_CHIP:
                *((byte*) (InitBuf[iBoard] + INITBUF_ChipSet))  = TITAN_CHIP;
                *((byte*) (InitBuf[iBoard] + INITBUF_DubicPresent))  = 1;
                break;

        case ATLAS_CHIP:
                *((byte*) (InitBuf[iBoard] + INITBUF_ChipSet))  = ATLAS_CHIP;
                mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpByte);
                mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpByte | TITAN_NODUBIC_M);
                *((byte*) (InitBuf[iBoard] + INITBUF_DubicPresent))  = 0;
                break;

        case ATHENA_CHIP:
        default:
                *((byte*) (InitBuf[iBoard] + INITBUF_ChipSet))  = ATHENA_CHIP;
                mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpByte);
                mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), TmpByte | TITAN_NODUBIC_M);
                *((byte*) (InitBuf[iBoard] + INITBUF_DubicPresent))  = 0;
                break;
    }

    MGASysInit(InitBuf[iBoard]);

    /* Unblank the screen */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_ADDR), 0x01);
    mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
    TmpByte &= 0xdf;           /* screen on */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);

#if( !defined(_WINDOWS_DLL16) && !defined(OS2) && !defined(INIT_ONLY))
#ifndef WINDOWS_NT
#ifndef __DDK_SRC__
    sp = (SYSPARMS *)CaddiInit(InitBuf[iBoard], VideoBuf[iBoard]);
    if(BindingRC[iBoard] != (dword)NULL)
    {
        dword _Far *pBufBind;

        pBufBind = BufBind;
        *pBufBind++ = INITRC;
        *pBufBind++ = (dword)BindingRC[iBoard];

        *pBufBind++ = SETENDPOINT + (0x1 << 16);
        *pBufBind++ = (dword)BindingRC[iBoard];
        *pBufBind++ = DONE;
        if (!mtxPostBuffer (BufBind, DONT_CARE, DONT_CARE))
            return(mtxFAIL);
    }
#else
    sp = (SYSPARMS *)InitDDK(InitBuf[iBoard], VideoBuf[iBoard]);
	 /***
     ***  _tDDK_STATE needs to be re-initialized here if you want the DDK
     ***  to behave exactly like the SDK
     ***/

#endif  /* __DDK_SRC__ */
#endif  /* #ifndef WINDOWS_NT */
#endif  /* #if( !defined(_WINDOWS_DLL16) && !defined(OS2))... */

    return(mtxOK);
}

/*----------------------------------------------------------
* blkModeSupported
*
*  Check if board support 8-bit block mode.
*     Condition: i) chip set ATHENA
*               ii) IMP+ PCB rev 2 or more
*              iii)
*
* Return:
*   mtxOK   : 8-bit block mode supported
*   mtxFAIL : 8-bit block mode not supported
*
*----------------------------------------------------------*/
bool blkModeSupported()
{
   dword TramDword;

   /* Test if ATHENA chip */
   if( ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) < ATHENA_CHIP)
      return mtxFAIL;

   /* Special case */
   if( ((Hw[iBoard].ProductType &  0x0f) == BOARD_MGA_RESERVED) &&
       (Hw[iBoard].DacType != TVP3026 )
     ) return mtxFAIL;


   /* Test IMP+ with PCB rev < 2, we read TramDword to find IMP+ /p4 */
   mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_OPMODE),TramDword);
   TramDword &= TITAN_TRAM_M;

   /* PCB rev < 2 and not a /p4 */
   if( (((Hw[iBoard].ProductRev & 0xf) < 2) && !TramDword))
      return mtxFAIL;


   return mtxOK;
}

/*----------------------------------------------------------
* mtxSetDisplayMode
*
* Select the display mode
*
* Return:
*   ptr != 0 : Start address of the vidset buffer
*   ptr = 0  : SetDisplayMode select failure
*
*----------------------------------------------------------*/

bool mtxSetDisplayMode(HwModeData *pDisplayModeSelect, dword Zoom)
{

    byte  TmpByte, vsyncPresent;
    dword TmpDword;
    dword Dst0, Dst1, i;
    dword InfoHardware;




    /*-----------------------------------------------------------*/

#ifdef PRINT_DEBUG
    {
        reOpenDebugfFile();
        debug_printf("****** SetDisplayMode\n");
    }
#endif

    if (Hw[iBoard].pCurrentHwMode == NULL)
    {
    #ifdef PRINT_DEBUG
        closeDebugfFile("Hw[iBoard].pCurrentHwMode == NULL Fail\n");
    #endif
        return(mtxFAIL);
    }

    /* Validate Display mode to see if it is <= Hard Mode */
    if (pDisplayModeSelect->DispWidth > Hw[iBoard].pCurrentHwMode->DispWidth)
    {
    #ifdef PRINT_DEBUG
        closeDebugfFile("pDisplayModeSelect->DispWidth > Hw[iBoard].pCurrentHwMode->DispWidth Fail\n");
    #endif
        return(mtxFAIL);
    }

    /* Validate pDisplayModeSelect to see if it is displayable */
    if (pDisplayModeSelect->DispType & DISP_NOT_SUPPORT)
    {
    #ifdef PRINT_DEBUG
        closeDebugfFile("DISPLAY_NOT_SUPPORT Fail\n");
    #endif
        return(mtxFAIL);
    }

    if(pDisplayModeSelect->DispType & 0x08)     /* 565 mode */
       *((byte*) (InitBuf[iBoard] + INITBUF_565Mode))  = TRUE;
    else
       *((byte*) (InitBuf[iBoard] + INITBUF_565Mode))  = FALSE;


    Hw[iBoard].pCurrentDisplayMode = NULL;
    mtxSetVideoMode(mtxADV_MODE);


    /* begin programmation of display in vsynch */

    /* Test blank screen */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_ADDR), 0x01);
    mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), vsyncPresent);
    vsyncPresent = !(vsyncPresent & 0x20);

    /* Test if valide horizontal parameters in CRTC */
    if (vsyncPresent)
      {
      mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_1_CRTC_ADDR), 0x00);
      mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET  + TITAN_1_CRTC_DATA), TmpByte);
      mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_1_CRTC_ADDR), 0x01);
      mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET  + TITAN_1_CRTC_DATA), vsyncPresent);
      /* Compare     Hdisplay       Htotal */
      vsyncPresent = vsyncPresent < TmpByte;
      }




    if (vsyncPresent)
      {
      for (i = 0; i < 1000000L; i++)
         {
         mgaReadDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_STATUS), TmpDword);
         if ( !(TmpDword & TITAN_VSYNCSTS_M) ) break;
         }
      for (i = 0; i < 1000000L; i++)
         {
         mgaReadDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_STATUS), TmpDword);
         if ( (TmpDword & TITAN_VSYNCSTS_M) ) break;
         }
      }


    /*------ Strap added in ATHENA For max clock dac support ----*/
    GetMGAConfiguration(pMgaBaseAddr, &Dst0, &Dst1, &InfoHardware);

    mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), InfoHardware);

    if(!((Dst1 & TITAN_DST1_200MHZ_M) >> TITAN_DST1_200MHZ_A))
       InfoHardware = InfoHardware & 0xfffffffb;  /* bit 2=0: Board supports regular (135MHz/170MHz) operation */
    else
       InfoHardware = InfoHardware | 0x00000004;  /* bit 2=1: Board supports 200MHz operation */


    mgaWriteDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), InfoHardware);

    /*------ Strap added for ATHENA ------------------------------*/
    if ( blkModeSupported() )
        {
        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_OPMODE), InfoHardware);

        if(Dst0 & TITAN_DST0_BLKMODE_M)
            InfoHardware = InfoHardware & 0xf7ffffff;  /* bit 27=0: VRAM 4 bit block mode */
        else
            InfoHardware = InfoHardware | 0x08000000;  /* bit 27=1: VRAM 8 bit block mode */
        mgaWriteDWORD(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_OPMODE), InfoHardware);
        }

    /* Blank the screen */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_ADDR), 0x01);
    mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
    TmpByte |= 0x20;           /* screen off */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);

    Hw[iBoard].pCurrentDisplayMode = pDisplayModeSelect;
    Hw[iBoard].CurrentZoomFactor = (Zoom & 0x000f000f);

    /*** Load video parameters, load values in vidtab[] ***/
    loadVidPar(Zoom, Hw[iBoard].pCurrentHwMode, Hw[iBoard].pCurrentDisplayMode);

    /*** Calculate register values of the CRTC and put in crtcTab[] ***/
    calculCrtcParam();

    MoveToVideoBuffer((byte *)vidtab, (byte *)crtcTab, (byte *)VideoBuf[iBoard]);

#ifdef PRINT_DEBUG
    imprimeBuffer(InitBuf[iBoard], VideoBuf[iBoard]);
#endif

#if 0
    /*VIDEOPRO Init if TV MODE*/
    if (pDisplayModeSelect->DispType & 0x02)
    {
        switch(pDisplayModeSelect->DispWidth)
        {
            default:
            case 640:
                    if (VAFCconnector)
                        initVideoMode(NTSC_STD | VAFC,
                                        (byte)pDisplayModeSelect->PixWidth);
                    else
                        initVideoMode(NTSC_STD,
                                        (byte)pDisplayModeSelect->PixWidth);
                    break;

            case 768:
                    if (VAFCconnector)
                        initVideoMode(PAL_STD  | VAFC,
                                        (byte)pDisplayModeSelect->PixWidth);
                    else
                        initVideoMode(PAL_STD,
                                        (byte)pDisplayModeSelect->PixWidth);
                    break;
        }
    }
#endif

    MGAVidInit(InitBuf[iBoard], VideoBuf[iBoard]);

#if 0
    /*VIDEOPRO Make on if TV mode off sinon */
    if (pDisplayModeSelect->DispType & 0x02)
    {
        if (VAFCconnector)
            initVideoPro(1, PX2085);
        else
            initVideoPro(1, Hw[iBoard].DacType);
    }
    else
    {
        initVideoPro(0, Hw[iBoard].DacType);
    }
#endif
#ifdef SCRAP
    /*** BEN TEST SPECIAL POUR VIDEOPRO ***/
    mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_R), TmpByte);
    TmpByte = TmpByte & 0xfb;   /* force bit 2 a 0 (clock) */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_W), TmpByte);

    mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CRT_CTRL),TmpByte);
    TmpByte |= 0xc0;               /* Set vertical and horizontal reset */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CRT_CTRL),TmpByte);

    if(pDisplayModeSelect->DispType & 0x02 ) /* mode TV */
        initVideoPro(1);
    else
        initVideoPro(0);
#endif

    /*** BEN pour Pedro ***/
    /* Flag to avoid multiple initialisation of lvid[0:2] and lvidfield */
    *((byte*)(VideoBuf[iBoard] + VIDEOBUF_LvidInitFlag)) |= 0x80;

#if( !defined(_WINDOWS_DLL16) && !defined(OS2) && !defined(INIT_ONLY))
#ifndef WINDOWS_NT
    /*** BEN Permet de determiner DBWindowXOffset et DBWindowYOffset ***/
#ifndef __DDK_SRC__
    sp = (SYSPARMS *)CaddiInit(InitBuf[iBoard], VideoBuf[iBoard]);
#else
    sp = (SYSPARMS *)InitDDK(InitBuf[iBoard], VideoBuf[iBoard]);
#endif
#endif
#endif

#ifdef _WINDOWS_DLL16
    if(NbSxciLoaded)
    {
        fp1 = (FARPROC2)GetProcAddress(hsxci, "Win386LibEntry");
        (*fp1)((byte _Far *)InitBuf[iBoard], (byte _Far *)VideoBuf[iBoard],
                        Hw[iBoard].pCurrentHwMode->FbPitch, ID_CallCaddiInit);
    }
#endif

    /* Unblank the screen */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_ADDR), 0x01);
    mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
    TmpByte &= 0xdf;           /* screen on */
    mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);

    /* Wait for start of vertical sync */
    mgaPollDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_STATUS),
                                        TITAN_VSYNCSTS_SET, TITAN_VSYNCSTS_M);

    /* Need 16 ms for be sure we are one retrace make */
/* ------------------------------ Remplace par un delai de 16 ms */
/*    delay_us(16000); */

    /*** Calculation of CurrentOverScanX and CurrentOverScanY in structure HwData ***/
    if ( ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) > 0 )  /* NOT TITAN */
    {
        Hw[iBoard].CurrentOverScanX = 0;
        Hw[iBoard].CurrentOverScanY = 0;
    }
    else
    {
        overScan();
    }

#if( !defined(WINDOWS) && !defined(OS2) && !defined(WINDOWS_NT) && !defined(INIT_ONLY))
    mtxScClip(0, 0, pDisplayModeSelect->DispWidth, pDisplayModeSelect->DispHeight);
#endif

#ifdef _WINDOWS_DLL16
    if(NbSxciLoaded)
    {
        *(pDllMem+PAN_DISP_WIDTH)  = Hw[iBoard].pCurrentDisplayMode->DispWidth-1;
        *(pDllMem+PAN_DISP_HEIGHT) = Hw[iBoard].pCurrentDisplayMode->DispHeight-1;

        switch((Zoom & 0x000f000f))
        {
            case(0x00010001):
                    *(pDllMem+DB_SCALE) = (word)1;
                    break;

            case(0x00020002):
                    *(pDllMem+DB_SCALE) = (word)2;
                    break;

            case(0x00040004):
                    *(pDllMem+DB_SCALE) = (word)4;
                    break;

            default:
                    *(pDllMem+DB_SCALE) = (word)1;
        }
        AdjustDBWindow();
    }
#endif  /* #ifdef _WINDOWS_DLL16 */

#ifdef PRINT_DEBUG
    closeDebugfFile("Fin Set Display Mode\n");
#endif

    return(mtxOK);
}









/*----------------------- Ajustement overscan ------------------------------
hblank_e n'a que 6 bits de resolution. On le construit comme suit
5 bits Lsb dans reg 3 <4:0> et 6ieme bit dans reg 5 <7>

horizontal blank end = (reg 3 & 0x1f) | ((reg 5 >> 2) & 0x20)

On complete les bits manquant de BlankEnd en utilisant les bits
<7:6> de BLANK START.
SI les 6 bits LSBs  de BLANK START sont superieur a ceux du BLANK END
alors ceci veu dire les deux les plus significatif de BLANK END sont egale
a ceux du BLANK START + 1, sinon il sont egaux.

Une fois qu'on a le BLANK END complet on peut le comparer au horizontal Total
pour connaitre l'overscan a gauche.

0.......Blank End....Htotal - 1.

Note: On compare a Htotal -1. si il y 10 caractere alors on va de 0...9

Idem pour l'overscan vertical ou il manque les 2 bits MSBs <9:8>.

Note: Il y a un cas special ou le HBLANKE est a zero, dans ce cas
      l'overscan doit-etre a zero.
----------------------------------------------------------------------------*/

static void overScan(void)
{
    word total, blank_s, blank_e, mask;

    /* Overlay to left of screen */
    /* Htotal = reg(0) + 5 donc Htotal - 1 = reg(0) + 4 */

    total   = (word)(crtcTab[0] + 4);
    blank_s = (word)crtcTab[2];
    blank_e  = (word)((crtcTab[3] & 0x1f) | ( (crtcTab[5] >> 2) & 0x20 ));

    if (blank_e != 0) /* We verify for the special case where blank_e == 0 */
    {
        mask = blank_s >> 6;
        if ((blank_s & 0x3f) > blank_e) mask++;
        blank_e |= mask << 6;
        Hw[iBoard].CurrentOverScanX = (total - blank_e) << 3; /* 8 pixel per cell */
    }
    else
    {
        Hw[iBoard].CurrentOverScanX = 0;
    }

    /* Overlay on top of screen */
    /* Vtotal = reg(6,7) + 2 donc Vtotal - 1 = reg(6,7) + 1 */

    total    = (word)crtcTab[6] + 1;
    mask         = (word)crtcTab[7];
    total    |= ((mask << 4) & 0x200) | ((mask << 8) & 0x100);
    blank_s  = (word)crtcTab[21]                   |
                    ( ((word)crtcTab[9] << 4) & 0x200 ) |
                    ( ((word)crtcTab[7] << 5) & 0x100 ) ;
    blank_e  = (word)crtcTab[22];

    mask         = blank_s >> 8;
    if ((blank_s & 0x7f) > blank_e)
        mask++;
    blank_e |= mask << 8;

    Hw[iBoard].CurrentOverScanY = (total - blank_e);

    /* Test if we double the scan lines (Horizontal retrace divide select) */
    if (crtcTab[23] & 0x04)
        Hw[iBoard].CurrentOverScanY <<= 1;

    /* We modify the overscan, must recalculate the HotSpot */
    if  (Hw[iBoard].cursorInfo.CurWidth > 0)
        mtxCursorSetHotSpot(Hw[iBoard].cursorInfo.cHotSX,
                                  Hw[iBoard].cursorInfo.cHotSX);
}




void mapPciVl(dword addr)
{
    byte    TmpByte;
    dword   pci_id, TmpDword;
    mgaReadDWORD(*(pMgaBaseAddr+0x2000),pci_id);
    if ((pci_id == (dword)0x0518102b) || (pci_id == (dword)0x0d10102b))
    {
        mgaWriteDWORD(*(pMgaBaseAddr+0x2010),addr);
        mgaReadBYTE(*(pMgaBaseAddr+0x2004), TmpByte);
        mgaWriteBYTE(*(pMgaBaseAddr+0x2004), TmpByte | 2);

        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CONFIG),TmpDword);

        if (TmpDword&TITAN_VGAEN_M)
        {
        #ifndef WINDOWS_NT
            _outp(0x46e8, 0x08);
        #else
            _outp(ADDR_46E8_PORT, 0x08);
        #endif
        }

    }
}


/*-------------------------------------------------------------------
* MapBoard
*
* Map all MGA devices in systems
*
* Set global variables:
*   - Hw[].MapAddress
*   - MgaSel  : Board selector
*-------------------------------------------------------------------*/
bool MapBoard(void)
{
    dword   val_id, ba;

#if USE_VP_GET_ACCESS_RANGES

    VIDEO_ACCESS_RANGE MgaDriverPciAccessRange[14];
    ULONG       ulNbPciAccessRanges = 14;
    VP_STATUS   status;
    USHORT      VendorId = MATROX_VENDOR_ID;
    USHORT      DeviceId[] = { MGA_DEVICE_ID_ATH, MGA_DEVICE_ID_ATL };
    ULONG       ulNbDeviceIds = 2;
    ULONG       ulDeviceCnt = 0;
    ULONG       k;
    BOOLEAN     bRangeFound;

#endif

//[dlee] For now, we'll just check base addresses AC000 and C8000 on Alpha
//#ifndef MGA_ALPHA
    dword ScanAddr[] = { MGA_ISA_BASE_1, MGA_ISA_BASE_2, MGA_ISA_BASE_3,
                         MGA_ISA_BASE_4, MGA_ISA_BASE_5, MGA_ISA_BASE_6,
                         MGA_ISA_BASE_7 };
//#else
//    dword ScanAddr[] = { MGA_ISA_BASE_2, MGA_ISA_BASE_1 };
//#endif

    word    i, j, b_exist;
    PciBiosInfo bi;

#ifndef WINDOWS_NT
    NbBoard = 0;
#endif

    MgaSel = getmgasel();
    mtxSetVLB(MgaSel);

#ifdef WINDOWS_NT
    // Special
    if (NtInterfaceType == PCIBus)
    {
#endif

#if USE_VP_GET_ACCESS_RANGES

#define  PCI_SLOT_MAX   32

    for (i = 0; i < (word)ulNbPciAccessRanges; i++)
    {
        MgaDriverPciAccessRange[i].RangeStart.LowPart = 0xffffffff;
    }

//    DbgBreakPoint();
//    _asm {int 3}

    PciSlot = 0;

    status = VideoPortGetAccessRanges(pMgaDeviceExtension,
                                      0,
                                      (PIO_RESOURCE_DESCRIPTOR) NULL,
                                      ulNbPciAccessRanges,
                                      MgaDriverPciAccessRange,
                                      &VendorId,
                                      &DeviceId[ulDeviceCnt],
                                      &PciSlot);
    if (status == NO_ERROR)
    {
        VideoDebugPrint((1, "MGA: no_error on DeviceId %d\n",
                                                            ulDeviceCnt));
        i = 0;
        while ((i < (word)ulNbPciAccessRanges) &&
               (NbBoard < 7) &&
               ((ba = MgaDriverPciAccessRange[i].RangeStart.LowPart) !=
                                                              0xffffffff))
        {
            if (MgaDriverPciAccessRange[i].RangeLength == 0x4000)
            {
                // This is a control aperture.
                // Do we already know about it?
                bRangeFound = FALSE;
                for (k = 0; k < NbBoard; k++)
                {
                    if (Hw[k].MapAddress == ba)
                    {
                        bRangeFound = TRUE;
                        break;
                    }
                }
                if (!bRangeFound)
                {
                    // This is a new memory-space range.
                    if ((pMgaBaseAddr = setmgasel(MgaSel, ba, 4)) != NULL)
                    {
                        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_REV),
                                                                  val_id);
                        if ( (val_id & (~TITAN_CHIPREV_M)) == TITAN_ID)
                        {
                            // This is one of ours!
                            Hw[NbBoard].MapAddress = ba;
                            Hw[NbBoard].BaseAddress = pMgaBaseAddr;
                            MgaBusType[NbBoard] = MGA_BUS_PCI;
                            NbBoard++;
                        }
                        else
                        {
                            // We don't know what this was!  Free the range.
                            VideoPortFreeDeviceBase(pMgaDeviceExtension,
                                                            pMgaBaseAddr);
                        }
                    }
                }
            }
            MgaDriverPciAccessRange[i].RangeStart.LowPart = 0xffffffff;
            i++;
        }
    }
    else
    {
        if (status == ERROR_MORE_DATA)
            VideoDebugPrint((1, "MGA: error_more_data on DeviceId %d\n", ulDeviceCnt));
        else if (status == ERROR_DEV_NOT_EXIST)
            VideoDebugPrint((1, "MGA: error_dev_not_exist on DeviceId %d\n", ulDeviceCnt));
        else
            VideoDebugPrint((1, "MGA: unknown error on DeviceId %d\n", ulDeviceCnt));
    }

#else   /* #if USE_VP_GET_ACCESS_RANGES */

#ifdef WINDOWS_NT   /* For WinNT3.1 and WinNT3.5/Intel */
    // Get access to ports before calling pciFindFirstMGA_2.
    //if (VideoPortVerifyAccessRanges(pMgaDeviceExtension,
    //                                1,
    //                                &MgaPciCseAccessRange) == NO_ERROR &&
    //   (pMgaPciIo = VideoPortGetDeviceBase(pMgaDeviceExtension,
    //                   MgaPciCseAccessRange.RangeStart,
    //                   MgaPciCseAccessRange.RangeLength,
    //                   MgaPciCseAccessRange.RangeInIoSpace)) != NULL)
    if ((pMgaPciIo = VideoPortGetDeviceBase(pMgaDeviceExtension,
                       MgaPciCseAccessRange.RangeStart,
                       MgaPciCseAccessRange.RangeLength,
                       MgaPciCseAccessRange.RangeInIoSpace)) != NULL)
    {
#endif  /* #ifdef MGA_WINNT31 */

#ifndef OS2
        if ( (ba = (dword)pciFindFirstMGA_2()) != (dword)-1)
        {
            while ( (ba != (dword)-1 ) && (NbBoard < 7) )
            {
        #ifdef WINDOWS_NT
                b_exist = 0;
                for (j = 0; j < NbBoard; j++)
                {
                    if (Hw[j].MapAddress == ba)
                    {
                        b_exist = 1;
                        break;
                    }
                }
                if (!b_exist)
                {
                    // This is a new range.
        #endif
                    pMgaBaseAddr = setmgasel(MgaSel, ba, 4);
                    if (pMgaBaseAddr != NULL)
                    {
                        mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_REV),val_id);
                        if ( (val_id & (~TITAN_CHIPREV_M)) == TITAN_ID)
                        {
                            Hw[NbBoard].MapAddress = ba;
                    #ifdef WINDOWS_NT
                            Hw[NbBoard].BaseAddress = pMgaBaseAddr;
                            MgaBusType[NbBoard] = MGA_BUS_PCI;
                            Hw[NbBoard].ConfigSpace = configSpace - 0x100;
                            if (configSpace > 0xd000)
                                Hw[NbBoard].ConfigSpace = 0;

                        #if 0   // TO BE COMPLETED
                            if (Hw[NbBoard].ConfigSpace != 0)
                            {
                                MgaPciConfigAccessRange.RangeStart.LowPart = (ULONG)configSpace;
                                if (VideoPortVerifyAccessRanges(pMgaDeviceExtension,
                                        1,
                                        &MgaPciConfigAccessRange) == NO_ERROR &&
                                   (pMgaPciConfigSpace = VideoPortGetDeviceBase(pMgaDeviceExtension,
                                        MgaPciConfigAccessRange.RangeStart,
                                        MgaPciConfigAccessRange.RangeLength,
                                        MgaPciConfigAccessRange.RangeInIoSpace)) != NULL)
                                {
                                    Hw[NbBoard].ConfigSpaceAddress = pMgaPciConfigSpace;
                                }
                            }
                        #endif
                    #endif
                            NbBoard++;
                        }
                    #ifdef WINDOWS_NT
                        else
                        {
                            // We don't know what that was!
                            VideoPortFreeDeviceBase(pMgaDeviceExtension,
                                                               pMgaBaseAddr);
                        }
                    #endif
                    }
            #ifdef WINDOWS_NT
                }
            #endif
                ba =  (dword)pciFindNextMGA_2();
            }
        }

    #ifdef WINDOWS_NT
        // Free access to ports after calling pciFindFirst/NextMGA_2.
        VideoPortFreeDeviceBase(pMgaDeviceExtension,pMgaPciIo);
    }
    #endif  /* #ifdef WINDOWS_NT */

    else
    {
    #ifdef WINDOWS_NT
        if ((pciBiosRoutine = pciBiosCallAddr()) != NULL)
        {
            VideoDebugPrint((1, "pciBiosRoutine = 0x%x\n", pciBiosRoutine));
    #endif
            if ( pciBiosPresent( &bi ) )
            {
#endif /* #ifndef OS2 */

                ba =  (dword)pciFindFirstMGA();
                while ( (ba != (dword)-1 ) && (NbBoard < 7) )
                {
            #ifdef WINDOWS_NT
                    b_exist = 0;
                    for (j = 0; j < NbBoard; j++)
                    {
                        if (Hw[j].MapAddress == ba)
                        {
                            b_exist = 1;
                            break;
                        }
                    }
                    if (!b_exist)
                    {
                        // This is a new range.
            #endif
                        pMgaBaseAddr = setmgasel(MgaSel, ba, 4);
                        if (pMgaBaseAddr != NULL)
                        {
                            mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_REV),
                                                                     val_id);
                            if ( (val_id & (~TITAN_CHIPREV_M)) == TITAN_ID)
                            {
                                Hw[NbBoard].MapAddress = ba;
                        #ifdef WINDOWS_NT
                                Hw[NbBoard].BaseAddress = pMgaBaseAddr;
                                MgaBusType[NbBoard] = MGA_BUS_PCI;
                        #endif
                                NbBoard++;
                            }
                    #ifdef WINDOWS_NT
                            else
                            {
                                // We don't know what that was!
                                VideoPortFreeDeviceBase(pMgaDeviceExtension,
                                                               pMgaBaseAddr);
                            }
                    #endif
                        }
                #ifdef WINDOWS_NT
                    }
                #endif

                    ba =  (dword)pciFindNextMGA();

                }
#ifndef OS2
            }

#ifdef WINDOWS_NT
        }
#endif
    }
#endif /* #ifndef OS2 */
#endif  /* #if USE_VP_GET_ACCESS_RANGES */

#ifdef WINDOWS_NT
    // Special
    }
    else
    {
#endif
    /* Search ISA BUS */
    if ( mtxIsVLBBios() )
    {
    #ifndef WINDOWS_NT
        _outp(0x46e8, 0x00);
    #else
        _outp(ADDR_46E8_PORT, 0x00);
    #endif
    }

//#ifndef MGA_ALPHA
    for (i=0; (i < 7) && (NbBoard < 7); i++)
//#else
//    for (i=0; (i < 2) && (NbBoard < 2); i++)
//#endif
    {
        b_exist = 0;
        for (j = 0; j < NbBoard; j++)
        {
            if (Hw[j].MapAddress == ScanAddr[i])
            {
                b_exist = 1;
                break;
            }
        }

    #ifdef WINDOWS_NT
        // On Windows NT, we have to verify that the range we're about to map
        // does not conflict with a range that has already been mapped by
        // another driver.
        //if ((!b_exist) && (!bConflictDetected(ScanAddr[i])))
        if (!b_exist)
        {
    #endif

            pMgaBaseAddr = setmgasel(MgaSel, ScanAddr[i], 4);
            if (pMgaBaseAddr != NULL)
            {
                mapPciVl(ScanAddr[i]);
                mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_REV),val_id);
                if ( !b_exist && ((val_id & (~TITAN_CHIPREV_M)) == TITAN_ID))
                {
                    Hw[NbBoard].MapAddress = ScanAddr[i];
            #ifdef WINDOWS_NT
                    Hw[NbBoard].BaseAddress = pMgaBaseAddr;
                    MgaBusType[NbBoard] = MGA_BUS_ISA;
                    Hw[NbBoard].ConfigSpace = 0;
            #endif
                    if ( mtxIsVLBBios() && (ScanAddr[i] == MGA_ISA_BASE_1) )
                        mgaWriteDWORD(*(pMgaBaseAddr+0x2010), (dword)0x80000000 |
                                                        (dword)MGA_ISA_BASE_1);
                    NbBoard++;
                }
        #ifdef WINDOWS_NT
                else
                {
                    // We don't know what that was!
                    VideoPortFreeDeviceBase(pMgaDeviceExtension, pMgaBaseAddr);
                }
        #endif
            }
    #ifdef WINDOWS_NT
        }
    #endif
    }

#ifdef WINDOWS_NT
    // Special
    }
#endif

    /* Indicates end of array */
    Hw[NbBoard].MapAddress = (dword)-1;

    if (NbBoard == 0)
        return(mtxFAIL);
    else
        return(mtxOK);

}





/*-----------------------------------------------------
* adjustDefaultVidset
*
* Return default Vidset for the select board
*------------------------------------------------------*/
char *adjustDefaultVidset()
{
    general_info *generalInfo;

    mgainf = DefaultVidset;
    generalInfo = (general_info *)selectMgaInfoBoard();
    generalInfo->MapAddress = Hw[iBoard].MapAddress;

#ifdef WINDOWS_NT
    generalInfo->BitOperation8_16 = -1;
#else
    generalInfo->BitOperation8_16 = (short)0xffff;
#endif

    return(mgainf);
}


//[dlee] Modified for Windows NT
//       This is not called for Windows NT because we can't open files in
//       kernel mode. (MGA.INF is new read in the user-mode driver instead)

#ifndef WINDOWS_NT
/*--------------------------------------------------------------
* mtxLectureMgaInf
*
* Read file mga.inf and put data in buffer mgainf
* or take DefaultVidset
*
*--------------------------------------------------------------*/
bool mtxLectureMgaInf(void)
{
#ifdef WINDOWS
    LPSTR lpszEnv;
    bool findMGA;
#endif

#ifdef OS2
    HFILE       hFile;
    USHORT      usAction;
    USHORT      usInfoLevel = 1;
    FILESTATUS  status;
    USHORT      bytesRead;
    ULONG           fn_ID;
    char            mgaName[] = "MGA";
    char far        *mgaPathPtr;
    char            mgaPath[300];
    USHORT      fileSize;
#else
    FILE        *pFile;
    char        *env, path[128];
    long        fileSize;
#endif
    int i;

#ifndef OS2
    /*** Reading file MGA.INF ***/
    /*** Put values in global array mgainf ***/
    strcpy(path, "mga.inf");
    if ((pFile = fopen(path, "rb")) == NULL)
    {
#endif

#ifdef WINDOWS
        /*** Find MGA variable ***/
        findMGA = FALSE;
        lpszEnv = GetDOSEnvironment();

        while(*lpszEnv != '\0')
        {
            if (! (strncmp("MGA=", lpszEnv, 4)) )
            {
                findMGA = TRUE;
                break;
            }

            lpszEnv += lstrlen(lpszEnv) + 1;
        }

        if (findMGA)
        {
            strcpy(path, lpszEnv+4);
            i = strlen(path);
            if (path[i-1] != '\\')
            strcat(path, "\\");
            strcat(path, "mga.inf");

            if ((pFile = fopen(path, "rb")) == NULL)
            {
                mgainf = adjustDefaultVidset();
                return mtxOK;
            }
        }
        else
        {
            mgainf = adjustDefaultVidset();
            return mtxOK;
        }
#endif  /* #ifdef WINDOWS */

#if( !defined(WINDOWS) && !defined(OS2) && !defined(WINDOWS_NT) )

        /* Check environment variable MGA */
        if ( (env = getenv("MGA")) != NULL )
        {
            strcpy(path, env);
            i = strlen(path);
            if (path[i-1] != '\\')
                strcat(path, "\\");
            strcat(path, "mga.inf");
            if ((pFile = fopen(path, "rb")) == NULL)
            {
                mgainf = adjustDefaultVidset();
                return mtxOK;
            }
        }
        else
        {
            mgainf = adjustDefaultVidset();
            return mtxOK;
        }
#endif /* #if( !defined(WINDOWS) && !defined(OS2) && !defined(WINDOWS_NT) ) */

#ifdef OS2
        /* Position of mga.inf defined by the environnement variable MGA */
        /* if it is not defined, we will use the setup by defaut */

        if(DosScanEnv(mgaName, &mgaPathPtr))
        {
            mgainf = adjustDefaultVidset();
            return(mtxOK);
        }
        strcpy(mgaPath, mgaPathPtr);
        strcat(mgaPath, "\\mga.inf");

        if(DosOpen2(mgaPath, &hFile, &usAction, 0L, FILE_NORMAL, FILE_OPEN,
                    OPEN_ACCESS_READONLY | OPEN_SHARE_DENYREADWRITE, NULL, 0L))
        {
            mgainf = adjustDefaultVidset();
            return(mtxOK);
        }

        DosQFileInfo(hFile, usInfoLevel, &status, (USHORT)sizeof(FILESTATUS));
        fileSize = (USHORT)status.cbFile;
#else
    }
    fseek(pFile, 0, SEEK_END);
    fileSize = ftell(pFile);
    rewind(pFile);
#endif

    if (CheckHwAllDone && (mgainf != DefaultVidset))
    free( (void *)mgainf);

    if ( (mgainf = (char *)malloc(fileSize * sizeof(char))) == 0 )
    {
    #ifdef OS2
        DosClose(hFile);
    #else
        fclose(pFile);
    #endif
        mgainf = adjustDefaultVidset();
        /*** BEN setter un warning code ici ***/
        return(mtxOK);
    }

#ifdef OS2
    if ( DosRead(hFile, (PVOID)mgainf, fileSize, &bytesRead) ||
        (bytesRead != fileSize))
#else
    if ( fread(mgainf, sizeof(char), fileSize, pFile) < fileSize )
#endif
    {
#ifdef OS2
        DosClose(hFile);
#else
        fclose(pFile);
#endif
        free(mgainf);
        mgainf = adjustDefaultVidset();
        /*** BEN setter un warning code ici ***/
        return(mtxOK);
    }

    if ( ((header *)mgainf)->Revision != (short)VERSION_NUMBER)
    {
        /* Conversion of old mga.inf file to the current revision */
        if ( !(mgainf = mtxConvertMgaInf( mgainf )))
        {
        #ifdef OS2
            DosClose(hFile);
        #else
            fclose(pFile);
        #endif
            mgainf = adjustDefaultVidset();
            /*** BEN setter un warning code ici ***/
            return(mtxOK);
        }
    }

#ifdef OS2
    DosClose(hFile);
#else
    fclose(pFile);
#endif

    if ( (general_info *)selectMgaInfoBoard() == NULL)
    {
        free(mgainf);
        mgainf = adjustDefaultVidset();
        /*** BEN setter un warning code ici ***/
        return(mtxOK);
    }

    if (strncmp(mgainf, "Matrox MGA Setup file", 21))
    {
        free(mgainf);
        mgainf = adjustDefaultVidset();
    }

    return(mtxOK);
}
#endif  /* #ifndef WINDOWS_NT */





/*-----------------------------------------------------
* selectMgaInfoBoard
*
* Return a pointer at the first information for the
* selected board
*------------------------------------------------------
*
* Algorithme de recherche
*     mga.inf support 7 card in the system. We have to fit the MapAdress
*     of the card whith the one specified in structure general_info. If
*     no one of the seven general_info fit, we pick the first valid one.
*  Note : The map adresse of the structure is not updated, we must not use
*         this adress outside this function.
*
*------------------------------------------------------*/


char *selectMgaInfoBoard()
{
    word IndexBoard, DefaultBoard;
    header *pHeader = (header *)mgainf;
    general_info  *genInfo = NULL;

    DefaultBoard = NB_BOARD_MAX;
    for (IndexBoard = 0; !genInfo && (IndexBoard < NB_BOARD_MAX); IndexBoard++)
    {
        if ( pHeader->BoardPtr[IndexBoard] > 0 )
        {
            if ( DefaultBoard == NB_BOARD_MAX) DefaultBoard = IndexBoard;
            genInfo = (general_info *)(mgainf + pHeader->BoardPtr[IndexBoard]);
            if (Hw[iBoard].MapAddress != genInfo->MapAddress) genInfo = NULL;
        }
    }

    if ( !genInfo)  /*** BEN setter un warning code ici ***/
    {
        if (DefaultBoard < NB_BOARD_MAX)
        {
            genInfo = (general_info *)(mgainf + pHeader->BoardPtr[DefaultBoard]);
        }
        else
        {
            mgainf  = adjustDefaultVidset();
            pHeader = (header *)mgainf;
            genInfo = (general_info *)(mgainf + pHeader->BoardPtr[0]);
        }
    }

    return (char *)genInfo;
}




/*-----------------------------------------------------
* UpdateHwModeTable
*
* Update hardware mode table with interlace informations
* if we are in interlace mode
*
*------------------------------------------------------*/

void UpdateHwModeTable (char *pMgaInfo,
                       HwModeData *pHwMode,
                       HwModeInterlace *piHwMode,
                       bool dacSupportHires )
{

    short FlagMonitorSupport;
    word  TmpRes;
    HwModeData *pHwMode1;
    general_info *generalInfo = (general_info *)pMgaInfo;

    if (CheckHwAllDone)
    {
        for (pHwMode1 = pHwMode ; pHwMode1->DispWidth != (word)-1; pHwMode1++)
        {
            pHwMode1->DispType &= 0x5e;    /* force interlaced = 0 and monitor limited = 0 */

            if (pHwMode1->DispType & 0x40) /* Hw limited */
                pHwMode1->DispType |= 0x80; /* force not displayable bit on */
        }
    }

    for ( ; pHwMode->DispWidth != (word)-1; piHwMode++, pHwMode++)
    {
        /* Determine TmpRes for compatibility with spec mga.inf */
        switch (pHwMode->DispWidth)
        {
            case 640:   if (pHwMode->DispType & 0x02)
                            TmpRes = RESNTSC;
                        else
                            TmpRes = RES640;
                        break;

            case 768:   TmpRes = RESPAL;
                        break;

            case 800:   TmpRes = RES800;
                        break;

            case 1024:  TmpRes = RES1024;
                        break;

            case 1152:  TmpRes = RES1152;
                        break;

            case 1280:  TmpRes = RES1280;
                        break;

            case 1600:  TmpRes = RES1600;
                        break;
        }

        FlagMonitorSupport = generalInfo ->MonitorSupport[TmpRes];

        /*** Update of the pHwMode table if I (interlace) ***/
        switch ( FlagMonitorSupport )
        {
            case MONITOR_I:
                    if(piHwMode->FbPitch)
                    {
                        pHwMode->FbPitch = piHwMode->FbPitch;
                        pHwMode->DispType = piHwMode->DispType;
                        pHwMode->NumOffScr = piHwMode->NumOffScr;
                        pHwMode->pOffScr = piHwMode->pOffScr;
                    }
                    pHwMode->DispType |= DISP_SUPPORT_I;    /* Interlace */
                    break;

            case MONITOR_NA:
                    pHwMode->DispType |= DISP_SUPPORT_NA;   /* monitor  limited */
                    break;
        }

        /* Not displayable, hw limited */
        if ((pHwMode->DispWidth > 1280) && !dacSupportHires)
            pHwMode->DispType |= DISP_SUPPORT_HWL;

#if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE))
        if (SupportDDC && !(byte)InDDCTable(pHwMode->DispWidth))
           pHwMode->DispType |= DISP_SUPPORT_NA;   /* monitor  limited */
#endif

        /*** For ATLAS chip we can't do Z buffering ***/
        if( ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) == ATLAS_CHIP &&
                                                        pHwMode->ZBuffer )
            pHwMode->DispType |= DISP_SUPPORT_HWL;

        /*** For an Ultima board we can't do Z-buffer ***/

        if( !((Dst1 & TITAN_DST1_ABOVE1280_M) && (Dst1 & TITAN_DST1_200MHZ_M)) &&
            (ProductMGA[iBoard] == MGA_PCI_2M || ProductMGA[iBoard] == MGA_PCI_4M) &&
            ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) == ATHENA_CHIP &&
            pHwMode->ZBuffer && Hw[iBoard].DacType != TVP3026)
            {
            pHwMode->DispType |= DISP_SUPPORT_HWL;
            }

        /* For Impression Lite we can't do double buffering */
        if ((Dst1 & TITAN_DST1_ABOVE1280_M) && (Dst1 & TITAN_DST1_200MHZ_M) &&
            ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) == ATHENA_CHIP &&
            (pHwMode->DispType & 0x10) && pHwMode->ZBuffer)
            {
            pHwMode->DispType |= DISP_SUPPORT_HWL;
            }


        /* PACK PIXEL ON TVP and Windows only */

    #ifdef _WINDOWS_DLL16
        if ((pHwMode->PixWidth == 24) && (Hw[iBoard].DacType != TVP3026))
            pHwMode->DispType |= DISP_SUPPORT_HWL;
    #else
        if (pHwMode->PixWidth == 24)
            pHwMode->DispType |= DISP_SUPPORT_HWL;
    #endif

    }
}

/*-----------------------------------------------------
* mtxGetMgaSel
*
* Return the selector
* (Called by the driver)
*------------------------------------------------------*/

dword mtxGetMgaSel(void)
{
    return(MgaSel);
}






/*-----------------------------------------------------
* mtxGetInfo
*
* Return useful informations to Open GL and Windows
*------------------------------------------------------*/

void mtxGetInfo(HwModeData **pCurHwMode, HwModeData **pCurDispMode, byte **InitBuffer, byte **VideoBuffer)
{
    *pCurHwMode = Hw[iBoard].pCurrentHwMode;
    *pCurDispMode = Hw[iBoard].pCurrentDisplayMode;
    *InitBuffer = InitBuf[iBoard];
    *VideoBuffer = VideoBuf[iBoard];
}


#ifdef WINDOWS
/*-----------------------------------------------------
* mtxGetHwData
*
* Return useful informations to Open GL and Windows
* Return value:
*   - null pointer : no MGA board
*   - valid pointer: pointer to HwData structure
*------------------------------------------------------*/

HwData *mtxGetHwData(void)
{
    if(Hw[iBoard].MapAddress == (dword)-1)
        return 0;
    else
        return(&Hw[iBoard]);
}
#endif  /* #ifdef WINDOWS */




/*-----------------------------------------------------
* InitHwStruct
*
* Initialize: Hw[].pCurrentHwMode
*             Hw[].VramAvailable
*             Hw[].DramAvailable
*------------------------------------------------------*/

bool InitHwStruct(byte CurBoard, HwModeData *pHwModeData, word sizeArray,
                  dword VramAvailable, dword DramAvailable)
{
    /* Dynamic allocation of memory if we have more than 1 board */

    if (NbBoard == 1)
    {
        Hw[CurBoard].pCurrentHwMode = pHwModeData;
    }
    else
    {
      #ifdef WINDOWS_NT
        if(! (Hw[CurBoard].pCurrentHwMode = AllocateSystemMemory(sizeArray)))
            return mtxFAIL;
        Hw[CurBoard].pHwMode = Hw[CurBoard].pCurrentHwMode;
      #else
        if(! (Hw[CurBoard].pCurrentHwMode = malloc(sizeArray)))
            return mtxFAIL;
      #endif
        memcpy(Hw[CurBoard].pCurrentHwMode, pHwModeData, sizeArray);
    }

    FirstMode[CurBoard] = Hw[CurBoard].pCurrentHwMode;
    Hw[CurBoard].VramAvail = VramAvailable;
    Hw[CurBoard].DramAvail = DramAvailable;

    return mtxOK;
}




/*-------------------------------------------------------------------
* mtxSetLUT
*
* Initialize RAMDAC LUT
*
* Return value:
*    mtxOK   - successfull
*   mtxFAIL  - failed (not in a LUT mode
*-------------------------------------------------------------------*/
bool mtxSetLUT(word index, mtxRGB color)
{

    if(! (Hw[iBoard].pCurrentHwMode->DispType & 0x04))
        return mtxFAIL;

    switch(Hw[iBoard].DacType)
    {
        case BT482:
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT482_WADR_PAL),
                                                            (byte)index);
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT482_COL_PAL),
                                                            (byte)color);
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT482_COL_PAL),
                                                        (byte)(color >> 8));
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT482_COL_PAL),
                                                        (byte)(color >> 16));
            break;

        case BT485:
        case PX2085:
        case VIEWPOINT:
        case TVP3026:
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT484_WADR_PAL),
                                                            (byte)index);
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT484_COL_PAL),
                                                            (byte)color);
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT484_COL_PAL),
                                                        (byte)(color >> 8));
            mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT484_COL_PAL),
                                                        (byte)(color >> 16));
            break;

        default:
            return mtxFAIL;
    }
    return mtxOK;
}



/*---------------------------------------------
* mtxClose
* Supported for compatibility. Nothing done
*---------------------------------------------*/
void mtxClose(void)
{
}



#ifdef _WINDOWS_DLL16
/*----------------------------------------------------------
* mtxLoadSXCI
*
* Load SXCI.DLL
*
* Return: (mtxOK or mtxFAIL)
*
*----------------------------------------------------------*/

HANDLE FAR PASCAL _export mtxLoadSXCI(word mode, word FAR *ErrorCode)
{
    char cBuffer[20];


    GetPrivateProfileString("mga.drv","3D","",cBuffer,sizeof(cBuffer),
                                                                "SYSTEM.INI");
    if( (strcmp(cBuffer,"OFF")== 0) && mode == SXCI_3D &&
      (((Hw[iBoard].ProductRev >> 4) & 0x0000000f) == 0) )  /* TITAN */
    {
        *ErrorCode = 101;
        return(0);
    }

    GetPrivateProfileString("boot","display.drv","",cBuffer,sizeof(cBuffer),
                                                                "SYSTEM.INI");
    if( (strcmp(cBuffer,"mga16.drv")== 0) && mode == SXCI_3D )
    {
        *ErrorCode = 103;       /* driver not supported */
        return(0);
    }

    if( (Hw[iBoard].pCurrentHwMode->ZBuffer == FALSE) && mode == SXCI_3D)
    {
        *ErrorCode = 102;
        return(0);
    }


    /*** If pack pixel mode: can't load sxci.dll ***/
    if( Hw[iBoard].pCurrentHwMode->PixWidth == 24)
    {
        *ErrorCode = 104;
        return(0);
    }



    hsxci = LoadLibrary("sxci.dll");
    if(hsxci > 32)
    {
        fp1 = (FARPROC2)GetProcAddress(hsxci, "Win386LibEntry");
    }
    else
    {
        *ErrorCode = 100;
        return(0);
    }

    pDllMem = (word FAR *)memalloc(30);
    (*fp1)(pDllMem, 31);    /* Call PassPoolMem */

    *(pDllMem+PAN_X) = 0;
    *(pDllMem+PAN_Y) = 0;
    *(pDllMem+PAN_DISP_WIDTH)  = Hw[iBoard].pCurrentDisplayMode->DispWidth-1;
    *(pDllMem+PAN_DISP_HEIGHT) = Hw[iBoard].pCurrentDisplayMode->DispHeight-1;
    *(pDllMem+PAN_BOUND_LEFT)   = 0;
    *(pDllMem+PAN_BOUND_RIGHT)  = 0;
    *(pDllMem+PAN_BOUND_TOP)    = 0;
    *(pDllMem+PAN_BOUND_BOTTOM) = 0;
    *(pDllMem+DB_SCALE) = (word)1;

    *ErrorCode = hsxci;
    NbSxciLoaded++;
    return(hsxci);
}



/*----------------------------------------------------------
* mtxUnloadSXCI
*
* Unload SXCI.DLL
*
* Return: void
*
*----------------------------------------------------------*/

void FAR PASCAL _export mtxUnloadSXCI(void)
{
    if(NbSxciLoaded)
    {
        if(NbSxciLoaded == 1)
            memfree((void FAR **)&pDllMem);
        FreeLibrary(hsxci);
        NbSxciLoaded--;
    }
}

#endif  /* #ifdef _WINDOWS_DLL16 */




/*----------------------------------------------------------
* ProgrammeClock
*
* Set clock according of new strapping: (50MHz, 55MHz or 60MHz)
* VD34, VD33 -> MGA-PCI/2 and MGA-VLB/2
* VD49, VD36 -> MGA-PCI/2+ and MGA-VLB/2+
*
* For TITAN -> 45MHz
*----------------------------------------------------------*/

bool ProgrammeClock(byte Chip, dword Dst1, dword InfoDac)
{
    dword Value;
    dword ValClock;
    byte TmpByte;

    if( (Chip == ATLAS_CHIP) || (Chip == ATHENA_CHIP))
    {
        if ((Hw[iBoard].ProductType &  0x0f) == BOARD_MGA_RESERVED)
        {
            ValClock = 0x065AC3D;  /* 50MHz */
        }

        /*** Detect if MGA-PCI/2+ or MGA-VLB/2+ ***/
        else if( ((ProductMGA[iBoard] == MGA_PCI_2M) ||
                  (ProductMGA[iBoard] == MGA_PCI_4M)) &&
                 (InfoDac == Info_Dac_ViewPoint))
        {
            Value = ((Dst1 & TITAN_DST1_NOMUXES_M) >>
                                                (TITAN_DST1_NOMUXES_A-1)) |
                    ((Dst1 & TITAN_DST1_ABOVE1280_M) >>
                                                TITAN_DST1_ABOVE1280_A);

            switch(Value)
            {
                case 3:
                        ValClock = 0x065AC3D;  /* 50MHz */
                        break;
                case 2:
                        ValClock = 0x068A413;  /* 60MHz */
                        break;
                case 0:
                        ValClock = 0x067D83D;  /* 55MHz */
                        break;
                default:
                        return(mtxFAIL);
            }
        }
        else
        {
            Value = (Dst1 & TITAN_DST1_RAMSPEED_M) >> TITAN_DST1_RAMSPEED_A;

            switch(Value)
            {
                case 0:
                        ValClock = 0x065AC3D;  /* 50MHz */
                        break;
                case 1:
                        ValClock = 0x068A413;  /* 60MHz */
                        break;
                case 3:
                        ValClock = 0x067D83D;  /* 55MHz */
                        break;
                default:
                        return(mtxFAIL);
            }
        }
    }
    else  /* TITAN */
    {
        ValClock = 0x0063AC44;   /* 45MHz */
    }

    /* Lookup for find real frequency to progrmming */
    switch( ValClock )
    {
        case 0x063AC44: presentMclk[iBoard] = 45000000L; /* 45Mhz */
                        break;

        case 0x065AC3D: presentMclk[iBoard] = 50000000L; /* 50Mhz */
                        break;

        case 0x067D83D: presentMclk[iBoard] = 55000000L; /* 55Mhz */
                        break;

        case 0x068A413: presentMclk[iBoard] = 60000000L; /* 60Mhz */
                        break;

        case 0x06d4423: presentMclk[iBoard] = 65000000L; /* 65Mhz */
                        break;

        case 0x06ea410: presentMclk[iBoard] = 70000000L; /* 70Mhz */
                        break;

        case 0x06ed013: presentMclk[iBoard] = 75000000L; /* 75Mhz */
                        break;

        case 0x06f7020: presentMclk[iBoard] = 80000000L; /* 80Mhz */
                        break;

        case 0x071701e: presentMclk[iBoard] = 85000000L; /* 85Mhz */
                        break;

        case 0x074fc13: presentMclk[iBoard] = 90000000L; /* 90Mhz */
                        break;

        default:        ValClock = 0x065AC3D;
                        presentMclk[iBoard] = 50000000L; /* 50Mhz */
    }

    if(InfoDac == Info_Dac_TVP3026)
    {
        setTVP3026Freq(pMgaBaseAddr, presentMclk[iBoard] / 1000L, 3, 0);
    }
    else
    {
        /*** Program MCLOCK ***/
        mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_R), TmpByte);
        programme_reg_icd ( pMgaBaseAddr, 3, ValClock );
        mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_ISTAT0), TmpByte);
        delay_us(10000);
    }

    return(mtxOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxpci.c ===
/*****************************************************************************
*          name: PCI acces module
*
*   description: Acces the PCI functions in the BIOS
*
*      designed: Christian Toutant, august 26, 1993
* last modified: 
*
*       version: $Id: 
*
* function in modul:
*
******************************************************************************/

#include "switches.h"

#ifdef WINDOWS_NT
    #include "dderror.h"
    #include <string.h>
#endif  /* #ifdef WINDOWS_NT */

#include "bind.h"
#include "defbind.h"
#include "def.h"
#include "mga.h"
#include "mgai_c.h"
#include "mgai.h"

#include "mtxpci.h"

/* GLOBAL */
word  pciBoardInfo = 0;   

/* Prototypes */

#ifdef WINDOWS_NT

//HACK!!!
typedef struct _MULTI_MODE
{
    ULONG   MulModeNumber;                // unique mode Id
    ULONG   MulWidth;                     // total width of mode
    ULONG   MulHeight;                    // total height of mode
    ULONG   MulPixWidth;                  // pixel depth of mode
    ULONG   MulRefreshRate;               // refresh rate of mode
    USHORT  MulArrayWidth;                // number of boards arrayed along X
    USHORT  MulArrayHeight;               // number of boards arrayed along Y
    UCHAR   MulBoardNb[NB_BOARD_MAX];     // board numbers of required boards
    USHORT  MulBoardMode[NB_BOARD_MAX];   // mode required from each board
    HwModeData *MulHwModes[NB_BOARD_MAX]; // pointers to required HwModeData
} MULTI_MODE, *PMULTI_MODE;


/*--------------------------------------------------------------------------*\
| HW_DEVICE_EXTENSION
|
| Define device extension structure. This is device dependant/private
| information.
|
\*--------------------------------------------------------------------------*/
typedef struct _MGA_DEVICE_EXTENSION {
    ULONG   SuperModeNumber;                // Current mode number
    ULONG   NumberOfSuperModes;             // Total number of modes
    PMULTI_MODE pSuperModes;                // Array of super-modes structures
                                            // For each board:
    ULONG   NumberOfModes[NB_BOARD_MAX];    // Number of available modes
    ULONG   NumberOfValidModes[NB_BOARD_MAX];
                                            // Number of valid modes
    ULONG   ModeFlags2D[NB_BOARD_MAX];      // 2D modes supported by each board
    ULONG   ModeFlags3D[NB_BOARD_MAX];      // 3D modes supported by each board
    USHORT  ModeFreqs[NB_BOARD_MAX][64];    // Refresh rates bit fields
    UCHAR   ModeList[NB_BOARD_MAX][64];     // Valid hardware modes list
    HwModeData *pMgaHwModes[NB_BOARD_MAX];  // Array of mode information structs.
    BOOLEAN bUsingInt10;                    // May need this later
    PVOID   KernelModeMappedBaseAddress[NB_BOARD_MAX];
                                            // Kern-mode virt addr base of MGA regs
    PVOID   UserModeMappedBaseAddress[NB_BOARD_MAX];
                                            // User-mode virt addr base of MGA regs
    PVOID   MappedAddress[];                // NUM_MGA_COMMON_ACCESS_RANGES elements
} MGA_DEVICE_EXTENSION, *PMGA_DEVICE_EXTENSION;

    void initConfigAddress( void );
    int  nextDevice( void );
    dword getConfigData( int reg );
    void setConfigData( int reg, dword donnee);
    dword pciFindFirstMGA_1();
    dword pciFindNextMGA_1();
    void setAthenaRevision_1(void);
    PUCHAR pciBiosCallAddr();

extern  byte  NbBoard;
extern  HwData Hw[];

#endif  /* #ifdef WINDOWS_NT */

bool pciBiosCall( union _REGS *r );
bool pciBiosPresent( PciBiosInfo *info);
dword pciFindFirstMGA();
dword pciFindNextMGA();
void setPciOptionReg();
void disPostedWFeature();
dword pciFindFirstMGA_2();
dword pciFindNextMGA_2();

#ifdef WINDOWS_NT
#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,initConfigAddress)
    #pragma alloc_text(PAGE,getConfigData)
    #pragma alloc_text(PAGE,setConfigData)
    #pragma alloc_text(PAGE,pciFindFirstMGA_1)
    #pragma alloc_text(PAGE,pciFindNextMGA_1)
    #pragma alloc_text(PAGE,pciBiosCall)
    #pragma alloc_text(PAGE,pciBiosPresent)
    #pragma alloc_text(PAGE,setAthenaRevision_1)
    #pragma alloc_text(PAGE,pciFindFirstMGA)
    #pragma alloc_text(PAGE,pciFindNextMGA)
    #pragma alloc_text(PAGE,pciBiosCallAddr)
    #pragma alloc_text(PAGE,setPciOptionReg)
    #pragma alloc_text(PAGE,disPostedWFeature)
    #pragma alloc_text(PAGE,pciFindFirstMGA_2)
    #pragma alloc_text(PAGE,pciFindNextMGA_2)
#endif
#endif  /* #ifdef WINDOWS_NT */

#if (!defined(WINDOWS_NT) || defined(MGA_WINNT31) || (!USE_VP_GET_ACCESS_RANGES))
/* The only part of this file required for Alpha under WinNT3.5 is setPciOptionReg */

word errorCode = 0;
static word 
currentMgaIndexATL = 0;
currentMgaIndexATH = 0;
word configSpace = 0xffff;

/* Extern parameter */
extern dword MgaSel;
extern  dword    getmgasel(void);

#ifndef WINDOWS_NT
#else
extern  PUCHAR pMgaBaseAddr;
extern  PUCHAR setmgasel(dword MgaSel, dword phyadr, dword limit);
#endif

#ifdef WINDOWS_NT

#define SET_EAX(r,d)        (r).e.reax  = d
#define SET_EBX(r,d)        (r).e.rebx  = d
#define SET_ECX(r,d)        (r).e.recx  = d
#define SET_EDX(r,d)        (r).e.redx  = d
#define SET_AX(r,d)         (r).x.ax  = d
#define SET_BX(r,d)         (r).x.bx  = d
#define SET_CX(r,d)         (r).x.cx  = d
#define SET_DX(r,d)         (r).x.dx  = d
#define SET_SI(r,d)         (r).x.si  = d
#define SET_DI(r,d)         (r).x.di  = d


#define GET_EAX(r)          ((r).e.reax)
#define GET_EBX(r)          ((r).e.rebx)
#define GET_ECX(r)          ((r).e.recx)
#define GET_EDX(r)          ((r).e.redx)
#define GET_ESI(r)          ((r).e.resi)
#define GET_EDI(r)          ((r).e.redi)
#define GET_AX(r)           ((r).x.ax)
#define GET_BX(r)           ((r).x.bx)
#define GET_CX(r)           ((r).x.cx)
#define GET_DX(r)           ((r).x.dx)
#define GET_SI(r)           ((r).x.si)
#define GET_DI(r)           ((r).x.di)

VOID    (*pciBiosRoutine)();

#define inp     _inp
#define outp    _outp

#define CONFIG_SPACE            0x0000c000

extern  PUCHAR  pMgaPciIo, pMgaPciConfigSpace;
extern  PVOID   pMgaDeviceExtension;
extern  VIDEO_ACCESS_RANGE MgaPciConfigAccessRange, MgaPciCseAccessRange;

#define TITAN_PEL_ADDR_RD  (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3c7 - 0x3c0))
#define TITAN_PEL_ADDR_WR  (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3c8 - 0x3c0))
#define TITAN_PEL_DATA     (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3c9 - 0x3c0))

// Mechanism 1 is used this way only for Windows NT.
/* Mechanism #1 interface */

#define CONFIG_ADDRESS     0xcf8
#define CONFIG_DATA        0xcfc

#define BUS_NUMBER_M      0x00ff0000h
#define DEV_NUMBER_M      0x0000f800h
#define BUS_NUMBER_A      16
#define DEV_NUMBER_A      11
#define REG_NUMBER_M      0xfc

#define MAGIG_ATLAS_NUMBER  0x0518102b
#define MAGIG_ATHENA_NUMBER 0x0D10102b

static dword              currentBUS = 0;
static dword              currentDEV = 0;


/*-------- Mechanism #1 */

void initConfigAddress()
{
    dword adresse;

    currentDEV = (dword)-1;
    currentBUS = 0;
    adresse = 0x80000000;
    outdw(CONFIG_ADDRESS, adresse);
}

int  nextDevice( void )
{
    int trouve = 0;
    dword magicID;
    currentDEV++;
    while ( !trouve && (currentBUS < 256) )
    {
        while ( !trouve && (currentDEV < 32 ) )
        {
            magicID = getConfigData( 0 );
            trouve = ( magicID == MAGIG_ATLAS_NUMBER) ||
                     ( magicID == MAGIG_ATHENA_NUMBER);

            if (trouve)return -1;
                currentDEV++;
        }
        currentDEV = 0;
        currentBUS++;
    }

    return trouve;
}

dword getConfigData( int reg )
{
    dword retVal, adresse;
    adresse = 0x80000000 | (currentBUS << BUS_NUMBER_A)
                         | (currentDEV << DEV_NUMBER_A);

    adresse |= reg & REG_NUMBER_M;
    outdw(CONFIG_ADDRESS, adresse);
    retVal = indw(CONFIG_DATA);
    outdw(CONFIG_ADDRESS, 0);

    return retVal;
}

void setConfigData( int reg, dword donnee)
{

    dword adresse;
    adresse = 0x80000000 | (currentBUS << BUS_NUMBER_A)
                         | (currentDEV << DEV_NUMBER_A);

    adresse |= reg & REG_NUMBER_M;
    outdw(CONFIG_ADDRESS, adresse);
    outdw(CONFIG_DATA, donnee);
    outdw(CONFIG_ADDRESS, 0);
}


/*----------------------------------------------------------------------------
|          name: setAthenaRevision_1
|
|   description: test acces to DAC in vgamode with snopping enabled
|                if snooping not supporting, set pciBoardInfo to
|                PCI_FLAG_ATHENA_REV1
|
|      designed: Christian Toutant, octobre 14, 1994
| last modified: 
|
| 
|    parameters:  PciDevice *dev  
|                 byte       command        
|
|      modifies: pciBoardInfo
|         calls: pciReadConfigByte, pciWriteConfigByte
|       returns: 
|                       
-----------------------------------------------------------------------------*/
void setAthenaRevision_1()
{
   dword command;
   dword classe;
   dword baseAddress;
   byte  btmp;

   command = getConfigData( 0x4 );
   classe  = getConfigData( 0x8 );
   baseAddress = getConfigData( 0x10 );

   if ( !(classe & 0x00800000) && !(command & (dword)3) )
      {
      command |= (dword)2;
      setConfigData( 0x4, command);
      if ((pMgaBaseAddr = setmgasel(MgaSel, baseAddress, 4)) != NULL)
          {
          mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CONFIG+1),btmp);
          mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CONFIG+1),btmp & ~(byte)4);
          VideoPortFreeDeviceBase(pMgaDeviceExtension, pMgaBaseAddr);
          }
      }

   if ( !(classe & 0x00800000) && !(command & (dword)PCI_SNOOPING) )
   {
      /* assume athena rev > 1 */
      pciBoardInfo &= ~(word)PCI_FLAG_ATHENA_REV1;

      /* init location 64 at 0 */
      VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
      VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);    /* reinit write addr */

      /* empty fifo */
      VideoPortReadPortUchar(TITAN_PEL_ADDR_RD);

      /* active snooping */
      setConfigData( 0x4, command |  (dword)PCI_SNOOPING);

      /* write to DAC in snooping mode */
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)0x11);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)0x22);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)0x33);

      /* restore snooping */
      setConfigData( 0x4, command );

      /* now if the acces fail, we assume athena rev 1 */
      VideoPortWritePortUchar(TITAN_PEL_ADDR_RD, (UCHAR)64);    /* init read addr to loc 64 */
      if (
          (VideoPortReadPortUchar(TITAN_PEL_DATA) != 0x11) ||
          (VideoPortReadPortUchar(TITAN_PEL_DATA) != 0x22) ||
          (VideoPortReadPortUchar(TITAN_PEL_DATA) != 0x33)
         ) pciBoardInfo |= PCI_FLAG_ATHENA_REV1;

      /* init location 64 at 0 */
      VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
      VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
      VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);  /* reinit write addr */
   }
}


/*----------------------------------------------------------------------------
|          name: pciFindFirstMGA_1
|
|   description: Find the first MGA device in the system and return the base
|                address of the device in the system (a succesive call to the 
|                function pciFindNextMGA give the address of other mga device
|                in the system). Use harware mechanisme #1.
|
|      designed: Christian Toutant, march 26, 1994
| last modified: 
|
| 
|    parameters: none
|      modifies: static variable currentIndex set to 1.
|         calls: pciBiosPresent, pciFindDevice, pciReadConfigDWord
|       returns: dword base address of the first mga found.
|                -1 if no mga found (or no PCI BIOS found).
|                       
-----------------------------------------------------------------------------*/
dword pciFindFirstMGA_1()
{
    initConfigAddress();
    return pciFindNextMGA_1();
}

/*----------------------------------------------------------------------------
|          name: pciFindNextMGA_1
|
|   description: Find the next MGA device in the system and return the base
|                address of the device the function pciFindFirstMGA must me call
|                before call to this function. Use harware mechanisme #1.
|
|
|      designed: Christian Toutant, march 26, 1994
| last modified: 
|
| 
|    parameters: none
|      modifies: static variable currentIndex is incremented by 1.
|         calls: pciBiosPresent, pciFindDevice, pciReadConfigDWord
|       returns: dword base address of the first mga found.
|                -1 if no mga found (or no PCI BIOS found).
|                       
-----------------------------------------------------------------------------*/
dword pciFindNextMGA_1()
{

    dword address = 0;

    if ( nextDevice() )
    {
        setAthenaRevision_1();
        address = getConfigData( 0x10 );
    }
    else
        address = (dword)-1;

    return address;
}

#endif  /* #ifdef WINDOWS_NT */

/*----------------------------------------------------------------------------
|          name: pciBiosCall
|
|   description: call PCI BIOS function. The parameters is passed by register.
|                reel mode      
|                16 bit protected mode: The call is make via int 1aH
|                                
|                                
|                32 protected mode: The protected mode PCI BIOS is accessed by
|                                   calling through a protected mode entry point   
|                                   in the PCI BIOS. The entry point and information 
|                                   needed for building segment descriptors are provided
|                                   by teh BIOS32 Service Directory.
|                                   see PCI BIOS SPECIFICATION rev 2.0 section 3.3.
|
|                                 
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: union _REGS *r_in   register need for the PCI Bus Specific Operation 
|                                  (AH must forced PCI_FUNCTION_ID (B1h))
|
|      modifies: *r_out is modified to reflect the register state after the BIOS Call.
|         calls: int 1ah
|
|       returns: bool
|                       mtxOK   int 1ah succes 
|                       mtxFAIL int 1ah failed (see register for more information)
|                       
|         note1: This implementation is compiler dependant, a different way for
|                genarate interrupt may be use.
|
|         note2: For now, we use the reel mode int 1ah. 
|                The entry point and structure initialisation needed for use 
|                the BIOS32 Service Directory  we be implemented with the function
|                pciBiosPresent.
|                ref. PCI BIOS SPECIFICATION rev 2.0 section 3.3.
-----------------------------------------------------------------------------*/
bool pciBiosCall( union _REGS *r )
{
#ifdef WINDOWS_NT
        return mtxFAIL;
#endif  /* #ifdef WINDOWS_NT */

}

/*----------------------------------------------------------------------------
|          name: pciBiosPresent
|
|   description: Check if the PCI BIOS is present in the system. This function
|                must be call before any call to PCI BIOS function. 
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: PciBiosInfo *info  information about the bios
|      modifies: *info  updated to bios found information
|         calls: 
|       returns: bool
|                       mtxOK   PCI bios found
|                       mtxFAIL otherwise
|
|          note: if the BIOS32 Service Directory is implemented, this function
|                must find the entry point and initialise all structure needed
|                for call to BIOS function.
|                ref. PCI BIOS SPECIFICATION rev 2.0 section 3.3.
-----------------------------------------------------------------------------*/
bool pciBiosPresent( PciBiosInfo *info)
{

#ifdef WINDOWS_NT
    // We're not using this for now.
    return mtxFAIL;
#endif  /* #ifdef WINDOWS_NT */
}

/*----------------------------------------------------------------------------
|          name: pciFindFirstMGA
|
|   description: Find the first MGA device in the system and return the base
|                address of the device in the system (a succesive call to the 
|                function pciFindNextMGA give the address of other mga device
|                in the system).
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: none
|      modifies: global variable MgaSel and pMgaBaseAddress
|                static variable currentIndex set to 1.
|         calls: pciBiosPresent, pciFindDevice, pciReadConfigDWord
|       returns: dword base address of the first mga found.
|                -1 if no mga found (or no PCI BIOS found).
|                       
-----------------------------------------------------------------------------*/
dword pciFindFirstMGA()
{

#ifdef WINDOWS_NT
    return (dword)-1;
#endif  /* #ifdef WINDOWS_NT */
}

/*----------------------------------------------------------------------------
|          name: pciFindNextMGA
|
|   description: Find the next MGA device in the system and return the base
|                address of the device the function pciFindFirstMGA must me call
|                before call to this function. This function search a mga device 
|                a currentIndex and increment the current index by 1. A call to
|                pciFindFirstMGA set the currentIndex to 1.
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: none
|      modifies: global variable MgaSel and pMgaBaseAddress
|                static variable currentIndex is incremented by 1.
|         calls: pciBiosPresent, pciFindDevice, pciReadConfigDWord
|       returns: dword base address of the first mga found.
|                -1 if no mga found (or no PCI BIOS found).
|                       
-----------------------------------------------------------------------------*/
dword pciFindNextMGA()
{
#ifdef WINDOWS_NT
    return (dword)-1;
#endif  /* #ifdef WINDOWS_NT */
}


#ifdef WINDOWS_NT

PUCHAR pciBiosCallAddr()
{
    return((PUCHAR)NULL);
}

#endif  /* #ifdef WINDOWS_NT */

#endif  /* #if (!defined(WINDOWS_NT) || defined(MGA_WINNT31) || (!USE_VP_GET_ACCESS_RANGES)) */

#if (USE_VP_GET_ACCESS_RANGES)
    extern  PVOID   pMgaDeviceExtension;
    extern  ULONG   PciSlot;
#endif

#if 0

/*----------------------------------------------------------------------------
|          name: setPciOptionReg
|
|   description: set the option register of all mga to 1
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: none
|      modifies: 
|         calls: pciBiosPresent, pciFindDevice, pciReadConfigDWord
|       returns: void
|                       
-----------------------------------------------------------------------------*/
void setPciOptionReg()
{
#if (USE_VP_GET_ACCESS_RANGES)
    UCHAR   ConfigBuf = 0x01;
    ULONG   ConfigOffset = 0x40;
    ULONG   ConfigLength = 0x01;

    VideoPortSetBusData(pMgaDeviceExtension,    //PVOID HwDeviceExtension,
                        PCIConfiguration,       //IN BUS_DATA_TYPE BusDataType,
                        PciSlot,                //IN ULONG SlotNumber,
                        &ConfigBuf,             //IN PVOID Buffer,
                        ConfigOffset,           //IN ULONG Offset,
                        ConfigLength);          //IN ULONG Length

#else   /* #if (USE_VP_GET_ACCESS_RANGES) */

    byte    i;

    // Use mechanism #1 also!!!

    // Get access to ports before trying to map I/O configuration space.
    if ((pMgaPciIo = VideoPortGetDeviceBase(pMgaDeviceExtension,
                               MgaPciCseAccessRange.RangeStart,
                               MgaPciCseAccessRange.RangeLength,
                               MgaPciCseAccessRange.RangeInIoSpace)) != NULL)
    {
        // Map I/O Configuration Space.
        outp(pMgaPciIo+PCI_CSE-PCI_CSE, 0x80);
        outp(pMgaPciIo+PCI_FORWARD-PCI_CSE, 0x00);

        for (i = 0; i < NbBoard; i++)
        {
            if (Hw[i].ConfigSpace != 0)
            {
                MgaPciConfigAccessRange.RangeStart.LowPart = (ULONG)Hw[i].ConfigSpace;
                if ((pMgaPciConfigSpace = VideoPortGetDeviceBase(pMgaDeviceExtension,
                            MgaPciConfigAccessRange.RangeStart,
                            MgaPciConfigAccessRange.RangeLength,
                            MgaPciConfigAccessRange.RangeInIoSpace)) != NULL)
            {
                outp(pMgaPciConfigSpace + 0x40, 0x01);
                VideoPortFreeDeviceBase(pMgaDeviceExtension,pMgaPciConfigSpace);
            }
        }
        outp(pMgaPciIo+PCI_CSE-PCI_CSE, 0x00);
        VideoPortFreeDeviceBase(pMgaDeviceExtension,pMgaPciIo);
    }

#endif  /* #if (USE_VP_GET_ACCESS_RANGES) */

}

#endif  //#if 0

#if (!defined(WINDOWS_NT) || defined(MGA_WINNT31) || (!USE_VP_GET_ACCESS_RANGES))

/*----------------------------------------------------------------------------
|          name: pciFindFirstMGA_2
|
|   description: Find the first MGA device in the system and return the base
|                address of the device in the system (a succesive call to the 
|                function pciFindNextMGA give the address of other mga device
|                in the system).
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: none
|      modifies: global variable MgaSel and pMgaBaseAddress
|                static variable currentIndex set to 1.
|         calls: pciBiosPresent, pciFindDevice, pciReadConfigDWord
|       returns: dword base address of the first mga found.
|                -1 if no mga found (or no PCI BIOS found).
|                       
-----------------------------------------------------------------------------*/
dword pciFindFirstMGA_2()
{
    dword address;

    configSpace = 0x0000;
    address = pciFindFirstMGA_1();
    if (address == (dword)-1 )
    {
        configSpace = 0xc000;
        return pciFindNextMGA_2();
    }
    else
    {
        return address;
    }
}

/*----------------------------------------------------------------------------
|          name: pciFindNextMGA_2
|
|   description: Find the next MGA device in the system and return the base
|                address of the device the function pciFindFirstMGA must me call
|                before call to this function. This function search a mga device 
|                a currentIndex and increment the current index by 1. A call to
|                pciFindFirstMGA set the currentIndex to 1.
|
|      designed: Christian Toutant, august 26, 1993
| last modified: 
|
| 
|    parameters: none
|      modifies: global variable MgaSel and pMgaBaseAddress
|                static variable currentIndex is incremented by 1.
|         calls: pciBiosPresent, pciFindDevice, pciReadConfigDWord
|       returns: dword base address of the first mga found.
|                -1 if no mga found (or no PCI BIOS found).
|                       
-----------------------------------------------------------------------------*/
dword pciFindNextMGA_2()
{
    byte  command, subClass;
    dword address = 0;

    /* Map I/O Configuration Space */
    address = pciFindNextMGA_1();
    if (address != (dword)-1 )
        return address;

    // Restore this before going on, or you'll be sorry!
    address = 0;
    outp(pMgaPciIo+PCI_CSE-PCI_CSE, 0x80);

    while (!address)
    {
        if (configSpace > 0xcf00)
        {
            address = (dword)-1;
            outp(pMgaPciIo+PCI_CSE-PCI_CSE, 0x00);
        }
        else
        {
            // Get access to the current I/O space.
            MgaPciConfigAccessRange.RangeStart.LowPart = (ULONG)configSpace;
            if (VideoPortVerifyAccessRanges(pMgaDeviceExtension,
                                  1,
                                  &MgaPciConfigAccessRange) == NO_ERROR &&
                (pMgaPciConfigSpace = VideoPortGetDeviceBase(pMgaDeviceExtension,
                            MgaPciConfigAccessRange.RangeStart,
                            MgaPciConfigAccessRange.RangeLength,
                            MgaPciConfigAccessRange.RangeInIoSpace)) != NULL)
            {
                if ((
                     (inp(pMgaPciConfigSpace    ) == 0x2b) &&
                     (inp(pMgaPciConfigSpace + 1) == 0x10) &&
                     (inp(pMgaPciConfigSpace + 2) == 0x18) &&
                     (inp(pMgaPciConfigSpace + 3) == 0x05)
                    ) ||
                    (
                     (inp(pMgaPciConfigSpace    ) == 0x2b) &&
                     (inp(pMgaPciConfigSpace + 1) == 0x10) &&
                     (inp(pMgaPciConfigSpace + 2) == 0x10) &&
                     (inp(pMgaPciConfigSpace + 3) == 0x0D)
                    )
                   )
                {
                    address  = (dword)inp(pMgaPciConfigSpace + 0x13) << 24;
                    address |= (dword)inp(pMgaPciConfigSpace + 0x12) << 16;
                    address |= (dword)inp(pMgaPciConfigSpace + 0x11) <<  8;
                    address |= (dword)(inp(pMgaPciConfigSpace + 0x10) & 0x0c);
                    command  = inp(pMgaPciConfigSpace + PCI_COMMAND);
                    subClass = inp(pMgaPciConfigSpace + PCI_CLASS_CODE + 1);

/*---      Detect ATHENA revision < 2     
   If MGA board is in VGA mode and the snooping test fail, set
   ATHENA rev 1 flag
---*/
                    /* Test if we are in vga mode & snooping disabled*/
                    if ( !subClass && !(command & PCI_SNOOPING) )
                    {
                        /* assume athena rev > 1 */
                        pciBoardInfo &= ~(word)PCI_FLAG_ATHENA_REV1;

                        /* init location 64 at 0 */
                        VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
                        VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);

                        /* empty fifo */
                        VideoPortReadPortUchar(TITAN_PEL_ADDR_RD);

                        /* active snooping */
                        outp(pMgaPciConfigSpace + PCI_COMMAND,
                                            (byte)(command | PCI_SNOOPING));

                        /* write to DAC in snooping mode */
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)0x11);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)0x22);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)0x33);

                        /* restore snooping */
                        outp(pMgaPciConfigSpace + PCI_COMMAND, (byte)command);

                        /* now if the acces fail, we assume athena rev 1 */
                        VideoPortWritePortUchar(TITAN_PEL_ADDR_RD, (UCHAR)64);
                        if (
                            (VideoPortReadPortUchar(TITAN_PEL_DATA) != 0x11) ||
                            (VideoPortReadPortUchar(TITAN_PEL_DATA) != 0x22) ||
                            (VideoPortReadPortUchar(TITAN_PEL_DATA) != 0x33)
                           ) pciBoardInfo |= PCI_FLAG_ATHENA_REV1;

                        /* init location 64 at 0 */
                        VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
                        VideoPortWritePortUchar(TITAN_PEL_DATA, (UCHAR)00);
                        VideoPortWritePortUchar(TITAN_PEL_ADDR_WR, (UCHAR)64);  /* reinit write addr */
                  }

             
/*---- END Detect ATHENA revision < 2     */


                    /* If MGA board is in VGA mode and the MEM/IO space is not 
                        enabled, enable it.
                    */
                    if (!subClass && !(command & 0x03))
                    {
                       outp(pMgaPciConfigSpace + PCI_COMMAND,
                                                         (byte)(command | 2));
                       if ((pMgaBaseAddr = setmgasel(MgaSel, address, 4)) != NULL)
                       {
                           mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CONFIG+1),
                                                                     command);
                           mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CONFIG+1),
                                                          command & ~(byte)4);
                           VideoPortFreeDeviceBase(pMgaDeviceExtension,pMgaBaseAddr);
                       }
                    }
                }
                VideoPortFreeDeviceBase(pMgaDeviceExtension,pMgaPciConfigSpace);
            }
        }
        configSpace += 0x100;
    }
    outp(pMgaPciIo+PCI_CSE-PCI_CSE, 0x00);

    return address;
}


#endif  /* #if (!defined(WINDOWS_NT) || defined(MGA_WINNT31) || (!USE_VP_GET_ACCESS_RANGES)) */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxpci.h ===
/******* Constant *****************/

# define MGA_DEVICE_ID_ATL      0x0518
# define MGA_DEVICE_ID_ATH      0x0D10
# define MATROX_VENDOR_ID       0x102b

# define INTEL_DEVICE_ID        0x0486
# define INTEL_VENDOR_ID        0x8086


/* Error code */
# define    SUCCESFUL           0x00
# define    FUNC_NOT_SUPPORTED  0x81
# define    BAD_VENDOR_ID       0x83
# define    DEVICE_NOT_FOUND    0x86
# define    BAD_REGISTER_NUMBER 0x87

# define    NO_PCI_BIOS         0x01
# define    NO_PCI_DEVICE       0x02
# define    ERR_READ_REG        0x03

/* Configuration Space Header Register address */
# define PCI_DEVIDE_ID          0x02
# define PCI_VENDOR_ID          0x00
# define PCI_STATUS             0x06
# define PCI_COMMAND            0x04
# define PCI_CLASS_CODE         0x09
# define PCI_REVISION_ID        0x08
# define PCI_BIST               0x0f
# define PCI_HEADER_TYPE        0x0e
# define PCI_LATENCY_TIMER      0x0d
# define PCI_CACHE_LINE_SIZE    0x0c
# define PCI_BASE_ADDRESS       0x10
# define PCI_ROM_BASE           0x30
# define PCI_MAX_LAT            0x3f
# define PCI_MIN_GNT            0x3e
# define PCI_INTERRUPT_PIN      0x3d
# define PCI_INTERRUPT_LINE     0x3c

/* ClassCode */
# define CLASS_MASS_STORAGE     0x01
# define CLASS_NETWORK          0x02
# define CLASS_DISPLAY          0x03
# define CLASS_MULTIMEDIA       0x04
# define CLASS_MEMORY           0x05
# define CLASS_BRIDGE           0x06
# define CLASS_CUSTOM           0xff

/* SUBCLASS */
# define SCLASS_DISPLAY_VGA     0x00
# define SCLASS_DISPLAY_XGA     0x01
# define SCLASS_DISPLAY_OTHER   0x80

/* BIOS FUNCTION CALL */
# define PCI_INTERRUPT          0x1a
# define PCI_FUNCTION_ID        0xb1
# define PCI_BIOS_PRESENT       0x01
# define FIND_PCI_DEVICE        0x02
# define FIND_PCI_CLASS_CODE    0x03
# define GENERATE_SPECIAL_CYCLE 0x06
# define READ_CONFIG_BYTE       0x08
# define READ_CONFIG_WORD       0x09
# define READ_CONFIG_DWORD      0x0a
# define WRITE_CONFIG_BYTE      0x0b
# define WRITE_CONFIG_WORD      0x0c
# define WRITE_CONFIG_DWORD     0x0d


/* COMMAND register fields */
# define PCI_SNOOPING           0x20

# define PCI_FLAG_ATHENA_REV1   0x0001

# define PCI_BIOS_BASE          0x000e0000
# define PCI_BIOS_LENGTH        0x00020000
# define PCI_BIOS_SERVICE_ID    0x49435024  /* "$PCI" */

/* Mechanisme #2 interface */
# define PCI_CSE     0xcf8
# define PCI_FORWARD 0xcfa
# define MAGIC_ID_ATL    0x0518102b
# define MAGIC_ID_ATH    0x0D10102b

/******* Structure PCI *************/
typedef struct
    {
    word busNumber;
    union
        {
        byte val;
        struct {
            byte functionNumber:3;
            byte deviceNumber:5;
            } n; 
        } devFuncNumber;
    } PciDevice;

typedef struct
    {
    byte hwMecanisme;
    word version;
    byte lastPciBus;
    } PciBiosInfo;

/* Prototype */

extern bool pciBiosPresent( PciBiosInfo *biosInfo);
extern bool pciFindDevice(PciDevice *dev, word deviceId, word vendorId, word index);
extern bool pciFindClassCode(PciDevice *dev, dword classCode, word index);
extern bool pciBusOperation( PciDevice *dev, dword specData );
#if !( defined(OS2) || defined(__MICROSOFTC600__) )
extern bool pciReadConfigByte( PciDevice *dev, word pciRegister, byte *);
extern bool pciReadConfigWord( PciDevice *dev, word pciRegister, word *);
extern bool pciReadConfigDWord( PciDevice *dev, word pciRegister, dword *);
extern bool pciWriteConfigByte( PciDevice *dev, word pciRegister, byte);
extern bool pciWriteConfigWord( PciDevice *dev, word pciRegister, word);
extern bool pciWriteConfigDWord( PciDevice *dev, dword pciRegister, dword);
#endif
extern dword pciFindFirstMGA();
extern dword pciFindNextMGA();
extern dword pciFindFirstMGA_2();
extern dword pciFindNextMGA_2();
extern void  disPostedWFeature();

/* GLOBAL VARIABLE */
extern word   pciBoardInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxvga.h ===
#ifndef WINDOWS_NT
  #define   VGA_ATTRIB_ADDR     0x3c0
  #define   VGA_ATTRIB_WRITE    0x3c0
  #define   VGA_ATTRIB_READ     0x3c1
  #define   VGA_MISC            0x3c2
  #define   VGA_SEQ_ADDR        0x3c4
  #define   VGA_SEQ_DATA        0x3c5
  #define   VGA_FEAT            0x3da
  #define   VGA_GRAPHIC_ADDR    0x3ce
  #define   VGA_GRAPHIC_DATA    0x3cf
  #define   VGA_CRT_ADDR        0x3d4
  #define   VGA_CRT_DATA        0x3d5
  #define   VGA_AUX_ADDR        0x3de
  #define   VGA_AUX_DATA        0x3df
#else
  #define   VGA_ATTRIB_ADDR     (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c0 - 0x3c0))
  #define   VGA_ATTRIB_WRITE    (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c0 - 0x3c0))
  #define   VGA_ATTRIB_READ     (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c1 - 0x3c0))
  #define   VGA_MISC            (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c2 - 0x3c0))
  #define   VGA_SEQ_ADDR        (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c4 - 0x3c0))
  #define   VGA_SEQ_DATA        (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c5 - 0x3c0))
  #define   VGA_FEAT            (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3da - 0x3d4))
  #define   VGA_GRAPHIC_ADDR    (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3ce - 0x3c0))
  #define   VGA_GRAPHIC_DATA    (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3cf - 0x3c0))
  #define   VGA_CRT_ADDR        (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3d4 - 0x3d4))
  #define   VGA_CRT_DATA        (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3d5 - 0x3d4))
  #define   VGA_AUX_ADDR        (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[4]) + (0x3de - 0x3de))
  #define   VGA_AUX_DATA        (PVOID) ((ULONG)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[4]) + (0x3df - 0x3df))

  #define   ADDR_EQUIP_LO       (PUCHAR) ((((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[6]))
  #define   ADDR_CRT_MODE       (PUCHAR) ((((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[7]))
  #define   ADDR_MAX_ROW        (PUCHAR) ((((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[8]))
  #define   VGA_RAM             (PUCHAR) ((((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[10]))
  #define   VGA_MEM             (PUCHAR) ((((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[11]))
#endif

typedef struct
{
   byte featureCtl;           /* 0x3da */
   byte seqData[4];           /* 0x3c5 */
   byte mor;                  /* 0x3c2 */
   byte crtcData[0x19];       /* 0x3d4 */
   byte attrData[0x14];       /* 0x3c0 */
   byte graphicsCtl[9];       /* 0x3ce */
   byte auxilaryReg[15];      /* 0x3de */
   word crtcBasePort;
   byte latchData[4];
} VideoHardware;



typedef struct
{
   int  addrEquipementLow;
   byte EquipementLow;

   int  addrCRTMode;
   byte CRTMode[0x1e];

   int  addrMaxRow;
   byte MaxRow[7];

   int   addrSavePtr;
   byte SavePtr[4];
} VideoData;




extern void setupVgaHw(void);
extern void setupVgaData(void);
extern void loadFont16(void);
extern void setupVga(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxvga.c ===
/*/****************************************************************************
*          name: mtxvga.c
*
*   description: Routine for switching between VGA mode and TERMINATOR mode
*
*      designed: Christian Toutant
* last modified: $Author: nphung $, $Date: 94/01/04 05:11:34 $
*
*       version: $Id: mtxvga.c 2.0 94/01/04 05:11:34 nphung Exp $
*
*    parameters: -
*      modifies: -
*         calls: -
*       returns: -
******************************************************************************/

#include "switches.h"

#if USE_SETUP_VGA

#ifndef WINDOWS_NT
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <conio.h>
#include <os2.h>
#endif

#include "bind.h"
#include "sxci.h"
#include "defbind.h"
#include "def.h"
#include "mga.h"
#include "mgai_c.h"
#include "mgai.h"

#include "mtxvga.h"
#include "mtxfont.h"

#ifdef WINDOWS_NT

#include "mga_nt.h"

PUCHAR   address;             // where to store the return value of setmgasel

#else   /* #ifdef WINDOWS_NT */

/*MTX* added by mp on thursday, 5/20/93 */
extern  volatile byte far *setmgasel(dword MgaSel, dword phyadr, word limit);
extern dword getmgasel(void);

/*MTX* added by mp on friday, 5/21/93 */
extern   ULONG current_phys_address;
extern   USHORT   current_num_pages;
/*END*/

dword vgasel;              // selector to use in setmgasel
volatile byte far *address;   // where to store the return value of setmgasel
/*END*/

#endif   /* #ifdef WINDOWS_NT */

/*----------------------- Load Font -----------------------------------*/
extern byte CharSet14[];
extern byte CharSet16[];



byte OpenFont[] =
   { 0x02, 0x04, 0x04, 0x07, 0x04, 0x02,
     0x05, 0x00, 0x06, 0x04
   };
byte CloseFont[] =
   { 0x02, 0x03, 0x04, 0x03, 0x04, 0x00,
     0x05, 0x10, 0x06, 0x0e, 0x06, 0x0a
   };

void OCFont(byte *d)
{
   _outp(VGA_SEQ_ADDR, d[0] );
   _outp(VGA_SEQ_DATA, d[1] );
   _outp(VGA_SEQ_ADDR, d[2] );
   _outp(VGA_SEQ_DATA, d[3] );
   _outp(VGA_GRAPHIC_ADDR, d[4] );
   _outp(VGA_GRAPHIC_DATA, d[5] );
   _outp(VGA_GRAPHIC_ADDR, d[6] );
   _outp(VGA_GRAPHIC_DATA, d[7] );
   _outp(VGA_GRAPHIC_ADDR, d[8] );
   _outp(VGA_GRAPHIC_DATA, d[9] );
}

void loadFont16(void)
{
#ifndef WINDOWS_NT

#ifndef OS2
   struct overlay{int off; short seg;};
#endif
   
   int i, j;

#ifndef OS2
   volatile char _Far *vgaRam;
   ((struct overlay *)&vgaRam) -> seg = 0x60;
   ((struct overlay *)&vgaRam) -> off = 0xa0000;
#else
   vgasel = getmgasel();
   address = setmgasel(vgasel, (ULONG)0xA0000, 16);
#endif

   OCFont(OpenFont);
   for (i = 0; i < 256; i++)
       for (j = 0; j < 16; j++)
#ifndef OS2
          vgaRam[i * 32 + j] = CharSet16[i * 16 + j];
#else
         *((volatile unsigned char far *)(address + i * 32 + j)) = 
            CharSet16[i * 16 + j];
#endif

   OCFont(CloseFont);

#else /* #ifndef WINDOWS_NT */

   int i, j;
   address = VGA_RAM;

   OCFont(OpenFont);
   for (i = 0; i < 256; i++)
       for (j = 0; j < 16; j++)
         mgaWriteBYTE((*((PUCHAR)(address + i*32 + j))),CharSet16[i*16 + j]);

   OCFont(CloseFont);

#endif   /* #ifndef WINDOWS_NT */
}

/*----------------------- fin Load Font -----------------------------------*/


void clearVgaMem()
{
#ifndef WINDOWS_NT

#ifndef OS2
   struct overlay{int off; short seg;};
#endif
   word i;

#ifndef OS2
   volatile char _Far *vgaRam;
   ((struct overlay *)&vgaRam) -> seg = 0x60;
   ((struct overlay *)&vgaRam) -> off = 0xb8000;
#else
   vgasel = getmgasel();
   address = setmgasel(vgasel, (ULONG)0xB8000, 8);
#endif
   for (i = 0; i < (word)8000; i += 2)
      {
#ifndef OS2
      vgaRam[i]   = ' ';
      vgaRam[i+1] = 0x07;
#else
      *((volatile unsigned char far *)(address + i)) = ' ';

      *((volatile unsigned char far *)(address + i + 1)) = 0x07;
#endif
      }

#else    /* #ifndef WINDOWS_NT */

   word i;

   address = VGA_MEM;
   for (i = 0; i < (word)8000; i += 2)
   {
      mgaWriteBYTE((*((PUCHAR)(address + i))),' ');
      mgaWriteBYTE((*((PUCHAR)(address + i + 1))),0x07);
   }

#endif   /* #ifndef WINDOWS_NT */
}

/*----------------------- fin Load Font -----------------------------------*/

/*----------------------- SETUP VGA -----------------------------------*/
VideoHardware videoHw =
    {
      0x00,    
      { 0x00, 0x03, 0x00, 0x02 },             /* Sequencer 01-04 */
      0x67,                                  /* Misc Output Register */
      {
         0x5F,0x4F,0x50,0x82,0x55,0x81,      /* Crtc 00-05 */
         0xBF,0x1F,0x00,0x4f,0x0d,0x0e,      /* Crtc 06-0b */
         0x00,0x00,0x07,0x80,0x9C,0x8E,      /* Crtc 0c-11 */
         0x8F,0x28,0x1F,0x96,0xB9,0xA3,      /* Crtc 12-17 */
         0xFF                                /* Crtc 18 */
      },
      {
         0x00,0x01,0x02,0x03,0x04,0x05,      /* Attributes Ctlr 00-05 */
         0x14,0x07,0x38,0x39,0x3a,0x3b,      /* Attributes Ctlr 06-0b */
         0x3c,0x3d,0x3e,0x3f,0x0c,0x00,      /* Attributes Ctlr 0c-11 */
         0x0F,0x08                           /* Attributes Ctlr 12-13 */
      },
      {
         0x00,0x00,0x00,0x00,0x00,0x10,      /* Graphics Ctlr 00-05 */
         0x0E,0x00,0xFF                      /* Graphics Ctlr 06-08 */
      },
      {
         0x40,0x00,0x00,0x00,0x00,0x00,      /* Auxiliary reg 00-05 */
         0x00,0xc0,0xa7,0x00,0x00,0x00,      /* Auxiliary reg 06-0b */
         0x80, 0x20, 0x00                    /* Auxiliary reg 0c-0e */
      },
      0x3d4,                           /* CRTC base port */
      { 0x07, 0x07, 0x03, 0x03 }          /* Latch Data */
   };

VideoData vidData =
{
   0x410, 0x20,
   0x449,
   {
     0x03, 0x50, 0x00, 0x00, 0x10, 0x00, 0x00,
     0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x07, 0x06, 0x00, 0xD4, 0x03, 0x29, 0x30
   },
   0x484,
   {  0x18, 0x10, 0x00, 0x70, 0xF9, 0x31, 0x0B },
   0x4a8,
   {  0xDC, 0x05, 0x5A, 0x02 }

};



void setupVgaHw(void)
{
#ifndef WINDOWS_NT

#ifndef OS2
   struct overlay{int off; short seg;};
#endif

   int i;

#ifndef OS2
   volatile char _Far *vgaRam;
   ((struct overlay *)&vgaRam) -> seg = 0x60;
   ((struct overlay *)&vgaRam) -> off = 0xa0000;
#else
   vgasel = getmgasel();
   address = setmgasel(vgasel, (ULONG)0xA0000, 16);
#endif

   _outp(VGA_GRAPHIC_ADDR, 05);                  /* Set write mode 0 */
   _outp(VGA_GRAPHIC_DATA, 00);

   _outp(VGA_GRAPHIC_ADDR, 06);                  /* Set map to A000h */
   _outp(VGA_GRAPHIC_DATA, 04);

   _outp(VGA_GRAPHIC_ADDR, 04);                  /* Setup memory mode */
   _outp(VGA_GRAPHIC_DATA, 07);

   _outp(VGA_GRAPHIC_ADDR, 02);                  /* Set map mask register  */

   _outp(VGA_GRAPHIC_DATA, 1);                   /* Setup plane 0 access   */

#ifndef OS2
   vgaRam[0xffff] = videoHw.latchData[0];       /* Get saved latch 0 data */
#else
   *((volatile unsigned char far *)(address + 0xFFFF)) = videoHw.latchData[0];
#endif
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 2);                   /* Setup plane 1 access   */

#ifndef OS2
   vgaRam[0xffff] = videoHw.latchData[1];       /* Get saved latch 1 data */
#else
   *((volatile unsigned char far *)(address + 0xFFFF)) = videoHw.latchData[1];
#endif
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 4);                   /* Setup plane 2 access   */

#ifndef OS2
   vgaRam[0xffff] = videoHw.latchData[2];       /* Get saved latch 0 data */
#else
   *((volatile unsigned char far *)(address + 0xFFFF)) = videoHw.latchData[2];
#endif
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 8);                   /* Setup plane 8 access   */

#ifndef OS2
   vgaRam[0xffff] = videoHw.latchData[3];       /* Get saved latch 0 data */
#else
   *((volatile unsigned char far *)(address + 0xFFFF)) = videoHw.latchData[3];
#endif
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 0x0f);                /* Setup plane 8 access   */

#ifndef OS2
   i = vgaRam[0xffff];
#else
   i = *((volatile unsigned char far *)(address + 0xFFFF));
#endif

/* ----------------------------------- Reset sequenceur ------------------------------------ */
   _outp(VGA_SEQ_ADDR, 00);
   _outp(VGA_SEQ_DATA, 01);
/* ------------------------------------------------------------------------------------------ */

/* -------------------------- Programmation du sequenceur ----------------------------------- */
   for(i = 0; i < 4; i++)
      {
      _outp(VGA_SEQ_ADDR, i + 1);
      _outp(VGA_SEQ_DATA, videoHw.seqData[i]);
      }

/* ------------------------------------------------------------------------------------------ */

/* -------------------------- Programmation du Misc output register ------------------------- */
      _outp(VGA_MISC, videoHw.mor);
/* ------------------------------------------------------------------------------------------ */

/* ----------------------------------- Start sequenceur ------------------------------------ */
   _outp(VGA_SEQ_ADDR, 00);
   _outp(VGA_SEQ_DATA, 03);
/* ------------------------------------------------------------------------------------------ */

/* ----------------------------------- Programmation du crtc  ------------------------------- */
   _outp(VGA_CRT_ADDR, 0x11);              /* Setup no protect bit */
   _outp(VGA_CRT_DATA, 0x00);
   for(i = 0; i < 25; i++)
      {
      _outp(VGA_CRT_ADDR, i);
      _outp(VGA_CRT_DATA, videoHw.crtcData[i]);
      }
/* ------------------------------------------------------------------------------------------ */

   i = _inp(VGA_FEAT);                 /* Clear attribute flip/flop */
   _outp(VGA_FEAT, 0);                 /* Zero feature control register */
/* ---------------- Programmation du attribute controler (reg 10h, 12h-13h ) ---------------- */
   _outp(VGA_ATTRIB_ADDR, 0x10);              /* Write attribute index 10h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x10]);

   _outp(VGA_ATTRIB_ADDR, 0x12);              /* Write attribute index 12h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x12]);
   _outp(VGA_ATTRIB_ADDR, 0x13);              /* Write attribute index 13h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x13]);

/* ------------------------------------------------------------------------------------------ */

/* --------------------------- Programmation du graphics controlers ------------------------- */
   for(i = 0; i < 9; i++)
      {
      _outp(VGA_GRAPHIC_ADDR, i);
      _outp(VGA_GRAPHIC_DATA, videoHw.graphicsCtl[i]);
      }
/* ------------------------------------------------------------------------------------------ */

/* ------------------ Programmation du graphics controlers ---------------- */
   for(i = 0; i < 15; i++)
      {
      _outp(VGA_AUX_ADDR, i);
      _outp(VGA_AUX_DATA, videoHw.auxilaryReg[i]);
      }
/* ------------------------------------------------------------------------------------------ */

/* ----------------- Programmation du auxiliary register ----------------- */
   for(i = 0; i < 15; i++)
      {
      _outp(VGA_AUX_ADDR, i);
      _outp(VGA_AUX_DATA, videoHw.auxilaryReg[i]);
      }
/* ------------------------------------------------------------------------------------------ */


   _outp(VGA_FEAT, videoHw.featureCtl);                  /* \restore feature control register */

/* -------------------- Programmation du attribute controler (0-0fh et 11h) ----------------- */
   for(i = 0; i < 16; i++)
      {
      _outp(VGA_ATTRIB_ADDR, i);
      _outp(VGA_ATTRIB_WRITE, videoHw.attrData[i]);
      }
   _outp(VGA_ATTRIB_ADDR, 0x11);              /* Write attribute index 11h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x11]);
/*       ------------------------------------------------------------------- */
   _outp(VGA_ATTRIB_ADDR, 0xff);              /* Write attribute index 11h */

#else   /* ifndef WINDOWS_NT */

   UCHAR    i;
   PUCHAR   pVgaRam;

   pVgaRam = VGA_RAM;

   _outp(VGA_GRAPHIC_ADDR, 05);                  /* Set write mode 0 */
   _outp(VGA_GRAPHIC_DATA, 00);

   _outp(VGA_GRAPHIC_ADDR, 06);                  /* Set map to A000h */
   _outp(VGA_GRAPHIC_DATA, 04);

   _outp(VGA_GRAPHIC_ADDR, 04);                  /* Setup memory mode */
   _outp(VGA_GRAPHIC_DATA, 07);

   _outp(VGA_GRAPHIC_ADDR, 02);                  /* Set map mask register  */

   _outp(VGA_GRAPHIC_DATA, 1);                   /* Setup plane 0 access   */

   mgaWriteBYTE((*(pVgaRam+0xFFFF)), videoHw.latchData[0]);
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 2);                   /* Setup plane 1 access   */

   mgaWriteBYTE((*(pVgaRam+0xFFFF)), videoHw.latchData[1]);
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 4);                   /* Setup plane 2 access   */

   mgaWriteBYTE((*(pVgaRam+0xFFFF)), videoHw.latchData[2]);
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 8);                   /* Setup plane 8 access   */

   mgaWriteBYTE((*(pVgaRam+0xFFFF)), videoHw.latchData[3]);
                                    /* and Write to Vram      */

   _outp(VGA_GRAPHIC_DATA, 0x0f);                /* Setup plane 8 access   */

   mgaReadBYTE((*(pVgaRam+0xFFFF)), i);

/* ----------------------------------- Reset sequenceur ------------------------------------ */
   _outp(VGA_SEQ_ADDR, 00);
   _outp(VGA_SEQ_DATA, 01);
/* ------------------------------------------------------------------------------------------ */

/* -------------------------- Programmation du sequenceur ----------------------------------- */
   for(i = 0; i < 4; i++)
      {
      _outp(VGA_SEQ_ADDR, (UCHAR)(i + 1));
      _outp(VGA_SEQ_DATA, videoHw.seqData[i]);
      }

/* ------------------------------------------------------------------------------------------ */

/* -------------------------- Programmation du Misc output register ------------------------- */
      _outp(VGA_MISC, videoHw.mor);
/* ------------------------------------------------------------------------------------------ */

/* ----------------------------------- Start sequenceur ------------------------------------ */
   _outp(VGA_SEQ_ADDR, 00);
   _outp(VGA_SEQ_DATA, 03);
/* ------------------------------------------------------------------------------------------ */

/* ----------------------------------- Programmation du crtc  ------------------------------- */
   _outp(VGA_CRT_ADDR, 0x11);              /* Setup no protect bit */
   _outp(VGA_CRT_DATA, 0x00);
   for(i = 0; i < 25; i++)
      {
      _outp(VGA_CRT_ADDR, i);
      _outp(VGA_CRT_DATA, videoHw.crtcData[i]);
      }
/* ------------------------------------------------------------------------------------------ */

   i = _inp(VGA_FEAT);                 /* Clear attribute flip/flop */
   _outp(VGA_FEAT, 0);                 /* Zero feature control register */
/* ---------------- Programmation du attribute controler (reg 10h, 12h-13h ) ---------------- */
   _outp(VGA_ATTRIB_ADDR, 0x10);              /* Write attribute index 10h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x10]);

   _outp(VGA_ATTRIB_ADDR, 0x12);              /* Write attribute index 12h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x12]);
   _outp(VGA_ATTRIB_ADDR, 0x13);              /* Write attribute index 13h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x13]);

/* ------------------------------------------------------------------------------------------ */

/* --------------------------- Programmation du graphics controlers ------------------------- */
   for(i = 0; i < 9; i++)
      {
      _outp(VGA_GRAPHIC_ADDR, i);
      _outp(VGA_GRAPHIC_DATA, videoHw.graphicsCtl[i]);
      }
/* ------------------------------------------------------------------------------------------ */

/* ------------------ Programmation du graphics controlers ---------------- */
   for(i = 0; i < 15; i++)
      {
      _outp(VGA_AUX_ADDR, i);
      _outp(VGA_AUX_DATA, videoHw.auxilaryReg[i]);
      }
/* ------------------------------------------------------------------------------------------ */

/* ----------------- Programmation du auxiliary register ----------------- */
   for(i = 0; i < 15; i++)
      {
      _outp(VGA_AUX_ADDR, i);
      _outp(VGA_AUX_DATA, videoHw.auxilaryReg[i]);
      }
/* ------------------------------------------------------------------------------------------ */


   _outp(VGA_FEAT, videoHw.featureCtl);                  /* \restore feature control register */

/* -------------------- Programmation du attribute controler (0-0fh et 11h) ----------------- */
   for(i = 0; i < 16; i++)
      {
      _outp(VGA_ATTRIB_ADDR, i);
      _outp(VGA_ATTRIB_WRITE, videoHw.attrData[i]);
      }
   _outp(VGA_ATTRIB_ADDR, 0x11);              /* Write attribute index 11h */
   _outp(VGA_ATTRIB_WRITE, videoHw.attrData[0x11]);
/*       ------------------------------------------------------------------- */
   _outp(VGA_ATTRIB_ADDR, 0xff);              /* Write attribute index 11h */

#endif  /* ifndef WINDOWS_NT */

}

/*----------------------- FIN SETUP VGA -----------------------------------*/
#ifndef WINDOWS_NT
#ifndef OS2
void cust_memcpy(byte _Far *dest,byte _Far *src, size_t n)
{
   int i;
   for(i = 0; i < n; i++) dest[i] = src[i];
}
#endif
#endif

void setupVgaData(void)
{
#ifndef WINDOWS_NT

#ifndef OS2
   struct overlay{int off; short seg;};

   byte _Far *vgaData;
   ((struct overlay *)&vgaData) -> seg = 0x60;

   ((struct overlay *)&vgaData) -> off = vidData.addrEquipementLow;

   *vgaData &= 0xcf;
   *vgaData |= vidData.EquipementLow;

   ((struct overlay *)&vgaData) -> off = vidData.addrCRTMode;
   cust_memcpy(vgaData,(byte _Far *)vidData.CRTMode, sizeof(vidData.CRTMode));

   ((struct overlay *)&vgaData) -> off = vidData.addrMaxRow;
   cust_memcpy(vgaData,(byte _Far *)vidData.MaxRow, sizeof(vidData.MaxRow));

#else
   byte vgaData;
   int i;
   
   vgasel = getmgasel();
   address = setmgasel(vgasel, (ULONG)vidData.addrEquipementLow, 1);
   vgaData = *((volatile unsigned char far *)(address));
   vgaData &= 0xCF;
   // I'm not sure if this has to be done sequentially, 
   // so i'll do it that way.
   *((volatile unsigned char far *)(address)) = vgaData;
   vgaData |= vidData.EquipementLow;
   *((volatile unsigned char far *)(address)) = vgaData;

   address = setmgasel(vgasel, (ULONG)vidData.addrCRTMode, 1);

   for(i = 0; i < (int)sizeof(vidData.CRTMode); i++)
      *((volatile unsigned char far *)(address + i)) = vidData.CRTMode[i];
   
   address = setmgasel(vgasel, (ULONG)vidData.addrMaxRow, 1);

   for(i = 0; i < (int)sizeof(vidData.MaxRow); i++)
      *((volatile unsigned char far *)(address + i)) = vidData.MaxRow[i];
#endif

/*
   ((struct overlay *)&vgaData) -> off = vidData.addrSavePtr;
   cust_memcpy(vgaData, vidData.SavePtr, sizeof(vidData.SavePtr));
*/

#else    /* #ifndef WINDOWS_NT   */

   byte vgaData;
   int i;
   
   address = ADDR_EQUIP_LO;
   mgaReadBYTE((*((PUCHAR)(address))),vgaData);
   vgaData &= 0xCF;
   // I'm not sure if this has to be done sequentially, 
   // so i'll do it that way.
   mgaWriteBYTE((*((PUCHAR)(address))),vgaData);
   vgaData |= vidData.EquipementLow;
   mgaWriteBYTE((*((PUCHAR)(address))),vgaData);

   address = ADDR_CRT_MODE;

   for(i = 0; i < (int)sizeof(vidData.CRTMode); i++)
       mgaWriteBYTE((*((PUCHAR)(address + i))),vidData.CRTMode[i]);
   
   address = ADDR_MAX_ROW;

   for(i = 0; i < (int)sizeof(vidData.MaxRow); i++)
      mgaWriteBYTE((*((PUCHAR)(address + i))),vidData.MaxRow[i]);

#endif   /* #ifndef WINDOWS_NT   */
}


/*----------------------- fin SETUP VGA -----------------------------------*/



void setupVga(void)
{
#ifndef WINDOWS_NT
/*MTX* added by mp on friday, 5/21/93 */
   ULONG original_phys_address = current_phys_address;
   USHORT   original_num_pages = current_num_pages;
/*END*/
#endif   /* #ifndef WINDOWS_NT */

   setupVgaHw();
   setupVgaData();
   loadFont16();
#ifndef WINDOWS_NT
   clearVgaMem();
#endif   /* #ifndef WINDOWS_NT */

#ifndef WINDOWS_NT
/*MTX* added by mp on friday, 5/21/93 */
   vgasel = getmgasel();
   setmgasel(vgasel, original_phys_address, original_num_pages);
/*END*/
#endif   /* #ifndef WINDOWS_NT */

}

#endif   /* #if USE_SETUP_VGA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxvpro.c ===
/*/****************************************************************************
*          name: mtxvpro.c
*
*   description: Routines to initialise VIDEO PRO board
*
*      designed: Christian Toutant
* last modified: 
*
*       version: 
*
*       bool InitVideoPro( bool );
*
******************************************************************************/

#if 0

#include "switches.h"

#ifdef WINDOWS_NT
    #if defined(ALLOC_PRAGMA)
//    #pragma alloc_text(PAGE,detectVideoBoard)
    #pragma alloc_text(PAGE,init_denc)
    #pragma alloc_text(PAGE,init_dac)
    #pragma alloc_text(PAGE,init_adc)
    #pragma alloc_text(PAGE,init_psg)
    #pragma alloc_text(PAGE,init_ctrl)
    #pragma alloc_text(PAGE,init_luts)
//    #pragma alloc_text(PAGE,en_encoder)
    #pragma alloc_text(PAGE,initVideoMode)
//    #pragma alloc_text(PAGE,initVideoPro)
    #endif

    //Not to be paged out:
    //  Hw
    //  pMgaBaseAddr
    //  iBoard
    //  mtxVideoMode
    //  pMgaDeviceExtension
    //#if defined(ALLOC_PRAGMA)
    //#pragma data_seg("PAGE")
    //#endif

#else   /* #ifdef WINDOWS_NT */

    #include <stdlib.h>
    #include <string.h>
    #include <stdio.h>
    #include <dos.h>
    #include <time.h>

#endif  /* #ifdef WINDOWS_NT */


#ifdef WINDOWS
   #include "windows.h"				  
#endif


#include "bind.h"
#include "defbind.h"
#include "def.h"
#include "mga.h"
#include "mgai_c.h"
#include "mgai.h"
#include "caddi.h"				  

#include "mtxvpro.h"
#include "ENC_REG.h"


#define TO_FLOAT(i)     ((dword)(i) * 10000)
#define TO_INT(f)       ((dword)(f) / 10000)

/*-------  Extern global variables */
extern HwData Hw[];
extern byte iBoard;

#ifndef WINDOWS_NT

    extern volatile byte _Far *pMgaBaseAddr;
    static word encBaseAddr;

#else   /* #ifndef WINDOWS_NT */

    #define inp     _inp
    #define outp    _outp

    extern  PUCHAR  pMgaBaseAddr;
    extern  PVOID   pMgaDeviceExtension;
    extern  VIDEO_ACCESS_RANGE VideoProAccessRange;

    static  PUCHAR encBaseAddr;

#endif  /* #ifndef WINDOWS_NT */

static EncReg *ptrEncReg;
static dword gain = 10000;


#ifndef WINDOWS_NT

word detectVideoBoard()
{

   word videoProPorts[3] = {0x240, 0x300, 0x340};
   byte i;
   
   for (i = 0; i < 3; i++)
      if ( ( inp(videoProPorts[i]+2) & 0xe0 ) == 0x40 ) 
         return videoProPorts[i];

   return 0;
}

#else   /* #ifndef WINDOWS_NT */

PUCHAR detectVideoBoard()
{
    // If this call succeeds, pVideoProIo will be valid upon return.  The
    // calling function will have to execute a VideoPortFreeDeviceBase().

  #if 1
    return 0;
  #else
    ULONG videoProPorts[3] = {0x240, 0x300, 0x340};
    PUCHAR  pVideoProIo;
    byte  i;
   
    for (i = 0; i < 3; i++)
    {
        // Get access to ports before trying to map I/O configuration space.
        VideoProAccessRange.RangeStart.LowPart = (ULONG)videoProPorts[i];

        if (VideoPortVerifyAccessRanges(pMgaDeviceExtension,
                                        1,
                                        &VideoProAccessRange) == NO_ERROR &&
        (pVideoProIo = VideoPortGetDeviceBase(pMgaDeviceExtension,
                               VideoProAccessRange.RangeStart,
                               VideoProAccessRange.RangeLength,
                               VideoProAccessRange.RangeInIoSpace)) != NULL)
        {
            if ( (inp(pVideoProIo+2) & 0xe0) == 0x40 )
            {
                // pVideoProIo will be freed later by the calling routine.
                return pVideoProIo;
            }
            VideoPortFreeDeviceBase(pMgaDeviceExtension,pVideoProIo);
        }
    }
    return 0;
  #endif
}

#endif  /* #ifndef WINDOWS_NT */


void init_denc()
{
#ifndef WINDOWS_NT
   word indexPort, dataPort, i;
#else
   PUCHAR indexPort, dataPort;
   word   i;
#endif

   indexPort = encBaseAddr + DENC_ADDR_CTRL;
   dataPort  = encBaseAddr + DENC_DATA_CTRL;

   outp (indexPort, 0);        /* Point to the first index */
   for (i = 0; i < DENC_NBRE_REG; i++)
      outp (dataPort, ptrEncReg->dencReg[i]);
}

void init_dac()
{
   byte offset;

   for (offset = 0; offset < DAC_NBRE_REG-1; offset++)
      outp ((encBaseAddr + DAC_OFFSET + offset), ptrEncReg->dacReg[offset]);
}

void init_adc()
{
   word i;
   for (i = 0; i < ADC_NBRE_REG; i++)
      outp (encBaseAddr + ADC_OFFSET + i, ptrEncReg->adcReg[i]);
}

void init_psg(int dacAdjust )
{
#ifndef WINDOWS_NT
   word indexPort, dataPort, i;
#else
   PUCHAR indexPort, dataPort;
   word   i;
#endif

   indexPort = encBaseAddr + PSG_ADDR_CTRL;
   dataPort  = encBaseAddr + PSG_DATA_CTRL;

   for (i = 0; i < PSG_NBRE_REG - 3; i++)  /* 3 for 3 registers RO */
		{
      outpw (indexPort, i);        

#ifndef WINDOWS_NT
      if (i == 0x0a) /* Ajustement dependant du DAC */
         outpw (dataPort, ptrEncReg->psgReg[i] + dacAdjust);
      else
         outpw (dataPort, ptrEncReg->psgReg[i]);
#else
      if (i == 0x0a) /* Ajustement dependant du DAC */
         outpw ((PUSHORT)dataPort, (USHORT)(ptrEncReg->psgReg[i] + dacAdjust));
      else
         outpw ((PUSHORT)dataPort, (USHORT)(ptrEncReg->psgReg[i]));
#endif
      }
}

void init_ctrl()
{
   /* Enable filter */
#ifndef WINDOWS_NT
   outpw (encBaseAddr + ENC_CTRL_OFFSET, ptrEncReg->boardCtrlReg | ENC_FILTER);
#else
   outpw ((PUSHORT)(encBaseAddr + ENC_CTRL_OFFSET),
                            (USHORT)(ptrEncReg->boardCtrlReg | ENC_FILTER));
#endif
}

void init_luts()
{
#ifndef WINDOWS_NT
   word indexPort, dataPort;
#else
   PUCHAR indexPort, dataPort;
#endif
   byte colorTab[256][3];
   word i, j;
   dword tmp;

   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
         colorTab[i][j] = (byte)i;

   indexPort = encBaseAddr + DAC_LUT_CTRL_WR;
   dataPort  = encBaseAddr + DAC_LUT_DATA;

   outp (indexPort, 0);
   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
         {
         tmp = TO_INT((dword)colorTab[i][j] * gain);
         if (tmp > 0xff) tmp = 0xff;
         outp (dataPort, (byte)tmp);
         }

   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
         {

         tmp =  TO_INT( (((dword)colorTab[i][j] * (dword)220 * gain) / (dword)256)
                                  +  TO_FLOAT(16) + (TO_FLOAT(1) / 2)
                                 );

         if ( tmp > 0xeb )
            colorTab[i][j] = 0xeb;
         else
            colorTab[i][j] = (byte)tmp;
         }

//         colorTab[i][j] = (double)(colorTab[i][j]*220.0/256.0)
//                                    + 16.0 + 0.5;

   indexPort = encBaseAddr + DENC_CLUT_CTRL_WR;
   dataPort  = encBaseAddr + DENC_CLUT_DATA;

   outp (indexPort, 0);
   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
         outp (dataPort, colorTab[i][j]);

   inp (encBaseAddr + DENC_DATA_CTRL);     /* To activate the CLUT */
}



#ifndef WINDOWS_NT
void en_encoder (bool state,int encBaseAddr)
#else
void en_encoder (bool state,PUCHAR encBaseAddr)
#endif
{
#ifndef WINDOWS_NT
 word indexPort, dataPort;
#else
    PUCHAR indexPort, dataPort;
#endif

 byte colorTab[256][3];
 word i, j;
 if (state)
   init_luts(); 
 else
 {
   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
            colorTab[i][j] = 0;

   indexPort = encBaseAddr + 0x10 + 0x00;
   dataPort  = encBaseAddr + 0x10 + 0x01;

   outp (indexPort, 0);
   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
         outp (dataPort, colorTab[i][j]);

   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
         {
         colorTab[i][j] =  (byte)TO_INT((colorTab[i][j] * TO_FLOAT(220) / 256)
                                  +  TO_FLOAT(16) + (TO_FLOAT(1) / 2)
                                 );

// ((double)(colorTab[i][j]*220.0/256.0)+ 16.0 + 0.5) );
         }



   indexPort = encBaseAddr + 0x04 + 0x00;
   dataPort  = encBaseAddr + 0x04 + 0x01;

   outp (indexPort, 0);
   for (i = 0; i < 256; i++)
      for (j = 0; j < 3; j++)
         outp (dataPort, colorTab[i][j]);

#ifndef WINDOWS_NT
   inp (encBaseAddr + 0x04 + 0x03);     /* To activate the CLUT */
#else
        inp ((PUCHAR)(encBaseAddr + 0x04 + 0x03));  /* To activate the CLUT */
#endif
 }
}


bool initVideoMode(word mode, byte pwidth)
{
   int dacAdjust = 0;

   if ( !(encBaseAddr = detectVideoBoard()) ) 
      return mtxFAIL;

   gain = 10000;
   if ( (inp(encBaseAddr + 2) & 0x7) > 0 ) 
      {
      switch (mode)
         {
         case NTSC_STD: 
            ptrEncReg = &ntsca_1;
            gain = 14100;
            break;
         case PAL_STD:  
            ptrEncReg = &pala_1;  
            gain = 14100;
            break;
         case NTSC_STD | VAFC:
            ptrEncReg = &ntsc_1;
            break;

         case PAL_STD | VAFC:
            ptrEncReg = &pal_1;
            break;
         }
      if ( mode & VAFC )
         {
         switch( pwidth )
            {
            case  8:
               dacAdjust = 4;
               break;

            case 16:
               dacAdjust = 2;
               break;

            case 32:
               dacAdjust = 0;
               break;
            }
         }
      else
         {
	      switch(Hw[iBoard].DacType)
            {
		      case BT482:
		      case BT485: 
               switch( pwidth )
                  {
                  case  8:
                     dacAdjust = 0;
                     break;

                  case 16:
                  case 32:
                     dacAdjust = 1;
                     break;
                  }
               break;
            
		      case VIEWPOINT: 
               dacAdjust = 5;
               break;


            case TVP3026:   
               switch( pwidth )
                  {
                  case  8:
                     dacAdjust = 18;
                     break;

                  case 16:
                     dacAdjust = 22;
                     break;

                  case 32:
                     dacAdjust = 26;
                     break;
                  }
               break;
            }

         }

      }
   else
      switch (mode)
         {
         case NTSC_STD: 
            ptrEncReg = &ntsca_0;
            break;
         case PAL_STD:  
            ptrEncReg = &pala_0;  
            break;
         case NTSC_STD | VAFC: 
            switch (pwidth)
               {
               case  8: ptrEncReg = &ntsc8_0;  break;
               case 16: ptrEncReg = &ntsc16_0; break;
               case 32: ptrEncReg = &ntsc32_0; break;
               }
            break;
         case PAL_STD | VAFC: 
            switch (pwidth)
               {
               case  8: ptrEncReg = &pal8_0;  break;
               case 16: ptrEncReg = &pal16_0; break;
               case 32: ptrEncReg = &pal32_0; break;
               }
            break;
         }


   init_denc();
   init_dac();
   init_adc();
   init_psg( dacAdjust );
   init_ctrl();
   init_luts(); 

   return mtxOK;
}

/*
   mode OFF/NTSC/PAL
*/

bool initVideoPro(byte mode , word DacType)
{
   byte tmpByte;
#ifndef WINDOWS_NT
   word encBaseAddr;
#else
   PUCHAR encBaseAddr;
#endif

   if ( !(encBaseAddr = detectVideoBoard()) ) 
      return mtxFAIL;
   en_encoder(mode, encBaseAddr);

   mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CRT_CTRL),tmpByte);
   if (mode)
      tmpByte |= 0xc0;                 /* Set vertical and horizontal reset */
   else
      tmpByte &= 0x3f;                 /* Reset vertical and horizontal reset */
   mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CRT_CTRL),tmpByte);

#ifndef WINDOWS_NT
   if (mode)
      outpw(encBaseAddr, inpw(encBaseAddr) | 0x48);     /* set GENCLOCK_EN et VIDRST_EN */
   else
      outpw(encBaseAddr, inpw(encBaseAddr) & ~(0x48));/* reset GENCLOCK_EN et VIDRST_EN */
#else
   if (mode)
      outpw((PUSHORT)encBaseAddr, (USHORT)(inpw((PUSHORT)encBaseAddr) | 0x48));     /* set GENCLOCK_EN et VIDRST_EN */
   else
      outpw((PUSHORT)encBaseAddr, (USHORT)(inpw((PUSHORT)encBaseAddr) & ~(0x48)));  /* reset GENCLOCK_EN et VIDRST_EN */
#endif

   if (  (DacType == VIEWPOINT) && mode )
      {
      mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_R), tmpByte);
      tmpByte = tmpByte & 0xfb;   /* force bit 2 a 0 (clock) */
      mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_W), tmpByte);
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+VPOINT_INDEX), VPOINT_INPUT_CLK);
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+VPOINT_DATA), 0x01);
      }

   if (  (DacType == TVP3026) && mode )
      {
      mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_R), tmpByte);
      tmpByte = tmpByte & 0xfb;   /* force bit 2 a 0 (clock) */
      mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_W), tmpByte);
      /* remove use of double clock */
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+TVP3026_INDEX), TVP3026_CLK_SEL);
      mgaReadBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+TVP3026_DATA), tmpByte);
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+TVP3026_DATA), (tmpByte & 0xf0) | 1);
      }


   if (mode)
      {
      mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_R), tmpByte);
      tmpByte = tmpByte & 0xfb;   /* force bit 2 a 0 (clock) */
      mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_MISC_OUT_W), tmpByte);

      if (DacType == BT485)
         {
         mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT485_WADR_PAL), 1);
         mgaReadBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT485_CMD_REG0), tmpByte);
         mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT485_CMD_REG0), tmpByte | 0x80);
         mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT485_CMD_REG3), 0x00);
         mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + BT485_CMD_REG0), tmpByte);
         }
      }
   if (  (DacType == PX2085)  )
   {
      /* ASC:GCRE to 1 */
      mgaReadBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x18),tmpByte);
      if (mode)
         tmpByte |= 0x80;
      else
         tmpByte &= 0x7f;
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x18),tmpByte);


      /* GCR:BLK to 0100b */
      mgaReadBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x28),tmpByte);
      if (mode)
         tmpByte &= 0x07;
      else
         tmpByte &= 0x0f;
      tmpByte |= 0x40;
         mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x28),tmpByte);

      /* TEST:GT to 01 */
      mgaReadBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x1c),tmpByte);
      if (mode)
         tmpByte |= 0x80;
      else
         tmpByte &= 0x7f;
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x1c),tmpByte);


   /*---*/

      mgaReadBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x18),tmpByte);
      tmpByte &= 0x7f;
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x18),tmpByte);

      mgaReadBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x28),tmpByte);
      tmpByte &= 0x0f;
      mgaWriteBYTE(*(pMgaBaseAddr+RAMDAC_OFFSET+0x28),tmpByte);
   }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxvideo.c ===
/*/****************************************************************************
*          name: mtxvideo.c
*
*   description: Routine for switching between VGA mode and TERMINATOR mode
*
*      designed: Christian Toutant
* last modified: $Author: ctoutant $, $Date: 94/06/13 14:06:06 $
*
*       version: $Id: MTXVIDEO.C 1.50 94/06/13 14:06:06 ctoutant Exp $
*
*
* void mtxSetVideoMode (word mode)
* word mtxGetVideoMode (void)
*
******************************************************************************/

#include "switches.h"

#ifdef WINDOWS_NT
#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,testFifo)
    #pragma alloc_text(PAGE,mtxSetVLB)
    #pragma alloc_text(PAGE,mtxIsVLBBios)
    #pragma alloc_text(PAGE,compareDac)
    #pragma alloc_text(PAGE,mgaVL_AC00)
    #pragma alloc_text(PAGE,SetVgaDis)
    #pragma alloc_text(PAGE,mtxSetVideoMode)
    #pragma alloc_text(PAGE,mtxGetVideoMode)
//Not to be paged out:
    //#pragma alloc_text(PAGE,SetVgaEn)
    //#pragma alloc_text(PAGE,rdTitanReg)
    //#pragma alloc_text(PAGE,wrTitanReg)
    //#pragma alloc_text(PAGE,rdDacReg)
    //#pragma alloc_text(PAGE,wrDacReg)
    //#pragma alloc_text(PAGE,rdDubicDReg)
    //#pragma alloc_text(PAGE,wrDubicDReg)
    //#pragma alloc_text(PAGE,rdDubicIReg)
    //#pragma alloc_text(PAGE,wrDubicIReg)
    //#pragma alloc_text(PAGE,delay_us)
    //#pragma alloc_text(PAGE,mtxIsVLB)
    //#pragma alloc_text(PAGE,mtxMapVLBSpace)
    //#pragma alloc_text(PAGE,mtxUnMapVLBSpace)
    //#pragma alloc_text(PAGE,mtxCheckVgaEn)
    //#pragma alloc_text(PAGE,checkCursorEn)
    //#pragma alloc_text(PAGE,setVgaMode)
    //#pragma alloc_text(PAGE,restoreVga)
    //#pragma alloc_text(PAGE,blankEcran)
    //#pragma alloc_text(PAGE,isPciBus)
    //#pragma alloc_text(PAGE,isaToWide)
    //#pragma alloc_text(PAGE,wideToIsa)
#endif

//Not to be paged out:
//  isVLBFlag
//  cursorStat
//  saveBitOperation
//#if defined(ALLOC_PRAGMA)
    //#pragma data_seg("PAGE")
//#endif
#endif  /* #ifdef WINDOWS_NT */

#ifdef WINDOWS
   #include "windows.h"
#endif

#ifndef WINDOWS_NT
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <conio.h>
#include <time.h>
#endif

#include "bind.h"
#include "defbind.h"
#ifndef __DDK_SRC__
  #include "sxci.h"
#endif
#include "def.h"
#include "mga.h"
#include "mgai_c.h"
#include "mgai.h"

static byte ucCrtc0, ucCrtc1, ucCrtc6, ucCrtc11, ucGctl6, ucMisc, ucGctlIndx;

/* vgadac.h replaced with vgadac.c */
/* #include "vgadac.h" */
typedef struct {unsigned short r, g, b;} DacReg;
extern  DacReg vgaDac[];

#ifdef OS2
extern byte getVgaMode();
#endif /* OS2 */

long setTVP3026Freq ( volatile byte _Far *pDeviceParam, long fout, long reg, byte pWidth );


# define TEMP_BUF_S    0x4000


# define BIOS_VL        0xc0000
# define BIOS_ID_OFF    0x78

# define MOUSE_SRATE        18
# define LASER_SRATE        2
# define    SEQ_ADDR            0x3c4
# define    SEQ_DATA            0x3c5
# define    PEL_ADDR_WR     0x3c7
# define    PEL_ADDR_RD     0x3c8
# define PEL_DATA           0x3c9

# define SEQ_SYNCRST        0x01
# define SEQ_ASYNCRST   0x02
# define VGA_RESET_REG  0x00

# define  BOARD_MGA_VL   0x0a
# define  BOARD_MGA_VL_M 0x0e

# define  ROBITWREN_M    0xff000000L
# define  ROBITWREN_A    24
# define  SETROBITWREN  0x8d000000L
# define  CLRROBITWREN  0x00000000L

# define AllocVideoBuffer(x)    (dword *)malloc(x << 2)
# define FreeVideoBuffer(x) free(x)
# define MaxVideoBuffer(x)      findMaxVideoBuffer(x, 0)

// Need these to figure out where the VGA i/o port registers are mapped
#ifdef WINDOWS_NT

extern  PUCHAR  pMgaBiosVl;

typedef struct _MULTI_MODE
{
    ULONG   MulModeNumber;                // unique mode Id
    ULONG   MulWidth;                     // total width of mode
    ULONG   MulHeight;                    // total height of mode
    ULONG   MulPixWidth;                  // pixel depth of mode
    ULONG   MulRefreshRate;               // refresh rate of mode
    USHORT  MulArrayWidth;                // number of boards arrayed along X
    USHORT  MulArrayHeight;               // number of boards arrayed along Y
    UCHAR   MulBoardNb[NB_BOARD_MAX];     // board numbers of required boards
    USHORT  MulBoardMode[NB_BOARD_MAX];   // mode required from each board
    HwModeData *MulHwModes[NB_BOARD_MAX]; // pointers to required HwModeData
} MULTI_MODE, *PMULTI_MODE;


/*--------------------------------------------------------------------------*\
| HW_DEVICE_EXTENSION
|
| Define device extension structure. This is device dependant/private
| information.
|
\*--------------------------------------------------------------------------*/
typedef struct _MGA_DEVICE_EXTENSION {
    ULONG   SuperModeNumber;                // Current mode number
    ULONG   NumberOfSuperModes;             // Total number of modes
    PMULTI_MODE pSuperModes;                // Array of super-modes structures
                                            // For each board:
    ULONG   NumberOfModes[NB_BOARD_MAX];    // Number of available modes
    ULONG   NumberOfValidModes[NB_BOARD_MAX];
                                            // Number of valid modes
    ULONG   ModeFlags2D[NB_BOARD_MAX];      // 2D modes supported by each board
    ULONG   ModeFlags3D[NB_BOARD_MAX];      // 3D modes supported by each board
    USHORT  ModeFreqs[NB_BOARD_MAX][64];    // Refresh rates bit fields
    UCHAR   ModeList[NB_BOARD_MAX][64];     // Valid hardware modes list
    HwModeData *pMgaHwModes[NB_BOARD_MAX];  // Array of mode information structs.
    BOOLEAN bUsingInt10;                    // May need this later
    PVOID   KernelModeMappedBaseAddress[NB_BOARD_MAX];
                                            // Kern-mode virt addr base of MGA regs
    PVOID   UserModeMappedBaseAddress[NB_BOARD_MAX];
                                            // User-mode virt addr base of MGA regs
    PVOID   MappedAddress[];                // NUM_MGA_COMMON_ACCESS_RANGES elements
} MGA_DEVICE_EXTENSION, *PMGA_DEVICE_EXTENSION;

#define TITAN_SEQ_ADDR_PORT   (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c4 - 0x3c0))
#define TITAN_SEQ_DATA_PORT   (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3c5 - 0x3c0))
#define TITAN_GCTL_ADDR_PORT  (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3ce - 0x3c0))
#define TITAN_GCTL_DATA_PORT  (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[2]) + (0x3cf - 0x3c0))
#define TITAN_1_CRTC_ADDR_PORT (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3d4 - 0x3d4))
#define TITAN_1_CRTC_DATA_PORT (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[3]) + (0x3d5 - 0x3d4))
//#define ADDR_46E8_PORT        (PVOID) ((ULONG_PTR)(((PMGA_DEVICE_EXTENSION)pMgaDeviceExtension)->MappedAddress[5]) + (0x46e8 - 0x46e8))
#define ADDR_46E8_PORT        0x46e8
#endif


/* Debug */

/*--------------  Start of extern global variables -----------------------*/
extern dword MgaSel;
extern volatile byte _Far* pMgaBaseAddr;
extern HwData Hw[];
extern byte iBoard;
extern byte InitBuf[NB_BOARD_MAX][INITBUF_S];
extern byte VideoBuf[NB_BOARD_MAX][VIDEOBUF_S];
extern word mtxVideoMode;

#if 0
/*VIDEOPRO*/
extern bool VAFCconnector;
extern bool initVideoPro(byte mode, byte dactype);
#endif

extern void MGASysInit(byte *);
extern void MGAVidInit(byte *, byte *);
#ifdef OS2
  extern volatile byte _Far *setmgasel(dword MgaSel, dword phyadr, word limit);
#else
  extern volatile byte _Far *setmgasel(dword MgaSel, dword phyadr, dword limit);
#endif

/*---------------  end of extern global variables ------------------------*/

#ifdef WINDOWS
    extern dword ValMSec;
#endif

/*----------------------start of local Variables ---------------------------*/
/* Dac VGA */


static PixMap cursorStat = {0,0,0,0x102,0};
byte   saveBitOperation = 0;
bool isVLBFlag = 0;		/* OS2 needs this variable Global */



/*---------------------- End of Local variables ----------------------------*/

/*
static void testFifo(word count)
{
    word FifoCount;

    FifoCount = 0;

   while (FifoCount < count)
    {
      FifoCount = 64;
      mgaReadBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_FIFOSTATUS), FifoCount);
      }
   }
*/

static dword rdTitanReg(word reg)
{
    dword dat;
    mgaReadDWORD(*(pMgaBaseAddr + TITAN_OFFSET + (reg)), dat);
    return dat;
}


static void wrTitanReg(word reg, dword mask, dword donnee)
{
    dword tmp;
    if (mask != 0xffffffff)
        {
        mgaReadDWORD(*(pMgaBaseAddr + TITAN_OFFSET + (reg)), tmp);
        donnee = (tmp & ~mask) | donnee;
        }
    mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + (reg)), donnee);
}


static byte rdDacReg(word reg)
{
    byte dat;
    mgaReadBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + (reg)), dat);
    return dat;
}



static void wrDacReg(word reg, byte mask, byte donnee)
{
    byte tmp;
    if (mask != 0xff)
        {
        mgaReadBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + (reg)), tmp);
        donnee = (tmp & ~mask) | donnee;
        }
    mgaWriteBYTE(*(pMgaBaseAddr + (long)RAMDAC_OFFSET + (reg)), donnee);
}


static byte rdDubicDReg(word reg)
{
    byte tmp;
    mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + (reg)), tmp);
    return tmp;
}


static void wrDubicDReg(word reg, byte mask, byte donnee)
{
    byte tmp;
    if (mask != 0xff)
        {
        mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + (reg)), tmp);
        donnee = (tmp & ~mask) | donnee;
        }
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + (reg)), donnee);
}

static dword rdDubicIReg(word reg)
{
    dword tmp;
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), (byte)reg);

    mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[0]);
    mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[1]);
    mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[2]);
    mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[3]);

    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 8);
    return tmp;
}


void wrDubicIReg(word reg, dword mask, dword donnee)
{
    dword tmp;

    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), (byte)reg);

    if (mask != 0xffffffff)
        {
        mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[0]);
        mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[1]);
        mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[2]);
        mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), ((byte *)&tmp)[3]);
        donnee = (tmp & ~mask) | donnee;

        }

    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), (byte)reg);
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA),((byte *)&donnee)[0]);
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA),((byte *)&donnee)[1]);
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA),((byte *)&donnee)[2]);
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA),((byte *)&donnee)[3]);
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 8);
}


void delay_us(dword delai)   /* delai = number of microseconds */
{

#ifdef WINDOWS_NT
    VideoPortStallExecution(delai);
#else
  #ifdef OS2
     DosSleep((unsigned long)delai / 1000L);
  #else
     #ifdef WINDOWS
         {

         dword _Far *tick = MAKELP(0x40, 0x6c);
         unsigned long t;

         _asm{ pushf
               sti  }   /* enable the interrupt because of a hang bug */

         if(delai < 55000L)
            t = (delai * (ValMSec /100L)) / 550L;
         else
            t = (delai / 550L) * (ValMSec/100);

         /*** Wait a moment (based on the loop in mtxinit.c) ***/
         while(t && *tick)
            t --;

         _asm  popf
         }
     #else
         clock_t start;

         delai = delai / 1000;   /* Convert in millisecond */
         delai = delai / 55;     /* delai become now a number of tick */
         if(delai == 0)
            delai = 1;
         start = clock();
         while ((clock() - start) < delai);
     #endif
  #endif
#endif

}



/*----------------------- VLB Support -----------------------------------------*/
bool mtxSetVLB(dword sel)
{
        word i, c;
        char id[] = "_VB";
        volatile byte _Far* pMgaBiosAddr;

    isVLBFlag = mtxOK;

#ifdef WINDOWS_NT
    if ((pMgaBiosAddr = pMgaBiosVl) == NULL)
#else
    if ((pMgaBiosAddr = setmgasel(MgaSel, BIOS_VL, 4)) == NULL)
#endif
    {
      isVLBFlag = mtxFAIL;
    }
    else
    {
        for(i = 0; i <= strlen(id) ; i++)
          {
             mgaReadBYTE(*(pMgaBiosAddr + BIOS_ID_OFF + i), c);
             if (c != id[i])
                {
                isVLBFlag = mtxFAIL;
                break;
                }
          }
    }
    return isVLBFlag;
}


bool mtxIsVLBBios()
{
   return ( isVLBFlag );

}


bool mtxIsVLB ()
{
   dword val_id;

    if ( isVLBFlag  && Hw[iBoard].VGAEnable )
      return mtxOK;

   mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_REV),val_id);

   return  (isVLBFlag  && !( (val_id & (~TITAN_CHIPREV_M)) == TITAN_ID));
}


void mtxMapVLBSpace()
{
        if ( mtxIsVLB() )
                {
#ifndef WINDOWS_NT
                _outp(0x46e8, 0x00);
#else
                _outp(ADDR_46E8_PORT, 0x00);
#endif
                if (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
                        mgaWriteDWORD(*(pMgaBaseAddr + 0x2010), 0x000ac000);
                }
}

void mtxUnMapVLBSpace()
{
        if ( mtxIsVLB() )
                {
                if (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
                        mgaWriteDWORD(*(pMgaBaseAddr + 0x2010), 0x800ac000);
#ifndef WINDOWS_NT
                _outp(0x46e8, 0x08);
#else
                _outp(ADDR_46E8_PORT, 0x08);
#endif
                }
}

bool mtxCheckVgaEn()
{
        mtxMapVLBSpace();
        if (rdTitanReg(TITAN_CONFIG) & TITAN_VGAEN_M)
                {
                mtxUnMapVLBSpace();
                return mtxOK;
                }
        else
                return mtxFAIL;
}

static bool checkCursorEn()
{
    byte stat;
    stat = 0;
    switch(Hw[iBoard].DacType)
        {
        case BT482:
            /*-- Permits the access to Extented register */
            wrDacReg(BT482_WADR_PAL, 0xff, BT482_CUR_REG); /* points to Cursor register */
            stat = rdDacReg(BT482_PIX_RD_MSK) & BT482_CUR_MODE_M;
         break;

        case BT485:
        case PX2085:
            stat = rdDacReg(BT485_CMD_REG2) & BT485_CUR_MODE_M;
         break;

        case VIEWPOINT:
         wrDacReg(VPOINT_INDEX, 0xff, VPOINT_CUR_CTL);
         stat = rdDacReg(VPOINT_DATA) & 0x40;
         break;


        }
    return stat;
}




/*------------------------------------------------
* setVgaMode
*
* Call VGA bios for select video mode
*
*
* Return:   nothing
*------------------------------------------------*/
static void setVgaMode(word mode)
{

//[dlee] Modified for Windows NT - can't call _int86...
#ifdef WINDOWS_NT
#ifndef MGA_ALPHA

//    VIDEO_X86_BIOS_ARGUMENTS    BiosArguments;
//
//      BiosArguments.Eax = mode;
//      BiosArguments.Ebx = 0;
//      BiosArguments.Ecx = 0;
//      BiosArguments.Edx = 0;
//      BiosArguments.Esi = 0;
//      BiosArguments.Edi = 0;
//      BiosArguments.Ebp = 0;
//
//      VideoPortInt10(pMgaDeviceExtension, &BiosArguments);
//
#else   /* #ifndef MGA_ALPHA */
    #ifdef MGA_WINNT35
        // Try this for Alpha/3.5
        // setupVga();
    #endif
#endif  /* #ifndef MGA_ALPHA */

#else   /* #ifdef WINDOWS_NT */

  #ifdef OS2
    setupVga();
  #else
    union _REGS r;

    #ifdef __WATCOMC__
        r.w.ax = mode;
     #else
        r.x.ax = mode;
     #endif
     _int86(0x10, &r, &r);
  #endif

#endif  /* #ifdef WINDOWS_NT */

}

/*
static void compareDac()
{
    word i;
    wrDacReg(BT485_RADR_PAL,0xff,00);
    for(i = 0; i < 0x100; i ++)
        {
        DacVga[i][0] = rdDacReg(BT485_COL_PAL);
        DacVga[i][1] = rdDacReg(BT485_COL_PAL);
        DacVga[i][2] = rdDacReg(BT485_COL_PAL);
        }
    for(i = 0; i < 0x100; i ++)
        {
            if ( (DacVga[i][0] != vgaDac[i].r) ||
                  (DacVga[i][1] != vgaDac[i].g) ||
                  (DacVga[i][2] != vgaDac[i].b)
                )
                {
                    printf ("Erreur DAC index %02x Ecrit[%02x %02x %02x] Lue[%02x %02x %02x]\n",
                                i,
                                vgaDac[i].r,vgaDac[i].g,vgaDac[i].b,
                                DacVga[i][0],DacVga[i][1],DacVga[i][2]
                             );
                }

        }

}
*/


#ifdef WINDOWS_NT
void restoreVga()
#else
static void restoreVga()
#endif
{
    word i;
    wrDacReg(BT485_WADR_PAL,0xff,00);
        for(i = 0; i < 0x100; i ++)
            {
#ifdef WINDOWS_NT
            wrDacReg(BT485_COL_PAL, 0xff, (byte) vgaDac[i].r);
            wrDacReg(BT485_COL_PAL, 0xff, (byte) vgaDac[i].g);
            wrDacReg(BT485_COL_PAL, 0xff, (byte) vgaDac[i].b);
#else
            wrDacReg(BT485_COL_PAL, 0xff, (byte)vgaDac[i].r);
            wrDacReg(BT485_COL_PAL, 0xff, (byte)vgaDac[i].g);
            wrDacReg(BT485_COL_PAL, 0xff, (byte)vgaDac[i].b);
#endif
            }
}


/* Works only if board is in mode terminator */
static void blankEcran(bool b)
{
    byte TmpByte;

    if ( mtxCheckVgaEn() ) /* Acces IO (mode VGA) */
        {
        if (b) /* Blank the screen */
            {
#ifndef WINDOWS_NT
            _outp(TITAN_SEQ_ADDR, 0x01);
            TmpByte = _inp(TITAN_SEQ_DATA);
        TmpByte |= 0x20;        /* screen off */
            _outp(TITAN_SEQ_DATA, TmpByte);
#else
            _outp(TITAN_SEQ_ADDR_PORT, 0x01);
            TmpByte = _inp(TITAN_SEQ_DATA_PORT);
            TmpByte |= 0x20;        /* screen off */
            _outp(TITAN_SEQ_DATA_PORT, TmpByte);
#endif
            }
        else  /* Unblank the screen */
            {
#ifndef WINDOWS_NT
            _outp(TITAN_SEQ_ADDR, 0x01);
            TmpByte = _inp(TITAN_SEQ_DATA);
        TmpByte &= 0xdf;
            _outp(TITAN_SEQ_DATA, TmpByte);
#else
            _outp(TITAN_SEQ_ADDR_PORT, 0x01);
            TmpByte = _inp(TITAN_SEQ_DATA_PORT);
            TmpByte &= 0xdf;
            _outp(TITAN_SEQ_DATA_PORT, TmpByte);
#endif
            }

        }
    else /* Memory Access (mode terminator) */
        {

        if (b) /* Blank the screen */
            {
            mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_ADDR), 0x01);
        mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
        TmpByte |= 0x20;        /* screen off */
        mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
            }
        else  /* Unblank the screen */
            {
           mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_ADDR), 0x01);
        mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
        TmpByte &= 0xdf;        /* screen on */
           mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_SEQ_DATA), TmpByte);
            }
        }
}



/*------------------------------------------------
* mgaVL_AC00
*
* Check the BIOS id for VL BUS if we use the special mapping AC00
*
*
* Return:   1 if VL BUS at AC00
*------------------------------------------------*/
static int mgaVL_AC00()
{
   int i;
   char c;
   int retValue = 0;
   char id[] = "_VL";
   volatile byte _Far* pMgaBiosAddr;

   if (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
      {
    #ifdef WINDOWS_NT
      if ((pMgaBiosAddr = pMgaBiosVl) == NULL)
    #else
      if ((pMgaBiosAddr = setmgasel(MgaSel, BIOS_VL, 4)) == NULL)
    #endif
      {
          retValue = 0;
      }
      else
      {
         for(retValue = 1, i = 0; i < 3; i++)
            {
            mgaReadBYTE(*(pMgaBiosAddr + BIOS_ID_OFF + i), c);
            if (c != id[i])
               {
               retValue = 0;
               break;
               }
            }
//    #ifdef WINDOWS_NT
//         pMgaBaseAddr = Hw[iBoard].BaseAddress;
//    #else
//         if ((pMgaBaseAddr = setmgasel(MgaSel, MGA_ISA_BASE_1, 4)) == NULL)
//         {
//            retValue = 0;
//         }
//    #endif
      }

      }
   return retValue;
}


/*------------------------------------------------
* isPciBus
*
*
* Return: mtxOK if PCI bus
*------------------------------------------------*/
bool isPciBus()
{
   return ((Hw[iBoard].ProductRev >> 4 ) & 0x0f)         &&
          (rdTitanReg(TITAN_CONFIG) & (dword)TITAN_PCI_M);
}

/*------------------------------------------------
* isaToWide
*
* Go in wide bus and disable VGA
*
* Note : If we are at adresse AC00 use a special
*        sequence to disable VGA.
*
* Return:   nothing
*------------------------------------------------*/
static void isaToWide()
{
   mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_CLR);
    delay_us(2);

/* Special procedure for adresse AC00 */
   if (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
      {
       mgaWriteBYTE(*(pMgaBaseAddr  + TITAN_OFFSET + TITAN_TEST + 3),   0x8d);
       mgaWriteBYTE(*(pMgaBaseAddr  + TITAN_OFFSET + TITAN_CONFIG + 3), 0x01);
       mgaWriteBYTE(*(pMgaBaseAddr  + TITAN_OFFSET + TITAN_CONFIG), 0x00);
       mgaWriteBYTE(*(pMgaBaseAddr  + TITAN_OFFSET + TITAN_TEST +   3), 0x00);
      delay_us(1);

       mgaWriteBYTE(*(pMgaBaseAddr  + TITAN_OFFSET + TITAN_CONFIG + 1), 0x00);
       mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_CONFIG), 0x01000300);
      }
   else
      {
        wrTitanReg(TITAN_TEST, ROBITWREN_M, SETROBITWREN);
        wrTitanReg(TITAN_CONFIG,TITAN_ISA_M, TITAN_ISA_WIDE_BUS);
      delay_us(1);
        wrTitanReg(TITAN_TEST, ROBITWREN_M, CLRROBITWREN);

      wrTitanReg(TITAN_CONFIG, TITAN_VGAEN_M, 0);

      }
}


/*------------------------------------------------
* wideToIsa
*
* Go in ISA mode and enable VGA
*
* Note : If we are at adresse AC00 use a special
*        sequence to enable VGA.
*
* Return:   nothing
*------------------------------------------------*/
static void wideToIsa()
{
#if (defined (WINDOWS) || defined (OS2)|| defined(__MICROSOFTC600__))
   dword configAddr; /* Use only for windows */
#endif
   /* Remove Soft Reset */
   mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_CLR);
    delay_us(2);

   /* Unlock acces to ISA/WIDE field */
   mgaWriteBYTE(*(pMgaBaseAddr  + TITAN_OFFSET + TITAN_TEST + 3), 0x8d);

/* Note : For a VL card at base adress AC00, the acces to the CONFIG
          register must be 32 bits. For the make SXCIEXT.DLL, we use
          the microsoft 16bit C/C++ 7.0 compiler. Whit C/C++ 7.0,
          a 32 bits acces is broke in two 16 bits acces, we must use
          an inline assembler programme to make a 32 bit acces.
*/

#if(!defined(WINDOWS) && !defined(OS2))
        wrTitanReg(TITAN_CONFIG,TITAN_ISA_M | TITAN_VGAEN_M | TITAN_BIOSEN_M,
                 TITAN_ISA_ISA_BUS| TITAN_VGAEN_M | TITAN_BIOSEN_M);

#else
      if (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
         {
         configAddr = (dword)pMgaBaseAddr + TITAN_OFFSET  + TITAN_CONFIG;
#ifdef OS2
         _asm
#else
            __asm
#endif
             {
             push    es
             push    di
             les     di, [configAddr]

 ; mov eax, 11000700h
             _emit   066h
             _emit   0b8h
             _emit   000h
             _emit   007h
             _emit   000h
             _emit   011h

; stosd
             _emit   066h
             _emit   0abh

             pop     di
             pop     es
             }
         }

      else
           wrTitanReg(TITAN_CONFIG,TITAN_ISA_M | TITAN_VGAEN_M | TITAN_BIOSEN_M,
                    TITAN_ISA_ISA_BUS| TITAN_VGAEN_M | TITAN_BIOSEN_M);

#endif

   /* lock  acces to ISA/WIDE field */
   delay_us(1);
   mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET  + TITAN_TEST + 3), 0x00);
}

/*------------------------------------------------
* SetVgaEn
*
* Initialise all the MGA register for the VGA mode
*
*
* Return:   nothing
*------------------------------------------------*/

#ifdef WINDOWS_NT
void SetVgaEn()
#else
static void SetVgaEn()
#endif
{
    dword mask, donnee;
    byte reg, tmpByte;

    mtxMapVLBSpace();

   cursorStat.Width  = Hw[iBoard].cursorInfo.CurWidth;
    cursorStat.Height = (word)checkCursorEn();


/*--------------------------- Blank Screen ---------------------------------*/
    blankEcran(1);

#ifdef OS2

    if(Hw[iBoard].DacType == TVP3026)
        {
        mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_AUX_ADDR), AUX_INPUT_1);
        mgaReadBYTE( *(pMgaBaseAddr + TITAN_OFFSET + TITAN_AUX_DATA), tmpByte);
        vmode = getVgaMode();
        if ( (vmode < 4) || (vmode == 7) )
            {
            /* 28 Mhz */
            if (tmpByte & HI_REFRESH_M)
               setTVP3026Freq(pMgaBaseAddr, 40400, 2, 0);
            else
               setTVP3026Freq(pMgaBaseAddr, 28636, 2, 0);
            }
        else /* 25 Mhz */
            {
            if (tmpByte & HI_REFRESH_M)
               setTVP3026Freq(pMgaBaseAddr, 36000, 2, 0);
            else
               setTVP3026Freq(pMgaBaseAddr, 25057, 2, 0);
            }
        }
#endif


/*------------------------ Host vgaen inactif ------------------------------*/
/* to be sure that the VGA registers are accessible */

    wrTitanReg(TITAN_CONFIG, TITAN_VGAEN_M, 0);
   /* -- We select the VGA clock (else it could be to high for the
         VGA section
   */
    //mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_MISC_OUT_W), 0x67);
    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_MISC_OUT_W), ucMisc);

   /* reset extended crtc start  address */
   mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_AUX_ADDR), 0x0a);
    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_AUX_DATA), 0x80);
/*--------------------------------------------------------------------------*/



   /* Remove all synch */
   mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_ADDR), 0x11);
    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_DATA), 0x40);

    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_ADDR), 0x01);  /* -- Kill synch -- */
    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_DATA), 0x00);

    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_ADDR), 0x00);
    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_DATA), 0x00);

    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_ADDR), 0x06);
    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_1_CRTC_DATA), 0x00);

/*--------------------------------------------------------------------------*/


/*------ reset exterm hsync and vsync polarity (no inversion ------*/
if(Hw[iBoard].DacType == VIEWPOINT)
   {
    mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_GEN_CTL);
    mgaReadBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + VPOINT_DATA), tmpByte);
    /* Put hsync = negative, vsync = negative */
    tmpByte = tmpByte & 0xfc;
    mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_GEN_CTL);
    mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + VPOINT_DATA), tmpByte);
   }
else
   if(Hw[iBoard].DacType == TVP3026)
      {
      mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_GEN_CTL);
      mgaReadBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
      /* Put hsync = negative, vsync = negative */
      tmpByte = tmpByte & 0xfc;
      mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_GEN_CTL);
      mgaWriteBYTE(*(pMgaBaseAddr + RAMDAC_OFFSET + TVP3026_DATA), tmpByte);
      }
   else
      {
      mgaReadBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_CONFIG + 2), tmpByte);
      tmpByte |= 1; /* Expansion device available <16> of CONFIG */
      mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_CONFIG + 2), tmpByte);
      mgaWriteBYTE(*(pMgaBaseAddr + EXPDEV_OFFSET), 0 );
      }
/*--------------------------------------------------------------------------*/



/*--------------- Disable interrupt Genere By Dubic --------------------*/
   /* The index pointer of the DUBIC must have the value 8 before
      we acces the direct register
   */
   mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 8);

   /* We save the value of the DUBIC register 0 and we disable the mouse
      (or laser) interrupt
   */
    reg = rdDubicDReg(DUBIC_DUB_SEL);
    wrDubicDReg(DUBIC_DUB_SEL, 0xff, 0x40);
/*--------------------------------------------------------------------------*/



/*------------------------ Start programming of DUBIC --------------------*/
/* We don't touch to this DAC type */
    mask = ~(
               (dword)DUBIC_DACTYPE_M |
               (dword)DUBIC_LVID_M
           );

    if (rdDubicIReg(DUBIC_DUB_CTL2) & DUBIC_LASEREN_M)          /* SRATE */
        donnee = (dword)LASER_SRATE << DUBIC_SRATE_A;            /* LASER */
    else
        donnee = (dword)MOUSE_SRATE << DUBIC_SRATE_A ;           /* MOUSE */

    donnee |= (dword)DUBIC_BLANKDEL_M;
    wrDubicIReg(DUBIC_DUB_CTL, mask , donnee);
/*--------------------------------------------------------------------------*/






/*---------------------------- Place DAC in VGA mode -----------------------*/

switch(Hw[iBoard].DacType)
    {
        case BT482:
            wrDacReg(BT482_CMD_REGA, 0xff, 1);
            wrDacReg(BT482_WADR_PAL, 0xff,BT482_CMD_REGB);
            wrDacReg(BT482_PIX_RD_MSK, 0xff,0x00); /* command reg B = 00h */
            wrDacReg(BT482_WADR_PAL, 0xff,BT482_CUR_REG);
            wrDacReg(BT482_PIX_RD_MSK, 0xff,0x10); /* command reg Cur = 10h (interlace)*/
            wrDacReg(BT482_CMD_REGA, 0xff,0);
            break;

        case BT485:
        case PX2085:
          mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR),DUBIC_DUB_CTL2);
          mgaReadBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA), tmpByte);
          mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR),DUBIC_DUB_CTL2);
          mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_DATA),tmpByte | DUBIC_LDCLKEN_M);
          mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 8);

            wrDacReg(BT485_CMD_REG0,0xff, 0x80); /* access sequence cmd 3 */
            wrDacReg(BT485_WADR_PAL,0xff, 0x01);
            wrDacReg(BT485_CMD_REG1,0xff, 0);
            wrDacReg(BT485_CMD_REG2,0xff, 0);
            wrDacReg(BT485_CMD_REG3,0xff, 0);
            wrDacReg(BT485_CMD_REG0,0xff, 0x00); /* access sequence cmd 3 */
            break;

        case VIEWPOINT:
         /* Software reset to put the DAC in a default state */
         wrDacReg(VPOINT_INDEX,0xff, VPOINT_RESET);
         wrDacReg(VPOINT_DATA,0xff, 0x00 );

         wrDacReg(VPOINT_INDEX, 0xff, VPOINT_GEN_CTL);
         wrDacReg(VPOINT_DATA, 0xff, 00);

         /* Change DUBIC CTL2 */
          wrDubicIReg(DUBIC_DUB_CTL2, (dword)0x40 , 0);
            break;

        case TVP3026:
         /* Software reset to put the DAC in a default state */
         wrDacReg(TVP3026_INDEX,0xff, TVP3026_GEN_IO_CTL);
         wrDacReg(TVP3026_DATA,0xff, 0x01 );
         wrDacReg(TVP3026_INDEX,0xff, TVP3026_GEN_IO_DATA);
         wrDacReg(TVP3026_DATA,0xff, 0x01 );

         wrDacReg(TVP3026_INDEX,0xff, TVP3026_MISC_CTL);
         wrDacReg(TVP3026_DATA,0xff, 0x04 );

         wrDacReg(TVP3026_INDEX, 0xff, TVP3026_GEN_CTL);
         wrDacReg(TVP3026_DATA, 0xff, 00);

         wrDacReg(TVP3026_INDEX, 0xff, TVP3026_CLK_SEL);
         wrDacReg(TVP3026_DATA, 0xff, 00);

         wrDacReg(TVP3026_INDEX, 0xff, TVP3026_TRUE_COLOR_CTL);
         wrDacReg(TVP3026_DATA, 0xff, 0x80);


         wrDacReg(TVP3026_INDEX, 0xff, TVP3026_MUX_CTL);
         wrDacReg(TVP3026_DATA, 0xff, 0x98);

         wrDacReg(TVP3026_INDEX, 0xff, TVP3026_MCLK_CTL);
         wrDacReg(TVP3026_DATA, 0xff, 0x18);

         /* Change DUBIC CTL2 */
          wrDubicIReg(DUBIC_DUB_CTL2, (dword)0x40 , 0);
         break;

    }

/*--------------------------------------------------------------------------*/



  /* Softreset ON */
  mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_SET);
  delay_us(2);

/*-------------------------- Host vgaen actif ------------------------------*/
    if ( !isPciBus() && (Hw[iBoard].ProductType &  BOARD_MGA_VL_M) == BOARD_MGA_VL)
      wideToIsa(); /* This function put also the mga in VGA mode */
   else
      {
       wrTitanReg(TITAN_CONFIG, TITAN_VGAEN_M, TITAN_VGAEN_M);
      }
    wrDubicIReg(DUBIC_DUB_CTL, DUBIC_VGA_EN_M , DUBIC_VGA_EN_M);
/*--------------------------------------------------------------------------*/

/*---------------------------- SoftReset inactif ---------------------------*/
    mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_CLR);
    delay_us(2);
/*--------------------------------------------------------------------------*/

/*------------------------ Restore interrupt du DUBIC --------------------*/
    wrDubicDReg(DUBIC_DUB_SEL, 0xff, reg);
/*--------------------------------------------------------------------------*/


/*----------------- Special case where we use MGA_ISA_BASE_1 ---------------*/
    if (  !isPciBus()                                                  &&
          ((Hw[iBoard].ProductType &  BOARD_MGA_VL_M) != BOARD_MGA_VL) &&
            (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
        )
            {
            /* if vga boots vga 8 bit, force access 8 bit and enable bios */
            if ( (saveBitOperation & 3) == 0 )
                {
                mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), tmpByte);
                tmpByte &= ~(byte)TITAN_CONFIG_M;
                tmpByte |= TITAN_CONFIG_8;

                mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), tmpByte);
                wrTitanReg(TITAN_CONFIG, TITAN_BIOSEN_M, TITAN_BIOSEN_M);
                mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), tmpByte);
                }
            }

/*--------------------------------------------------------------------------*/

#ifndef WINDOWS_NT
      _outp(TITAN_SEQ_ADDR, 0x00);     /* -- Stop VGA sequenceur --- */
        _outp(TITAN_SEQ_DATA, 0x03);

        _outp(TITAN_GCTL_ADDR, 0x06);
        _outp(TITAN_GCTL_DATA, ucGctl6);

        _outp(TITAN_1_CRTC_ADDR, 0x11);  /* -- Unlock CRTC register -- */
        _outp(TITAN_1_CRTC_DATA, (byte)(ucCrtc11 & 0x7f));

        _outp(TITAN_1_CRTC_ADDR, 0x01);
        _outp(TITAN_1_CRTC_DATA, ucCrtc1);

        _outp(TITAN_1_CRTC_ADDR, 0x00);
        _outp(TITAN_1_CRTC_DATA, ucCrtc0);

        _outp(TITAN_1_CRTC_ADDR, 0x06);
        _outp(TITAN_1_CRTC_DATA, ucCrtc6);

        _outp(TITAN_1_CRTC_ADDR, 0x11);  /* -- Restore CRTC register -- */
        _outp(TITAN_1_CRTC_DATA, ucCrtc11);

//        _outp(TITAN_GCTL_ADDR, ucGctlIndx);
#else
      _outp(TITAN_SEQ_ADDR_PORT, 0x00);     /* -- Stop VGA sequenceur --- */
        _outp(TITAN_SEQ_DATA_PORT, 0x03);

        _outp(TITAN_GCTL_ADDR_PORT, 0x06);
        _outp(TITAN_GCTL_DATA_PORT, ucGctl6);

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x11);  /* -- Unlock CRTC register -- */
        _outp(TITAN_1_CRTC_DATA_PORT, (byte)(ucCrtc11 & 0x7f));

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x01);
        _outp(TITAN_1_CRTC_DATA_PORT, ucCrtc1);

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x00);
        _outp(TITAN_1_CRTC_DATA_PORT, ucCrtc0);

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x06);
        _outp(TITAN_1_CRTC_DATA_PORT, ucCrtc6);

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x11);  /* -- Restore CRTC register -- */
        _outp(TITAN_1_CRTC_DATA_PORT, ucCrtc11);

//        _outp(TITAN_GCTL_ADDR_PORT, ucGctlIndx);
#endif

/*-------------------------- Restore VGA mode ------------------------------*/
   mtxUnMapVLBSpace();
    setVgaMode(3);

#ifndef WINDOWS_NT
    restoreVga();   /* Dac */
#endif

/*--------------------------------------------------------------------------*/


/*--------------------------- UnBlank Screen ---------------------------------*/
    blankEcran(0);
/*--------------------------------------------------------------------------*/


    }



/*------------------------------------------------
* SetVgaDis
*
* Initialize all the MGA register for the TERMINATOR mode
*
*
* Return:   nothing
*------------------------------------------------*/
static void SetVgaDis()
{
    byte reg, tmpByte;
   int  vlBiosId = 0;

/*--------------------------- Blank Screen ---------------------------------*/
    blankEcran(1);
/*--------------------------------------------------------------------------*/

/*------------------ Save Vga and validate addresse Terminator ---------------*/
#ifndef WINDOWS_NT
//        ucGctlIndx = _inp(TITAN_GCTL_ADDR);

        _outp(TITAN_GCTL_ADDR, 0x06);
        ucGctl6 = _inp(TITAN_GCTL_DATA);
        _outp(TITAN_GCTL_DATA, 0x0c);       /* -- Memory map selecr 11 -- */

      _outp(TITAN_SEQ_ADDR, 0x00);     /* -- Stop VGA sequenceur --- */
        _outp(TITAN_SEQ_DATA, 0x01);

        _outp(TITAN_1_CRTC_ADDR, 0x11);  /* -- Unlock CRTC register -- */
        ucCrtc11 = _inp(TITAN_1_CRTC_DATA);
        _outp(TITAN_1_CRTC_DATA, (ucCrtc11 & 0x7f));

        _outp(TITAN_1_CRTC_ADDR, 0x01);  /* -- Kill synch -- */
        ucCrtc1 = _inp(TITAN_1_CRTC_DATA);
        _outp(TITAN_1_CRTC_DATA, 0x00);

        _outp(TITAN_1_CRTC_ADDR, 0x00);
        ucCrtc0 = _inp(TITAN_1_CRTC_DATA);
        _outp(TITAN_1_CRTC_DATA, 0x00);

        _outp(TITAN_1_CRTC_ADDR, 0x06);
        ucCrtc6 = _inp(TITAN_1_CRTC_DATA);
        _outp(TITAN_1_CRTC_DATA, 0x00);

#else
//        ucGctlIndx = _inp(TITAN_GCTL_ADDR_PORT);

        _outp(TITAN_GCTL_ADDR_PORT, 0x06);
        ucGctl6 = _inp(TITAN_GCTL_DATA_PORT);
        _outp(TITAN_GCTL_DATA_PORT, 0x0c);   /* -- Memory map selecr 11 --*/


      _outp(TITAN_SEQ_ADDR_PORT, 0x00);     /* -- Stop VGA sequenceur --- */
        _outp(TITAN_SEQ_DATA_PORT, 0x01);

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x11);  /* -- Unlock CRTC register -- */
        ucCrtc11 = _inp(TITAN_1_CRTC_DATA_PORT);
        _outp(TITAN_1_CRTC_DATA_PORT, (byte)(ucCrtc11 & 0x7f));

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x01);  /* -- Kill synch -- */
        ucCrtc1 = _inp(TITAN_1_CRTC_DATA_PORT);
        _outp(TITAN_1_CRTC_DATA_PORT, 0x00);

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x00);
        ucCrtc0 = _inp(TITAN_1_CRTC_DATA_PORT);
        _outp(TITAN_1_CRTC_DATA_PORT, 0x00);

        _outp(TITAN_1_CRTC_ADDR_PORT, 0x06);
        ucCrtc6 = _inp(TITAN_1_CRTC_DATA_PORT);
        _outp(TITAN_1_CRTC_DATA_PORT, 0x00);

#endif
      delay_us(8);                    /* time to complete stop sequenceur */

       mtxMapVLBSpace();
/*--------------------------------------------------------------------------*/

/*----------------- Special case where we use MGA_ISA_BASE_1 ---------------*/

    if (  !isPciBus()                                                 &&
          ((Hw[iBoard].ProductType &  BOARD_MGA_VL_M) != BOARD_MGA_VL) &&
            (Hw[iBoard].MapAddress == MGA_ISA_BASE_1)
        )
            {
         /* If this function is call from mtxCheckHwAll, the ProducType
            unknow at this moment, we have to see in the BIOS eprom
            to search for the VL ID
         */
         vlBiosId = mgaVL_AC00();

         /* if vga 8 bit, disable bios and force acces 16 bit */
        mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), saveBitOperation);
            if ( (saveBitOperation & 3) != 1 )
                {
                wrTitanReg(TITAN_CONFIG, TITAN_BIOSEN_M, 0);
                mgaReadBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), tmpByte);
                tmpByte &= ~(byte)TITAN_CONFIG_M;
                tmpByte |= TITAN_CONFIG_16;
                mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET + TITAN_CONFIG), tmpByte);
                }
            }

/*--------------------------------------------------------------------------*/


/*---------------------------- SoftReset actif -----------------------------*/
    mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_SET);
    delay_us(2);
/*--------------------------------------------------------------------------*/


/*------------------------ Host vgaen inactif ------------------------------*/

   if ( !isPciBus() &&
         (
         ((Hw[iBoard].ProductType &  BOARD_MGA_VL_M) == BOARD_MGA_VL ) ||
         vlBiosId
         )
      )
      {
      isaToWide();
        }
   else
      {
       mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_SET);
       delay_us(2);
      wrTitanReg(TITAN_CONFIG, TITAN_VGAEN_M, 0);
      }

    wrDubicIReg(DUBIC_DUB_CTL, DUBIC_VGA_EN_M , 0);
/*--------------------------------------------------------------------------*/


/*---------------------------- SoftReset inactif -----------------------------*/
    mgaWriteDWORD(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_RST), TITAN_SOFTRESET_CLR);
    delay_us(2);
/*--------------------------------------------------------------------------*/



/*--- vvvvv test seulement ----*/
    mgaReadBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_MISC_OUT_R), ucMisc);
    mgaWriteBYTE(*(pMgaBaseAddr + TITAN_OFFSET + TITAN_MISC_OUT_W), 0x27);
/*^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/


/*------------------------ Disable interrupt of DUBIC --------------------*/
    mgaWriteBYTE(*(pMgaBaseAddr + DUBIC_OFFSET + DUBIC_NDX_PTR), 8);
    reg = rdDubicDReg(DUBIC_DUB_SEL);
    wrDubicDReg(DUBIC_DUB_SEL, 0xff, 0x40);
/*--------------------------------------------------------------------------*/





/*------------------------ start programming of DUBIC --------------------*/
    wrDubicIReg(DUBIC_DUB_CTL, DUBIC_BLANKDEL_M | DUBIC_VGA_EN_M , 0);
/*--------------------------------------------------------------------------*/



/*------------------------ Restore interrupt of DUBIC --------------------*/
    wrDubicDReg(DUBIC_DUB_SEL, 0xff, reg);
/*--------------------------------------------------------------------------*/

}

/*------------------------------------------------
* mtxSetVideoMode
*
* Select Video mode (VGA/TERMINATOR)
*
*
* Return:   nothing
*------------------------------------------------*/
void mtxSetVideoMode (word mode)
{
    switch(mode)
        {
        case mtxPASSTHRU:
#if 0
         /*VIDEOPRO*/
         initVideoPro(0, Hw[iBoard].DacType);
#endif
            if (Hw[iBoard].VGAEnable && !mtxCheckVgaEn())
                    {
                    SetVgaEn();
                    mtxVideoMode = mtxPASSTHRU;
                    }
            break;

        case mtxADV_MODE:
            if (mtxCheckVgaEn())
                {
                mgaWriteBYTE(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_CONFIG+1), 0x07);
                SetVgaDis();
                wrDubicIReg(DUBIC_DUB_CTL,0,0);
                if (Hw[iBoard].pCurrentHwMode != 0)
                    {
                    MGASysInit(InitBuf[iBoard]);
                    if (Hw[iBoard].pCurrentDisplayMode != 0)
                        {
                        MGAVidInit(InitBuf[iBoard], VideoBuf[iBoard]);
#if 0
                  /*VIDEOPRO*/
                  if (Hw[iBoard].pCurrentDisplayMode->DispType & 0x02)
                     {
                     if (VAFCconnector)
                        initVideoPro(1, PX2085);
                     else
                        initVideoPro(1, Hw[iBoard].DacType);
                     }
                  else
                     initVideoPro(0, Hw[iBoard].DacType);
#endif

                        blankEcran(0);
                        /* Restore Cursor visibility */
                        if (cursorStat.Width > 0)
                            {
                            mtxCursorSetShape(&cursorStat);
                            if (cursorStat.Height > 0)
                                mtxCursorEnable(1);

                            }
                        }
                    }
                }
         else
            if ( !isPciBus() &&
                 ((Hw[iBoard].ProductType &  BOARD_MGA_VL_M) == BOARD_MGA_VL)
               ) isaToWide();



            mtxVideoMode = mtxADV_MODE;
            break;
        }
}


#ifdef OS2
/*MTX* modified by mp on monday, 5/3/93 */
int mtxCheckMGAEnable()
{
    int ret_value;

    ret_value = (int)mtxVideoMode;
    return(ret_value);
}

int mtxCheckVgaEnable()
{
    return ((int)rdTitanReg(TITAN_CONFIG) & TITAN_VGAEN_M);
}

/*END*/
#endif



/*------------------------------------------------------
* mtxGetVideoMode
*
* Get video mode
*
* Return: - mtxVGA      : mode VGA
*         - mtxADV_MODE : mode high resolution
*------------------------------------------------------*/

word mtxGetVideoMode (void)
{
   return (mtxVideoMode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mtxvpro.h ===
/***************************************************************************
*                                    ADC.H                                 *
****************************************************************************
*
*   Last change: 18 janvier 1994
*
*   By:          Patrice Gagnon
*
*   Changes: 
*
*   Description: All definitions used for the ENCODER's test program.
*
****************************************************************************/


/**********************  DEFINES: IDENTIFICATION  ************************/

#define DENC_REG            0
#define PSG_REG             1
#define DAC_REG             2
#define ADC_REG             3
#define CTRL_REG            4
#define MGA_DAC_LUT         0
#define ENC_DENC_CLUT       1
#define ENC_DAC_COL_LUT     2
#define ENC_COL_LUT         3
#define ALL_COL_LUT         4
#define ENC_DAC_CUR_LUT     5

#define ENC_ID_REV0      0x50
#define PSG_ID           0x02
#define BASE_VER         0x02
#define DELUXE_VER       0x03

#define PAL_STD            1
#define NTSC_STD           2
#define VAFC            0x10

#define BLANC        0x00ffffff
#define NOIR         0x00000000
#define ROUGE        0x00ff0000
#define VERT         0x0000ff00
#define BLEU         0x000000ff

#define RED_PATH           0
#define GREEN_PATH         1
#define BLUE_PATH          2
#define WHITE_PATH         3
#define ALPHA_PATH         4

#define DEFAULT_REG        0
#define PATH_REG           1
#define VISU_ALPHA         2
#define KEYING             3
#define ONE_CHANGE         4

#define ALL_REG         0xff

#define BOTH_SENSE         3
#define ONLY_DENC          2
#define ONLY_DAC           1
#define NONE               0
#define MGA_SENSE          1

#define MAX_LEVEL       0xfc  
#define MIN_LEVEL       0x00  
#define BLANCK_LEVEL    0x64
#define WHITE_LEVEL     0xff
#define RED_LEVEL       0xa4    
#define GREEN_LEVEL     0xd4 
#define BLUE_LEVEL      0x84
#define SECUR_FACTOR    0x0c    /* 57 mV of security */
                             
/********************  DEFINES: NUMBER OF REGISTER  **********************/

#define DENC_NBRE_REG            16

#define PSG_NBRE_REG             23
#define PSG_NBRE_FULL_REG        17  
#define PSG_NBRE_REG_A_CHAMP      3

#define DAC_NBRE_REG             16+1   /* COMMAND3 addition */      
#define DAC_NBRE_REG_A_CHAMP      4+1   /*    "         "    */
#define DAC_NBRE_FULL_REG        12

#define ADC_NBRE_REG              8-4   /* IOUT4-6 unused */
#define ADC_NBRE_REG_A_CHAMP      1
#define ADC_NBRE_FULL_REG         6-3   /*    "      "    */


/********************  DEFINES: CALCUL OF ADDRESSES  *********************/

#define BASE_ADDR1           0x240
#define BASE_ADDR2           0x300
#define BASE_ADDR3           0x340

#define ENC_CTRL_OFFSET      0x00
#define ENC_ID_OFFSET        0x02
#define DENC_OFFSET          0x04
#define PSG_OFFSET           0x08
#define ADC_OFFSET           0x0c
#define DAC_OFFSET           0x10

                                                  
#define DENC_CLUT_CTRL_RD    ( DENC_OFFSET + 0x0 )
#define DENC_CLUT_CTRL_WR    ( DENC_OFFSET + 0x0 )
#define DENC_CLUT_DATA       ( DENC_OFFSET + 0x1 )

#define DAC_LUT_CTRL_RD      ( DAC_OFFSET  + 0x3 )
#define DAC_LUT_CTRL_WR      ( DAC_OFFSET  + 0x0 )
#define DAC_LUT_DATA         ( DAC_OFFSET  + 0x1 )

#define DAC_CUR_CTRL_RD      ( DAC_OFFSET  + 0x7 )
#define DAC_CUR_CTRL_WR      ( DAC_OFFSET  + 0x4 )
#define DAC_CUR_DATA         ( DAC_OFFSET  + 0x5 )

#define DENC_ADDR_CTRL       ( DENC_OFFSET + 0x2 )
#define DENC_DATA_CTRL       ( DENC_OFFSET + 0x3 )

#define PSG_ADDR_CTRL        ( PSG_OFFSET  + 0x0 )
#define PSG_DATA_CTRL        ( PSG_OFFSET  + 0x2 )


/****************************** MACROS ***********************************/

#define AUTO_INC     (inw (dataPort) >> 9) & 0x1
#define VERSION      enc.board.id_reg.f.ver
#define NOT_ENCODER  (enc.board.id_reg.all & 0xf7)   != ENC_ID_REV0
#define VAFC_INPUT   enc.board.ctrl_reg.f.vafc_input == IN_VAFC
#define KEYING_EN    enc.denc.index08.f.keye         == ENABLE
#define IN_NTSC      enc.board.ctrl_reg.f.ntsc_en    == NTSC_STD

#define CLEAR_LUT(lutSel)  initEveryLut (lutSel,1,0x00,0xff,0,0,0)

/********************  DEFINES: FIELD  *********************/
#define  ENC_FILTER  ( (word)0x0004 )
/************************* DENC'S STRUCTURE ******************************/

/***** CONTROL TABLE *****/


typedef struct
   {
   union			  			   			    /*     INDEX 00     */
      {
      struct
         {
         byte mod       : 2;
         byte ccir      : 1;
         byte scbw      : 1;
         byte fmt       : 3;
         byte vtby      : 1;
         } f;
      byte all;
      } index00;
       			   
   byte trer;    			   			    /*     INDEX 01     */
   byte treg;    			   			    /*     INDEX 02     */
   byte treb;    			   			    /*     INDEX 03     */

   union			  			   			    /*     INDEX 04     */
      {
      struct
         {
         byte oef       : 1;
         byte hlck      : 1;
         byte hpll      : 1;
         byte nint      : 1;
         byte vtrc      : 1;
         byte scen      : 1;
         byte sysel     : 2;
         } f;
      byte all;
      } index04;
   union			  			   			    /*     INDEX 05     */
      {
      struct
         {
         byte gdc       : 6;
         byte unused    : 2;
         } f;
      byte all;
      } index05;

   byte idel;    			   			    /*     INDEX 06     */

   union			  			   			    /*     INDEX 07     */
      {
      struct
         {
         byte pso       : 6;
         byte unused    : 2;
         } f;
      byte all;
      } index07;
   union			  			   			    /*     INDEX 08     */
      {
      struct
         {
         byte srsn      : 1;
         byte gpsw      : 1;
         byte im        : 1;
         byte coki      : 1;
         byte cpr       : 1;
         byte src       : 1;
         byte keye      : 1;
         byte dd        : 1;
         } f;
      byte all;
      } index08;
   union			  			   			    /*     INDEX 09     */
      {
      struct
         {
         byte rtce      : 1;
         byte rtin      : 1;
         byte rtsc      : 1;
         byte iepi      : 1;
         byte mpkc      : 2;
         byte bame      : 1;
         byte unused    : 1;
         } f;
      byte all;
      } index09;

   byte chps;   			   			    /*     INDEX 0C     */
   byte fsco;	  			   			    /*     INDEX 0D     */

   union			  			   			    /*     INDEX 0E     */
      {
      struct
         {
         byte std       : 4;
         byte clck      : 1;
         byte unused    : 3;
         } f;
      byte all;
      } index0E;
   } DENC;




/************************** PSG'S STRUCTURE ******************************/


#define PSG_DPYCTL_IDX         0x0
#define PSG_POLCTL_IDX         0x1
#define PSG_EXTCTL_IDX         0x2
#define PSG_V_TOTAL_IDX        0x3
#define PSG_H_TOTAL_IDX        0x7
#define PSG_HS_BURST_IDX       0x10     /* Horiz. start */
#define PSG_HE_BURST_IDX       0x11     /* Horiz. end   */
#define PSG_VS_BURST_IDX       0x12     /* Vert.  start */
#define PSG_VE_BURST_IDX       0x13     /* Vert.  end   */
#define PSG_VCOUNT_IDX         0x14
#define PSG_HCOUNT_IDX         0x15
#define PSG_SCOUNT_IDX         0x16


typedef struct
   {
   union			  			   			    /*      INDEX      */
      {
      struct
         {
         word index_reg            : 5;
         word chip_ver             : 2;
         word chip_id              : 5;
         word unused               : 4;
         } f;
      word all;
      } index;

   union			  			   			    /*      DPYCTL      */
      {
      struct
         {
         word non_interlaced       : 1;
         word run                  : 1;
         word divise_select        : 2;
         word serrated_sync        : 1;
         word equalization_pulses  : 1;
         word video                : 1;
         word video_read           : 1;        /* read back bit */
         word clamp_pulse          : 1;
         word autoinc              : 1;
         word unused               : 6;
         } f;
      word all;
      } dpyctl;

   union			  			   			    /*      POLCTL      */
      {
      struct
         {
         word hori_sync            : 1;
         word vert_sync            : 1;
         word composite_sync       : 1;
         word composite_blank      : 1;
         word burst_pulse          : 1;
         word clamp_pulse          : 1;
         word internal_pclk        : 1;
         word pclk                 : 1;
         word unused               : 8;
       	} f;  
      word all;
      } polctl;

   union			  			   			    /*      EXTCTL      */
      {
      struct
         {
         word external_sync        : 1;
         word hori_reset           : 1;
         word scan_mode            : 2;
         word hori_reset_input_pol : 1;
         word vert_reset_input_pol : 1;
         word field_scan_mode      : 1;
         word unused               : 9;
         } f;
      word all;
      } extctl;


   word vtotal;
   word vsblnk;
   word veblnk;
   word vesync;
   word htotal;
   word hsblnk;
   word heblnk;
   word hesync;
   word vssyncs;
   word sethcnt;
   word setvcnt;
   word hsclmp;
   word heclmp;
   word hsbrst;
   word hebrst;
   word vsbrst;
   word vebrst;
   word vcount;
   word hcount;
   word scount;

   } PSG;


/*************************** DAC'S STRUCTURE *****************************/

typedef struct
   {
   byte col_addr_wr;
   byte col_data;   
   byte rd_msk;     
   byte col_addr_rd;
   byte cur_addr_wr;
   byte cur_data;   

   union			  			         /*      COMMAND REGISTER 0      */
      {
      struct
         {
         byte power_down_en        : 1;
         byte dac_resolution       : 1;
         byte red_sync_en          : 1;
         byte green_sync_en        : 1;
         byte blue_sync_en         : 1;
         byte setup_en             : 1;
         byte clk_disable          : 1;
         byte reserved             : 1;
         } f;
      byte all;
      } command0;

   byte cur_addr_rd;

   union			  			         /*      COMMAND REGISTER 1      */
      {
      struct
         {
         byte switch_ctrl          : 1;
         byte switch_en            : 1;
         byte multiplexing_rate    : 1;
         byte color_format         : 1;
         byte tc_bypass            : 1;
         byte bit_par_pixel_sel    : 2;
         byte reserved             : 1;
         } f;
      byte all;
      } command1;

   union			  			         /*      COMMAND REGISTER 2      */
      {
      struct
         {
         byte cursor_mode_sel      : 2;
         byte palette_index_sel    : 1;
         byte disp_mode_sel        : 1;
         byte clksel_en            : 1;
         byte portsel_mask         : 1;
         byte test_path_en         : 1;
         byte sclk_disable         : 1;
         } f;
      byte all;
      } command2;

   union			  			         /*      COMMAND REGISTER 3      */
      {
      struct
         {
         byte msb_add_cntr         : 2;
         byte curs_sel             : 1;
         byte clk_muliplier        : 1;
         byte reserved             : 4;
         } f;
      byte all;
      } command3;

   union			  			         /*            STATUS            */
      {
      struct
         {
         byte color_comp_add       : 2;
         byte rw_access_status     : 1;
         byte sense                : 1;
         byte rev                  : 2;
         byte id                   : 2;
         } f;
      byte all;
      } status;

   byte ram_data;   
   byte cur_x_low;  
   byte cur_x_hi;   
   byte cur_y_low;  
   byte cur_y_hi;   
   } DAC;


/*************************** ADC'S STRUCTURE *****************************/

typedef struct
   {
   union			  			         /*       COMMAND REGISTER       */
      {
      struct
         {
         byte sync_detect_lev      : 1;
         byte reserved             : 1;
         byte color_out_sel        : 2;
         byte sync_detect_sel      : 3;
         byte digitize_sel         : 1;
         } f;
      byte all;
      } cmd_reg;

   byte iout0;
   byte iout1;
   byte iout2;
/*   byte iout3;
   byte iout4;
   byte iout5;
   byte reserved; */
   } ADC;


/*********************** ENC CONFIG'S STRUCTURE **************************/

typedef struct
   {
   union			  			         /*       CTRL REGISTER       */
      {
      struct
         {
         word vafc_input           : 1;
         word ntsc_en              : 1;
         word filter_en            : 1;
         word genclock_en          : 1;
         word genclock_pol         : 1;
         word vidrst_pol           : 1;
         word vidrst_en            : 1;
         word hi_reg_bt254         : 1;
         word denc_mode            : 1;
         word alpha_sync_en        : 1;
         word clr_sense            : 1;
         word reserved             : 3;
         word dac_sense            : 1;
         word denc_sense           : 1;
         } f;
      word all;
      } ctrl_reg;

   union			  			         /*       ID REGISTER       */
      {
      struct
         {
         word rev                  : 3;
         word ver                  : 2;
         word id                   : 3;
         word dum                  : 8;
         } f;
      word all;
      } id_reg;

   } BOARD;


/*************************** GENERAL STRUCTURE ***************************/

typedef struct
   {
   DENC       denc;
   PSG        psg;
   DAC        dac;
   ADC        adc;
   BOARD      board;
   } ENC_CONFIG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\mvtovid.c ===
/*/****************************************************************************
*          name: MoveToVideoBuffer
*
*   description: This function will move from the NPI structures the required
*                information for MGAVidInit.
*
*      designed: Bart Simpson. february 17, 1993
* last modified: $Author: bleblanc $, $Date: 94/05/26 09:39:51 $
*
*       version: $Id: MVTOVID.C 1.16 94/05/26 09:39:51 bleblanc Exp $
*
*    parameters: BYTE* VidTab, BYTE* CrtcTab, BYTE* VideoBuffer
*      modifies: VideoBuffer content
*         calls: -
*       returns: -
******************************************************************************/

#include "switches.h"
#include "g3dstd.h"
#include "bind.h"
#include "defbind.h"
#ifndef __DDK_SRC__
  #include "sxci.h"
#endif
#include "def.h"

#ifdef WINDOWS_NT
#if defined(ALLOC_PRAGMA)
    #ifdef NO_FLOAT
        VOID MoveToVideoBuffer(BYTE* pVidTab, BYTE* pCrtcTab, BYTE* pVideoBuffer);
    #else
        VOID MoveToVideoBuffer(BYTE* pVidTab, BYTE* pCrtcTab, BYTE* pVideoBuffer);
    #endif

    #pragma alloc_text(PAGE,MoveToVideoBuffer)
#endif

//#if defined(ALLOC_PRAGMA)
//    #pragma data_seg("PAGE")
//#endif
#endif  /* #ifdef WINDOWS_NT */

#ifdef OS2
    #define _Far far
#endif

#ifdef NO_FLOAT

VOID MoveToVideoBuffer(BYTE* pVidTab, BYTE* pCrtcTab, BYTE* pVideoBuffer)
{

/*** Values of PCLK for the RAMDAC ***/

typedef struct
 {
 word FbPitch;
 long Pclk_I;
 long Pclk_NI;
 } Pclk;


Pclk Pclk_Ramdac[] = {
     640,  1227,  3150,
     768,  1475,  4500,
     800,  3300 , 5000,
    1024,  4500 , 7500,
    1152,  6200 , 10600,
    1280,  8000 , 13500,
    1600,     0 , 20000, {(word) -1}
};


extern volatile byte _Far *pMgaBaseAddr;
extern HwData Hw[NB_BOARD_MAX+1];
extern byte iBoard;

Pclk *p1;
long Sclk;
dword Srate;
byte LaserScl;




   /*** Move parameters from VidTab in the VideoBuffer ***/

/* [dlee] Don't use magic numbers to index into Vid structure! When building
   32-bit executables, the elements of the Vid structure are dword aligned,
   not byte aligned!!!   */

#ifdef WINDOWS_NT

   *((BYTE*)(pVideoBuffer + VIDEOBUF_ALW))       = (BYTE)((vid *)pVidTab)[18].valeur;
   *((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) = (BYTE)((vid *)pVidTab)[13].valeur;
   *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK))     = (DWORD)((vid *)pVidTab)[0].valeur;

   *((WORD*)(pVideoBuffer + VIDEOBUF_DBWinXOffset)) = (WORD)((vid *)pVidTab)[3].valeur;

   /* In interlace mode, we must double the Vertical back porch */
   *((WORD*)(pVideoBuffer + VIDEOBUF_DBWinYOffset)) =
      (WORD)((vid *)pVidTab)[13].valeur ?
           (WORD)((vid *)pVidTab)[8].valeur * 2 :  /* Interlace */
           (WORD)((vid *)pVidTab)[8].valeur;

   /*** Set some new parameters in the VideoBuffer ***/

   *((BYTE*)(pVideoBuffer + VIDEOBUF_VideoDelay)) = *((BYTE*)(pCrtcTab + (31 * LONG_S)));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol))   = (BYTE)((vid *)pVidTab)[28].valeur;
   *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol))   = (BYTE)((vid *)pVidTab)[27].valeur;
   *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncDelay)) = *((BYTE*)(pCrtcTab + (33 * LONG_S)));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal))   &= 0x80;   /**** FORCE !#@$!@#$!@#$ ***/

#else

   *((BYTE*)(pVideoBuffer + VIDEOBUF_ALW))       = *((BYTE*)(pVidTab + (18*(26+LONG_S)) + 26));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) = *((BYTE*)(pVidTab + (13*(26+LONG_S)) + 26));
   *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK))     = *((DWORD*)(pVidTab + (0*(26+LONG_S)) + 26));
   *((WORD*)(pVideoBuffer + VIDEOBUF_DBWinXOffset)) = *((WORD*)(pVidTab + (3*(26+LONG_S)) + 26));

   /* In interlace mode, we must double the Vertical back porch */
   *((WORD*)(pVideoBuffer + VIDEOBUF_DBWinYOffset)) =
      *((WORD*)(pVidTab + (13*(26+LONG_S)) + 26)) ?
           *((WORD*)(pVidTab + (8*(26+LONG_S)) + 26)) * 2 :  /* Interlace */
           *((WORD*)(pVidTab + (8*(26+LONG_S)) + 26)) ;


   /*** Set some new parameters in the VideoBuffer ***/

   *((BYTE*)(pVideoBuffer + VIDEOBUF_VideoDelay)) = *((BYTE*)(pCrtcTab + (31 * LONG_S)));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol))   = *((BYTE*)(pVidTab + (28*(26+LONG_S)) + 26));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol))   = *((BYTE*)(pVidTab + (27*(26+LONG_S)) + 26));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncDelay)) = *((BYTE*)(pCrtcTab + (33 * LONG_S)));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal))   &= 0x80;   /**** FORCE !#@$!@#$!@#$ ***/

#endif  /* #ifdef WINDOWS_NT */

   *((DWORD*)(pVideoBuffer + VIDEOBUF_OvsColor))   = 0x0000; /**** FORCE !#@$!@#$!@#$ ***/


   /*** srate and laserscl need to be set according to PCLK ***/
   /*******************************************************************/
   /*** PIXEL CLOCK : Programmation of registers SRATE and LASERSCL ***/
   /*** N.B. Values of SCLK and SPLCLK are in MHz ***/

   /* Find PCLK value in table Pclk_Ramdac[] */
   for (p1 = Pclk_Ramdac; p1->FbPitch != (word)-1; p1++)
      {
      if (p1->FbPitch == Hw[iBoard].pCurrentDisplayMode->FbPitch)
         {
          if (Hw[iBoard].pCurrentDisplayMode->DispType & 0x1)  /* if interlace */
            {
            switch (Hw[iBoard].DacType)
               {
               case BT482:
                  Sclk = p1->Pclk_I*(Hw[iBoard].pCurrentDisplayMode->PixWidth/8);
                  break;
               case BT485:
               case PX2085:
               case VIEWPOINT:
               case TVP3026:
                  Sclk = p1->Pclk_I/(32/Hw[iBoard].pCurrentDisplayMode->PixWidth);
                  break;
               }
            }
          else
            {
            switch (Hw[iBoard].DacType)
               {
               case BT482:
                  Sclk = p1->Pclk_NI*(Hw[iBoard].pCurrentDisplayMode->PixWidth/8);
                  break;
               case BT485:
               case PX2085:
               case VIEWPOINT:
               case TVP3026:
                  Sclk = p1->Pclk_NI/(32/Hw[iBoard].pCurrentDisplayMode->PixWidth);
                  break;
               }
            }
          break;
         }
      }


   /*** MOUSE ***/

   if (Hw[iBoard].PortCfg == MOUSE_PORT)
      Srate = (dword)((Sclk*100)/16384);       /* Srate = SCLK / (200*32*256) */

   /*** LASER ***/
   else
      {
      if (Sclk < 2200)
         Srate = 0;
      else if (Sclk >= 2200 && Sclk < 4400)
         Srate = 1;
      else if (Sclk >= 4400 && Sclk < 8800)
         Srate = 3;
      else if (Sclk >= 8800 && Sclk < 17600)
         Srate = 7;
      else
         Srate = 9;

      if ((Sclk/(Srate+1)) < 1400)
         LaserScl = 0;
      else if ((Sclk/(Srate+1)) >= 1400 && (Sclk/(Srate+1)) < 1750)
         LaserScl = 1;
      else if ((Sclk/(Srate+1)) >= 1750)
         LaserScl = 2;
      }

   *((BYTE*)(pVideoBuffer + VIDEOBUF_Srate))      = (byte)Srate;

   if (Hw[iBoard].PortCfg != MOUSE_PORT)
	  *((BYTE*)(pVideoBuffer + VIDEOBUF_LaserScl))   = LaserScl;

   /*** move the CTRC parameters in the VideoBuffer ***/

   { WORD i;

   for (i = 0; i <= 28; i++)
      {
      *((BYTE*)(pVideoBuffer + VIDEOBUF_CRTC + i)) = *((BYTE*)(pCrtcTab + (i * LONG_S)));
      }
   }

   }

/**************************************************************************/
#else


VOID MoveToVideoBuffer(BYTE* pVidTab, BYTE* pCrtcTab, BYTE* pVideoBuffer)
{

/*** Values of PCLK for the RAMDAC ***/

typedef struct
 {
 word  FbPitch;
 float Pclk_I;
 float Pclk_NI;
 } Pclk;


Pclk Pclk_Ramdac[] = {
     640,  12.27,  31.5,
     768,  14.75,  45.0,
     800,  33.0 ,  50.0,
    1024,  45.0 ,  75.0,
    1152,  62.0 , 106.0,
    1280,  80.0 , 135.0,
    1600,     0 , 200.0, {-1}
};


extern volatile byte _Far *pMgaBaseAddr;
extern HwData Hw[NB_BOARD_MAX+1];
extern byte iBoard;

Pclk *p1;
float Sclk;
dword Srate;
byte LaserScl;




   /*** Move parameters from VidTab in the VideoBuffer ***/

   *((BYTE*)(pVideoBuffer + VIDEOBUF_ALW))       = *((BYTE*)(pVidTab + (18*(26+LONG_S)) + 26));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) = *((BYTE*)(pVidTab + (13*(26+LONG_S)) + 26));
   *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK))     = *((DWORD*)(pVidTab + (0*(26+LONG_S)) + 26));
   *((WORD*)(pVideoBuffer + VIDEOBUF_DBWinXOffset)) = *((WORD*)(pVidTab + (3*(26+LONG_S)) + 26));
   /* In interlace mode, we must double the Vertical back porch */
   *((WORD*)(pVideoBuffer + VIDEOBUF_DBWinYOffset)) =
      *((WORD*)(pVidTab + (13*(26+LONG_S)) + 26)) ?
           *((WORD*)(pVidTab + (8*(26+LONG_S)) + 26)) * 2 :  /* Interlace */
           *((WORD*)(pVidTab + (8*(26+LONG_S)) + 26)) ;


   /*** Set some new parameters in the VideoBuffer ***/

   *((BYTE*)(pVideoBuffer + VIDEOBUF_VideoDelay)) = *((BYTE*)(pCrtcTab + (31 * LONG_S)));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol))   = *((BYTE*)(pVidTab + (28*(26+LONG_S)) + 26));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol))   = *((BYTE*)(pVidTab + (27*(26+LONG_S)) + 26));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncDelay)) = *((BYTE*)(pCrtcTab + (33 * LONG_S)));
   *((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal))   &= 0x80;   /**** FORCE !#@$!@#$!@#$ ***/

   *((DWORD*)(pVideoBuffer + VIDEOBUF_OvsColor))   = 0x0000; /**** FORCE !#@$!@#$!@#$ ***/


   /*** srate and laserscl need to be set according to PCLK ***/
   /*******************************************************************/
   /*** PIXEL CLOCK : Programmation of registers SRATE and LASERSCL ***/
   /*** N.B. Values of SCLK and SPLCLK are in MHz ***/

   /* Find PCLK value in table Pclk_Ramdac[] */
   for (p1 = Pclk_Ramdac; p1->FbPitch != (word)-1; p1++)
      {
      if (p1->FbPitch == Hw[iBoard].pCurrentDisplayMode->FbPitch)
         {
          if (Hw[iBoard].pCurrentDisplayMode->DispType & 0x1)  /* if interlace */
            {
            switch (Hw[iBoard].DacType)
               {
               case BT482:
                  Sclk = p1->Pclk_I*(Hw[iBoard].pCurrentDisplayMode->PixWidth/8);
                  break;
               case BT485:
               case PX2085:
               case VIEWPOINT:
               case TVP3026:
                 Sclk = p1->Pclk_I/(32/Hw[iBoard].pCurrentDisplayMode->PixWidth);
                  break;
               }
            }
          else
            {
            switch (Hw[iBoard].DacType)
               {
               case BT482:
                  Sclk = p1->Pclk_NI*(Hw[iBoard].pCurrentDisplayMode->PixWidth/8);
                  break;
               case BT485:
               case PX2085:
               case VIEWPOINT:
               case TVP3026:
                  Sclk = p1->Pclk_NI/(32/Hw[iBoard].pCurrentDisplayMode->PixWidth);
                  break;
               }
            }
          break;
         }
      }


   /*** MOUSE ***/

   if (Hw[iBoard].PortCfg == MOUSE_PORT)
      Srate = (dword)(Sclk/1.638400);       /* Srate = SCLK / (200*32*256) */

   /*** LASER ***/
   else
      {
      if (Sclk < 22)
         Srate = 0;
      else if (Sclk >= 22 && Sclk < 44)
         Srate = 1;
      else if (Sclk >= 44 && Sclk < 88)
         Srate = 3;
      else if (Sclk >= 88 && Sclk < 176)
         Srate = 7;
      else
         Srate = 9;

      if ((Sclk/(Srate+1)) >= 0 && (Sclk/(Srate+1)) < 14)
         LaserScl = 0;
      else if ((Sclk/(Srate+1)) >= 14 && (Sclk/(Srate+1)) < 17.5)
         LaserScl = 1;
      else if ((Sclk/(Srate+1)) >= 17.5)
         LaserScl = 2;
      }

   *((BYTE*)(pVideoBuffer + VIDEOBUF_Srate))      = Srate;
   *((BYTE*)(pVideoBuffer + VIDEOBUF_LaserScl))   = LaserScl;

   /*** move the CTRC parameters in the VideoBuffer ***/

   { WORD i;

   for (i = 0; i <= 28; i++)
      {
      *((BYTE*)(pVideoBuffer + VIDEOBUF_CRTC + i)) = *((BYTE*)(pCrtcTab + (i * LONG_S)));
      }
   }

   }

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\proto.h ===
/*/****************************************************************************
*          name: proto.h
*
*   description: Contains all the "extern" functions declarations
*
*      designed: g3d_soft
* last modified: $Author: unknown $, $Date: 94/11/24 11:50:08 $
*
*       version: $Id: PROTO.H 1.33 94/11/24 11:50:08 unknown Exp $
*
******************************************************************************/

extern VOID Decoder(BYTE *);         /*** CADDI command decoder ***/

/*** RC opcodes ***/

extern VOID (*SetFgColor())(VOID);
extern VOID (*SetFgIndex())(VOID);
extern VOID (*SetClipList())(VOID);
extern VOID (*SetBgColor())(VOID);
extern VOID (*SetBgIndex())(VOID);
extern VOID (*SetTrivialIn())(VOID);
extern VOID (*SetTransparency())(VOID);
extern VOID (*SetEndPoint())(VOID);
extern VOID (*SetLineStyle())(VOID);
extern VOID (*SetFillPattern())(VOID);
extern VOID (*SetLogicOp())(VOID);
extern VOID (*SetZBuffer())(VOID);
extern VOID (*InitRC())(VOID);
extern VOID (*Set2DViewport())(VOID);
extern VOID (*Set2DWindow())(VOID);
extern VOID (*Set2DWindow32())(VOID);
extern VOID (*SetLightSources())(VOID);
extern VOID (*SetSurfaceAttr())(VOID);
extern VOID (*SetViewer())(VOID);
extern VOID (*SetClip3D())(VOID);
extern VOID (*SetRenderData())(VOID);
extern VOID (*SetRenderMode())(VOID);
extern VOID (*ChangeMatrix())(VOID);
extern VOID (*SetOutline())(VOID);
extern VOID (*SetPlaneMask())(VOID);
extern VOID (*SetAsynchronousSwap())(VOID);
extern VOID (*SetLineStyleOffset())(VOID);

/*** SC opcodes ***/
extern VOID (*RenderScPolyLine())(VOID);
extern VOID (*RenderScPolygon())(VOID);
extern VOID (*SpanLine())(VOID);
extern VOID (*RenderSCPolyTriangle())(VOID);

/*** 2D opcodes ***/
extern VOID (*Render2DMultiPolyLine())(VOID);
extern VOID (*Render2DPolygon())(VOID);
extern VOID (*Render2DPolygon32())(VOID);

/*** MISC opcodes ***/
extern VOID (*Sync())(VOID);
extern VOID (*NoOp())(VOID);
extern VOID (*Clear())(VOID);
extern VOID (*SetBufferConfiguration())(VOID);
extern VOID (*SetBufferConfIndex())(VOID);
extern VOID (*SetBufferDummy())(VOID);
extern VOID (*SetBufferSideSide())(VOID);
extern VOID (*SetBufferFrontBack())(VOID);

extern VOID (*BadOpcode())(VOID);         /*** Non-existing opcode replacement ***/

/*** 3D opcodes ***/

extern VOID (*RenderPolyQuad())(VOID);
extern VOID (*RenderPolyLine())(VOID);
extern VOID (*Triangle())(VOID);
extern VOID (*RenderPolyTriangle())(VOID);

/*** MISC functions ***/

extern DWORD XformRGB24ToSliceFmt(DWORD);
extern DWORD XformMask24ToSliceFmt(DWORD);
extern VOID  DefCaddiSysRegToTitan(VOID);
extern VOID  SetHWtoRC(VOID);

/*** INIT functions ***/

extern BYTE* CaddiInit(BYTE*, BYTE*);
extern VOID  InitDefaultRC(VOID);
extern VOID  InitDefaultClipList(VOID);
extern VOID  CaddiClose(VOID);
extern BYTE* InitSysParm(VOID);
extern VOID  InitDefaultLSDB(VOID);

extern VOID MGASysInit(BYTE*);
extern VOID MGAVidInit(BYTE*, BYTE*);
extern DWORD GetMGAMctlwtst(DWORD, DWORD);
extern VOID SetMGALUT(volatile BYTE _Far *, BYTE*, BYTE, BYTE);
extern VOID GetMGAConfiguration(volatile BYTE _Far *, DWORD*, DWORD*, DWORD*);
extern SDWORD setFrequence(volatile BYTE _Far *, SDWORD, SDWORD);
extern SDWORD setTVP3026Freq(volatile BYTE _Far *, SDWORD, SDWORD, BYTE);

/*** 3D functions ***/

extern VOID CalcLSKB();

/*** Utility functions used to setup CADDI buffers ***/

extern DWORD BufDone(BYTE*);
extern DWORD BufNoOp(BYTE*, BYTE*, WORD);
extern DWORD BufSync(BYTE*);
extern DWORD BufSetFgColor(BYTE*, BYTE*, float, float, float);
extern DWORD BufSetBgColor(BYTE*, BYTE*, float, float, float);
extern DWORD BufSetLogicOp(BYTE*, BYTE*, WORD);
extern DWORD BufSetFillPattern(BYTE*, BYTE*, WORD, BYTE[8]);
extern DWORD BufSetLineStyle(BYTE*, BYTE*, WORD, DWORD);
extern DWORD BufSetEndPoint(BYTE*, BYTE*, WORD);
extern DWORD BufSetTransparency(BYTE*, BYTE*, WORD);
extern DWORD BufSetTrivialIn(BYTE*, BYTE*, WORD);
extern DWORD BufSetZBuffer(BYTE*, BYTE*, WORD, DWORD);
extern DWORD BufInitRC(BYTE*, BYTE*);
extern DWORD BufSet2DViewport(BYTE*, BYTE*, WORD, WORD, WORD, WORD);
extern DWORD BufSet2DWindow(BYTE*, BYTE*, SWORD, SWORD, SWORD, SWORD);
extern DWORD BufSet2DWindow32(BYTE*, BYTE*, SDWORD, SDWORD, SDWORD, SDWORD);
extern DWORD BufClear(BYTE*, BYTE*, WORD, float, float, float, float);
extern DWORD BufSetViewer(BYTE*, BYTE*, WORD, float, float, float, float, float, float);
extern DWORD BufSetSurfaceAttr(BYTE*, BYTE*, float, float, float, float, float, float,
                              float, float, float, float, float, float, float);
extern DWORD BufSetBufferConfiguration(BYTE*, BYTE*, BYTE, BYTE);
extern DWORD BufSetClip3D(BYTE*, BYTE*, WORD);
extern DWORD BufSetRenderData(BYTE*, BYTE*, DWORD);
extern DWORD BufSetRenderMode(BYTE*, BYTE*, WORD);
extern DWORD BufSetPlaneMask(BYTE*, BYTE*, WORD, DWORD);
extern DWORD BufSetLineStyleOffset(BYTE*, BYTE*, WORD);

/*** Blit functions ***/

extern VOID (*SetEnvBlitPlan(SWORD, SWORD, SWORD, SWORD, WORD, WORD, WORD))
            (SWORD, SWORD, SWORD, SWORD, WORD, WORD, WORD);
extern VOID (*SetEnvBlitPoly(SWORD, SWORD, SWORD, SWORD, WORD, WORD, WORD))
            (SWORD, SWORD, SWORD, SWORD, WORD, WORD, WORD);
extern VOID (*SetEnvIloadPlan(SWORD, SWORD, WORD, WORD, WORD, DWORD*))
            (SWORD, SWORD, WORD, WORD, WORD, DWORD*);
extern VOID (*SetEnvIloadPoly(SWORD, SWORD, WORD, WORD, WORD, DWORD*))
            (SWORD, SWORD, WORD, WORD, WORD, DWORD*);
extern VOID (*SetEnvIdumpPoly(SWORD, SWORD, WORD, WORD, WORD, DWORD*))
            (SWORD, SWORD, WORD, WORD, WORD, DWORD*);
extern VOID (*SetEnvIloadExp(SWORD, SWORD, WORD, WORD, WORD, DWORD*))
            (SWORD, SWORD, WORD, WORD, WORD, DWORD*);
extern VOID (*SetEnvIloadDither(SWORD, SWORD, WORD, WORD, WORD, DWORD*))
            (SWORD, SWORD, WORD, WORD, WORD, DWORD*);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\switches.h ===
/**************************************************************************\

$Header:$

$Log:$

\**************************************************************************/

/*****************************************************************************
*
*   file name:   switches.h
*
******************************************************************************/

//#ifdef NT_UP    /* Command-line Define used under Windows NT */
#if 1    /* Command-line Define used under Windows NT */

    #define WINDOWS_NT  1

    // Specify compilation for Intel or Alpha (where 'Alpha' is defined
    // as non-x86)
    #if !defined(_X86_)
        #define     ALPHA           1
    #endif

    #if defined(ALPHA)
        #define MGA_ALPHA
    #endif

    // Specify compilation for WinNT 3.1 or WinNT 3.5
    //#define MGA_WINNT31
    #define MGA_WINNT35

    #include "dderror.h"
    #include "devioctl.h"
    #include "miniport.h"
    #include "ntddvdeo.h"

    #define _Far
    #define  NO_FLOAT       1

    #define WINNT_PCIBIOSCALL   0
    #define WINNT_PCIBUS        1

    #ifdef MGA_ALPHA
        #define DbgBreakPoint() DbgBreakPoint()
    #else
        #define DbgBreakPoint() _asm {int 3}
    #endif

    #if (defined(MGA_WINNT35) && defined(MGA_ALPHA))
        #define USE_VP_GET_ACCESS_RANGES    1
        #define USE_DDC_CODE                0
        #define USE_SETUP_VGA               0
    #else
        #define USE_VP_GET_ACCESS_RANGES    1
        #define USE_DDC_CODE                0
        #define USE_SETUP_VGA               1
    #endif

    //#define USE_DDC_CODE                (defined (WINDOWS_NT)) && (defined (_X86_))

#else   /* #ifdef NT_UP */

    #define USE_VP_GET_ACCESS_RANGES    TRUE
    #define USE_DDC_CODE                0
    #define USE_SETUP_VGA               0

#endif  /* #ifdef NT_UP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\sxci.h ===
/*****************************************************************************
*
*   file name:   sxci.h
*
******************************************************************************/


/* [dlee] Modified for Windows NT */

#ifdef WINDOWS_NT
extern  PVOID          pMgaDeviceExtension;
#endif

/*
 * opcodes for SXCI
 */

/*** general opcodes ***/
#define CLEAR                   0x0004
#define DONE                    0x0001
#define INITRC                  0x0E00
#define NOOP                    0x0501
#define SETBUFFERCONFIGURATION  0x0300
#define SETBGCOLOR              0x1800
#define SETCLIPLIST             0x0500
#define SETENDPOINT             0x1700
#define SETFGCOLOR              0x0402
#define SETFILLPATTERN          0x1600
#define SETLINESTYLE            0x0502
#define SETLINESTYLEOFFSET      0x0600
#define SETLOGICOP              0x0800
#define SETTRANSPARENCY         0x1400
#define SETTRIVIALIN            0x1300
#define SYNC                    0x0301

/*** screen opcodes ***/
#define RENDERSCPOLYLINE        0x0304
#define RENDERSCPOLYGON         0x0404
#define SPANLINE                0x0204

/*** 2D opcodes ***/
#define RENDER2DMULTIPOLYLINE   0x0602
#define RENDER2DMULTIPOLYLINE32 0x0a02
#define RENDER2DPOLYGON         0x0302
#define RENDER2DPOLYGON32       0x0902
#define SET2DVIEWPORT           0x0002
#define SET2DWINDOW             0x0102
#define SET2DWINDOW32           0x0702

/*** 3D opcodes ***/
#define CHANGEMATRIX            0x0000
#define RENDERPOLYLINE          0x0103
#define RENDERPOLYQUAD          0x0203
#define RENDERPOLYTRIANGLE      0x0303
#define SETCLIP3D               0x0400
#define SETLIGHTSOURCES         0x0700
#define SETRENDERDATA           0x1000
#define SETRENDERMODE           0x0A00
#define SETSURFACEATTR          0x1100
#define SETVIEWER               0x0B00
#define SETZBUFFER              0x0c00


/*
 *   typedefs for SXCI data
 */

typedef float IFLOAT;           /* integer value passed as a float */
typedef float NFLOAT;           /* a normalized float 0.0 <= value <= 1.0 */

typedef struct {
    double x;
    double y;
    double z;
} point;

typedef enum {
    Xaxis,
    Yaxis,
    Zaxis,
    Waxis
} axis_name;                        

typedef struct {
    double data[4][4];
} matrix;


typedef struct {
    float   M[4][4];
} MATRIX4;

typedef struct {
    float   X;
    float   Y;
    float   Z;
} POINT3;

typedef struct {
    NFLOAT  X;
    NFLOAT  Y;
    NFLOAT  Z;
} NORM3;                        /* where X*X + Y*Y + Z*Z = 1.0 */

typedef struct {
    NFLOAT  Red;
    NFLOAT  Green;
    NFLOAT  Blue;
} COLOR3;

/* sxci interprets these 16-bit datum as a signed values */
typedef struct {
    word    X;
    word    Y;
} IPOINT2;

/* sxci interprets these 32-bit datum as a signed values */
typedef struct {
    dword   X;
    dword   Y;
} IPOINT2_32;

#define NULL_LIGHT_TYPE             0.0
typedef struct {
    float   Type;               /* Type = 0.0 */
} NULL_LIGHT;

#define AMBIENT_LIGHT_TYPE          1.0
typedef struct {
    float   Type;               /* Type = 1.0 */
    COLOR3  AmbientCol;
} AMBIENT_LIGHT;

#define DIRECTIONAL_LIGHT_TYPE      2.0
typedef struct {
    float   Type;               /* Type = 2.0 */
    COLOR3  DiffuseCol;
    COLOR3  SpecularCol;
    NORM3   Direction;
} DIRECTIONAL_LIGHT;

#define POSITIONAL_LIGHT_TYPE       3.0
typedef struct {
    float   Type;               /* Type = 3.0 */
    COLOR3  DiffuseCol;
    COLOR3  SpecularCol;
    POINT3  Position;
    NFLOAT  AttGlobal;
    NFLOAT  AttDist;
} POSITIONAL_LIGHT;

#define SPOT_LIGHT_TYPE             4.0
typedef struct {
    float   Type;               /* Type = 4.0 */
    COLOR3  DiffuseCol;
    COLOR3  SpecularCol;
    POINT3  Position;
    NORM3   Direction;
    NFLOAT  AttGlobal;
    NFLOAT  AttDist;
    IFLOAT  ConeExp;
    NFLOAT  CosMaxIAngle;
    NFLOAT  CosAttIAngle;
} SPOT_LIGHT;

typedef union {
    NULL_LIGHT          Null_Light;
    AMBIENT_LIGHT       Ambient_Light;
    DIRECTIONAL_LIGHT   Directional_Light;
    POSITIONAL_LIGHT    Positional_Light;
    SPOT_LIGHT          Spot_Light;
} LIGHT_SOURCES;


/*
 *   typedefs for SXCI commands (templates)
 */

/*  -------------------------------------------------------------------
 *  General Opcodes
 *  -------------------------------------------------------------------  */

/*** Clear ***/
#define DISPLAY_AND_Z     0x0
#define DISPLAY_ONLY      0x1
#define Z_ONLY            0x2
#define Z_NEAR            0.0
#define Z_FAR             1.0
typedef struct {
    short       Opcode;         /* 0x0004 */
    short       ClearMode;      /* 0 = clear display and z */
                                /* 1 = clear display only  */
                                /* 2 = clear Z-buffer only */
    long        RcId;           /* Rendering context Id */
    COLOR3      ClearColor;     /* color for display clear */
    NFLOAT      ClearDepth;     /* Depth for Z-buffer clear */
} Clear;


/*** Done ***/
typedef struct {
    short       Opcode;         /* 0x0001 */
    char        Null;
    char        Reserved;
} Done;


/*** InitRc ***/
typedef struct {
    short       Opcode;         /* 0x0E00 */
    short       Null;
    long        RcId;
} InitRc;


/*** NoOp ***/
typedef struct {
    short       Opcode;         /* 0x0501 */
    short       Len;            /* Number of longs to skip */
    long        RcId;           /* Rendering context Id */
    long        Data[1];        /* Data buffer to skip */
} NoOp;


/*** SetBufferConfiguration ***/
#define TC_FULL_DEPTH   0       /* Normal mode:display full depth frame buffer */
#define TC_BUF_A        1       /* Double-buffer mode: display frame buffer A */
#define TC_BUF_B        2       /* Double-buffer mode: display frame buffer B */
typedef struct {
    short       Opcode;         /* 0x0300 */
    char        BcDisplayMode;  
    char        BcDrawMode;     
    long        RcId;           /* Rendering context Id */
} SetBufferConfiguration;


/*** SetBgColor ***/
typedef struct {
    short       Opcode;         /* 0x1800 */
    short       Null;
    long        RcId;           /* Rendering context Id */
    COLOR3      BgColor;        /* Background color */
} SetBgColor;


/*** SetCliplist ***/
typedef struct {
    short       Opcode;
    short       CliplistLength;
    long        RcId;
    long        ClipId;
    mtxClipList Cliplist;
} SetCliplist;


/*** SetEndPoint ***/
typedef struct {
    short       Opcode;         /* 0x1700 */
    short       EndPoint;       /* 0 = disabled, 1 = Enabled */
    long        RcId;           /* Rendering context Id */
} SetEndPoint;


/*** SetFgColor ***/
typedef struct {
    short       Opcode;         /* 0x0402 */
    short       Null;
    long        RcId;           /* Rendering context Id */
    COLOR3      FgColor;        /* Foreground color */
} SetFgColor;


/*** SetFillPattern ***/
typedef struct {
    short       Opcode;         /* 0x1600 */
    short       PattMode;       /* 0 = disabled, 1 = Enabled */
    long        RcId;           /* Rendering context Id */
    char        FillPatt[8];    /* Fill pattern data */
} SetFillPattern;


/*** SetLinesStyle ***/
typedef struct {
    short       Opcode;         /* 0x0502 */
    short       LsMode;         /* 0 = disabled, 1 = Enabled */
    long        RcId;           /* Rendering context Id */
    long        LineStyle;      /* 32-bit line style */
} SetLineStyle;


/*** SetLinesStyleOffset ***/
typedef struct {
    short       Opcode;         /* 0x0600 */
    short       Offset;         /* Offset to shift the pattern when it is */
                                /* reset (value 0 to 31 */
    long        RcId;           /* Rendering context Id */
} SetLineStyleOffset;


/*** SetLogicOp ***/
#define         CLEAR_OP        ((word)0x0)
#define         NOR             ((word)0x1)
#define         ANDINVERTED     ((word)0x2)
#define         REPLACEINVERTED ((word)0x3)
#define         ANDREVERSE      ((word)0x4)
#define         INVERT          ((word)0x5)
#define         XOR             ((word)0x6)
#define         NAND            ((word)0x7)
#define         AND             ((word)0x8)
#define         EQUIV           ((word)0x9)
#define         NOOP_OP         ((word)0xa)
#define         ORINVERTED      ((word)0xb)
#define         REPLACE         ((word)0xc)
#define         ORREVERSE       ((word)0xd)
#define         OR              ((word)0xe)
#define         SET             ((word)0xf)

typedef struct {
    short       Opcode;        /* 0x0800 */
    short       LogicOp;
    long        RcId;          /* Rendering context Id */
} SetLogicOp;


/*** SetTransparency ***/
#if !defined(OPAQUE)
   #define         OPAQUE          ((word)0x0)
#endif
#if !defined(TRANSPARENT)
   #define         TRANSPARENT     ((word)0x1)
#endif

typedef struct {
   short        Opcode;        /* 0x1400 */
   short        TranspMode;    /* 0 = opaque, 1 = transparent */
   long         RcId;          /* Rendering context Id */
} SetTransparency;


/*** SetTrivialIn ***/
typedef struct {
   short        Opcode;
   short        TrivMode;
   long         RcId;
} SetTrivialIn;


/*** Sync ***/
typedef struct {
    short       Opcode;        /* 0x0301 */
    char        Null;
    char        Reserved;
    long        RcId;          /* Special RcId set to -1 */
} Sync;


/*  -------------------------------------------------------------------
 *  Screen Opcodes
 *  -------------------------------------------------------------------  */

/*** RenderScPolyline ***/
typedef struct {
    short       Opcode;        /* 0x0304 */
    short       Npts;          /* Number of points */
    long        RcId;          /* Rendering context Id */
    IPOINT2     Points[1];     /* xy coordinates */
} RenderScPolyline;


/*** RenderScPolygon ***/
typedef struct {
    short       Opcode;        /* 0x0404 */
    short       Npts;          /* MUST be 3 or 4 */
    long        RcId;          /* Rendering context Id */
    IPOINT2     Points[1];     /* Array of points */
} RenderScPolygon;


/*** SpanLine ***/
typedef struct {
    short       Opcode;        /* 0x0204 */
    short       Null;
    long        RcId;          /* Rendering context Id */
    long        YPosition;     /* Vertical screen position */
    long        XStart;        /* Start point (screen coords) */
    long        XEnd;          /* End point (screen coords) */
    long        ZStart;        /* Start Z value (screen coords) */
    long        ZEnd;          /* End Z value (screen coords) */
    COLOR3      RGBStart;      /* Start RGB value */
    COLOR3      RGBEnd;        /* End RGB value */
} SpanLine;




/*  -------------------------------------------------------------------
 *  2D Opcodes
 *  -------------------------------------------------------------------  */

/*** Render2dMultiPolyline ***/
typedef struct {
    short       Opcode;        /* 0x0602 */
    short       Npts;          /* Number of points */
    long        RcId;          /* Rendering context Id */
    IPOINT2     Data[1];       /* Data consisting of tag fields and xy coords */
} Render2dMultiPolyline;


/*** Render2dMultiPolyline32 ***/
typedef struct {
    short       Opcode;        /* 0x0A02 */
    short       Npts;          /* Number of points */
    long        RcId;          /* Rendering context Id */
    IPOINT2_32  Data[1];       /* Data consisting of tag fields and xy coords */
} Render2dMultiPolyline32;


/*** Render2dPolygon ***/
typedef struct {
    short       Opcode;        /* 0x0302 */
    short       Npts;          /* MUST be 3 or 4 */
    long        RcId;          /* Rendering context Id */
    IPOINT2     Points[1];     /* Array of points */
} Render2dPolygon;


/*** Render2dPolygon32 ***/
typedef struct {
    short       Opcode;        /* 0x0902 */
    short       Npts;          /* MUST be 3 or 4 */
    long        RcId;          /* Rendering context Id */
    IPOINT2_32  Data[1];       /* Array of points */
} Render2dPolygon32;


/*** Set2dViewport ***/
typedef struct {
    short       Opcode;        /* 0x0002 */
    short       Null;
    long        RcId;
    IPOINT2     XMinYMin;      
    IPOINT2     XMaxYMax;      
} Set2dViewport;


/*** Set2dWindow ***/
typedef struct {
    short       Opcode;        /* 0x0102 */
    short       Null;
    long        RcId;
    IPOINT2     XMinYMin;      /* upper left hand corner of virtual window */
    IPOINT2     XMaxYMax;      /* lower right hand corner of virtual window */
} Set2dWindow;


/*** Set2dWindow32 ***/
typedef struct {
    short       Opcode;        /* 0x0702 */
    short       Null;
    long        RcId;
    IPOINT2_32  XMinYMin;      /* upper left hand corner of virtual window */
    IPOINT2_32  XMaxYMax;      /* lower right hand corner of virtual window */
} Set2dWindow32;


/*  -------------------------------------------------------------------
 *  3D Opcodes
 *  -------------------------------------------------------------------  */

/*** ChangeMatrix ***/
#define MW                 0   /* Modeling to world coordinate matrix */
#define WV                 1   /* World to viewing coordinate matrix */
#define VS                 2   /* Viewing to screen coordinate matrix */

#define MAT_REPLACE        0   /* Replace  M=source */
#define MAT_PREMULT        1   /* Pre-multiply  M=source*M */
#define MAT_POSTMULT       2   /* Post-multiply  M=M*source */

#define IEEE               0
/* XG3 support declaration */
#define DEVICE_DEPENDANT   1

typedef struct {
    short       Opcode;        /* 0x0000 */
    short       MatrixNo;      /* MW, WV or VS */
    long        RcId;          /* index to target Rc */
    short       Operation;     /* 0=Replace, 1=Pre-mult, 2=Post-mult */
    short       Mode;          /* must be 0 = source in IEEE floating point */
    MATRIX4     Source;
} ChangeMatrix;


/*** RenderPolyline ***/
typedef struct {
    short       Opcode;        /* 0x0103 */
    short       LenVertexList; /* length of VertexList[] in longs */
    long        RcId;
    POINT3      Points[1];     /* VertexPosition */
} RenderPolyline;



typedef struct {
   POINT3   VertexPosition;          /* Vertex position */
   NORM3    OptVertexNormal;         /* Optional vertex normal */
} TileVertexList;

typedef struct {
   IFLOAT   VertexInfo;              /* Which vertices are specified */
   NORM3    OptTileNormal;           /* Optional tile normal */
   TileVertexList  TileVertexLst[1];
} TileList;


/*** RenderPolyQuad ***/
typedef struct {
    short       Opcode;        /* 0x0203 */
    short       LenTileList;   /* Length of TileList in longs */
    long        RcId;
    TileList    TileLst[1];
} RenderPolyQuad;


/*** RenderPolyTriangle ***/
typedef struct {
    short       Opcode;        /* 0x0303 */
    short       LenTileList;   /* Length of tileList[] in longs */
    long        RcId;
    TileList    TileLst[1];
} RenderPolyTriangle;



/*** SetClip3D defines ***/

#define CLIP_LEFT                0x01
#define CLIP_TOP                 0x02
#define CLIP_RIGHT               0x04
#define CLIP_BOTTOM              0x08
#define CLIP_FRONT               0x10
#define CLIP_BACK                0x20
#define CLIP_ALL                 0x3f

typedef struct {
    short       Opcode;        /* 0x0400 */
    short       Clip3DPlanes;  /* see defines above */
    long        RcId;
} SetClip3D;


/*** SetLightSources ***/
typedef struct {
    short       Opcode;        /* 0x0700 */
    short       LenLSDB;       /* Length of LSDB[] in longs */
    long        RcId;
    long        LSDBId;        /* buffer id for sxci to store LSDB */
    float       LSDB[1];       /* light source description buffer data */
} SetLightSources;


/*** SetRenderData ***/
#define     RD_VERTEX_NORMAL    (0x1 << 0)
#define     RD_TILE_NORMAL      (0x1 << 8)
typedef struct {
    short       Opcode;        /* 0x1000 */
    short       Null;
    long        RcId;
    long        OptData;       /* see defines above */
    NORM3       Reserved;
    COLOR3      Reserved1;
    NORM3       Reserved2;
} SetRenderData;


/*** SetRenderMode ***/
#define WIREFRAME_NORMAL    0       /* Wireframe  - special for AutoCAD */
#define WIREFRAME_ACAD      0       /* Wireframe  - special for AutoCAD */
#define FLAT_EXTENDED       8       /* solves double lighting problem of mode 2,
                                       the view direction and viewing matrix
                                       must be correctly set */
#define GOURAUD_EXTENDED    9       /* solves double lighting problem of mode 4,
                                       the view direction and viewing matrix
                                       must be correctly set */


typedef struct {
    short       Opcode;        /* 0x0A00 */
    short       RenderMode;    /* see defines above */
    long        RcId;
} SetRenderMode;


/*** SetSurfaceAttr ***/
typedef struct {
    short       Opcode;        /* 0x1100 */
    short       Null;
    long        RcId;
    COLOR3      SurfEmission;  /* Emission color */
    COLOR3      SurfAmbient;   /* Ambient reflectivity constant */
    COLOR3      SurfDiffuse;   /* Diffuse reflectivity constant */
    COLOR3      SurfSpecular;  /* Specular reflectivity constant */
    IFLOAT      SurfSpecExp;   /* Specular reflectivity exponent */
} SetSurfaceAttr;



#define         INFINITE_VIEWER      0
#define         LOCAL_VIEWER         1
/*** SetViewer, formerly SetViewDirection ***/
typedef struct {
    short       Opcode;        /* 0x0B00 */
    short       ViewMode;      /* mode = 0 infinite viewer */
                               /* mode = 1 local viewer */
    long        RcId;
    POINT3      ViewerPosition;  /* Viewer position in world coords */
    NORM3       ViewerDirection; /* normalized direction */
} SetViewer;


/*** SetZBuffer ***/
#define         ZF_DISABLE      ((short)0)      /* Z buffering disabled */
#define         ZF_ENABLE       ((short)1)      /* Z buffering enabled  */

#define         ZF_LESS         ((long)0)       /* NEVER replace intensity */
#define         ZF_LEQUAL       ((long)1)       /* LESS than or EQUAL */
typedef struct {
    short       Opcode;        /* 0x0C00 */
    short       ZMode;         /* 0=disable, 1=enable */
    long        RcId;
    long        ZFunction;     /* 0 = < compares */
} SetZBuffer;                  /* 1 = <= compares */



/*  -------------------------------------------------------------------
 *  For SXCI.DLL
 *  -------------------------------------------------------------------  */

#define SXCI_2D         2
#define SXCI_3D         3

#define ID_mtxAllocBuffer    1
#define ID_mtxAllocCL        2
#define ID_mtxAllocRC        3
#define ID_mtxAllocLSDB      4
#define ID_mtxFreeBuffer     5
#define ID_mtxFreeCL         6
#define ID_mtxFreeLSDB       7
#define ID_mtxFreeRC         8
#define ID_mtxPostBuffer     9
#define ID_mtxSetCL          10
#define ID_mtxBlendCL        11
#define ID_mtxGetBlockSize   12

#define ID_mtxScScBitBlt     13
#define ID_mtxScMemBitBlt    14
#define ID_mtxMemScBitBlt    15

#define ID_mtxAllocHugeBuffer    16
#define ID_mtxFreeHugeBuffer     17

#define ID_CallCaddiInit     30
#define ID_PassPoolMem       31
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\sys.c ===
/*/****************************************************************************
*          name: MGASysInit
*
*   description: Initialise the SYSTEM related hardware of the MGA device.
*
*      designed: Bart Simpson, february 10, 1993
* last modified: $Author: bleblanc $, $Date: 94/11/09 10:48:18 $
*
*       version: $Id: SYS.C 1.10 94/11/09 10:48:18 bleblanc Exp $
*
*    parameters: BYTE* to init buffer
*      modifies: MGA hardware
*         calls: GetMGAConfiguration, GetMGAMctlwtst
*       returns: -
******************************************************************************/

#include "switches.h"
#include "g3dstd.h"

#include "caddi.h"
#include "def.h"
#include "mga.h"

#include "global.h"
#include "proto.h"

#include "mgai.h"

#ifdef WINDOWS_NT
#include "video.h"
#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,MGASysInit)
#endif
#endif

VOID MGASysInit(BYTE* pInitBuffer)
   {
   DWORD DST0, DST1, Info;
   DWORD TmpDword;
   BYTE DUB_SEL, TmpByte;
   volatile BYTE _Far *pDevice;

#if( defined(WINDOWS) || defined(OS2))

   ((struct {unsigned short o; short s;}*) &pDevice)->o = *((WORD*)(pInitBuffer + INITBUF_MgaOffset));
   ((struct {unsigned short o; short s;}*) &pDevice)->s = *((WORD*)(pInitBuffer + INITBUF_MgaSegment));

#else
  #ifdef WINDOWS_NT

  //   ((struct {unsigned short o; short s;}*) &pDevice)->o = *((WORD*)(pInitBuffer + INITBUF_MgaOffset));
  //   ((struct {unsigned short o; short s;}*) &pDevice)->s = *((WORD*)(pInitBuffer + INITBUF_MgaSegment));
    pDevice = (BYTE *)(*((DWORD*)(pInitBuffer + INITBUF_MgaOffset)));

  #else

    #ifdef __MICROSOFTC600__
       /*** DOS real-mode 32-bit address ***/
       pDevice = *((DWORD*)(pInitBuffer + INITBUF_MgaOffset));
    #else
       /*** DOS protected-mode 48-bit address ***/
       ((struct {unsigned long o; short s;}*) &pDevice)->o = *((DWORD*)(pInitBuffer + INITBUF_MgaOffset));
       ((struct {unsigned long o; short s;}*) &pDevice)->s = *((WORD*)(pInitBuffer + INITBUF_MgaSegment));
    #endif

  #endif
#endif

   /*** ##### DUBIC PATCH Disable mouse IRQ and proceed ###### ***/

   mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
   mgaReadBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
   mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DUB_SEL), 0x00);

   /*** ###################################################### ***/

   /*** Get System Configuration ***/

   GetMGAConfiguration(pDevice, &DST0, &DST1, &Info);

   /*** Program the DRAWING ENGINE items in the TITAN ***/

   mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_MCTLWTST), GetMGAMctlwtst(DST0, DST1));

   /*** Program the HOST INTERFACE items in the TITAN ***/

   mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_IEN), 0);       /*** Disable interrupts ***/
   mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_ICLEAR), 0x0f); /*** Clear pending INT  ***/

   mgaReadDWORD(*(pDevice + TITAN_OFFSET + TITAN_OPMODE), TmpDword);

      /*** clear fields to be modified ***/

      TmpDword &= ~((DWORD)TITAN_NOWAIT_M | (DWORD)TITAN_RFHCNT_M | (DWORD)TITAN_FBM_M |
                    (DWORD)TITAN_HYPERPG_M | (DWORD)TITAN_TRAM_M);

      /*** program the fields ***/

      TmpDword |= (DWORD)TITAN_NOWAIT_M;

                            /***        15.625*40.0/64.0 DO 8.8       ***/
      TmpDword |= (((DWORD)(((DWORD)0x0fa0*(DWORD)0x2800/(DWORD)0x4000)>>8) << TITAN_RFHCNT_A) & (DWORD)TITAN_RFHCNT_M); /*** FIXED ***/

      TmpDword |= ((((DWORD)(*((BYTE*)(pInitBuffer + INITBUF_FBM)))) << TITAN_FBM_A) & (DWORD)TITAN_FBM_M);
      TmpDword |= ((((DST1 & (DWORD)TITAN_DST1_HYPERPG_M) >> TITAN_DST1_HYPERPG_A) << TITAN_HYPERPG_A) & (DWORD)TITAN_HYPERPG_M);

      /*** ATTENTION reversed bit according to DST1 ***/
      TmpDword |= ((((~DST1 & (DWORD)TITAN_DST1_TRAM_M) >> TITAN_DST1_TRAM_A) << TITAN_TRAM_A) & (DWORD)TITAN_TRAM_M);

   mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_OPMODE), TmpDword);

   mgaReadDWORD(*(pDevice + TITAN_OFFSET + TITAN_CONFIG), TmpDword);

      /*** clear fields to be modified ***/

      TmpDword &= ~((DWORD)TITAN_EXPDEV_M);

      /*** program the fields ***/

      TmpDword |= ((((DST1 & (DWORD)TITAN_DST1_EXPDEV_M) >> TITAN_DST1_EXPDEV_A) << TITAN_EXPDEV_A) & (DWORD)TITAN_EXPDEV_M);
      
   mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_CONFIG), TmpDword);

   /*** Program the SYSTEM items in the DUBIC ***/
      /*** OLD code had programming of lvid[2:0] ***/

   /*** Program 8/16 bits device or keep actual setup as selected ***/

   if (*((BYTE*)(pInitBuffer + INITBUF_16)) == (BYTE)1)
      {
      mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_CONFIG), TmpByte);
      TmpByte &= ~TITAN_CONFIG_M;
      mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_CONFIG), TmpByte | TITAN_CONFIG_16);
      }
   else
      {
      if (*((BYTE*)(pInitBuffer + INITBUF_16)) == (BYTE)2)
         {
      mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_CONFIG), TmpByte);
      TmpByte &= ~TITAN_CONFIG_M;
      mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_CONFIG), TmpByte | TITAN_CONFIG_8);
         }
      }

   /*** ##### DUBIC PATCH ReEnable mouse IRQ ################# ***/

   mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
   mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);

   /*** ###################################################### ***/

   }


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\vgadac.c ===
/**************************************************************************\

$Header:$

$Log:$

\**************************************************************************/

#include "switches.h"

#ifdef WINDOWS_NT
// Not to be paged out
//#if defined(ALLOC_PRAGMA)
//    #pragma data_seg("PAGE")
//#endif
#endif  /* #ifdef WINDOWS_NT */

typedef struct {unsigned short r, g, b;} DacReg;

DacReg vgaDac[] = {      /* {r, g, b} */
{0x00, 0x00, 0x00},          /* index 00  */
{0x00, 0x00, 0x2a},          /* index 01  */
{0x00, 0x2a, 0x00},          /* index 02  */
{0x00, 0x2a, 0x2a},          /* index 03  */
{0x2a, 0x00, 0x00},          /* index 04  */
{0x2a, 0x00, 0x2a},          /* index 05  */
{0x2a, 0x2a, 0x00},          /* index 06  */
{0x2a, 0x2a, 0x2a},          /* index 07  */
{0x00, 0x00, 0x15},          /* index 08  */
{0x00, 0x00, 0x3f},          /* index 09  */
{0x00, 0x2a, 0x15},          /* index 0a  */
{0x00, 0x2a, 0x3f},          /* index 0b  */
{0x2a, 0x00, 0x15},          /* index 0c  */
{0x2a, 0x00, 0x3f},          /* index 0d  */
{0x2a, 0x2a, 0x15},          /* index 0e  */
{0x2a, 0x2a, 0x3f},          /* index 0f  */
{0x00, 0x15, 0x00},          /* index 10  */
{0x00, 0x15, 0x2a},          /* index 11  */
{0x00, 0x3f, 0x00},          /* index 12  */
{0x00, 0x3f, 0x2a},          /* index 13  */
{0x2a, 0x15, 0x00},          /* index 14  */
{0x2a, 0x15, 0x2a},          /* index 15  */
{0x2a, 0x3f, 0x00},          /* index 16  */
{0x2a, 0x3f, 0x2a},          /* index 17  */
{0x00, 0x15, 0x15},          /* index 18  */
{0x00, 0x15, 0x3f},          /* index 19  */
{0x00, 0x3f, 0x15},          /* index 1a  */
{0x00, 0x3f, 0x3f},          /* index 1b  */
{0x2a, 0x15, 0x15},          /* index 1c  */
{0x2a, 0x15, 0x3f},          /* index 1d  */
{0x2a, 0x3f, 0x15},          /* index 1e  */
{0x2a, 0x3f, 0x3f},          /* index 1f  */
{0x15, 0x00, 0x00},          /* index 20  */
{0x15, 0x00, 0x2a},          /* index 21  */
{0x15, 0x2a, 0x00},          /* index 22  */
{0x15, 0x2a, 0x2a},          /* index 23  */
{0x3f, 0x00, 0x00},          /* index 24  */
{0x3f, 0x00, 0x2a},          /* index 25  */
{0x3f, 0x2a, 0x00},          /* index 26  */
{0x3f, 0x2a, 0x2a},          /* index 27  */
{0x15, 0x00, 0x15},          /* index 28  */
{0x15, 0x00, 0x3f},          /* index 29  */
{0x15, 0x2a, 0x15},          /* index 2a  */
{0x15, 0x2a, 0x3f},          /* index 2b  */
{0x3f, 0x00, 0x15},          /* index 2c  */
{0x3f, 0x00, 0x3f},          /* index 2d  */
{0x3f, 0x2a, 0x15},          /* index 2e  */
{0x3f, 0x2a, 0x3f},          /* index 2f  */
{0x15, 0x15, 0x00},          /* index 30  */
{0x15, 0x15, 0x2a},          /* index 31  */
{0x15, 0x3f, 0x00},          /* index 32  */
{0x15, 0x3f, 0x2a},          /* index 33  */
{0x3f, 0x15, 0x00},          /* index 34  */
{0x3f, 0x15, 0x2a},          /* index 35  */
{0x3f, 0x3f, 0x00},          /* index 36  */
{0x3f, 0x3f, 0x2a},          /* index 37  */
{0x15, 0x15, 0x15},          /* index 38  */
{0x15, 0x15, 0x3f},          /* index 39  */
{0x15, 0x3f, 0x15},          /* index 3a  */
{0x15, 0x3f, 0x3f},          /* index 3b  */
{0x3f, 0x15, 0x15},          /* index 3c  */
{0x3f, 0x15, 0x3f},          /* index 3d  */
{0x3f, 0x3f, 0x15},          /* index 3e  */
{0x3f, 0x3f, 0x3f},          /* index 3f  */
{0x00, 0x00, 0x00},          /* index 40  */
{0x00, 0x00, 0x00},          /* index 41  */
{0x00, 0x00, 0x00},          /* index 42  */
{0x00, 0x00, 0x00},          /* index 43  */
{0x00, 0x00, 0x00},          /* index 44  */
{0x00, 0x00, 0x00},          /* index 45  */
{0x00, 0x00, 0x00},          /* index 46  */
{0x00, 0x00, 0x00},          /* index 47  */
{0x00, 0x00, 0x00},          /* index 48  */
{0x00, 0x00, 0x00},          /* index 49  */
{0x00, 0x00, 0x00},          /* index 4a  */
{0x00, 0x00, 0x00},          /* index 4b  */
{0x00, 0x00, 0x00},          /* index 4c  */
{0x00, 0x00, 0x00},          /* index 4d  */
{0x00, 0x00, 0x00},          /* index 4e  */
{0x00, 0x00, 0x00},          /* index 4f  */
{0x00, 0x00, 0x00},          /* index 50  */
{0x00, 0x00, 0x00},          /* index 51  */
{0x00, 0x00, 0x00},          /* index 52  */
{0x00, 0x00, 0x00},          /* index 53  */
{0x00, 0x00, 0x00},          /* index 54  */
{0x00, 0x00, 0x00},          /* index 55  */
{0x00, 0x00, 0x00},          /* index 56  */
{0x00, 0x00, 0x00},          /* index 57  */
{0x00, 0x00, 0x00},          /* index 58  */
{0x00, 0x00, 0x00},          /* index 59  */
{0x00, 0x00, 0x00},          /* index 5a  */
{0x00, 0x00, 0x00},          /* index 5b  */
{0x00, 0x00, 0x00},          /* index 5c  */
{0x00, 0x00, 0x00},          /* index 5d  */
{0x00, 0x00, 0x00},          /* index 5e  */
{0x00, 0x00, 0x00},          /* index 5f  */
{0x00, 0x00, 0x00},          /* index 60  */
{0x00, 0x00, 0x00},          /* index 61  */
{0x00, 0x00, 0x00},          /* index 62  */
{0x00, 0x00, 0x00},          /* index 63  */
{0x00, 0x00, 0x00},          /* index 64  */
{0x00, 0x00, 0x00},          /* index 65  */
{0x00, 0x00, 0x00},          /* index 66  */
{0x00, 0x00, 0x00},          /* index 67  */
{0x00, 0x00, 0x00},          /* index 68  */
{0x00, 0x00, 0x00},          /* index 69  */
{0x00, 0x00, 0x00},          /* index 6a  */
{0x00, 0x00, 0x00},          /* index 6b  */
{0x00, 0x00, 0x00},          /* index 6c  */
{0x00, 0x00, 0x00},          /* index 6d  */
{0x00, 0x00, 0x00},          /* index 6e  */
{0x00, 0x00, 0x00},          /* index 6f  */
{0x00, 0x00, 0x00},          /* index 70  */
{0x00, 0x00, 0x00},          /* index 71  */
{0x00, 0x00, 0x00},          /* index 72  */
{0x00, 0x00, 0x00},          /* index 73  */
{0x00, 0x00, 0x00},          /* index 74  */
{0x00, 0x00, 0x00},          /* index 75  */
{0x00, 0x00, 0x00},          /* index 76  */
{0x00, 0x00, 0x00},          /* index 77  */
{0x00, 0x00, 0x00},          /* index 78  */
{0x00, 0x00, 0x00},          /* index 79  */
{0x00, 0x00, 0x00},          /* index 7a  */
{0x00, 0x00, 0x00},          /* index 7b  */
{0x00, 0x00, 0x00},          /* index 7c  */
{0x00, 0x00, 0x00},          /* index 7d  */
{0x00, 0x00, 0x00},          /* index 7e  */
{0x00, 0x00, 0x00},          /* index 7f  */
{0x00, 0x00, 0x00},          /* index 80  */
{0x00, 0x00, 0x00},          /* index 81  */
{0x00, 0x00, 0x00},          /* index 82  */
{0x00, 0x00, 0x00},          /* index 83  */
{0x00, 0x00, 0x00},          /* index 84  */
{0x00, 0x00, 0x00},          /* index 85  */
{0x00, 0x00, 0x00},          /* index 86  */
{0x00, 0x00, 0x00},          /* index 87  */
{0x00, 0x00, 0x00},          /* index 88  */
{0x00, 0x00, 0x00},          /* index 89  */
{0x00, 0x00, 0x00},          /* index 8a  */
{0x00, 0x00, 0x00},          /* index 8b  */
{0x00, 0x00, 0x00},          /* index 8c  */
{0x00, 0x00, 0x00},          /* index 8d  */
{0x00, 0x00, 0x00},          /* index 8e  */
{0x00, 0x00, 0x00},          /* index 8f  */
{0x00, 0x00, 0x00},          /* index 90  */
{0x00, 0x00, 0x00},          /* index 91  */
{0x00, 0x00, 0x00},          /* index 92  */
{0x00, 0x00, 0x00},          /* index 93  */
{0x00, 0x00, 0x00},          /* index 94  */
{0x00, 0x00, 0x00},          /* index 95  */
{0x00, 0x00, 0x00},          /* index 96  */
{0x00, 0x00, 0x00},          /* index 97  */
{0x00, 0x00, 0x00},          /* index 98  */
{0x00, 0x00, 0x00},          /* index 99  */
{0x00, 0x00, 0x00},          /* index 9a  */
{0x00, 0x00, 0x00},          /* index 9b  */
{0x00, 0x00, 0x00},          /* index 9c  */
{0x00, 0x00, 0x00},          /* index 9d  */
{0x00, 0x00, 0x00},          /* index 9e  */
{0x00, 0x00, 0x00},          /* index 9f  */
{0x00, 0x00, 0x00},          /* index a0  */
{0x00, 0x00, 0x00},          /* index a1  */
{0x00, 0x00, 0x00},          /* index a2  */
{0x00, 0x00, 0x00},          /* index a3  */
{0x00, 0x00, 0x00},          /* index a4  */
{0x00, 0x00, 0x00},          /* index a5  */
{0x00, 0x00, 0x00},          /* index a6  */
{0x00, 0x00, 0x00},          /* index a7  */
{0x00, 0x00, 0x00},          /* index a8  */
{0x00, 0x00, 0x00},          /* index a9  */
{0x00, 0x00, 0x00},          /* index aa  */
{0x00, 0x00, 0x00},          /* index ab  */
{0x00, 0x00, 0x00},          /* index ac  */
{0x00, 0x00, 0x00},          /* index ad  */
{0x00, 0x00, 0x00},          /* index ae  */
{0x00, 0x00, 0x00},          /* index af  */
{0x00, 0x00, 0x00},          /* index b0  */
{0x00, 0x00, 0x00},          /* index b1  */
{0x00, 0x00, 0x00},          /* index b2  */
{0x00, 0x00, 0x00},          /* index b3  */
{0x00, 0x00, 0x00},          /* index b4  */
{0x00, 0x00, 0x00},          /* index b5  */
{0x00, 0x00, 0x00},          /* index b6  */
{0x00, 0x00, 0x00},          /* index b7  */
{0x00, 0x00, 0x00},          /* index b8  */
{0x00, 0x00, 0x00},          /* index b9  */
{0x00, 0x00, 0x00},          /* index ba  */
{0x00, 0x00, 0x00},          /* index bb  */
{0x00, 0x00, 0x00},          /* index bc  */
{0x00, 0x00, 0x00},          /* index bd  */
{0x00, 0x00, 0x00},          /* index be  */
{0x00, 0x00, 0x00},          /* index bf  */
{0x00, 0x00, 0x00},          /* index c0  */
{0x00, 0x00, 0x00},          /* index c1  */
{0x00, 0x00, 0x00},          /* index c2  */
{0x00, 0x00, 0x00},          /* index c3  */
{0x00, 0x00, 0x00},          /* index c4  */
{0x00, 0x00, 0x00},          /* index c5  */
{0x00, 0x00, 0x00},          /* index c6  */
{0x00, 0x00, 0x00},          /* index c7  */
{0x00, 0x00, 0x00},          /* index c8  */
{0x00, 0x00, 0x00},          /* index c9  */
{0x00, 0x00, 0x00},          /* index ca  */
{0x00, 0x00, 0x00},          /* index cb  */
{0x00, 0x00, 0x00},          /* index cc  */
{0x00, 0x00, 0x00},          /* index cd  */
{0x00, 0x00, 0x00},          /* index ce  */
{0x00, 0x00, 0x00},          /* index cf  */
{0x00, 0x00, 0x00},          /* index d0  */
{0x00, 0x00, 0x00},          /* index d1  */
{0x00, 0x00, 0x00},          /* index d2  */
{0x00, 0x00, 0x00},          /* index d3  */
{0x00, 0x00, 0x00},          /* index d4  */
{0x00, 0x00, 0x00},          /* index d5  */
{0x00, 0x00, 0x00},          /* index d6  */
{0x00, 0x00, 0x00},          /* index d7  */
{0x00, 0x00, 0x00},          /* index d8  */
{0x00, 0x00, 0x00},          /* index d9  */
{0x00, 0x00, 0x00},          /* index da  */
{0x00, 0x00, 0x00},          /* index db  */
{0x00, 0x00, 0x00},          /* index dc  */
{0x00, 0x00, 0x00},          /* index dd  */
{0x00, 0x00, 0x00},          /* index de  */
{0x00, 0x00, 0x00},          /* index df  */
{0x00, 0x00, 0x00},          /* index e0  */
{0x00, 0x00, 0x00},          /* index e1  */
{0x00, 0x00, 0x00},          /* index e2  */
{0x00, 0x00, 0x00},          /* index e3  */
{0x00, 0x00, 0x00},          /* index e4  */
{0x00, 0x00, 0x00},          /* index e5  */
{0x00, 0x00, 0x00},          /* index e6  */
{0x00, 0x00, 0x00},          /* index e7  */
{0x00, 0x00, 0x00},          /* index e8  */
{0x00, 0x00, 0x00},          /* index e9  */
{0x00, 0x00, 0x00},          /* index ea  */
{0x00, 0x00, 0x00},          /* index eb  */
{0x00, 0x00, 0x00},          /* index ec  */
{0x00, 0x00, 0x00},          /* index ed  */
{0x00, 0x00, 0x00},          /* index ee  */
{0x00, 0x00, 0x00},          /* index ef  */
{0x00, 0x00, 0x00},          /* index f0  */
{0x00, 0x00, 0x00},          /* index f1  */
{0x00, 0x00, 0x00},          /* index f2  */
{0x00, 0x00, 0x00},          /* index f3  */
{0x00, 0x00, 0x00},          /* index f4  */
{0x00, 0x00, 0x00},          /* index f5  */
{0x00, 0x00, 0x00},          /* index f6  */
{0x00, 0x00, 0x00},          /* index f7  */
{0x00, 0x00, 0x00},          /* index f8  */
{0x00, 0x00, 0x00},          /* index f9  */
{0x00, 0x00, 0x00},          /* index fa  */
{0x00, 0x00, 0x00},          /* index fb  */
{0x00, 0x00, 0x00},          /* index fc  */
{0x00, 0x00, 0x00},          /* index fd  */
{0x00, 0x00, 0x00},          /* index fe  */
{0x00, 0x00, 0x00}       /* index ff  */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\sxci_nt.c ===
/**************************************************************************\

$Header: o:\src/RCS/SXCI_NT.C 1.3 93/12/20 11:38:48 jyharbec Exp $

$Log:	SXCI_NT.C $
 * Revision 1.3  93/12/20  11:38:48  jyharbec
 * Added VerifyAccessRanges in setmgasel.
 * 
 * Revision 1.2  93/11/04  04:56:24  dlee
 * Modified for Alpha
 * 
 * Revision 1.1  93/08/27  12:37:38  jyharbec
 * Initial revision
 * 

\**************************************************************************/


/*/****************************************************************************
*          name: sxci_nt.c
*
*   description: Initialization routines specific to Windows NT.
*
*      designed:
* last modified: dlee
*
*       version: 1.0
*
*    parameters: -
*      modifies: -
*         calls: -
*       returns: -
******************************************************************************/

#include    "switches.h"
#include    "video.h"

/*** Global variables ***/
SHORT wSelector;
extern  PVOID          pMgaDeviceExtension;

/*** Internal prototypes ***/
VOID    _mtxSetSelector (SHORT wSel);
PVOID   setmgasel (LONG *pBoardSel, LONG dwBaseAddress, SHORT wNumPages);
PVOID   setmgaselNoV (LONG *pBoardSel, LONG dwBaseAddress, SHORT wNumPages);
PVOID   getmgasel (void);
PVOID   AllocateSystemMemory(ULONG NumberOfBytes);
BOOLEAN bConflictDetected(ULONG ulAddressToVerify);

#if defined(ALLOC_PRAGMA)
//    #pragma alloc_text(PAGE,setmgasel)
//    #pragma alloc_text(PAGE,getmgasel)
    #pragma alloc_text(PAGE,_mtxSetSelector)
    #pragma alloc_text(PAGE,AllocateSystemMemory)
    #pragma alloc_text(PAGE,bConflictDetected)
#endif

//#if defined(ALLOC_PRAGMA)
//    #pragma data_seg("PAGE")
//#endif

// Structure to be filled out and used by setmgasel.  Just modify the
// 0xffffffff fields.

VIDEO_ACCESS_RANGE MgaSelAccessRange =
    {0xffffffff, 0x00000000, 0xffffffff, 0, 0, 0};

/*-----------------------------------------------------
* setmgasel
*
* This function returns a far pointer to the physical address
*
* Return: (ptr)  = 0 : No valid pointer
*         (ptr) != 0 : Pointer to board 
*-----------------------------------------------------*/

PVOID setmgasel (LONG *pBoardSel, LONG dwBaseAddress, SHORT wNumPages)
{
    PHYSICAL_ADDRESS    paTemp;

    paTemp.HighPart = 0;
    paTemp.LowPart  = dwBaseAddress;
    if (dwBaseAddress == 0xAC000)
    {
        MgaSelAccessRange.RangeShareable = 1;
    }
    else
    {
        MgaSelAccessRange.RangeShareable = 0;
    }

    MgaSelAccessRange.RangeStart.LowPart = dwBaseAddress;
    MgaSelAccessRange.RangeLength = wNumPages * (4*1024);

    if (VideoPortVerifyAccessRanges(pMgaDeviceExtension,
                                    1,
                                    &MgaSelAccessRange) == NO_ERROR)
    {
        return(VideoPortGetDeviceBase(pMgaDeviceExtension, paTemp,
                                                wNumPages * (4*1024), 0));
    }
    else
    {
        return(NULL);
    }
}

/*-----------------------------------------------------
* setmgaselNoV
*
* This function returns a far pointer to the physical address
*
* Return: (ptr)  = 0 : No valid pointer
*         (ptr) != 0 : Pointer to board 
*-----------------------------------------------------*/

PVOID setmgaselNoV (LONG *pBoardSel, LONG dwBaseAddress, SHORT wNumPages)
{
    PHYSICAL_ADDRESS    paTemp;

    paTemp.HighPart = 0;
    paTemp.LowPart  = dwBaseAddress;

    return(VideoPortGetDeviceBase(pMgaDeviceExtension, paTemp,
                                                wNumPages * (4*1024), 0));
}

/*-----------------------------------------------------
* getmgasel
*
* This function returns a far pointer to the physical address
*
* Return: (ptr)  = 0 : No valid pointer
*         (ptr) != 0 : Pointer to board 
*-----------------------------------------------------*/

PVOID getmgasel (void)
{
   return (NULL);
}

/*-----------------------------------------------------
* _mtxSetSelector
*
* This function gets a valid selector 
*
* Return: nothing
*-----------------------------------------------------*/

void _mtxSetSelector (SHORT wSel)
{
   wSelector = wSel;
}


/*--------------------------------------------------------------------------*\
| AllocateSystemMemory
|
|
|
\*--------------------------------------------------------------------------*/
PVOID AllocateSystemMemory(ULONG NumberOfBytes)
{

    PVOID pBuf;

    if(VideoPortAllocateBuffer(pMgaDeviceExtension, NumberOfBytes, &pBuf) == NO_ERROR)
        return(pBuf);
    else
        return(NULL);
}


/*--------------------------------------------------------------------------*\
| bConflictDetected
|
| Checks to see if another driver has already mapped something at
| ulAddressToVerify
|
| Returns: TRUE if this area has already been mapped.
|          FALSE otherwise.
\*--------------------------------------------------------------------------*/
BOOLEAN bConflictDetected(ULONG ulAddressToVerify)
{
    VIDEO_ACCESS_RANGE   varTemp;

    varTemp.RangeStart.HighPart = 0;
    varTemp.RangeStart.LowPart  = ulAddressToVerify;
    varTemp.RangeLength         = 0x00004000;
    varTemp.RangeInIoSpace      = 0;
    varTemp.RangeVisible        = 0;
    varTemp.RangeShareable      = 1;

    if (VideoPortVerifyAccessRanges(pMgaDeviceExtension, 1, &varTemp)
           != NO_ERROR)
        {
        VideoDebugPrint((1, "MGA.SYS!Someone is using 0x%x\n", ulAddressToVerify));
        return(TRUE);
        }

    // No conflict, return false.
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\tables.c ===
/**************************************************************************\

$Header: r:rcs\TABLES.C 1.2 94/09/16 05:28:50 bleblanc Exp $

$Log:	TABLES.C $
 * Revision 1.2  94/09/16  05:28:50  bleblanc
 * modes 0,Z en 8-bit avec PCI_2M enleves
 *
 * Revision 1.1  94/08/22  05:44:29  bleblanc
 * Initial revision
 *

\**************************************************************************/


/*/****************************************************************************
*          name: tables.c
*
*   description: Offscreens and hardware modes definitions
*
*      designed: Benoit Leblanc
* last modified: $Author: bleblanc $
*
*       version: $Id: TABLES.C 1.2 94/09/16 05:28:50 bleblanc Exp $
*
******************************************************************************/

#include "switches.h"
#include "bind.h"
#include "defbind.h"

#ifdef WINDOWS_NT
    #if defined(ALLOC_PRAGMA)
    #pragma data_seg("PAGE")
    #endif
#endif

#define N_VRAM     0    /* normal off screen memory in VRAM, supports block mode */
#define N_DRAM     6    /* normal off screen memory in DRAM, no block mode */
#define Z_VRAM     1    /* z-buffer memory in VRAM, supports block mode */
#define Z_DRAM     7    /* z-buffer memory in DRAM, no block mode */
#define DB_VRAM    8

#define Z          1    /* Z-buffer available */
#define ND      0xc0    /* Not displayable , hw limited */
#define TV      0x02    /* TV Mode */
#define LUT     0x04    /* LUT mode (pseudo color) */
#define M565    0x08    /* Mode 565 XGA */
#define DB      0x10





/* OFFSCREENS DEFINITION */


/*------------------*/
/*** MGA-ULT/ 1Mb ***/
/*------------------*/

OffScrData OffScrFBM_000_A[] = {
/* 640x480/8 */
       N_VRAM, 0,  480, 640, 1158, 0x000000ff, 0,
/* 640x480/16 */
       N_VRAM, 0,  480, 640,  339, 0x0000ffff, 0,
/* 768x576/8 */
       N_VRAM, 0,  576, 768,  789, 0x000000ff, 0,
/* 768x576/16 */
       N_VRAM, 0,  576, 768,  106, 0x0000ffff, 0,
/* 800x600/8 */
       N_VRAM, 0,  600, 800,  710, 0x000000ff, 0,
/* 800x600/16 */
       N_VRAM, 0,  600, 800,   55, 0x0000ffff, 0,
/* 1024x768/8 */
       N_VRAM, 0,  768, 1024, 256, 0x000000ff, 0,
/* 1152x882/8 */
       N_VRAM, 0,  882, 1152,  28, 0x000000ff, 0,
};




/*----------------------------*/
/*** MGA-ULT/ 1Mb INTERLACE ***/
/*----------------------------*/

OffScrData iOffScrFBM_000_A[] = {
/* 640x480/8 */
       N_VRAM,   0,  480,  768,  885, 0x000000ff, 0,
       N_VRAM, 640,    0,  128,  480, 0x000000ff, 0,
/* 640x480/16 */
       N_VRAM,   0,  480,  768,  202, 0x0000ffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x0000ffff, 0,
/* 800x600/8 */
       N_VRAM,   0,  600, 1024,  424, 0x000000ff, 0,
       N_VRAM, 800,    0,  224,  600, 0x000000ff, 0,
};




/*------------------------*/
/*** MGA-ULT/ 2Mb TITAN ***/
/*------------------------*/

OffScrData OffScrFBM_010_A[] = {
/* 640x480/8   */
       N_VRAM, 0,  480,  640, 2796, 0x000000ff, 0,
/* 640x480/16  */
       N_VRAM, 0,  480,  640, 1158, 0x0000ffff, 0,
/* 640x480/32  */
       N_VRAM, 0,  480,  640,  339, 0xffffffff, 0,
       N_VRAM, 0,    0,  640,  480, 0xff000000, 0,
/* 768x576/8   */
       N_VRAM, 0,  576,  768, 2154, 0x000000ff, 0,
/* 768x576/16  */
       N_VRAM, 0,  576,  768,  789, 0x0000ffff, 0,
/* 768x576/32  */
       N_VRAM, 0,  576,  768,  106, 0xffffffff, 0,
       N_VRAM, 0,    0,  768,  576, 0xff000000, 0,
/* 800x600/8   */
       N_VRAM, 0,  600,  800, 2021, 0x000000ff, 0,
/* 800x600/16  */
       N_VRAM, 0,  600,  800,  710, 0x0000ffff, 0,
/* 800x600/32  */
       N_VRAM, 0,  600,  800,   55, 0xffffffff, 0,
       N_VRAM, 0,    0,  800,  600, 0xff000000, 0,
/* 1024x768/8  */
       N_VRAM, 0,  768, 1024, 1280, 0x000000ff, 0,
/* 1024x768/16 */
       N_VRAM, 0,  768, 1024,  256, 0x0000ffff, 0,
/* 1152x882/8  */
       N_VRAM, 0,  882, 1152,  938, 0x000000ff, 0,
/* 1152x882/16 */
       N_VRAM, 0,  882, 1152,   28, 0x0000ffff, 0,
/* 1280x1024/8 */
       N_VRAM, 0, 1024, 1280,  614, 0x000000ff, 0,
/* 1600x1200/8 */
       N_VRAM, 0, 1200, 1600,  110, 0x000000ff, 0
};




/*------------------------------*/
/*** MGA-ULT/ 2Mb INTERLACE   ***/
/*------------------------------*/

OffScrData iOffScrFBM_010_A[] = {
/* 640x480/8   */
       N_VRAM,   0,  480,  768, 2250, 0x000000ff, 0,
       N_VRAM, 640,    0,  128,  480, 0x000000ff, 0,
/* 640x480/16  */
       N_VRAM,   0,  480,  768,  885, 0x0000ffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x0000ffff, 0,
/* 640x480/32  */
       N_VRAM,   0,  480,  768,  202, 0xffffffff, 0,
       N_VRAM, 640,    0,  128,  480, 0xffffffff, 0,
       N_VRAM,   0,    0,  640,  480, 0xff000000, 0,
/* 800x600/8   */
       N_VRAM,   0,  600, 1024, 1448, 0x000000ff, 0,
       N_VRAM, 800,    0,  224,  600, 0x000000ff, 0,
/* 800x600/16  */
       N_VRAM,   0,  600, 1024,  424, 0x0000ffff, 0,
       N_VRAM, 800,    0,  224,  600, 0x0000ffff, 0,
/* 1152x882/8  */
       N_VRAM,   0,  882, 1280,  756, 0x000000ff, 0,
       N_VRAM,1152,    0,  128,  882, 0x000000ff, 0,
};


/*------------------*/
/*** MGA-IMP/ 3Mb ***/
/*------------------*/

OffScrData OffScrFBM_010_B[] = {
/* 640x480/8   */
       N_VRAM, 0,  480,  640, 4435, 0x000000ff, 0,
/* 640x480/8Z  */
       N_VRAM, 0,  480,  640, 2796, 0x000000ff, 0,
       Z_VRAM, 0, 3276,  640,  960, 0x000000ff, 512,
       N_VRAM, 0, 4237,  640,  678, 0x000000ff, 0,
/* 640x480/16  */
       N_VRAM, 0,  480,  640, 1977, 0x0000ffff, 0,
/* 640x480/16Z */
       N_VRAM, 0,  480,  640, 1158, 0x0000ffff, 0,
       Z_VRAM, 0, 1638,  640,  480, 0x0000ffff, 256,
       N_VRAM, 0, 2119,  640,  338, 0x0000ffff, 0,
/* 640x480/32  */
       N_VRAM, 0,  480,  640,  748, 0xffffffff, 0,
       N_VRAM, 0,    0,  640,  480, 0xff000000, 0,
/* 640x480/32Z */
       N_VRAM, 0,  480,  640,  339, 0xffffffff, 0,
       Z_VRAM, 0,  819,  640,  240, 0xffffffff, 128,
       N_VRAM, 0, 1060,  640,  168, 0xffffffff, 0,
       N_VRAM, 0,    0,  640,  480, 0xff000000, 0,
/* 768x576/8   */
       N_VRAM, 0,  576,  768, 3520, 0x000000ff, 0,
/* 768x576/8Z  */
       N_VRAM, 0,  576,  768, 2154, 0x000000ff, 0,
       Z_VRAM, 0, 2730,  768, 1152, 0x000000ff, 512,
       N_VRAM, 0, 3883,  768,  213, 0x000000ff, 0,
/* 768x576/16  */
       N_VRAM, 0,  576,  768, 1472, 0x0000ffff, 0,
/* 768x576/16Z */
       N_VRAM, 0,  576,  768,  789, 0x0000ffff, 0,
       Z_VRAM, 0, 1365,  768,  576, 0x0000ffff, 256,
       N_VRAM, 0, 1942,  768,  106, 0x0000ffff, 0,
/* 768x576/32  */
       N_VRAM, 0,  576,  768,  448, 0xffffffff, 0,
       N_VRAM, 0,    0,  768,  576, 0xff000000, 0,
/* 768x576/32Z */
       Z_VRAM, 0,  682,  768,  288, 0xffffffff, 512,
       N_VRAM, 0,  576,  768,  106, 0xffffffff, 0,
       N_VRAM, 0,  971,  768,   53, 0xffffffff, 0,
       N_VRAM, 0,    0,  768,  576, 0xff000000, 0,
/* 800x600/8   */
       N_VRAM, 0,  600,  800, 3332, 0x000000ff, 0,
/* 800x600/8Z  */
       N_VRAM, 0,  600,  800, 2021, 0x000000ff, 0,
       Z_VRAM, 0, 2621,  800, 1200, 0x000000ff, 352,
       N_VRAM, 0, 3822,  800,  110, 0x000000ff, 0,
/* 800x600/16  */
       N_VRAM, 0,  600,  800, 1366, 0x0000ffff, 0,
/* 800x600/16Z */
       N_VRAM, 0,  600,  800,  710, 0x0000ffff, 0,
       Z_VRAM, 0, 1310,  800,  600, 0x0000ffff, 576,
       N_VRAM, 0, 1911,  800,   55, 0x0000ffff, 0,
/* 800x600/32  */
       N_VRAM, 0,  600,  800,  383, 0xffffffff, 0,
       N_VRAM, 0,    0,  800,  600, 0xff000000, 0,
/* 800x600/32Z */
       Z_VRAM, 0,  655,  800,  300, 0xffffffff, 288,
       N_VRAM, 0,  600,  800,   55, 0xffffffff, 0,
       N_VRAM, 0,  956,  800,   27, 0xffffffff, 0,
       N_VRAM, 0,    0,  800,  600, 0xff000000, 0,
/* 1024x768/8  */
       N_VRAM, 0,  768, 1024, 2304, 0x000000ff, 0,
/* 1024x768/16 */
       N_VRAM, 0,  768, 1024,  768, 0x0000ffff, 0,
/* 1024x768/32 */
       N_VRAM, 0,    0, 1024,  768, 0xff000000, 0,
/* 1152x882/8  */
       N_VRAM, 0,  882, 1152, 1848, 0x000000ff, 0,
/* 1152x882/16 */
       N_VRAM, 0,  882, 1152,  483, 0x0000ffff, 1,
/* 1280x1024/8 */
       N_VRAM, 0, 1024, 1280, 1433, 0x000000ff, 0,
/* 1280x1024/16 */
       N_VRAM, 0, 1024, 1280,  204, 0x0000ffff, 1,
/* 1600x1200/8 */
       N_VRAM, 0, 1200, 1600,  766, 0x000000ff, 1
};

/*----------------------------*/
/*** MGA-IMP/ 3Mb INTERLACE ***/
/*----------------------------*/

OffScrData iOffScrFBM_010_B[] = {
/* 640x480/8   */
       N_VRAM,   0,  480,  768, 3616, 0x000000ff, 0,
       N_VRAM, 640,    0,  128,  480, 0x000000ff, 0,
/* 640x480/8Z  */
       N_VRAM,   0,  480,  768, 2250, 0x000000ff, 0,
       Z_VRAM,   0, 2730,  768,  800, 0x000000ff, 512,
       N_VRAM,   0, 3531,  768,  565, 0x000000ff, 0,
       N_VRAM, 640,    0,  128,  480, 0x000000ff, 0,
/* 640x480/16  */
       N_VRAM,   0,  480,  768, 1568, 0x0000ffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x0000ffff, 0,
/* 640x480/16Z */
       N_VRAM,   0,  480,  768,  885, 0x0000ffff, 0,
       Z_VRAM,   0, 1365,  768,  400, 0x0000ffff, 256,
       N_VRAM,   0, 1766,  768,  282, 0x0000ffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x0000ffff, 0,
/* 640x480/32  */
       N_VRAM,   0,  480,  768,  544, 0xffffffff, 0,
       N_VRAM, 640,    0,  128,  480, 0xffffffff, 0,
       N_VRAM,   0,    0,  640,  480, 0xff000000, 0,
/* 640x480/32Z */
       N_VRAM,   0,  480,  768,  202, 0xffffffff, 0,
       Z_VRAM,   0,  682,  768,  200, 0xffffffff, 512,
       N_VRAM,   0,  883,  768,  141, 0xffffffff, 0,
       N_VRAM, 640,    0,  128,  480, 0xffffffff, 0,
       N_VRAM,   0,    0,  640,  480, 0xff000000, 0,
/* 800x600/8   */
       N_VRAM,   0,  480, 1024, 2472, 0x000000ff, 0,
       N_VRAM, 800,    0,  224,  600, 0x000000ff, 0,
/* 800x600/8Z  */
       N_VRAM,   0,  600, 1024, 1448, 0x000000ff, 0,
       Z_VRAM,   0, 2048, 1024,  937, 0x000000ff, 0,
       N_VRAM,   0, 2986, 1024,   86, 0x000000ff, 0,
       N_VRAM, 800,    0,  224,  600, 0x000000ff, 0,
/* 800x600/16  */
       N_VRAM,   0,  600, 1024,  936, 0x0000ffff, 0,
       N_VRAM, 800,    0,  224,  600, 0x0000ffff, 0,
/* 800x600/16Z */
       Z_VRAM,   0, 1024, 1024,  468, 0x0000ffff, 0,
       N_VRAM,   0,  600, 1024,  424, 0x0000ffff, 0,
       N_VRAM,   0, 1493, 1024,   43, 0x0000ffff, 0,
       N_VRAM, 800,    0,  224,  600, 0x0000ffff, 0,
/* 800x600/32  */
       N_VRAM,   0,  600, 1024,  168, 0xffffffff, 0,
       N_VRAM, 800,    0,  224,  600, 0xffffffff, 0,
       N_VRAM,   0,    0,  800,  600, 0xff000000, 0,
/* 1152x882/8  */
       N_VRAM,   0,  882, 1280, 1575, 0x000000ff, 0,
       N_VRAM,1152,    0,  128,  882, 0x000000ff, 0,
/* 1152x882/16 */
       N_VRAM,   0,  882, 1280,  346, 0x0000ffff, 0,
       N_VRAM,1152,    0,  128,  882, 0x0000ffff, 0
};


/*-------------------------*/
/*** MGA-IMP/ 3Mb with Z ***/
/*-------------------------*/

OffScrData OffScrFBM_011_A[] = {
/* 640x480/8   */
       N_VRAM, 0,  480,  640, 3616, 0x000000ff, 0,
       N_DRAM, 0, 6554,  640, 3276, 0x000000ff, 0,
       N_VRAM, 0, 9831,  640,  818, 0x000000ff, 0,
/* 640x480/8Z  */
       N_VRAM, 0,  480,  640, 3616, 0x000000ff, 0,
       N_DRAM, 0, 7514,  640, 2316, 0x000000ff, 0,
       Z_DRAM, 0, 6553,  640,  960, 0x000000ff, 384,
       N_VRAM, 0, 9831,  640,  818, 0x000000ff, 0,
/* 640x480/16  */
       N_DRAM, 0, 3277,  640, 1638, 0x0000ffff, 0,
       N_VRAM, 0,  480,  640, 1568, 0x0000ffff, 0,
       N_VRAM, 0, 4916,  640,  408, 0x0000ffff, 0,
/* 640x480/16Z */
       N_VRAM, 0,  480,  640, 1568, 0x0000ffff, 0,
       N_DRAM, 0, 3757,  640, 1158, 0x0000ffff, 0,
       Z_DRAM, 0, 3276,  640,  480, 0x0000ffff, 512,
       N_VRAM, 0, 4916,  640,  408, 0x0000ffff, 0,
/* 640x480/32  */
       N_DRAM, 0, 1639,  640,  818, 0xffffffff, 0,
       N_VRAM, 0,  480,  640,  544, 0xffffffff, 0,
       N_VRAM, 0, 2458,  640,  204, 0xffffffff, 0,
       N_VRAM, 0,    0,  640,  480, 0xff000000, 0,
/* 640x480/32Z */
       N_DRAM, 0, 1879,  640,  578, 0xffffffff, 0,
       N_VRAM, 0,  480,  640,  544, 0xffffffff, 0,
       Z_DRAM, 0, 1638,  640,  240, 0xffffffff, 256,
       N_VRAM, 0, 2458,  640,  204, 0xffffffff, 0,
       N_VRAM, 0,    0,  640,  480, 0xff000000, 0,
/* 768x576/8   */
       N_VRAM, 0,  576,  768, 2837, 0x000000ff, 0,
       N_DRAM, 0, 5462,  768, 2730, 0x000000ff, 0,
       N_VRAM, 0, 8192,  768,  682, 0x000000ff, 0,
/* 768x576/8Z  */
       N_VRAM, 0,  576,  768, 2837, 0x000000ff, 0,
       N_DRAM, 0, 6614,  768, 1578, 0x000000ff, 0,
       Z_DRAM, 0, 5461,  768, 1152, 0x000000ff, 256,
       N_VRAM, 0, 8192,  768,  682, 0x000000ff, 0,
/* 768x576/16  */
       N_DRAM, 0, 2731,  768, 1365, 0x0000ffff, 0,
       N_VRAM, 0,  576,  768, 1130, 0x0000ffff, 0,
       N_VRAM, 0, 4096,  768,  341, 0x0000ffff, 0,
/* 768x576/16Z */
       N_VRAM, 0,  576,  768, 1130, 0x0000ffff, 0,
       N_DRAM, 0, 3307,  768,  789, 0x0000ffff, 0,
       Z_DRAM, 0, 2730,  768,  576, 0x0000ffff, 512,
       N_VRAM, 0, 4096,  768,  341, 0x0000ffff, 0,
/* 768x576/32  */
       N_DRAM, 0, 1366,  768,  682, 0xffffffff, 0,
       N_VRAM, 0,  576,  768,  277, 0xffffffff, 0,
       N_VRAM, 0, 2048,  768,  170, 0xffffffff, 0,
       N_VRAM, 0,    0,  768,  576, 0xff000000, 0,
/* 768x576/32Z */
       N_DRAM, 0, 1654,  768,  394, 0xffffffff, 0,
       Z_DRAM, 0, 1365,  768,  288, 0xffffffff, 256,
       N_VRAM, 0,  576,  768,  277, 0xffffffff, 0,
       N_VRAM, 0, 2048,  768,  170, 0xffffffff, 0,
       N_VRAM, 0,    0,  768,  576, 0xff000000, 0,
/* 800x600/8   */
       N_VRAM, 0,  600,  800, 2676, 0x000000ff, 0,
       N_DRAM, 0, 5243,  800, 2621, 0x000000ff, 0,
       N_VRAM, 0, 7865,  800,  654, 0x000000ff, 0,
/* 800x600/8Z  */
       N_VRAM, 0,  600,  800, 2676, 0x000000ff, 0,
       N_DRAM, 0, 6443,  800, 1421, 0x000000ff, 0,
       Z_DRAM, 0, 5242,  800, 1200, 0x000000ff, 704,
       N_VRAM, 0, 7865,  800,  654, 0x000000ff, 0,
/* 800x600/16  */
       N_DRAM, 0, 2622,  800, 1310, 0x0000ffff, 0,
       N_VRAM, 0,  600,  800, 1038, 0x0000ffff, 0,
       N_VRAM, 0, 3933,  800,  326, 0x0000ffff, 0,
/* 800x600/16Z */
       N_VRAM, 0,  600,  800, 1038, 0x0000ffff, 0,
       N_DRAM, 0, 3222,  800,  710, 0x0000ffff, 0,
       Z_DRAM, 0, 2621,  800,  600, 0x0000ffff, 352,
       N_VRAM, 0, 3933,  800,  326, 0x0000ffff, 0,
/* 800x600/32  */
       N_DRAM, 0, 1311,  800,  655, 0xffffffff, 0,
       N_VRAM, 0,  600,  800,  219, 0xffffffff, 0,
       N_VRAM, 0, 1967,  800,  162, 0xffffffff, 0,
       N_VRAM, 0,    0,  800,  600, 0xff000000, 0,
/* 800x600/32Z */
       N_DRAM, 0, 1611,  800,  355, 0xffffffff, 0,
       Z_DRAM, 0, 1310,  800,  300, 0xffffffff, 576,
       N_VRAM, 0,  600,  800,  219, 0xffffffff, 0,
       N_VRAM, 0, 1967,  800,  162, 0xffffffff, 0,
       N_VRAM, 0,    0,  800,  600, 0xff000000, 0,
/* 1024x768/8  */
       N_DRAM, 0, 4096, 1024, 2048, 0x000000ff, 0,
       N_VRAM, 0,  768, 1024, 1792, 0x000000ff, 0,
       N_VRAM, 0, 6144, 1024,  512, 0x000000ff, 0,
/* 1024x768/8Z */
       N_VRAM, 0,  768, 1024, 1792, 0x000000ff, 0,
       Z_DRAM, 0, 4096, 1024, 1536, 0x000000ff, 0,
       N_VRAM, 0, 6144, 1024,  512, 0x000000ff, 0,
       N_DRAM, 0, 5632, 1024,  512, 0x000000ff, 0,
/* 1024x768/16 */
       N_DRAM, 0, 2048, 1024, 1024, 0x0000ffff, 0,
       N_VRAM, 0,  768, 1024,  512, 0x0000ffff, 0,
       N_VRAM, 0, 3072, 1024,  256, 0x0000ffff, 0,
/* 1024x768/16Z*/
       Z_DRAM, 0, 2048, 1024,  768, 0x0000ffff, 0,
       N_VRAM, 0,  768, 1024,  512, 0x0000ffff, 0,
       N_VRAM, 0, 3072, 1024,  256, 0x0000ffff, 0,
       N_DRAM, 0, 2816, 1024,  256, 0x0000ffff, 0,
/* 1024x768/32*/
       N_DRAM, 0, 1024, 1024,  512, 0xffffffff, 0,
       N_VRAM, 0,    0, 1024,  768, 0xff000000, 0,
/* 1152x882/8  */
       N_DRAM, 0, 3641, 1152, 1820, 0x000000ff, 0,
       N_VRAM, 0,  882, 1152, 1393, 0x000000ff, 0,
       N_VRAM, 0, 5462, 1152,  454, 0x000000ff, 0,
/* 1152x882/8Z */
       Z_DRAM, 0, 3640, 1152, 1764, 0x000000ff, 1024,
       N_VRAM, 0,  882, 1152, 1393, 0x000000ff, 0,
       N_VRAM, 0, 5462, 1152,  454, 0x000000ff, 0,
       N_DRAM, 0, 5405, 1152,   56, 0x000000ff, 0,
/* 1152x882/16 */
       N_DRAM, 0, 1821, 1152,  909, 0x0000ffff, 0,
       N_VRAM, 0,  882, 1152,  255, 0x0000ffff, 0,
       N_VRAM, 0, 2731, 1152,  227, 0x0000ffff, 0,
/* 1152x882/16Z*/
       Z_DRAM, 0, 1820, 1152,  882, 0x0000ffff, 512,
       N_VRAM, 0,  882, 1152,  255, 0x0000ffff, 0,
       N_VRAM, 0, 2731, 1152,  227, 0x0000ffff, 0,
       N_DRAM, 0, 2703, 1152,   27, 0x0000ffff, 0,
/* 1280x1024/8 */
       N_DRAM, 0, 3277, 1280, 1638, 0x000000ff, 0,
       N_VRAM, 0, 1024, 1280, 1024, 0x000000ff, 0,
       N_VRAM, 0, 4916, 1280,  408, 0x000000ff, 0,
/* 1280x1024/8Z*/
       N_VRAM, 0, 1024, 1280, 1024, 0x000000ff, 0,
/* 1280x1024/16 */
       N_DRAM, 0, 1639, 1280,  818, 0x0000ffff, 0,
       N_VRAM, 0, 2458, 1280,  204, 0x0000ffff, 0,
/* 1280x1024/16Z */
       {(word) -1},
/* 1600x1200/8 */
       N_DRAM, 0, 2622, 1600, 1310, 0x000000ff, 0,
       N_VRAM, 0, 1200, 1600,  438, 0x000000ff, 0,
       N_VRAM, 0, 3933, 1600,  326, 0x000000ff, 0
};


/*------------------------------------*/
/*** MGA-IMP/ 3Mb with Z  INTERLACE ***/
/*------------------------------------*/

OffScrData iOffScrFBM_011_A[] = {
/* 640x480/8   */
       N_VRAM,   0,  480,  768, 2933, 0x000000ff, 0,
       N_DRAM,   0, 5462,  768, 2730, 0x000000ff, 0,
       N_VRAM,   0, 8192,  768,  682, 0x000000ff, 0,
       N_VRAM, 640,    0,  128,  480, 0x000000ff, 0,
/* 640x480/8Z  */
       N_VRAM,   0,  480,  768, 2933, 0x000000ff, 0,
       N_DRAM,   0, 6262,  768, 1930, 0x000000ff, 0,
       Z_DRAM,   0, 5462,  768,  800, 0x000000ff, 256,
       N_VRAM,   0, 8192,  768,  682, 0x000000ff, 0,
       N_VRAM, 640,    0,  128,  480, 0x000000ff, 0,
/* 640x480/16  */
       N_DRAM,   0, 2731,  768, 1365, 0x0000ffff, 0,
       N_VRAM,   0,  480,  768, 1226, 0x0000ffff, 0,
       N_VRAM,   0, 4096,  768,  341, 0x0000ffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x0000ffff, 0,
/* 640x480/16Z */
       N_VRAM,   0,  480,  768, 1226, 0x0000ffff, 0,
       N_DRAM,   0, 3131,  768,  965, 0x0000ffff, 0,
       Z_DRAM,   0, 2731,  768,  400, 0x0000ffff, 512,
       N_VRAM,   0, 4096,  768,  341, 0x0000ffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x0000ffff, 0,
/* 640x480/32  */
       N_DRAM,   0, 1366,  768,  682, 0xffffffff, 0,
       N_VRAM,   0,  480,  768,  373, 0xffffffff, 0,
       N_VRAM,   0, 2048,  768,  170, 0xffffffff, 0,
       N_VRAM, 640,    0,  128,  480, 0xffffffff, 0,
       N_VRAM,   0,    0,  640,  480, 0xff000000, 0,
/* 640x480/32Z */
       N_DRAM,   0, 1566,  768,  482, 0xffffffff, 0,
       N_VRAM,   0,  480,  768,  373, 0xffffffff, 0,
       Z_DRAM,   0, 1365,  768,  200, 0xffffffff, 256,
       N_VRAM,   0, 2048,  768,  170, 0xffffffff, 0,
       N_VRAM, 640,    0,  128,  480, 0xffffffff, 0,
       N_VRAM,   0,    0,  640,  480, 0xff000000, 0,
/* 800x600/8   */
       N_DRAM,   0, 4096, 1024, 2048, 0x000000ff, 0,
       N_VRAM,   0,  600, 1024, 1960, 0x000000ff, 0,
       N_VRAM,   0, 6144, 1024,  512, 0x000000ff, 0,
       N_VRAM, 800,    0,  224,  600, 0x000000ff, 0,
/* 800x600/8Z  */
       N_VRAM,   0,  600, 1024, 1960, 0x000000ff, 0,
       N_DRAM,   0, 5034, 1024, 1110, 0x000000ff, 0,
       Z_DRAM,   0, 4096, 1024,  937, 0x000000ff, 0,
       N_VRAM,   0, 6144, 1024,  512, 0x000000ff, 0,
       N_VRAM, 800,    0,  224,  600, 0x000000ff, 0,
/* 800x600/16  */
       N_DRAM,   0, 2048, 1024, 1024, 0x0000ffff, 0,
       N_VRAM,   0,  600, 1024,  680, 0x0000ffff, 0,
       N_VRAM,   0, 3072, 1024,  256, 0x0000ffff, 0,
       N_VRAM, 800,    0,  224,  600, 0x0000ffff, 0,
/* 800x600/16Z */
       N_VRAM,   0,  600, 1024,  680, 0x0000ffff, 0,
       N_DRAM,   0, 2517, 1024,  555, 0x0000ffff, 0,
       Z_DRAM,   0, 2048, 1024,  468, 0x0000ffff, 0,
       N_VRAM,   0, 3072, 1024,  256, 0x0000ffff, 0,
       N_VRAM, 800,    0,  224,  600, 0x0000ffff, 0,
/* 800x600/32  */
       N_DRAM,   0, 1024, 1024,  512, 0xffffffff, 0,
       N_VRAM,   0, 1536, 1024,  128, 0xffffffff, 0,
       N_VRAM,   0,  600, 1024,   40, 0xffffffff, 0,
       N_VRAM, 800,    0,  224,  600, 0xffffffff, 0,
       N_VRAM,   0,    0,  800,  600, 0xff000000, 0,
/* 800x600/32Z */
       N_DRAM,   0, 1259, 1024,  277, 0xffffffff, 0,
       Z_DRAM,   0, 1024, 1024,  234, 0xffffffff, 0,
       N_VRAM,   0, 1536, 1024,  128, 0xffffffff, 0,
       N_VRAM,   0,  600, 1024,   40, 0xffffffff, 0,
       N_VRAM, 800,    0,  224,  600, 0xffffffff, 0,
       N_VRAM,   0,    0,  800,  600, 0xff000000, 0,
/* 1152x882/8  */
       N_DRAM,   0, 3277, 1280, 1638, 0x000000ff, 0,
       N_VRAM,   0,  882, 1280, 1166, 0x000000ff, 0,
       N_VRAM,   0, 4916, 1280,  408, 0x000000ff, 0,
       N_VRAM,1152,    0,  128,  882, 0x000000ff, 0,
/* 1152x882/8Z */
       Z_DRAM,   0, 2048, 1280, 1587, 0x000000ff, 1024,
       N_VRAM,   0,  882, 1280, 1166, 0x000000ff, 0,
       N_VRAM,   0, 4916, 1280,  408, 0x000000ff, 0,
       N_DRAM,   0, 4865, 1280,   50, 0x000000ff, 0,
       N_VRAM,1152,    0,  128,  882, 0x000000ff, 0,
/* 1152x882/16 */
       N_DRAM,   0, 1639, 1280,  818, 0x0000ffff, 0,
       N_VRAM,   0, 2458, 1280,  204, 0x0000ffff, 0,
       N_VRAM,   0,  882, 1280,  142, 0x0000ffff, 0,
       N_VRAM,1152,    0,  128,  882, 0x0000ffff, 0,
/* 1152x882/16Z*/
       Z_DRAM,   0, 1638, 1280,  793, 0x0000ffff, 512,
       N_VRAM,   0, 2458, 1280,  204, 0x0000ffff, 0,
       N_VRAM,   0,  882, 1280,  142, 0x0000ffff, 0,
       N_DRAM,   0, 2433, 1280,   24, 0x0000ffff, 0,
       N_VRAM,1152,    0,  128,  882, 0x0000ffff, 0
};


/*--------------------------*/
/*** MGA-PRO/4/V (4.5Meg) ***/
/*--------------------------*/

OffScrData OffScrFBM_101_B[] = {
/* 640x480/24 */
       N_VRAM, 0,  480,  640, 1772, 0x00ffffff, 0,
       N_DRAM, 0, 2253,  640,  204, 0xffffffff, 0,
/* 768x576/24 */
       N_VRAM, 0,  576,  768, 1301, 0x00ffffff, 0,
       N_DRAM, 0, 1878,  768,  170, 0xffffffff, 0,
/* 800x600/24 */
       N_VRAM, 0,  600,  800, 1202, 0x00ffffff, 0,
       N_DRAM, 0, 1803,  800,  163, 0xffffffff, 0,
/* 1024x768/24 */
       N_VRAM, 0,  768, 1024,  640, 0x00ffffff, 0,
       N_DRAM, 0, 1408, 1024,  128, 0xffffffff, 0,
/* 1152x882/24 */
       N_VRAM, 0,  882, 1152,  369, 0x00ffffff, 0,
       N_DRAM, 0, 1252, 1152,  113, 0xffffffff, 0,
/* 1280x1024/24 */
       N_VRAM, 0, 1024, 1280,  102, 0x00ffffff, 0,
       N_DRAM, 0, 1127, 1280,  101, 0xffffffff, 0
};



/*------------------------------------*/
/*** MGA-PRO/4/V (4.5Meg) INTERLACE ***/
/*------------------------------------*/

OffScrData iOffScrFBM_101_B[] = {
/* 640x480/24 */
       N_VRAM,    0,  480,  768, 1397, 0x00ffffff, 0,
       N_DRAM,    0, 1878,  768,  170, 0xffffffff, 0,
       N_VRAM,  640,    0,  128,  480, 0x00ffffff, 0,
/* 800x600/24 */
       N_VRAM,    0,  600, 1024,  808, 0x00ffffff, 0,
       N_DRAM,    0, 1408, 1024,  128, 0xffffffff, 0,
       N_VRAM,  800,    0,  224,  600, 0x00ffffff, 0,
/* 1152x882/24 */
       N_VRAM,    0,  882, 1280,  244, 0x00ffffff, 0,
       N_DRAM,    0, 1127, 1280,  101, 0xffffffff, 0,
       N_VRAM, 1152,    0,  128,  882, 0x00ffffff, 0
};



/*-----------------------------------------*/
/*** MGA-PRO/4Z/V (4.5Mb + 4Mb Z-buffer) ***/
/*-----------------------------------------*/

OffScrData OffScrFBM_111_A[] = {
/* 640x480/24 */
       N_VRAM, 0,  480,  640, 1977, 0x00ffffff, 0,
       N_DRAM, 0, 2458,  640, 1638, 0xffffffff, 0,
/* 640x480/24Z */
       N_VRAM, 0,  480,  640, 1977, 0x00ffffff, 0,
       N_DRAM, 0, 2698,  640, 1398, 0xffffffff, 0,
       Z_DRAM, 0, 2458,  640,  239, 0xffffffff, 0,
/* 768x576/24 */
       N_VRAM, 0,  576,  768, 1472, 0x00ffffff, 0,
       N_DRAM, 0, 2048,  768, 1365, 0xffffffff, 0,
/* 768x576/24Z */
       N_VRAM, 0,  576,  768, 1472, 0x00ffffff, 0,
       N_DRAM, 0, 2336,  768, 1077, 0xffffffff, 0,
       Z_DRAM, 0, 2048,  768,  288, 0xffffffff, 0,
/* 800x600/24 */
       N_VRAM, 0,  600,  800, 1366, 0x00ffffff, 0,
       N_DRAM, 0, 1967,  800, 1309, 0xffffffff, 0,
/* 800x600/24Z */
       N_VRAM, 0,  600,  800, 1366, 0x00ffffff, 0,
       N_DRAM, 0, 2267,  800, 1009, 0xffffffff, 0,
       Z_DRAM, 0, 1967,  800,  299, 0xffffffff, 0,
/* 1024x768/24 */
       N_DRAM, 0, 1536, 1024, 1024, 0xffffffff, 0,
       N_VRAM, 0,  768, 1024,  768, 0x00ffffff, 0,
/* 1024x768/24Z */
       N_VRAM, 0,  768, 1024,  768, 0x00ffffff, 0,
       N_DRAM, 0, 1920, 1024,  640, 0xffffffff, 0,
       Z_DRAM, 0, 1536, 1024,  384, 0xffffffff, 0,
/* 1152x882/24 */
       N_DRAM, 0, 1366, 1152,  909, 0xffffffff, 0,
       N_VRAM, 0,  882, 1152,  483, 0x00ffffff, 0,
/* 1152x882/24Z */
       N_VRAM, 0,  882, 1152,  483, 0x00ffffff, 0,
       N_DRAM, 0, 1807, 1152,  468, 0xffffffff, 0,
       Z_DRAM, 0, 1366, 1152,  440, 0xffffffff, 0,
/* 1280x1024/24 */
       N_DRAM, 0, 1229, 1280,  819, 0xffffffff, 0,
       N_VRAM, 0, 1024, 1280,  204, 0x00ffffff, 0,
/* 1280x1024/24Z */
       Z_DRAM, 0, 1229, 1280,  511, 0xffffffff, 0,
       N_DRAM, 0, 1741, 1280,  307, 0xffffffff, 0,
       N_VRAM, 0, 1024, 1280,  204, 0x00ffffff, 0
};



/*---------------------------------------------------*/
/*** MGA-PRO/4Z/V (4.5Mb + 4Mb Z-buffer) INTERLACE ***/
/*---------------------------------------------------*/

OffScrData iOffScrFBM_111_A[] = {
/* 640x480/24 */
       N_VRAM,   0,  480,  768, 1568, 0x00ffffff, 0,
       N_DRAM,   0, 2048,  768, 1365, 0xffffffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x00ffffff, 0,
/* 640x480/24Z */
       N_VRAM,   0,  480,  768, 1568, 0x00ffffff, 0,
       N_DRAM,   0, 2248,  768, 1165, 0xffffffff, 0,
       Z_DRAM,   0, 2048,  768,  200, 0xffffffff, 0,
       N_VRAM, 640,    0,  128,  480, 0x00ffffff, 0,
/* 800x600/24 */
       N_DRAM,   0, 1536, 1024, 1024, 0xffffffff, 0,
       N_VRAM,   0,  600, 1024,  936, 0x00ffffff, 0,
       N_VRAM, 800,    0,  224,  600, 0x00ffffff, 0,
/* 800x600/24Z */
       N_VRAM,   0,  600, 1024,  936, 0x00ffffff, 0,
       N_DRAM,   0, 1771, 1024,  789, 0xffffffff, 0,
       Z_DRAM,   0, 1536, 1024,  234, 0xffffffff, 0,
       N_VRAM, 800,    0,  224,  600, 0x00ffffff, 0,
/* 1152x882/24 */
       N_DRAM,   0, 1229, 1280,  819, 0xffffffff, 0,
       N_VRAM,   0,  882, 1280,  346, 0x00ffffff, 0,
       N_VRAM,1152,    0,  128,  882, 0x00ffffff, 0,
/* 1152x882/24Z */
       N_DRAM,   0, 1626, 1280,  422, 0xffffffff, 0,
       Z_DRAM,   0, 1229, 1280,  396, 0xffffffff, 0,
       N_VRAM,   0,  882, 1280,  346, 0x00ffffff, 0,
       N_VRAM,1152,    0,  128,  882, 0x00ffffff, 0
};





/**************************/
/*** HWMODES DEFINITION ***/
/**************************/

/*------------------*/
/*** MGA-ULT/ 1Mb ***/
/*------------------*/

HwModeData HwModesFBM_000_A[21] = {
     640,  480,        DB, 0,  8,      256,  640, 1, &OffScrFBM_000_A[0],
     640,  480,    DB+LUT, 0,  8,      256,  640, 1, &OffScrFBM_000_A[0],
     640,  480,        DB, 0, 16,    32768,  640, 1, &OffScrFBM_000_A[1],
     640,  480,      M565, 0, 16,    65536,  640, 1, &OffScrFBM_000_A[1],
     800,  600,        DB, 0,  8,      256,  800, 1, &OffScrFBM_000_A[4],
     800,  600,    DB+LUT, 0,  8,      256,  800, 1, &OffScrFBM_000_A[4],
     800,  600,        DB, 0, 16,    32768,  800, 1, &OffScrFBM_000_A[5],
     800,  600,      M565, 0, 16,    65536,  800, 1, &OffScrFBM_000_A[5],
    1024,  768,        DB, 0,  8,      256, 1024, 1, &OffScrFBM_000_A[6],
    1024,  768,    DB+LUT, 0,  8,      256, 1024, 1, &OffScrFBM_000_A[6],
    1152,  882,        DB, 0,  8,      256, 1152, 1, &OffScrFBM_000_A[7],
    1152,  882,    DB+LUT, 0,  8,      256, 1152, 1, &OffScrFBM_000_A[7],
     640,  480,     DB+TV, 0,  8,      256,  640, 2, &OffScrFBM_000_A[0],
     640,  480, DB+TV+LUT, 0,  8,      256,  640, 2, &OffScrFBM_000_A[0],
     640,  480,     DB+TV, 0, 16,    32768,  640, 2, &OffScrFBM_000_A[1],
     640,  480,   TV+M565, 0, 16,    65536,  640, 2, &OffScrFBM_000_A[1],
     768,  576,     DB+TV, 0,  8,      256,  768, 1, &OffScrFBM_000_A[2],
     768,  576, DB+TV+LUT, 0,  8,      256,  768, 1, &OffScrFBM_000_A[2],
     768,  576,     DB+TV, 0, 16,    32768,  768, 1, &OffScrFBM_000_A[3],
     768,  576,   TV+M565, 0, 16,    65536,  768, 1, &OffScrFBM_000_A[3],{(word) -1}
};



HwModeInterlace iHwModesFBM_000_A[21] = {

/* 640x480/8         */  768,        DB, 2, &iOffScrFBM_000_A[0],
/* 640x480/8  LUT    */  768,    DB+LUT, 2, &iOffScrFBM_000_A[0],
/* 640x480/16        */  768,        DB, 2, &iOffScrFBM_000_A[2],
/* 640x480/15        */  768,      M565, 2, &iOffScrFBM_000_A[2],
/* 800x600/8         */ 1024,        DB, 2, &iOffScrFBM_000_A[4],
/* 800x600/8  LUT    */ 1024,    DB+LUT, 2, &iOffScrFBM_000_A[4],
/* 800x600/16        */ 1024,     ND+DB, 0, 0,
/* 800x600/15        */ 1024,   ND+M565, 0, 0,
/* 1024x768/8        */  {0},
/* 1024x768/8 LUT    */  {0},
/* 1152x882/8        */ 1280,     ND+DB, 0, 0,
/* 1152x882/8 LUT    */ 1280, ND+DB+LUT, 0, 0,
/* 640x480/8  TV     */  768,     DB+TV, 2, &iOffScrFBM_000_A[0],
/* 640x480/8  TV+LUT */  768, DB+TV+LUT, 2, &iOffScrFBM_000_A[0],
/* 640x480/16 TV     */  768,     DB+TV, 2, &iOffScrFBM_000_A[2],
/* 640x480/15 TV     */  768,   TV+M565, 2, &iOffScrFBM_000_A[2],
/* 768x576/8  TV     */  {0},
/* 768x576/8  TV+LUT */  {0},
/* 768x576/16 TV     */  {0},
/* 768x576/15 TV     */  {0},
                        {(word) -1}
};




/*------------------------*/
/*** MGA-ULT/ 2Mb TITAN ***/
/*------------------------*/

HwModeData HwModesFBM_010_A[34] = {
     640,  480,        DB, 0,  8,      256,  640, 1, &OffScrFBM_010_A[0],
     640,  480,    LUT+DB, 0,  8,      256,  640, 1, &OffScrFBM_010_A[0],
     640,  480,        DB, 0, 16,    32768,  640, 1, &OffScrFBM_010_A[1],
     640,  480,      M565, 0, 16,    65536,  640, 1, &OffScrFBM_010_A[1],
     640,  480,        DB, 0, 32, 16777216,  640, 2, &OffScrFBM_010_A[2],
     800,  600,        DB, 0,  8,      256,  800, 1, &OffScrFBM_010_A[8],
     800,  600,    DB+LUT, 0,  8,      256,  800, 1, &OffScrFBM_010_A[8],
     800,  600,        DB, 0, 16,    32768,  800, 1, &OffScrFBM_010_A[9],
     800,  600,      M565, 0, 16,    65536,  800, 1, &OffScrFBM_010_A[9],
     800,  600,        DB, 0, 32, 16777216,  800, 2, &OffScrFBM_010_A[10],
    1024,  768,        DB, 0,  8,      256, 1024, 1, &OffScrFBM_010_A[12],
    1024,  768,    DB+LUT, 0,  8,      256, 1024, 1, &OffScrFBM_010_A[12],
    1024,  768,        DB, 0, 16,    32768, 1024, 1, &OffScrFBM_010_A[13],
    1024,  768,      M565, 0, 16,    65536, 1024, 1, &OffScrFBM_010_A[13],
    1152,  882,        DB, 0,  8,      256, 1152, 1, &OffScrFBM_010_A[14],
    1152,  882,    DB+LUT, 0,  8,      256, 1152, 1, &OffScrFBM_010_A[14],
    1152,  882,        DB, 0, 16,    32768, 1152, 1, &OffScrFBM_010_A[15],
    1152,  882,      M565, 0, 16,    65536, 1152, 1, &OffScrFBM_010_A[15],
    1280, 1024,        DB, 0,  8,      256, 1280, 1, &OffScrFBM_010_A[16],
    1280, 1024,    DB+LUT, 0,  8,      256, 1280, 1, &OffScrFBM_010_A[16],
    1600, 1200,        DB, 0,  8,      256, 1600, 1, &OffScrFBM_010_A[17],
    1600, 1200,    DB+LUT, 0,  8,      256, 1600, 1, &OffScrFBM_010_A[17],
     640,  480,     TV+DB, 0,  8,      256,  640, 2, &OffScrFBM_010_A[0],
     640,  480, TV+DB+LUT, 0,  8,      256,  640, 2, &OffScrFBM_010_A[0],
     640,  480,     TV+DB, 0, 16,    32768,  640, 2, &OffScrFBM_010_A[1],
     640,  480,   TV+M565, 0, 16,    65536,  640, 2, &OffScrFBM_010_A[1],
     640,  480,     TV+DB, 0, 32, 16777216,  640, 3, &OffScrFBM_010_A[2],
     768,  576,     TV+DB, 0,  8,      256,  768, 1, &OffScrFBM_010_A[4],
     768,  576, TV+DB+LUT, 0,  8,      256,  768, 1, &OffScrFBM_010_A[4],
     768,  576,     TV+DB, 0, 16,    32768,  768, 1, &OffScrFBM_010_A[5],
     768,  576,   TV+M565, 0, 16,    65536,  768, 1, &OffScrFBM_010_A[5],
     768,  576,     TV+DB, 0, 32, 16777216,  768, 2, &OffScrFBM_010_A[6],{(word) -1}
};



HwModeInterlace iHwModesFBM_010_A[34] = {

/* 640x480/8          */     768,        DB, 2, &iOffScrFBM_010_A[0],
/* 640x480/8   LUT    */     768,    DB+LUT, 2, &iOffScrFBM_010_A[0],
/* 640x480/16         */     768,        DB, 2, &iOffScrFBM_010_A[2],
/* 640x480/15         */     768,      M565, 2, &iOffScrFBM_010_A[2],
/* 640x480/32         */     768,        DB, 3, &iOffScrFBM_010_A[4],
/* 800x600/8          */    1024,        DB, 2, &iOffScrFBM_010_A[7],
/* 800x600/8   LUT    */    1024,    DB+LUT, 2, &iOffScrFBM_010_A[7],
/* 800x600/16         */    1024,        DB, 2, &iOffScrFBM_010_A[9],
/* 800x600/15         */    1024,      M565, 2, &iOffScrFBM_010_A[9],
/* 800x600/32         */    1024,     ND+DB, 0, 0,
/* 1024x768/8         */     {0},
/* 1024x768/8  LUT    */     {0},
/* 1024x768/16        */     {0},
/* 1024x768/15        */     {0},
/* 1152x882/8         */    1280,        DB, 2, &iOffScrFBM_010_A[11],
/* 1152x882/8  LUT    */    1280,    DB+LUT, 2, &iOffScrFBM_010_A[11],
/* 1152x882/16        */    1280,     ND+DB, 0, 0,
/* 1152x882/15        */    1280,   ND+M565, 0, 0,
/* 1280x1024/8        */     {0},
/* 1280x1024/8 LUT    */     {0},
/* 1600x1200/8        */    1600,     ND+DB, 0, 0,
/* 1600x1200/8 LUT    */    1600, ND+DB+LUT, 0, 0,
/* 640x480/8   TV     */     768,     TV+DB, 2, &iOffScrFBM_010_A[0],
/* 640x480/8   TV+LUT */     768, TV+DB+LUT, 2, &iOffScrFBM_010_A[0],
/* 640x480/16  TV     */     768,     TV+DB, 2, &iOffScrFBM_010_A[2],
/* 640x480/15  TV     */     768,   TV+M565, 2, &iOffScrFBM_010_A[2],
/* 640x480/32  TV     */     768,     TV+DB, 3, &iOffScrFBM_010_A[4],
/* 768x576/8   TV     */     {0},
/* 768x576/8   TV+LUT */     {0},
/* 768x576/16  TV     */     {0},
/* 768x576/15  TV     */     {0},
/* 768x576/32  TV     */     {0},
                            {(word) -1}
};


/*------------------*/
/*** MGA-IMP/ 3Mb ***/
/*------------------*/

HwModeData HwModesFBM_010_B[48] = {
     640,  480,        DB, 0,  8,      256,  640, 1, &OffScrFBM_010_B[0],
     640,  480,    DB+LUT, 0,  8,      256,  640, 1, &OffScrFBM_010_B[0],
     640,  480,        DB, Z,  8,      256,  640, 3, &OffScrFBM_010_B[1],
     640,  480,        DB, 0, 16,    32768,  640, 1, &OffScrFBM_010_B[4],
     640,  480,      M565, 0, 16,    65536,  640, 1, &OffScrFBM_010_B[4],
     640,  480,        DB, Z, 16,    65536,  640, 3, &OffScrFBM_010_B[5],
     640,  480,        DB, 0, 32, 16777216,  640, 2, &OffScrFBM_010_B[8],
     640,  480,        DB, Z, 32, 16777216,  640, 4, &OffScrFBM_010_B[10],
     800,  600,        DB, 0,  8,      256,  800, 1, &OffScrFBM_010_B[28],
     800,  600,    DB+LUT, 0,  8,      256,  800, 1, &OffScrFBM_010_B[28],
     800,  600,        DB, Z,  8,      256,  800, 3, &OffScrFBM_010_B[29],
     800,  600,        DB, 0, 16,    32768,  800, 1, &OffScrFBM_010_B[32],
     800,  600,      M565, 0, 16,    65536,  800, 1, &OffScrFBM_010_B[32],
     800,  600,        DB, Z, 16,    32768,  800, 3, &OffScrFBM_010_B[33],
     800,  600,        DB, 0, 32, 16777216,  800, 2, &OffScrFBM_010_B[36],
     800,  600,        DB, Z, 32, 16777216,  800, 4, &OffScrFBM_010_B[38],
    1024,  768,        DB, 0,  8,      256, 1024, 1, &OffScrFBM_010_B[42],
    1024,  768,    DB+LUT, 0,  8,      256, 1024, 1, &OffScrFBM_010_B[42],
    1024,  768,        DB, 0, 16,    32768, 1024, 1, &OffScrFBM_010_B[43],
    1024,  768,      M565, 0, 16,    65536, 1024, 1, &OffScrFBM_010_B[43],
    1024,  768,        DB, 0, 32, 16777216, 1024, 1, &OffScrFBM_010_B[44],
    1152,  882,        DB, 0,  8,      256, 1152, 1, &OffScrFBM_010_B[45],
    1152,  882,    DB+LUT, 0,  8,      256, 1152, 1, &OffScrFBM_010_B[45],
    1152,  882,        DB, 0, 16,    32768, 1152, 1, &OffScrFBM_010_B[46],
    1152,  882,      M565, 0, 16,    65536, 1152, 1, &OffScrFBM_010_B[46],
    1280, 1024,        DB, 0,  8,      256, 1280, 1, &OffScrFBM_010_B[47],
    1280, 1024,    DB+LUT, 0,  8,      256, 1280, 1, &OffScrFBM_010_B[47],
    1280, 1024,     ND+DB, 0, 16,    32768, 1280, 1, &OffScrFBM_010_B[48],
    1280, 1024,   ND+M565, 0, 16,    65536, 1280, 1, &OffScrFBM_010_B[48],
    1600, 1200,        DB, 0,  8,      256, 1600, 1, &OffScrFBM_010_B[49],
    1600, 1200,    DB+LUT, 0,  8,      256, 1600, 1, &OffScrFBM_010_B[49],
     640,  480,     TV+DB, 0,  8,      256,  640, 2, &OffScrFBM_010_B[0],
     640,  480, TV+DB+LUT, 0,  8,      256,  640, 2, &OffScrFBM_010_B[0],
     640,  480,     TV+DB, Z,  8,      256,  640, 4, &OffScrFBM_010_B[1],
     640,  480,     TV+DB, 0, 16,    32768,  640, 2, &OffScrFBM_010_B[4],
     640,  480,   TV+M565, 0, 16,    65536,  640, 2, &OffScrFBM_010_B[4],
     640,  480,     TV+DB, Z, 16,    32768,  640, 4, &OffScrFBM_010_B[5],
     640,  480,     TV+DB, 0, 32, 16777216,  640, 3, &OffScrFBM_010_B[8],
     640,  480,     TV+DB, Z, 32, 16777216,  640, 5, &OffScrFBM_010_B[10],
     768,  576,     TV+DB, 0,  8,      256,  768, 1, &OffScrFBM_010_B[14],
     768,  576, TV+DB+LUT, 0,  8,      256,  768, 1, &OffScrFBM_010_B[14],
     768,  576,     TV+DB, Z,  8,      256,  768, 3, &OffScrFBM_010_B[15],
     768,  576,     TV+DB, 0, 16,    32768,  768, 1, &OffScrFBM_010_B[18],
     768,  576,   TV+M565, 0, 16,    65536,  768, 1, &OffScrFBM_010_B[18],
     768,  576,     TV+DB, Z, 16,    32768,  768, 3, &OffScrFBM_010_B[19],
     768,  576,     TV+DB, 0, 32, 16777216,  768, 2, &OffScrFBM_010_B[22],
     768,  576,     TV+DB, Z, 32, 16777216,  768, 4, &OffScrFBM_010_B[24],{(word) -1}
};


/*------------------- ---------*/
/*** MGA-IMP/ 3Mb  INTERLACE ***/
/*-----------------------------*/

HwModeInterlace iHwModesFBM_010_B[48] = {

/* 640X480/8          */     768,        DB, 2, &iOffScrFBM_010_B[0],
/* 640X480/8   LUT    */     768,    DB+LUT, 2, &iOffScrFBM_010_B[0],
/* 640X480/8Z         */     768,        DB, 4, &iOffScrFBM_010_B[2],
/* 640X480/16         */     768,        DB, 2, &iOffScrFBM_010_B[6],
/* 640X480/15         */     768,      M565, 2, &iOffScrFBM_010_B[6],
/* 640X480/16Z        */     768,        DB, 4, &iOffScrFBM_010_B[8],
/* 640X480/32         */     768,        DB, 3, &iOffScrFBM_010_B[12],
/* 640X480/32Z        */     768,        DB, 5, &iOffScrFBM_010_B[15],
/* 800X600/8          */    1024,        DB, 2, &iOffScrFBM_010_B[20],
/* 800X600/8   LUT    */    1024,    DB+LUT, 2, &iOffScrFBM_010_B[20],
/* 800X600/8Z         */    1024,        DB, 4, &iOffScrFBM_010_B[22],
/* 800X600/16         */    1024,        DB, 2, &iOffScrFBM_010_B[26],
/* 800X600/15         */    1024,      M565, 2, &iOffScrFBM_010_B[26],
/* 800X600/16Z        */    1024,        DB, 4, &iOffScrFBM_010_B[28],
/* 800X600/32         */    1024,        DB, 3, &iOffScrFBM_010_B[32],
/* 800X600/32Z        */    1024,     ND+DB, 0, 0,
/* 1024x768/8         */     {0},
/* 1024x768/8  LUT    */     {0},
/* 1024x768/16        */     {0},
/* 1024x768/15        */     {0},
/* 1024x768/32        */     {0},
/* 1152X882/8         */    1280,        DB, 2, &iOffScrFBM_010_B[35],
/* 1152X882/8  LUT    */    1280,    DB+LUT, 2, &iOffScrFBM_010_B[35],
/* 1152X882/16        */    1280,     ND+DB, 0, 0,
/* 1152X882/15        */    1280,   ND+M565, 0, 0,
/* 1280x1024/8        */     {0},
/* 1280x1024/8 LUT    */     {0},
/* 1280x1024/16       */     {0},
/* 1280x1024/15       */     {0},
/* 1600x1200/8        */    1600,     ND+DB, 0, 0,
/* 1600x1200/8 LUT    */    1600, ND+DB+LUT, 0, 0,
/* 640X480/8   TV     */     768,     TV+DB, 2, &iOffScrFBM_010_B[0],
/* 640X480/8   TV+LUT */     768, TV+DB+LUT, 2, &iOffScrFBM_010_B[0],
/* 640X480/8Z  TV     */     768,     TV+DB, 4, &iOffScrFBM_010_B[2],
/* 640X480/16  TV     */     768,     TV+DB, 2, &iOffScrFBM_010_B[6],
/* 640X480/15  TV     */     768,   TV+M565, 2, &iOffScrFBM_010_B[6],
/* 640X480/16Z TV     */     768,     TV+DB, 4, &iOffScrFBM_010_B[8],
/* 640X480/32  TV     */     768,     TV+DB, 3, &iOffScrFBM_010_B[12],
/* 640X480/32Z TV     */     768,     TV+DB, 5, &iOffScrFBM_010_B[15],
/* 768X576/8   TV     */     {0},
/* 768X576/8   TV+LUT */     {0},
/* 768X576/8Z  TV     */     {0},
/* 768X576/16  TV     */     {0},
/* 768X576/15  TV     */     {0},
/* 768X576/16Z TV     */     {0},
/* 768X576/32  TV     */     {0},
/* 768X576/32Z TV     */     {0},
                            {(word) -1}
};


/*-------------------------*/
/*** MGA-IMP/ 3Mb with Z ***/
/*-------------------------*/

HwModeData HwModesFBM_011_A[55] = {
     640,  480,        DB, 0,  8,      256,  640, 3, &OffScrFBM_011_A[0],
     640,  480,    DB+LUT, 0,  8,      256,  640, 3, &OffScrFBM_011_A[0],
     640,  480,        DB, Z,  8,      256,  640, 4, &OffScrFBM_011_A[3],
     640,  480,        DB, 0, 16,    32768,  640, 3, &OffScrFBM_011_A[7],
     640,  480,      M565, 0, 16,    65536,  640, 3, &OffScrFBM_011_A[7],
     640,  480,        DB, Z, 16,    32768,  640, 4, &OffScrFBM_011_A[10],
     640,  480,        DB, 0, 32, 16777216,  640, 4, &OffScrFBM_011_A[14],
     640,  480,        DB, Z, 32, 16777216,  640, 5, &OffScrFBM_011_A[18],
     800,  600,        DB, 0,  8,      256,  800, 3, &OffScrFBM_011_A[46],
     800,  600,    DB+LUT, 0,  8,      256,  800, 3, &OffScrFBM_011_A[46],
     800,  600,        DB, Z,  8,      256,  800, 4, &OffScrFBM_011_A[49],
     800,  600,        DB, 0, 16,    32768,  800, 3, &OffScrFBM_011_A[53],
     800,  600,      M565, 0, 16,    65536,  800, 3, &OffScrFBM_011_A[53],
     800,  600,        DB, Z, 16,    32768,  800, 4, &OffScrFBM_011_A[56],
     800,  600,        DB, 0, 32, 16777216,  800, 4, &OffScrFBM_011_A[60],
     800,  600,        DB, Z, 32, 16777216,  800, 5, &OffScrFBM_011_A[64],
    1024,  768,        DB, 0,  8,      256, 1024, 3, &OffScrFBM_011_A[69],
    1024,  768,    DB+LUT, 0,  8,      256, 1024, 3, &OffScrFBM_011_A[69],
    1024,  768,        DB, Z,  8,      256, 1024, 4, &OffScrFBM_011_A[72],
    1024,  768,        DB, 0, 16,    32768, 1024, 3, &OffScrFBM_011_A[76],
    1024,  768,      M565, 0, 16,    65536, 1024, 3, &OffScrFBM_011_A[76],
    1024,  768,        DB, Z, 16,    32768, 1024, 4, &OffScrFBM_011_A[79],
    1024,  768,        DB, 0, 32, 16777216, 1024, 2, &OffScrFBM_011_A[83],
    1152,  882,        DB, 0,  8,      256, 1152, 3, &OffScrFBM_011_A[85],
    1152,  882,    DB+LUT, 0,  8,      256, 1152, 3, &OffScrFBM_011_A[85],
    1152,  882,        DB, Z,  8,      256, 1152, 4, &OffScrFBM_011_A[88],
    1152,  882,        DB, 0, 16,    32768, 1152, 3, &OffScrFBM_011_A[92],
    1152,  882,      M565, 0, 16,    65536, 1152, 3, &OffScrFBM_011_A[92],
    1152,  882,        DB, Z, 16,    32768, 1152, 4, &OffScrFBM_011_A[95],
    1280, 1024,        DB, 0,  8,      256, 1280, 3, &OffScrFBM_011_A[99],
    1280, 1024,    DB+LUT, 0,  8,      256, 1280, 3, &OffScrFBM_011_A[99],
    1280, 1024,        DB, Z,  8,      256, 1280, 1, &OffScrFBM_011_A[102],
    1280, 1024,     ND+DB, 0, 16,    32768, 1280, 2, &OffScrFBM_011_A[103],
    1280, 1024,   ND+M565, 0, 16,    65536, 1280, 2, &OffScrFBM_011_A[103],
    1280, 1024,     ND+DB, Z, 16,    32768, 1280, 0, &OffScrFBM_011_A[105],
    1600, 1200,        DB, 0,  8,      256, 1600, 3, &OffScrFBM_011_A[106],
    1600, 1200,    DB+LUT, 0,  8,      256, 1600, 3, &OffScrFBM_011_A[106],
     640,  480,     TV+DB, 0,  8,      256,  640, 4, &OffScrFBM_011_A[0],
     640,  480, TV+DB+LUT, 0,  8,      256,  640, 4, &OffScrFBM_011_A[0],
     640,  480,     TV+DB, Z,  8,      256,  640, 5, &OffScrFBM_011_A[3],
     640,  480,     TV+DB, 0, 16,    32768,  640, 4, &OffScrFBM_011_A[7],
     640,  480,   TV+M565, 0, 16,    65536,  640, 4, &OffScrFBM_011_A[7],
     640,  480,     TV+DB, Z, 16,    32768,  640, 5, &OffScrFBM_011_A[10],
     640,  480,     TV+DB, 0, 32, 16777216,  640, 5, &OffScrFBM_011_A[14],
     640,  480,     TV+DB, Z, 32, 16777216,  640, 6, &OffScrFBM_011_A[18],
     768,  576,     TV+DB, 0,  8,      256,  768, 3, &OffScrFBM_011_A[23],
     768,  576, TV+DB+LUT, 0,  8,      256,  768, 3, &OffScrFBM_011_A[23],
     768,  576,     TV+DB, Z,  8,      256,  768, 4, &OffScrFBM_011_A[26],
     768,  576,     TV+DB, 0, 16,    32768,  768, 3, &OffScrFBM_011_A[30],
     768,  576,   TV+M565, 0, 16,    65536,  768, 3, &OffScrFBM_011_A[30],
     768,  576,     TV+DB, Z, 16,    32768,  768, 4, &OffScrFBM_011_A[33],
     768,  576,     TV+DB, 0, 32, 16777216,  768, 4, &OffScrFBM_011_A[37],
     768,  576,     TV+DB, Z, 32, 16777216,  768, 5, &OffScrFBM_011_A[41],{(word) -1}
};


/*------------------------------------*/
/*** MGA-IMP/ 3Mb with Z  INTERLACE ***/
/*------------------------------------*/

HwModeInterlace iHwModesFBM_011_A[55] = {

/* 640X480/8           */     768,        DB, 4, &iOffScrFBM_011_A[0],
/* 640X480/8    LUT    */     768,    DB+LUT, 4, &iOffScrFBM_011_A[0],
/* 640X480/8Z          */     768,        DB, 5, &iOffScrFBM_011_A[4],
/* 640X480/16          */     768,        DB, 4, &iOffScrFBM_011_A[9],
/* 640X480/15          */     768,      M565, 4, &iOffScrFBM_011_A[9],
/* 640X480/16Z         */     768,        DB, 5, &iOffScrFBM_011_A[13],
/* 640X480/32          */     768,        DB, 5, &iOffScrFBM_011_A[18],
/* 640X480/32Z         */     768,        DB, 6, &iOffScrFBM_011_A[23],
/* 800X600/8           */    1024,        DB, 4, &iOffScrFBM_011_A[29],
/* 800X600/8    LUT    */    1024,    DB+LUT, 4, &iOffScrFBM_011_A[29],
/* 800X600/8Z          */    1024,        DB, 5, &iOffScrFBM_011_A[33],
/* 800X600/16          */    1024,        DB, 4, &iOffScrFBM_011_A[38],
/* 800X600/15          */    1024,      M565, 4, &iOffScrFBM_011_A[38],
/* 800X600/16Z         */    1024,        DB, 5, &iOffScrFBM_011_A[42],
/* 800X600/32          */    1024,        DB, 5, &iOffScrFBM_011_A[47],
/* 800X600/32Z         */    1024,        DB, 6, &iOffScrFBM_011_A[52],
/* 1024x768/8          */     {0},
/* 1024x768/8   LUT    */     {0},
/* 1024x768/8Z         */     {0},
/* 1024x768/16         */     {0},
/* 1024x768/15         */     {0},
/* 1024x768/16Z        */     {0},
/* 1024x768/32         */     {0},
/* 1152X882/8          */    1280,        DB, 4, &iOffScrFBM_011_A[58],
/* 1152X882/8   LUT    */    1280,    DB+LUT, 4, &iOffScrFBM_011_A[58],
/* 1152X882/8Z         */    1280,        DB, 5, &iOffScrFBM_011_A[62],
/* 1152X882/16         */    1280,     ND+DB, 0, 0,
/* 1152X882/15         */    1280,   ND+M565, 0, 0,
/* 1152X882/16Z        */    1280,     ND+DB, 0, 0,
/* 1280x1024/8         */     {0},
/* 1280x1024/8  LUT    */     {0},
/* 1280x1024/8Z        */     {0},
/* 1280x1024/16        */     {0},
/* 1280x1024/15        */     {0},
/* 1280x1024/16Z       */     {0},
/* 1600x1200/8         */    1600,     ND+DB, 0, 0,
/* 1600x1200/8  LUT    */    1600, ND+DB+LUT, 0, 0,
/* 640X480/8    TV     */     768,     TV+DB, 4, &iOffScrFBM_011_A[0],
/* 640X480/8    TV+LUT */     768, TV+DB+LUT, 4, &iOffScrFBM_011_A[0],
/* 640X480/8Z   TV     */     768,     TV+DB, 5, &iOffScrFBM_011_A[4],
/* 640X480/16   TV     */     768,     TV+DB, 4, &iOffScrFBM_011_A[9],
/* 640X480/15   TV     */     768,   TV+M565, 4, &iOffScrFBM_011_A[9],
/* 640X480/16Z  TV     */     768,     TV+DB, 5, &iOffScrFBM_011_A[13],
/* 640X480/32   TV     */     768,     TV+DB, 5, &iOffScrFBM_011_A[18],
/* 640X480/32Z  TV     */     768,     TV+DB, 6, &iOffScrFBM_011_A[23],
/* 768X576/8    TV     */     {0},
/* 768X576/8    TV+LUT */     {0},
/* 768X576/8Z   TV     */     {0},
/* 768X576/16   TV     */     {0},
/* 768X576/15   TV     */     {0},
/* 768X576/16Z  TV     */     {0},
/* 768X576/32   TV     */     {0},
/* 768X576/32Z  TV     */     {0},
                             {(word) -1}
};



/*--------------------------*/
/*** MGA-PRO/4/V (4.5Meg) ***/
/*--------------------------*/

HwModeData HwModesFBM_101_B[8] = {
     640,  480,   DB, 0, 32, 16777216,  640, 2, &OffScrFBM_101_B[0],
     800,  600,   DB, 0, 32, 16777216,  800, 2, &OffScrFBM_101_B[4],
    1024,  768,   DB, 0, 32, 16777216, 1024, 2, &OffScrFBM_101_B[6],
    1152,  882,   DB, 0, 32, 16777216, 1152, 2, &OffScrFBM_101_B[8],
    1280, 1024,   DB, 0, 32, 16777216, 1280, 2, &OffScrFBM_101_B[10],
     640,  480,TV+DB, 0, 32, 16777216,  640, 2, &OffScrFBM_101_B[0],
     768,  576,TV+DB, 0, 32, 16777216,  768, 2, &OffScrFBM_101_B[2],{(word) -1}
};



HwModeInterlace iHwModesFBM_101_B[8] = {

/* 640x480/24      */     768,    DB, 3, &iOffScrFBM_101_B[0],
/* 800x600/24      */    1024,    DB, 3, &iOffScrFBM_101_B[3],
/* 1024x768/24     */     {0},
/* 1152x882/24     */    1280,    DB, 3, &iOffScrFBM_101_B[6],
/* 1280x1024/24    */     {0},
/* 640x480/24   TV */     768, TV+DB, 3, &iOffScrFBM_101_B[0],
/* 768x576/24   TV */     {0},
                         {(word) -1}
};


/*-----------------------------------------*/
/*** MGA-PRO/4Z/V (4.5Mb + 4Mb Z-buffer) ***/
/*-----------------------------------------*/

HwModeData HwModesFBM_111_A[15] = {
     640,  480,   DB, 0, 32, 16777216,  640, 2, &OffScrFBM_111_A[0],
     640,  480,   DB, Z, 32, 16777216,  640, 3, &OffScrFBM_111_A[2],
     800,  600,   DB, 0, 32, 16777216,  800, 2, &OffScrFBM_111_A[10],
     800,  600,   DB, Z, 32, 16777216,  800, 3, &OffScrFBM_111_A[12],
    1024,  768,   DB, 0, 32, 16777216, 1024, 2, &OffScrFBM_111_A[15],
    1024,  768,   DB, Z, 32, 16777216, 1024, 3, &OffScrFBM_111_A[17],
    1152,  882,   DB, 0, 32, 16777216, 1152, 2, &OffScrFBM_111_A[20],
    1152,  882,   DB, Z, 32, 16777216, 1152, 3, &OffScrFBM_111_A[22],
    1280, 1024,   DB, 0, 32, 16777216, 1280, 2, &OffScrFBM_111_A[25],
    1280, 1024,   DB, Z, 32, 16777216, 1280, 3, &OffScrFBM_111_A[27],
     640,  480,TV+DB, 0, 32, 16777216,  640, 2, &OffScrFBM_111_A[0],
     640,  480,TV+DB, Z, 32, 16777216,  640, 3, &OffScrFBM_111_A[2],
     768,  576,TV+DB, 0, 32, 16777216,  768, 2, &OffScrFBM_111_A[5],
     768,  576,TV+DB, Z, 32, 16777216,  768, 3, &OffScrFBM_111_A[7],{(word) -1}
};



HwModeInterlace iHwModesFBM_111_A[15] = {

/* 640x480/24       */     768,    DB, 3, &iOffScrFBM_111_A[0],
/* 640x480/24Z      */     768,    DB, 4, &iOffScrFBM_111_A[3],
/* 800x600/24       */    1024,    DB, 3, &iOffScrFBM_111_A[7],
/* 800x600/24Z      */    1024,    DB, 4, &iOffScrFBM_111_A[10],
/* 1024x768/24      */     {0},
/* 1024x768/24Z     */     {0},
/* 1152x882/24      */    1280,    DB, 3, &iOffScrFBM_111_A[14],
/* 1152x882/24Z     */    1280,    DB, 4, &iOffScrFBM_111_A[17],
/* 1280x1024/24     */     {0},
/* 1280x1024/24Z    */     {0},
/* 640x480/24    TV */     768, TV+DB, 3, &iOffScrFBM_111_A[0],
/* 640x480/24Z   TV */     768, TV+DB, 4, &iOffScrFBM_111_A[3],
/* 768x576/24    TV */     {0},
/* 768x576/24Z   TV */     {0},
                          {(word) -1}
};


/*----------------------------------*/
/*** MGA PCI 2Mb (Atlas+Athena) ***/
/*----------------------------------*/

OffScrData OffAth2[] = {
/*  640x 480/ 8 */
 N_VRAM,  0,   480,   640,  2796, 0x000000ff,   0,
/*  640x 480/ 8 DB */
 N_VRAM,  0,   960,   640,  2316, 0x000000ff,   0,
DB_VRAM,  0,   480,   640,   480, 0x000000ff,   0,
/*  640x 480/ 8 DB+Z */
 N_VRAM,  0,   480,   640,   339, 0x0000ffff,   0,
 N_VRAM,  0,  1300,   640,   338, 0x0000ffff,   0,
 Z_VRAM,  0,   819,   640,   480, 0x0000ffff, 128,
/*  640x 480/16 */
 N_VRAM,  0,   480,   640,  1158, 0x0000ffff,   0,
/*  640x 480/16 Z */
 N_VRAM,  0,   480,   640,   339, 0x0000ffff,   0,
 N_VRAM,  0,  1300,   640,   338, 0x0000ffff,   0,
 Z_VRAM,  0,   819,   640,   480, 0x0000ffff, 128,
/*  640x 480/16 DB */
 N_VRAM,  0,   960,   640,   678, 0x0000ffff,   0,
DB_VRAM,  0,   480,   640,   480, 0x0000ffff,   0,
/*  640x 480/32 */
 N_VRAM,  0,   480,   640,   339, 0xffffffff,   0,
 N_VRAM,  0,    0,    480,   640, 0xff000000,   0,
/*  800x 600/ 8 */
 N_VRAM,  0,   600,   800,  2021, 0x000000ff,   0,
/*  800x 600/ 8 DB */
 N_VRAM,  0,  1200,   800,  1421, 0x000000ff,   0,
DB_VRAM,  0,   600,   800,   600, 0x000000ff,   0,
/*  800x 600/ 8 DB+Z */
 N_VRAM,  0,   600,   800,    55, 0x0000ffff,   0,
 N_VRAM,  0,  1256,   800,    54, 0x0000ffff,   0,
 Z_VRAM,  0,   655,   800,   600, 0x0000ffff, 288,
/*  800x 600/16 */
 N_VRAM,  0,   600,   800,   710, 0x0000ffff,   0,
/*  800x 600/16 Z */
 N_VRAM,  0,   600,   800,    55, 0x0000ffff,   0,
 N_VRAM,  0,  1256,   800,    54, 0x0000ffff,   0,
 Z_VRAM,  0,   655,   800,   600, 0x0000ffff, 288,
/*  800x 600/16 DB */
 N_VRAM,  0,  1200,   800,   110, 0x0000ffff,   0,
DB_VRAM,  0,   600,   800,   600, 0x0000ffff,   0,
/*  800x 600/32 */
 N_VRAM,  0,   600,   800,    55, 0xffffffff,   0,
 N_VRAM,  0,    0,    600,   800, 0xff000000,   0,
/* 1024x 768/ 8 */
 N_VRAM,  0,   768,  1024,  1280, 0x000000ff,   0,
/* 1024x 768/ 8 DB */
 N_VRAM,  0,  1536,  1024,   512, 0x000000ff,   0,
DB_VRAM,  0,   768,  1024,   768, 0x000000ff,   0,
/* 1024x 768/16 */
 N_VRAM,  0,   768,  1024,   256, 0x0000ffff,   0,
/* 1152x 882/ 8 */
 N_VRAM,  0,   882,  1152,   938, 0x000000ff,   0,
/* 1152x 882/ 8 DB */
 N_VRAM,  0,  1764,  1152,    56, 0x000000ff,   0,
DB_VRAM,  0,   882,  1152,   882, 0x000000ff,   0,
/* 1152x 882/16 */
 N_VRAM,  0,   882,  1152,    28, 0x0000ffff,   0,
/* 1280x1024/ 8 */
 N_VRAM,  0,  1024,  1280,   614, 0x000000ff,   0,
/* 1600x1200/ 8 */
 N_VRAM,  0,  1200,  1600,   110, 0x000000ff,   0,
/*  768x 576/ 8 */
 N_VRAM,  0,   576,   768,  2154, 0x000000ff,   0,
/*  768x 576/ 8 DB */
 N_VRAM,  0,  1152,   768,  1578, 0x000000ff,   0,
DB_VRAM,  0,   576,   768,   576, 0x000000ff,   0,
/*  768x 576/ 8 DB+Z */
 N_VRAM,  0,   576,   768,   106, 0x0000ffff,   0,
 N_VRAM,  0,  1259,   768,   105, 0x0000ffff,   0,
 Z_VRAM,  0,   682,   768,   576, 0x0000ffff, 512,
/*  768x 576/16 */
 N_VRAM,  0,   576,   768,   789, 0x0000ffff,   0,
/*  768x 576/16 Z */
 N_VRAM,  0,   576,   768,   106, 0x0000ffff,   0,
 N_VRAM,  0,  1259,   768,   105, 0x0000ffff,   0,
 Z_VRAM,  0,   682,   768,   576, 0x0000ffff, 512,
/*  768x 576/16 DB */
 N_VRAM,  0,  1152,   768,   213, 0x0000ffff,   0,
DB_VRAM,  0,   576,   768,   576, 0x0000ffff,   0,
/*  768x 576/32 */
 N_VRAM,  0,   576,   768,   106, 0xffffffff,   0,
 N_VRAM,  0,    0,    576,   768, 0xff000000,   0,
};


/*----------------------------------*/
/*** MGA PCI 2Mb (Atlas+Athena) ***/
/*----------------------------------*/

OffScrData iOffAth2[] = {
/*  640x 480/ 8 */
 N_VRAM,    0,  480,  768, 2250, 0x000000ff,   0,
 N_VRAM,  480,    0,  128,  480, 0x000000ff,   0,
/*  640x 480/ 8 DB */
 N_VRAM,    0,  960,  768, 1770, 0x000000ff,   0,
 N_VRAM,  640,    0,  128,  480, 0x000000ff,   0,
DB_VRAM,    0,  480,  768,  480, 0x000000ff,   0,
/*  640x 480/ 8 DB+Z */
 N_VRAM,    0,  480,  768,  202, 0x0000ffff,   0,
 N_VRAM,    0, 1083,  768,  281, 0x0000ffff,   0,
 N_VRAM,  640,    0,  128,  682, 0x0000ffff,   0,
 N_VRAM,  640, 1083,  128,  281, 0x0000ffff,   0,
 Z_VRAM,    0,  682,  768,  400, 0x0000ffff, 512,
DB_VRAM,    0,  480,  768,  480, 0x0000ffff,   0,
/*  640x 480/16 */
 N_VRAM,    0,  480,  768,  885, 0x0000ffff,   0,
 N_VRAM,  480,    0,  128,  480, 0x0000ffff,   0,
/*  640x 480/16 Z */
 N_VRAM,    0, 1083,  768,  281, 0x0000ffff,   0,
 N_VRAM,    0,  480,  768,  202, 0x0000ffff,   0,
 N_VRAM,  640,    0,  128,  682, 0x0000ffff,   0,
 N_VRAM,  640, 1083,  128,  281, 0x0000ffff,   0,
 Z_VRAM,    0,  682,  768,  400, 0x0000ffff, 512,
/*  640x 480/16 DB */
 N_VRAM,    0,  960,  768,  405, 0x0000ffff,   0,
 N_VRAM,  640,    0,  128,  480, 0x0000ffff,   0,
DB_VRAM,    0,  480,  768,  480, 0x0000ffff,   0,
/*  640x 480/32 */
 N_VRAM,    0,  480,  768,  202, 0xffffffff,   0,
 N_VRAM,  480,    0,  128,  480, 0xffffffff,   0,
 N_VRAM,    0,    0,  480,  768, 0xff000000,   0,
/*  800x 600/ 8 */
 N_VRAM,    0,  600, 1024, 1448, 0x000000ff,   0,
 N_VRAM,  600,    0,  224,  600, 0x000000ff,   0,
/*  800x 600/ 8 DB */
 N_VRAM,    0, 1200, 1024,  848, 0x000000ff,   0,
 N_VRAM,  800,    0,  224,  600, 0x000000ff,   0,
DB_VRAM,    0,  600, 1024,  600, 0x000000ff,   0,
/*  800x 600/16 */
 N_VRAM,    0,  600, 1024,  424, 0x0000ffff,   0,
 N_VRAM,  600,    0,  224,  600, 0x0000ffff,   0,
/* 1024x 768/ 8 */
 N_VRAM,    0,  768, 1024, 1280, 0x000000ff,   0,
 N_VRAM,  768,    0,    0,  768, 0x000000ff,   0,
/* 1024x 768/ 8 DB */
 N_VRAM,    0, 1536, 1024,  512, 0x000000ff,   0,
 N_VRAM, 1024,    0,    0,  768, 0x000000ff,   0,
DB_VRAM,    0,  768, 1024,  768, 0x000000ff,   0,
/* 1024x 768/16 */
 N_VRAM,    0,  768, 1024,  256, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0,  768, 0x0000ffff,   0,
/* 1152x 882/ 8 */
 N_VRAM,    0,  882, 1280,  756, 0x000000ff,   0,
 N_VRAM,  882,    0,  128,  882, 0x000000ff,   0,
/* 1280x1024/ 8 */
 N_VRAM,    0, 1024, 1280,  614, 0x000000ff,   0,
 N_VRAM, 1024,    0,    0, 1024, 0x000000ff,   0,
/* 1600x1200/ 8 */
 N_VRAM,    0, 1200, 1600,  110, 0x000000ff,   0,
 N_VRAM, 1200,    0,    0, 1200, 0x000000ff,   0,
/*  768x 576/ 8 */
 N_VRAM,    0,  576,  768, 2154, 0x000000ff,   0,
 N_VRAM,  576,    0,    0,  576, 0x000000ff,   0,
/*  768x 576/ 8 DB */
 N_VRAM,    0, 1152,  768, 1578, 0x000000ff,   0,
 N_VRAM,  768,    0,    0,  576, 0x000000ff,   0,
DB_VRAM,    0,  576,  768,  576, 0x000000ff,   0,
/*  768x 576/ 8 DB+Z */
 N_VRAM,    0,  576,  768,  106, 0x0000ffff,   0,
 N_VRAM,    0, 1259,  768,  105, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0,  682, 0x0000ffff,   0,
 N_VRAM,  768, 1259,    0,  105, 0x0000ffff,   0,
 Z_VRAM,    0,  682,  768,  576, 0x0000ffff, 512,
DB_VRAM,    0,  576,  768,  576, 0x0000ffff,   0,
/*  768x 576/16 */
 N_VRAM,    0,  576,  768,  789, 0x0000ffff,   0,
 N_VRAM,  576,    0,    0,  576, 0x0000ffff,   0,
/*  768x 576/16 Z */
 N_VRAM,    0, 1259,  768,  105, 0x0000ffff,   0,
 N_VRAM,    0,  576,  768,  106, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0,  682, 0x0000ffff,   0,
 N_VRAM,  768, 1259,    0,  105, 0x0000ffff,   0,
 Z_VRAM,    0,  682,  768,  576, 0x0000ffff, 512,
/*  768x 576/16 DB */
 N_VRAM,    0, 1152,  768,  213, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0,  576, 0x0000ffff,   0,
DB_VRAM,    0,  576,  768,  576, 0x0000ffff,   0,
/*  768x 576/32 */
 N_VRAM,    0,  576,  768,  106, 0xffffffff,   0,
 N_VRAM,  576,    0,    0,  576, 0xffffffff,   0,
 N_VRAM,    0,    0,  576,  768, 0xff000000,   0,
};


/*----------------------------------*/
/*** MGA PCI 2Mb (Atlas+Athena) ***/
/*----------------------------------*/

HwModeData ModesAth2[63] = {
  640,  480,         0, 0,  8,      256,  640,  1, &OffAth2[0],
  640,  480,        DB, 0,  8,      256,  640,  2, &OffAth2[1],
  640,  480,        DB, Z,  8,      256,  640,  3, &OffAth2[3],
  640,  480,       LUT, 0,  8,      256,  640,  1, &OffAth2[0],
  640,  480,    DB+LUT, 0,  8,      256,  640,  1, &OffAth2[0],
  640,  480,         0, 0, 16,    32768,  640,  1, &OffAth2[6],
  640,  480,         0, Z, 16,    32768,  640,  3, &OffAth2[7],
  640,  480,        DB, 0, 16,    32768,  640,  2, &OffAth2[10],
  640,  480,      M565, 0, 16,    65536,  640,  1, &OffAth2[6],
  640,  480,   M565+DB, 0, 16,    65536,  640,  2, &OffAth2[10],
  640,  480,         0, 0, 32, 16777216,  640,  2, &OffAth2[12],
  800,  600,         0, 0,  8,      256,  800,  1, &OffAth2[14],
  800,  600,        DB, 0,  8,      256,  800,  2, &OffAth2[15],
  800,  600,        DB, Z,  8,      256,  800,  3, &OffAth2[17],
  800,  600,       LUT, 0,  8,      256,  800,  1, &OffAth2[14],
  800,  600,    DB+LUT, 0,  8,      256,  800,  1, &OffAth2[14],
  800,  600,         0, 0, 16,    32768,  800,  1, &OffAth2[20],
  800,  600,         0, Z, 16,    32768,  800,  3, &OffAth2[21],
  800,  600,        DB, 0, 16,    32768,  800,  2, &OffAth2[24],
  800,  600,      M565, 0, 16,    65536,  800,  1, &OffAth2[20],
  800,  600,   M565+DB, 0, 16,    65536,  800,  2, &OffAth2[24],
  800,  600,         0, 0, 32, 16777216,  800,  2, &OffAth2[26],
 1024,  768,         0, 0,  8,      256, 1024,  1, &OffAth2[28],
 1024,  768,        DB, 0,  8,      256, 1024,  2, &OffAth2[29],
 1024,  768,       LUT, 0,  8,      256, 1024,  1, &OffAth2[28],
 1024,  768,    DB+LUT, 0,  8,      256, 1024,  1, &OffAth2[28],
 1024,  768,         0, 0, 16,    32768, 1024,  1, &OffAth2[31],
 1024,  768,      M565, 0, 16,    65536, 1024,  1, &OffAth2[31],
 1152,  882,         0, 0,  8,      256, 1152,  1, &OffAth2[32],
 1152,  882,        DB, 0,  8,      256, 1152,  2, &OffAth2[33],
 1152,  882,       LUT, 0,  8,      256, 1152,  1, &OffAth2[32],
 1152,  882,    DB+LUT, 0,  8,      256, 1152,  1, &OffAth2[32],
 1152,  882,         0, 0, 16,    32768, 1152,  1, &OffAth2[35],
 1152,  882,      M565, 0, 16,    65536, 1152,  1, &OffAth2[35],
 1280, 1024,         0, 0,  8,      256, 1280,  1, &OffAth2[36],
 1280, 1024,       LUT, 0,  8,      256, 1280,  1, &OffAth2[36],
 1280, 1024,    DB+LUT, 0,  8,      256, 1280,  1, &OffAth2[36],
 1600, 1200,         0, 0,  8,      256, 1600,  1, &OffAth2[37],
 1600, 1200,       LUT, 0,  8,      256, 1600,  1, &OffAth2[37],
 1600, 1200,    DB+LUT, 0,  8,      256, 1600,  1, &OffAth2[37],
  640,  480,        TV, 0,  8,      256,  640,  1, &OffAth2[0],
  640,  480,     TV+DB, 0,  8,      256,  640,  2, &OffAth2[1],
  640,  480,     TV+DB, Z,  8,      256,  640,  3, &OffAth2[3],
  640,  480,    TV+LUT, 0,  8,      256,  640,  1, &OffAth2[0],
  640,  480, TV+DB+LUT, 0,  8,      256,  640,  1, &OffAth2[0],
  640,  480,        TV, 0, 16,    32768,  640,  1, &OffAth2[6],
  640,  480,        TV, Z, 16,    32768,  640,  3, &OffAth2[7],
  640,  480,     TV+DB, 0, 16,    32768,  640,  2, &OffAth2[10],
  640,  480,   TV+M565, 0, 16,    65536,  640,  1, &OffAth2[6],
  640,  480,TV+M565+DB, 0, 16,    65536,  640,  2, &OffAth2[10],
  640,  480,        TV, 0, 32, 16777216,  640,  2, &OffAth2[12],
  768,  576,        TV, 0,  8,      256,  768,  1, &OffAth2[38],
  768,  576,     TV+DB, 0,  8,      256,  768,  2, &OffAth2[39],
  768,  576,     TV+DB, Z,  8,      256,  768,  3, &OffAth2[41],
  768,  576,    TV+LUT, 0,  8,      256,  768,  1, &OffAth2[38],
  768,  576, TV+DB+LUT, 0,  8,      256,  768,  1, &OffAth2[38],
  768,  576,        TV, 0, 16,    32768,  768,  1, &OffAth2[44],
  768,  576,        TV, Z, 16,    32768,  768,  3, &OffAth2[45],
  768,  576,     TV+DB, 0, 16,    32768,  768,  2, &OffAth2[48],
  768,  576,   TV+M565, 0, 16,    65536,  768,  1, &OffAth2[44],
  768,  576,TV+M565+DB, 0, 16,    65536,  768,  2, &OffAth2[48],
  768,  576,        TV, 0, 32, 16777216,  768,  2, &OffAth2[50],
{(word) -1}
};


/*----------------------------------*/
/*** MGA PCI 2Mb (Atlas+Athena) ***/
/*----------------------------------*/

HwModeInterlace iModesAth2[63] = {
/*  640x 480/ 8 */   768,         0, 2, &iOffAth2[0],
/*  640x 480/ 8 */   768,        DB, 3, &iOffAth2[2],
/*  640x 480/ 8 */   768,        DB, 6, &iOffAth2[5],
/*  640x 480/ 8 */   768,       LUT, 2, &iOffAth2[0],
/*  640x 480/ 8 */   768,    DB+LUT, 2, &iOffAth2[0],
/*  640x 480/16 */   768,         0, 2, &iOffAth2[11],
/*  640x 480/16 */   768,         0, 5, &iOffAth2[13],
/*  640x 480/16 */   768,        DB, 3, &iOffAth2[18],
/*  640x 480/16 */   768,      M565, 2, &iOffAth2[11],
/*  640x 480/16 */   768,   M565+DB, 3, &iOffAth2[18],
/*  640x 480/32 */   768,         0, 3, &iOffAth2[21],
/*  800x 600/ 8 */  1024,         0, 2, &iOffAth2[24],
/*  800x 600/ 8 */  1024,        DB, 3, &iOffAth2[26],
/*  800x 600/ 8 */  1024,        ND, 0, 0,
/*  800x 600/ 8 */  1024,       LUT, 2, &iOffAth2[24],
/*  800x 600/ 8 */  1024,    DB+LUT, 2, &iOffAth2[24],
/*  800x 600/16 */  1024,         0, 2, &iOffAth2[29],
/*  800x 600/16 */  1024,        ND, 0, 0,
/*  800x 600/16 */  1024,        ND, 0, 0,
/*  800x 600/16 */  1024,      M565, 2, &iOffAth2[29],
/*  800x 600/16 */  1024,        ND, 0, 0,
/*  800x 600/32 */  1024,        ND, 0, 0,
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/16 */   {0},
/* 1024x 768/16 */   {0},
/* 1152x 882/ 8 */  1280,         0, 2, &iOffAth2[38],
/* 1152x 882/ 8 */  1280,        ND, 0, 0,
/* 1152x 882/ 8 */  1280,       LUT, 2, &iOffAth2[38],
/* 1152x 882/ 8 */  1280,    DB+LUT, 2, &iOffAth2[38],
/* 1152x 882/16 */  1280,        ND, 0, 0,
/* 1152x 882/16 */  1280,        ND, 0, 0,
/* 1280x1024/ 8 */   {0},
/* 1280x1024/ 8 */   {0},
/* 1280x1024/ 8 */   {0},
/* 1600x1200/ 8 */  1600,         0, 2, &iOffAth2[42],
/* 1600x1200/ 8 */  1600,       LUT, 2, &iOffAth2[42],
/* 1600x1200/ 8 */  1600,    DB+LUT, 2, &iOffAth2[42],
/*  640x 480/ 8 */   768,        TV, 2, &iOffAth2[0],
/*  640x 480/ 8 */   768,     TV+DB, 3, &iOffAth2[2],
/*  640x 480/ 8 */   768,     TV+DB, 6, &iOffAth2[5],
/*  640x 480/ 8 */   768,    TV+LUT, 2, &iOffAth2[0],
/*  640x 480/ 8 */   768, TV+DB+LUT, 2, &iOffAth2[0],
/*  640x 480/16 */   768,        TV, 2, &iOffAth2[11],
/*  640x 480/16 */   768,        TV, 5, &iOffAth2[13],
/*  640x 480/16 */   768,     TV+DB, 3, &iOffAth2[18],
/*  640x 480/16 */   768,   TV+M565, 2, &iOffAth2[11],
/*  640x 480/16 */   768,TV+M565+DB, 3, &iOffAth2[18],
/*  640x 480/32 */   768,        TV, 3, &iOffAth2[21],
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/32 */   {0},
{(word) -1}
};

/*----------------------------------*/
/*** MGA PCI 4Mb (Atlas+Athena) ***/
/*----------------------------------*/

OffScrData OffAth4[] = {
/*  640x 480/ 8 */
 N_VRAM,  0,   480,   640,  6073, 0x000000ff,   0,
/*  640x 480/ 8 Z */
 N_VRAM,  0,   480,   640,  2796, 0x000000ff,   0,
 N_VRAM,  0,  4237,   640,  2315, 0x000000ff,   0,
 Z_VRAM,  0,  3276,   640,   960, 0x000000ff, 512,
/*  640x 480/ 8 DB */
 N_VRAM,  0,   960,   640,  5593, 0x000000ff,   0,
DB_VRAM,  0,   480,   640,   480, 0x000000ff,   0,
/*  640x 480/ 8 DB+Z */
 N_VRAM,  0,  4237,   640,  2315, 0x000000ff,   0,
 N_VRAM,  0,   480,   640,  1158, 0x000000ff,   0,
 N_VRAM,  0,  2119,   640,  1157, 0x000000ff,   0,
 Z_VRAM,  0,  3276,   640,   960, 0x000000ff, 512,
DB_VRAM,  0,  1639,   640,   479, 0x000000ff,   0,
/*  640x 480/16 */
 N_VRAM,  0,   480,   640,  2796, 0x0000ffff,   0,
/*  640x 480/16 Z */
 N_VRAM,  0,   480,   640,  1158, 0x0000ffff,   0,
 N_VRAM,  0,  2119,   640,  1157, 0x0000ffff,   0,
 Z_VRAM,  0,  1638,   640,   480, 0x0000ffff, 256,
/*  640x 480/16 DB */
 N_VRAM,  0,   960,   640,  2316, 0x0000ffff,   0,
DB_VRAM,  0,   480,   640,   480, 0x0000ffff,   0,
/*  640x 480/16 DB+Z */
 N_VRAM,  0,   960,   640,   678, 0x0000ffff,   0,
 N_VRAM,  0,  2599,   640,   677, 0x0000ffff,   0,
 Z_VRAM,  0,  1638,   640,   480, 0x0000ffff, 256,
 Z_VRAM,  0,  2118,   640,   480, 0x0000ffff, 256,
DB_VRAM,  0,   480,   640,   480, 0x0000ffff,   0,
/*  640x 480/32 */
 N_VRAM,  0,   480,   640,  1158, 0xffffffff,   0,
 N_VRAM,  0,    0,    480,   640, 0xff000000,   0,
/*  640x 480/32 Z */
 N_VRAM,  0,  1060,   640,   578, 0xffffffff,   0,
 N_VRAM,  0,   480,   640,   339, 0xffffffff,   0,
 Z_VRAM,  0,   819,   640,   240, 0xffffffff, 128,
/*  640x 480/32 DB */
 N_VRAM,  0,   960,   640,   678, 0xffffffff,   0,
DB_VRAM,  0,   480,   640,   480, 0xffffffff,   0,
/*  800x 600/ 8 */
 N_VRAM,  0,   600,   800,  4642, 0x000000ff,   0,
/*  800x 600/ 8 Z */
 N_VRAM,  0,   600,   800,  2021, 0x000000ff,   0,
 N_VRAM,  0,  3822,   800,  1420, 0x000000ff,   0,
 Z_VRAM,  0,  2621,   800,  1200, 0x000000ff, 352,
/*  800x 600/ 8 DB */
 N_VRAM,  0,  1200,   800,  4042, 0x000000ff,   0,
DB_VRAM,  0,   600,   800,   600, 0x000000ff,   0,
/*  800x 600/ 8 DB+Z */
 N_VRAM,  0,  3822,   800,  1420, 0x000000ff,   0,
 N_VRAM,  0,   600,   800,   710, 0x000000ff,   0,
 N_VRAM,  0,  1911,   800,   709, 0x000000ff,   0,
 Z_VRAM,  0,  2621,   800,  1200, 0x000000ff, 352,
DB_VRAM,  0,  1311,   800,   599, 0x000000ff,   0,
/*  800x 600/16 */
 N_VRAM,  0,   600,   800,  2021, 0x0000ffff,   0,
/*  800x 600/16 Z */
 N_VRAM,  0,   600,   800,   710, 0x0000ffff,   0,
 N_VRAM,  0,  1911,   800,   709, 0x0000ffff,   0,
 Z_VRAM,  0,  1310,   800,   600, 0x0000ffff, 576,
/*  800x 600/16 DB */
 N_VRAM,  0,  1200,   800,  1421, 0x0000ffff,   0,
DB_VRAM,  0,   600,   800,   600, 0x0000ffff,   0,
/*  800x 600/16 DB+Z */
 N_VRAM,  0,  1200,   800,   110, 0x0000ffff,   0,
 N_VRAM,  0,  2511,   800,   109, 0x0000ffff,   0,
 Z_VRAM,  0,  1310,   800,   600, 0x0000ffff, 576,
 Z_VRAM,  0,  1910,   800,   600, 0x0000ffff, 576,
DB_VRAM,  0,   600,   800,   600, 0x0000ffff,   0,
/*  800x 600/32 */
 N_VRAM,  0,   600,   800,   710, 0xffffffff,   0,
 N_VRAM,  0,    0,    600,   800, 0xff000000,   0,
/*  800x 600/32 Z */
 N_VRAM,  0,   956,   800,   354, 0xffffffff,   0,
 N_VRAM,  0,   600,   800,    55, 0xffffffff,   0,
 Z_VRAM,  0,   655,   800,   300, 0xffffffff, 288,
/*  800x 600/32 DB */
 N_VRAM,  0,  1200,   800,   110, 0xffffffff,   0,
DB_VRAM,  0,   600,   800,   600, 0xffffffff,   0,
/* 1024x 768/ 8 */
 N_VRAM,  0,   768,  1024,  3328, 0x000000ff,   0,
/* 1024x 768/ 8 Z */
 N_VRAM,  0,   768,  1024,  1280, 0x000000ff,   0,
 N_VRAM,  0,  3585,  1024,   511, 0x000000ff,   0,
 Z_VRAM,  0,  2048,  1024,  1536, 0x000000ff,   0,
/* 1024x 768/ 8 DB */
 N_VRAM,  0,  1536,  1024,  2560, 0x000000ff,   0,
DB_VRAM,  0,   768,  1024,   768, 0x000000ff,   0,
/* 1024x 768/ 8 DB+Z */
 N_VRAM,  0,  3585,  1024,   511, 0x000000ff,   0,
 N_VRAM,  0,   768,  1024,   256, 0x000000ff,   0,
 N_VRAM,  0,  1793,  1024,   255, 0x000000ff,   0,
 Z_VRAM,  0,  2048,  1024,  1536, 0x000000ff,   0,
DB_VRAM,  0,  1025,  1024,   767, 0x000000ff,   0,
/* 1024x 768/16 */
 N_VRAM,  0,   768,  1024,  1280, 0x0000ffff,   0,
/* 1024x 768/16 Z */
 N_VRAM,  0,   768,  1024,   256, 0x0000ffff,   0,
 N_VRAM,  0,  1793,  1024,   255, 0x0000ffff,   0,
 Z_VRAM,  0,  1024,  1024,   768, 0x0000ffff,   0,
/* 1024x 768/16 DB */
 N_VRAM,  0,  1536,  1024,   512, 0x0000ffff,   0,
DB_VRAM,  0,   768,  1024,   768, 0x0000ffff,   0,
/* 1024x 768/32 */
 N_VRAM,  0,   768,  1024,   256, 0xffffffff,   0,
 N_VRAM,  0,    0,    768,  1024, 0xff000000,   0,
/* 1152x 882/ 8 */
 N_VRAM,  0,   882,  1152,  2758, 0x000000ff,   0,
/* 1152x 882/ 8 Z */
 N_VRAM,  0,   882,  1152,   938, 0x000000ff,   0,
 N_VRAM,  0,  3585,  1152,    55, 0x000000ff,   0,
 Z_VRAM,  0,  1820,  1152,  1764, 0x000000ff, 512,
/* 1152x 882/ 8 DB */
 N_VRAM,  0,  1764,  1152,  1876, 0x000000ff,   0,
DB_VRAM,  0,   882,  1152,   882, 0x000000ff,   0,
/* 1152x 882/ 8 DB+Z */
 N_VRAM,  0,  3585,  1152,    55, 0x000000ff,   0,
 N_VRAM,  0,   882,  1152,    28, 0x000000ff,   0,
 N_VRAM,  0,  1793,  1152,    27, 0x000000ff,   0,
 Z_VRAM,  0,  1820,  1152,  1764, 0x000000ff, 512,
DB_VRAM,  0,   911,  1152,   881, 0x000000ff,   0,
/* 1152x 882/16 */
 N_VRAM,  0,   882,  1152,   938, 0x0000ffff,   0,
/* 1152x 882/16 Z */
 N_VRAM,  0,   882,  1152,    28, 0x0000ffff,   0,
 N_VRAM,  0,  1793,  1152,    27, 0x0000ffff,   0,
 Z_VRAM,  0,   910,  1152,   882, 0x0000ffff, 256,
/* 1152x 882/16 DB */
 N_VRAM,  0,  1764,  1152,    56, 0x0000ffff,   0,
DB_VRAM,  0,   882,  1152,   882, 0x0000ffff,   0,
/* 1152x 882/32 */
 N_VRAM,  0,   882,  1152,    28, 0xffffffff,   0,
 N_VRAM,  0,    0,    882,  1152, 0xff000000,   0,
/* 1280x1024/ 8 */
 N_VRAM,  0,  1024,  1280,  2252, 0x000000ff,   0,
/* 1280x1024/ 8 DB */
 N_VRAM,  0,  2048,  1280,  1228, 0x000000ff,   0,
DB_VRAM,  0,  1024,  1280,  1024, 0x000000ff,   0,
/* 1280x1024/16 */
 N_VRAM,  0,  1024,  1280,   614, 0x0000ffff,   0,
/* 1280x1024/ 24 */
 N_VRAM,  0,  1024,  1280,    68, 0x00ffffff,   0,
/* 1600x1200/ 8 */
 N_VRAM,  0,  1200,  1600,  1421, 0x000000ff,   0,
/* 1600x1200/ 8 DB */
 N_VRAM,  0,  2400,  1600,   221, 0x000000ff,   0,
DB_VRAM,  0,  1200,  1600,  1200, 0x000000ff,   0,
/* 1600x1200/16 */
 N_VRAM,  0,  1200,  1600,   110, 0x0000ffff,   0,
/*  768x 576/ 8 */
 N_VRAM,  0,   576,   768,  4885, 0x000000ff,   0,
/*  768x 576/ 8 Z */
 N_VRAM,  0,   576,   768,  2154, 0x000000ff,   0,
 N_VRAM,  0,  3883,   768,  1577, 0x000000ff,   0,
 Z_VRAM,  0,  2730,   768,  1152, 0x000000ff, 512,
/*  768x 576/ 8 DB */
 N_VRAM,  0,  1152,   768,  4309, 0x000000ff,   0,
DB_VRAM,  0,   576,   768,   576, 0x000000ff,   0,
/*  768x 576/ 8 DB+Z */
 N_VRAM,  0,  3883,   768,  1577, 0x000000ff,   0,
 N_VRAM,  0,   576,   768,   789, 0x000000ff,   0,
 N_VRAM,  0,  1942,   768,   788, 0x000000ff,   0,
 Z_VRAM,  0,  2730,   768,  1152, 0x000000ff, 512,
DB_VRAM,  0,  1366,   768,   575, 0x000000ff,   0,
/*  768x 576/16 */
 N_VRAM,  0,   576,   768,  2154, 0x0000ffff,   0,
/*  768x 576/16 Z */
 N_VRAM,  0,   576,   768,   789, 0x0000ffff,   0,
 N_VRAM,  0,  1942,   768,   788, 0x0000ffff,   0,
 Z_VRAM,  0,  1365,   768,   576, 0x0000ffff, 256,
/*  768x 576/16 DB */
 N_VRAM,  0,  1152,   768,  1578, 0x0000ffff,   0,
DB_VRAM,  0,   576,   768,   576, 0x0000ffff,   0,
/*  768x 576/16 DB+Z */
 N_VRAM,  0,  1152,   768,   213, 0x0000ffff,   0,
 N_VRAM,  0,  2518,   768,   212, 0x0000ffff,   0,
 Z_VRAM,  0,  1365,   768,   576, 0x0000ffff, 256,
 Z_VRAM,  0,  1941,   768,   576, 0x0000ffff, 256,
DB_VRAM,  0,   576,   768,   576, 0x0000ffff,   0,
/*  768x 576/32 */
 N_VRAM,  0,   576,   768,   789, 0xffffffff,   0,
 N_VRAM,  0,    0,    576,   768, 0xff000000,   0,
/*  768x 576/32 Z */
 N_VRAM,  0,   971,   768,   393, 0xffffffff,   0,
 N_VRAM,  0,   576,   768,   106, 0xffffffff,   0,
 Z_VRAM,  0,   682,   768,   288, 0xffffffff, 512,
/*  768x 576/32 DB */
 N_VRAM,  0,  1152,   768,   213, 0xffffffff,   0,
DB_VRAM,  0,   576,   768,   576, 0xffffffff,   0,
};


/*----------------------------------*/
/*** MGA PCI 4Mb (Atlas+Athena) ***/
/*----------------------------------*/

OffScrData iOffAth4[] = {
/*  640x 480/ 8 */
 N_VRAM,    0,  480,  768, 4981, 0x000000ff,   0,
 N_VRAM,  480,    0,  128,  480, 0x000000ff,   0,
/*  640x 480/ 8 Z */
 N_VRAM,    0,  480,  768, 2250, 0x000000ff,   0,
 N_VRAM,    0, 3531,  768, 1929, 0x000000ff,   0,
 N_VRAM,  640,    0,  128, 2730, 0x000000ff,   0,
 N_VRAM,  640, 3531,  128, 1929, 0x000000ff,   0,
 Z_VRAM,    0, 2730,  768,  800, 0x000000ff, 512,
/*  640x 480/ 8 DB */
 N_VRAM,    0,  960,  768, 4501, 0x000000ff,   0,
 N_VRAM,  640,    0,  128,  480, 0x000000ff,   0,
DB_VRAM,    0,  480,  768,  480, 0x000000ff,   0,
/*  640x 480/ 8 DB+Z */
 N_VRAM,    0, 3531,  768, 1929, 0x000000ff,   0,
 N_VRAM,    0,  480,  768,  885, 0x000000ff,   0,
 N_VRAM,    0, 1846,  768,  884, 0x000000ff,   0,
 N_VRAM,  640,    0,  128,  480, 0x000000ff,   0,
 N_VRAM,  640, 1364,  128,  479, 0x000000ff,   0,
 Z_VRAM,    0, 2731,  768,  799, 0x000000ff, 512,
DB_VRAM,    0, 1366,  768,  479, 0x000000ff,   0,
/*  640x 480/16 */
 N_VRAM,    0,  480,  768, 2250, 0x0000ffff,   0,
 N_VRAM,  480,    0,  128,  480, 0x0000ffff,   0,
/*  640x 480/16 Z */
 N_VRAM,    0, 1766,  768,  964, 0x0000ffff,   0,
 N_VRAM,    0,  480,  768,  885, 0x0000ffff,   0,
 N_VRAM,  640,    0,  128, 1365, 0x0000ffff,   0,
 N_VRAM,  640, 1766,  128,  964, 0x0000ffff,   0,
 Z_VRAM,    0, 1365,  768,  400, 0x0000ffff, 256,
/*  640x 480/16 DB */
 N_VRAM,    0,  960,  768, 1770, 0x0000ffff,   0,
 N_VRAM,  640,    0,  128,  480, 0x0000ffff,   0,
DB_VRAM,    0,  480,  768,  480, 0x0000ffff,   0,
/*  640x 480/16 DB+Z */
 N_VRAM,    0,  960,  768,  810, 0x0000ffff,   0,
 N_VRAM,    0, 4331,  768,  564, 0x0000ffff,   0,
 N_VRAM,  640,    0,  128,  960, 0x0000ffff,   0,
 Z_VRAM,    0, 1366,  768,  399, 0x0000ffff, 256,
 Z_VRAM,    0, 1766,  768,  399, 0x0000ffff, 256,
DB_VRAM,    0,  480,  768,  480, 0x0000ffff,   0,
/*  640x 480/32 */
 N_VRAM,    0,  480,  768,  885, 0xffffffff,   0,
 N_VRAM,  480,    0,  128,  480, 0xffffffff,   0,
 N_VRAM,    0,    0,  480,  768, 0xff000000,   0,
/*  640x 480/32 Z */
 N_VRAM,    0,  883,  768,  481, 0xffffffff,   0,
 N_VRAM,    0,  480,  768,  202, 0xffffffff,   0,
 N_VRAM,  640,    0,  128,  682, 0xffffffff,   0,
 N_VRAM,  640,  883,  128,  481, 0xffffffff,   0,
 Z_VRAM,    0,  682,  768,  200, 0xffffffff, 512,
/*  640x 480/32 DB */
 N_VRAM,    0,  960,  768,  405, 0xffffffff,   0,
 N_VRAM,  640,    0,  128,  480, 0xffffffff,   0,
DB_VRAM,    0,  480,  768,  480, 0xffffffff,   0,
/*  800x 600/ 8 */
 N_VRAM,    0,  600, 1024, 3496, 0x000000ff,   0,
 N_VRAM,  600,    0,  224,  600, 0x000000ff,   0,
/*  800x 600/ 8 Z */
 N_VRAM,    0,  600, 1024, 1448, 0x000000ff,   0,
 N_VRAM,    0, 2986, 1024, 1109, 0x000000ff,   0,
 N_VRAM,  800,    0,  224, 2048, 0x000000ff,   0,
 N_VRAM,  800, 2986,  224, 1109, 0x000000ff,   0,
 Z_VRAM,    0, 2048, 1024,  937, 0x000000ff,   0,
/*  800x 600/ 8 DB */
 N_VRAM,    0, 1200, 1024, 2896, 0x000000ff,   0,
 N_VRAM,  800,    0,  224,  600, 0x000000ff,   0,
DB_VRAM,    0,  600, 1024,  600, 0x000000ff,   0,
/*  800x 600/16 */
 N_VRAM,    0,  600, 1024, 1448, 0x0000ffff,   0,
 N_VRAM,  600,    0,  224,  600, 0x0000ffff,   0,
/*  800x 600/16 Z */
 N_VRAM,    0, 1493, 1024,  554, 0x0000ffff,   0,
 N_VRAM,    0,  600, 1024,  424, 0x0000ffff,   0,
 N_VRAM,  800,    0,  224, 1024, 0x0000ffff,   0,
 N_VRAM,  800, 1493,  224,  554, 0x0000ffff,   0,
 Z_VRAM,    0, 1024, 1024,  468, 0x0000ffff,   0,
/*  800x 600/16 DB */
 N_VRAM,    0, 1200, 1024,  848, 0x0000ffff,   0,
 N_VRAM,  800,    0,  224,  600, 0x0000ffff,   0,
DB_VRAM,    0,  600, 1024,  600, 0x0000ffff,   0,
/*  800x 600/32 */
 N_VRAM,    0,  600, 1024,  424, 0xffffffff,   0,
 N_VRAM,  600,    0,  224,  600, 0xffffffff,   0,
 N_VRAM,    0,    0,  600, 1024, 0xff000000,   0,
/* 1024x 768/ 8 */
 N_VRAM,    0,  768, 1024, 3328, 0x000000ff,   0,
 N_VRAM,  768,    0,    0,  768, 0x000000ff,   0,
/* 1024x 768/ 8 Z */
 N_VRAM,    0,  768, 1024, 1280, 0x000000ff,   0,
 N_VRAM,    0, 3585, 1024,  511, 0x000000ff,   0,
 N_VRAM, 1024,    0,    0, 2048, 0x000000ff,   0,
 N_VRAM, 1024, 3585,    0,  511, 0x000000ff,   0,
 Z_VRAM,    0, 2048, 1024, 1536, 0x000000ff,   0,
/* 1024x 768/ 8 DB */
 N_VRAM,    0, 1536, 1024, 2560, 0x000000ff,   0,
 N_VRAM, 1024,    0,    0,  768, 0x000000ff,   0,
DB_VRAM,    0,  768, 1024,  768, 0x000000ff,   0,
/* 1024x 768/16 */
 N_VRAM,    0,  768, 1024, 1280, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0,  768, 0x0000ffff,   0,
/* 1024x 768/16 Z */
 N_VRAM,    0, 1793, 1024,  255, 0x0000ffff,   0,
 N_VRAM,    0,  768, 1024,  256, 0x0000ffff,   0,
 N_VRAM, 1024,    0,    0, 1024, 0x0000ffff,   0,
 N_VRAM, 1024, 1793,    0,  255, 0x0000ffff,   0,
 Z_VRAM,    0, 1024, 1024,  768, 0x0000ffff,   0,
/* 1024x 768/16 DB */
 N_VRAM,    0, 1536, 1024,  512, 0x0000ffff,   0,
 N_VRAM, 1024,    0,    0,  768, 0x0000ffff,   0,
DB_VRAM,    0,  768, 1024,  768, 0x0000ffff,   0,
/* 1024x 768/32 */
 N_VRAM,    0,  768, 1024,  256, 0xffffffff,   0,
 N_VRAM,  768,    0,    0,  768, 0xffffffff,   0,
 N_VRAM,    0,    0,  768, 1024, 0xff000000,   0,
/* 1152x 882/ 8 */
 N_VRAM,    0,  882, 1280, 2394, 0x000000ff,   0,
 N_VRAM,  882,    0,  128,  882, 0x000000ff,   0,
/* 1152x 882/ 8 Z */
 N_VRAM,    0,  882, 1280,  756, 0x000000ff,   0,
 N_VRAM,    0, 3227, 1280,   49, 0x000000ff,   0,
 N_VRAM, 1152,    0,  128, 1638, 0x000000ff,   0,
 N_VRAM, 1152, 3227,  128,   49, 0x000000ff,   0,
 Z_VRAM,    0, 1638, 1280, 1587, 0x000000ff, 512,
/* 1152x 882/ 8 DB */
 N_VRAM,    0, 1764, 1280, 1512, 0x000000ff,   0,
 N_VRAM, 1152,    0,  128,  882, 0x000000ff,   0,
DB_VRAM,    0,  882, 1280,  882, 0x000000ff,   0,
/* 1152x 882/16 */
 N_VRAM,    0,  882, 1280,  756, 0x0000ffff,   0,
 N_VRAM,  882,    0,  128,  882, 0x0000ffff,   0,
/* 1280x1024/ 8 */
 N_VRAM,    0, 1024, 1280, 2252, 0x000000ff,   0,
 N_VRAM, 1024,    0,    0, 1024, 0x000000ff,   0,
/* 1280x1024/ 8 DB */
 N_VRAM,    0, 2048, 1280, 1228, 0x000000ff,   0,
 N_VRAM, 1280,    0,    0, 1024, 0x000000ff,   0,
DB_VRAM,    0, 1024, 1280, 1024, 0x000000ff,   0,
/* 1280x1024/16 */
 N_VRAM,    0, 1024, 1280,  614, 0x0000ffff,   0,
 N_VRAM, 1024,    0,    0, 1024, 0x0000ffff,   0,
/* 1600x1200/ 8 */
 N_VRAM,    0, 1200, 1600, 1421, 0x000000ff,   0,
 N_VRAM, 1200,    0,    0, 1200, 0x000000ff,   0,
/* 1600x1200/ 8 DB */
 N_VRAM,    0, 2400, 1600,  221, 0x000000ff,   0,
 N_VRAM, 1600,    0,    0, 1200, 0x000000ff,   0,
DB_VRAM,    0, 1200, 1600, 1200, 0x000000ff,   0,
/* 1600x1200/16 */
 N_VRAM,    0, 1200, 1600,  110, 0x0000ffff,   0,
 N_VRAM, 1200,    0,    0, 1200, 0x0000ffff,   0,
/*  768x 576/ 8 */
 N_VRAM,    0,  576,  768, 4885, 0x000000ff,   0,
 N_VRAM,  576,    0,    0,  576, 0x000000ff,   0,
/*  768x 576/ 8 Z */
 N_VRAM,    0,  576,  768, 2154, 0x000000ff,   0,
 N_VRAM,    0, 3883,  768, 1577, 0x000000ff,   0,
 N_VRAM,  768,    0,    0, 2730, 0x000000ff,   0,
 N_VRAM,  768, 3883,    0, 1577, 0x000000ff,   0,
 Z_VRAM,    0, 2730,  768, 1152, 0x000000ff, 512,
/*  768x 576/ 8 DB */
 N_VRAM,    0, 1152,  768, 4309, 0x000000ff,   0,
 N_VRAM,  768,    0,    0,  576, 0x000000ff,   0,
DB_VRAM,    0,  576,  768,  576, 0x000000ff,   0,
/*  768x 576/ 8 DB+Z */
 N_VRAM,    0, 3883,  768, 1577, 0x000000ff,   0,
 N_VRAM,    0,  576,  768,  789, 0x000000ff,   0,
 N_VRAM,    0, 1942,  768,  788, 0x000000ff,   0,
 N_VRAM,  768,    0,    0,  576, 0x000000ff,   0,
 N_VRAM,  768, 1364,    0,  575, 0x000000ff,   0,
 Z_VRAM,    0, 2731,  768, 1151, 0x000000ff, 512,
DB_VRAM,    0, 1366,  768,  575, 0x000000ff,   0,
/*  768x 576/16 */
 N_VRAM,    0,  576,  768, 2154, 0x0000ffff,   0,
 N_VRAM,  576,    0,    0,  576, 0x0000ffff,   0,
/*  768x 576/16 Z */
 N_VRAM,    0, 1942,  768,  788, 0x0000ffff,   0,
 N_VRAM,    0,  576,  768,  789, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0, 1365, 0x0000ffff,   0,
 N_VRAM,  768, 1942,    0,  788, 0x0000ffff,   0,
 Z_VRAM,    0, 1365,  768,  576, 0x0000ffff, 256,
/*  768x 576/16 DB */
 N_VRAM,    0, 1152,  768, 1578, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0,  576, 0x0000ffff,   0,
DB_VRAM,    0,  576,  768,  576, 0x0000ffff,   0,
/*  768x 576/16 DB+Z */
 N_VRAM,    0, 1152,  768,  426, 0x0000ffff,   0,
 N_VRAM,    0, 5035,  768,  212, 0x0000ffff,   0,
 N_VRAM,  768,    0,    0, 1152, 0x0000ffff,   0,
 Z_VRAM,    0, 1366,  768,  575, 0x0000ffff, 256,
 Z_VRAM,    0, 1942,  768,  575, 0x0000ffff, 256,
DB_VRAM,    0,  576,  768,  576, 0x0000ffff,   0,
/*  768x 576/32 */
 N_VRAM,    0,  576,  768,  789, 0xffffffff,   0,
 N_VRAM,  576,    0,    0,  576, 0xffffffff,   0,
 N_VRAM,    0,    0,  576,  768, 0xff000000,   0,
/*  768x 576/32 Z */
 N_VRAM,    0,  971,  768,  393, 0xffffffff,   0,
 N_VRAM,    0,  576,  768,  106, 0xffffffff,   0,
 N_VRAM,  768,    0,    0,  682, 0xffffffff,   0,
 N_VRAM,  768,  971,    0,  393, 0xffffffff,   0,
 Z_VRAM,    0,  682,  768,  288, 0xffffffff, 512,
/*  768x 576/32 DB */
 N_VRAM,    0, 1152,  768,  213, 0xffffffff,   0,
 N_VRAM,  768,    0,    0,  576, 0xffffffff,   0,
DB_VRAM,    0,  576,  768,  576, 0xffffffff,   0,
};


/*----------------------------------*/
/*** MGA PCI 4Mb (Atlas+Athena) ***/
/*----------------------------------*/

HwModeData ModesAth4[98] = {
  640,  480,         0, 0,  8,      256,  640,  1, &OffAth4[0],
  640,  480,         0, Z,  8,      256,  640,  3, &OffAth4[1],
  640,  480,        DB, 0,  8,      256,  640,  2, &OffAth4[4],
  640,  480,        DB, Z,  8,      256,  640,  5, &OffAth4[6],
  640,  480,       LUT, 0,  8,      256,  640,  1, &OffAth4[0],
  640,  480,    DB+LUT, 0,  8,      256,  640,  1, &OffAth4[0],
  640,  480,         0, 0, 16,    32768,  640,  1, &OffAth4[11],
  640,  480,         0, Z, 16,    32768,  640,  3, &OffAth4[12],
  640,  480,        DB, 0, 16,    32768,  640,  2, &OffAth4[15],
  640,  480,        DB, Z, 16,    32768,  640,  5, &OffAth4[17],
  640,  480,      M565, 0, 16,    65536,  640,  1, &OffAth4[11],
  640,  480,   M565+DB, 0, 16,    65536,  640,  2, &OffAth4[15],
  640,  480,         0, 0, 32, 16777216,  640,  2, &OffAth4[22],
  640,  480,         0, Z, 32, 16777216,  640,  3, &OffAth4[24],
  640,  480,        DB, 0, 32, 16777216,  640,  2, &OffAth4[27],
  800,  600,         0, 0,  8,      256,  800,  1, &OffAth4[29],
  800,  600,         0, Z,  8,      256,  800,  3, &OffAth4[30],
  800,  600,        DB, 0,  8,      256,  800,  2, &OffAth4[33],
  800,  600,        DB, Z,  8,      256,  800,  5, &OffAth4[35],
  800,  600,       LUT, 0,  8,      256,  800,  1, &OffAth4[29],
  800,  600,    DB+LUT, 0,  8,      256,  800,  1, &OffAth4[29],
  800,  600,         0, 0, 16,    32768,  800,  1, &OffAth4[40],
  800,  600,         0, Z, 16,    32768,  800,  3, &OffAth4[41],
  800,  600,        DB, 0, 16,    32768,  800,  2, &OffAth4[44],
  800,  600,        DB, Z, 16,    32768,  800,  5, &OffAth4[46],
  800,  600,      M565, 0, 16,    65536,  800,  1, &OffAth4[40],
  800,  600,   M565+DB, 0, 16,    65536,  800,  2, &OffAth4[44],
  800,  600,         0, 0, 32, 16777216,  800,  2, &OffAth4[51],
  800,  600,         0, Z, 32, 16777216,  800,  3, &OffAth4[53],
  800,  600,        DB, 0, 32, 16777216,  800,  2, &OffAth4[56],
 1024,  768,         0, 0,  8,      256, 1024,  1, &OffAth4[58],
 1024,  768,         0, Z,  8,      256, 1024,  3, &OffAth4[59],
 1024,  768,        DB, 0,  8,      256, 1024,  2, &OffAth4[62],
 1024,  768,        DB, Z,  8,      256, 1024,  5, &OffAth4[64],
 1024,  768,       LUT, 0,  8,      256, 1024,  1, &OffAth4[58],
 1024,  768,    DB+LUT, 0,  8,      256, 1024,  1, &OffAth4[58],
 1024,  768,         0, 0, 16,    32768, 1024,  1, &OffAth4[69],
 1024,  768,         0, Z, 16,    32768, 1024,  3, &OffAth4[70],
 1024,  768,        DB, 0, 16,    32768, 1024,  2, &OffAth4[73],
 1024,  768,      M565, 0, 16,    65536, 1024,  1, &OffAth4[69],
 1024,  768,   M565+DB, 0, 16,    65536, 1024,  2, &OffAth4[73],
 1024,  768,         0, 0, 32, 16777216, 1024,  2, &OffAth4[75],
 1152,  882,         0, 0,  8,      256, 1152,  1, &OffAth4[77],
 1152,  882,         0, Z,  8,      256, 1152,  3, &OffAth4[78],
 1152,  882,        DB, 0,  8,      256, 1152,  2, &OffAth4[81],
 1152,  882,        DB, Z,  8,      256, 1152,  5, &OffAth4[83],
 1152,  882,       LUT, 0,  8,      256, 1152,  1, &OffAth4[77],
 1152,  882,    DB+LUT, 0,  8,      256, 1152,  1, &OffAth4[77],
 1152,  882,         0, 0, 16,    32768, 1152,  1, &OffAth4[88],
 1152,  882,         0, Z, 16,    32768, 1152,  3, &OffAth4[89],
 1152,  882,        DB, 0, 16,    32768, 1152,  2, &OffAth4[92],
 1152,  882,      M565, 0, 16,    65536, 1152,  1, &OffAth4[88],
 1152,  882,   M565+DB, 0, 16,    65536, 1152,  2, &OffAth4[92],
 1152,  882,         0, 0, 32, 16777216, 1152,  2, &OffAth4[94],
 1280, 1024,         0, 0,  8,      256, 1280,  1, &OffAth4[96],
 1280, 1024,        DB, 0,  8,      256, 1280,  2, &OffAth4[97],
 1280, 1024,       LUT, 0,  8,      256, 1280,  1, &OffAth4[96],
 1280, 1024,    DB+LUT, 0,  8,      256, 1280,  1, &OffAth4[96],
 1280, 1024,         0, 0, 16,    32768, 1280,  1, &OffAth4[99],
 1280, 1024,      M565, 0, 16,    65536, 1280,  1, &OffAth4[99],
 1280, 1024,         0, 0, 24, 16777216, 1280,  1, &OffAth4[100],
 1600, 1200,         0, 0,  8,      256, 1600,  1, &OffAth4[101],
 1600, 1200,        DB, 0,  8,      256, 1600,  2, &OffAth4[102],
 1600, 1200,       LUT, 0,  8,      256, 1600,  1, &OffAth4[101],
 1600, 1200,    DB+LUT, 0,  8,      256, 1600,  1, &OffAth4[101],
 1600, 1200,         0, 0, 16,    32768, 1600,  1, &OffAth4[104],
 1600, 1200,      M565, 0, 16,    65536, 1600,  1, &OffAth4[104],
  640,  480,        TV, 0,  8,      256,  640,  1, &OffAth4[0],
  640,  480,        TV, Z,  8,      256,  640,  3, &OffAth4[1],
  640,  480,     TV+DB, 0,  8,      256,  640,  2, &OffAth4[4],
  640,  480,     TV+DB, Z,  8,      256,  640,  5, &OffAth4[6],
  640,  480,    TV+LUT, 0,  8,      256,  640,  1, &OffAth4[0],
  640,  480, TV+DB+LUT, 0,  8,      256,  640,  1, &OffAth4[0],
  640,  480,        TV, 0, 16,    32768,  640,  1, &OffAth4[11],
  640,  480,        TV, Z, 16,    32768,  640,  3, &OffAth4[12],
  640,  480,     TV+DB, 0, 16,    32768,  640,  2, &OffAth4[15],
  640,  480,     TV+DB, Z, 16,    32768,  640,  5, &OffAth4[17],
  640,  480,   TV+M565, 0, 16,    65536,  640,  1, &OffAth4[11],
  640,  480,TV+M565+DB, 0, 16,    65536,  640,  2, &OffAth4[15],
  640,  480,        TV, 0, 32, 16777216,  640,  2, &OffAth4[22],
  640,  480,        TV, Z, 32, 16777216,  640,  3, &OffAth4[24],
  640,  480,     TV+DB, 0, 32, 16777216,  640,  2, &OffAth4[27],
  768,  576,        TV, 0,  8,      256,  768,  1, &OffAth4[105],
  768,  576,        TV, Z,  8,      256,  768,  3, &OffAth4[106],
  768,  576,     TV+DB, 0,  8,      256,  768,  2, &OffAth4[109],
  768,  576,     TV+DB, Z,  8,      256,  768,  5, &OffAth4[111],
  768,  576,    TV+LUT, 0,  8,      256,  768,  1, &OffAth4[105],
  768,  576, TV+DB+LUT, 0,  8,      256,  768,  1, &OffAth4[105],
  768,  576,        TV, 0, 16,    32768,  768,  1, &OffAth4[116],
  768,  576,        TV, Z, 16,    32768,  768,  3, &OffAth4[117],
  768,  576,     TV+DB, 0, 16,    32768,  768,  2, &OffAth4[120],
  768,  576,     TV+DB, Z, 16,    32768,  768,  5, &OffAth4[122],
  768,  576,   TV+M565, 0, 16,    65536,  768,  1, &OffAth4[116],
  768,  576,TV+M565+DB, 0, 16,    65536,  768,  2, &OffAth4[120],
  768,  576,        TV, 0, 32, 16777216,  768,  2, &OffAth4[127],
  768,  576,        TV, Z, 32, 16777216,  768,  3, &OffAth4[129],
  768,  576,     TV+DB, 0, 32, 16777216,  768,  2, &OffAth4[132],
{(word) -1}
};


/*----------------------------------*/
/*** MGA PCI 4Mb (Atlas+Athena) ***/
/*----------------------------------*/

HwModeInterlace iModesAth4[98] = {
/*  640x 480/ 8 */   768,         0, 2, &iOffAth4[0],
/*  640x 480/ 8 */   768,         0, 5, &iOffAth4[2],
/*  640x 480/ 8 */   768,        DB, 3, &iOffAth4[7],
/*  640x 480/ 8 */   768,        DB, 7, &iOffAth4[10],
/*  640x 480/ 8 */   768,       LUT, 2, &iOffAth4[0],
/*  640x 480/ 8 */   768,    DB+LUT, 2, &iOffAth4[0],
/*  640x 480/16 */   768,         0, 2, &iOffAth4[17],
/*  640x 480/16 */   768,         0, 5, &iOffAth4[19],
/*  640x 480/16 */   768,        DB, 3, &iOffAth4[24],
/*  640x 480/16 */   768,        DB, 6, &iOffAth4[27],
/*  640x 480/16 */   768,      M565, 2, &iOffAth4[17],
/*  640x 480/16 */   768,   M565+DB, 3, &iOffAth4[24],
/*  640x 480/32 */   768,         0, 3, &iOffAth4[33],
/*  640x 480/32 */   768,         0, 5, &iOffAth4[36],
/*  640x 480/32 */   768,        DB, 3, &iOffAth4[41],
/*  800x 600/ 8 */  1024,         0, 2, &iOffAth4[44],
/*  800x 600/ 8 */  1024,         0, 5, &iOffAth4[46],
/*  800x 600/ 8 */  1024,        DB, 3, &iOffAth4[51],
/*  800x 600/ 8 */  1024,        DB, 0, &iOffAth4[54],
/*  800x 600/ 8 */  1024,       LUT, 2, &iOffAth4[44],
/*  800x 600/ 8 */  1024,    DB+LUT, 2, &iOffAth4[44],
/*  800x 600/16 */  1024,         0, 2, &iOffAth4[54],
/*  800x 600/16 */  1024,         0, 5, &iOffAth4[56],
/*  800x 600/16 */  1024,        DB, 3, &iOffAth4[61],
/*  800x 600/16 */  1024,        ND, 0, 0,
/*  800x 600/16 */  1024,      M565, 2, &iOffAth4[54],
/*  800x 600/16 */  1024,   M565+DB, 3, &iOffAth4[61],
/*  800x 600/32 */  1024,         0, 3, &iOffAth4[64],
/*  800x 600/32 */  1024,        ND, 0, 0,
/*  800x 600/32 */  1024,        ND, 0, 0,
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/ 8 */   {0},
/* 1024x 768/16 */   {0},
/* 1024x 768/16 */   {0},
/* 1024x 768/16 */   {0},
/* 1024x 768/16 */   {0},
/* 1024x 768/16 */   {0},
/* 1024x 768/32 */   {0},
/* 1152x 882/ 8 */  1280,         0, 2, &iOffAth4[90],
/* 1152x 882/ 8 */  1280,         0, 5, &iOffAth4[92],
/* 1152x 882/ 8 */  1280,        DB, 3, &iOffAth4[97],
/* 1152x 882/ 8 */  1280,        ND, 0, 0,
/* 1152x 882/ 8 */  1280,       LUT, 2, &iOffAth4[90],
/* 1152x 882/ 8 */  1280,    DB+LUT, 2, &iOffAth4[90],
/* 1152x 882/16 */  1280,         0, 2, &iOffAth4[100],
/* 1152x 882/16 */  1280,        ND, 0, 0,
/* 1152x 882/16 */  1280,        ND, 0, 0,
/* 1152x 882/16 */  1280,      M565, 2, &iOffAth4[100],
/* 1152x 882/16 */  1280,        ND, 0, 0,
/* 1152x 882/32 */  1280,        ND, 0, 0,
/* 1280x1024/ 8 */   {0},
/* 1280x1024/ 8 */   {0},
/* 1280x1024/ 8 */   {0},
/* 1280x1024/ 8 */   {0},
/* 1280x1024/16 */   {0},
/* 1280x1024/16 */   {0},
/* 1280x1024/24 */   {0},
/* 1600x1200/ 8 */  1600,         0, 2, &iOffAth4[109],
/* 1600x1200/ 8 */  1600,        DB, 3, &iOffAth4[111],
/* 1600x1200/ 8 */  1600,       LUT, 2, &iOffAth4[109],
/* 1600x1200/ 8 */  1600,    DB+LUT, 2, &iOffAth4[109],
/* 1600x1200/16 */  1600,         0, 2, &iOffAth4[114],
/* 1600x1200/16 */  1600,      M565, 2, &iOffAth4[114],
/*  640x 480/ 8 */   768,        TV, 2, &iOffAth4[0],
/*  640x 480/ 8 */   768,        TV, 5, &iOffAth4[2],
/*  640x 480/ 8 */   768,     TV+DB, 3, &iOffAth4[7],
/*  640x 480/ 8 */   768,     TV+DB, 7, &iOffAth4[10],
/*  640x 480/ 8 */   768,    TV+LUT, 2, &iOffAth4[0],
/*  640x 480/ 8 */   768, TV+DB+LUT, 2, &iOffAth4[0],
/*  640x 480/16 */   768,        TV, 2, &iOffAth4[17],
/*  640x 480/16 */   768,        TV, 5, &iOffAth4[19],
/*  640x 480/16 */   768,     TV+DB, 3, &iOffAth4[24],
/*  640x 480/16 */   768,     TV+DB, 6, &iOffAth4[27],
/*  640x 480/16 */   768,   TV+M565, 2, &iOffAth4[17],
/*  640x 480/16 */   768,TV+M565+DB, 3, &iOffAth4[24],
/*  640x 480/32 */   768,        TV, 3, &iOffAth4[33],
/*  640x 480/32 */   768,        TV, 5, &iOffAth4[36],
/*  640x 480/32 */   768,     TV+DB, 3, &iOffAth4[41],
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/ 8 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/16 */   {0},
/*  768x 576/32 */   {0},
/*  768x 576/32 */   {0},
/*  768x 576/32 */   {0},
{(word) -1}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\vid.c ===
/*/****************************************************************************
*          name: MGAVidInit
*
*   description: Initialise the VIDEO related hardware of the MGA device.
*
*      designed: Bart Simpson, february 11, 1993
* last modified: $Author: bleblanc $, $Date: 94/11/09 10:48:34 $
*
*       version: $Id: VID.C 1.49 94/11/09 10:48:34 bleblanc Exp $
*
*    parameters: BYTE* to Video buffer
*      modifies: MGA hardware
*         calls: GetMGAConfiguration
*       returns: -
******************************************************************************/

#include "switches.h"
#include "g3dstd.h"

#include "caddi.h"
#include "def.h"
#include "mga.h"

#include "global.h"
#include "proto.h"

#include "mgai.h"

#ifdef WINDOWS_NT
#include "video.h"
#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,MGAVidInit)
#endif
#endif

/* extern void setTVP3026Freq(volatile BYTE _Far *pDevice, LONG fout_voulue, LONG reg, WORD pWidth); */

/*--------------  start of extern global variables -----------------------*/

VOID MGAVidInit(BYTE* pInitBuffer, BYTE* pVideoBuffer)
   {
   DWORD DST0, DST1, Info;
   DWORD TmpDword, ByteCount, RegisterCount;
   BYTE TmpByte, DUB_SEL;
   BOOL pixelClk90Mhz;
   volatile BYTE _Far *pDevice;
   WORD res;

#if( defined(WINDOWS) || defined(OS2))

   ((struct {unsigned short o; short s;}*) &pDevice)->o = *((WORD*)(pInitBuffer + INITBUF_MgaOffset));
   ((struct {unsigned short o; short s;}*) &pDevice)->s = *((WORD*)(pInitBuffer + INITBUF_MgaSegment));

#else
  #ifdef WINDOWS_NT

     pDevice = (BYTE *)(*((DWORD*)(pInitBuffer + INITBUF_MgaOffset)));

  #else

    #ifdef __MICROSOFTC600__
       /*** DOS real-mode 32-bit address ***/
       pDevice = *((DWORD*)(pInitBuffer + INITBUF_MgaOffset));
    #else
       /*** DOS protected-mode 48-bit address ***/
       ((struct {unsigned long o; short s;}*) &pDevice)->o = *((DWORD*)(pInitBuffer + INITBUF_MgaOffset));
       ((struct {unsigned long o; short s;}*) &pDevice)->s = *((WORD*)(pInitBuffer + INITBUF_MgaSegment));
    #endif

  #endif
#endif

   /* value is true if PixelClk >= 90Mhz */
   pixelClk90Mhz = *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)) >= 90000;
   /*** ##### DUBIC PATCH Disable mouse IRQ and proceed ###### ***/

   if ( (*((BYTE*)(pInitBuffer + INITBUF_DubicPresent))) ) /* Dubic Present */
      {
      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
      mgaReadBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DUB_SEL), 0x00);
      }

   /*** ###################################################### ***/

   /*** Get System Configuration ***/

   GetMGAConfiguration(pDevice, &DST0, &DST1, &Info);

   /*** Program the Titan CRTC_CTRL register ***/

   mgaReadDWORD(*(pDevice + TITAN_OFFSET + TITAN_CRT_CTRL), TmpDword);

   TmpDword &= ~((DWORD)TITAN_CRTCBPP_M     |
                 (DWORD)TITAN_ALW_M         |
                 (DWORD)TITAN_INTERLACE_M   |
                 (DWORD)TITAN_VIDEODELAY0_M |
                 (DWORD)TITAN_VIDEODELAY1_M |
                 (DWORD)TITAN_VIDEODELAY2_M |
                 (DWORD)TITAN_VSCALE_M      |
                 (DWORD)TITAN_SYNCDEL_M);


   TmpDword |= ((DWORD)(*((BYTE*)(pInitBuffer + INITBUF_PWidth))) << TITAN_CRTCBPP_A) & (DWORD)TITAN_CRTCBPP_M;

   /* PACK PIXEL */
   if( !(*((BYTE*)(pInitBuffer + INITBUF_PWidth)) == (BYTE)(TITAN_PWIDTH_PW24 >> TITAN_PWIDTH_A))/* NOT PACK PIXEL */ )
      TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_ALW))) << TITAN_ALW_A) & (DWORD)TITAN_ALW_M;

   if (*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) == TRUE)
      {
      if (*((WORD*)(pInitBuffer + INITBUF_ScreenWidth)) <= (WORD)768)
         {
         TmpDword |= (DWORD)TITAN_INTERLACE_768;
         }
      else
         {
         if (*((WORD*)(pInitBuffer + INITBUF_ScreenWidth)) <= (WORD)1024)
            {
            TmpDword |= (DWORD)TITAN_INTERLACE_1024;
            }
         else
            {
            TmpDword |= (DWORD)TITAN_INTERLACE_1280;
            }
         }
      }

   TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_VideoDelay))) << TITAN_VIDEODELAY0_A) & (DWORD)TITAN_VIDEODELAY0_M;
   TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_VideoDelay))) << (TITAN_VIDEODELAY1_A - 1)) & (DWORD)TITAN_VIDEODELAY1_M;
   TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_VideoDelay))) << (TITAN_VIDEODELAY2_A - 2)) & (DWORD)TITAN_VIDEODELAY2_M;


/* Programing Atlas VSCALE and SYNCDEL if NO DUBIC */

   if ( !(*((BYTE*)(pInitBuffer + INITBUF_DubicPresent))) ) /* No Dubic */
      {

/*********************************************************************/        
      if ( ((Info & (DWORD)Info_Dac_M) != (DWORD)Info_Dac_ViewPoint ) &&
           (*((BYTE*)(pInitBuffer + INITBUF_ChipSet)) != 2/*ATHENA_CHIP*/)
         )
         {
         /*------ hsync and vsync polarity extern implementation */
         mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_CONFIG + 2), TmpByte);
         TmpByte |= 1; /* Expansion device available <16> of CONFIG */
         mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_CONFIG + 2), TmpByte);
         TmpByte   = *(BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol);
         TmpByte  |= *(BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol) << 1;
         mgaWriteBYTE(*(pDevice + EXPDEV_OFFSET), TmpByte );
         }
/*********************************************************************/

/*** Set synch polarity for athena chipset ***/
/* MISC REGISTER 
      bit 7: 0 - Vsync positive
             1 - Vsync negative
      bit 6: 0 - Hsync positive
             1 - Hsync negative
*/
      if(*((BYTE*)(pInitBuffer + INITBUF_ChipSet)) == 2/*ATHENA_CHIP*/)
         {
         mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_R), TmpByte);
         TmpByte &= 0x3f;   /* Set bit <7:6> to 0 */
         TmpByte |= *(BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol) << 6;
         TmpByte |= *(BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol) << 7;

         if (((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_TVP3026) ||
             ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_ViewPoint) 
            )
            TmpByte |= 0xc0;   /* force <7:6> to negative polarity and
                                  use DAC support  for synch polarity */
         else
            TmpByte ^= 0xc0;   /* reverse bit <7:6> */
         mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), TmpByte);
         }

         switch (Info & (DWORD)Info_Dac_M)
            {
            case (DWORD)Info_Dac_BT484:
            case (DWORD)Info_Dac_BT485:
            case (DWORD)Info_Dac_PX2085:
            case (DWORD)Info_Dac_ATT2050:
               switch ( *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncDelay)) )
                  {
                  default:
                  case 0:
                     TmpDword |= (((DWORD)0 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;

                  case 3:
                     TmpDword |= (((DWORD)1 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;

                  case 5:
                     TmpDword |= (((DWORD)2 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;

                  case 8:
                     TmpDword |= (((DWORD)3 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;
                  }
                                                  
                                                        /* PACK PIXEL */
               switch ( *((BYTE*)(pInitBuffer + INITBUF_PWidth)) & 0x3 )
                  {
                  case TITAN_CRTCBPP_8:
                     TmpDword |= (DWORD)0x01 << TITAN_VSCALE_A;
                     break;               /* 0x1 = clock divide by 2   */  

                  case TITAN_CRTCBPP_16:
                     TmpDword |= (((DWORD)0 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     TmpDword |= (DWORD)0x02 << TITAN_VSCALE_A;
                     break;

                  case TITAN_CRTCBPP_32:
                     TmpDword |= (((DWORD)0 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     TmpDword |= (DWORD)0x03 << TITAN_VSCALE_A; 
                     break;

                  }
               break;


            case (DWORD)Info_Dac_ViewPoint:     
            case (DWORD)Info_Dac_TVP3026:     
               switch ( *((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncDelay)) )
                  {
                  case 0:
                  case 1:
                     TmpDword |= (((DWORD)0 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;

                  case 2:
                  case 3:
                     TmpDword |= (((DWORD)1 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;

                  case 4:
                  case 5:
                  case 6:
                     TmpDword |= (((DWORD)2 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;

                  case 7:
                  case 8:
                  default:
                     TmpDword |= (((DWORD)3 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;
                  }
                                                        /* PACK PIXEL */
               switch ( *((BYTE*)(pInitBuffer + INITBUF_PWidth))  & 0x3)
                  {                               /* for PRO board (2 DUBIC) */
                  case TITAN_CRTCBPP_8:
                     TmpDword |= (((DWORD)0 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     break;   /* VSCALE = 0 */

                  case TITAN_CRTCBPP_16:
                     TmpDword |= (((DWORD)0 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     TmpDword |= (DWORD)0x01 << TITAN_VSCALE_A;
                     break;              

                  case TITAN_CRTCBPP_32:
                     TmpDword |= (((DWORD)0 << TITAN_SYNCDEL_A) & (DWORD)TITAN_SYNCDEL_M);
                     TmpDword |= (DWORD)0x02 << TITAN_VSCALE_A;
                     break;
                  }
               break;

            }

      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_CRT_CTRL), TmpDword);
      }
   else /* ELSE NO DUBIC programming DUBIC */
      {
      mgaWriteDWORD(*(pDevice + TITAN_OFFSET + TITAN_CRT_CTRL), TmpDword);


   
   
      /*** Program the Dubic DUB_CTL register ***/

      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DUB_CTL);

      for (TmpDword = 0, ByteCount = 0; ByteCount <= 3; ByteCount++)
         {
         mgaReadBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DATA), TmpByte);
         TmpDword |= ((DWORD)TmpByte << ((DWORD)8 * ByteCount));
         }

      /** Do not program the LVID field, KEEP it for EXTERNAL APPLICATION
      *** if bit 7 of LvidInitFlag is 1
      **/
      if (*((BYTE*)(pVideoBuffer + VIDEOBUF_LvidInitFlag)) & 0x80)
         {
         TmpDword &= ~((DWORD)DUBIC_IMOD_M | (DWORD)DUBIC_VSYNC_POL_M | (DWORD)DUBIC_HSYNC_POL_M |
                      (DWORD)DUBIC_DACTYPE_M | (DWORD)DUBIC_INT_EN_M | (DWORD)DUBIC_GENLOCK_M |
                      (DWORD)DUBIC_BLANK_SEL_M | (DWORD)DUBIC_SYNC_DEL_M | (DWORD)DUBIC_SRATE_M |
                      (DWORD)DUBIC_FBM_M | (DWORD)DUBIC_VGA_EN_M | (DWORD)DUBIC_BLANKDEL_M);
         }
      else  /*** disable live video ***/
         {
         TmpDword &= ~((DWORD)DUBIC_IMOD_M | (DWORD)DUBIC_VSYNC_POL_M | (DWORD)DUBIC_HSYNC_POL_M |
                      (DWORD)DUBIC_DACTYPE_M | (DWORD)DUBIC_INT_EN_M | (DWORD)DUBIC_GENLOCK_M |
                      (DWORD)DUBIC_BLANK_SEL_M | (DWORD)DUBIC_SYNC_DEL_M | (DWORD)DUBIC_SRATE_M |
                      (DWORD)DUBIC_FBM_M | (DWORD)DUBIC_VGA_EN_M | (DWORD)DUBIC_BLANKDEL_M |
                      (DWORD)DUBIC_LVID_M);
         }

      TmpDword |= ((~((DWORD)(*((BYTE*)(pInitBuffer + INITBUF_PWidth))) + (DWORD)1)) << DUBIC_IMOD_A) & (DWORD)DUBIC_IMOD_M;
      TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol))) << DUBIC_VSYNC_POL_A) & (DWORD)DUBIC_VSYNC_POL_M;
      TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol))) << DUBIC_HSYNC_POL_A) & (DWORD)DUBIC_HSYNC_POL_M;

      TmpDword |= (Info << DUBIC_DACTYPE_A) & (DWORD)DUBIC_DACTYPE_M;

      if (*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) == TRUE)
         {
         TmpDword |= (DWORD)DUBIC_INT_EN_M;
         }

      /*** GenLock forced to 0 ***/

      /*** vga_en forced to 0 ***/

      /*** BlankSel forced to 0 (only one DAC) ***/

      /*** Blankdel forced to 0 for mode TERMINATOR ***/

      switch (Info & (DWORD)Info_Dac_M)    /*** IMOD need to be set in TmpDword (DUB_CTL) ***/
         {
         case (DWORD)Info_Dac_ATT:

            switch (TmpDword & (DWORD)DUBIC_IMOD_M)
               {
               case (DWORD)DUBIC_IMOD_32:
                  TmpDword |= (((DWORD)1 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;

               case (DWORD)DUBIC_IMOD_16:
                  TmpDword |= (((DWORD)8 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;

               case (DWORD)DUBIC_IMOD_8:
                  TmpDword |= (((DWORD)4 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;
               }
            break;

         case (DWORD)Info_Dac_BT481:
         case (DWORD)Info_Dac_BT482:

            switch (TmpDword & (DWORD)DUBIC_IMOD_M)
               {
               case (DWORD)DUBIC_IMOD_32:
                  TmpDword |= (((DWORD)1 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;

               case (DWORD)DUBIC_IMOD_16:
                  TmpDword |= (((DWORD)8 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;

               case (DWORD)DUBIC_IMOD_8:
                  TmpDword |= (((DWORD)7 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;
               }
            break;

         case (DWORD)Info_Dac_Sierra:

            switch (TmpDword & (DWORD)DUBIC_IMOD_M)
               {
               case (DWORD)DUBIC_IMOD_32:
                  TmpDword |= (((DWORD)1 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;

               case (DWORD)DUBIC_IMOD_16:
                  TmpDword |= (((DWORD)12 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;

               case (DWORD)DUBIC_IMOD_8:
                  TmpDword |= (((DWORD)8 << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
                  break;
               }
            break;


         case (DWORD)Info_Dac_BT484:
         case (DWORD)Info_Dac_BT485:
         case (DWORD)Info_Dac_PX2085:
         case (DWORD)Info_Dac_ATT2050:

/*** BEN note: Definir cette facon de faire pour les autres RAMDAC lorsque
               ce sera calcule dans vidfile.c ... ***/
            TmpDword |= ( ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncDelay))) << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
            break;


         case (DWORD)Info_Dac_Chameleon:      /*** UNKNOWN ***/
            break;

         case (DWORD)Info_Dac_TVP3026:     
         case (DWORD)Info_Dac_ViewPoint:     
            TmpDword |= ( ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_HsyncDelay))) << DUBIC_SYNC_DEL_A) & (DWORD)DUBIC_SYNC_DEL_M);
            TmpDword |= (DWORD)DUBIC_BLANKDEL_M;
            break;
         }

      TmpDword |= ((DWORD)(*((BYTE*)(pInitBuffer + INITBUF_FBM))) << DUBIC_FBM_A) & (DWORD)DUBIC_FBM_M;

      TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_Srate))) << DUBIC_SRATE_A) & (DWORD)DUBIC_SRATE_M;

      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DUB_CTL);

      for (ByteCount = 0; ByteCount <= 3; ByteCount++)
         {
         TmpByte = (BYTE)(TmpDword >> ((DWORD)8 * ByteCount));
         mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DATA), TmpByte);
         }

      /*** Program the Dubic DUB_CTL2 register ***/

      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DUB_CTL2);

      for (TmpDword = 0, ByteCount = 0; ByteCount <= 3; ByteCount++)
         {
         mgaReadBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DATA), TmpByte);
         TmpDword |= ((DWORD)TmpByte << ((DWORD)8 * ByteCount));
         }


/*** !!!??? This comment is not valid since we set LVIDFIELD just after that ***/
   /** Do not program the LVIDFIELD field, KEEP it for EXTERNAL APPLICATION
   *** if bit 7 of LvidInitFlag is 1
   **/

      if (*((BYTE*)(pVideoBuffer + VIDEOBUF_LvidInitFlag)) & 0x80)
         {
         TmpDword &= ~((DWORD)DUBIC_SYNCEN_M | (DWORD)DUBIC_LASERSCL_M |
                       (DWORD)DUBIC_CLKSEL_M | (DWORD)DUBIC_LDCLKEN_M);
         }
      else   /*** Disable live video ***/
         {
         TmpDword &= ~((DWORD)DUBIC_SYNCEN_M | (DWORD)DUBIC_LASERSCL_M | (DWORD)DUBIC_LVIDFIELD_M |
                       (DWORD)DUBIC_CLKSEL_M | (DWORD)DUBIC_LDCLKEN_M);
         }


   /** Because we lost the cursor in interlace mode , we have to program **/
   /** LVIDFIELD to 1                                                    **/

      if (*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) == TRUE)
         TmpDword |= (DWORD)DUBIC_LVIDFIELD_M;
      else
         TmpDword &= ~((DWORD)DUBIC_LVIDFIELD_M);



      TmpDword |= ((DWORD)(*((BYTE*)(pVideoBuffer + VIDEOBUF_LaserScl))) << DUBIC_LASERSCL_A) & (DWORD)DUBIC_LASERSCL_M;

      TmpDword |= (DWORD)DUBIC_SYNCEN_M;        /*** sync forced to enable ***/

      /*** CLOCKSEL forced to 0 except for viewpoint ***/

      if ( 
            ((Info & (DWORD)Info_Dac_M) == Info_Dac_ViewPoint) ||
            ((Info & (DWORD)Info_Dac_M) == Info_Dac_TVP3026)
         )
            TmpDword |= (DWORD)DUBIC_CLKSEL_M;       

      /* Special case for BT485: LDCLKEN must be set to 1 only in VGA mode */
      /* and in 24-bit mode */
      if( ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_BT485)  ||
          ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_PX2085) ||
          ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_ATT2050)
        )
         {
         if( *((BYTE*)(pInitBuffer + INITBUF_PWidth)) == (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A) )
            TmpDword |= (DWORD)DUBIC_LDCLKEN_M;     /*** ldclkl running ***/
         }
      else
         TmpDword |= (DWORD)DUBIC_LDCLKEN_M;       /*** ldclkl running ***/


      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_DUB_CTL2);

      for (ByteCount = 0; ByteCount <= 3; ByteCount++)
         {
         TmpByte = (BYTE)(TmpDword >> ((DWORD)8 * ByteCount));
         mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DATA), TmpByte);
         }

      /*** Program the Dubic OVS_COL register ***/

      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), DUBIC_OVS_COL);

      TmpDword = *((DWORD*)(pVideoBuffer + VIDEOBUF_OvsColor));
   
      for (ByteCount = 0; ByteCount <= 3; ByteCount++)
         {
         TmpByte = (BYTE)(TmpDword >> ((DWORD)8 * ByteCount));
         mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DATA), TmpByte);
         }

      }


   /*** Program the RAMDAC ***/

   switch (Info & (DWORD)Info_Dac_M)
      {
      case (DWORD)Info_Dac_ATT:            /*** UNKNOWN ***/
         break;

      case (DWORD)Info_Dac_BT481:          /*** UNKNOWN ***/
         break;

      case (DWORD)Info_Dac_BT482:

         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               TmpByte = 0x01;
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               if ( *((BYTE*)(pInitBuffer + INITBUF_565Mode)) )
                  TmpByte = 0xe1;
               else
                  TmpByte = 0xa1;
               break;
            }

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_CMD_REGA), TmpByte);

         /*** Read Mask (INDIRECT) ***/

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_WADR_PAL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_PIX_RD_MSK), 0xff);

         /*** Command Register B (INDIRECT) ***/

         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal)) & (BYTE)0x1) << 5) | (BYTE)0x02;

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_WADR_PAL), 0x02);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_PIX_RD_MSK), TmpByte);

         /*** Cursor Register (INDIRECT) ***/

         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) & (BYTE)0x1) << 4) | (BYTE)0x04;

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_WADR_PAL), 0x03);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT482_PIX_RD_MSK), TmpByte);

         break;

      case (DWORD)Info_Dac_Sierra:         /*** UNKNOWN ***/
         break;

      case (DWORD)Info_Dac_BT484:

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_PIX_RD_MSK), 0xff);
         /* Overlay must me 0 */
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_WADR_OVL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_OVL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_OVL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_COL_OVL), 0x00);
                                                                                     /** BEN 0x1e */
         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal)) & (BYTE)0x1) << 5) | (BYTE)0x02;
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_CMD_REG0), TmpByte);

         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               TmpByte = 0x40;
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               if ( *((BYTE*)(pInitBuffer + INITBUF_565Mode)) )
                  TmpByte = 0x28;
               else
                  TmpByte = 0x20;
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               TmpByte = 0x00;
               break;
            }

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_CMD_REG1), TmpByte);
                                                                                      
         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) & (BYTE)0x1) << 3) | (BYTE)0x24;
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT484_CMD_REG2), TmpByte);

         break;

      case (DWORD)Info_Dac_BT485:
      case (DWORD)Info_Dac_PX2085:
      case (DWORD)Info_Dac_ATT2050:

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_PIX_RD_MSK), 0xff);
                                                                                     /** BEN 0x9e */
         /* OverScan must me 0 */
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_WADR_OVL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_COL_OVL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_COL_OVL), 0x00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_COL_OVL), 0x00);
         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal)) & (BYTE)0x1) << 5) | (BYTE)0x82;
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG0), TmpByte);

         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               TmpByte = 0x40;
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               if ( *((BYTE*)(pInitBuffer + INITBUF_565Mode)) )
                  TmpByte = 0x28;
               else
                  TmpByte = 0x20;
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               TmpByte = 0x00;
               break;
            }

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG1), TmpByte);


      if( ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_BT485) ||
          ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_ATT2050)
        )
         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) & (BYTE)0x1) << 3) | (BYTE)0x24;
      else  /* PX2085 */
         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) & (BYTE)0x1) << 3) | (BYTE)0x44;

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG2), TmpByte);


         /*** Indirect addressing from STATUS REGISTER ***/

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_WADR_PAL), 0x01);

         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               if ( ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_PX2085) ||
                    ((Info & (DWORD)Info_Dac_M) == (DWORD)Info_Dac_BT485) ||
                    pixelClk90Mhz /* pclk >= 90Mhz */
                  )
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG3), 0x08);
               else
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG3), 0x00);

               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + BT485_CMD_REG3), 0x00);
               break;
            }
         break;


      case (DWORD)Info_Dac_Chameleon:      /*** UNKNOWN ***/
         break;

      case (DWORD)Info_Dac_ViewPoint:

         /* Software reset to put the DAC in a default state */
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_RESET);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x00 );


         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_PIX_RD_MSK), 0xff);

         /* OverScan must me 0 */
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_OVS_RED);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x00 );
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_OVS_GREEN);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x00 );
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_OVS_BLUE);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x00 );

         /* Misc. Control Register */
         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal)) & (BYTE)0x1) << 4);

         /*** (94/02/07) BEN modif to program sync polarity in VIEWPOINT ***/
         /*** (94/04/11) Christian: doesn't apply for ATHENA ***/
/*         if ( ! (*((BYTE*)(pInitBuffer + INITBUF_DubicPresent))) &&  */
/*               (*((BYTE*)(pInitBuffer + INITBUF_ChipSet)) != 2) */ /*ATHENA_CHIP*/
/*            )  */
         if ( ! (*((BYTE*)(pInitBuffer + INITBUF_DubicPresent))))
            {
            TmpByte &= 0xfc;   /* Set bit 0,1 to 0 */
            TmpByte |= *(BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol);
            TmpByte |= *(BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol) << 1;
            }

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_GEN_CTL);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), TmpByte);

         /* Multiplex Control Register (True Color 24 bit) */
         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_MUX_CTL1);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x80 );
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_MUX_CTL2);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x1c );
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               if ( *((BYTE*)(pInitBuffer + INITBUF_565Mode)) )
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_MUX_CTL1);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x45 );  /* XGA */
                  }
               else
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_MUX_CTL1);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x44 );  /* Targa */
                  }

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_MUX_CTL2);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x04 );
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_MUX_CTL1);

#if !(MACRO_ECHO)
               if ( *((BYTE*)(pInitBuffer + INITBUF_ChipSet)) == 1)     /* ATLAS */
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x46 );
               else
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x46 );
#else
              /* 
               * Redundant if-else causes massive compilation error in macro
               * debug echo mode.
               */
              mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x46 );
#endif


               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_MUX_CTL2);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x04 );
               break;
            }


         /* Input Clock Select Register (Select CLK1 as doubled clock source */
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_INPUT_CLK);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x11 );

         /* Output Clock Selection Register Bits
            VCLK/2 output ratio (xx001xxx)
            RCLK/2 output ratio (xxxxx001)
         */

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_OUTPUT_CLK);
         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x5b );
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x52 );
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x49 );
               break;
            }

         if ( ! (*((BYTE*)(pInitBuffer + INITBUF_DubicPresent))) )
            {
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_GEN_IO_CTL);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x03 );

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_GEN_IO_DATA);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x01 );

            
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_AUX_CTL);
            switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
               {
               case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x09 );
                  break;

               case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x08 );
                  break;

               case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x08 );
                  break;
               }
            }


         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_INDEX), VPOINT_KEY_CTL);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + VPOINT_DATA), (BYTE)0x10 );



         break;

      case (DWORD)Info_Dac_TVP3026:

         /* Software reset to put the DAC in a default state */
         res = *((WORD*)(pInitBuffer + INITBUF_ScreenWidth));

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_PIX_RD_MSK), 0xff);

         /* FIX AVEC GAL DAT No GEN014 */
         /* general purpose I/O tell to the gal the vertical resolution */
         /* if vertical resolution is >= 1024, the count is by increment 
         /* of two */
            
         if ( res < 1280)
            {
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_GEN_IO_CTL);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x00 );

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_GEN_IO_DATA);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x01 );
            }
         else
            {
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_GEN_IO_CTL);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x01 );

            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_GEN_IO_DATA);
            mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x00 );
            }

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MISC_CTL);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x0c);


         /* init Interlace Cursor support */
         /* NOTE: We set the vertival detect method bit to 1 to be in synch
                  with NPI diag code. Whith some video parameters, the cursor
                  disaper if we put this bit a 0.
         */
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_CURSOR_CTL);
         mgaReadBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), TmpByte);
         /* Set interlace bit */
         TmpByte &= ~(BYTE)(1 << 5);   
         TmpByte |= (((*((BYTE*)(pVideoBuffer + VIDEOBUF_Interlace)) & (BYTE)0x1)) << 5);
         /* Set vertival detect method */
         TmpByte |= 0x10;
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), TmpByte);



         /* OverScan must me 0 */
         /* Overscan is not enabled in general ctl register */
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_CUR_COL_ADDR), 00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_CUR_COL_DATA), 00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_CUR_COL_DATA), 00);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_CUR_COL_DATA), 00);
         /* Put to ZERO */

         /* Misc. Control Register */
         TmpByte = ((*((BYTE*)(pVideoBuffer + VIDEOBUF_Pedestal)) & (BYTE)0x1) << 4);

         /* For the TVP3026, we use DAC capability for sync polarity */
         if (! (*((BYTE*)(pInitBuffer + INITBUF_DubicPresent))) )
            {
            TmpByte &= 0xfc;   /* Set bit 0,1 to 0 */
            TmpByte |= *(BYTE*)(pVideoBuffer + VIDEOBUF_HsyncPol);
            TmpByte |= *(BYTE*)(pVideoBuffer + VIDEOBUF_VsyncPol) << 1;
            }

         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_GEN_CTL);
         mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), TmpByte);

         /* Multiplex Control Register (True Color 24 bit) */
         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_CLK_SEL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0xb5 );


               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_TRUE_COLOR_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0xa0 );
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MUX_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x4c );
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_CLK_SEL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0xa5 );

               if ( *((BYTE*)(pInitBuffer + INITBUF_565Mode)) )
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_TRUE_COLOR_CTL);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x65 );  
                  }
               else
                  {
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_TRUE_COLOR_CTL);
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x64 );  
                  }

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MUX_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x54 );
               break;

         case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_CLK_SEL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x95 );

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_TRUE_COLOR_CTL);
               if ( *((BYTE*)(pInitBuffer + INITBUF_ChipSet)) == 1)     /* ATLAS */
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x66 );
               else
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x66 );
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MUX_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x5c );
               break;

         case (BYTE)(TITAN_PWIDTH_PW24 >> TITAN_PWIDTH_A):
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_CLK_SEL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x95 );

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_TRUE_COLOR_CTL);
               if ( *((BYTE*)(pInitBuffer + INITBUF_ChipSet)) == 1)     /* ATLAS */
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x76 );
               else
                  mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x76 );
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MUX_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), (BYTE)0x5c );

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_LATCH_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 4 );

               break;

            }



            if ( *((BYTE*)(pInitBuffer + INITBUF_DB_FrontBack)) )
               {
               /** Enable double buffer feature of the TVP3026 and set DAC mask **/
 
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_TRUE_COLOR_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0xA0);

               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_MUX_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0x54);

               /*** Always display buffer A ***/
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_INDEX), TVP3026_LATCH_CTL);
               mgaWriteBYTE(*(pDevice + RAMDAC_OFFSET + TVP3026_DATA), 0x86);
               }

       break;

      }

   /*** Program the LUT in the DAC (the LUT is internal to the function) ***/
   /*** Done only if flag LUTMode is FALSE ***/

   if ( ! (*((BYTE*)(pInitBuffer + INITBUF_LUTMode))) )
      {
         if ( *((BYTE*)(pInitBuffer + INITBUF_565Mode)) )
            SetMGALUT(pDevice, (BYTE*)0, *((BYTE*)(pInitBuffer + INITBUF_PWidth)), 0x08);
         else if ( *((BYTE*)(pInitBuffer + INITBUF_DB_FrontBack)) )
            SetMGALUT(pDevice, (BYTE*)0, *((BYTE*)(pInitBuffer + INITBUF_PWidth)), 0x10);
         else
            SetMGALUT(pDevice, (BYTE*)0, *((BYTE*)(pInitBuffer + INITBUF_PWidth)), 0);
      }


   /*** Program the CLOCK GENERATOR ***/

   switch (Info & (DWORD)Info_Dac_M)
      {
      case (DWORD)Info_Dac_BT482:

         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)), 2);
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)) << 1, 2);
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)) << 1, 2);
               break;
            }

         break;



      case (DWORD)Info_Dac_BT485:
      case (DWORD)Info_Dac_PX2085:

         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
               setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)) >> 1, 2);
               break;

            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)) >> 1, 2);
               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)), 2);
               break;
            }

         break;

      case (DWORD)Info_Dac_ATT2050:

         switch (*((BYTE*)(pInitBuffer + INITBUF_PWidth)))
            {
            case (BYTE)(TITAN_PWIDTH_PW8 >> TITAN_PWIDTH_A):
            case (BYTE)(TITAN_PWIDTH_PW16 >> TITAN_PWIDTH_A):
               if (pixelClk90Mhz) /* pclk >= 90Mhz */
                  setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)) >> 1, 2);
               else
                  setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)), 2);

               break;

            case (BYTE)(TITAN_PWIDTH_PW32 >> TITAN_PWIDTH_A):
               setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)), 2);
               break;
            }

         break;

      case (DWORD)Info_Dac_ViewPoint:
         setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)) >> 1, 2);
         break;

      case (DWORD)Info_Dac_TVP3026:
         setTVP3026Freq(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)), 2, *((BYTE*)(pInitBuffer + INITBUF_PWidth)));
/*** BEN we call it twice because of a bug with setup program for windows at
     1152x882x24 ***/
         setTVP3026Freq(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)), 2, *((BYTE*)(pInitBuffer + INITBUF_PWidth)));
         break;

      default:

         setFrequence(pDevice, *((DWORD*)(pVideoBuffer + VIDEOBUF_PCLK)), 2);
         break;
      }


   /*** Program the CRTC ***/

   /*** Select access on 0x3d4 and 0x3d5 ***/

   mgaReadBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_R), TmpByte);
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_MISC_OUT_W), (TmpByte | (BYTE)0x01));

   /*** Unprotect registers 0-7 ***/

   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_1_CRTC_ADDR), 0x11);
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_1_CRTC_DATA), 0x40);

   for (RegisterCount = 0; RegisterCount <= 24; RegisterCount++)
      {
      TmpByte = *((BYTE*)(pVideoBuffer + VIDEOBUF_CRTC + RegisterCount));

      mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_1_CRTC_ADDR), (unsigned char)RegisterCount);
      mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_1_CRTC_DATA), TmpByte);
      }

      /*** Get extended address register ***/

   RegisterCount = (DWORD)26;
   TmpByte = *((BYTE*)(pVideoBuffer + VIDEOBUF_CRTC + RegisterCount));

   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_AUX_ADDR), 0x0A);
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_AUX_DATA), TmpByte);

   RegisterCount = (DWORD)28;
   TmpByte = *((BYTE*)(pVideoBuffer + VIDEOBUF_CRTC + RegisterCount));

   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_AUX_ADDR), 0x0D);
   mgaWriteBYTE(*(pDevice + TITAN_OFFSET + TITAN_AUX_DATA), TmpByte);

      /*** Get interlace support register ***/




   /*** ##### DUBIC PATCH ReEnable mouse IRQ ################# ***/
   if ( (*((BYTE*)(pInitBuffer + INITBUF_DubicPresent))) ) /* Dubic Present */
      {
      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_NDX_PTR), 0x08);
      mgaWriteBYTE(*(pDevice + DUBIC_OFFSET + DUBIC_DUB_SEL), DUB_SEL);
      }

   /*** ###################################################### ***/
   }



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\vidfile.c ===
/*/****************************************************************************
*          name: vidfile.c
*
*   description: Calculate video parameters
*
*      designed: Gilles-Marie Perron
* last modified: $Author: ctoutant $, $Date: 94/10/24 11:08:23 $
*
*       version: $Id: vidfile.c 1.44 94/10/24 11:08:23 ctoutant Exp Locker: ctoutant $
*
*    parameters: -
*      modifies: -
*         calls: -
*       returns: -
******************************************************************************/

#include "switches.h"
#include "bind.h"
#include "mtxpci.h"     /* pciBoardInfo, PCI_FLAG_ATHENA_REV1 */


#ifdef WINDOWS_NT

bool loadVidPar(dword Zoom, HwModeData *HwMode, HwModeData *DisplayMode);
void calculCrtcParam(void);
byte detectPatchWithGal(void);
void GetMGAConfiguration(volatile byte _Far *, dword*, dword*, dword*);

#if defined(ALLOC_PRAGMA)
    #pragma alloc_text(PAGE,loadVidPar)
    #pragma alloc_text(PAGE,calculCrtcParam)
    #pragma alloc_text(PAGE,detectPatchWithGal)
#endif

//#if defined(ALLOC_PRAGMA)
//    #pragma data_seg("PAGE")
//#endif
#endif

#ifndef WINDOWS_NT
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
#endif

#include "bind.h"
#include "defbind.h"
#ifndef __DDK_SRC__
  #include "sxci.h"
#endif
#include "mgai_c.h"
#include "mgai.h"
#include "mga.h"
#include "vidfile.h"

#if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE))
/*********** DDC CODE ****************/
#include "edid.h"
/*********** DDC CODE ****************/
#endif


#define VCLK_DIVISOR          8



vid vidtab [29] =    {{"Pixel_clk",                 75000},      /* 0 */
                      {"H_Front_porch",             24},
                      {"H_sync",                    136},
                      {"H_back_porch",              144},
                      {"H_Overscan",                16},
                      {"H_Visible",                 1024},       /* 5 */
                      {"V_front_porch",             3},
                      {"V_sync",                    6},
                      {"V_back_porch",              29},
                      {"V_Overscan",                2},
                      {"V_visible",                 768},        /* 10 */
                      {"P_width",                   8},
                      {"Overscan_Enable",           0},
                      {"Interlace_mode_Enable",     0},
                      {"Start_add_Frame_Buffer",    0},
                      {"Zoom_factor_x",             1},          /* 15 */
                      {"Zoom_factor_y",             1},
                      {"Virtuel_VIDEO_pitch",       1024},
                      {"ALW",                       1},
                      {"H_blanking_Skew",           0},
                      {"H_retrace_end_Skew",        0},          /* 20 */
                      {"Cursor_end_Skew",           0},
                      {"Cursor_Enable",             0},
                      {"CRTC_test_Enable",          0},
                      {"V_IRQ_Enable",              0},
                      {"Select_5_Refresh_Cycle",    0},          /* 25 */
                      {"CRTC_reg_0_7_Protect",      0},
                      {"Hsync_pol",                 0},
                      {"Vsync_pol",                 0}
                      };


ResParamSet ResParam[100] = {
                            {  640,  480,  8,  75,  31200,  640, 32,  64,  96, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0 },		                            {  640,  480, 8,  75,  31200,  640, 32,  64,  96, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0 },
                            {  640,  480, 16,  75,  31200,  640, 32,  64,  96, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0 },
                            {  640,  480, 24,  75,  31200,  640, 32,  64,  96, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0 },
                            {  640,  480, 32,  75,  31200,  640, 32,  64,  96, 0,  480,  1,  3, 16, 0, 0, 0, 0, 0 },

                            {  640,  480,  8,  72,  31500,  640, 32,  32, 128, 0,  480,  9,  3, 28, 0, 0, 0, 0, 0 },
							{  640,  480, 16,  72,  31500,  640, 32,  32, 128, 0,  480,  9,  3, 28, 0, 0, 0, 0, 0 },
                            {  640,  480, 24,  72,  31500,  640, 32,  32, 128, 0,  480,  9,  3, 28, 0, 0, 0, 0, 0 },
                            {  640,  480, 32,  72,  31500,  640, 32,  32, 128, 0,  480,  9,  3, 28, 0, 0, 0, 0, 0 },

                            {  640,  480,  8,  60,  25175,  640, 32,  96,  32, 0,  480,  8,  5, 32, 0, 0, 0, 0, 0 },
                            {  640,  480, 16,  60,  25175,  640, 32,  96,  32, 0,  480,  8,  5, 32, 0, 0, 0, 0, 0 },
                            {  640,  480, 24,  60,  25175,  640, 32,  96,  32, 0,  480,  8,  5, 32, 0, 0, 0, 0, 0 },
                            {  640,  480, 32,  60,  25175,  640, 32,  96,  32, 0,  480,  8,  5, 32, 0, 0, 0, 0, 0 },

                            {  800,  600,  8,  75,  49500,  800, 32,  64, 160, 1,  600,  1,  3, 21, 0, 0, 0, 1, 1 },
                            {  800,  600, 16,  75,  49500,  800, 32,  64, 160, 1,  600,  1,  3, 21, 0, 0, 0, 1, 1 },
                            {  800,  600, 24,  75,  49500,  800, 32,  64, 160, 1,  600,  1,  3, 21, 0, 0, 0, 1, 1 },
                            {  800,  600, 32,  75,  49500,  800, 32,  64, 160, 1,  600,  1,  3, 21, 0, 0, 0, 1, 1 },

                            {  800,  600,  8,  72,  51500,  800, 64, 128,  96, 0,  600, 33,  6, 19, 0, 0, 0, 1, 1 },
                            {  800,  600, 16,  72,  51500,  800, 64, 128,  96, 0,  600, 33,  6, 19, 0, 0, 0, 1, 1 },
                            {  800,  600, 24,  72,  51500,  800, 64, 128,  96, 0,  600, 33,  6, 19, 0, 0, 0, 1, 1 },
                            {  800,  600, 32,  72,  51500,  800, 64, 128,  96, 0,  600, 33,  6, 19, 0, 0, 0, 1, 1 },

                            {  800,  600,  8,  60,  40500,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },
                            {  800,  600, 16,  60,  40500,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },
                            {  800,  600, 24,  60,  40500,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },
                            {  800,  600, 32,  60,  40500,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },

                            {  800,  600,  8,  56,  37800,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },
                            {  800,  600, 16,  56,  37800,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },
                            {  800,  600, 24,  56,  37800,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },
                            {  800,  600, 32,  56,  37800,  800, 32, 128, 128, 0,  600,  2,  4, 14, 0, 0, 0, 1, 1 },

							{ 1024,  768,  8,  43,  44900, 1024, 32, 128,  64, 0,  384,  1,  4, 21, 0, 0, 1, 1, 1 },
 							{ 1024,  768, 16,  43,  44900, 1024, 32, 128,  64, 0,  384,  1,  4, 21, 0, 0, 1, 1, 1 },
							{ 1024,  768, 24,  43,  44900, 1024, 32, 128,  64, 0,  384,  1,  4, 21, 0, 0, 1, 1, 1 },
							{ 1024,  768, 32,  43,  44900, 1024, 32, 128,  64, 0,  384,  1,  4, 21, 0, 0, 1, 1, 1 },

                            { 1024,  768,  8,  75,  78750, 1024, 32,  96, 160, 1,  768,  1,  3, 28, 0, 0, 0, 1, 1 },
                            { 1024,  768, 16,  75,  78750, 1024, 32,  96, 160, 1,  768,  1,  3, 28, 0, 0, 0, 1, 1 },
                            { 1024,  768, 24,  75,  78750, 1024, 32,  96, 160, 1,  768,  1,  3, 28, 0, 0, 0, 1, 1 },
                            { 1024,  768, 32,  75,  78750, 1024, 32,  96, 160, 1,  768,  1,  3, 28, 0, 0, 0, 1, 1 },

                            { 1024,  768,  8,  70,  75000, 1024, 32, 128, 160, 0,  768,  3,  6, 21, 0, 0, 0, 0, 0 },
                            { 1024,  768, 16,  70,  75000, 1024, 32, 128, 160, 0,  768,  3,  6, 21, 0, 0, 0, 0, 0 },
                            { 1024,  768, 24,  70,  75000, 1024, 32, 128, 160, 0,  768,  3,  6, 21, 0, 0, 0, 0, 0 },
                            { 1024,  768, 32,  70,  75000, 1024, 32, 128, 160, 0,  768,  3,  6, 21, 0, 0, 0, 0, 0 },

                            { 1024,  768,  8,  60,  65000, 1024, 32, 128, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 },
                            { 1024,  768, 16,  60,  65000, 1024, 32, 128, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 },
                            { 1024,  768, 24,  60,  65000, 1024, 32, 128, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 },
                            { 1024,  768, 32,  60,  65000, 1024, 32, 128, 160, 0,  768,  3,  6, 29, 0, 0, 0, 0, 0 },

 							{ 1152,  882,  8,  75, 111350, 1152, 32, 224, 224, 0,  882,  2, 10, 16, 0, 0, 0, 0, 0 },
 							{ 1152,  882, 16,  75, 111350, 1152, 32, 224, 224, 0,  882,  2, 10, 16, 0, 0, 0, 0, 0 },
 							{ 1152,  882, 24,  75, 111350, 1152, 32, 224, 224, 0,  882,  2, 10, 16, 0, 0, 0, 0, 0 },
  							{ 1152,  882, 32,  75, 111350, 1152, 32, 224, 224, 0,  882,  2, 10, 16, 0, 0, 0, 0, 0 },

 							{ 1152,  882,  8,  72,  97000, 1152, 97, 128,  95, 0,  882,  4,  8, 20, 0, 0, 0, 0, 0 },
 							{ 1152,  882, 16,  72,  97000, 1152, 97, 128,  95, 0,  882,  4,  8, 20, 0, 0, 0, 0, 0 },
 							{ 1152,  882, 24,  72,  97000, 1152, 97, 128,  95, 0,  882,  4,  8, 20, 0, 0, 0, 0, 0 },
 							{ 1152,  882, 32,  72,  95000, 1152, 64, 128,  68, 0,  882, 28,  8, 39, 0, 0, 0, 0, 0 },

							{ 1152,  882,  8,  60,  80500, 1152, 32, 128, 160, 0,  882,  4,  8, 16, 0, 0, 0, 0, 0 },
 							{ 1152,  882, 16,  60,  80500, 1152, 32, 128, 160, 0,  882,  4,  8, 16, 0, 0, 0, 0, 0 },
							{ 1152,  882, 24,  60,  80500, 1152, 32, 128, 160, 0,  882,  4,  8, 16, 0, 0, 0, 0, 0 },
							{ 1152,  882, 32,  60,  80500, 1152, 32, 128, 160, 0,  882,  4,  8, 16, 0, 0, 0, 0, 0 },

                            { 1280, 1024,  8,  75, 135600, 1280, 32, 128, 256, 1, 1024,  2,  3, 37, 0, 0, 0, 1, 1 },
                            { 1280, 1024, 16,  75, 135600, 1280, 32, 128, 256, 1, 1024,  2,  3, 37, 0, 0, 0, 1, 1 },
                            { 1280, 1024, 24,  75, 135600, 1280, 32, 128, 256, 1, 1024,  2,  3, 37, 0, 0, 0, 1, 1 },
                            { 1280, 1024, 32,  75, 135600, 1280, 32, 128, 256, 1, 1024,  2,  3, 37, 0, 0, 0, 1, 1 },

                            { 1280, 1024,  8,  72, 135000, 1280, 64, 128, 288, 0, 1024,  6,  6, 30, 0, 0, 0, 0, 0 },                             { 1280, 1024,  8,  72, 135000, 1280, 64, 128, 288, 0, 1024,  6,  6, 30, 0, 0, 0, 0, 0 },
                            { 1280, 1024, 16,  72, 135000, 1280, 64, 128, 288, 0, 1024,  6,  6, 30, 0, 0, 0, 0, 0 },
                            { 1280, 1024, 24,  72, 135000, 1280, 64, 128, 288, 0, 1024,  6,  6, 30, 0, 0, 0, 0, 0 },
                            { 1280, 1024, 32,  72, 135000, 1280, 64, 128, 288, 0, 1024,  6,  6, 30, 0, 0, 0, 0, 0 },

                            { 1280, 1024,  8,  60, 110000, 1280, 32, 128, 288, 0, 1024,  3,  3, 26, 0, 0, 0, 0, 0 },
                            { 1280, 1024, 16,  60, 110000, 1280, 32, 128, 288, 0, 1024,  3,  3, 26, 0, 0, 0, 0, 0 },
                            { 1280, 1024, 24,  60, 110000, 1280, 32, 128, 288, 0, 1024,  3,  3, 26, 0, 0, 0, 0, 0 },
                            { 1280, 1024, 32,  60, 110000, 1280, 32, 128, 288, 0, 1024,  3,  3, 26, 0, 0, 0, 0, 0 },

                            { 1600, 1200,  8,  72, 185400, 1600, 32, 128, 320, 0, 1200,  4, 18, 16, 0, 0, 0, 0, 0 },
                            { 1600, 1200, 16,  72, 185400, 1600, 32, 128, 320, 0, 1200,  4, 18, 16, 0, 0, 0, 0, 0 },
                            { 1600, 1200, 24,  72, 185400, 1600, 32, 128, 320, 0, 1200,  4, 18, 16, 0, 0, 0, 0, 0 },
                            { 1600, 1200, 32,  72, 185400, 1600, 32, 128, 320, 0, 1200,  4, 18, 16, 0, 0, 0, 0, 0 },

                            { 1600, 1200,  8,  60, 156000, 1600, 32, 160, 256, 0, 1200, 10,  8, 48, 0, 0, 0, 0, 0 },
                            { 1600, 1200, 16,  60, 156000, 1600, 32, 160, 256, 0, 1200, 10,  8, 48, 0, 0, 0, 0, 0 },
                            { 1600, 1200, 24,  60, 156000, 1600, 32, 160, 256, 0, 1200, 10,  8, 48, 0, 0, 0, 0, 0 },
                            { 1600, 1200, 32,  60, 156000, 1600, 32, 160, 256, 0, 1200, 10,  8, 48, 0, 0, 0, 0, 0 },

                            {(word)-1}
                           };




extern  volatile byte _Far* pMgaBaseAddr;

dword crtcTab[NB_CRTC_PARAM];
extern byte iBoard;
extern HwData Hw[NB_BOARD_MAX];
extern char DefaultVidset[];
extern dword ProductMGA[NB_BOARD_MAX];

/* Prototype */
byte detectPatchWithGal(void);
extern char *selectMgaInfoBoard(void);


/****************** definition of exit tab *********************************/
/*                                                                         */
/*********************** value of registers ********************************/
/*                                                                         */
/* crtctab[0]= horizontal total                                            */
/* crtctab[1]= horizontal display end                                      */
/* crtctab[2]= horizontal blanking start                                   */
/* crtctab[3]= horizontal blanking end                                     */
/* crtctab[4]= horizontal retrace start                                    */
/* crtctab[5]= horizontal retrace end                                      */
/* crtctab[6]= vertical total                                              */
/* crtctab[7]= overflow                                                    */
/* crtctab[8]= preset row scan                                             */
/* crtctab[9]= maximum scanline                                            */
/* crtctab[10]=cursor start                                                */
/* crtctab[11]=cursor end                                                  */
/* crtctab[12]=start adrress high                                          */
/* crrctab[13]=start address low                                           */
/* crtctab[14]=cursor position high                                        */
/* crtctab[15]=cursor position low                                         */
/* crtctab[16]=vertical retrace start                                      */
/* crtctab[17]=vertical retrace end                                        */
/* crtctab[18]=vertical display enable end                                 */
/* crtctab[19]=offset                                                      */
/* crtctab[20]=underline location                                          */
/* crtctab[21]=vertical blanking start                                     */
/* crtctab[22]=vertical blanking end                                       */
/* crtctab[23]=mode control                                                */
/* crtctab[24]=line compare                                                */
/* crtctab[25]=cpu page select                                             */
/* crtctab[26]=crtc extended address register                              */
/* crtctab[27]=32k video ram page select register                          */
/* crtctab[28]=interlace support register                                  */
/* crtctab[29]=automatic line wrap                                         */
/* crtctab[30]=pixel clock                                                 */
/* crtctab[31]=video delay                                                 */
/* crtctab[32]=Hsync polarite                                              */
/* crtctab[33]=sync delay of dub_ctl register                              */
/*                                                                         */
/***************************************************************************/



/************************************************************************/
/*/
* Name:           loadVidPar()
*
* synopsis:
*
* bugs:
* designed:
* reviewed:
* last modified:
*
* parameters:  (char *vidFile);
* uses:
*
* calls: calculCrtcParam();
*
* returns: mtxOK
*          mtxFAIL
*************************************************************************/

bool loadVidPar(dword Zoom, HwModeData *HwMode, HwModeData *DisplayMode)
{
 general_info *genInfo;
 Vidparm          *vidParm;
 word TmpRes, ZoomIndex, ZoomVal;
 Vidset *pVidset = (Vidset *)0;
 word NbVidParam, i;


 ZoomVal = (word)(Zoom & 0x0000ffff);

#if ((!defined (WINDOWS_NT)) || (USE_DDC_CODE))
/*********** DDC CODE ****************/

if ( SupportDDC )
   {

   /*** Find video parameters with the highest refresh rate (see vesavid.h) ***/

   pVidset = NULL;

   for (i=0; VesaParam[i].DispWidth != (word)-1 ; i++)
      {
       if( VesaParam[i].DispWidth == DisplayMode->DispWidth && VesaParam[i].Support )
         {
          pVidset = &(VesaParam[i].VideoSet);
          break;
         }
      }

   if( pVidset == NULL )
      return(mtxFAIL);
   }
/*********** DDC CODE ****************/

else
#endif


   {
    if (Zoom & 0xff000000)
       {
		pVidset = NULL;

        for (i=0; ResParam[i].DispWidth != (word)-1 ; i++)
          {
           if ((ResParam[i].DispWidth   == DisplayMode->DispWidth) &&
               (ResParam[i].PixDepth    == DisplayMode->PixWidth) &&
               (ResParam[i].RefreshRate == (word)((Zoom >> 24) & 0x000000ff)))
             {
              pVidset = &(ResParam[i].VideoSet);
              break;
             }
          }

        if (pVidset == NULL)
           return(mtxFAIL);

        }
     else
        {
         switch(Zoom & 0xff)
           {
            case 2:  ZoomIndex = 1; break;
            case 4:  ZoomIndex = 2; break;
            default: ZoomIndex = 0; break;
           }

         /*** According to Board#, Resolution and PixWidth: Determine pVidset ***/

         /* ChT if no paramters for this card then default parameters */
         if ( !(genInfo = (general_info *)selectMgaInfoBoard()) ||
               (genInfo->NumVidparm < 0)
            )
            {
         #ifdef PRINT
               printf("No info for this board in mga.inf file\n");
               printf("Please run Setup\n");
         #endif
            vidParm = (Vidparm *)( DefaultVidset + sizeof(header) + sizeof(general_info));
         NbVidParam = ( (general_info *)( DefaultVidset +    sizeof(header)))->NumVidparm;
            }
         else
            {
            vidParm = (Vidparm *)( (char *)genInfo + sizeof(general_info));
         NbVidParam = genInfo->NumVidparm;
            }


      /* Determine TmpRes for compatibility with spec mga.inf */
        switch (DisplayMode->DispWidth)
          {
           case 640:
               if (DisplayMode->DispType & 0x02)
                  TmpRes = RESNTSC;
               else
                  TmpRes = RES640;
               break;
            case 768:
               TmpRes = RESPAL;
               break;
            case 800:
               TmpRes = RES800;
               break;
            case 1024:
               TmpRes = RES1024;
               break;
            case 1152:
               TmpRes = RES1152;
               break;
            case 1280:
               TmpRes = RES1280;
               break;
            case 1600:
               TmpRes = RES1600;
               break;
         }




      for (i=0; i<NbVidParam; i++)
         {

         if ( vidParm[i].Resolution == TmpRes &&
               vidParm[i].PixWidth   == (DisplayMode->PixWidth == 24 ? 32:DisplayMode->PixWidth)
            )
            {
               pVidset = &(vidParm[i].VidsetPar[ZoomIndex]);
               break;
            }
         }


         if (!pVidset)
         {
         #ifdef PRINT
            printf("Video parameter not found in mga.inf");
         #endif
         return mtxFAIL;
         }


      /*** If there is no video parameter in file mga.inf for zoomming > 1
            (the first item = -1) then we keep video parameters for zoom = 1 ***/

      if ((pVidset->PixClock == (long)-1) && (ZoomVal > 1))
         pVidset = &(vidParm[i].VidsetPar[0]);
	  }

   }   /* else - Support DDC */


 /*** Transfer video parametres towards array vidtab[] ***/

   if (ZoomVal == 0) {
	  VideoDebugPrint ((0, "Division by zero (ZoomVal == 0) may occur!!"));
   }
   else
	  vidtab[0].valeur  = (unsigned long)pVidset->PixClock / ZoomVal;
   vidtab[1].valeur  = (unsigned long)pVidset->HFPorch;
   vidtab[2].valeur  = (unsigned long)pVidset->HSync;
   vidtab[3].valeur  = (unsigned long)pVidset->HBPorch;
   vidtab[4].valeur  = (unsigned long)pVidset->HOvscan;
   vidtab[5].valeur  = (unsigned long)pVidset->HDisp;

   vidtab[6].valeur  = (unsigned long)pVidset->VFPorch;
   vidtab[7].valeur  = (unsigned long)pVidset->VSync;
   vidtab[8].valeur  = (unsigned long)pVidset->VBPorch;
   vidtab[9].valeur  = (unsigned long)pVidset->VOvscan;
   vidtab[10].valeur = (unsigned long)pVidset->VDisp;
   vidtab[11].valeur = DisplayMode->PixWidth;

   vidtab[12].valeur = (unsigned long)pVidset->OvscanEnable;
   vidtab[13].valeur = (unsigned long)pVidset->InterlaceEnable;

   vidtab[14].valeur = Hw[iBoard].YDstOrg;  /* Start address */

   /* PACK PIXEL, CRTC en 32 bit et TITAN en 8 bits
      donc, YDstOrg transfome en byte
   */
   if (DisplayMode->PixWidth == 24)
      vidtab[14].valeur >>= 2;

   vidtab[15].valeur = ZoomVal;    /* Zoom factor X */
   vidtab[16].valeur = ZoomVal;    /* Zoom factor Y */

   vidtab[17].valeur = HwMode->FbPitch;      /* Virtual video pitch */

   if ( (DisplayMode->FbPitch != HwMode->FbPitch) || (ZoomVal > 1) ||
        (DisplayMode->DispType & 0x01) ||
        (ProductMGA[iBoard] == MGA_PCI_4M) )
      vidtab[18].valeur = 0;                   /* ALW  Non-Automatic Line Wrap */
   else
      vidtab[18].valeur = 1;


   if( detectPatchWithGal() )
      vidtab[18].valeur = 0;                   /* ALW  Non-Automatic Line Wrap */


   vidtab[27].valeur = (unsigned long)pVidset->HsyncPol;
   vidtab[28].valeur = (unsigned long)pVidset->VsyncPol;

   return(mtxOK);
}





/************************************************************************/
/*                                                                      */
/*  Translate the CTRC value in MGA registers value...                  */
/*                                                                      */
/************************************************************************/


void calculCrtcParam(void)
{


/*declarations-------------------------------------------------------------*/

unsigned long bs, be;
unsigned long h_front_p,hbskew,hretskew,h_sync,h_back_p,h_over;
unsigned long h_vis,h_total,v_vis,v_over,v_front_p,v_sync,v_back_p,vert_t;
unsigned long start_add_f,virt_vid_p,v_blank;
unsigned char v_blank_e,rline_c,cpu_p,page_s,alw,p_width;
unsigned long mux_rate,ldclk_en_dotclk;
int over_e,hsync_pol,div_1024,int_m;
int vclkhtotal,vclkhvis,vclkhsync,vclkhover,vclkhbackp,vclkhblank,vclkhfrontp;
int x_zoom,y_zoom;
int Cur_e,Crtc_tst_e,cur_e_sk,e_v_int,sel_5ref,crtc_reg_prt,i;

long rep_ge,nb_vclk_hfront_p,nb_vclk_hblank,delai,delai2,delai3,delai4;
/* long gclk; */
long vclk_divisor,pixel_clk;

int flagDelay3=0,flagDelay4=0;

long delayTab[4]={5000,11000,24000,28000};  /* for the value of delays */
long delayTab_A[6]={3000, 4000, 5000,11000,24000,28000};  /* for the value of delays */
                                            /* of register crtc_ctrl of the titan    */


/* structure for horizontal blanking end register -------------------------*/

union{

     struct {unsigned char pos :5;
             unsigned char skew:2;
             unsigned char res :1;

            }f;
     unsigned char all;
     } hor_blk_e;


/* structure for horizontal retrace end register----------------------------*/

union{

     struct {unsigned char pos :5;
             unsigned char skew:2;
             unsigned char res :1;
            }f;
     unsigned char all;
     } hor_ret;


/* structure for the calculation of the horizontal blank end position-------*/
/* since the last bit goes in the horizontal retrace end register ----------*/

union{
     struct {unsigned char horz_blank_e :5;
             unsigned char horz_ret     :1;
             unsigned char unused       :2;
            }f;
     unsigned char all;
     } hor_blk_a;


/* structure for the calculation of the vertical total since the first 7 bit go----*/
/* in the vertical total register and 8 and 9 go in the overflow register-*/


union{

     struct {unsigned long vert_t0_7    :8;
             unsigned long vert_t8      :1;
             unsigned long vert_t9      :1;
             unsigned long unused       :22;
            }f;
     unsigned long all;
     } v_total;


/* structure for the overflow register--------------------------------------*/

union{

     struct {unsigned char r0   :1;
             unsigned char r1   :1;
             unsigned char r2   :1;
             unsigned char r3   :1;
             unsigned char r4   :1;
             unsigned char r5   :1;
             unsigned char r6   :1;
             unsigned char r7   :1;
            }f;
     unsigned char all;
     } r_overf;

/* structure for the maximum scan line register-----------------------------*/
union{

     struct {unsigned char maxsl       :5;
             unsigned char v_blank_9   :1;
             unsigned char line_c      :1;
             unsigned char line_doub_e :1;
            }f;
     unsigned char all;
     } r_maxscanl;

/* structure for the cursor start register----------------------------------*/

union{

     struct {unsigned char curstart    :5;
             unsigned char cur_e       :1;
             unsigned char res         :1;
             unsigned char crtc_tst_e  :1;
            }f;
     unsigned char all;
     } r_cursor_s;

/* structure for the cursor end register------------------------------------*/

union{

     struct {unsigned char curend    :5;
             unsigned char cur_sk    :2;
             unsigned char res       :1;
            }f;
     unsigned char all;
     } r_cursor_e;

/* structure for the calculation of the vertical retrace start register------*/
/* the 7 least significant bits go in the register and the other 2   */
/* go in the overflow register                                       */

union{

     struct {unsigned long bit0_7    :8;
             unsigned long bit8      :1;
             unsigned long bit9      :1;
            }f;
     unsigned long all;
      } rvert_ret_s;

/* structure for the vertical retrace end register -------------------------*/

union{

     struct {unsigned char bit0_3       :4;
             unsigned char cl           :1;
             unsigned char e_vi         :1;
             unsigned char sel_5ref     :1;
             unsigned char reg_prot     :1;
            }f;
     unsigned char all;
      } rvert_ret_e;

/* structure for the calculation of the vertical display enable end---------*/

union{

     struct {unsigned long bit0_7       :8;
             unsigned long bit8         :1;
             unsigned long bit9         :1;
            }f;
     unsigned long all;
      } v_disp_e;

/* structure for the calculation of the vertical blanking start-------------*/
union{

     struct {unsigned long bit0_7       :8;
             unsigned long bit8         :1;
             unsigned long bit9         :1;
            }f;
     unsigned long all;
      } v_blank_s;

/* structure of the mode control register ----------------------------------*/

union{

     struct {unsigned char r0   :1;
             unsigned char r1   :1;
             unsigned char r2   :1;
             unsigned char r3   :1;
             unsigned char r4   :1;
             unsigned char r5   :1;
             unsigned char r6   :1;
             unsigned char r7   :1;
            }f;
     unsigned char all;
     } r_mode;

/* structure of the crtc extended add register------------------------*/

union{

     struct {unsigned char crtcadd    :2;
             unsigned char crtccur    :2;
             unsigned char crtc_add_e :1;
             unsigned char aux_cl     :1;
             unsigned char dip_sw_e   :1;
             unsigned char irq_e      :1;
            }f;
     unsigned char all;
     } r_crtc_ext;

/*structure of the interlace support register--------------------------*/

union{

     struct {unsigned char crtcadd    :4;
             unsigned char seq_vid    :1;
             unsigned char port       :1;
             unsigned char m_int      :1;
             unsigned char hr_16      :1;
            }f;
     unsigned char all;
     } r_int_s;




/* gclk=25.0e-9; */
vclk_divisor=VCLK_DIVISOR;



/* variable defined for the entry table-------------------------------- */

pixel_clk     =vidtab[0].valeur * 1000;
h_front_p     =vidtab[1].valeur;
h_sync        =vidtab[2].valeur;
h_back_p      =vidtab[3].valeur;
h_over        =vidtab[4].valeur;
h_vis         =vidtab[5].valeur;
v_front_p     =vidtab[6].valeur;
v_sync        =vidtab[7].valeur;
v_back_p      =vidtab[8].valeur;
v_over        =vidtab[9].valeur;
v_vis         =vidtab[10].valeur;
p_width       =(unsigned char)vidtab[11].valeur;
over_e        =vidtab[12].valeur;
int_m         =vidtab[13].valeur;
start_add_f   =vidtab[14].valeur;
x_zoom        =vidtab[15].valeur;
y_zoom        =vidtab[16].valeur;
virt_vid_p    =vidtab[17].valeur;
alw           =(unsigned char)vidtab[18].valeur;
hbskew        =vidtab[19].valeur;
hretskew      =vidtab[20].valeur;
cur_e_sk      =vidtab[21].valeur;
Cur_e         =vidtab[22].valeur;
Crtc_tst_e    =vidtab[23].valeur;
e_v_int       =vidtab[24].valeur;
sel_5ref      =vidtab[25].valeur;
crtc_reg_prt  =vidtab[26].valeur;
hsync_pol     =vidtab[27].valeur;


if (p_width == 24) /* Pack Pixel */
   {
   h_front_p = (h_front_p * 3 ) >> 2;
   h_sync    = (h_sync    * 3 ) >> 2;
   h_back_p  = (h_back_p  * 3 ) >> 2;
   h_over    = (h_over    * 3 ) >> 2;
   h_vis     = (h_vis     * 3 ) >> 2;

   if ( (h_front_p % 32) ) h_front_p += 32 - (h_front_p % 32);
   if ( (h_sync    % 32) ) h_sync    += 32 - (h_sync    % 32);
   if ( (h_back_p  % 32) ) h_back_p  += 32 - (h_back_p  % 32);
   }


/*----------------calculation of reg htotal --------------------------------*/

   h_total=h_vis+h_front_p+h_sync+h_back_p;


#ifdef NO_FLOAT
   vclkhtotal= (((h_total/VCLK_DIVISOR)*10)+5)/10;
#else
   vclkhtotal=h_total/VCLK_DIVISOR+0.5;
#endif

   crtcTab[0]=(vclkhtotal/x_zoom)-5;

   /* in pack pixel, the number of LCLKs in the total horizontal line
      (active + blanked) must be a multiple of the number of LCLKs
      per pixel group.
   */
   if ((p_width == 24) && ((crtcTab[0]+5) % 3 )) /* Pack Pixel */
      {
      vclkhtotal += (3 - ((crtcTab[0]+5) % 3)) * x_zoom;
      crtcTab[0] += 3 - ((crtcTab[0]+5) % 3);
      }

/* PACK PIXEL, temporary PATCH */

/*----------------calculation of the horizontal display enable end reg -----*/


#ifdef NO_FLOAT
   vclkhvis=(((h_vis/VCLK_DIVISOR)*10)+5)/10;
#else
   vclkhvis=h_vis/VCLK_DIVISOR+0.5;
#endif

   crtcTab[1]=(vclkhvis/x_zoom)-1;


/*----------------calculation of the horizontal blanking start register-----*/

   if(detectPatchWithGal() == 0)
      {
      if (h_over>0)
         {
         if (h_over<(VCLK_DIVISOR/2))
            vclkhover=1*over_e;
         else
         #ifdef NO_FLOAT
            vclkhover=((((h_over/VCLK_DIVISOR)*10)+5)/10)*over_e;
         #else
            vclkhover=(h_over/VCLK_DIVISOR+0.5)*over_e;
         #endif
         }
      else
         vclkhover=0;

      /* Create overscan to bypass a problem in the bank switch */
      /* with old revision of TVP3026                           */

      crtcTab[2]=((vclkhvis+vclkhover)/x_zoom)-1;

      }
   else
      {
      crtcTab[2] = crtcTab[1] - 1;                         /* See DAT #??? */
      vclkhover=0;
      }


/*-----------calculation of horizontal blanking end register----------------*/


#ifdef NO_FLOAT
   vclkhfrontp=(((h_front_p/VCLK_DIVISOR)*10)+5)/10;

   vclkhsync=(((h_sync/VCLK_DIVISOR)*10)+5)/10;

   vclkhbackp=(((h_back_p/VCLK_DIVISOR)*10)+5)/10;
#else
   vclkhfrontp=h_front_p/VCLK_DIVISOR+0.5;

   vclkhsync=h_sync/VCLK_DIVISOR+0.5;

   vclkhbackp=h_back_p/VCLK_DIVISOR+0.5;
#endif

   vclkhblank=vclkhfrontp+vclkhbackp+vclkhsync-(2*vclkhover*over_e);

   hor_blk_a.all=((vclkhvis+vclkhover+vclkhblank)/x_zoom)-2;

   bs = crtcTab[2];
   be = hor_blk_a.all + 1;

   if (!((0x40 > bs) & (0x40 < be) ||
         (0x80 > bs) & (0x80 < be) ||
         (0xc0 > bs) & (0xc0 < be)))
      hor_blk_a.all = 0;

   if (detectPatchWithGal() == 0)
      hor_blk_e.f.pos=hor_blk_a.f.horz_blank_e;
   else
      hor_blk_e.f.pos=(vclkhtotal/x_zoom)-2;


   hor_blk_e.f.skew=(unsigned char)hbskew;

   hor_blk_e.f.res=0;

   crtcTab[3]=hor_blk_e.all;


/*----------calculation of the horizontal retrace start register----------*/


   crtcTab[4]=((vclkhvis+vclkhfrontp)/x_zoom)-1;



/*---------------calculation of the horizontal retrace end register---------*/


   hor_ret.f.pos=((vclkhvis+vclkhfrontp+vclkhsync)/x_zoom)-1;

   hor_ret.f.skew=(unsigned char)hretskew;

   hor_ret.f.res=hor_blk_a.f.horz_ret;

   if(detectPatchWithGal() == 0)
      hor_ret.f.res=hor_blk_a.f.horz_ret;
   else
      hor_ret.f.res=(unsigned char)(crtcTab[0]+3) >> 5;

   crtcTab[5]=hor_ret.all;

/*--------------calculation of the vertical total register ----------------*/

   vert_t=v_vis+v_front_p+v_sync+v_back_p;

   div_1024=(vert_t>1023) ? 2 : 1;

   v_total.all=vert_t/div_1024-2;

   crtcTab[6]=v_total.f.vert_t0_7;


/*------------- preset row scan register -----------------------------------*/

   crtcTab[8]=0;


/*----------------calculation of the cursor start register------------------*/


   r_cursor_s.f.curstart=0;

   r_cursor_s.f.cur_e=~Cur_e;

   r_cursor_s.f.res=0;

   r_cursor_s.f.crtc_tst_e=(byte)Crtc_tst_e;

   crtcTab[10]=r_cursor_s.all;

/*----------------calculation of the cursor end register -------------------*/

   r_cursor_e.f.curend=0;

   r_cursor_e.f.cur_sk=(byte)cur_e_sk;

   r_cursor_e.f.res=0;

   crtcTab[11]=r_cursor_e.all;

/*----------------calculation of the add start add high register -----------*/
   start_add_f = start_add_f / 8;

   crtcTab[12]=start_add_f/256;

/*-----------------calculation of the add start add low register -----------*/

   crtcTab[13]=start_add_f;

/*----------------- cursor position high register --------------------------*/

   crtcTab[14]=0;

/*----------------- cursor position low register ---------------------------*/

   crtcTab[15]=0;

/*------------------calculation of the vertical retrace start register------*/

   rvert_ret_s.all=((v_vis+v_front_p)/div_1024)-1;

   crtcTab[16]=rvert_ret_s.f.bit0_7;


/*-------------- calculation of the vertical retrace end register ----------*/

   rvert_ret_e.f.bit0_3=(unsigned char)(v_vis+v_front_p+v_sync)/div_1024-1;

   rvert_ret_e.f.cl=1;

   rvert_ret_e.f.e_vi=(byte)e_v_int;

   rvert_ret_e.f.sel_5ref=(byte)sel_5ref;

   rvert_ret_e.f.reg_prot=(byte)crtc_reg_prt;

   crtcTab[17]=rvert_ret_e.all;

/*--------------calculation of the vertical display enable register --------*/

   v_disp_e.all=v_vis/div_1024-1;

   crtcTab[18]=v_disp_e.f.bit0_7;

/*--------------calculation of the offset register -------------------------*/

   crtcTab[19]=((virt_vid_p/VCLK_DIVISOR)+(virt_vid_p*int_m/VCLK_DIVISOR))/2;
   if (p_width == 24) /* Pack Pixel */
      crtcTab[19] = (crtcTab[19] * 3) >> 2;

/*------------------ under line location register --------------------------*/

   crtcTab[20]=0;

/*-----------calculation of the vertical blanking start register ----------*/

   v_blank_s.all=(v_vis+(v_over*over_e))/div_1024-1;

   crtcTab[21]=v_blank_s.f.bit0_7;

/*-----------calculation of the vertical blanking end register ------------*/

   v_blank=v_back_p+v_sync+v_front_p-(2*v_over*over_e);

   v_blank_e=(unsigned char)(
            (v_vis+(v_over*over_e)+v_blank-((v_over*over_e>0) ? 0 : 1))/div_1024-1);

   crtcTab[22]=v_blank_e;


/*-------------- mode control register -------------------------------------*/

   r_mode.f.r0=0;

   r_mode.f.r1=0;

   r_mode.f.r2=div_1024==2 ? 1 : 0 ;

   r_mode.f.r3=0;

   r_mode.f.r4=0;

   r_mode.f.r5=0;

   r_mode.f.r6=1;

   r_mode.f.r7=1;

   crtcTab[23]=r_mode.all;

/*----------- line compare register ----------------------------------------*/

#ifdef WINDOWS_NT
    rline_c=0xFF;
#else
   rline_c=-1;
#endif

   crtcTab[24]=rline_c;


/*-----------calculation of the maximum scan line register -----------------*/


   r_maxscanl.f.maxsl=(y_zoom==1) ? 0 : y_zoom-1;

   r_maxscanl.f.v_blank_9=(unsigned char)v_blank_s.f.bit9;

   r_maxscanl.f.line_c=1;

   r_maxscanl.f.line_doub_e=0;

   crtcTab[9]=r_maxscanl.all;

/*-------------- overflow register -----------------------------------------*/


   r_overf.f.r0=(unsigned char)v_total.f.vert_t8;

   r_overf.f.r1=(unsigned char)v_disp_e.f.bit8;

   r_overf.f.r2=(unsigned char)rvert_ret_s.f.bit8;

   r_overf.f.r3=(unsigned char)v_blank_s.f.bit8;

   r_overf.f.r4=1;

   r_overf.f.r5=(unsigned char)v_total.f.vert_t9;

   r_overf.f.r6=(unsigned char)v_disp_e.f.bit9;

   r_overf.f.r7=(unsigned char)rvert_ret_s.f.bit9;

   crtcTab[7]=r_overf.all;

/*------------ cpu page select register ------------------------------------*/

   cpu_p=0;

   crtcTab[25]=cpu_p;

/*------------ crtc extended address register ------------------------------*/

   r_crtc_ext.f.crtcadd=0;

   r_crtc_ext.f.crtccur=0;

   r_crtc_ext.f.crtc_add_e=1;

   r_crtc_ext.f.aux_cl=0;

   r_crtc_ext.f.dip_sw_e=0;

   r_crtc_ext.f.irq_e=1;

   crtcTab[26]=r_crtc_ext.all;

/*------------ 32k video ram page select register -----------------*/

   page_s=0;

   crtcTab[27]=page_s;

/*----------- interlace support register--------------------------*/


   r_int_s.f.crtcadd=0;

   r_int_s.f.seq_vid=0;

   r_int_s.f.port=0;

   r_int_s.f.m_int=(byte)int_m;

   r_int_s.f.hr_16=0;

   crtcTab[28]=r_int_s.all;

/*------------other arguments entered in the table------------------------*/
   crtcTab[29]=alw;

   crtcTab[30]=pixel_clk;

   crtcTab[32]=hsync_pol;


/*************************************************************************/
/*                                                                       */
/* calculation of video delay for the crtc_ctrl register                 */
/*                                                                       */
/*************************************************************************/


   rep_ge=(37*25*(pixel_clk/1000000)) / vclk_divisor;

   nb_vclk_hfront_p= (h_front_p*1000) / (vclk_divisor * x_zoom);

   nb_vclk_hblank=( ((h_front_p+h_sync+h_back_p)*1000) / (VCLK_DIVISOR) / x_zoom);

   delai=nb_vclk_hfront_p-1000;

   delai2=rep_ge-625;

   delai3=nb_vclk_hblank-rep_ge-2000;

   delai4=((nb_vclk_hblank+1000)/2)-3000;

   /*** BEN ajout ***/
   crtcTab[31]=0x00;

   if ( (Hw[iBoard].ProductRev >> 4) == 0 )  /* TITAN */
      {
      for (i=0;i<4;i++)
         {
         if (delayTab[i]>=delai)
            {
            if (delayTab[i]>=delai2)
               {
               if (delayTab[i]<=delai3)
                  {
                  /*** The fourth was temporarily eliminated ***/
                  /*    if (delayTab[i]<=delai4) */
                  /*     { */
                  if (delayTab[i]==28000)
                    {
                    crtcTab[31]=0x03;
                    break;
                    }
                  else if (delayTab[i]==24000)
                    {
                    crtcTab[31]=0x02;
                    break;
                    }
                  else if (delayTab[i]==11000)
                    {
                    crtcTab[31]=0x01;
                    break;
                    }
                  else
                    {
                    crtcTab[31]=0x00;
                    break;
                    }
            /*    } */
                  }
               }
            }
         }
      }
   else    /* 2 video delay add for atlas and I suppose,for newest     */
      {    /* variation of titan they have the same video delay        */

      for (i=0;i<6;i++)
         {
         if (delayTab_A[i]>=delai)
            {
            if (delayTab_A[i]>=delai2)
               {
               if (delayTab_A[i]<=delai3)
                  {
                  if (delayTab_A[i]==28000)
                     {
                     crtcTab[31]=0x3;
                     break;
                     }
                  else if (delayTab_A[i]==24000)
                     {
                     crtcTab[31]=0x2;
                     break;
                     }
                  else if (delayTab_A[i]==11000)
                     {
                     crtcTab[31]=0x1;
                     break;
                     }
                  else if (delayTab_A[i]==5000)
                     {
                     crtcTab[31]=0x0;
                     break;
                     }
                  else if (delayTab_A[i]==4000)
                     {
                     crtcTab[31]=0x5;
                     flagDelay4=1;
                     break;
                     }
                  else if (delayTab_A[i]==3000)
                     {
                     crtcTab[31]=0x4;
                     flagDelay3=1;
                     continue;
                     }
                  }
               }
            }
         }
      }


   if ( flagDelay3 && flagDelay4 )
      crtcTab[31]=0x5; /* if we are videodelay 3 and 4 they respect 3 rules */


/***************************************************************************/
/*                                                                         */
/* calcul hsync delay for the register dub_ctl for the field  hsync_del    */
/*                                                                         */
/***************************************************************************/

   switch (p_width)
      {
      case 8:
         mux_rate=ldclk_en_dotclk=4;
         break;

      case 16:
         mux_rate=ldclk_en_dotclk=2;
         break;
/* PACK PIXEL add cas 24 */
      case 32:
      case 24:
         mux_rate=ldclk_en_dotclk=1;
         break;
      }

   switch (Hw[iBoard].DacType)
      {
      case BT485:
      case PX2085:
                           /*********************************/
                           /*     For  BT485                */
                           /*                               */
                           /* syncdel=1 ldclk expressed in  */
                           /*         dotclock + 7 dotclock */
                           /*         --------------------- */
                           /*               (muxrate)       */
                           /*                               */
                           /* syncdel= a whole value        */
                           /*          and rounded          */
                           /*                               */
                           /* muxrate= ( 8bpp=4:1)          */
                           /*        = (16bpp=2:1)          */
                           /*        = (32bpp=1:1)          */
                           /*                               */
                           /*                               */
                           /*********************************/
         crtcTab[33]=((ldclk_en_dotclk+7)*100/mux_rate+50)/100;
         break;

      case VIEWPOINT:      /*********************************/
                           /*                               */
                           /*     For  VIEWPOINT            */
                           /*                               */
                           /* syncdel=2 ldclk expressed in  */
                           /*         dotclock + 14 dotclock*/
                           /*         --------------------- */
                           /*               (muxrate)       */
                           /*                               */
                           /* syncdel= a whole value        */
                           /*          and rounded          */
                           /*                               */
                           /* muxrate= ( 8bpp=4:1)          */
                           /*        = (16bpp=2:1)          */
                           /*        = (32bpp=1:1)          */
                           /*                               */
                           /*                               */
                           /*********************************/
         crtcTab[33]=02/*((ldclk_en_dotclk*2 + 14)*100/(mux_rate*2)+50)/100*/;
         break;


      case TVP3026:
         crtcTab[33]=0;
         break;

#ifdef SCRAP
        case BT481:

           crtcTab[33]=02;
           break;
#endif

      default:

         crtcTab[33]=02;
         break;


      }

}

/************************************************************************/
/*/
* Name:           getAthenaRevision
*
* synopsis:       try to find the silicone revision of athena chip
*
*
* returns:        revision : -1   - Unknow or not a athena chip
*/
/* --------------------------- D.A.T. GEN0?? ---------------------------*/
/*  Strap  nomuxes   block8    tram   Athena rev|     Type de ram       */
/*           0         0         0        2     |4Mbit (8-bit blk node) */
/*           0         0         1        2     |  "      "     "       */
/*           0         1         0        2     |4Mbit (4-bit blk node) */
/*           0         1         1        1     |2Mbit (4-bit blk node) */
/*                                              |                       */
/*           1         0         0        1     |4Mbit (8-bit blk node) */
/*           1         0         1        1     |  "      "     "       */
/*           1         1         0        1     |4Mbit (4-bit blk node) */
/*           1         1         1        2     |2Mbit (4-bit blk node) */
/*----------------------------------------------------------------------*/

word getAthenaRevision(dword dst0, dword dst1)
{
   byte  _block8, _tram, _nomuxes;
   word  rev = 2;

   _block8  = (dst0 & TITAN_DST0_BLKMODE_M) != 0;
   _tram    = (dst1 & TITAN_DST1_TRAM_M)    != 0;
   _nomuxes = (dst1 & TITAN_DST1_NOMUXES_M) != 0;

   /* check if athena chip */
   if( ((Hw[iBoard].ProductRev >> 4) & 0x0000000f) != ATHENA_CHIP)
      return (word) -1;


   if ( Hw[iBoard].DacType == TVP3026 )
      {
      if (_block8 && _tram) /* IMP+ /P */
         {
         rev = _nomuxes ? 2 : 1;
         }
      else
         {
         rev = _nomuxes ? 1 : 2;
         }
      }
   else
      {
      if ( Hw[iBoard].VGAEnable )
         rev = pciBoardInfo & PCI_FLAG_ATHENA_REV1 ? 1 : 2;
      else
         rev = 2;
      }

   return rev;
}






/************************************************************************/
/*/
* Name:           detectPatchWithGal
*
* synopsis:       Detect if the board has the patch that fixes the bug
*                 with SOE (See DAT on missing pixel in the bank switch).
*
*
* returns:        byte : mtxOK   - the board has the patch.
*                        mtxFAIL - it hasn't
*/

byte detectPatchWithGal(void)
{
    byte result=0;
    dword TramDword;
    /* general_info *genInfo; */

    dword Dst0, Dst1;
    dword InfoHardware;


    if ( Hw[iBoard].DacType != TVP3026 )
        return mtxFAIL; /* GAL in use on TVP3026 only */



    if ((Hw[iBoard].ProductType &  0x0f) == BOARD_MGA_RESERVED)
        return mtxFAIL; /* Always rev 2 */


    /*------ Strap added in ATHENA For max clock dac support ----*/
    GetMGAConfiguration(pMgaBaseAddr, &Dst0, &Dst1, &InfoHardware);


    if ( Dst1 & TITAN_DST1_ABOVE1280_M )
        return mtxFAIL; /* no gal on this board */


    if ( getAthenaRevision(Dst0, Dst1) == 2)
        return mtxFAIL; /* No gal on rev 2 */


    mgaReadDWORD(*(pMgaBaseAddr+TITAN_OFFSET+TITAN_OPMODE),TramDword);
    TramDword &= TITAN_TRAM_M;

    /** The GAL is present on Rev2 or higher board with bit TRAM at 0 and
        on board with bit TRAM at 1 (/P4) **/

    if( (((Hw[iBoard].ProductRev & 0xf) >= 2) && !TramDword) || TramDword)
        result = mtxOK;
    else
        result = mtxFAIL;

    return(result);
}

word ConvBitToFreq (word BitFreq)
{
   word result;

     // bit  0:  43 Hz interlaced
     // bit  1:  56 Hz
     // bit  2:  60 Hz
     // bit  3:  66 Hz
     // bit  4:  70 Hz
     // bit  5:  72 Hz
     // bit  6:  75 Hz
     // bit  7:  76 Hz
     // bit  8:  80 Hz
     // bit  9:  85 Hz
     // bit 10:  90 Hz
     // bit 11: 100 Hz
     // bit 12: 120 Hz

     switch (BitFreq)
        {
        case 0:
           result = 43;
           break;
        case 1:
           result = 56;
           break;
        case 2:
           result = 60;
           break;
        case 3:
           result = 66;
           break;
        case 4:
           result = 70;
           break;
        case 5:
           result = 72;
           break;
        case 6:
           result = 75;
           break;
        case 7:
           result = 76;
           break;
        case 8:
           result = 80;
           break;
        case 9:
           result = 85;
           break;
        case 10:
           result = 90;
           break;
        case 11:
           result = 100;
           break;
        case 12:
           result = 120;
        default:
		   result = 0;
           break;

        }

 return(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\matrox\mga\mini\vidfile.h ===
/******  VIDFILE.H  ******/
#ifndef VIDFILE
#define VIDFILE

typedef struct
   {
   word         DispWidth;
   word         DispHeight;
   word         PixDepth;
   word         RefreshRate;
   Vidset       VideoSet;
   } ResParamSet;

#ifdef WINDOWS_NT
#pragma pack( )
#endif

extern word ConvBitToFreq (word BitFreq);
extern ResParamSet ResParam[100];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\brush.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: brush.h
*
* Contains all the brush related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#ifndef __BRUSH__H__
#define __BRUSH__H__

//
// Brush stuff
//
// 'Slow' brushes are used when we don't have hardware pattern capability,
// and we have to handle patterns using screen-to-screen blts:
//
#define SLOW_BRUSH_CACHE_DIM_X  8
#define SLOW_BRUSH_CACHE_DIM_Y  1   // Controls the number of brushes cached
                                    // in off-screen memory, when we don't have
                                    // the hardware pattern support. We
                                    // allocate 3 x 3 brushes, so we can cache
                                    // a total of 9 brushes:

#define SLOW_BRUSH_COUNT  (SLOW_BRUSH_CACHE_DIM_X * SLOW_BRUSH_CACHE_DIM_Y)
#define SLOW_BRUSH_DIMENSION    40  // After alignment is taken care of, every
                                    // off-screen brush cache entry will be 48
                                    // pels in both dimensions

#define SLOW_BRUSH_ALLOCATION   (SLOW_BRUSH_DIMENSION + 8)
                                    // Actually allocate 72x72 pels for each
                                    // pattern, using the 8 extra for brush
                                    // alignment

//
// 'Fast' brushes are used when we have hardware pattern capability:
//
#define FAST_BRUSH_COUNT        16  // Total number of non-hardware brushes
                                    // cached off-screen
#define FAST_BRUSH_DIMENSION    8   // Every off-screen brush cache entry is
                                    // 8 pels in both dimensions
#define FAST_BRUSH_ALLOCATION   8   // We have to align ourselves, so this is
                                    // the dimension of each brush allocation

//
// Common to both implementations:
//
#define RBRUSH_2COLOR           1   // For RBRUSH flags

#define TOTAL_BRUSH_COUNT       max(FAST_BRUSH_COUNT, SLOW_BRUSH_COUNT)
                                    // This is the maximum number of brushes
                                    //   we can possibly have cached off-screen
#define TOTAL_BRUSH_SIZE        64  // We'll only ever handle 8x8 patterns,
                                    //   and this is the number of pels

//
// New brush support
//

#define NUM_CACHED_BRUSHES      16

#define CACHED_BRUSH_WIDTH_LOG2 6
#define CACHED_BRUSH_WIDTH      (1 << CACHED_BRUSH_WIDTH_LOG2)
#define CACHED_BRUSH_HEIGHT_LOG2 6
#define CACHED_BRUSH_HEIGHT     (1 << CACHED_BRUSH_HEIGHT_LOG2)
#define CACHED_BRUSH_SIZE       (CACHED_BRUSH_WIDTH * CACHED_BRUSH_HEIGHT)

typedef struct _BrushEntry BrushEntry;

//
// NOTE: Changes to the RBRUSH or BRUSHENTRY structures must be reflected
// in i386/strucs.inc!
//
typedef struct _RBrush
{
    FLONG       fl;                 // Type flags
    DWORD       areaStippleMode;    // area stipple mode if 1bpp.

    //
    //??? get rid of bTransparent later. We need it now so everything
    // compiles OK
    //
    BOOL        bTransparent;       // TRUE if brush was realized for a
                                    // transparent blt (meaning colours are
                                    // white and black).
                                    // FALSE if not (meaning it's already been
                                    // colour-expanded to the correct colours).
                                    // Value is undefined if the brush isn't
                                    // 2 colour.
    ULONG       ulForeColor;        // Foreground colour if 1bpp
    ULONG       ulBackColor;        // Background colour if 1bpp
    POINTL      ptlBrushOrg;        // Brush origin of cached pattern.  Initial
                                    // value should be -1
    BrushEntry* pbe;                // Points to brush-entry that keeps track
                                    // of the cached off-screen brush bits
    ULONG       aulPattern[1];      // Open-ended array for keeping copy of the
                                    // actual pattern bits in case the brush
                                    // origin changes, or someone else steals
                                    // our brush entry (declared as a ULONG
                                    // for proper dword alignment)
    //
    // Don't put anything after here
    //
} RBrush;                           /* rb, prb */

typedef struct _BrushEntry
{
    RBrush*     prbVerify;          // We never dereference this pointer to
                                    // find a brush realization; it is only
                                    // ever used in a compare to verify that
                                    // for a given realized brush, our
                                    // off-screen brush entry is still valid.
    ULONG       ulPixelOffset;      // pixel offset in video memory to brush
                                    // partial product for this stride is
                                    // ppdev->ulBrushPackedPP
} BrushEntry;                       /* be, pbe */

typedef union _RBrushColor
{
    RBrush*     prb;
    ULONG       iSolidColor;
} RBrushColor;                     /* rbc, prbc */

BOOL    bEnableBrushCache(PDev* ppdev);
VOID    vAssertModeBrushCache(PDev* ppdev, BOOL bEnable);
VOID    vDisableBrushCache(PDev* ppdev);
VOID    vRealizeDitherPattern(HDEV hdev, RBrush* prb, ULONG ulRGBToDither);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\bitblt.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: bitblt.c
 *
 * Contains the high-level DrvBitBlt and DrvCopyBits functions.
 *
 *
 * NOTE:  Please see heap.c for a discussion of the types of bitmaps
 *        our acceleration functions are likely to encounter and the
 *        possible states of these bitmaps.
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "clip.h"
#include "heap.h"
#include "log.h"

//@@BEGIN_DDKSPLIT
#if GDI_TEST
ULONG
vPuntBefore(SURFOBJ * psoSrc, SURFOBJ * psoDst)
{
    ULONG   flags = 0;

    if(MAKE_BITMAPS_OPAQUE)
    {
        if(psoSrc != NULL && psoSrc->iType == STYPE_DEVBITMAP)
        {
            Surf *  psurfSrc = (Surf *) psoSrc->dhpdev;

            ASSERTDD(psurfSrc != NULL, "expected non-null psurf");
    
            psoSrc->iType = STYPE_BITMAP;
            flags |= 1;
        }

        if(psoDst != NULL && psoDst->iType == STYPE_DEVBITMAP)
        {
            Surf *  psurfDst = (Surf *) psoDst->dhpdev;
            
            ASSERTDD(psurfDst != NULL, "expected non-null psurf");
    
            psoDst->iType = STYPE_BITMAP;
            flags |= 2;
    
        }

    }

    return flags;
}

void
vPuntAfter(ULONG flags, SURFOBJ * psoSrc, SURFOBJ * psoDst)
{
    if(MAKE_BITMAPS_OPAQUE)
    {
        if(psoSrc != NULL && (flags & 1))
        {
            Surf *  psurfSrc = (Surf *) psoSrc->dhpdev;
    
            ASSERTDD(psurfSrc != NULL, "expected non-null psurf");
            ASSERTDD(psoSrc->iType == STYPE_BITMAP, "expected STYPE_BITMAP");
    
            psoSrc->iType = STYPE_DEVBITMAP;
        }

        ASSERTDD(psoDst != NULL, "expected non-null psoDst");

        if(flags & 2)
        {
            Surf *  psurfDst = (Surf *) psoDst->dhpdev;
            
            ASSERTDD(psurfDst != NULL, "expected non-null psurf");
            ASSERTDD(psoDst->iType == STYPE_BITMAP, "expected STYPE_BITMAP");
                
            psoDst->iType = STYPE_DEVBITMAP;
    
        }

    }
}
#endif
//@@END_DDKSPLIT

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvBitBlt
//
// DrvBitBlt provides general bit-block transfer capabilities between
// device-managed surfaces, between GDI-managed standard-format bitmaps, or
// between a device-managed surface and a GDI-managed standard-format bitmap.
//
// Parameters:
//   psoDst---Points to the SURFOBJ structure that describes the surface on
//            which to draw
//   psoSrc---Points to a SURFOBJ structure that describes the source for
//            the bit-block transfer operation, if required by the rop4
//            parameter
//   psoMask--Points to a SURFOBJ structure that describes a surface to be
//            used as a mask for the rop4 parameter. The mask is a bitmap with
//            1 bit per pixel. Typically, a mask is used to limit the area to
//            be modified in the destination surface. Masking is selected by
//            setting the rop4 parameter to the value 0xAACC. The destination
//            surface is unaffected if the mask is 0x0000. 
//
//            The mask will be large enough to cover the destination rectangle.
//
//            If this parameter is null and a mask is required by the rop4
//            parameter, the implicit mask in the brush is used
//   pco------Points to a CLIPOBJ structure that limits the area to be modified
//            GDI services (CLIPOBJ_Xxx) that enumerate the clip region as a
//            set of rectangles are provided. Whenever possible, GDI simplifies
//            the clipping involved; for example, this function is never called
//            with a single clipping rectangle. GDI clips the destination
//            rectangle before calling this function, making additional
//            clipping unnecessary. 
//   pxlo-----Points to a XLATEOBJ structure that specifies how color indices
//            should be translated between the source and destination surfaces.
//            If the source surface is palette-managed, its colors are
//            represented by indices into a lookup table of RGB values. The
//            XLATEOBJ structure can be queried for a translate vector that
//            will allow the device driver to translate any source index into
//            a color index for the destination. 
//
//            The situation is more complicated when, for example, the source
//            is RGB, but the destination is palette-managed. In this case,
//            the closest match to each source RGB value must be found in the
//            destination palette. The driver can call the XLATEOBJ_iXlate
//            service to perform this operation. 
//
//            Optionally, the device driver can match colors when the target
//            palette is the default device palette. 
//   prclDst--Points to a RECTL structure that defines the area to be modified.
//            This structure uses the coordinate system of the destination
//            surface. The lower and right edges of this rectangle are not
//            part of the bit-block transfer, meaning the rectangle is lower
//            right exclusive. 
//            DrvBitBlt is never called with an empty destination rectangle.
//            The two points that define the rectangle are always well-ordered.
//   pptlSrc--Points to a POINTL structure that defines the upper left corner
//            of the source rectangle, if a source exists. This parameter is
//            ignored if there is no source. 
//   pptlMask-Points to a POINTL structure that defines which pixel in the mask
//            corresponds to the upper left corner of the source rectangle, if
//            a source exists. This parameter is ignored if the psoMask
//            parameter is null. 
//   pbo------Points to the brush object that defines the pattern for the
//            bit-block transfer. GDI's BRUSHOBJ_pvGetRbrush service can be
//            used to retrieve the device's realization of the brush. This
//            parameter is ignored if the rop4 parameter does not require a
//            pattern. 
//   pptlBrush-Points to a POINTL structure that defines the origin of the
//            brush in the destination surface. The upper left pixel of the
//            brush is aligned at this point, and the brush repeats according
//            to its dimensions. This parameter is ignored if the rop4
//            parameter does not require a pattern. 
//   rop4-----Specifies a raster operation that defines how the mask, pattern,
//            source, and destination pixels are combined to write to the
//            destination surface. 
//            This is a quaternary raster operation, which is an extension of
//            the ternary Rop3 operation. A Rop4 has 16 relevant bits, which
//            are similar to the 8 defining bits of a Rop3. The simplest way
//            to implement a Rop4 is to consider its 2 bytes separately: The
//            low byte specifies a Rop3 that should be calculated if the mask
//            is one; the high byte specifies a Rop3 that can be calculated and
//            applied if the mask is 0. 
//
// Return Value
//   The return value is TRUE if the bit-block transfer operation is successful
//   Otherwise, it is FALSE, and an error code is logged.
//
//-----------------------------------------------------------------------------
BOOL
DrvBitBlt(SURFOBJ*  psoDst,
          SURFOBJ*  psoSrc,
          SURFOBJ*  psoMsk,
          CLIPOBJ*  pco,
          XLATEOBJ* pxlo,
          RECTL*    prclDst,
          POINTL*   pptlSrc,
          POINTL*   pptlMsk,
          BRUSHOBJ* pbo,
          POINTL*   pptlBrush,
          ROP4      rop4)
{
    BOOL            bResult;
    GFNPB           pb;
    XLATEOBJ        xloTmp;
    ULONG           aulTmp[2];

    ASSERTDD(!(rop4 & 0xFFFF0000), "DrvBitBlt: unexpected rop4 code");

    pb.ulRop4   = (ULONG) rop4;

    pb.psurfDst = (Surf*)psoDst->dhsurf;
    
    pb.prclDst = prclDst;

    if ( psoSrc == NULL )
    {
        pb.psurfSrc = NULL;

        //
        // We will only be given fills to device managed surfaces
        //
        ASSERTDD(pb.psurfDst != NULL,
                 "DrvBitBlt: unexpected gdi managed destination");

        if ( pb.psurfDst->flags & SF_SM )
        {
            goto puntIt;
        }

        //
        // We are filling surface in video memory
        //
        pb.ppdev = pb.psurfDst->ppdev;

        vSurfUsed(pb.ppdev, pb.psurfDst);

        //
        // If a mask is required punt it
        //
        
        if ( (rop4 & 0xFF) != (rop4 >> 8) )
        {
            goto puntIt;
        }

        //
        // Since 'psoSrc' is NULL, the rop3 had better not indicate
        // that we need a source.
        //
        ASSERTDD((((rop4 >> 2) ^ rop4) & 0x33) == 0,
                 "Need source but GDI gave us a NULL 'psoSrc'");

        //
        // Default to solid fill
        //

        if ( (((rop4 >> 4) ^ rop4) & 0xf) != 0 )
        {
            //
            // The rop says that a pattern is truly required
            // (blackness, for instance, doesn't need one):
            //
            
            //
            // for pbo->iSolidColor, a value of 0xFFFFFFFF(-1) indicates that
            // a nonsolid brush must be realized
            //
            if ( pbo->iSolidColor == -1 )
            {
                //
                // Non-solid brush case. Try to realize the pattern brush; By
                // doing this call-back, GDI will eventually call us again
                // through DrvRealizeBrush
                //
                pb.prbrush = (RBrush*)pbo->pvRbrush;
                if ( pb.prbrush == NULL )
                {
                    pb.prbrush = (RBrush*)BRUSHOBJ_pvGetRbrush(pbo);
                    if ( pb.prbrush == NULL )
                    {
                        //
                        // If we couldn't realize the brush, punt
                        // the call (it may have been a non 8x8
                        // brush or something, which we can't be
                        // bothered to handle, so let GDI do the
                        // drawing):
                        //
                        DBG_GDI((2, "DrvBitBlt: BRUSHOBJ_pvGetRbrush failed"));
                        
                        goto puntIt;
                    }
                }

                pb.pptlBrush = pptlBrush;
                
                //
                // Check if brush pattern is 1 BPP or not
                // Note: This is set in DrvRealizeBrush
                //
                if ( pb.prbrush->fl & RBRUSH_2COLOR )
                {
                    //
                    // 1 BPP pattern. Do a Mono fill
                    //
                    pb.pgfn = vMonoPatFill;
                }
                else
                {
                    pb.pgfn = vPatFill;
                }
            }
            else
            {
                ASSERTDD( (pb.ppdev->cBitsPerPel == 32) 
                    ||(pbo->iSolidColor&(0xFFFFFFFF<<pb.ppdev->cBitsPerPel))==0,
                         "DrvBitBlt: unused solid color bits not zero");
               
                pb.solidColor = pbo->iSolidColor;

                if ( rop4 != ROP4_PATCOPY )
                {
                    pb.pgfn = vSolidFillWithRop;
                }
                else
                {
                    pb.pgfn = pb.ppdev->pgfnSolidFill;
                }
            }        
        }// if ((((ucRop3 >> 4) ^ (ucRop3)) & 0xf) != 0)
        else
        {
            //
            // Turn some logicops into solid block fills. We get here
            // only for rops 00, 55, AA and FF.
            //
            if ( rop4 == ROP4_BLACKNESS )
            {
                pb.solidColor = 0;
                pb.ulRop4 = ROP4_PATCOPY;
            }
            else if( rop4 == ROP4_WHITENESS )
            {
                pb.solidColor = 0xffffff;
                pb.ulRop4 = ROP4_PATCOPY;
            }
            else if ( pb.ulRop4 == ROP4_NOP)
            {
                return TRUE;
            }
            else
            {
                pb.pgfn = vInvert;
                goto doIt;
            }

            pb.pgfn = pb.ppdev->pgfnSolidFill;

        }

        goto doIt;

    }// if ( psoSrc == NULL )

    //
    // We know we have a source
    //
    pb.psurfSrc = (Surf*)psoSrc->dhsurf;
    pb.pptlSrc = pptlSrc;

    if ( (pb.psurfDst == NULL) || (pb.psurfDst->flags & SF_SM) )
    {
        //
        // Destination is in system memory
        //

        if(pb.psurfSrc != NULL && pb.psurfSrc->flags & SF_VM)
        {
            pb.ppdev = pb.psurfSrc->ppdev;

            //
            // Source is in video memory
            //
            if(rop4 == ROP4_SRCCOPY)
            {
                if(pb.ppdev->iBitmapFormat != BMF_32BPP &&
                   (pxlo == NULL || pxlo->flXlate == XO_TRIVIAL) )
                {
                    pb.psoDst = psoDst;
                    pb.pgfn = vUploadNative;
        
                    goto doIt;
                }
            }
        }

        goto puntIt;

    }

    //
    // After this point we know that the destination is in video memory
    //

    pb.ppdev = pb.psurfDst->ppdev;

    if ( psoMsk != NULL )
    {
        goto puntIt;
    }

    //
    // After this point we know we do not have a mask
    //
      if( (rop4 == 0xb8b8 || rop4 == 0xe2e2)
        && (pbo->iSolidColor != (ULONG)-1)
        && (psoSrc->iBitmapFormat == BMF_1BPP)
        && (pxlo->pulXlate[0] == 0)
        && ((pxlo->pulXlate[1] & pb.ppdev->ulWhite) == pb.ppdev->ulWhite) )
    {
        //
        // When the background and foreground colors are black and
        // white, respectively, and the ROP is 0xb8 or 0xe2, and
        // the source bitmap is monochrome, the blt is simply a
        // color expanding monochrome blt.
        //
        //
        // Rather than add another parameter to 'pfnXfer', we simply
        // overload the 'pxlo' pointer.  Note that we still have to
        // special-case 0xb8 and 0xe2 in our 'pfnXfer1bpp' routine
        // to handle this convention:
        //
        xloTmp = *pxlo;
        xloTmp.pulXlate = aulTmp;
        aulTmp[0] = pbo->iSolidColor;
        aulTmp[1] = pbo->iSolidColor;
        
        pb.pxlo = &xloTmp;
        DBG_GDI((6, "Rop is 0x%x", pb.ulRop4));
        pb.pgfn = vMonoDownload;
        pb.psoSrc = psoSrc;

        goto doIt;

    }

    if ( pbo != NULL )
    {
        goto puntIt;
    }

    //
    // After this point we know we do not have a brush
    //


    //
    // We have a source to dest rop2 operation
    //

    if ( pb.psurfSrc == NULL )
    {
        pb.psoSrc = psoSrc;

        if(psoSrc->iBitmapFormat == BMF_1BPP)
        {
            pb.pxlo = pxlo;
            pb.pgfn = vMonoDownload;
                        
            goto doIt;

        }
        else if(psoSrc->iBitmapFormat == pb.ppdev->iBitmapFormat 
                 && (pxlo == NULL || pxlo->flXlate == XO_TRIVIAL) )
        {
//@@BEGIN_DDKSPLIT
            // TODO: find out if we need to check for pxlo == NULL
            // TODO: Handle 24 bpp download since it get called many times
            // during WinBench 99 tests
//@@END_DDKSPLIT

            pb.psoSrc = psoSrc;
            pb.pgfn = vDownloadNative;

            goto doIt;
        }    
        else
        {
            goto puntIt;
        }
    }

    if ( pb.psurfSrc->flags & SF_SM )
    {
        //
        // Source is in system memory
        //
        goto puntIt;
    }

    //
    // We now have both a source and a destination in video memory
    //

//@@BEGIN_DDKSPLIT
    // TODO: find if we will ever get a non-trivial translation when
    //       both source and dest are device managed.
//@@END_DDKSPLIT
    if( pxlo != NULL && !(pxlo->flXlate & XO_TRIVIAL))
    {
        goto puntIt;
    }

    if ( (rop4 == ROP4_SRCCOPY) || (psoSrc == psoDst) )
    {
        if ( pb.psurfSrc->ulPixDelta == pb.psurfDst->ulPixDelta )
        {
            pb.pgfn = vCopyBltNative;
        }
        else
        {
            pb.pgfn = vCopyBlt;
        }
    }
    else
    {
        pb.pgfn = vRop2Blt;
    }

doIt:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvBitBlt: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(pb.ppdev);
    
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        pb.pRects = pb.prclDst;
        pb.lNumRects = 1;
        pb.pgfn(&pb);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL   rcl;

        if (bIntersect(pb.prclDst, &pco->rclBounds, &rcl))
        {
            pb.pRects = &rcl;
            pb.lNumRects = 1;
            pb.pgfn(&pb);
        }
    }
    else
    {
        pb.pco = pco;
        vClipAndRender(&pb);
    }
    
    if( ((pb.pgfn == vCopyBlt) || (pb.pgfn == vCopyBltNative))
      &&(pb.ppdev->pdsurfScreen == pb.psurfSrc)
      &&(pb.psurfSrc == pb.psurfDst)
      &&(pb.ppdev->bNeedSync) )
    {
        pb.ppdev->bNeedSync = TRUE;
        InputBufferSwap(pb.ppdev);
    }
    else
    {
        InputBufferFlush(pb.ppdev);
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;

puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(psoSrc, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                        pptlMsk, pbo, pptlBrush, rop4);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, psoSrc, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT
    
    return bResult;
}// DrvBitBlt()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvCopyBits
//
// DrvCopyBits translates between device-managed raster surfaces and GDI
// standard-format bitmaps. 
//
// Parameters
//  psoDst------Points to the destination surface for the copy operation. 
//  psoSrc------Points to the source surface for the copy operation. 
//  pco---------Points to a CLIPOBJ structure that defines a clipping region on
//              the destination surface. 
//  pxlo--------Points to a XLATEOBJ structure that defines the translation of
//              color indices between the source and target surfaces. 
//  prclDst-----Points to a RECTL structure that defines the area to be
//              modified. This structure uses the coordinate system of the
//              destination surface. The lower and right edges of this
//              rectangle are not part of the bit-block transfer, meaning the
//              rectangle is lower right exclusive. 
//              DrvCopyBits is never called with an empty destination rectangle
//              The two points that define the rectangle are always
//              well-ordered. 
//
//  pptlSrc-----Points to a POINTL structure that defines the upper-left corner
//              of the source rectangle. 
//
// Return Value
//  The return value is TRUE if the source surface is successfully copied to
//  the destination surface.
//
// Comments
//  This function is required for a device driver that has device-managed
//  bitmaps or raster surfaces. The implementation in the driver must
//  translate driver surfaces to and from any standard-format bitmap.
//
//  Standard-format bitmaps are single-plane, packed-pixel format. Each scan
//  line is aligned on a 4-byte boundary. These bitmaps have 1, 4, 8, 16, 24,
//  32, or 64 bits per pixel.
//
//  This function should ideally be able to deal with RLE and device-dependent
//  bitmaps (see the Platform SDK). The device-dependent format is optional;
//  only a few specialized drivers need to support it. These bitmaps can be
//  sent to this function as a result of the following Win32 GDI functions:
//  SetDIBits, SetDIBitsToDevice, GetDIBits, SetBitmapBits, and GetBitmapBits.
//
//  Kernel-mode GDI calls this function from its simulations
//
//-----------------------------------------------------------------------------
BOOL
DrvCopyBits(SURFOBJ*  psoDst,
            SURFOBJ*  psoSrc,
            CLIPOBJ*  pco,
            XLATEOBJ* pxlo,
            RECTL*    prclDst,
            POINTL*   pptlSrc)
{
    return DrvBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, 
                        NULL, NULL, NULL, ROP4_SRCCOPY);
}// DrvCopyBits()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvTransparentBlt
//
//DrvTransparentBlt provides bit-block transfer capabilities with transparency.
//
// Parameters
//  psoDst------Points to the SURFOBJ that identifies the target surface on
//              which to draw. 
//  psoSrc------Points to the SURFOBJ that identifies the source surface of the
//              bit-block transfer. 
//  pco---------Points to a CLIPOBJ structure. The CLIPOBJ_Xxx service routines
//              are provided to enumerate the clip region as a set of
//              rectangles. This enumeration limits the area of the destination
//              that is modified. Whenever possible, GDI simplifies the
//              clipping involved. 
//  pxlo--------Points to a XLATEOBJ that tells how the source color indices
//              should be translated for writing to the target surface. 
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified. This rectangle is specified in the coordinate
//              system of the destination surface and is defined by two points:
//              upper left and lower right. The rectangle is lower-right
//              exclusive; that is, its lower and right edges are not a part of
//              the bit-block transfer. The two points that define the
//              rectangle are always well ordered. 
//              DrvTransparentBlt is never called with an empty destination
//              rectangle. 
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied. This rectangle is specified in the coordinate
//              system of the source surface and is defined by two points:
//              upper left and lower right. The two points that define the
//              rectangle are always well ordered. 
//              The source rectangle will never exceed the bounds of the source
//              surface, and so will never overhang the source surface. 
//
//              This rectangle is mapped to the destination rectangle defined
//              by prclDst. DrvTransparentBlt is never called with an empty
//              source rectangle. 
//  iTransColor-Specifies the transparent color in the source surface format.
//              It is a color index value that has been translated to the
//              source surface's palette. 
//  ulReserved--Reserved; this parameter must be set to zero. 
//
// Return Value
//  DrvTransparentBlt returns TRUE upon success. Otherwise, it returns FALSE.
//
// Comments
//  Bit-block transfer with transparency is supported between two
//  device-managed surfaces or between a device-managed surface and a
//  GDI-managed standard format bitmap. Driver writers are encouraged to
//  support the case of blting from off-screen device bitmaps in video memory
//  to other surfaces in video memory; all other cases can be punted to
//  EngTransparentBlt with little performance penalty.
//
//  The pixels on the source surface that match the transparent color specified
//  by iTransColor are not copied.
//
//  The driver will never be called with overlapping source and destination
//  rectangles on the same surface.
//
//  The driver should ignore any unused bits in the color key comparison, such
//  as for the most significant bit when the bitmap format is a 5-5-5 16bpp.
//
//  The driver hooks DrvTransparentBlt by setting the HOOK_TRANSPARENTBLT flag
//  when it calls EngAssociateSurface. If the driver has hooked
//  DrvTransparentBlt and is called to perform an operation that it does not
//  support, the driver should have GDI handle the operation by forwarding the
//  data in a call to EngTransparentBlt.
//
//-----------------------------------------------------------------------------
BOOL 
DrvTransparentBlt(SURFOBJ*    psoDst,
                  SURFOBJ*    psoSrc,
                  CLIPOBJ*    pco,
                  XLATEOBJ*   pxlo,
                  RECTL*      prclDst,
                  RECTL*      prclSrc,
                  ULONG       iTransColor,
                  ULONG       ulReserved)
{
    GFNPB       pb;
    BOOL        bResult;

    ASSERTDD(psoDst != NULL, "DrvTransparentBlt: psoDst is NULL");
    ASSERTDD(psoSrc != NULL, "DrvTransparentBlt: psoSrc is NULL");

    pb.psurfDst = (Surf *) psoDst->dhsurf;
    pb.psurfSrc = (Surf *) psoSrc->dhsurf;

    ASSERTDD(pb.psurfDst != NULL || pb.psurfSrc != NULL, 
             "DrvTransparentBlt: expected at least one device managed surface");

    // Only handle one-to-one blts
    if (prclDst->right - prclDst->left != prclSrc->right - prclSrc->left)
        goto puntIt;

    if (prclDst->bottom - prclDst->top != prclSrc->bottom - prclSrc->top)
        goto puntIt;
    
    // Only handle trivial color translation
    if ( pxlo != NULL && !(pxlo->flXlate & XO_TRIVIAL))
        goto puntIt;

    // for now, only handle video memory to video memory transparent blts
    if(pb.psurfDst == NULL || pb.psurfDst->flags & SF_SM)
        goto puntIt;

    if(pb.psurfSrc == NULL || pb.psurfSrc->flags & SF_SM)
        goto puntIt;
    
    pb.ppdev = (PPDev) psoDst->dhpdev;

    pb.prclDst = prclDst;
    pb.prclSrc = prclSrc;
    pb.pptlSrc = NULL;
    pb.colorKey = iTransColor;
    pb.pgfn = pb.ppdev->pgfnTransparentBlt;
    pb.pco = pco;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvTransparentBlt: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(pb.ppdev);
    vClipAndRender(&pb);
    InputBufferFlush(pb.ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;
    
puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(psoSrc, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngTransparentBlt(psoDst,
                             psoSrc,
                             pco,
                             pxlo,
                             prclDst,
                             prclSrc,
                             iTransColor,
                             ulReserved);
//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, psoSrc, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;
}// DrvTransparentBlt()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvAlphaBlend
//
// DrvAlphaBlend provides bit-block transfer capabilities with alpha blending.
//
// Parameters
//  psoDest-----Points to a SURFOBJ that identifies the surface on which to
//              draw. 
//  psoSrc------Points to a SURFOBJ that identifies the source surface. 
//  pco---------Points to a CLIPOBJ. The CLIPOBJ_Xxx service routines are
//              provided to enumerate the clip region as a set of rectangles.
//              This enumeration limits the area of the destination that is
//              modified. Whenever possible, GDI simplifies the clipping
//              involved. However, unlike DrvBitBlt, DrvAlphaBlend might be
//              called with a single rectangle in order to prevent round-off
//              errors in clipping the output. 
//  pxlo--------Points to a XLATEOBJ that specifies how color indices should be
//              translated between the source and destination surfaces. 
//              If the source surface is palette managed, its colors are
//              represented by indices into a lookup table of RGB color values.
//              In this case, the XLATEOBJ can be queried for a translate
//              vector that allows the device driver to quickly translate any
//              source index into a color index for the destination. 
//
//              The situation is more complicated when, for example, the source
//              is RGB but the destination is palette managed. In this case,
//              the closest match to each source RGB value must be found in the
//              destination palette. The driver can call the XLATEOBJ_iXlate
//              service routine to perform this matching operation. 
//  prclDest----Points to a RECTL structure that defines the rectangular area
//              to be modified. This rectangle is specified in the coordinate
//              system of the destination surface and is defined by two points:
//              upper left and lower right. The two points that define the
//              rectangle are always well ordered. The rectangle is lower-right
//              exclusive; that is, its lower and right edges are not a part of
//              the blend. 
//              The driver should be careful to do proper clipping when writing
//              the pixels because the specified rectangle might overhang the
//              destination surface. 
//
//              DrvAlphaBlend is never called with an empty destination
//              rectangle. 
//  prclSrc-----Points to a RECTL structure that defines the area to be copied.
//              This rectangle is specified in the coordinate system of the
//              source surface, and is defined by two points: upper left and
//              lower right. The two points that define the rectangle are
//              always well ordered. The rectangle is lower-right exclusive;
//              that is, its lower and right edges are not a part of the blend.
//              The source rectangle will never exceed the bounds of the source
//              surface, and so will never overhang the source surface. 
//
//              DrvAlphaBlend is never called with an empty source rectangle. 
//
//              The mapping is defined by prclSrc and prclDest. The points
//              specified in prclDest and prclSrc lie on integer coordinates,
//              which correspond to pixel centers. A rectangle defined by two
//              such points is considered to be a geometric rectangle with two
//              vertices whose coordinates are the given points, but with 0.5
//              subtracted from each coordinate. (POINTL structures are
//              shorthand notation for specifying these fractional coordinate
//              vertices.) 
//  pBlendObj---Points to a BLENDOBJ structure that describes the blending
//              operation to perform between the source and destination
//              surfaces. This structure is a wrapper for the BLENDFUNCTION
//              structure, which includes necessary source and destination
//              format information not available in the XLATEOBJ. BLENDFUNCTION
//              is declared in the Platform SDK. Its members are defined as
//              follows: 
//              BlendOp defines the blend operation to be performed. Currently
//              this value must be AC_SRC_OVER, which means that the source
//              bitmap is placed over the destination bitmap based on the alpha
//              values of the source pixels. There are three possible cases
//              that this blend operation should handle. These are described in
//              the Comments section of this reference page. 
//
//              BlendFlags is reserved and is currently set to zero. 
//
//              SourceConstantAlpha defines the constant blend factor to apply
//              to the entire source surface. This value is in the range of
//              [0,255], where 0 is completely transparent and 255 is
//              completely opaque. 
//
//              AlphaFormat defines whether the surface is assumed to have an
//              alpha channel. This member can optionally be set to the
//              following value: 
//
//              AC_SRC_ALPHA 
//                  The source surface can be assumed to be in a pre-multiplied
//                  alpha 32bpp "BGRA" format; that is, the surface type is
//                  BMF_32BPP and the palette type is BI_RGB. The alpha
//                  component is an integer in the range of [0,255], where 0 is
//                  completely transparent and 255 is completely opaque. 
// Return Value
//  DrvAlphaBlend returns TRUE upon success. Otherwise, it reports an error and
//  returns FALSE.
//
// Comments
//  A bit-block transfer with alpha blending is supported between the following
//  surfaces: 
//
//  From one driver-managed surface to another driver-managed surface. 
//  From one GDI-managed standard format bitmap to another GDI-managed standard
//  format bitmap. 
//  From one device-managed surface to a GDI-managed surface, and vice versa. 
//  The three possible cases for the AC_SRC_OVER blend function are: 
//
//  The source bitmap has no per pixel alpha (AC_SRC_ALPHA is not set), so the
//  blend is applied to the pixel's color channels based on the constant source
//  alpha value specified in SourceConstantAlpha as follows: 
//
//  Dst.Red = Round(((Src.Red * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Red)) / 255);
//  Dst.Green = Round(((Src.Green * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Green)) / 255);
//  Dst.Blue = Round(((Src.Blue * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Blue)) / 255);
//
//  Do the next computation only if the destination bitmap has an alpha channel
//  Dst.Alpha = Round(((Src.Alpha * SourceConstantAlpha) + 
//            ((255 ? SourceConstantAlpha) * Dst.Alpha)) / 255);
//
//  The source bitmap has per pixel alpha values (AC_SRC_ALPHA is set), and
//  SourceConstantAlpha is not used (it is set to 255). The blend is computed
//  as follows: 
//
//  Temp.Red = Src.Red + Round(((255 ? Src.Alpha) * Dst.Red) / 255);
//  Temp.Green = Src.Green + Round(((255 ? Src.Alpha) * Dst.Green) / 255);
//  Temp.Blue = Src.Blue + Round(((255 ? Src.Alpha) * Dst.Blue) / 255);
//
//  Do the next computation only if the destination bitmap has an alpha channel
//
//  Temp.Alpha = Src.Alpha + Round(((255 ? Src.Alpha) * Dst.Alpha) / 255);
//
//  The source bitmap has per pixel alpha values (AC_SRC_ALPHA is set), and
//  SourceConstantAlpha is used (it is not set to 255). The blend is computed
//  as follows: 
//
//  Temp.Red = Round((Src.Red * SourceConstantAlpha) / 255);
//  Temp.Green = Round((Src.Green * SourceConstantAlpha) / 255);
//  Temp.Blue = Round((Src.Blue * SourceConstantAlpha) / 255);
//
//  The next computation must be done even if the destination bitmap does not
//  have an alpha channel
//
//  Temp.Alpha = Round((Src.Alpha * SourceConstantAlpha) / 255);
//
//  Note that the following equations use the just-computed Temp.Alpha value:
//
//  Dst.Red = Temp.Red + Round(((255 ? Temp.Alpha) * Dst.Red) / 255);
//  Dst.Green = Temp.Green + Round(((255 ? Temp.Alpha) * Dst.Green) / 255);
//  Dst.Blue = Temp.Blue + Round(((255 ? Temp.Alpha) * Dst.Blue) / 255);
//
//  Do the next computation only if the destination bitmap has an alpha channel
//
//  Dst.Alpha = Temp.Alpha + Round(((255 ? Temp.Alpha) * Dst.Alpha) / 255);
//
//  DrvAlphaBlend can be optionally implemented in graphics drivers. It can be
//  provided to handle some kinds of alpha blends, such as blends where the
//  source and destination surfaces are the same format and do not contain an
//  alpha channel.
//
//  A hardware implementation can use floating point or fixed point in the
//  blend operation. Compatibility tests will account for a small epsilon in
//  the results. When using fixed point, an acceptable approximation to the
//  term x/255 is (x*257)/65536. Incorporating rounding, the term:
//
//  (255 - Src.Alpha) * Dst.Red) / 255
//
//  can then be approximated as:
//
//  temp = (255 - Src.Alpha) * Dst.Red) + 128;
//  result = (temp + (temp >> 8)) >> 8;
//
//  The Round(x) function rounds to the nearest integer, computed as:
//
//  Trunc(x + 0.5);
//
//  The driver hooks DrvAlphaBlend by setting the HOOK_ALPHABLEND flag when it
//  calls EngAssociateSurface. If the driver has hooked DrvAlphaBlend and is
//  called to perform an operation that it does not support, the driver should
//  have GDI handle the operation by forwarding the data in a call to
//  EngAlphaBlend.
//
//-----------------------------------------------------------------------------
BOOL
DrvAlphaBlend(SURFOBJ*  psoDst,
              SURFOBJ*  psoSrc,
              CLIPOBJ*  pco,
              XLATEOBJ* pxlo,
              RECTL*    prclDst,
              RECTL*    prclSrc,
              BLENDOBJ* pBlendObj)
{
    BOOL        bSourceInSM;
    BOOL        bResult;
    GFNPB       pb;
    
    ASSERTDD(psoDst != NULL, "DrvAlphaBlend: psoDst is NULL");
    ASSERTDD(psoSrc != NULL, "DrvAlphaBlend: psoSrc is NULL");

    DBG_GDI((7,"DrvAlphaBlend"));

    pb.psurfDst = (Surf *) psoDst->dhsurf;
    pb.psurfSrc = (Surf *) psoSrc->dhsurf;

    // Only handle one-to-one alpha blts
    if (prclDst->right - prclDst->left != prclSrc->right - prclSrc->left)
        goto puntIt;

    if (prclDst->bottom - prclDst->top != prclSrc->bottom - prclSrc->top)
        goto puntIt;
    
    if(pb.psurfDst == NULL || pb.psurfDst->flags & SF_SM)
        goto puntIt;

    pb.ppdev = (PPDev) psoDst->dhpdev;

    // We can't handle blending in 8bpp

//@@BEGIN_DDKSPLIT
    // TODO: Investigate doing blending in 8bpp
//@@END_DDKSPLIT
    if (pb.ppdev->cPelSize == 0)
        goto puntIt;

    pb.ucAlpha = pBlendObj->BlendFunction.SourceConstantAlpha;
    
    if(pb.psurfSrc == NULL || pb.psurfSrc->flags & SF_SM)
    {

        pb.psoSrc = psoSrc;

//@@BEGIN_DDKSPLIT
        // TODO: find out how we should verify that the XLATEOBJ is reasonable
//@@END_DDKSPLIT

        if(pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
        {
            ASSERTDD(psoSrc->iBitmapFormat == BMF_32BPP,
                "DrvAlphaBlend: source alpha specified with non 32bpp source");
        
            pb.pgfn = vAlphaBlendDownload;

            // This could be a cursor that is drawing... force a swap
            // buffer at the next synchronization event.

            pb.ppdev->bForceSwap = TRUE;

//@@BEGIN_DDKSPLIT
            // TODO: improve our alpha blend download acceleration code
            //       it's currently slower then punting
//@@END_DDKSPLIT
        }
        else
        {
            goto puntIt;
        }
    }
    else
    {
        // Only handle trivial color translation
        if (pxlo != NULL && !(pxlo->flXlate & XO_TRIVIAL))
            goto puntIt;

        if(pBlendObj->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
        {
            ASSERTDD(psoSrc->iBitmapFormat == BMF_32BPP,
                "DrvAlphaBlend: source alpha specified with non 32bpp source");
        
            pb.pgfn = vAlphaBlend;
        }
        else
        {
            pb.pgfn = vConstantAlphaBlend;
        }
    }

    pb.prclDst = prclDst;
    pb.prclSrc = prclSrc;
    pb.pptlSrc = NULL;
    pb.pco = pco;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvAlphaBlend: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    vCheckGdiContext(pb.ppdev);
    vClipAndRender(&pb);
    InputBufferFlush(pb.ppdev);
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;
    
puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(psoSrc, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngAlphaBlend(
        psoDst, psoSrc, pco, pxlo, prclDst, prclSrc, pBlendObj);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, psoSrc, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;

}// DrvAlphaBlend()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvGradientFill
//
// DrvGradientFill shades the specified primitives.
//
// Parameters
//  psoDest-----Points to the SURFOBJ that identifies the surface on which to
//              draw. 
//  pco---------Points to a CLIPOBJ. The CLIPOBJ_Xxx service routines are
//              provided to enumerate the clip region as a set of rectangles.
//              This enumeration limits the area of the destination that is
//              modified. Whenever possible, GDI simplifies the clipping
//              involved. 
//  pxlo--------Should be ignored by the driver. 
//  pVertex-----Points to an array of TRIVERTEX structures, with each entry
//              containing position and color information. TRIVERTEX is defined
//              in the Platform SDK. 
//  nVertex-----Specifies the number of TRIVERTEX structures in the array to
//              which pVertex points. 
//  pMesh-------Points to an array of structures that define the connectivity
//              of the TRIVERTEX elements to which pVertex points. 
//              When rectangles are being drawn, pMesh points to an array of
//              GRADIENT_RECT structures that specify the upper left and lower
//              right TRIVERTEX elements that define a rectangle. Rectangle
//              drawing is lower-right exclusive. GRADIENT_RECT is defined in
//              the Platform SDK. 
//
//              When triangles are being drawn, pMesh points to an array of
//              GRADIENT_TRIANGLE structures that specify the three TRIVERTEX
//              elements that define a triangle. Triangle drawing is
//              lower-right exclusive. GRADIENT_TRIANGLE is defined in the
//              Platform SDK. 
//  nMesh-------Specifies the number of elements in the array to which pMesh
//              points. 
//  prclExtents-Points to a RECTL structure that defines the area in which the
//              gradient drawing is to occur. The points are specified in the
//              coordinate system of the destination surface. This parameter is
//              useful in estimating the size of the drawing operations. 
//  pptlDitherOrg-Points to a POINTL structure that defines the origin on the
//              surface for dithering. The upper left pixel of the dither
//              pattern is aligned with this point. 
//  ulMode------Specifies the current drawing mode and how to interpret the
//              array to which pMesh points. This parameter can be one of the
//              following values:
//              Value                   Meaning 
//              GRADIENT_FILL_RECT_H    pMesh points to an array of
//                                      GRADIENT_RECT structures. Each
//                                      rectangle is to be shaded from left to
//                                      right. Specifically, the upper-left and
//                                      lower-left pixels are the same color,
//                                      as are the upper-right and lower-right
//                                      pixels. 
//              GRADIENT_FILL_RECT_V    pMesh points to an array of
//                                      GRADIENT_RECT structures. Each
//                                      rectangle is to be shaded from top to
//                                      bottom. Specifically, the upper-left
//                                      and upper-right pixels are the same
//                                      color, as are the lower-left and
//                                      lower-right pixels. 
//              GRADIENT_FILL_TRIANGLE  pMesh points to an array of
//                                      GRADIENT_TRIANGLE structures. 
//
//              The gradient fill calculations for each mode are documented in
//              the Comments section. 
//
// Return Value
//  DrvGradientFill returns TRUE upon success. Otherwise, it returns FALSE. and
//  reports an error by calling EngSetLastError.
//
// Comments
//  DrvGradientFill can be optionally implemented in graphics drivers.
//
//  The driver hooks DrvGradientFill by setting the HOOK_GRADIENTFILL flag when
//  it calls EngAssociateSurface. If the driver has hooked DrvGradientFill and
//  is called to perform an operation that it does not support, the driver
//  should have GDI handle the operation by forwarding the data in a call to
//  EngGradientFill.
//
//  The formulas for computing the color value at each pixel of the primitive
//  depend on ulMode as follows: 
//
//  GRADIENT_FILL_TRIANGLE 
//      The triangle's vertices are defined as V1, V2, and V3. Point P is
//      inside the triangle. Draw lines from P to V1, V2, and V3 to form three
//      sub-triangles. Let ai denote the area of the triangle opposite Vi for
//      i=1,2,3. The color at point P is computed as: 
//
//      RedP   = (RedV1 * a1 + RedV2 * a2 + RedV3 * a3) / (a1+a2+a3 ()) 
//      GreenP = (GreenV1 * a1 + GreenV2 * a2 + GreenV3 * a3) / (a1+a2+a3 ()) 
//      BlueP ( )  = (BlueV1 * a1 + BlueV2 * a2 + BlueV3 * a3) / (a1+a2+a3)
//
//  GRADIENT_FILL_RECT_H 
//      The rectangle's top-left point is V1 and the bottom-right point is V2.
//      Point P is inside the rectangle. The color at point P is given by: 
//
//      RedP =   (RedV2 * (Px - V1x) + RedV1 * (V2x - Px)) / (V2x-V1x)
//      GreenP = (GreenV2 * (Px - V1x) + GreenV1 * (V2x - Px)) / (V2x-V1x)
//      BlueP =  (BlueV2 * (Px - V1x) + BlueV1 * (V2x - Px)) / (V2x-V1x)
//
//  GRADIENT_FILL_RECT_V 
//      The rectangle's top-left point is V1 and the bottom-right point is V2.
//      Point P is inside the rectangle. The color at point P is given by: 
//
//      RedP   = (RedV2 * (Py-V1y) + RedV1 * (V2y - Py)) / (V2y-V1y)
//      GreenP = (GreenV2 * (Py-V1y) + GreenV1 * (V2y - Py)) / (V2y-V1y)
//      BlueP  = (BlueV2 * (Py-V1y) + BlueV1 * (V2y - Py)) / (V2y-V1y)
//
//-----------------------------------------------------------------------------
BOOL
DrvGradientFill(SURFOBJ*    psoDst,
                CLIPOBJ*    pco,
                XLATEOBJ*   pxlo,
                TRIVERTEX*  pVertex,
                ULONG       nVertex,
                PVOID       pMesh,
                ULONG       nMesh,
                RECTL*      prclExtents,
                POINTL*     pptlDitherOrg,
                ULONG       ulMode)
{
    GFNPB       pb;
    BOOL        bResult;
    
    ASSERTDD(psoDst != NULL, "DrvGradientFill: psoDst is NULL");

    pb.psurfDst = (Surf *) psoDst->dhsurf;
    pb.psurfSrc = NULL;

    // for now, only handle video memory gradient fills
    if(pb.psurfDst == NULL || pb.psurfDst->flags & SF_SM)
        goto puntIt;

    pb.ppdev = (PPDev) psoDst->dhpdev;
    
    pb.ulMode = ulMode;

    // setup default dest
    
    if(pb.ulMode == GRADIENT_FILL_TRIANGLE)
    {
//@@BEGIN_DDKSPLIT
        // TODO: add support for triangle gradient fill ... our hardware
        //       can easily support this acceleration.
//@@END_DDKSPLIT
        goto puntIt;
    }
    else
    {
        GRADIENT_RECT   *pgr = (GRADIENT_RECT *) pMesh;

#ifdef DBG
        for(ULONG i = 0; i < nMesh; i++)
        {
            ULONG   ulLr = pgr[i].LowerRight;

            ASSERTDD( ulLr < nVertex, "DrvGradientFill: bad vertex index");
        }
#endif

        pb.pgfn = pb.ppdev->pgfnGradientFillRect;
    }

    pb.pco = pco;

    pb.ptvrt = pVertex;
    pb.ulNumTvrt = nVertex;
    pb.pvMesh = pMesh;
    pb.ulNumMesh = nMesh;
    pb.prclDst = prclExtents;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(pb.ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvGradientFill: re-entered! %d", pb.ppdev->ulLockCount));
    }
    EngAcquireSemaphore(pb.ppdev->hsemLock);
    pb.ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(pb.ppdev);
    vClipAndRender(&pb);
    InputBufferFlush(pb.ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    pb.ppdev->ulLockCount--;
    EngReleaseSemaphore(pb.ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return TRUE;
    
puntIt:

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    ULONG flags = vPuntBefore(NULL, psoDst);
#endif
//@@END_DDKSPLIT

    bResult = EngGradientFill(
            psoDst, pco, pxlo, pVertex, nVertex, 
            pMesh, nMesh, prclExtents, pptlDitherOrg, ulMode);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, NULL, psoDst);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    return bResult;

}// DrvGradientFill()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\brush.c ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: brush.c
*
* Content:   Handles all brush/pattern initialization and realization. 
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#include "precomp.h"
#include "heap.h"

//-----------------------------------------------------------------------------
//
// VOID vRealizeDitherPattern
//
// Generates an 8x8 dither pattern, in our internal realization format, for
// the colour ulRGBToDither.
//
//-----------------------------------------------------------------------------
VOID
vRealizeDitherPattern(HDEV      hdev,
                      RBrush*   prb,
                      ULONG     ulRGBToDither)
{
    //
    // Do the actual dithering
    // Note: This function is NT5 only. If you want to write a NT4 driver,
    // you have to implement dither function in the driver
    //
    EngDitherColor(hdev, DM_DEFAULT, ulRGBToDither, &prb->aulPattern[0]);

    //
    // Initialize the fields we need
    //
    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;
    prb->pbe           = NULL;
}// vRealizeDitherPattern()

//---------------------------Public*Routine------------------------------------
//
// BOOL DrvRealizeBrush
//
// This function allows us to convert GDI brushes into an internal form
// we can use.  It is called by GDI when we've called BRUSHOBJ_pvGetRbrush
// in some other function like DrvBitBlt, and GDI doesn't happen have a cached
// realization lying around.
//
// Parameters:
// pbo----------Points to the BRUSHOBJ that is to be realized. All other
//              parameters, except for psoTarget, can be queried from this
//              object. Parameter specifications are provided as an
//              optimization. This parameter is best used only as a parameter
//              for BRUSHOBJ_pvAllocRBrush, which allocates the memory for the
//              realized brush. 
// psoTarget----Points to the surface for which the brush is to be realized.
//              This surface can be the physical surface for the device, a
//              device format bitmap, or a standard format bitmap. 
// psoPattern---Points to the surface that describes the pattern for the brush.
//              For a raster device, this is a bitmap. For a vector device,
//              this is one of the pattern surfaces provided by DrvEnablePDEV. 
// psoMask------Points to a transparency mask for the brush. This is a 1 bit
//              per pixel bitmap that has the same extent as the pattern. A
//              mask of zero means the pixel is considered a background pixel
//              for the brush. (In transparent background mode, the background
//              pixels are unaffected in a fill.) Plotters can ignore this
//              parameter because they never draw background information.
// pxlo---------Points to a XLATEOBJ that defines the interpretration of colors
//              in the pattern. A XLATEOBJXxx service routine can be called to
//              translate the colors to device color indices. Vector devices
//              should translate color zero through the XLATEOBJ to get the
//              foreground color for the brush. 
// ulHatch------Specifies whether psoPattern is one of the hatch brushes
//              returned by DrvEnablePDEV. This is true if the value of this
//              parameter is less than HS_API_MAX. 
//
// Return Value
//  The return value is TRUE if the brush was successfully realized. Otherwise,
//  it is FALSE, and an error code is logged.
//
// Comments
//  To realize a brush, the driver converts a GDI brush into a form that can be
//  used internally. A realized brush contains information and accelerators the
//  driver needs to fill an area with a pattern; information that is defined by
//  the driver and used only by the driver.
//
//  The driver's realization of a brush is written into the buffer allocated by
//  a call to BRUSHOBJ_pvAllocRbrush.
//
//  DrvRealizeBrush is required for a driver that does any drawing to any
//  surface.
//
//  ppdev->bRealizeTransparent -- Hint for whether or not the brush should be
//                              realized for transparency.  If this hint is
//                              wrong, there will be no error, but the brush
//                              will have to be unnecessarily re-realized.
//
// Note: You should always set 'ppdev->bRealizeTransparent' before calling
//       BRUSHOBJ_pvGetRbrush!
//
//-----------------------------------------------------------------------------
BOOL
DrvRealizeBrush(BRUSHOBJ*   pbo,
                SURFOBJ*    psoDst,
                SURFOBJ*    psoPattern,
                SURFOBJ*    psoMask,
                XLATEOBJ*   pxlo,
                ULONG       ulHatch)
{
    PDev*       ppdev = (PDev*)psoDst->dhpdev;
    
    BYTE*       pbDst;
    BYTE*       pbSrc;
    LONG        i;
    LONG        j;
    LONG        lNumPixelToBeCopied;
    LONG        lSrcDelta;
    RBrush*     prb;    
    ULONG*      pulXlate;
    ULONG       ulPatternFormat;

    PERMEDIA_DECL;

    DBG_GDI((6, "DrvRealizeBrush called for pbo 0x%x", pbo));

    //
    // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE:
    //
    if ( ulHatch & RB_DITHERCOLOR )
    {
        //
        // Move this test in here since we always support monochrome brushes
        // as they live in the on-chip area stipple. These dithered brushes
        // will always be colored requiring available off-screen memory.
        //
        if ( !(ppdev->flStatus & STAT_BRUSH_CACHE) )
        {
            //
            // We only handle brushes if we have an off-screen brush cache
            // available.  If there isn't one, we can simply fail the
            // realization, and eventually GDI will do the drawing for us
            // (although a lot slower than we could have done it)
            //
            DBG_GDI((6, "brush cache not enabled"));
            goto ReturnFalse;
        }

        DBG_GDI((7, "DITHERONREALIZE"));

        //
        // We have a fast path for dithers when we set GCAPS_DITHERONREALIZE
        // First, we need to allocate memory for the realization of a brush
        // Note: actually we ask for allocation of a RBRUSH + the brush
        // stamp size
        //
        prb = (RBrush*)BRUSHOBJ_pvAllocRbrush(pbo,
                       sizeof(RBrush) + (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
        if ( prb == NULL )
        {
            DBG_GDI((1, "BRUSHOBJ_pvAllocRbrush() in dither return NULL\n"));
            goto ReturnFalse;
        }

        //
        // Dither and realize the brsuh pattern
        //
        vRealizeDitherPattern(psoDst->hdev, prb, ulHatch);

        goto ReturnTrue;
    }// if ( ulHatch & RB_DITHERCOLOR )

    //
    // We only handle brushes if we have an off-screen brush cache available
    // If there isn't one, we can simply fail the realization, and eventually
    // GDI will do the drawing for us (although a lot slower than we could have
    // done it). We always succeed for 1bpp patterns since we use the area
    // stipple unit to do these rather than off-screen memory.
    //
    ulPatternFormat = psoPattern->iBitmapFormat;

    if ( !(ppdev->flStatus & STAT_BRUSH_CACHE)
        &&(ulPatternFormat != BMF_1BPP) )
    {
        DBG_GDI((1, "brush cache not enabled, or Bitmap is not 1 BPP"));
        goto ReturnFalse;
    }

    //
    // We only accelerate 8x8 patterns since most of the video card can only
    // accelerate 8x8 brush
    //
    if ( (psoPattern->sizlBitmap.cx != 8)
       ||(psoPattern->sizlBitmap.cy != 8) )
    {
        DBG_GDI((1, "Brush Bitmap size is not 8x8"));
        goto ReturnFalse;
    }

    //    
    // We need to allocate memory for the realization of a brush
    // Note: actually we ask for allocation of a RBRUSH + the brush stamp size
    //
    prb = (RBrush*)BRUSHOBJ_pvAllocRbrush(pbo,
                   sizeof(RBrush) + (TOTAL_BRUSH_SIZE << ppdev->cPelSize));
    if ( prb == NULL )
    {
        DBG_GDI((0, "BRUSHOBJ_pvAllocRbrush() failed"));
        goto ReturnFalse;
    }

    //
    // Initialize the fields we need
    //
    prb->ptlBrushOrg.x = LONG_MIN;
    prb->fl            = 0;

    prb->pbe = NULL;

    lSrcDelta = psoPattern->lDelta;
    pbSrc     = (BYTE*)psoPattern->pvScan0;
    pbDst     = (BYTE*)&prb->aulPattern[0];

    //
    // At 8bpp, we handle patterns at 1bpp, 4bpp and 8bpp with/without an xlate
    // At 16bpp, we handle patterns at 16 bpp without an xlate.
    // At 32bpp, we handle patterns at 32bpp without an xlate.
    // We handle all the patterns at 1 bpp with/without an Xlate
    //
    // Check if the brush pattern has the same color depth as our current
    // display color depth
    //
    if ( ulPatternFormat == BMF_1BPP )
    {
        DWORD   Data;

        DBG_GDI((7, "Realizing 1bpp brush"));

        //
        // We dword align the monochrome bitmap so that every row starts
        // on a new long (so that we can do long writes later to transfer
        // the bitmap to the area stipple unit).
        //
        for ( i = 8; i != 0; i-- )
        {
            //
            // Replicate the brush to 32 bits wide, as the TX cannot
            // span fill 8 bit wide brushes
            //
            Data = (*pbSrc) & 0xff;
            Data |= Data << 8;
            Data |= Data << 16;
            *(DWORD*)pbDst = Data;

            //
            // Area stipple is loaded with DWORDS
            //
            pbDst += sizeof(DWORD);
            pbSrc += lSrcDelta;
        }

        pulXlate         = pxlo->pulXlate;
        prb->fl         |= RBRUSH_2COLOR;
        prb->ulForeColor = pulXlate[1];
        prb->ulBackColor = pulXlate[0];
    }// Pattern at 1 BPP
    else if ( (ulPatternFormat == BMF_4BPP)&&(ppdev->iBitmapFormat == BMF_8BPP))
    {
        DBG_GDI((7, "Realizing 4bpp brush"));

        //
        // The screen is 8bpp and the pattern is 4bpp:
        //            
        pulXlate = pxlo->pulXlate;

        for ( i = 8; i != 0; i-- )
        {
            //
            // Inner loop is repeated only 4 times because each loop
            // handles 2 pixels:
            //
            for ( j = 4; j != 0; j-- )
            {
                *pbDst++ = (BYTE)pulXlate[*pbSrc >> 4];
                *pbDst++ = (BYTE)pulXlate[*pbSrc & 15];
                pbSrc++;
            }

            pbSrc += lSrcDelta - 4;
        }
    }// Pattern 4BPP and Screen 8 BPP
    else if ( ( ppdev->iBitmapFormat == ulPatternFormat )
            &&( (pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL) ) )
    {
        DBG_GDI((7, "Realizing un-translated brush"));

        //
        // The pattern is the same colour depth as the screen, and
        // there's no translation to be done.
        // Here we first need to calculate how many pixel need to be
        // copied
        //
        lNumPixelToBeCopied = (8 << ppdev->cPelSize);

        for ( i = 8; i != 0; i-- )
        {
            RtlCopyMemory(pbDst, pbSrc, lNumPixelToBeCopied);

            pbSrc += lSrcDelta;
            pbDst += lNumPixelToBeCopied;
        }
    }// Pattern and Screen has same color depth, No Xlate
    else if ( (ppdev->iBitmapFormat == BMF_8BPP)
            &&(ulPatternFormat == BMF_8BPP) )
    {
        DBG_GDI((7, "Realizing 8bpp translated brush"));

        //
        // The screen is 8bpp, and there's translation to be done
        // So we have to do copy + Xlate one by one
        //
        pulXlate = pxlo->pulXlate;

        for ( i = 8; i != 0; i-- )
        {
            for ( j = 8; j != 0; j-- )
            {
                *pbDst++ = (BYTE)pulXlate[*pbSrc++];
            }

            pbSrc += lSrcDelta - 8;
        }
    }// Screen mode and pattern mode all at 8 BPP
    else
    {
        //
        // We've got a brush whose format we haven't special cased.
        //
        goto ReturnFalse;
    }

ReturnTrue:
    DBG_GDI((6, "DrvRealizeBrush returning true"));
    
    return(TRUE);

ReturnFalse:

    if ( psoPattern != NULL )
    {
        DBG_GDI((1, "Failed realization -- Type: %li Format: %li cx: %li cy: %li",
                 psoPattern->iType, psoPattern->iBitmapFormat,
                 psoPattern->sizlBitmap.cx, psoPattern->sizlBitmap.cy));
    }
    DBG_GDI((6, "DrvRealizeBrush returning false"));

    return(FALSE);
}// DrvRealizeBrush()

//-----------------------------------------------------------------------------
//
// BOOL bEnableBrushCache
//
// Allocates off-screen memory for storing the brush cache.
//
//-----------------------------------------------------------------------------
BOOL
bEnableBrushCache(PDev* ppdev)
{
    BrushEntry* pbe;            // Pointer to the brush-cache entry
    LONG        i;
    LONG        lDelta;
    ULONG       ulPixOffset;

    DBG_GDI((6, "bEnableBrushCache"));

    ASSERTDD(!(ppdev->flStatus & STAT_BRUSH_CACHE),
                "bEnableBrushCache: unexpected already enabled brush cache");
    
    //
    // ENABLE_BRUSH_CACHE by default is on. It would be turned off in
    // bInitializeHw() if 3D buffers runs out of memory
    //
    if ( !(ppdev->flStatus & ENABLE_BRUSH_CACHE) )
    {
        DBG_GDI((1, "Brush cache not valid for creation"));
        goto ReturnTrue;
    }

    ppdev->ulBrushVidMem = ulVidMemAllocate(ppdev,
                                            CACHED_BRUSH_WIDTH,
                                            CACHED_BRUSH_HEIGHT
                                             *NUM_CACHED_BRUSHES,
                                             ppdev->cPelSize,
                                            &lDelta,
                                            &ppdev->pvmBrushHeap,
                                            &ppdev->ulBrushPackedPP,
                                            FALSE);

    if (ppdev->ulBrushVidMem == 0 )
    {
        DBG_GDI((0, "bEnableBrushCache: failed to allocate video memory"));
        goto ReturnTrue;    // See note about why we can return TRUE...
    }

    ASSERTDD(lDelta == (CACHED_BRUSH_WIDTH << ppdev->cPelSize),
             "bEnableBrushCache: unexpected stride does not match width");

    ppdev->cBrushCache = NUM_CACHED_BRUSHES;

    ulPixOffset = (ULONG) ppdev->ulBrushVidMem >> ppdev->cPelSize;
    pbe = &ppdev->abe[0];
    
    for (i = 0; i < NUM_CACHED_BRUSHES; i++, pbe++)
    {
        pbe->prbVerify = NULL;
        pbe->ulPixelOffset = ulPixOffset;
        ulPixOffset += CACHED_BRUSH_SIZE;

        memset((pbe->ulPixelOffset << ppdev->cPelSize) + ppdev->pjScreen, 
                    0x0, (CACHED_BRUSH_SIZE << ppdev->cPelSize)); 
    }
    
    //
    // We successfully allocated the brush cache, so let's turn
    // on the switch showing that we can use it:
    //
    DBG_GDI((6, "bEnableBrushCache: successfully allocated brush cache"));
    ppdev->flStatus |= STAT_BRUSH_CACHE;

ReturnTrue:
    //
    // If we couldn't allocate a brush cache, it's not a catastrophic
    // failure; patterns will still work, although they'll be a bit
    // slower since they'll go through GDI.  As a result we don't
    // actually have to fail this call:
    //
    DBG_GDI((6, "Passed bEnableBrushCache"));

    return(TRUE);
}// bEnableBrushCache()

//-----------------------------------------------------------------------------
//
// VOID vDisableBrushCache
//
// Cleans up anything done in bEnableBrushCache.
//
//-----------------------------------------------------------------------------
VOID
vDisableBrushCache(PDev* ppdev)
{
    DBG_GDI((6,"vDisableBrushCache"));
    if(ppdev->flStatus & STAT_BRUSH_CACHE)
    {
        DBG_GDI((6,"vDisableBrushCache: freeing brush cache"));
        VidMemFree(ppdev->pvmBrushHeap->lpHeap,
                   (FLATPTR)(ppdev->ulBrushVidMem));
        ppdev->cBrushCache = 0;

        ppdev->flStatus &= ~STAT_BRUSH_CACHE;
        DBG_GDI((6,"vDisableBrushCache: freeing brush cache done"));
    }

}// vDisableBrushCache()

//-----------------------------------------------------------------------------
//
// VOID vAssertModeBrushCache
//
// Resets the brush cache when we exit out of full-screen.
//
//-----------------------------------------------------------------------------
VOID
vAssertModeBrushCache(PDev*   ppdev,
                      BOOL    bEnable)
{
    if ( bEnable )
    {
        bEnableBrushCache(ppdev);
    }
    else
    {
        vDisableBrushCache(ppdev);
    }
}// vAssertModeBrushCache()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\clip.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: clip.c
 *
 * Clipping code.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *****************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "clip.h"

//----------------------------*Public*Routine-------------------------------
// BOOL bIntersect
//
// Function:
//      Check the integration of two input rectangles (RECTL* pRcl1,
//      RECTL* pRcl2) and set the intersection result in (RECTL* pRclResult)
//
// Return:
//      TRUE---If 'prcl1' and 'prcl2' intersect. The intersection will be in
//            'prclResult'
//      FALSE--If they don't intersect. 'prclResult' is undefined.
//
//---------------------------------------------------------------------------
BOOL
bIntersect(RECTL*  pRcl1,
           RECTL*  pRcl2,
           RECTL*  pRclResult)
{
    DBG_GDI((7, "bIntersect called--pRcl1=0x%x, pRcl2=0x%x, pRclResult=0x%x",
            pRcl1, pRcl2, pRclResult));
    
    pRclResult->left  = max(pRcl1->left,  pRcl2->left);
    pRclResult->right = min(pRcl1->right, pRcl2->right);

    //
    // Check if there an intersection horizontally
    //
    if ( pRclResult->left < pRclResult->right )
    {
        pRclResult->top    = max(pRcl1->top,    pRcl2->top);
        pRclResult->bottom = min(pRcl1->bottom, pRcl2->bottom);

        if (pRclResult->top < pRclResult->bottom)
        {
            //
            // Check if there an intersection vertically
            //
            return(TRUE);
        }
    }

    DBG_GDI((7, "bIntersect returned FALSE"));

    //
    // Return FALSE if there is no intersection
    //
    return(FALSE);
}// bIntersect()

//-----------------------------Public Routine-------------------------------
// LONG cIntersect
//
// This routine takes a list of rectangles from 'pRclIn' and clips them
// in-place to the rectangle 'pRclClip'.  The input rectangles don't
// have to intersect 'prclClip'; the return value will reflect the
// number of input rectangles that did intersect, and the intersecting
// rectangles will be densely packed.
//
//--------------------------------------------------------------------------
LONG
cIntersect(RECTL*  pRclClip,
           RECTL*  pRclIn,
           LONG    lNumOfRecs)
{
    LONG    cIntersections;
    RECTL*  pRclOut;

    DBG_GDI((7, "cIntersect called--pRclClip=0x%x, pRclIn=0x%x,lNumOfRecs=%ld",
             pRclClip, pRclIn, lNumOfRecs));

    cIntersections = 0;
    pRclOut        = pRclIn;        // Put the result in place as the input

    //
    // Validate input parameter
    //
    ASSERTDD( ((pRclIn != NULL ) && (pRclClip != NULL) && ( lNumOfRecs >= 0 )),
              "Wrong input to cIntersect" );    

    for (; lNumOfRecs != 0; pRclIn++, lNumOfRecs--)
    {
        pRclOut->left  = max(pRclIn->left,  pRclClip->left);
        pRclOut->right = min(pRclIn->right, pRclClip->right);

        if ( pRclOut->left < pRclOut->right )
        {
            //
            // Find intersection, horizontally, between current rectangle and
            // the clipping rectangle.
            //
            pRclOut->top    = max(pRclIn->top,    pRclClip->top);
            pRclOut->bottom = min(pRclIn->bottom, pRclClip->bottom);

            if ( pRclOut->top < pRclOut->bottom )
            {
                //
                // Find intersection, vertically, between current rectangle and
                // the clipping rectangle. Put this rectangle in the result
                // list and increment the counter. Ready for next input
                //
                pRclOut++;
                cIntersections++;
            }
        }
    }// loop through all the input rectangles

    DBG_GDI((7, "cIntersect found %d intersections", cIntersections));
    return(cIntersections);
}// cIntersect()

//-----------------------------Public Routine-------------------------------
// VOID vClipAndRender
//
// Clips the destination rectangle calling pfgn (the render function) as
// appropriate.
//
// Argumentes needed from function block (GFNPB)
// 
// pco------pointer to clip object
// prclDst--pointer to destination rectangle
// psurfDst-pointer to destination Surf
// psurfSrc-pointer to destination Surf (NULL if no source)
// pptlSrc--pointer to source point
// prclSrc--pointer to source rectangle (used if pptlSrc == NULL)
// pgfn-----pointer to render function
//
// NOTES:
//
// pptlSrc and prclSrc are only used if psurfSrc == psurfDst.  If there is
// no source psurfSrc must be set to NULL.  If prclSrc is specified, pptlSrc
// is not used.
//
//--------------------------------------------------------------------------

VOID vClipAndRender(GFNPB * ppb)
{
    CLIPOBJ * pco = ppb->pco;
    
    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
    {
        ppb->pRects = ppb->prclDst;
        ppb->lNumRects = 1;
        ppb->pgfn(ppb);
    }
    else if (pco->iDComplexity == DC_RECT)
    {
        RECTL   rcl;

        if (bIntersect(ppb->prclDst, &pco->rclBounds, &rcl))
        {
            ppb->pRects = &rcl;
            ppb->lNumRects = 1;
            ppb->pgfn(ppb);
        }
    }
    else
    {
        ClipEnum    ce;
        LONG        c;
        BOOL        bMore;
        ULONG       ulDir = CD_ANY;

        // determine direction if operation on same surface
        if(ppb->psurfDst == ppb->psurfSrc)
        {
            LONG   lXSrc, lYSrc, offset;

            if(ppb->pptlSrc != NULL)
            {
                lXSrc = ppb->pptlSrc->x;
                lYSrc = ppb->pptlSrc->y;
            }
            else
            {
                lXSrc = ppb->prclSrc->left;
                lYSrc = ppb->prclSrc->top;
            }

            // NOTE: we can safely shift by 16 because the surface
            //       stride will never be greater the 2--16
            offset = (ppb->prclDst->top - lYSrc) << 16;
            offset += (ppb->prclDst->left - lXSrc);
            if(offset > 0)
                ulDir = CD_LEFTUP;
            else
                ulDir = CD_RIGHTDOWN;
        }


        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, ulDir, 0);

        do
        {
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

            c = cIntersect(ppb->prclDst, ce.arcl, ce.c);

            if (c != 0)
            {
                ppb->pRects = ce.arcl;
                ppb->lNumRects = c;
                ppb->pgfn(ppb);
            }

        } while (bMore);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\clip.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: clip.h
*
* External interface for clip.h
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#ifndef __CLIP__
#define __CLIP__

VOID
vClipAndRender(
    GFNPB * ppb);

BOOL
bIntersect(
    RECTL*  pRcl1,
    RECTL*  pRcl2,
    RECTL*  pRclResult);

LONG
cIntersect(
    RECTL*  pRclClip,
    RECTL*  pRclIn,
    LONG    lNumOfRecs);

#endif // __CLIP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3ddelta.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddelta.h
*
*  Content: 3DLabs Delta unit related defines. Used only by D3D.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifdef __D3DDELTA
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __D3DDELTA

//-----------------------------------------------------------------------------
//   Conversion macros from ARGB values into Delta Gambit registers format
//-----------------------------------------------------------------------------
#define RGB_GET_GAMBIT_ALPHA(ci)  (((ci) & 0xff000000) >> 2)
#define RGB_GET_GAMBIT_RED(ci)	  (((ci) & 0xff0000) << 6)
#define RGB_GET_GAMBIT_GREEN(ci)  (((ci) & 0xff00) << 14)
#define RGB_GET_GAMBIT_BLUE(ci)	  (((ci) & 0xff) << 22)

#define RGB_GET_GAMBIT_FOG(ci)	  (((ci) & 0xff000000) >> 10)

#define AS_ULONG(val)   *((volatile DWORD *) &(val))


//-----------------------------------------------------------------------------
//     Macros defining the different Vertex types.tags for the Delta unit
//-----------------------------------------------------------------------------

#define VTX_FOG     (0x1 << 25)     
#define VTX_RGB     (0x7 << 21)
#define VTX_R       (0x1 << 21)
#define VTX_RGBA    (0xF << 21)
#define VTX_COLOR   (0x1 << 30)
#define VTX_STQ     (0x7 << 16)
#define VTX_KSKD    (0x3 << 19)
#define VTX_KS      (0x1 << 19)
#define VTX_XYZ     (0x7 << 26)
#define VTX_XY      (0x3 << 26)
#define VTX_GRP     (0x2 << 14)

#define GAMBIT_RGB_VTX                (VTX_GRP | VTX_RGB | VTX_XYZ)   
#define GAMBIT_RGB_F_VTX              (VTX_GRP | VTX_RGB | VTX_XYZ | VTX_FOG) 
#define GAMBIT_RGB_TEX_VTX            (VTX_GRP | VTX_RGB | VTX_XYZ | VTX_STQ)
#define GAMBIT_RGB_F_TEX_VTX          (VTX_GRP | VTX_RGB | VTX_XYZ |         \
                                                 VTX_STQ | VTX_FOG)
#define GAMBIT_RGBA_VTX               (VTX_GRP | VTX_RGBA | VTX_XYZ)  
#define GAMBIT_RGBA_F_VTX             (VTX_GRP | VTX_RGBA | VTX_XYZ | VTX_FOG)
#define GAMBIT_RGBA_TEX_VTX           (VTX_GRP | VTX_RGBA | VTX_XYZ | VTX_STQ)
#define GAMBIT_RGBA_F_TEX_VTX         (VTX_GRP | VTX_RGBA | VTX_XYZ |        \
                                                 VTX_STQ | VTX_FOG)
#define GAMBIT_FLAT_VTX               (VTX_GRP | VTX_XYZ)
#define GAMBIT_XYZ_VTX                (VTX_GRP | VTX_XYZ)
#define GAMBIT_XYZ_COLOR_VTX          (VTX_GRP | VTX_XYZ | VTX_COLOR)
#define GAMBIT_XYZ_STQ_VTX            (VTX_GRP | VTX_XYZ | VTX_STQ)
#define GAMBIT_XYZ_STQ_FOG_VTX        (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_FOG)
#define GAMBIT_XYZ_STQ_KSKD_VTX       (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_KSKD)
#define GAMBIT_XYZ_STQ_KS_VTX         (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_KS)
#define GAMBIT_XYZ_STQ_KS_COL_VTX     (VTX_GRP | VTX_XYZ | VTX_STQ |         \
                                                 VTX_KS | VTX_COLOR)
#define GAMBIT_XYZ_STQ_KS_COL_FOG_VTX (VTX_GRP | VTX_XYZ | VTX_STQ |         \
                                                 VTX_KS | VTX_COLOR | VTX_FOG)
#define GAMBIT_XY_VTX                 (VTX_GRP | VTX_XY)
#define GAMBIT_XY_STQ_VTX             (VTX_GRP | VTX_XY | VTX_STQ)
#define GAMBIT_XY_STQ_FOG_VTX         (VTX_GRP | VTX_XY | VTX_STQ | VTX_FOG)
#define GAMBIT_XY_STQ_KSKD_VTX        (VTX_GRP | VTX_XY | VTX_STQ | VTX_KSKD)
#define GAMBIT_COLS_VTX               (VTX_GRP | VTX_RGB)
#define GAMBIT_PACKED_COLS_VTX        (VTX_GRP | VTX_COLOR)
#define GAMBIT_COLS_ALPHA_VTX         (VTX_GRP | VTX_RGBA)
#define GAMBIT_COLS_KSKD_VTX          (VTX_GRP | VTX_RGB | VTX_KSKD)
#define GAMBIT_FLAT_F_VTX             (VTX_GRP | VTX_XYZ | VTX_FOG)
#define GAMBIT_FLAT_TEX_VTX           (VTX_GRP | VTX_XYZ | VTX_STQ)
#define GAMBIT_FLAT_F_TEX_VTX         (VTX_GRP | VTX_XYZ | VTX_STQ | VTX_FOG)
#define GAMBIT_CI_VTX                 (VTX_GRP | VTX_R | VTX_XYZ) 
#define GAMBIT_CI_F_VTX               (VTX_GRP | VTX_R | VTX_XYZ | VTX_FOG)

//-----------------------------------------------------------------------------
//                     Vertex Data downloading macros
//-----------------------------------------------------------------------------
// 4 Entries
#define SEND_VERTEX_XYZ(Num, x_value, y_value, z_value)     \
{                                                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_XYZ_VTX | Num));          \
    LD_INPUT_FIFO_DATA( AS_ULONG(x_value) );                \
    LD_INPUT_FIFO_DATA( AS_ULONG(y_value) );                \
    LD_INPUT_FIFO_DATA( AS_ULONG(z_value) );                \
}

// 7 Entries
#define SEND_VERTEX_STQ_XYZ(Num, s_value, t_value, q_value,  \
                                 x_value, y_value, z_value)  \
{                                                            \
    LD_INPUT_FIFO_DATA( (GAMBIT_XYZ_STQ_VTX | Num));       \
    LD_INPUT_FIFO_DATA(AS_ULONG(s_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(t_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(q_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(x_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(y_value));                   \
    LD_INPUT_FIFO_DATA(AS_ULONG(z_value));                   \
}

// 8 Entries
#define SEND_VERTEX_STQ_KS_XYZ(Num, s_value, t_value, q_value,             \
                                    Ks_value, x_value, y_value, z_value)   \
{                                                                          \
    LD_INPUT_FIFO_DATA(  (GAMBIT_XYZ_STQ_KS_VTX | Num));                 \
    LD_INPUT_FIFO_DATA( AS_ULONG(s_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(t_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(q_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(Ks_value));                               \
    LD_INPUT_FIFO_DATA( AS_ULONG(x_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(y_value));                                \
    LD_INPUT_FIFO_DATA( AS_ULONG(z_value));                                \
}

// 2 Entries
#define SEND_VERTEX_FOG(vNo, fog_value)        \
{                                              \
    LD_INPUT_FIFO_DATA( vNo);                 \
    LD_INPUT_FIFO_DATA(fog_value);             \
}

// 4 Entries
#define SEND_VERTEX_RGB_MONO(vNo, Color)                \
{                                                       \
    LD_INPUT_FIFO_DATA( (GAMBIT_COLS_VTX | vNo));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
}

// 4 Entries
#define SEND_VERTEX_RGB(vNo, Color)                     \
{                                                       \
    LD_INPUT_FIFO_DATA( (GAMBIT_COLS_VTX | vNo));     \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_RED(Color));      \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_GREEN(Color));    \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));     \
}

// 2 Entries
#define SEND_VERTEX_RGBA_P2(vNo, Color)                     \
{                                                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_PACKED_COLS_VTX | vNo));  \
    LD_INPUT_FIFO_DATA(Color);                              \
}

// 2 Entries
#define SEND_VERTEX_RGB_MONO_P2(vNo, Color)                                 \
{                                                                           \
    DWORD dwBlueVal = RGB_GET_GAMBIT_BLUE(Color);                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_PACKED_COLS_VTX | vNo));                  \
    LD_INPUT_FIFO_DATA( dwBlueVal | (dwBlueVal << 8) | (dwBlueVal << 16));  \
}

// 5 Entries
#define SEND_VERTEX_RGBA(vNo, Color)                        \
{                                                           \
    LD_INPUT_FIFO_DATA( (GAMBIT_COLS_ALPHA_VTX | vNo));   \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_RED(Color));          \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_GREEN(Color));        \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_BLUE(Color));         \
    LD_INPUT_FIFO_DATA(RGB_GET_GAMBIT_ALPHA(Color));        \
}

//-----------------------------------------------------------------------------
//                        HW Alpha stippling macros
//-----------------------------------------------------------------------------

extern DWORD FlatStipplePatterns[128];

#define SET_STIPPLED_ALPHA(AlphaValue)                                      \
{                                                                           \
    DWORD* pStipple;                                                        \
    DWORD NewAlpha = AlphaValue;                                            \
    if (NewAlpha != pContext->LastAlpha)                                    \
    {                                                                       \
        pContext->LastAlpha = NewAlpha;                                     \
        pStipple = FlatStipplePatterns + (NewAlpha << 3);                   \
        LD_INPUT_FIFO_DATA((0x00ff8000 | __Permedia2TagAreaStipplePattern0));  \
        LD_INPUT_FIFO_DATA( pStipple[0]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[1]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[2]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[3]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[4]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[5]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[6]);                                   \
        LD_INPUT_FIFO_DATA( pStipple[7]);                                   \
                                                                            \
    }                                                                       \
    RENDER_AREA_STIPPLE_ENABLE(ulRenderCmd);                                \
}

//-----------------------------------------------------------------------------
//                        Rendering command setup macros
//-----------------------------------------------------------------------------

#define RENDER_AREA_STIPPLE_ENABLE(a) a |= __RENDER_AREA_STIPPLE_ENABLE;
#define RENDER_AREA_STIPPLE_DISABLE(a) a &= ~__RENDER_AREA_STIPPLE_ENABLE;

#define RENDER_TEXTURE_ENABLE(a) a |= __RENDER_TEXTURE_ENABLE;
#define RENDER_TEXTURE_DISABLE(a) a &= ~__RENDER_TEXTURE_ENABLE;

#define RENDER_FOG_ENABLE(a) a |= (1 << 14);
#define RENDER_FOG_DISABLE(a) a &= ~(1 << 14);

#define RENDER_SUB_PIXEL_CORRECTION_ENABLE(a) a |= (1 << 16);
#define RENDER_SUB_PIXEL_CORRECTION_DISABLE(a) a &= ~(1 << 16);


#define RENDER_LINE(a) a &= ~(0xC0);
#define RENDER_TRAPEZOID(a) {a &= ~(0xC0); a |= (0x40);}
#define RENDER_POINT(a) {a &= ~(0xC0);a |= (0x80);}

#define RENDER_NEGATIVE_CULL(a) a |= (1 << 20);
#define RENDER_POSITIVE_CULL(a) a &= ~(1 << 20);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dhw.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dhw.h
*
* Content:  D3D Global definitions and macros.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/

#ifdef __D3DHW
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __D3DHW


#ifndef __DIRECTX
#include "directx.h"
#endif

//-----------------------------------------------------------------------------
//               Known Issues in current version of the D3D driver
//-----------------------------------------------------------------------------
//
// Stencil support is not yet completed
//
// Some games may have some issues when running under a Permedia 2 since this
// hw has some limitations, namely:
//   1) Alpha blending modes available
//   2) Alpha channel interpolation is not possible
//   3) There is no mip mapping support
//   4) Texture filtering is applied only to textures being magnified
//
//  Also, the fill rules of the Delta setup unit don't follow exactly the D3D
//  fill rules, though in practice this shouldn't be a much of a problem for
//  most apps.


//-----------------------------------------------------------------------------
//                      Global enabling/disabling definitions
//-----------------------------------------------------------------------------
// Set to 1 to enable stencil buffer support in the driver
#define D3D_STENCIL         1

// Code stubs to implement a T&L driver. Since the P2 does not support this
// in hw, this symbol should always be set to zero.
#define D3DDX7_TL           0

// Code stubs to implement mip mapping, Since the P2 does not support this 
// natively in hw, this symbols should always be set to zero. Only shows
// how/where to grab DDI info to implement it.
#define D3D_MIPMAPPING      0

// This code shows how to add stateblock support into your DX7 driver. It is
// functional code, so this symbols should be set to one.
#define D3D_STATEBLOCKS     1


//-----------------------------------------------------------------------------
//                         DX6 FVF Support declarations
//-----------------------------------------------------------------------------
typedef struct _P2TEXCOORDS{
    D3DVALUE tu;
    D3DVALUE tv;
} P2TEXCOORDS, *LPP2TEXCOORDS;

typedef struct _P2COLOR {
    D3DCOLOR color;
} P2COLOR, *LPP2COLOR;

typedef struct _P2SPECULAR {
    D3DCOLOR specular;
} P2SPECULAR, *LPP2SPECULAR;

typedef struct _P2PSIZE{
    D3DVALUE psize;
} P2PSIZE, *LPP2PSIZE;

typedef struct _P2FVFOFFSETS{ 
        DWORD dwColOffset;
        DWORD dwSpcOffset;
        DWORD dwTexOffset;
        DWORD dwTexBaseOffset;
//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
        DWORD dwPntSizeOffset;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT
        DWORD dwStride;
} P2FVFOFFSETS , *LPP2FVFOFFSETS;

    // track appropriate pointers to fvf vertex components
__inline void __SetFVFOffsets (DWORD  *lpdwColorOffs, 
                               DWORD  *lpdwSpecularOffs, 
                               DWORD  *lpdwTexOffs, 
                               LPP2FVFOFFSETS lpP2FVFOff)
{
    if (lpP2FVFOff == NULL) {
        // Default non-FVF case , we just set up everything as for a D3DTLVERTEX
        *lpdwColorOffs    = offsetof( D3DTLVERTEX, color);
        *lpdwSpecularOffs = offsetof( D3DTLVERTEX, specular);
        *lpdwTexOffs      = offsetof( D3DTLVERTEX, tu);
    } else {
        // Use the offsets info to setup the corresponding fields
        *lpdwColorOffs    = lpP2FVFOff->dwColOffset;
        *lpdwSpecularOffs = lpP2FVFOff->dwSpcOffset;
        *lpdwTexOffs      = lpP2FVFOff->dwTexOffset;
    }
}

//Size of maximum FVF that we can get. Used for temporary storage
typedef BYTE P2FVFMAXVERTEX[ 3 * sizeof( D3DVALUE ) +    // Position coordinates
                             5 * 4                  +    // D3DFVF_XYZB5
                                 sizeof( D3DVALUE ) +    // FVF_TRANSFORMED
                             3 * sizeof( D3DVALUE ) +    // Normals
                                 sizeof( DWORD )    +    // RESERVED1
                                 sizeof( DWORD )    +    // Diffuse color
                                 sizeof( D3DCOLOR ) +    // Specular color
                                 sizeof( D3DVALUE ) +    // Point sprite size
                             4 * 8 * sizeof( D3DVALUE )  // 8 sets of 4D texture coordinates
                           ];

#define FVFTEX( lpVtx , dwOffs )     ((LPP2TEXCOORDS)((LPBYTE)(lpVtx) + dwOffs))
#define FVFCOLOR( lpVtx, dwOffs )    ((LPP2COLOR)((LPBYTE)(lpVtx) + dwOffs))
#define FVFSPEC( lpVtx, dwOffs)      ((LPP2SPECULAR)((LPBYTE)(lpVtx) + dwOffs))
#define FVFPSIZE( lpVtx, dwOffs)     ((LPP2PSIZE)((LPBYTE)(lpVtx) + dwOffs))

//-----------------------------------------------------------------------------
//                           Miscelaneous definitions
//-----------------------------------------------------------------------------

//AZN9
#ifdef SUPPORTING_MONOFLAG
#define RENDER_MONO (Flags & CTXT_HAS_MONO_ENABLED)
#else
#define RENDER_MONO 0
#endif

// Defines used in the FakeBlendNum field of the P2 D3D context in order to
// make up for missing features in the hw that can be easily simulated
#define FAKE_ALPHABLEND_ONE_ONE     1
#define FAKE_ALPHABLEND_MODULATE    2

#define NOT_HANDLED DBG_D3D((4, "    **Not Currently Handled**"));

// This is defined in the the d3dcntxt.h header, we use it to declare functions
struct _permedia_d3dcontext;
typedef struct _permedia_d3dcontext PERMEDIA_D3DCONTEXT;

//-----------------------------------------------------------------------------
//                       D3D global functions and callbacks
//-----------------------------------------------------------------------------


// Render state processing
DWORD 
__ProcessPermediaStates(PERMEDIA_D3DCONTEXT* pContext, 
                      DWORD Count,
                      LPD3DSTATE lpState, 
                      LPDWORD lpStateMirror);

void 
__HandleDirtyPermediaState(PPDev ppdev, 
                         PERMEDIA_D3DCONTEXT* pContext, 
                         LPP2FVFOFFSETS lpP2FVFOff);

void __HWPreProcessTSS(PERMEDIA_D3DCONTEXT *pContext, 
                      DWORD dwStage, 
                      DWORD dwState, 
                      DWORD dwValue);

// Texture functions
void 
EnableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext);

void 
DisableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext);

void 
P2LUTDownload(PPDev ppdev, 
              PermediaSurfaceData* pPrivateDest, 
              PERMEDIA_D3DCONTEXT* pContext, 
              LPDDRAWI_DDRAWSURFACE_LCL pTexture);

// Chip specific
BOOL 
SetupDefaultsPermediaContext(PERMEDIA_D3DCONTEXT* pContext);

void 
CleanDirect3DContext(PERMEDIA_D3DCONTEXT* pContext, ULONG_PTR dwhContext);

HRESULT 
InitPermediaContext(PERMEDIA_D3DCONTEXT* Context);

void 
SetupCommonContext(PERMEDIA_D3DCONTEXT* pContext);

void 
__PermediaDisableUnits(PERMEDIA_D3DCONTEXT* pContext);

void 
DisableAllUnits(PPDev ppdev);

void __DeleteAllStateSets(PERMEDIA_D3DCONTEXT* pContext);

// Hardware primitive setup functions
void 
P2_Draw_FVF_Line(PERMEDIA_D3DCONTEXT *pContext, 
                 LPD3DTLVERTEX lpV0, 
                 LPD3DTLVERTEX lpV1,
                 LPD3DTLVERTEX lpVFlat, 
                 LPP2FVFOFFSETS lpFVFOff);

void 
P2_Draw_FVF_Point(PERMEDIA_D3DCONTEXT *pContext, 
                  LPD3DTLVERTEX lpV0, 
                  LPP2FVFOFFSETS lpFVFOff);

void 
P2_Draw_FVF_Point_Sprite(PERMEDIA_D3DCONTEXT *pContext, 
                         LPD3DTLVERTEX lpV0, 
                         LPP2FVFOFFSETS lpFVFOff);

typedef void (D3DFVFDRAWTRIFUNC)(PERMEDIA_D3DCONTEXT *, 
                                 LPD3DTLVERTEX, 
                                 LPD3DTLVERTEX,
                                 LPD3DTLVERTEX, 
                                 LPP2FVFOFFSETS);

typedef D3DFVFDRAWTRIFUNC *D3DFVFDRAWTRIFUNCPTR;

typedef void (D3DFVFDRAWPNTFUNC)(PERMEDIA_D3DCONTEXT *, 
                                 LPD3DTLVERTEX, 
                                 LPP2FVFOFFSETS);

typedef D3DFVFDRAWPNTFUNC *D3DFVFDRAWPNTFUNCPTR;

D3DFVFDRAWPNTFUNCPTR __HWSetPointFunc(PERMEDIA_D3DCONTEXT *pContext,
                                       LPP2FVFOFFSETS lpP2FVFOff);

D3DFVFDRAWTRIFUNC P2_Draw_FVF_Solid_Tri;
D3DFVFDRAWTRIFUNC P2_Draw_FVF_Wire_Tri;
D3DFVFDRAWTRIFUNC P2_Draw_FVF_Point_Tri;

// Driver callbacks
void CALLBACK 
D3DHALCreateDriver(PPDev ppdev, 
                   LPD3DHAL_GLOBALDRIVERDATA* lpD3DGlobalDriverData,
                   LPD3DHAL_CALLBACKS* lpD3DHALCallbacks,
                   LPDDHAL_D3DBUFCALLBACKS* lpDDExeBufCallbacks);

DWORD CALLBACK 
D3DValidateTextureStageState( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA lpvtssd );

DWORD CALLBACK 
D3DDrawPrimitives2( LPD3DNTHAL_DRAWPRIMITIVES2DATA pd );

DWORD CALLBACK 
D3DGetDriverState( LPDDHAL_GETDRIVERSTATEDATA);

DWORD CALLBACK 
D3DCreateSurfaceEx( LPDDHAL_CREATESURFACEEXDATA);

DWORD CALLBACK 
D3DDestroyDDLocal( LPDDHAL_DESTROYDDLOCALDATA);

DWORD CALLBACK 
DdSetColorKey(LPDDHAL_SETCOLORKEYDATA psckd);

//-----------------------------------------------------------------------------
//                    Conversion, math and culling macros
//-----------------------------------------------------------------------------
/*
 * This loses one bit of accuracy, but adds and clamps without ifs.
 * We first mask all channels with 0xfe.  This leaves the lsb of
 * each channel clear, so when the terms are added, any carry goes
 * into the new highest bit.  Now all we have to do is generate a
 * mask for any channels that have overflowed.  So we shift right
 * and eliminate everything but the overflow bits, so each channel
 * contains either 0x00 or 0x01.  Subtracting each channel from 0x80
 * produces 0x7f or 0x80.  We just shift this left once and mask to
 * give 0xfe or 0x00.  (We could eliminate the final mask here, but
 * it would introduce noise into the low-bit of every channel..)
 */
#define CLAMP8888(result, color, specular) \
     result = (color & 0xfefefefe) + (specular & 0xfefefe); \
     result |= ((0x808080 - ((result >> 8) & 0x010101)) & 0x7f7f7f) << 1;

#define RGB256_TO_LUMA(r,g,b) (float)(((float)r * 0.001172549019608) + \
                                      ((float)g * 0.002301960784314) + \
                                      ((float)b * 0.000447058823529));

#define LONG_AT(flt) (*(long *)(&flt))
#define ULONG_AT(flt) (*(unsigned long *)(&flt))

//Triangle culling macro
#define CULL_TRI(pCtxt,p0,p1,p2)                                         \
    ((pCtxt->CullMode != D3DCULL_NONE) &&                                \
     (((p1->sx - p0->sx)*(p2->sy - p0->sy) <=                            \
       (p2->sx - p0->sx)*(p1->sy - p0->sy)) ?                            \
      (pCtxt->CullMode == D3DCULL_CCW)     :                             \
      (pCtxt->CullMode == D3DCULL_CW) ) )

ULONG inline RGB888ToHWFmt(ULONG dwRGB888Color, ULONG ColorMask, ULONG RGB888Mask)
{
    unsigned long m;
    int s = 0;

    if (ColorMask)
        for (s = 0, m = ColorMask; !(m & RGB888Mask);  s++)
            m <<= 1;

    return ((dwRGB888Color >> s) & ColorMask);
}

//-----------------------------------------------------------------------------
//                              State Set overrides
//-----------------------------------------------------------------------------

#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define MAX_STATE       D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS      32
#define DWORD_SHIFT     5

#define VALID_STATE(type)       ((DWORD)(type) < 2*D3DSTATE_OVERRIDE_BIAS)

typedef struct _D3DStateSet {
    DWORD               bits[MAX_STATE >> DWORD_SHIFT];
} D3DStateSet;

#define STATESET_MASK(set, state)       \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))


//-----------------------------------------------------------------------------
//  One special legacy texture op we can;t easily map into the new texture ops
//-----------------------------------------------------------------------------
#define D3DTOP_LEGACY_ALPHAOVR (0x7fffffff)

// Temporary data structure we are using here until d3dnthal.h gets updated AZN
typedef struct {
    DWORD       dwOperation;
    DWORD       dwParam; 
    DWORD       dwReserved;
} P2D3DHAL_DP2STATESET;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3d.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3d.c
*
* Content: Main context and texture management callbacks for D3D
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "d3ddelta.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_3D2P
BOOL D3DInitialised = FALSE;

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DContextCreate
//
// The ContextCreate callback is invoked when a new Direct3D device is being 
// created by a Direct3D application. The driver is required to generate a 
// unique context id for this new context. Direct3D will then use this context 
// id in every subsequent callback invocation for this Direct3D device. 
//
// Context is the current rasterization state. For instance, if there are 3 
// applications running, each will have a different state at any point in time.
// When each one is running, the hardware has to make sure that the context, 
// (whether doing Gouraud shading, for example) is the same as the last time 
// that application got a time slice. 
//
// State is anything that the particular device needs to know per context 
// i.e. what surface is being rendered to, shading, texture, texture handles, 
// what physical surfaces those texture handles represent, etc. The context 
// encapsulates all state for the Direct3D device - state is not shared 
// between contexts. Therefore the driver needs to maintain full state 
// information for each context. This state will be changed by calls to the 
// RenderState callback. In the case of rasterization only hardware, the 
// driver need only maintain rasterization state. As well as state, the driver 
// will also want to store the lpDDS, lpDDSZ, and dwPid from the callback 
// data argument. 
//
// The driver should not create a context handle of zero. This is guaranteed 
// to be an invalid context handle. 
//
// Parameters
//      pccd
//           Pointer to a structure containing things including the current
//           rendering surface, the current Z surface, and the DirectX object
//           handle, etc.
//
//          .lpDDGbl    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDLcl(replaces lpDDGbl in DX7)    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDS      
//                This is the surface that is to be used as the rendering 
//                target, i.e., the 3D accelerator sprays its bits at this 
//                surface. 
//          .lpDDSZ     
//                The surface that is to be used as the Z buffer. If this 
//                is NULL, no Z buffering is to be performed. 
//          .dwPid      
//                The process id of the Direct3D application that initiated 
//                the creation of the Direct3D device. 
//          .dwhContext 
//                The driver should place the context ID that it wants Direct3D 
//                to use when communicating with the driver. This should be 
//                unique. 
//          .ddrval     
//                Return code. DD_OK indicates success. 
//
// Return Value
//      Returns one of the following values: 
//                DDHAL_DRIVER_HANDLED  
//                DDHAL_DRIVER_NOTHANDLED   
//
//-----------------------------------------------------------------------------

TextureCacheManager P2TextureManager;
DWORD   P2TMcount = 0;

DWORD CALLBACK 
D3DContextCreate(LPD3DHAL_CONTEXTCREATEDATA pccd)
{
    PERMEDIA_D3DCONTEXT* pContext;
    PermediaSurfaceData* pPrivateData;
    DWORD dwSlotNum;

    LPDDRAWI_DIRECTDRAW_GBL lpDDGbl=pccd->lpDDLcl->lpGbl;

    // Remember the global data for this context.
    PPDev ppdev = (PPDev)lpDDGbl->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DBG_D3D((6,"Entering D3DContextCreate"));

    // Find an empty slot in the global D3D context table
    for (dwSlotNum = 1; dwSlotNum < MAX_CONTEXT_NUM; dwSlotNum++) 
    {
        if (ContextSlots[dwSlotNum] == 0) 
            break;
    }

    // return if we have no contexts left
    if (dwSlotNum == MAX_CONTEXT_NUM)
    {
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        return (DDHAL_DRIVER_HANDLED);
    }

    // Now allocate the drivers D3D context memory.  Simply a chunk of
    // RAM with the relevent data in it.
    pContext = (PERMEDIA_D3DCONTEXT *)
        ENGALLOCMEM( FL_ZERO_MEMORY, sizeof(PERMEDIA_D3DCONTEXT), ALLOC_TAG);

    if (pContext == NULL)
    {
        DBG_D3D((0,"ERROR: Couldn't allocate Context mem"));
        pccd->ddrval = DDERR_OUTOFMEMORY;
        return (DDHAL_DRIVER_HANDLED);
    }
    else
    {
        DBG_D3D((4,"Allocated Context Mem"));
        memset((void *)pContext, 0, sizeof(PERMEDIA_D3DCONTEXT));
    }

    // Setup the drivers's D3D context
    pContext->Hdr.pSelf = (UINT_PTR)pContext;

    // Set up the DRIVER rendering context structure for sanity checks
    pContext->Hdr.MagicNo = RC_MAGIC_NO;

    // Remember the card we are running on
    pContext->ppdev = ppdev;

    // Set context handle in driver's D3D context
    pccd->dwhContext = dwSlotNum;                 //out:Context handle
    ContextSlots[dwSlotNum] = (UINT_PTR)pContext;

    DBG_D3D((4,"Allocated Direct3D context: 0x%x",pccd->dwhContext));

    // Allocate a register context
    P2CtxtPtr pP2ctxt;

    pP2ctxt = P2AllocateNewContext( pContext->ppdev, NULL, 0, P2CtxtWriteOnly);

    if (pP2ctxt == NULL)
    {
        DBG_D3D((0,"ERROR: Couldn't allocate Register Context"));
        CleanDirect3DContext(pContext, pccd->dwhContext);
        pccd->ddrval = DDERR_OUTOFMEMORY;
        return (DDHAL_DRIVER_HANDLED);
    }
    else
    {
        DBG_D3D((4,"Allocated Register context: 0x%x",pP2ctxt));

        // Record the register context in the window render context
        pContext->hPermediaContext = pP2ctxt;

    }

    // No texture at present
    pContext->CurrentTextureHandle = 0;

    // Initialize texture management for this context
    if (0 == P2TMcount)
    {
        if ( FAILED(TextureCacheManagerInitialize(&P2TextureManager)) )
        {
            DBG_D3D((0,"ERROR: Couldn't initialize TextureCacheManager"));
            CleanDirect3DContext(pContext, pccd->dwhContext);
            pccd->ddrval = DDERR_OUTOFMEMORY;
            return (DDHAL_DRIVER_HANDLED);
        }
    }
    P2TMcount++;
    pContext->pTextureManager = &P2TextureManager;

    // Remember the local DD object and get the 
    // correct array of surfaces for this context
    pContext->pDDLcl = pccd->lpDDLcl;
    pContext->pHandleList = GetSurfaceHandleList(pccd->lpDDLcl);
    if (pContext->pHandleList == NULL)
    {
        DBG_D3D((0,"ERROR: Couldn't get a surface handle for lpDDLcl"));
        CleanDirect3DContext(pContext, pccd->dwhContext);
        pccd->ddrval = DDERR_OUTOFMEMORY;
        return (DDHAL_DRIVER_HANDLED);
    }

    DBG_D3D((4,"Getting pHandleList=%08lx for pDDLcl %08lx",
                                 pContext->pHandleList,pccd->dwPID));

    pContext->RenderSurfaceHandle = DDS_LCL(pccd->lpDDS)->lpSurfMore->dwSurfaceHandle;
    if (NULL != pccd->lpDDSZ) 
        pContext->ZBufferHandle = DDS_LCL(pccd->lpDDSZ)->lpSurfMore->dwSurfaceHandle;
    else
        pContext->ZBufferHandle = 0;
    // Now write the default setup to the chip.
    if ( FAILED(InitPermediaContext(pContext)) )
    {
        DBG_D3D((0,"ERROR: D3DContextCreate receives bad parameters "));
        CleanDirect3DContext(pContext, pccd->dwhContext);
        pccd->ddrval = D3DHAL_CONTEXT_BAD;
        return (DDHAL_DRIVER_HANDLED);
    }

    // ---------------- Setup default states in driver ------------------------

    // On context creation, no render states are overridden
    STATESET_INIT(pContext->overrides);

#if D3D_STATEBLOCKS
    // Default state block recording mode = no recording
    pContext->bStateRecMode = FALSE;
    pContext->pCurrSS = NULL;
    pContext->pIndexTableSS = NULL;
    pContext->dwMaxSSIndex = 0;
#endif //D3D_STATEBLOCKS

    pContext->Hdr.Flags = CTXT_HAS_GOURAUD_ENABLED ;
    pContext->CullMode = D3DCULL_CCW;

    // Set the last alpha value to 16 to force a new
    // send of the flat stipple patterns.
    pContext->LastAlpha = 16;

    pContext->bKeptStipple  = FALSE;  // By default, stippling is off
    pContext->bCanChromaKey = FALSE;  // Turn Chroma keying off by default
    pContext->LowerChromaColor = 0x0; // These are the default chromakey values
    pContext->UpperChromaColor = 0x0;

    pContext->FakeBlendNum = 0;       // No need to emulate any blend mode

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    pContext->bPointSpriteEnabled = FALSE; // Point sprite defaults
    pContext->fPointSize = 1.0f;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

    // Initialise the RenderCommand.  States will add to this
    pContext->RenderCommand = 0;
    RENDER_SUB_PIXEL_CORRECTION_ENABLE(pContext->RenderCommand);

    // Setup TSS defaults for stage 0
    pContext->TssStates[D3DTSS_TEXTUREMAP] = 0;
    pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_MODULATE;
    pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
    pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
    pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_CURRENT;
    pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
    pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_CURRENT;
    pContext->TssStates[D3DTSS_TEXCOORDINDEX] = 0;
    pContext->TssStates[D3DTSS_ADDRESS] = D3DTADDRESS_WRAP;
    pContext->TssStates[D3DTSS_ADDRESSU] = D3DTADDRESS_WRAP;
    pContext->TssStates[D3DTSS_ADDRESSV] = D3DTADDRESS_WRAP;
    pContext->TssStates[D3DTSS_MAGFILTER] = D3DTFG_POINT;
    pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
    pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_NONE;

    pContext->TssStates[D3DTSS_BUMPENVMAT00] = 0;           // info we don't use
    pContext->TssStates[D3DTSS_BUMPENVMAT01] = 0;           // in this sample 
    pContext->TssStates[D3DTSS_BUMPENVMAT10] = 0;
    pContext->TssStates[D3DTSS_BUMPENVMAT11] = 0;
    pContext->TssStates[D3DTSS_BUMPENVLSCALE] = 0;
    pContext->TssStates[D3DTSS_BUMPENVLOFFSET] = 0;
    pContext->TssStates[D3DTSS_BORDERCOLOR] = 0x00000000;
    pContext->TssStates[D3DTSS_MAXMIPLEVEL] = 0;
    pContext->TssStates[D3DTSS_MAXANISOTROPY] = 1;

    // Force a change in texture before any 
    // rendering takes place for this context
    DIRTY_TEXTURE;

    DBG_D3D((6,"Exiting D3DContextCreate"));

    pccd->ddrval = DD_OK;
    return (DDHAL_DRIVER_HANDLED);
} // D3DContextCreate

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DContextDestroy
//
// This callback is invoked when a Direct3D Device is being destroyed. As each 
// device is represented by a context ID, the driver is passed a context to 
// destroy. 
//
// The driver should free all resources it allocated to the context being 
// deleted. For example, the driver should free any texture resources it 
// associated with the context. The driver should not free the DirectDraw 
// surface(s) associated with the context because these will be freed by 
// DirectDraw in response to an application or Direct3D runtime request.
//
// Parameters
//     pcdd
//          Pointer to Context destroy information.
//
//          .dwhContext 
//               The ID of the context to be destroyed. 
//          .ddrval
//               Return code. DD_OK indicates success. 
//
// Return Value
//      Returns one of the following values: 
//                DDHAL_DRIVER_HANDLED   
//                DDHAL_DRIVER_NOTHANDLED    
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pcdd)
{
    PERMEDIA_D3DCONTEXT *pContext;

    // Deleting context
    DBG_D3D((6,"Entering D3DContextDestroy, context = %08lx",pcdd->dwhContext));

    pContext = (PERMEDIA_D3DCONTEXT *)ContextSlots[pcdd->dwhContext] ;

    if ( pContext != NULL && pContext->Hdr.MagicNo == RC_MAGIC_DISABLE)
        // render context has been deliberately disabled.
        // set the magic number back to valid to allow the cleanup
        // to proceed in the normal way.
        pContext->Hdr.MagicNo = RC_MAGIC_NO ;

    CHK_CONTEXT( pContext, pcdd->ddrval, "D3DContextDestroy");

    DBG_D3D((4,"Freeing context resources"));
    CleanDirect3DContext(pContext, pcdd->dwhContext);

    pcdd->ddrval = DD_OK;

    DBG_D3D((6,"Exiting D3DContextDestroy"));

    return (DDHAL_DRIVER_HANDLED);
} // D3DContextDestroy


//-----------------------------------------------------------------------------
//
// void __InitD3DTextureWithDDSurfInfo
//
//-----------------------------------------------------------------------------
void  
__InitD3DTextureWithDDSurfInfo(PPERMEDIA_D3DTEXTURE pTexture, 
                               LPDDRAWI_DDRAWSURFACE_LCL lpSurf, 
                               PPDev ppdev)
{
    DBG_D3D((10,"Entering lpSurf=%08lx %08lx",lpSurf,lpSurf->lpGbl->fpVidMem));
    
    pTexture->pTextureSurface = 
            (PermediaSurfaceData*)lpSurf->lpGbl->dwReserved1;

    if (NULL != pTexture->pTextureSurface)
    {
        pTexture->pTextureSurface->dwFlags |= P2_SURFACE_NEEDUPDATE;
        // need to recover this as CreateSurfaceEx may call us during TextureSwap()
        pTexture->dwPaletteHandle = pTexture->pTextureSurface->dwPaletteHandle;
    }
    // Need to remember the sizes and the log of the sizes of the maps
    pTexture->fpVidMem = lpSurf->lpGbl->fpVidMem;
    pTexture->lPitch = lpSurf->lpGbl->lPitch;
    pTexture->wWidth = (WORD)(lpSurf->lpGbl->wWidth);
    pTexture->wHeight = (WORD)(lpSurf->lpGbl->wHeight);
    pTexture->dwRGBBitCount=lpSurf->lpGbl->ddpfSurface.dwRGBBitCount;
    pTexture->m_dwBytes = pTexture->wHeight * pTexture->lPitch; 
    // Magic number for validity check
    pTexture->MagicNo = TC_MAGIC_NO;
    pTexture->dwFlags = lpSurf->dwFlags; 
    pTexture->dwCaps = lpSurf->ddsCaps.dwCaps;
    pTexture->dwCaps2= lpSurf->lpSurfMore->ddsCapsEx.dwCaps2;
    if (DDRAWISURF_HASCKEYSRCBLT & pTexture->dwFlags)
    {
         pTexture->dwKeyLow = lpSurf->ddckCKSrcBlt.dwColorSpaceLowValue;
         pTexture->dwKeyHigh = lpSurf->ddckCKSrcBlt.dwColorSpaceHighValue;
         DBG_D3D((4, "ColorKey exists (%08lx %08lx) on surface %d",
                     pTexture->dwKeyLow,pTexture->dwKeyHigh,
                     lpSurf->lpSurfMore->dwSurfaceHandle));
    }

    if (DD_P2AGPCAPABLE(ppdev) && pTexture->dwCaps & DDSCAPS_NONLOCALVIDMEM) 
    {
        pTexture->lSurfaceOffset = DD_AGPSURFBASEOFFSET(lpSurf->lpGbl);
    }

#if D3D_MIPMAPPING
    // Verify if texture has mip maps atteched
    if (lpSurf->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpNextSurf;
        int LOD;

        lpNextSurf = lpSurf;
        LOD = 0;

        pTexture->bMipMap = TRUE;

        // Calculate the number of mipmap levels (if this is a mipmap)
        pTexture->iMipLevels = (DWORD)((pTexture->wWidth > pTexture->wHeight) ?
                                                  log2((int)pTexture->wWidth) :
                                             log2((int)pTexture->wHeight)) + 1;

        // Walk the chain of surfaces and find all of the mipmap levels
        for (LOD = 0; LOD < pTexture->iMipLevels; LOD++)
        {
            DBG_D3D((4, "Loading texture LOD:%d, Ptr:0x%x",
                        LOD, lpNextSurf->lpGbl->fpVidMem));

            // Store the offsets for each of the mipmap levels
            StorePermediaLODLevel(ppdev, pTexture, lpNextSurf, LOD);

            // Is there another surface in the chain?
            if (lpNextSurf->lpAttachList)
            {
                lpNextSurf = lpNextSurf->lpAttachList->lpAttached;
                if (lpNextSurf == NULL)
                    break;
            }
            else 
                break;
        }

        // This isn't really a MipMap if LOD is 0
        if (LOD == 0)
        {
            DBG_D3D((4, "Texture was not a mipmap - only 1 level"));
            pTexture->bMipMap = FALSE;
            pTexture->iMipLevels = 1;
        }
        else
        {
            // Fill in the remaining levels with the smallest LOD
            // (this is for applications that haven't bothered to
            // pass us all of the LOD's).
            if (LOD < (pTexture->iMipLevels - 1))
            {
                int iLastLOD = LOD;

                DBG_D3D((4,"Filling in missing mipmaps!"));

                for (;LOD < MAX_MIP_LEVELS; LOD++)
                {
                    pTexture->MipLevels[LOD] = pTexture->MipLevels[iLastLOD];
                }
            }
        }
    }
    else 
#endif //D3D_MIPMAPPING
    {
        // NOT A MIPMAP, simply store away the offset of level 0
        pTexture->bMipMap = FALSE;
        pTexture->iMipLevels = 1;
        StorePermediaLODLevel(ppdev, pTexture, lpSurf, 0);
    }

    // If debugging show what has just been created
    DISPTEXTURE((ppdev, pTexture, &lpSurf->lpGbl->ddpfSurface));

    DBG_D3D((10,"Exiting __InitD3DTextureWithDDSurfInfo"));
} // __InitD3DTextureWithDDSurfInfo


//@@BEGIN_DDKSPLIT
#if MULTITHREADED

//-----------------------------------------------------------------------------
//
// Multithread support wrappers for D3D callback functions
//
//-----------------------------------------------------------------------------

//DWORD CALLBACK MtD3DContextCreate(LPD3DHAL_CONTEXTCREATEDATA pccd);
WRAPMTDXCALLBACK(D3D, D3DContextCreate, LPD3DHAL_CONTEXTCREATEDATA, pccd, 
                 pccd->lpDDLcl->lpGbl->dhpdev)

//DWORD CALLBACK MtD3DContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pcdd);
WRAPMTDXCALLBACK(D3D, D3DContextDestroy, LPD3DHAL_CONTEXTDESTROYDATA, pcdd, 
                 ((PERMEDIA_D3DCONTEXT *)ContextSlots[pcdd->dwhContext])->ppdev)

#endif  MULTITHREADED
//@@END_DDKSPLIT


//-----------------------------------------------------------------------------
// Direct3D HAL Table.
//
// This table contains all of the HAL calls that this driver supports in the 
// D3DHAL_Callbacks structure. These calls pertain to device context, scene 
// capture, execution, textures, transform, lighting, and pipeline state. 
// None of this is emulation code. The calls take the form of a return code 
// equal to: HalCall(HalCallData* lpData). All of the information in this 
// table will be implementation specific according to the specifications of 
// the hardware.
//
//-----------------------------------------------------------------------------

#define PermediaTriCaps {                                   \
    sizeof(D3DPRIMCAPS),                                    \
    D3DPMISCCAPS_CULLCCW    |        /* miscCaps */         \
    D3DPMISCCAPS_CULLCW     |                               \
    D3DPMISCCAPS_CULLNONE   |                               \
    D3DPMISCCAPS_MASKPLANES |                               \
    D3DPMISCCAPS_MASKZ,                                     \
    D3DPRASTERCAPS_DITHER    |          /* rasterCaps */    \
    D3DPRASTERCAPS_SUBPIXEL  |                              \
    D3DPRASTERCAPS_ZTEST     |                              \
    D3DPRASTERCAPS_FOGVERTEX |                              \
    D3DPRASTERCAPS_STIPPLE,                                 \
    D3DPCMPCAPS_NEVER        |                              \
    D3DPCMPCAPS_LESS         |                              \
    D3DPCMPCAPS_EQUAL        |                              \
    D3DPCMPCAPS_LESSEQUAL    |                              \
    D3DPCMPCAPS_GREATER      |                              \
    D3DPCMPCAPS_NOTEQUAL     |                              \
    D3DPCMPCAPS_GREATEREQUAL |                              \
    D3DPCMPCAPS_ALWAYS       |                              \
    D3DPCMPCAPS_LESSEQUAL,           /* zCmpCaps */         \
    D3DPBLENDCAPS_SRCALPHA |         /* sourceBlendCaps */  \
    D3DPBLENDCAPS_ONE,                                      \
    D3DPBLENDCAPS_INVSRCALPHA |      /* destBlendCaps */    \
    D3DPBLENDCAPS_ZERO        |                             \
    D3DPBLENDCAPS_ONE,                                      \
    0,                               /* alphatestCaps */    \
    D3DPSHADECAPS_COLORFLATRGB|      /* shadeCaps */        \
    D3DPSHADECAPS_COLORGOURAUDRGB |                         \
    D3DPSHADECAPS_SPECULARFLATRGB |                         \
    D3DPSHADECAPS_SPECULARGOURAUDRGB |                      \
    D3DPSHADECAPS_FOGFLAT        |                          \
    D3DPSHADECAPS_FOGGOURAUD     |                          \
    D3DPSHADECAPS_ALPHAFLATBLEND |                          \
    D3DPSHADECAPS_ALPHAFLATSTIPPLED,                        \
    D3DPTEXTURECAPS_PERSPECTIVE |   /* textureCaps */       \
    D3DPTEXTURECAPS_ALPHA       |                           \
    D3DPTEXTURECAPS_POW2        |                           \
    D3DPTEXTURECAPS_TRANSPARENCY,                           \
    D3DPTFILTERCAPS_NEAREST |       /* textureFilterCaps*/  \
    D3DPTFILTERCAPS_LINEAR,                                 \
    D3DPTBLENDCAPS_DECAL         |  /* textureBlendCaps */  \
    D3DPTBLENDCAPS_DECALALPHA    |                          \
    D3DPTBLENDCAPS_MODULATE      |                          \
    D3DPTBLENDCAPS_MODULATEALPHA |                          \
    D3DPTBLENDCAPS_COPY,                                    \
    D3DPTADDRESSCAPS_WRAP   |       /* textureAddressCaps */\
    D3DPTADDRESSCAPS_MIRROR |                               \
    D3DPTADDRESSCAPS_CLAMP  |                               \
    D3DPTADDRESSCAPS_INDEPENDENTUV,                         \
    8,                              /* stippleWidth */      \
    8                               /* stippleHeight */     \
}          

static D3DDEVICEDESC_V1 PermediaCaps = {
    sizeof(D3DDEVICEDESC_V1),                       /* dwSize */
    D3DDD_COLORMODEL           |                    /* dwFlags */
    D3DDD_DEVCAPS              |
    D3DDD_TRICAPS              |
    D3DDD_LINECAPS             |
    D3DDD_DEVICERENDERBITDEPTH |
    D3DDD_DEVICEZBUFFERBITDEPTH,
    D3DCOLOR_RGB /*| D3DCOLOR_MONO*/,              /* dcmColorModel */
    D3DDEVCAPS_FLOATTLVERTEX |                     /* devCaps */
    D3DDEVCAPS_DRAWPRIMITIVES2 |
    D3DDEVCAPS_DRAWPRIMITIVES2EX    |
#if D3DDX7_TL
    D3DDEVCAPS_HWTRANSFORMANDLIGHT  |
#endif //D3DDX7_TL
    D3DDEVCAPS_SORTINCREASINGZ  |
    D3DDEVCAPS_SORTEXACT |
    D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
    D3DDEVCAPS_EXECUTESYSTEMMEMORY |
    D3DDEVCAPS_TEXTUREVIDEOMEMORY,
    { sizeof(D3DTRANSFORMCAPS), 
      0 },                                         /* transformCaps */
    FALSE,                                         /* bClipping */
    { sizeof(D3DLIGHTINGCAPS), 
      0 },                                         /* lightingCaps */
    PermediaTriCaps,                               /* lineCaps */
    PermediaTriCaps,                               /* triCaps */
    DDBD_16 | DDBD_32,                             /* dwDeviceRenderBitDepth */
    DDBD_16,                                       /* Z Bit depths */
    0,                                             /* dwMaxBufferSize */
    0                                              /* dwMaxVertexCount */
};

// Alpha Stipple patterns from Foley And Van Dam

DWORD FlatStipplePatterns[128] =
{
    //Pattern 0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        
    // Pattern 1
    0x88, 0x00, 0x22, 0x00, 0x88, 0x00, 0x22, 0x00,

    // Pattern 2
    0xAA, 0x00, 0x22, 0x00, 0xAA, 0x00, 0x22, 0x00,

    // Pattern 3
    0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00, 0xAA, 0x00,

    // Pattern 4
    0xAA, 0x44, 0xAA, 0x00, 0xAA, 0x44, 0xAA, 0x00,

    // Pattern 5
    0xAA, 0x44, 0xAA, 0x11, 0xAA, 0x44, 0xAA, 0x11,

    // Pattern 6
    0xAA, 0x55, 0xAA, 0x11, 0xAA, 0x55, 0xAA, 0x11,

    // Pattern 7
    0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55,

    // Pattern 8
    0xEE, 0x55, 0xAA, 0x55, 0xEE, 0x55, 0xAA, 0x55,

    // Pattern 9
    0xEE, 0x55, 0xBB, 0x55, 0xEE, 0x55, 0xBB, 0x55,

    // Pattern 10
    0xFF, 0x55, 0xBB, 0x55, 0xFF, 0x55, 0xBB, 0x55,

    // Pattern 11
    0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55, 0xFF, 0x55,

    // Pattern 12
    0xFF, 0xdd, 0xFF, 0x55, 0xFF, 0xdd, 0xFF, 0x55,

    // Pattern 13
    0xFF, 0xdd, 0xFF, 0x77, 0xFF, 0xdd, 0xFF, 0x77,

    // Pattern 14
    0xFF, 0xFF, 0xFF, 0x77, 0xFF, 0xFF, 0xFF, 0x77,

    // Pattern 15
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};


//-----------------------------------------------------------------------------
// gD3DTextureFormats is a static structure which contains information 
// pertaining to pixel format, dimensions, bit depth, surface requirements, 
// overlays, and FOURCC codes of the supported texture formats.  These texture 
// formats will vary with the driver implementation according to the 
// capabilities of the hardware. 
//-----------------------------------------------------------------------------
DDSURFACEDESC gD3DTextureFormats [] = 
{
    // 5:5:5 RGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB,                         // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0x7c00,                           // ddpfPixelFormat.dwRBitMask
      0x03e0,                           // ddpfPixelFormat.dwGBitMask
      0x001f,                           // ddpfPixelFormat.dwBBitMask
      0                                 // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 1:5:5:5 ARGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_ALPHAPIXELS,      // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0x7c00,                           // ddpfPixelFormat.dwRBitMask
      0x03e0,                           // ddpfPixelFormat.dwGBitMask
      0x001f,                           // ddpfPixelFormat.dwBBitMask
      0x8000                            // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 5:6:5 RGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB,                         // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0xf800,                           // ddpfPixelFormat.dwRBitMask
      0x07e0,                           // ddpfPixelFormat.dwGBitMask
      0x001f,                           // ddpfPixelFormat.dwBBitMask
      0                                 // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 4:4:4:4 ARGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_ALPHAPIXELS,      // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      16,                               // ddpfPixelFormat.dwRGBBitCount
      0x0f00,                           // ddpfPixelFormat.dwRBitMask
      0x00f0,                           // ddpfPixelFormat.dwGBitMask
      0x000f,                           // ddpfPixelFormat.dwBBitMask
      0xf000                            // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 8:8:8 RGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB,                         // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      32,                               // ddpfPixelFormat.dwRGBBitCount
      0x00ff0000,                       // ddpfPixelFormat.dwRBitMask
      0x0000ff00,                       // ddpfPixelFormat.dwGBitMask
      0x000000ff,                       // ddpfPixelFormat.dwBBitMask
      0                                 // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 8:8:8:8 ARGB format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_ALPHAPIXELS,      // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      32,                               // ddpfPixelFormat.dwRGBBitCount
      0x00ff0000,                       // ddpfPixelFormat.dwRBitMask
      0x0000ff00,                       // ddpfPixelFormat.dwGBitMask
      0x000000ff,                       // ddpfPixelFormat.dwBBitMask
      0xff000000                        // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps 
    },

    // 4 bit palettized format
    {
    sizeof(DDSURFACEDESC),              // dwSize 
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags 
    0,                                  // dwHeight 
    0,                                  // dwWidth 
    0,                                  // lPitch 
    0,                                  // dwBackBufferCount 
    0,                                  // dwZBufferBitDepth 
    0,                                  // dwAlphaBitDepth 
    0,                                  // dwReserved 
    NULL,                               // lpSurface 
    { 0, 0 },                           // ddckCKDestOverlay 
    { 0, 0 },                           // ddckCKDestBlt 
    { 0, 0 },                           // ddckCKSrcOverlay 
    { 0, 0 },                           // ddckCKSrcBlt 
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize 
      DDPF_RGB | DDPF_PALETTEINDEXED4,  // ddpfPixelFormat.dwFlags 
      0,                                // ddpfPixelFormat.dwFourCC
      4,                                // ddpfPixelFormat.dwRGBBitCount
      0x00,                             // ddpfPixelFormat.dwRBitMask
      0x00,                             // ddpfPixelFormat.dwGBitMask
      0x00,                             // ddpfPixelFormat.dwBBitMask
      0x00                              // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps
    },

    // 8 bit palettized format
    {
    sizeof(DDSURFACEDESC),              // dwSize
    DDSD_CAPS | DDSD_PIXELFORMAT,       // dwFlags
    0,                                  // dwHeight
    0,                                  // dwWidth
    0,                                  // lPitch
    0,                                  // dwBackBufferCount
    0,                                  // dwZBufferBitDepth
    0,                                  // dwAlphaBitDepth
    0,                                  // dwReserved
    NULL,                               // lpSurface
    { 0, 0 },                           // ddckCKDestOverlay
    { 0, 0 },                           // ddckCKDestBlt
    { 0, 0 },                           // ddckCKSrcOverlay
    { 0, 0 },                           // ddckCKSrcBlt
    {
      sizeof(DDPIXELFORMAT),            // ddpfPixelFormat.dwSize
      DDPF_RGB | DDPF_PALETTEINDEXED8,  // ddpfPixelFormat.dwFlags
      0,                                // ddpfPixelFormat.dwFourCC
      8,                                // ddpfPixelFormat.dwRGBBitCount
      0x00,                             // ddpfPixelFormat.dwRBitMask
      0x00,                             // ddpfPixelFormat.dwGBitMask
      0x00,                             // ddpfPixelFormat.dwBBitMask
      0x00                              // ddpfPixelFormat.dwAlphaBitMask
    },
    DDSCAPS_TEXTURE,                    // ddscaps.dwCaps
    },

};

ULONG gD3DNumberOfTextureFormats = 
                        sizeof(gD3DTextureFormats) / sizeof(DDSURFACEDESC);

//------------------------------------------------------------------------------
// D3D working structures for callbacks and global data
//------------------------------------------------------------------------------

// D3D callbacks and global data
D3DHAL_GLOBALDRIVERDATA gD3DGlobalDriverData;
D3DHAL_CALLBACKS        gD3DCallBacks;

// D3D contexts table
// each entry points to a valid PERMEDIA_D3DCONTEXT structure
UINT_PTR ContextSlots[MAX_CONTEXT_NUM] = {0};

// Handles table
// each entry is a DWLIST structure (*dwSurfaceList,*dwPaletteList;pDDLcl)
DWLIST  HandleList[MAX_CONTEXT_NUM] = {0}; 

//-----------------------------------------------------------------------------
//
// void D3DHALCreateDriver
//
// The main D3D Callback.  
//      Clears contexts 
//      Fills in entry points to D3D driver.  
//      Generates texture formats.
//
//-----------------------------------------------------------------------------
void CALLBACK 
D3DHALCreateDriver(PPDev ppdev, 
                   LPD3DHAL_GLOBALDRIVERDATA* lpD3DGlobalDriverData,
                   LPD3DHAL_CALLBACKS* lpD3DHALCallbacks,
                   LPDDHAL_D3DBUFCALLBACKS* lpDDExeBufCallbacks)
{
    D3DHAL_GLOBALDRIVERDATA deviceD3DGlobal;
    D3DHAL_CALLBACKS deviceD3DHALCallbacks;

    DBG_D3D((6,"Entering D3DHALCreateDriver"));

    // Contexts are cleared out. It is allright to use the D3DInitialised BOOL,
    // because it is global, and therefore forced into shared data segment by
    // the build.
    if (D3DInitialised == FALSE)
    {
        // Clear the contexts.
        memset(ContextSlots, 0, (sizeof(ContextSlots[0]) * MAX_CONTEXT_NUM) );
        memset(HandleList, 0, (sizeof(HandleList[0]) * MAX_CONTEXT_NUM) );

        D3DInitialised = TRUE;
    }

    // Here we fill in the supplied structures.
    // Can disable D3D HAL in registry if we are in the wrong mode
    if (ppdev->iBitmapFormat == BMF_8BPP )
    {
        *lpD3DGlobalDriverData = NULL;
        *lpD3DHALCallbacks = NULL;
        *lpDDExeBufCallbacks = NULL;
        DBG_D3D((0, "D3DHALCreateDriver: Disabled"));
        return;
    }


    // Set the pointers for D3D global data
    ppdev->pD3DDriverData32 = (UINT_PTR)&gD3DGlobalDriverData;
    ppdev->pD3DHALCallbacks32 = (UINT_PTR)&gD3DCallBacks;

    // Clear the global data
    memset(&deviceD3DGlobal, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    deviceD3DGlobal.dwSize = sizeof(D3DHAL_GLOBALDRIVERDATA);
    
    // Clear the call-backs
    memset(&deviceD3DHALCallbacks, 0, sizeof(D3DHAL_CALLBACKS));
    deviceD3DHALCallbacks.dwSize = sizeof(D3DHAL_CALLBACKS);

    deviceD3DGlobal.dwNumVertices = 0;        // We don't parse execute buffers
    deviceD3DGlobal.dwNumClipVertices = 0;

#if D3D_MIPMAPPING
    // Add mipmapping cap bits to our texturing capabilities
    PermediaCaps.dpcTriCaps.dwTextureFilterCaps |= 
                                D3DPTFILTERCAPS_MIPNEAREST |
                                D3DPTFILTERCAPS_MIPLINEAR |
                                D3DPTFILTERCAPS_LINEARMIPNEAREST |
                                D3DPTFILTERCAPS_LINEARMIPLINEAR;

    PermediaCaps.dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_MIPMAPLODBIAS;
#endif

    // Can do packed 24 bit on P2.
    PermediaCaps.dwDeviceRenderBitDepth |= DDBD_24;
    if (DD_P2AGPCAPABLE(ppdev))
        PermediaCaps.dwDevCaps |= D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
    PermediaCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMTLVERTEX;

    deviceD3DGlobal.hwCaps = PermediaCaps;
    deviceD3DGlobal.dwNumTextureFormats = gD3DNumberOfTextureFormats;
    deviceD3DGlobal.lpTextureFormats = &gD3DTextureFormats[0];

    // D3D Context callbacks
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    deviceD3DHALCallbacks.ContextCreate = MtD3DContextCreate;
    deviceD3DHALCallbacks.ContextDestroy = MtD3DContextDestroy;
#else
//@@END_DDKSPLIT
    deviceD3DHALCallbacks.ContextCreate = D3DContextCreate;
    deviceD3DHALCallbacks.ContextDestroy = D3DContextDestroy;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT

    //
    // Return the HAL table.
    //

    memcpy(&gD3DGlobalDriverData, &deviceD3DGlobal, sizeof(D3DHAL_GLOBALDRIVERDATA));
    memcpy(&gD3DCallBacks, &deviceD3DHALCallbacks, sizeof(D3DHAL_CALLBACKS));

    *lpD3DGlobalDriverData = &gD3DGlobalDriverData;
    *lpD3DHALCallbacks = &gD3DCallBacks;
    *lpDDExeBufCallbacks = NULL;

    DBG_D3D((6,"Exiting D3DHALCreateDriver"));

    return;
} // D3DHALCreateDriver

//-----------------------------------------------------------------------------
//
// void CleanDirect3DContext
//
// After it has been decided that a context is indeed still active
// and is being freed, this function walks along cleaning everything
// up.  Note it can be called either as a result of a D3DContextDestroy,
// or as a result of the app exiting without freeing the context, or
// as the result of an error whilst creating the context.
//
//-----------------------------------------------------------------------------
void 
CleanDirect3DContext(PERMEDIA_D3DCONTEXT* pContext, ULONG_PTR dwhContext)
{
    PERMEDIA_D3DTEXTURE* pTexture;
    DWORD dwSlotNum = 1;
    PPDev ppdev = pContext->ppdev;

    DBG_D3D((10,"Entering CleanDirect3DContext"));

    // free up Permedia register context id (resources)
    if (pContext->hPermediaContext)
    {
        P2FreeContext( ppdev, pContext->hPermediaContext);
    }

    // clean up texture manager stuff it is already allocated for this context
    if (pContext->pTextureManager)
    {
        pContext->pTextureManager = NULL;
        P2TMcount--;
        if (0 == P2TMcount)
        {
            if (0 != P2TextureManager.m_heap.m_data_p)
            {
                TextureCacheManagerEvictTextures(&P2TextureManager);
                ENGFREEMEM(P2TextureManager.m_heap.m_data_p);
                P2TextureManager.m_heap.m_data_p=NULL;
            }
        }
    }

#if D3D_STATEBLOCKS
    // Free up any remaining state sets
    __DeleteAllStateSets(pContext);
#endif //D3D_STATEBLOCKS

    // Finally, free up the rendering context structure itself
    ENGFREEMEM((PVOID)pContext->Hdr.pSelf);

    // Mark the context as now empty!
    ContextSlots[dwhContext] = 0;

    DBG_D3D((10,"Exiting CleanDirect3DContext, Context 0x%x deleted.",
                                                            dwhContext));

} // CleanDirect3DContext

//-----------------------------------------------------------------------------
//
// HRESULT InitPermediaContext
//
// Given a valid context, this sets up the rest of the chip, and
// enables the relevent units.  There is a software copy of most things.
//
//-----------------------------------------------------------------------------
HRESULT 
InitPermediaContext(PERMEDIA_D3DCONTEXT* pContext)
{
    PPDev ppdev = pContext->ppdev;

    DBG_D3D((10,"Entering InitPermediaContext"));

    SET_CURRENT_D3D_CONTEXT(pContext->hPermediaContext);

    // Initially turn off all.units
    __PermediaDisableUnits(pContext);

    // Setup initial state of Permedia 2 registers for this D3D context
    SetupDefaultsPermediaContext(pContext);

    DBG_D3D((10,"Exiting InitPermediaContext"));
    // Setup the correct surface (render & depth buffer) characteristics
    return SetupPermediaRenderTarget(pContext);

} // InitPermediaContext

//-----------------------------------------------------------------------------
//
// BOOL: SetupDefaultsPermediaContext
//
// Sets up the Permedia HW context(chip.registers) according to some D3D and
// some HW specific defaults. Done only when initializing the context
//
//-----------------------------------------------------------------------------
BOOL 
SetupDefaultsPermediaContext(PERMEDIA_D3DCONTEXT* pContext)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering SetupDefaultsPermediaContext"));

    //=========================================================================
    // Initialize our software copy of some registers for their default values 
    //=========================================================================

    // Setup the default & constant ( Z Buffer) LB settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->LBReadMode.WindowOrigin = __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN;
    pSoftPermedia->LBReadMode.DataType = __PERMEDIA_LBDEFAULT;     // default
    pSoftPermedia->LBReadMode.ReadSourceEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->LBReadMode.ReadDestinationEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->LBReadMode.PatchMode = 0;

    // Setup the default & constant FB settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->FBReadMode.ReadSourceEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->FBReadMode.ReadDestinationEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->FBReadMode.DataType = __PERMEDIA_FBDATA;
                                                    // Top Left for D3D origin
    pSoftPermedia->FBReadMode.WindowOrigin = __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN;
    pSoftPermedia->FBReadMode.PatchMode = 0;
    pSoftPermedia->FBReadMode.PackedData = 0;
    pSoftPermedia->FBReadMode.RelativeOffset = 0;

    // Setup the default & constant Alpha Blend Mode settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 0;
    pSoftPermedia->AlphaBlendMode.SourceBlend = __PERMEDIA_BLEND_FUNC_ONE;
    pSoftPermedia->AlphaBlendMode.DestinationBlend = __PERMEDIA_BLEND_FUNC_ZERO;
    pSoftPermedia->AlphaBlendMode.NoAlphaBuffer = 0;
    pSoftPermedia->AlphaBlendMode.ColorOrder = COLOR_MODE;
    pSoftPermedia->AlphaBlendMode.BlendType = 0;
    pSoftPermedia->AlphaBlendMode.ColorConversion = 1;
    pSoftPermedia->AlphaBlendMode.AlphaConversion = 1;

    // Setup the default & constant  Dither Mode settings
    //  this will be updated into the chip in SetupPermediaRenderTarget
    pSoftPermedia->DitherMode.ColorOrder = COLOR_MODE;
    pSoftPermedia->DitherMode.XOffset = DITHER_XOFFSET;
    pSoftPermedia->DitherMode.YOffset = DITHER_YOFFSET;
    pSoftPermedia->DitherMode.UnitEnable = __PERMEDIA_ENABLE;
    pSoftPermedia->DitherMode.ForceAlpha = 0;

    //=========================================================================
    //  Find out info for memory widths
    //=========================================================================

    PPDev ppdev = pContext->ppdev;

    DBG_D3D((4, "ScreenWidth %d, ScreenHeight %d, Bytes/Pixel %d",
                ppdev->cxScreen, ppdev->cyScreen, 
                ppdev->ddpfDisplay.dwRGBBitCount >> 3));

    vCalcPackedPP( ppdev->cxMemory, NULL, &pContext->ulPackedPP);
    DBG_D3D((4, "PackedPP = %04x", pContext->ulPackedPP));

    //=========================================================================
    // Initialize hardware registers to their default values 
    //=========================================================================

    // Number of registers we are going to set up
    RESERVEDMAPTR(34);

    // ----------------- Render and Depth Buffer setup ----------------------

    // Setup default offset of render buffer in video memory
    SEND_PERMEDIA_DATA(FBWindowBase, 0x0);

    // Setup  offset from destination to source for copy operations
    SEND_PERMEDIA_DATA(FBSourceOffset, 0x0);

    // Render buffer Write Mode setup
    pSoftPermedia->FBWriteMode.UnitEnable = __PERMEDIA_ENABLE;
    COPY_PERMEDIA_DATA(FBWriteMode, pSoftPermedia->FBWriteMode);

    // Render buffer Write Masks (write to all bits in the pixel)
    SEND_PERMEDIA_DATA(FBSoftwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);

    // Set block fill colour to black
    SEND_PERMEDIA_DATA(FBBlockColor, 0x0);

    // Set window origin offsets to (0,0)
    SEND_PERMEDIA_DATA(WindowOrigin, 0x0);

    // WindowSetup
    pSoftPermedia->Window.ForceLBUpdate = 0;
    pSoftPermedia->Window.LBUpdateSource = 0;
    pSoftPermedia->Window.DisableLBUpdate = 0;
    COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);

    // Disable Screen Scissor unit
    SEND_PERMEDIA_DATA(ScissorMode, __PERMEDIA_DISABLE);

    // Depth Buffer offset
    SEND_PERMEDIA_DATA(LBSourceOffset, 0);

    // Depth Buffer Write mode (initially allow LB Writes)
    pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
    COPY_PERMEDIA_DATA(LBWriteMode, pSoftPermedia->LBWriteMode);

    // Depth comparisons
    pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_ENABLE;
    pSoftPermedia->DepthMode.CompareMode =
                                __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
    pSoftPermedia->DepthMode.NewDepthSource = __PERMEDIA_DEPTH_SOURCE_DDA;
    pSoftPermedia->DepthMode.UnitEnable = __PERMEDIA_DISABLE;
    COPY_PERMEDIA_DATA(DepthMode, pSoftPermedia->DepthMode);


    // ----------------- Texture units setup -----------------------------

    // Enable texture address unit, disable perspective correction
    pSoftPermedia->TextureAddressMode.Enable = 1;
    pSoftPermedia->TextureAddressMode.PerspectiveCorrection = 0;
    pSoftPermedia->TextureAddressMode.DeltaFormat = 0;
    COPY_PERMEDIA_DATA(TextureAddressMode, pSoftPermedia->TextureAddressMode);

    // Enable texture color mode unit, set modulation blending, no specular
    // as defaults
    pSoftPermedia->TextureColorMode.TextureEnable = 1;
    pSoftPermedia->TextureColorMode.ApplicationMode = _P2_TEXTURE_MODULATE;
    pSoftPermedia->TextureColorMode.TextureType = 0;
    pSoftPermedia->TextureColorMode.KdDDA = 0;
    pSoftPermedia->TextureColorMode.KsDDA = 0;
    COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);

    // Enable texture mapping unit, set frame buffer size as default texture
    // map size (to be oevrriden in EnableTexturePermedia)
    pSoftPermedia->TextureMapFormat.PackedPP = pContext->ulPackedPP;
    pSoftPermedia->TextureMapFormat.WindowOrigin =
                                __PERMEDIA_TOP_LEFT_WINDOW_ORIGIN; //top left
    pSoftPermedia->TextureMapFormat.SubPatchMode = 0;
    pSoftPermedia->TextureMapFormat.TexelSize = 1;
    COPY_PERMEDIA_DATA(TextureMapFormat, pSoftPermedia->TextureMapFormat);

    // Setup Textura data format (to be oevrriden in EnableTexturePermedia)
    pSoftPermedia->TextureDataFormat.TextureFormat = 1;
    pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 1;
    pSoftPermedia->TextureDataFormat.ColorOrder = COLOR_MODE;
    COPY_PERMEDIA_DATA(TextureDataFormat, pSoftPermedia->TextureDataFormat);

    // Setup default texture map base address (in video memory)
    SEND_PERMEDIA_DATA(TextureBaseAddress, 0);

    // Setup texture reading defaults: Repeat s,t wrapping, 256x256 texture
    // no texture filtering set up.
    pSoftPermedia->TextureReadMode.PackedData = 0;
    pSoftPermedia->TextureReadMode.FilterMode = 0;
    pSoftPermedia->TextureReadMode.Height = 8;
    pSoftPermedia->TextureReadMode.Width = 8;
    pSoftPermedia->TextureReadMode.pad1 = 0;
    pSoftPermedia->TextureReadMode.pad2 = 0;
    pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_REPEAT;
    pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_REPEAT;
    pSoftPermedia->TextureReadMode.Enable = 1;
    COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);

    // Disable Texture LUT unit for palettized textures
    SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_DISABLE);

    // -------------- Other rendering units setup ----------------

    // Setup defaults of YUV units used for chromakey testing
    pSoftPermedia->YUVMode.Enable = __PERMEDIA_DISABLE;
    pSoftPermedia->YUVMode.TestMode = PM_YUVMODE_CHROMATEST_DISABLE;
    pSoftPermedia->YUVMode.TestData = PM_YUVMODE_TESTDATA_INPUT;
    pSoftPermedia->YUVMode.RejectTexel = FALSE;
    pSoftPermedia->YUVMode.TexelDisableUpdate = FALSE;
    COPY_PERMEDIA_DATA(YUVMode, pSoftPermedia->YUVMode);

    // Chromakey values initially black
    SEND_PERMEDIA_DATA(ChromaUpperBound, 0x00000000);
    SEND_PERMEDIA_DATA(ChromaLowerBound, 0x00000000);

    SEND_PERMEDIA_DATA(AlphaMapUpperBound, 0xFFFFFFFF);
    SEND_PERMEDIA_DATA(AlphaMapLowerBound, 0x11000000);

    // Default Fog color is white
    pSoftPermedia->FogColor = 0xFFFFFFFF;
    SEND_PERMEDIA_DATA(FogColor, pSoftPermedia->FogColor);

    // Fog setup
    pSoftPermedia->FogMode.FogEnable = 1;
    COPY_PERMEDIA_DATA(FogMode, pSoftPermedia->FogMode);

    // Stencil mode setup
    pSoftPermedia->StencilMode.DPFail = __PERMEDIA_STENCIL_METHOD_KEEP;
    pSoftPermedia->StencilMode.DPPass = __PERMEDIA_STENCIL_METHOD_KEEP;
    pSoftPermedia->StencilMode.UnitEnable = __PERMEDIA_DISABLE;
    pSoftPermedia->StencilMode.StencilSource =
                                        __PERMEDIA_STENCIL_SOURCE_TEST_LOGIC;
    COPY_PERMEDIA_DATA(StencilMode, pSoftPermedia->StencilMode);

    // Host out unit , disable read backs
    SEND_PERMEDIA_DATA(FilterMode, __PERMEDIA_DISABLE);

    // Disable statistics unit
    SEND_PERMEDIA_DATA(StatisticMode, __PERMEDIA_DISABLE);


    // ----------------- Rasterization setup -----------------------------

    // Setup Rasterizer units defaults
    SEND_PERMEDIA_DATA(RasterizerMode, 0);

    // Setup a step of -1, as this doesn't change very much
    SEND_PERMEDIA_DATA(dY, 0xFFFF0000);

    // Setup for Gourand shaded colour model, and enable unit
    pContext->Hdr.SoftCopyP2Regs.ColorDDAMode.UnitEnable = 1;
    pContext->Hdr.SoftCopyP2Regs.ColorDDAMode.ShadeMode = 1;
    COPY_PERMEDIA_DATA(ColorDDAMode, pContext->Hdr.SoftCopyP2Regs.ColorDDAMode);

    // Disable stippling unit
    SEND_PERMEDIA_DATA(AreaStippleMode, 0x0); //AZN

    // Setup the Delta setup chip for rasterization
    pSoftPermedia->DeltaMode.TargetChip = 2;
    pSoftPermedia->DeltaMode.SpecularTextureEnable = 0;
    // The below changes to normalize in the perspective case
    // It must not be on in the non-perspective case as the bad Q's will
    // get used in the normalisation.
    pSoftPermedia->DeltaMode.TextureParameterMode = 1;
    pSoftPermedia->DeltaMode.TextureEnable = 1;
    pSoftPermedia->DeltaMode.DiffuseTextureEnable = 0;

    pSoftPermedia->DeltaMode.FogEnable = 1;
    pSoftPermedia->DeltaMode.SmoothShadingEnable = 1;
    pSoftPermedia->DeltaMode.DepthEnable = 0;
    pSoftPermedia->DeltaMode.SubPixelCorrectionEnable = 1;
    pSoftPermedia->DeltaMode.DiamondExit = 1;
    pSoftPermedia->DeltaMode.NoDraw = 0;
    pSoftPermedia->DeltaMode.ClampEnable = 0;
    pSoftPermedia->DeltaMode.FillDirection = 0;
#ifndef P2_CHIP_CULLING
    pSoftPermedia->DeltaMode.BackfaceCull = 0;
#else
    pSoftPermedia->DeltaMode.BackfaceCull = 1;
#endif
    pSoftPermedia->DeltaMode.ColorOrder = COLOR_MODE;
    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

    // Send all this data to Permedia2
    COMMITDMAPTR();
    FLUSHDMA();

    DBG_D3D((10,"Exiting SetupDefaultsPermediaContext"));

    return TRUE;
} // SetupDefaultsPermediaContext

//-----------------------------------------------------------------------------
//
// void SetupPermediaRenderTarget
//
// Sets up the correct surface characteristics (format, stride, etc) of the 
// render buffer and the depth buffer in the Permedia registers
//
//-----------------------------------------------------------------------------
HRESULT 
SetupPermediaRenderTarget(PERMEDIA_D3DCONTEXT* pContext)
{
    __P2RegsSoftwareCopy*   pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PPDev                   ppdev = pContext->ppdev;
    PPERMEDIA_D3DTEXTURE    pSurfRender,pSurfZBuffer;
    PermediaSurfaceData*    pPrivateRender;
    PERMEDIA_DEFS(pContext->ppdev);
    
    DBG_D3D((10,"Entering SetupPermediaRenderTarget"));

    pSurfRender = 
        TextureHandleToPtr(pContext->RenderSurfaceHandle, pContext);

    if (!CHECK_D3DSURFACE_VALIDITY(pSurfRender)) 
    {
        DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
            " Invalid pSurfRender handle=%08lx",
            pContext->RenderSurfaceHandle));
        return DDERR_INVALIDPARAMS;
    }

    if (DDSCAPS_SYSTEMMEMORY & pSurfRender->dwCaps)
    {
        DBG_D3D((0, "ERROR: SetupPermediaRenderTarget"
            " Render Surface in SYSTEMMEMORY handle=%08lx",
            pContext->RenderSurfaceHandle));
        return DDERR_INVALIDPARAMS;    
    }
    pPrivateRender=pSurfRender->pTextureSurface;
    if (!CHECK_P2_SURFACEDATA_VALIDITY(pPrivateRender))
    {
        DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
            " invalid pSurfRender->pTextureSurface handle=%08lx",
            pContext->RenderSurfaceHandle));
        return DDERR_INVALIDPARAMS;
    }
    if (0 != pContext->ZBufferHandle)
    {
        pSurfZBuffer = 
            TextureHandleToPtr(pContext->ZBufferHandle, pContext);

        if (!CHECK_D3DSURFACE_VALIDITY(pSurfZBuffer))
        {
            DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
                " invalid pSurfZBuffer handle=%08lx",
                pContext->ZBufferHandle));
            pContext->ZBufferHandle = 0;
        }
        else
        if (DDSCAPS_SYSTEMMEMORY & pSurfZBuffer->dwCaps)
        {
            DBG_D3D((0, "ERROR: SetupPermediaRenderTarget"
                " pSurfZBuffer in SYSTEMMEMORY  handle=%08lx",
                pContext->ZBufferHandle));
            pContext->ZBufferHandle = 0;
        }
        else
        if (!CHECK_P2_SURFACEDATA_VALIDITY(pSurfZBuffer->pTextureSurface))
        {
            DBG_D3D((0,"ERROR: SetupPermediaRenderTarget"
                " invalid pSurfZBuffer->pTextureSurface handle=%08lx",
                pContext->ZBufferHandle));
            pContext->ZBufferHandle = 0;
        }
    }

    // The default is linear surfaces...
    DBG_D3D((4,"Rendered surface Width: %d", pSurfRender->wWidth));
    pSoftPermedia->FBReadMode.PackedPP = pSurfRender->pTextureSurface->ulPackedPP;
    pContext->PixelOffset = 
        (DWORD)((UINT_PTR)pSurfRender->fpVidMem>>(pSurfRender->dwRGBBitCount>>4));

    DBG_D3D((4,"Setting FBReadMode: 0x%x",pSoftPermedia->FBReadMode));
    // Record the surface information
    RESERVEDMAPTR(10);
    // If there is a Z Buffer, then we must setup the Partial products to be
    // the same as those chosen when it was allocated.

    if (0 != pContext->ZBufferHandle)
    {
        PermediaSurfaceData* pPrivateZ = pSurfZBuffer->pTextureSurface;
        pSoftPermedia->LBReadMode.PackedPP = pPrivateZ->ulPackedPP;
        
        //actually check dwStencilBitMask 
        if (0==pPrivateZ->SurfaceFormat.BlueMask)
        {
            pSoftPermedia->LBReadFormat.DepthWidth = 0;                 // 16 bits
            pSoftPermedia->LBReadFormat.StencilWidth = 0;               // No Stencil
            pSoftPermedia->DeltaMode.DepthFormat = 1;   //PM_DELTAMODE_DEPTHWIDTH_16
        }
        else
        {
            pSoftPermedia->LBReadFormat.DepthWidth = 3;                 // 15 bits
            pSoftPermedia->LBReadFormat.StencilWidth = 3;               // 1 Stencil
            pSoftPermedia->DeltaMode.DepthFormat = 0;   //PM_DELTAMODE_DEPTHWIDTH_15
        }

        SEND_PERMEDIA_DATA(LBWindowBase, 
            (DWORD)((UINT_PTR)pSurfZBuffer->fpVidMem>>P2DEPTH16));
        COPY_PERMEDIA_DATA(LBReadFormat, pSoftPermedia->LBReadFormat);
        COPY_PERMEDIA_DATA(LBWriteFormat, pSoftPermedia->LBReadFormat);

        DBG_D3D((4,"Setting LBReadMode: 0x%x",pSoftPermedia->LBReadMode));
    }
    else
    {   // No Z Buffer, just stuff the same Partial products as the desktop.
        pSoftPermedia->LBReadMode.PackedPP = pContext->ulPackedPP;
    }

    COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
    COPY_PERMEDIA_DATA(LBReadMode, pSoftPermedia->LBReadMode);

    // Set up the screen dimensions to be the same size as the surface.
    SEND_PERMEDIA_DATA(ScreenSize, 
        (pSurfRender->wWidth & 0xFFFF) | (pSurfRender->wHeight << 16));

    // DitherMode and AlphaBlendMode both depend on the surface pixel format
    // being correct.
    pSoftPermedia->DitherMode.ColorFormat =
    pSoftPermedia->AlphaBlendMode.ColorFormat=
        pPrivateRender->SurfaceFormat.Format;
    pSoftPermedia->DitherMode.ColorFormatExtension = 
    pSoftPermedia->AlphaBlendMode.ColorFormatExtension =
        pPrivateRender->SurfaceFormat.FormatExtension;
    pSoftPermedia->FBReadPixel = pPrivateRender->SurfaceFormat.FBReadPixel;
    SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
    SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
    COPY_PERMEDIA_DATA(AlphaBlendMode, pSoftPermedia->AlphaBlendMode);
    COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting SetupPermediaRenderTarget"));
    return DD_OK;

} // SetupPermediaRenderTarget


//=============================================================================
//
// In the new DX7 DDI we don't have the Texture Create/Destroy/Swap calls
// anymore, so now we need a mechanism for generating texture handles. This
// is done by the runtime, which will associate a surface handle for each 
// surface created with the DD local object, and will get our D3DCreateSurfaceEx
// callback called. 
//
// Since this creation can very well happen before we create a D3D context, we
// need to keep track of this association, and when we do get called to create
// a D3D context, we will now be given the relevant DD local object pointer to
// resolve which handles are ours (and to which private texture structures we
// need to use).
//
// This mechanism is also used to associate a palette to a texture
//
//=============================================================================

//-----------------------------------------------------------------------------
//
// BOOL SetTextureSlot
//
// In the handle list element corresponding to this local DD object, store or
// update the pointer to the pTexture associated to the surface handle 
// from the lpDDSLcl surface.
//
//-----------------------------------------------------------------------------
BOOL
SetTextureSlot(LPVOID pDDLcl,
               LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl,
               PPERMEDIA_D3DTEXTURE pTexture)
{
    int   i,j= -1;
    DWORD dwSurfaceHandle;

    DBG_D3D((10,"Entering SetTextureSlot"));

    ASSERTDD(NULL != pDDLcl && NULL != lpDDSLcl && NULL != pTexture,
                                    "SetTextureSlot invalid input");
    dwSurfaceHandle = lpDDSLcl->lpSurfMore->dwSurfaceHandle;

    // Find the handle list element associated with the local DD object,
    // if there's none then select an empty one to be used
    for (i = 0; i < MAX_CONTEXT_NUM;i++)
    {
        if (pDDLcl == HandleList[i].pDDLcl)
        {
            break;  // found the right slot
        }
        else
        if (0 == HandleList[i].pDDLcl && -1 == j)
        {
            j=i;    // first empty slot !
        }
    }

    // If we overrun the existing handle list elements, we need to
    // initialize an existing empty slot or return an error.
    if (i >= MAX_CONTEXT_NUM)
    {
        if (-1 != j)
        {
            //has an empty slot for this process, so use it
            i = j;  
            HandleList[j].pDDLcl = pDDLcl;
            ASSERTDD(NULL == HandleList[j].dwSurfaceList,"in SetTextureSlot");
        }
        else
        {
            //all process slots has been used, fail
            DBG_D3D((0,"SetTextureSlot failed with pDDLcl=%x "
                       "dwSurfaceHandle=%08lx pTexture=%x",
                       pDDLcl,dwSurfaceHandle,pTexture));
            return false;
        }
    }

    ASSERTDD(i < MAX_CONTEXT_NUM, "in SetTextureSlot");

    if ( NULL == HandleList[i].dwSurfaceList ||
        dwSurfaceHandle >= PtrToUlong(HandleList[i].dwSurfaceList[0]))
    {
        // dwSurfaceHandle numbers are going to be ordinal numbers starting
        // at one, so we use this number to figure out a "good" size for
        // our new list.
        DWORD newsize = ((dwSurfaceHandle + LISTGROWSIZE) / LISTGROWSIZE)
                                                              * LISTGROWSIZE;
        PPERMEDIA_D3DTEXTURE *newlist= (PPERMEDIA_D3DTEXTURE *)
            ENGALLOCMEM( FL_ZERO_MEMORY,
                         sizeof(PPERMEDIA_D3DTEXTURE)*newsize,
                         ALLOC_TAG);
        DBG_D3D((4,"Growing pDDLcl=%x's SurfaceList[%x] size to %08lx",
                   pDDLcl,newlist,newsize));

        if (NULL == newlist)
        {
            DBG_D3D((0,"SetTextureSlot failed to increase "
                       "HandleList[%d].dwSurfaceList",i));
            return false;
        }

        memset(newlist,0,newsize);

        // we had a formerly valid surfacehandle list, so we now must 
        // copy it over and free the memory allocated for it
        if (NULL != HandleList[i].dwSurfaceList)
        {
            memcpy(newlist,HandleList[i].dwSurfaceList,
                PtrToUlong(HandleList[i].dwSurfaceList[0]) * 
                sizeof(PPERMEDIA_D3DTEXTURE));
            ENGFREEMEM(HandleList[i].dwSurfaceList);
            DBG_D3D((4,"Freeing pDDLcl=%x's old SurfaceList[%x]",
                       pDDLcl,HandleList[i].dwSurfaceList));
        }

        HandleList[i].dwSurfaceList = newlist;
         //store size in dwSurfaceList[0]
        *(DWORD*)HandleList[i].dwSurfaceList = newsize;
    }

    // Store a pointer to the pTexture associated to this surface handle
    HandleList[i].dwSurfaceList[dwSurfaceHandle] = pTexture;
    pTexture->HandleListIndex = i; //store index here to facilitate search
    DBG_D3D((4,"Set pDDLcl=%x Handle=%08lx pTexture = %x",
                pDDLcl, dwSurfaceHandle, pTexture));

    DBG_D3D((10,"Exiting SetTextureSlot"));

    return true;
} // SetTextureSlot

//-----------------------------------------------------------------------------
//
// PPERMEDIA_D3DTEXTURE GetTextureSlot
//
// Find the pointer to the PPERMEDIA_D3DTEXTURE associated to the 
// dwSurfaceHandle corresponding to the given local DD object
//
//-----------------------------------------------------------------------------
PPERMEDIA_D3DTEXTURE
GetTextureSlot(LPVOID pDDLcl, DWORD dwSurfaceHandle)
{
    DBG_D3D((10,"Entering GetTextureSlot"));

    DWORD   i;
    for (i = 0; i < MAX_CONTEXT_NUM; i++)
    {
        if (HandleList[i].pDDLcl == pDDLcl)
        {
            if (HandleList[i].dwSurfaceList &&
                PtrToUlong(HandleList[i].dwSurfaceList[0]) > dwSurfaceHandle )
            {
                return  HandleList[i].dwSurfaceList[dwSurfaceHandle];
            }
            else
                break;
        }
    }
    DBG_D3D((10,"Exiting GetTextureSlot"));

    return NULL;    //Not found
} // GetTextureSlot

//-----------------------------------------------------------------------------
//
// LPDWLIST GetSurfaceHandleList
//
// Get the handle list which is associated to a specific PDD_DIRECTDRAW_LOCAL
// pDDLcl. It is called from D3DContextCreate to get the handle list associated
// to the pDDLcl with which the context is being created.
//
//-----------------------------------------------------------------------------
LPDWLIST 
GetSurfaceHandleList(LPVOID pDDLcl)
{
    DWORD   i;

    DBG_D3D((10,"Entering GetSurfaceHandleList"));

    ASSERTDD(NULL != pDDLcl, "GetSurfaceHandleList get NULL==pDDLcl"); 
    for (i = 0; i < MAX_CONTEXT_NUM;i++)
    {
        if (HandleList[i].pDDLcl == pDDLcl)
        {
            DBG_D3D((4,"Getting pHandleList=%08lx for pDDLcl %x",
                &HandleList[i],pDDLcl));
            return &HandleList[i];
        }
    }

    DBG_D3D((10,"Exiting GetSurfaceHandleList"));

    return NULL;   //No surface handle available yet
} // GetSurfaceHandleList

//-----------------------------------------------------------------------------
//
// void ReleaseSurfaceHandleList
//
// Free all the associated surface handle and palette memory pools associated
// to a given DD local object.
//
//-----------------------------------------------------------------------------
void 
ReleaseSurfaceHandleList(LPVOID pDDLcl)
{
    DWORD   i;

    DBG_D3D((10,"Entering ReleaseSurfaceHandleList"));

    ASSERTDD(NULL != pDDLcl, "ReleaseSurfaceHandleList get NULL==pDDLcl"); 
    for (i = 0; i < MAX_CONTEXT_NUM; i++)
    {
        if (HandleList[i].pDDLcl == pDDLcl)
        {
            DWORD j;

            if (NULL != HandleList[i].dwSurfaceList)
            {
                DBG_D3D((4,"Releasing HandleList[%d].dwSurfaceList[%x] "
                           "for pDDLcl %x", i, HandleList[i].dwSurfaceList,
                           pDDLcl));

                for (j = 1; j < PtrToUlong(HandleList[i].dwSurfaceList[0]); j++)
                {
                    PERMEDIA_D3DTEXTURE* pTexture = 
                        (PERMEDIA_D3DTEXTURE*)HandleList[i].dwSurfaceList[j];
                    if (NULL != pTexture)
                    {
                        PermediaSurfaceData *pPrivateData=
                            pTexture->pTextureSurface;
                        if (CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData) &&
                            (pPrivateData->fpVidMem))
                        {
                            TextureCacheManagerRemove(&P2TextureManager,
                                pTexture);
                        }
                        ENGFREEMEM(pTexture);
                    }
                }

                ENGFREEMEM(HandleList[i].dwSurfaceList);
                HandleList[i].dwSurfaceList = NULL;
            }

            HandleList[i].pDDLcl = NULL;

            if (NULL != HandleList[i].dwPaletteList)
            {
                DBG_D3D((4,"Releasing dwPaletteList %x for pDDLcl %x",
                    HandleList[i].dwPaletteList,pDDLcl));

                for (j = 1; j < PtrToUlong(HandleList[i].dwPaletteList[0]); j++)
                {
                    LPVOID pPalette = (LPVOID)HandleList[i].dwPaletteList[j];
                    if (NULL != pPalette)
                        ENGFREEMEM(pPalette);
                }

                ENGFREEMEM(HandleList[i].dwPaletteList);
                HandleList[i].dwPaletteList = NULL;
            }

            break;
        }
    }

    DBG_D3D((10,"Exiting ReleaseSurfaceHandleList"));
} // ReleaseSurfaceHandleList

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DGetDriverState
//
// This callback is used by both the DirectDraw and Direct3D runtimes to obtain
// information from the driver about its current state.
//
// Parameters
//
//     lpgdsd   
//           pointer to GetDriverState data structure
//
//           dwFlags
//                   Flags to indicate the data required
//           dwhContext
//                   The ID of the context for which information 
//                   is being requested
//           lpdwStates
//                   Pointer to the state data to be filled in by the driver
//           dwLength
//                   Length of the state data buffer to be filled 
//                   in by the driver
//           ddRVal
//                   Return value
//
// Return Value
//
//      DDHAL_DRIVER_HANDLED
//      DDHAL_DRIVER_NOTHANDLED
//-----------------------------------------------------------------------------
DWORD CALLBACK  
D3DGetDriverState( LPDDHAL_GETDRIVERSTATEDATA lpgdsd )
{
    PERMEDIA_D3DCONTEXT *pContext;
    DBG_D3D((6,"Entering D3DGetDriverState"));
    if (lpgdsd->dwFlags != D3DDEVINFOID_TEXTUREMANAGER)
    {
        DBG_D3D((0,"D3DGetDriverState DEVICEINFOID=%08lx not supported",
            lpgdsd->dwFlags));
        return DDHAL_DRIVER_NOTHANDLED;
    }
    if (lpgdsd->dwLength < sizeof(D3DDEVINFO_TEXTUREMANAGER))
    {
        DBG_D3D((0,"D3DGetDriverState dwLength=%d is not sufficient",
            lpgdsd->dwLength));
        return DDHAL_DRIVER_NOTHANDLED;
    }
    pContext = (PERMEDIA_D3DCONTEXT *)ContextSlots[lpgdsd->dwhContext] ;
    // Check if we got a valid context handle.
    CHK_CONTEXT(pContext, lpgdsd->ddRVal, "D3DGetDriverState");

    TextureCacheManagerGetStats(pContext,
           (LPD3DDEVINFO_TEXTUREMANAGER)lpgdsd->lpdwStates);

    lpgdsd->ddRVal = DD_OK;

    DBG_D3D((6,"Exiitng D3DGetDriverState"));

    return DDHAL_DRIVER_HANDLED;
} // D3DGetDriverState

//-----------------------------------------------------------------------------
//
//  __CreateSurfaceHandle
//
//  allocate a new surface handle
//
//  return value
//
//      DD_OK   -- no error
//      DDERR_OUTOFMEMORY -- allocation of texture handle failed
//
//-----------------------------------------------------------------------------

DWORD __CreateSurfaceHandle( PPDev ppdev,
                             LPVOID pDDLcl,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl)
{
    PPERMEDIA_D3DTEXTURE pTexture;

    DUMPSURFACE(10, lpDDSLcl, NULL);

    if (0 == lpDDSLcl->lpSurfMore->dwSurfaceHandle)
    {
        DBG_D3D((0,"D3DCreateSurfaceEx got 0 surfacehandle dwCaps=%08lx",
            lpDDSLcl->ddsCaps.dwCaps));
        return DD_OK;
    }

    pTexture = 
        GetTextureSlot(pDDLcl,lpDDSLcl->lpSurfMore->dwSurfaceHandle);

    if ((0 == lpDDSLcl->lpGbl->fpVidMem) && 
        (DDSCAPS_SYSTEMMEMORY & lpDDSLcl->ddsCaps.dwCaps))
    {
        // this is a system memory destroy notification
        // so go ahead free the slot for this surface if we have it
        if (NULL != pTexture)
        {
            ASSERTDD(HandleList[pTexture->HandleListIndex].dwSurfaceList
                [lpDDSLcl->lpSurfMore->dwSurfaceHandle] == pTexture,
                "__CreateSurfaceHandle: mismatching pTexture in HandleList");
            HandleList[pTexture->HandleListIndex].dwSurfaceList
                [lpDDSLcl->lpSurfMore->dwSurfaceHandle]=0;
            ENGFREEMEM(pTexture);
            DBG_D3D((8,"D3DCreateSurfaceEx freeing handle=%08lx dwCaps=%08lx",
            lpDDSLcl->lpSurfMore->dwSurfaceHandle,lpDDSLcl->ddsCaps.dwCaps));
        }
        return DD_OK;
    }
    if (NULL == pTexture)
    {
        pTexture =
            (PERMEDIA_D3DTEXTURE*)ENGALLOCMEM( FL_ZERO_MEMORY,
                                               sizeof(PERMEDIA_D3DTEXTURE),
                                               ALLOC_TAG);

        if (NULL != pTexture) 
        {
            if (!SetTextureSlot(pDDLcl,lpDDSLcl,pTexture))
            {
                // Free texture structure since we won't be able to remember it
                // in order to later delete it. We must do it now.
                ENGFREEMEM(pTexture);
                return DDERR_OUTOFMEMORY;
            }
        }
        else
        {
            DBG_D3D((0,"ERROR: Couldn't allocate Texture data mem"));
            return DDERR_OUTOFMEMORY;
        } 
    }

    lpDDSLcl->dwReserved1=pTexture->HandleListIndex;    
    __InitD3DTextureWithDDSurfInfo(pTexture,lpDDSLcl,ppdev);

    if (pTexture->dwCaps & DDSCAPS_TEXTURE)
    {
        for (int i = 1; i < MAX_CONTEXT_NUM; i++)
        {
            PERMEDIA_D3DCONTEXT *pContext =
                                     (PERMEDIA_D3DCONTEXT *)ContextSlots[i];
            if (IS_D3DCONTEXT_VALID(pContext))
            {
                DBG_D3D((4,"   Context 0x%x, Pointer 0x%x",
                                                (DWORD)i, pContext));
                if ((pContext->pDDLcl == pDDLcl)
                    && (pContext->CurrentTextureHandle == 
                        lpDDSLcl->lpSurfMore->dwSurfaceHandle) 
                   )
                {
                    // If the texture being swapped is 
                    // currently being used then we need 
                    // to change the chip setup to reflect this.
                    DIRTY_TEXTURE;
                }
            }
        }
    }

    return DD_OK;
}


//-----------------------------------------------------------------------------
//
//  __CreateSurfaceHandleLoop
//
//  allocate a list of new surface handles by traversing AttachList
//      recursively and calling __CreateSurfaceHandle()
//      only exceptions are for MIPMAP and CUBMAP, which we only
//      use one handle to the root to represent the whole surface
//  return value
//
//      DD_OK   -- no error
//      DDERR_OUTOFMEMORY -- allocation of texture handle failed
//
//-----------------------------------------------------------------------------

DWORD __CreateSurfaceHandleLoop( PPDev ppdev,
                             LPVOID pDDLcl,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSLclroot,
                             LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl)
{
    LPATTACHLIST    curr;
    DWORD ddRVal=DD_OK;
    // Now allocate the texture data space
    if (0 == lpDDSLcl->lpSurfMore->dwSurfaceHandle)
    {
        DBG_D3D((0,"__CreateSurfaceHandleLoop got 0 handle dwCaps=%08lx",
            lpDDSLcl->ddsCaps.dwCaps));
        return DD_OK;
    }

    if ((0 == lpDDSLcl->lpGbl->dwReserved1) && 
        (DDSCAPS_VIDEOMEMORY & lpDDSLcl->ddsCaps.dwCaps)
        )
    {
        DBG_D3D((4,"__CreateSurfaceHandleLoop got "
            "handle=%08lx dwCaps=%08lx not yet created",
            lpDDSLcl->lpSurfMore->dwSurfaceHandle,lpDDSLcl->ddsCaps.dwCaps));
        return DD_OK;
    }

    DBG_D3D((4,"** In __CreateSurfaceHandleLoop %08lx %08lx %08lx %08lx %x",
        lpDDSLcl->ddsCaps.dwCaps,lpDDSLcl->lpSurfMore->dwSurfaceHandle,
        lpDDSLcl->dwFlags,lpDDSLcl->lpGbl->dwReserved1,
        lpDDSLcl->lpGbl->fpVidMem));

    ddRVal=__CreateSurfaceHandle( ppdev, pDDLcl, lpDDSLcl);
    if (DD_OK != ddRVal)
    {
        return ddRVal;
    }

    // for some surfaces other than MIPMAP or CUBEMAP, such as
    // flipping chains, we make a slot for every surface, as
    // they are not as interleaved
    if ((lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) ||
        (lpDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP)
       )
    {
        return DD_OK;
    }
    curr = lpDDSLcl->lpAttachList;
    if (NULL == curr) 
        return DD_OK;

    // check if there is another surface attached!
    if (curr->lpLink)
    {
        lpDDSLcl=curr->lpLink->lpAttached; 
        if (NULL != lpDDSLcl && lpDDSLcl != lpDDSLclroot)
        {
            ddRVal=__CreateSurfaceHandleLoop( ppdev, pDDLcl, 
                 lpDDSLclroot, lpDDSLcl);
            if (DD_OK != ddRVal)
            {
                return ddRVal;
            }
        }
    }
    lpDDSLcl=curr->lpAttached;
    if (NULL != lpDDSLcl && lpDDSLcl != lpDDSLclroot)
        ddRVal=__CreateSurfaceHandleLoop( ppdev, pDDLcl, 
            lpDDSLclroot, lpDDSLcl);
    return ddRVal;
}
//-----------------------------Public Routine----------------------------------
//
// DWORD D3DCreateSurfaceEx
//
// D3dCreateSurfaceEx creates a Direct3D surface from a DirectDraw surface and 
// associates a requested handle value to it.
//
// All Direct3D drivers must support D3dCreateSurfaceEx.
//
// D3dCreateSurfaceEx creates an association between a DirectDraw surface and 
// a small integer surface handle. By creating these associations between a
// handle and a DirectDraw surface, D3dCreateSurfaceEx allows a surface handle
// to be imbedded in the Direct3D command stream. For example when the
// D3DDP2OP_TEXBLT command token is sent to D3dDrawPrimitives2 to load a texture
// map, it uses a source handle and destination handle which were associated
//  with a DirectDraw surface through D3dCreateSurfaceEx.
//
// For every DirectDraw surface created under the local DirectDraw object, the
// runtime generates a valid handle that uniquely identifies the surface and
// places it in pcsxd->lpDDSLcl->lpSurfMore->dwSurfaceHandle. This handle value
// is also used with the D3DRENDERSTATE_TEXTUREHANDLE render state to enable
// texturing, and with the D3DDP2OP_SETRENDERTARGET and D3DDP2OP_CLEAR commands
// to set and/or clear new rendering and depth buffers. The driver should fail
// the call and return DDHAL_DRIVER_HANDLE if it cannot create the Direct3D
// surface. 
//
// As appropriate, the driver should also store any surface-related information
// that it will subsequently need when using the surface. The driver must create
// a new surface table for each new lpDDLcl and implicitly grow the table when
// necessary to accommodate more surfaces. Typically this is done with an
// exponential growth algorithm so that you don't have to grow the table too
// often. Direct3D calls D3dCreateSurfaceEx after the surface is created by
// DirectDraw by request of the Direct3D runtime or the application.
//
// Parameters
//
//      lpcsxd
//           pointer to CreateSurfaceEx structure that contains the information
//           required for the driver to create the surface (described below). 
//
//           dwFlags
//                   Currently unused
//           lpDDLcl
//                   Handle to the DirectDraw object created by the application.
//                   This is the scope within which the lpDDSLcl handles exist.
//                   A DD_DIRECTDRAW_LOCAL structure describes the driver.
//           lpDDSLcl
//                   Handle to the DirectDraw surface we are being asked to
//                   create for Direct3D. These handles are unique within each
//                   different DD_DIRECTDRAW_LOCAL. A DD_SURFACE_LOCAL structure
//                   represents the created surface object.
//           ddRVal
//                   Specifies the location in which the driver writes the return
//                   value of the D3dCreateSurfaceEx callback. A return code of
//                   DD_OK indicates success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLE
//      DDHAL_DRIVER_NOTHANDLE
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DCreateSurfaceEx( LPDDHAL_CREATESURFACEEXDATA lpcsxd )
{
    PPERMEDIA_D3DTEXTURE pTexture;
    LPVOID pDDLcl= (LPVOID)lpcsxd->lpDDLcl;
    LPDDRAWI_DDRAWSURFACE_LCL   lpDDSLcl=lpcsxd->lpDDSLcl;
    LPATTACHLIST    curr;

    DBG_D3D((6,"Entering D3DCreateSurfaceEx"));

    lpcsxd->ddRVal = DD_OK;

    if (NULL == lpDDSLcl || NULL == pDDLcl)
    {
        DBG_D3D((0,"D3DCreateSurfaceEx received 0 lpDDLcl or lpDDSLcl pointer"));
        return DDHAL_DRIVER_HANDLED;
    }


    // We check that what we are handling is a texture, zbuffer or a rendering
    // target buffer. We don't check if it is however stored in local video
    // memory since it might also be a system memory texture that we will later
    // blt with __TextureBlt.
    // also if your driver supports DDSCAPS_EXECUTEBUFFER create itself, it must 
    // process DDSCAPS_EXECUTEBUFFER here as well.
    if (!(lpDDSLcl->ddsCaps.dwCaps & 
             (DDSCAPS_TEXTURE       | 
              DDSCAPS_3DDEVICE      | 
              DDSCAPS_ZBUFFER))
       )
    {
        DBG_D3D((2,"D3DCreateSurfaceEx w/o "
             "DDSCAPS_TEXTURE/3DDEVICE/ZBUFFER Ignored"
             "dwCaps=%08lx dwSurfaceHandle=%08lx",
             lpDDSLcl->ddsCaps.dwCaps,
             lpDDSLcl->lpSurfMore->dwSurfaceHandle));
        return DDHAL_DRIVER_HANDLED;
    }

    DBG_D3D((4,"Entering D3DCreateSurfaceEx handle=%08lx",
        lpDDSLcl->lpSurfMore->dwSurfaceHandle));
    PPDev ppdev=(PPDev)lpcsxd->lpDDLcl->lpGbl->dhpdev;
    PERMEDIA_DEFS(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_D3D((MT_LOG_LEVEL, "D3DCreateSurfaceEx: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    // Now allocate the texture data space
    lpcsxd->ddRVal = __CreateSurfaceHandleLoop( ppdev, pDDLcl, lpDDSLcl, lpDDSLcl);
    DBG_D3D((4,"Exiting D3DCreateSurfaceEx"));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return DDHAL_DRIVER_HANDLED;
} // D3DCreateSurfaceEx

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DDestroyDDLocal
//
// D3dDestroyDDLocal destroys all the Direct3D surfaces previously created by
// D3DCreateSurfaceEx that belong to the same given local DirectDraw object.
//
// All Direct3D drivers must support D3dDestroyDDLocal.
// Direct3D calls D3dDestroyDDLocal when the application indicates that the
// Direct3D context is no longer required and it will be destroyed along with
// all surfaces associated to it. The association comes through the pointer to
// the local DirectDraw object. The driver must free any memory that the
// driver's D3dCreateSurfaceExDDK_D3dCreateSurfaceEx_GG callback allocated for
// each surface if necessary. The driver should not destroy the DirectDraw
// surfaces associated with these Direct3D surfaces; this is the application's
// responsibility.
//
// Parameters
//
//      lpdddd
//            Pointer to the DestoryLocalDD structure that contains the
//            information required for the driver to destroy the surfaces.
//
//            dwFlags
//                  Currently unused
//            pDDLcl
//                  Pointer to the local Direct Draw object which serves as a
//                  reference for all the D3D surfaces that have to be destroyed.
//            ddRVal
//                  Specifies the location in which the driver writes the return
//                  value of D3dDestroyDDLocal. A return code of DD_OK indicates
//                   success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLED
//      DDHAL_DRIVER_NOTHANDLED
//-----------------------------------------------------------------------------
DWORD CALLBACK  
D3DDestroyDDLocal( LPDDHAL_DESTROYDDLOCALDATA lpdddd )
{
    DBG_D3D((6,"Entering D3DDestroyDDLocal"));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    PPDev ppdev=(PPDev)lpdddd->pDDLcl->lpGbl->dhpdev;
    
    if(ppdev->ulLockCount)
    {
         DBG_D3D((MT_LOG_LEVEL, "D3DCreateSurfaceEx: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    ReleaseSurfaceHandleList(LPVOID(lpdddd->pDDLcl));
    lpdddd->ddRVal = DD_OK;

    DBG_D3D((6,"Exiting D3DDestroyDDLocal"));

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return DDHAL_DRIVER_HANDLED;
} // D3DDestroyDDLocal

//-----------------------------Public Routine----------------------------------
//
//  DdSetColorkey
//
//  DirectDraw SetColorkey callback
//
//  Parameters
//       lpSetColorKey
//             Pointer to the LPDDHAL_SETCOLORKEYDATA parameters structure 
//
//             lpDDSurface
//                  Surface struct
//             dwFlags
//                  Flags
//             ckNew
//                  New chroma key color values
//             ddRVal
//                  Return value
//             SetColorKey
//                  Unused: Win95 compatibility
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdSetColorKey(LPDDHAL_SETCOLORKEYDATA lpSetColorKey)
{
    DWORD dwSurfaceHandle =
                        lpSetColorKey->lpDDSurface->lpSurfMore->dwSurfaceHandle;
    DWORD index = (DWORD)lpSetColorKey->lpDDSurface->dwReserved1;

    DBG_D3D((6,"Entering DdSetColorKey dwSurfaceHandle=%d index=%d",
        dwSurfaceHandle, index));

    lpSetColorKey->ddRVal = DD_OK;
    // We don't have to do anything for normal blt source colour keys:
    if (!(DDSCAPS_TEXTURE & lpSetColorKey->lpDDSurface->ddsCaps.dwCaps) ||
        !(DDSCAPS_VIDEOMEMORY & lpSetColorKey->lpDDSurface->ddsCaps.dwCaps) 
       )
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    if (0 != dwSurfaceHandle && NULL != HandleList[index].dwSurfaceList)
    {
        PERMEDIA_D3DTEXTURE *pTexture =
                                HandleList[index].dwSurfaceList[dwSurfaceHandle];

        ASSERTDD(PtrToUlong(HandleList[index].dwSurfaceList[0]) > dwSurfaceHandle,
            "SetColorKey: incorrect dwSurfaceHandle");

        if (NULL != pTexture)
        {
            DBG_D3D((4, "DdSetColorKey surface=%08lx KeyLow=%08lx",
                dwSurfaceHandle,pTexture->dwKeyLow));
            pTexture->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
            pTexture->dwKeyLow = lpSetColorKey->ckNew.dwColorSpaceLowValue;
            pTexture->dwKeyHigh = lpSetColorKey->ckNew.dwColorSpaceHighValue;
        }
    }
    else
    {
        lpSetColorKey->ddRVal = DDERR_INVALIDPARAMS;
    }
    DBG_D3D((6,"Exiting DdSetColorKey"));

    return DDHAL_DRIVER_HANDLED;
}   // DdSetColorKey


//@@BEGIN_DDKSPLIT
#if MULTITHREADED

//-----------------------------------------------------------------------------
//
// Multithread support wrappers for D3D callback functions
//
//-----------------------------------------------------------------------------

//DWORD CALLBACK MtD3DDrawPrimitives2(LPD3DNTHAL_DRAWPRIMITIVES2DATA pdp2);, 
WRAPMTDXCALLBACK(D3D, D3DDrawPrimitives2, LPD3DNTHAL_DRAWPRIMITIVES2DATA, pdp2, 
                 ((PERMEDIA_D3DCONTEXT *)ContextSlots[pdp2->dwhContext])->ppdev)

//DWORD CALLBACK MtDdSetColorKey(LPDDHAL_SETCOLORKEYDATA lpSetColorKey);
WRAPMTDXCALLBACK(D3D, DdSetColorKey, LPDDHAL_SETCOLORKEYDATA, lpSetColorKey,
                 lpSetColorKey->lpDD->dhpdev);

#endif  MULTITHREADED

//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dcntxt.h ===
/******************************Module*Header*********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dcntxt.h
*
*  Content: D3D Context management related definitions and macros
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifdef __DCONTEXT
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __DCONTEXT

#ifndef __SOFTCOPY
#include "d3dsoft.h"
#endif

#ifndef __TEXTURES
#include "d3dtext.h"
#endif

//-----------------------------------------------------------------------------
//                       Context indexing structure
//-----------------------------------------------------------------------------
#define MAX_CONTEXT_NUM 200
extern  UINT_PTR ContextSlots[];

//-----------------------------------------------------------------------------
//                       Context validation macros
//-----------------------------------------------------------------------------
#define RC_MAGIC_DISABLE 0xd3d00000
#define RC_MAGIC_NO 0xd3d00100

#define IS_D3DCONTEXT_VALID(ptr)          \
    ( ((ptr) != NULL) && ((ptr)->Hdr.MagicNo == RC_MAGIC_NO) )

#define CHK_CONTEXT(pCtxt, retVar, funcname)             \
    if (!IS_D3DCONTEXT_VALID(pCtxt)) {                   \
        retVar = D3DHAL_CONTEXT_BAD;                     \
        DBG_D3D((0,"Context not valid in %s",funcname)); \
        return (DDHAL_DRIVER_HANDLED);                   \
    }

// Defines for the dwDirtyFlags field of our context
#define CONTEXT_DIRTY_ALPHABLEND          2
#define CONTEXT_DIRTY_ZBUFFER             4
#define CONTEXT_DIRTY_TEXTURE             8
#define CONTEXT_DIRTY_MULTITEXTURE       16

#define DIRTY_ALPHABLEND     pContext->dwDirtyFlags |= CONTEXT_DIRTY_ALPHABLEND;
#define DIRTY_TEXTURE        pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;
#define DIRTY_ZBUFFER        pContext->dwDirtyFlags |= CONTEXT_DIRTY_ZBUFFER;
#define DIRTY_MULTITEXTURE   pContext->dwDirtyFlags |= CONTEXT_DIRTY_MULTITEXTURE;


//-----------------------------------------------------------------------------
//                    Context rendering state tracking
//-----------------------------------------------------------------------------
// Flags to keep track of various rendering states or conditions in a D3D context
// these are tracked in the Hdr.Flags field
#define CTXT_HAS_GOURAUD_ENABLED      (1 << 0)
#define CTXT_HAS_ZBUFFER_ENABLED      (1 << 1)
#define CTXT_HAS_SPECULAR_ENABLED     (1 << 2)
#define CTXT_HAS_FOGGING_ENABLED      (1 << 3)
#define CTXT_HAS_PERSPECTIVE_ENABLED  (1 << 4)
#define CTXT_HAS_TEXTURE_ENABLED      (1 << 5)
#define CTXT_HAS_ALPHABLEND_ENABLED   (1 << 6)
#define CTXT_HAS_MONO_ENABLED         (1 << 7)
#define CTXT_HAS_WRAPU_ENABLED        (1 << 8)
#define CTXT_HAS_WRAPV_ENABLED        (1 << 9)
    // Use the alpha value to calculate a stipple pattern
#define CTXT_HAS_ALPHASTIPPLE_ENABLED (1 << 10)
#define CTXT_HAS_ZWRITE_ENABLED       (1 << 11)
    // Enable last point on lines
#define CTXT_HAS_LASTPIXEL_ENABLED    (1 << 12)

#if D3D_STATEBLOCKS
//-----------------------------------------------------------------------------
//                     State sets structure definitions
//-----------------------------------------------------------------------------
#define FLAG DWORD
#define FLAG_SIZE (8*sizeof(DWORD))

typedef struct _P2StateSetRec {
    DWORD                   dwHandle;
    DWORD                   bCompressed;

    union {
        struct {
            // Stored state block info (uncompressed)
            DWORD RenderStates[MAX_STATE];
            DWORD TssStates[D3DTSS_TEXTURETRANSFORMFLAGS+1];

            FLAG bStoredRS[(MAX_STATE + FLAG_SIZE)/ FLAG_SIZE];
            FLAG bStoredTSS[(D3DTSS_TEXTURETRANSFORMFLAGS + FLAG_SIZE) / FLAG_SIZE];
        } uc;
        struct {
            // Stored state block info (compressed)
            DWORD dwNumRS;
            DWORD dwNumTSS;
            struct {
                DWORD dwType;
                DWORD dwValue;
            } pair[1];
        } cc;
    } u;

} P2StateSetRec;

#define SSPTRS_PERPAGE (4096/sizeof(P2StateSetRec *))

#define FLAG_SET(flag, number)     \
    flag[ (number) / FLAG_SIZE ] |= (1 << ((number) % FLAG_SIZE))

#define IS_FLAG_SET(flag, number)  \
    (flag[ (number) / FLAG_SIZE ] & (1 << ((number) % FLAG_SIZE) ))
#endif //D3D_STATEBLOCKS

//-----------------------------------------------------------------------------
//                     Context structure definitions
//-----------------------------------------------------------------------------

typedef struct _D3DContextHeader {
    
    unsigned long MagicNo;   // Magic number to verify validity of pointer
    UINT_PTR pSelf;          // 32 Bit pointer to this structure
    unsigned long Flags;
    unsigned long FillMode;

    // Software copy of Registers for permedia
    __P2RegsSoftwareCopy SoftCopyP2Regs;  

} D3DCONTEXTHEADER;

typedef struct _TextureCacheManager *PTextureCacheManager;

typedef struct _permedia_d3dcontext {

    // The magic number MUST come at the start of the structure
    D3DCONTEXTHEADER    Hdr;

    // Stored surface info
    UINT_PTR             RenderSurfaceHandle;
    UINT_PTR             ZBufferHandle;
    ULONG                ulPackedPP;

                         // handle on Permedia register state context
    P2CtxtPtr            hPermediaContext; 

    PPDev ppdev;            // The card we are running on.

    BOOL bCanChromaKey;

    // Stippling state
    BOOL bKeptStipple;
    DWORD LastAlpha;
    BYTE CurrentStipple[8];

    DWORD RenderCommand;

    DWORD RenderStates[MAX_STATE];
    DWORD TssStates[D3DTSS_TEXTURETRANSFORMFLAGS+1]; // D3D DX6 TSS States
    DWORD dwWrap[8]; // D3D DX6 Wrap flags

    DWORD dwDirtyFlags;

    // Texture filtering modes
    BOOL bMagFilter;        // Filter the magnified textures
    BOOL bMinFilter;        // Filter the minified textures

    // Misc. state
    D3DCULL CullMode;
    DWORD FakeBlendNum;

    D3DStateSet     overrides;     // To overide states in rendering
    
    // Texture data & sizes (for Permedia setup) of our CurrentTextureHandle
    FLOAT DeltaHeightScale;
    FLOAT DeltaWidthScale;
    DWORD MaxTextureXi;
    FLOAT MaxTextureXf;
    DWORD MaxTextureYi;
    FLOAT MaxTextureYf;

    DWORD CurrentTextureHandle;

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    // Point sprite support
    BOOL bPointSpriteEnabled;
    FLOAT fPointSize;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

#if D3D_STATEBLOCKS
    BOOL bStateRecMode;            // Toggle for executing or recording states
    P2StateSetRec   *pCurrSS;      // Ptr to SS currently being recorded
    P2StateSetRec   **pIndexTableSS; // Pointer to table of indexes
    DWORD           dwMaxSSIndex;    // size of table of indexes
#endif

    DWORD PixelOffset;     // Offset in pixels to start of the rendering buffer

    DWORD LowerChromaColor;    // Last lower bound chroma key for this context
    DWORD UpperChromaColor;    // Last upper bound chroma key for this context

    PTextureCacheManager   pTextureManager;
    LPDWLIST    pHandleList;
    LPVOID      pDDLcl;                   // Local surface pointer used as a ID
} PERMEDIA_D3DCONTEXT ;


//-----------------------------------------------------------------------------
//                          Context switching
//-----------------------------------------------------------------------------
// Code to do a context switch.  If we aren't DMAing we need to resend the 
// registers on each context switch to work around the Permedia bug.  In the 
// DMA case, these registers will be inserted at the start of the buffer.
#define SET_CURRENT_D3D_CONTEXT(ctxt)        \
    if(ctxt != ppdev->permediaInfo->pCurrentCtxt)   \
    {                                       \
        P2SwitchContext(ppdev,  ctxt);   \
    }

HRESULT 
SetupPermediaRenderTarget(PERMEDIA_D3DCONTEXT* pContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dline.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dline.c
*
* Content:    Direct3D hw line rasterization code.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3ddelta.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#if defined(_ALPHA_)
#include <math.h>
#endif


//-----------------------------------------------------------------------------
//
// VOID P2_Draw_FVF_Line
//
// Hardare render a single line coming from two FVF vertices
//
// Primitive rendering at this stage is dependent upon the current value/setting
// of texturing, perspective correction, fogging, gouraud/flat shading, and
// specular highlights.
//
//-----------------------------------------------------------------------------
VOID
P2_Draw_FVF_Line(PERMEDIA_D3DCONTEXT   *pContext, 
                 LPD3DTLVERTEX    lpV0, 
                 LPD3DTLVERTEX    lpV1,
                 LPD3DTLVERTEX    lpVFlat,
                 LPP2FVFOFFSETS   lpFVFOff)
{
    DWORD       dwFlags = pContext->Hdr.Flags;
    ULONG       ulRenderCmd = pContext->RenderCommand;
    DWORD       dwColorOffs,dwSpecularOffs,dwTexOffs;
    D3DCOLOR    dwColor0, dwColor1;
    D3DCOLOR    dwSpec0, dwSpec1;
    D3DVALUE    fS0, fS1, fT0, fT1, fQ0, fQ1;
    D3DVALUE    fKs0, fKs1;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering P2_Draw_FVF_Line"));

    // Set line rendering mode
    RENDER_LINE(ulRenderCmd);

    // Fix up the biasing in delta because delta doesn't do it for us for lines.
    RESERVEDMAPTR(0x80);
    SEND_PERMEDIA_DATA(RasterizerMode, BIAS_NONE);

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    // Get vertex color value (FVF based)
    if (dwColorOffs)
    {
        dwColor0  = FVFCOLOR(lpV0, dwColorOffs)->color;
        dwColor1  = FVFCOLOR(lpV1, dwColorOffs)->color;
        if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
        {
            dwColor0  |= 0xFF000000;
            dwColor1  |= 0xFF000000;
        }
    }
    else
    {
        // must set default in case no D3DFVF_DIFFUSE
        dwColor0  = 0xFFFFFFFF;
        dwColor1  = 0xFFFFFFFF;
    }

    // Get vertex specular value (FVF based) if necessary
    if ((dwFlags & (CTXT_HAS_SPECULAR_ENABLED | CTXT_HAS_FOGGING_ENABLED))
        && (dwSpecularOffs!=0))
    {
        dwSpec0   = FVFSPEC(lpV0, dwSpecularOffs)->specular;
        dwSpec1   = FVFSPEC(lpV1, dwSpecularOffs)->specular;
    }

    if ((dwFlags & CTXT_HAS_TEXTURE_ENABLED) && (dwTexOffs != 0))
    {
         // Get s,t texture coordinates (FVF based)
        fS0 = FVFTEX(lpV0,dwTexOffs)->tu;
        fT0 = FVFTEX(lpV0,dwTexOffs)->tv;
        fS1 = FVFTEX(lpV1,dwTexOffs)->tu;
        fT1 = FVFTEX(lpV1,dwTexOffs)->tv;

        // Wrap texture coordinates if necessary
        WRAP_LINE(fS, dwFlags & CTXT_HAS_WRAPU_ENABLED);
        WRAP_LINE(fT, dwFlags & CTXT_HAS_WRAPV_ENABLED);

        // Scale s,t coordinate values
        fS0 *= pContext->DeltaWidthScale;
        fS1 *= pContext->DeltaWidthScale;
        fT0 *= pContext->DeltaHeightScale;
        fT1 *= pContext->DeltaHeightScale;

        // Apply perpspective corrections if necessary
        if (dwFlags & CTXT_HAS_PERSPECTIVE_ENABLED)
        {
            fQ0 = lpV0->rhw;
            fQ1 = lpV1->rhw;
            fS0 *= fQ0;
            fT0 *= fQ0;
            fS1 *= fQ1;
            fT1 *= fQ1;
        }
        else
        {
            fQ0 = fQ1 = 1.0;
        }

        // Send lines s,t,q,ks (conditionaly),x,y,z values
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            fKs0 = RGB256_TO_LUMA(RGB_GETRED(dwSpec0),
                                    RGB_GETGREEN(dwSpec0),
                                    RGB_GETBLUE(dwSpec0));
            
            if (dwFlags & CTXT_HAS_GOURAUD_ENABLED) 
            {
                fKs1 = RGB256_TO_LUMA(RGB_GETRED(dwSpec1),
                                        RGB_GETGREEN(dwSpec1),
                                        RGB_GETBLUE(dwSpec1));
            } 
            else
            {
                fKs1 = fKs0;
            }

            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0, fKs0,
                                                lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1, fKs1,
                                                lpV1->sx, lpV1->sy, lpV1->sz);
        }
        else
        {
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0,
                                                lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1,
                                                lpV1->sx, lpV1->sy, lpV1->sz);
        }
    }
    else    // not textured line
    {
        // If specular is enabled, change the colours
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            CLAMP8888(dwColor0, dwColor0, dwSpec0 );
            CLAMP8888(dwColor1, dwColor1, dwSpec1 );
        }

        // Send lines x,y,z values
        SEND_VERTEX_XYZ(__Permedia2TagV0FloatS, lpV0->sx, lpV0->sy, lpV0->sz);
        SEND_VERTEX_XYZ(__Permedia2TagV1FloatS, lpV1->sx, lpV1->sy, lpV1->sz);
    }

    // If fog is set, send the appropriate values
    if ((dwFlags & CTXT_HAS_FOGGING_ENABLED) && (dwSpecularOffs!=0))
    {
        SEND_VERTEX_FOG(__Permedia2TagV0FixedF, RGB_GET_GAMBIT_FOG(dwSpec0));
        SEND_VERTEX_FOG(__Permedia2TagV1FixedF, RGB_GET_GAMBIT_FOG(dwSpec1));
    }

    // Send appropriate color depending on Gouraud , Mono, & Alpha
    if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
    {
        // Gouraud shading
        if (RENDER_MONO)
        {
            SEND_VERTEX_RGB_MONO_P2(__Permedia2TagV0FixedS, dwColor0);
            SEND_VERTEX_RGB_MONO_P2(__Permedia2TagV1FixedS, dwColor1);
        }
        else
        {
            if (dwFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
                {
                    dwColor0 &= 0xFFFFFF;     // supress color's alpha value
                    dwColor1 &= 0xFFFFFF;
                }
            }
            SEND_VERTEX_RGBA_P2(__Permedia2TagV0FixedS, dwColor0);
            SEND_VERTEX_RGBA_P2(__Permedia2TagV1FixedS, dwColor1);
        }
    }
    else   // Flat shading
    {
        // Get vertex color value (FVF based) from the right vertex!
        if (dwColorOffs)
        {
            dwColor0  = FVFCOLOR(lpVFlat, dwColorOffs)->color;
            if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
            {
                dwColor0  |= 0xFF000000;
            }
        }
        else
        {
            // must set default in case no D3DFVF_DIFFUSE
            dwColor0  = 0xFFFFFFFF;
        }

        
        if (RENDER_MONO)
        {
            // Get constant color from the blue channel
            DWORD BlueChannel;
            BlueChannel = RGBA_GETBLUE(dwColor0);
            SEND_PERMEDIA_DATA(ConstantColor,
                            RGB_MAKE(BlueChannel, BlueChannel, BlueChannel));
        }
        else
        {
            if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
            {
                dwColor0 &= 0xFFFFFF;
            }
            SEND_PERMEDIA_DATA(ConstantColor,
                            RGBA_MAKE(RGBA_GETBLUE(dwColor0), 
                                      RGBA_GETGREEN(dwColor0),
                                      RGBA_GETRED(dwColor0), 
                                      RGBA_GETALPHA(dwColor0)));
        }
    }

    SEND_PERMEDIA_DATA(DrawLine01, ulRenderCmd);
    SEND_PERMEDIA_DATA(RasterizerMode, 0);
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting P2_Draw_FVF_Line"));
} // P2_Draw_FVF_Line

//-----------------------------------------------------------------------------
//
// void P2_Draw_FVF_Wire_Tri
//
//-----------------------------------------------------------------------------
void 
P2_Draw_FVF_Wire_Tri(PERMEDIA_D3DCONTEXT *pContext, 
                     LPD3DTLVERTEX lpV0, 
                     LPD3DTLVERTEX lpV1,
                     LPD3DTLVERTEX lpV2, 
                     LPP2FVFOFFSETS lpFVFOff)
{
    DBG_D3D((10,"Entering P2_Draw_FVF_Wire_Tri"));

    P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, lpFVFOff);
    P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV0, lpFVFOff);
    P2_Draw_FVF_Line(pContext, lpV2, lpV0, lpV0, lpFVFOff);

    DBG_D3D((10,"Exiting P2_Draw_FVF_Wire_Tri"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dpoint.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dpoint.c
*
* Content:    Direct3D hw point rasterization code.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3ddelta.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#if defined(_ALPHA_)
#include <math.h>
#endif

//-----------------------------------------------------------------------------
//
// VOID P2_Draw_FVF_Point
//
// Hardare render a single point coming from a FVF vertex
// 
// Primitive rendering at this stage is dependent upon the current value/setting
// of texturing, perspective correction, fogging, gouraud/flat shading, and
// specular highlights.
//
//-----------------------------------------------------------------------------
VOID
P2_Draw_FVF_Point(PERMEDIA_D3DCONTEXT  *pContext,
                  LPD3DTLVERTEX        lpV0, 
                  LPP2FVFOFFSETS       lpFVFOff)
{
    PPDev       pPdev       = pContext->ppdev;
    DWORD       dwFlags     = pContext->Hdr.Flags;
    ULONG       ulRenderCmd = pContext->RenderCommand;
    DWORD       dwColorOffs,dwSpecularOffs,dwTexOffs;
    D3DCOLOR    dwColor, dwSpecular;
    D3DVALUE    fKs, fS, fT, fQ;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering P2_Draw_FVF_Point"));

    // Set point rendering mode
    RENDER_POINT(ulRenderCmd);

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    RESERVEDMAPTR(0x80);
    SEND_PERMEDIA_DATA(RasterizerMode, BIAS_NEARLY_HALF);

    // Get vertex color value (FVF based)
    if (dwColorOffs)
    {
        dwColor = FVFCOLOR(lpV0, dwColorOffs)->color;
        if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
        {
            dwColor  |= 0xFF000000;
        }
    }
    else
    {
        // must set default in case no D3DFVF_DIFFUSE
        dwColor = 0xFFFFFFFF;
    }

    // Get vertex specular value (FVF based) if necessary
    if ((dwFlags & (CTXT_HAS_SPECULAR_ENABLED | CTXT_HAS_FOGGING_ENABLED))
        && (dwSpecularOffs != 0))
    {
        dwSpecular = FVFSPEC(lpV0, dwSpecularOffs)->specular;
    }

    if ((dwFlags & CTXT_HAS_TEXTURE_ENABLED) && (dwTexOffs != 0))
    {
        // Get s,t texture coordinates (FVF based)
        fS = FVFTEX(lpV0,dwTexOffs)->tu;
        fT = FVFTEX(lpV0,dwTexOffs)->tv;

        // Scale s,t coordinate values
        fS *= pContext->DeltaWidthScale;
        fT *= pContext->DeltaHeightScale;

        // Apply perpspective corrections if necessary
        if (dwFlags & CTXT_HAS_PERSPECTIVE_ENABLED)
        {
            fQ = lpV0->rhw;
            fS *= fQ;
            fT *= fQ;
        }
        else
        {
            fQ = 1.0;
        }

        // Send points s,t,q,ks (conditionaly),x,y,z values
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs != 0))
        {
            fKs = RGB256_TO_LUMA(RGB_GETRED(dwSpecular),
                                 RGB_GETGREEN(dwSpecular),
                                 RGB_GETBLUE(dwSpecular));

            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV0FloatS, fS, fT, fQ, fKs,
                                                  lpV0->sx, lpV0->sy, lpV0->sz);
        } 
        else 
        {
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV0FloatS, fS, fT, fQ, 
                                                  lpV0->sx, lpV0->sy, lpV0->sz);
        }
    }
    else // not textured point
    {
        // If specular is enabled, change the colours
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs != 0))
        {
            CLAMP8888(dwColor, dwColor, dwSpecular);
        }

        // Send lines x,y,z values
        SEND_VERTEX_XYZ(__Permedia2TagV0FloatS, lpV0->sx, lpV0->sy, lpV0->sz);
    }

    // If fog is set, send the appropriate value
    if ((dwFlags & CTXT_HAS_FOGGING_ENABLED) && (dwSpecularOffs != 0))
    {
        SEND_VERTEX_FOG(__Permedia2TagV0FixedF, RGB_GET_GAMBIT_FOG(dwSpecular));
    }

    // Send appropriate color depending on Gouraud , Mono, & Alpha
    if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
    {
        // Gouraud shading
        if (RENDER_MONO)
        {
            SEND_VERTEX_RGB_MONO_P2(__Permedia2TagV0FixedS, dwColor);
        }
        else
        {
            if (dwFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
                {
                    dwColor &= 0xFFFFFF;  // supress color's alpha value
                }
            }
            SEND_VERTEX_RGBA_P2(__Permedia2TagV0FixedS, dwColor);
        }
    }
    else        // Flat shading
    {
        if (RENDER_MONO)
        {
            // Get constant color from the blue channel
            DWORD BlueChannel = RGBA_GETBLUE(dwColor);
            SEND_PERMEDIA_DATA(ConstantColor,
                RGB_MAKE(BlueChannel, BlueChannel, BlueChannel));
        }
        else
        {
            if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
            {
                dwColor &= 0xFFFFFF;
            }
            SEND_PERMEDIA_DATA(ConstantColor,
                RGBA_MAKE(RGBA_GETBLUE(dwColor),
                          RGBA_GETGREEN(dwColor), 
                          RGBA_GETRED(dwColor), 
                          RGBA_GETALPHA(dwColor)));
        }
    }

    SEND_PERMEDIA_DATA(DrawLine01, ulRenderCmd);
    SEND_PERMEDIA_DATA(RasterizerMode, 0);
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting P2_Draw_FVF_Point"));

} // P2_Draw_FVF_Point

//-----------------------------------------------------------------------------
//
// void P2_Draw_FVF_Point_Tri
//
// Render a triangle with FVF vertexes when the point fillmode is active
//
//-----------------------------------------------------------------------------
void 
P2_Draw_FVF_Point_Tri(PERMEDIA_D3DCONTEXT *pContext, 
                      LPD3DTLVERTEX lpV0, 
                      LPD3DTLVERTEX lpV1,
                      LPD3DTLVERTEX lpV2, 
                      LPP2FVFOFFSETS lpFVFOff)
{
    D3DFVFDRAWPNTFUNCPTR       pPoint;

    DBG_D3D((10,"Entering P2_Draw_FVF_Point_Tri"));

    pPoint = __HWSetPointFunc(pContext, lpFVFOff);
    (*pPoint)(pContext, lpV0, lpFVFOff);
    (*pPoint)(pContext, lpV1, lpFVFOff);
    (*pPoint)(pContext, lpV2, lpFVFOff);

    DBG_D3D((10,"Exiting P2_Draw_FVF_Point_Tri"));

} // P2_Draw_FVF_Point_Tri

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
//-----------------------------------------------------------------------------
//
// void P2_Draw_FVF_Point_Sprite
//
// Render a point sprite with FVF vertexes when the point sprite enable is on
//
//-----------------------------------------------------------------------------
#define SPRITETEXCOORDMAX (4095.75F/4096.F)

void 
P2_Draw_FVF_Point_Sprite(PERMEDIA_D3DCONTEXT *pContext, 
                         LPD3DTLVERTEX lpV0, 
                         LPP2FVFOFFSETS lpFVFOff)
{
    P2FVFMAXVERTEX fvfVUL, fvfVUR, fvfVLL, fvfVLR;
    DWORD       dwColorOffs,dwSpecularOffs,dwTexOffs;
    D3DVALUE fPntSize, fPntSizeHalf;

    DBG_D3D((10,"Entering P2_Draw_FVF_Point_Sprite"));

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    // Compute point sprite size
    if (lpFVFOff->dwPntSizeOffset)
    {
        fPntSize = FVFPSIZE(lpV0, lpFVFOff->dwPntSizeOffset)->psize;
    }
    else
    {
        fPntSize = pContext->fPointSize;
    }

    // Initialize square values
    memcpy( &fvfVUL, lpV0, lpFVFOff->dwStride);
    memcpy( &fvfVUR, lpV0, lpFVFOff->dwStride);
    memcpy( &fvfVLL, lpV0, lpFVFOff->dwStride);
    memcpy( &fvfVLR, lpV0, lpFVFOff->dwStride);

    // Clamp point size to zero
    if (fPntSize > 0.0f)
        fPntSizeHalf =  fPntSize * 0.5f;
    else
        fPntSizeHalf = 0.0f;

    // Make this a square of size fPntSize
    ((D3DTLVERTEX *)&fvfVUL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVUL)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVUR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVUR)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVLL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVLL)->sy += fPntSizeHalf;

    ((D3DTLVERTEX *)&fvfVLR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)&fvfVLR)->sy += fPntSizeHalf;

    if ((pContext->bPointSpriteEnabled) && (dwTexOffs))
    {
        // Modify texture coordinates according to spec
        FVFTEX(&fvfVUL, dwTexOffs)->tu = 0.0f;
        FVFTEX(&fvfVUL, dwTexOffs)->tv = 0.0f;

        FVFTEX(&fvfVUR, dwTexOffs)->tu = SPRITETEXCOORDMAX;
        FVFTEX(&fvfVUR, dwTexOffs)->tv = 0.0f;

        FVFTEX(&fvfVLL, dwTexOffs)->tu = 0.0f;
        FVFTEX(&fvfVLL, dwTexOffs)->tv = SPRITETEXCOORDMAX;

        FVFTEX(&fvfVLR, dwTexOffs)->tu = SPRITETEXCOORDMAX;
        FVFTEX(&fvfVLR, dwTexOffs)->tv = SPRITETEXCOORDMAX;
    }


   // here we are going to send the required quad
    P2_Draw_FVF_Solid_Tri(pContext, (D3DTLVERTEX *)&fvfVUL,
                                    (D3DTLVERTEX *)&fvfVUR,
                                    (D3DTLVERTEX *)&fvfVLL, lpFVFOff);

    P2_Draw_FVF_Solid_Tri(pContext, (D3DTLVERTEX *)&fvfVLL,
                                    (D3DTLVERTEX *)&fvfVUR,
                                    (D3DTLVERTEX *)&fvfVLR, lpFVFOff);

    DBG_D3D((10,"Exiting P2_Draw_FVF_Point_Sprite"));
}
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dhw.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dhw.c
*
*  Content: Hardware dependent texture setup for D3D 
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "d3ddelta.h"
#include "dd.h"
#include "heap.h"
#include "d3dtxman.h"


//-----------------------------------------------------------------------------
//
// PERMEDIA_D3DTEXTURE *TextureHandleToPtr
//
// Find the texture associated to a given texture handle vale (which is to
// say , to a surface handle )
//
//-----------------------------------------------------------------------------

PERMEDIA_D3DTEXTURE *
TextureHandleToPtr(UINT_PTR thandle, PERMEDIA_D3DCONTEXT* pContext)
{

    //  only a DX7 context can get here
    ASSERTDD(NULL != pContext->pHandleList,
                       "pHandleList==NULL in TextureHandleToPtr");

    if (pContext->pHandleList->dwSurfaceList == NULL)
    {
        // avoid AV if our surface list is missing
        return NULL;
    }

    if ((PtrToUlong(pContext->pHandleList->dwSurfaceList[0]) > thandle) && 
        (0 != thandle))
    {
        return pContext->pHandleList->dwSurfaceList[(DWORD)thandle];
    }

    // Request for pointer for an invalid handle returns NULL
    return NULL;               
} // TextureHandleToPtr

//-----------------------------------------------------------------------------
//
// PERMEDIA_D3DTEXTURE *PaletteHandleToPtr
//
//-----------------------------------------------------------------------------

PERMEDIA_D3DPALETTE *
PaletteHandleToPtr(UINT_PTR phandle, PERMEDIA_D3DCONTEXT* pContext)
{
    ASSERTDD(NULL != pContext->pHandleList,
               "pHandleList==NULL in PaletteHandleToPtr");

    if ( (NULL != pContext->pHandleList->dwPaletteList) &&
         (PtrToUlong(pContext->pHandleList->dwPaletteList[0]) > phandle) &&
         (0 != phandle)
       )
    {
        return pContext->pHandleList->dwPaletteList[(DWORD)phandle];
    }
    return NULL;               
} // PaletteHandleToPtr


//-----------------------------------------------------------------------------
//
//void StorePermediaLODLevel
//
// Store private data specific to a level of detail
//
//-----------------------------------------------------------------------------
void 
StorePermediaLODLevel(PPDev ppdev, 
                      PERMEDIA_D3DTEXTURE* pTexture, 
                      LPDDRAWI_DDRAWSURFACE_LCL pSurf, 
                      int LOD)
{
    DWORD dwPartialWidth;
    int iPixelSize;

    DBG_D3D((10,"Entering StorePermediaLODLevel"));

    // if it's any surface type that's not created by driver
    // certainly there's no need to texture it
    if (NULL == pTexture->pTextureSurface)
        return; 

    // Get the BYTE Offset to the texture map
    if (DDSCAPS_NONLOCALVIDMEM & pTexture->dwCaps)
    {
        pTexture->MipLevels[LOD].PixelOffset = 
                (DWORD)(DD_AGPSURFACEPHYSICAL(pSurf->lpGbl) - ppdev->dwGARTDev);
    }
    else 
    {
        pTexture->MipLevels[LOD].PixelOffset = (DWORD)pSurf->lpGbl->fpVidMem;  
    }
    // .. Convert it to Pixels
    switch(pTexture->pTextureSurface->SurfaceFormat.PixelSize) 
    {
        case __PERMEDIA_4BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset <<= 1;
            break;
        case __PERMEDIA_8BITPIXEL: /* No Change*/
            break;
        case __PERMEDIA_16BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset >>= 1;
            break;
        case __PERMEDIA_24BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset /= 3;
            break;
        case __PERMEDIA_32BITPIXEL:
            pTexture->MipLevels[LOD].PixelOffset >>= 2;
            break;
        default:
            ASSERTDD(0,"Invalid Texture Pixel Size!");
            pTexture->MipLevels[LOD].PixelOffset >>= 1;
            break;
    }
    // P2 recognises that the texture is AGP if you set bit 30 to be 1.
    if (DDSCAPS_NONLOCALVIDMEM & pTexture->dwCaps)
    {
        pTexture->MipLevels[LOD].PixelOffset |= (1 << 30);
    }
    DBG_D3D((4,"Storing LOD: %d, Pitch: %d, Width: %d PixelOffset=%08lx", 
                LOD, pSurf->lpGbl->lPitch, 
                pSurf->lpGbl->wWidth,pTexture->MipLevels[LOD].PixelOffset));
    

    // Get the Partial Products for this LOD
    iPixelSize = pTexture->pTextureSurface->SurfaceFormat.PixelSize;

    if (iPixelSize == __PERMEDIA_4BITPIXEL)
    {
        dwPartialWidth = (pSurf->lpGbl->lPitch << 1);
    } 
    else 
    {
        if (iPixelSize != __PERMEDIA_24BITPIXEL)
        {
            dwPartialWidth = (pSurf->lpGbl->lPitch >> iPixelSize);
        } 
        else 
        {
            dwPartialWidth = pSurf->lpGbl->lPitch / 3;
        }
    }

    if (dwPartialWidth < 32) 
        dwPartialWidth = 32;

    vCalcPackedPP( dwPartialWidth, NULL, &pTexture->MipLevels[LOD].ulPackedPP);

    pTexture->MipLevels[LOD].logWidth = log2((int)pSurf->lpGbl->wWidth);
    pTexture->MipLevels[LOD].logHeight = log2((int)pSurf->lpGbl->wHeight);

    DBG_D3D((10,"Exiting StorePermediaLODLevel"));

} // StorePermediaLODLevel

//@@BEGIN_DDKSPLIT
// Note: we are currently not using more than 8MB of AGP memory
#if 0
//-----------------------------------------------------------------------------
//
//  BOOL CheckAGPTexturePage
//
// Check that the AGP texture we are about to use hasn't been placed
// in a different 8MB page. 
// dwGARTDev represents our current base address for the AGP texture memory
// dwGARTDevBase is the value we were passed at start of day
//-----------------------------------------------------------------------------

BOOL CheckAGPTexturePage(PPDev ppdev,
                         PERMEDIA_D3DCONTEXT* pContext,
                         PERMEDIA_D3DTEXTURE* pTexture,
                         LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    BOOL bChanged = FALSE;

    DBG_D3D((10,"Entering CheckAGPTexturePage"));

    ASSERTDD(pSurf, "ERROR: NULL Surface passed to CheckAGPTexturePage!");
 
        // Calculate the offset to the texture from the current 
        // base pointer in AGP memory
        UINT_PTR lSurfaceOffset = pTexture->lSurfaceOffset;
        UINT_PTR lTextureSize = pTexture->wHeight * pTexture->lPitch;

        // Account for a potential LUT added to the end of the surface
        lTextureSize += (256 * sizeof(DWORD));
        
        // If the texture falls outside the current 8Mb window 
        // then adjust the AGP base address
        if (lSurfaceOffset < ppdev->dwGARTLin ||
            ((lSurfaceOffset + lTextureSize - ppdev->dwGARTLin) >= 0x800000))
        {
            UINT_PTR dwNewGARTOffset = lSurfaceOffset;
            bChanged = TRUE;
        
            ppdev->dwGARTDev = ppdev->dwGARTDevBase + dwNewGARTOffset;
            ppdev->dwGARTLin = ppdev->dwGARTLinBase + dwNewGARTOffset;

            DBG_D3D((4,"Relocated AGP TextureBase Address "
                       "to : 0x%x (Base: 0x%x)", 
                       ppdev->dwGARTDev, ppdev->dwGARTDevBase));
        }

        //If the texture is in a different place relative to the base of 
        // AGP memory that we are using then update it
        if (pTexture->dwGARTDevLast != ppdev->dwGARTDev)
        {
            pTexture->dwGARTDevLast = ppdev->dwGARTDev;
            StorePermediaLODLevel(ppdev, pTexture, pSurf, 0);
        }

    DBG_D3D((10,"Exiting CheckAGPTexturePage"));

    return bChanged;
}
#endif
//@@END_DDKSPLIT

//-----------------------------------------------------------------------------
//
// void DisableTexturePermedia
//
// Disable texturing in P2
//
//-----------------------------------------------------------------------------
void 
DisableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext)
{
    DWORD* pFlags = &pContext->Hdr.Flags;
    PERMEDIA_D3DTEXTURE* pTexture = NULL;
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering DisableTexturePermedia"));

    pContext->FakeBlendNum &= ~FAKE_ALPHABLEND_MODULATE;
    
    // The textures have been turned off, so...
    ASSERTDD(pContext->CurrentTextureHandle == 0,
        "DisableTexturePermedia expected zero texture handle");

    DBG_D3D((4, "Disabling Texturing"));
    
    RESERVEDMAPTR(8);
    // Turn off texture address generation
    pSoftPermedia->TextureAddressMode.Enable = 0;
    COPY_PERMEDIA_DATA(TextureAddressMode, pSoftPermedia->TextureAddressMode);

    // Turn off texture reads
    pSoftPermedia->TextureReadMode.Enable = 0;
    COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
    
    // Turn off textures
    pSoftPermedia->TextureColorMode.TextureEnable = 0;
    COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);

    // Set the texture base address to 0
    // (turning off the 'AGP' bit in the process)
    // Also stop TexelLUTTransfer messages
    SEND_PERMEDIA_DATA(TextureBaseAddress, 0);
    SEND_PERMEDIA_DATA(TexelLUTTransfer, __PERMEDIA_DISABLE);


    // Set current texture to 0
    pContext->CurrentTextureHandle = 0;
    *pFlags &= ~CTXT_HAS_TEXTURE_ENABLED;
    RENDER_TEXTURE_DISABLE(pContext->RenderCommand);
    
    // If textures were in copy mode, we may have fiddled with the DDA,
    // to improve performance.
    if ((unsigned int)pSoftPermedia->TextureColorMode.ApplicationMode ==
        _P2_TEXTURE_COPY) 
    {
        if (*pFlags & CTXT_HAS_GOURAUD_ENABLED) 
        {
            pSoftPermedia->DeltaMode.SmoothShadingEnable = 1;

            COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
            pSoftPermedia->ColorDDAMode.UnitEnable = 1;
             // Smooth shade, DDA Enable
            COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);

        }
        else 
        {
            pSoftPermedia->DeltaMode.SmoothShadingEnable = 0;

            COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
            pSoftPermedia->ColorDDAMode.UnitEnable = 1;
             // Flat shade, DDA Enable
            COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);

        }
    }

    if (pContext->bCanChromaKey == TRUE) 
    {
        // Turn off Chroma Keying
        
        pSoftPermedia->YUVMode.TestMode = PM_YUVMODE_CHROMATEST_DISABLE;
        pSoftPermedia->YUVMode.Enable = __PERMEDIA_DISABLE;

        COPY_PERMEDIA_DATA(YUVMode, pSoftPermedia->YUVMode);

        pContext->bCanChromaKey = FALSE;
    }

    COMMITDMAPTR();

    DBG_D3D((10,"Exiting DisableTexturePermedia"));

    return;

} // DisableTexturePermedia

//-----------------------------------------------------------------------------
//
// void Convert_Chroma_2_8888ARGB
//
// Conversion of a chroma value into 32bpp ARGB
//
//-----------------------------------------------------------------------------
void
Convert_Chroma_2_8888ARGB(DWORD *pdwLowerBound, DWORD *pdwUpperBound,
                          DWORD dwRedMask, DWORD dwAlphaMask, DWORD dwPixelSize)
{
    DBG_D3D((10,"Entering Convert_Chroma_2_8888ARGB"));

    switch (dwPixelSize) {
    case __PERMEDIA_8BITPIXEL:
        if (dwRedMask == 0xE0)
        {
            // Never any alpha
            *pdwLowerBound = 
                CHROMA_LOWER_ALPHA(FORMAT_332_32BIT_BGR(*pdwLowerBound));
            *pdwUpperBound = 
                CHROMA_UPPER_ALPHA(FORMAT_332_32BIT_BGR(*pdwUpperBound));
        }
        else
        {
            *pdwLowerBound = FORMAT_2321_32BIT_BGR(*pdwLowerBound);
            *pdwUpperBound = FORMAT_2321_32BIT_BGR(*pdwUpperBound);
            if (!dwAlphaMask)
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
        }

        break;

    case __PERMEDIA_16BITPIXEL:
        switch (dwRedMask)
        {
        case 0xf00:
            *pdwLowerBound = (FORMAT_4444_32BIT_BGR(*pdwLowerBound));
            *pdwUpperBound = (FORMAT_4444_32BIT_BGR(*pdwUpperBound));
            if (!dwAlphaMask) 
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
            // Acount for the internal 8888 -> 4444 translation
            // which causes bilinear chroma keying to fail in
            // some cases
            *pdwLowerBound = *pdwLowerBound & 0xF0F0F0F0;
            *pdwUpperBound = *pdwUpperBound | 0x0F0F0F0F;

            break;
        case 0x7c00:
            *pdwLowerBound = FORMAT_5551_32BIT_BGR(*pdwLowerBound);
            *pdwUpperBound = FORMAT_5551_32BIT_BGR(*pdwUpperBound);
            if (!dwAlphaMask) 
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
            // Acount for the internal 8888 -> 5551 translation
            // which causes bilinear chroma keying to fail in
            // some cases
            *pdwLowerBound = *pdwLowerBound & 0x80F8F8F8;
            *pdwUpperBound = *pdwUpperBound | 0x7F070707;
            break;
        default:
            // Always supply full range of alpha values to ensure test 
            // is done
            *pdwLowerBound = 
                CHROMA_LOWER_ALPHA(FORMAT_565_32BIT_BGR(*pdwLowerBound));
            *pdwUpperBound = 
                CHROMA_UPPER_ALPHA(FORMAT_565_32BIT_BGR(*pdwUpperBound));
            if (!dwAlphaMask)
            {
                *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
                *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
            }
            // Acount for the internal 888 -> 565 translation
            // which causes bilinear chroma keying to fail in
            // some cases
            *pdwLowerBound = *pdwLowerBound & 0xF8F8FCF8;
            *pdwUpperBound = *pdwUpperBound | 0x07070307;
            break;
        }
        break;
    case __PERMEDIA_24BITPIXEL:
    case __PERMEDIA_32BITPIXEL:
        *pdwLowerBound = FORMAT_8888_32BIT_BGR(*pdwLowerBound);
        *pdwUpperBound = FORMAT_8888_32BIT_BGR(*pdwUpperBound);
        // If the surface isn't alpha'd then set a valid
        // range of alpha to catch all cases.
        if (!dwAlphaMask)
        {
            *pdwLowerBound = CHROMA_LOWER_ALPHA(*pdwLowerBound);
            *pdwUpperBound = CHROMA_UPPER_ALPHA(*pdwUpperBound);
        }
        break;
    }

    DBG_D3D((10,"Exiting Convert_Chroma_2_8888ARGB"));

} // Convert_Chroma_2_8888ARGB


//-----------------------------------------------------------------------------
//
// void EnableTexturePermedia
//
// Enable and setup texturing for pContext->CurrentTextureHandle
//
//-----------------------------------------------------------------------------
void 
EnableTexturePermedia(PERMEDIA_D3DCONTEXT* pContext)
{
    DWORD* pFlags = &pContext->Hdr.Flags;
    PERMEDIA_D3DTEXTURE* pTexture = NULL;
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);
    PERMEDIA_D3DPALETTE* pPalette=NULL;
    LPPALETTEENTRY lpColorTable=NULL;   // array of palette entries
    PPDev   ppdev = pContext->ppdev;

    DBG_D3D((10,"Entering EnableTexturePermedia %d",
        pContext->CurrentTextureHandle));

    pContext->FakeBlendNum &= ~FAKE_ALPHABLEND_MODULATE;

    // A texture has been turned on so ...
    ASSERTDD(pContext->CurrentTextureHandle != 0,
        "EnableTexturePermedia expected non zero texture handle");

    // We must be texturing so...
    pTexture = TextureHandleToPtr(pContext->CurrentTextureHandle, pContext);
    
    if (CHECK_D3DSURFACE_VALIDITY(pTexture)) 
    {
        PermediaSurfaceData* pPrivateData;
        DWORD cop = pContext->TssStates[D3DTSS_COLOROP];
        DWORD ca1 = pContext->TssStates[D3DTSS_COLORARG1];
        DWORD ca2 = pContext->TssStates[D3DTSS_COLORARG2];
        DWORD aop = pContext->TssStates[D3DTSS_ALPHAOP];
        DWORD aa1 = pContext->TssStates[D3DTSS_ALPHAARG1];

        // Current is the same as diffuse in stage 0
        if (ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;

        pPrivateData = pTexture->pTextureSurface;

        if (!CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData))
        {
            DBG_D3D((0,"EnableTexturePermedia get invalid pPrivateData=0x%x"
                " from SurfaceHandle=%d", pPrivateData,
                pContext->CurrentTextureHandle));
            pContext->CurrentTextureHandle = 0;

            // If the texture is bad, let's ensure it's marked as such. 
            pTexture->MagicNo = TC_MAGIC_DISABLE;

            goto Exit_EnableTexturePermedia;
        }

        if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            if (NULL==pPrivateData->fpVidMem)
            {
                TextureCacheManagerAllocNode(pContext,pTexture);
                if (NULL==pPrivateData->fpVidMem)
                {
                    DBG_D3D((0,"EnableTexturePermedia unable to allocate memory from heap"));
                    pContext->CurrentTextureHandle = 0;
                    goto Exit_EnableTexturePermedia;
                }
                pPrivateData->dwFlags |= P2_SURFACE_NEEDUPDATE;
            }
            TextureCacheManagerTimeStamp(pContext->pTextureManager,pTexture);
            if (pPrivateData->dwFlags & P2_SURFACE_NEEDUPDATE)
            {
                RECTL   rect;
                rect.left=rect.top=0;
                rect.right=pTexture->wWidth;
                rect.bottom=pTexture->wHeight;
                // texture download
                // Switch to DirectDraw context
                pPrivateData->dwFlags &= ~P2_SURFACE_NEEDUPDATE;
                // .. Convert it to Pixels

                pTexture->MipLevels[0].PixelOffset = 
                    (DWORD)(pPrivateData->fpVidMem);

                switch(pTexture->pTextureSurface->SurfaceFormat.PixelSize) 
                {
                    case __PERMEDIA_4BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset <<= 1;
                        break;
                    case __PERMEDIA_8BITPIXEL: /* No Change*/
                        break;
                    case __PERMEDIA_16BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset >>= 1;
                        break;
                    case __PERMEDIA_24BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset /= 3;
                        break;
                    case __PERMEDIA_32BITPIXEL:
                        pTexture->MipLevels[0].PixelOffset >>= 2;
                        break;
                    default:
                        ASSERTDD(0,"Invalid Texture Pixel Size!");
                        pTexture->MipLevels[0].PixelOffset >>= 1;
                        break;
                }
                PermediaPatchedTextureDownload(pContext->ppdev, 
                                           pPrivateData,
                                           pTexture->fpVidMem,
                                           pTexture->lPitch,
                                           &rect,
                                           pPrivateData->fpVidMem,
                                           pTexture->lPitch,
                                           &rect);

                //need to restore following registers
                RESERVEDMAPTR(7);
                SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
                COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
                SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
                SEND_PERMEDIA_DATA(FBWindowBase,0);   
                COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);
                COPY_PERMEDIA_DATA(AlphaBlendMode, pSoftPermedia->AlphaBlendMode);
                COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
                COMMITDMAPTR();

                DBG_D3D((10, "Copy from %08lx to %08lx w=%08lx h=%08lx p=%08lx b=%08lx",
                    pTexture->fpVidMem,pPrivateData->fpVidMem,pTexture->wWidth,
                    pTexture->wHeight,pTexture->lPitch,pTexture->dwRGBBitCount));
            }
        }        
        // If it is a palette indexed texture, we simply follow the chain
        // down from the surface to it's palette and pull out the LUT values
        // from the PALETTEENTRY's in the palette.
        if (pPrivateData->SurfaceFormat.Format == PERMEDIA_8BIT_PALETTEINDEX ||
            pPrivateData->SurfaceFormat.Format == PERMEDIA_4BIT_PALETTEINDEX) 
        {
            pPalette = 
                    PaletteHandleToPtr(pTexture->dwPaletteHandle,pContext);
            if (NULL != pPalette)
            {
                //some apps are not setting their alpha correctly with palette
                //then it's up to palette to tell us
                pPrivateData->SurfaceFormat.bAlpha =
                    pPalette->dwFlags & DDRAWIPAL_ALPHA;
            }
        }

        if ((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) &&
             cop == D3DTOP_MODULATE &&
             (aa1 == D3DTA_TEXTURE && aop == D3DTOP_LEGACY_ALPHAOVR)) 
        {
            // if this is legacy modulation then we take the texture alpha
            // only if the texure format has it
            if (pPrivateData->SurfaceFormat.bAlpha)
                pContext->FakeBlendNum |= FAKE_ALPHABLEND_MODULATE;
        }
        else if ((ca2 == D3DTA_DIFFUSE && ca1 == D3DTA_TEXTURE) &&
             cop == D3DTOP_MODULATE &&
             (aa1 == D3DTA_TEXTURE && aop == D3DTOP_SELECTARG1)) 
        {
            // if this is DX6 modulation then we take the texture alpha
            // no matter what ( it will be xFF if it doesn't exist)
            pContext->FakeBlendNum |= FAKE_ALPHABLEND_MODULATE;
        }

        // Enable Texture Address calculation
        pSoftPermedia->TextureAddressMode.Enable = 1;
            
        // Enable Textures
        pSoftPermedia->TextureColorMode.TextureEnable = 1;
        if (*pFlags & CTXT_HAS_SPECULAR_ENABLED)
        {
            pSoftPermedia->DeltaMode.SpecularTextureEnable = 1;
            pSoftPermedia->TextureColorMode.KsDDA = 1; 
            pSoftPermedia->TextureColorMode.ApplicationMode |= 
                                                         _P2_TEXTURE_SPECULAR;
        } 
        else 
        {
            pSoftPermedia->DeltaMode.SpecularTextureEnable = 0;
            pSoftPermedia->TextureColorMode.KsDDA = 0; 
            pSoftPermedia->TextureColorMode.ApplicationMode &= 
                                                        ~_P2_TEXTURE_SPECULAR;
        }

        // reserve here for all cases in this function!!
        RESERVEDMAPTR(272);
        
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

        // Set Partial products for texture (assume no mipmapping).
        pSoftPermedia->TextureMapFormat.PackedPP = 
            pTexture->MipLevels[0].ulPackedPP;

        pSoftPermedia->TextureMapFormat.TexelSize = 
                                        pPrivateData->SurfaceFormat.PixelSize;

        if (pPrivateData->dwFlags & P2_ISPATCHED)
        {
            DBG_D3D((4,"   Enabling Patching for this texture"));
            pSoftPermedia->TextureMapFormat.SubPatchMode = 1;
        } 
        else 
        {
            pSoftPermedia->TextureMapFormat.SubPatchMode = 0;
        }

        DBG_D3D((4, "    Texel Size: 0x%x", 
                 pPrivateData->SurfaceFormat.PixelSize));

        // Set texture size
        DBG_D3D((4,"     Texture Width: 0x%x", 
                 pTexture->MipLevels[0].logWidth));
        DBG_D3D((4,"     Texture Height: 0x%x", 
                 pTexture->MipLevels[0].logHeight));

        pSoftPermedia->TextureReadMode.Width = 
                                       pTexture->MipLevels[0].logWidth;
        pSoftPermedia->TextureReadMode.Height = 
                                       pTexture->MipLevels[0].logHeight;

        pSoftPermedia->TextureReadMode.Enable = 1;
        pContext->DeltaWidthScale = (float)pTexture->wWidth * (1 / 2048.0f);
        pContext->DeltaHeightScale = (float)pTexture->wHeight * (1 / 2048.0f);

        pContext->MaxTextureXf = (float)(2048 / pTexture->wWidth);
        pContext->MaxTextureYf = (float)(2048 / pTexture->wHeight);

        myFtoui(&pContext->MaxTextureXi, pContext->MaxTextureXf);
        pContext->MaxTextureXi -= 1;
        myFtoui(&pContext->MaxTextureYi, pContext->MaxTextureYf);
        pContext->MaxTextureYi -= 1;

        *pFlags |= CTXT_HAS_TEXTURE_ENABLED;
        RENDER_TEXTURE_ENABLE(pContext->RenderCommand);
        
        DBG_D3D((4,"     Texture Format: 0x%x", 
                 pPrivateData->SurfaceFormat.Format));
        DBG_D3D((4,"     Texture Format Extension: 0x%x", 
                 pPrivateData->SurfaceFormat.FormatExtension));

        pSoftPermedia->TextureDataFormat.TextureFormat = 
                                            pPrivateData->SurfaceFormat.Format;
        pSoftPermedia->TextureDataFormat.TextureFormatExtension = 
                                   pPrivateData->SurfaceFormat.FormatExtension;

        if (pPrivateData->SurfaceFormat.bAlpha) 
        {
            pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 0;
        } 
        else 
        {
            pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 1;
        }

        // If we are copying textures, there is no need for colour data
        // to be generated, so we turn off the DDA
        if (((unsigned int)pSoftPermedia->TextureColorMode.ApplicationMode) == 
                                                              _P2_TEXTURE_COPY)
        {
            pSoftPermedia->ColorDDAMode.UnitEnable = 0;
            DBG_D3D((4, "    Disabling DDA"));
        }
        else
        {
            pSoftPermedia->ColorDDAMode.UnitEnable = 1;
            DBG_D3D((4, "    Enabling DDA"));
        }
        
        // Load the texture base address BEFORE the TexelLUTTransfer message 
        // to ensure we load the LUT from the right sort of memory (AGP or not)
        // Always set the base address at the root texture (not the miplevels 
        // if there are any)
        DBG_D3D((4, "Setting texture base address to 0x%08X", 
                 pTexture->MipLevels[0].PixelOffset));
        SEND_PERMEDIA_DATA(TextureBaseAddress, 
                           pTexture->MipLevels[0].PixelOffset);

        // If it is a palette indexed texture, we simply follow the chain
        // down from the surface to it's palette and pull out the LUT values
        // from the PALETTEENTRY's in the palette.
        if (pPrivateData->SurfaceFormat.Format == PERMEDIA_8BIT_PALETTEINDEX) 
        {

            if (NULL != pPalette)
            {
                int i;
                lpColorTable = pPalette->ColorTable;
                

                if (pPalette->dwFlags & DDRAWIPAL_ALPHA)
                {
                    for (i = 0; i < 256; i++)
                    {
                        SEND_PERMEDIA_DATA(TexelLUTData, *(DWORD*)lpColorTable);
                        lpColorTable++;
                    }
                }
                else
                {
                    for (i = 0; i < 256; i++)
                    {
                        SEND_PERMEDIA_DATA(TexelLUTData,
                            CHROMA_UPPER_ALPHA(*(DWORD*)lpColorTable));
                        lpColorTable++;
                    }
                }

                SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_ENABLE);

                DBG_D3D((4,"Texel LUT pPalette->dwFlags=%08lx bAlpha=%d", 
                    pPalette->dwFlags,pPrivateData->SurfaceFormat.bAlpha));

                // Must reset the LUT index on Permedia P2
                SEND_PERMEDIA_DATA(TexelLUTIndex, 0);
                
            }
            else
            {
                DBG_D3D((0, "NULL == pPalette in EnableTexturePermedia"
                    "dwPaletteHandle=%08lx dwSurfaceHandle=%08lx",
                    pTexture->dwPaletteHandle,
                    pContext->CurrentTextureHandle)); 
            }
        } 
        else if (pPrivateData->SurfaceFormat.Format == 
                                                    PERMEDIA_4BIT_PALETTEINDEX)
        {
            if (NULL != pPalette)
            {
                int i;
                lpColorTable = pPalette->ColorTable;
                
                SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_ENABLE);

                if (pPalette->dwFlags & DDRAWIPAL_ALPHA)
                {
                    for (i = 0; i < 16; i++)
                    {
                        SEND_PERMEDIA_DATA_OFFSET(TexelLUT0,
                                                *(DWORD*)lpColorTable,i);
                        lpColorTable++;
                    }
                }
                else
                {
                    for (i = 0; i < 16; i++)
                    {
                        SEND_PERMEDIA_DATA_OFFSET(TexelLUT0,
                            CHROMA_UPPER_ALPHA(*(DWORD*)lpColorTable),i);
                        lpColorTable++;
                    }
                }
                

                // Must reset the LUT index on Permedia P2
                
                SEND_PERMEDIA_DATA(TexelLUTIndex, 0);
                SEND_PERMEDIA_DATA(TexelLUTTransfer, __PERMEDIA_DISABLE);
            
            }
            else
            {
                DBG_D3D((0, "NULL == pPalette in EnableTexturePermedia"
                    "dwPaletteHandle=%08lx dwSurfaceHandle=%08lx",
                    pTexture->dwPaletteHandle,
                    pContext->CurrentTextureHandle)); 
            }
        }
        else
        {
            // Not palette indexed
            
            SEND_PERMEDIA_DATA(TexelLUTMode, __PERMEDIA_DISABLE);
            
        }

        if ((pTexture->dwFlags & DDRAWISURF_HASCKEYSRCBLT)
            && (pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])) 
        {
            DWORD LowerBound = pTexture->dwKeyLow;
            DWORD UpperBound = pTexture->dwKeyHigh;
            DWORD dwLowIndexColor;

            pContext->bCanChromaKey = TRUE;
            
            DBG_D3D((4,"    Can Chroma Key the texture"));
            // Enable Chroma keying for the texture
            // ..and set the correct colour

            // Evaluate the new chroma key value.  Shouldn't be too expensive,
            // as it is only bit shifts and a couple of tests.
            // We also change only when the texture map has changed.
            DBG_D3D((4, "dwColorSpaceLow = 0x%08X", LowerBound));
            DBG_D3D((4, "dwColorSpaceHigh = 0x%08X", UpperBound));

            if (NULL != pPalette) 
            {
                if (pPrivateData->SurfaceFormat.Format == 
                                                    PERMEDIA_4BIT_PALETTEINDEX)
                {
                    LowerBound &= 0x0F;
                }
                else
                {
                    LowerBound &= 0xFF;
                }
                lpColorTable = pPalette->ColorTable;

                // ChromaKeying for 4/8 Bit textures is done on the looked up 
                // color, not the index. This means using a range is 
                // meaningless and we have to lookup the color from the 
                // palette.  Make sure the user doesn't force us to access 
                // invalid memory.
                dwLowIndexColor = *(DWORD*)(&lpColorTable[LowerBound]);
                if (pPalette->dwFlags & DDRAWIPAL_ALPHA)
                {
                    LowerBound = UpperBound = dwLowIndexColor;
                }
                else
                {
                    LowerBound = CHROMA_LOWER_ALPHA(dwLowIndexColor);
                    UpperBound = CHROMA_UPPER_ALPHA(dwLowIndexColor);
                }
                DBG_D3D((4,"PaletteHandle=%08lx Lower=%08lx ChromaColor=%08lx"
                    "lpColorTable=%08lx dwFlags=%08lx",
                    pTexture->dwPaletteHandle, LowerBound, dwLowIndexColor,
                    lpColorTable, pPalette->dwFlags));
            }
            else 
                Convert_Chroma_2_8888ARGB(&LowerBound,
                                      &UpperBound,
                                      pPrivateData->SurfaceFormat.RedMask,
                                      pPrivateData->SurfaceFormat.AlphaMask,
                                      pPrivateData->SurfaceFormat.PixelSize);

            DBG_D3D((4,"LowerBound Selected: 0x%x", LowerBound));
            DBG_D3D((4,"UpperBound Selected: 0x%x", UpperBound));

            // If it's a P2 we can use alpha mapping to 
            // improve bilinear chroma keying.
            if (0/*(unsigned int)pSoftPermedia->TextureReadMode.FilterMode == 1*/)
            {
                pSoftPermedia->TextureDataFormat.AlphaMap = 
                                             PM_TEXDATAFORMAT_ALPHAMAP_EXCLUDE;
                pSoftPermedia->TextureDataFormat.NoAlphaBuffer = 1;
                
                SEND_PERMEDIA_DATA(AlphaMapUpperBound, UpperBound);
                SEND_PERMEDIA_DATA(AlphaMapLowerBound, LowerBound);
                SEND_PERMEDIA_DATA(ChromaUpperBound, 0xFFFFFFFF);
                SEND_PERMEDIA_DATA(ChromaLowerBound, 0xFF000000);
                
                pSoftPermedia->YUVMode.TestMode = 
                                               PM_YUVMODE_CHROMATEST_PASSWITHIN;
            }
            else
            {
                pSoftPermedia->TextureDataFormat.AlphaMap =  
                                              PM_TEXDATAFORMAT_ALPHAMAP_DISABLE;
                
                SEND_PERMEDIA_DATA(ChromaUpperBound, UpperBound);
                SEND_PERMEDIA_DATA(ChromaLowerBound, LowerBound);
                

                pSoftPermedia->YUVMode.TestMode = 
                                               PM_YUVMODE_CHROMATEST_FAILWITHIN;
            }
        }
        else
        {
            DBG_D3D((2,"    Can't Chroma Key the texture"));
            pContext->bCanChromaKey = FALSE;
            pSoftPermedia->TextureDataFormat.AlphaMap = __PERMEDIA_DISABLE;
            pSoftPermedia->YUVMode.TestMode = PM_YUVMODE_CHROMATEST_DISABLE;
        }
        

        // Restore the filter mode from the mag filter.
        if (pContext->bMagFilter) 
        {
            pSoftPermedia->TextureReadMode.FilterMode = 1;
        }
        else 
        {
            pSoftPermedia->TextureReadMode.FilterMode = 0;
        }

        // If the texture is a YUV texture we need to change the color order
        // of the surface and turn on the YUV->RGB conversoin
        if (pPrivateData->SurfaceFormat.Format == PERMEDIA_YUV422) 
        {
            pSoftPermedia->YUVMode.Enable = __PERMEDIA_ENABLE;
            pSoftPermedia->TextureDataFormat.ColorOrder = INV_COLOR_MODE;
        }
        else 
        {
            pSoftPermedia->YUVMode.Enable = __PERMEDIA_DISABLE;
            pSoftPermedia->TextureDataFormat.ColorOrder = COLOR_MODE;
        }   

        // Send the Commands at the end (except the texture base address!!)
        
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COPY_PERMEDIA_DATA(TextureDataFormat, pSoftPermedia->TextureDataFormat);
        COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
        COPY_PERMEDIA_DATA(TextureMapFormat, pSoftPermedia->TextureMapFormat);
        COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);
        COPY_PERMEDIA_DATA(YUVMode, pSoftPermedia->YUVMode);
        COPY_PERMEDIA_DATA(TextureAddressMode, 
                                             pSoftPermedia->TextureAddressMode);

        COMMITDMAPTR();
        FLUSHDMA();
    }
    else 
    {
        DBG_D3D((0,"Invalid Texture handle (%d)!, doing nothing", 
                 pContext->CurrentTextureHandle));
        pContext->CurrentTextureHandle = 0;

        // If the texture is bad, let's ensure it's marked as such.
        // But only if the texture is actually there!!
        if (pTexture) 
            pTexture->MagicNo = TC_MAGIC_DISABLE;     
    }


Exit_EnableTexturePermedia:

    DBG_D3D((10,"Exiting EnableTexturePermedia"));

} // EnableTexturePermedia

//-----------------------------------------------------------------------------
//
// void: __PermediaDisableUnits
//
// Disables all the mode registers to give us a clean start.
//
//-----------------------------------------------------------------------------
void 
__PermediaDisableUnits(PERMEDIA_D3DCONTEXT* pContext)
{
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering __PermediaDisableUnits"));

    RESERVEDMAPTR(28);

    SEND_PERMEDIA_DATA(RasterizerMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AreaStippleMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ScissorMode,          __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(ColorDDAMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FogMode,              __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(LBReadMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(Window,               __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(StencilMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(DepthMode,            __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(LBWriteMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBReadMode,           __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(DitherMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AlphaBlendMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LogicalOpMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBWriteMode,          __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(StatisticMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FilterMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBSourceData,         __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(LBWriteFormat,        __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(TextureReadMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureMapFormat,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureDataFormat,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTMode,         __PERMEDIA_DISABLE);

    SEND_PERMEDIA_DATA(TextureColorMode,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AStart,               PM_BYTE_COLOR(0xFF));

    // Ensure AGP bit not set.
    SEND_PERMEDIA_DATA(TextureBaseAddress,   0);
    SEND_PERMEDIA_DATA(TexelLUTIndex,        0);
    SEND_PERMEDIA_DATA(TexelLUTTransfer,     __PERMEDIA_DISABLE);

    COMMITDMAPTR();
    FLUSHDMA();

    DBG_D3D((10,"Exiting __PermediaDisableUnits"));

} // __PermediaDisableUnits


#ifdef DBG

//-----------------------------------------------------------------------------
//
// void DumpTexture
//
// Debug dump of texture information
//
//-----------------------------------------------------------------------------
void 
DumpTexture(PPDev ppdev, 
            PERMEDIA_D3DTEXTURE* pTexture, 
            DDPIXELFORMAT* pPixelFormat)
{
    DBG_D3D((4, "\n** Texture Dump:"));

    DBG_D3D((4,"  Texture Width: %d", pTexture->wWidth));
    DBG_D3D((4,"  Texture Height: %d", pTexture->wHeight));

    if (NULL != pTexture->pTextureSurface)
    {
        DBG_D3D((4,"  LogWidth: %d", 
                 pTexture->MipLevels[0].logWidth));
        DBG_D3D((4,"  LogHeight: %d", 
                 pTexture->MipLevels[0].logHeight));
        DBG_D3D((4,"  PackedPP0: 0x%x", 
            pTexture->pTextureSurface->ulPackedPP));
    }
    DBG_D3D((4,"  Pixel Offset of Texture (PERMEDIA Chip): 0x%x", 
             pTexture->MipLevels[0].PixelOffset));
    
    // Show texture format
    if (pPixelFormat->dwRGBAlphaBitMask == 0xf000) 
    {
        DBG_D3D((4,"  Texture is 4:4:4:4"));
    }
    else if (pPixelFormat->dwRBitMask == 0xff0000) 
    {
        if (pPixelFormat->dwRGBAlphaBitMask != 0) 
        {
            DBG_D3D((4,"  Texture is 8:8:8:8"));
        }
        else 
        {
            DBG_D3D((4,"  Texture is 8:8:8"));
        }
    }
    else if (pPixelFormat->dwRBitMask == 0x7c00) 
    {
        if (pPixelFormat->dwRGBAlphaBitMask != 0) 
        {
            DBG_D3D((4,"  Texture is 1:5:5:5"));
        }
        else 
        {
            DBG_D3D((4,"  Texture is 5:5:5"));
        }
    }
    else if (pPixelFormat->dwRBitMask == 0xf800) 
    {
        DBG_D3D((4,"  Texture is 5:6:5"));
    }
    else if (pPixelFormat->dwRBitMask == 0xe0) 
    {
        DBG_D3D((4,"  Texture is 3:3:2"));
    }
} // DumpTexture
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3ddx6.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddx6.c
*
*  Content:    Direct3D DX6 Callback function interface
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "dd.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_6D2P
//-----------------------------------------------------------------------------
//
// DX6 allows driver-level acceleration of the new vertex-buffer API. It 
// allows data and commands, indices and statechanges to be contained in 
// two separate DirectDraw surfaces. The DirectDraw surfaces can reside 
// in system, AGP, or video memory depending on the type of allocation
// requested by the user  The interface is designed to accomodate legacy
// ExecuteBuffer applications with no driver impact. This allows higher 
// performance on both legacy applications as well as the highest 
// possible performance through the vertex buffer API.
//
//-----------------------------------------------------------------------------

#define STARTVERTEXSIZE (sizeof(D3DHAL_DP2STARTVERTEX))

// Macros for updating properly our instruction pointer to our next instruction
// in the command buffer
#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                            \
        NEXTINSTRUCTION_S(ptr, sizeof(type), num, extrabytes)

#define NEXTINSTRUCTION_S(ptr, typesize, num, extrabytes)                      \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +      \
                                ((num) * (typesize)) + (extrabytes))

// Error reporting macro , sets up error code and exits DrawPrimitives2
#define PARSE_ERROR_AND_EXIT( pDP2Data, pIns, pStartIns, ddrvalue)             \
   {                                                                           \
            pDP2Data->dwErrorOffset = (DWORD)((LPBYTE)pIns-(LPBYTE)pStartIns); \
            pDP2Data->ddrval = ddrvalue;                                       \
            goto Exit_DrawPrimitives2;                                         \
   }

// Macros for verifying validity of the command and vertex buffers. This MUST
// be done by the driver even on free builds as the runtime avoids this check
// in order to not parse the command buffer too. 
#define CHECK_CMDBUF_LIMITS( pDP2Data, pBuf, type, num, extrabytes)            \
        CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, sizeof(type), num, extrabytes)

#define CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, typesize, num, extrabytes)      \
   {                                                                           \
        LPBYTE pBase,pEnd,pBufEnd;                                             \
        pBase = (LPBYTE)(pDP2Data->lpDDCommands->lpGbl->fpVidMem +             \
                        pDP2Data->dwCommandOffset);                            \
        pEnd  = pBase + pDP2Data->dwCommandLength;                             \
        pBufEnd = ((LPBYTE)pBuf + ((num) * (typesize)) + (extrabytes) - 1);    \
        if (! ((LPBYTE)pBufEnd < pEnd) && ( pBase <= (LPBYTE)pBuf))            \
        {                                                                      \
            DBG_D3D((0,"DX6 D3D: Trying to read past Command Buffer limits "   \
                    "%x %x %x %x",pBase ,(LPBYTE)pBuf, pBufEnd, pEnd ));       \
            PARSE_ERROR_AND_EXIT( pDP2Data, lpIns, lpInsStart,                 \
                                  D3DERR_COMMAND_UNPARSED      );              \
        }                                                                      \
    }

#define CHECK_DATABUF_LIMITS( pDP2Data, iIndex)                                \
   {                                                                           \
        if (! (((LONG)iIndex >= 0) &&                                          \
               ((LONG)iIndex <(LONG)pDP2Data->dwVertexLength)))                \
        {                                                                      \
            DBG_D3D((0,"DX6 D3D: Trying to read past Vertex Buffer limits "    \
                "%d limit= %d ",(LONG)iIndex, (LONG)pDP2Data->dwVertexLength));\
            PARSE_ERROR_AND_EXIT( pDP2Data, lpIns, lpInsStart,                 \
                                  D3DERR_COMMAND_UNPARSED      );              \
        }                                                                      \
    }

// Macros for accessing vertexes in the vertex buffer based on an index or on
// a previous accessed vertex
#define LP_FVF_VERTEX(lpBaseAddr, wIndex, P2FVFOffs)                           \
         (LPD3DTLVERTEX)((LPBYTE)(lpBaseAddr) + (wIndex) * (P2FVFOffs).dwStride)

#define LP_FVF_NXT_VTX(lpVtx, P2FVFOffs )                                      \
         (LPD3DTLVERTEX)((LPBYTE)(lpVtx) + (P2FVFOffs).dwStride)


// Forward declaration of utility functions
DWORD __CheckFVFRequest(DWORD dwFVF, LPP2FVFOFFSETS lpP2FVFOff);

D3DFVFDRAWTRIFUNCPTR __HWSetTriangleFunc(PERMEDIA_D3DCONTEXT *pContext);

HRESULT  __Clear( PERMEDIA_D3DCONTEXT* pContext,
              DWORD   dwFlags,
              DWORD   dwFillColor,
              D3DVALUE dvFillDepth,
              DWORD   dwFillStencil,
              LPD3DRECT lpRects,
              DWORD   dwNumRects);

HRESULT  __TextureBlt(PERMEDIA_D3DCONTEXT* pContext,
                D3DHAL_DP2TEXBLT* lpdp2texblt);

HRESULT  __SetRenderTarget(PERMEDIA_D3DCONTEXT* pContext,
                     DWORD hRenderTarget,
                     DWORD hZBuffer);

HRESULT  __PaletteUpdate(PERMEDIA_D3DCONTEXT* pContext,
                     DWORD dwPaletteHandle, 
                     WORD wStartIndex, 
                     WORD wNumEntries,
                     BYTE * pPaletteData);

HRESULT  __PaletteSet(PERMEDIA_D3DCONTEXT* pContext,
                  DWORD dwSurfaceHandle,
                  DWORD dwPaletteHandle,
                  DWORD dwPaletteFlags);

void __BeginStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __EndStateSet(PERMEDIA_D3DCONTEXT*);

void __DeleteStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __ExecuteStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __CaptureStateSet(PERMEDIA_D3DCONTEXT*, DWORD);

void __RestoreD3DContext(PPDev ppdev, PERMEDIA_D3DCONTEXT* pContext);

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DDrawPrimitives2
//
// The D3DDrawPrimitives2 callback is filled in by drivers which directly 
// support the rendering primitives using the new DDI. If this entry is
// left as NULL, the API will be emulated through DX5-level HAL interfaces.
//
// PARAMETERS
//
//      lpdp2d   This structure is used when D3DDrawPrimitives2 is called 
//               to draw a set of primitives using a vertex buffer. The
//               surface specified by the lpDDCommands in 
//               D3DHAL_DRAWPRIMITIVES2DATA contains a sequence of 
//               D3DHAL_DP2COMMAND structures. Each D3DHAL_DP2COMMAND 
//               specifies either a primitive to draw, a state change to
//               process, or a re-base command.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK 
D3DDrawPrimitives2( LPD3DHAL_DRAWPRIMITIVES2DATA lpdp2d )
{
    LPDDRAWI_DDRAWSURFACE_LCL lpCmdLcl, lpDataLcl;
    LPD3DHAL_DP2COMMAND       lpIns, lpResumeIns;  
    LPD3DTLVERTEX             lpVertices=NULL, lpV0, lpV1, lpV2, lpV3;
    LPBYTE                    lpInsStart, lpPrim;
    PERMEDIA_D3DCONTEXT       *pContext;
    UINT                      i,j;
    WORD                      wCount, wIndex, wIndex1, wIndex2, wIndex3,
                              wFlags, wIndxBase;
    HRESULT                   ddrval;
    P2FVFOFFSETS              P2FVFOff;
    D3DHAL_DP2TEXTURESTAGESTATE *lpRState;
    D3DFVFDRAWTRIFUNCPTR       pTriangle;
    D3DFVFDRAWPNTFUNCPTR       pPoint;
    DWORD                     dwEdgeFlags;

    DBG_D3D((6,"Entering D3DDrawPrimitives2"));

    DBG_D3D((8,"  dwhContext = %x",lpdp2d->dwhContext));
    DBG_D3D((8,"  dwFlags = %x",lpdp2d->dwFlags));
    DBG_D3D((8,"  dwVertexType = %d",lpdp2d->dwVertexType));
    DBG_D3D((8,"  dwCommandOffset = %d",lpdp2d->dwCommandOffset));
    DBG_D3D((8,"  dwCommandLength = %d",lpdp2d->dwCommandLength));
    DBG_D3D((8,"  dwVertexOffset = %d",lpdp2d->dwVertexOffset));
    DBG_D3D((8,"  dwVertexLength = %d",lpdp2d->dwVertexLength));

    // Retrieve permedia d3d context from context handle
    pContext = (PERMEDIA_D3DCONTEXT*)ContextSlots[lpdp2d->dwhContext];

    // Check if we got a valid context
    CHK_CONTEXT(pContext, lpdp2d->ddrval, "DrawPrimitives2");

    PPDev ppdev = pContext->ppdev;
    PERMEDIA_DEFS(ppdev);
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    
    // Switch hw context, and force the next switch to wait for the Permedia
    SET_CURRENT_D3D_CONTEXT(pContext->hPermediaContext);

    // Restore our D3D rendering context
    __RestoreD3DContext(ppdev, pContext);

    // Get appropriate pointers to command buffer
    lpInsStart = (LPBYTE)(lpdp2d->lpDDCommands->lpGbl->fpVidMem);
    if (lpInsStart == NULL)
    {
        DBG_D3D((0,"DX6 Command Buffer pointer is null"));
        lpdp2d->ddrval = DDERR_INVALIDPARAMS;
        goto Exit_DrawPrimitives2;
    }
    lpIns = (LPD3DHAL_DP2COMMAND)(lpInsStart + lpdp2d->dwCommandOffset);

    // Check if the FVF format being passed is valid. 
    if (__CheckFVFRequest(lpdp2d->dwVertexType, &P2FVFOff) != DD_OK)
    {
        DBG_D3D((0,"DrawPrimitives2 cannot handle "
                   "Flexible Vertex Format requested"));
        PARSE_ERROR_AND_EXIT(lpdp2d, lpIns, lpInsStart,
                             D3DERR_COMMAND_UNPARSED);
    }

    // Process commands while we haven't exhausted the command buffer
    while ((LPBYTE)lpIns < 
           (lpInsStart + lpdp2d->dwCommandLength + lpdp2d->dwCommandOffset))  
    {
        // Get pointer to first primitive structure past the D3DHAL_DP2COMMAND
        lpPrim = (LPBYTE)lpIns + sizeof(D3DHAL_DP2COMMAND);

        DBG_D3D((4,"D3DDrawPrimitive2: parsing instruction %d count = %d @ %x", 
                lpIns->bCommand, lpIns->wPrimitiveCount, lpIns));

        // If our next command involves some actual rendering, we have to make
        // sure that our rendering context is realized
        switch( lpIns->bCommand )
        {
        case D3DDP2OP_POINTS:
        case D3DDP2OP_LINELIST:
        case D3DDP2OP_INDEXEDLINELIST:
        case D3DDP2OP_INDEXEDLINELIST2:
        case D3DDP2OP_LINESTRIP:
        case D3DDP2OP_INDEXEDLINESTRIP:
        case D3DDP2OP_TRIANGLELIST:
        case D3DDP2OP_INDEXEDTRIANGLELIST:
        case D3DDP2OP_INDEXEDTRIANGLELIST2:
        case D3DDP2OP_TRIANGLESTRIP:
        case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        case D3DDP2OP_TRIANGLEFAN:
        case D3DDP2OP_INDEXEDTRIANGLEFAN:
            
            // Check if vertex buffer resides in user memory or in a DDraw surface
            if (NULL == lpVertices)
            {
                if (NULL == lpdp2d->lpVertices)
                {
                    DBG_D3D((0,"DX6 Vertex Buffer pointer is null"));
                    lpdp2d->ddrval = DDERR_INVALIDPARAMS;
                    goto Exit_DrawPrimitives2;
                }            
                if (lpdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
                {
                    // Get appropriate pointer to vertices , memory is already secured
                    lpVertices = (LPD3DTLVERTEX)((LPBYTE)lpdp2d->lpVertices + 
                                                         lpdp2d->dwVertexOffset);
                } 
                else 
                {
                    // Get appropriate pointer to vertices 
                    lpVertices = 
                       (LPD3DTLVERTEX)((LPBYTE)lpdp2d->lpDDVertex->lpGbl->fpVidMem
                                                                 + lpdp2d->dwVertexOffset);
                }

                if (NULL == lpVertices)
                {
                    DBG_D3D((0,"DX6 Vertex Buffer pointer is null"));
                    lpdp2d->ddrval = DDERR_INVALIDPARAMS;
                    goto Exit_DrawPrimitives2;
                }            
            }
            // fall through intentionally, no break here
        case D3DDP2OP_LINELIST_IMM:
        case D3DDP2OP_TRIANGLEFAN_IMM:
            // Update triangle rendering function
            pTriangle = __HWSetTriangleFunc(pContext);
            pPoint    = __HWSetPointFunc(pContext, &P2FVFOff);      

            // Handle State changes that may need to update the chip
            if (pContext->dwDirtyFlags)
            {
                // Handle the dirty states
                __HandleDirtyPermediaState(ppdev, pContext, &P2FVFOff);
            }
            break;
        }

        // Execute the current command buffer command
        switch( lpIns->bCommand )
        {

        case D3DDP2OP_RENDERSTATE:

            // Specifies a render state change that requires processing. 
            // The rendering state to change is specified by one or more 
            // D3DHAL_DP2RENDERSTATE structures following D3DHAL_DP2COMMAND.
            
            DBG_D3D((8,"D3DDP2OP_RENDERSTATE "
                    "state count = %d", lpIns->wStateCount));

            // Check we are in valid buffer memory
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2RENDERSTATE, lpIns->wStateCount, 0);

            lpdp2d->ddrval = __ProcessPermediaStates(pContext,
                                                     lpIns->wStateCount,
                                                     (LPD3DSTATE) (lpPrim),
                                                     lpdp2d->lpdwRStates);

            if ( FAILED(lpdp2d->ddrval) )
            {
                DBG_D3D((2,"Error processing D3DDP2OP_RENDERSTATE"));
                PARSE_ERROR_AND_EXIT(lpdp2d, lpIns, lpInsStart, ddrval);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2RENDERSTATE, 
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_TEXTURESTAGESTATE:
            // Specifies texture stage state changes, having wStateCount 
            // D3DNTHAL_DP2TEXTURESTAGESTATE structures follow the command
            // buffer. For each, the driver should update its internal 
            // texture state associated with the texture at dwStage to 
            // reflect the new value based on TSState.

            DBG_D3D((8,"D3DDP2OP_TEXTURESTAGESTATE"));

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2TEXTURESTAGESTATE, lpIns->wStateCount, 0);

            lpRState = (D3DHAL_DP2TEXTURESTAGESTATE *)(lpPrim);
            for (i = 0; i < lpIns->wStateCount; i++)
            {
                if (0 == lpRState->wStage)
                {

                   // Tell __HWSetupPrimitive to look at stage state data
                   DIRTY_MULTITEXTURE;

                   if ((lpRState->TSState >= D3DTSS_TEXTUREMAP) &&
                        (lpRState->TSState <= D3DTSS_TEXTURETRANSFORMFLAGS))
                   {
#if D3D_STATEBLOCKS
                        if (!pContext->bStateRecMode)
                        {
#endif //D3D_STATEBLOCKS
                            if (pContext->TssStates[lpRState->TSState] !=
                                                          lpRState->dwValue)
                            {
                                // Store value associated to this stage state
                                pContext->TssStates[lpRState->TSState] =
                                                             lpRState->dwValue;

                                // Perform any necessary preprocessing of it
                                __HWPreProcessTSS(pContext,
                                                  0,
                                                  lpRState->TSState,
                                                  lpRState->dwValue);

                                DBG_D3D((8,"TSS State Chg , Stage %d, "
                                           "State %d, Value %d",
                                        (LONG)lpRState->wStage, 
                                        (LONG)lpRState->TSState, 
                                        (LONG)lpRState->dwValue));
                                DIRTY_TEXTURE; //AZN5
                            }
#if D3D_STATEBLOCKS
                        } 
                        else
                        {
                            if (pContext->pCurrSS != NULL)
                            {
                                DBG_D3D((6,"Recording RS %x = %x",
                                         lpRState->TSState, lpRState->dwValue));

                                // Recording the state in a stateblock
                                pContext->pCurrSS->u.uc.TssStates[lpRState->TSState] =
                                                                    lpRState->dwValue;
                                FLAG_SET(pContext->pCurrSS->u.uc.bStoredTSS,
                                         lpRState->TSState);
                            }
                        }
#endif //D3D_STATEBLOCKS
                   }
                   else
                   {
                        DBG_D3D((2,"Unhandled texture stage state %d value %d",
                            (LONG)lpRState->TSState, (LONG)lpRState->dwValue));
                   }
                }
                else
                {
                    DBG_D3D((0,"Texture Stage other than 0 received,"
                               " not supported in hw"));
                }
                lpRState ++;
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TEXTURESTAGESTATE, 
                            lpIns->wStateCount, 0); 
            break;

        case D3DNTDP2OP_VIEWPORTINFO:
            // Specifies the clipping rectangle used for guard-band 
            // clipping by guard-band aware drivers. The clipping 
            // rectangle (i.e. the viewing rectangle) is specified 
            // by the D3DHAL_DP2 VIEWPORTINFO structures following 
            // D3DHAL_DP2COMMAND

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2VIEWPORTINFO, lpIns->wStateCount, 0);

            // We don't implement guard band clipping in this driver so
            // we just skip any of this data that might be sent to us
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2VIEWPORTINFO,
                            lpIns->wStateCount, 0); 
            break;

        case D3DNTDP2OP_WINFO:
            // Specifies the w-range for W buffering. It is specified
            // by one or more D3DHAL_DP2WINFO structures following
            // D3DHAL_DP2COMMAND.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2WINFO, lpIns->wStateCount, 0);

            // We dont implement a w-buffer in this driver so we just 
            // skip any of this data that might be sent to us 
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2WINFO,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_POINTS:

            DBG_D3D((8,"D3DDP2OP_POINTS"));

            // Point primitives in vertex buffers are defined by the 
            // D3DHAL_DP2POINTS structure. The driver should render
            // wCount points starting at the initial vertex specified 
            // by wFirst. Then for each D3DHAL_DP2POINTS, the points
            // rendered will be (wFirst),(wFirst+1),...,
            // (wFirst+(wCount-1)). The number of D3DHAL_DP2POINTS
            // structures to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2POINTS, lpIns->wPrimitiveCount, 0);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                wIndex = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
                wCount = ((D3DHAL_DP2POINTS*)lpPrim)->wCount;

                lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);

                // Check first & last vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
                CHECK_DATABUF_LIMITS(lpdp2d, ((LONG)wIndex + wCount - 1));
                for (j = 0; j < wCount; j++)
                {
                    (*pPoint)(pContext, lpV0, &P2FVFOff);
                    lpV0 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
                }

                lpPrim += sizeof(D3DHAL_DP2POINTS);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2POINTS, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_LINELIST:

            DBG_D3D((8,"D3DDP2OP_LINELIST"));

            // Non-indexed vertex-buffer line lists are defined by the 
            // D3DHAL_DP2LINELIST structure. Given an initial vertex, 
            // the driver will render a sequence of independent lines, 
            // processing two new vertices with each line. The number 
            // of lines to render is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be 
            // (wVStart, wVStart+1),(wVStart+2, wVStart+3),...,
            // (wVStart+(wPrimitiveCount-1)*2), wVStart+wPrimitiveCount*2 - 1).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2LINELIST, 1, 0);

            wIndex = ((D3DHAL_DP2LINELIST*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d,
                                   ((LONG)wIndex + 2*lpIns->wPrimitiveCount - 1) );
            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, &P2FVFOff);

                lpV0 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
                lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST:

            DBG_D3D((8,"D3DDP2OP_INDEXEDLINELIST"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),...
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, 
                D3DHAL_DP2INDEXEDLINELIST, lpIns->wPrimitiveCount, 0);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            { 
                wIndex1 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV2;

                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1, P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2, P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2);
                P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV1, &P2FVFOff);

                lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST2:

            DBG_D3D((8,"D3DDP2OP_INDEXEDLINELIST2"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, 
                    D3DHAL_DP2INDEXEDLINELIST, lpIns->wPrimitiveCount,
                    STARTVERTEXSIZE);

            // Access base index
            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                wIndex1 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDLINELIST*)lpPrim)->wV2;

                lpV1 = LP_FVF_VERTEX(lpVertices, (wIndex1+wIndxBase), P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, (wIndex2+wIndxBase), P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);
                P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV1, &P2FVFOff);

                lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINESTRIP:

            DBG_D3D((8,"D3DDP2OP_LINESTRIP"));

            // Non-index line strips rendered with vertex buffers are
            // specified using D3DHAL_DP2LINESTRIP. The first vertex 
            // in the line strip is specified by wVStart. The 
            // number of lines to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of lines rendered will be (wVStart, wVStart+1),
            // (wVStart+1, wVStart+2),(wVStart+2, wVStart+3),...,
            // (wVStart+wPrimitiveCount, wVStart+wPrimitiveCount+1).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2LINESTRIP, 1, 0);

            wIndex = ((D3DHAL_DP2LINESTRIP*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex + lpIns->wPrimitiveCount);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, &P2FVFOff);

                lpV0 = lpV1;
                lpV1 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINESTRIP:

            DBG_D3D((8,"D3DDP2OP_INDEXEDLINESTRIP"));

            // Indexed line strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDLINESTRIP. The number
            // of lines to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[1], wV[2]),
            // (wV[2], wV[3]), ...
            // (wVStart[wPrimitiveCount-1], wVStart[wPrimitiveCount]). 
            // Although the D3DHAL_DP2INDEXEDLINESTRIP structure only
            // has enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+1 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, 
                    WORD, lpIns->wPrimitiveCount + 1, STARTVERTEXSIZE);

            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex1 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[0];
                wIndex2 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[1];
                lpV1 = 
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex1+wIndxBase, P2FVFOff);

                //We need to check each vertex separately
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                lpV1 = lpV2;
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2 + wIndxBase, P2FVFOff);

                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);
                P2_Draw_FVF_Line(pContext, lpV1, lpV2, lpV1, &P2FVFOff);

                if ( i % 2 )
                {
                    wIndex2 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[1];
                } 
                else if ( (i+1) < lpIns->wPrimitiveCount )
                {
                    // advance to the next element only if we're not done yet
                    lpPrim += sizeof(D3DHAL_DP2INDEXEDLINESTRIP);
                    wIndex2 = ((D3DHAL_DP2INDEXEDLINESTRIP*)lpPrim)->wV[0];
                }
            }

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            // Advance only as many vertex indices there are, with no padding!
            NEXTINSTRUCTION(lpIns, WORD, 
                            lpIns->wPrimitiveCount + 1, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLELIST:

            DBG_D3D((8,"D3DDP2OP_TRIANGLELIST"));

            // Non-indexed vertex buffer triangle lists are defined by 
            // the D3DHAL_DP2TRIANGLELIST structure. Given an initial
            // vertex, the driver will render independent triangles, 
            // processing three new vertices with each triangle. The
            // number of triangles to render is specified by the 
            // wPrimitveCount field of D3DHAL_DP2COMMAND. The sequence
            // of vertices processed will be  (wVStart, wVStart+1, 
            // vVStart+2), (wVStart+3, wVStart+4, vVStart+5),...,
            // (wVStart+(wPrimitiveCount-1)*3), wVStart+wPrimitiveCount*3-2, 
            // vStart+wPrimitiveCount*3-1).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2TRIANGLELIST, 1, 0);

            wIndex = ((D3DHAL_DP2TRIANGLELIST*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d, 
                         ((LONG)wIndex + 3*lpIns->wPrimitiveCount - 1) );

            
            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            {
                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV0, lpV1, lpV2, &P2FVFOff);

                lpV0 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
                lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
                lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
            }
            

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLELIST"));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.

            // This is the only indexed primitive where we don't get 
            // an offset into the vertex buffer in order to maintain
            // DX3 compatibility. A new primitive 
            // (D3DDP2OP_INDEXEDTRIANGLELIST2) has been added to handle
            // the corresponding DX6 primitive.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2INDEXEDTRIANGLELIST, lpIns->wPrimitiveCount, 0);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            { 
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV2;
                wIndex3 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV3;
                wFlags  = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wFlags;


                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1, P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2, P2FVFOff);
                lpV3 = LP_FVF_VERTEX(lpVertices, wIndex3, P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex3);
                if (!CULL_TRI(pContext,lpV1,lpV2,lpV3))
                {

                    if (pContext->Hdr.FillMode == D3DFILL_POINT)
                    {
                        (*pPoint)( pContext, lpV1, &P2FVFOff);
                        (*pPoint)( pContext, lpV2, &P2FVFOff);
                        (*pPoint)( pContext, lpV3, &P2FVFOff);
                    } 
                    else if (pContext->Hdr.FillMode == D3DFILL_WIREFRAME)
                    {
                        if ( wFlags & D3DTRIFLAG_EDGEENABLE1 )
                            P2_Draw_FVF_Line( pContext,
                                              lpV1, lpV2, lpV1, &P2FVFOff);
                        if ( wFlags & D3DTRIFLAG_EDGEENABLE2 )
                            P2_Draw_FVF_Line( pContext,
                                              lpV2, lpV3, lpV1, &P2FVFOff);
                        if ( wFlags & D3DTRIFLAG_EDGEENABLE3 )
                            P2_Draw_FVF_Line( pContext,
                                              lpV3, lpV1, lpV1, &P2FVFOff);
                    }
                    else
                        (*pTriangle)(pContext, lpV1, lpV2, lpV3, &P2FVFOff);
                }

                lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST2:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLELIST2 "));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST2 structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    D3DHAL_DP2INDEXEDTRIANGLELIST2, lpIns->wPrimitiveCount,
                    STARTVERTEXSIZE);

            // Access base index here
            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            for (i = lpIns->wPrimitiveCount; i > 0; i--)
            { 
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV1;
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV2;
                wIndex3 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV3;

                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1+wIndxBase, P2FVFOff);
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2+wIndxBase, P2FVFOff);
                lpV3 = LP_FVF_VERTEX(lpVertices, wIndex3+wIndxBase, P2FVFOff);

                // Must check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex3 + wIndxBase);

                if (!CULL_TRI(pContext,lpV1,lpV2,lpV3)) 
                {
                    if (pContext->Hdr.FillMode == D3DFILL_POINT)
                    {
                        (*pPoint)( pContext, lpV1, &P2FVFOff);
                        (*pPoint)( pContext, lpV2, &P2FVFOff);
                        (*pPoint)( pContext, lpV3, &P2FVFOff);
                    }
                    else if (pContext->Hdr.FillMode == D3DFILL_WIREFRAME)
                    {
                            P2_Draw_FVF_Line( pContext,
                                              lpV1, lpV2, lpV1, &P2FVFOff);
                            P2_Draw_FVF_Line( pContext,
                                              lpV2, lpV3, lpV1, &P2FVFOff);
                            P2_Draw_FVF_Line( pContext,
                                              lpV3, lpV1, lpV1, &P2FVFOff);
                    } 
                    else
                        (*pTriangle)(pContext, lpV1, lpV2, lpV3, &P2FVFOff);
                }

                lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST2, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLESTRIP:

            DBG_D3D((8,"D3DDP2OP_TRIANGLESTRIP"));

            // Non-index triangle strips rendered with vertex buffers 
            // are specified using D3DHAL_DP2TRIANGLESTRIP. The first 
            // vertex in the triangle strip is specified by wVStart. 
            // The number of triangles to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of triangles rendered for the odd-triangles case will 
            // be (wVStart, wVStart+1, vVStart+2), (wVStart+1, 
            // wVStart+3, vVStart+2),.(wVStart+2, wVStart+3, 
            // vVStart+4),.., (wVStart+wPrimitiveCount-1), 
            // wVStart+wPrimitiveCount, vStart+wPrimitiveCount+1). For an
            // even number of , the last triangle will be .,
            // (wVStart+wPrimitiveCount-1, vStart+wPrimitiveCount+1,
            // wVStart+wPrimitiveCount).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2TRIANGLESTRIP, 1, 0);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex = ((D3DHAL_DP2TRIANGLESTRIP*)lpPrim)->wVStart;
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
                lpV1 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);

                // Check first and last vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
                CHECK_DATABUF_LIMITS(lpdp2d,
                                     wIndex + lpIns->wPrimitiveCount + 1);
            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                if ( i % 2 )
                {
                    lpV0 = lpV1;
                    lpV1 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
                }
                else
                {
                    lpV0 = lpV2;
                    lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
                }

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV0, lpV1, lpV2, &P2FVFOff);
            }
            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLESTRIP:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLESTRIP"));

            // Indexed triangle strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDTRIANGLESTRIP. The number
            // of triangles to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of triangles 
            // rendered for the odd-triangles case will be 
            // (wV[0],wV[1],wV[2]),(wV[1],wV[3],wV[2]),
            // (wV[2],wV[3],wV[4]),...,(wV[wPrimitiveCount-1],
            // wV[wPrimitiveCount],wV[wPrimitiveCount+1]). For an even
            // number of triangles, the last triangle will be
            // (wV[wPrimitiveCount-1],wV[wPrimitiveCount+1],
            // wV[wPrimitiveCount]).Although the 
            // D3DHAL_DP2INDEXEDTRIANGLESTRIP structure only has 
            // enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+2 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command


            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    WORD, lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            // Access base index
            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex  = ((D3DHAL_DP2INDEXEDTRIANGLESTRIP*)lpPrim)->wV[0];
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLESTRIP*)lpPrim)->wV[1];

                // We need to check each vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);

                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex + wIndxBase, P2FVFOff);
                lpV1 = LP_FVF_VERTEX(lpVertices, wIndex1 + wIndxBase, P2FVFOff);

            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLESTRIP*)lpPrim)->wV[2];
                // We need to check each new vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2+wIndxBase);
                if ( i % 2 )
                {
                    lpV0 = lpV1;
                    lpV1 = LP_FVF_VERTEX(lpVertices, wIndex2+wIndxBase, P2FVFOff);
                }
                else
                {
                    lpV0 = lpV2;
                    lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2+wIndxBase, P2FVFOff);
                }

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV0, lpV1, lpV2, &P2FVFOff);

                // We will advance our pointer only one WORD in order 
                // to fetch the next index
                lpPrim += sizeof(WORD);
            }
 
            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, WORD , 
                            lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLEFAN:

            DBG_D3D((8,"D3DDP2OP_TRIANGLEFAN"));

            // The D3DHAL_DP2TRIANGLEFAN structure is used to draw 
            // non-indexed triangle fans. The sequence of triangles
            // rendered will be (wVstart+1, wVStart+2, wVStart),
            // (wVStart+2,wVStart+3,wVStart), (wVStart+3,wVStart+4
            // wVStart),...,(wVStart+wPrimitiveCount,
            // wVStart+wPrimitiveCount+1,wVStart).

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim, D3DHAL_DP2TRIANGLEFAN, 1, 0);

            wIndex = ((D3DHAL_DP2TRIANGLEFAN*)lpPrim)->wVStart;

            lpV0 = LP_FVF_VERTEX(lpVertices, wIndex, P2FVFOff);
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);

            // Check first & last vertex
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex);
            CHECK_DATABUF_LIMITS(lpdp2d, wIndex + lpIns->wPrimitiveCount + 1);

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            {
                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV1, lpV2, lpV0, &P2FVFOff);

                lpV1 = lpV2;
                lpV2 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLEFAN, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLEFAN:

            DBG_D3D((8,"D3DDP2OP_INDEXEDTRIANGLEFAN"));

            // The D3DHAL_DP2INDEXEDTRIANGLEFAN structure is used to 
            // draw indexed triangle fans. The sequence of triangles
            // rendered will be (wV[1], wV[2],wV[0]), (wV[2], wV[3],
            // wV[0]), (wV[3], wV[4], wV[0]),...,
            // (wV[wPrimitiveCount], wV[wPrimitiveCount+1],wV[0]).
            // The indexes are relative to a base index value that 
            // immediately follows the command

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    WORD, lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            wIndxBase = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
            lpPrim = lpPrim + sizeof(D3DHAL_DP2STARTVERTEX);

            // guard defensively against pathological commands
            if ( lpIns->wPrimitiveCount > 0 )
            {
                wIndex  = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[0];
                wIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[1];
                lpV0 = LP_FVF_VERTEX(lpVertices, wIndex + wIndxBase, P2FVFOff);
                lpV1 = 
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex1 + wIndxBase, P2FVFOff);

                // We need to check each vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex + wIndxBase);
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex1 + wIndxBase);
            }

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            { 
                wIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];
                lpV1 = lpV2;
                lpV2 = LP_FVF_VERTEX(lpVertices, wIndex2 + wIndxBase, P2FVFOff);

                // We need to check each vertex
                CHECK_DATABUF_LIMITS(lpdp2d, wIndex2 + wIndxBase);

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                    (*pTriangle)(pContext, lpV1, lpV2, lpV0, &P2FVFOff);

                // We will advance our pointer only one WORD in order 
                // to fetch the next index
                lpPrim += sizeof(WORD);
            }

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, WORD , 
                            lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINELIST_IMM:

            DBG_D3D((8,"D3DDP2OP_LINELIST_IMM"));

            // Draw a set of lines specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of lines that follow. The type and size of the
            // vertices are determined by the dwVertexType member
            // of the D3DHAL_DRAWPRIMITIVES2DATA structure.

            // Primitives in an IMM instruction are stored in the
            // command buffer and are DWORD aligned
            lpPrim = (LPBYTE)((ULONG_PTR)(lpPrim + 3 ) & ~3 );

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS_S(lpdp2d, lpPrim,
                    P2FVFOff.dwStride, lpIns->wPrimitiveCount + 1, 0);

            // Get vertex pointers
            lpV0 = (LPD3DTLVERTEX)lpPrim;
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);

            for (i = 0; i < lpIns->wPrimitiveCount; i++)
            {
                P2_Draw_FVF_Line(pContext, lpV0, lpV1, lpV0, &P2FVFOff);

                lpV0 = lpV1;
                lpV1 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);
            }

            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            wCount = lpIns->wPrimitiveCount;
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);

            NEXTINSTRUCTION_S(lpIns, P2FVFOff.dwStride, wCount + 1, 0);

            break;

        case D3DDP2OP_TRIANGLEFAN_IMM:

            DBG_D3D((8,"D3DDP2OP_TRIANGLEFAN_IMM"));

            // Draw a triangle fan specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of triangles that follow. The type and size of the
            // vertices are determined by the dwVertexType member
            // of the D3DHAL_DRAWPRIMITIVES2DATA structure.

            // Verify the command buffer validity for the first structure
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                    BYTE , 0 , sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));

            // Get Edge flags (we still have to process them)
            dwEdgeFlags = ((D3DHAL_DP2TRIANGLEFAN_IMM *)lpPrim)->dwEdgeFlags;
            lpPrim = (LPBYTE)lpPrim + sizeof(D3DHAL_DP2TRIANGLEFAN_IMM); 

            // Vertices in an IMM instruction are stored in the
            // command buffer and are DWORD aligned
            lpPrim = (LPBYTE)((ULONG_PTR)(lpPrim + 3 ) & ~3 );

            // Verify the rest of the command buffer
            CHECK_CMDBUF_LIMITS_S(lpdp2d, lpPrim,
                    P2FVFOff.dwStride, lpIns->wPrimitiveCount + 2, 0);

            // Get vertex pointers
            lpV0 = (LPD3DTLVERTEX)lpPrim;
            lpV1 = LP_FVF_NXT_VTX(lpV0, P2FVFOff);
            lpV2 = LP_FVF_NXT_VTX(lpV1, P2FVFOff);

            for (i = 0 ; i < lpIns->wPrimitiveCount ; i++)
            {

                if (!CULL_TRI(pContext,lpV0,lpV1,lpV2))
                {
                    if (pContext->Hdr.FillMode == D3DFILL_POINT)
                    {
                        if (0 == i)
                        {
                            (*pPoint)( pContext, lpV0, &P2FVFOff);
                            (*pPoint)( pContext, lpV1, &P2FVFOff);
                        }
                        (*pPoint)( pContext, lpV2, &P2FVFOff);
                    } 
                    else if (pContext->Hdr.FillMode == D3DFILL_WIREFRAME)
                    {
                        // dwEdgeFlags is a bit sequence representing the edge
                        // flag for each one of the outer edges of the 
                        // triangle fan
                        if (0 == i)
                        {
                            if (dwEdgeFlags & 0x0001)
                                P2_Draw_FVF_Line( pContext, lpV0, lpV1, lpV0,
                                                  &P2FVFOff);

                            dwEdgeFlags >>= 1;
                        }

                        if (dwEdgeFlags & 0x0001)
                            P2_Draw_FVF_Line( pContext, lpV1, lpV2, lpV0,
                                              &P2FVFOff);

                        dwEdgeFlags >>= 1;

                        if (i == (UINT)lpIns->wPrimitiveCount - 1)
                        {
                            // last triangle fan edge
                            if (dwEdgeFlags & 0x0001)
                                P2_Draw_FVF_Line( pContext, lpV2, lpV0, lpV0,
                                                  &P2FVFOff);
                        }
                    }
                    else
                        (*pTriangle)(pContext, lpV1, lpV2, lpV0, &P2FVFOff);
                }

                lpV1 = lpV2;
                lpV2 = LP_FVF_NXT_VTX(lpV2, P2FVFOff);
            }
 
            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            wCount = lpIns->wPrimitiveCount;
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);

            NEXTINSTRUCTION_S(lpIns, P2FVFOff.dwStride, 
                              wCount + 2, sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));
            break;

        case D3DDP2OP_TEXBLT:
            // Inform the drivers to perform a BitBlt operation from a source
            // texture to a destination texture. A texture can also be cubic
            // environment map. The driver should copy a rectangle specified
            // by rSrc in the source texture to the location specified by pDest
            // in the destination texture. The destination and source textures
            // are identified by handles that the driver was notified with
            // during texture creation time. If the driver is capable of
            // managing textures, then it is possible that the destination
            // handle is 0. This indicates to the driver that it should preload
            // the texture into video memory (or wherever the hardware
            // efficiently textures from). In this case, it can ignore rSrc and
            // pDest. Note that for mipmapped textures, only one D3DDP2OP_TEXBLT
            // instruction is inserted into the D3dDrawPrimitives2 command stream.
            // In this case, the driver is expected to BitBlt all the mipmap
            // levels present in the texture.

            // Verify the command buffer validity
            CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                     D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);

            DBG_D3D((8,"D3DDP2OP_TEXBLT"));

            for ( i = 0; i < lpIns->wStateCount; i++)
            {
                __TextureBlt(pContext, (D3DHAL_DP2TEXBLT*)(lpPrim));
                lpPrim += sizeof(D3DHAL_DP2TEXBLT);
            }

            //need to restore following registers
            RESERVEDMAPTR(15);
            SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
            COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
            SEND_PERMEDIA_DATA(FBSourceOffset, 0x0);
            SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
            SEND_PERMEDIA_DATA(FBWindowBase,0);   
            COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);
            COPY_PERMEDIA_DATA(AlphaBlendMode, pSoftPermedia->AlphaBlendMode);
            COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
            COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
            COPY_PERMEDIA_DATA(TextureColorMode, 
                pSoftPermedia->TextureColorMode);
            COPY_PERMEDIA_DATA(TextureReadMode, 
                pSoftPermedia->TextureReadMode);
            COPY_PERMEDIA_DATA(TextureAddressMode,  
                pSoftPermedia->TextureAddressMode); 
            COPY_PERMEDIA_DATA(TextureDataFormat, 
                pSoftPermedia->TextureDataFormat);
            COPY_PERMEDIA_DATA(TextureMapFormat, 
                pSoftPermedia->TextureMapFormat);
                                           
            if (pContext->CurrentTextureHandle)
            {
                PERMEDIA_D3DTEXTURE* pTexture;
                pTexture = TextureHandleToPtr(pContext->CurrentTextureHandle,
                    pContext);
                if (NULL != pTexture)
                {
                    SEND_PERMEDIA_DATA(TextureBaseAddress, 
                           pTexture->MipLevels[0].PixelOffset);
                }
            }
            COMMITDMAPTR();

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_STATESET:
            {
                P2D3DHAL_DP2STATESET *pStateSetOp = (P2D3DHAL_DP2STATESET*)(lpPrim);
                DBG_D3D((8,"D3DDP2OP_STATESET"));
#if D3D_STATEBLOCKS
                for (i = 0; i < lpIns->wStateCount; i++, pStateSetOp++)
                {
                    switch (pStateSetOp->dwOperation)
                    {
                    case D3DHAL_STATESETBEGIN  :
                        __BeginStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEND    :
                        __EndStateSet(pContext);
                        break;
                    case D3DHAL_STATESETDELETE :
                        __DeleteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEXECUTE:
                        __ExecuteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETCAPTURE:
                        __CaptureStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    default :
                        DBG_D3D((0,"D3DDP2OP_STATESET has invalid"
                            "dwOperation %08lx",pStateSetOp->dwOperation));
                    }
                }
#endif //D3D_STATEBLOCKS
                // Update the command buffer pointer
                NEXTINSTRUCTION(lpIns, P2D3DHAL_DP2STATESET, 
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_SETPALETTE:
            // Attach a palette to a texture, that is , map an association
            // between a palette handle and a surface handle, and specify
            // the characteristics of the palette. The number of
            // D3DNTHAL_DP2SETPALETTE structures to follow is specified by
            // the wStateCount member of the D3DNTHAL_DP2COMMAND structure

            {
                D3DHAL_DP2SETPALETTE* lpSetPal =
                                            (D3DHAL_DP2SETPALETTE*)(lpPrim);

                DBG_D3D((8,"D3DDP2OP_SETPALETTE"));

                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                          D3DHAL_DP2SETPALETTE, lpIns->wStateCount, 0);

                for (i = 0; i < lpIns->wStateCount; i++, lpSetPal++)
                {
                    __PaletteSet(pContext,
                                lpSetPal->dwSurfaceHandle,
                                lpSetPal->dwPaletteHandle,
                                lpSetPal->dwPaletteFlags );
                }
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETPALETTE, 
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_UPDATEPALETTE:
            // Perform modifications to the palette that is used for palettized
            // textures. The palette handle attached to a surface is updated
            // with wNumEntries PALETTEENTRYs starting at a specific wStartIndex
            // member of the palette. (A PALETTENTRY (defined in wingdi.h and
            // wtypes.h) is actually a DWORD with an ARGB color for each byte.) 
            // After the D3DNTHAL_DP2UPDATEPALETTE structure in the command
            // stream the actual palette data will follow (without any padding),
            // comprising one DWORD per palette entry. There will only be one
            // D3DNTHAL_DP2UPDATEPALETTE structure (plus palette data) following
            // the D3DNTHAL_DP2COMMAND structure regardless of the value of
            // wStateCount.

            {
                D3DHAL_DP2UPDATEPALETTE* lpUpdatePal =
                                          (D3DHAL_DP2UPDATEPALETTE*)(lpPrim);
                PERMEDIA_D3DPALETTE* pPalette;

                DBG_D3D((8,"D3DDP2OP_UPDATEPALETTE"));

                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                           D3DHAL_DP2UPDATEPALETTE, 1,
                           lpUpdatePal->wNumEntries * sizeof(PALETTEENTRY));

                // We will ALWAYS have only 1 palette update structure + palette
                // following the D3DDP2OP_UPDATEPALETTE token
                ASSERTDD(1 == lpIns->wStateCount,
                         "1 != wStateCount in D3DDP2OP_UPDATEPALETTE");

                __PaletteUpdate(pContext,
                                        lpUpdatePal->dwPaletteHandle,
                                        lpUpdatePal->wStartIndex,
                                        lpUpdatePal->wNumEntries,
                                        (BYTE*)(lpUpdatePal+1) );

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2UPDATEPALETTE, 
                                1,
                                (DWORD)lpUpdatePal->wNumEntries * 
                                     sizeof(PALETTEENTRY));
            }
            break;

        case D3DDP2OP_SETRENDERTARGET:
            // Map a new rendering target surface and depth buffer in
            // the current context.  This replaces the old D3dSetRenderTarget
            // callback. 

            {
                D3DHAL_DP2SETRENDERTARGET* pSRTData;

                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                        D3DHAL_DP2SETRENDERTARGET, lpIns->wStateCount, 0);

                // Get new data by ignoring all but the last structure
                pSRTData = (D3DHAL_DP2SETRENDERTARGET*)lpPrim +
                           (lpIns->wStateCount - 1);

                __SetRenderTarget(pContext,
                                          pSRTData->hRenderTarget,
                                          pSRTData->hZBuffer);

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETRENDERTARGET,
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_CLEAR:
            // Perform hardware-assisted clearing on the rendering target,
            // depth buffer or stencil buffer. This replaces the old D3dClear
            // and D3dClear2 callbacks. 

            {
                D3DHAL_DP2CLEAR* pClear;
                // Verify the command buffer validity
                CHECK_CMDBUF_LIMITS(lpdp2d, lpPrim,
                        RECT, lpIns->wStateCount, 
                        (sizeof(D3DHAL_DP2CLEAR) - sizeof(RECT)));

                // Get new data by ignoring all but the last structure
                pClear = (D3DHAL_DP2CLEAR*)lpPrim;

                DBG_D3D((8,"D3DDP2OP_CLEAR dwFlags=%08lx dwColor=%08lx "
                           "dvZ=%08lx dwStencil=%08lx",
                           pClear->dwFlags,
                           pClear->dwFillColor,
                           (DWORD)(pClear->dvFillDepth*0x0000FFFF),
                           pClear->dwFillStencil));

                __Clear(pContext, 
                                pClear->dwFlags,        // in:  surfaces to clear
                                pClear->dwFillColor,    // in:  Color value for rtarget
                                pClear->dvFillDepth,    // in:  Depth value for
                                                        //      Z-buffer (0.0-1.0)
                                pClear->dwFillStencil,  // in:  value used to clear stencil
                                                        // in:  Rectangles to clear
                                (LPD3DRECT)((LPBYTE)pClear + 
                                         sizeof(D3DHAL_DP2CLEAR) -
                                         sizeof(RECT)),
                                (DWORD)lpIns->wStateCount); // in:  Number of rectangles
                //need to restore following registers
                RESERVEDMAPTR(4);
                SEND_PERMEDIA_DATA(FBReadPixel, pSoftPermedia->FBReadPixel);
                COPY_PERMEDIA_DATA(FBReadMode, pSoftPermedia->FBReadMode);
                SEND_PERMEDIA_DATA(FBPixelOffset, pContext->PixelOffset);
                SEND_PERMEDIA_DATA(FBWindowBase,0);   
                COMMITDMAPTR();
                NEXTINSTRUCTION(lpIns, RECT, lpIns->wStateCount, 
                                (sizeof(D3DHAL_DP2CLEAR) - sizeof(RECT))); 
            }
            break;

#if D3DDX7_TL
        case D3DDP2OP_SETMATERIAL:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETMATERIAL,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_SETLIGHT:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETLIGHT,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_CREATELIGHT:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2CREATELIGHT,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_SETTRANSFORM:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETTRANSFORM,
                            lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_ZRANGE:
            // We don't support T&L in this driver so we only skip this data
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2ZRANGE,
                            lpIns->wStateCount, 0);
            break;
#endif //D3DDX7_TL

        default:

            ASSERTDD((pContext->ppdev->pD3DParseUnknownCommand),
                     "D3D DX6 ParseUnknownCommand callback == NULL");

            // Call the ParseUnknown callback to process 
            // any unidentifiable token
            ddrval = (pContext->ppdev->pD3DParseUnknownCommand)
                                 ( (VOID **) lpIns , (VOID **) &lpResumeIns);
            if ( SUCCEEDED(ddrval) )
            {
                // Resume buffer processing after D3DParseUnknownCommand
                // was succesful in processing an unknown command
                lpIns = lpResumeIns;
                break;
            }

            DBG_D3D((2,"unhandled opcode (%d)- returning "
                        "D3DERR_COMMAND_UNPARSED @ addr %x",
                        lpIns->bCommand,lpIns));

            PARSE_ERROR_AND_EXIT( lpdp2d, lpIns, lpInsStart, ddrval);
        } // switch

    } //while

    lpdp2d->ddrval = DD_OK;

Exit_DrawPrimitives2:

    // any necessary housekeeping can be done here before leaving

    DBG_D3D((6,"Exiting D3DDrawPrimitives2"));

    return DDHAL_DRIVER_HANDLED;
} // D3DDrawPrimitives2


//-----------------------------Public Routine----------------------------------
//
// DWORD D3DValidateTextureStageState
//
// ValidateTextureStageState evaluates the current state for blending 
// operations (including multitexture) and returns the number of passes the 
// hardware can do it in. This is a mechanism to query the driver about 
// whether it is able to handle the current stage state setup that has been 
// set up in hardware.  For example, some hardware cannot do two simultaneous 
// modulate operations because they have only one multiplication unit and one 
// addition unit.  
//
// The other reason for this function is that some hardware may not map 
// directly onto the Direct3D state architecture. This is a mechanism to map 
// the hardware's capabilities onto what the Direct3D DDI expects.
//
// Parameters
//
//      lpvtssd
//
//          .dwhContext
//               Context handle
//          .dwFlags
//               Flags, currently set to 0
//          .dwReserved
//               Reserved
//          .dwNumPasses
//               Number of passes the hardware can perform the operation in
//          .ddrval
//               return value
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DValidateTextureStageState( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA lpvtssd )
{
    PERMEDIA_D3DTEXTURE *lpTexture;
    PERMEDIA_D3DCONTEXT *pContext;
    DWORD mag, min, cop, ca1, ca2, aop, aa1, aa2;

    DBG_D3D((6,"Entering D3DValidateTextureStageState"));

    pContext = (PERMEDIA_D3DCONTEXT*)ContextSlots[lpvtssd->dwhContext];

    // Check if we got a valid context handle.
    CHK_CONTEXT(pContext, lpvtssd->ddrval, "D3DValidateTextureStageState");

    lpvtssd->dwNumPasses = 0;
    lpvtssd->ddrval =  DD_OK;

    mag = pContext->TssStates[D3DTSS_MAGFILTER];
    min = pContext->TssStates[D3DTSS_MINFILTER];
    cop = pContext->TssStates[D3DTSS_COLOROP];
    ca1 = pContext->TssStates[D3DTSS_COLORARG1];
    ca2 = pContext->TssStates[D3DTSS_COLORARG2];
    aop = pContext->TssStates[D3DTSS_ALPHAOP];
    aa1 = pContext->TssStates[D3DTSS_ALPHAARG1];
    aa2 = pContext->TssStates[D3DTSS_ALPHAARG2];

    if (!pContext->TssStates[D3DTSS_TEXTUREMAP])
    {
        lpvtssd->dwNumPasses = 1;

        // Current is the same as diffuse in stage 0
        if (ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if (aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        // Check TSS even with texture handle = 0 since
        // certain operations with the fragments colors might
        // be  possible. Here we only allow plain "classic" rendering

        if ((ca1 == D3DTA_DIFFUSE )    && 
            (cop == D3DTOP_SELECTARG1) &&
            (aa1 == D3DTA_DIFFUSE )    &&
            (aop == D3DTOP_SELECTARG1))
        {
        }
        else if ((ca2 == D3DTA_DIFFUSE )    && 
                 (cop == D3DTOP_SELECTARG2) &&
                 (aa2 == D3DTA_DIFFUSE) &&
                 (aop == D3DTOP_SELECTARG2))
        {
        } 
        // Default modulation
        else if ((ca2 == D3DTA_DIFFUSE)   && 
                 (ca1 == D3DTA_TEXTURE)   && 
                 (cop == D3DTOP_MODULATE) &&
                 (aa1 == D3DTA_TEXTURE)   && 
                 (aop == D3DTOP_SELECTARG1)) 
        {
        }
        // Check disable
        else if (cop == D3DTOP_DISABLE) 
        {
        }
        else
            goto Fail_Validate;
    }
    else
    if ((mag != D3DTFG_POINT && mag != D3DTFG_LINEAR) || 
        (min != D3DTFG_POINT && min != D3DTFG_LINEAR)
       )
    {
        lpvtssd->ddrval = D3DERR_CONFLICTINGTEXTUREFILTER;
        DBG_D3D((2,"D3DERR_CONFLICTINGTEXTUREFILTER"));
    }
    else
    {
        lpvtssd->dwNumPasses = 1;

        // Current is the same as diffuse in stage 0
        if (ca2 == D3DTA_CURRENT)
            ca2 = D3DTA_DIFFUSE;
        if (aa2 == D3DTA_CURRENT)
            aa2 = D3DTA_DIFFUSE;

        // Check decal
        if ((ca1 == D3DTA_TEXTURE )    && 
           (cop == D3DTOP_SELECTARG1) &&
           (aa1 == D3DTA_TEXTURE)     && 
           (aop == D3DTOP_SELECTARG1))
        {
        }
        // Check all modulate variations
        else if ((ca2 == D3DTA_DIFFUSE)   && 
                 (ca1 == D3DTA_TEXTURE)   && 
                 (cop == D3DTOP_MODULATE))
        {
            if (
                // legacy (DX5) mode
                ((aa1 == D3DTA_TEXTURE)   && 
                (aop == D3DTOP_LEGACY_ALPHAOVR)) ||
                // modulate color & pass diffuse alpha
                ((aa2 == D3DTA_DIFFUSE)   && 
                     (aop == D3DTOP_SELECTARG2))
               )

            {
                PermediaSurfaceData* pPrivateData;

                // Get Texture for current stage (0) to verify properties
                lpTexture = TextureHandleToPtr(
                                    pContext->TssStates[D3DTSS_TEXTUREMAP],
                                    pContext);

                if (!CHECK_D3DSURFACE_VALIDITY(lpTexture))
                {
                    // we're lacking key information about the texture
                    DBG_D3D((0,"D3DValidateTextureStageState gets "
                               "NULL == lpTexture"));
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    goto Exit_ValidateTSS;
                }

                pPrivateData = lpTexture->pTextureSurface;

                if (NULL == pPrivateData)
                {
                    // we're lacking key information about the texture
                    DBG_D3D((0,"D3DValidateTextureStageState gets "
                               "NULL == lpTexture->pTextureSurface"));
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    goto Exit_ValidateTSS;
                }

                // legacy texture modulation must have texture alpha
                if (!pPrivateData->SurfaceFormat.bAlpha &&
                    (aop == D3DTOP_LEGACY_ALPHAOVR))
                {
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    DBG_D3D((2,"D3DERR_WRONGTEXTUREFORMAT a format "
                               "with alpha must be used"));
                    goto Exit_ValidateTSS;
                }

                // modulation w diffuse alpha channel must lack texture
                // alpha channel due to Permedia2 limitations on 
                // texture blending operations
                if (pPrivateData->SurfaceFormat.bAlpha &&
                    (aop == D3DTOP_SELECTARG2))
                {
                    lpvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                    lpvtssd->dwNumPasses = 0;
                    DBG_D3D((2,"D3DERR_WRONGTEXTUREFORMAT a format "
                               "with alpha must be used"));
                    goto Exit_ValidateTSS;
                }
            }
            // modulate alpha
            else if ((aa2 == D3DTA_DIFFUSE)   && 
                     (aa1 == D3DTA_TEXTURE)   && 
                     (aop == D3DTOP_MODULATE))
            {
            }
            // modulate color & pass texture alpha
            else if ((aa1 == D3DTA_TEXTURE)   && 
                     (aop == D3DTOP_SELECTARG1)) 
            {
            }
            else
            {
                goto Fail_Validate;
            }
        }
        // Check decal alpha
        else if ((ca2 == D3DTA_DIFFUSE)            && 
                 (ca1 == D3DTA_TEXTURE)            && 
                 (cop == D3DTOP_BLENDTEXTUREALPHA) &&
                 (aa2 == D3DTA_DIFFUSE)            && 
                 (aop == D3DTOP_SELECTARG2))
        {
        }

        // Check add
        else if ((ca2 == D3DTA_DIFFUSE) && 
                 (ca1 == D3DTA_TEXTURE) && 
                 (cop == D3DTOP_ADD)    &&
                 (aa2 == D3DTA_DIFFUSE) && 
                 (aop == D3DTOP_SELECTARG2))
        {
        }
        // Check disable
        else if ((cop == D3DTOP_DISABLE) || 
                  (cop == D3DTOP_SELECTARG2 && 
                   ca2 == D3DTA_DIFFUSE     && 
                   aop == D3DTOP_SELECTARG2 && 
                   aa2 == D3DTA_DIFFUSE)       )
        {
        }
        // Don't understand
        else {
Fail_Validate:
            DBG_D3D((4,"Failing with cop=%d ca1=%d ca2=%d aop=%d aa1=%d aa2=%d",
                       cop,ca1,ca2,aop,aa1,aa2));

            if (!((cop == D3DTOP_DISABLE)           ||
                  (cop == D3DTOP_ADD)               ||
                  (cop == D3DTOP_MODULATE)          ||
                  (cop == D3DTOP_BLENDTEXTUREALPHA) ||
                  (cop == D3DTOP_SELECTARG2)        ||
                  (cop == D3DTOP_SELECTARG1)))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLOROPERATION;
            
            else if (!((aop == D3DTOP_SELECTARG1)      ||
                       (aop == D3DTOP_SELECTARG2)      ||
                       (aop == D3DTOP_MODULATE)        ||
                       (aop == D3DTOP_LEGACY_ALPHAOVR)))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAOPERATION;

            else if (!(ca1 == D3DTA_TEXTURE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLORARG;

            else if (!(ca2 == D3DTA_DIFFUSE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLORARG;

            else if (!(aa1 == D3DTA_TEXTURE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAARG;

            else if (!(aa2 == D3DTA_DIFFUSE))
                    lpvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAARG;
            else
                 lpvtssd->ddrval = D3DERR_UNSUPPORTEDCOLOROPERATION;

            lpvtssd->dwNumPasses = 0;
            DBG_D3D((2,"D3DERR_UNSUPPORTEDCOLOROPERATION"));
            goto Exit_ValidateTSS;
        }
    }
Exit_ValidateTSS:
    DBG_D3D((6,"Exiting D3DValidateTextureStageState with dwNumPasses=%d",
                                                    lpvtssd->dwNumPasses));

    return DDHAL_DRIVER_HANDLED;
} // D3DValidateTextureStageState

//-----------------------------Public Routine----------------------------------
//
// DWORD __CheckFVFRequest
//
// This utility function verifies that the requested FVF format makes sense
// and computes useful offsets into the data and a stride between succesive
// vertices.
//
//-----------------------------------------------------------------------------
DWORD 
__CheckFVFRequest(DWORD dwFVF, LPP2FVFOFFSETS lpP2FVFOff)
{
    DWORD stride;
    UINT iTexCount; 

    DBG_D3D((10,"Entering __CheckFVFRequest"));

    memset(lpP2FVFOff, 0, sizeof(P2FVFOFFSETS));

    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED1 | D3DFVF_RESERVED2 |
         D3DFVF_NORMAL)) ||
         ((dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)) == 0) )
    {
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers, and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    lpP2FVFOff->dwStride = sizeof(D3DVALUE) * 3;

    if (dwFVF & D3DFVF_XYZRHW)
    {
        lpP2FVFOff->dwStride += sizeof(D3DVALUE);
    }

    if (dwFVF & D3DFVF_DIFFUSE)
    {
        lpP2FVFOff->dwColOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwStride += sizeof(D3DCOLOR);
    }

    if (dwFVF & D3DFVF_SPECULAR)
    {
        lpP2FVFOff->dwSpcOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwStride  += sizeof(D3DCOLOR);
    }


//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    if (dwFVF & D3DFVF_S)
    {
        lpP2FVFOff->dwPntSizeOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwStride  += sizeof(D3DVALUE);
    }
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

    iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;

    if (iTexCount >= 1)
    {
        lpP2FVFOff->dwTexBaseOffset = lpP2FVFOff->dwStride;
        lpP2FVFOff->dwTexOffset = lpP2FVFOff->dwTexBaseOffset;

        if (0xFFFF0000 & dwFVF)
        {
            //expansion of FVF, these 16 bits are designated for up to 
            //8 sets of texture coordinates with each set having 2bits
            //Normally a capable driver has to process all coordinates
            //However, code below only show correct parsing w/o really
            //observing all the texture coordinates.In reality,this would 
            //result in incorrect result.
            UINT i,numcoord;
            DWORD extrabits;
            for (i = 0; i < iTexCount; i++)
            {
                extrabits= (dwFVF >> (16+2*i)) & 0x0003;
                switch(extrabits)
                {
                case    1:
                    // one more D3DVALUE for 3D textures
                    numcoord = 3;
                    break;
                case    2:
                    // two more D3DVALUEs for 4D textures
                    numcoord = 4;
                    break;
                case    3:
                    // one less D3DVALUE for 1D textures
                    numcoord = 1;
                    break;
                default:
                    // i.e. case 0 regular 2 D3DVALUEs
                    numcoord = 2;
                    break;
                }

                DBG_D3D((0,"Expanded TexCoord set %d has a offset %8lx",
                           i,lpP2FVFOff->dwStride));
                lpP2FVFOff->dwStride += sizeof(D3DVALUE) * numcoord;
            }
            DBG_D3D((0,"Expanded dwVertexType=0x%08lx has %d Texture Coords "
                       "with total stride=0x%08lx",
                       dwFVF, iTexCount, lpP2FVFOff->dwStride));
        }
        else
            lpP2FVFOff->dwStride   += iTexCount * sizeof(D3DVALUE) * 2;
    } 
    else
    {
        lpP2FVFOff->dwTexBaseOffset = 0;
        lpP2FVFOff->dwTexOffset = 0;
    }

    DBG_D3D((10,"Exiting __CheckFVFRequest"));
    return DD_OK;
} // __CheckFVFRequest

//-----------------------------------------------------------------------------
//
// D3DFVFDRAWTRIFUNCPTR __HWSetTriangleFunc
//
// Select the appropiate triangle rendering function depending on the
// current fillmode set for the current context
//
//-----------------------------------------------------------------------------
D3DFVFDRAWTRIFUNCPTR 
__HWSetTriangleFunc(PERMEDIA_D3DCONTEXT *pContext)
{

    if ( pContext->Hdr.FillMode == D3DFILL_SOLID )
        return P2_Draw_FVF_Solid_Tri;
    else
    {
        if ( pContext->Hdr.FillMode == D3DFILL_WIREFRAME )
            return P2_Draw_FVF_Wire_Tri;
        else
            // if it isn't solid nor line it must be a point filled triangle
            return P2_Draw_FVF_Point_Tri;
    }
}


//-----------------------------------------------------------------------------
//
// D3DFVFDRAWPNTFUNCPTR __HWSetPointFunc
//
// Select the appropiate point rendering function depending on the
// current point sprite mode  set for the current context
//
//-----------------------------------------------------------------------------
D3DFVFDRAWPNTFUNCPTR 
__HWSetPointFunc(PERMEDIA_D3DCONTEXT *pContext, LPP2FVFOFFSETS lpP2FVFOff)
{
//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    // Only if we are not enabling point sprites and the default point size
    // is 1.0f and vertexes don't have their own point size, then use 
    // classical points for rendering
    if ( pContext->bPointSpriteEnabled ||
         (pContext->fPointSize != 1.0f) ||
         (lpP2FVFOff->dwPntSizeOffset) )
        return P2_Draw_FVF_Point_Sprite;
    else
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT
        return P2_Draw_FVF_Point;
}


//-----------------------------------------------------------------------------
//
// void __TextureBlt
//
// Transfer a texture from system memory into AGP or video memory
//-----------------------------------------------------------------------------
HRESULT 
__TextureBlt(PERMEDIA_D3DCONTEXT* pContext,
             D3DHAL_DP2TEXBLT* lpdp2texblt)
{
    PPERMEDIA_D3DTEXTURE dsttex,srctex;
    RECTL rDest;
    PPDev ppdev=pContext->ppdev;

    DBG_D3D((10,"Entering __TextureBlt"));

    if (0 == lpdp2texblt->dwDDSrcSurface)
    {
        DBG_D3D((0,"Inavlid handle TexBlt from %08lx to %08lx",
            lpdp2texblt->dwDDSrcSurface,lpdp2texblt->dwDDDestSurface));
        return DDERR_INVALIDPARAMS;
    }

    srctex = TextureHandleToPtr(lpdp2texblt->dwDDSrcSurface,pContext);

    if(!CHECK_D3DSURFACE_VALIDITY(srctex))
    {
        DBG_D3D((0,"D3DDP2OP_TEXBLT: invalid dwDDSrcSurface !"));
        return DDERR_INVALIDPARAMS;
    }

    if (0 == lpdp2texblt->dwDDDestSurface)
    {
        PPERMEDIA_D3DTEXTURE pTexture = srctex;
        PermediaSurfaceData* pPrivateData = pTexture->pTextureSurface;
        if (!(pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
        {
            DBG_D3D((0,"Must be a managed texture to do texture preload"));
            return DDERR_INVALIDPARAMS;
        }
        if (NULL==pPrivateData->fpVidMem)
        {
            TextureCacheManagerAllocNode(pContext,pTexture);
            if (NULL==pPrivateData->fpVidMem)
            {
                DBG_D3D((0,"EnableTexturePermedia unable to "
                    "allocate memory from heap"));
                return DDERR_OUTOFVIDEOMEMORY;
            }
            pPrivateData->dwFlags |= P2_SURFACE_NEEDUPDATE;
        }
        if (pPrivateData->dwFlags & P2_SURFACE_NEEDUPDATE)
        {
            RECTL   rect;
            rect.left=rect.top=0;
            rect.right=pTexture->wWidth;
            rect.bottom=pTexture->wHeight;
            // texture download
            // Switch to DirectDraw context
            pPrivateData->dwFlags &= ~P2_SURFACE_NEEDUPDATE;
            // .. Convert it to Pixels

            pTexture->MipLevels[0].PixelOffset = 
                (ULONG)(pPrivateData->fpVidMem);
            switch(pTexture->pTextureSurface->SurfaceFormat.PixelSize) 
            {
                case __PERMEDIA_4BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset <<= 1;
                    break;
                case __PERMEDIA_8BITPIXEL: /* No Change*/
                    break;
                case __PERMEDIA_16BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset >>= 1;
                    break;
                case __PERMEDIA_24BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset /=  3;
                    break;
                case __PERMEDIA_32BITPIXEL:
                    pTexture->MipLevels[0].PixelOffset >>= 2;
                    break;
                default:
                    ASSERTDD(0,"Invalid Texture Pixel Size!");
                    pTexture->MipLevels[0].PixelOffset >>=  1;
                    break;
            }
            PermediaPatchedTextureDownload(pContext->ppdev, 
                                       pPrivateData,
                                       pTexture->fpVidMem,
                                       pTexture->lPitch,
                                       &rect,
                                       pPrivateData->fpVidMem,
                                       pTexture->lPitch,
                                       &rect);
            DBG_D3D((10, "Copy from %08lx to %08lx w=%08lx h=%08lx "
                "p=%08lx b=%08lx",
                pTexture->fpVidMem,pPrivateData->fpVidMem,pTexture->wWidth,
                pTexture->wHeight,pTexture->lPitch,pTexture->dwRGBBitCount));
        }
        return DD_OK;
    }
    else
    {
        dsttex = TextureHandleToPtr(lpdp2texblt->dwDDDestSurface,pContext);

        if(!CHECK_D3DSURFACE_VALIDITY(dsttex))
        {
            DBG_D3D((0,"D3DDP2OP_TEXBLT: invalid dwDDDestSurface !"));
            return DDERR_INVALIDPARAMS;
        }
    }

    if (NULL != dsttex && NULL != srctex)
    {
        rDest.left = lpdp2texblt->pDest.x;
        rDest.top = lpdp2texblt->pDest.y;
        rDest.right = rDest.left + lpdp2texblt->rSrc.right
                                         - lpdp2texblt->rSrc.left;
        rDest.bottom = rDest.top + lpdp2texblt->rSrc.bottom 
                                         - lpdp2texblt->rSrc.top;

        DBG_D3D((4,"TexBlt from %d %08lx %08lx to %d %08lx %08lx",
            lpdp2texblt->dwDDSrcSurface,srctex->dwCaps,srctex->dwCaps2,
            lpdp2texblt->dwDDDestSurface,dsttex->dwCaps,dsttex->dwCaps2));

        dsttex->dwPaletteHandle = srctex->dwPaletteHandle;
        dsttex->pTextureSurface->dwPaletteHandle = srctex->dwPaletteHandle;
        if ((DDSCAPS_VIDEOMEMORY & srctex->dwCaps) &&
            !(DDSCAPS2_TEXTUREMANAGE & srctex->dwCaps2))
        {
            PermediaSurfaceData* pPrivateDest = dsttex->pTextureSurface;
            PermediaSurfaceData* pPrivateSource = srctex->pTextureSurface;
            // If the surface sizes don't match, then we are stretching.
            // Also the blits from Nonlocal- to Videomemory have to go through
            // the texture unit!
            if (!(DDSCAPS_VIDEOMEMORY & dsttex->dwCaps) ||
                (DDSCAPS2_TEXTUREMANAGE & dsttex->dwCaps2))
            {
                DBG_DD((0,"DDBLT_ROP: NOT ABLE TO BLT FROM "
                          "VIDEO TO NON-VIDEO SURFACE"));
                return DDERR_INVALIDPARAMS;
            }
            if ( DDSCAPS_NONLOCALVIDMEM & srctex->dwCaps)
            {
                DBG_DD((3,"DDBLT_ROP: STRETCHCOPYBLT OR "
                          "MIRROR OR BOTH OR AGPVIDEO"));

                PermediaStretchCopyBlt( ppdev, 
                                        NULL, 
                                        pPrivateDest,
                                        pPrivateSource,
                                        &rDest,
                                        &lpdp2texblt->rSrc, 
                                        dsttex->MipLevels[0].PixelOffset, 
                                        srctex->MipLevels[0].PixelOffset);
            }
            else
            {
                ULONG   ulDestPixelShift=ShiftLookup[dsttex->dwRGBBitCount>>3];
                LONG    lPixPitchDest = dsttex->lPitch >> ulDestPixelShift;
                LONG    lPixPitchSrc = srctex->lPitch >> ulDestPixelShift;
                LONG    srcOffset=(LONG)((srctex->fpVidMem - dsttex->fpVidMem)
                                >> ulDestPixelShift);
                DBG_DD((3,"DDBLT_ROP:  COPYBLT %08lx %08lx %08lx",
                    srctex->fpVidMem, dsttex->fpVidMem, ulDestPixelShift));

                // For some reason, the user might want 
                // to do a conversion on the data as it is
                // blitted from VRAM->VRAM by turning on Patching. 
                // If Surf1Patch XOR Surf2Patch then
                // do a special blit that isn't packed and does patching.
                if (((pPrivateDest->dwFlags & P2_CANPATCH) ^ 
                     (pPrivateSource->dwFlags & P2_CANPATCH)) 
                       & P2_CANPATCH)
                {
                    DBG_DD((4,"Doing Patch-Conversion!"));

                    PermediaPatchedCopyBlt( ppdev, 
                                            lPixPitchDest, 
                                            lPixPitchSrc, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &lpdp2texblt->rSrc, 
                                            dsttex->MipLevels[0].PixelOffset, 
                                            srcOffset);
                }
                else
                {
                    DBG_DD((4,"Doing PermediaPackedCopyBlt!"));
                    PermediaPackedCopyBlt(  ppdev, 
                                            lPixPitchDest, 
                                            lPixPitchSrc, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &lpdp2texblt->rSrc, 
                                            dsttex->MipLevels[0].PixelOffset, 
                                            srcOffset);
                }
            }
        }
        else
        if (dsttex->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            // texture download
            if (pContext->CurrentTextureHandle == lpdp2texblt->dwDDDestSurface) 
                DIRTY_TEXTURE;
            dsttex->pTextureSurface->dwFlags |= P2_SURFACE_NEEDUPDATE;
            SysMemToSysMemSurfaceCopy(
                srctex->fpVidMem,
                srctex->lPitch,
                srctex->dwRGBBitCount,
                dsttex->fpVidMem,
                dsttex->lPitch,
                dsttex->dwRGBBitCount, 
                &lpdp2texblt->rSrc, 
                &rDest);
        }
        else
        if (DDSCAPS_NONLOCALVIDMEM & dsttex->dwCaps)
        {
            // Blt from system to AGP memory
            SysMemToSysMemSurfaceCopy(srctex->fpVidMem,
                                      srctex->lPitch,
                                      srctex->dwRGBBitCount,
                                      dsttex->fpVidMem,
                                      dsttex->lPitch,
                                      dsttex->dwRGBBitCount,
                                      &lpdp2texblt->rSrc,
                                      &rDest);
        }
        else
        if (DDSCAPS_LOCALVIDMEM & dsttex->dwCaps)
        {
            // texture download
            PermediaPatchedTextureDownload(ppdev, 
                                           dsttex->pTextureSurface,
                                           srctex->fpVidMem,
                                           srctex->lPitch,
                                           &lpdp2texblt->rSrc,
                                           dsttex->fpVidMem,
                                           dsttex->lPitch,
                                           &rDest);
        }
        else
        {
            DBG_DD((0,"DDBLT_ROP: NOT ABLE TO BLT FROM "
                      "SYSTEM TO NON-VIDEO SURFACE"));
            return DDERR_INVALIDPARAMS;
        }
    }

    DBG_D3D((10,"Exiting __TextureBlt"));
    return DD_OK;
}   //__TextureBlt

//-----------------------------------------------------------------------------
//
// void __SetRenderTarget
//
// Set new render and z buffer target surfaces
//-----------------------------------------------------------------------------
            
HRESULT  __SetRenderTarget(PERMEDIA_D3DCONTEXT* pContext,
                       DWORD hRenderTarget,
                       DWORD hZBuffer)
{
    DBG_D3D((10,"Entering __SetRenderTarget Target=%d Z=%d",
                                        hRenderTarget,hZBuffer));
    // Call a function to initialise registers that will setup the rendering
    pContext->RenderSurfaceHandle = hRenderTarget;
    pContext->ZBufferHandle = hZBuffer;
    SetupPermediaRenderTarget(pContext);

    // The AlphaBlending may need to be changed.
    DIRTY_ALPHABLEND;

    // Dirty the Z Buffer (the new target may not have one)
    DIRTY_ZBUFFER;

    DBG_D3D((10,"Exiting __SetRenderTarget"));

    return DD_OK;
} // __SetRenderTarget


//-----------------------------------------------------------------------------
//
// void __Clear
//
// Clears selectively the frame buffer, z buffer and stencil buffer for the 
// D3D Clear2 callback and for the D3DDP2OP_CLEAR command token.
//
//-----------------------------------------------------------------------------
HRESULT  __Clear( PERMEDIA_D3DCONTEXT* pContext,
              DWORD   dwFlags,        // in:  surfaces to clear
              DWORD   dwFillColor,    // in:  Color value for rtarget
              D3DVALUE dvFillDepth,   // in:  Depth value for
                                      //      Z-buffer (0.0-1.0)
              DWORD   dwFillStencil,  // in:  value used to clear stencil buffer
              LPD3DRECT lpRects,      // in:  Rectangles to clear
              DWORD   dwNumRects)     // in:  Number of rectangles
{
    int i;
    PermediaSurfaceData*    pPrivateData;
    RECTL*  pRect;
    PPDev   ppdev=pContext->ppdev;
    PERMEDIA_DEFS(pContext->ppdev);

    if (D3DCLEAR_TARGET & dwFlags)
    {
        DWORD   a,r,g,b;

        PPERMEDIA_D3DTEXTURE    pSurfRender = 
            TextureHandleToPtr(pContext->RenderSurfaceHandle, pContext);

        if(!CHECK_D3DSURFACE_VALIDITY(pSurfRender))
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: invalid RenderSurfaceHandle !"));
            return DDERR_INVALIDPARAMS;
        }

        pPrivateData = pSurfRender->pTextureSurface;

        if( NULL == pPrivateData)
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: NULL == pPrivateData(pSurfRender)!"));
            return DDERR_INVALIDPARAMS;
        }

        // Translate into HW specific format
        a = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.AlphaMask, 0x80000000);
        r = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.RedMask, 0x00800000);
        g = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.GreenMask, 0x00008000);
        b = RGB888ToHWFmt(dwFillColor,
                          pPrivateData->SurfaceFormat.BlueMask, 0x00000080);

        dwFillColor = a | r | g | b;

        DBG_D3D((8,"D3DDP2OP_CLEAR convert to %08lx with Mask %8lx %8lx %8lx",
                   dwFillColor,
                   pPrivateData->SurfaceFormat.RedMask,
                   pPrivateData->SurfaceFormat.GreenMask,
                   pPrivateData->SurfaceFormat.BlueMask));

        pRect = (RECTL*)lpRects;

        // Do clear for each Rect that we have
        for (i = dwNumRects; i > 0; i--)
        {
            PermediaFastClear(ppdev, pPrivateData,  
                pRect, pContext->PixelOffset, dwFillColor);
            pRect++;
        }
    }

    if (((D3DCLEAR_ZBUFFER
#if D3D_STENCIL
        | D3DCLEAR_STENCIL
#endif  //D3D_STENCIL
        ) & dwFlags) 
        && (0 != pContext->ZBufferHandle))
    {
        DWORD   dwZbufferClearValue = 0x0000FFFF; //no stencil case
        DWORD   dwWriteMask;
        PPERMEDIA_D3DTEXTURE    pSurfZBuffer = 
            TextureHandleToPtr(pContext->ZBufferHandle, pContext);

        if(!CHECK_D3DSURFACE_VALIDITY(pSurfZBuffer))
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: invalid ZBufferHandle !"));
            return DDERR_INVALIDPARAMS;
        }

        // get z buffer pixelformat info
        pPrivateData = pSurfZBuffer->pTextureSurface;

        if( NULL == pPrivateData)
        {
            DBG_D3D((0,"D3DDP2OP_CLEAR: NULL == pPrivateData(pSurfZBuffer)!"));
            return DDERR_INVALIDPARAMS;
        }

#if D3D_STENCIL
        //actually check dwStencilBitMask
        if (0 == pPrivateData->SurfaceFormat.BlueMask)
        {
            dwWriteMask = 0xFFFFFFFF;   //all 16bits are for Z
            dwZbufferClearValue = (DWORD)(dvFillDepth*0x0000FFFF);
        }
        else
        {
            dwWriteMask = 0;
            dwZbufferClearValue = (DWORD)(dvFillDepth*0x00007FFF);

            if (D3DCLEAR_ZBUFFER & dwFlags)
                dwWriteMask |= 0x7FFF7FFF;

            if (D3DCLEAR_STENCIL & dwFlags)
            {
                dwWriteMask |= 0x80008000;
                if (0 != dwFillStencil)
                {
                    dwZbufferClearValue |= 0x8000;  //or stencil bit
                }
            }
            if (0xFFFFFFFF != dwWriteMask)
            {
                RESERVEDMAPTR(1);
                SEND_PERMEDIA_DATA(FBHardwareWriteMask, dwWriteMask);
                COMMITDMAPTR();
            }
        }
#endif  //D3D_STENCIL

        pRect = (RECTL*)lpRects;

        for (i = dwNumRects; i > 0; i--)
        {                
            PermediaFastLBClear(ppdev, pPrivateData, pRect,
                (DWORD)((UINT_PTR)pSurfZBuffer->fpVidMem >> P2DEPTH16), 
                dwZbufferClearValue);
            pRect++;
        }

#if D3D_STENCIL
        // Restore the LB write mask is we didn't clear stencil & zbuffer
        if (0xFFFFFFFF != dwWriteMask)
        {
            RESERVEDMAPTR(1);
            SEND_PERMEDIA_DATA(FBHardwareWriteMask, 0xFFFFFFFF);    //restore
            COMMITDMAPTR();
        }
#endif  //D3D_STENCIL
    }
    
    return DD_OK;

} // __Clear

//-----------------------------------------------------------------------------
//
// void __PaletteSet
//
// Attaches a palette handle to a texture in the given context
// The texture is the one associated to the given surface handle.
//
//-----------------------------------------------------------------------------
HRESULT 
__PaletteSet(PERMEDIA_D3DCONTEXT* pContext,
             DWORD dwSurfaceHandle,
             DWORD dwPaletteHandle,
             DWORD dwPaletteFlags)
{
    PERMEDIA_D3DTEXTURE * pTexture;

    ASSERTDD(0 != dwSurfaceHandle, "dwSurfaceHandle==0 in D3DDP2OP_SETPALETTE");

    DBG_D3D((8,"SETPALETTE %d to %d", dwPaletteHandle, dwSurfaceHandle));

    pTexture = TextureHandleToPtr(dwSurfaceHandle, pContext);

    if (!CHECK_D3DSURFACE_VALIDITY(pTexture))
    {
        DBG_D3D((0,"__PaletteSet:NULL==pTexture Palette=%08lx Surface=%08lx", 
            dwPaletteHandle, dwSurfaceHandle));
        return DDERR_INVALIDPARAMS;   // invalid dwSurfaceHandle, skip it
    }

    pTexture->dwPaletteHandle = dwPaletteHandle;
    // need to make it into private data if driver created this surface
    if (NULL != pTexture->pTextureSurface)
        pTexture->pTextureSurface->dwPaletteHandle = dwPaletteHandle;
    if (pContext->CurrentTextureHandle == dwSurfaceHandle) 
        DIRTY_TEXTURE;
    if (0 == dwPaletteHandle)
    {
        return D3D_OK;  //palette association is OFF
    }

    // Check if we need to grow our palette list for this handle element
    if (NULL == pContext->pHandleList->dwPaletteList ||
        dwPaletteHandle >= PtrToUlong(pContext->pHandleList->dwPaletteList[0]))
    {
        DWORD newsize = ((dwPaletteHandle + 
                                LISTGROWSIZE)/LISTGROWSIZE)*LISTGROWSIZE;
        PPERMEDIA_D3DPALETTE *newlist = (PPERMEDIA_D3DPALETTE *)
                  ENGALLOCMEM( FL_ZERO_MEMORY, 
                               sizeof(PPERMEDIA_D3DPALETTE)*newsize,
                               ALLOC_TAG);

        DBG_D3D((8,"Growing pDDLcl=%x's "
                   "PaletteList[%x] size to %08lx",
                  pContext->pDDLcl, newlist, newsize));

        if (NULL == newlist)
        {
            DBG_D3D((0,"D3DDP2OP_SETPALETTE Out of memory."));
            return DDERR_OUTOFMEMORY;
        }

        memset(newlist,0,newsize);

        if (NULL != pContext->pHandleList->dwPaletteList)
        {
            memcpy(newlist,pContext->pHandleList->dwPaletteList,
                   PtrToUlong(pContext->pHandleList->dwPaletteList[0]) *
                         sizeof(PPERMEDIA_D3DPALETTE));
            ENGFREEMEM(pContext->pHandleList->dwPaletteList);
            DBG_D3D((8,"Freeing pDDLcl=%x's old PaletteList[%x]",
                       pContext->pDDLcl,
                       pContext->pHandleList->dwPaletteList));
        }

        pContext->pHandleList->dwPaletteList = newlist;
         //store size in dwSurfaceList[0]
        *(DWORD*)pContext->pHandleList->dwPaletteList = newsize;
    }

    // If we don't have a palette hanging from this palette list
    // element we have to create one. The actual palette data will
    // come down in the D3DDP2OP_UPDATEPALETTE command token.
    if (NULL == pContext->pHandleList->dwPaletteList[dwPaletteHandle])
    {
        pContext->pHandleList->dwPaletteList[dwPaletteHandle] = 
            (PERMEDIA_D3DPALETTE*)ENGALLOCMEM( FL_ZERO_MEMORY,
                                               sizeof(PERMEDIA_D3DPALETTE),
                                               ALLOC_TAG);
        if (NULL == pContext->pHandleList->dwPaletteList[dwPaletteHandle])
        {
            DBG_D3D((0,"D3DDP2OP_SETPALETTE Out of memory."));
            return DDERR_OUTOFMEMORY;
        }
    }

    // driver may store this dwFlags to decide whether 
    // ALPHA exists in Palette
    pContext->pHandleList->dwPaletteList[dwPaletteHandle]->dwFlags =
                                                            dwPaletteFlags;

    return DD_OK;

} // PaletteSet

//-----------------------------------------------------------------------------
//
// void __PaletteUpdate
//
// Updates the entries of a palette attached to a texture in the given context
//
//-----------------------------------------------------------------------------
HRESULT 
__PaletteUpdate(PERMEDIA_D3DCONTEXT* pContext,
                DWORD dwPaletteHandle, 
                WORD wStartIndex, 
                WORD wNumEntries,
                BYTE * pPaletteData)

{
    PERMEDIA_D3DPALETTE* pPalette;

    DBG_D3D((8,"UPDATEPALETTE %d (%d,%d) %d",
              dwPaletteHandle,
              wStartIndex,
              wNumEntries,
              pContext->CurrentTextureHandle));

    pPalette = PaletteHandleToPtr(dwPaletteHandle,pContext);

    if (NULL != pPalette)
    {
        ASSERTDD(256 >= wStartIndex + wNumEntries,
                 "wStartIndex+wNumEntries>256 in D3DDP2OP_UPDATEPALETTE");

        // Copy the palette & associated data
        pPalette->wStartIndex = wStartIndex;
        pPalette->wNumEntries = wNumEntries;

        memcpy((LPVOID)&pPalette->ColorTable[wStartIndex],
               (LPVOID)pPaletteData,
               (DWORD)wNumEntries*sizeof(PALETTEENTRY));

        // If we are currently texturing and the texture is using the
        // palette we just updated, dirty the texture flag so that
        // it set up with the right (updated) palette
        if (pContext->CurrentTextureHandle)
        {
            PERMEDIA_D3DTEXTURE * pTexture=
                TextureHandleToPtr(pContext->CurrentTextureHandle,pContext);

            if (pTexture && pTexture->pTextureSurface)
            {
                if (pTexture->dwPaletteHandle == dwPaletteHandle)
                {
                    DIRTY_TEXTURE;
                    DBG_D3D((8,"UPDATEPALETTE DIRTY_TEXTURE"));
                }
            }
        }
    }
    else
    {
        return DDERR_INVALIDPARAMS;
    }
    return DD_OK;

} // __PaletteUpdate


//-----------------------------------------------------------------------------
//
// void __RestoreD3DContext
//
// Restores the P2 registers to what they were when we last left this D3D context
//
//-----------------------------------------------------------------------------
void __RestoreD3DContext(PPDev ppdev, PERMEDIA_D3DCONTEXT* pContext)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(ppdev);

    // Dirty everything in order to restore the D3D state
    DIRTY_TEXTURE;
    DIRTY_ZBUFFER;
    DIRTY_ALPHABLEND;

    // Restore the correct surface (render & depth buffer) characteristics
    SetupPermediaRenderTarget(pContext);

    //Bring back manually some registers which we care about
    RESERVEDMAPTR(5);
    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
    COPY_PERMEDIA_DATA(ColorDDAMode, pSoftPermedia->ColorDDAMode);
    COPY_PERMEDIA_DATA(FogColor, pSoftPermedia->FogColor);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, -1 );
    COMMITDMAPTR();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtext.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtext.h
*
*  Content:  D3D Texture management related definitions and macros
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifdef __TEXTURES
#pragma message ("FILE : "__FILE__" : Multiple Inclusion");
#endif

#define __TEXTURES


//-----------------------------------------------------------------------------
//                        Texture validation macros 
//-----------------------------------------------------------------------------
#define TC_MAGIC_DISABLE 0xd3d10000
#define TC_MAGIC_NO 0xd3d10100

#define CHECK_D3DSURFACE_VALIDITY(ptr)               \
    ((ptr) != NULL && (ptr)->MagicNo == TC_MAGIC_NO)

#define CHECK_TEXTURESTRUCT_VALIDITY(ptr)         \
    ( ((ptr) != NULL) &&                          \
      ( ((ptr)->MagicNo == TC_MAGIC_NO) ||        \
        ((ptr)->MagicNo == TC_MAGIC_DISABLE) )    \
    )

//-----------------------------------------------------------------------------
//                       Texture structure definitions
//-----------------------------------------------------------------------------

// We only handle one single mipmap on this sample driver since the P2 doesn't
// natively support them
#if D3D_MIPMAPPING
#define MAX_MIP_LEVELS 12
#else
#define MAX_MIP_LEVELS 1
#endif // D3D_MIPMAPPING

// stores information needed to quickly setup a mipmap level on
// the chip.  At the moment this is Partial Products and widths/heights
typedef struct tagMIPTEXTURE {

    // Widths and heights for this mip level
    INT logWidth;
    INT logHeight;

    // Partial products for this mip level
    ULONG ulPackedPP;

    // Offset in pixels to start of the texture
    // for the current miplevel
    DWORD PixelOffset;

} MIPTEXTURE;

typedef struct _permedia_d3dtexture 
{
    // Magic number to verify validity of pointer
    ULONG MagicNo ;

    // the following four memebers are exact replicates
    // of those in DDRAWI_DDRAWSURFACE_GBL
    DWORD       dwCaps;
    DWORD       dwCaps2;
    FLATPTR     fpVidMem;                  // pointer to video memory
    LONG        lPitch;                    // pitch of surface
    DWORD       dwRGBBitCount;
    UINT_PTR    lSurfaceOffset;

    // Width and Height of texture
    WORD    wWidth;
    WORD    wHeight;

    // The AGP that the last texture came from
    DWORD dwGARTDevLast;

    BOOL bMipMap;
    DWORD                   m_dwBytes;
    DWORD                   m_dwPriority;
    DWORD                   m_dwTicks;
    DWORD                   m_dwHeapIndex;
    ULONG       HandleListIndex;    // indicating which list it's with
    // For setting up MipMaps 
    MIPTEXTURE MipLevels[MAX_MIP_LEVELS];

    DWORD       dwFlags;
    DWORD       dwKeyLow;
    DWORD       dwKeyHigh;
    PermediaSurfaceData* pTextureSurface;
    DWORD       dwPaletteHandle;

    // The number of mipmap levels this texture should have
    int iMipLevels;
} PERMEDIA_D3DTEXTURE, *PPERMEDIA_D3DTEXTURE;

//-----------------------------------------------------------------------------
//                       DX7 Texture management definitions
//-----------------------------------------------------------------------------

typedef struct _permedia_d3dpalette 
{
    DWORD   dwFlags;
    WORD    wStartIndex;
    WORD    wNumEntries;
    PALETTEENTRY ColorTable[256];   // array of palette entries, could be dynamic later
} PERMEDIA_D3DPALETTE, *PPERMEDIA_D3DPALETTE;

#define LISTGROWSIZE    1024
typedef struct _DWLIST
{
    PPERMEDIA_D3DTEXTURE   *dwSurfaceList;    // array to hold handles, 
                                              // dynamically allocated 
                                              // dwSurfaceList[0] is the number 
                                              // of entries in dwSurfaceList 
                                              // if allocated
    PPERMEDIA_D3DPALETTE   *dwPaletteList;    // array to hold handles, 
                                              // dynamically allocated 
                                              // dwPaletteList[0] is the number
                                              // of entries in dwPaletteList
                                              // if allocated
    LPVOID  pDDLcl;                           // owning ddraw pointer as a key
} DWLIST;
typedef DWLIST FAR* LPDWLIST;
extern DWLIST  HandleList[]; 
extern LPDWLIST GetSurfaceHandleList(LPVOID);
void ReleaseSurfaceHandleList(LPVOID);
PERMEDIA_D3DPALETTE *PaletteHandleToPtr(UINT_PTR phandle,
                                        PERMEDIA_D3DCONTEXT* pContext);

//-----------------------------------------------------------------------------
//                              Texture debugging
//-----------------------------------------------------------------------------
// Tracing/Debugging functions
void DumpTexture(PPDev ppdev,
                 PERMEDIA_D3DTEXTURE* pTexture,
                 DDPIXELFORMAT* pPixelFormat);


#ifdef DBG
#define DISPTEXTURE(arg) DumpTexture arg
#else
#define DISPTEXTURE(arg)
#endif

//-----------------------------------------------------------------------------
//                      Texture hash table definitions
//-----------------------------------------------------------------------------
#define TEXTURE_HASH_SIZE   256     // these many entries in the hash table

void InitTextureHashTable(PERMEDIA_D3DCONTEXT   *pContext);

// Then the hash funtion is just an 'and'
#define TEXTURE_HASH_OF(i)  ((i) & 0xff)

PERMEDIA_D3DTEXTURE *TextureHandleToPtr(UINT_PTR thandle,
                                        PERMEDIA_D3DCONTEXT* pContext);

void StorePermediaLODLevel(PPDev ppdev,
                           PERMEDIA_D3DTEXTURE* pTexture,
                           LPDDRAWI_DDRAWSURFACE_LCL pSurf,
                           int LOD);

//-----------------------------------------------------------------------------
//                  Texture coordinate wrapping macros
//-----------------------------------------------------------------------------
#define FLUSH_DUE_TO_WRAP(par)
#define DONT_FLUSH_DUE_TO_WRAP(par)
#define WRAP(par, wrapit) if(wrapit) {                      \
    float elp;                                              \
    float erp;                                              \
    float emp;                                              \
    elp = (float)fabs(par##1 - par##0);                     \
    erp = (float)fabs(par##2 - par##1);                     \
    emp = (float)fabs(par##0 - par##2);                     \
    if( (elp > (float)0.5) && (erp > (float)0.5) )          \
    {                                                       \
        if (par##1 < par##2) { par##1 += 1.0; }             \
        else { par##2 += 1.0; par##0 += 1.0; }              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else if( (erp > (float)0.5) && (emp > (float)0.5) )     \
    {                                                       \
        if (par##2 < par##0) { par##2 += 1.0; }             \
        else { par##0 += 1.0; par##1 += 1.0; }              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else if( (emp > (float)0.5) && (elp > (float)0.5) )     \
    {                                                       \
        if(par##0 < par##1) { par##0 += 1.0; }              \
        else { par##1 += 1.0; par##2 += 1.0; }              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else                                                    \
    {                                                       \
        DONT_FLUSH_DUE_TO_WRAP(par);                        \
    }                                                       \
} else {                                                    \
    DONT_FLUSH_DUE_TO_WRAP(par);                            \
}

 
#define WRAP_LINE(par, wrapit) if(wrapit) {                 \
    float elp;                                              \
    elp = (float)fabs(par##1 - par##0);                     \
    if(elp > (float)0.5)                                    \
    {                                                       \
        if (par##1 < par##0) { par##1 += 1.0; }             \
        else { par##0 += 1.0;}                              \
        FLUSH_DUE_TO_WRAP(par);                             \
    }                                                       \
    else                                                    \
    {                                                       \
        DONT_FLUSH_DUE_TO_WRAP(par);                        \
    }                                                       \
} else {                                                    \
    DONT_FLUSH_DUE_TO_WRAP(par);                            \
}


//-----------------------------------------------------------------------------
//                  Texture coordinate recentering macros
//-----------------------------------------------------------------------------

// Keeps the texture coordinates centered around 0 
// and avoid exceeding the texel wrapping limit.
#define RECENTER_TEX_COORDS(Maxf, Maxi, fTC0, fTC1, fTC2)                \
{                                                                        \
    long tcmax;                                                          \
    unsigned long tcmin;                                                 \
    int i;                                                               \
                                                                         \
    tcmax = LONG_AT(fTC0);                                               \
    if (tcmax < LONG_AT(fTC1)) tcmax = LONG_AT(fTC1);                    \
    if (tcmax < LONG_AT(fTC2)) tcmax = LONG_AT(fTC2);                    \
    if (tcmax >= *(long *)&Maxf)                                         \
    {                                                                    \
        myFtoi(&i, *(float *)&tcmax);                                    \
        i -= Maxi;                                                       \
        fTC0 -= i;                                                       \
        fTC1 -= i;                                                       \
        fTC2 -= i;                                                       \
    }                                                                    \
    else                                                                 \
    {                                                                    \
        tcmin = ULONG_AT(fTC0);                                          \
        if (tcmin < ULONG_AT(fTC1)) tcmin = ULONG_AT(fTC1);              \
        if (tcmin < ULONG_AT(fTC2)) tcmin = ULONG_AT(fTC2);              \
        if (*(float *)&tcmin <= -Maxf)                                   \
        {                                                                \
            myFtoi(&i, *(float *)&tcmin);                                \
            i += Maxi;                                                   \
            fTC0 -= i;                                                   \
            fTC1 -= i;                                                   \
            fTC2 -= i;                                                   \
        }                                                                \
    }                                                                    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dstate.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstate.c
*
*       Contains code to translate D3D renderstates and texture stage
*       states into hardware specific settings.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#include "d3ddelta.h"
#include "d3dtxman.h"
#define ALLOC_TAG ALLOC_TAG_SD2P
//-----------------------------------------------------------------------------
//
// void __SelectFVFTexCoord
//
// This utility function sets the correct texture offset depending on the
// texturing coordinate set wished to be used from the FVF vertexes
//
//-----------------------------------------------------------------------------
void 
__SelectFVFTexCoord(LPP2FVFOFFSETS lpP2FVFOff, DWORD dwTexCoord)
{
    DBG_D3D((10,"Entering __SelectFVFTexCoord"));

    lpP2FVFOff->dwTexOffset = lpP2FVFOff->dwTexBaseOffset + 
                                dwTexCoord * 2 * sizeof(D3DVALUE);

    // verify the requested texture coordinate doesn't exceed the FVF 
    // vertex structure provided , if so go down to set 0 as a 
    // crash-avoiding alternative
    if (lpP2FVFOff->dwTexOffset >= lpP2FVFOff->dwStride)
        lpP2FVFOff->dwTexOffset = lpP2FVFOff->dwTexBaseOffset;

    DBG_D3D((10,"Exiting __SelectFVFTexCoord"));
} // __SelectFVFTexCoord


//-----------------------------------------------------------------------------
//
// HRESULT __HWPreProcessTSS
//
// Processes the state changes that must be done as soon as they arrive
//
//-----------------------------------------------------------------------------
void __HWPreProcessTSS(PERMEDIA_D3DCONTEXT *pContext, 
                      DWORD dwStage, 
                      DWORD dwState, 
                      DWORD dwValue)
{
    DBG_D3D((10,"Entering __HWPreProcessTSS"));

    if (D3DTSS_ADDRESS == dwState)
    {
        pContext->TssStates[D3DTSS_ADDRESSU] = dwValue;
        pContext->TssStates[D3DTSS_ADDRESSV] = dwValue;
    }
    else
    if (D3DTSS_TEXTUREMAP == dwState && 0 != dwValue)
    {
        PPERMEDIA_D3DTEXTURE   pTexture=TextureHandleToPtr(dwValue, pContext);
        if (CHECK_D3DSURFACE_VALIDITY(pTexture) &&
            (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) 
        {
            TextureCacheManagerIncNumTexturesSet(pContext->pTextureManager);
            if (pTexture->m_dwHeapIndex)
                TextureCacheManagerIncNumSetTexInVid(pContext->pTextureManager);
        }
    }
    DBG_D3D((10,"Exiting __HWPreProcessTSS"));
} // __HWPreProcessTSS

//-----------------------------------------------------------------------------
//
// HRESULT __HWSetupStageStates
//
// Processes the state changes related to the DX6 texture stage states in the 
// current rendering context
//
//-----------------------------------------------------------------------------
HRESULT WINAPI __HWSetupStageStates(PERMEDIA_D3DCONTEXT *pContext, 
                                    LPP2FVFOFFSETS lpP2FVFOff)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    DWORD           *pFlags = &pContext->Hdr.Flags;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering __HWSetupStageStates"));

    
    // If we are to texture map our primitives
    if (pContext->TssStates[D3DTSS_TEXTUREMAP])
    {
        DWORD dwMag = pContext->TssStates[D3DTSS_MAGFILTER];
        DWORD dwMin = pContext->TssStates[D3DTSS_MINFILTER];
        DWORD dwMip = pContext->TssStates[D3DTSS_MIPFILTER];
        DWORD dwCop = pContext->TssStates[D3DTSS_COLOROP];
        DWORD dwCa1 = pContext->TssStates[D3DTSS_COLORARG1];
        DWORD dwCa2 = pContext->TssStates[D3DTSS_COLORARG2];
        DWORD dwAop = pContext->TssStates[D3DTSS_ALPHAOP];
        DWORD dwAa1 = pContext->TssStates[D3DTSS_ALPHAARG1];
        DWORD dwAa2 = pContext->TssStates[D3DTSS_ALPHAARG2];
        DWORD dwTau = pContext->TssStates[D3DTSS_ADDRESSU];
        DWORD dwTav = pContext->TssStates[D3DTSS_ADDRESSV];
        DWORD dwTxc = pContext->TssStates[D3DTSS_TEXCOORDINDEX];

        DBG_D3D((6,"Setting up w TSS:"
                   "dwCop=%x dwCa1=%x dwCa2=%x dwAop=%x dwAa1=%x dwAa2=%x "
                   "dwMag=%x dwMin=%x dwMip=%x dwTau=%x dwTav=%x dwTxc=%x",
                   dwCop, dwCa1, dwCa2, dwAop, dwAa1, dwAa2,
                   dwMag, dwMin, dwMip, dwTau, dwTav, dwTxc));

        // Choose texture coord to use
        __SelectFVFTexCoord( lpP2FVFOff, dwTxc);

        // Current is the same as diffuse in stage 0
        if (dwCa2 == D3DTA_CURRENT)
            dwCa2 = D3DTA_DIFFUSE;
        if (dwAa2 == D3DTA_CURRENT)
            dwAa2 = D3DTA_DIFFUSE;

        // Check if we need to disable texturing 
        if (dwCop == D3DTOP_DISABLE || 
            (dwCop == D3DTOP_SELECTARG2 && dwCa2 == D3DTA_DIFFUSE && 
             dwAop == D3DTOP_SELECTARG2 && dwAa2 == D3DTA_DIFFUSE))
        {
            //Please don't clear pContext->TssStates[D3DTSS_TEXTUREMAP] though
           pContext->CurrentTextureHandle = 0;
            DBG_D3D((10,"Exiting __HWSetupStageStates , texturing disabled"));
            return DD_OK;
        }

        // setup the address mode
        switch (dwTau) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to TSS U address mode = %d"
                                                                      ,dwTau));
                pSoftPermedia->TextureReadMode.SWrapMode = _P2_TEXTURE_REPEAT;
                break;
        }
        switch (dwTav) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to TSS V address mode = %d"
                                                                      ,dwTav));
                pSoftPermedia->TextureReadMode.TWrapMode = _P2_TEXTURE_REPEAT;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();

        // Enable-disable wrapping flags for U & V       
        if (pContext->dwWrap[dwTxc] &  D3DWRAPCOORD_0)
        {
            *pFlags |= CTXT_HAS_WRAPU_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPU_ENABLED;
        }

        if (pContext->dwWrap[dwTxc] &  D3DWRAPCOORD_1)
        {
            *pFlags |= CTXT_HAS_WRAPV_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPV_ENABLED;
        }

        // Setup the equivalent texture filtering state
        if (dwMip == D3DTFP_NONE) 
        {
            // We can only take care of magnification filtering on the P2
            if (dwMag == D3DTFG_LINEAR)
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_LINEAR;
            }
            else if (dwMag == D3DTFG_POINT)
            {
                pContext->bMagFilter = FALSE; // D3DFILTER_NEAREST;
            }
        }
        else if (dwMip == D3DTFP_POINT) 
        {
            if (dwMin == D3DTFN_POINT) 
            {
                pContext->bMagFilter = FALSE; // D3DFILTER_MIPNEAREST;
            }
            else if (dwMin == D3DTFN_LINEAR) 
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_MIPLINEAR;
            }
        }
        else 
        { // dwMip == D3DTFP_LINEAR
            if (dwMin == D3DTFN_POINT) 
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_LINEARMIPNEAREST;
            }
            else if (dwMin == D3DTFN_LINEAR) 
            {
                pContext->bMagFilter = TRUE; // D3DFILTER_LINEARMIPLINEAR;
            }
        }

        // Setup the equivalent texture blending state
        // Check if we need to decal
        if ((dwCa1 == D3DTA_TEXTURE && dwCop == D3DTOP_SELECTARG1) &&
             (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_SELECTARG1)) 
        {
            // D3DTBLEND_COPY;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_COPY;
        }
        // check if we the app modified the TSS for decaling after first
        // setting it up for modulating via the legacy renderstates
        // this is a Permedia2 specific optimization.
        else if ((dwCa1 == D3DTA_TEXTURE && dwCop == D3DTOP_SELECTARG1) &&
             (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_LEGACY_ALPHAOVR)) 
        {
            // D3DTBLEND_COPY;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_COPY;
        }
        // Check if we need to modulate & pass texture alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) &&
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_SELECTARG1)) 
        {
            // D3DTBLEND_MODULATE;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        }
        // Check if we need to modulate & pass diffuse alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) &&
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa2 == D3DTA_DIFFUSE && dwAop == D3DTOP_SELECTARG2)) 
        {
            // D3DTBLEND_MODULATE;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        }
        // Check if we need to do legacy modulate
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) &&
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa1 == D3DTA_TEXTURE && dwAop == D3DTOP_LEGACY_ALPHAOVR)) 
        {
            // D3DTBLEND_MODULATE;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        }
        // Check if we need to decal alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) && 
                  dwCop == D3DTOP_BLENDTEXTUREALPHA &&
                 (dwAa2 == D3DTA_DIFFUSE && dwAop == D3DTOP_SELECTARG2)) 
        {
            // D3DTBLEND_DECALALPHA;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_DECAL;
        }
        // Check if we need to modulate alpha
        else if ((dwCa2 == D3DTA_DIFFUSE && dwCa1 == D3DTA_TEXTURE) && 
                  dwCop == D3DTOP_MODULATE &&
                 (dwAa2 == D3DTA_DIFFUSE && dwAa1 == D3DTA_TEXTURE) && 
                  dwAop == D3DTOP_MODULATE) 
        {
            // D3DTBLEND_MODULATEALPHA;
            pSoftPermedia->TextureColorMode.ApplicationMode =
                                                         _P2_TEXTURE_MODULATE;
        } else
        {
            DBG_D3D((0,"Trying to setup a state we don't understand!"));
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureColorMode, pSoftPermedia->TextureColorMode);
        COMMITDMAPTR();

        pContext->CurrentTextureHandle = pContext->TssStates[D3DTSS_TEXTUREMAP];
    }
    else
        // No texturing
        pContext->CurrentTextureHandle = 0;

    DIRTY_TEXTURE;

    DBG_D3D((10,"Exiting __HWSetupStageStates"));

    return DD_OK;
} //__HWSetupStageStates

//-----------------------------------------------------------------------------
//
// void __HandleDirtyPermediaState
// 
// Setup of context that is deferred until just before 
// rendering an actual rendering primitive
//
//-----------------------------------------------------------------------------
void 
__HandleDirtyPermediaState(PPDev ppdev, 
                           PERMEDIA_D3DCONTEXT* pContext,
                           LPP2FVFOFFSETS lpP2FVFOff)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    PERMEDIA_DEFS(pContext->ppdev);

    ULONG AlphaBlendSend;

    DBG_D3D((10,"Entering __HandleDirtyPermediaState"));

    // We need to keep this ordering of evaluation on the P2

    // --------------Have the texture or the stage states changed ? -----------

    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_TEXTURE)
    {
        DBG_D3D((4,"preparing to handle CONTEXT_DIRTY_TEXTURE"));
        // Choose between legacy Texture Handle or TSS
        if (pContext->dwDirtyFlags & CONTEXT_DIRTY_MULTITEXTURE)
        {
            pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_MULTITEXTURE;
            //Setup TSS state AND textures
            if ( SUCCEEDED(__HWSetupStageStates(pContext, lpP2FVFOff)) )
            {
                // if this FVF has no tex coordinates at all disable texturing
                if (lpP2FVFOff->dwTexBaseOffset == 0)
                {
                    pContext->CurrentTextureHandle = 0;
                    DBG_D3D((2,"No texture coords present in FVF "
                               "to texture map primitives"));
                }
            }
            else
            {
                pContext->CurrentTextureHandle = 0;
                DBG_D3D((0,"TSS Setup failed"));
            }
        }
        else
        {   
            // select default texture coordinate index
             __SelectFVFTexCoord( lpP2FVFOff, 0);
        }
    }

    // --------------Has the state of the LB changed ? ------------------------

    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ZBUFFER)
    {
        DBG_D3D((4,"CONTEXT_DIRTY_ZBUFFER handled"));
        pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_ZBUFFER;

        if ((pContext->Hdr.Flags & CTXT_HAS_ZBUFFER_ENABLED) && 
            (pContext->ZBufferHandle))
        {
            if (pContext->Hdr.Flags & CTXT_HAS_ZWRITE_ENABLED)
            {
                if (__PERMEDIA_DEPTH_COMPARE_MODE_NEVER ==
                    (int)pSoftPermedia->DepthMode.CompareMode)
                {
                    pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                             __PERMEDIA_DISABLE;
                    pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                }
                else
                {
                    pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                             __PERMEDIA_ENABLE;
                    pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
                }
                pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_ENABLE;
            } 
            else 
            {
                pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                         __PERMEDIA_ENABLE;
                pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_DISABLE;
            }

            // We are Z Buffering 

            // Enable Z test
            pSoftPermedia->DepthMode.UnitEnable = __PERMEDIA_ENABLE;

            // Tell delta we are Z Buffering.
            pSoftPermedia->DeltaMode.DepthEnable = 1;
        }
        else
        {
            // We are NOT Z Buffering

            // Disable Writes
            pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_DISABLE;

            // Disable Z test
            pSoftPermedia->DepthMode.UnitEnable = __PERMEDIA_DISABLE;
            pSoftPermedia->DepthMode.WriteMask = __PERMEDIA_DISABLE;

            // No reads, no writes
            pSoftPermedia->LBReadMode.ReadDestinationEnable =
                                                         __PERMEDIA_DISABLE;
            // Tell delta we aren't Z Buffering.
            pSoftPermedia->DeltaMode.DepthEnable = 0;
        }

        if (__PERMEDIA_ENABLE == pSoftPermedia->StencilMode.UnitEnable)
        {
            pSoftPermedia->LBReadMode.ReadDestinationEnable = __PERMEDIA_ENABLE;

            pSoftPermedia->LBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
        }

        RESERVEDMAPTR(7);
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
        COPY_PERMEDIA_DATA(StencilMode, pSoftPermedia->StencilMode);
        COPY_PERMEDIA_DATA(StencilData, pSoftPermedia->StencilData);
        COPY_PERMEDIA_DATA(Window, pSoftPermedia->Window);
        COPY_PERMEDIA_DATA(DepthMode, pSoftPermedia->DepthMode);
        COPY_PERMEDIA_DATA(LBReadMode, pSoftPermedia->LBReadMode);
        COPY_PERMEDIA_DATA(LBWriteMode, pSoftPermedia->LBWriteMode);
        COMMITDMAPTR();

    } // if CONTEXT_DIRTY_ZBUFFER

    // ----------------Has the alphablend type changed ? ----------------------


    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ALPHABLEND)
    {
        // Only clear when we have an alphablend dirty context
        pContext->FakeBlendNum &= ~FAKE_ALPHABLEND_ONE_ONE;

        pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_ALPHABLEND;

        // Verify that requested blend mode is HW supported
        DWORD dwBlendMode;
        dwBlendMode = 
            (((DWORD)pSoftPermedia->AlphaBlendMode.SourceBlend) |
             ((DWORD)pSoftPermedia->AlphaBlendMode.DestinationBlend) << 4);

        DBG_D3D((4,"CONTEXT_DIRTY_ALPHABLEND handled: Blend mode = %08lx",
                                                              dwBlendMode));

        switch (dwBlendMode) {

            // In this case, we set the bit to the QuickDraw mode
            case __PERMEDIA_BLENDOP_ONE_AND_INVSRCALPHA:
                DBG_D3D((4,"Blend Operation is PreMult"));
                pSoftPermedia->AlphaBlendMode.BlendType = 1;
                break;
            // This is the standard blend
            case __PERMEDIA_BLENDOP_SRCALPHA_AND_INVSRCALPHA:
                DBG_D3D((4,"Blend Operation is Blend"));
                pSoftPermedia->AlphaBlendMode.BlendType = 0;
                break;
            case ((__PERMEDIA_BLEND_FUNC_ZERO << 4) | 
                   __PERMEDIA_BLEND_FUNC_SRC_ALPHA):
                // we substitute the SrcBlend = SrcAlpha DstBlend = 1
                // with the 1,0 mode since we really dont' support
                // it, just so apps perform reasonably
                pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 0;

            case ((__PERMEDIA_BLEND_FUNC_ONE << 4) 
                 | __PERMEDIA_BLEND_FUNC_ZERO):

            case __PERMEDIA_BLENDOP_ONE_AND_ZERO:
            // This is code for 'no blending'
                DBG_D3D((4,"Blend Operation is validly None"));
                break;
            case ((__PERMEDIA_BLEND_FUNC_ONE << 4) | 
                   __PERMEDIA_BLEND_FUNC_SRC_ALPHA):
                // we substitute the SrcBlend = SrcAlpha DstBlend = 1
                // with the 1,1 mode since we really dont' support
                // it, just so apps perform reasonably
            case __PERMEDIA_BLENDOP_ONE_AND_ONE:
                DBG_D3D((4,"BlendOperation is 1 Source, 1 Dest"));
                pSoftPermedia->AlphaBlendMode.BlendType = 1;
                pContext->FakeBlendNum |= FAKE_ALPHABLEND_ONE_ONE;
                break;
            default:
                DBG_D3D((2,"Blend Operation is invalid! BlendOp == %x",
                                                              dwBlendMode));
                // This is a fallback blending mode 
                dwBlendMode = __PERMEDIA_BLENDOP_ONE_AND_ZERO;
                break;
        }


        if ((pContext->Hdr.Flags & CTXT_HAS_ALPHABLEND_ENABLED) && 
            (dwBlendMode != __PERMEDIA_BLENDOP_ONE_AND_ZERO))
        {
            // Set the AlphaBlendMode register on Permedia
            pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 1;
            // Turn on destination read in the FBReadMode register
            pSoftPermedia->FBReadMode.ReadDestinationEnable = 1;
        }
        else
        {
            // Set the AlphaBlendMode register on Permedia
            pSoftPermedia->AlphaBlendMode.AlphaBlendEnable = 0;
            // Turn off the destination read in FbReadMode register
            pSoftPermedia->FBReadMode.ReadDestinationEnable = 0;

            // if not sending alpha, turn alpha to 1
            RESERVEDMAPTR(1);
            SEND_PERMEDIA_DATA(AStart,      PM_BYTE_COLOR(0xFF));
            COMMITDMAPTR();
        }

        AlphaBlendSend = ((DWORD)*(DWORD*)(&pSoftPermedia->AlphaBlendMode));

        // Insert changes in blend mode for unsupported blend operations
        // in this function
        if (FAKE_ALPHABLEND_ONE_ONE & pContext->FakeBlendNum)
        {
            AlphaBlendSend &= 0xFFFFFF01;
            AlphaBlendSend |= (__PERMEDIA_BLENDOP_ONE_AND_INVSRCALPHA << 1);
        }

        RESERVEDMAPTR(2);
        COPY_PERMEDIA_DATA(FBReadMode,     pSoftPermedia->FBReadMode);
        COPY_PERMEDIA_DATA(AlphaBlendMode, AlphaBlendSend);
        COMMITDMAPTR();

    }

    // --------------------Has the texture handle changed ? -------------------

    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_TEXTURE)
    {
        pContext->dwDirtyFlags &= ~CONTEXT_DIRTY_TEXTURE;
        DBG_D3D((4,"CONTEXT_DIRTY_TEXTURE handled"));
        if (pContext->CurrentTextureHandle == 0)
            DisableTexturePermedia(pContext);
        else
            EnableTexturePermedia(pContext);
    }

    DBG_D3D((10,"Exiting __HandleDirtyPermediaState"));

} // __HandleDirtyPermediaState

//-----------------------------------------------------------------------------
//
// void __MapRS_Into_TSS0
//
// Map Renderstate changes into the corresponding change in the Texture Stage
// State #0 .
//
//-----------------------------------------------------------------------------
void 
__MapRS_Into_TSS0(PERMEDIA_D3DCONTEXT* pContext,
                  DWORD dwRSType,
                  DWORD dwRSVal)
{
    DBG_D3D((10,"Entering __MapRS_Into_TSS0"));

    // Process each specific renderstate
    switch (dwRSType)
    {

    case D3DRENDERSTATE_TEXTUREHANDLE:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_TEXTUREMAP] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        switch (dwRSVal)
        {
            case D3DTBLEND_DECALALPHA:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] =
                                               D3DTOP_BLENDTEXTUREALPHA;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG2;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                break;
            case D3DTBLEND_MODULATE:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_MODULATE;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                // a special legacy alpha operation is called for
                // that depends on the format of the texture
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_LEGACY_ALPHAOVR;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                break;
            case D3DTBLEND_MODULATEALPHA:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_MODULATE;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_MODULATE;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                break;
            case D3DTBLEND_COPY:
            case D3DTBLEND_DECAL:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_SELECTARG1;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG1;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                break;
            case D3DTBLEND_ADD:
                //Mirror texture related render states into TSS stage 0
                pContext->TssStates[D3DTSS_COLOROP] = D3DTOP_ADD;
                pContext->TssStates[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                pContext->TssStates[D3DTSS_ALPHAOP] = D3DTOP_SELECTARG2;
                pContext->TssStates[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                pContext->TssStates[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        }
        break;

    case D3DRENDERSTATE_BORDERCOLOR:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_BORDERCOLOR] = dwRSVal;
        break;

    case D3DRENDERSTATE_MIPMAPLODBIAS:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_MIPMAPLODBIAS] = dwRSVal;
        break;

    case D3DRENDERSTATE_ANISOTROPY:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_MAXANISOTROPY] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREADDRESS:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_ADDRESSU] =
        pContext->TssStates[D3DTSS_ADDRESSV] = dwRSVal; 
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSU:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_ADDRESSU] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSV:
        //Mirror texture related render states into TSS stage 0
        pContext->TssStates[D3DTSS_ADDRESSV] = dwRSVal;
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
        switch(dwRSVal)
        {
            case D3DFILTER_NEAREST:
                pContext->TssStates[D3DTSS_MAGFILTER] = D3DTFG_POINT;
                break;
            case D3DFILTER_LINEAR:
            case D3DFILTER_MIPLINEAR:
            case D3DFILTER_MIPNEAREST:
            case D3DFILTER_LINEARMIPNEAREST:
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->TssStates[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                break;
            default:
                break;
        }
        break;

    case D3DRENDERSTATE_TEXTUREMIN:
        switch(dwRSVal)
        {
            case D3DFILTER_NEAREST:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                break;
            case D3DFILTER_LINEAR:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                break;
            case D3DFILTER_MIPNEAREST:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                break;
            case D3DFILTER_MIPLINEAR:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                break;
            case D3DFILTER_LINEARMIPNEAREST:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_POINT;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                break;
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->TssStates[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                pContext->TssStates[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                break;;
            default:
                break;
        }
        break;

    default:
        // All other renderstates don't have a corresponding TSS state so
        // we don't have to worry about mapping them.
        break;

    } // switch (dwRSType of renderstate)

    DBG_D3D((10,"Exiting __MapRS_Into_TSS0"));

} // __MapRS_Into_TSS0


//-----------------------------------------------------------------------------
//
// void __ProcessRenderState
//
// Handle a single render state change
//
//-----------------------------------------------------------------------------
void
__ProcessRenderStates(PERMEDIA_D3DCONTEXT* pContext, 
                      DWORD dwRSType,
                      DWORD dwRSVal)
{
    __P2RegsSoftwareCopy* pSoftPermedia = &pContext->Hdr.SoftCopyP2Regs;
    DWORD* pFlags = &pContext->Hdr.Flags;

    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering __ProcessRenderStates"));

    // Process each specific renderstate
    switch (dwRSType) {

    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        DBG_D3D((8, "ChangeState: Texture Blend Mode 0x%x "
                                  "(D3DTEXTUREBLEND)", dwRSVal));
        switch (dwRSVal) {
            case D3DTBLEND_DECALALPHA:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_DECAL;
                break;
            case D3DTBLEND_MODULATE:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_MODULATE;
                break;
            case D3DTBLEND_MODULATEALPHA:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_MODULATE;
                break;
            case D3DTBLEND_COPY:
            case D3DTBLEND_DECAL:
                pSoftPermedia->TextureColorMode.ApplicationMode =
                                                     _P2_TEXTURE_COPY;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureColorMode,
                                       pSoftPermedia->TextureColorMode);
        COMMITDMAPTR();
        DIRTY_TEXTURE;          // May need to change DDA
        break;

    case D3DRENDERSTATE_TEXTUREADDRESS:
        DBG_D3D((8, "ChangeState: Texture address 0x%x "
                    "(D3DTEXTUREADDRESS)", dwRSVal));
        switch (dwRSVal) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to ChangeState "
                            " D3DRENDERSTATE_TEXTUREADDRESS = %d",
                                                    dwRSVal));
                // set a fallback value
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode,
                                         pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSU:
        DBG_D3D((8, "ChangeState: Texture address 0x%x "
                    "(D3DTEXTUREADDRESSU)", dwRSVal));
        switch (dwRSVal) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to ChangeState "
                            " D3DRENDERSTATE_TEXTUREADDRESSU = %d",
                                                      dwRSVal));
                // set a fallback value
                pSoftPermedia->TextureReadMode.SWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
        }
        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREADDRESSV:
        DBG_D3D((8, "ChangeState: Texture address 0x%x "
                    "(D3DTEXTUREADDRESSV)", dwRSVal));
        switch (dwRSVal) {
            case D3DTADDRESS_CLAMP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_CLAMP;
                break;
            case D3DTADDRESS_WRAP:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
            case D3DTADDRESS_MIRROR:
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_MIRROR;
                break;
            default:
                DBG_D3D((2, "Illegal value passed to ChangeState "
                            " D3DRENDERSTATE_TEXTUREADDRESSV = %d",
                                                   dwRSVal));
                // set a fallback value
                pSoftPermedia->TextureReadMode.TWrapMode =
                                                  _P2_TEXTURE_REPEAT;
                break;
        }

        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(TextureReadMode, pSoftPermedia->TextureReadMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREHANDLE:
        DBG_D3D((8, "ChangeState: Texture Handle 0x%x",dwRSVal));
        if (dwRSVal != pContext->CurrentTextureHandle)
        {
            pContext->CurrentTextureHandle = dwRSVal;
            DIRTY_TEXTURE;
        }
        break;

    case D3DRENDERSTATE_ANTIALIAS:
        DBG_D3D((8, "ChangeState: AntiAlias 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_WRAPU:
        DBG_D3D((8, "ChangeState: Wrap_U "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_WRAPU_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPU_ENABLED;
        }
        break;


    case D3DRENDERSTATE_WRAPV:
        DBG_D3D((8, "ChangeState: Wrap_V "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_WRAPV_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_WRAPV_ENABLED;
        }
        break;

    case D3DRENDERSTATE_LINEPATTERN:
        DBG_D3D((8, "ChangeState: Line Pattern "
                    "(D3DLINEPATTERN) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ZWRITEENABLE:
        DBG_D3D((8, "ChangeState: Z Write Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            // Local Buffer Write mode
            if (!(*pFlags & CTXT_HAS_ZWRITE_ENABLED))
            {
                DBG_D3D((8, "   Enabling Z Writes"));
                *pFlags |= CTXT_HAS_ZWRITE_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ZWRITE_ENABLED)
            {
                DBG_D3D((8, "   Disabling Z Writes"));
                *pFlags &= ~CTXT_HAS_ZWRITE_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        break;

    case D3DRENDERSTATE_ALPHATESTENABLE:
        DBG_D3D((8, "ChangeState: Alpha Test Enable "
                    "(BOOL) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_LASTPIXEL:
        // True for last pixel on lines
        DBG_D3D((8, "ChangeState: Last Pixel "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_LASTPIXEL_ENABLED;
        }
        else
        {
            *pFlags &= ~CTXT_HAS_LASTPIXEL_ENABLED;
        }
        break;

    case D3DRENDERSTATE_TEXTUREMAG:
        DBG_D3D((8, "ChangeState: Texture magnification "
                    "(D3DTEXTUREFILTER) 0x%x",dwRSVal));
        switch(dwRSVal) {
            case D3DFILTER_NEAREST:
            case D3DFILTER_MIPNEAREST:
                pContext->bMagFilter = FALSE;
                pSoftPermedia->TextureReadMode.FilterMode = 0;
                break;
            case D3DFILTER_LINEAR:
            case D3DFILTER_MIPLINEAR:
            case D3DFILTER_LINEARMIPNEAREST:
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->bMagFilter = TRUE;
                pSoftPermedia->TextureReadMode.FilterMode = 1;
                break;
            default:
                break;
        }
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_TEXTUREMIN:
        DBG_D3D((8, "ChangeState: Texture minification "
                    "(D3DTEXTUREFILTER) 0x%x",dwRSVal));
        switch(dwRSVal) {
            case D3DFILTER_NEAREST:
            case D3DFILTER_MIPNEAREST:
                pContext->bMinFilter = FALSE;
                break;
            case D3DFILTER_MIPLINEAR:
            case D3DFILTER_LINEAR:
            case D3DFILTER_LINEARMIPNEAREST:
            case D3DFILTER_LINEARMIPLINEAR:
                pContext->bMinFilter = TRUE;
                break;
            default:
                break;
        }
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_SRCBLEND:
        DBG_D3D((8, "ChangeState: Source Blend (D3DBLEND):"));
        DECODEBLEND(4, dwRSVal);
        switch (dwRSVal) {
            case D3DBLEND_ZERO:
                pSoftPermedia->AlphaBlendMode.SourceBlend =
                                  __PERMEDIA_BLEND_FUNC_ZERO;
                break;
            case D3DBLEND_ONE:
                pSoftPermedia->AlphaBlendMode.SourceBlend =
                                  __PERMEDIA_BLEND_FUNC_ONE;
                break;
            case D3DBLEND_SRCALPHA:
                pSoftPermedia->AlphaBlendMode.SourceBlend =
                                  __PERMEDIA_BLEND_FUNC_SRC_ALPHA;
                break;
            default:
                DBG_D3D((2,"Invalid Source Blend! - %d",
                                              dwRSVal));
                break;
        }

        // If alpha is on, we may need to validate the chosen blend
        if (*pFlags & CTXT_HAS_ALPHABLEND_ENABLED) 
            DIRTY_ALPHABLEND;

        break;

    case D3DRENDERSTATE_DESTBLEND:
        DBG_D3D((8, "ChangeState: Destination Blend (D3DBLEND):"));
        DECODEBLEND(4, dwRSVal);
        switch (dwRSVal) {
            case D3DBLEND_ZERO:
                pSoftPermedia->AlphaBlendMode.DestinationBlend =
                             __PERMEDIA_BLEND_FUNC_ZERO;
                break;
            case D3DBLEND_ONE:
                pSoftPermedia->AlphaBlendMode.DestinationBlend =
                             __PERMEDIA_BLEND_FUNC_ONE;
                break;
            case D3DBLEND_INVSRCALPHA:
                pSoftPermedia->AlphaBlendMode.DestinationBlend =
                             __PERMEDIA_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                break;
            default:
                DBG_D3D((2,"Invalid Dest Blend! - %d", dwRSVal));
                break;
        }

        // If alpha is on, we may need to validate the chosen blend
        if (*pFlags & CTXT_HAS_ALPHABLEND_ENABLED) 
            DIRTY_ALPHABLEND;

        break;

    case D3DRENDERSTATE_CULLMODE:
        DBG_D3D((8, "ChangeState: Cull Mode "
                    "(D3DCULL) 0x%x",dwRSVal));
        pContext->CullMode = (D3DCULL) dwRSVal;
        switch(dwRSVal) {
            case D3DCULL_NONE:
#ifdef P2_CHIP_CULLING
                pSoftPermedia->DeltaMode.BackfaceCull = 0;
#endif
                break;

            case D3DCULL_CCW:
#ifdef P2_CHIP_CULLING
                RENDER_NEGATIVE_CULL(pContext->RenderCommand);
                pSoftPermedia->DeltaMode.BackfaceCull = 1;
#endif
                break;

            case D3DCULL_CW:
#ifdef P2_CHIP_CULLING
                RENDER_POSITIVE_CULL(pContext->RenderCommand);
                pSoftPermedia->DeltaMode.BackfaceCull = 1;
#endif
                break;
        }
        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_ZFUNC:
        DBG_D3D((8, "ChangeState: Z Compare function "
                    "(D3DCMPFUNC) 0x%x",dwRSVal));
        switch (dwRSVal) {
            case D3DCMP_NEVER:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_NEVER;
                break;
            case D3DCMP_LESS:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_LESS;
                break;
            case D3DCMP_EQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_EQUAL;
                break;
            case D3DCMP_LESSEQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                break;
            case D3DCMP_GREATER:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_GREATER;
                break;
            case D3DCMP_NOTEQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_NOT_EQUAL;
                break;
            case D3DCMP_GREATEREQUAL:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL;
                break;
            case D3DCMP_ALWAYS:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_ALWAYS;
                break;
            default:
                pSoftPermedia->DepthMode.CompareMode =
                             __PERMEDIA_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                break;
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_ALPHAREF:
        DBG_D3D((8, "ChangeState: Alpha Reference "
                    "(D3DFIXED) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ALPHAFUNC:
        DBG_D3D((8, "ChangeState: Alpha compare function "
                    "(D3DCMPFUNC) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_DITHERENABLE:
        DBG_D3D((8, "ChangeState: Dither Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            pSoftPermedia->DitherMode.DitherEnable = DITHER_ENABLE;
        }
        else
        {
            pSoftPermedia->DitherMode.DitherEnable = 0;
        }
        RESERVEDMAPTR(1);
        COPY_PERMEDIA_DATA(DitherMode, pSoftPermedia->DitherMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_COLORKEYENABLE:
        DBG_D3D((8, "ChangeState: ColorKey Enable "
                    "(BOOL) 0x%x",dwRSVal));
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_MIPMAPLODBIAS:
        DBG_D3D((8, "ChangeState: Mipmap LOD Bias "
                    "(INT) 0x%x", dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ALPHABLENDENABLE:
        DBG_D3D((8, "ChangeState: Blend Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            if (!(*pFlags & CTXT_HAS_ALPHABLEND_ENABLED))
            {
                // Set the blend enable flag in the render context struct
                *pFlags |= CTXT_HAS_ALPHABLEND_ENABLED;
                DIRTY_ALPHABLEND;
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                // Turn off blend enable flag in render context struct
                *pFlags &= ~CTXT_HAS_ALPHABLEND_ENABLED;
                DIRTY_ALPHABLEND;
            }
        }
        break;

    case D3DRENDERSTATE_FOGENABLE:
        DBG_D3D((8, "ChangeState: Fog Enable "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
                *pFlags |= CTXT_HAS_FOGGING_ENABLED;
                RENDER_FOG_ENABLE(pContext->RenderCommand);
        }
        else
        {
                *pFlags &= ~CTXT_HAS_FOGGING_ENABLED;
                RENDER_FOG_DISABLE(pContext->RenderCommand);
        }
        DIRTY_TEXTURE;
        break;

    case D3DRENDERSTATE_FOGCOLOR:
        DBG_D3D((8, "ChangeState: Fog Color "
                    "(D3DCOLOR) 0x%x",dwRSVal));
        {
            BYTE red, green, blue, alpha;

            red = (BYTE)RGBA_GETRED(dwRSVal);
            green = (BYTE)RGBA_GETGREEN(dwRSVal);
            blue = (BYTE)RGBA_GETBLUE(dwRSVal);
            alpha = (BYTE)RGBA_GETALPHA(dwRSVal);
            DBG_D3D((4,"FogColor: Red 0x%x, Green 0x%x, Blue 0x%x",
                                                 red, green, blue));
            RESERVEDMAPTR(1);
            pSoftPermedia->FogColor = RGBA_MAKE(blue, green, red, alpha);
            SEND_PERMEDIA_DATA(FogColor, pSoftPermedia->FogColor);
            COMMITDMAPTR();
        }
        break;

    case D3DRENDERSTATE_SPECULARENABLE:
        DBG_D3D((8, "ChangeState: Specular Lighting "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            *pFlags |= CTXT_HAS_SPECULAR_ENABLED;
        } 
        else
        {
            *pFlags &= ~CTXT_HAS_SPECULAR_ENABLED;
        }
        break;

    case D3DRENDERSTATE_FILLMODE:
        DBG_D3D((8, "ChangeState: Fill Mode 0x%x",dwRSVal));
        pContext->Hdr.FillMode = dwRSVal;
        RESERVEDMAPTR(1);
        switch (dwRSVal) {
            case D3DFILL_POINT:
                DBG_D3D((4, "RM = Point"));
                // Restore the RasterizerMode
                SEND_PERMEDIA_DATA(RasterizerMode, 0);
                break;
            case D3DFILL_WIREFRAME:
                DBG_D3D((4, "RM = Wire"));
                // Add nearly a half in the delta case for lines
                // (lines aren't biased on a delta).
                SEND_PERMEDIA_DATA(RasterizerMode, BIAS_NEARLY_HALF);
                break;
            case D3DFILL_SOLID:
                DBG_D3D((4, "RM = Solid"));
                // Restore the RasterizerMode
                SEND_PERMEDIA_DATA(RasterizerMode, 0);
                break;
            default:
                // Illegal value
                DBG_D3D((4, "RM = Nonsense"));
                pContext->Hdr.FillMode = D3DFILL_SOLID;
                // Restore the RasterizerMode
                SEND_PERMEDIA_DATA(RasterizerMode, 0);
                break;
        }
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_TEXTUREPERSPECTIVE:
        DBG_D3D((8, "ChangeState: Texture Perspective "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            pSoftPermedia->TextureAddressMode.PerspectiveCorrection = 1;
            pSoftPermedia->DeltaMode.TextureParameterMode = 2; // Normalise
            *pFlags |= CTXT_HAS_PERSPECTIVE_ENABLED;
        }
        else
        {
            pSoftPermedia->TextureAddressMode.PerspectiveCorrection = 0;
            pSoftPermedia->DeltaMode.TextureParameterMode = 1; // Clamp
            *pFlags &= ~CTXT_HAS_PERSPECTIVE_ENABLED;
        }

        RESERVEDMAPTR(3);
        // Just to ensure that the texture unit 
        // can take the perspective change
        COPY_PERMEDIA_DATA(LBWriteMode, pSoftPermedia->LBWriteMode);
        COPY_PERMEDIA_DATA(TextureAddressMode,
                                 pSoftPermedia->TextureAddressMode);
        COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_ZENABLE:
        DBG_D3D((8, "ChangeState: Z Enable "
                    "(TRUE) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            if ( (!(*pFlags & CTXT_HAS_ZBUFFER_ENABLED)) &&
                 (pContext->ZBufferHandle) )
            {
                // Local Buffer Write mode
                DBG_D3D((4, "       Enabling Z Buffer"));

                *pFlags |= CTXT_HAS_ZBUFFER_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ZBUFFER_ENABLED)
            {
                DBG_D3D((4, "  Disabling Z Buffer"));
                *pFlags &= ~CTXT_HAS_ZBUFFER_ENABLED;
                DIRTY_ZBUFFER;
            }
        }
        break;

    case D3DRENDERSTATE_SHADEMODE:
        DBG_D3D((8, "ChangeState: Shade mode "
                    "(D3DSHADEMODE) 0x%x",dwRSVal));
        RESERVEDMAPTR(2);
        switch(dwRSVal) {
            case D3DSHADE_PHONG:
            case D3DSHADE_GOURAUD:
                if (!(*pFlags & CTXT_HAS_GOURAUD_ENABLED))
                {
                    pSoftPermedia->ColorDDAMode.ShadeMode = 1;

                    // Set DDA to gouraud
                    COPY_PERMEDIA_DATA(ColorDDAMode,
                                               pSoftPermedia->ColorDDAMode);
                    pSoftPermedia->DeltaMode.SmoothShadingEnable = 1;
                    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

                    *pFlags |= CTXT_HAS_GOURAUD_ENABLED;
                    // If we are textureing, some changes may need to be made
                    if (pContext->CurrentTextureHandle != 0)
                        DIRTY_TEXTURE;
                }
                break;
            case D3DSHADE_FLAT:
                if (*pFlags & CTXT_HAS_GOURAUD_ENABLED)
                {
                    pSoftPermedia->ColorDDAMode.ShadeMode = 0;

                    // Set DDA to flat
                    COPY_PERMEDIA_DATA(ColorDDAMode,
                                               pSoftPermedia->ColorDDAMode);
                    pSoftPermedia->DeltaMode.SmoothShadingEnable = 0;
                    COPY_PERMEDIA_DATA(DeltaMode, pSoftPermedia->DeltaMode);

                    *pFlags &= ~CTXT_HAS_GOURAUD_ENABLED;
                    // If we are textureing, some changes may need to be made
                    if (pContext->CurrentTextureHandle != 0) 
                        DIRTY_TEXTURE;
                }
                break;
        }
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_ROP2:
        DBG_D3D((8, "ChangeState: ROP (D3DROP2) 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_ZVISIBLE:
        // From DX6 onwards this is an obsolete render state. 
        // The D3D runtime does not support it anymore so drivers 
        // don't need to implement it
        DBG_D3D((8, "ChangeState: Z Visible 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_PLANEMASK:
        DBG_D3D((8, "ChangeState: Plane Mask "
                    "(ULONG) 0x%x",dwRSVal));
        RESERVEDMAPTR(1);
        SEND_PERMEDIA_DATA(FBHardwareWriteMask, (DWORD)dwRSVal);
        COMMITDMAPTR();
        break;

    case D3DRENDERSTATE_MONOENABLE:
        DBG_D3D((8, "ChangeState: Mono Raster enable "
                    "(BOOL) 0x%x", dwRSVal));
        if (dwRSVal)
        {
                *pFlags |= CTXT_HAS_MONO_ENABLED;
        }
        else
        {
                *pFlags &= ~CTXT_HAS_MONO_ENABLED;
        }
        break;

    case D3DRENDERSTATE_SUBPIXEL:
        DBG_D3D((8, "ChangeState: SubPixel Correction "
                    "(BOOL) 0x%x", dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_SUBPIXELX:
        DBG_D3D((8, "ChangeState: SubPixel Correction (xOnly) "
                    "(BOOL) 0x%x", dwRSVal));
        NOT_HANDLED;
        break;

#if D3D_STENCIL
    //
    // Stenciling Render States
    //
    case D3DRENDERSTATE_STENCILENABLE:
        DBG_D3D((8, "ChangeState: Stencil Enable "
                    "(ULONG) 0x%x",dwRSVal));
        if (dwRSVal != 0)
        {
            pSoftPermedia->StencilMode.UnitEnable = __PERMEDIA_ENABLE;
        }
        else
        {
            pSoftPermedia->StencilMode.UnitEnable = __PERMEDIA_DISABLE;
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILFAIL:
        DBG_D3D((8, "ChangeState: Stencil Fail Method "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DSTENCILOP_KEEP:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_KEEP;
            break;
        case D3DSTENCILOP_ZERO:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_ZERO;
            break;
        case D3DSTENCILOP_REPLACE:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_REPLACE;
            break;
        case D3DSTENCILOP_INCRSAT:
        case D3DSTENCILOP_INCR:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_INCR;
            break;
        case D3DSTENCILOP_DECR:
        case D3DSTENCILOP_DECRSAT:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_DECR;
            break;
        case D3DSTENCILOP_INVERT:
            pSoftPermedia->StencilMode.SFail =
                                     __PERMEDIA_STENCIL_METHOD_INVERT;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil method 0x%x",
                                                   dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILZFAIL:
        DBG_D3D((8, "ChangeState: Stencil Pass Depth Fail Method "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DSTENCILOP_KEEP:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_KEEP;
            break;
        case D3DSTENCILOP_ZERO:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_ZERO;
            break;
        case D3DSTENCILOP_REPLACE:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_REPLACE;
            break;
        case D3DSTENCILOP_INCRSAT:
        case D3DSTENCILOP_INCR:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_INCR;
            break;
        case D3DSTENCILOP_DECR:
        case D3DSTENCILOP_DECRSAT:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_DECR;
            break;
        case D3DSTENCILOP_INVERT:
            pSoftPermedia->StencilMode.DPFail =
                                     __PERMEDIA_STENCIL_METHOD_INVERT;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil method 0x%x",
                                                   dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILPASS:
        DBG_D3D((8, "ChangeState: Stencil Pass Method "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DSTENCILOP_KEEP:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_KEEP;
            break;
        case D3DSTENCILOP_ZERO:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_ZERO;
            break;
        case D3DSTENCILOP_REPLACE:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_REPLACE;
            break;
        case D3DSTENCILOP_INCRSAT:
        case D3DSTENCILOP_INCR:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_INCR;
            break;
        case D3DSTENCILOP_DECR:
        case D3DSTENCILOP_DECRSAT:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_DECR;
            break;
        case D3DSTENCILOP_INVERT:
            pSoftPermedia->StencilMode.DPPass =
                         __PERMEDIA_STENCIL_METHOD_INVERT;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil method 0x%x",
                                                dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILFUNC:
        DBG_D3D((8, "ChangeState: Stencil Comparison Function "
                    "(ULONG) 0x%x",dwRSVal));
        switch (dwRSVal) {
        case D3DCMP_NEVER:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_NEVER;
            break;
        case D3DCMP_LESS:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_LESS;
            break;
        case D3DCMP_EQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_EQUAL;
            break;
        case D3DCMP_LESSEQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_LESS_OR_EQUAL;
            break;
        case D3DCMP_GREATER:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_GREATER;
            break;
        case D3DCMP_NOTEQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_NOT_EQUAL;
            break;
        case D3DCMP_GREATEREQUAL:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL;
            break;
        case D3DCMP_ALWAYS:
            pSoftPermedia->StencilMode.CompareFunction =
                         __PERMEDIA_STENCIL_COMPARE_MODE_ALWAYS;
            break;
        default:
            DBG_D3D((2, " Unrecognized stencil comparison function 0x%x",
                                                       dwRSVal));
        }
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILREF:
        DBG_D3D((8, "ChangeState: Stencil Reference Value "
                    "(ULONG) 0x%x",dwRSVal));
        pSoftPermedia->StencilData.ReferenceValue =
                                     ( dwRSVal & 0x0001 );
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILMASK:
        DBG_D3D((8, "ChangeState: Stencil Compare Mask "
                    "(ULONG) 0x%x",dwRSVal));
        pSoftPermedia->StencilData.CompareMask =
                                    ( dwRSVal & 0x0001 );
        DIRTY_ZBUFFER;
        break;

    case D3DRENDERSTATE_STENCILWRITEMASK:
        DBG_D3D((8, "ChangeState: Stencil Write Mask "
                    "(ULONG) 0x%x",dwRSVal));
        pSoftPermedia->StencilData.WriteMask =
                                    ( dwRSVal & 0x0001 );
        DIRTY_ZBUFFER;
        break;
#endif // D3D_STENCIL

    //
    // Stippling
    //
    case D3DRENDERSTATE_STIPPLEDALPHA:
        DBG_D3D((8, "ChangeState: Stippled Alpha "
                    "(BOOL) 0x%x",dwRSVal));
        if (dwRSVal)
        {
            if (!(*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED))
            {
                // Force a new start on the Alpha pattern
                pContext->LastAlpha = 16;

                *pFlags |= CTXT_HAS_ALPHASTIPPLE_ENABLED;
                if (pContext->bKeptStipple == TRUE)
                {
                    RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
                }
            }
        }
        else
        {
            if (*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED)
            {
                // If Alpha Stipple is being turned off, turn the normal
                // stipple back on, and enable it.
                int i;
                RESERVEDMAPTR(8);
                for (i = 0; i < 8; i++)
                {
                    SEND_PERMEDIA_DATA_OFFSET(AreaStipplePattern0, 
                                  (DWORD)pContext->CurrentStipple[i], i);
                }
                COMMITDMAPTR();
                *pFlags &= ~CTXT_HAS_ALPHASTIPPLE_ENABLED;

                if (pContext->bKeptStipple == TRUE)
                {
                    RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
                }
            }
        }
        break;

    case D3DRENDERSTATE_STIPPLEENABLE:
        DBG_D3D((8, "ChangeState: Stipple Enable "
                    "(BOOL) 0x%x", dwRSVal));
        if (dwRSVal)
        {
            if (!(*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED))
            {
                    RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
            }
            pContext->bKeptStipple = TRUE;
        }
        else
        {
            RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
            pContext->bKeptStipple = FALSE;
        }
        break;

    case D3DRENDERSTATE_CLIPPING:
        DBG_D3D((8, "ChangeState: Clipping 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_LIGHTING:
        DBG_D3D((8, "ChangeState: Lighting 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_EXTENTS:
        DBG_D3D((8, "ChangeState: Extents 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_AMBIENT:
        DBG_D3D((8, "ChangeState: Ambient 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_FOGVERTEXMODE:
        DBG_D3D((8, "ChangeState: Fog Vertex Mode 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_COLORVERTEX:
        DBG_D3D((8, "ChangeState: Color Vertex 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_LOCALVIEWER:
        DBG_D3D((8, "ChangeState: LocalViewer 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_NORMALIZENORMALS:
        DBG_D3D((8, "ChangeState: Normalize Normals 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_COLORKEYBLENDENABLE:
        DBG_D3D((8, "ChangeState: Colorkey Blend Enable 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Diffuse Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Specular Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Ambient Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
        DBG_D3D((8, "ChangeState: Emmisive Material Source 0x%x",dwRSVal));
        NOT_HANDLED;
        break;
    case D3DRENDERSTATE_VERTEXBLEND:
        DBG_D3D((8, "ChangeState: Vertex Blend 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_CLIPPLANEENABLE:
        DBG_D3D((8, "ChangeState: Clip Plane Enable 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_SCENECAPTURE:
        // This state pass TRUE or FALSE to replace the functionality
        // of D3DHALCallbacks->SceneCapture(), Permedia2 Hardware doesn't
        // need begin/end scene information, therefore it's a NOOP here.
        if (dwRSVal)
            TextureCacheManagerResetStatCounters(pContext->pTextureManager);

        DBG_D3D((8,"D3DRENDERSTATE_SCENECAPTURE=%x", (DWORD)dwRSVal));
        NOT_HANDLED;
        break;
    case D3DRENDERSTATE_EVICTMANAGEDTEXTURES:
        DBG_D3D((8,"D3DRENDERSTATE_EVICTMANAGEDTEXTURES=%x", (DWORD)dwRSVal));
        if (NULL != pContext->pTextureManager)
            TextureCacheManagerEvictTextures(pContext->pTextureManager);
        break;

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
    case D3DRENDERSTATE_POINTSIZE:
        DBG_D3D((8, "ChangeState: Point size 0x%x",dwRSVal));
        (DWORD&)(pContext->fPointSize) = dwRSVal;
        break;

    case D3DRENDERSTATE_POINTSPRITE_ENABLE:
        DBG_D3D((8, "ChangeState: Point Sprite Enable 0x%x",dwRSVal));
        pContext->bPointSpriteEnabled = dwRSVal;
        break;

    // All of the following point sprite related render states are
    // ignored by this driver since we are a Non-TnLHal driver.
    case D3DRENDERSTATE_POINTATTENUATION_A:
        DBG_D3D((8, "ChangeState: Point Attenuation A 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_POINTATTENUATION_B:
        DBG_D3D((8, "ChangeState: Point Attenuation B 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_POINTATTENUATION_C:
        DBG_D3D((8, "ChangeState: Point Attenuation C 0x%x",dwRSVal));
        NOT_HANDLED;
        break;

    case D3DRENDERSTATE_POINTSIZEMIN:
        DBG_D3D((8, "ChangeState: Point Size Min 0x%x",dwRSVal));
        NOT_HANDLED;
        break;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

    case D3DRENDERSTATE_WRAP0:
    case D3DRENDERSTATE_WRAP1:
    case D3DRENDERSTATE_WRAP2:
    case D3DRENDERSTATE_WRAP3:
    case D3DRENDERSTATE_WRAP4:
    case D3DRENDERSTATE_WRAP5:
    case D3DRENDERSTATE_WRAP6:
    case D3DRENDERSTATE_WRAP7:
        DBG_D3D((8, "ChangeState: Wrap(%x) "
                    "(BOOL) 0x%x",(dwRSType - D3DRENDERSTATE_WRAPBIAS ),dwRSVal));
        pContext->dwWrap[dwRSType - D3DRENDERSTATE_WRAPBIAS] = dwRSVal;
        break;

    default:
        if ((dwRSType >= D3DRENDERSTATE_STIPPLEPATTERN00) && 
            (dwRSType <= D3DRENDERSTATE_STIPPLEPATTERN07))
        {
            DBG_D3D((8, "ChangeState: Loading Stipple0x%x with 0x%x",
                                    dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00,
                                    (DWORD)dwRSVal));

            pContext->CurrentStipple[(dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00)] =
                                                         (BYTE)dwRSVal;

            if (!(*pFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED))
            {
                // Flat-Stippled Alpha is not on, so use the 
                // current stipple pattern
                RESERVEDMAPTR(1);
                SEND_PERMEDIA_DATA_OFFSET(AreaStipplePattern0,
                                    (DWORD)dwRSVal,
                                    dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00);
                COMMITDMAPTR();
            }
        }
        else
        {
            DBG_D3D((2, "ChangeState: Unhandled opcode = %d", dwRSType));
        }
        break;
    } // switch (dwRSType of renderstate)

    // Mirror any change that happened in the render states into TSS 0
    __MapRS_Into_TSS0(pContext, dwRSType, dwRSVal);

    DBG_D3D((10,"Exiting __ProcessRenderStates"));
}

//-----------------------------------------------------------------------------
//
// DWORD __ProcessPermediaStates
//
// Handle render state changes that arrive through the D3DDP2OP_RENDERSTATE
// token in the DP2 command stream.
//
//-----------------------------------------------------------------------------
DWORD 
__ProcessPermediaStates(PERMEDIA_D3DCONTEXT* pContext, 
                        DWORD dwCount,
                        LPD3DSTATE lpState,
                        LPDWORD lpStateMirror)
{

    DWORD dwRSType, dwRSVal, i;

    DBG_D3D((10,"Entering __ProcessPermediaStates"));
    DBG_D3D((4, "__ProcessPermediaStates: Processing %d State changes", dwCount));

    // Loop through all renderstates passed in the DP2 command stream
    for (i = 0; i < dwCount; i++, lpState++)
    {
        dwRSType = (DWORD) lpState->drstRenderStateType;
        dwRSVal  = (DWORD) lpState->dwArg[0];

        DBG_D3D((8, "__ProcessPermediaStates state %d value = %d",
                                          dwRSType, dwRSVal));

        // Check validity of the render state
        if (!VALID_STATE(dwRSType))
        {
            DBG_D3D((0, "state 0x%08x is invalid", dwRSType));
            return DDERR_INVALIDPARAMS;
        }

        // Verify if state needs to be overrided or ignored
        if (IS_OVERRIDE(dwRSType))
        {
            DWORD override = GET_OVERRIDE(dwRSType);
            if (dwRSVal)
            {
                DBG_D3D((4, "in RenderState, setting override for state %d",
                                                                   override));
                STATESET_SET(pContext->overrides, override);
            }
            else
            {
                DBG_D3D((4, "in RenderState, clearing override for state %d",
                                                                    override));
                STATESET_CLEAR(pContext->overrides, override);
            }
            continue;
        }

        if (STATESET_ISSET(pContext->overrides, dwRSType))
        {
            DBG_D3D((4, "in RenderState, state %d is overridden, ignoring",
                                                                      dwRSType));
            continue;
        }

#if D3D_STATEBLOCKS
        if (!pContext->bStateRecMode)
        {
#endif D3D_STATEBLOCKS
            // Store the state in the context
            pContext->RenderStates[dwRSType] = dwRSVal;

            // Mirror value
            if ( lpStateMirror )
                lpStateMirror[dwRSType] = dwRSVal;


            __ProcessRenderStates(pContext, dwRSType, dwRSVal);
#if D3D_STATEBLOCKS
        }
        else
        {
            if (pContext->pCurrSS != NULL)
            {
                DBG_D3D((6,"Recording RS %x = %x",dwRSType,dwRSVal));

                // Recording the state in a stateblock
                pContext->pCurrSS->u.uc.RenderStates[dwRSType] = dwRSVal;
                FLAG_SET(pContext->pCurrSS->u.uc.bStoredRS,dwRSType);
            }
        }
#endif D3D_STATEBLOCKS

    } // for (i)

    DBG_D3D((10,"Exiting __ProcessPermediaStates"));

    return DD_OK;
} // __ProcessPermediaStates

#if D3D_STATEBLOCKS
//-----------------------------------------------------------------------------
//
// P2StateSetRec *FindStateSet
//
// Find a state identified by dwHandle starting from pRootSS.
// If not found, returns NULL.
//
//-----------------------------------------------------------------------------
P2StateSetRec *FindStateSet(PERMEDIA_D3DCONTEXT* pContext,
                            DWORD dwHandle)
{
    if (dwHandle <= pContext->dwMaxSSIndex)
        return pContext->pIndexTableSS[dwHandle - 1];
    else
    {
        DBG_D3D((2,"State set %x not found (Max = %x)",
                    dwHandle, pContext->dwMaxSSIndex));
        return NULL;
    }
}

//-----------------------------------------------------------------------------
//
// void DumpStateSet
//
// Dump info stored in a state set
//
//-----------------------------------------------------------------------------
#define ELEMS_IN_ARRAY(a) ((sizeof(a)/sizeof(a[0])))

void DumpStateSet(P2StateSetRec *pSSRec)
{
    DWORD i;

    DBG_D3D((0,"DumpStateSet %x, Id=%x bCompressed=%x",
                pSSRec,pSSRec->dwHandle,pSSRec->bCompressed));

    if (!pSSRec->bCompressed)
    {
        // uncompressed state set

        // Dump render states values
        for (i=0; i< MAX_STATE; i++)
        {
            DBG_D3D((0,"RS %x = %x",i, pSSRec->u.uc.RenderStates[i]));
        }

        // Dump TSS's values
        for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
        {
            DBG_D3D((0,"TSS %x = %x",i, pSSRec->u.uc.TssStates[i]));
        }

        // Dump RS bit masks
        for (i=0; i< ELEMS_IN_ARRAY(pSSRec->u.uc.bStoredRS); i++)
        {
            DBG_D3D((0,"bStoredRS[%x] = %x",i, pSSRec->u.uc.bStoredRS[i]));
        }

        // Dump TSS bit masks
        for (i=0; i< ELEMS_IN_ARRAY(pSSRec->u.uc.bStoredTSS); i++)
        {
            DBG_D3D((0,"bStoredTSS[%x] = %x",i, pSSRec->u.uc.bStoredTSS[i]));
        }

    }
    else
    {
        // compressed state set

        DBG_D3D((0,"dwNumRS =%x  dwNumTSS=%x",
                    pSSRec->u.cc.dwNumRS,pSSRec->u.cc.dwNumTSS));

        // dump compressed state
        for (i=0; i< pSSRec->u.cc.dwNumTSS + pSSRec->u.cc.dwNumRS; i++)
        {
            DBG_D3D((0,"RS/TSS %x = %x",
                        pSSRec->u.cc.pair[i].dwType, 
                        pSSRec->u.cc.pair[i].dwValue));
        }

    }

}

//-----------------------------------------------------------------------------
//
// void AddStateSetIndexTableEntry
//
// Add an antry to the index table. If necessary, grow it.
//-----------------------------------------------------------------------------
void AddStateSetIndexTableEntry(PERMEDIA_D3DCONTEXT* pContext,
                                DWORD dwNewHandle,
                                P2StateSetRec *pNewSSRec)
{
    DWORD dwNewSize;
    P2StateSetRec **pNewIndexTableSS;

    // If the current list is not large enough, we'll have to grow a new one.
    if (dwNewHandle > pContext->dwMaxSSIndex)
    {
        // New size of our index table
        // (round up dwNewHandle in steps of SSPTRS_PERPAGE)
        dwNewSize = ((dwNewHandle -1 + SSPTRS_PERPAGE) / SSPTRS_PERPAGE)
                      * SSPTRS_PERPAGE;

        // we have to grow our list
        pNewIndexTableSS = (P2StateSetRec **)
                                ENGALLOCMEM( FL_ZERO_MEMORY,
                                             dwNewSize*sizeof(P2StateSetRec *),
                                             ALLOC_TAG);

        if (!pNewIndexTableSS)
        {
            // we weren't able to grow the list so we will keep the old one
            // and (sigh) forget about this state set since that is the 
            // safest thing to do. We will delete also the state set structure
            // since no one will otherwise be able to find it later.
            DBG_D3D((0,"Out of mem growing state set list,"
                       " droping current state set"));
            ENGFREEMEM(pNewSSRec);
            return;
        }

        if (pContext->pIndexTableSS)
        {
            // if we already had a previous list, we must transfer its data
            memcpy(pNewIndexTableSS, 
                   pContext->pIndexTableSS,
                   pContext->dwMaxSSIndex*sizeof(P2StateSetRec *));
            
            //and get rid of it
            ENGFREEMEM(pContext->pIndexTableSS);
        }

        // New index table data
        pContext->pIndexTableSS = pNewIndexTableSS;
        pContext->dwMaxSSIndex = dwNewSize;
    }

    // Store our state set pointer into our access list
    pContext->pIndexTableSS[dwNewHandle - 1] = pNewSSRec;
}

//-----------------------------------------------------------------------------
//
// void CompressStateSet
//
// Compress a state set so it uses the minimum necessary space. Since we expect 
// some apps to make extensive use of state sets we want to keep things tidy.
// Returns address of new structure (ir old, if it wasn't compressed)
//
//-----------------------------------------------------------------------------
P2StateSetRec * CompressStateSet(PERMEDIA_D3DCONTEXT* pContext,
                                 P2StateSetRec *pUncompressedSS)
{
    P2StateSetRec *pCompressedSS;
    DWORD i, dwSize, dwIndex, dwCount;

    // Create a new state set of just the right size we need

    // Calculate how large 
    dwCount = 0;
    for (i=0; i< MAX_STATE; i++)
        if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredRS , i))
        {
            dwCount++;
        };

    for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
        if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredTSS , i))
        {
            dwCount++;
        };

    // Create a new state set of just the right size we need
    // ANY CHANGE MADE TO THE P2StateSetRec structure MUST BE REFLECTED HERE!
    dwSize = 2*sizeof(DWORD) +                          // handle , flags
             2*sizeof(DWORD) +                          // # of RS & TSS
             2*dwCount*sizeof(DWORD);                   // compressed structure

    if (dwSize >= sizeof(P2StateSetRec))
    {
        // it is not efficient to compress, leave uncompressed !
        pUncompressedSS->bCompressed = FALSE;
        return pUncompressedSS;
    }

    pCompressedSS = (P2StateSetRec *)ENGALLOCMEM( FL_ZERO_MEMORY,
                                                    dwSize, ALLOC_TAG);

    if (pCompressedSS)
    {
        // adjust data in new compressed state set
        pCompressedSS->bCompressed = TRUE;
        pCompressedSS->dwHandle = pUncompressedSS->dwHandle;

        // Transfer our info to this new state set
        pCompressedSS->u.cc.dwNumRS = 0;
        pCompressedSS->u.cc.dwNumTSS = 0;
        dwIndex = 0;

        for (i=0; i< MAX_STATE; i++)
            if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredRS , i))
            {
                pCompressedSS->u.cc.pair[dwIndex].dwType = i;
                pCompressedSS->u.cc.pair[dwIndex].dwValue = 
                                    pUncompressedSS->u.uc.RenderStates[i];
                pCompressedSS->u.cc.dwNumRS++;
                dwIndex++;
            }

        for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
            if (IS_FLAG_SET(pUncompressedSS->u.uc.bStoredTSS , i))
            {
                pCompressedSS->u.cc.pair[dwIndex].dwType = i;
                pCompressedSS->u.cc.pair[dwIndex].dwValue = 
                                    pUncompressedSS->u.uc.TssStates[i];
                pCompressedSS->u.cc.dwNumTSS++;
                dwIndex++;
            }

        // Get rid of the old(uncompressed) one
        ENGFREEMEM(pUncompressedSS);
        return pCompressedSS;

    }
    else
    {
        DBG_D3D((0,"Not enough memory left to compress D3D state set"));
        pUncompressedSS->bCompressed = FALSE;
        return pUncompressedSS;
    }

}

//-----------------------------------------------------------------------------
//
// void __DeleteAllStateSets
//
// Delete any remaining state sets for cleanup purpouses
//
//-----------------------------------------------------------------------------
void __DeleteAllStateSets(PERMEDIA_D3DCONTEXT* pContext)
{
    P2StateSetRec *pSSRec;
    DWORD dwSSIndex;

    DBG_D3D((10,"Entering __DeleteAllStateSets"));

    if (pContext->pIndexTableSS)
    {
        for(dwSSIndex = 0; dwSSIndex < pContext->dwMaxSSIndex; dwSSIndex++)
        {
            if (pSSRec = pContext->pIndexTableSS[dwSSIndex])
            {
                ENGFREEMEM(pSSRec);
            }
        }

        // free fast index table
        ENGFREEMEM(pContext->pIndexTableSS);
    }

    DBG_D3D((10,"Exiting __DeleteAllStateSets"));
}

//-----------------------------------------------------------------------------
//
// void __BeginStateSet
//
// Create a new state set identified by dwParam and start recording states
//
//-----------------------------------------------------------------------------
void __BeginStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __BeginStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;

    // Create a new state set
    pSSRec = (P2StateSetRec *)ENGALLOCMEM( FL_ZERO_MEMORY,
                                           sizeof(P2StateSetRec), ALLOC_TAG);
    if (!pSSRec)
    {
        DBG_D3D((0,"Run out of memory for additional state sets"));
        return;
    }

    // remember handle to current state set
    pSSRec->dwHandle = dwParam;
    pSSRec->bCompressed = FALSE;

    // Get pointer to current recording state set
    pContext->pCurrSS = pSSRec;

    // Start recording mode
    pContext->bStateRecMode = TRUE;

    DBG_D3D((10,"Exiting __BeginStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __EndStateSet
//
// stop recording states - revert to executing them.
//
//-----------------------------------------------------------------------------
void __EndStateSet(PERMEDIA_D3DCONTEXT* pContext)
{
    DWORD dwHandle;
    P2StateSetRec *pNewSSRec;

    DBG_D3D((10,"Entering __EndStateSet"));

    if (pContext->pCurrSS)
    {
        dwHandle = pContext->pCurrSS->dwHandle;

        // compress the current state set
        // Note: after being compressed the uncompressed version is free'd.
        pNewSSRec = CompressStateSet(pContext, pContext->pCurrSS);

        AddStateSetIndexTableEntry(pContext, dwHandle, pNewSSRec);
    }

    // No state set being currently recorded
    pContext->pCurrSS = NULL;

    // End recording mode
    pContext->bStateRecMode = FALSE;


    DBG_D3D((10,"Exiting __EndStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __DeleteStateSet
//
// Delete the recorder state ste identified by dwParam
//
//-----------------------------------------------------------------------------
void __DeleteStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __DeleteStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;
    DWORD i;

    if (pSSRec = FindStateSet(pContext, dwParam))
    {
        // Clear index table entry
        pContext->pIndexTableSS[dwParam - 1] = NULL;

        // Now delete the actual state set structure
        ENGFREEMEM(pSSRec);
    }

    DBG_D3D((10,"Exiting __DeleteStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __ExecuteStateSet
//
//
//-----------------------------------------------------------------------------
void __ExecuteStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __ExecuteStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;
    DWORD i;

    if (pSSRec = FindStateSet(pContext, dwParam))
    {

        if (!pSSRec->bCompressed)
        {
            // uncompressed state set

            // Execute any necessary render states
            for (i=0; i< MAX_STATE; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredRS , i))
                {
                    DWORD dwRSType, dwRSVal;

                    dwRSType = i;
                    dwRSVal = pSSRec->u.uc.RenderStates[dwRSType];

                    // Store the state in the context
                    pContext->RenderStates[dwRSType] = dwRSVal;

                    DBG_D3D((6,"__ExecuteStateSet RS %x = %x",
                                dwRSType, dwRSVal));

                    // Process it
                    __ProcessRenderStates(pContext, dwRSType, dwRSVal);

                    DIRTY_TEXTURE;
                    DIRTY_ZBUFFER;
                    DIRTY_ALPHABLEND;
                }

            // Execute any necessary TSS's
            for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredTSS , i))
                {
                    DWORD dwTSState, dwValue;

                    dwTSState = i;
                    dwValue = pSSRec->u.uc.TssStates[dwTSState];

                    DBG_D3D((6,"__ExecuteStateSet TSS %x = %x",
                                dwTSState, dwValue));

                    // Store value associated to this stage state
                    pContext->TssStates[dwTSState] = dwValue;

                    // Perform any necessary preprocessing of it
                    __HWPreProcessTSS(pContext, 0, dwTSState, dwValue);

                    DIRTY_TEXTURE;
                }

            // Execute any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -
        }
        else
        {
            // compressed state set

            // Execute any necessary render states
            for (i=0; i< pSSRec->u.cc.dwNumRS; i++)
            {
                DWORD dwRSType, dwRSVal;

                dwRSType = pSSRec->u.cc.pair[i].dwType;
                dwRSVal = pSSRec->u.cc.pair[i].dwValue;

                // Store the state in the context
                pContext->RenderStates[dwRSType] = dwRSVal;

                DBG_D3D((6,"__ExecuteStateSet RS %x = %x",
                            dwRSType, dwRSVal));

                // Process it
                __ProcessRenderStates(pContext, dwRSType, dwRSVal);

                DIRTY_TEXTURE;
                DIRTY_ZBUFFER;
                DIRTY_ALPHABLEND;
            }

            // Execute any necessary TSS's
            for (; i< pSSRec->u.cc.dwNumTSS + pSSRec->u.cc.dwNumRS; i++)
            {
                DWORD dwTSState, dwValue;

                dwTSState = pSSRec->u.cc.pair[i].dwType;
                dwValue = pSSRec->u.cc.pair[i].dwValue;

                DBG_D3D((6,"__ExecuteStateSet TSS %x = %x",
                            dwTSState, dwValue));

                // Store value associated to this stage state
                pContext->TssStates[dwTSState] = dwValue;

                // Perform any necessary preprocessing of it
                __HWPreProcessTSS(pContext, 0, dwTSState, dwValue);

                DIRTY_TEXTURE;
            }

            // Execute any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -

        }
    }

    DBG_D3D((10,"Exiting __ExecuteStateSet"));
}

//-----------------------------------------------------------------------------
//
// void __CaptureStateSet
//
//
//-----------------------------------------------------------------------------
void __CaptureStateSet(PERMEDIA_D3DCONTEXT* pContext, DWORD dwParam)
{
    DBG_D3D((10,"Entering __CaptureStateSet dwParam=%08lx",dwParam));

    P2StateSetRec *pSSRec;
    DWORD i;

    if (pSSRec = FindStateSet(pContext, dwParam))
    {
        if (!pSSRec->bCompressed)
        {
            // uncompressed state set

            // Capture any necessary render states
            for (i=0; i< MAX_STATE; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredRS , i))
                {
                    pSSRec->u.uc.RenderStates[i] = pContext->RenderStates[i];
                }

            // Capture any necessary TSS's
            for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                if (IS_FLAG_SET(pSSRec->u.uc.bStoredTSS , i))
                {
                    pSSRec->u.uc.TssStates[i] = pContext->TssStates[i];
                }

            // Capture any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -
        }
        else
        {
            // compressed state set

            // Capture any necessary render states
            for (i=0; i< pSSRec->u.cc.dwNumRS; i++)
            {
                DWORD dwRSType;

                dwRSType = pSSRec->u.cc.pair[i].dwType;
                pSSRec->u.cc.pair[i].dwValue = pContext->RenderStates[dwRSType];

            }

            // Capture any necessary TSS's
            for (; i< pSSRec->u.cc.dwNumTSS + pSSRec->u.cc.dwNumRS; i++)
                {
                    DWORD dwTSState;

                    dwTSState = pSSRec->u.cc.pair[i].dwType;
                    pSSRec->u.cc.pair[i].dwValue = pContext->TssStates[dwTSState];
                }

            // Capture any necessary state for lights, materials, transforms,
            // viewport info, z range and clip planes - here -

        }
    }

    DBG_D3D((10,"Exiting __CaptureStateSet"));
}
#endif //D3D_STATEBLOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dsoft.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsoft.h
*
*  Content:  D3D hw register value tracking mechanism.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#ifdef __SOFTCOPY
#pragma message ("FILE : "__FILE__" : Multiple Inclusion");
#endif

#define __SOFTCOPY


// For the Permedia 2 specific registers.
#include "p2regs.h"


//-----------------------------------------------------------------------------
//     Permedia 2 hardware registers software copy structure definition
//-----------------------------------------------------------------------------
typedef struct {
    // Common Local Buffer Registers
    __Permedia2LBReadModeFmat                LBReadMode;
    __Permedia2LBReadFormatFmat              LBReadFormat;
    __Permedia2LBWriteModeFmat               LBWriteMode;

    // Common Frame Buffer Registers
    __Permedia2FBReadModeFmat                FBReadMode;
    __Permedia2FBWriteModeFmat               FBWriteMode;
    DWORD                                    FBReadPixel;
    __Permedia2LogicalOpModeFmat             LogicalOpMode;
    __Permedia2DitherModeFmat                DitherMode;
    __Permedia2ColorDDAModeFmat              ColorDDAMode;

    // Common Depth/Stencil/Window Registers
    __Permedia2DepthModeFmat                 DepthMode;
    __Permedia2StencilModeFmat               StencilMode;
    __Permedia2StencilDataFmat               StencilData;
    __Permedia2WindowFmat                    Window;

    // Alpha/Fog registers
    __Permedia2AlphaBlendModeFmat            AlphaBlendMode;
    __Permedia2FogModeFmat                   FogMode;
    DWORD                                    FogColor;

    // Delta Register
    __Permedia2DeltaModeFmat                 DeltaMode;

    // Chroma testing register
    __Permedia2YUVModeFmat                   YUVMode;

    // Texture Registers
    __Permedia2TextureColorModeFmat          TextureColorMode;
    __Permedia2TextureAddrModeFmat           TextureAddressMode;
    __Permedia2TextureReadModeFmat           TextureReadMode;
    __Permedia2TextureDataFormatFmat         TextureDataFormat;
    __Permedia2TextureMapFormatFmat          TextureMapFormat;

} __P2RegsSoftwareCopy;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtxman.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.h
*
* Content:  D3D Texture manager definitions and macros.
*
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#ifdef __D3DTEXMAN
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif
#define __D3DTEXMAN

#ifndef __D3DHW
#include "d3dhw.h"
#endif
#ifndef __DCONTEXT
#include "d3dcntxt.h"
#endif

#define parent(k) (k / 2)
#define lchild(k) (k * 2)
#define rchild(k) (k * 2 + 1)

__inline ULONGLONG TextureCost(PPERMEDIA_D3DTEXTURE pTexture)
{
#ifdef _X86_
    ULONGLONG retval = 0;
    _asm
    {
        mov     ebx, pTexture;
        mov     eax, [ebx]PERMEDIA_D3DTEXTURE.m_dwPriority;
        mov     ecx, eax;
        shr     eax, 1;
        mov     DWORD PTR retval + 4, eax;
        shl     ecx, 31;
        mov     eax, [ebx]PERMEDIA_D3DTEXTURE.m_dwTicks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR retval, eax;
    }
    return retval;
#else
    return ((ULONGLONG)pTexture->m_dwPriority << 31) + 
            ((ULONGLONG)(pTexture->m_dwTicks >> 1));
#endif
}

typedef struct _TextureHeap 
{
    DWORD   m_next;
    DWORD   m_size;
    PPERMEDIA_D3DTEXTURE *m_data_p;
} TextureHeap, *PTextureHeap;

void TextureHeapHeapify(PTextureHeap,DWORD);
bool TextureHeapAdd(PTextureHeap,PPERMEDIA_D3DTEXTURE);
PPERMEDIA_D3DTEXTURE TextureHeapExtractMin(PTextureHeap);
PPERMEDIA_D3DTEXTURE TextureHeapExtractMax(PTextureHeap);
void TextureHeapDel(PTextureHeap,DWORD);
void TextureHeapUpdate(PTextureHeap,DWORD,DWORD,DWORD); 

typedef struct _TextureCacheManager 
{    
    TextureHeap m_heap;
    unsigned int tcm_ticks;
    D3DDEVINFO_TEXTUREMANAGER m_stats;
}TextureCacheManager, *PTextureCacheManager;

// Free the LRU texture 
BOOL TextureCacheManagerFreeTextures(PTextureCacheManager,DWORD, DWORD);
    //remove all HW handles and release surface
void TextureCacheManagerRemove(PTextureCacheManager,PPERMEDIA_D3DTEXTURE);  
    
HRESULT TextureCacheManagerAllocNode(PERMEDIA_D3DCONTEXT*,PPERMEDIA_D3DTEXTURE);
HRESULT TextureCacheManagerInitialize(PTextureCacheManager);
    
__inline void TextureCacheManagerRemoveFromHeap(
    PTextureCacheManager pTextureCacheManager,
    PPERMEDIA_D3DTEXTURE lpD3DTexI) 
{ 
    TextureHeapDel(&pTextureCacheManager->m_heap,lpD3DTexI->m_dwHeapIndex); 
}
__inline void TextureCacheManagerUpdatePriority(
    PTextureCacheManager pTextureCacheManager,
    PPERMEDIA_D3DTEXTURE lpD3DTexI) 
{ 
    TextureHeapUpdate(&pTextureCacheManager->m_heap,
        lpD3DTexI->m_dwHeapIndex, 
        lpD3DTexI->m_dwPriority, lpD3DTexI->m_dwTicks); 
}
__inline void TextureCacheManagerIncTotSz(
    PTextureCacheManager pTextureCacheManager,
    DWORD dwSize)
{
    ++pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes += dwSize;
}
__inline void TextureCacheManagerDecTotSz(
    PTextureCacheManager pTextureCacheManager,
    DWORD dwSize)
{
    --pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes -= dwSize;
}
__inline void TextureCacheManagerIncNumSetTexInVid(
    PTextureCacheManager pTextureCacheManager)
{
    ++pTextureCacheManager->m_stats.dwNumUsedTexInVid;
}
__inline void TextureCacheManagerIncNumTexturesSet(
    PTextureCacheManager pTextureCacheManager)
{
    ++pTextureCacheManager->m_stats.dwNumTexturesUsed;
}
__inline void TextureCacheManagerResetStatCounters(
    PTextureCacheManager pTextureCacheManager)
{
    pTextureCacheManager->m_stats.bThrashing = 0;
    pTextureCacheManager->m_stats.dwNumEvicts = 0;
    pTextureCacheManager->m_stats.dwNumVidCreates = 0;
    pTextureCacheManager->m_stats.dwNumUsedTexInVid = 0;
    pTextureCacheManager->m_stats.dwNumTexturesUsed = 0;
}
__inline void TextureCacheManagerGetStats(
    PERMEDIA_D3DCONTEXT *pContext,
    LPD3DDEVINFO_TEXTUREMANAGER stats)
{
    memcpy(stats, &pContext->pTextureManager->m_stats, 
        sizeof(D3DDEVINFO_TEXTUREMANAGER));
}
void TextureCacheManagerEvictTextures(PTextureCacheManager);
void TextureCacheManagerTimeStamp(PTextureCacheManager,PPERMEDIA_D3DTEXTURE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtri.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtri.c
*
*  Content:    Direct3D hw triangle rasterization code.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "d3ddelta.h"
#include "d3dhw.h"
#include "d3dcntxt.h"
#if defined(_ALPHA_)
#include <math.h>
#endif

//-----------------------------------------------------------------------------
//
// VOID P2_Draw_FVF_Solid_Tri
//
// Hardware render a single triangle coming from three FVF vertices
//
//-----------------------------------------------------------------------------
VOID
P2_Draw_FVF_Solid_Tri(PERMEDIA_D3DCONTEXT  *pContext,
                      LPD3DTLVERTEX    lpV0, 
                      LPD3DTLVERTEX    lpV1,
                      LPD3DTLVERTEX    lpV2, 
                      LPP2FVFOFFSETS   lpFVFOff)
{
    DWORD           dwFlags = pContext->Hdr.Flags;
    DWORD           dwColorOffs,dwSpecularOffs,dwTexOffs;
    ULONG           ulRenderCmd = pContext->RenderCommand;
    D3DCOLOR        dwColor0, dwColor1, dwColor2;
    D3DCOLOR        dwSpec0, dwSpec1, dwSpec2;
    D3DVALUE        fS0, fS1, fS2, fT0, fT1, fT2, fQ0, fQ1, fQ2;
    D3DVALUE        fKs0, fKs1, fKs2;
    PERMEDIA_DEFS(pContext->ppdev);

    DBG_D3D((10,"Entering P2_Draw_FVF_Solid_Tri"));

    // Set triangle rendering mode
    RENDER_TRAPEZOID(ulRenderCmd);

    RESERVEDMAPTR(0x80);

    // Get FVF structure offsets
    __SetFVFOffsets(&dwColorOffs,&dwSpecularOffs,&dwTexOffs,lpFVFOff);

    // Get vertex color value (FVF based)
    if (dwColorOffs)
    {
        dwColor0  = FVFCOLOR(lpV0, dwColorOffs)->color;
        dwColor1  = FVFCOLOR(lpV1, dwColorOffs)->color;
        dwColor2  = FVFCOLOR(lpV2, dwColorOffs)->color;
        if (FAKE_ALPHABLEND_MODULATE & pContext->FakeBlendNum)
        {
            dwColor0  |= 0xFF000000;
            dwColor1  |= 0xFF000000;
            dwColor2  |= 0xFF000000;
        }
    }
    else
    {
        // must set default in case no D3DFVF_DIFFUSE
        dwColor0  = 0xFFFFFFFF;
        dwColor1  = 0xFFFFFFFF;
        dwColor2  = 0xFFFFFFFF;
    }
    // Get vertex specular value (FVF based) if necessary
    if ((dwFlags & (CTXT_HAS_SPECULAR_ENABLED | CTXT_HAS_FOGGING_ENABLED))
        && (dwSpecularOffs!=0))
    {
        dwSpec0   = FVFSPEC(lpV0, dwSpecularOffs)->specular;
        dwSpec1   = FVFSPEC(lpV1, dwSpecularOffs)->specular;
        dwSpec2   = FVFSPEC(lpV2, dwSpecularOffs)->specular;
    }

    if ( (dwFlags & CTXT_HAS_TEXTURE_ENABLED) && (dwTexOffs != 0) )
    {
         // Get s,t texture coordinates (FVF based)
        fS0 = FVFTEX(lpV0,dwTexOffs)->tu; 
        fT0 = FVFTEX(lpV0,dwTexOffs)->tv;
        
        fS1 = FVFTEX(lpV1,dwTexOffs)->tu; 
        fT1 = FVFTEX(lpV1,dwTexOffs)->tv;
        
        fS2 = FVFTEX(lpV2,dwTexOffs)->tu; 
        fT2 = FVFTEX(lpV2,dwTexOffs)->tv;

        // The hw requires us to keep the texture coordinates centered around 0
        // and avoid exceeding the texel wrapping limit.
        RECENTER_TEX_COORDS(pContext->MaxTextureXf, 
                            pContext->MaxTextureXi, fS0, fS1, fS2);
        RECENTER_TEX_COORDS(pContext->MaxTextureYf, 
                            pContext->MaxTextureYi, fT0, fT1, fT2);

        // Wrap texture coordinates if necessary
        WRAP(fS,dwFlags & CTXT_HAS_WRAPU_ENABLED);
        WRAP(fT,dwFlags & CTXT_HAS_WRAPV_ENABLED);

        // Scale s,t coordinate values
        fS0 *= pContext->DeltaWidthScale;
        fS1 *= pContext->DeltaWidthScale;
        fS2 *= pContext->DeltaWidthScale;
        fT0 *= pContext->DeltaHeightScale;
        fT1 *= pContext->DeltaHeightScale;
        fT2 *= pContext->DeltaHeightScale;

        // Apply perspective corrections if necessary
        if (dwFlags & CTXT_HAS_PERSPECTIVE_ENABLED)
        {
            fQ0 = lpV0->rhw; 
            fQ1 = lpV1->rhw;
            fQ2 = lpV2->rhw;

            fS0 *= fQ0;
            fT0 *= fQ0;

            fS1 *= fQ1;
            fT1 *= fQ1;

            fS2 *= fQ2;
            fT2 *= fQ2;
        }
        else
        {
            fQ0 = fQ1 = fQ2 = 1.0;
        }

        // Send lines s,t,q,ks (conditionaly),x,y,z values
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            fKs0   = RGB256_TO_LUMA(RGB_GETRED(dwSpec0),
                                        RGB_GETGREEN(dwSpec0),
                                        RGB_GETBLUE(dwSpec0));
            if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
            {
                fKs1 = RGB256_TO_LUMA(RGB_GETRED(dwSpec1),
                                        RGB_GETGREEN(dwSpec1),
                                        RGB_GETBLUE(dwSpec1));
                fKs2 = RGB256_TO_LUMA(RGB_GETRED(dwSpec2),
                                        RGB_GETGREEN(dwSpec2),
                                        RGB_GETBLUE(dwSpec2));
            }   
            else 
            {
                fKs2 = fKs1 = fKs0; 
            }

            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0, fKs0,
                                                  lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1, fKs1,
                                                  lpV1->sx, lpV1->sy, lpV1->sz);
            SEND_VERTEX_STQ_KS_XYZ(__Permedia2TagV2FloatS, fS2, fT2, fQ2, fKs2,
                                                  lpV2->sx, lpV2->sy, lpV2->sz);
        }
        else
        {
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV0FloatS, fS0, fT0, fQ0,
                                                lpV0->sx, lpV0->sy, lpV0->sz);
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV1FloatS, fS1, fT1, fQ1,
                                                lpV1->sx, lpV1->sy, lpV1->sz);
            SEND_VERTEX_STQ_XYZ(__Permedia2TagV2FloatS, fS2, fT2, fQ2,
                                                lpV2->sx, lpV2->sy, lpV2->sz);
        }

    }
    else     // not textured triangle
    {
        // If specular is enabled, change the colours
        if ((dwFlags & CTXT_HAS_SPECULAR_ENABLED) && (dwSpecularOffs!=0))
        {
            CLAMP8888(dwColor0, dwColor0, dwSpec0);
            CLAMP8888(dwColor1, dwColor1, dwSpec1);
            CLAMP8888(dwColor2, dwColor2, dwSpec2);
        }

        // Send triangles x,y,z values
        SEND_VERTEX_XYZ(__Permedia2TagV0FloatS, lpV0->sx, lpV0->sy, lpV0->sz);
        SEND_VERTEX_XYZ(__Permedia2TagV1FloatS, lpV1->sx, lpV1->sy, lpV1->sz);
        SEND_VERTEX_XYZ(__Permedia2TagV2FloatS, lpV2->sx, lpV2->sy, lpV2->sz);
    }

    // If fog is set, send the appropriate values
    if ((dwFlags & CTXT_HAS_FOGGING_ENABLED) && (dwSpecularOffs!=0))
    {
        SEND_VERTEX_FOG(__Permedia2TagV0FixedF, RGB_GET_GAMBIT_FOG(dwSpec0));
        SEND_VERTEX_FOG(__Permedia2TagV1FixedF, RGB_GET_GAMBIT_FOG(dwSpec1));
        SEND_VERTEX_FOG(__Permedia2TagV2FixedF, RGB_GET_GAMBIT_FOG(dwSpec2));
    }

    // Set alpha stippling if required by context
    if (dwFlags & CTXT_HAS_ALPHASTIPPLE_ENABLED)
    {
        SET_STIPPLED_ALPHA( (RGBA_GETALPHA(lpV0->color) >> 4) );
    }

    // Send appropriate color depending on Gouraud , Mono, & Alpha
    if (dwFlags & CTXT_HAS_GOURAUD_ENABLED)
    {
        // Gouraud shading
        if (RENDER_MONO)
        {
            SEND_VERTEX_RGB_MONO(__Permedia2TagV0FixedS, dwColor0);
            SEND_VERTEX_RGB_MONO(__Permedia2TagV1FixedS, dwColor1);
            SEND_VERTEX_RGB_MONO(__Permedia2TagV2FixedS, dwColor2);
        }
        else
        {
            if (dwFlags & CTXT_HAS_ALPHABLEND_ENABLED)
            {
                if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
                {
                    dwColor0 &= 0xFFFFFF;     // supress color's alpha value
                    dwColor1 &= 0xFFFFFF;
                    dwColor2 &= 0xFFFFFF;
                }
                SEND_VERTEX_RGBA(__Permedia2TagV0FixedS, dwColor0);
                SEND_VERTEX_RGBA(__Permedia2TagV1FixedS, dwColor1);
                SEND_VERTEX_RGBA(__Permedia2TagV2FixedS, dwColor2);
            }
            else
            {
                SEND_VERTEX_RGB(__Permedia2TagV0FixedS, dwColor0);
                SEND_VERTEX_RGB(__Permedia2TagV1FixedS, dwColor1);
                SEND_VERTEX_RGB(__Permedia2TagV2FixedS, dwColor2);
            }
        }
    }
    else    // Flat shading
    {
        if (RENDER_MONO)
        {
            // Get constant color from the blue channel
            DWORD BlueChannel = RGBA_GETBLUE(dwColor0);
            SEND_PERMEDIA_DATA( ConstantColor,
                            RGB_MAKE(BlueChannel, BlueChannel, BlueChannel));
        }
        else
        {
            if (pContext->FakeBlendNum & FAKE_ALPHABLEND_ONE_ONE)
            {
                dwColor0 &= 0xFFFFFF;
            }

            SEND_PERMEDIA_DATA( ConstantColor,
                                   RGBA_MAKE(RGBA_GETBLUE(dwColor0),
                                             RGBA_GETGREEN(dwColor0),
                                             RGBA_GETRED(dwColor0), 
                                             RGBA_GETALPHA(dwColor0)));
        }
    }

    SEND_PERMEDIA_DATA(DrawTriangle, ulRenderCmd); 
    COMMITDMAPTR();

    DBG_D3D((10,"Exiting P2_Draw_FVF_Solid_Tri"));

} // P2_Draw_FVF_Solid_Tri
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\d3dtxman.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.c
*
* Content:  D3D Texture manager
*
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#include "precomp.h"
#include "d3dtxman.h"
#include "dd.h"
#include "heap.h"
#define ALLOC_TAG ALLOC_TAG_TD2P
//-----------------------------------------------------------------------------
//
// void TextureHeapHeapify
//
//-----------------------------------------------------------------------------
void TextureHeapHeapify(PTextureHeap pTextureHeap, DWORD k)
{
    while(true) 
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);
        if(l < pTextureHeap->m_next)
            if(TextureCost(pTextureHeap->m_data_p[l]) <
                             TextureCost(pTextureHeap->m_data_p[k]))
                smallest = l;
            else
                smallest = k;
        else
            smallest = k;
        if(r < pTextureHeap->m_next)
            if(TextureCost(pTextureHeap->m_data_p[r]) <
                             TextureCost(pTextureHeap->m_data_p[smallest]))
                smallest = r;
        if(smallest != k) 
        {
            PPERMEDIA_D3DTEXTURE t = pTextureHeap->m_data_p[k];
            pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[smallest];
            pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            pTextureHeap->m_data_p[smallest] = t;
            t->m_dwHeapIndex = smallest;
            k = smallest;
        }
        else
            break;
    }
}

//-----------------------------------------------------------------------------
//
// bool TextureHeapAdd
//
//-----------------------------------------------------------------------------
bool TextureHeapAdd(PTextureHeap pTextureHeap, PPERMEDIA_D3DTEXTURE lpD3DTexI)
{
    if(pTextureHeap->m_next == pTextureHeap->m_size) 
    {
        pTextureHeap->m_size = pTextureHeap->m_size * 2 - 1;
        PPERMEDIA_D3DTEXTURE *p = (PPERMEDIA_D3DTEXTURE *)
            ENGALLOCMEM( FL_ZERO_MEMORY, 
                sizeof(PPERMEDIA_D3DTEXTURE)*pTextureHeap->m_size,ALLOC_TAG);

        if(p == 0)
        {
            DBG_D3D((0,"Failed to allocate memory to grow heap."));
            pTextureHeap->m_size = (pTextureHeap->m_size + 1) / 2; // restore size
            return false;
        }
        memcpy(p + 1, pTextureHeap->m_data_p + 1, 
            sizeof(PPERMEDIA_D3DTEXTURE) * (pTextureHeap->m_next - 1));
        ENGFREEMEM( pTextureHeap->m_data_p);
        pTextureHeap->m_data_p = p;
    }
    ULONGLONG Cost = TextureCost(lpD3DTexI);
    for(DWORD k = pTextureHeap->m_next; k > 1; k = parent(k))
        if(Cost < TextureCost(pTextureHeap->m_data_p[parent(k)])) 
        {
            pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
            pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
        }
        else
            break;
    pTextureHeap->m_data_p[k] = lpD3DTexI;
    lpD3DTexI->m_dwHeapIndex = k;
    ++pTextureHeap->m_next;
    return true;
}

//-----------------------------------------------------------------------------
//
// PPERMEDIA_D3DTEXTURE TextureHeapExtractMin
//
//-----------------------------------------------------------------------------
PPERMEDIA_D3DTEXTURE TextureHeapExtractMin(PTextureHeap pTextureHeap)
{
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[1];
    --pTextureHeap->m_next;
    pTextureHeap->m_data_p[1] = pTextureHeap->m_data_p[pTextureHeap->m_next];
    pTextureHeap->m_data_p[1]->m_dwHeapIndex = 1;
    TextureHeapHeapify(pTextureHeap,1);
    lpD3DTexI->m_dwHeapIndex = 0;
    return lpD3DTexI;
}

//-----------------------------------------------------------------------------
//
// PPERMEDIA_D3DTEXTURE TextureHeapExtractMax
//
//-----------------------------------------------------------------------------
PPERMEDIA_D3DTEXTURE TextureHeapExtractMax(PTextureHeap pTextureHeap)
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper. 
    // NOTE: (lchild(i) >= m_next) is true only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    unsigned max = pTextureHeap->m_next - 1;
    ULONGLONG maxcost = 0;
    for(unsigned i = max; lchild(i) >= pTextureHeap->m_next; --i)
    {
        ULONGLONG Cost = TextureCost(pTextureHeap->m_data_p[i]);
        if(maxcost < Cost)
        {
            maxcost = Cost;
            max = i;
        }
    }
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[max];
    TextureHeapDel(pTextureHeap,max);
    return lpD3DTexI;
}

//-----------------------------------------------------------------------------
//
// void TextureHeapDel
//
//-----------------------------------------------------------------------------
void TextureHeapDel(PTextureHeap pTextureHeap, DWORD k)
{
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[k];
    --pTextureHeap->m_next;
    ULONGLONG Cost = TextureCost(pTextureHeap->m_data_p[pTextureHeap->m_next]);
    if(Cost < TextureCost(lpD3DTexI))
    {
        while(k > 1)
        {
            if(Cost < TextureCost(pTextureHeap->m_data_p[parent(k)]))
            {
                pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
                pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
    }
    else
    {
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
        TextureHeapHeapify(pTextureHeap,k);
    }
    lpD3DTexI->m_dwHeapIndex = 0;
}

//-----------------------------------------------------------------------------
//
// void TextureHeapUpdate
//
//-----------------------------------------------------------------------------
void TextureHeapUpdate(PTextureHeap pTextureHeap, DWORD k,
                       DWORD priority, DWORD ticks) 
{
    PPERMEDIA_D3DTEXTURE lpD3DTexI = pTextureHeap->m_data_p[k];
    ULONGLONG Cost = 0;
#ifdef _X86_
    _asm
    {
        mov     edx, 0;
        shl     edx, 31;
        mov     eax, priority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR Cost + 4, edx;
        shl     ecx, 31;
        mov     eax, ticks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR Cost, eax;
    }
#else
    Cost = ((ULONGLONG)priority << 31) + ((ULONGLONG)(ticks >> 1));
#endif
    if(Cost < TextureCost(lpD3DTexI))
    {
        while(k > 1)
        {
            if(Cost < TextureCost(pTextureHeap->m_data_p[parent(k)]))
            {
                pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
                pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            }
            else
                break;
            k = parent(k);
        }
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        lpD3DTexI->m_dwHeapIndex = k;
        pTextureHeap->m_data_p[k] = lpD3DTexI;
    }
    else
    {
        lpD3DTexI->m_dwPriority = priority;
        lpD3DTexI->m_dwTicks = ticks;
        TextureHeapHeapify(pTextureHeap,k);
    }
}

//-----------------------------------------------------------------------------
//
// HRESULT TextureCacheManagerInitialize
//
//-----------------------------------------------------------------------------
HRESULT TextureCacheManagerInitialize(
    PTextureCacheManager pTextureCacheManager)
{
    pTextureCacheManager->tcm_ticks = 0;
    pTextureCacheManager->m_heap.m_next = 1;
    pTextureCacheManager->m_heap.m_size = 1024;
    pTextureCacheManager->m_heap.m_data_p = (PPERMEDIA_D3DTEXTURE *)
        ENGALLOCMEM( FL_ZERO_MEMORY, 
            sizeof(PPERMEDIA_D3DTEXTURE)*pTextureCacheManager->m_heap.m_size,
            ALLOC_TAG);
    if(pTextureCacheManager->m_heap.m_data_p == 0)
    {
        DBG_D3D((0,"Failed to allocate texture heap."));
        return E_OUTOFMEMORY;
    }
    memset(pTextureCacheManager->m_heap.m_data_p, 0, 
        sizeof(PPERMEDIA_D3DTEXTURE) * pTextureCacheManager->m_heap.m_size);
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// BOOL TextureCacheManagerFreeTextures
//
//-----------------------------------------------------------------------------
BOOL TextureCacheManagerFreeTextures(
    PTextureCacheManager pTextureCacheManager,DWORD dwStage, DWORD dwBytes)
{
    if(pTextureCacheManager->m_heap.m_next <= 1)
        return false;
    PPERMEDIA_D3DTEXTURE rc;
    for(unsigned i = 0; 
        pTextureCacheManager->m_heap.m_next > 1 && i < dwBytes; 
        i += rc->m_dwBytes)
    {
        // Find the LRU texture and remove it.
        rc = TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        TextureCacheManagerRemove(pTextureCacheManager,rc);
        pTextureCacheManager->m_stats.dwLastPri = rc->m_dwPriority;
        ++pTextureCacheManager->m_stats.dwNumEvicts;
        DBG_D3D((2, "Removed texture with timestamp %u,%u (current = %u).", 
            rc->m_dwPriority, rc->m_dwTicks, pTextureCacheManager->tcm_ticks));
    }
    return true;
}

//-----------------------------------------------------------------------------
//
// HRESULT TextureCacheManagerAllocNode
//
//-----------------------------------------------------------------------------
HRESULT TextureCacheManagerAllocNode(
    PERMEDIA_D3DCONTEXT* pContext,
    PPERMEDIA_D3DTEXTURE pTexture)
{
    DWORD trycount = 0, bytecount = pTexture->m_dwBytes;
    PermediaSurfaceData* pPrivateData=pTexture->pTextureSurface;
    PTextureCacheManager pTextureCacheManager=pContext->pTextureManager;
    if (NULL == pPrivateData)
    {
        DBG_D3D((0,"pTextureSurface==NULL invalid texture"));
        return D3D_OK;  //we already have the video memory allocated
    }
    // Attempt to allocate a texture.
    while(NULL == pPrivateData->fpVidMem)
    {
        LONG lScratchDelta;
        DWORD   PackedPP;
        ++trycount;
        pPrivateData->fpVidMem=(FLATPTR)
            ulVidMemAllocate( pContext->ppdev,
                              pTexture->wWidth,
                              pTexture->wHeight,
                              ShiftLookup[pTexture->dwRGBBitCount>>3],
                              &lScratchDelta,
                              &pPrivateData->pvmHeap,
                              &PackedPP,
                              FALSE);
        DBG_D3D((8,"Got fpVidMem=%08lx",pPrivateData->fpVidMem));
        if (NULL != pPrivateData->fpVidMem)
        {   // No problem, there is enough memory. 
            pTexture->m_dwTicks = pTextureCacheManager->tcm_ticks;
            if(!TextureHeapAdd(&pTextureCacheManager->m_heap,pTexture))
            {          
                VidMemFree(pPrivateData->pvmHeap->lpHeap,
                    pPrivateData->fpVidMem);
                pPrivateData->fpVidMem=NULL;
                DBG_D3D((0,"Out of memory"));
                return DDERR_OUTOFMEMORY;
            }
            pPrivateData->dwFlags |= P2_SURFACE_NEEDUPDATE;
            break;
        }
        else
        {
            if (!TextureCacheManagerFreeTextures(
                pTextureCacheManager,0, bytecount))
            {
                DBG_D3D((0,"all Freed no further video memory available"));
                return DDERR_OUTOFVIDEOMEMORY;	//nothing left
            }
            bytecount <<= 1;
        }
    }
    if(trycount > 1)
    {
        DBG_D3D((8, "Allocated texture after %u tries.", trycount));
    }
    TextureCacheManagerIncTotSz(pTextureCacheManager,
        pTexture->m_dwBytes);
    ++pTextureCacheManager->m_stats.dwWorkingSet;
    pTextureCacheManager->m_stats.dwWorkingSetBytes 
        += (pTexture->m_dwBytes);
    ++pTextureCacheManager->m_stats.dwNumVidCreates;
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// void TextureCacheManagerRemove
//
// remove all HW handles and release surface
//
//-----------------------------------------------------------------------------
void TextureCacheManagerRemove(
    PTextureCacheManager pTextureCacheManager,
    PPERMEDIA_D3DTEXTURE pTexture)
{
    PermediaSurfaceData* pPrivateData=pTexture->pTextureSurface;
    if (CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData) && pPrivateData->fpVidMem)
    {
        VidMemFree(pPrivateData->pvmHeap->lpHeap,pPrivateData->fpVidMem);
        pPrivateData->fpVidMem=NULL;
        TextureCacheManagerDecTotSz(pTextureCacheManager,
            pTexture->m_dwBytes);
        --pTextureCacheManager->m_stats.dwWorkingSet;
        pTextureCacheManager->m_stats.dwWorkingSetBytes -= 
            (pTexture->m_dwBytes);
    }
    if (pTexture->m_dwHeapIndex && pTextureCacheManager->m_heap.m_data_p)
        TextureHeapDel(&pTextureCacheManager->m_heap,
        pTexture->m_dwHeapIndex); 
}

//-----------------------------------------------------------------------------
//
// void TextureCacheManagerEvictTextures
//
//-----------------------------------------------------------------------------
void TextureCacheManagerEvictTextures(
    PTextureCacheManager pTextureCacheManager)
{
    while(pTextureCacheManager->m_heap.m_next > 1)
    {
        PPERMEDIA_D3DTEXTURE lpD3DTexI = 
            TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        TextureCacheManagerRemove(pTextureCacheManager,lpD3DTexI);
    }
    pTextureCacheManager->tcm_ticks = 0;
}

//-----------------------------------------------------------------------------
//
// void TextureCacheManagerTimeStamp
//
//-----------------------------------------------------------------------------
void TextureCacheManagerTimeStamp(
    PTextureCacheManager pTextureCacheManager,PPERMEDIA_D3DTEXTURE lpD3DTexI)
{
    TextureHeapUpdate(&pTextureCacheManager->m_heap,
        lpD3DTexI->m_dwHeapIndex, lpD3DTexI->m_dwPriority, 
        pTextureCacheManager->tcm_ticks);
    pTextureCacheManager->tcm_ticks += 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dd.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dd.c
*
* Content:
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define INITGUID
#include "precomp.h"
#include <mmsystem.h>
#include "directx.h"
#include "dd.h"
#include "d3dhw.h"
#include "d3dtext.h"
#include "heap.h"

//-----------------------------------------------------------------------------
//
// use bits to indicate which ROPs you support.
//
// DWORD 0, bit 0 == ROP 0
// DWORD 8, bit 31 == ROP 255
//
//-----------------------------------------------------------------------------

static BYTE ropList[] =
{
    SRCCOPY >> 16,
};

static DWORD rops[DD_ROP_SPACE] = { 0 };



// The FourCC's we support
static DWORD fourCC[] =
{
    FOURCC_YUV422
};

//-----------------------------------------------------------------------------
//
//      setupRops
//
//      build array for supported ROPS
//
//-----------------------------------------------------------------------------

VOID
setupRops( LPBYTE proplist, LPDWORD proptable, int cnt )
{
    INT         i;
    DWORD       idx;
    DWORD       bit;
    DWORD       rop;

    for(i=0; i<cnt; i++)
    {
        rop = proplist[i];
        idx = rop / 32;
        bit = 1L << ((DWORD)(rop % 32));
        proptable[idx] |= bit;
    }

} // setupRops

//-----------------------------------------------------------------------------
//
//  P2DisableAllUnits
//
//  reset permedia rasterizer to known state
//
//-----------------------------------------------------------------------------

VOID
P2DisableAllUnits(PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);

    RESERVEDMAPTR(47);
    SEND_PERMEDIA_DATA(RasterizerMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AreaStippleMode,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ScissorMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(ColorDDAMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FogMode,             __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LBReadMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(Window,              __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(StencilMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(DepthMode,           __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LBWriteMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBReadMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(DitherMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LogicalOpMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBWriteMode,         __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(StatisticMode,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AlphaBlendMode,      __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FilterMode,          __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBSourceData,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(LBWriteFormat,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode,     __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureMapFormat,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureDataFormat,   __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(YUVMode,             __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AStart,              PM_BYTE_COLOR(0xFF));
    SEND_PERMEDIA_DATA(TextureBaseAddress,  __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTIndex,       __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TexelLUTTransfer,    __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureAddressMode,  __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(AlphaMapUpperBound,  0);
    SEND_PERMEDIA_DATA(AlphaMapLowerBound,  0);
    SEND_PERMEDIA_DATA(Color,  0);

    SEND_PERMEDIA_DATA(FBWriteMode, __PERMEDIA_ENABLE);
    SEND_PERMEDIA_DATA(FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA(FBHardwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);
    SEND_PERMEDIA_DATA(FBSoftwareWriteMask, __PERMEDIA_ALL_WRITEMASKS_SET);

    // We sometimes use the scissor in DDRAW to scissor out unnecessary pixels.
    SEND_PERMEDIA_DATA(ScissorMinXY, 0);
    SEND_PERMEDIA_DATA(ScissorMaxXY, (ppdev->cyMemory << 16) | (ppdev->cxMemory));
    SEND_PERMEDIA_DATA(ScreenSize, (ppdev->cyMemory << 16) | (ppdev->cxMemory));

    SEND_PERMEDIA_DATA(WindowOrigin, 0x0);

    // DirectDraw might not need to set these up
    SEND_PERMEDIA_DATA(dXDom, 0x0);
    SEND_PERMEDIA_DATA(dXSub, 0x0);

    // set max size, no filtering
    SEND_PERMEDIA_DATA(TextureReadMode,
        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
        PM_TEXREADMODE_WIDTH(11) |
        PM_TEXREADMODE_HEIGHT(11) );

    // 16 bit Z, no other buffers
    SEND_PERMEDIA_DATA(LBWriteFormat, __PERMEDIA_DEPTH_WIDTH_16);

    // Ensure an extra LBData message doesn't flow through the core.
    SEND_PERMEDIA_DATA(Window, PM_WINDOW_DISABLELBUPDATE(__PERMEDIA_ENABLE));

    SEND_PERMEDIA_DATA(FBReadPixel, ppdev->bPixShift);

    COMMITDMAPTR();
    FLUSHDMA();

}   // P2DisableAllUnits

//-----------------------------------------------------------------------------
//
// GetDDHALInfo
//
// Takes a pointer to a partially or fully filled in ppdev and a pointer
// to an empty DDHALINFO and fills in the DDHALINFO.
//
//-----------------------------------------------------------------------------

VOID
GetDDHALInfo(PPDev ppdev, DDHALINFO* pHALInfo)
{
    DWORD dwResult;
    BOOL bRet;

    DBG_DD(( 5, "DDraw:GetDDHalInfo"));

    // Setup the HAL driver caps.
    memset( pHALInfo, 0, sizeof(DDHALINFO));
    pHALInfo->dwSize = sizeof(DDHALINFO);

    // Setup the ROPS we do.
    setupRops( ropList, rops, sizeof(ropList)/sizeof(ropList[0]));

    // The most basic DirectDraw functionality
    pHALInfo->ddCaps.dwCaps =   DDCAPS_BLT |
                                DDCAPS_BLTQUEUE |
                                DDCAPS_BLTCOLORFILL |
                                DDCAPS_READSCANLINE;

    pHALInfo->ddCaps.ddsCaps.dwCaps =   DDSCAPS_OFFSCREENPLAIN |
                                        DDSCAPS_PRIMARYSURFACE |
                                        DDSCAPS_FLIP;

    // add caps for D3D
    pHALInfo->ddCaps.dwCaps |=  DDCAPS_3D |
                                DDCAPS_ALPHA |
                                DDCAPS_BLTDEPTHFILL;

    // add surface caps for D3D
    pHALInfo->ddCaps.ddsCaps.dwCaps |=  DDSCAPS_ALPHA |
                                        DDSCAPS_3DDEVICE |
                                        DDSCAPS_ZBUFFER;

    // Permedia can do
    // 1. Stretching/Shrinking
    // 2. YUV->RGB conversion (only non paletted mode)
    // 3. Mirroring in X and Y

    // add Permedia caps to global caps
    pHALInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH |
                               DDCAPS_COLORKEY |
                               DDCAPS_CANBLTSYSMEM;


#if DX7_STEREO
    // check if mode supports stereo
    DD_STEREOMODE DDStereoMode;
    DDStereoMode.dwHeight = ppdev->cyScreen;
    DDStereoMode.dwWidth  = ppdev->cxScreen;
    DDStereoMode.dwBpp    = ppdev->cBitsPerPel;
    DDStereoMode.dwRefreshRate= 0;
    ppdev->bCanDoStereo=bIsStereoMode(ppdev,&DDStereoMode);

    // Stereo caps are set if the driver can do stereo in any mode:
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_STEREO;
    pHALInfo->ddCaps.dwSVCaps = DDSVCAPS_STEREOSEQUENTIAL;
#endif

    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGETEXTURE;

    //declare we can handle textures wider than the primary
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_WIDESURFACES;

    // Special effects caps
    pHALInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTSTRETCHY |
                                DDFXCAPS_BLTSTRETCHX |
                                DDFXCAPS_BLTSTRETCHYN |
                                DDFXCAPS_BLTSTRETCHXN |
                                DDFXCAPS_BLTSHRINKY |
                                DDFXCAPS_BLTSHRINKX |
                                DDFXCAPS_BLTSHRINKYN |
                                DDFXCAPS_BLTSHRINKXN |
                                DDFXCAPS_BLTMIRRORUPDOWN |
                                DDFXCAPS_BLTMIRRORLEFTRIGHT;


    // add AlphaBlt and Filter caps
    pHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTALPHA |
                                 DDFXCAPS_BLTFILTER;

    // colorkey caps, only src color key supported
    pHALInfo->ddCaps.dwCKeyCaps =   DDCKEYCAPS_SRCBLT |
                                    DDCKEYCAPS_SRCBLTCLRSPACE;

    // We can do a texture from sysmem to video mem blt.
    pHALInfo->ddCaps.dwSVBCaps = DDCAPS_BLT;
    pHALInfo->ddCaps.dwSVBCKeyCaps = 0;
    pHALInfo->ddCaps.dwSVBFXCaps = 0;

    // Fill in the sysmem->vidmem rops (only can copy);
    for(int i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSVBRops[i] = rops[i];
    }

    if (ppdev->iBitmapFormat != BMF_8BPP)
    {
        pHALInfo->ddCaps.dwCaps |= DDCAPS_BLTFOURCC;
        pHALInfo->ddCaps.dwCKeyCaps |=  DDCKEYCAPS_SRCBLTCLRSPACEYUV;
    }

    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_TEXTURE;

    // Z Buffer is only 16 Bits on Permedia
    pHALInfo->ddCaps.dwZBufferBitDepths = DDBD_16;

#if D3D_MIPMAPPING
    // Mip Mapping
    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_MIPMAP;
#endif

    if (DD_P2AGPCAPABLE(ppdev))
    {
        DBG_DD((1, "GetDDHALInfo: P2 AGP board - supports NONLOCALVIDMEM"));

        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM |
                                    DDCAPS2_NONLOCALVIDMEMCAPS;
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM |
                                           DDSCAPS_NONLOCALVIDMEM;
    }
    else
    {
        DBG_DD((1,"GetDDHALInfo: P2 Board is NOT AGP"));
    }

    // Won't do Video-Sys mem Blits.
    pHALInfo->ddCaps.dwVSBCaps = 0;
    pHALInfo->ddCaps.dwVSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwVSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwVSBRops[i] = 0;
    }

    // Won't do Sys-Sys mem Blits
    pHALInfo->ddCaps.dwSSBCaps = 0;
    pHALInfo->ddCaps.dwSSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwSSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSSBRops[i] = 0;
    }

    // bit depths supported for alpha and Z
    pHALInfo->ddCaps.dwAlphaBltConstBitDepths = DDBD_2 |
                                                DDBD_4 |
                                                DDBD_8;
    pHALInfo->ddCaps.dwAlphaBltPixelBitDepths = DDBD_1 |
                                                DDBD_8;
    pHALInfo->ddCaps.dwAlphaBltSurfaceBitDepths = DDBD_1 |
                                                  DDBD_2 |
                                                  DDBD_4 |
                                                  DDBD_8;
    pHALInfo->ddCaps.dwAlphaOverlayConstBitDepths = DDBD_2 |
                                                    DDBD_4 |
                                                    DDBD_8;
    pHALInfo->ddCaps.dwAlphaOverlayPixelBitDepths = DDBD_1 |
                                                    DDBD_8;
    pHALInfo->ddCaps.dwAlphaOverlaySurfaceBitDepths = DDBD_1 |
                                                      DDBD_2 |
                                                      DDBD_4 |
                                                      DDBD_8;

    // ROPS supported
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwRops[i] = rops[i];
    }

    // For DX5 and beyond we support this new informational callback.
    pHALInfo->GetDriverInfo = DdGetDriverInfo;
    pHALInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;

    // now setup D3D callbacks
    D3DHALCreateDriver( ppdev,
                        (LPD3DHAL_GLOBALDRIVERDATA*)
                            &pHALInfo->lpD3DGlobalDriverData,
                        (LPD3DHAL_CALLBACKS*)
                            &pHALInfo->lpD3DHALCallbacks,
                        (LPDDHAL_D3DBUFCALLBACKS*)
                            &pHALInfo->lpD3DBufCallbacks);

    if(pHALInfo->lpD3DGlobalDriverData == NULL)
    {
        // no D3D available - kill caps we set before
        pHALInfo->ddCaps.dwCaps &=
            ~(DDCAPS_3D | DDCAPS_BLTDEPTHFILL);
        pHALInfo->ddCaps.ddsCaps.dwCaps &=
            ~(DDSCAPS_3DDEVICE | DDSCAPS_ZBUFFER);
    }

}  // GetHALInfo

//-----------------------------------------------------------------------------
//
//  Global DirectDraw Callbacks
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
//  DdFlip
//
//  This callback is invoked whenever we are about to flip to from
//  one surface to another. lpFlipData->lpSurfCurr is the surface we were at,
//  lpFlipData->lpSurfTarg is the one we are flipping to.
//
//  You should point the hardware registers at the new surface, and
//  also keep track of the surface that was flipped away from, so
//  that if the user tries to lock it, you can be sure that it is done
//  being displayed
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdFlip( LPDDHAL_FLIPDATA lpFlipData)
{
    PPDev ppdev=(PPDev)lpFlipData->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD       dwDDSurfaceOffset;
    HRESULT     ddrval;

    DBG_DD(( 3, "DDraw:Flip"));

    // Switch to DirectDraw context
    DDCONTEXT;

    // is the previous Flip already done?
    // check if the current surface is already displayed
    ddrval = updateFlipStatus(ppdev);
    if( FAILED(ddrval) )
    {
        lpFlipData->ddRVal = ddrval;
        return DDHAL_DRIVER_HANDLED;
    }

    // everything is OK, do the flip.
    // get offset for Permedia ScreenBase register
    dwDDSurfaceOffset=(DWORD)lpFlipData->lpSurfTarg->lpGbl->fpVidMem;


#if DX7_STEREO
    if (lpFlipData->dwFlags & DDFLIP_STEREO)   // will be stereo
    {
        DBG_DD((4,"DDraw:Flip:Stereo"));
        DBG_DD((5,"ScreenBase: %08lx", dwDDSurfaceOffset));

        if (lpFlipData->lpSurfTargLeft!=NULL)
        {
            DWORD dwDDLeftSurfaceOffset;
            dwDDLeftSurfaceOffset=(DWORD)
                lpFlipData->lpSurfTargLeft->lpGbl->fpVidMem;
            LD_PERMEDIA_REG(PREG_SCREENBASERIGHT,dwDDLeftSurfaceOffset>>3);
            DBG_DD((5,"ScreenBaseLeft: %08lx", dwDDLeftSurfaceOffset));
        }

        ULONG ulVControl=READ_PERMEDIA_REG(PREG_VIDEOCONTROL);
        if ((ulVControl&PREG_VC_STEREOENABLE)==0 ||
            !ppdev->bDdStereoMode)
        {
            ppdev->bDdStereoMode=TRUE;
            LD_PERMEDIA_REG(PREG_VIDEOCONTROL, ulVControl
                                             | PREG_VC_STEREOENABLE);
        }
    } else
#endif // DX7_STEREO
    {
        // append flip command to Permedia render pipeline
        // that makes sure that all buffers are flushed before
        // the flip occurs
#if DX7_STEREO
        if (ppdev->bDdStereoMode)
        {
            ppdev->bDdStereoMode=FALSE;
            LD_PERMEDIA_REG(PREG_VIDEOCONTROL,
                READ_PERMEDIA_REG(PREG_VIDEOCONTROL)&
                ~PREG_VC_STEREOENABLE);
        }
#endif
    }

    // adjust base address according to register spec.
    dwDDSurfaceOffset>>=3;

    // add new base address to render pipeline
    RESERVEDMAPTR(1);
    LD_INPUT_FIFO(__Permedia2TagSuspendUntilFrameBlank, dwDDSurfaceOffset);
    COMMITDMAPTR();
    FLUSHDMA();

    // remember new Surface Offset for GetFlipStatus
    ppdev->dwNewDDSurfaceOffset=dwDDSurfaceOffset;

    lpFlipData->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;

} // DdFlip

//-----------------------------------------------------------------------------
//
// DdWaitForVerticalBlank
//
// This callback is invoked to get information about the vertical blank
// status of the display or to wait until the display is at the begin or
// the end of the vertical blank
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdWaitForVerticalBlank(LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    static int bInVBlank = FALSE;
    PPDev ppdev=(PPDev)lpWaitForVerticalBlank->lpDD->dhpdev;

    DBG_DD(( 2, "DDraw:WaitForVerticalBlank"));

    switch(lpWaitForVerticalBlank->dwFlags)
    {

    case DDWAITVB_I_TESTVB:

        // If the monitor is off, we don't always want to report
        // the same status or else an app polling this status
        // might hang

        if( !(READ_PERMEDIA_REG(PREG_VIDEOCONTROL) & PREG_VC_VIDEO_ENABLE))
        {
            lpWaitForVerticalBlank->bIsInVB = bInVBlank;
            bInVBlank = !bInVBlank;
        }
        else
        {
            // Just a request for current VBLANK status.

            lpWaitForVerticalBlank->bIsInVB = IN_VRETRACE(ppdev);
        }

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKBEGIN:

        // we don't care to wait if the monitor is off

        if( READ_PERMEDIA_REG(PREG_VIDEOCONTROL) & PREG_VC_VIDEO_ENABLE)
        {
            // if blockbegin is requested we wait until the vertical retrace
            // is over, and then wait for the display period to end.

            while(IN_VRETRACE(ppdev));
            while(IN_DISPLAY(ppdev));
        }

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;

    case DDWAITVB_BLOCKEND:

        // we don't care to wait if the monitor is off

        if( READ_PERMEDIA_REG(PREG_VIDEOCONTROL) & PREG_VC_VIDEO_ENABLE)
        {
            // if blockend is requested we wait for the vblank interval to end.

            if( IN_VRETRACE(ppdev) )
            {
                while( IN_VRETRACE(ppdev) );
            }
            else
            {
                while(IN_DISPLAY(ppdev));
                while(IN_VRETRACE(ppdev));
            }
        }

        lpWaitForVerticalBlank->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_NOTHANDLED;

} // WaitForVerticalBlank

//-----------------------------------------------------------------------------
//
//  Lock
//
//  This call is invoked to lock a DirectDraw Videomemory surface. To make
//  sure there are no pending drawing operations on the surface, flush all
//  drawing operations and wait for a flip if it is still pending.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdLock( LPDDHAL_LOCKDATA lpLockData )
{
    PPDev ppdev=(PPDev)lpLockData->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    HRESULT     ddrval;
    DWORD pSurf;

    DBG_DD(( 2, "DDraw:Lock"));

    //
    // Switch to DirectDraw context
    //
    DDCONTEXT;

    // check to see if any pending physical flip has occurred
    ddrval = updateFlipStatus(ppdev);
    if( FAILED(ddrval) )
    {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // don't allow a lock if a blt is in progress
    //

    if(DRAW_ENGINE_BUSY)
    {
        DBG_DD((2,"DDraw:Lock, DrawEngineBusy"));
        FLUSHDMA();
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }


    // send a flush and wait for outstanding operations
    // before allowing surfaces to be locked.

    SYNC_WITH_PERMEDIA;

    // now check if the user wants to lock a texture surface,
    // which was loaded as patched! In this case we have to to
    // a blit to unpatch before we return it to the user
    // This is not expensive, since we leave it unpatched for
    // the future when the application decides to use it this way
    LPDDRAWI_DDRAWSURFACE_LCL  pLcl=lpLockData->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL  pGbl=pLcl->lpGbl;
    PermediaSurfaceData       *pPrivate=
        (PermediaSurfaceData*)pGbl->dwReserved1;

    //
    //  If the user attempts to lock a managed surface, mark it as dirty
    //  and return.
    //

    if (pLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        DBG_DD(( 3, "DDraw:Lock %08lx %08lx",
            pLcl->lpSurfMore->dwSurfaceHandle, pGbl->fpVidMem));
        if (NULL != pPrivate)
            pPrivate->dwFlags |= P2_SURFACE_NEEDUPDATE;
        lpLockData->lpSurfData = (LPVOID)(pLcl->lpGbl->fpVidMem +
                                          (pLcl->lpGbl->lPitch * lpLockData->rArea.top) +
                                          (lpLockData->rArea.left << DDSurf_GetPixelShift(pLcl)));
        lpLockData->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    DD_CHECK_PRIMARY_SURFACE_DATA(pLcl,pPrivate);

    //
    //  We only need to unswizzle a surface if the
    //  PrivateData is in a format we know (pPrivate!=NULL)
    //

    if (pPrivate!=NULL)
    {
        //
        //  if the surface is a texture which was loaded in a swizzled
        //  format, we have to undo the swizzle before succeding the lock.
        //  In this driver, a texture remains unswizzled when a user
        //  attempted to lock it once.
        //

        if (pPrivate->dwFlags & P2_ISPATCHED)
        {
            //
            // The scratchpad must be 32 lines high and should have
            // the same width as our original surface.
            //

            PermediaSurfaceData ScratchData=*pPrivate;
            LONG lScratchDelta;
            VIDEOMEMORY*  pvmHeap;
            ULONG ulScratchOffset=
                ulVidMemAllocate( ppdev,
                                  DDSurf_Width(pLcl),
                                  DDSurf_Height(pLcl),
                                  DDSurf_GetPixelShift(pLcl),
                                  &lScratchDelta,
                                  &pvmHeap,
                                  &ScratchData.ulPackedPP,
                                  FALSE);

            DBG_DD(( 5, "  unswizzle surface, scratchpad at: %08lx",
                           ulScratchOffset));
            if (ulScratchOffset!=0)
            {
                RECTL rSurfRect;
                RECTL rScratchRect;

                rSurfRect.left=0;
                rSurfRect.top=0;
                rSurfRect.right=DDSurf_Width(pLcl);
                rSurfRect.bottom=32;

                rScratchRect=rSurfRect;

                // scratchpad should be non patched
                ScratchData.dwFlags &= ~(P2_ISPATCHED|P2_CANPATCH);

                LONG lSurfOffset;
                DWORD dwSurfBase=(DWORD)pGbl->fpVidMem >>
                    DDSurf_GetPixelShift(pLcl);
                DWORD dwScratchBase=ulScratchOffset >>
                    DDSurf_GetPixelShift(pLcl);
                lScratchDelta >>= DDSurf_GetPixelShift(pLcl);
                LONG lSurfDelta=DDSurf_Pitch(pLcl)>>
                    DDSurf_GetPixelShift(pLcl);

                for (DWORD i=0; i<DDSurf_Height(pLcl); i+=32)
                {
                    lSurfOffset = dwSurfBase-dwScratchBase;
                    // first do a patched to unpatched blt to the scratchpad
                    PermediaPatchedCopyBlt( ppdev,
                                            lScratchDelta,
                                            lSurfDelta,
                                            &ScratchData,
                                            pPrivate,
                                            &rScratchRect,
                                            &rSurfRect,
                                            dwScratchBase,
                                            lSurfOffset);

                    // then do a fast copyblt back to the original
                    // Packed blit ignores the ISPATCHED flag

                    lSurfOffset = dwScratchBase-dwSurfBase;

                    PermediaPackedCopyBlt( ppdev,
                                           lSurfDelta,
                                           lScratchDelta,
                                           pPrivate,
                                           &ScratchData,
                                           &rSurfRect,
                                           &rScratchRect,
                                           dwSurfBase,
                                           lSurfOffset);

                    rSurfRect.top += 32;
                    rSurfRect.bottom += 32;
                }

                pPrivate->dwFlags &= ~P2_ISPATCHED;

                //
                // free scratchpad memory
                //
                VidMemFree( pvmHeap->lpHeap, ulScratchOffset);

                SYNC_WITH_PERMEDIA;
            } else
            {
                lpLockData->ddRVal = DDERR_OUTOFMEMORY;
                return DDHAL_DRIVER_HANDLED;
            }
        }
    }


    // Because we correctly set 'fpVidMem' to be the offset into our frame
    // buffer when we created the surface, DirectDraw will automatically take
    // care of adding in the user-mode frame buffer address if we return
    // DDHAL_DRIVER_NOTHANDLED:

    return DDHAL_DRIVER_NOTHANDLED;

} // DdLock

//-----------------------------------------------------------------------------
//
//  DdGetScanLine
//
//  This callback is invoked to get the current scanline of our video display
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetScanLine(LPDDHAL_GETSCANLINEDATA lpGetScanLine)
{
    PPDev ppdev=(PPDev)lpGetScanLine->lpDD->dhpdev;

    DBG_DD(( 2, "DDraw:GetScanLine"));

    //  If a vertical blank is in progress the scan line is
    //  indeterminant. If the scan line is indeterminant we return
    //  the error code DDERR_VERTICALBLANKINPROGRESS.
    //  Otherwise we return the scan line and a success code

    if( IN_VRETRACE(ppdev) )
    {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
        lpGetScanLine->dwScanLine = 0;
    }
    else
    {
        lpGetScanLine->dwScanLine = CURRENT_VLINE(ppdev);
        lpGetScanLine->ddRVal = DD_OK;
    }
    return DDHAL_DRIVER_HANDLED;

} // DdGetScanLine

//-----------------------------------------------------------------------------
//
//  DdGetBltStatus
//
//  This callback is invoked to get the current blit status or to ask if the
//  user can add the next blit.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetBltStatus(LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus )
{
    PPDev ppdev=(PPDev)lpGetBltStatus->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 2, "DDraw:DdGetBltStatus"));

    // CANBLT: can we add a blt?
    // On the Permedia we can always add blits

    if( lpGetBltStatus->dwFlags == DDGBS_CANBLT )
    {
        lpGetBltStatus->ddRVal = DD_OK;
    }
    else
    {
        if( DRAW_ENGINE_BUSY )
        {

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
            if(ppdev->ulLockCount)
            {
                 DBG_DD((MT_LOG_LEVEL, "DdGetBltStatus: re-entry! %d", ppdev->ulLockCount));
            }
            EngAcquireSemaphore(ppdev->hsemLock);
            ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

            // switch to DDraw context if necessary
            DDCONTEXT;

            FLUSHDMA();
            lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
            ppdev->ulLockCount--;
            EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
        }
        else
        {
            lpGetBltStatus->ddRVal = DD_OK;
        }
    }

    return DDHAL_DRIVER_HANDLED;

} // DdGetBltStatus

//-----------------------------------------------------------------------------
//
// DdGetFlipStatus
//
// If the display has went through one refresh cycle since the flip
// occurred we return DD_OK.  If it has not went through one refresh
// cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
// is still busy "drawing" the flipped page. We also return
// DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
// to know if they could flip yet
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetFlipStatus(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus )
{
    PPDev ppdev=(PPDev)lpGetFlipStatus->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 2, "DDraw:GetFlipStatus"));

    // switch to DDraw context if necessary
    DDCONTEXT;

    // we can always flip, since the flip is pipelined
    // but we allow only one flip in advance
    if( lpGetFlipStatus->dwFlags == DDGFS_CANFLIP )
    {
        lpGetFlipStatus->ddRVal = updateFlipStatus(ppdev);

        return DDHAL_DRIVER_HANDLED;
    }

    // don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem

    lpGetFlipStatus->ddRVal = updateFlipStatus(ppdev);

    return DDHAL_DRIVER_HANDLED;

} // DdGetFlipStatus



//-----------------------------------------------------------------------------
//
//  DdMapMemory
//
//  This is a new DDI call specific to Windows NT that is used to map
//  or unmap all the application modifiable portions of the frame buffer
//  into the specified process's address space.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory)
{
    PDev*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    DBG_DD(( 2, "DDraw:MapMemory"));

    ppdev = (PDev*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
            &ShareMemory,
            sizeof(VIDEO_SHARE_MEMORY),
            &ShareMemoryInformation,
            sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
            &ReturnedDataLength))
        {
            DBG_DD((0, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;

            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess=(FLATPTR)ShareMemoryInformation.VirtualAddress;

    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
            IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
            &ShareMemory,
            sizeof(VIDEO_SHARE_MEMORY),
            NULL,
            0,
            &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;

    return(DDHAL_DRIVER_HANDLED);
}


//-----------------------------------------------------------------------------
//
// DdSetExclusiveMode
//
// This function is called by DirectDraw when we switch from the GDI surface,
// to DirectDraw exclusive mode, e.g. to run a game in fullcreen mode.
// You only need to implement this function when you are using the
// 'HeapVidMemAllocAligned' function and allocate memory for Device Bitmaps
// and DirectDraw surfaces from the same heap.
//
// We use this call to disable GDI DeviceBitMaps when we are running in
// DirectDraw exclusive mode. Otherwise a DD app gets confused if both GDI and
// DirectDraw allocate memory from the same heap.
//
// See also DdFlipToGDISurface.
//
//-----------------------------------------------------------------------------


DWORD CALLBACK
DdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode)
{
    PDev*   ppdev=(PDev*)lpSetExclusiveMode->lpDD->dhpdev;

    DBG_DD((6, "DDraw::DdSetExclusiveMode called"));

    // remember setting of exclusive mode in ppdev,
    // so GDI can stop to promote DeviceBitmaps into
    // video memory

    ppdev->bDdExclusiveMode = lpSetExclusiveMode->dwEnterExcl;

    if (ppdev->bDdExclusiveMode)
    {
        // remove all GDI device bitmaps from video memory here
        // and make sure they will not be promoted to videomemory
        // until we leave exclusive mode.

        bDemoteAll(ppdev);
    }

    lpSetExclusiveMode->ddRVal=DD_OK;

    return (DDHAL_DRIVER_HANDLED);
}

//-----------------------------------------------------------------------------
//
// DWORD DdFlipToGDISurface
//
// This function is called by DirectDraw when it flips to the surface on which
// GDI can write to.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface)
{
    PDev*   ppdev=(PDev*)lpFlipToGDISurface->lpDD->dhpdev;

    DBG_DD((6, "DDraw::DdFlipToGDISurface called"));

    ppdev->dwNewDDSurfaceOffset=0xffffffff;

#if DX7_STEREO
    if (ppdev->bDdStereoMode)
    {
        ppdev->bDdStereoMode=FALSE;
        LD_PERMEDIA_REG(PREG_VIDEOCONTROL,
            READ_PERMEDIA_REG(PREG_VIDEOCONTROL) &
            ~PREG_VC_STEREOENABLE);
    }
#endif

    lpFlipToGDISurface->ddRVal=DD_OK;

    //
    //  we return NOTHANDLED, then the ddraw runtime takes
    //  care that we flip back to the primary...
    //
    return (DDHAL_DRIVER_NOTHANDLED);
}

//-----------------------------------------------------------------------------
//
// DWORD DdFreeDriverMemory
//
// This function called by DirectDraw when it's running low on memory in
// our heap.  You only need to implement this function if you use the
// DirectDraw 'HeapVidMemAllocAligned' function in your driver, and you
// can boot those allocations out of memory to make room for DirectDraw.
//
// We implement this function in the P2 driver because we have DirectDraw
// entirely manage our off-screen heap, and we use HeapVidMemAllocAligned
// to put GDI device-bitmaps in off-screen memory.  DirectDraw applications
// have a higher priority for getting stuff into video memory, though, and
// so this function is used to boot those GDI surfaces out of memory in
// order to make room for DirectDraw.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdFreeDriverMemory(PDD_FREEDRIVERMEMORYDATA lpFreeDriverMemory)
{
    PDev*   ppdev;

    DBG_DD((6, "DDraw::DdFreeDriverMemory called"));

    ppdev = (PDev*)lpFreeDriverMemory->lpDD->dhpdev;

    lpFreeDriverMemory->ddRVal = DDERR_OUTOFMEMORY;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_DD((MT_LOG_LEVEL, "DdFreeDriverMemory: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT

    //
    // If we successfully freed up some memory, set the return value to
    // 'DD_OK'.  DirectDraw will try again to do its allocation, and
    // will call us again if there's still not enough room.  (It will
    // call us until either there's enough room for its alocation to
    // succeed, or until we return something other than DD_OK.)
    //
    if ( bMoveOldestBMPOut(ppdev) )
    {
        lpFreeDriverMemory->ddRVal = DD_OK;
    }

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (DDHAL_DRIVER_HANDLED);
}// DdFreeDriverMemory()

//-----------------------------------------------------------------------------
//
// BOOL DrvGetDirectDrawInfo
//
// Function called by DirectDraw to returns the capabilities of the graphics
// hardware
//
// Parameters:
//
// dhpdev-------Is a handle to the PDEV returned by the driver's DrvEnablePDEV
//              routine.
// pHalInfo-----Points to a DD_HALINFO structure in which the driver should
//              return the hardware capabilities that it supports.
// pdwNumHeaps--Points to the location in which the driver should return the
//              number of VIDEOMEMORY structures pointed to by pvmList.
// pvmList------Points to an array of VIDEOMEMORY structures in which the
//              driver should return information about each video memory chunk
//              that it controls. The driver should ignore this parameter when
//              it is NULL.
// pdwNumFourCC-Points to the location in which the driver should return the
//              number of DWORDs pointed to by pdwFourCC.
// pdwFourCC----Points to an array of DWORDs in which the driver should return
//              information about each FOURCC that it supports. The driver
//              should ignore this parameter when it is NULL.
//
// Return:
//  Returns TRUE if it succeeds; otherwise, it returns FALSE
//
// Note:
//  This function will be called twice before DrvEnableDirectDraw is called.
//
// Comments
//  The driver's DrvGetDirectDrawInfo routine should do the following:
//  1)When pvmList and pdwFourCC are NULL:
//  Reserve off-screen video memory for DirectDraw use. Write the number of
//  driver video memory heaps and supported FOURCCs in pdwNumHeaps and
//  pdwNumFourCC, respectively.
//
//  2)When pvmList and pdwFourCC are not NULL:
//  Write the number of driver video memory heaps and supported FOURCCs in
//  pdwNumHeaps and pdwNumFourCC, respectively.
//  Get ptr to reserved offscreen mem?
//  For each VIDEOMEMORY structure in the list to which pvmList points, fill in
//  the appropriate members to describe a particular chunk of display memory.
//  The list of structures provides DirectDraw with a complete description of
//  the driver's off-screen memory.
//
//  3)Initialize the members of the DD_HALINFO structure with driver-specific
//  information as follows:
//  Initialize the appropriate members of the VIDEOMEMORYINFO structure to
//  describe the general characteristics of the display's memory.
//  Initialize the appropriate members of the DDNTCORECAPS structure to
//  describe the capabilities of the hardware.
//  If the driver implements a DdGetDriverInfo function, set GetDriverInfo to
//  point to it and set dwFlags to DDHALINFO_GETDRIVERINFOSET
//
//-----------------------------------------------------------------------------

BOOL
DrvGetDirectDrawInfo(DHPDEV         dhpdev,
                     DD_HALINFO*    pHalInfo,
                     DWORD*         pdwNumHeaps,
                     VIDEOMEMORY*   pvmList,     // Will be NULL on first call
                     DWORD*         pdwNumFourCC,
                     DWORD*         pdwFourCC)   // Will be NULL on first call
{
    BOOL            bCanFlip;
    BOOL            bDefineAGPHeap = FALSE,bDefineDDrawHeap = FALSE;
    LONGLONG        li;
    VIDEOMEMORY*    pVm;
    DWORD           cHeaps;
    DWORD           dwRegistryValue;

    DBG_DD((3, "DrvGetDirectDrawInfo Called"));

    PDev *ppdev=(PDev*) dhpdev;


    *pdwNumFourCC = 0;
    *pdwNumHeaps = 0;

    //On the first call, setup the chip info

    if(!(pvmList && pdwFourCC)) {

        //
        // Fill in the DDHAL Informational caps
        //
        GetDDHALInfo(ppdev, pHalInfo);

        //
        // Current primary surface attributes:
        //
        pHalInfo->vmiData.pvPrimary                 = ppdev->pjScreen;
        pHalInfo->vmiData.fpPrimary                 = 0;
        pHalInfo->vmiData.dwDisplayWidth            = ppdev->cxScreen;
        pHalInfo->vmiData.dwDisplayHeight           = ppdev->cyScreen;
        pHalInfo->vmiData.lDisplayPitch             = ppdev->lDelta;
        pHalInfo->vmiData.ddpfDisplay.dwSize        = sizeof(DDPIXELFORMAT);
        pHalInfo->vmiData.ddpfDisplay.dwFlags       = DDPF_RGB;
        pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cjPelSize * 8;

        if ( ppdev->iBitmapFormat == BMF_8BPP ) {
            //
            // Tell DDRAW that the surface is 8-bit color indexed
            //
            pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
        }

        //
        // These masks will be zero at 8bpp:
        //
        pHalInfo->vmiData.ddpfDisplay.dwRBitMask    = ppdev->flRed;
        pHalInfo->vmiData.ddpfDisplay.dwGBitMask    = ppdev->flGreen;
        pHalInfo->vmiData.ddpfDisplay.dwBBitMask    = ppdev->flBlue;

        //
        // We have to tell DirectDraw our preferred off-screen alignment
        //
        pHalInfo->vmiData.dwOffscreenAlign = 4;
        pHalInfo->vmiData.dwZBufferAlign = 4;
        pHalInfo->vmiData.dwTextureAlign = 4;

        pHalInfo->ddCaps.dwVidMemTotal =
            (ppdev->lVidMemHeight - ppdev->cyScreen) * ppdev->lDelta;
    }

    cHeaps = 0;

    //
    // Determine the YUV modes for Video playback acceleration. We can do YUV
    // conversions at any depth except 8 bits...
    //
    if (ppdev->iBitmapFormat != BMF_8BPP) {
        *pdwNumFourCC = sizeof( fourCC ) / sizeof( fourCC[0] );
    }

    if(DD_P2AGPCAPABLE(ppdev)) {
        bDefineAGPHeap = TRUE;
        cHeaps++;
    }

    // Do we have sufficient videomemory to create an off-screen heap for
    // DDraw? Test how much video memory is left after we subtract
    // that which is being used for the screen.

    if ( (ppdev->cxScreen < ppdev->lVidMemWidth)
       ||(ppdev->cyScreen < ppdev->lVidMemHeight))
    {
            bDefineDDrawHeap = TRUE;
            cHeaps++;
    }

    ppdev->cHeaps = cHeaps;
    *pdwNumHeaps  = cHeaps;

    // Define the fourCC's that we support
    if (pdwFourCC) {
        memcpy(pdwFourCC, fourCC, sizeof(fourCC));
    }

    // If pvmList is not NULL then we can go ahead and fill out the VIDEOMEMORY
    // structures which define our requested heaps.

    if(pvmList) {

        pVm=pvmList;

        //
        // Snag a pointer to the video-memory list so that we can use it to
        // call back to DirectDraw to allocate video memory:
        //
        ppdev->pvmList = pVm;

        //
        // Create one heap to describe the unused portion of video memory for
        // DirectDraw use
        //
        // Note: here lVidMemWidth is in "pixel" unit. So we should multiply it
        // by cjPelSize to get actually BYTES of video memory
        //
        // fpStart---Points to the starting address of a memory range in the
        // heap.
        // fpEnd-----Points to the ending address of a memory range if the heap
        // is linear. This address is inclusive, that is, it specifies the last
        // valid address in the range. Thus, the number of bytes specified by
        // fpStart and fpEnd is (fpEnd-fpStart+1).
        //
        // Define the heap for DirectDraw
        //
        if ( bDefineDDrawHeap )
        {
            pVm->dwFlags        = VIDMEM_ISLINEAR ;
            pVm->fpStart        = ppdev->cyScreen * ppdev->lDelta;
            pVm->fpEnd          = ppdev->lVidMemHeight * ppdev->lDelta - 1;

            //
            // DWORD align the size, the hardware should guarantee this
            //
            ASSERTDD(((pVm->fpEnd - pVm->fpStart + 1) & 3) == 0,
                    "The off-screen heap size should be DWORD aligned");

            pVm->ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            DBG_DD((7, "fpStart %ld fpEnd %ld", pVm->fpStart, pVm->fpEnd));
            DBG_DD((7, "DrvGetDirectDrawInfo Creates 1 heap for DDRAW"));

            pVm++;

        }

        //Define the AGP heap
        if(bDefineAGPHeap) {
            DWORD dwAGPMemBytes;
            BOOL bSuccess;

            // Request 32Mb of AGP Memory, DDRAW will allocate less
            // if this amount is not available
            dwAGPMemBytes = P2_AGP_HEAPSIZE*1024*1024;

            DBG_DD((7, "Initialised AGP Heap for P2"));

            // The start address of the heap,
            // just set to zero as DDRAW handles the allocation
            pVm->fpStart = 0;
            // Fetch the last byte of AGP memory
            pVm->fpEnd = dwAGPMemBytes - 1;

            // drivers can set VIDMEM_ISWC here,
            // then memory will be write combined.
            // but memory on AGP buses is always uncached
            pVm->dwFlags = VIDMEM_ISNONLOCAL | VIDMEM_ISLINEAR | VIDMEM_ISWC;

            // Only use AGP memory for textures and OFFSCREENPLAIN
            pVm->ddsCaps.dwCaps =   DDSCAPS_OVERLAY |
                                    DDSCAPS_FRONTBUFFER |
                                    DDSCAPS_BACKBUFFER |
                                    DDSCAPS_ZBUFFER |
                                    DDSCAPS_3DDEVICE
                                    ;

            pVm->ddsCapsAlt.dwCaps =DDSCAPS_OVERLAY |
                                    DDSCAPS_FRONTBUFFER |
                                    DDSCAPS_BACKBUFFER |
                                    DDSCAPS_ZBUFFER |
                                    DDSCAPS_3DDEVICE
                                    ;
            ++pVm;
        }

    }


    DBG_DD((6, "DrvGetDirectDrawInfo return TRUE"));
    return(TRUE);
}// DrvGetDirectDrawInfo()

//-----------------------------------------------------------------------------
//
//  InitDDHAL
//
//  do the final initialisation of the HAL:
//  setup DDraw specific variables for the ppdev and fill in all callbacks
//  for DirectDraw
//
//  No Chip register setup is done here - it is all handled in the mode
//  change code which this function calls
//
//-----------------------------------------------------------------------------

BOOL
InitDDHAL(PPDev ppdev)
{
    PERMEDIA_DEFS(ppdev);

    DBG_DD((1, "DDraw:InitDDHAL*************************************" ));
    DBG_DD((1, "    ScreenStart =%08lx", ppdev->dwScreenStart));
    DBG_DD((1, "    ScreenWidth=%08lx",  ppdev->cxScreen ));
    DBG_DD((1, "    ScreenHeight=%08lx", ppdev->cyScreen));
    DBG_DD((1, "    dwRGBBitCount=%ld", ppdev->ddpfDisplay.dwRGBBitCount ));
    DBG_DD((1, "    RMask:   0x%x", ppdev->ddpfDisplay.dwRBitMask ));
    DBG_DD((1, "    GMask:   0x%x", ppdev->ddpfDisplay.dwGBitMask ));
    DBG_DD((1, "    BMask:   0x%x", ppdev->ddpfDisplay.dwBBitMask ));
    DBG_DD((1, "*****************************************************" ));

    // Fill in the HAL Callback pointers
    memset(&ppdev->DDHALCallbacks, 0, sizeof(DDHAL_DDCALLBACKS));
    ppdev->DDHALCallbacks.dwSize = sizeof(DDHAL_DDCALLBACKS);
    ppdev->DDHALCallbacks.WaitForVerticalBlank = DdWaitForVerticalBlank;
    ppdev->DDHALCallbacks.CanCreateSurface = DdCanCreateSurface;
    ppdev->DDHALCallbacks.GetScanLine = DdGetScanLine;
    ppdev->DDHALCallbacks.MapMemory = DdMapMemory;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->DDHALCallbacks.CreateSurface = MtDdCreateSurface;
#else
//@@END_DDKSPLIT
    ppdev->DDHALCallbacks.CreateSurface = DdCreateSurface;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT

    // Fill in the HAL Callback flags
    ppdev->DDHALCallbacks.dwFlags = DDHAL_CB32_WAITFORVERTICALBLANK |
                                    DDHAL_CB32_MAPMEMORY |
                                    DDHAL_CB32_GETSCANLINE |
                                    DDHAL_CB32_CANCREATESURFACE |
                                    DDHAL_CB32_CREATESURFACE;

    // Fill in the Surface Callback pointers
    memset(&ppdev->DDSurfCallbacks, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    ppdev->DDSurfCallbacks.dwSize = sizeof(DDHAL_DDSURFACECALLBACKS);
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->DDSurfCallbacks.DestroySurface = MtDdDestroySurface;
    ppdev->DDSurfCallbacks.Flip = MtDdFlip;
    ppdev->DDSurfCallbacks.Lock = MtDdLock;
    ppdev->DDSurfCallbacks.GetBltStatus = DdGetBltStatus;       // Internally protected
    ppdev->DDSurfCallbacks.GetFlipStatus = MtDdGetFlipStatus;
    ppdev->DDSurfCallbacks.Blt = MtDdBlt;
#else
//@@END_DDKSPLIT
    ppdev->DDSurfCallbacks.DestroySurface = DdDestroySurface;
    ppdev->DDSurfCallbacks.Flip = DdFlip;
    ppdev->DDSurfCallbacks.Lock = DdLock;
    ppdev->DDSurfCallbacks.GetBltStatus = DdGetBltStatus;
    ppdev->DDSurfCallbacks.GetFlipStatus = DdGetFlipStatus;
    ppdev->DDSurfCallbacks.Blt = DdBlt;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT

    ppdev->DDSurfCallbacks.dwFlags =    DDHAL_SURFCB32_DESTROYSURFACE |
                                        DDHAL_SURFCB32_FLIP     |
                                        DDHAL_SURFCB32_LOCK     |
                                        DDHAL_SURFCB32_BLT |
                                        DDHAL_SURFCB32_GETBLTSTATUS |
                                        DDHAL_SURFCB32_GETFLIPSTATUS;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->DDSurfCallbacks.SetColorKey = MtDdSetColorKey;
#else
//@@END_DDKSPLIT
    ppdev->DDSurfCallbacks.SetColorKey = DdSetColorKey;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT
    ppdev->DDSurfCallbacks.dwFlags |= DDHAL_SURFCB32_SETCOLORKEY;

    // Fill in the DDHAL Informational caps
    GetDDHALInfo(ppdev, &ppdev->ddhi32);

    return (TRUE);

}// InitDDHAL()

//-----------------------------------------------------------------------------
//
//  bIsStereoMode
//
//  Decide if mode can be displayed as stereo mode. Here we limit stereo
//  modes so that two front and two backbuffers can be created for rendering.
//
//-----------------------------------------------------------------------------

BOOL bIsStereoMode(PDev *ppdev, PDD_STEREOMODE pDDStereoMode)
{
    pDDStereoMode->bSupported = FALSE;

    // we need to check dwBpp for a valid value as PDD_STEREOMODE.dwBpp is a
    // parameter passed on from the user mode API call

    if ((pDDStereoMode->dwWidth >= 320) &&
        (pDDStereoMode->dwHeight >= 240) &&
        (pDDStereoMode->dwBpp >=  8) &&
        (pDDStereoMode->dwBpp <= 32)
       )
    {
        DWORD dwLines=ppdev->FrameBufferLength/
            (pDDStereoMode->dwWidth*pDDStereoMode->dwBpp/8);
        if (dwLines > (pDDStereoMode->dwHeight*4))
        {
            pDDStereoMode->bSupported = TRUE;
        }
    }

    return pDDStereoMode->bSupported;
}

//-----------------------------------------------------------------------------
//
// DdGetDriverInfo
//
// callback for various new HAL features, post DX3.
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
{
    PPDev ppdev=(PPDev)lpData->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD dwSize;

    DBG_DD(( 2, "DDraw:GetDriverInfo"));

    // Get a pointer to the chip we are on.


    // Default to 'not supported'
    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;
    ppdev = (PDev*) lpData->dhpdev;

    // fill in supported stuff
    if (IsEqualIID(&lpData->guidInfo, &GUID_D3DCallbacks3))
    {
        D3DHAL_CALLBACKS3 D3DCB3;
        DBG_DD((3,"  GUID_D3DCallbacks3"));

        memset(&D3DCB3, 0, sizeof(D3DHAL_CALLBACKS3));
        D3DCB3.dwSize = sizeof(D3DHAL_CALLBACKS3);
        D3DCB3.lpvReserved = NULL;
        D3DCB3.ValidateTextureStageState = D3DValidateTextureStageState;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
        D3DCB3.DrawPrimitives2 = MtD3DDrawPrimitives2;
#else
//@@END_DDKSPLIT
        D3DCB3.DrawPrimitives2 = D3DDrawPrimitives2;
//@@BEGIN_DDKSPLIT
#endif MULTITHREADED
//@@END_DDKSPLIT
        D3DCB3.dwFlags |=   D3DHAL3_CB32_DRAWPRIMITIVES2           |
                            D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE |
                            0;

        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        dwSize=min(lpData->dwExpectedSize,sizeof(D3DHAL_CALLBACKS3));
        memcpy(lpData->lpvData, &D3DCB3, dwSize);
        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&lpData->guidInfo, &GUID_D3DExtendedCaps))
    {
        D3DNTHAL_D3DEXTENDEDCAPS D3DExtendedCaps;
        DBG_DD((3,"  GUID_D3DExtendedCaps"));

        memset(&D3DExtendedCaps, 0, sizeof(D3DExtendedCaps));
        dwSize=min(lpData->dwExpectedSize, sizeof(D3DExtendedCaps));

        lpData->dwActualSize = dwSize;
        D3DExtendedCaps.dwSize = dwSize;

        // number of (multi)textures we support simultaneusly for DX6
        D3DExtendedCaps.dwFVFCaps = 1;

        D3DExtendedCaps.dwMinTextureWidth  = 1;
        D3DExtendedCaps.dwMinTextureHeight = 1;
        D3DExtendedCaps.dwMaxTextureWidth  = 2048;
        D3DExtendedCaps.dwMaxTextureHeight = 2048;

        D3DExtendedCaps.dwMinStippleWidth = 8;
        D3DExtendedCaps.dwMaxStippleWidth = 8;
        D3DExtendedCaps.dwMinStippleHeight = 8;
        D3DExtendedCaps.dwMaxStippleHeight = 8;

        D3DExtendedCaps.dwTextureOpCaps =
            D3DTEXOPCAPS_DISABLE                   |
            D3DTEXOPCAPS_SELECTARG1                |
            D3DTEXOPCAPS_SELECTARG2                |
            D3DTEXOPCAPS_MODULATE                  |
            D3DTEXOPCAPS_ADD                       |
            D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
            0;

        D3DExtendedCaps.wMaxTextureBlendStages = 1;
        D3DExtendedCaps.wMaxSimultaneousTextures = 1;

        // Full range of the integer (non-fractional) bits of the
        // post-normalized texture indices. If the
        // D3DDEVCAPS_TEXREPEATNOTSCALEDBYSIZE bit is set, the
        // device defers scaling by the texture size until after
        // the texture address mode is applied. If it isn't set,
        // the device scales the texture indices by the texture size
        // (largest level-of-detail) prior to interpolation.
        D3DExtendedCaps.dwMaxTextureRepeat = 2048;

        // In order to support stencil buffers in DX6 we need besides
        // setting these caps and handling the proper renderstates to
        // declare the appropriate z buffer pixel formats here in
        // response to the GUID_ZPixelFormats and implement the
        // Clear2 callback. Also , we need to be able to create the
        // appropriate ddraw surfaces.
#if D3D_STENCIL
        D3DExtendedCaps.dwStencilCaps =  0                      |
                                        D3DSTENCILCAPS_KEEP     |
                                        D3DSTENCILCAPS_ZERO     |
                                        D3DSTENCILCAPS_REPLACE  |
                                        D3DSTENCILCAPS_INCRSAT  |
                                        D3DSTENCILCAPS_DECRSAT  |
                                        D3DSTENCILCAPS_INVERT;
#endif

#if D3DDX7_TL
        // In order to use hw accelerated T&L we must declare
        // how many simultaneously active lights we can handle.
        D3DExtendedCaps.dwMaxActiveLights = 0;
#endif //D3DDX7_TL

//@@BEGIN_DDKSPLIT
#if D3D_POINTSPRITES
        // Parameter for point sprites
        D3DExtendedCaps.dvMaxPointSize = 10.0;
#endif // D3D_POINTSPRITES
//@@END_DDKSPLIT

        memcpy(lpData->lpvData, &D3DExtendedCaps, dwSize);
        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&lpData->guidInfo, &GUID_ZPixelFormats))
    {
        DDPIXELFORMAT ddZBufPixelFormat[2];
        DWORD         dwNumZPixelFormats;

        DBG_DD((3,"  GUID_ZPixelFormats"));


        memset(&ddZBufPixelFormat, 0, sizeof(ddZBufPixelFormat));

#if D3D_STENCIL
        dwSize = (DWORD)min(lpData->dwExpectedSize, 2*sizeof(DDPIXELFORMAT));
        lpData->dwActualSize = 2*sizeof(DDPIXELFORMAT) + sizeof(DWORD);
#else
        dwSize = (DWORD)min(lpData->dwExpectedSize, 1*sizeof(DDPIXELFORMAT));
        lpData->dwActualSize = 1*sizeof(DDPIXELFORMAT) + sizeof(DWORD);
#endif

        // If we didn't support stencils, we would only fill one 16-bit
        // Z Buffer format since that is all what the Permedia supports.
        // Drivers that implement stencil buffer support (like this one)
        // have to report here all Z Buffer formats supported since they
        // have to support the Clear2 callback (or the D3DDP2OP_CLEAR
        // token)

#if D3D_STENCIL
        dwNumZPixelFormats = 2;
#else
        dwNumZPixelFormats = 1;
#endif

        ddZBufPixelFormat[0].dwSize = sizeof(DDPIXELFORMAT);
        ddZBufPixelFormat[0].dwFlags = DDPF_ZBUFFER;
        ddZBufPixelFormat[0].dwFourCC = 0;
        ddZBufPixelFormat[0].dwZBufferBitDepth = 16;
        ddZBufPixelFormat[0].dwStencilBitDepth = 0;
        ddZBufPixelFormat[0].dwZBitMask = 0xFFFF;
        ddZBufPixelFormat[0].dwStencilBitMask = 0x0000;
        ddZBufPixelFormat[0].dwRGBZBitMask = 0;

#if D3D_STENCIL
        ddZBufPixelFormat[1].dwSize = sizeof(DDPIXELFORMAT);
        ddZBufPixelFormat[1].dwFlags = DDPF_ZBUFFER | DDPF_STENCILBUFFER;
        ddZBufPixelFormat[1].dwFourCC = 0;
        // The sum of the z buffer bit depth AND the stencil depth
        // should be included here
        ddZBufPixelFormat[1].dwZBufferBitDepth = 16;
        ddZBufPixelFormat[1].dwStencilBitDepth = 1;
        ddZBufPixelFormat[1].dwZBitMask = 0x7FFF;
        ddZBufPixelFormat[1].dwStencilBitMask = 0x8000;
        ddZBufPixelFormat[1].dwRGBZBitMask = 0;
#endif

        memcpy(lpData->lpvData, &dwNumZPixelFormats, sizeof(DWORD));
        memcpy((LPVOID)((LPBYTE)(lpData->lpvData) + sizeof(DWORD)),
                        &ddZBufPixelFormat, dwSize);

        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo),
                &GUID_D3DParseUnknownCommandCallback))
    {
        DBG_DD((3,"  GUID_D3DParseUnknownCommandCallback"));
        ppdev->pD3DParseUnknownCommand =
            (PFND3DNTPARSEUNKNOWNCOMMAND)(lpData->lpvData);
        lpData->ddRVal = DD_OK;
    }
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_DDMoreCaps))
    {
        DD_MORECAPS DDMoreCaps;

        DBG_DD((3,"  GUID_DDMoreCaps"));

        // here we set all the caps for the new
        // DirectDraw 7 AlphaBlt callback

        memset(&DDMoreCaps, 0, sizeof(DD_MORECAPS));

        DDMoreCaps.dwSize=sizeof(DD_MORECAPS);

        // alpha caps for Vmem->Vmem blts
        // claim to do lots of stuff, we can still fail in callback
        DDMoreCaps.dwAlphaCaps    = DDALPHACAPS_BLTALPHAPIXELS |
                                    DDALPHACAPS_BLTSATURATE |
                                    DDALPHACAPS_BLTPREMULT  |
                                    DDALPHACAPS_BLTNONPREMULT |
                                    DDALPHACAPS_BLTALPHAFILL |
                                    DDALPHACAPS_BLTARGBSCALE1F |
                                    DDALPHACAPS_BLTARGBSCALE2F |
                                    DDALPHACAPS_BLTARGBSCALE4F |
                                    DDALPHACAPS_BLTALPHAANDARGBSCALING;

        DDMoreCaps.dwSVBAlphaCaps = 0;
        // alpha capabilities for System->Vmem blts
        DDMoreCaps.dwVSBAlphaCaps = 0;
        // alpha capabilities for Vmem->System blts
        DDMoreCaps.dwSSBAlphaCaps = 0;
        // alpha capabilities for System->System blts

        // filter caps for Vmem->Vmem blts
        DDMoreCaps.dwFilterCaps   = DDFILTCAPS_BLTQUALITYFILTER |
                                    DDFILTCAPS_BLTCANDISABLEFILTER;

        DDMoreCaps.dwSVBFilterCaps= 0;
        // filter capabilities for System->Vmem blts
        DDMoreCaps.dwVSBFilterCaps= 0;
        // filter capabilities for Vmem->System blts
        DDMoreCaps.dwSSBFilterCaps= 0;
        // filter capabilities for System->System blts

        lpData->dwActualSize = sizeof(DDMoreCaps);
        dwSize=min( sizeof(DDMoreCaps), lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDMoreCaps, dwSize);
        lpData->ddRVal = DD_OK;
    }
#endif
//@@END_DDKSPLIT
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_Miscellaneous2Callbacks) )
    {
        BOOL bRet;
        DWORD dwResult;

        DDHAL_DDMISCELLANEOUS2CALLBACKS MISC2_CB;

        DBG_DD((3,"  GUID_Miscellaneous2Callbacks2"));

        memset(&MISC2_CB, 0, sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS));
        MISC2_CB.dwSize = sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS);

        MISC2_CB.dwFlags  = 0
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
            | DDHAL_MISC2CB32_ALPHABLT
#endif
//@@END_DDKSPLIT
            | DDHAL_MISC2CB32_CREATESURFACEEX
            | DDHAL_MISC2CB32_GETDRIVERSTATE
            | DDHAL_MISC2CB32_DESTROYDDLOCAL;

        MISC2_CB.GetDriverState = D3DGetDriverState;
        MISC2_CB.CreateSurfaceEx = D3DCreateSurfaceEx;
        MISC2_CB.DestroyDDLocal = D3DDestroyDDLocal;

//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
        MISC2_CB.AlphaBlt = DdAlphaBlt;
#endif
//@@END_DDKSPLIT
        lpData->dwActualSize = sizeof(MISC2_CB);
        dwSize = min(sizeof(MISC2_CB),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &MISC2_CB, dwSize);
        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_UpdateNonLocalHeap))
    {
        LPDDHAL_UPDATENONLOCALHEAPDATA pDDNonLocalHeap;

        DBG_DD((3,"  GUID_UpdateNonLocalHeap"));

        pDDNonLocalHeap = (LPDDHAL_UPDATENONLOCALHEAPDATA)lpData->lpvData;

        ppdev->dwGARTLinBase = pDDNonLocalHeap->fpGARTLin;
        ppdev->dwGARTDevBase = pDDNonLocalHeap->fpGARTDev;

        // These values are used to specify the base address of the
        // visible 8Mb window of AGP memory

        ppdev->dwGARTLin = pDDNonLocalHeap->fpGARTLin;
        ppdev->dwGARTDev = pDDNonLocalHeap->fpGARTDev;

        DDCONTEXT;
        SYNC_WITH_PERMEDIA;

        LD_PERMEDIA_REG (PREG_AGPTEXBASEADDRESS,(ULONG)ppdev->dwGARTDev);

        DBG_DD((3,"GartLin: 0x%x, GartDev: 0x%x",
            (ULONG)ppdev->dwGARTLin, ppdev->dwGARTDev));

        lpData->ddRVal = DD_OK;

    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_GetHeapAlignment) )
    {

        LPDDHAL_GETHEAPALIGNMENTDATA lpFData=
            (LPDDHAL_GETHEAPALIGNMENTDATA) lpData->lpvData;

        DBG_DD((3,"  GUID_GetHeapAlignment"));

        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_NTPrivateDriverCaps) )
    {
        DD_NTPRIVATEDRIVERCAPS DDPrivateDriverCaps;

        DBG_DD((3,"  GUID_NTPrivateDriverCaps"));

        memset(&DDPrivateDriverCaps, 0, sizeof(DDPrivateDriverCaps));
        DDPrivateDriverCaps.dwSize=sizeof(DDPrivateDriverCaps);

        // we want the kernel to call us when a primary surface is created
        // so that we can store some private information in the
        // lpGbl->dwReserved1 field
        DDPrivateDriverCaps.dwPrivateCaps=DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION;

        lpData->dwActualSize =sizeof(DDPrivateDriverCaps);

        dwSize = min(sizeof(DDPrivateDriverCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDPrivateDriverCaps, dwSize);
        lpData->ddRVal = DD_OK;
    }
#if DX7_STEREO
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_DDMoreSurfaceCaps) )
    {
        DD_MORESURFACECAPS DDMoreSurfaceCaps;
        DDSCAPSEX   ddsCapsEx, ddsCapsExAlt;
        ULONG ulCopyPointer;

        DBG_DD((3,"  GUID_DDMoreSurfaceCaps"));

        // fill in everything until expectedsize...
        memset(&DDMoreSurfaceCaps, 0, sizeof(DDMoreSurfaceCaps));

        // Caps for heaps 2..n
        memset(&ddsCapsEx, 0, sizeof(ddsCapsEx));
        memset(&ddsCapsExAlt, 0, sizeof(ddsCapsEx));

        DDMoreSurfaceCaps.dwSize=lpData->dwExpectedSize;

        DBG_DD((3,"  stereo support: %ld", ppdev->bCanDoStereo));
        if (ppdev->bCanDoStereo)
        {
            DDMoreSurfaceCaps.ddsCapsMore.dwCaps2 =
                DDSCAPS2_STEREOSURFACELEFT;
        }
        lpData->dwActualSize = lpData->dwExpectedSize;

        dwSize = min(sizeof(DDMoreSurfaceCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDMoreSurfaceCaps, dwSize);

        // now fill in other heaps...
        while (dwSize < lpData->dwExpectedSize)
        {
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsEx,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsExAlt,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
        }

        lpData->ddRVal = DD_OK;
    }
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_DDStereoMode) ) {
        PDD_STEREOMODE pDDStereoMode;

        // Permedia supports all modes as stereo modes.
        // for test purposes, we restrict them to something
        // larger than 320x240

        //
        // note: this GUID_DDStereoMode is only used on NT to
        // report stereo modes. There is no need to implement
        // it in win9x drivers. Win9x drivers report stereo
        // modes by setting the DDMODEINFO_STEREO bit in the
        // dwFlags member of the DDHALMODEINFO structure.
        // It is also recommended to report DDMODEINFO_MAXREFRESH
        // for stereo modes when running under a runtime >= DX7 to
        // allow applications to select higher refresh rates for
        // stereo modes.
        //

        if (lpData->dwExpectedSize >= sizeof(PDD_STEREOMODE))
        {
            pDDStereoMode = (PDD_STEREOMODE) lpData->lpvData;

            bIsStereoMode( ppdev, pDDStereoMode);

            DBG_DD((3,"  GUID_DDStereoMode(%d,%d,%d,%d=%d)",
                pDDStereoMode->dwWidth,
                pDDStereoMode->dwHeight,
                pDDStereoMode->dwBpp,
                pDDStereoMode->dwRefreshRate,
                pDDStereoMode->bSupported));

            lpData->dwActualSize = sizeof(DD_STEREOMODE);
            lpData->ddRVal = DD_OK;
        }
    }
#endif
    else if (IsEqualIID(&(lpData->guidInfo), &GUID_NonLocalVidMemCaps) )
    {
        DD_NONLOCALVIDMEMCAPS DDNonLocalVidMemCaps;

        DBG_DD((3,"  GUID_DDNonLocalVidMemCaps"));

        memset(&DDNonLocalVidMemCaps, 0, sizeof(DDNonLocalVidMemCaps));
        DDNonLocalVidMemCaps.dwSize=sizeof(DDNonLocalVidMemCaps);

        //fill in all supported nonlocal to videomemory blts
        //
        DDNonLocalVidMemCaps.dwNLVBCaps = DDCAPS_BLT |
                                          DDCAPS_BLTSTRETCH |
                                          DDCAPS_BLTQUEUE |
                                          DDCAPS_COLORKEY |
                                          DDCAPS_ALPHA |
                                          DDCAPS_CANBLTSYSMEM;

        DDNonLocalVidMemCaps.dwNLVBCaps2 = 0;

        DDNonLocalVidMemCaps.dwNLVBCKeyCaps=DDCKEYCAPS_SRCBLT |
                                            DDCKEYCAPS_SRCBLTCLRSPACE;


        DDNonLocalVidMemCaps.dwNLVBFXCaps = DDFXCAPS_BLTALPHA |
                                            DDFXCAPS_BLTFILTER |
                                            DDFXCAPS_BLTSTRETCHY |
                                            DDFXCAPS_BLTSTRETCHX |
                                            DDFXCAPS_BLTSTRETCHYN |
                                            DDFXCAPS_BLTSTRETCHXN |
                                            DDFXCAPS_BLTSHRINKY |
                                            DDFXCAPS_BLTSHRINKX |
                                            DDFXCAPS_BLTSHRINKYN |
                                            DDFXCAPS_BLTSHRINKXN |
                                            DDFXCAPS_BLTMIRRORUPDOWN |
                                            DDFXCAPS_BLTMIRRORLEFTRIGHT;

        if (ppdev->iBitmapFormat != BMF_8BPP)
        {
            DDNonLocalVidMemCaps.dwNLVBCaps |= DDCAPS_BLTFOURCC;
            DDNonLocalVidMemCaps.dwNLVBCKeyCaps|=DDCKEYCAPS_SRCBLTCLRSPACEYUV;
        }

        for(INT i = 0; i < DD_ROP_SPACE; i++ )
            DDNonLocalVidMemCaps.dwNLVBRops[i] = rops[i];

        lpData->dwActualSize =sizeof(DDNonLocalVidMemCaps);

        dwSize = min(sizeof(DDNonLocalVidMemCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDNonLocalVidMemCaps, dwSize);
        lpData->ddRVal = DD_OK;
    } else if (IsEqualIID(&lpData->guidInfo, &GUID_NTCallbacks))
    {
        DD_NTCALLBACKS NtCallbacks;

        memset(&NtCallbacks, 0, sizeof(NtCallbacks));

        dwSize = min(lpData->dwExpectedSize, sizeof(DD_NTCALLBACKS));

        NtCallbacks.dwSize           = dwSize;
        NtCallbacks.dwFlags          =   DDHAL_NTCB32_FREEDRIVERMEMORY
                                       | DDHAL_NTCB32_SETEXCLUSIVEMODE
                                       | DDHAL_NTCB32_FLIPTOGDISURFACE
                                       ;
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
        NtCallbacks.FreeDriverMemory = DdFreeDriverMemory;      // Internally protected
        NtCallbacks.SetExclusiveMode = MtDdSetExclusiveMode;
        NtCallbacks.FlipToGDISurface = MtDdFlipToGDISurface;
#else
//@@END_DDKSPLIT
        NtCallbacks.FreeDriverMemory = DdFreeDriverMemory;
        NtCallbacks.SetExclusiveMode = DdSetExclusiveMode;
        NtCallbacks.FlipToGDISurface = DdFlipToGDISurface;
//@@BEGIN_DDKSPLIT
#endif  MULTITHREADED
//@@END_DDKSPLIT

        memcpy(lpData->lpvData, &NtCallbacks, dwSize);

        lpData->ddRVal = DD_OK;
    }

    // We always handled it.
    return DDHAL_DRIVER_HANDLED;

}   // GetDriverInfo


//-----------------------------------------------------------------------------
//
//  updateFlipStatus
//
//  return DD_OK when last flip has occured.
//
//-----------------------------------------------------------------------------

HRESULT
updateFlipStatus( PPDev ppdev )
{
    PERMEDIA_DEFS(ppdev);
    DBG_DD((6, "DDraw:updateFlipStatus"));

    // we assume that we are already in the DDraw/D3D context.

    // read Permedia register which tells us if there is a flip pending
    if (ppdev->dwNewDDSurfaceOffset!=0xffffffff)
    {
        ULONG ulScreenBase=READ_PERMEDIA_REG(PREG_SCREENBASE);

        if (ulScreenBase!=
            ppdev->dwNewDDSurfaceOffset)
        {

            DBG_DD((7,"  SurfaceOffset %08lx instead of %08lx",
                ulScreenBase,
                ppdev->dwNewDDSurfaceOffset));

            //
            //  make sure all pending data was flushed!
            //
            FLUSHDMA();

            //
            // if we are busy, return
            // otherwise the pipeline is empty and we can
            // fall through and to check if the chip already flipped.
            //
            if (DRAW_ENGINE_BUSY)
                return DDERR_WASSTILLDRAWING;

        }
    }

    DWORD dwVideoControl=READ_PERMEDIA_REG(PREG_VIDEOCONTROL);

    if (dwVideoControl & PREG_VC_SCREENBASEPENDING)
    {
        DBG_DD((7,"  VideoControl still pending (%08lx)",dwVideoControl));
        return DDERR_WASSTILLDRAWING;
    }

    return DD_OK;

} // updateFlipStatus




//@@BEGIN_DDKSPLIT
#if MULTITHREADED

//-----------------------------------------------------------------------------
//
// Multithread support wrappers for Dx callback functions
//
//-----------------------------------------------------------------------------

//DWORD CALLBACK MtDdBlt( LPDDHAL_BLTDATA lpBlt );
WRAPMTDXCALLBACK(DD, DdBlt, LPDDHAL_BLTDATA, lpBlt,
                 lpBlt->lpDD->dhpdev);

//DWORD CALLBACK MtDdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd);
WRAPMTDXCALLBACK(DD, DdCreateSurface, LPDDHAL_CREATESURFACEDATA, pcsd,
                 pcsd->lpDD->dhpdev);

//DWORD CALLBACK MtDdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd);
WRAPMTDXCALLBACK(DD, DdDestroySurface, LPDDHAL_DESTROYSURFACEDATA, psdd,
                 psdd->lpDD->dhpdev);

//DWORD CALLBACK MtDdFlip( LPDDHAL_FLIPDATA lpFlipData);
WRAPMTDXCALLBACK(DD, DdFlip, LPDDHAL_FLIPDATA, lpFlipData,
                 lpFlipData->lpDD->dhpdev);

//DWORD CALLBACK MtDdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface);
WRAPMTDXCALLBACK(DD, DdFlipToGDISurface, PDD_FLIPTOGDISURFACEDATA, lpFlipToGDISurface,
                 lpFlipToGDISurface->lpDD->dhpdev);

//DWORD CALLBACK MtDdGetFlipStatus(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus);
WRAPMTDXCALLBACK(DD, DdGetFlipStatus, LPDDHAL_GETFLIPSTATUSDATA, lpGetFlipStatus,
                 lpGetFlipStatus->lpDD->dhpdev);

//DWORD CALLBACK MtDdLock( LPDDHAL_LOCKDATA lpLockData );
WRAPMTDXCALLBACK(DD, DdLock, LPDDHAL_LOCKDATA, lpLockData,
                 lpLockData->lpDD->dhpdev);

//DWORD CALLBACK MtDdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);
WRAPMTDXCALLBACK(DD, DdSetExclusiveMode, PDD_SETEXCLUSIVEMODEDATA, lpSetExclusiveMode,
                 lpSetExclusiveMode->lpDD->dhpdev);

#endif  MULTITHREADED
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dd.h ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dd.h
*
* Content:     definitions and macros for DirectDraw
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/   

#ifndef _DD_H_
#define _DD_H_

extern DWORD ShiftLookup[];

// DirectDraw Macros for determining surface characteristics
#define DDSurf_Width(lpLcl) ( lpLcl->lpGbl->wWidth )
#define DDSurf_Height(lpLcl) ( lpLcl->lpGbl->wHeight )
#define DDSurf_Pitch(lpLcl) (lpLcl->lpGbl->lPitch)
#define DDSurf_Get_dwCaps(lpLcl) (lpLcl->ddsCaps.dwCaps)
#define DDSurf_BitDepth(lpLcl) (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount)
#define DDSurf_AlphaBitDepth(lpLcl) (lpLcl->lpGbl->ddpfSurface.dwAlphaBitDepth)
#define DDSurf_RGBAlphaBitMask(lpLcl) \
            (lpLcl->lpGbl->ddpfSurface.dwRGBAlphaBitMask)
#define DDSurf_GetPixelShift(a) (ShiftLookup[(DDSurf_BitDepth(a) >> 3)])

//
// DirectDraw callback functions implemented in this driver
//
DWORD CALLBACK DdCanCreateSurface( LPDDHAL_CANCREATESURFACEDATA pccsd );
DWORD CALLBACK DdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd );
DWORD CALLBACK DdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd );
DWORD CALLBACK DdBlt( LPDDHAL_BLTDATA lpBlt );
//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
DWORD CALLBACK DdAlphaBlt( LPDDHAL_BLTDATA lpBlt );
#endif
//@@END_DDKSPLIT
DWORD CALLBACK DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);
DWORD CALLBACK DdMapMemory(PDD_MAPMEMORYDATA lpMapMemory);



//
// here are various blitter functions
//
VOID 
PermediaPackedCopyBlt (PPDev, 
                       DWORD, 
                       DWORD, 
                       PermediaSurfaceData*, 
                       PermediaSurfaceData*, 
                       RECTL*, 
                       RECTL*, 
                       DWORD, 
                       LONG);

VOID 
PermediaPatchedCopyBlt(PPDev, 
                       DWORD, 
                       DWORD, 
                       PermediaSurfaceData*, 
                       PermediaSurfaceData*, 
                       RECTL*, 
                       RECTL*, 
                       DWORD, 
                       LONG);

//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
VOID
PermediaSourceAlphaBlt(PPDev ppdev, 
                       LPDDHAL_BLTDATA lpBlt, 
                       PermediaSurfaceData* pDest, 
                       PermediaSurfaceData* pSource, 
                       RECTL *rDest, 
                       RECTL *rSrc, 
                       DWORD windowBase, 
                       DWORD SourceOffset,
                       ULONG ulDestPixelShift);

VOID
PermediaAlphaFill(PPDev ppdev, 
                  LPDDHAL_BLTDATA lpBlt, 
                  PermediaSurfaceData* pDest, 
                  RECTL *rDest, 
                  DWORD dwWindowBase, 
                  ULONG ulDestPixelShift);
#endif
//@@END_DDKSPLIT

// Clear functions
VOID PermediaFastClear(PPDev, PermediaSurfaceData*, 
                       RECTL*, DWORD, DWORD);
VOID PermediaClearManagedSurface(DWORD,RECTL*, 
                  FLATPTR,LONG,DWORD);
VOID PermediaFastLBClear(PPDev, PermediaSurfaceData*, 
                         RECTL*, DWORD, DWORD);

// FX Blits
VOID PermediaStretchCopyBlt(PPDev, LPDDHAL_BLTDATA, PermediaSurfaceData*, 
                            PermediaSurfaceData*, RECTL *, RECTL *, DWORD, 
                            DWORD);
VOID PermediaStretchCopyChromaBlt(PPDev, LPDDHAL_BLTDATA, PermediaSurfaceData*, 
                                  PermediaSurfaceData*, RECTL *, RECTL *,
                                  DWORD, DWORD);
VOID PermediaSourceChromaBlt(PPDev, LPDDHAL_BLTDATA, PermediaSurfaceData*, 
                             PermediaSurfaceData*, RECTL*, RECTL*, 
                             DWORD, DWORD);
VOID PermediaYUVtoRGB(PPDev, DDBLTFX*, PermediaSurfaceData*, 
                      PermediaSurfaceData*, RECTL*, RECTL*, DWORD, DWORD);

// SYSMEM->VIDMEM Blits
VOID PermediaPackedDownload(PPDev, PermediaSurfaceData* pPrivateData, 
                            LPDDRAWI_DDRAWSURFACE_LCL lpSourceSurf, 
                            RECTL* rSrc, 
                            LPDDRAWI_DDRAWSURFACE_LCL lpDestSurf, 
                            RECTL* rDest);

// Texture Downloads
VOID PermediaPatchedTextureDownload(PPDev, PermediaSurfaceData*,FLATPTR,
                                    LONG,RECTL*,FLATPTR,LONG,RECTL*);

// DX Utility functions.
//
HRESULT updateFlipStatus( PPDev ppdev );

// Sysmem->Sysmem Blit
VOID SysMemToSysMemSurfaceCopy(FLATPTR,LONG,DWORD,FLATPTR,
                               LONG,DWORD,RECTL*,RECTL*);

//
//  function to validate RGB format of a DirectDraw surface
//
BOOL ValidRGBAlphaSurfaceformat(DDPIXELFORMAT *pPixFormat, INT *pIndex);
BOOL SetRGBAlphaSurfaceFormat  (DDPIXELFORMAT *pPixFormat, 
                                PERMEDIA_SURFACE *pSurfaceFormat);
//
// Initialise DirectDraw structs
//

BOOL InitDDHAL(PPDev ppdev);

//
//  setup some DDraw data stored in ppdev
//
VOID SetupDDData(PPDev ppdev);
BOOL bIsStereoMode(PPDev ppdev,PDD_STEREOMODE pDDStereoMode);

// Useful macro
#define ROUND_UP_TO_64K(x)  (((ULONG)(x) + 0x10000 - 1) & ~(0x10000 - 1))

// DD Blit helper defines.
#define PIXELS_INTO_RECT_PACKED(rect, PixelPitch, lPixelMask) \
((rect->top * PixelPitch) + \
(rect->left & ~lPixelMask))

#define RECTS_PIXEL_OFFSET(rS,rD,SourcePitch,DestPitch,Mask) \
(PIXELS_INTO_RECT_PACKED(rS, SourcePitch, Mask) - \
 PIXELS_INTO_RECT_PACKED(rD, DestPitch, Mask) )

#define LINEAR_FUDGE(SourcePitch, DestPitch, rectDest) \
((DestPitch - SourcePitch) * (rectDest->top))

//
//  check if privateData for primary surface was properly
//  initialized
//
#define DD_CHECK_PRIMARY_SURFACE_DATA( pLcl, pPrivate) \
    if ((pLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) ||\
        (pLcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER))\
    {\
        if (!CHECK_P2_SURFACEDATA_VALIDITY(pPrivate))\
        {\
            ASSERTDD(FALSE, "primary surface data not initialized");\
            /*SetupPrimarySurfaceData(ppdev, pLcl);*/\
            pPrivate = (PermediaSurfaceData*)pLcl->lpGbl->dwReserved1;\
        }\
    }\



//@@BEGIN_DDKSPLIT
#if MULTITHREADED
//
// Multithread wrapped DirectDraw callback functions implemented in this driver
//
DWORD CALLBACK MtDdBlt(LPDDHAL_BLTDATA lpBlt);
DWORD CALLBACK MtDdCreateSurface( LPDDHAL_CREATESURFACEDATA pcsd);
DWORD CALLBACK MtDdDestroySurface( LPDDHAL_DESTROYSURFACEDATA psdd);
DWORD CALLBACK MtDdFlip(LPDDHAL_FLIPDATA lpFlipData);
DWORD CALLBACK MtDdFlipToGDISurface(PDD_FLIPTOGDISURFACEDATA lpFlipToGDISurface);
DWORD CALLBACK MtDdGetFlipStatus(LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus);
DWORD CALLBACK MtDdLock(LPDDHAL_LOCKDATA lpLockData);
DWORD CALLBACK MtDdSetExclusiveMode(PDD_SETEXCLUSIVEMODEDATA lpSetExclusiveMode);

//
// Multithread wrapped Direct3D callback functions implemented in this driver
//
DWORD CALLBACK MtD3DDrawPrimitives2(LPD3DNTHAL_DRAWPRIMITIVES2DATA);
DWORD CALLBACK MtDdSetColorKey(LPDDHAL_SETCOLORKEYDATA lpSetColorKey);

#endif  MULTITHREADED
//@@END_DDKSPLIT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\dddebug.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dddebug.c
*
* Content:     some DDraw and D3D debug output functions
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include <windef.h>
#include <limits.h>
#include <stdio.h>
#include <stdarg.h>

#if (DBG)

//-----------------------------------------------------------------------------
//
//  DecodeBlend
//
//  produce debug output for D3D blend modes
//
//-----------------------------------------------------------------------------

VOID 
DecodeBlend( LONG Level, DWORD i )
{
    switch ((D3DBLEND)i)
    {
    case D3DBLEND_ZERO:
        DISPDBG((Level, "  ZERO"));
        break;
    case D3DBLEND_ONE:
        DISPDBG((Level, "  ONE"));
        break;
    case D3DBLEND_SRCCOLOR:
        DISPDBG((Level, "  SRCCOLOR"));
        break;
    case D3DBLEND_INVSRCCOLOR:
        DISPDBG((Level, "  INVSRCCOLOR"));
        break;
    case D3DBLEND_SRCALPHA:
        DISPDBG((Level, "  SRCALPHA"));
        break;
    case D3DBLEND_INVSRCALPHA:
        DISPDBG((Level, "  INVSRCALPHA"));
        break;
    case D3DBLEND_DESTALPHA:
        DISPDBG((Level, "  DESTALPHA"));
        break;
    case D3DBLEND_INVDESTALPHA:
        DISPDBG((Level, "  INVDESTALPHA"));
        break;
    case D3DBLEND_DESTCOLOR:
        DISPDBG((Level, "  DESTCOLOR"));
        break;
    case D3DBLEND_INVDESTCOLOR:
        DISPDBG((Level, "  INVDESTCOLOR"));
        break;
    case D3DBLEND_SRCALPHASAT:
        DISPDBG((Level, "  SRCALPHASAT"));
        break;
    case D3DBLEND_BOTHSRCALPHA:
        DISPDBG((Level, "  BOTHSRCALPHA"));
        break;
    case D3DBLEND_BOTHINVSRCALPHA:
        DISPDBG((Level, "  BOTHINVSRCALPHA"));
        break;
    }
}  /* DecodeBlend */

// Surface dumping is turned on by setting DDDebugLevel 

LONG DDDebugLevel = 0;

//-----------------------------------------------------------------------------
//
//  DumpSurface
//
//  dump properties of a DirectDraw Surface
//
//-----------------------------------------------------------------------------

VOID 
DumpSurface(LONG Level, 
            LPDDRAWI_DDRAWSURFACE_LCL lpDDSurface, 
            LPDDSURFACEDESC lpDDSurfaceDesc)
{
    LPDDRAWI_DDRAWSURFACE_GBL psurf_gbl;
    LPDDRAWI_DDRAWSURFACE_LCL psurf_lcl;
    LPDDPIXELFORMAT pPixFormat;
    DDSCAPS ddsCaps;
    DDSCAPSEX ddsCapsEx;

    memset( &ddsCaps, 0, sizeof(ddsCaps));
    memset( &ddsCapsEx, 0, sizeof(ddsCapsEx));
    
    if (Level <= DDDebugLevel)
    {
        Level = 0;

        DBG_DD((Level,"  Surface Dump:"));
        
        if (lpDDSurfaceDesc != NULL)
        {
            pPixFormat = &lpDDSurfaceDesc->ddpfPixelFormat;
            ddsCaps = lpDDSurfaceDesc->ddsCaps;
            
            DBG_DD((Level,"    Surface Width:                      0x%x", 
                lpDDSurfaceDesc->dwWidth));
            DBG_DD((Level,"    Surface Height:                     0x%x", 
                lpDDSurfaceDesc->dwHeight));
            DBG_DD((Level,"    dwFlags:                            0x%x", 
                lpDDSurfaceDesc->dwFlags));
            
            DBG_DD((Level,"    DestOverlay: dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceLowValue));
            DBG_DD((Level,"    DestOverlay: dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKDestOverlay.dwColorSpaceHighValue));
            DBG_DD((Level,"    DestBlt:     dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKDestBlt.dwColorSpaceLowValue));
            DBG_DD((Level,"    DestBlt:     dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKDestBlt.dwColorSpaceHighValue));
            DBG_DD((Level,"    SrcOverlay:  dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceLowValue));
            DBG_DD((Level,"    SrcOverlay:  dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKSrcOverlay.dwColorSpaceHighValue));
            DBG_DD((Level,"    SrcBlt:      dwColorSpaceLowValue:  0x%x", 
                lpDDSurfaceDesc->ddckCKSrcBlt.dwColorSpaceLowValue));
            DBG_DD((Level,"    SrcBlt:      dwColorSpaceHighValue: 0x%x", 
                lpDDSurfaceDesc->ddckCKSrcBlt.dwColorSpaceHighValue));
            
        }
        else if (lpDDSurface != NULL)
        {
            psurf_gbl = lpDDSurface->lpGbl;
            psurf_lcl = lpDDSurface;
            pPixFormat = &psurf_gbl->ddpfSurface;
            ddsCaps = psurf_lcl->ddsCaps;
            ddsCapsEx= psurf_lcl->lpSurfMore->ddsCapsEx;
            DBG_DD((Level,"    Surface Width:          0x%x", 
                psurf_gbl->wWidth));
            DBG_DD((Level,"    Surface Height:         0x%x", 
                psurf_gbl->wHeight));
            DBG_DD((Level,"    ddsCaps.dwCaps:         0x%x", 
                psurf_lcl->ddsCaps.dwCaps));
            DBG_DD((Level,"    dwFlags:                0x%x", 
                psurf_lcl->dwFlags));
        }
        DBG_DD((Level,"    dwFourCC:               0x%x", 
            pPixFormat->dwFourCC));
        DBG_DD((Level,"    dwRGBBitCount:          0x%x", 
            pPixFormat->dwRGBBitCount));
        DBG_DD((Level,"    dwR/Y BitMask:          0x%x", 
            pPixFormat->dwRBitMask));
        DBG_DD((Level,"    dwG/U BitMask:          0x%x", 
            pPixFormat->dwGBitMask));
        DBG_DD((Level,"    dwB/V BitMask:          0x%x", 
            pPixFormat->dwBBitMask));
        DBG_DD((Level,"    dwRGBAlphaBitMask:      0x%x", 
            pPixFormat->dwRGBAlphaBitMask));
        
        DBG_DD((Level,"  Surface Is:"));

        if (ddsCaps.dwCaps & DDSCAPS_TEXTURE)
        {
            DBG_DD((Level,"   TEXTURE"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            DBG_DD((Level,"   SYSTEMMEMORY"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
        {
            DBG_DD((Level,"   VIDEOMEMORY"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            DBG_DD((Level,"   NONLOCALVIDMEM"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)
        {
            DBG_DD((Level,"   LOCALVIDMEM"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
        {
            DBG_DD((Level,"   PRIMARYSURFACE"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN)
        {
            DBG_DD((Level,"   OFFSCREEN_PLAIN"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER)
        {
            DBG_DD((Level,"   FRONT_BUFFER"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_BACKBUFFER)
        {
            DBG_DD((Level,"   BACK_BUFFER"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_COMPLEX)
        {
            DBG_DD((Level,"   COMPLEX"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_FLIP)
        {
            DBG_DD((Level,"   FLIP"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_MODEX)
        {
            DBG_DD((Level,"   MODEX"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_ALLOCONLOAD)
        {
            DBG_DD((Level,"   ALLOCONLOAD"));
        }
        if (ddsCaps.dwCaps & DDSCAPS_LIVEVIDEO)
        {
            DBG_DD((Level,"   LIVEVIDEO"));
        }
        if (pPixFormat->dwFlags & DDPF_ZBUFFER)
        {
            DBG_DD((Level,"   Z BUFFER"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            DBG_DD((Level,"   ALPHAPIXELS"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHA)
        {
            DBG_DD((Level,"   ALPHA"));
        }
        if (pPixFormat->dwFlags & DDPF_ALPHAPREMULT)
        {
            DBG_DD((Level,"   ALPHAPREMULT"));
        }
#if DX7_STEREO
        if (ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
        {
            DBG_DD((Level,"   STEREOSURFACELEFT"));
        }
#endif
    }
}   // DumpSurface 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\ddcpyblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddcpyblt.c
*
* Content:     several copy and clear blits for Permedia 2
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"

//-----------------------------------------------------------------------------
//
// PermediaPackedCopyBlt
//
// Does a packed blit, allowing for different source and destination
// partial products.
//
// ppdev----------- the ppdev
// dwDestPitch----- pitch of destination surface          
// dwSourcePitch--- pitch of source surface
// pDest----------- pointer to private data structure of dest. surface
// pSource--------- pointer to private data structure of source surface
// *rDest---------- dest. rectangle of blit
// *rSrc----------- source rectangle of blit
// dwWindowBase---- offset of dest. window in frame buffer  
// lWindowOffset--- offset of source window in frame buffer
//
//-----------------------------------------------------------------------------

VOID 
PermediaPackedCopyBlt(  PPDev ppdev,                    // ppdev
                        DWORD dwDestPitch,              // pitch of dest 
                        DWORD dwSourcePitch,
                        PermediaSurfaceData* pDest,
                        PermediaSurfaceData* pSource,
                        RECTL   *rDest,
                        RECTL   *rSrc,
                        DWORD   dwWindowBase,   
                        LONG    lWindowOffset
                        )
{
    PERMEDIA_DEFS(ppdev);

    LONG    lOffset;
    LONG    lSourceOffset;
   
    LONG    lPixelSize=pDest->SurfaceFormat.PixelSize;
    LONG    lPixelMask=3>>pDest->SurfaceFormat.PixelShift;
    LONG    lPixelShift=2-pDest->SurfaceFormat.PixelShift;
    
    DBG_DD(( 5, "DDraw:PermediaPackedCopyBlt "
        "From %08lx %08lx %08lx %08lx %08lx %08lx %08lx "
        "To   %08lx %08lx %08lx %08lx %08lx %08lx %08lx",
        dwSourcePitch,pSource,rSrc->bottom,rSrc->left,
        rSrc->right,rSrc->top,lWindowOffset,
        dwDestPitch,pDest,rDest->bottom,rDest->left,
        rDest->right,rDest->top,dwWindowBase));

    ASSERTDD(!(rSrc->top<0) && !(rSrc->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");
    ASSERTDD(!(rDest->top<0) && !(rDest->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");

    lOffset = (((rDest->left & lPixelMask)-(rSrc->left & lPixelMask)) & 7);
    lSourceOffset = lWindowOffset + 
                    RECTS_PIXEL_OFFSET(rSrc, rDest,
                                       dwSourcePitch, dwDestPitch, 
                                       lPixelMask ) + 
                    LINEAR_FUDGE(dwSourcePitch, dwDestPitch, rDest);
    
    RESERVEDMAPTR(14);

    SEND_PERMEDIA_DATA( FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    // set packed with offset
    SEND_PERMEDIA_DATA( FBWindowBase, dwWindowBase);

    SEND_PERMEDIA_DATA( FBReadMode,  
                        PM_FBREADMODE_PARTIAL(pSource->ulPackedPP) |
                        PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_RELATIVEOFFSET(lOffset));

    SEND_PERMEDIA_DATA( FBWriteConfig,   
                        PM_FBREADMODE_PARTIAL(pDest->ulPackedPP) |
                        PM_FBREADMODE_READSOURCE(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)        |
                        PM_FBREADMODE_RELATIVEOFFSET(lOffset));

    SEND_PERMEDIA_DATA( LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA( FBSourceOffset, lSourceOffset);

    // Render the rectangle

    if (lSourceOffset >= 0) {
        // Use left to right and top to bottom
        SEND_PERMEDIA_DATA( StartXDom, 
            INTtoFIXED(rDest->left >> lPixelShift));
        SEND_PERMEDIA_DATA( StartXSub, 
            INTtoFIXED((rDest->right >> lPixelShift) + lPixelMask));
        SEND_PERMEDIA_DATA( PackedDataLimits,    
                            PM_PACKEDDATALIMITS_OFFSET(lOffset)      |
                            PM_PACKEDDATALIMITS_XSTART(rDest->left) |
                            PM_PACKEDDATALIMITS_XEND(rDest->right));
        SEND_PERMEDIA_DATA( StartY, INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA( dY, INTtoFIXED(1));
    }
    else {
        // Use right to left and bottom to top
        SEND_PERMEDIA_DATA( StartXDom, 
            INTtoFIXED(((rDest->right) >> lPixelShift) + lPixelMask));
        SEND_PERMEDIA_DATA( StartXSub, 
            INTtoFIXED(rDest->left >> lPixelShift));
        SEND_PERMEDIA_DATA( PackedDataLimits,    
                            PM_PACKEDDATALIMITS_OFFSET(lOffset)       |
                            PM_PACKEDDATALIMITS_XSTART(rDest->right) |
                            PM_PACKEDDATALIMITS_XEND(rDest->left));
        SEND_PERMEDIA_DATA( StartY, INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA( dY, (DWORD)INTtoFIXED(-1));
    }

    SEND_PERMEDIA_DATA( Count, rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA( Render, __RENDER_TRAPEZOID_PRIMITIVE);
    COMMITDMAPTR();
    FLUSHDMA();

}   //  PermediaPackedCopyBlt 

//-----------------------------------------------------------------------------
//
// PermediaPatchedCopyBlt
//
// Does a patched blit, i.e. blits from source to destination and
// turns on patching. Note that this method cannot use packed blits.
// 
// ppdev----------- the ppdev
// dwDestPitch----- pitch of destination surface          
// dwSourcePitch--- pitch of source surface
// pDest----------- pointer to private data structure of dest. surface
// pSource--------- pointer to private data structure of source surface
// *rDest---------- dest. rectangle of blit
// *rSrc----------- source rectangle of blit
// dwWindowBase---- offset of dest. window in frame buffer  
// lWindowOffset--- offset of source window in frame buffer
//
//-----------------------------------------------------------------------------

VOID 
PermediaPatchedCopyBlt( PPDev ppdev,
                        DWORD dwDestPitch,
                        DWORD dwSourcePitch,
                        PermediaSurfaceData* pDest,
                        PermediaSurfaceData* pSource,
                        RECTL *rDest,
                        RECTL *rSrc,
                        DWORD  dwWindowBase,
                        LONG   lWindowOffset
                        )
{
    PERMEDIA_DEFS(ppdev);

    LONG    lSourceOffset;
    LONG    lPixelSize=pDest->SurfaceFormat.PixelSize;
    LONG    lPixelMask=pDest->SurfaceFormat.PixelMask;
    LONG    lPixelShift=pDest->SurfaceFormat.PixelShift;

    ASSERTDD(!(rSrc->top<0) && !(rSrc->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");
    ASSERTDD(!(rDest->top<0) && !(rDest->left<0),
        "PermediaPackedCopyBlt: cannot handle neg. src coordinates");

    DBG_DD(( 5, "DDraw:PermediaPatchedCopyBlt"));

    lSourceOffset = lWindowOffset + 
                    RECTS_PIXEL_OFFSET(rSrc, rDest,
                        dwSourcePitch, dwDestPitch, lPixelMask) +
                    LINEAR_FUDGE(dwSourcePitch, dwDestPitch, rDest);

    RESERVEDMAPTR(13);

    SEND_PERMEDIA_DATA( FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    // Patching isn't symetric, so we need to reverse the patch code depending
    // on the direction of the patch

    SEND_PERMEDIA_DATA( FBWindowBase, dwWindowBase);

    if (pDest->dwFlags & P2_CANPATCH) 
    {
        pDest->dwFlags |= P2_ISPATCHED;
        SEND_PERMEDIA_DATA( FBReadMode, 
                            pSource->ulPackedPP | 
                            __FB_READ_SOURCE);
        SEND_PERMEDIA_DATA( FBWriteConfig, 
                            pDest->ulPackedPP                 |
                            PM_FBREADMODE_PATCHENABLE(__PERMEDIA_ENABLE) |
                            PM_FBREADMODE_PATCHMODE(__PERMEDIA_SUBPATCH));
    } else 
    {
        pDest->dwFlags &= ~P2_ISPATCHED;
        SEND_PERMEDIA_DATA( FBReadMode, 
                            pSource->ulPackedPP               | 
                            __FB_READ_SOURCE                          |
                            PM_FBREADMODE_PATCHENABLE(__PERMEDIA_ENABLE) |
                            PM_FBREADMODE_PATCHMODE(__PERMEDIA_SUBPATCH) );
        SEND_PERMEDIA_DATA(FBWriteConfig, (pDest->ulPackedPP ));
    }

    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(FBSourceOffset, lSourceOffset);

    // Render the rectangle

    if (lSourceOffset >= 0) 
    {
        // Use left to right and top to bottom
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    } else 
    {
        // Use right to left and bottom to top
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY, (DWORD)INTtoFIXED(-1));
    }
 
    SEND_PERMEDIA_DATA(Count, rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE);
    COMMITDMAPTR();
    FLUSHDMA();

}   // PermediaPatchedCopyBlt 

//-----------------------------------------------------------------------------
//
// PermediaFastClear
//
// Does a fast clear of a surface. Supports all color depths
// Can clear depth or Frame buffer.
//
// ppdev---------the ppdev        
// pPrivateData--pointer to private data structure of dest. surface
// rDest---------rectangle for colorfill in dest. surface 
// dwWindowBase--offset of dest. surface in frame buffer
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
PermediaFastClear(PPDev ppdev, 
                  PermediaSurfaceData* pPrivateData,
                  RECTL *rDest, 
                  DWORD dwWindowBase, 
                  DWORD dwColor)
{
    PERMEDIA_DEFS(ppdev);

    ULONG   ulRenderBits;
    BOOL    bFastFill=TRUE;
    LONG    lPixelSize=pPrivateData->SurfaceFormat.PixelSize;
    

    DBG_DD(( 5, "DDraw:PermediaFastClear"));

    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData), 
        "Private Surface data not valid in clear");

    ASSERTDD((pPrivateData->dwFlags & P2_PPVALID),
        "PermediaFastClear called with invalid PP codes");

    ulRenderBits = __RENDER_FAST_FILL_ENABLE
                 | __RENDER_TRAPEZOID_PRIMITIVE;

    // Clear depending on depth
    switch (lPixelSize) 
    {
        case __PERMEDIA_4BITPIXEL:
            dwColor &= 0xF;
            dwColor |= dwColor << 4;
            // fall through...
        case __PERMEDIA_8BITPIXEL:
            dwColor &= 0xFF;
            dwColor |= dwColor << 8;
            // fall through
        case __PERMEDIA_16BITPIXEL:
            dwColor &= 0xFFFF;
            dwColor |= (dwColor << 16);
            break;

        case __PERMEDIA_24BITPIXEL:
            dwColor &= 0xFFFFFF;
            dwColor |= ((dwColor & 0xFF) << 24);
            // Can't use SGRAM fast block fills on any color, only on grey.
            if (((dwColor & 0xFF) == ((dwColor & 0xFF00) >> 8)) &&
                    ((dwColor & 0xFF) == ((dwColor & 0xFF0000) >> 16))) {
                bFastFill = TRUE;
            } else {
                bFastFill = FALSE;
            }
            break;

        default:
            break;
    }


    RESERVEDMAPTR(15);
    SEND_PERMEDIA_DATA( dXDom, 0x0);
    SEND_PERMEDIA_DATA( dXSub, 0x0);
    SEND_PERMEDIA_DATA( FBPixelOffset, 0);
    SEND_PERMEDIA_DATA( FBReadPixel, 
                        pPrivateData->SurfaceFormat.FBReadPixel);

    if (bFastFill) 
    {
        SEND_PERMEDIA_DATA(FBBlockColor, dwColor);
    } else 
    {
        ulRenderBits &= ~__RENDER_FAST_FILL_ENABLE;
        SEND_PERMEDIA_DATA(FBWriteData, dwColor);
    }

    SEND_PERMEDIA_DATA(FBReadMode,    
                       PM_FBREADMODE_PARTIAL(pPrivateData->ulPackedPP)|
                       PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE));

    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_CONSTANT_FB_WRITE);
    SEND_PERMEDIA_DATA(FBWindowBase,  dwWindowBase);

    // Render the rectangle

    SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
    SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
    SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
    SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);

    SEND_PERMEDIA_DATA(Render, ulRenderBits);

    // Reset our pixel values.
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);
    COMMITDMAPTR();
    FLUSHDMA();

}   //PermediaFastClear

//-----------------------------------------------------------------------------
//
// PermediaClearManagedSurface
//
// Does a clear of a managed surface. Supports all color depths
//
// PixelSize-----surface color depth
// rDest---------rectangle for colorfill in dest. surface 
// fpVidMem------pointer to fill
// lPitch--------Surface Pitch
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
PermediaClearManagedSurface(DWORD   PixelSize,
                  RECTL     *rDest, 
                  FLATPTR   fpVidMem, 
                  LONG      lPitch,
                  DWORD     dwColor)
{
    BYTE* pDestStart;
    LONG i;
    DBG_DD(( 5, "DDraw:PermediaClearManagedSurface"));

    LONG lByteWidth = rDest->right - rDest->left;
    LONG lHeight = rDest->bottom - rDest->top;

    // Calculate the start pointer for the dest
    pDestStart   = (BYTE*)(fpVidMem + (rDest->top * lPitch));
    // Clear depending on depth
    switch (PixelSize) 
    {
        case __PERMEDIA_4BITPIXEL:
        {
            DWORD   right=rDest->right,left=rDest->left;
            dwColor &= 0x0F;
            dwColor |= dwColor << 4;
            if (right & 1)
            {
                pDestStart = (BYTE*)(fpVidMem + (rDest->top * lPitch));
                pDestStart += right/2;
                for (i=0;i<lHeight;i++)
                {
                    pDestStart[i*lPitch] = (pDestStart[i*lPitch] & 0xF0) |
                        (BYTE)(dwColor & 0x0F);
                }   
                right--;
            }

            if (left & 1)
            {
                pDestStart = (BYTE*)(fpVidMem + (rDest->top * lPitch));
                pDestStart += left/2;
                for (i=0;i<lHeight;i++)
                {
                    pDestStart[i*lPitch] = (pDestStart[i*lPitch] & 0x0F) |
                        (BYTE)(dwColor << 4);
                }   
                left++;
            }
            pDestStart = (BYTE*)(fpVidMem + (rDest->top * lPitch));
            while (--lHeight >= 0) 
            {
                while (left<right)
                {
                    pDestStart[left/2]=(BYTE)dwColor;
                    left +=2;
                }
                pDestStart += lPitch;
            }
        }
        break;
        case __PERMEDIA_8BITPIXEL:
            pDestStart += rDest->left;
            while (--lHeight >= 0) 
            {
                for (i=0;i<lByteWidth;i++)
                    pDestStart[i]=(BYTE)dwColor;
                pDestStart += lPitch;
            }
            break;
            // fall through
        case __PERMEDIA_16BITPIXEL:
            pDestStart += rDest->left*2;
            while (--lHeight >= 0) 
            {
                LPWORD  lpWord=(LPWORD)pDestStart;
                for (i=0;i<lByteWidth;i++)
                    lpWord[i]=(WORD)dwColor;
                pDestStart += lPitch;
            }
            break;

        case __PERMEDIA_24BITPIXEL:
            dwColor &= 0xFFFFFF;
            dwColor |= ((dwColor & 0xFF) << 24);
        default:
            pDestStart += rDest->left*4;
            while (--lHeight >= 0) 
            {
                LPDWORD lpDWord=(LPDWORD)pDestStart;
                for (i=0;i<lByteWidth;i++)
                    lpDWord[i]=(WORD)dwColor;
                pDestStart += lPitch;
            }
            break;
    }
}
//-----------------------------------------------------------------------------
//
// PermediaFastLBClear
//
// Does a fast clear of the Permedia Z (local) Buffer. The Permedia Z Buffer
// is always 16 bit wide...
//
// ppdev---------the ppdev        
// pPrivateData--pointer to private data structure of dest. surface
// rDest---------rectangle for colorfill in dest. surface 
// dwWindowBase--offset of dest. surface in frame buffer
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
PermediaFastLBClear(PPDev ppdev,
                    PermediaSurfaceData* pPrivateData,
                    RECTL *rDest,
                    DWORD dwWindowBase,
                    DWORD dwColor)
{
    PERMEDIA_DEFS(ppdev);
    
    DBG_DD(( 5, "DDraw:PermediaFastLBClear"));
    
    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateData), 
                "Private Surface data not valid in clear");
    ASSERTDD((pPrivateData->dwFlags & P2_PPVALID),
        "PermediaFastClear called with invalid PP codes");
    
    // Clear according to Z-Buffer depth
    dwColor &= 0xFFFF;
    dwColor |= dwColor << 16;
    
    RESERVEDMAPTR(15);
    SEND_PERMEDIA_DATA( dXDom, 0x0);
    SEND_PERMEDIA_DATA( dXSub, 0x0);
    SEND_PERMEDIA_DATA( FBPixelOffset, 0);
    SEND_PERMEDIA_DATA( FBReadPixel, __PERMEDIA_16BITPIXEL);    
    SEND_PERMEDIA_DATA( FBBlockColor, dwColor);
    SEND_PERMEDIA_DATA( FBReadMode,    
                        PM_FBREADMODE_PARTIAL(pPrivateData->ulPackedPP) |
                        PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE));
    SEND_PERMEDIA_DATA( LogicalOpMode, __PERMEDIA_CONSTANT_FB_WRITE);
    SEND_PERMEDIA_DATA( FBWindowBase, dwWindowBase);
    SEND_PERMEDIA_DATA( StartXDom, INTtoFIXED(rDest->left));
    SEND_PERMEDIA_DATA( StartXSub, INTtoFIXED(rDest->right));
    SEND_PERMEDIA_DATA( StartY,    INTtoFIXED(rDest->top));
    SEND_PERMEDIA_DATA( dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA( Count,     rDest->bottom - rDest->top);
    SEND_PERMEDIA_DATA( Render,    __RENDER_FAST_FILL_ENABLE
                                  |__RENDER_TRAPEZOID_PRIMITIVE);

    // Reset our pixel values.
    SEND_PERMEDIA_DATA( LogicalOpMode, __PERMEDIA_DISABLE);

    COMMITDMAPTR();
    FLUSHDMA();
    
}   // PermediaFastLBClear 

//-----------------------------------------------------------------------------
//
// SysMemToSysMemSurfaceCopy
//
// Does a copy from System memory to System memory (either from or to an
// AGP surface, or any other system memory surface)
//
//-----------------------------------------------------------------------------

VOID 
SysMemToSysMemSurfaceCopy(FLATPTR     fpSrcVidMem,
                          LONG        lSrcPitch,
                          DWORD       dwSrcBitCount,
                          FLATPTR     fpDstVidMem,
                          LONG        lDstPitch, 
                          DWORD       dwDstBitCount,
                          RECTL*      rSource,
                          RECTL*      rDest)
{
    BYTE* pSourceStart;
    BYTE* pDestStart;
    BYTE  pixSource;
    BYTE* pNewDest;
    BYTE* pNewSource;

    DBG_DD(( 5, "DDraw:SysMemToSysMemSurfaceCopy"));

    LONG lByteWidth = rSource->right - rSource->left;
    LONG lHeight = rSource->bottom - rSource->top;
    if (NULL == fpSrcVidMem || NULL == fpDstVidMem)
    {
        DBG_DD(( 0, "DDraw:SysMemToSysMemSurfaceCopy unexpected 0 fpVidMem"));
        return;
    }
    // Calculate the start pointer for the source and the dest
    pSourceStart = (BYTE*)(fpSrcVidMem + (rSource->top * lSrcPitch));
    pDestStart   = (BYTE*)(fpDstVidMem + (rDest->top * lDstPitch));

    // Be careful if the source is 4 bits deep.
    if(4 == dwSrcBitCount)
    {
        // May have to handle horrible single pixel edges.  Check if we need to
        if (!((1 & (rSource->left ^ rDest->left)) == 1))
        {
            pSourceStart += rSource->left / 2;
            pDestStart += rDest->left / 2;
            lByteWidth /= 2;

            // Do we have to account for the odd pixel at the start?
            if (rSource->left & 0x1) 
            {
                    lByteWidth--;
            }

            // If the end is odd then miss of the last nibble (do it later).
            if (rSource->right & 0x1) 
            {
                    lByteWidth--;
            }

            while (--lHeight >= 0) 
            {
                // Potentially copy the left hand pixel
                if (rSource->left & 0x1) {
                    *pDestStart &= 0x0F;
                    *pDestStart |= (*pSourceStart & 0xF0);

                    pNewDest = pDestStart + 1;
                    pNewSource = pSourceStart + 1;
                } else {
                    pNewDest = pDestStart;
                    pNewSource = pSourceStart;
                }

                // Byte copy the rest of the field
                memcpy(pNewDest, pNewSource, lByteWidth);

                // Potentially copy the right hand pixel
                if (rSource->right & 0x1) {
                    *(pNewDest + lByteWidth) &= 0xF0;
                    *(pNewDest + lByteWidth) |= 
                        (*(pNewSource + lByteWidth) & 0xF);
                }

                pDestStart += lDstPitch;
                pSourceStart += lSrcPitch;
            }

        } else 
        {
            // Do it the hard way - copy single pixels one at a time

            pSourceStart += rSource->left / 2;
            pDestStart += rDest->left / 2;

            while (--lHeight >= 0) 
            {
                BOOL bOddSource = rSource->left & 0x1;
                BOOL bOddDest = rDest->left & 0x1;

                pNewDest = pDestStart;
                pNewSource = pSourceStart;

                for (INT i = 0; i < lByteWidth; i++) 
                {
                    if (bOddSource) {
                        pixSource = (*pNewSource & 0xF0) >> 4;
                        pNewSource++;
                    } else {
                        pixSource = (*pNewSource & 0x0F);
                    }

                    if (bOddDest) {
                        *pNewDest &= 0x0F;
                        *pNewDest |= pixSource << 4;
                        pNewDest++;
                    } else {
                        *pNewDest &= 0xF0;
                        *pNewDest |= pixSource;
                    }

                    bOddSource = !bOddSource;
                    bOddDest = !bOddDest;
                }

                // Step onto the next line
                pDestStart += lDstPitch;
                pSourceStart += lSrcPitch;
            }
        }
    }
    else // The simple 8, 16 or 24 bit copy
    {
        pSourceStart += rSource->left * (dwSrcBitCount >> 3);
        pDestStart += rDest->left * (dwDstBitCount >> 3);
        lByteWidth *= (dwSrcBitCount >> 3);

        while (--lHeight >= 0) 
        {
            memcpy(pDestStart, pSourceStart, lByteWidth);
            pDestStart += lDstPitch;
            pSourceStart += lSrcPitch;
        };
    }

}   // SysMemToSysMemSurfaceCopy
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\ddldblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddldblt.c
*
* Content:     DirectDraw System to Videomemory download routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"

typedef struct tagSHORTDWORD 
{
    BYTE Red;
    BYTE Green;
    BYTE Blue;
} SHORTDWORD, *LPSHORTDWORD;

//-----------------------------------------------------------------------------
//
// PermediaPatchedTextureDownload
//
// Do a texture download to the linear region of memory. Access to textures
// is faster if they are stored as "patched". This function downloads a texture
// from system to videomemory and rearranges the data in the patched format.
//
// ppdev---------the PPDev
// pPrivateDest--DDraw private surface data for the dest. surface
// fpSrcVidMem---linear pointer to source systemmemory surface
// lSrcPitch-----pitch of source surface
// rSrc----------source rectangle
// fpDstVidMem---offset in videomemory of dest surface
// lDstPitch-----pitch of dest. surface
// rDest---------destination rectangle
//
//-----------------------------------------------------------------------------

VOID 
PermediaPatchedTextureDownload (PPDev ppdev, 
                                PermediaSurfaceData* pPrivateDest, 
                                FLATPTR     fpSrcVidMem,
                                LONG        lSrcPitch,
                                RECTL*      rSrc, 
                                FLATPTR     fpDstVidMem,
                                LONG        lDstPitch,
                                RECTL*      rDest)
{
    PERMEDIA_DEFS(ppdev);

    ULONG ulTextureBase = (ULONG)(fpDstVidMem);
    LONG  lWidth = rDest->right - rDest->left;
    LONG  lLines = rDest->bottom - rDest->top;

    DBG_DD((5,"DDraw:PermediaPatchedTextureDownload:, PrivateDest: 0x%x",
                pPrivateDest));

    if (NULL == fpSrcVidMem)
    {
        DBG_DD(( 0, "DDraw:PermediaPatchedTextureDownload"
            " unexpected NULL = fpSrcVidMem"));
        return;
    }
    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateDest),
             "Blt32: Destination Private Data not valid!");

    DBG_DD((6,"  Texture Base: 0x%x DstPitch=0x%x", 
                ulTextureBase, lDstPitch));
    DBG_DD((6,"  Source Base: 0x%x SourcePitch: 0x%x", 
                fpSrcVidMem,lSrcPitch));
    DBG_DD((6,"  rSource->left: 0x%x, rSource->right: 0x%x", 
                rSrc->left,rSrc->right));
    DBG_DD((6,"  rSource->top: 0x%x, rSource->bottom: 0x%x\n", 
                rSrc->top, rSrc->bottom));
    DBG_DD((6,"  rDest->left: 0x%x, rDest->right: 0x%x", 
                rDest->left,rDest->right));
    DBG_DD((6,"  rDest->top: 0x%x, rDest->bottom: 0x%x\n", 
                rDest->top, rDest->bottom));

    //
    //  define some handy variables
    //
    
    LONG lPixelSize=pPrivateDest->SurfaceFormat.PixelSize;

    RESERVEDMAPTR(18);

    SEND_PERMEDIA_DATA( ColorDDAMode,        __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA( AlphaBlendMode,      __PERMEDIA_DISABLE);                
    SEND_PERMEDIA_DATA( Window, PM_WINDOW_DISABLELBUPDATE(__PERMEDIA_ENABLE));
    SEND_PERMEDIA_DATA( dXDom, 0x0);
    SEND_PERMEDIA_DATA( dXSub, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pPrivateDest->SurfaceFormat.FBReadPixel);
 
    switch (lPixelSize)
    {
    case __PERMEDIA_4BITPIXEL:
        // There are half as many 8-bit, 4-bit texels
        DBG_DD((6,"  Texture is 4-Bit indexed"));
        lWidth >>= 1;
        SEND_PERMEDIA_DATA(DitherMode, 0);
        break;
    case __PERMEDIA_8BITPIXEL: 
        DBG_DD((6,"  Texture is 8-Bit indexed"));
        SEND_PERMEDIA_DATA(DitherMode, 0);
        break;
    default:
        if (lPixelSize != __PERMEDIA_24BITPIXEL) {
            DBG_DD((6,"  Texture is BGR"));
            ulTextureBase >>= lPixelSize;
        } else {
            DBG_DD((6,"  Texture is 24-Bit BGR"));
            ulTextureBase /= 3;
        }
        // Setup the Dither unit
        SEND_PERMEDIA_DATA(DitherMode,( 
                (INV_COLOR_MODE << PM_DITHERMODE_COLORORDER)|
                (1 << PM_DITHERMODE_ENABLE)                 |
                (pPrivateDest->SurfaceFormat.Format << 
                    PM_DITHERMODE_COLORFORMAT) |
                (pPrivateDest->SurfaceFormat.FormatExtension << 
                    PM_DITHERMODE_COLORFORMATEXTENSION) ));
        break;
    }

    DBG_DD((6,"  Partial Products: 0x%x", pPrivateDest->ulPackedPP));
    DBG_DD((6,"  Texture Width: 0x%x, Downloaded as: 0x%x", 
                (rDest->right - rDest->left),lWidth));
    DBG_DD((6,"  Texture Height: 0x%x", rDest->bottom - rDest->top));
    DBG_DD((6,"  PixelSize: 0x%x", pPrivateDest->SurfaceFormat.PixelSize));
    DBG_DD((6,"  Format: 0x%x", pPrivateDest->SurfaceFormat.Format));
    DBG_DD((6,"  Format Extension: 0x%x", 
                 pPrivateDest->SurfaceFormat.FormatExtension));

    // Downloading a texture, disable texture colour mode.
    SEND_PERMEDIA_DATA(TextureColorMode,    (0 << PM_TEXCOLORMODE_ENABLE));
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);

    //
    //  all textures get by default marked as P2_CANPATCH,
    //  except 4 bit paletted textures
    //
    if (pPrivateDest->dwFlags & P2_CANPATCH) {

        // Mark the texture as being patched.
        pPrivateDest->dwFlags |= P2_ISPATCHED;

        // set up partial product and patch
        SEND_PERMEDIA_DATA(FBReadMode,  
                PM_FBREADMODE_PARTIAL(pPrivateDest->ulPackedPP) |
                PM_FBREADMODE_PATCHENABLE(__PERMEDIA_ENABLE) |
                PM_FBREADMODE_PATCHMODE(__PERMEDIA_SUBPATCH) );

    } else {

        // This texture isn't patched
        pPrivateDest->dwFlags &= ~P2_ISPATCHED;

        // Load up the partial products of the texture, don't use patching
        SEND_PERMEDIA_DATA(FBReadMode, 
                PM_FBREADMODE_PARTIAL(pPrivateDest->ulPackedPP));
    }

    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    SEND_PERMEDIA_DATA(FBWindowBase, ulTextureBase);

    // Use left to right and top to bottom
    if (lWidth == 2048)
    {
        // special case for 2048-wide textures because of the precision
        // of the StartXSub register
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(-1));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(lWidth-1));
    }
    else
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(0));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(lWidth));
    }
    SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(0));
    SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,     (lLines));
    SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE |
                                  __RENDER_SYNC_ON_HOST_DATA);
    COMMITDMAPTR();

    switch (lPixelSize) {

    case __PERMEDIA_4BITPIXEL:
    case __PERMEDIA_8BITPIXEL:
    {
        BYTE* pTextureData = (BYTE*)fpSrcVidMem;

        //
        //  download texture data line by line
        //
        while(lLines-- > 0)
        {
            LONG lWords=lWidth;
            BYTE *pData=pTextureData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pData++);
            }

            COMMITDMAPTR();

            //
            //  force flush only every couple of lines
            //
            if ((lLines & 3)==0)
            {
                FLUSHDMA();
            }

            pTextureData += lSrcPitch;
        }
    }
    break;

    case __PERMEDIA_16BITPIXEL:
    {
        BYTE* pTextureData  = (BYTE*)fpSrcVidMem;

        if (pPrivateDest->SurfaceFormat.RedMask == 0x7c00)
        {
            DBG_DD((6,"  Texture is BGR, 16 bit 5:5:5:1"));

            //
            //  download texture data line by line
            //
            while(lLines-- > 0)
            {
                LONG lWords=lWidth;
                WORD *pData=(WORD*)pTextureData;

                RESERVEDMAWORDS(lWords+1);

                LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                        ((lWords-1) << 16));

                while (lWords--)
                {
                    LD_INPUT_FIFO_DATA(FORMAT_5551_32BIT((DWORD)*pData));
                    pData++;
                }

                COMMITDMAPTR();

                //
                //  force flush only every couple of lines
                //
                if ((lLines & 3)==0)
                {
                    FLUSHDMA();
                }

                pTextureData += lSrcPitch;
            }
        }
        else if(pPrivateDest->SurfaceFormat.RedMask == 0xF00)
        {
            DBG_DD((6,"  Texture is BGR, 16 bit 4:4:4:4"));
            //
            //  download texture data line by line
            //
            while(lLines-- > 0)
            {
                LONG lWords=lWidth;
                WORD *pData=(WORD*)pTextureData;

                RESERVEDMAWORDS(lWords+1);

                LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                    ((lWords-1) << 16));

                while (lWords--)
                {
                    LD_INPUT_FIFO_DATA(FORMAT_4444_32BIT((DWORD)*pData));
                    pData++;
                }

                COMMITDMAPTR();

                //
                //  force flush only every couple of lines
                //
                if ((lLines & 3)==0)
                {
                    FLUSHDMA();
                }

                pTextureData += lSrcPitch;
            }
        }
        else
        {
            DBG_DD((6,"  Texture is BGR, 16 bit 5:6:5"));
            //
            //  download texture data line by line
            //
            while(lLines-- > 0)
            {
                LONG lWords=lWidth;
                WORD *pData=(WORD*)pTextureData;

                RESERVEDMAWORDS(lWords+1);

                LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                    ((lWords-1) << 16));

                while (lWords--)
                {
                    LD_INPUT_FIFO_DATA(FORMAT_565_32BIT((DWORD)*pData));
                    pData++;
                }

                COMMITDMAPTR();

                //
                //  force flush only every couple of lines
                //
                if ((lLines & 3)==0)
                {
                    FLUSHDMA();
                }

                pTextureData += lSrcPitch;
            }
        }
    }
    break;

    case __PERMEDIA_24BITPIXEL:
    case __PERMEDIA_32BITPIXEL:
    {
        BYTE* pTextureData  = (BYTE*)fpSrcVidMem;
        //
        //  download texture data line by line
        //
        while(lLines-- > 0)
        {
            LONG lWords=lWidth;
            ULONG *pData=(ULONG*)pTextureData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pData++);
            }

            COMMITDMAPTR();

            //
            //  force flush only every couple of lines
            //
            if ((lLines & 3)==0)
            {
                FLUSHDMA();
            }

            pTextureData += lSrcPitch;
        }
    }
    break;

    }

    RESERVEDMAPTR(2);
    SEND_PERMEDIA_DATA(DitherMode, 0);
    SEND_PERMEDIA_DATA(WaitForCompletion, 0);
    COMMITDMAPTR();

} // PermediaPatchedTextureDownload 


//-----------------------------------------------------------------------------
//
// PermediaPackedDownload
//
// Function to do a system to video memory blt.
// Uses the packed bit on Permedia to do the packing for us. Needs
// to setup the offset bit for alignment and doesn't need to adjust
// the partial products. The calling function guarantees that the
// source and destination rects have the same size.
// 
//
// ppdev----------the PPDev 
// pPrivateDst----Permedia Surface data for destination
// lpSourceSurf---DDraw LCL for source surface 
// rSrc-----------source rect
// lpDestSurf-----DDraw LCL for destination surface
// rDest----------dest rect
//
//-----------------------------------------------------------------------------

VOID
PermediaPackedDownload(PPDev ppdev, 
                       PermediaSurfaceData* pPrivateDst, 
                       LPDDRAWI_DDRAWSURFACE_LCL lpSourceSurf, 
                       RECTL* rSrc, 
                       LPDDRAWI_DDRAWSURFACE_LCL lpDestSurf, 
                       RECTL* rDst)
{
    PERMEDIA_DEFS(ppdev);

    LONG  lDstOffset;           // dest offset in packed coordinates
    LONG  lSrcOffset;           // source offset in buffer in bytes
    LONG  lDstLeft, lDstRight;  // left and right dst in packed coordiantes
    LONG  lSrcLeft, lSrcRight;  // left and right src in packed coordiantes
    LONG  lPackedWidth;         // packed width to download
    LONG  lPixelMask;           // mask for pixels per packed DWORD
    LONG  lOffset;              // relative offset between src and dest 
    LONG  lPixelShift;          // handy helper var which contains pixel 
                                // shift from packed to surface format
    LONG  lPixelSize;           // just a helper
    LONG  lExtraDword;          // chip needs extra dummy 
                                // DWORD passed at end of line

    DBG_DD((5,"DDraw:PermediaPackedDownload, PrivateDst: 0x%x",
                pPrivateDst));

    ASSERTDD(CHECK_P2_SURFACEDATA_VALIDITY(pPrivateDst), 
                "Blt: Destination Private Data not valid!");
    ASSERTDD((rSrc->right-rSrc->left)==(rDst->right-rDst->left),
                "PermediaPackedDownload: src and dest rect width not equal");
    ASSERTDD((rSrc->bottom-rSrc->top)==(rDst->bottom-rDst->top),
                "PermediaPackedDownload: src and dest rect height not equal");

    // get a handy variable for pixel shifts, masks and size
    lPixelSize=pPrivateDst->SurfaceFormat.PixelSize;
    lPixelMask=pPrivateDst->SurfaceFormat.PixelMask;
    lPixelShift=pPrivateDst->SurfaceFormat.PixelShift;

    // offset in dst buffer adjusted to packed format
    lDstOffset =(LONG)((UINT_PTR)(lpDestSurf->lpGbl->fpVidMem) >> lPixelShift);

    // calculate offset in source buffer adjusted to packed format
    lSrcOffset = ((rSrc->left & ~lPixelMask) << lPixelShift) + 
                  (rSrc->top * lpSourceSurf->lpGbl->lPitch);

    // Calculate the relative offset within the dword packed dimensions
    lOffset = ((rDst->left & lPixelMask) - 
               (rSrc->left & lPixelMask)) & 0x7;

    // set up the left and right end of the unpacked source data
    lDstLeft  = rDst->left;
    lDstRight = rDst->right;

    // precalc packed width for 32 bit case
    lPackedWidth = lDstRight-lDstLeft;
    lExtraDword=0;

    if (lPixelSize != __PERMEDIA_32BITPIXEL) 
    {
        // we need to check both source and dest
        // if they have different alignments
        LONG lSrcLeft2  = rSrc->left;
        LONG lSrcRight2 = rSrc->right;

        // Set up the relative offset to allow us to download packed word
        // and byte aligned data.
        if (lPixelSize == __PERMEDIA_4BITPIXEL) 
        {
            lDstLeft >>= 3;
            lSrcLeft2 >>= 3;
            lDstRight = (lDstRight + 7) >> 3;
            lSrcRight2 = (lSrcRight2 + 7) >> 3;
        }
        else 
        if (lPixelSize == __PERMEDIA_8BITPIXEL) 
        {
            lDstLeft >>= 2;
            lSrcLeft2 >>= 2;
            lDstRight = (lDstRight + 3) >> 2;
            lSrcRight2 = (lSrcRight2 + 3) >> 2;
        }
        else 
        {
            lDstLeft >>= 1;
            lSrcLeft2 >>= 1;
            lDstRight = (lDstRight + 1) >> 1;
            lSrcRight2 = (lSrcRight2 + 1) >> 1;
        }

        if ((lSrcRight2-lSrcLeft2) < (lDstRight-lDstLeft))
        {
            lExtraDword=1;
            lPackedWidth = lDstRight-lDstLeft;
        } else
        {
            lPackedWidth = lSrcRight2-lSrcLeft2;
        }
    } 

    RESERVEDMAPTR(12);
    SEND_PERMEDIA_DATA(FBReadPixel, pPrivateDst->SurfaceFormat.FBReadPixel);

    // No logical ops in SYS->VIDMEM Blits
    SEND_PERMEDIA_DATA(LogicalOpMode, 0);

    // Load up the partial products of image
    SEND_PERMEDIA_DATA(FBReadMode, (pPrivateDst->ulPackedPP) |
                                   PM_FBREADMODE_PACKEDDATA(__PERMEDIA_ENABLE)|
                                   PM_FBREADMODE_RELATIVEOFFSET(lOffset) );

    SEND_PERMEDIA_DATA(FBPixelOffset, 0);
    SEND_PERMEDIA_DATA(FBWindowBase,  lDstOffset);

    // Use left to right and top to bottom
    SEND_PERMEDIA_DATA(StartXDom,       INTtoFIXED(lDstLeft));
    SEND_PERMEDIA_DATA(StartXSub,       INTtoFIXED(lDstLeft+lPackedWidth));
    SEND_PERMEDIA_DATA(PackedDataLimits,PM_PACKEDDATALIMITS_OFFSET(lOffset) | 
                                        (rDst->left << 16) | 
                                         rDst->right);
    SEND_PERMEDIA_DATA(StartY,          INTtoFIXED(rDst->top));
    SEND_PERMEDIA_DATA(dY,              INTtoFIXED(1));
    SEND_PERMEDIA_DATA(Count,           (rDst->bottom - rDst->top));
    SEND_PERMEDIA_DATA(Render,          __RENDER_TRAPEZOID_PRIMITIVE | 
                                        __RENDER_SYNC_ON_HOST_DATA);
    COMMITDMAPTR();

    //
    // introduce some more handy pointers and LONGs
    //
    BYTE *pSurfaceData = (BYTE *)lpSourceSurf->lpGbl->fpVidMem + lSrcOffset;
    LONG lPitch =lpSourceSurf->lpGbl->lPitch;
    LONG lHeight=rDst->bottom - rDst->top;

    //
    // pump the whole thing in one huge block 
    // if the pitch and linewidth are the same and no extra treatment
    // for the buffer end is necessary
    //
    if ((lExtraDword==0) &&
        (lPackedWidth*(LONG)sizeof(ULONG))==lPitch)
    {
        vBlockLoadInputFifo( pP2dma, 
                             __Permedia2TagColor, 
                             (ULONG*)pSurfaceData, 
                             lPackedWidth*lHeight);
    } else
    {
        //
        //  lExtraDword is zero or 1, depends if we have to do a special
        //  treatment after this while block
        //
        while (lHeight>lExtraDword)
        {
            LONG lWords=lPackedWidth;
            ULONG *pImage=(ULONG*)pSurfaceData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pImage++);
            }

            COMMITDMAPTR();

            //
            //  force flush only every couple of lines
            //
            if ((lHeight & 3)==0)
            {
                FLUSHDMA();
            }

            pSurfaceData += lPitch;
            lHeight--;
        }

        //
        // treat last line separately, because we could read over the
        // end of buffer here if the source and dest rects are aligned
        // differently. lHeight will only be one here if lExtraDword==1
        //
        if (lHeight==1)
        {
            LONG lWords=lPackedWidth-1;
            ULONG *pImage=(ULONG*)pSurfaceData;

            RESERVEDMAWORDS(lWords+1);

            LD_INPUT_FIFO_DATA( __Permedia2TagColor | 
                                ((lWords-1) << 16));

            while (lWords--)
            {
                LD_INPUT_FIFO_DATA(*pImage++);
            }

            COMMITDMAPTR();

            //
            // send extra dummy DWORD
            //
            RESERVEDMAPTR(1);
            SEND_PERMEDIA_DATA( Color, 0);
            COMMITDMAPTR();

        }

        FLUSHDMA();
    }
} // PermediaPackedDownload
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\ddblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddblt.c
*
* Content:    DirectDraw Blt and AlphaBlt callbacks
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "precomp.h"
#include "directx.h"
#include "dd.h"

//
// lookup table to get shift values from Permedia format definition
DWORD ShiftLookup[5] = { 0, 0, 1, 0, 2};

//@@BEGIN_DDKSPLIT
#if DX7_ALPHABLT
//---------------------------------------------------------------------------
// BOOL Intersect
//
// Function:
//      Check the integration of two input rectangles (RECTL* pRcl1,
//      RECTL* pRcl2) and set the intersection result in (RECTL* pRclResult)
//
// Return:
//      TRUE---If 'prcl1' and 'prcl2' intersect. The intersection will be in
//            'prclResult'
//      FALSE--If they don't intersect. 'prclResult' is undefined.
//
//---------------------------------------------------------------------------

BOOL
Intersect(RECTL*  pRcl1,
          RECT*   pRcl2,
          RECTL*  pRclResult)
{
    pRclResult->left  = max(pRcl1->left,  pRcl2->left);
    pRclResult->right = min(pRcl1->right, pRcl2->right);

    //
    // Check if there is a horizontal intersection
    //
    if ( pRclResult->left < pRclResult->right )
    {
        pRclResult->top    = max(pRcl1->top,    pRcl2->top);
        pRclResult->bottom = min(pRcl1->bottom, pRcl2->bottom);

        //
        // Check if there a vertical intersection
        //
        if (pRclResult->top < pRclResult->bottom)
            return(TRUE);

    }

    //
    // Return FALSE if there is no intersection
    //
    return(FALSE);
}// Intersect()

//-----------------------------------------------------------------------------
//  IsDstRectClipped
//  
//  check if the destination rectangle of a blit is clipped by the given clip  
//  rectangles. The function takes the rectangles as is and there can be cases
//  where a dest. rectangle is not clipped, but do not detect it...
//
//  pDstRect---destination rectangle for blt
//  iClipRects-number of clip regions
//  pClipRects-clipping regions
//
//Return:
//  TRUE---dest rectangle is clipped
//  FALSE--dest rectangle is not clipped
//-----------------------------------------------------------------------------

BOOL 
IsDstRectClipped(RECTL *pDstRect, 
                 INT iClipRects, 
                 RECT *pClipRects)
{
    INT i;
    RECTL rClippedRect;

    for ( i=0; i<iClipRects; i++)
    {
        if (Intersect( pDstRect, &pClipRects[i], &rClippedRect))
        {
            if (pDstRect->left==rClippedRect.left &&
                pDstRect->right==rClippedRect.right &&
                pDstRect->top==rClippedRect.top &&
                pDstRect->bottom==rClippedRect.bottom 
               )
            {
                // dest rect is not clipped!!!
                return FALSE;
            }
        }
    }

    return TRUE;
}
#endif
//@@END_DDKSPLIT

//-----------------------------------------------------------------------------
//
//  DdPermediaBlt
//
//  implements DirectDraw Blt callback  
//
//  lpBlt----structure for passing information to DDHAL Blt
//
//-----------------------------------------------------------------------------

DWORD CALLBACK 
DdBlt( LPDDHAL_BLTDATA lpBlt )
{
    PPDev ppdev=(PPDev)lpBlt->lpDD->dhpdev;
    PERMEDIA_DEFS(ppdev);

    DWORD   dwWindowBase;
    RECTL   rSrc;
    RECTL   rDest;
    DWORD   dwFlags;
    LONG    lPixPitchDest;
    LONG    lPixPitchSrc;
    HRESULT ddrval;
    LPDDRAWI_DDRAWSURFACE_LCL  pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL  pDestLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pSrcGbl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDestGbl;
    PermediaSurfaceData* pPrivateSource;
    PermediaSurfaceData* pPrivateDest;
    
    pDestLcl    = lpBlt->lpDDDestSurface;
    pSrcLcl     = lpBlt->lpDDSrcSurface;
    
    DBG_DD((2,"DDraw: Blt, ppdev: 0x%x",ppdev));
    
    pDestGbl    = pDestLcl->lpGbl;
    pPrivateDest= (PermediaSurfaceData*)pDestGbl->dwReserved1;
    
    DD_CHECK_PRIMARY_SURFACE_DATA(pDestLcl,pPrivateDest);

    DBG_DD((10, "Dest Surface:"));
    DUMPSURFACE(10, pDestLcl, NULL);

    ULONG ulDestPixelShift=DDSurf_GetPixelShift(pDestLcl);

    dwFlags = lpBlt->dwFlags;
   
    // For the future, drivers should ignore the DDBLT_ASYNC
    // flag, because its hardly used by applications and
    // nowadays drivers can queue up lots of blits, so that
    // the applications do not have to wait for it.
    
    // get local copy of src and dest rect    
    rSrc = lpBlt->rSrc;
    rDest = lpBlt->rDest;

    // Switch to DirectDraw context
    DDCONTEXT;
    
    if (DDSurf_BitDepth(pDestLcl)==24)
    {
        return DDHAL_DRIVER_NOTHANDLED;  
    }

    dwWindowBase = (DWORD)((UINT_PTR)(pDestGbl->fpVidMem) >> 
        ulDestPixelShift);

    // get pitch for destination in pixels
    lPixPitchDest = pDestGbl->lPitch >> ulDestPixelShift;

    if (dwFlags & DDBLT_ROP)
    {

        if ((lpBlt->bltFX.dwROP >> 16) != (SRCCOPY >> 16))
        {
            DBG_DD((1,"DDraw:Blt:BLT ROP case not supported!"));
            return DDHAL_DRIVER_NOTHANDLED;
        }

        LONG    srcOffset;
        
        DBG_DD((3,"DDBLT_ROP:  SRCCOPY"));

        if (pSrcLcl != NULL) 
        {
            pSrcGbl = pSrcLcl->lpGbl;
            
            pPrivateSource = (PermediaSurfaceData*)pSrcGbl->dwReserved1;
            
            DD_CHECK_PRIMARY_SURFACE_DATA(pSrcLcl,pPrivateSource);

            DBG_DD((10, "Source Surface:"));
            DUMPSURFACE(10, pSrcLcl, NULL);
        }
        else 
        {
            return DDHAL_DRIVER_NOTHANDLED;
        }

        if (DDSurf_BitDepth(pSrcLcl)==24)
            return DDHAL_DRIVER_NOTHANDLED;  

        // determine src pitch in pixels
        lPixPitchSrc = pSrcGbl->lPitch >> ulDestPixelShift;


        // Operation is System -> Video memory blit, 
        // as a texture download or an image download.
        if ((pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) && 
            (pDestLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
        {
            ASSERTDD(!(pDestLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM),
                "unsupported texture download to AGP memory");

            if ((pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                        DDSCAPS2_TEXTUREMANAGE)
                && (NULL != pPrivateDest)
               )
            {   
                // texture download

                DBG_DD((3,"SYSMEM->MANAGED MEM Blit"
                           "(texture to system memory)"));
                
                pPrivateDest->dwFlags |= P2_SURFACE_NEEDUPDATE;
                SysMemToSysMemSurfaceCopy(
                    pSrcGbl->fpVidMem,
                    pSrcGbl->lPitch,
                    DDSurf_BitDepth(pSrcLcl),
                    pDestGbl->fpVidMem,
                    pDestGbl->lPitch,
                    DDSurf_BitDepth(pDestLcl), 
                    &rSrc, 
                    &rDest);

                goto BltDone;
            }
            else
            if (pPrivateDest!=NULL)
            {
                if ( (pDestLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) &&
                    ((rSrc.right-rSrc.left)==(LONG)pSrcGbl->wWidth) &&
                    ((rSrc.bottom-rSrc.top)==(LONG)pSrcGbl->wHeight)
                    )
                {   
                    // 
                    // patched texture download can only be done 
                    // when the texture is downloaded as a whole!
                    //

                    DBG_DD((3,"SYSMEM->VIDMEM Blit (texture to videomemory)"));

                    PermediaPatchedTextureDownload(
                        ppdev, 
                        pPrivateDest, 
                        pSrcGbl->fpVidMem,
                        pSrcGbl->lPitch,
                        &rSrc, 
                        pDestGbl->fpVidMem,
                        pDestGbl->lPitch, 
                        &rDest);
                }
                else
                {
                    // Image download

                    DBG_DD((3,"SYSMEM->VIDMEM Blit (system to videomemory)"));

                    PermediaPackedDownload( 
                        ppdev, 
                        pPrivateDest, 
                        pSrcLcl, 
                        &rSrc, 
                        pDestLcl, 
                        &rDest);
                }                   
                goto BltDone;
            } else
            {
                DBG_DD((0,"DDraw: Blt, privatedest invalid"));
                return DDHAL_DRIVER_NOTHANDLED;
            }
        }

        if (pPrivateSource == NULL ||
            pPrivateDest == NULL)
        {
            DBG_DD((0,"DDraw: Blt, privatesource or dest invalid"));
            return DDHAL_DRIVER_NOTHANDLED;
        }

        BOOL bNonLocalToVideo=FALSE;

        // set base of source
        if ( DDSCAPS_NONLOCALVIDMEM & pSrcLcl->ddsCaps.dwCaps)
        {
            // turn on AGP bus texture source
            srcOffset  = (LONG) DD_AGPSURFACEPHYSICAL(pSrcGbl);
            srcOffset |= 1 << 30;

            bNonLocalToVideo=TRUE;

        } else
        {
            srcOffset = (LONG)((pSrcGbl->fpVidMem) >> 
                pPrivateSource->SurfaceFormat.PixelSize);
        }

        // Operation is YUV->RGB conversion
        if ((pPrivateSource != NULL) && 
            (pPrivateSource->SurfaceFormat.Format == PERMEDIA_YUV422) &&
            (pPrivateSource->SurfaceFormat.FormatExtension 
                    == PERMEDIA_YUV422_EXTENSION))
        {
            DBG_DD((3,"YUV to RGB blt"));
            
            // We are only doing blits from YUV422 to RGB !

            if (pPrivateDest->SurfaceFormat.Format != PERMEDIA_YUV422)
            {
                DBG_DD((4,"Blitting from Source YUV to RGB"));
                
                // YUV to RGB blt
                PermediaYUVtoRGB(   ppdev, 
                                    &lpBlt->bltFX, 
                                    pPrivateDest, 
                                    pPrivateSource, 
                                    &rDest, 
                                    &rSrc, 
                                    dwWindowBase, 
                                    srcOffset);
                
                goto BltDone;
            }
            else
            {
                DBG_DD((0,"Couldn't handle YUV to YUV blt"));

                lpBlt->ddRVal = DD_OK;

                return DDHAL_DRIVER_NOTHANDLED;
            }
        }

        ASSERTDD(DDSurf_BitDepth(pSrcLcl)==DDSurf_BitDepth(pDestLcl),
                 "Blt between surfaces of different"
                 "color depths are not supported");

        BOOL bMirror=(dwFlags & DDBLT_DDFX)==DDBLT_DDFX;
        if (bMirror)
        {
            bMirror=  (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) || 
                      (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT);
        }
        BOOL bStretched=((rSrc.right - rSrc.left) != 
                            (rDest.right - rDest.left) || 
                        (rSrc.bottom - rSrc.top) != 
                            (rDest.bottom - rDest.top));

        // Is it a colorkey blt?
        if (dwFlags & DDBLT_KEYSRCOVERRIDE)
        {
            DBG_DD((3,"DDBLT_KEYSRCOVERRIDE"));

            // If the surface sizes don't match, then we are stretching.
            if (bStretched || bMirror)
            {
                PermediaStretchCopyChromaBlt(   ppdev, 
                                                lpBlt, 
                                                pPrivateDest, 
                                                pPrivateSource, 
                                                &rDest, 
                                                &rSrc, 
                                                dwWindowBase, 
                                                srcOffset);
            }
            else
            {
                PermediaSourceChromaBlt(    ppdev, 
                                            lpBlt, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &rSrc, 
                                            dwWindowBase, 
                                            srcOffset);
            }
            
            goto BltDone;
            
        }
        else
        { 
            // If the surface sizes don't match, then we are stretching.
            // Also the blits from Nonlocal- to Videomemory have to go through
            // the texture unit!
            if ( bStretched || bMirror || bNonLocalToVideo)
            {
                DBG_DD((3,"DDBLT_ROP: STRETCHCOPYBLT OR "
                          "MIRROR OR BOTH OR AGPVIDEO"));

                PermediaStretchCopyBlt( ppdev, 
                                        lpBlt, 
                                        pPrivateDest, 
                                        pPrivateSource, 
                                        &rDest, 
                                        &rSrc, 
                                        dwWindowBase, 
                                        srcOffset);
            }
            else
            {
                DBG_DD((3,"DDBLT_ROP:  COPYBLT %08lx %08lx %08lx",
                    pSrcGbl->fpVidMem,pDestGbl->fpVidMem,ulDestPixelShift));

                // Work out the source offset 
                // (offset in pixels from dst to src)
                srcOffset = (LONG)((pSrcGbl->fpVidMem - pDestGbl->fpVidMem) 
                    >> ulDestPixelShift);
                // For some reason, the user might want 
                // to do a conversion on the data as it is
                // blitted from VRAM->VRAM by turning on Patching. 
                // If Surf1Patch XOR Surf2Patch then
                // do a special blit that isn't packed and does patching.
                if (((pPrivateDest->dwFlags & P2_CANPATCH) ^ 
                     (pPrivateSource->dwFlags & P2_CANPATCH)) 
                       & P2_CANPATCH)
                {
                    DBG_DD((4,"Doing Patch-Conversion!"));

                    PermediaPatchedCopyBlt( ppdev, 
                                            lPixPitchDest, 
                                            lPixPitchSrc, 
                                            pPrivateDest, 
                                            pPrivateSource, 
                                            &rDest, 
                                            &rSrc, 
                                            dwWindowBase, 
                                            srcOffset);
                }
                else
                {
                    PermediaPackedCopyBlt( ppdev, 
                                           lPixPitchDest, 
                                           lPixPitchSrc, 
                                           pPrivateDest, 
                                           pPrivateSource, 
                                           &rDest, 
                                           &rSrc, 
                                           dwWindowBase, 
                                           srcOffset);
                }
            }
            goto BltDone;
        }

    }
    else if (pPrivateDest==NULL)
    {
        DBG_DD((0,"Private Surface data invalid!"));
        DUMPSURFACE(0, pDestLcl, NULL);
    } else if (dwFlags & DDBLT_COLORFILL)
    {
        DBG_DD((3,"DDBLT_COLORFILL: Color=0x%x", lpBlt->bltFX.dwFillColor));
        if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                    DDSCAPS2_TEXTUREMANAGE)
        {
            PermediaClearManagedSurface(pPrivateDest->SurfaceFormat.PixelSize,
                  &rDest, 
                  pDestGbl->fpVidMem, 
                  pDestGbl->lPitch,
                  lpBlt->bltFX.dwFillColor);
            pPrivateDest->dwFlags |= P2_SURFACE_NEEDUPDATE;
        }
        else
        {
            PermediaFastClear( ppdev, 
                           pPrivateDest, 
                           &rDest, 
                           dwWindowBase, 
                           lpBlt->bltFX.dwFillColor);
        }
    }
    else if (dwFlags & DDBLT_DEPTHFILL)
    {
        DBG_DD((3,"DDBLT_DEPTHFILL:  Value=0x%x", lpBlt->bltFX.dwFillColor));
        
        // Work out the window base for the LB clear, acount for the depth size
        dwWindowBase = (DWORD)((UINT_PTR)(pDestGbl->fpVidMem) 
            >> __PERMEDIA_16BITPIXEL);
        
        // Call the LB Solid Fill Function.
        PermediaFastLBClear( ppdev, 
                             pPrivateDest, 
                             &rDest, 
                             dwWindowBase, 
                             lpBlt->bltFX.dwFillColor);
    }
    else
    {
        DBG_DD((1,"DDraw:Blt:Blt case not supported %08lx", dwFlags));
        return DDHAL_DRIVER_NOTHANDLED;
    }
    
BltDone:
   
    lpBlt->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdBlt ()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\video\ms\3dlabs\perm2\disp\ddstrblt.c ===
/******************************Module*Header**********************************\
*
*                           *********************
*                           * DDraw SAMPLE CODE *
*                           *********************
*
* Module Name: ddstrblt.c
*
* Content:    
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/


#include "precomp.h"
#include "directx.h"
#include "dd.h"



//--------------------------------------------------------------------------
//
//  ConvertColorKeys
//
//  converts a color key to the Permedia internal format according to 
//  the given Permedia surface format
//
//--------------------------------------------------------------------------

VOID
ConvertColorKeys(PermediaSurfaceData *pSurface,
                 DWORD &dwLowerBound, 
                 DWORD &dwUpperBound)
{
    switch (pSurface->SurfaceFormat.Format)
    {
        case PERMEDIA_444_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_4444_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_4444_32BIT_BGR(dwUpperBound));
            break;
        case PERMEDIA_332_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_332_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_332_32BIT_BGR(dwUpperBound));
            break;
        case PERMEDIA_2321_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_2321_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_2321_32BIT_BGR(dwUpperBound));
            break;
        case PERMEDIA_4BIT_PALETTEINDEX:
        case PERMEDIA_8BIT_PALETTEINDEX:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_PALETTE_32BIT(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_PALETTE_32BIT(dwUpperBound));
            break;
        case PERMEDIA_5551_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_5551_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_5551_32BIT_BGR(dwUpperBound));
            dwLowerBound = dwLowerBound & 0xF8F8F8F8;   
            dwUpperBound = dwUpperBound | 0x07070707;
            break;
        case PERMEDIA_8888_RGB:
            // The permedia 565 mode is an extension, so don't confuse it with 
            // the 8888 mode which has the same number
            if (pSurface->SurfaceFormat.FormatExtension == 
                PERMEDIA_565_RGB_EXTENSION)
            {
                dwLowerBound = CHROMA_LOWER_ALPHA(
                    FORMAT_565_32BIT_BGR(dwLowerBound));
                dwUpperBound = CHROMA_UPPER_ALPHA(
                    FORMAT_565_32BIT_BGR(dwUpperBound));
                dwLowerBound = dwLowerBound & 0xF8F8FcF8; 
                dwUpperBound = dwUpperBound | 0x07070307;
            }
            else
            {
                dwLowerBound = CHROMA_LOWER_ALPHA(
                    FORMAT_8888_32BIT_BGR(dwLowerBound));
                dwUpperBound = CHROMA_UPPER_ALPHA(
                    FORMAT_8888_32BIT_BGR(dwUpperBound));
            }
            break;
        case PERMEDIA_888_RGB:
            dwLowerBound = CHROMA_LOWER_ALPHA(
                FORMAT_8888_32BIT_BGR(dwLowerBound));
            dwUpperBound = CHROMA_UPPER_ALPHA(
                FORMAT_8888_32BIT_BGR(dwUpperBound));
            break;
    }

    // swap blue and red if we have a RGB surface
    if (!pSurface->SurfaceFormat.ColorOrder)
    {
        dwLowerBound = SWAP_BR(dwLowerBound);   
        dwUpperBound = SWAP_BR(dwUpperBound);   
    }
}

//--------------------------------------------------------------------------
//
// PermediaStretchCopyBlt
//
// stretched blt through texture unit. no keying.
// handle mirroring if the stretched image requires it.
//
//--------------------------------------------------------------------------

VOID 
PermediaStretchCopyBlt( PPDev ppdev, 
                        LPDDHAL_BLTDATA lpBlt, 
                        PermediaSurfaceData* pDest, 
                        PermediaSurfaceData* pSource, 
                        RECTL *rDest, 
                        RECTL *rSrc, 
                        DWORD dwWindowBase, 
                        DWORD dwSourceOffset
                        )
{
    LONG lXScale;
    LONG lYScale;
    BOOL bYMirror=FALSE;
    BOOL bXMirror=FALSE;
    LONG lPixelSize=pDest->SurfaceFormat.PixelSize;

    DWORD dwDestWidth = rDest->right - rDest->left;
    DWORD dwDestHeight = rDest->bottom - rDest->top;
    DWORD dwSourceWidth = rSrc->right - rSrc->left;
    DWORD dwSourceHeight = rSrc->bottom - rSrc->top;

    DWORD dwTexSStart, dwTexTStart;
    DWORD dwRenderDirection;

    PERMEDIA_DEFS(ppdev);

    DBG_DD(( 5, "DDraw:PermediaStretchCopyBlt dwWindowBase=%08lx "
        "dwSourceOffset=%08lx", dwWindowBase, dwSourceOffset));

    ASSERTDD(pDest, "Not valid private surface in destination");
    ASSERTDD(pSource, "Not valid private surface in source");

    lXScale = (dwSourceWidth << 20) / dwDestWidth;
    lYScale = (dwSourceHeight << 20) / dwDestHeight;
    
    // Changes pixel depth to Dest buffer pixel depth if neccessary.
    RESERVEDMAPTR(28);

    SEND_PERMEDIA_DATA( FBPixelOffset, 0x0);
    SEND_PERMEDIA_DATA( FBReadPixel, pDest->SurfaceFormat.FBReadPixel);

    if (lPixelSize != 0)
    {
        // set writeback to dest surface...
        SEND_PERMEDIA_DATA( DitherMode,  
                            (pDest->SurfaceFormat.ColorOrder << 
                                PM_DITHERMODE_COLORORDER) | 
                            (pDest->SurfaceFormat.Format << 
                                PM_DITHERMODE_COLORFORMAT) |
                            (pDest->SurfaceFormat.FormatExtension << 
                                PM_DITHERMODE_COLORFORMATEXTENSION) |
                            (__PERMEDIA_ENABLE << PM_DITHERMODE_ENABLE)); 

    } 

    SEND_PERMEDIA_DATA(FBWindowBase, dwWindowBase);

    // set no read of dest.
    SEND_PERMEDIA_DATA(FBReadMode, pDest->ulPackedPP);
    SEND_PERMEDIA_DATA(LogicalOpMode, __PERMEDIA_DISABLE);

    // set base of source
    SEND_PERMEDIA_DATA(TextureBaseAddress, dwSourceOffset);
    SEND_PERMEDIA_DATA(TextureAddressMode,(1 << PM_TEXADDRESSMODE_ENABLE));
    SEND_PERMEDIA_DATA(TextureColorMode,  (1 << PM_TEXCOLORMODE_ENABLE) |
                                          (_P2_TEXTURE_COPY << 
                                                PM_TEXCOLORMODE_APPLICATION));

    SEND_PERMEDIA_DATA(TextureReadMode,
                        PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE)|
                        PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE)|
                        PM_TEXREADMODE_WIDTH(11) |
                        PM_TEXREADMODE_HEIGHT(11) );

    // set source bitmap format
    SEND_PERMEDIA_DATA(TextureDataFormat, 
                        (pSource->SurfaceFormat.Format << 
                            PM_TEXDATAFORMAT_FORMAT) |
                        (pSource->SurfaceFormat.FormatExtension << 
                            PM_TEXDATAFORMAT_FORMATEXTENSION) |
                        (pSource->SurfaceFormat.ColorOrder << 
                            PM_TEXDATAFORMAT_COLORORDER));
    SEND_PERMEDIA_DATA(TextureMapFormat, (pSource->ulPackedPP) | 
                                         (pSource->SurfaceFormat.PixelSize << 
                                            PM_TEXMAPFORMAT_TEXELSIZE) );

    // If we are doing special effects, and we are mirroring, 
    // we need to fix up the rectangles and change the sense of 
    // the render operation - we need to be carefull with overlapping
    // rectangles
    if (dwWindowBase != dwSourceOffset)
    {
        dwRenderDirection = 1;
    }
    else
    {
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else if(rSrc->left < rDest->left)
        {
            dwRenderDirection = 0;
        }
        else dwRenderDirection = 1;
    }

    if(NULL != lpBlt && lpBlt->dwFlags & DDBLT_DDFX)
    {
        bYMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN;
        bXMirror = lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT;

    } else
    {
        if (dwRenderDirection==0)
        {
            bXMirror = TRUE;
            bYMirror = TRUE;
        }
    }

    if (bXMirror)        
    {
        dwTexSStart = rSrc->right - 1;
        lXScale = -lXScale;
    }   
    else
    {
        dwTexSStart = rSrc->left;
    }

    if (bYMirror)        
    {
        dwTexTStart = rSrc->bottom - 1;
        lYScale = -lYScale;
    }
    else
    {
        dwTexTStart = rSrc->top;
    }

    SEND_PERMEDIA_DATA(SStart,      dwTexSStart << 20);
    SEND_PERMEDIA_DATA(TStart,      dwTexTStart << 20);
    SEND_PERMEDIA_DATA(dSdx,        lXScale);
    SEND_PERMEDIA_DATA(dSdyDom,     0);
    SEND_PERMEDIA_DATA(dTdx,        0);
    SEND_PERMEDIA_DATA(dTdyDom,     lYScale);
    
    // Render the rectangle

    if (dwRenderDirection)
    {
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->top));
        SEND_PERMEDIA_DATA(dY,        INTtoFIXED(1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }
    else
    {
        // Render right to left, bottom to top
        SEND_PERMEDIA_DATA(StartXDom, INTtoFIXED(rDest->right));
        SEND_PERMEDIA_DATA(StartXSub, INTtoFIXED(rDest->left));
        SEND_PERMEDIA_DATA(StartY,    INTtoFIXED(rDest->bottom - 1));
        SEND_PERMEDIA_DATA(dY,        (DWORD)INTtoFIXED(-1));
        SEND_PERMEDIA_DATA(Count,     rDest->bottom - rDest->top);
        SEND_PERMEDIA_DATA(Render,    __RENDER_TRAPEZOID_PRIMITIVE | 
                                      __RENDER_TEXTURED_PRIMITIVE);
    }

    SEND_PERMEDIA_DATA(DitherMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureAddressMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureColorMode, __PERMEDIA_DISABLE);
    SEND_PERMEDIA_DATA(TextureReadMode, __PERMEDIA_DISABLE);

    COMMITDMAPTR();
    FLUSHDMA();

}   // PermediaStretchCopyBlt 

//--------------------------------------------------------------------------
//
// PermediaSourceChromaBlt
//
// Does a blit through the texture unit to allow chroma keying.
// Note the unpacking of the colour key to fit into the Permedia format.
//
//--------------------------------------------------------------------------

VOID 