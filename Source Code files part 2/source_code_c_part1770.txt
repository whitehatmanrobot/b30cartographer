     ppi->pfd.iCharset = *(BYTE *)pszT++;
                        }
                        else
                        {
                            ppi->pfd.bItalic  = FALSE;
                            ppi->pfd.iCharset = DEFAULT_CHARSET;
                        }

                        _Rstrcpyn(ppi->pfd.szFace, (LPTSTR)pszT, ARRAYSIZE(ppi->pfd.szFace));

#ifdef WINNT
                        // But if this is a SHELLFONT page and the font name is "MS Shell Dlg",
                        // then its font secretly gets morphed into MS Shell Dlg 2 (if
                        // all the other pages agree)...  The wackiness continues...
                        if (staticIsOS(OS_NT5) &&
                            (ppd->fFlags & PD_SHELLFONT) &&
                            IsPageInfoSHELLFONT(ppi) &&
                            lstrcmpi(ppi->pfd.szFace, TEXT("MS Shell Dlg")) == 0)
                        {
                            _Rstrcpyn(ppi->pfd.szFace, TEXT("MS Shell Dlg 2"), ARRAYSIZE(ppi->pfd.szFace));
                        }
#endif
                        //
                        //  USER quirk #2: If the font height is 0x7FFF, then
                        //  USER really uses the MessageBox font and no font
                        //  information is stored in the dialog template.
                        //  Win95's dialog template converter doesn't support
                        //  this, so we won't either.

                    }
#else
                    else
                    {
                        // Get the caption string from the dialog template, only
                        //
                        LPBYTE pszT;

                        if (ppi->bDialogEx)
                            pszT = (LPBYTE) (pDlgExTemplate + 1);
                        else
                            pszT = (LPBYTE) (pDlgTemplate + 1);

                        // The menu name is either 0xffff followed by a word, or a string.
                        //
                        switch (*(LPWORD)pszT) {
                        case 0xffff:
                            pszT += 2 * sizeof(WORD);
                            break;

                        default:
                            pszT += (_Rstrlen((LPTSTR)pszT) + 1) * sizeof(RESCHAR);
                            break;
                        }
                        //
                        // Now we are pointing at the class name.
                        //
                        pszT += (_Rstrlen((LPTSTR)pszT) + 1) * sizeof(RESCHAR);

                        _Rstrcpyn(ppi->szCaption, (LPTSTR)pszT, ARRAYSIZE(ppi->szCaption));
                    }
#endif
                }

                if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
                    return bResult;

                UnlockResource(hDlgTemplate);
            }
            FreeResource(hDlgTemplate);
        }
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("GetPageInfo - ERROR: FindResource() failed"));
    }
    return bResult;
}


//
//  Helper function that edits a dialog template in preparation for it
//  becoming a property sheet page.  This has been split out because
//  the legacy CreatePage function needs to do this, too.
//
//  Returns the place where the style was edited on success, or
//  NULL if we took an exception while editing the template.
//
//  The old style is returned in pdwSaveStyle so it can be replaced later.
//

LPDWORD
EditPropSheetTemplate(
    LPDLGTEMPLATE pDlgTemplate,
    LPDWORD pdwSaveStyle,
    BOOL fFlags)                        // PD_*
{
    DWORD lSaveStyle;
    DWORD dwNewStyle;
    LPDWORD pdwStyle;
    LPDLGEXTEMPLATE pDlgExTemplate = (LPDLGEXTEMPLATE) pDlgTemplate;

    try {
        //
        // We need to save the SETFONT, LOCALEDIT, and CLIPCHILDREN
        // flags.
        //
        if (pDlgExTemplate->wSignature == 0xFFFF)
        {
            pdwStyle = &pDlgExTemplate->dwStyle;
        }
        else
        {
            pdwStyle = &pDlgTemplate->style;
        }

        lSaveStyle = *pdwStyle;
        *pdwSaveStyle = lSaveStyle;

        dwNewStyle = (lSaveStyle & (DS_SHELLFONT | DS_LOCALEDIT | WS_CLIPCHILDREN))
                                    | WS_CHILD | WS_TABSTOP | DS_3DLOOK | DS_CONTROL;

#ifdef WINNT
        // If SHELLFONT has been turned off and this page uses it, then turn
        // it off.
        if (!(fFlags & PD_SHELLFONT) &&
            (dwNewStyle & DS_SHELLFONT) == DS_SHELLFONT)
            dwNewStyle &= ~DS_FIXEDSYS;     // Leave DS_USEFONT but lose FIXEDSYS
#endif

        *pdwStyle = dwNewStyle;

    } except (UnhandledExceptionFilter( GetExceptionInformation() )) {
        return NULL;
    }
    __endexcept

    return pdwStyle;
}

#ifdef UNICODE

void RethunkShadowStrings(PISP pisp)
{
    //
    //  Note:  Old code recomputed the entire UNICODE PROPSHEETHEADER
    //  from the ANSI shadow at certain points, in case
    //  the app edited the ANSI shadow.
    //
    //  So we do it too.  I need to ask Eric Flo why we did it in the
    //  first place.  Note that the algorithm is buggy - if the app
    //  edited any of the string fields (or any of the flags that
    //  gate the string fields), we both leak the original memory
    //  *and* fault when we try to free something that wasn't
    //  allocated via LocalAlloc.  We preserve the bug to be compatible
    //  with NT4.  (Snicker.)
    //
    DWORD dwSize = min(sizeof(PROPSHEETPAGE), pisp->_cpfx.pispShadow->_psp.dwSize);
    dwSize = min(dwSize, GETORIGINALSIZE(pisp));

    FreePropertyPageStrings(&pisp->_psp);
    hmemcpy(&pisp->_psp, &pisp->_cpfx.pispShadow->_psp, dwSize);
    //
    //  If this copy fails, we will carry on with happy NULL strings.
    //  So some strings are empty, boo-hoo.
    //
    EVAL(CopyPropertyPageStrings(&pisp->_psp, StrDup_AtoW));
}
#endif

//
//  This function creates a dialog box from the specified dialog template
// with appropriate style flags.
//
HWND NEAR PASCAL _CreatePageDialog(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LPDLGTEMPLATE pDlgTemplate)
{
    HWND hwndPage;
    LPARAM lParam;
    LPDWORD pdwStyle;
    DWORD lSaveStyle;

    DLGPROC pfnDlgProc;

    pdwStyle = EditPropSheetTemplate(pDlgTemplate, &lSaveStyle, ppd->fFlags);

    if (!pdwStyle)                  // error editing template
        return NULL;

    //
    //  Thunk the Dialog proc if we were created by x86 code on RISC.
    //

#ifdef WX86
    if (pisp->_pfx.dwInternalFlags & PSPI_WX86) {
        pfnDlgProc = (DLGPROC) Wx86ThunkProc( pisp->_psp.pfnDlgProc, (PVOID) 4, TRUE );

        if (pfnDlgProc == NULL)
            return NULL;
    }
    else
#endif
        pfnDlgProc = pisp->_psp.pfnDlgProc;

    //
    //  Decide what to pass as the lParam to the CreateDialogIndirectParam.
    //

#ifdef UNICODE
    //
    // If the caller was ANSI, then use the ANSI PROPSHEETPAGE.
    //
    if (HASANSISHADOW(pisp))
    {
        lParam = (LPARAM) &pisp->_cpfx.pispShadow->_psp;
    }

    else if (pisp->_psp.dwFlags & PSP_SHPAGE)
    {
        //
        //  PSP_SHPAGE is a special flag used by pre-IE5 shell32 only.
        //  See prshti.h for gory details.  If we get this far, it means
        //  that we need to pass the CLASSICPREFIX instead of the
        //  PROPSHEETPAGE.
        //
        lParam = (LPARAM)&pisp->_cpfx;
    }
    else
    {
        //
        //  Normal UNICODE caller gets the UNICODE PROPSHEETPAGE.
        //
        lParam = (LPARAM)&pisp->_psp;
    }
#else
    //
    //  ANSI caller gets the ANSI PROPSHEETHEADER (our only one).
    //
    lParam = (LPARAM)&pisp->_psp;
#endif

    //
    //  All set - go create it.
    //

#ifdef UNICODE

    if (HASANSISHADOW(pisp)) {
        hwndPage = CreateDialogIndirectParamA(
                        pisp->_psp.hInstance,
                        (LPCDLGTEMPLATE)pDlgTemplate,
                        hwndParent,
                        pfnDlgProc, lParam);
        RethunkShadowStrings(pisp);
    } else {
        hwndPage = CreateDialogIndirectParam(
                        pisp->_psp.hInstance,
                        (LPCDLGTEMPLATE)pDlgTemplate,
                        hwndParent,
                        pfnDlgProc, lParam);
    }

#else

    hwndPage = CreateDialogIndirectParam(
                    pisp->_psp.hInstance,
                    (LPCDLGTEMPLATE)pDlgTemplate,
                    hwndParent,
                    pfnDlgProc, lParam);

#endif

    //
    //  Restore the original dialog template style.
    //
    try {
        MwWriteDWORD((LPBYTE)pdwStyle, lSaveStyle);
    } except (UnhandledExceptionFilter( GetExceptionInformation() )) {

        if (hwndPage) {
            DestroyWindow(hwndPage);
        }
        return NULL;
    }
    __endexcept


    return hwndPage;
}


HWND _CreatePage(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LANGID langidMUI)
{
    HWND hwndPage = NULL; // NULL indicates an error

    if (!CallPropertyPageCallback(pisp, PSPCB_CREATE))
    {
        return NULL;
    }

#ifdef UNICODE
    if (HASANSISHADOW(pisp)) {
        RethunkShadowStrings(pisp);
    }
#endif

#if defined(WIN32) && !defined(WINNT)
    // Check if this is a proxy page for 16-bit page object.
    if (pisp->_psp.dwFlags & PSP_IS16)
    {
        // Yes, call 16-bit side of CreatePage();
        return CreatePage16(pisp->_psp.lParam, hwndParent);
    }
#endif
        
    if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
    {
        hwndPage=_CreatePageDialog(ppd, pisp, hwndParent, (LPDLGTEMPLATE)pisp->_psp.P_pResource);
    }
    else
    {
        HRSRC hRes;
        hRes = FindResourceExRetry(pisp->_psp.hInstance, RT_DIALOG, 
                                   pisp->_psp.P_pszTemplate, langidMUI);
        if (hRes)
        {
            HGLOBAL hDlgTemplate;
            hDlgTemplate = LoadResource(pisp->_psp.hInstance, hRes);
            if (hDlgTemplate)
            {
                const DLGTEMPLATE FAR * pDlgTemplate;
                pDlgTemplate = (LPDLGTEMPLATE)LockResource(hDlgTemplate);
                if (pDlgTemplate)
                {
                    ULONG cbTemplate=SizeofResource(pisp->_psp.hInstance, hRes);
                    LPDLGTEMPLATE pdtCopy = (LPDLGTEMPLATE)Alloc(cbTemplate);

                    ASSERT(cbTemplate>=sizeof(DLGTEMPLATE));

                    if (pdtCopy)
                    {
                        hmemcpy(pdtCopy, pDlgTemplate, cbTemplate);
                        hwndPage=_CreatePageDialog(ppd, pisp, hwndParent, pdtCopy);
                        Free(pdtCopy);
                    }

                    UnlockResource(hDlgTemplate);
                }
                FreeResource(hDlgTemplate);
            }
        }
    }

    return hwndPage;
}

//===========================================================================
//
//  Legacy crap
//
//  CreatePage is an internal entry point used by shell32 prior to NT5/IE5.
//
//  Win95's shell32 passes a PROPSHEETPAGEA.
//
//  WinNT's shell32 passes a CLASSICPREFIX + PROPSHEETPAGEW.
//
//  The kicker is that shell32 really doesn't need any property sheet page
//  features.  It's just too lazy to do some dialog style editing.
//
//

HWND WINAPI CreatePage(LPVOID hpage, HWND hwndParent)
{
    HWND hwndPage = NULL; // NULL indicates an error
    HRSRC hrsrc;
    LPPROPSHEETPAGE ppsp;

#ifdef WINNT
    //
    //  Move from the CLASSICPREFIX to the PROPSHEETHEADER.
    //
    ppsp = &CONTAINING_RECORD(hpage, ISP, _cpfx)->_psp;
#else
    //
    //  It's already a PROPSHEETHEADER.
    //
    ppsp = hpage;
#endif

    // Docfind2.c never passed these flags, so we don't need to implement them.
    ASSERT(!(ppsp->dwFlags & (PSP_USECALLBACK | PSP_IS16 | PSP_DLGINDIRECT)));

#ifdef WINNT
    hrsrc = FindResourceW(ppsp->hInstance, ppsp->P_pszTemplate, RT_DIALOG);
#else
    hrsrc = FindResourceA(ppsp->hInstance, (LPSTR)ppsp->P_pszTemplate, (LPSTR)RT_DIALOG);
#endif
    if (hrsrc)
    {
        LPCDLGTEMPLATE pDlgTemplate = LoadResource(ppsp->hInstance, hrsrc);
        if (pDlgTemplate)
        {
            //
            //  Make a copy of the template so we can edit it.
            //

            DWORD cbTemplate = SizeofResource(ppsp->hInstance, hrsrc);
            LPDLGTEMPLATE pdtCopy = (LPDLGTEMPLATE)Alloc(cbTemplate);

            ASSERT(cbTemplate>=sizeof(DLGTEMPLATE));

            if (pdtCopy)
            {
                DWORD dwScratch;

                hmemcpy(pdtCopy, pDlgTemplate, cbTemplate);
                if (EditPropSheetTemplate(pdtCopy, &dwScratch, PD_SHELLFONT))
                {

#ifdef WINNT
                    hwndPage = CreateDialogIndirectParamW(
                                    ppsp->hInstance,
                                    pdtCopy,
                                    hwndParent,
                                    ppsp->pfnDlgProc, (LPARAM)hpage);
#else
                    hwndPage = CreateDialogIndirectParamA(
                                    ppsp->hInstance,
                                    pdtCopy,
                                    hwndParent,
                                    ppsp->pfnDlgProc, (LPARAM)hpage);
#endif
                }
                Free(pdtCopy);
            }
        }
    }

    return hwndPage;
}

//  End of legacy crap
//
//===========================================================================

//
//  AllocPropertySheetPage
//
//  Allocate the memory into which we will dump a property sheet page.
//
//  Nothing is actually copied into the buffer.  The only thing interesting
//  is that the external HPROPSHEETPAGE is set up on the assumption that
//  we will not require a shadow.
//
//  We assume that we are allocating the memory for a non-shadow page.
//
PISP AllocPropertySheetPage(DWORD dwClientSize)
{
    PISP pisp;
    LPBYTE pbAlloc;

    //
    //  An ISP consists of the "above" part, the "below" part, and
    //  the baggage passed by the app.  Negative baggage is okay;
    //  it means we have a down-level app that doesn't know about
    //  pszHeaderTitle.
    //

    pbAlloc = LocalAlloc(LPTR, sizeof(pisp->above) + sizeof(pisp->below) +
                               (dwClientSize - sizeof(PROPSHEETPAGE)));

    if (!pbAlloc)
        return NULL;

    pisp = (PISP)(pbAlloc + sizeof(pisp->above));

#ifdef UNICODE
    //
    // Set up the CLASSICPREFIX fields.
    //
    pisp->_cpfx.pispMain = pisp;
    ASSERT(pisp->_cpfx.pispShadow == NULL);
#endif

    //
    //  Assume no shadow - The app gets the PISP itself.
    //

    pisp->_pfx.hpage = (HPROPSHEETPAGE)pisp;

    return pisp;
}

#ifdef UNICODE

//
//  Helper function during page creation.  The incoming string is really
//  an ANSI string.  Thunk it to UNICODE.  Fortunately, we already have
//  another helper function that does the work.
//
STDAPI_(LPTSTR) StrDup_AtoW(LPCTSTR ptsz)
{
    return ProduceWFromA(CP_ACP, (LPCSTR)ptsz);
}
#endif

//
//  CreatePropertySheetPage
//
//  Where HPROPSHEETPAGEs come from.
//
//  The fNeedShadow parameter means "The incoming LPCPROPSHEETPAGE is in the
//  opposite character set from what you implement natively".
//
//  If we are compiling UNICODE, then fNeedShadow is TRUE if the incoming
//  LPCPROPSHEETPAGE is really an ANSI property sheet page.
//
//  If we are compiling ANSI-only, then fNeedShadow is always FALSE because
//  we don't support UNICODE in the ANSI-only version.
//
#ifdef UNICODE
HPROPSHEETPAGE WINAPI _CreatePropertySheetPage(LPCPROPSHEETPAGE psp, BOOL fNeedShadow, BOOL fWx86)
#else
HPROPSHEETPAGE WINAPI CreatePropertySheetPage(LPCPROPSHEETPAGE psp)
#define fNeedShadow FALSE
#endif
{
    PISP pisp;
    DWORD dwSize;

    ASSERT(PROPSHEETPAGEA_V1_SIZE == PROPSHEETPAGEW_V1_SIZE);
    ASSERT(sizeof(PROPSHEETPAGEA) == sizeof(PROPSHEETPAGEW));

    if ((psp->dwSize < MINPROPSHEETPAGESIZE) ||
#ifndef MAINWIN                                         // because of diff. in MAX_PATH 
        (psp->dwSize > 4096) ||                         // or the second version     
#endif
        (psp->dwFlags & ~PSP_ALL))                      // bogus flag used
        return NULL;

    //
    // The PROPSHEETPAGE structure can be larger than the
    // defined size.  This allows ISV's to place private
    // data at the end of the structure.  The ISP structure
    // consists of some private fields and a PROPSHEETPAGE
    // structure.  Calculate the size of the private fields,
    // and then add in the dwSize field to determine the
    // amount of memory necessary.
    //

    //
    //  An ISP consists of the "above" part, the "below" part, and
    //  the baggage passed by the app.  Negative baggage is okay;
    //  it means we have a down-level app that doesn't know about
    //  pszHeaderTitle.
    //

    //
    //  If we have an "other" client, then the native side of the
    //  property sheet doesn't carry any baggage.  It's just a
    //  plain old PROPSHEETPAGE.
    //

    dwSize = fNeedShadow ? sizeof(PROPSHEETPAGE) : psp->dwSize;
    pisp = AllocPropertySheetPage(dwSize);

    if (pisp)
    {
        STRDUPPROC pfnStrDup;

#ifdef WX86
        //
        //  We we're being called by Wx86, set the flag so we remember.
        //

        if ( fWx86 ) {
            pisp->_pfx.dwInternalFlags |= PSPI_WX86;
        }
#endif

        SETORIGINALSIZE(pisp, dwSize);

        //
        // Bulk copy the contents of the PROPSHEETPAGE, or
        // as much of it as the app gave us.
        //
        hmemcpy(&pisp->_psp, psp, min(dwSize, psp->dwSize));

        //
        // Decide how to copy the strings
        //
#ifdef UNICODE
        if (fNeedShadow)
            pfnStrDup = StrDup_AtoW;
        else
#endif
            pfnStrDup = StrDup;

        // Now copy them
        if (!CopyPropertyPageStrings(&pisp->_psp, pfnStrDup))
            goto ExitStrings;

#ifdef UNICODE
        if (fNeedShadow)
        {
            PISP pispAnsi = AllocPropertySheetPage(psp->dwSize);
            if (!pispAnsi)
                goto ExitShadow;

            //
            //  Copy the entire client PROPSHEETPAGE, including the
            //  baggage.
            //
            hmemcpy(&pispAnsi->_psp, psp, psp->dwSize);

            //
            //  Hook the two copies to point to each other.
            //
            pisp->_cpfx.pispShadow = pispAnsi;
            pispAnsi->_cpfx.pispShadow = pispAnsi;
            pispAnsi->_cpfx.pispMain = pisp;

            //
            //  If there is a shadow, then the
            //  external handle is the ANSI shadow.
            //
            ASSERT(pispAnsi->_pfx.hpage == (HPROPSHEETPAGE)pispAnsi);
            pisp->_pfx.hpage = (HPROPSHEETPAGE)pispAnsi;

            //
            //  Okay, now StrDupA them strings.
            //
            if (!CopyPropertyPageStrings(&pispAnsi->_psp, (STRDUPPROC)StrDupA))
                goto ExitShadowStrings;
        }
#endif

        //
        // Increment the reference count to the parent object.
        //

        if (HASREFPARENT(pisp))
            InterlockedIncrement((LPLONG)pisp->_psp.pcRefParent);

        //
        //  Welcome to the world.
        //
        CallPropertyPageCallback(pisp, PSPCB_ADDREF);

        return ExternalizeHPROPSHEETPAGE(pisp);
    }
    else
    {
        return NULL;
    }

#ifdef UNICODE
ExitShadowStrings:
    FreePropertyPageStrings(&pisp->_cpfx.pispShadow->_psp);
    FreePropertyPageStruct(pisp->_cpfx.pispShadow);
ExitShadow:;
#endif
ExitStrings:
    FreePropertyPageStrings(&pisp->_psp);
    FreePropertyPageStruct(pisp);
    return NULL;
}
#undef fNeedShadow

#ifdef UNICODE

HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW psp)
{
    BOOL fWx86 = FALSE;

#ifdef WX86
    fWx86 = Wx86IsCallThunked();
#endif

    return _CreatePropertySheetPage(psp, FALSE, fWx86);
}

HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA psp)
{
    BOOL fWx86 = FALSE;

#ifdef WX86
    fWx86 = Wx86IsCallThunked();
#endif

    return _CreatePropertySheetPage((LPCPROPSHEETPAGE)psp, TRUE, fWx86);
}

#else

HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW psp)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}

#endif

#ifdef UNICODE

// HACK FOR HIJAAK 95!
//
// Instead of creating
// property sheet pages with CreatePropertySheetPage, they merely
// take a pointer to a PROPSHEETPAGE structure and cast it to
// HPROPSHEETPAGE.  They got away with this on Win95 because Win95's
// HPROPSHEETPAGE actually was 95% identical to a PROPSHEETPAGE.
// (The missing 5% causes RIPs at property sheet destruction, which
// Hijaak no doubt ignored.)
//
// On NT and IE5, this coincidence is not true.
//
// So validate that what we have is really a property sheet
// structure by checking if it's on the heap at the
// right place.  If not, then make one.
//

HPROPSHEETPAGE WINAPI _Hijaak95Hack(LPPROPDATA ppd, HPROPSHEETPAGE hpage)
{
    if (hpage && !LocalSize(PropSheetBase(hpage))) {
        // SLACKERS!  Have to call CreatePropertySheetPage for them
        RIPMSG(0, "App passed HPROPSHEETPAGE not created by us; trying to cope");
        hpage = _CreatePropertySheetPage((LPCPROPSHEETPAGE)hpage,
                                         ppd->fFlags & PD_NEEDSHADOW,
                                         ppd->fFlags & PD_WX86);
    }
    return hpage;
}
#endif

#if 0

extern BOOL WINAPI GetPageInfo16(HPROPSHEETPAGE16 hpage, LPTSTR pszCaption, int cbCaption, LPPOINT ppt, HICON FAR * phIcon, BOOL FAR* bRTL);

extern BOOL WINAPI GetPageInfo16ME(HPROPSHEETPAGE16 hpage, LPTSTR pszCaption, int cbCaption, LPPOINT ppt, HICON FAR * phIcon, BOOL FAR* bRTL)
{
    return GetPageInfo16(hpage, pszCaption, cbCaption, ppt, phIcon, bRTL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\progress.c ===
/*-----------------------------------------------------------------------
**
** Progress.c
**
** A "gas gauge" type control for showing application progress.
**
**
** BUGBUG: need to implement the block style per UI style guidelines
**
**-----------------------------------------------------------------------*/
#include "ctlspriv.h"

// BUGBUG raymondc - should Process control support __int64 on Win64?

typedef struct {
    HWND hwnd;
    DWORD dwStyle;
    int iLow, iHigh;
    int iPos;
    int iStep;
    HFONT hfont;
    COLORREF _clrBk;
    COLORREF _clrBar;
} PRO_DATA, NEAR *PPRO_DATA;    // ppd

LRESULT CALLBACK ProgressWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);


#pragma code_seg(CODESEG_INIT)

BOOL FAR PASCAL InitProgressClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, s_szPROGRESS_CLASS, &wc)) {
#ifndef WIN32
        extern LRESULT CALLBACK _ProgressWndProc(HWND, UINT, WPARAM, LPARAM);
        wc.lpfnWndProc        = _ProgressWndProc;
#else
        wc.lpfnWndProc        = ProgressWndProc;
#endif
        wc.lpszClassName    = s_szPROGRESS_CLASS;
        wc.style            = CS_GLOBALCLASS | CS_HREDRAW | CS_VREDRAW;
        wc.hInstance        = hInstance;    // use DLL instance if in DLL
        wc.hIcon            = NULL;
        wc.hCursor            = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszMenuName        = NULL;
        wc.cbWndExtra        = sizeof(PPRO_DATA);    // store a pointer
        wc.cbClsExtra        = 0;

        if (!RegisterClass(&wc))
            return FALSE;
    }
    return TRUE;
}

#pragma code_seg()


int NEAR PASCAL UpdatePosition(PPRO_DATA ppd, int iNewPos, BOOL bAllowWrap)
{
    int iPosOrg = ppd->iPos;
    UINT uRedraw = RDW_INVALIDATE | RDW_UPDATENOW;

    if (ppd->iLow == ppd->iHigh)
        iNewPos = ppd->iLow;

    if (iNewPos < ppd->iLow) {
        if (!bAllowWrap)
            iNewPos = ppd->iLow;
        else {
            iNewPos = ppd->iHigh - ((ppd->iLow - iNewPos) % (ppd->iHigh - ppd->iLow));
            // wrap, erase old stuff too
            uRedraw |= RDW_ERASE;
        }
    }
    else if (iNewPos > ppd->iHigh) {
        if (!bAllowWrap)
            iNewPos = ppd->iHigh;
        else {
            iNewPos = ppd->iLow + ((iNewPos - ppd->iHigh) % (ppd->iHigh - ppd->iLow));
            // wrap, erase old stuff too
            uRedraw |= RDW_ERASE;
        }
    }

    // if moving backwards, erase old version
    if (iNewPos < iPosOrg)
        uRedraw |= RDW_ERASE;

    if (iNewPos != ppd->iPos) {
        ppd->iPos = iNewPos;
        // paint, maybe erase if we wrapped
        RedrawWindow(ppd->hwnd, NULL, NULL, uRedraw);

        MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ppd->hwnd, OBJID_CLIENT, 0);
    }
    return iPosOrg;
}

#define HIGHBG g_clrHighlight
#define HIGHFG g_clrHighlightText
#define LOWBG g_clrBtnFace
#define LOWFG g_clrBtnText

void NEAR PASCAL ProPaint(PPRO_DATA ppd, HDC hdcIn)
{
    int x, dxSpace, dxBlock, nBlocks, i;
    HDC    hdc;
    RECT rc, rcClient;
    PAINTSTRUCT ps;
    int iStart, iEnd;
    // RECT rcLeft, rcRight;
    // TCHAR ach[40];
    // int xText, yText, cText;
    // HFONT hFont;
    // DWORD dw;

    if (hdcIn == NULL)
        hdc = BeginPaint(ppd->hwnd, &ps);
    else
        hdc = hdcIn;

    GetClientRect(ppd->hwnd, &rcClient);

    //  give 1 pixel around the bar
    InflateRect(&rcClient, -1, -1);
    rc = rcClient;


    if (ppd->dwStyle & PBS_VERTICAL) {
        iStart = rc.top;
        iEnd = rc.bottom;
        dxBlock = (rc.right - rc.left) * 2 / 3;
    } else {
        iStart = rc.left;
        iEnd = rc.right;
        dxBlock = (rc.bottom - rc.top) * 2 / 3;
    }

    x = MulDiv(iEnd - iStart, ppd->iPos - ppd->iLow, ppd->iHigh - ppd->iLow);

    dxSpace = 2;
    if (dxBlock == 0)
        dxBlock = 1;    // avoid div by zero

    if (ppd->dwStyle & PBS_SMOOTH) {
        dxBlock = 1;
        dxSpace = 0;
    }

    nBlocks = (x + (dxBlock + dxSpace) - 1) / (dxBlock + dxSpace); // round up

    for (i = 0; i < nBlocks; i++) {

        if (ppd->dwStyle & PBS_VERTICAL) {

            rc.top = rc.bottom - dxBlock;

            // are we past the end?
            if (rc.bottom <= rcClient.top)
                break;

            if (rc.top <= rcClient.top)
                rc.top = rcClient.top + 1;

        } else {
            rc.right = rc.left + dxBlock;

            // are we past the end?
            if (rc.left >= rcClient.right)
                break;

            if (rc.right >= rcClient.right)
                rc.right = rcClient.right - 1;
        }

        if (ppd->_clrBar == CLR_DEFAULT)
            FillRectClr(hdc, &rc, g_clrHighlight);
        else
            FillRectClr(hdc, &rc, ppd->_clrBar);


        if (ppd->dwStyle & PBS_VERTICAL) {
            rc.bottom = rc.top - dxSpace;
        } else {
            rc.left = rc.right + dxSpace;
        }
    }

    if (hdcIn == NULL)
        EndPaint(ppd->hwnd, &ps);
}

LRESULT NEAR PASCAL Progress_OnCreate(HWND hWnd, LPCREATESTRUCT pcs)
{
    PPRO_DATA ppd = (PPRO_DATA)LocalAlloc(LPTR, sizeof(*ppd));
    if (!ppd)
        return -1;

    // remove ugly double 3d edge
    SetWindowPtr(hWnd, 0, ppd);
    ppd->hwnd = hWnd;
    ppd->iHigh = 100;        // default to 0-100
    ppd->iStep = 10;        // default to step of 10
    ppd->dwStyle = pcs->style;
    ppd->_clrBk = CLR_DEFAULT;
    ppd->_clrBar = CLR_DEFAULT;

#ifdef DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0)
        ppd->dwStyle |= PBS_SMOOTH;

    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_MENU) < 0)  {
        ppd->dwStyle |= PBS_VERTICAL;
        SetWindowPos(hWnd, NULL, 0, 0, 40, 100, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
#endif

    // hack of the 3d client edge that WM_BORDER implies in dialogs
    // add the 1 pixel static edge that we really want
    SetWindowLong(hWnd, GWL_EXSTYLE, (pcs->dwExStyle & ~WS_EX_CLIENTEDGE) | WS_EX_STATICEDGE);

    if (!(pcs->dwExStyle & WS_EX_STATICEDGE))
        SetWindowPos(hWnd, NULL, 0,0,0,0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);

    return 0;
}

LRESULT CALLBACK ProgressWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int x;
    HFONT hFont;
    PPRO_DATA ppd = (PPRO_DATA)GetWindowPtr(hWnd, 0);

    switch (wMsg)
    {
    case WM_CREATE:
        CCCreateWindow();
        return Progress_OnCreate(hWnd, (LPCREATESTRUCT)lParam);

    case WM_DESTROY:
        CCDestroyWindow();
        if (ppd)
            LocalFree((HLOCAL)ppd);
        break;

        case WM_SYSCOLORCHANGE:
            InitGlobalColors();
            InvalidateRect(hWnd, NULL, TRUE);
            break;

    case WM_SETFONT:
        hFont = ppd->hfont;
        ppd->hfont = (HFONT)wParam;
        return (LRESULT)(UINT_PTR)hFont;

    case WM_GETFONT:
            return (LRESULT)(UINT_PTR)ppd->hfont;

    case PBM_GETPOS:
        return ppd->iPos;

    case PBM_GETRANGE:
        if (lParam) {
            PPBRANGE ppb = (PPBRANGE)lParam;
            ppb->iLow = ppd->iLow;
            ppb->iHigh = ppd->iHigh;
        }
        return (wParam ? ppd->iLow : ppd->iHigh);

    case PBM_SETRANGE:
        // win95 compat
        wParam = LOWORD(lParam);
        lParam = HIWORD(lParam);
        // fall through

    case PBM_SETRANGE32:
    {
        LRESULT lret = MAKELONG(ppd->iLow, ppd->iHigh);

        // only repaint if something actually changed
        if ((int)wParam != ppd->iLow || (int)lParam != ppd->iHigh)
        {
            ppd->iHigh = (int)lParam;
            ppd->iLow  = (int)wParam;
            // force an invalidation/erase but don't redraw yet
            RedrawWindow(ppd->hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
            UpdatePosition(ppd, ppd->iPos, FALSE);
        }
        return lret;
    }

    case PBM_SETPOS:
        return (LRESULT)UpdatePosition(ppd, (int) wParam, FALSE);

    case PBM_SETSTEP:
        x = ppd->iStep;
        ppd->iStep = (int)wParam;
        return (LRESULT)x;

    case PBM_STEPIT:
        return (LRESULT)UpdatePosition(ppd, ppd->iStep + ppd->iPos, TRUE);

    case PBM_DELTAPOS:
        return (LRESULT)UpdatePosition(ppd, ppd->iPos + (int)wParam, FALSE);

    case PBM_SETBKCOLOR:
    {
        COLORREF clr = ppd->_clrBk;
        ppd->_clrBk = (COLORREF)lParam;
        InvalidateRect(hWnd, NULL, TRUE);
        return clr;
    }

    case PBM_SETBARCOLOR:
    {
        COLORREF clr = ppd->_clrBar;
        ppd->_clrBar = (COLORREF)lParam;
        InvalidateRect(hWnd, NULL, TRUE);
        return clr;
    }

    case WM_PRINTCLIENT:
    case WM_PAINT:
        ProPaint(ppd,(HDC)wParam);
        break;

    case WM_ERASEBKGND:
        if (ppd) {
            if (ppd->_clrBk != CLR_DEFAULT) {
                RECT rc;
                GetClientRect(hWnd, &rc);
                FillRectClr((HDC)wParam, &rc, ppd->_clrBk);
                return 1;
            }
        }
        goto DoDefault;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_PROGRESS;
        goto DoDefault;

DoDefault:
    default:
        return DefWindowProc(hWnd,wMsg,wParam,lParam);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\pager.h ===
//---------------------------------------------------------------------------------------
//  File : Pager.h
//  Description :
//        This is the header file for the pager control
//---------------------------------------------------------------------------------------
#include "ccontrol.h"

#define PGMP_RECALCSIZE  200

//---------------------------------------------------------------------------------------
class CPager : public CControl
{
public:
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT PagerWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT PagerDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
protected:
    
    CPager();
    
    //Function Members    
    DWORD _PGFToPGNDirection(DWORD dwDir);
    void _Scroll(DWORD dwDirection);
    void _SetChildPos(RECT * prcChild, UINT uFlags);
    void _NeedScrollbars(RECT rc);
    int  _GetPage(DWORD dwDirection);
    void _OnSetChild(HWND hwnd, HWND hwndChild);
    void _OnSetPos(int iPos);
    int  _OnGetPos();
    int  _OnSetBorder(int iBorder);
    int  _OnSetButtonSize(int iSize);
    void _OnReCalcSize();
    void _OnLButtonChange(UINT uMsg,LPARAM lParam);
    void _OnMouseMove(WPARAM wParam,LPARAM lParam);
    void _DrawButton(HDC hdc,int button);
    void _DrawBlank(HDC hdc,int button);
    BOOL _OnPrint(HDC hdc,UINT uFlags);
    int  _HitTest(int x , int y);
    int  _HitTestScreen(LPPOINT ppt);
    int  _HitTestCursor();
    void _GetChildSize();
    RECT _GetButtonRect(int iButton);
    void _OnMouseLeave();
    inline _GetButtonSize();
    DWORD  _GetButtonState(int iButton);
    void _OnTimer(UINT id);
    LRESULT _DragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
    void _KillTimer();

    virtual void v_OnPaint(HDC hdc);
    virtual LRESULT v_OnCreate();
    virtual void v_OnSize(int x, int y);
    virtual void v_OnNCPaint();
    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam);
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam);    
    virtual BOOL v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT *plres);

    //Data Members
    HWND    _hwndChild;    
    POINT   _ptPos;
    POINT   _ptLastMove;
    BITBOOL _fReCalcSend:1;
    BITBOOL _fForwardMouseMsgs:1;
    BITBOOL _fBkColorSet:1;
    BITBOOL _fTimerSet :1;
    BITBOOL _fOwnsButtonDown :1;
    int     _iButtonTrack;
    RECT    _rcDefClient; // this is our "natural" client rect if we didn't mess with nccalc
    DWORD   _dwState[2];  // State of the two scroll buttons
    RECT    _rcChildIdeal; // our child's ideal size
    int     _iButtonSize;
    HDRAGPROXY  _hDragProxy;

    COLORREF _clrBk;
    int _iBorder;

    UINT _cLinesPerTimeout;
    UINT _cPixelsPerLine;
    UINT _cTimeout;
};
//---------------------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\prsht.c ===
#include "ctlspriv.h"
#include "help.h" // Help IDs
#include "prshti.h"

#include "dlgcvt.h"

#ifdef WX86
#include <wx86ofl.h>
#endif

#ifdef UNIX
#include <mainwin.h>
#endif

#define FLAG_CHANGED    0x0001
#define DEFAULTHEADERHEIGHT    58   // in pixels
#define DEFAULTTEXTDIVIDERGAP  5
#define DEFAULTCTRLWIDTH       501   // page list window in new wizard style
#define DEFAULTCTRLHEIGHT      253   // page list window in new wizard style
#define TITLEX                 22
#define TITLEY                 10
#define SUBTITLEX              44
#define SUBTITLEY              25

// fixed sizes for the bitmap painted in the header section
#define HEADERBITMAP_Y            5
#define HEADERBITMAP_WIDTH        49
#define HEADERBITMAP_CXBACK       (5 + HEADERBITMAP_WIDTH)
#define HEADERBITMAP_HEIGHT       49                
#define HEADERSUBTITLE_WRAPOFFSET 10

// Fixed sizes for the watermark bitmap (Wizard97IE5 style)
#define BITMAP_WIDTH  164
#define BITMAP_HEIGHT 312

#define DRAWTEXT_WIZARD97FLAGS (DT_LEFT | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL)

LPVOID WINAPI MapSLFix(HANDLE);
VOID WINAPI UnMapSLFixArray(int, HANDLE *);

LRESULT CALLBACK WizardWndProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);

#if  !defined(WIN32)
#ifdef FE_IME
typedef void *PVOID;
DWORD WINAPI GetCurrentThreadID(VOID);
DWORD WINAPI GetCurrentProcessID(VOID);
PVOID WINAPI ImmFindThreadLink(DWORD dwThreadID);
BOOL WINAPI ImmCreateThreadLink(DWORD dwPid, DWORD dwTid);
#endif
#endif

void    NEAR PASCAL ResetWizButtons(LPPROPDATA ppd);

typedef struct  // tie
{
    TC_ITEMHEADER   tci;
    HWND            hwndPage;
    UINT            state;
} TC_ITEMEXTRA;

#define CB_ITEMEXTRA (sizeof(TC_ITEMEXTRA) - sizeof(TC_ITEMHEADER))
#define IS_WIZARDPSH(psh) ((psh).dwFlags & (PSH_WIZARD | PSH_WIZARD97 | PSH_WIZARD_LITE))
#define IS_WIZARD(ppd) IS_WIZARDPSH(ppd->psh)

void NEAR PASCAL PageChange(LPPROPDATA ppd, int iAutoAdj);
void NEAR PASCAL RemovePropPageData(LPPROPDATA ppd, int nPage);
HRESULT GetPageLanguage(PISP pisp, WORD *pwLang);
UINT GetDefaultCharsetFromLang(LANGID wLang);
#ifdef WINNT
LANGID NT5_GetUserDefaultUILanguage(void);
#endif

//
// IMPORTANT:  The IDHELP ID should always be LAST since we just subtract
// 1 from the number of IDs if no help in the page.
// IDD_APPLYNOW should always be the FIRST ID for standard IDs since it
// is sometimes not displayed and we'll start with index 1.
//
const static int IDs[] = {IDOK, IDCANCEL, IDD_APPLYNOW, IDHELP};
const static int WizIDs[] = {IDD_BACK, IDD_NEXT, IDD_FINISH, IDCANCEL, IDHELP};
const static WORD wIgnoreIDs[] = {IDD_PAGELIST, IDD_DIVIDER, IDD_TOPDIVIDER};

// Prsht_PrepareTemplate action matrix. Please do not change without contacting [msadek]...

const PSPT_ACTION g_PSPT_Action [PSPT_TYPE_MAX][PSPT_OS_MAX][PSPT_OVERRIDE_MAX]={
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_WIN9XCOMPAT,  // PSPT_TYPE_MIRRORED, PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_WIN9XCOMPAT,  // PSPT_TYPE_MIRRORED, PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_MIRRORED, PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_MIRRORED, PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENABLED,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENABLED,  PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_ENABLED,  PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN95_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_LOADENGLISH,  // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WIN98_BIDI, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT4_ENA, PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_LOADENGLISH,  // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_FLIP,         // PSPT_TYPE_ENGLISH,  PSPT_OS_WINNT5,     PSPT_OVERRIDE_USEPAGELANG
    PSPT_ACTION_NOACTION,     // PSPT_TYPE_ENGLISH,  PSPT_OS_OTHER,      PSPT_OVERRIDE_NOOVERRIDE
    PSPT_ACTION_NOMIRRORING,  // PSPT_TYPE_ENGLISH,  PSPT_OS_OTHER,      PSPT_OVERRIDE_USEPAGELANG
    };

void NEAR PASCAL _SetTitle(HWND hDlg, LPPROPDATA ppd)
{
    TCHAR szFormat[50];
    TCHAR szTitle[128];
    TCHAR szTemp[128 + 50];
    LPCTSTR pCaption = ppd->psh.pszCaption;

    if (IS_INTRESOURCE(pCaption)) {
        LoadString(ppd->psh.hInstance, (UINT)LOWORD(pCaption), szTitle, ARRAYSIZE(szTitle));
        pCaption = (LPCTSTR)szTitle;
    }

    if (ppd->psh.dwFlags & PSH_PROPTITLE) {
        if (*pCaption == 0)
        {
            // Hey, no title, we need a different resource for localization
            LocalizedLoadString(IDS_PROPERTIES, szTemp, ARRAYSIZE(szTemp));
            pCaption = szTemp;
        }
        else
        {
            LocalizedLoadString(IDS_PROPERTIESFOR, szFormat, ARRAYSIZE(szFormat));
            if ((lstrlen(pCaption) + 1 + lstrlen(szFormat) + 1) < ARRAYSIZE(szTemp)) {
                wsprintf(szTemp, szFormat, pCaption);
                pCaption = szTemp;
            }
        }
    }
#ifdef WINDOWS_ME
    if(ppd->psh.dwFlags & PSH_RTLREADING) {
        SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_RTLREADING);
        }
#endif // WINDOWS_ME
    SetWindowText(hDlg, pCaption);
}

BOOL _SetHeaderFonts(HWND hDlg, LPPROPDATA ppd)
{
    HFONT   hFont;
    LOGFONT LogFont;

    GetObject(GetWindowFont(hDlg), sizeof(LogFont), &LogFont);

    LogFont.lfWeight = FW_BOLD;
    if ((hFont = CreateFontIndirect(&LogFont)) == NULL)
    {
        ppd->hFontBold = NULL;
        return FALSE;
    }
    ppd->hFontBold = hFont;
    // Save the font as a window prop so we can delete it later
    return TRUE;
}

int _WriteHeaderTitle(LPPROPDATA ppd, HDC hdc, LPRECT prc, LPCTSTR pszTitle, BOOL bTitle, DWORD dwDrawFlags)
{
    LPCTSTR pszOut;
    int cch;
    int cx, cy;
    TCHAR szTitle[MAX_PATH*4];
    HFONT hFontOld = NULL;
    HFONT hFont;
    int yDrawHeight = 0;

    if (IS_INTRESOURCE(pszTitle))
    {
        LoadString(GETPPSP(ppd, ppd->nCurItem)->hInstance, (UINT)LOWORD(pszTitle), szTitle, ARRAYSIZE(szTitle));
        pszOut = szTitle;
    }
    else
        pszOut = pszTitle;

    cch = lstrlen(pszOut);

    if (bTitle && ppd->hFontBold)
        hFont = ppd->hFontBold;
    else
        hFont = GetWindowFont(ppd->hDlg);

    hFontOld = SelectObject(hdc, hFont);

    if (bTitle)
    {
        cx = TITLEX;
        cy = TITLEY;
        ExtTextOut(hdc, cx, cy, 0, prc, pszOut, cch, NULL);
    }
    else
    {
        RECT rcWrap;
        CopyRect(&rcWrap, prc);

        rcWrap.left = SUBTITLEX;
        rcWrap.top = ppd->ySubTitle;
        yDrawHeight = DrawText(hdc, pszOut, cch, &rcWrap, dwDrawFlags);
    }

    if (hFontOld)
        SelectObject(hdc, hFontOld);

    return yDrawHeight;
}

// In Wizard97 only:
// The subtitles user passed in could be larger than the two line spaces we give
// them, especially in localization cases. So here we go through all subtitles and
// compute the max space they need and set the header height so that no text is clipped
int _ComputeHeaderHeight(LPPROPDATA ppd, int dxMax)
{
    int dyHeaderHeight;
    int dyTextDividerGap;
    HDC hdc;
    dyHeaderHeight = DEFAULTHEADERHEIGHT;
    hdc = GetDC(ppd->hDlg);

    // First, let's get the correct text height and spacing, this can be used
    // as the title height and the between-lastline-and-divider spacing.
    {
        HFONT hFont, hFontOld;
        TEXTMETRIC tm;
        if (ppd->hFontBold)
            hFont = ppd->hFontBold;
        else
            hFont = GetWindowFont(ppd->hDlg);

        hFontOld = SelectObject(hdc, hFont);
        if (GetTextMetrics(hdc, &tm))
        {
            dyTextDividerGap = tm.tmExternalLeading;
            ppd->ySubTitle = max ((tm.tmHeight + tm.tmExternalLeading + TITLEY), SUBTITLEY);
        }
        else
        {
            dyTextDividerGap = DEFAULTTEXTDIVIDERGAP;
            ppd->ySubTitle = SUBTITLEY;
        }

        if (hFontOld)
            SelectObject(hdc, hFontOld);
    }

    // Second, get the subtitle text block height
    // should make into a function if shared
    {
        RECT rcWrap;
        UINT uPages;

        //
        //  WIZARD97IE5 subtracts out the space used by the header bitmap.
        //  WIZARD97IE4 uses the full width since the header bitmap
        //  in IE4 is a watermark and occupies no space.
        //
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
            rcWrap.right = dxMax;
        else
            rcWrap.right = dxMax - HEADERBITMAP_CXBACK - HEADERSUBTITLE_WRAPOFFSET;
        for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
        {
            PROPSHEETPAGE *ppsp = GETPPSP(ppd, uPages);
            if (!(ppsp->dwFlags & PSP_HIDEHEADER) &&
                 (ppsp->dwFlags & PSP_USEHEADERSUBTITLE))
            {
                int iSubHeaderHeight = _WriteHeaderTitle(ppd, hdc, &rcWrap, ppsp->pszHeaderSubTitle,
                    FALSE, DT_CALCRECT | DRAWTEXT_WIZARD97FLAGS);
                if ((iSubHeaderHeight + ppd->ySubTitle) > dyHeaderHeight)
                    dyHeaderHeight = iSubHeaderHeight + ppd->ySubTitle;
            }
        }
    }

    // If the header height has been recomputed, set the correct gap between
    // the text and the divider.
    if (dyHeaderHeight != DEFAULTHEADERHEIGHT)
    {
        ASSERT(dyHeaderHeight > DEFAULTHEADERHEIGHT);
        dyHeaderHeight += dyTextDividerGap;
    }

    ReleaseDC(ppd->hDlg, hdc);
    return dyHeaderHeight;
}

void MoveAllButtons(HWND hDlg, const int *pids, int idLast, int dx, int dy)
{
    do {
        HWND hCtrl;
        RECT rcCtrl;

        int iCtrl = *pids;
        hCtrl = GetDlgItem(hDlg, iCtrl);
        GetWindowRect(hCtrl, &rcCtrl);

        //
        // If the dialog wizard window is mirrored, then rcl.right
        // in terms of screen coord is the near edge (lead). [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hDlg))
            rcCtrl.left = rcCtrl.right;

        ScreenToClient(hDlg, (LPPOINT)&rcCtrl);
        SetWindowPos(hCtrl, NULL, rcCtrl.left + dx,
                     rcCtrl.top + dy, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
    } while(*(pids++) != idLast);
}

void NEAR PASCAL RemoveButton(HWND hDlg, int idRemove, const int *pids)
{
    int idPrev = 0;
    HWND hRemove;
    HWND hPrev;
    RECT rcRemove, rcPrev;
    int iWidth = 0;
    const int *pidRemove;

    // get the previous id
    for (pidRemove = pids; *pidRemove != idRemove; pidRemove++)
        idPrev = *pidRemove;


    if (idPrev) {
        hRemove = GetDlgItem(hDlg, idRemove);
        hPrev = GetDlgItem(hDlg, idPrev);
        GetWindowRect(hRemove, &rcRemove);
        GetWindowRect(hPrev, &rcPrev);

        //
        // If the dialog window is mirrored, then the prev button
        // will be ahead (to the right) of the button-to-be-removed.
        // As a result, the subtraction will be definitely negative,
        // so let's convert it to be positive. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hDlg))
            iWidth = rcPrev.right - rcRemove.right;
        else
            iWidth = rcRemove.right - rcPrev.right;
    }

    MoveAllButtons(hDlg, pids, idRemove, iWidth, 0);
    ShowWindow(hRemove, SW_HIDE);

    // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
    // WRONG - EnableWindow(hRemove, FALSE);
}

typedef struct LOGPALETTE256 {
    WORD    palVersion;
    WORD    palNumEntries;
    union {
        PALETTEENTRY rgpal[256];
        RGBQUAD rgq[256];
    } u;
} LOGPALETTE256;

HPALETTE PaletteFromBmp(HBITMAP hbm)
{
    LOGPALETTE256 pal;
    int i,n;
    HDC hdc;
    HPALETTE hpl;

    hdc = CreateCompatibleDC(NULL);
    SelectObject(hdc, hbm);
    n = GetDIBColorTable(hdc, 0, 256, pal.u.rgq);

    if (n)                          // DIB section with color table
    {
        // Palettes are such a hassle.  GetDIBColorTable returns RGBQUADs, whereas
        // LOGPALETTE wants PALETTEENTRYss, and the two are reverse-endian
        // of each other.
        for (i= 0 ; i < n; i++)
        {
            PALETTEENTRY pe;
            pe.peRed = pal.u.rgq[i].rgbRed;
            pe.peGreen = pal.u.rgq[i].rgbGreen;
            pe.peBlue = pal.u.rgq[i].rgbBlue;
            pe.peFlags = 0;
            pal.u.rgpal[i] = pe;
        }

        pal.palVersion = 0x0300;
        pal.palNumEntries = (WORD)n;

        hpl = CreatePalette((LPLOGPALETTE)&pal);
    }
    else                            // Not a DIB section or no color table
    {
        hpl = CreateHalftonePalette(hdc);
    }

    DeleteDC(hdc);
    return hpl;
}

// -------------- stolen from user code -------------------------------------
//
//  GetCharDimensions(hDC, psiz)
//
//  This function loads the Textmetrics of the font currently selected into
//  the given hDC and saves the height and Average char width of the font
//  (NOTE: the
//  AveCharWidth value returned by the text metrics call is wrong for
//  proportional fonts -- so, we compute them).
//
// -------------- stolen from user code --------------------------------------
TCHAR AveCharWidthData[52+1] = TEXT("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
void GetCharDimensions(HDC hDC, SIZE *psiz)
{
    TEXTMETRIC  tm;

    // Store the System Font metrics info.
    GetTextMetrics(hDC, &tm);

    if (!(tm.tmPitchAndFamily & TMPF_FIXED_PITCH)) // the name is opposite:)
        psiz->cx = tm.tmAveCharWidth;
    else
    {
        // Change from tmAveCharWidth.  We will calculate a true average as
        // opposed to the one returned by tmAveCharWidth. This works better
        // when dealing with proportional spaced fonts. -- ROUND UP
        if (GetTextExtentPoint32(hDC, AveCharWidthData, 52, psiz) == TRUE)
        {
            psiz->cx = ((psiz->cx / 26) + 1) / 2;
        }
        else
            psiz->cx = tm.tmAveCharWidth;
    }

    psiz->cy = tm.tmHeight;
}

//
//  It is a feature that USER considers keyboard accelerators live even if
//  the control is hidden.  This lets you put a hidden static in front of
//  a custom control to get an accelerator attached to the custom control.
//
//  Unfortunately, it means that the &F accelerator for "Finish" activates
//  the Finish button even when the Finish button is hidden.  The normal
//  workaround for this is to disable the control, but that doesn't work
//  because Microsoft PhotoDraw runs around and secretly hides and shows
//  buttons without going through PSM_SETWIZBUTTONS, so they end up showing
//  a disabled window and their wizard stops working.
//
//  So instead, we subclass the buttons and customize their WM_GETDLGCODE
//  so that when the control is hidden, they disable their accelerators.
//
LRESULT CALLBACK Prsht_ButtonSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LRESULT lres;


    switch (wm)
    {

    case WM_GETDLGCODE:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        if (!IsWindowVisible(hwnd))
        {
            // To remove yourself from the mnemonic search, you have to
            // return DLGC_WANTCHAR if you are give a NULL LPMSG pointer.
            // Normally, the dialog manager sends a real LPMSG containing
            // the message that just got received, but when it's poking
            // around looking for accelerators, it doesn't give you a
            // message at all.  It is in that case that you want to
            // say, "Hey, I will process the (nonexistent) message".
            // This tricks USER into thinking you're an edit control, so
            // it won't scan your for mnemonics.
            if ((LPMSG)lp == NULL)
                lres |= DLGC_WANTCHARS;

        }
        break;

    case WM_NCDESTROY:
        // Clean up subclass
        RemoveWindowSubclass(hwnd, Prsht_ButtonSubclassProc, 0);
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;

    default:
        lres = DefSubclassProc(hwnd, wm, wp, lp);
        break;
    }

    return lres;
}

void Prsht_SubclassButton(HWND hDlg, UINT idd)
{
    SetWindowSubclass(GetDlgItem(hDlg, idd), Prsht_ButtonSubclassProc, 0, 0);
}

//
// Because StrCmpIW(lstrcmpiW) converts unicode string to ansi depends on user locale
// on Win9x platform, we can't compare two different locale's unicode string properly.
// This is why we use small private helper function to compare limited DBCS font facename
//
BOOL CompareFontFaceW(LPCWSTR lpwz1, LPCWSTR lpwz2, BOOL fBitCmp)
{
#ifndef WINNT
    BOOL fRet = TRUE;   // Return FALSE if strings are same, otherwise return TRUE

    if (fBitCmp)
    {
        int iLen1, iLen2;

        iLen1 = lstrlenW(lpwz1);
        iLen2 = lstrlenW(lpwz2);
        if (iLen1 == iLen2)
        {
            int i;

            for (i = 0; i < iLen1; i++)
            {
                if (lpwz1[i] != lpwz2[i])
                    break;
            }

            if (i >= iLen1)
                fRet = FALSE;
        }
    }
    else
        fRet = lstrcmpiW(lpwz1, lpwz2);

    return fRet;
#else
    return lstrcmpiW(lpwz1, lpwz2);
#endif
}

// 
// GetPageFontMetrics
//
// synopsis: 
// 
// Get the real font metrics from PAGEFONTDATA. Used in InitPropSheetDlg() to
// calculate the physical page size based on the font specified in page templates
//
// fML is set if we are in here because of an ML scenario, in which case the
// font names need to be mapped.
//

BOOL GetPageFontMetrics(LPPROPDATA ppd, PPAGEFONTDATA ppfd, BOOL fML)
{
    LOGFONT    lf = {0};
    HFONT      hFont;
    HRESULT    fRc = FALSE;
    HDC        hdc;
    
    if (ppfd && (ppfd->PointSize > 0) && ppfd->szFace[0])
    {

        // font name mapping
        // should be done only for the platform less than NT5
        // NT5 is supposed to work with native typeface on any system locale.
        //
        if (!staticIsOS(OS_WIN2000ORGREATER) && fML)
        {
            // replace native font face name to single byte name for non-native platform
            typedef struct tagFontFace
            {
                BOOL fBitCmp;
                LPCWSTR lpEnglish;
                LPCWSTR lpNative;
            } FONTFACE, *LPFONTFACE;
    
            const static FONTFACE s_FontTbl[] = 
            {
                {   FALSE, L"MS Gothic", L"MS UI Gothic"                                   },
                {   TRUE,  L"MS Gothic", L"\xff2d\xff33 \xff30\x30b4\x30b7\x30c3\x30af"    },
                {   TRUE,  L"GulimChe",  L"\xad74\xb9bc"                                   },
                {   TRUE,  L"MS Song",   L"\x5b8b\x4f53"                                   },
                {   TRUE,  L"MingLiU",   L"\x65b0\x7d30\x660e\x9ad4"                       }
            };

            int i;

            for (i = 0; i < ARRAYSIZE(s_FontTbl); i++)
            {
                if (!CompareFontFaceW(ppfd->szFace, s_FontTbl[i].lpNative, s_FontTbl[i].fBitCmp))
                {
                    lstrcpynW(lf.lfFaceName, s_FontTbl[i].lpEnglish, ARRAYSIZE(lf.lfFaceName));
                    break;
                }
            }
            if (i >= ARRAYSIZE(s_FontTbl))
                lstrcpynW(lf.lfFaceName, ppfd->szFace, ARRAYSIZE(lf.lfFaceName));
        }
        else
            lstrcpynW(lf.lfFaceName, ppfd->szFace, ARRAYSIZE(lf.lfFaceName));

        // Try to use the cache
        if (ppfd->iCharset  == ppd->pfdCache.iCharset &&
            ppfd->bItalic   == ppd->pfdCache.bItalic &&
            ppfd->PointSize == ppd->pfdCache.PointSize &&
            lstrcmpiW(ppfd->szFace, ppd->pfdCache.szFace) == 0) {
            fRc = TRUE;
        } else {
            if (hdc = GetDC(ppd->hDlg))
            {
                lf.lfHeight = -MulDiv(ppfd->PointSize, GetDeviceCaps(hdc,LOGPIXELSY), 72);
                lf.lfCharSet = (BYTE)ppfd->iCharset;
                lf.lfItalic  = (BYTE)ppfd->bItalic;
                lf.lfWeight = FW_NORMAL;

                hFont = CreateFontIndirectW(&lf);
                if (hFont)
                {
                    HFONT hFontOld = SelectObject(hdc, hFont);

                    GetCharDimensions(hdc, &ppd->sizCache);
                    if (hFontOld)
                        SelectObject(hdc, hFontOld);

                    DeleteObject(hFont);

                    // Save these font metrics into the cache
                    ppd->pfdCache = *ppfd;
                    fRc = TRUE;
                }
                ReleaseDC(ppd->hDlg, hdc);

            }
        }
    }
    return fRc;
}

//
//  The "ideal page size" of a property sheet is the maximum size of all
//  pages.
//
//  GIPS_SKIPINTERIOR97HEIGHT and GIPS_SKIPEXTERIOR97HEIGHT selective
//  exclude Wiz97 pages from the height computation.  They are important
//  because interior pages are shorter than exterior pages by
//  ppd->cyHeaderHeight.
//

#define GIPS_SKIPINTERIOR97HEIGHT 1
#define GIPS_SKIPEXTERIOR97HEIGHT 2

void Prsht_GetIdealPageSize(LPPROPDATA ppd, PSIZE psiz, UINT flags)
{
    UINT uPages;

    *psiz = ppd->sizMin;

    for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
    {
        PISP pisp = GETPISP(ppd, uPages);
        int cy = pisp->_pfx.siz.cy;

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            if (pisp->_psp.dwFlags & PSP_HIDEHEADER)
            {
                if (flags & GIPS_SKIPEXTERIOR97HEIGHT) goto skip;
            }
            else
            {
                if (flags & GIPS_SKIPINTERIOR97HEIGHT) goto skip;
            }
        }

        if (psiz->cy < cy)
            psiz->cy = cy;

    skip:;
        if (psiz->cx < pisp->_pfx.siz.cx)
            psiz->cx = pisp->_pfx.siz.cx;
    }

}

#define IsMSShellDlgMapped(langid) (PRIMARYLANGID(langid) == LANG_JAPANESE)

//
//  Given a page, decide what size it wants to be and save it in the
//  pisp->_pfx.siz.
//
void Prsht_ComputeIdealPageSize(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi)
{
    BOOL fUsePageFont;

    // pressume page and frame dialog are in same character set
    LANGID wPageLang = ppd->wFrameLang;
    int    iPageCharset = DEFAULT_CHARSET;

    if (SUCCEEDED(GetPageLanguage(pisp, &wPageLang)))
    {
        // GetPageLanguage fails if page is marked PSP_DLGINDIRECT;
        // we'll try to recover from that later.  For now,
        // we leave pagelang to DEFAULT_CHARSET and see if we can take
        // the charset info from template EX.
        //
        // if PSH_USEPAGELANG is specified, we can assume that
        // page charset == frame charset and no need for ML adjustment
        // *except for* the case of NT Japanese version that replaces
        // frame's MS Shell Dlg to their native font. We handle this
        // exception later where we set up fUsePageFont; 
        //
        if (!(ppd->psh.dwFlags & PSH_USEPAGELANG)
            && wPageLang != ppd->wFrameLang)
        {
            iPageCharset  = GetDefaultCharsetFromLang(wPageLang);
        }
        else
            iPageCharset  = ppd->iFrameCharset;
    }

    // Use the font in the page if any of these conditions are met:
    //
    // A) It's a SHELLFONT page.  Do this even if the font is not
    //    "MS Shell Dlg 2".  This gives apps a way to specify that
    //    their custom-font page should be measured against the
    //    font in the page rather than in the frame font.
    //
    // B) ML scenario - complicated original comment below...
    //
    //  1) we've detected lang in the caller's resource and
    //  it's different from the frame dialog
    //  2) the caller's page doesn't have lang info or we've
    //  failed to get it (iPageCharset == DEFAULT_CHARSET),
    // then we find the page is described with DLGTEMPLATEEX
    // and has meaningful charset specified (!= defaultcharset)
    // *and* the charset is different from frame's
    //  3) the exception for NT Japanese platform that maps
    //     MS Shell Dlg to their native font. For US Apps to
    //     work on these platforms they typically specify 
    //     PSH_USEPAGELANG to get English buttons on frame
    //     but they still need to get the frame sized based on
    //     page font
    //
    // Otherwise, IE4 compat **requires** that we use the frame font.
    // ISVs have hacked around this historical bug by having large
    // dialog templates with extra space in them.
    //
    fUsePageFont =
        /* --- A) It's a SHELLFONT page --- */
        IsPageInfoSHELLFONT(ppi) ||
        /* --- B) ML scenario --- */
#ifdef WINNT
        ((ppd->psh.dwFlags & PSH_USEPAGELANG) 
        && IsMSShellDlgMapped(NT5_GetUserDefaultUILanguage())) ||
#endif
        (ppd->iFrameCharset != iPageCharset
        && (iPageCharset != DEFAULT_CHARSET
            || (ppi->pfd.iCharset != DEFAULT_CHARSET
                && ppi->pfd.iCharset != ppd->iFrameCharset)));

    if (fUsePageFont &&
        GetPageFontMetrics(ppd, &ppi->pfd, MLIsMLHInstance(pisp->_psp.hInstance)))
    {
        // Compute Real Dialog Unit for the page
        pisp->_pfx.siz.cx = MulDiv(ppi->pt.x, ppd->sizCache.cx, 4);
        pisp->_pfx.siz.cy = MulDiv(ppi->pt.y, ppd->sizCache.cy, 8);
    } else {
        RECT rcT;
        // IE4 compat - Use the frame font
        rcT.top = rcT.left = 0;         // Win95 will fault if these are uninit
        rcT.right = ppi->pt.x;
        rcT.bottom = ppi->pt.y;
        MapDialogRect(ppd->hDlg, &rcT);
        pisp->_pfx.siz.cx = rcT.right;
        pisp->_pfx.siz.cy = rcT.bottom;

        //
        //  If this is PSP_DLGINDIRECT but the character set and face name
        //  say this is a "generic" property sheet, then take the frame
        //  font or the page font, whichever is bigger.
        //
        //  This fixes the Chinese MingLiu font, which is not as tall as
        //  the English MS Sans Serif font.  Without this fix, we would
        //  use MingLui (the frame font), and then your MS Shell Dlg pages
        //  would get truncated.
        //
        //  (Truncated property sheets is what you got in NT4, but I guess
        //  looking pretty is more important than bug-for-bug compatibility.
        //  Who knows what apps will be broken by this change.)
        //
        if ((pisp->_psp.dwFlags & PSP_DLGINDIRECT) &&
            ppi->pfd.iCharset == DEFAULT_CHARSET &&
            lstrcmpiW(ppi->pfd.szFace, L"MS Shell Dlg") == 0)
        {
            int i;
            GetPageFontMetrics(ppd, &ppi->pfd, FALSE);
            i = MulDiv(ppi->pt.x, ppd->sizCache.cx, 4);
            if (pisp->_pfx.siz.cx < i)
                pisp->_pfx.siz.cx = i;
            i = MulDiv(ppi->pt.y, ppd->sizCache.cy, 8);
            if (pisp->_pfx.siz.cy < i)
                pisp->_pfx.siz.cy = i;

        }
    }
}

void NEAR PASCAL InitPropSheetDlg(HWND hDlg, LPPROPDATA ppd)
{
    PAGEINFOEX pi;
    int dxDlg, dyDlg, dyGrow, dxGrow;
    RECT rcMinSize, rcDlg, rcPage, rcOrigTabs;
    UINT uPages;
    HIMAGELIST himl = NULL;
    TC_ITEMEXTRA tie;
    TCHAR szStartPage[128];
    LPCTSTR pStartPage = NULL;
    UINT nStartPage;
    BOOL fPrematurePages = FALSE;
#ifdef DEBUG
    BOOL fStartPageFound = FALSE;
#endif
    LANGID langidMUI;
#ifndef WINNT
    DWORD dwExStyle;
#endif
    MONITORINFO mMonitorInfo;
    HMONITOR hMonitor;
    BOOL bMirrored = FALSE;
    // set our instance data pointer
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)ppd);

    // Make sure this gets inited early on.
    ppd->nCurItem = 0;

    // By default we allow the "Apply" button to be enabled
    ppd->fAllowApply = TRUE;

    if (IS_WIZARD(ppd)) {
        // Subclass our buttons so their mnemonics won't mess up applications
        // that run around hiding and showing the buttons behind our back.
        Prsht_SubclassButton(hDlg, IDD_BACK);
        Prsht_SubclassButton(hDlg, IDD_NEXT);
        Prsht_SubclassButton(hDlg, IDD_FINISH);
    } else
        _SetTitle(hDlg, ppd);

    if (ppd->psh.dwFlags & PSH_USEICONID)
    {
        ppd->psh.H_hIcon = LoadImage(ppd->psh.hInstance, ppd->psh.H_pszIcon, IMAGE_ICON, g_cxSmIcon, g_cySmIcon, LR_DEFAULTCOLOR);
    }

    if ((ppd->psh.dwFlags & (PSH_USEICONID | PSH_USEHICON)) && ppd->psh.H_hIcon)
        SendMessage(hDlg, WM_SETICON, FALSE, (LPARAM)(UINT_PTR)ppd->psh.H_hIcon);

    ppd->hDlg = hDlg;

    // IDD_PAGELIST should definitely exist
    ppd->hwndTabs = GetDlgItem(hDlg, IDD_PAGELIST);
    ASSERT(ppd->hwndTabs);
#ifndef WINNT
    // Turn off mirroring inheritance for the property sheet.
    dwExStyle = GetWindowLong(hDlg, GWL_EXSTYLE);
    if (dwExStyle & RTL_MIRRORED_WINDOW)
        SetWindowLong(hDlg, GWL_EXSTYLE, dwExStyle | RTL_NOINHERITLAYOUT);

    dwExStyle = GetWindowLong(ppd->hwndTabs, GWL_EXSTYLE);
    if (dwExStyle & RTL_MIRRORED_WINDOW)
        SetWindowLong(ppd->hwndTabs, GWL_EXSTYLE, dwExStyle | RTL_NOINHERITLAYOUT);
#endif
    TabCtrl_SetItemExtra(ppd->hwndTabs, CB_ITEMEXTRA);

    // nStartPage is either ppd->psh.H_nStartPage or the page pStartPage
    nStartPage = ppd->psh.H_nStartPage;
    if (ppd->psh.dwFlags & PSH_USEPSTARTPAGE)
    {
        nStartPage = 0;                 // Assume we don't find the page
        pStartPage = ppd->psh.H_pStartPage;

        if (IS_INTRESOURCE(pStartPage))
        {
            szStartPage[0] = TEXT('\0');
            LoadString(ppd->psh.hInstance, (UINT)LOWORD(pStartPage),
                       szStartPage, ARRAYSIZE(szStartPage));
            pStartPage = szStartPage;
        }
    }

#ifndef WINDOWS_ME
    tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE;
#endif
    tie.hwndPage = NULL;
    tie.tci.pszText = pi.szCaption;
    tie.state = 0;

    SendMessage(ppd->hwndTabs, WM_SETREDRAW, FALSE, 0L);

    // load langid we chose for frame dialog template
    ppd->wFrameLang =  LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
    
        // it's charset that really matters to font
    ppd->iFrameCharset = GetDefaultCharsetFromLang(ppd->wFrameLang);
    
    langidMUI = GetMUILanguage();

    for (uPages = 0; uPages < ppd->psh.nPages; uPages++)
    {
        PISP  pisp = GETPISP(ppd, uPages);

        if (GetPageInfoEx(ppd, pisp, &pi, langidMUI, GPI_ALL))
        {
            Prsht_ComputeIdealPageSize(ppd, pisp, &pi);

            // Add the page to the end of the tab list

            tie.tci.iImage = -1;
#ifdef WINDOWS_ME
            tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE | (pi.bRTL ? TCIF_RTLREADING : 0);
#endif
            if (pi.hIcon) {
                if (!himl) {
                    UINT flags = ILC_MASK;
                    if(IS_WINDOW_RTL_MIRRORED(ppd->hwndTabs)) {
                        flags |= ILC_MIRROR;
                    }    
                    himl = ImageList_Create(g_cxSmIcon, g_cySmIcon, flags, 8, 4);
                    TabCtrl_SetImageList(ppd->hwndTabs, himl);
                }

                tie.tci.iImage = ImageList_AddIcon(himl, pi.hIcon);
                // BUGBUG raymondc - we always destroy even if PSP_USEHICON?
                DestroyIcon(pi.hIcon);
            }

            // BUGBUG? What if this fails? Do we want to destroy the page?
            if (TabCtrl_InsertItem(ppd->hwndTabs, 1000, &tie.tci) >= 0)
            {
                // Nothing to do; all the code that was here got moved elsewhere
            }

            // remember if any page wants premature init
            if (pisp->_psp.dwFlags & PSP_PREMATURE)
                fPrematurePages = TRUE;

            // if the user is specifying the startpage via title, check it here
            if ((ppd->psh.dwFlags & PSH_USEPSTARTPAGE) &&
                !lstrcmpi(pStartPage, pi.szCaption))
            {
                nStartPage = uPages;
#ifdef DEBUG
                fStartPageFound = TRUE;
#endif
            }
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("PropertySheet failed to GetPageInfo"));
            RemovePropPageData(ppd, uPages--);
        }
    }

    SendMessage(ppd->hwndTabs, WM_SETREDRAW, TRUE, 0L);

    if (ppd->psh.pfnCallback) {
#ifdef WX86
        if (ppd->fFlags & PD_WX86)
            Wx86Callback(ppd->psh.pfnCallback, hDlg, PSCB_INITIALIZED, 0);
        else
#endif
            ppd->psh.pfnCallback(hDlg, PSCB_INITIALIZED, 0);
    }

    //
    // Now compute the size of the tab control.
    //

    // First get the rectangle for the whole dialog
    GetWindowRect(hDlg, &rcDlg);
    
    // For WIZARD_LITE style wizards, we stretch the tabs page and sunken divider
    // to cover the whole wizard (without the border)
    if (ppd->psh.dwFlags & PSH_WIZARD_LITE)
    {
        // Stretch the divider to the whole width of the wizard
        RECT rcDiv, rcDlgClient;
        HWND hDiv;

        // we allow both PSH_WIZARD and PSH_WIZARD_LITE to be set
        // it's exactly the same as setting just PSH_WIZARD_LITE
        RIPMSG(!(ppd->psh.dwFlags & PSH_WIZARD97),
               "Cannot combine PSH_WIZARD_LITE with PSH_WIZARD97");

        // but some bozos do it anyway, so turn off
        ppd->psh.dwFlags &= ~PSH_WIZARD97;

        // NOTE: GetDlgItemRect returns a rectangle relative to hDlg
        hDiv = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcDiv);
        if (hDiv)
            SetWindowPos(hDiv, NULL, 0, rcDiv.top, RECTWIDTH(rcDlg),
                         RECTHEIGHT(rcDiv), SWP_NOZORDER | SWP_NOACTIVATE);

        GetClientRect(hDlg, &rcDlgClient);
        
        // Stretch the page list control to cover the whole wizard client area above
        // the divider
        SetWindowPos(ppd->hwndTabs, NULL, 0, 0, RECTWIDTH(rcDlgClient),
                     rcDiv.top, SWP_NOZORDER | SWP_NOACTIVATE);
    }

    //
    //  While we're thinking about it, don't let people set both
    //  WIZARD97IE4 *and* WIZARD97IE5.  That's just way too strange.
    //
    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
        ppd->psh.dwFlags &= ~PSH_WIZARD97IE5;

    // Get the rectangle of the pagelist control in pixels.
    GetClientRect(ppd->hwndTabs, &rcOrigTabs);
    ppd->sizMin.cx = rcOrigTabs.right;
    ppd->sizMin.cy = rcOrigTabs.bottom;

    // Compute rcPage = Size of page area in pixels
    // For now, we only care about interior pages; we'll deal with exterior
    // pages later.
    rcPage.left = rcPage.top = 0;
    Prsht_GetIdealPageSize(ppd, (SIZE *)&rcPage.right, GIPS_SKIPEXTERIOR97HEIGHT);

    //
    //  IE4's Wizard97 assumed that all exterior pages were exactly
    //  DEFAULTHEADERHEIGHT dlu's taller than interior pages.  That's
    //  right, DEFAULTHEADERHEIGHT is a pixel count, but IE4 messed up
    //  and used it as a dlu count here.
    //
    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
    {
        SIZE sizT;
        SetRect(&rcMinSize, 0, 0, 0, DEFAULTHEADERHEIGHT);
        MapDialogRect(hDlg, &rcMinSize);
        Prsht_GetIdealPageSize(ppd, &sizT, GIPS_SKIPINTERIOR97HEIGHT);
        if (rcPage.bottom < sizT.cy - rcMinSize.bottom)
            rcPage.bottom = sizT.cy - rcMinSize.bottom;
    }

    // Now compute the minimum size for the page region
    rcMinSize = rcPage;

    //
    //  If this is a wizard then set the size of the page area to the entire
    //  size of the control.  If it is a normal property sheet then adjust for
    //  the tabs, resize the control, and then compute the size of the page
    //  region only.
    //
    if (IS_WIZARD(ppd))
        // initialize
        rcPage = rcMinSize;
    else
    {
        int i;
        RECT rcAdjSize;

        // initialize

        for (i = 0; i < 2; i++) {
            rcAdjSize = rcMinSize;
            TabCtrl_AdjustRect(ppd->hwndTabs, TRUE, &rcAdjSize);

            rcAdjSize.right  -= rcAdjSize.left;
            rcAdjSize.bottom -= rcAdjSize.top;
            rcAdjSize.left = rcAdjSize.top = 0;

            if (rcAdjSize.right < rcMinSize.right)
                rcAdjSize.right = rcMinSize.right;
            if (rcAdjSize.bottom < rcMinSize.bottom)
                rcAdjSize.bottom = rcMinSize.bottom;

            SetWindowPos(ppd->hwndTabs, NULL, 0,0, rcAdjSize.right, rcAdjSize.bottom,
                         SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        rcPage = rcMinSize = rcAdjSize;
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rcPage);
    }
    //
    // rcMinSize now contains the size of the control, including the tabs, and
    // rcPage is the rect containing the page portion (without the tabs).
    //

    // For wizard97:
    // Now we have the correct width for our wizard, let's compute the
    // header height based on that, shift the tab window and the pages
    // window down accordingly.
    //
    dyGrow = 0;
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        RECT rcTabs;
        SIZE sizT;

        // NOTE: we don't directly use rcPage because the verticle position for
        // ppd->hwndTabs is not determined, yet, even though the horizontal is
        // already computed. Therefore, we can only use rcPageCopy.right not
        // rcPageCopy.bottom in the following code.
        RECT rcTemp;
        CopyRect(&rcTemp, &rcPage);
        MapWindowPoints(ppd->hwndTabs, hDlg, (LPPOINT)&rcTemp, 2);

        GetWindowRect(ppd->hwndTabs, &rcTabs);
        MapWindowRect(NULL, hDlg, &rcTabs);

        // Set the header fonts first because we need to use the bold font
        // to compute the title height
        _SetHeaderFonts(hDlg, ppd);

        // Adjust the header height
        ppd->cyHeaderHeight = _ComputeHeaderHeight(ppd, rcTemp.right);

        // Since the app can change the subheader text on the fly,
        // our computation of the header height might end up wrong later.
        // Allow ISVs to precompensate for that by setting their exterior
        // pages larger than the interior pages by the amount they want
        // to reserve.
        // So if the largest external page is larger than the largest internal
        // page, then expand to enclose the external pages too.
        // IE4 Wizard97 didn't do this and MFC relies on the bug.

        if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
        {
            // A margin of 7dlu's is placed above the page, and another
            // margin of 7 dlu's is placed below.
            SetRect(&rcTemp, 0, 0, 0, 7+7);
            MapDialogRect(hDlg, &rcTemp);

            Prsht_GetIdealPageSize(ppd, &sizT, GIPS_SKIPINTERIOR97HEIGHT);

            if (ppd->cyHeaderHeight < sizT.cy - RECTHEIGHT(rcPage) - rcTemp.bottom)
                ppd->cyHeaderHeight = sizT.cy - RECTHEIGHT(rcPage) - rcTemp.bottom;
        }

        // Move the tab window right under the header
        dyGrow += ppd->cyHeaderHeight;
        SetWindowPos(ppd->hwndTabs, NULL, rcTabs.left, rcTabs.top + dyGrow,
                     RECTWIDTH(rcTabs), RECTHEIGHT(rcTabs), SWP_NOZORDER | SWP_NOACTIVATE);
    }

    //
    // Resize the dialog to make room for the control's new size.  This can
    // only grow the size.
    //
    dxGrow = rcMinSize.right - rcOrigTabs.right;
    dxDlg  = rcDlg.right - rcDlg.left + dxGrow;
    dyGrow += rcMinSize.bottom - rcOrigTabs.bottom;
    dyDlg  = rcDlg.bottom - rcDlg.top + dyGrow;

    //
    // Cascade property sheet windows (only for comctl32 and commctrl)
    //

    //
    // HACK: Putting CW_USEDEFAULT in dialog template does not work because
    //  CreateWindowEx ignores it unless the window has WS_OVERLAPPED, which
    //  is not appropriate for a property sheet.
    //
    {
        const TCHAR c_szStatic[] = TEXT("Static");
        UINT swp = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;
        if (!IsWindow(ppd->psh.hwndParent)) {
            HWND hwndT = CreateWindowEx(0, c_szStatic, NULL,
                                        WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT,
                                        0, 0, NULL, NULL, HINST_THISDLL, NULL);
            if (hwndT) {
                GetWindowRect(hwndT, &rcDlg);
                swp = SWP_NOZORDER | SWP_NOACTIVATE;
                DestroyWindow(hwndT);
            }
        } else {
            GetWindowRect(ppd->psh.hwndParent, &rcDlg);
            if (IsWindowVisible(ppd->psh.hwndParent)) {
                bMirrored = IS_WINDOW_RTL_MIRRORED(ppd->psh.hwndParent);
                
                rcDlg.top += g_cySmIcon;
                if(bMirrored)
                {
                    rcDlg.left = rcDlg.right - g_cxSmIcon - dxDlg;
                }
                else
                {
                    rcDlg.left += g_cxSmIcon;
                }    
            }
            swp = SWP_NOZORDER | SWP_NOACTIVATE;
        }
        hMonitor = MonitorFromWindow(hDlg, MONITOR_DEFAULTTONEAREST);
        mMonitorInfo.cbSize = sizeof(MONITORINFO);
        if (GetMonitorInfo(hMonitor, &mMonitorInfo))
        {
            if (mMonitorInfo.rcMonitor.right < (rcDlg.left + dxDlg))
            {
                // Move the Window left.
                rcDlg.left = mMonitorInfo.rcMonitor.right - dxDlg;
            }
            if (mMonitorInfo.rcMonitor.left > rcDlg.left)
            {
                // Move the Window Right.
                rcDlg.left = mMonitorInfo.rcMonitor.left;
            }
            if (mMonitorInfo.rcMonitor.bottom < (rcDlg.top + dyDlg))
            {
                // Move the Window Up.
                rcDlg.top = mMonitorInfo.rcMonitor.bottom - dyDlg;
            }
            if (mMonitorInfo.rcMonitor.top > rcDlg.top)
            {
                // Move the Window Down.
                rcDlg.top = mMonitorInfo.rcMonitor.top;
            }
        }
        SetWindowPos(hDlg, NULL, rcDlg.left, rcDlg.top, dxDlg, dyDlg, swp);
    }

    // Now we'll figure out where the page needs to start relative
    // to the bottom of the tabs.
    MapWindowRect(ppd->hwndTabs, hDlg, &rcPage);

    ppd->xSubDlg  = rcPage.left;
    ppd->ySubDlg  = rcPage.top;
    ppd->cxSubDlg = rcPage.right - rcPage.left;
    ppd->cySubDlg = rcPage.bottom - rcPage.top;

    //
    // move all the buttons down as needed and turn on appropriate buttons
    // for a wizard.
    //
    {
        RECT rcCtrl;
        HWND hCtrl;
        const int *pids;

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            hCtrl = GetDlgItemRect(hDlg, IDD_TOPDIVIDER, &rcCtrl);
            if (hCtrl)
                SetWindowPos(hCtrl, NULL, rcCtrl.left, ppd->cyHeaderHeight,
                             RECTWIDTH(rcCtrl) + dxGrow, RECTHEIGHT(rcCtrl), SWP_NOZORDER | SWP_NOACTIVATE);
        }

        if (IS_WIZARD(ppd)) {
            pids = WizIDs;

            hCtrl = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcCtrl);
            if (hCtrl)
                SetWindowPos(hCtrl, NULL, rcCtrl.left, rcCtrl.top + dyGrow,
                             RECTWIDTH(rcCtrl) + dxGrow, RECTHEIGHT(rcCtrl),
                             SWP_NOZORDER | SWP_NOACTIVATE);

            EnableWindow(GetDlgItem(hDlg, IDD_BACK), TRUE);
            ppd->idDefaultFallback = IDD_NEXT;
        } else {
            pids = IDs;
            ppd->idDefaultFallback = IDOK;
        }


        // first move everything over by the same amount that
        // the dialog grew by.

        // If we flipped the buttons, it should be aligned to the left
        // No move needed
        MoveAllButtons(hDlg, pids, IDHELP, ppd->fFlipped ? 0 : dxGrow, dyGrow);
            

        // If there's no help, then remove the help button.
        if (!(ppd->psh.dwFlags & PSH_HASHELP)) {
            RemoveButton(hDlg, IDHELP, pids);
        }

        // If we are not a wizard, and we should NOT show apply now
        if ((ppd->psh.dwFlags & PSH_NOAPPLYNOW) &&
            !IS_WIZARD(ppd))
        {
            RemoveButton(hDlg, IDD_APPLYNOW, pids);
        }

        if (IS_WIZARD(ppd) &&
            (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)))
        {
            DWORD dwStyle=0;

            RemoveButton(hDlg, IDD_FINISH, pids);

            // if there's no finish button showing, we need to place it where
            // the next button is
#ifdef UNIX
            // IEUNIX:
            // In motif look the default push button has a window rect which is noticably larger than
            // than a regular button. So before we get the window rect we need to remove this style otherwise
            // the finish button will look larger than the rest of the buttons
            //

            dwStyle=GetWindowLong(GetDlgItem(hDlg, IDD_NEXT),GWL_STYLE);

            SendMessage(GetDlgItem(hDlg, IDD_NEXT),BM_SETSTYLE,dwStyle & (~BS_DEFPUSHBUTTON),0);
#endif
            GetWindowRect(GetDlgItem(hDlg, IDD_NEXT), &rcCtrl);
#ifdef UNIX
            SendMessage(GetDlgItem(hDlg, IDD_NEXT),BM_SETSTYLE,dwStyle,0);
#endif
            MapWindowPoints(HWND_DESKTOP, hDlg, (LPPOINT)&rcCtrl, 2);
            SetWindowPos(GetDlgItem(hDlg, IDD_FINISH), NULL, rcCtrl.left, rcCtrl.top,
                         RECTWIDTH(rcCtrl), RECTHEIGHT(rcCtrl), SWP_NOZORDER | SWP_NOACTIVATE);
        }

    }

    // (dli) compute the Pattern Brush for the watermark
    // Note: This is done here because we need to know the size of the big dialog in
    // case the user wants to stretch the bitmap
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        int cx, cy;
        ASSERT(ppd->hbmHeader == NULL);
        ASSERT(ppd->hbmWatermark == NULL);

        //
        //  WIZARD97IE4 disabled the watermark and header bitmap
        //  if high contrast was turned on.
        //
        if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
            HIGHCONTRAST hc = {sizeof(hc)};
            if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0) &&
                (hc.dwFlags & HCF_HIGHCONTRASTON)) {
                ppd->psh.dwFlags &= ~(PSH_WATERMARK | PSH_USEHBMWATERMARK |
                                      PSH_USEHPLWATERMARK |
                                      PSH_HEADER | PSH_USEHBMHEADER);
            }
        }

        if ((ppd->psh.dwFlags & PSH_WATERMARK) && ppd->psh.H_hbmWatermark)
        {
            // Compute dimensions of final bitmap, which may be slightly
            // goofy due to stretching

            cx = cy = 0;            // Assume no stretching
            if (ppd->psh.dwFlags & PSH_STRETCHWATERMARK) {
                RECT rc;
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
                    // The WIZARD97IE4 watermark covers the entire dialog
                    if (GetDlgItemRect(hDlg, IDD_DIVIDER, &rc)) {
                        cx = dxDlg;
                        cy = rc.top;
                    }
                } else {
                    // The WIZARD97IE5 watermark does not stretch
                    // (Too many people passed this flag when converting
                    // from WIZARD97IE4 to WIZARD97IE5 and relied on
                    // the nonstretchability.)
                }
            }

            if (ppd->psh.dwFlags & PSH_USEHBMWATERMARK)
            {
                // LR_COPYRETURNORG means "If no stretching was needed,
                // then just return the original bitmap unaltered."
                // Note that we need special cleanup if a stretch occurred.
                ppd->hbmWatermark = (HBITMAP)CopyImage(ppd->psh.H_hbmWatermark,
                            IMAGE_BITMAP, cx, cy, LR_COPYRETURNORG);
            }
            else
            {
                ppd->hbmWatermark = (HBITMAP)LoadImage(ppd->psh.hInstance,
                        ppd->psh.H_pszbmWatermark,
                        IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION);
            }

            if (ppd->hbmWatermark)
            {
                // If app provides custom palette, then use it,
                // else create one based on the bmp.  (And if the bmp
                // doesn't have a palette, PaletteFromBmp will use the
                // halftone palette.)

                if (ppd->psh.dwFlags & PSH_USEHPLWATERMARK)
                    ppd->hplWatermark = ppd->psh.hplWatermark;
                else
                    ppd->hplWatermark = PaletteFromBmp(ppd->hbmWatermark);

                // And WIZARD97IE4 needs to turn it into a bitmap brush.
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
                    ppd->hbrWatermark = CreatePatternBrush(ppd->hbmWatermark);

            }

        }

        if ((ppd->psh.dwFlags & PSH_HEADER) && ppd->psh.H_hbmHeader)
        {
            cx = cy = 0;            // Assume no stretching
            if (ppd->psh.dwFlags & PSH_STRETCHWATERMARK) {
                if (ppd->psh.dwFlags & PSH_WIZARD97IE4) {
                    // The WIZARD97IE4 header covers the entire header
                    cx = dxDlg;
                    cy = ppd->cyHeaderHeight;
                } else {
                    // The WIZARD97IE5 header does not stretch
                    // (Too many people passed this flag when converting
                    // from WIZARD97IE4 to WIZARD97IE5 and relied on
                    // the nonstretchability.)
                }
            }

            if (ppd->psh.dwFlags & PSH_USEHBMHEADER)
            {
                // LR_COPYRETURNORG means "If no stretching was needed,
                // then just return the original bitmap unaltered."
                // Note that we need special cleanup if a stretch occurred.
                ppd->hbmHeader = (HBITMAP)CopyImage(ppd->psh.H_hbmHeader,
                            IMAGE_BITMAP, cx, cy, LR_COPYRETURNORG);
            }
            else
            {
                ppd->hbmHeader = (HBITMAP)LoadImage(ppd->psh.hInstance,
                        ppd->psh.H_pszbmHeader,
                        IMAGE_BITMAP, cx, cy, LR_CREATEDIBSECTION);
            }

            // And WIZARD97IE4 needs to turn it into a bitmap brush.
            if (ppd->hbmHeader && (ppd->psh.dwFlags & PSH_WIZARD97IE4))
                ppd->hbrHeader = CreatePatternBrush(ppd->hbmHeader);

        }
        else
        {
            // In case the user does not specify a header bitmap
            // use the top portion of the watermark
            ppd->hbmHeader = ppd->hbmWatermark;
            ppd->hbrHeader = ppd->hbrWatermark;
        }

    }


#ifdef UNIX
// IEUNIX : Motif compatibility
// Space the OK, Cancel, Apply and Help buttons evenly
// Assuming all buttons are of equal width
// PORT QSY     do not make adjustment for wizard type, because
//              1) original code did not account for wizard type, causing
//              misplaced controls
//              2) if adjust buttons  for wizard type
//              according to the orignal logic, the buttons
//              do not look very good
if ( !((ppd->psh.dwFlags & PSH_WIZARD) || (ppd->psh.dwFlags & PSH_WIZARD97)) &&
          MwCurrentLook() == LOOK_MOTIF) {
   RECT dim_dlg;
   RECT dim_button;
   int  i;
   int num_buttons = 2;
   int x;
   int y;
   RECT rcTabs;
   DWORD dwStyle;

   int iDefID=LOWORD(SendMessage(hDlg, DM_GETDEFID, 0, 0));

   GetClientRect(ppd->hwndTabs, &rcTabs);
   GetClientRect(hDlg, &dim_dlg);
   /*
     get the size of the ok button without the default rect.
   */

   dwStyle=GetWindowLong(GetDlgItem(hDlg, iDefID),GWL_STYLE);
   SendMessage(GetDlgItem(hDlg, iDefID),BM_SETSTYLE,dwStyle & (~BS_DEFPUSHBUTTON),0);

   GetWindowRect(GetDlgItem(hDlg, IDOK), &dim_button);


   y=rcTabs.bottom+(dim_dlg.bottom-rcTabs.bottom)/2-RECTHEIGHT(dim_button)/2+4;

   // We have OK and Cancel for sure. Find out if we have Apply and Help also
   if ((ppd->psh.dwFlags & PSH_HASHELP)) {
      num_buttons++;
   }

   if (!(ppd->psh.dwFlags & PSH_NOAPPLYNOW))
   {
      num_buttons++;
   }

   x = (RECTWIDTH(dim_dlg) - num_buttons * RECTWIDTH(dim_button))/(num_buttons + 1);

   for (i = 0; i < num_buttons; i++) {
       HWND tmp_button;
       RECT tmp_dim;
       switch(i) {
             case 0 :
                  tmp_button = GetDlgItemRect(hDlg, IDOK, &tmp_dim);
                  break;
             case 1 :
                  tmp_button = GetDlgItemRect(hDlg, IDCANCEL, &tmp_dim);
                  break;
             case 2 :
                  tmp_button = GetDlgItemRect(hDlg, IDD_APPLYNOW, &tmp_dim);
                  break;
             case 3 :
                  tmp_button = GetDlgItemRect(hDlg, IDHELP, &tmp_dim);
                  break;
       }

       SetWindowPos(tmp_button,
                    NULL,
                    (i) * RECTWIDTH(tmp_dim) + (i+1)*x,
                    y, // +10,
                    RECTWIDTH(tmp_dim),
                    RECTHEIGHT(tmp_dim),
                    SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
   }

  /*
     Now that all the buttons are placed Reset the default push button
  */

  SendMessage(GetDlgItem(hDlg, iDefID),BM_SETSTYLE,dwStyle,0);

}
#endif /* UNIX */

    // force the dialog to reposition itself based on its new size

    SendMessage(hDlg, DM_REPOSITION, 0, 0L);

    // do this here instead of using DS_SETFOREGROUND so we don't hose
    // pages that do things that want to set the foreground window
    // BUGBUG raymondc - Why do we do this at all?
    SetForegroundWindow(hDlg);

    // We set this to 1 if the user saves any changes.
    // do this before initting or switching to any pages
    ppd->nReturn = 0;

    // AppHack - Some people forgot to initialize nStartPage, and they were
    // lucky that the garbage value on the stack was zero.  Lucky no longer.
    if (nStartPage >= ppd->psh.nPages) {
        RIPMSG(0, "App forgot to initialize PROPSHEETHEADER.nStartPage field, assuming zero");
        nStartPage = 0;
    }

    // Now attempt to select the starting page.
    TabCtrl_SetCurSel(ppd->hwndTabs, nStartPage);
    PageChange(ppd, 1);
#ifdef DEBUG
    if (ppd->psh.dwFlags & PSH_USEPSTARTPAGE && !fStartPageFound)
        DebugMsg(DM_WARNING, TEXT("sh WN - Property start page '%s' not found."), pStartPage);
#endif

    // Now init any other pages that require it
    if (fPrematurePages)
    {
        int nPage;

        tie.tci.mask = TCIF_PARAM;
        for (nPage = 0; nPage < (int)ppd->psh.nPages; nPage++)
        {
            PISP pisp = GETPISP(ppd, nPage);

            if (!(pisp->_psp.dwFlags & PSP_PREMATURE))
                continue;

            TabCtrl_GetItem(ppd->hwndTabs, nPage, &tie.tci);

            if (tie.hwndPage)
                continue;

            if ((tie.hwndPage = _CreatePage(ppd, pisp, hDlg, langidMUI)) == NULL)
            {
                RemovePropPageData(ppd, nPage--);
                continue;
            }

            TabCtrl_SetItem(ppd->hwndTabs, nPage, &tie.tci);
        }
    }
}

HWND NEAR PASCAL _Ppd_GetPage(LPPROPDATA ppd, int nItem)
{
    if (ppd->hwndTabs)
    {
        TC_ITEMEXTRA tie;
        tie.tci.mask = TCIF_PARAM;
        TabCtrl_GetItem(ppd->hwndTabs, nItem, &tie.tci);
        return tie.hwndPage;
    }
    return NULL;
}

BOOL PASCAL _Ppd_IsPageHidden(LPPROPDATA ppd, int nItem)
{
    if (ppd->hwndTabs)
    {
        TCITEM tci;
        tci.mask = TCIF_STATE;
        tci.dwStateMask = TCIS_HIDDEN;
        if (TabCtrl_GetItem(ppd->hwndTabs, nItem, &tci))
            return tci.dwState;
    }
    return FALSE;
}

LRESULT NEAR PASCAL _Ppd_SendNotify(LPPROPDATA ppd, int nItem, int code, LPARAM lParam)
{
    PSHNOTIFY pshn;

    pshn.lParam = lParam;
    return SendNotifyEx(_Ppd_GetPage(ppd,nItem), ppd->hDlg, code, (LPNMHDR)&pshn, FALSE);
}

//
//  dwFind = 0 means just move to the current item + iAutoAdjust
//  dwFind != 0 means it's a dialog resource identifier we should look for
//
int FindPageIndex(LPPROPDATA ppd, int nCurItem, ULONG_PTR dwFind, LONG_PTR iAutoAdj)
{
    LRESULT nActivate;

    if (dwFind == 0) {
        nActivate = nCurItem + iAutoAdj;
        if (((UINT)nActivate) <= ppd->psh.nPages) {
            return((int)nActivate);
        }
    } else {
        for (nActivate = 0; (UINT)nActivate < ppd->psh.nPages; nActivate++) {
            if ((DWORD_PTR)GETPPSP(ppd, nActivate)->P_pszTemplate == dwFind) {
                return((int)nActivate);
            }
        }
    }
    return(-1);
}

//
//  If hpage != NULL, then return the index of the page which matches it,
//  or -1 on failure.
//
int FindPageIndexByHpage(LPPROPDATA ppd, HPROPSHEETPAGE hpage)
{
    int i;

    //
    //  Notice that we explicitly do not do a InternalizeHPROPSHEETPAGE,
    //  because the app might be passing us garbage.  We just want to
    //  say "Nope, can't find garbage here, sorry."
    //

    for (i = ppd->psh.nPages - 1; i >= 0; i--) {
        if (hpage == GETHPAGE(ppd, i))
            break;
    }
    return i;
}


// This WM_NEXTDLGCTL stuff works, except for ACT!4.0 which faults randomly
// I don't know why.  The USER people said that removing a
// SetFocus(NULL) call from SetDlgFocus works, but I tried that
// and the app merely faulted in a different place.  so I'm going
// back to the old IE4 way, which means that there are scenarios
// where the DEFID can get out of sync with reality.
#undef WM_NEXTDLGCTL_WORKS

#ifdef WM_NEXTDLGCTL_WORKS

//
//  Helper function that manages dialog box focus in a manner that keeps
//  USER in the loop, so we don't get "two buttons both with the bold
//  defpushbutton border" problems.
//
//  We have to use WM_NEXTDLGCTL to fix defid problems, such as this one:
//
//      Right-click My Computer, Properties.
//      Go to Advanced tab. Click Environment Variables.
//      Click New. Type a name for a new dummy environment variable.
//      Click OK.
//
//  At this point (with the old code), the "New" button is a DEFPUSHBUTTON,
//  but the DEFID is IDOK.  The USER folks said I should use WM_NEXTDLGCTL
//  to avoid this problem.  But using WM_NEXTDLGCTL introduces its own big
//  hairy mess of problems.  All the code in this function aside from the
//  SendMessage(WM_NEXTDLGCTL) are to work around "quirks" in WM_NEXTDLGCTL
//  or workarounds for app bugs.
//
//  THIS CODE IS SUBTLE AND QUICK TO ANGER!
//
void SetDlgFocus(LPPROPDATA ppd, HWND hwndFocus)
{
    //
    //  HACK!  It's possible that by the time we get around to changing
    //  the dialog focus, the dialog box doesn't have focus any more!
    //  This happens because PSM_SETWIZBUTTONS is a posted message, so
    //  it can arrive *after* focus has moved elsewhere (e.g., to a
    //  MessageBox).
    //
    //  There is no way to update the dialog box focus without
    //  letting it change the real focus (another "quirk" of
    //  WM_NEXTDLGCTL), so instead we remember who used to have the
    //  focus, let the dialog box do its focus goo, and then restore
    //  the focus as necessary.
    //
    HWND hwndFocusPrev = GetFocus();

    //  If focus belonged to a window within our property sheet, then
    //  let the dialog box code push the focus around.  Otherwise,
    //  focus belonged to somebody outside our property sheet, so
    //  remember to restore it after we're done.

    if (hwndFocusPrev && IsChild(ppd->hDlg, hwndFocusPrev))
        hwndFocusPrev = NULL;

    //  USER forgot to revalidate hwndOldFocus at this point, so we have
    //  to exit USER (by returning to comctl32) then re-enter USER
    //  (in the SendMessage below) so parameter validation will happen
    //  again.  Sigh.

    //
    //  Bug in Win9x and NT:  WM_NEXTDLGCTL will crash if the previous
    //  focus window destroys itself in response to WM_KILLFOCUS.
    //  (WebTurbo by NetMetrics does this.)  There's a missed
    //  revalidation so USER ends up using a window handle after
    //  it has been destroyed.  Oops.
    //
    //  (The NT folks consider this "Won't fix, because the system stays
    //  up; just the app crashes".  The 9x folks will try to get the fix
    //  into Win98 OSR.)
    //

    //
    //  Do a manual SetFocus here to make the old focus (if any)
    //  do all its WM_KILLFOCUS stuff, and possibly destroy itself (grrr).
    //
    //  We have to SetFocus to NULL because some apps (e.g.,
    //  Visual C 6.0 setup) do funky things on SetFocus, and our early
    //  SetFocus interferes with the EM_SETSEL that WM_NEXTDLGCTL will
    //  do later.
    //
    //  APP HACK 2:  But not if the target focus is the same as the
    //  curreng focus, because ACT!4.0 crashes if it receives a
    //  WM_KILLFOCUS when it is not expecting one.

    if (hwndFocus != GetFocus())
        SetFocus(NULL);

    //
    //  Note that by manually shoving the focus around, we
    //  have gotten focus and DEFPUSHBUTTON and DEFID all out
    //  of sync, which is exactly the problem we're trying to
    //  avoid!  Fortunately, USER also contains special
    //  recovery code to handle the case where somebody "mistakenly" called
    //  SetFocus() to change the focus.  (I put "mistakenly" in quotes because
    //  in this case, we did it on purpose.)
    //

    SendMessage(ppd->hDlg, WM_NEXTDLGCTL, (WPARAM)hwndFocus, MAKELPARAM(TRUE, 0));

    //
    //  If WM_NEXTDLGCTL damaged the focus, fix it.
    //
    if (hwndFocusPrev)
        SetFocus(hwndFocusPrev);
}
#endif

void NEAR PASCAL SetNewDefID(LPPROPDATA ppd)
{
    HWND hDlg = ppd->hDlg;
    HWND hwndFocus;
    hwndFocus = GetNextDlgTabItem(ppd->hwndCurPage, NULL, FALSE);
    ASSERT(hwndFocus);
    if (hwndFocus) {
#ifndef WM_NEXTDLGCTL_WORKS
        int id;
        if (((DWORD)SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0L)) & DLGC_HASSETSEL)
        {
            // select the text
            Edit_SetSel(hwndFocus, 0, -1);
        }

        id = GetDlgCtrlID(hwndFocus);
#endif

        //
        //  See if the handle give to us by GetNextDlgTabItem was any good.
        //  (For compatibility reasons, if the dialog contains no tabstops,
        //  it returns the first item.)
        //
        if ((GetWindowLong(hwndFocus, GWL_STYLE) & (WS_VISIBLE | WS_DISABLED | WS_TABSTOP)) == (WS_VISIBLE | WS_TABSTOP))
        {
            //
            //  Give the page a chance to change the default focus.
            //
            HWND hwndT = (HWND)_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_QUERYINITIALFOCUS, (LPARAM)hwndFocus);

            // The window had better be valid and a child of the page.
            if (hwndT && IsWindow(hwndT) && IsChild(ppd->hwndCurPage, hwndT))
            {
                hwndFocus = hwndT;
            }
        }
        else
        {
            // in prop sheet mode, focus on tabs,
            // in wizard mode, tabs aren't visible, go to idDefFallback
            if (IS_WIZARD(ppd))
                hwndFocus = GetDlgItem(hDlg, ppd->idDefaultFallback);
            else
                hwndFocus = ppd->hwndTabs;
        }

#ifdef WM_NEXTDLGCTL_WORKS
        //
        //  Aw-right.  Go for it.
        //
        SetDlgFocus(ppd, hwndFocus);

        //
        //  Hack for MFC:  MFC relies on DM_SETDEFID to know when to
        //  update its wizard buttons.
        //
        SendMessage(hDlg, DM_SETDEFID, SendMessage(hDlg, DM_GETDEFID, 0, 0), 0);
#else
        SetFocus(hwndFocus);
        ResetWizButtons(ppd);
        if (SendDlgItemMessage(ppd->hwndCurPage, id, WM_GETDLGCODE, 0, 0L) & DLGC_UNDEFPUSHBUTTON)
            SendMessage(ppd->hwndCurPage, DM_SETDEFID, id, 0);
        else {
            SendMessage(hDlg, DM_SETDEFID, ppd->idDefaultFallback, 0);
        }
#endif
    }
}


/*
 ** we are about to change pages.  what a nice chance to let the current
 ** page validate itself before we go away.  if the page decides not
 ** to be de-activated, then this'll cancel the page change.
 **
 ** return TRUE iff this page failed validation
 */
BOOL NEAR PASCAL PageChanging(LPPROPDATA ppd)
{
    BOOL bRet = FALSE;
    if (ppd && ppd->hwndCurPage)
    {
        bRet = BOOLFROMPTR(_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_KILLACTIVE, 0));
    }
    return bRet;
}

void NEAR PASCAL PageChange(LPPROPDATA ppd, int iAutoAdj)
{
    HWND hwndCurPage;
    HWND hwndCurFocus;
    int nItem;
    HWND hDlg, hwndTabs;

    TC_ITEMEXTRA tie;
    UINT FlailCount = 0;
    LRESULT lres;

    if (!ppd)
    {
        return;
    }

    hDlg = ppd->hDlg;
    hwndTabs = ppd->hwndTabs;

    // NOTE: the page was already validated (PSN_KILLACTIVE) before
    // the actual page change.

    hwndCurFocus = GetFocus();

TryAgain:
    FlailCount++;
    if (FlailCount > ppd->psh.nPages)
    {
        DebugMsg(DM_TRACE, TEXT("PropSheet PageChange attempt to set activation more than 10 times."));
        return;
    }

    nItem = TabCtrl_GetCurSel(hwndTabs);
    if (nItem < 0)
    {
        return;
    }

    tie.tci.mask = TCIF_PARAM;

    TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);
    hwndCurPage = tie.hwndPage;

    if (!hwndCurPage)
    {
        if ((hwndCurPage = _CreatePage(ppd, GETPISP(ppd, nItem), hDlg, GetMUILanguage())) == NULL)
        {
            /* Should we put up some sort of error message here?
             */
            RemovePropPageData(ppd, nItem);
            TabCtrl_SetCurSel(hwndTabs, 0);
            goto TryAgain;
        }

        // tie.tci.mask    = TCIF_PARAM;
        tie.hwndPage = hwndCurPage;
        TabCtrl_SetItem(hwndTabs, nItem, &tie.tci);

        if (HIDEWIZ97HEADER(ppd, nItem))
            // Subclass for back ground watermark painting.
            SetWindowSubclass(hwndCurPage, WizardWndProc, 0, (DWORD_PTR)ppd);
    }

    // THI WAS REMOVED as part of the fix for bug 18327.  The problem is we need to
    // send a SETACTIVE message to a page if it is being activated.
    //    if (ppd->hwndCurPage == hwndCurPage)
    //    {
    //        /* we should be done at this point.
    //        */
    //        return;
    //    }

    /* Size the dialog and move it to the top of the list before showing
     ** it in case there is size specific initializing to be done in the
     ** GETACTIVE message.
     */

    if (IS_WIZARD(ppd))
    {
        HWND hwndTopDivider= GetDlgItem(hDlg, IDD_TOPDIVIDER);

        if (ppd->psh.dwFlags & PSH_WIZARD97)
        {
            HWND hwndDivider;
            RECT rcDlg, rcDivider;
            GetClientRect(hDlg, &rcDlg);

            hwndDivider = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcDivider);
            if (hwndDivider)
                SetWindowPos(hwndDivider, NULL, rcDlg.left, rcDivider.top,
                             RECTWIDTH(rcDlg), RECTHEIGHT(rcDivider),
                             SWP_NOZORDER | SWP_NOACTIVATE);

            if (GETPPSP(ppd, nItem)->dwFlags & PSP_HIDEHEADER)
            {
                // In this case, we give the whole dialog box except for the portion under the
                // Bottom divider to the property page
                RECT rcTopDivider;
                ShowWindow(hwndTopDivider, SW_HIDE);
                ShowWindow(ppd->hwndTabs, SW_HIDE);

                hwndTopDivider = GetDlgItemRect(hDlg, IDD_DIVIDER, &rcTopDivider);
                SetWindowPos(hwndCurPage, HWND_TOP, rcDlg.left, rcDlg.top, RECTWIDTH(rcDlg), rcTopDivider.top - rcDlg.top, 0);
            }
            else
            {
                ShowWindow(hwndTopDivider, SW_SHOW);
                ShowWindow(ppd->hwndTabs, SW_SHOW);
                SetWindowPos(hwndCurPage, HWND_TOP, ppd->xSubDlg, ppd->ySubDlg, ppd->cxSubDlg, ppd->cySubDlg, 0);
            }
        }
        else
        {
            ShowWindow(hwndTopDivider, SW_HIDE);
            SetWindowPos(hwndCurPage, HWND_TOP, ppd->xSubDlg, ppd->ySubDlg, ppd->cxSubDlg, ppd->cySubDlg, 0);
        }
    } else {
        RECT rcPage;
        GetClientRect(ppd->hwndTabs, &rcPage);
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rcPage);
        MapWindowPoints(ppd->hwndTabs, hDlg, (LPPOINT)&rcPage, 2);
        SetWindowPos(hwndCurPage, HWND_TOP, rcPage.left, rcPage.top,
                     rcPage.right - rcPage.left, rcPage.bottom - rcPage.top, 0);
    }

    /* We want to send the SETACTIVE message before the window is visible
     ** to minimize on flicker if it needs to update fields.
     */

    //
    //  If the page returns non-zero from the PSN_SETACTIVE call then
    //  we will set the activation to the resource ID returned from
    //  the call and set activation to it.      This is mainly used by wizards
    //  to skip a step.
    //
    lres = _Ppd_SendNotify(ppd, nItem, PSN_SETACTIVE, 0);

    if (lres) {
        int iPageIndex = FindPageIndex(ppd, nItem,
                                       (lres == -1) ? 0 : lres, iAutoAdj);


        if ((lres == -1) &&
            (nItem == iPageIndex || iPageIndex >= TabCtrl_GetItemCount(hwndTabs))) {
            iPageIndex = ppd->nCurItem;
        }

        if (iPageIndex != -1) {
            TabCtrl_SetCurSel(hwndTabs, iPageIndex);
            ShowWindow(hwndCurPage, SW_HIDE);
            goto TryAgain;
        }
    }

    if (ppd->psh.dwFlags & PSH_HASHELP) {
        // PSH_HASHELP controls the "Help" button at the bottom
        // PSH_NOCONTEXTHELP controls the caption "?" button
        Button_Enable(GetDlgItem(hDlg, IDHELP),
                      (BOOL)(GETPPSP(ppd, nItem)->dwFlags & PSP_HASHELP));
    }

    //
    //  If this is a wizard then we'll set the dialog's title to the tab
    //  title.
    //
    if (IS_WIZARD(ppd)) {
        TC_ITEMEXTRA tie;
        TCHAR szTemp[128 + 50];

        tie.tci.mask = TCIF_TEXT;
        tie.tci.pszText = szTemp;
        tie.tci.cchTextMax = ARRAYSIZE(szTemp);
        //// BUGBUG -- Check for error. Does this return false if fails??
        TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);
#ifdef WINDOWS_ME
        tie.tci.mask = TCIF_RTLREADING;
        tie.tci.cchTextMax = 0;
        // hack, use cchTextMax to query tab item reading order
        TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);
        if( (ppd->psh.dwFlags & PSH_RTLREADING) || (tie.tci.cchTextMax))
            SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) | WS_EX_RTLREADING);       
        else
            SetWindowLong(hDlg, GWL_EXSTYLE, GetWindowLong(hDlg, GWL_EXSTYLE) & ~WS_EX_RTLREADING);                   
#endif // WINDOWS_ME

        if (szTemp[0])
            SetWindowText(hDlg, szTemp);
    }

    /* Disable all erasebkgnd messages that come through because windows
     ** are getting shuffled.  Note that we need to call ShowWindow (and
     ** not show the window in some other way) because DavidDs is counting
     ** on the correct parameters to the WM_SHOWWINDOW message, and we may
     ** document how to keep your page from flashing.
     */
    ppd->fFlags |= PD_NOERASE;
    ShowWindow(hwndCurPage, SW_SHOW);
    if (ppd->hwndCurPage && (ppd->hwndCurPage != hwndCurPage))
    {
        ShowWindow(ppd->hwndCurPage, SW_HIDE);
    }
    ppd->fFlags &= ~PD_NOERASE;

    ppd->hwndCurPage = hwndCurPage;
    ppd->nCurItem = nItem;

    /* Newly created dialogs seem to steal the focus, so we steal it back
     ** to the page list, which must have had the focus to get to this
     ** point.  If this is a wizard then set the focus to the dialog of
     ** the page.  Otherwise, set the focus to the tabs.
     */
    if (hwndCurFocus != hwndTabs)
    {
        SetNewDefID(ppd);
    }
    else
    {
        // The focus may have been stolen from us, bring it back
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hwndTabs, (LPARAM)TRUE);
    }

    // make sure the header is repaint
    if ((ppd->psh.dwFlags & PSH_WIZARD97) && (!(GETPPSP(ppd, nItem)->dwFlags & PSP_HIDEHEADER)))
        InvalidateRect(hDlg, NULL,TRUE);
}

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

//
// HACKHACK (reinerf)
//
// This function sends the PSN_LASTCHANCEAPPLY right after the property sheets have had "ok"
// pressed. This allows the "General" tab on the file/folder properties to do a rename, so that
// it wont rename the file out from under the other pages, and have them barf when they go to
// persist their info.
//
void NEAR PASCAL SendLastChanceApply(LPPROPDATA ppd)
{
    TC_ITEMEXTRA tie;
    int nItem;
    int nItems = TabCtrl_GetItemCount(ppd->hwndTabs);

    tie.tci.mask = TCIF_PARAM;

    // we start with the last tab and count towards the first. This ensures
    // that the more important tabs (such as the "General" tab) will be the last
    // to recieve the PSN_LASTCHANCEAPPLY message.
    for (nItem = nItems - 1; nItem >= 0; nItem--)
    {
        TabCtrl_GetItem(ppd->hwndTabs, nItem, &tie.tci);

        if (tie.hwndPage)
        {
            // we ignore the return vale from the PSN_LASTCHANCEAPPLY message since
            // there are probably prop sheet extensions that return both TRUE and
            // FALSE for messages that they dont process...(sigh)
            _Ppd_SendNotify(ppd, nItem, PSN_LASTCHANCEAPPLY, (LPARAM)TRUE);
        }
    }
}


#ifdef MAINWIN
EXTERN_C HKEY HKEY_ROOT;
#endif

// return TRUE iff all sheets successfully handle the notification
BOOL NEAR PASCAL ButtonPushed(LPPROPDATA ppd, WPARAM wParam)
{
    HWND hwndTabs;
    int nItems, nItem;
    int nNotify;
    TC_ITEMEXTRA tie;
    BOOL bExit = FALSE;
    int nReturnNew = ppd->nReturn;
    int fSuccess = TRUE;
    DECLAREWAITCURSOR;
    LRESULT lres = 0;
    LPARAM lParam = FALSE;

    switch (wParam) {
        case IDOK:
            lParam = TRUE;
            bExit = TRUE;
            // Fall through...

        case IDD_APPLYNOW:
            // First allow the current dialog to validate itself.
            if (_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_KILLACTIVE, 0))
                return FALSE;

            nReturnNew = 1;

            nNotify = PSN_APPLY;
            break;

        case IDCLOSE:
            lParam = TRUE;
            // fall through
        case IDCANCEL:
            bExit = TRUE;
            nNotify = PSN_RESET;
            break;

        default:
            return FALSE;
    }

    SetWaitCursor();

    hwndTabs = ppd->hwndTabs;

    tie.tci.mask = TCIF_PARAM;

    nItems = TabCtrl_GetItemCount(hwndTabs);
    for (nItem = 0; nItem < nItems; ++nItem)
    {

        TabCtrl_GetItem(hwndTabs, nItem, &tie.tci);

        if (tie.hwndPage)
        {
            /* If the dialog fails a PSN_APPY call (by returning TRUE),
             ** then it has invalid information on it (should be verified
             ** on the PSN_KILLACTIVE, but that is not always possible)
             ** and we want to abort the notifications.  We select the failed
             ** page below.
             */
            lres = _Ppd_SendNotify(ppd, nItem, nNotify, lParam);

            if (lres)
            {
                fSuccess = FALSE;
                bExit = FALSE;
                break;
            } else {
                // if we need a restart (Apply or OK), then this is an exit
                if ((nNotify == PSN_APPLY) && !bExit && ppd->nRestart) {
                    DebugMsg(DM_TRACE, TEXT("PropertySheet: restart flags force close"));
                    bExit = TRUE;
                }
            }

            /* We have either reset or applied, so everything is
             ** up to date.
             */
            tie.state &= ~FLAG_CHANGED;
            // tie.tci.mask = TCIF_PARAM;    // already set
            TabCtrl_SetItem(hwndTabs, nItem, &tie.tci);
        }
    }

#ifdef MAINWIN
    // This is a temporary solution for saving the
    // registry options incase IE doesnot shutdown
    // normaly.
    if( nNotify == PSN_APPLY )
        RegSaveKey(HKEY_ROOT, NULL, NULL);
#endif

    /* If we leave ppd->hwndCurPage as NULL, it will tell the main
     ** loop to exit.
     */
    if (fSuccess)
    {
        ppd->hwndCurPage = NULL;
    }
    else if (lres != PSNRET_INVALID_NOCHANGEPAGE)
    {
        // Need to change to the page that caused the failure.
        // if lres == PSN_INVALID_NOCHANGEPAGE, then assume sheet has already
        // changed to the page with the invalid information on it
        TabCtrl_SetCurSel(hwndTabs, nItem);
    }

    if (fSuccess)
    {
        // Set to the cached value
        ppd->nReturn = nReturnNew;
    }

    if (!bExit)
    {
        // before PageChange, so ApplyNow gets disabled faster.
        if (fSuccess)
        {
            TCHAR szOK[30];
            HWND hwndApply;

            if (!IS_WIZARD(ppd)) {
                // The ApplyNow button should always be disabled after
                // a successfull apply/cancel, since no change has been made yet.
                hwndApply = GetDlgItem(ppd->hDlg, IDD_APPLYNOW);
                Button_SetStyle(hwndApply, BS_PUSHBUTTON, TRUE);
                EnableWindow(hwndApply, FALSE);
                ResetWizButtons(ppd);
                SendMessage(ppd->hDlg, DM_SETDEFID, IDOK, 0);
                ppd->idDefaultFallback = IDOK;
            }

            // Undo PSM_CANCELTOCLOSE for the same reasons.
            if (ppd->fFlags & PD_CANCELTOCLOSE)
            {
                ppd->fFlags &= ~PD_CANCELTOCLOSE;
                LocalizedLoadString(IDS_OK, szOK, ARRAYSIZE(szOK));
                SetDlgItemText(ppd->hDlg, IDOK, szOK);
                EnableWindow(GetDlgItem(ppd->hDlg, IDCANCEL), TRUE);
            }
        }

        /* Re-"select" the current item and get the whole list to
         ** repaint.
         */
        if (lres != PSNRET_INVALID_NOCHANGEPAGE)
            PageChange(ppd, 1);
    }

    ResetWaitCursor();

    return(fSuccess);
}

//  Win3.1 USER didn't handle DM_SETDEFID very well-- it's very possible to get
//  multiple buttons with the default button style look.  This has been fixed
//  for Win95, but the Setup wizard needs this hack when running from 3.1.

// it seems win95 doesn't handle it well either..
void NEAR PASCAL ResetWizButtons(LPPROPDATA ppd)
{
    int id;

    if (IS_WIZARD(ppd)) {

        for (id = 0; id < ARRAYSIZE(WizIDs); id++)
            SendDlgItemMessage(ppd->hDlg, WizIDs[id], BM_SETSTYLE, BS_PUSHBUTTON, TRUE);
    }
}

void NEAR PASCAL SetWizButtons(LPPROPDATA ppd, LPARAM lParam)
{
    int idDef;
    int iShowID = IDD_NEXT;
    int iHideID = IDD_FINISH;
    BOOL bEnabled;
    BOOL bResetFocus;
    HWND hwndShow;
    HWND hwndFocus = GetFocus();
    HWND hwndHide;
    HWND hwndBack;
    HWND hDlg = ppd->hDlg;

    idDef = (int)LOWORD(SendMessage(hDlg, DM_GETDEFID, 0, 0));

    // Enable/Disable the IDD_BACK button
    hwndBack = GetDlgItem(hDlg, IDD_BACK);
    bEnabled = (lParam & PSWIZB_BACK) != 0;
    EnableWindow(hwndBack, bEnabled);

    // Enable/Disable the IDD_NEXT button, and Next gets shown by default
    // bEnabled remembers whether hwndShow should be enabled or not
    hwndShow = GetDlgItem(hDlg, IDD_NEXT);
    bEnabled = (lParam & PSWIZB_NEXT) != 0;
    EnableWindow(hwndShow, bEnabled);

    // Enable/Disable Show/Hide the IDD_FINISH button
    if (lParam & (PSWIZB_FINISH | PSWIZB_DISABLEDFINISH)) {
        iShowID = IDD_FINISH;           // If Finish is being shown
        iHideID = IDD_NEXT;             // then Next isn't

        hwndShow = GetDlgItem(hDlg, IDD_FINISH);
        bEnabled = (lParam & PSWIZB_FINISH) != 0;
        EnableWindow(hwndShow, bEnabled);
    }

    if (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)) {
        hwndHide = GetDlgItem(hDlg, iHideID);
        ShowWindow(hwndHide, SW_HIDE);
        // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
        // WRONG - EnableWindow(hwndHide, FALSE);

        hwndShow = GetDlgItem(hDlg, iShowID);
        // Cannot disable the window; see Prsht_ButtonSubclassProc for explanation.
        // WRONG - EnableWindow(hwndShow, bEnabled);
        ShowWindow(hwndShow, SW_SHOW);
    }


    // bResetFocus keeps track of whether or not we need to set Focus to our button
    bResetFocus = FALSE;
    if (hwndFocus)
    {
        // if the dude that has focus is a button, we want to steal focus away
        // so users can just press enter all the way through a property sheet,
        // getting the default as they go. this also catches the case
        // of where focus is on one of our buttons which was turned off.
        if (SendMessage(hwndFocus, WM_GETDLGCODE, 0, 0L) & (DLGC_UNDEFPUSHBUTTON|DLGC_DEFPUSHBUTTON))
            bResetFocus = TRUE;
    }
    if (!bResetFocus)
    {
        // if there is no focus or we're focused on an invisible/disabled
        // item on the sheet, grab focus.
        bResetFocus = !hwndFocus ||  !IsWindowVisible(hwndFocus) || !IsWindowEnabled(hwndFocus) ;
    }

    // We used to do this code only if we nuked a button which had default
    // or if bResetFocus. Unfortunately, some wizards turn off BACK+NEXT
    // and then when they turn them back on, they want DEFID on NEXT.
    // So now we always reset DEFID.
    {
        static const int ids[4] = { IDD_NEXT, IDD_FINISH, IDD_BACK, IDCANCEL };
        int i;
        HWND hwndNewFocus = NULL;

        for (i = 0; i < ARRAYSIZE(ids); i++) {
            hwndNewFocus = GetDlgItem(hDlg, ids[i]);

            // can't do IsVisible because we may be doing this
            // before the prop sheet as a whole is shown
            if ((GetWindowLong(hwndNewFocus, GWL_STYLE) & WS_VISIBLE) &&
                IsWindowEnabled(hwndNewFocus)) {
                hwndFocus = hwndNewFocus;
                break;
            }
        }

        ppd->idDefaultFallback = ids[i];
        if (bResetFocus) {
            if (!hwndNewFocus)
                hwndNewFocus = hDlg;
#ifdef WM_NEXTDLGCTL_WORKS
            SetDlgFocus(ppd, hwndNewFocus);
#else
            // 337614 - Since PSM_SETWIZBUTTONS is often a posted message,
            // we may end up here when we don't even have focus at all
            // (caller went on and called MessageBox or something before
            // we got a chance to set the buttons).  So do this only if
            // focus belongs to our dialog box (or if it's nowhere).
            hwndFocus = GetFocus();
            if (!hwndFocus || (ppd->hDlg == hwndFocus || IsChild(ppd->hDlg, hwndFocus)))
                SetFocus(hwndNewFocus);
#endif
        }
        ResetWizButtons(ppd);
        SendMessage(hDlg, DM_SETDEFID, ids[i], 0);

    }
}

//
//  lptie = NULL means "I don't care about the other goop, just give me
//  the index."
//
int NEAR PASCAL FindItem(HWND hwndTabs, HWND hwndPage,  TC_ITEMEXTRA FAR * lptie)
{
    int i;
    TC_ITEMEXTRA tie;

    if (!lptie)
    {
        tie.tci.mask = TCIF_PARAM;
        lptie = &tie;
    }

    for (i = TabCtrl_GetItemCount(hwndTabs) - 1; i >= 0; --i)
    {
        TabCtrl_GetItem(hwndTabs, i, &lptie->tci);

        if (lptie->hwndPage == hwndPage)
        {
            break;
        }
    }

    //this will be -1 if the for loop falls out.
    return i;
}

// a page is telling us that something on it has changed and thus
// "Apply Now" should be enabled

void NEAR PASCAL PageInfoChange(LPPROPDATA ppd, HWND hwndPage)
{
    int i;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    i = FindItem(ppd->hwndTabs, hwndPage, &tie);

    if (i == -1)
        return;

    if (!(tie.state & FLAG_CHANGED))
    {
        // tie.tci.mask = TCIF_PARAM;    // already set
        tie.state |= FLAG_CHANGED;
        TabCtrl_SetItem(ppd->hwndTabs, i, &tie.tci);
    }

    if (ppd->fAllowApply)
        EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), TRUE);
}

// a page is telling us that everything has reverted to its last
// saved state.

void NEAR PASCAL PageInfoUnChange(LPPROPDATA ppd, HWND hwndPage)
{
    int i;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    i = FindItem(ppd->hwndTabs, hwndPage, &tie);

    if (i == -1)
        return;

    if (tie.state & FLAG_CHANGED)
    {
        tie.state &= ~FLAG_CHANGED;
        TabCtrl_SetItem(ppd->hwndTabs, i, &tie.tci);
    }

    // check all the pages, if none are FLAG_CHANGED, disable IDD_APLYNOW
    for (i = ppd->psh.nPages-1 ; i >= 0 ; i--)
    {
        // BUGBUG? Does TabCtrl_GetItem return its information properly?!?

        if (!TabCtrl_GetItem(ppd->hwndTabs, i, &tie.tci))
            break;
        if (tie.state & FLAG_CHANGED)
            break;
    }
    if (i<0)
        EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), FALSE);
}

HDWP Prsht_RepositionControl(LPPROPDATA ppd, HWND hwnd, HDWP hdwp,
                             int dxMove, int dyMove, int dxSize, int dySize)
{
    if (hwnd) {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        MapWindowRect(HWND_DESKTOP, ppd->hDlg, &rc);
        hdwp = DeferWindowPos(hdwp, hwnd, NULL,
                    rc.left + dxMove, rc.top + dyMove,
                    RECTWIDTH(rc) + dxSize, RECTHEIGHT(rc) + dySize,
                    SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return hdwp;
}

//
//  dxSize/(dySize+dyMove) is the amount by which to resize the tab control.
//  dxSize/dySize controls how much the dialog should be grown.
//  Buttons move by (dxSize, dySize+dyMove).
//

BOOL Prsht_ResizeDialog(LPPROPDATA ppd, int dxSize, int dySize, int dyMove)
{
    BOOL fChanged = dxSize || dySize || dyMove;
    if (fChanged)
    {
        int dxMove = 0;     // To make the code more symmetric in x and y
        int dxAll = dxSize + dxMove;
        int dyAll = dySize + dyMove;
        RECT rc;
        UINT i;
        const int *rgid;
        UINT cid;
        HDWP hdwp;
        HWND hwnd;

        // Use DeferWindowPos to avoid flickering.  We expect to move
        // the tab control, up to five buttons, two possible dividers,
        // plus the current page.  (And a partridge in a pear tree.)
        //

        hdwp = BeginDeferWindowPos(1 + 5 + 2 + 1);

        // The tab control just sizes.
        hdwp = Prsht_RepositionControl(ppd, ppd->hwndTabs, hdwp,
                                       0, 0, dxAll, dyAll);

        //
        //  Move and size the current page.  We can't trust its location
        //  or size, since PageChange shoves it around without updating
        //  ppd->ySubDlg.
        //
        if (ppd->hwndCurPage) {
            hdwp = DeferWindowPos(hdwp, ppd->hwndCurPage, NULL,
                        ppd->xSubDlg, ppd->ySubDlg,
                        ppd->cxSubDlg, ppd->cySubDlg,
                        SWP_NOZORDER | SWP_NOACTIVATE);
        }

        //
        //  And our buttons just move by both the size and move (since they
        //  lie below both the tabs and the pages).
        //
        if (IS_WIZARD(ppd)) {
            //
            //  Ooh, wait, reposition the separator lines, too.
            //  Moves vertically but resizes horizontally.
            //
            hwnd = GetDlgItem(ppd->hDlg, IDD_DIVIDER);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           0, dyAll, dxAll, 0);

            //
            //  The top divider does not move vertically since it lies
            //  above the area that is changing.
            //
            hwnd = GetDlgItem(ppd->hDlg, IDD_TOPDIVIDER);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           0, 0, dxAll, 0);

            rgid = WizIDs;
            cid = ARRAYSIZE(WizIDs);
        } else {
            rgid = IDs;
            cid = ARRAYSIZE(IDs);
        }

        for (i = 0 ; i < cid; i++)
        {
            hwnd = GetDlgItem(ppd->hDlg, rgid[i]);
            hdwp = Prsht_RepositionControl(ppd, hwnd, hdwp,
                                           dxAll, dyAll, 0, 0);
        }

        // All finished sizing and moving.  Let 'er rip!
        if (hdwp)
            EndDeferWindowPos(hdwp);

        // Grow ourselves as well
        GetWindowRect(ppd->hDlg, &rc);
        SetWindowPos(ppd->hDlg, NULL, 0, 0,
                     RECTWIDTH(rc) + dxAll, RECTHEIGHT(rc) + dyAll,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }
    return fChanged;
}

BOOL Prsht_RecalcPageSizes(LPPROPDATA ppd)
{
    SIZE siz;
    int dxSize = 0, dySize = 0, dyMove = 0;

    // After inserting or removing a page, the tab control may have
    // changed height.  If so, then we need to resize ourselves to
    // accomodate the growth or shrinkage, so that all the tabs remain
    // visible.
    //
    // APP COMPAT!  We cannot do this by default because Jamba 1.1
    // **FAULTS** if the property sheet changes size after creation.
    // Grrrrrr...

    // Wizards don't have a visible tab control,
    // so do this only for non-wizards
    if (!IS_WIZARD(ppd))
    {
        RECT rc;

        // Get the client rect of the tab control in dialog coords
        GetClientRect(ppd->hwndTabs, &rc);
        MapWindowRect(ppd->hwndTabs, ppd->hDlg, &rc);

        // See how many rows there are now
        TabCtrl_AdjustRect(ppd->hwndTabs, FALSE, &rc);

        // rc.top is the new ySubDlg.  Compute the amount we have to move.
        dyMove = rc.top - ppd->ySubDlg;
        ppd->ySubDlg = rc.top;
    }

    Prsht_GetIdealPageSize(ppd, &siz, GIPS_SKIPEXTERIOR97HEIGHT);
    dxSize = siz.cx - ppd->cxSubDlg;
    dySize = siz.cy - ppd->cySubDlg;
    ppd->cxSubDlg = siz.cx;
    ppd->cySubDlg = siz.cy;
    return Prsht_ResizeDialog(ppd, dxSize, dySize, dyMove);
}

//
//  InsertPropPage
//
//  hpage is the page being inserted.
//
//  hpageInsertAfter described where it should be inserted.
//
//  hpageInsertAfter can be...
//
//      MAKEINTRESOURCE(index) to insert at a specific index.
//
//      NULL to insert at the beginning
//
//      an HPROPSHEETPAGE to insert *after* that page
//
BOOL NEAR PASCAL InsertPropPage(LPPROPDATA ppd, PSP FAR * hpageInsertAfter,
                                PSP FAR * hpage)
{
    TC_ITEMEXTRA tie;
    int nPage;
    HIMAGELIST himl;
    PAGEINFOEX pi;
    PISP pisp;
    int idx;

    hpage = _Hijaak95Hack(ppd, hpage);

    if (!hpage)
        return FALSE;

    if (ppd->psh.nPages >= MAXPROPPAGES)
        return FALSE; // we're full

    if (IS_INTRESOURCE(hpageInsertAfter))
    {
        // Inserting by index
        idx = (int) PtrToLong(hpageInsertAfter);

        // Attempting to insert past the end is the same as appending.
        if (idx > (int)ppd->psh.nPages)
            idx = (int)ppd->psh.nPages;
    }
    else
    {
        // Inserting by hpageInsertAfter.
        for (idx = 0; idx < (int)(ppd->psh.nPages); idx++) {
            if (hpageInsertAfter == GETHPAGE(ppd, idx))
                break;
        }

        if (idx >= (int)(ppd->psh.nPages))
            return FALSE; // hpageInsertAfter not found

        idx++; // idx Points to the insertion location (to the right of hpageInsertAfter)
        ASSERT(hpageInsertAfter == GETHPAGE(ppd, idx-1));
    }

    ASSERT(idx <= (int)(ppd->psh.nPages+1));

    // Shift all pages adjacent to the insertion point to the right
    for (nPage=ppd->psh.nPages - 1; nPage >= idx; nPage--)
        SETPISP(ppd, nPage+1, GETPISP(ppd, nPage));

    // Insert the new page
    pisp = InternalizeHPROPSHEETPAGE(hpage);
    SETPISP(ppd, idx, pisp);

    ppd->psh.nPages++;

    himl = TabCtrl_GetImageList(ppd->hwndTabs);

    if (!GetPageInfoEx(ppd, pisp, &pi, GetMUILanguage(),
                       GPI_ICON | GPI_BRTL | GPI_CAPTION | GPI_FONT | GPI_DIALOGEX))
    {
        DebugMsg(DM_ERROR, TEXT("InsertPropPage: GetPageInfo failed"));
        goto bogus;
    }

    Prsht_ComputeIdealPageSize(ppd, pisp, &pi);

#ifndef WINDOWS_ME
    tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE;
#else
    tie.tci.mask = TCIF_TEXT | TCIF_PARAM | TCIF_IMAGE | (pi.bRTL ? TCIF_RTLREADING : 0);
#endif
    tie.hwndPage = NULL;
    tie.tci.pszText = pi.szCaption;
    tie.state = 0;


    if (pi.hIcon) {
        if (himl)
            tie.tci.iImage = ImageList_AddIcon(himl, pi.hIcon);
        DestroyIcon(pi.hIcon);
    } else {
        tie.tci.iImage = -1;
    }

    // Insert the page into the tab list
    TabCtrl_InsertItem(ppd->hwndTabs, idx, &tie.tci);

    // If this page wants premature initialization then init it
    // do this last so pages can rely on "being there" at init time
    if (pisp->_psp.dwFlags & PSP_PREMATURE)
    {
        if ((tie.hwndPage = _CreatePage(ppd, pisp, ppd->hDlg, GetMUILanguage())) == NULL)
        {
            TabCtrl_DeleteItem(ppd->hwndTabs, idx);
            // don't free the pisp here let the caller do it
            // BUGBUG raymondc - but caller doesn't know if hIcon has been destroyed
            goto bogus;
        }

        tie.tci.mask = TCIF_PARAM;
        TabCtrl_SetItem(ppd->hwndTabs, idx, &tie.tci);
    }

    // Adjust the internally track current item if it is to the right of our insertion point
    if (ppd->nCurItem >= idx)
        ppd->nCurItem++;

    return TRUE;

bogus:
    // Shift everything back
    for (nPage=idx; nPage < (int)(ppd->psh.nPages-1); nPage++)
        SETPISP(ppd, nPage, GETPISP(ppd, nPage+1));

    ppd->psh.nPages--;
    return FALSE;
}

#define AddPropPage(ppd, hpage) InsertPropPage(ppd, (LPVOID)MAKEINTRESOURCE(-1), hpage)

// removes property sheet hpage (index if NULL)
void NEAR PASCAL RemovePropPage(LPPROPDATA ppd, int index, HPROPSHEETPAGE hpage)
{
    int i = -1;
    BOOL fReturn = TRUE;
    TC_ITEMEXTRA tie;

    //
    //  Notice that we explicitly do not do a InternalizeHPROPSHEETPAGE,
    //  because the app might be passing us garbage.  We just want to
    //  say "Nope, can't find garbage here, sorry."
    //

    tie.tci.mask = TCIF_PARAM;
    if (hpage) {
        i = FindPageIndexByHpage(ppd, hpage);
    }
    if (i == -1) {
        i = index;

        // this catches i < 0 && i >= (int)(ppd->psh.nPages)
        if ((UINT)i >= ppd->psh.nPages)
        {
            DebugMsg(DM_ERROR, TEXT("RemovePropPage: invalid page"));
            return;
        }
    }

    index = TabCtrl_GetCurSel(ppd->hwndTabs);
    if (i == index) {
        // if we're removing the current page, select another (don't worry
        // about this page having invalid information on it -- we're nuking it)
        PageChanging(ppd);

        if (index == 0)
            index++;
        else
            index--;

        if (SendMessage(ppd->hwndTabs, TCM_SETCURSEL, index, 0L) == -1) {
            // if we couldn't select (find) the new one, punt to 0th
            SendMessage(ppd->hwndTabs, TCM_SETCURSEL, 0, 0L);
        }
        PageChange(ppd, 1);
    }

    // BUGBUG if removing a page below ppd->nCurItem, need to update
    // nCurItem to prevent it from getting out of sync with hwndCurPage?

    tie.tci.mask = TCIF_PARAM;
    TabCtrl_GetItem(ppd->hwndTabs, i, &tie.tci);
    if (tie.hwndPage) {
        if (ppd->hwndCurPage == tie.hwndPage)
            ppd->hwndCurPage = NULL;
        DestroyWindow(tie.hwndPage);
    }

    RemovePropPageData(ppd, i);
}

void NEAR PASCAL RemovePropPageData(LPPROPDATA ppd, int nPage)
{
    TabCtrl_DeleteItem(ppd->hwndTabs, nPage);
    DestroyPropertySheetPage(GETHPAGE(ppd, nPage));

    //
    //  Delete the HPROPSHEETPAGE from our table and slide everybody down.
    //
    ppd->psh.nPages--;
    hmemcpy(&ppd->psh.H_phpage[nPage], &ppd->psh.H_phpage[nPage + 1],
            sizeof(ppd->psh.H_phpage[0]) * (ppd->psh.nPages - nPage));
}

// returns TRUE iff the page was successfully set to index/hpage
// Note:  The iAutoAdj should be set to 1 or -1.  This value is used
//        by PageChange if a page refuses a SETACTIVE to either increment
//        or decrement the page index.
BOOL NEAR PASCAL PageSetSelection(LPPROPDATA ppd, int index, HPROPSHEETPAGE hpage,
                                  int iAutoAdj)
{
    int i = -1;
    BOOL fReturn = FALSE;
    TC_ITEMEXTRA tie;

    tie.tci.mask = TCIF_PARAM;
    if (hpage) {
        for (i = ppd->psh.nPages - 1; i >= 0; i--) {
            if (hpage == GETHPAGE(ppd, i))
                break;
        }
    }
    if (i == -1) {
        if (index == -1)
            return FALSE;

        i = index;
    }
    if (i >= MAXPROPPAGES)
    {
        // don't go off the end of our HPROPSHEETPAGE array
        return FALSE;
    }

    fReturn = !PageChanging(ppd);
    if (fReturn)
    {
        index = TabCtrl_GetCurSel(ppd->hwndTabs);
        if (SendMessage(ppd->hwndTabs, TCM_SETCURSEL, i, 0L) == -1) {
            // if we couldn't select (find) the new one, fail out
            // and restore the old one
            SendMessage(ppd->hwndTabs, TCM_SETCURSEL, index, 0L);
            fReturn = FALSE;
        }
        PageChange(ppd, iAutoAdj);
    }
    return fReturn;
}

LRESULT NEAR PASCAL QuerySiblings(LPPROPDATA ppd, WPARAM wParam, LPARAM lParam)
{
    UINT i;
    for (i = 0 ; i < ppd->psh.nPages ; i++)
    {
        HWND hwndSibling = _Ppd_GetPage(ppd, i);
        if (hwndSibling)
        {
            LRESULT lres = SendMessage(hwndSibling, PSM_QUERYSIBLINGS, wParam, lParam);
            if (lres)
                return lres;
        }
    }
    return FALSE;
}

// REVIEW HACK This gets round the problem of having a hotkey control
// up and trying to enter the hotkey that is already in use by a window.
BOOL NEAR PASCAL HandleHotkey(LPARAM lparam)
{
    WORD wHotkey;
    TCHAR szClass[32];
    HWND hwnd;

    // What hotkey did the user type hit?
    wHotkey = (WORD)SendMessage((HWND)lparam, WM_GETHOTKEY, 0, 0);
    // Were they typing in a hotkey window?
    hwnd = GetFocus();
    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    if (lstrcmp(szClass, HOTKEY_CLASS) == 0)
    {
        // Yes.
        SendMessage(hwnd, HKM_SETHOTKEY, wHotkey, 0);
        return TRUE;
    }
    return FALSE;
}


//
//  Function handles Next and Back functions for wizards.  The code will
//  be either PSN_WIZNEXT or PSN_WIZBACK
//
BOOL NEAR PASCAL WizNextBack(LPPROPDATA ppd, int code)
{
    LRESULT   dwFind;
    int iPageIndex;
    int iAutoAdj = (code == PSN_WIZNEXT) ? 1 : -1;

    dwFind = _Ppd_SendNotify(ppd, ppd->nCurItem, code, 0);

    if (dwFind == -1) {
        return(FALSE);
    }

    iPageIndex = FindPageIndex(ppd, ppd->nCurItem, dwFind, iAutoAdj);

    if (iPageIndex == -1) {
        return(FALSE);
    }

    return(PageSetSelection(ppd, iPageIndex, NULL, iAutoAdj));
}

BOOL NEAR PASCAL Prsht_OnCommand(LPPROPDATA ppd, int id, HWND hwndCtrl, UINT codeNotify)
{

    //
    //  There's a bug in USER that when the user highlights a defpushbutton
    //  and presses ENTER, the WM_COMMAND is sent to the top-level dialog
    //  (i.e., the property sheet) instead of to the parent of the button.
    //  So if a property sheet page has a control whose ID coincidentally
    //  matches any of our own, we will think it's ours instead of theirs.
    if (hwndCtrl && GetParent(hwndCtrl) != ppd->hDlg)
        goto Forward;

    if (!hwndCtrl)
        hwndCtrl = GetDlgItem(ppd->hDlg, id);

    switch (id) {

        case IDCLOSE:
        case IDCANCEL:
            if (_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_QUERYCANCEL, 0) == 0) {
                ButtonPushed(ppd, id);
            }
            break;

        case IDD_APPLYNOW:
        case IDOK:
            if (!IS_WIZARD(ppd)) {

                //ButtonPushed returns true if and only if all pages have processed PSN_LASTCHANCEAPPLY
                if (ButtonPushed(ppd, id))
                {

                    //Everyone has processed the PSN_APPLY Message.  Now send PSN_LASTCHANCEAPPLY message.

                    //
                    // HACKHACK (reinerF)
                    //
                    // We send out a private PSN_LASTCHANCEAPPLY message telling all the pages
                    // that everyone is done w/ the apply. This is needed for pages who have to do
                    // something after every other page has applied. Currently, the "General" tab
                    // of the file properties needs a last-chance to rename files as well as new print
                    // dialog in  comdlg32.dll.
                    SendLastChanceApply(ppd);
                }
            }
            break;


        case IDHELP:
            if (IsWindowEnabled(hwndCtrl))
            {
                _Ppd_SendNotify(ppd, ppd->nCurItem, PSN_HELP, 0);
            }
            break;

        case IDD_FINISH:
        {
            HWND hwndNewFocus;
            EnableWindow(ppd->hDlg, FALSE);
            hwndNewFocus = (HWND)_Ppd_SendNotify(ppd, ppd->nCurItem, PSN_WIZFINISH, 0);
            // b#11346 - dont let multiple clicks on FINISH.
            if (!hwndNewFocus)
            {
                ppd->hwndCurPage = NULL;
                ppd->nReturn = 1;
            }
            else
            {
                EnableWindow(ppd->hDlg, TRUE);
                if (IsWindow(hwndNewFocus) && IsChild(ppd->hDlg, hwndNewFocus))
#ifdef WM_NEXTDLGCTL_WORKS
                    SetDlgFocus(ppd, hwndNewFocus);
#else
                    SetFocus(hwndNewFocus);
#endif
            }
        }
        break;

        case IDD_NEXT:
        case IDD_BACK:
            ppd->idDefaultFallback = id;
            WizNextBack(ppd, id == IDD_NEXT ? PSN_WIZNEXT : PSN_WIZBACK);
            break;

        default:
Forward:
            FORWARD_WM_COMMAND(_Ppd_GetPage(ppd, ppd->nCurItem), id, hwndCtrl, codeNotify, SendMessage);
    }

    return TRUE;
}

BOOL NEAR PASCAL Prop_IsDialogMessage(LPPROPDATA ppd, LPMSG32 pmsg32)
{
    if ((pmsg32->message == WM_KEYDOWN) && (GetKeyState(VK_CONTROL) < 0))
    {
        BOOL bBack = FALSE;

        switch (pmsg32->wParam) {
            case VK_TAB:
                bBack = GetKeyState(VK_SHIFT) < 0;
                break;

            case VK_PRIOR:  // VK_PAGE_UP
            case VK_NEXT:   // VK_PAGE_DOWN
                bBack = (pmsg32->wParam == VK_PRIOR);
                break;

            default:
                goto NoKeys;
        }
#ifdef KEYBOARDCUES
        //notify of navigation key usage
        SendMessage(ppd->hDlg, WM_CHANGEUISTATE, 
            MAKELONG(UIS_CLEAR, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
#endif

        if (IS_WIZARD(ppd))
        {
            int idWiz;
            int idDlg;
            HWND hwnd;

            if (bBack) {
                idWiz = PSN_WIZBACK;
                idDlg = IDD_BACK;
            } else {
                idWiz = PSN_WIZNEXT;
                idDlg = IDD_NEXT;
            }

            hwnd = GetDlgItem(ppd->hDlg, idDlg);
            if (IsWindowVisible(hwnd) && IsWindowEnabled(hwnd))
                WizNextBack(ppd, idWiz);
        }
        else
        {
            int iStart = TabCtrl_GetCurSel(ppd->hwndTabs);
            int iCur;

            //
            //  Skip over hidden tabs, but don't go into an infinite loop.
            //
            iCur = iStart;
            do {
                // tab in reverse if shift is down
                if (bBack)
                    iCur += (ppd->psh.nPages - 1);
                else
                    iCur++;

                iCur %= ppd->psh.nPages;
            } while (_Ppd_IsPageHidden(ppd, iCur) && iCur != iStart);
            PageSetSelection(ppd, iCur, NULL, 1);
        }
        return TRUE;
    }
NoKeys:

    //
    //  Since we now send out a PSN_TRANSLATEACCELERATOR, add a
    //  short-circuit so we don't do all this work for things
    //  that can't possibly be accelerators.
    //
    if (pmsg32->message >= WM_KEYFIRST && pmsg32->message <= WM_KEYLAST &&

    // And there had better be a target window...

        pmsg32->hwnd &&

    // and the target window must live either outside the propsheet
    // altogether or completely inside the propsheet page.
    // (This is so that the propsheet can display its own popup dialog,
    // but can't futz with the tab control or OK/Cancel buttons.)

            (!IsChild(ppd->hDlg, pmsg32->hwnd) ||
              IsChild(ppd->hwndCurPage, pmsg32->hwnd)) &&

    // Then ask the propsheet if he wants to eat it.
        _Ppd_SendNotify(ppd, ppd->nCurItem,
                        PSN_TRANSLATEACCELERATOR, (LPARAM)pmsg32) == PSNRET_MESSAGEHANDLED)
        return TRUE;

    if (IsDialogMessage32(ppd->hDlg, pmsg32, TRUE))
        return TRUE;

    return FALSE;
}

HRESULT Prsht_GetObject (LPPROPDATA ppd, HWND hDlg, int iItem, const IID *piid, void **pObject)
{
    TC_ITEMEXTRA tie;
    NMOBJECTNOTIFY non;
    PISP pisp = GETPISP(ppd, iItem);
    *pObject = NULL;

    tie.tci.mask = TCIF_PARAM;
    TabCtrl_GetItem(ppd->hwndTabs, iItem, &tie.tci);
    if (!tie.hwndPage && ((tie.hwndPage = _CreatePage(ppd, pisp, hDlg, GetMUILanguage())) == NULL))
    {
        RemovePropPageData(ppd, iItem);
        return E_UNEXPECTED;
    }
    TabCtrl_SetItem(ppd->hwndTabs, iItem, &tie.tci);

    non.iItem = -1;
    non.piid = piid;
    non.pObject = NULL;
    non.hResult = E_NOINTERFACE;
    non.dwFlags = 0;

    SendNotifyEx (tie.hwndPage, ppd->hwndTabs, PSN_GETOBJECT,
                  &non.hdr,
#ifdef UNICODE
                  TRUE
#else
                  FALSE
#endif //UNICODE
                 );
    if (SUCCEEDED (non.hResult))
    {
        *pObject = non.pObject;
        if (pObject == NULL)
            non.hResult = E_UNEXPECTED;
    }
    else if (non.pObject)
    {
        ((LPDROPTARGET) non.pObject)->lpVtbl->Release ((LPDROPTARGET) non.pObject);
        non.pObject = NULL;
    }
    return non.hResult;
}

//
//  We would not normally need IDD_PAGELIST except that DefWindowProc() and
//  WinHelp() do hit-testing differently.  DefWindowProc() will do cool
//  things like checking against the SetWindowRgn and skipping over windows
//  that return HTTRANSPARENT.  WinHelp() on the other hand
//  ignores window regions and transparency.  So what happens is if you
//  click on the transparent part of a tab control, DefWindowProc() says
//  (correctly) "He clicked on the dialog background".  We then say, "Okay,
//  WinHelp(), go display context help for the dialog background", and it
//  says, "Hey, I found a tab control.  I'm going to display help for the
//  tab control now."  To keep a bogus context menu from appearing, we
//  explicitly tell WinHelp that "If you found a tab control (IDD_PAGELIST),
//  then ignore it (NO_HELP)."
//
const static DWORD aPropHelpIDs[] = {  // Context Help IDs
    IDD_APPLYNOW, IDH_COMM_APPLYNOW,
    IDD_PAGELIST, NO_HELP,
    0, 0
};


void HandlePaletteChange(LPPROPDATA ppd, UINT uMessage, HWND hDlg)
{
    HDC hdc;
    hdc = GetDC(hDlg);
    if (hdc)
    {
        BOOL fRepaint;
        SelectPalette(hdc,ppd->hplWatermark,(uMessage == WM_PALETTECHANGED));
        fRepaint = RealizePalette(hdc);
        if (fRepaint)
            InvalidateRect(hDlg,NULL,TRUE);
    }
    ReleaseDC(hDlg,hdc);
}

//
//  Paint a rectangle with the specified brush and palette.
//
void PaintWithPaletteBrush(HDC hdc, LPRECT lprc, HPALETTE hplPaint, HBRUSH hbrPaint)
{
    HBRUSH hbrPrev = SelectBrush(hdc, hbrPaint);
    UnrealizeObject(hbrPaint);
    if (hplPaint)
    {
        SelectPalette(hdc, hplPaint, FALSE);
        RealizePalette(hdc);
    }
    FillRect(hdc, lprc, hbrPaint);
    SelectBrush(hdc, hbrPrev);
}

//
//  lprc is the target rectangle.
//  Use as much of the bitmap as will fit into the target rectangle.
//  If the bitmap is smaller than the target rectangle, then fill the rest with
//  the pixel in the upper left corner of the hbmpPaint.
//
void PaintWithPaletteBitmap(HDC hdc, LPRECT lprc, HPALETTE hplPaint, HBITMAP hbmpPaint)
{
    HDC hdcBmp;
    BITMAP bm;
    int cxRect, cyRect, cxBmp, cyBmp;

    GetObject(hbmpPaint, sizeof(BITMAP), &bm);
    hdcBmp = CreateCompatibleDC(hdc);
    SelectObject(hdcBmp, hbmpPaint);

    if (hplPaint)
    {
        SelectPalette(hdc, hplPaint, FALSE);
        RealizePalette(hdc);
    }

    cxRect = RECTWIDTH(*lprc);
    cyRect = RECTHEIGHT(*lprc);

    //  Never use more pixels from the bmp as we have room in the rect.
    cxBmp = min(bm.bmWidth, cxRect);
    cyBmp = min(bm.bmHeight, cyRect);

    BitBlt(hdc, lprc->left, lprc->top, cxBmp, cyBmp, hdcBmp, 0, 0, SRCCOPY);

    // If bitmap is too narrow, then StretchBlt to fill the width.
    if (cxBmp < cxRect)
        StretchBlt(hdc, lprc->left + cxBmp, lprc->top,
                   cxRect - cxBmp, cyBmp,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    // If bitmap is to short, then StretchBlt to fill the height.
    if (cyBmp < cyRect)
        StretchBlt(hdc, lprc->left, cyBmp,
                   cxRect, cyRect - cyBmp,
                   hdcBmp, 0, 0, 1, 1, SRCCOPY);

    DeleteDC(hdcBmp);
}

void _SetHeaderTitles(HWND hDlg, LPPROPDATA ppd, UINT uPage, LPCTSTR pszNewTitle, BOOL bTitle)
{
    PISP pisp = NULL;

    // Must be for wizard97 
    if (ppd->psh.dwFlags & PSH_WIZARD97)
    {
        // Page number must be within range
        if (uPage < ppd->psh.nPages)
        {
            // Get the page structure
            pisp = GETPISP(ppd, uPage);

            // We should have this page if it's within range
            ASSERT(pisp);

            // Do this only if this page has header.
            if (!(pisp->_psp.dwFlags & PSP_HIDEHEADER))
            {
                LPCTSTR pszOldTitle = bTitle ? pisp->_psp.pszHeaderTitle : pisp->_psp.pszHeaderSubTitle; 

                if (!IS_INTRESOURCE(pszOldTitle))
                    LocalFree((LPVOID)pszOldTitle);

                // Set the new title
                if (bTitle)
                    pisp->_psp.pszHeaderTitle = pszNewTitle;
                else
                    pisp->_psp.pszHeaderSubTitle = pszNewTitle;

                // set pszNewTitle to NULL here so that we don't free it later
                pszNewTitle = NULL;
                
                // set the correct flags
                pisp->_psp.dwFlags |= bTitle ? PSP_USEHEADERTITLE : PSP_USEHEADERSUBTITLE;

                // force redrawing of the titles
                if (uPage == (UINT)ppd->nCurItem)
                {
                    RECT rcHeader;
                    GetClientRect(hDlg, &rcHeader);
                    rcHeader.bottom = ppd->cyHeaderHeight;

                    InvalidateRect(hDlg, &rcHeader, FALSE);
                }
            }
        }
    }

    if (pszNewTitle)
        LocalFree((LPVOID)pszNewTitle);
}

void PropSheetPaintHeader(LPPROPDATA ppd, PISP pisp, HWND hDlg, HDC hdc)
{
    RECT rcHeader,rcHeaderBitmap;
    GetClientRect(hDlg, &rcHeader);
    rcHeader.bottom = ppd->cyHeaderHeight;

    // do we need to paint the header?
    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
    {
        // Do it the WIZARD97IE4 way

        // Bug-for-bug compatibility:  WIZARD97IE4 tested the wrong flag here
        if ((ppd->psh.dwFlags & PSH_WATERMARK) && (ppd->hbrWatermark))
            PaintWithPaletteBrush(hdc, &rcHeader, ppd->hplWatermark, ppd->hbrHeader);
        SetBkMode(hdc, TRANSPARENT);
    }
    else
    {
        // Do it the WIZARD97IE5 way
        if ((ppd->psh.dwFlags & PSH_HEADER) && (ppd->hbmHeader))
        {
            // compute the rectangle for the bitmap depending on the size of the header
            int bx = RECTWIDTH(rcHeader) - HEADERBITMAP_CXBACK;
            ASSERT(bx > 0);
            FillRect(hdc, &rcHeader, g_hbrWindow);
            SetRect(&rcHeaderBitmap, bx, HEADERBITMAP_Y, bx + HEADERBITMAP_WIDTH, HEADERBITMAP_Y + HEADERBITMAP_HEIGHT);
            PaintWithPaletteBitmap(hdc, &rcHeaderBitmap, ppd->hplWatermark, ppd->hbmHeader);
            SetBkColor(hdc, g_clrWindow);
            SetTextColor(hdc, g_clrWindowText);
        }
        else
            SendMessage(hDlg, WM_CTLCOLORSTATIC, (WPARAM)hdc, (LPARAM)hDlg);
    }

    //
    //  WIZARD97IE5 subtracts out the space used by the header bitmap.
    //  WIZARD97IE4 uses the full width since the header bitmap
    //  in IE4 is a watermark and occupies no space.
    //
    if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
        rcHeader.right -= HEADERBITMAP_CXBACK + HEADERSUBTITLE_WRAPOFFSET;

    ASSERT(rcHeader.right);

    if (HASHEADERTITLE(pisp))
        _WriteHeaderTitle(ppd, hdc, &rcHeader, pisp->_psp.pszHeaderTitle,
                          TRUE, DRAWTEXT_WIZARD97FLAGS);

    if (HASHEADERSUBTITLE(pisp))
        _WriteHeaderTitle(ppd, hdc, &rcHeader, pisp->_psp.pszHeaderSubTitle,
                          FALSE, DRAWTEXT_WIZARD97FLAGS);
}

// Free the title if we need to
void Prsht_FreeTitle(LPPROPDATA ppd)
{
    if (ppd->fFlags & PD_FREETITLE) {
        ppd->fFlags &= ~PD_FREETITLE;
        if (!IS_INTRESOURCE(ppd->psh.pszCaption)) {
            LocalFree((LPVOID)ppd->psh.pszCaption);
        }
    }
}

//
//  pfnStrDup is the function that converts lParam into a native character
//  set string.  (Either StrDup or StrDup_AtoW).
//
void Prsht_OnSetTitle(LPPROPDATA ppd, WPARAM wParam, LPARAM lParam, STRDUPPROC pfnStrDup)
{
    LPTSTR pszTitle;

    //
    //  The ppd->psh.pszCaption is not normally LocalAlloc()d; it's
    //  just a pointer copy.  But if the app does a PSM_SETTITLE,
    //  then all of a sudden it got LocalAlloc()d and needs to be
    //  freed.  PD_FREETITLE is the flag that tell us that this has
    //  happened.
    //

    if (IS_INTRESOURCE(lParam)) {
        pszTitle = (LPTSTR)lParam;
    } else {
        pszTitle = pfnStrDup((LPTSTR)lParam);
    }

    if (pszTitle) {
        Prsht_FreeTitle(ppd);           // Free old title if necessary

        ppd->psh.pszCaption = pszTitle;
        ppd->fFlags |= PD_FREETITLE;    // Need to free this

        ppd->psh.dwFlags = ((((DWORD)wParam) & PSH_PROPTITLE) | (ppd->psh.dwFlags & ~PSH_PROPTITLE));
        _SetTitle(ppd->hDlg, ppd);
    }
}

BOOL_PTR CALLBACK PropSheetDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndT;
    LPPROPDATA ppd = (LPPROPDATA)GetWindowLongPtr(hDlg, DWLP_USER);
    LRESULT lres;

    if (!ppd && (uMessage != WM_INITDIALOG))
        return FALSE;

    switch (uMessage)
    {
        case WM_INITDIALOG:
            InitPropSheetDlg(hDlg, (LPPROPDATA)lParam);
            return FALSE;

            // REVIEW for dealing with hotkeys.
            // BUGBUG: This code might not work with 32-bit WM_SYSCOMMAND msgs.
        case WM_SYSCOMMAND:
            if (wParam == SC_HOTKEY)
                return HandleHotkey(lParam);
            else if (wParam == SC_CLOSE)
            {
                UINT id = IDCLOSE;

                if (IS_WIZARD(ppd))
                    id = IDCANCEL;
                else if (ppd->fFlags & PD_CANCELTOCLOSE)
                    id = IDOK;

                // system menu close should be IDCANCEL, but if we're in the
                // PSM_CANCELTOCLOSE state, treat it as an IDOK (ie, "Close").
                return Prsht_OnCommand(ppd, id, NULL, 0);
            }

            return FALSE;      // Let default process happen

        case WM_NCDESTROY:
            {
                int iPage;

                ASSERT(GetDlgItem(hDlg, IDD_PAGELIST) == NULL);

                ppd->hwndTabs = NULL;

                // NOTE: all of the hwnds for the pages must be destroyed by now!

                // Release all page objects in REVERSE ORDER so we can have
                // pages that are dependant on eachother based on the initial
                // order of those pages
                //
                for (iPage = ppd->psh.nPages - 1; iPage >= 0; iPage--)
                {
                    DestroyPropertySheetPage(GETHPAGE(ppd, iPage));
                }
                // hwndCurPage is no longer valid from here on
                ppd->hwndCurPage = NULL;

                // If we are modeless, we need to free our ppd.  If we are modal,
                // we let _RealPropertySheet free it since one of our pages may
                // set the restart flag during DestroyPropertySheetPage above.
                if (ppd->psh.dwFlags & PSH_MODELESS)
                {
                    LocalFree(ppd);
                }
            }
            //
            // NOTES:
            //  Must return FALSE to avoid DS leak!!!
            //
            return FALSE;

        case WM_DESTROY:
            {
                // Destroy the image list we created during our init call.
                HIMAGELIST himl = TabCtrl_GetImageList(ppd->hwndTabs);
                if (himl)
                    ImageList_Destroy(himl);

                if (ppd->psh.dwFlags & PSH_WIZARD97)
                {

                    // Even if the PSH_USEHBMxxxxxx flag is set, we might
                    // need to delete the bitmap if we had to create a
                    // stretched copy.

                    if (ppd->psh.dwFlags & PSH_WATERMARK)
                    {
                        if ((!(ppd->psh.dwFlags & PSH_USEHBMWATERMARK) ||
                            ppd->hbmWatermark != ppd->psh.H_hbmWatermark) &&
                            ppd->hbmWatermark)
                            DeleteObject(ppd->hbmWatermark);

                        if (!(ppd->psh.dwFlags & PSH_USEHPLWATERMARK) &&
                            ppd->hplWatermark)
                            DeleteObject(ppd->hplWatermark);

                        if (ppd->hbrWatermark)
                            DeleteObject(ppd->hbrWatermark);
                    }

                    if ((ppd->psh.dwFlags & PSH_HEADER) && ppd->psh.H_hbmHeader)
                    {
                        if ((!(ppd->psh.dwFlags & PSH_USEHBMHEADER) ||
                            ppd->hbmHeader != ppd->psh.H_hbmHeader) &&
                            ppd->hbmHeader)
                        {
                            ASSERT(ppd->hbmHeader != ppd->hbmWatermark);
                            DeleteObject(ppd->hbmHeader);
                        }

                        if (ppd->hbrHeader)
                        {
                            ASSERT(ppd->hbrHeader != ppd->hbrWatermark);
                            DeleteObject(ppd->hbrHeader);
                        }
                    }

                    if (ppd->hFontBold)
                        DeleteObject(ppd->hFontBold);
                }

                if ((ppd->psh.dwFlags & PSH_USEICONID) && ppd->psh.H_hIcon)
                    DestroyIcon(ppd->psh.H_hIcon);

                Prsht_FreeTitle(ppd);
            }

            break;

        case WM_ERASEBKGND:
            return ppd->fFlags & PD_NOERASE;
            break;

        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc;
            PISP pisp;

            hdc = BeginPaint(hDlg, &ps);
            // (dli) paint the header
            if ((ppd->psh.dwFlags & PSH_WIZARD97) &&
                (!((pisp = GETPISP(ppd, ppd->nCurItem))->_psp.dwFlags & PSP_HIDEHEADER)))
            {
                PropSheetPaintHeader(ppd, pisp, hDlg, hdc);
            }

            if (ps.fErase) {
                SendMessage (hDlg, WM_ERASEBKGND, (WPARAM) hdc, 0);
            }

            EndPaint(hDlg, &ps);
        }
        break;

        case WM_COMMAND:
            // Cannot use HANDLE_WM_COMMAND, because we want to pass a result!
            return Prsht_OnCommand(ppd, GET_WM_COMMAND_ID(wParam, lParam),
                                   GET_WM_COMMAND_HWND(wParam, lParam),
                                   GET_WM_COMMAND_CMD(wParam, lParam));

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code)
            {
                case TCN_SELCHANGE:
                    PageChange(ppd, 1);
                    break;

                case TCN_SELCHANGING:
                {
                    lres = PageChanging(ppd);
                    if (!lres) {
                        SetWindowPos(ppd->hwndCurPage, HWND_BOTTOM, 0,0,0,0, SWP_NOACTIVATE | SWP_NOSIZE |SWP_NOMOVE);
                    }
                    goto ReturnLres;
                }
                break;

                case TCN_GETOBJECT:
                {
                    LPNMOBJECTNOTIFY lpnmon = (LPNMOBJECTNOTIFY)lParam;

                    lpnmon->hResult = Prsht_GetObject(ppd, hDlg, lpnmon->iItem,
                        lpnmon->piid, &lpnmon->pObject);
                }
                break;

                default:
                    return FALSE;
            }
            return TRUE;

        case PSM_SETWIZBUTTONS:
            SetWizButtons(ppd, lParam);
            break;

#ifdef UNICODE
        case PSM_SETFINISHTEXTA:
#endif
        case PSM_SETFINISHTEXT:
        {
            HWND    hFinish = GetDlgItem(hDlg, IDD_FINISH);
            HWND hwndFocus = GetFocus();
            HWND hwnd;
            BOOL fSetFocus = FALSE;

            if (!(ppd->psh.dwFlags & PSH_WIZARDHASFINISH)) {
                hwnd = GetDlgItem(hDlg, IDD_NEXT);
                if (hwnd == hwndFocus)
                    fSetFocus = TRUE;
                ShowWindow(hwnd, SW_HIDE);
            }

            hwnd = GetDlgItem(hDlg, IDD_BACK);
            if (hwnd == hwndFocus)
                fSetFocus = TRUE;
            ShowWindow(hwnd, SW_HIDE);

            if (lParam) {
#ifdef UNICODE
                if (uMessage == PSM_SETFINISHTEXTA) {
                    SetWindowTextA(hFinish, (LPSTR)lParam);
                } else
#endif
                    Button_SetText(hFinish, (LPTSTR)lParam);
            }
            ShowWindow(hFinish, SW_SHOW);
            Button_Enable(hFinish, TRUE);
            ResetWizButtons(ppd);
            SendMessage(hDlg, DM_SETDEFID, IDD_FINISH, 0);
            ppd->idDefaultFallback = IDD_FINISH;
            if (fSetFocus)
#ifdef WM_NEXTDLGCTL_WORKS
                SetDlgFocus(ppd, hFinish);
#else
                SetFocus(hFinish);
#endif
        }
        break;

#ifdef UNICODE
        case PSM_SETTITLEA:
            Prsht_OnSetTitle(ppd, wParam, lParam, StrDup_AtoW);
            break;
#endif

        case PSM_SETTITLE:
            Prsht_OnSetTitle(ppd, wParam, lParam, StrDup);
            break;

#ifdef UNICODE
        case PSM_SETHEADERTITLEA:
        {
            LPWSTR lpHeaderTitle = (lParam && HIWORD(lParam)) ?
                                   ProduceWFromA(CP_ACP, (LPCSTR)lParam) : StrDupW((LPWSTR)lParam);
            if (lpHeaderTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderTitle, TRUE); 
        }
        break;
#endif
        case PSM_SETHEADERTITLE:
        {
            LPTSTR lpHeaderTitle = StrDup((LPCTSTR)lParam);
            if (lpHeaderTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderTitle, TRUE); 
        }
        break;
            
#ifdef UNICODE
        case PSM_SETHEADERSUBTITLEA:
        {
            LPWSTR lpHeaderSubTitle = (lParam && HIWORD(lParam)) ?
                                   ProduceWFromA(CP_ACP, (LPCSTR)lParam) : StrDupW((LPWSTR)lParam);
            if (lpHeaderSubTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderSubTitle, FALSE); 
        }
        break;
#endif
        case PSM_SETHEADERSUBTITLE:
        {
            LPTSTR lpHeaderSubTitle = StrDup((LPCTSTR)lParam);
            if (lpHeaderSubTitle) 
                _SetHeaderTitles(hDlg, ppd, (UINT)wParam, lpHeaderSubTitle, FALSE); 
        }
        break;
            
        case PSM_CHANGED:
            PageInfoChange(ppd, (HWND)wParam);
            break;

        case PSM_RESTARTWINDOWS:
            ppd->nRestart |= ID_PSRESTARTWINDOWS;
            break;

        case PSM_REBOOTSYSTEM:
            ppd->nRestart |= ID_PSREBOOTSYSTEM;
            break;

        case PSM_DISABLEAPPLY:
            // the page is asking us to gray the "Apply" button and not let
            // anyone else re-enable it
            if (ppd->fAllowApply)
            {
                ppd->fAllowApply = FALSE;
                EnableWindow(GetDlgItem(ppd->hDlg, IDD_APPLYNOW), FALSE);
            }
            break;

        case PSM_ENABLEAPPLY:
            // the page is asking us to allow the the "Apply" button to be
            // once again enabled
            if (!ppd->fAllowApply)
                ppd->fAllowApply = TRUE;
            // BUGBUG - raymondc - shouldn't we call EnableWindow?
            break;

        case PSM_CANCELTOCLOSE:
            if (!(ppd->fFlags & PD_CANCELTOCLOSE))
            {
                TCHAR szClose[20];
                ppd->fFlags |= PD_CANCELTOCLOSE;
                LocalizedLoadString(IDS_CLOSE, szClose, ARRAYSIZE(szClose));
                SetDlgItemText(hDlg, IDOK, szClose);
                EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
            }
            break;

        case PSM_SETCURSEL:
            lres = PageSetSelection(ppd, (int)wParam, (HPROPSHEETPAGE)lParam, 1);
            goto ReturnLres;

        case PSM_SETCURSELID:
        {
            int iPageIndex;

            iPageIndex =  FindPageIndex(ppd, ppd->nCurItem, (DWORD)lParam, 1);

            if (iPageIndex == -1)
                lres = 0;
            else
                lres = PageSetSelection(ppd, iPageIndex, NULL, 1);
            goto ReturnLres;
        }
        break;

        case PSM_REMOVEPAGE:
            RemovePropPage(ppd, (int)wParam, (HPROPSHEETPAGE)lParam);
            break;

        case PSM_ADDPAGE:
            lres = AddPropPage(ppd,(HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_INSERTPAGE:
            lres = InsertPropPage(ppd, (HPROPSHEETPAGE)wParam, (HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_QUERYSIBLINGS:
            lres = QuerySiblings(ppd, wParam, lParam);
            goto ReturnLres;

        case PSM_UNCHANGED:
            PageInfoUnChange(ppd, (HWND)wParam);
            break;

        case PSM_APPLY:
            // a page is asking us to simulate an "Apply Now".
            // let the page know if we're successful
            lres = ButtonPushed(ppd, IDD_APPLYNOW);
            goto ReturnLres;

        case PSM_GETTABCONTROL:
            lres = (LRESULT)ppd->hwndTabs;
            goto ReturnLres;

        case PSM_GETCURRENTPAGEHWND:
            lres = (LRESULT)ppd->hwndCurPage;
            goto ReturnLres;

        case PSM_PRESSBUTTON:
            if (wParam <= PSBTN_MAX)
            {
                const static int IndexToID[] = {IDD_BACK, IDD_NEXT, IDD_FINISH, IDOK,
                IDD_APPLYNOW, IDCANCEL, IDHELP};
                Prsht_OnCommand(ppd, IndexToID[wParam], NULL, 0);
            }
            break;

        case PSM_ISDIALOGMESSAGE:
            // returning TRUE means we handled it, do a continue
            // FALSE do standard translate/dispatch
            lres = Prop_IsDialogMessage(ppd, (LPMSG32)lParam);
            goto ReturnLres;

        case PSM_HWNDTOINDEX:
            lres = FindItem(ppd->hwndTabs, (HWND)wParam, NULL);
            goto ReturnLres;

        case PSM_INDEXTOHWND:
            if ((UINT)wParam < ppd->psh.nPages)
                lres = (LRESULT)_Ppd_GetPage(ppd, (int)wParam);
            else
                lres = 0;
            goto ReturnLres;

        case PSM_PAGETOINDEX:
            lres = FindPageIndexByHpage(ppd, (HPROPSHEETPAGE)lParam);
            goto ReturnLres;

        case PSM_INDEXTOPAGE:
            if ((UINT)wParam < ppd->psh.nPages)
                lres = (LRESULT)GETHPAGE(ppd, wParam);
            else
                lres = 0;
            goto ReturnLres;

        case PSM_INDEXTOID:
            if ((UINT)wParam < ppd->psh.nPages)
            {
                lres = (LRESULT)GETPPSP(ppd, wParam)->P_pszTemplate;

                // Need to be careful -- return a value only if pszTemplate
                // is an ID.  Don't return out our internal pointers!
                if (!IS_INTRESOURCE(lres))
                    lres = 0;
            }
            else
                lres = 0;
            goto ReturnLres;

        case PSM_IDTOINDEX:
            lres = FindPageIndex(ppd, ppd->nCurItem, (DWORD)lParam, 0);
            goto ReturnLres;

        case PSM_GETRESULT:
            // This is valid only after the property sheet is gone
            if (ppd->hwndCurPage)
            {
                lres = -1;      // you shouldn't be calling me yet
            } else {
                lres = ppd->nReturn;
                if (lres > 0 && ppd->nRestart)
                    lres = ppd->nRestart;
            }
            goto ReturnLres;
            break;

        case PSM_RECALCPAGESIZES:
            lres = Prsht_RecalcPageSizes(ppd);
            goto ReturnLres;

            // these should be relayed to all created dialogs
        case WM_WININICHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_DISPLAYCHANGE:
            {
                int nItem, nItems = TabCtrl_GetItemCount(ppd->hwndTabs);
                for (nItem = 0; nItem < nItems; ++nItem)
                {

                    hwndT = _Ppd_GetPage(ppd, nItem);
                    if (hwndT)
                        SendMessage(hwndT, uMessage, wParam, lParam);
                }
                SendMessage(ppd->hwndTabs, uMessage, wParam, lParam);
            }
            break;

            //
            // send toplevel messages to the current page and tab control
            //
        case WM_PALETTECHANGED:
            //
            // If this is our window we need to avoid selecting and realizing
            // because doing so would cause an infinite loop between WM_QUERYNEWPALETTE
            // and WM_PALETTECHANGED.
            //
            if((HWND)wParam == hDlg) {
                return(FALSE);
            }
            //
            // FALL THROUGH
            //

        case WM_QUERYNEWPALETTE:
            // This is needed when another window which has different palette clips
            // us
            if ((ppd->psh.dwFlags & PSH_WIZARD97) &&
                (ppd->psh.dwFlags & PSH_WATERMARK) &&
                (ppd->psh.hplWatermark))
                HandlePaletteChange(ppd, uMessage, hDlg);

            //
            // FALL THROUGH
            //

        case WM_ENABLE:
        case WM_DEVICECHANGE:
        case WM_QUERYENDSESSION:
        case WM_ENDSESSION:
            if (ppd->hwndTabs)
                SendMessage(ppd->hwndTabs, uMessage, wParam, lParam);
            //
            // FALL THROUGH
            //

        case WM_ACTIVATEAPP:
        case WM_ACTIVATE:
            {
                hwndT = _Ppd_GetPage(ppd, ppd->nCurItem);
                if (hwndT && IsWindow(hwndT))
                {
                    //
                    // By doing this, we are "handling" the message.  Therefore
                    // we must set the dialog return value to whatever the child
                    // wanted.
                    //
                    lres = SendMessage(hwndT, uMessage, wParam, lParam);
                    goto ReturnLres;
                }
            }

            if ((uMessage == WM_PALETTECHANGED) || (uMessage == WM_QUERYNEWPALETTE))
                return TRUE;
            else
                return FALSE;

        case WM_CONTEXTMENU:
            // ppd->hwndTabs is handled by aPropHelpIDs to work around a USER bug.
            // See aPropHelpIDs for gory details.
            if ((ppd->hwndCurPage != (HWND)wParam) && (!IS_WIZARD(ppd)))
                WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(LPVOID) aPropHelpIDs);
            break;

        case WM_HELP:
            hwndT = (HWND)((LPHELPINFO)lParam)->hItemHandle;
            if ((GetParent(hwndT) == hDlg) && (hwndT != ppd->hwndTabs))
                WinHelp(hwndT, NULL, HELP_WM_HELP, (ULONG_PTR)(LPVOID) aPropHelpIDs);
            break;

        default:
            return FALSE;
       }
    return TRUE;

ReturnLres:
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, lres);
    return TRUE;

}

//
//  Draw the background for wizard pages.
//
BOOL Prsht_EraseWizBkgnd(LPPROPDATA ppd, HDC hdc)
{
    RECT rc;
    BOOL fPainted = FALSE;
    GetClientRect(ppd->hDlg, &rc);

    if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
    {
        if (ppd->hbrWatermark)
        {
            PaintWithPaletteBrush(hdc, &rc, ppd->hplWatermark, ppd->hbrWatermark);
            fPainted = TRUE;
        }
    }
    else                                // PSH_WIZARD97IE5
    {
        if (ppd->hbmWatermark)
        {
            // Right-hand side gets g_hbrWindow.
            rc.left = BITMAP_WIDTH;
            FillRect(hdc, &rc, g_hbrWindow);

            // Left-hand side gets watermark in top portion with autofill...
            rc.right = rc.left;
            rc.left = 0;
            PaintWithPaletteBitmap(hdc, &rc, ppd->hplWatermark, ppd->hbmWatermark);
            fPainted = TRUE;
        }
    }
    return fPainted;
}

LRESULT CALLBACK WizardWndProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    LPPROPDATA ppd = (LPPROPDATA)dwRefData;
    switch (uMessage)
    {
        case WM_ERASEBKGND:
            if (Prsht_EraseWizBkgnd(ppd, (HDC)wParam))
                return TRUE;
            break;

        // Only PSH_WIZARD97IE4 cares about these messages
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORDLG:
            if (!(ppd->psh.dwFlags & PSH_WIZARD97IE4))
                break;
            // fall through

        case WM_CTLCOLOR:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
            if (ppd->psh.dwFlags & PSH_WIZARD97IE4)
            {
              if (ppd->hbrWatermark) {
                POINT pt;
                // Bug-for-bug compatibility:  TRANSPARENT messes up edit
                // controls when they scroll, but that's what IE4 did.
                SetBkMode((HDC)wParam, TRANSPARENT);

                if (ppd->hplWatermark)
                {
                    SelectPalette((HDC)wParam, ppd->hplWatermark, FALSE);
                    RealizePalette((HDC)wParam);
                }
                UnrealizeObject(ppd->hbrWatermark);
                GetDCOrgEx((HDC)wParam, &pt);
                // Bug-for-bug compatibility:  We shouldn't use GetParent
                // because the notification might be forwarded up from an
                // embedded dialog child, but that's what IE4 did.
                ScreenToClient(GetParent((HWND)lParam), &pt);
                SetBrushOrgEx((HDC)wParam, -pt.x, -pt.y, NULL);
                return (LRESULT)(HBRUSH)ppd->hbrWatermark;
              }
            }
            else                        // PSH_WIZARD97IE5
            {
                if (ppd->hbmWatermark)
                {
                    LRESULT lRet = DefWindowProc(hDlg, uMessage, wParam, lParam);
                    if (lRet == DefSubclassProc(hDlg, uMessage, wParam, lParam))
                    {
                        SetTextColor((HDC)wParam, GetSysColor(COLOR_WINDOWTEXT));
                        SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
                        return (LRESULT)g_hbrWindow;
                    }
                    else
                        return lRet;
                }
            }
            break;

        case WM_PALETTECHANGED:
            if((HWND)wParam == hDlg)
                return(FALSE);

        case WM_QUERYNEWPALETTE:
            HandlePaletteChange(ppd, uMessage, hDlg);
            return TRUE;

        case WM_DESTROY:
            // Clean up subclass
            RemoveWindowSubclass(hDlg, WizardWndProc, 0);
            break;

        default:
            break;
    }

    return DefSubclassProc(hDlg, uMessage, wParam, lParam);
}

//
// EnumResLangProc
//
// purpose: a callback function for EnumResourceLanguages().
//          look into the type passed in and if it is RT_DIALOG
//          copy the lang of the first resource to our buffer
//          this also counts # of lang if more than one of them
//          are passed in
//
//
typedef struct  {
    WORD wLang;
    BOOL fFoundLang;
    LPCTSTR lpszType;
} ENUMLANGDATA;

BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    ENUMLANGDATA *pel = (ENUMLANGDATA *)lparam;
    BOOL fContinue = TRUE;

    ASSERT(pel);

    if (lpszType == pel->lpszType)
    {
        // When comctl's been initialized with a particular MUI language,
        // we pass in the langid to GetPageLanguage(), then it's given to this proc.
        // we want to look for a template that matches to the langid,
        // and if it's not found, we have to use the first instance of templates.
        // 
        if (pel->wLang == MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
            || (pel->wLang == wIdLang))
        {
            pel->wLang = wIdLang;
            pel->fFoundLang = TRUE;
            fContinue = FALSE; 
        }
    }
    return fContinue;   // continue until we get langs...
}

// GetPageLanguage
//
// purpose: tries to retrieve language information out of
//          given page's dialog template. We get the first language
//          in which the template is localized in.
//          currently doesn't support PSP_DLGINDIRECT case
//
// BUGBUG REVIEW: we luck out with browselc since there's only one lang per resid,
// we should cache the langid we loaded up front and pull it out here.
//
HRESULT GetPageLanguage(PISP pisp, WORD *pwLang)
{
    if (pisp && pwLang
#ifndef WINNT
                       && !(pisp->_psp.dwFlags & PSP_IS16)
#endif
                                                          )
    {
        if (pisp->_psp.dwFlags & PSP_DLGINDIRECT)
        {
            // try something other than dialog
            return E_FAIL; // not supported yet.
        }
        else
        {
            ENUMLANGDATA el;
            
            // the caller passes-in the langid with which we're initialized
            //
            el.wLang = *pwLang;
            el.fFoundLang = FALSE;
            el.lpszType = RT_DIALOG;
            // check with the dialog template specified
            EnumResourceLanguages(pisp->_psp.hInstance, RT_DIALOG, pisp->_psp.P_pszTemplate, EnumResLangProc, (LPARAM)&el);
            if (!el.fFoundLang)
            {
                // we couldn't find a matching lang in the given page's resource
                // so we'll take the first one
                el.wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
                
                // it doesn't matter if this fails, because we'll then end up with 
                // the neutral langid, which is the best guess here after failing 
                // to get any page lang.
                //
                EnumResourceLanguages(pisp->_psp.hInstance, RT_DIALOG, 
                                      pisp->_psp.P_pszTemplate, EnumResLangProc, (LPARAM)&el);
            }
            *pwLang = el.wLang;
        }
        return S_OK;
    }
    return E_FAIL;
}

//
//  FindResourceExRetry
//
//  Just like FindResourceEx, except that if we can't find the resource,
//  we try again with MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL).
//
HRSRC FindResourceExRetry(HMODULE hmod, LPCTSTR lpType, LPCTSTR lpName, WORD wLang)
{
    HRSRC hrsrc = FindResourceEx(hmod, lpType, lpName, wLang);

    // if failed because we couldn't find the resouce in requested lang
    // and requested lang wasn't neutral, then try neutral.
    if (!hrsrc && wLang != MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        hrsrc = FindResourceEx(hmod, lpType, lpName, wLang);
    }


    return hrsrc;
}


WORD GetShellResourceLangID(void);

// NT5_GetUserDefaultUILanguage
//
//  NT5 has a new function GetUserDefaultUILanguage which returns the
//  language the user as selected for UI.
//
//  If the function is not available (e.g., NT4), then use the
//  shell resource language ID.
//

typedef LANGID (CALLBACK* GETUSERDEFAULTUILANGUAGE)(void);

GETUSERDEFAULTUILANGUAGE _GetUserDefaultUILanguage;

LANGID NT5_GetUserDefaultUILanguage(void)
{
    if (_GetUserDefaultUILanguage == NULL)
    {
        HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

        //
        //  Must keep in a local to avoid thread races.
        //
        GETUSERDEFAULTUILANGUAGE pfn = NULL;

        if (hmod)
            pfn = (GETUSERDEFAULTUILANGUAGE)
                    GetProcAddress(hmod, "GetUserDefaultUILanguage");

        //
        //  If function is not available, then use our fallback
        //
        if (pfn == NULL)
            pfn = GetShellResourceLangID;

        ASSERT(pfn != NULL);
        _GetUserDefaultUILanguage = pfn;
    }

    return _GetUserDefaultUILanguage();
}


LCID CCGetSystemDefaultThreadLocale(LCID iLcidThreadOrig)
{
    UINT uLangThread, uLangThreadOrig;

    uLangThreadOrig = LANGIDFROMLCID(iLcidThreadOrig);

    

    // uLangThread is the language we think we want to use
    uLangThread = uLangThreadOrig;

    if (staticIsOS(OS_NT4ORGREATER) && !staticIsOS(OS_WIN2000ORGREATER))
    {
        int iLcidUserDefault = GetUserDefaultLCID();
        UINT uLangUD = LANGIDFROMLCID(iLcidUserDefault);

        //
        // If we are running on Enabled Arabic NT4, we should always
        // display the US English resources (since the UI is English), however NT4
        // Resource Loader will look for the current Thread Locale (which is Arabic).
        // This is no problem in NT5 since the Resource Loader will check for
        // the  UI Language (newly introduced) when loading such resources. To
        // fix this, we will change the thread locale to US English
        // and restore it back to Arabic/Hebrew if we are running on an Enabled Arabic/Hebrew NT4.
        // The check is done to make sure we are running within a Araic/Hebrew user locale
        // and the thread locale is still Arabic/Hebrew (i.e. nobody tried to SetThreadLocale).
        // [samera]
        //
        if( ((PRIMARYLANGID(uLangUD    ) == LANG_ARABIC) &&
             (PRIMARYLANGID(uLangThread) == LANG_ARABIC))   ||
            ((PRIMARYLANGID(uLangUD    ) == LANG_HEBREW) &&
             (PRIMARYLANGID(uLangThread) == LANG_HEBREW)))
        {
            uLangThread = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
        }
    }

    //
    //  Make locale match UI locale if not otherwise overridden.
    //
    if (uLangThread == uLangThreadOrig)
    {
        uLangThread = NT5_GetUserDefaultUILanguage();
    }

    //
    //  Now see if we actually changed the thread language.
    //
    if (uLangThread == uLangThreadOrig)
    {
        // No change, return the original locale, including sort stuff
        return iLcidThreadOrig;
    }
    else
    {
        // It changed, return a generic sort order, since we don't use
        // this information for sorting.
        return MAKELCID(uLangThread, SORT_DEFAULT);
    }
}

//
// GetAltFontLangId
// 
// used to detect "MS UI Gothic" on Jpn localized non NT5 platforms
// the font is shipped with IE5 for the language but comctl can't 
// always assume the font so we have a fake sublang id assigned to
// the secondary resource file for the language
//
int CALLBACK FontEnumProc(
  ENUMLOGFONTEX *lpelfe,    
  NEWTEXTMETRICEX *lpntme,  
  int FontType,             
  LPARAM lParam
)
{
    if (lParam)
    {
        *(BOOL *)lParam = TRUE;
    }
    return 0; // stop at the first callback
}
UINT GetDefaultCharsetFromLang(LANGID wLang)
{
    TCHAR    szData[6+1]; // 6 chars are max allowed for this lctype
    UINT     uiRet = DEFAULT_CHARSET;

    // JPN hack here: GetLocaleInfo() DOES return > 0 for Jpn altfont langid,
    // but doesn't get us any useful info. So for JPN, we ripout the SUBLANG
    // portion of id. we can't do this for other langs since sublang can affect
    // charset (ex. chinese)
    //
    if(PRIMARYLANGID(wLang) == LANG_JAPANESE)
        wLang = MAKELANGID(PRIMARYLANGID(wLang), SUBLANG_NEUTRAL);
    
    if (GetLocaleInfo(MAKELCID(wLang, SORT_DEFAULT), 
                      LOCALE_IDEFAULTANSICODEPAGE,
                      szData, ARRAYSIZE(szData)) > 0)
    {

        UINT uiCp = StrToInt(szData);
        CHARSETINFO   csinfo;

        if (TranslateCharsetInfo(IntToPtr_(DWORD *, uiCp), &csinfo, TCI_SRCCODEPAGE))
            uiRet = csinfo.ciCharset;
    }

    return uiRet;
}
BOOL IsFontInstalled(LANGID wLang, LPCTSTR szFace)
{
    BOOL     fInstalled = FALSE;
    HDC      hdc;
    LOGFONT  lf = {0};

    lstrcpyn(lf.lfFaceName, szFace, ARRAYSIZE(lf.lfFaceName));
    
    // retrieve charset from given language
    lf.lfCharSet = (BYTE)GetDefaultCharsetFromLang(wLang);
    
    // then see if we can enumrate the font
    hdc = GetDC(NULL);
    if (hdc)
    {
        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)FontEnumProc, (LPARAM)&fInstalled, 0);
        ReleaseDC(NULL, hdc);
    }

     return fInstalled;
}

LANGID GetAltFontLangId(LANGID wLang)
{
     LPCTSTR pszTypeFace = NULL;
     USHORT  usAltSubLang = SUBLANG_NEUTRAL;
     const static TCHAR s_szUIGothic[] = TEXT("MS UI Gothic");
     static int iPrimaryFontInstalled = -1;

     // most of the case we return the lang just as is
     switch(PRIMARYLANGID(wLang))
     {
         case LANG_JAPANESE:
             pszTypeFace = s_szUIGothic;
             usAltSubLang   = SUBLANG_JAPANESE_ALTFONT;
             break;
         // add code here to handle any other cases like Jpn
         default:
             return wLang;
     }

     // check existence of the font if we haven't
     if (iPrimaryFontInstalled < 0 && pszTypeFace)
     {
        iPrimaryFontInstalled = IsFontInstalled(wLang, pszTypeFace);
     }

     // return secondary lang id if our alternative font *is* installed
     if (iPrimaryFontInstalled == 1) 
         wLang = MAKELANGID(PRIMARYLANGID(wLang), usAltSubLang);

     return wLang;
}
// GetShellResourceLangID
//
// On NT4, we want to match our ML resource to the one that OS is localized.
// this is to prevent general UI (buttons) from changing along with regional
// setting change.
// Win95 won't change system default locale, NT5 will load from matching satelite
// resource dll automatically so this won't be needed on these platforms.
// This function finds shell32.dll and gets the language in which the dll is
// localized, then cache the lcid so we won't have to detect it again.
//
WORD GetShellResourceLangID(void)
{
    static WORD langRes = 0L;

    // we do this only once
    if (langRes == 0L)
    {
        HINSTANCE hinstShell;
        ENUMLANGDATA el = {MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), FALSE, RT_DIALOG};

        hinstShell = LoadLibrary(TEXT("shell32.dll"));
        if (hinstShell)
        {
            EnumResourceLanguages(hinstShell, RT_DIALOG, MAKEINTRESOURCE(DLG_EXITWINDOWS), EnumResLangProc, (LPARAM)&el);

            FreeLibrary(hinstShell);
        }

        if (PRIMARYLANGID(el.wLang) == LANG_CHINESE
           || PRIMARYLANGID(el.wLang) == LANG_PORTUGUESE )
        {
            // these two languages need special handling
            langRes = el.wLang;
        }
        else
        {
            // otherwise we use only primary langid.
            langRes = MAKELANGID(PRIMARYLANGID(el.wLang), SUBLANG_NEUTRAL);
        }
    }
    return langRes;
}

//
//  CCGetProperThreadLocale
//
//  This function computes its brains out and tries to decide
//  which thread locale we should use for our UI components.
//
//  Returns the desired locale.
//
//  Adjustment - For Arabic / Hebrew - NT4 Only
//
//      Converts the thread locale to US, so that neutral resources
//      loaded by the thread will be the US-English one, if available.
//      This is used when the locale is Arabic/Hebrew and the system is
//      NT4 enabled ( There was no localized NT4), as a result we need
//      always to see the English resources on NT4 Arabic/Hebrew.
//      [samera]
//
//  Adjustment - For all languages - NT4 Only
//
//      Convert the thread locale to the shell locale if not otherwise
//      altered by previous adjustments.
//
//  Adjustment - For all languages - NT5 Only
//
//      Always use the default UI language.  If that fails, then use the
//      shell locale.
//
//  The last two adjustments are handled in a common function, because
//  the NT5 fallback turns out to be equal to the NT4 algorithm.
//
LCID CCGetProperThreadLocale(OPTIONAL LCID *plcidPrev)
{
    LANGID uLangAlt, uLangMUI;
    LCID lcidRet, iLcidThreadOrig; 

    iLcidThreadOrig = GetThreadLocale();
    if (plcidPrev)
        *plcidPrev = iLcidThreadOrig;

    uLangMUI = GetMUILanguage();
    if ( uLangMUI ==  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL))
    {
        // return adjusted system default locale if MUI isn't initialized
        //
        lcidRet = CCGetSystemDefaultThreadLocale(iLcidThreadOrig);
    }
    else
    {
        // our host has initialized us with prefered MUI language
        // 
        lcidRet = MAKELCID(uLangMUI, SORT_DEFAULT);
    }

    uLangAlt = GetAltFontLangId(LANGIDFROMLCID(lcidRet));
    if (uLangAlt != LANGIDFROMLCID(lcidRet))
    {
        // use secondary resource for the language
        // if the platform *does* have the alternative font
        lcidRet = MAKELCID(uLangAlt, SORTIDFROMLCID(lcidRet));
    }
    
    return lcidRet;
}

//
//  CCLoadStringEx
//
//  Just like LoadString, except you can specify the language, too.
//
//  This is harder than you think, because NT5 changed the way strings
//  are loaded.  Quote:
//
//      We changed the resource loader in NT5, to only load resources
//      in the language of the thread locale, if the thread locale is
//      different to the user locale. The reasoning behind this was
//      the "random" loading of the language of the user locale in
//      the UI. This breaks if you do a SetThreadLocale to the User
//      Locale, because then the whole step is ignored and the
//      InstallLanguage of the system is loaded.
//
//  Therefore, we have to use FindResourceEx.
//
//
int CCLoadStringEx(UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang)
{
    return CCLoadStringExInternal(HINST_THISDLL, uID, lpBuffer, nBufferMax, wLang);
}

int CCLoadStringExInternal(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang)
{
    PWCHAR pwch;
    HRSRC hrsrc;
    int cwch = 0;

    if (nBufferMax <= 0) return 0;                  // sanity check

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */

    hrsrc = FindResourceExRetry(hInst, RT_STRING,
                                (LPCTSTR)(LONG_PTR)(1 + (USHORT)uID / 16),
                                wLang);
    if (hrsrc) {
        pwch = (PWCHAR)LoadResource(hInst, hrsrc);
        if (pwch) {
            /*
             *  Now skip over the strings in the resource until we
             *  hit the one we want.  Each entry is a counted string,
             *  just like Pascal.
             */
            for (uID %= 16; uID; uID--) {
#ifndef UNIX
                pwch += *pwch + 1;
#else   // unix version has a WORD first then followed by a padding word
        // then the whole string in WCHAR (4 bytes on UNIX)
                pwch += *(WORD *)pwch + 1;
#endif
            }
#ifndef UNIX
            cwch = min(*pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
#else   // length of the string is a WORD not WCHAR
            cwch = min(*(WORD *)pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
#endif
        }
    }
    lpBuffer[cwch] = L'\0';                 /* Terminate the string */
    return cwch;
}


//
//  LocalizedLoadString
//
//  Loads a string from our resources, using the correct language.
//

int LocalizedLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    return CCLoadStringEx(uID, lpBuffer, nBufferMax,
                LANGIDFROMLCID(CCGetProperThreadLocale(NULL)));
}

#ifdef WINNT
//
// Determine if the prop sheet frame should use the new
// "MS Shell Dlg 2" font.  To do this, we examine each page's dlg template.
// If all pages have SHELLFONT enabled, then
// we want to use the new font.
//
BOOL ShouldUseMSShellDlg2Font(LPPROPDATA ppd)
{
    UINT iPage;
    PAGEINFOEX pi;
    LANGID langidMUI;

    if (!staticIsOS(OS_WIN2000ORGREATER))
        return FALSE;

    langidMUI = GetMUILanguage();
    for (iPage = 0; iPage < ppd->psh.nPages; iPage++)
    {
        if (GetPageInfoEx(ppd, GETPISP(ppd, iPage), &pi, langidMUI, GPI_DIALOGEX))
        {
            if (!IsPageInfoSHELLFONT(&pi))
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}
#endif

PSPT_OS Prsht_GetOS()
{
    static PSPT_OS pspt_os = (PSPT_OS)-1;
    int iIsOSBiDiEnabled = 0;
    
    if (pspt_os != (PSPT_OS)-1)
    {
        return pspt_os;
    }


    iIsOSBiDiEnabled = GetSystemMetrics(SM_MIDEASTENABLED);
    
    if (staticIsOS(OS_WIN2000ORGREATER))
    {
        pspt_os = PSPT_OS_WINNT5;
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_NT4ORGREATER) && (!staticIsOS(OS_WIN2000ORGREATER)))
    {
        pspt_os = PSPT_OS_WINNT4_ENA;        
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_WIN95ORGREATER) && (!staticIsOS(OS_WIN98ORGREATER)))
    {
        pspt_os = PSPT_OS_WIN95_BIDI;
    }
    else if (iIsOSBiDiEnabled && staticIsOS(OS_WIN98ORGREATER))     
    {
        pspt_os = PSPT_OS_WIN98_BIDI;
    }
    else
    {
        pspt_os = PSPT_OS_OTHER;
    }

    return pspt_os;
}

PSPT_OVERRIDE Prsht_GetOverrideState(LPPROPDATA ppd)
{
   // if passed bad argument, assume no override
   if(!ppd)
       return PSPT_OVERRIDE_NOOVERRIDE;
       
   if (ppd->psh.dwFlags & PSH_USEPAGELANG)
       return PSPT_OVERRIDE_USEPAGELANG;

   return PSPT_OVERRIDE_NOOVERRIDE; 
}

PSPT_TYPE Prsht_GetType(LPPROPDATA ppd, WORD wLang)
{

   PISP pisp = NULL;
   // if passed bad argument, give it the english resources
    if(!ppd)
        return PSPT_TYPE_ENGLISH;

    pisp = GETPISP(ppd, 0);
    if(pisp)
    {
        PAGEINFOEX pi = {0};

        if ((IS_PROCESS_RTL_MIRRORED()) || 
            (GetPageInfoEx(ppd, pisp, &pi, wLang, GPI_BMIRROR) && pi.bMirrored))
            return PSPT_TYPE_MIRRORED;

        else
        {
            WORD wLang = 0;
            
            GetPageLanguage(pisp,&wLang);
            if((PRIMARYLANGID(wLang) == LANG_ARABIC) || (PRIMARYLANGID(wLang) == LANG_HEBREW))
                return PSPT_TYPE_ENABLED;
        }
    }

    return PSPT_TYPE_ENGLISH;
}

PSPT_ACTION Prsht_GetAction(PSPT_TYPE pspt_type, PSPT_OS pspt_os, PSPT_OVERRIDE pspt_override)
{
    if ((pspt_type < 0) || (pspt_type >= PSPT_TYPE_MAX)
        || (pspt_os < 0) || (pspt_os >= PSPT_OS_MAX)
        || (pspt_override < 0) || (pspt_override >= PSPT_OVERRIDE_MAX))
        return PSPT_ACTION_NOACTION;

    return g_PSPT_Action[pspt_type][pspt_os][pspt_override];   

}

void Prsht_PrepareTemplate(LPPROPDATA ppd, HINSTANCE hInst, HGLOBAL *phDlgTemplate, HRSRC *phResInfo, 
                          LPCSTR lpName, HWND hWndOwner, LPWORD lpwLangID)
{

    
    LPDLGTEMPLATE pDlgTemplate = NULL;
    PSPT_ACTION pspt_action;

    if (pDlgTemplate = (LPDLGTEMPLATE)LockResource(*phDlgTemplate))
    {   

        // We save BiDi templates as DIALOG (not DIALOGEX)
        // If we got an extended template then it is not ours
        
        if (((LPDLGTEMPLATEEX)pDlgTemplate)->wSignature == 0xFFFF)
            return;

        // Cut it short to save time
        //
        if (!(pDlgTemplate->dwExtendedStyle & (RTL_MIRRORED_WINDOW | RTL_NOINHERITLAYOUT)))
           return;
    }

    pspt_action = Prsht_GetAction(Prsht_GetType(ppd, *lpwLangID), Prsht_GetOS(), 
                                              Prsht_GetOverrideState(ppd));
                                              
    switch(pspt_action)
    {
        case PSPT_ACTION_NOACTION:
            return;

        case PSPT_ACTION_NOMIRRORING:
        {
            if (pDlgTemplate)
            {   
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_NOMIRROR, NULL, 0);
            }    
        }
        break;

        case PSPT_ACTION_FLIP:
        {
            if (pDlgTemplate)
            {
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_NOMIRROR, NULL, 0);
                EditBiDiDLGTemplate(pDlgTemplate, EBDT_FLIP, (PWORD)&wIgnoreIDs, ARRAYSIZE(wIgnoreIDs));
                ppd->fFlipped = TRUE;
            }    
        }
        break;

        case PSPT_ACTION_LOADENGLISH:
        {
            HGLOBAL hDlgTemplateTemp = NULL;
            HRSRC hResInfoTemp;

                            //
            //Try to load an English resource.
            //
            *lpwLangID = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);

            if ((hResInfoTemp = FindResourceExA( hInst, (LPCSTR)RT_DIALOG, lpName, *lpwLangID)))
            {
                hDlgTemplateTemp = LoadResource(hInst, hResInfoTemp);
            }
            if (hDlgTemplateTemp)
            {
                //
                //And return it to the caller to use it.
                // Since we loaeded a new template, we should copy it to a local memory
                // in case there is a callback.
                //
  
                DWORD   cbTemplate = SizeofResource(hInst, hResInfoTemp);
                LPVOID  pTemplateMod;

                pTemplateMod = (LPVOID)LocalAlloc(LPTR, cbTemplate * 2);
                if (pTemplateMod)
                {
                    memmove(pTemplateMod, hDlgTemplateTemp, cbTemplate);
                    LocalFree(*phDlgTemplate);
                    *phResInfo     = hResInfoTemp;
                    *phDlgTemplate = pTemplateMod;
                }
             }

        }
        break;

        case PSPT_ACTION_WIN9XCOMPAT:
        {
            if (pDlgTemplate)
            {
                pDlgTemplate->style |= DS_BIDI_RTL;
            }   
        }
    }
}


INT_PTR NEAR PASCAL _RealPropertySheet(LPPROPDATA ppd)
{
    HWND    hwndMain;
    MSG32   msg32;
    HWND    hwndTopOwner;
    int     nReturn = -1;
    HWND    hwndOriginalFocus;
    WORD    wLang, wUserLang;
    LCID    iLcidThread=0L;
    HRSRC   hrsrc = 0;
    LPVOID  pTemplate, pTemplateMod;
    LPTSTR  lpDlgId;
    if (ppd->psh.nPages == 0)
    {
        DebugMsg(DM_ERROR, TEXT("no pages for prop sheet"));
        goto FreePpdAndReturn;
    }

    ppd->hwndCurPage = NULL;
    ppd->nReturn     = -1;
    ppd->nRestart    = 0;

    hwndTopOwner = ppd->psh.hwndParent;
    hwndOriginalFocus = GetFocus();

#ifdef DEBUG
    if (GetAsyncKeyState(VK_CONTROL) < 0) {

        ppd->psh.dwFlags |= PSH_WIZARDHASFINISH;
    }
#endif

    if (!(ppd->psh.dwFlags & PSH_MODELESS))
    {
        //
        // Like dialog boxes, we only want to disable top level windows.
        // NB The mail guys would like us to be more like a regular
        // dialog box and disable the parent before putting up the sheet.
        if (hwndTopOwner)
        {
            while (GetWindowLong(hwndTopOwner, GWL_STYLE) & WS_CHILD)
                hwndTopOwner = GetParent(hwndTopOwner);

            ASSERT(hwndTopOwner);       // Should never get this!
            if ((hwndTopOwner == GetDesktopWindow()) ||
                (EnableWindow(hwndTopOwner, FALSE)))
            {
                //
                // If the window was the desktop window, then don't disable
                // it now and don't reenable it later.
                // Also, if the window was already disabled, then don't
                // enable it later.
                //
                hwndTopOwner = NULL;
            }
        }
    }

#if  !defined(WIN32)
#ifdef FE_IME
    // Win95d-B#754
    // When PCMCIA gets detected, NETDI calls DiCallClassInstaller().
    // The class installer of setupx calls PropertySheet() for msgsrv32.
    // We usually don't prepare thread link info in imm for that process as
    // it won't use IME normaly but we need to treat this case as special.
    //
    if (!ImmFindThreadLink(GetCurrentThreadID()))
    {
        ImmCreateThreadLink(GetCurrentProcessID(),GetCurrentThreadID());
    }
#endif
#endif

    //
    // WARNING! WARNING! WARNING! WARNING!
    //
    // Before you mess with any language stuff, be aware that MFC loads
    // resources directly out of comctl32.dll, so if you change the
    // way we choose the proper resource, you may break MFC apps.
    // See NT bug 302959.

    //
    // Support PSH_USEPAGELANG
    //

    // Presume we load our template based on thread lang id.
    wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
    wUserLang= MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

    // BUGBUG REVIEW: PSH_USEPAGELANG was in IE4... how does this work with PlugUI now??
    // 
    if (ppd->psh.dwFlags & PSH_USEPAGELANG)
    {
        // Get callers language version. We know we have at least one page
        if (FAILED(GetPageLanguage(GETPISP(ppd, 0), &wLang)))
        {
            // failed to get langid out of caller's resource
            // just pretend nothing happened.
            wLang = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
        }
        wUserLang = wLang;
    }
    else
        wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));

    //
    //  The only thing we need the thread locale for is to locate the
    //  correct dialog template.  We don't want it to affect page
    //  initialization or anything else like that, so get the template
    //  and quickly set the locale back before anyone notices.
    //
    //  If we can't get the requested language, retry with the neutral
    //  language.
    //


    // We have seperate dialog templates for Win95 BiDi localized
    // The code used to check to see if we are running on Win98 BiDi localized
    // and load this template.
    // We have a special case when running Office2000 with Arabic/Hebrew SKU on
    // BiDi win95 Enabled where we need to load this template as well
    if(Prsht_GetOS() == PSPT_OS_WIN95_BIDI)
    {
         lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD95 : DLG_PROPSHEET95);
         hrsrc = FindResourceEx(
                           HINST_THISDLL, RT_DIALOG,
                           lpDlgId,
                           wLang );
         // we only have DLG_WIZARD95 and DLG_PROPSHEET95 in Arabic & Hebrew language
         // if we got any other language we will fail
         // In this case, let's use the normal templates
         if(hrsrc)
         {
             ppd->fFlipped = TRUE;
         }
         else
         {
             lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD : DLG_PROPSHEET);
             hrsrc = FindResourceExRetry(
                               HINST_THISDLL, RT_DIALOG,
                               lpDlgId,
                                wLang );             
         }
    
    }
    else
    {
        lpDlgId = MAKEINTRESOURCE(IS_WIZARD(ppd) ? DLG_WIZARD : DLG_PROPSHEET);

        hrsrc = FindResourceExRetry(
                               HINST_THISDLL, RT_DIALOG,
                               lpDlgId,
                               wLang );
    }
    // Setup for failure
    hwndMain = NULL;

    if (hrsrc &&
        (pTemplate = (LPVOID)LoadResource(HINST_THISDLL, hrsrc)))
    {
        DWORD cbTemplate;

        cbTemplate = SizeofResource(HINST_THISDLL, hrsrc);

        pTemplateMod = (LPVOID)LocalAlloc(LPTR, cbTemplate * 2); //double it to give some play leeway

        if (pTemplateMod)
        {
            hmemcpy(pTemplateMod, pTemplate, cbTemplate);
            //Check the direction of this dialog and change it if it does not match the owner.
            Prsht_PrepareTemplate(ppd, HINST_THISDLL, &pTemplateMod, (HRSRC *)&hrsrc, 
                                 (LPSTR)lpDlgId,ppd->psh.hwndParent, &wUserLang);
        }
        else
        {
            pTemplateMod = pTemplate;       // no modifications
        }

        //
        //  Template editing and callbacks happen only if we were able
        //  to create a copy for modifying.
        //
        if (pTemplateMod != pTemplate)
        {
            if (ppd->psh.dwFlags & PSH_NOCONTEXTHELP)
            {
                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature ==  0xFFFF){
                    ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle &= ~DS_CONTEXTHELP;
                } else {
                    ((LPDLGTEMPLATE)pTemplateMod)->style &= ~DS_CONTEXTHELP;
                }
            }

            if (IS_WIZARD(ppd) &&
                (ppd->psh.dwFlags & PSH_WIZARDCONTEXTHELP)) {

                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature ==  0xFFFF){
                    ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle |= DS_CONTEXTHELP;
                } else {
                    ((LPDLGTEMPLATE)pTemplateMod)->style |= DS_CONTEXTHELP;
                }
            }

            // extra check for PSH_USEPAGELANG case
            if (ppd->psh.pfnCallback)
            {
#ifdef WX86
                if (ppd->fFlags & PD_WX86)
                    Wx86Callback(ppd->psh.pfnCallback, NULL, PSCB_PRECREATE, (LPARAM)(LPVOID)pTemplateMod);
                else
#endif
                    ppd->psh.pfnCallback(NULL, PSCB_PRECREATE, (LPARAM)(LPVOID)pTemplateMod);
#ifndef WINNT
                // If the callback turned off the mirroring extended style then turn off the mirroring style as well.
                if( staticIsOS(OS_WIN98ORGREATER) && 
                    (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature !=  0xFFFF) &&
                    (((LPDLGTEMPLATE)pTemplateMod)->style & DS_BIDI_RTL) &&
                    !(((LPDLGTEMPLATE)pTemplateMod)->dwExtendedStyle & RTL_MIRRORED_WINDOW)
                  )
                {
                    // Memphis ignores the Ext. styles let us use a normal style.
                    ((LPDLGTEMPLATE)pTemplateMod)->style &= ~DS_BIDI_RTL;
                }
#endif
            }
        }


        if (pTemplateMod)
        {
#ifdef WINNT
            //
            // For NT, we want to use MS Shell Dlg 2 font in the prop sheet if
            // all of the pages in the sheet use MS Shell Dlg 2.
            // To do this, we ensure the template is DIALOGEX and that the 
            // DS_SHELLFONT style bits (DS_SHELLFONT | DS_FIXEDSYS) are set.
            //
#ifndef UNIX // On UNIX MS Shell Dlg2 and MS Shell Dlg maps to the same font
            if (ShouldUseMSShellDlg2Font(ppd))
            {
                if (((LPDLGTEMPLATEEX)pTemplateMod)->wSignature != 0xFFFF)
                {
                    //
                    // Convert DLGTEMPLATE to DLGTEMPLATEEX.
                    //
                    LPVOID pTemplateCvtEx;            
                    int    iCharset = GetDefaultCharsetFromLang(wLang);
                    if (SUCCEEDED(CvtDlgToDlgEx(pTemplateMod, (LPDLGTEMPLATEEX *)&pTemplateCvtEx, iCharset)))
                    {
                        LocalFree(pTemplateMod);
                        pTemplateMod = pTemplateCvtEx;
                    } else {
                        // Unable to convert to ShellFont; oh well
                        goto NotShellFont;
                    }
                }
                //
                // Set DS_SHELLFONT style bits so we get "MS Shell Dlg2" font.
                //
                ((LPDLGTEMPLATEEX)pTemplateMod)->dwStyle |= DS_SHELLFONT;
                ppd->fFlags |= PD_SHELLFONT;
        NotShellFont:;
            }
#endif // UNIX
#endif

            // pTemplateMod is always unicode, even for the A function - no need to thunk
            hwndMain = CreateDialogIndirectParam(HINST_THISDLL, pTemplateMod,
                ppd->psh.hwndParent, PropSheetDlgProc, (LPARAM)(LPPROPDATA)ppd);

#ifdef WINNT
            // WORK AROUND WOW/USER BUG:  Even though InitPropSheetDlg sets
            // ppd->hDlg, in the WOW scenario, the incoming hDlg is WRONG!
            // The USER guys say "Tough.  You have to work around it."
            ppd->hDlg = hwndMain;
#endif
        }
        if (pTemplateMod != pTemplate)
            LocalFree(pTemplateMod);
    }

    if (!hwndMain)
    {
        int iPage;

        DebugMsg(DM_ERROR, TEXT("PropertySheet: unable to create main dialog"));

        if (hwndTopOwner && !(ppd->psh.dwFlags & PSH_MODELESS))
            EnableWindow(hwndTopOwner, TRUE);

        // Release all page objects in REVERSE ORDER so we can have
        // pages that are dependant on eachother based on the initial
        // order of those pages
        //
        for (iPage = (int)ppd->psh.nPages - 1; iPage >= 0; iPage--)
            DestroyPropertySheetPage(GETHPAGE(ppd, iPage));

        goto FreePpdAndReturn;
    }

#ifdef UNIX
    // On X Windows, to simulate modal behavior, it's not enough just to
    // process all the messages, because the window manager is a separate
    // process and doesn't generate any messages.
    // The only way to make it modal is to tell it explicitly to the
    // window manager BEFORE we map (show) a window. There's no means
    // to do it afterwards.
    // That's why I removed WS_VISIBLE from the dialogs' resources and
    // moved the ShowWindow up here, immediately after I tell the window
    // manager that I'm the modal guy (if I really am).

    MwSetModalPopup(hwndMain, !(ppd->psh.dwFlags & PSH_MODELESS));
    ShowWindow(hwndMain, SW_SHOW);
#endif

    if (ppd->psh.dwFlags & PSH_MODELESS)
        return (INT_PTR)hwndMain;

    while( ppd->hwndCurPage && GetMessage32(&msg32, NULL, 0, 0, TRUE) )
    {
        // if (PropSheet_IsDialogMessage(ppd->hDlg, (LPMSG)&msg32))
        if (Prop_IsDialogMessage(ppd, &msg32))
            continue;

        TranslateMessage32(&msg32, TRUE);
        DispatchMessage32(&msg32, TRUE);
    }

    if( ppd->hwndCurPage )
    {
        // GetMessage returned FALSE (WM_QUIT)
        DebugMsg( DM_TRACE, TEXT("PropertySheet: bailing in response to WM_QUIT (and reposting quit)") );
        ButtonPushed( ppd, IDCANCEL );  // nuke ourselves
        PostQuitMessage( (int) msg32.wParam );  // repost quit for next enclosing loop
    }

    // don't let this get mangled during destroy processing
    nReturn = ppd->nReturn ;

    if (ppd->psh.hwndParent && (GetActiveWindow() == hwndMain)) {
        DebugMsg(DM_TRACE, TEXT("Passing activation up"));
        SetActiveWindow(ppd->psh.hwndParent);
    }

    if (hwndTopOwner)
        EnableWindow(hwndTopOwner, TRUE);

    if (IsWindow(hwndOriginalFocus)) {
        SetFocus(hwndOriginalFocus);
    }

    DestroyWindow(hwndMain);

    // do pickup any PSM_REBOOTSYSTEM or PSM_RESTARTWINDOWS sent during destroy
    if ((nReturn > 0) && ppd->nRestart)
        nReturn = ppd->nRestart;

FreePpdAndReturn:

#ifdef WIN32
    LocalFree((HLOCAL)ppd);
#else
    LocalFree((HLOCAL)LOWORD(ppd));
#endif

    return nReturn;
}




#ifndef WINNT
//
// Description:
//   This function creates a 32-bit proxy page object for 16-bit page object.
//  The PSP_IS16 flag in psp.dwFlags indicates that this is a proxy object.
//
// Arguments:
//  hpage16 -- Specifies the handle to 16-bit property sheet page object.
//  hinst16 -- Specifies a handle to FreeLibrary16() when page is deleted.
//
//

HPROPSHEETPAGE WINAPI CreateProxyPage(HPROPSHEETPAGE hpage16, HINSTANCE hinst16)
{
    PISP pisp = AllocPropertySheetPage(sizeof(PROPSHEETPAGE));
    PROPSHEETPAGEA * ppsp = MapSLFix(hpage16);

    ASSERT(hpage16 != NULL);

    if (pisp)
    {
        pisp->_psp.dwSize = sizeof(pisp->_psp);
        if (ppsp)
        {
            // copy the dwFlags so we can reference PSP_HASHELP from the 32 bit side.
            pisp->_psp.dwFlags = ppsp->dwFlags | PSP_IS16;
        }
        else
        {
            pisp->_psp.dwFlags = PSP_IS16;
        }
        pisp->_psp.lParam = (LPARAM)hpage16;
        pisp->_psp.hInstance = hinst16;
    }

    if (ppsp)
    {
        UnMapSLFixArray(1, &hpage16);
    }

    return pisp ? ExternalizeHPROPSHEETPAGE(pisp) : NULL;
}

#else

HPROPSHEETPAGE WINAPI CreateProxyPage(HPROPSHEETPAGE hpage16, HINSTANCE hinst16)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}
#endif

// DestroyPropsheetPageArray
//
//  Helper function used during error handling.  It destroys the
//  incoming property sheet pages.

void DestroyPropsheetPageArray(LPCPROPSHEETHEADER ppsh)
{
    int iPage;

    if (!(ppsh->dwFlags & PSH_PROPSHEETPAGE))
    {
        // Release all page objects in REVERSE ORDER so we can have
        // pages that are dependant on eachother based on the initial
        // order of those pages

        for (iPage = (int)ppsh->nPages - 1; iPage >= 0; iPage--)
        {
            DestroyPropertySheetPage(ppsh->H_phpage[iPage]);
        }
    }
}

// PropertySheet API
//
// This function displays the property sheet described by ppsh.
//
// Since I don't expect anyone to ever check the return value
// (we certainly don't), we need to make sure any provided phpage array
// is always freed with DestroyPropertySheetPage, even if an error occurs.
//
//
//  The fNeedShadow parameter means "The incoming LPCPROPSHEETHEADER is in the
//  opposite character set from what you implement natively".
//
//  If we are compiling UNICODE, then fNeedShadow is TRUE if the incoming
//  LPCPROPSHEETHEADER is really an ANSI property sheet page.
//
//  If we are compiling ANSI-only, then fNeedShadow is always FALSE because
//  we don't support UNICODE in the ANSI-only version.
//

#ifdef UNICODE
INT_PTR WINAPI _PropertySheet(LPCPROPSHEETHEADER ppsh, BOOL fNeedShadow)
#else
INT_PTR WINAPI PropertySheet(LPCPROPSHEETHEADER ppsh)
#define fNeedShadow FALSE
#endif
{
    PROPDATA NEAR *ppd;
    int iPage;

    //
    // validate header
    //
    ASSERT(IsValidPROPSHEETHEADERSIZE(sizeof(PROPSHEETHEADER)));

    if (!IsValidPROPSHEETHEADERSIZE(ppsh->dwSize))
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: dwSize is not correct") );
        goto invalid_call;
    }

    if (ppsh->dwFlags & ~PSH_ALL)
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: invalid flags") );
        goto invalid_call;
    }

    // BUGBUG: is this >= for a reason?
    if (ppsh->nPages >= MAXPROPPAGES)
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: too many pages ( use MAXPROPPAGES )") );
        goto invalid_call;
    }

    ppd = (PROPDATA NEAR *)LocalAlloc(LPTR, sizeof(PROPDATA));
    if (ppd == NULL)
    {
        DebugMsg(DM_ERROR, TEXT("failed to alloc property page data"));

invalid_call:
        DestroyPropsheetPageArray(ppsh);
        return -1;
    }

    //  Initialize the flags.
    ppd->fFlags      = FALSE;

#ifdef WX86
    //
    //  If Wx86 is calling, set the flag that thunks the callbacks.
    //

    if ( Wx86IsCallThunked() ) {
        ppd->fFlags |= PD_WX86;
    }
#endif

    if (fNeedShadow)
        ppd->fFlags |= PD_NEEDSHADOW;

    // make a copy of the header so we can party on it
    hmemcpy(&ppd->psh, ppsh, ppsh->dwSize);

    // so we don't have to check later...
    if (!(ppd->psh.dwFlags & PSH_USECALLBACK))
        ppd->psh.pfnCallback = NULL;

    // fix up the page pointer to point to our copy of the page array
    ppd->psh.H_phpage = ppd->rghpage;

    if (ppd->psh.dwFlags & PSH_PROPSHEETPAGE)
    {
        // for lazy clients convert PROPSHEETPAGE structures into page handles
        LPCPROPSHEETPAGE ppsp = ppsh->H_ppsp;

        for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
        {
#ifdef UNICODE
            ppd->psh.H_phpage[iPage] = _CreatePropertySheetPage(ppsp, fNeedShadow,
                ppd->fFlags & PD_WX86);
#else
            ppd->psh.H_phpage[iPage] = CreatePropertySheetPage(ppsp);
#endif
            if (!ppd->psh.H_phpage[iPage])
            {
                iPage--;
                ppd->psh.nPages--;
            }

            ppsp = (LPCPROPSHEETPAGE)((LPBYTE)ppsp + ppsp->dwSize);      // next PROPSHEETPAGE structure
        }
    }
    else
    {
#ifdef UNICODE

        // The UNICODE build needs to hack around Hijaak 95.
        //
        ppd->psh.nPages = 0;
        for (iPage = 0; iPage < (int)ppsh->nPages; iPage++)
        {
            ppd->psh.H_phpage[ppd->psh.nPages] = _Hijaak95Hack(ppd, ppsh->H_phpage[iPage]);
            if (ppd->psh.H_phpage[ppd->psh.nPages])
            {
                ppd->psh.nPages++;
            }
        }
#else
        // make a copy of the pages passed in, since we will party here
        hmemcpy(ppd->psh.H_phpage, ppsh->H_phpage, sizeof(HPROPSHEETPAGE) * ppsh->nPages);
#endif

    }

    //
    //  Everybody else assumes that the HPROPSHEETPAGEs have been
    //  internalized, so let's do that before anybody notices.
    //
    for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
    {
        SETPISP(ppd, iPage, InternalizeHPROPSHEETPAGE(ppd->psh.H_phpage[iPage]));
    }

    //
    //  Walk all pages to see if any have help and if so, set the PSH_HASHELP
    //  flag in the header.
    //
    if (!(ppd->psh.dwFlags & PSH_HASHELP))
    {
        for (iPage = 0; iPage < (int)ppd->psh.nPages; iPage++)
        {
            if (GETPPSP(ppd, iPage)->dwFlags & PSP_HASHELP)
            {
                ppd->psh.dwFlags |= PSH_HASHELP;
                break;
            }
        }
    }

    return _RealPropertySheet(ppd);
}
#undef fNeedShadow

#ifdef UNICODE

INT_PTR WINAPI PropertySheetW(LPCPROPSHEETHEADERW ppsh)
{
    return _PropertySheet(ppsh, FALSE);
}

INT_PTR WINAPI PropertySheetA(LPCPROPSHEETHEADERA ppsh)
{
    PROPSHEETHEADERW pshW;
    INT_PTR iResult;

    //
    //  Most validation is done by _PropertySheet, but we need
    //  to validate the header size, or we won't survive the thunk.
    //
    if (!IsValidPROPSHEETHEADERSIZE(ppsh->dwSize))
    {
        DebugMsg( DM_ERROR, TEXT("PropertySheet: dwSize is not correct") );
        goto Error;
    }

    if (!ThunkPropSheetHeaderAtoW(ppsh, &pshW))
        goto Error;

    iResult = _PropertySheet(&pshW, TRUE);

    FreePropSheetHeaderW(&pshW);

    return iResult;

Error:
    DestroyPropsheetPageArray((LPCPROPSHEETHEADER)ppsh);
    return -1;
}

#else

INT_PTR WINAPI PropertySheetW(LPCPROPSHEETHEADERW ppsh)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return -1;
}

#endif

//
//  CopyPropertyPageStrings
//
//  We have a PROPSHEETPAGE structure that contains pointers to strings.
//  For each string, create a copy and smash the pointer-to-copy in the
//  place where the original static pointer used to be.
//
//  The method of copying varies depending on what kind of copy we want
//  to make, so we use a callback procedure.
//
//  UNICODE-to-UNICODE: StrDupW
//  ANSI-to-UNICODE:    StrDup_AtoW
//  ANSI-to-ANSI:       StrDupA
//
//  On failure, all strings that did not get properly duplicated are set
//  to NULL.  You still have to call FreePropertyPageStrings to clear
//  them out.  Notice that when we fail to allocate, we merely make a note
//  of the fact and continue onward.  This ensures that all string fields
//  are set to NULL if they could not be dup'd.
//
//  ppsp - A pointer to either a PROPSHEETPAGEA or PROPSHEETPAGEW.
//         The two structures are laid out identically, so it doesn't matter.
//
//  pfnStrDup - function that will make the appropriate copy.
//

BOOL CopyPropertyPageStrings(LPPROPSHEETPAGE ppsp, STRDUPPROC pfnStrDup)
{
    BOOL fSuccess = TRUE;

    if (!(ppsp->dwFlags & PSP_DLGINDIRECT) && !IS_INTRESOURCE(ppsp->P_pszTemplate))
    {
        ppsp->P_pszTemplate = pfnStrDup(ppsp->P_pszTemplate);
        if (!ppsp->P_pszTemplate)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEICONID) && !IS_INTRESOURCE(ppsp->P_pszIcon))
    {
        ppsp->P_pszIcon = pfnStrDup(ppsp->P_pszIcon);
        if (!ppsp->P_pszIcon)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USETITLE) && !IS_INTRESOURCE(ppsp->pszTitle))
    {
        ppsp->pszTitle = pfnStrDup(ppsp->pszTitle);
        if (!ppsp->pszTitle)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEHEADERTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderTitle))
    {
        ppsp->pszHeaderTitle = pfnStrDup(ppsp->pszHeaderTitle);
        if (!ppsp->pszHeaderTitle)
            fSuccess = FALSE;
    }

    if ((ppsp->dwFlags & PSP_USEHEADERSUBTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderSubTitle))
    {
        ppsp->pszHeaderSubTitle = pfnStrDup(ppsp->pszHeaderSubTitle);
        if (!ppsp->pszHeaderSubTitle)
            fSuccess = FALSE;
    }

    return fSuccess;
}

//
//  FreePropertyPageStrings
//
//  Free the strings that live inside a property sheet page structure.
//
//  ppsp - A pointer to either a PROPSHEETPAGEA or PROPSHEETPAGEW.
//         The two structures are laid out identically, so it doesn't matter.
//

void FreePropertyPageStrings(LPCPROPSHEETPAGE ppsp)
{
    if (!(ppsp->dwFlags & PSP_DLGINDIRECT) && !IS_INTRESOURCE(ppsp->P_pszTemplate))
        LocalFree((LPVOID)ppsp->P_pszTemplate);

    if ((ppsp->dwFlags & PSP_USEICONID) && !IS_INTRESOURCE(ppsp->P_pszIcon))
        LocalFree((LPVOID)ppsp->P_pszIcon);

    if ((ppsp->dwFlags & PSP_USETITLE) && !IS_INTRESOURCE(ppsp->pszTitle))
        LocalFree((LPVOID)ppsp->pszTitle);

    if ((ppsp->dwFlags & PSP_USEHEADERTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderTitle))
        LocalFree((LPVOID)ppsp->pszHeaderTitle);

    if ((ppsp->dwFlags & PSP_USEHEADERSUBTITLE) && !IS_INTRESOURCE(ppsp->pszHeaderSubTitle))
        LocalFree((LPVOID)ppsp->pszHeaderSubTitle);
}

#ifdef UNICODE

//*************************************************************
//
//  ThunkPropSheetHeaderAtoW ()
//
//  Purpose:  Thunks the Ansi version of PROPSHEETHEADER to
//            Unicode.
//
//            Note that the H_phpage / H_ppsp field is not thunked.
//            We'll deal with that separately.
//
//*************************************************************

BOOL ThunkPropSheetHeaderAtoW (LPCPROPSHEETHEADERA ppshA,
                                LPPROPSHEETHEADERW ppsh)
{
    //
    //  Deciding whether an item should be freed or not is tricky, so we
    //  keep a private array of all the pointers we've allocated, so we
    //  know what to free when we fail.
    //
    LPTSTR Alloced[5] = { 0 };

    ASSERT(IsValidPROPSHEETHEADERSIZE(ppshA->dwSize));

    hmemcpy(ppsh, ppshA, ppshA->dwSize);

    ppsh->dwFlags |= PSH_THUNKED;
    if ((ppsh->dwFlags & PSH_USEICONID) && !IS_INTRESOURCE(ppsh->H_pszIcon))
    {
        ppsh->H_pszIcon = Alloced[0] = StrDup_AtoW(ppsh->H_pszIcon);
        if (!ppsh->H_pszIcon)
            goto ExitIcon;
    }

    if (!IS_WIZARDPSH(*ppsh) && !IS_INTRESOURCE(ppsh->pszCaption))
    {
        ppsh->pszCaption = Alloced[1] = StrDup_AtoW(ppsh->pszCaption);
        if (!ppsh->pszCaption)
            goto ExitCaption;
    }

    if ((ppsh->dwFlags & PSH_USEPSTARTPAGE) && !IS_INTRESOURCE(ppsh->H_pStartPage))
    {
        ppsh->H_pStartPage = Alloced[2] = StrDup_AtoW(ppsh->H_pStartPage);
        if (!ppsh->H_pStartPage)
            goto ExitStartPage;
    }

    if (ppsh->dwFlags & PSH_WIZARD97)
    {
        if ((ppsh->dwFlags & PSH_WATERMARK) &&
            !(ppsh->dwFlags & PSH_USEHBMWATERMARK) &&
            !IS_INTRESOURCE(ppsh->H_pszbmWatermark))
        {
            ppsh->H_pszbmWatermark = Alloced[3] = StrDup_AtoW(ppsh->H_pszbmWatermark);
            if (!ppsh->H_pszbmWatermark)
                goto ExitWatermark;
        }

        if ((ppsh->dwFlags & PSH_HEADER) &&
            !(ppsh->dwFlags & PSH_USEHBMHEADER) &&
            !IS_INTRESOURCE(ppsh->H_pszbmHeader))
        {
            ppsh->H_pszbmHeader = Alloced[4] = StrDup_AtoW(ppsh->H_pszbmHeader);
            if (!ppsh->H_pszbmHeader)
                goto ExitHeader;
        }
    }

    return TRUE;

ExitHeader:
    if (Alloced[3]) LocalFree(Alloced[3]);
ExitWatermark:
    if (Alloced[2]) LocalFree(Alloced[2]);
ExitStartPage:
    if (Alloced[1]) LocalFree(Alloced[1]);
ExitCaption:
    if (Alloced[0]) LocalFree(Alloced[0]);
ExitIcon:
    return FALSE;
}

void FreePropSheetHeaderW(LPPROPSHEETHEADERW ppsh)
{
    if ((ppsh->dwFlags & PSH_USEICONID) && !IS_INTRESOURCE(ppsh->H_pszIcon))
        LocalFree((LPVOID)ppsh->H_pszIcon);

    if (!IS_WIZARDPSH(*ppsh) && !IS_INTRESOURCE(ppsh->pszCaption))
        LocalFree((LPVOID)ppsh->pszCaption);

    if ((ppsh->dwFlags & PSH_USEPSTARTPAGE) && !IS_INTRESOURCE(ppsh->H_pStartPage))
        LocalFree((LPVOID)ppsh->H_pStartPage);

    if (ppsh->dwFlags & PSH_WIZARD97)
    {
        if ((ppsh->dwFlags & PSH_WATERMARK) &&
            !(ppsh->dwFlags & PSH_USEHBMWATERMARK) &&
            !IS_INTRESOURCE(ppsh->H_pszbmWatermark))
            LocalFree((LPVOID)ppsh->H_pszbmWatermark);

        if ((ppsh->dwFlags & PSH_HEADER) &&
            !(ppsh->dwFlags & PSH_USEHBMHEADER) &&
            !IS_INTRESOURCE(ppsh->H_pszbmHeader))
            LocalFree((LPVOID)ppsh->H_pszbmHeader);
    }
}

#endif

#ifndef WINNT

typedef LPARAM HPROPSHEETPAGE16;

extern BOOL WINAPI GetPageInfo16(HPROPSHEETPAGE16 hpage, LPTSTR pszCaption, int cbCaption, LPPOINT ppt, HICON FAR * phIcon);
extern BOOL WINAPI GetPageInfoME(HPROPSHEETPAGE16 hpage, LPTSTR pszCaption, int cbCaption, LPPOINT ppt, HICON FAR * phIcon, BOOL FAR* bRTL);

BOOL WINAPI _GetPageInfo16(HPROPSHEETPAGE16 hpage, LPTSTR pszCaption, int cbCaption, LPPOINT ppt, HICON FAR *hIcon, BOOL FAR * bRTL)
{

    // HACKHACK:  after win95 shipped, the thunk was changed for this api on
    // ME platforms.  so we have to detect the two cases and call them differently.
    if (g_fMEEnabled) {
        return GetPageInfoME(hpage, pszCaption, cbCaption, ppt, hIcon, bRTL);
    } else {
        if (bRTL)
            *bRTL = 0;
        return GetPageInfo16(hpage, pszCaption, cbCaption, ppt, hIcon);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\prshti.h ===
//
//  Internal data structures for property sheet support.
//

//
//  Wiz97 underwent a redesign between IE4 and IE5
//  so we have to treat them as two unrelated wizard styles that happen to
//  have frighteningly similar names.  So prsht.h contains both
//  PSH_WIZARD97IE4 and PSH_WIZARD97IE5, and defines PSH_WIZARD97 to be
//  the one appropriate to the version of the header file being included.
//
//  We redefine PSH_WIZARD97 to mean "Any form of Wizard97",
//
#undef  PSH_WIZARD97
#define PSH_WIZARD97        (PSH_WIZARD97IE4 | PSH_WIZARD97IE5)

//
//  The history of PROPSHEETHEADER
//
//  PROPSHEETHEADERSIZE_BETA
//
//      This is the property sheet header that shipped in an early
//      Win95 beta (sometime between Sep 1993 and Sep 1994, maybe M5).
//
//      It is just like the shipping Win95 property sheet header,
//      except that it lacks the PFNPROPSHEETCALLBACK at the end.
//      We grudgingly accept it but don't publicize the fact.
//
//      For some reason, we have always supported this wacky
//      ancient unreleased PROPSHEETHEADER, so there's no point
//      in dropping support for it now...  If you think it's not
//      worth retaining support for this ancient structure,
//      feel free to nuke it.  But you become responsible for the
//      potential app compat bugs from Norton Utilities for
//      Windows 95 v1.0.
//
//  PROPSHEETHEADERSIZE_V1
//
//      This is the property sheet header that shipped in Win95,
//      NT4, and IE3.  It is documented and lots of people use it.
//
//  PROPSHEETHEADERSIZE_V1a
//
//      This is an interim property sheet header that never shipped.
//      Support for it has been broken for a long time, so I dropped
//      the support altogether for IE5.
//
//  PROPSHEETHEADERSIZE_V2
//
//      This is the property sheet header that shipped in IE4.
//
#define PROPSHEETHEADERSIZE_BETA    CCSIZEOF_STRUCT(PROPSHEETHEADER, H_ppsp)
#define PROPSHEETHEADERSIZE_V1      CCSIZEOF_STRUCT(PROPSHEETHEADER, pfnCallback)
#define PROPSHEETHEADERSIZE_V2      CCSIZEOF_STRUCT(PROPSHEETHEADER, H_pszbmHeader)

#define IsValidPROPSHEETHEADERSIZE(dwSize) \
       ((dwSize) == PROPSHEETHEADERSIZE_BETA || \
        (dwSize) == PROPSHEETHEADERSIZE_V1   || \
        (dwSize) == PROPSHEETHEADERSIZE_V2)

// PropertySheetPage structure sizes:

#define MINPROPSHEETPAGESIZEA PROPSHEETPAGEA_V1_SIZE
#define MINPROPSHEETPAGESIZEW PROPSHEETPAGEW_V1_SIZE
#define MINPROPSHEETPAGESIZE  PROPSHEETPAGE_V1_SIZE

//  - COMPATIBILITY CONSTRAINT -
//
//  Shell32 prior to IE5 knows the internal structure of the HPROPSHEETPAGE,
//  so we have to give it what it wants.  (shell32\bitbuck.c, docfind2.c)
//
//  Win95 Golden - Shell32 expects the HPROPSHEETPAGE to be equal to
//  the lParam that is passed to the dialog proc's WM_INITDIALOG.
//  No special flags are passed in the PROPSHEETPAGE to indicate
//  that this assumption is being made.
//
//  Win95 IE4 Integrated - Same as Win95 Golden, except that
//  the shell sets the PSP_SHPAGE bit in the PROPSHEETPAGE.dwFlags
//  to indicate that it wants this wacky behavior.
//
//  WinNT Golden - Shell32 expects the HPROPSHEETPAGE to be equal
//  to a pointer to the internal PSP structure used by WinNT golden.
//  The internal PSP structure looked like a PROPSHEETPAGE, except
//  that it had two fields stuck in front.  (One DWORD and one pointer.)
//  The NT shell passes the PSP_SHPAGE flag.
//
//  WinNT IE4 Integrated - Same as WinNT Golden.
//
//  Furthermore, all versions of Shell32 prior to IE5 call the internal
//  CreatePage function (shell32\docfind2.c)
//
//  - Summary -
//
//                passes       expected      expects
//              PSP_SHPAGE       PSP         CLASSICPREFIX
//              ---------      -------       -------------
//  95 Gold                      ANSI
//  95/IE4          *            ANSI
//  NT Gold         *            UNI           *
//  NT/IE4          *            UNI           *
//
//  Note that Win95 Gold does not set the PSP_SHPAGE flag, so we have
//  to assume that any ANSI caller might be a Win95 Gold shell32.
//
//  WinNT is easier.  We return the WinNT Golden UNICODE version of
//  the PSP if (and only if) the PSP_SHPAGE flag is set.
//
//  The PSP_SHPAGE flag has been removed from the header file so nobody
//  can pass it ever again.
//
//  So our structures look like this.  The bracketed section is the
//  the memory block passed by the app to CreatePropertySheetPage
//  and whose layout cannot be altered.
//
//  ANSI Comctl32, ANSI application:
//
//            +---------------+
//            | PAGEPREFIX    |
//  hpage95->/+---------------+
//          / | PROPSHEETPAGE |
//          | |  (ANSI)       |
//          | |               |
//          | +---------------+
//          | |               |
//          | | app goo       |
//          \ |               |
//           \+---------------+
//
//  UNICODE Comctl32, ANSI application.
//
//
//          The authoritative page      The shadow page
//
//            +---------------+         + - - - - - - - +
//            | PAGEPREFIX    |         | PAGEPREFIX    |
//            +---------------+         +---------------+ <- hpageNT
//            | CLASSICPREFIX |<-\/-----| CLASSICPREFIX |
//            +---------------+<-/\---->+---------------+\<- hpage95
//            | PROPSHEETPAGE |         | PROPSHEETPAGE | \
//            |  (UNICODE)    |         |  (ANSI)       | |
//            |               |         |               | |
//            +---------------+         +---------------+ |
//                                      |               | |
//                                      | app goo       | |
//                                      |               | /
//                                      +---------------+/
//
//                                  (The dotted line around PAGEPREFIX
//                                   means that it is allocated but unused.)
//
//
//  UNICODE Comctl32, UNICODE application.
//
//            +---------------+
//            | PAGEPREFIX    |
//  hpageNT-> +---------------+
//            | CLASSICPREFIX |
//  hpage95->/+---------------+
//          / | PROPSHEETPAGE |
//          | |  (UNICODE)    |
//          | |               |
//          | +---------------+
//          | |               |
//          | | app goo       |
//          \ |               |
//           \+---------------+
//
//  Are we confused yet?  Let's try to explain.
//
//  REQUIREMENT
//
//      The app goo must be kept in the structure
//      corresponding to the character set of the application.
//
//      Notice that if the application is ANSI, then the app goo
//      is kept with the ANSI version of PROPSHEETPAGE.  If the
//      application is UNICODE, then the app goo is kept with the
//      UNICODE version of the PROPSHEETPAGE.
//
//      It doesn't hurt to "accidentally" put a copy of the app goo
//      on the version the app doesn't use; that just wastes memory.
//
//  REQUIREMENT
//
//      If a UNICODE app passed PSP_SHPAGE, then the hpage must
//      point to the CLASSICPREFIX structure.
//
//      To simplify matters (like HPROPSHEETPAGE validation), we
//      apply this rule even if the app didn't pass PSP_SHPAGE.
//
//  DESIGN
//
//      If the app is ANSI and we support UNICODE, then we create
//      a UNICODE copy of the ANSI property sheet structure,
//      and the ANSI PROPSHEETPAGE becomes a "shadow".
//      The UNICODE copy does not need to carry the app goo
//      since it will never be seen by the app.
//
//  REQUIREMENT
//
//      If an ANSI app creates a property sheet page, then the hpage
//      must point to the ANSI version of the PROPSHEETPAGE.
//      (Because the app might be shell32.)
//
//  >> CAUTION <<
//
//      The requirements on hpages rule means that any time an hpage
//      comes in from the outside world, we need to sniff it and decide
//      if it's the UNICODE version or the ANSI version; if it's
//      the ANSI version, then we switch the pointer to point to
//      the UNICODE version instead.
//
//  REMARK
//
//      Internally, we use only the UNICODE version of the PROPSHEETPAGE.
//      (Unless we're building Win95 ANSI-only, duh.)  The ANSI version
//      (the "shadow") is just for show to keep the app happy.  It is
//      the UNICODE version that is authoritative.
//
//      Only the authoritative PROPSHEETPAGE needs to have the PAGEPREFIX,
//      but we put one on both sides to simplify memory management,
//      because it means that all PROPSHEETPAGEs look the same (both
//      authoritative and shadow).

#define PSP_SHPAGE                 0x00000200  // Ewww; see above

#ifdef UNICODE
//
//  CLASSICPREFIX
//
//  This structure is allocated ahead of the PROPSHEETPAGE when we
//  create an HPROPSHEETPAGE.  See the diagrams above.  Sometimes
//  the HPROPSHEETPAGE points to this structure, sometimes it doesn't.
//  See the diagrams above.
//
//  This structure can never change, due to backwards compatibility
//  constraints described above.  (Okay, you can change it once you
//  decide to drop support for versions of NT less than 5, like that'll
//  ever happen.)

//
//  pispMain
//
//      Points to the main copy of the HPROPSHEETPAGE.
//
//  pispShadow
//
//      Points to that shadow copy of the HPROPSHEETPAGE, or NULL if
//      there is no shadow copy.

typedef struct CLASSICPREFIX {
    union ISP *pispMain;
    union ISP *pispShadow;
} CLASSICPREFIX, *PCLASSICPREFIX;

#endif // UNICODE

//
//  PAGEPREFIX
//
//  Stuff that we track which isn't part of the CLASSICPREFIX.
//
//  hpage is the HPROPSHEETPAGE that we give out to applications.
//

typedef struct PAGEPREFIX {
    HPROPSHEETPAGE hpage;
    DWORD dwInternalFlags;
    SIZE siz;                           // Page ideal size
} PAGEPREFIX, *PPAGEPREFIX;

//
//  Flag values for dwInternalFlags
//

#define PSPI_WX86               1
#define PSPI_FETCHEDICON        2       // For debugging (GetPageInfoEx)
#define PSPI_SIZEMASK           0xFFFF0000

//
//  _PSP
//
//  This is the structure than the compiler thinks an HPROPSHEETPAGE
//  points to.  To make sure all our code goes through
//  InternalizeHPROPSHEETPAGE on the way in and
//  ExternalizeHPROPSHEETPAGE on the way out, we intentionally leave
//  it undefined.

typedef struct _PSP PSP, *PPSP;

//
//  ISP - Internal Sheet Page
//
//  Our internal structure for tracking property sheet pages.  This
//  is also what a native-character set HPROPSHEETPAGE points to.
//
//  Note the "union with an array of one element that we index with
//  the value -1 in order to access it at negative offsets" trick.
//
//  Note also that the CLASSICPREFIX goes above the HPROPSHEETPAGE
//  on Win95, but below it on WinNT.  See discussion at the top of this
//  file.
//
//  To save all the typing of union names and [-1]'s, access to fields
//  of an IPSP are encapsulated inside the _psp, _cpfx, and _pfx macros.

typedef union ISP {
    struct {
        PAGEPREFIX pfx;             // lives above the HPROPSHEETPAGE
        #ifdef UNICODE_WIN9x
        CLASSICPREFIX cpfx;         // lives above the HPROPSHEETPAGE
        #endif
    } above[1];
    struct {
        #ifdef WINNT
        CLASSICPREFIX cpfx;         // lives below the HPROPSHEETPAGE
        #endif
        PROPSHEETPAGE psp;          // lives below the HPROPSHEETPAGE
    } below;
} ISP, *PISP;

#define _pfx    above[-1].pfx
#define _psp    below.psp
#ifdef WINNT
#define _cpfx   below.cpfx
#else
#define _cpfx   above[-1].cpfx
#endif

#define GETORIGINALSIZE(psp) (((psp)->_pfx.dwInternalFlags & PSPI_SIZEMASK) >> 16)
#define SETORIGINALSIZE(psp, iSize) ((psp)->_pfx.dwInternalFlags |= (iSize << 16))

#define PropSheetBase(pisp)     ((LPBYTE)(pisp) - sizeof((PISP)pisp)->above)

//
//  Converting an HPROPSHEETPAGE into a PSP means sniffing at the
//  _cpfx.dwFlags and seeing if it's an ANSI page or a UNICODE page.
//

__inline
PISP
InternalizeHPROPSHEETPAGE(HPROPSHEETPAGE hpage)
{
    PISP pisp = (PISP)hpage;
#ifdef UNICODE
    return pisp->_cpfx.pispMain;
#else // !UNICODE
    //  ANSI Comctl32's HPROPSHEETPAGE is the real thing
    return pisp;
#endif
}

#ifdef UNICODE
#define ExternalizeHPROPSHEETPAGE(pisp) ((pisp)->_pfx.hpage)
#else
#define ExternalizeHPROPSHEETPAGE(pisp) ((HPROPSHEETPAGE)(pisp))
#endif

//
// Used for GetPageInfo(), prpage.c
//
typedef struct {
    short     PointSize;
    WCHAR     szFace[LF_FACESIZE];
    BOOL      bItalic;
    int       iCharset;
} PAGEFONTDATA, * PPAGEFONTDATA;

//
//  PROPDATA
//
//  The state of a property sheet.
//

typedef struct
{
    HWND hDlg;          // the dialog for this instance data
    PROPSHEETHEADER psh;

    HWND hwndCurPage;   // current page hwnd
    HWND hwndTabs;      // tab control window
    int nCurItem;       // index of current item in tab control
    int idDefaultFallback; // the default id to set as DEFID if page doesn't have one

    int nReturn;
    UINT nRestart;

    int xSubDlg, ySubDlg;       // dimensions of sub dialog
    int cxSubDlg, cySubDlg;

    BOOL fFlags;
    BOOL fFlipped;      // Property sheet not mirrored but with flipped buttons

    // Wizard97 IE4 vs. IE5 discrepancy:
    //
    //  Wizard 97 IE4 - "watermark" refers to the bitmap that is used to
    //                  paint the background of the dialog.
    //  Wizard 97 IE5 - "watermark" refers to the bitmap that goes on
    //                  on the left-hand side of Welcome/Finish screens.
    //
  
    HBITMAP hbmWatermark;
    HBRUSH  hbrWatermark;
    HPALETTE hplWatermark;

    int cyHeaderHeight;
    HFONT hFontBold;
    HBITMAP hbmHeader;
    HBRUSH  hbrHeader;
    int ySubTitle;      // The subtitle's starting Y position
    BOOL fAllowApply;

    // These fields are used by MLUI
    LANGID wFrameLang;      // langid of propsheet frame
    int iFrameCharset;      // charset of propsheet frame

    // These fields cache font metric information
    PAGEFONTDATA    pfdCache;           // Cached font descriptor
    SIZE            sizCache;           // Cached height and width go here
    SIZE            sizMin;             // Smallest we allow pages to get

    HPROPSHEETPAGE rghpage[MAXPROPPAGES];

} PROPDATA, *LPPROPDATA;
// defines for fFlags
#define PD_NOERASE       0x0001
#define PD_CANCELTOCLOSE 0x0002
#define PD_DESTROY       0x0004
#define PD_WX86          0x0008
#define PD_FREETITLE     0x0010
#define PD_SHELLFONT     0x0020         // Is the frame using SHELLFONT?
#define PD_NEEDSHADOW    0x0040

//
//  Helper macros
//
//  UNIX does not support dummy unions, so we have to say
//  DUMMYUNION<n>_MEMBER all over the place.
//  So all these underscore macros do the grunky work for us.
//
//  H_blah means "the field in the PROPSHEETHEADER named blah".
//  P_blah means "the field in the PROPSHEETPAGE   named blah".
//
//
#define H_hIcon             DUMMYUNION_MEMBER(hIcon)
#define H_pszIcon           DUMMYUNION_MEMBER(pszIcon)
#define H_nStartPage        DUMMYUNION2_MEMBER(nStartPage)
#define H_pStartPage        DUMMYUNION2_MEMBER(pStartPage)
#define H_phpage            DUMMYUNION3_MEMBER(phpage)
#define H_ppsp              DUMMYUNION3_MEMBER(ppsp)
#define H_hbmWatermark      DUMMYUNION4_MEMBER(hbmWatermark)
#define H_pszbmWatermark    DUMMYUNION4_MEMBER(pszbmWatermark)
#define H_hbmHeader         DUMMYUNION5_MEMBER(hbmHeader)
#define H_pszbmHeader       DUMMYUNION5_MEMBER(pszbmHeader)

#define P_pszTemplate       DUMMYUNION_MEMBER(pszTemplate)
#define P_pResource         DUMMYUNION_MEMBER(pResource)
#define P_hIcon             DUMMYUNION2_MEMBER(hIcon)
#define P_pszIcon           DUMMYUNION2_MEMBER(pszIcon)

//
//  HASCALLBACK - We should call the callback for this page.
//

#define HASCALLBACK(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USECALLBACK) && \
         (pisp)->_psp.pfnCallback)

//
//  HASREFPARENT - We should adjust the pcRefParent for this page.
//

#define HASREFPARENT(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEREFPARENT) && \
         (pisp)->_psp.pcRefParent)

//
//  HASHEADERTITLE - We should display a header title for this page.
//

#define HASHEADERTITLE(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEHEADERTITLE) && \
         (pisp)->_psp.pszHeaderTitle)

//
//  HASHEADERSUBTITLE - We should display a header subtitle for this page.
//

#define HASHEADERSUBTITLE(pisp) \
       (((pisp)->_psp.dwFlags & PSP_USEHEADERSUBTITLE) && \
         (pisp)->_psp.pszHeaderSubTitle)

//
//  GETPISP - Obtain the PISP for this page.  Once they have been
//            placed into the H_phpage, all the HPROPSHEETPAGEs are
//            already internalized, so we can just cast them over.
//

#define GETPISP(ppd, i) ((PISP)(ppd)->psh.H_phpage[i])

//
//  SETPISP - Change the PISP for this page.
//

#define SETPISP(ppd, i, v) ((ppd)->psh.H_phpage[i] = (HPROPSHEETPAGE)(v))

//
//  GETHPAGE - Obtain the external HPROPSHEETPAGE for this page.
//
#define GETHPAGE(ppd, i) ExternalizeHPROPSHEETPAGE(GETPISP(ppd, i))

//
//  GETPPSP - Obtain the PPSP for this page.  We get the PISP
//            and then retrieve the PROPSHEETHEADER part.
//

#define GETPPSP(ppd, i) (&GETPISP(ppd, i)->_psp)

//
//  HASANSISHADOW
//
//  Does this authoritative property sheet page have an ANSI shadow?
//
//  If we are built ANSI, then the canonical PSP is equal to the
//  ANSI version, so there is no shadow.  (It's already the real thing.)
//
#ifdef UNICODE
#define HASANSISHADOW(pisp) ((pisp)->_cpfx.pispShadow)
#else
#define HASANSISHADOW(pisp) FALSE
#endif

//
//  HIDEWIZ97HEADER
//
//      Nonzero if we are a WIZARD97 property sheet but we should
//      hide the header for this page.

#define HIDEWIZ97HEADER(ppd, i) \
        (((ppd)->psh.dwFlags & PSH_WIZARD97) && \
          (GETPPSP(ppd, i)->dwFlags & PSP_HIDEHEADER))

//
//  Stub macros so we don't have to put "#ifdef BIG_ENDIAN" everywhere.
//
#ifndef BIG_ENDIAN
#define MwReadDWORD(lpByte)   *(LPDWORD)(lpByte)
#define MwWriteDWORD(lpByte, dwValue)   *(LPDWORD)(lpByte) = dwValue
#endif

//
//  End of helper macros
//

//
//  Functions shared between prsht.c and prpage.c
//
PISP AllocPropertySheetPage(DWORD dwClientSize);
HWND _CreatePage(LPPROPDATA ppd, PISP pisp, HWND hwndParent, LANGID langidMUI);
HPROPSHEETPAGE WINAPI _CreatePropertySheetPage(LPCPROPSHEETPAGE psp, BOOL fNeedShadow, BOOL fWx86);
#ifdef UNICODE
HPROPSHEETPAGE WINAPI _Hijaak95Hack(LPPROPDATA ppd, HPROPSHEETPAGE hpage);
#else
#define _Hijaak95Hack(ppd, hpage) hpage
#endif

typedef LPTSTR (STDMETHODCALLTYPE *STRDUPPROC)(LPCTSTR ptsz);

BOOL CopyPropertyPageStrings(LPPROPSHEETPAGE ppsp, STRDUPPROC pfnStrDup);
void FreePropertyPageStrings(LPCPROPSHEETPAGE ppsp);

BOOL ThunkPropSheetHeaderAtoW (LPCPROPSHEETHEADERA ppshA,
                                LPPROPSHEETHEADERW ppsh);
void FreePropSheetHeaderW(LPPROPSHEETHEADERW ppsh);

STDAPI_(LPTSTR) StrDup_AtoW(LPCTSTR ptsz);


typedef struct 
{
    POINT pt;               // Dialog box dimensions (DLU)
    HICON hIcon;            // Page icon
    PAGEFONTDATA pfd;       // Font info
#ifdef WINDOWS_ME
    BOOL bRTL;              // If tab caption should be right to left reading
#endif
    BOOL bMirrored;            // if the page contains mirroring flags
    BOOL bDialogEx;         // Is it a DIALOGEX?
    DWORD dwStyle;          // Dialog style
    TCHAR szCaption[128 + 50];  // Caption as stored in template

} PAGEINFOEX;

//
//  These flags control which parts of the PAGEINFOEX get filled in.
//
#define GPI_PT          0x0000      // so cheap, we always fetch it
#define GPI_ICON        0x0001
#define GPI_FONT        0x0002      // PAGEFONTDATA
#define GPI_BRTL        0x0000      // so cheap, we always fetch it
#define GPI_BMIRROR     0x0000      // so cheap, we always fetch it
#define GPI_DIALOGEX    0x0000      // so cheap, we always fetch it
#define GPI_CAPTION     0x0004
#define GPI_ALL         0x0007

BOOL WINAPI GetPageInfoEx(LPPROPDATA ppd, PISP pisp, PAGEINFOEX *ppi, LANGID langidMUI, DWORD flags);

// SHELLFONT means that you are a DIALOGEX and have the DS_SHELLFONT bits set
// Although this is supported only on NT5, the flag is still meaningful on
// Win9x to indicate an implicit PSH_USEPAGEFONT.
#define IsPageInfoSHELLFONT(ppi) \
    ((ppi)->bDialogEx && DS_SHELLFONT == (DS_SHELLFONT & (ppi)->dwStyle))

// Prsht_PrepareTemplate operating systems types
// Used as array indices. Be careful !!

typedef enum {
    PSPT_OS_WIN95_BIDI,    // Win95  BiDi
    PSPT_OS_WIN98_BIDI,    // Win98  BiDi   (Or Higher)
    PSPT_OS_WINNT4_ENA,    // WinNT4 BiDi Ena, No Winnt4 BiDi loc
    PSPT_OS_WINNT5,        // WinNT5 (Or Higher)
    PSPT_OS_OTHER,         // Anything else ....
    PSPT_OS_MAX            
    } PSPT_OS;

// Prsht_PrepareTemplate property sheet type 
// Used as array indices. Be careful !!
typedef enum {
    PSPT_TYPE_MIRRORED,     // Mirrored first page OR mirrored Process
    PSPT_TYPE_ENABLED,      // First page Language is BiDi
    PSPT_TYPE_ENGLISH,      // Anything else ....
    PSPT_TYPE_MAX           
} PSPT_TYPE;

// Prsht_PrepareTemplate property sheet default behavior override
// Used as array indices. Be careful !!

typedef enum {
    PSPT_OVERRIDE_NOOVERRIDE,
    PSPT_OVERRIDE_USEPAGELANG,  // Overridden by PSH_USEPAGELANG
    PSPT_OVERRIDE_MAX
    } PSPT_OVERRIDE;

// Prsht_PrepareTemplate Preparation action
typedef enum {
    PSPT_ACTION_NOACTION,      // Don't touch whatever you've passed
    PSPT_ACTION_NOMIRRORING,   // Turn off mirroring
    PSPT_ACTION_FLIP,          // Turn off mirroring and flip
    PSPT_ACTION_LOADENGLISH,   // load English template
    PSPT_ACTION_WIN9XCOMPAT    // Tags the templae with DS_BIDI_RTL for Win9x compat
    } PSPT_ACTION;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\rcids.h ===
#define IDS_SPACE       0x0400
#define IDS_PLUS        0x0401
#define IDS_NONE        0x0402

/* System MenuHelp
 */
#define MH_SYSMENU      (0x8000U - MINSYSCOMMAND)
#define IDS_SYSMENU     (MH_SYSMENU-16)
#define IDS_HEADER      (MH_SYSMENU-15)
#define IDS_HEADERADJ   (MH_SYSMENU-14)
#define IDS_TOOLBARADJ  (MH_SYSMENU-13)

/* Cursor ID's
 */
#define IDC_SPLIT       100
#define IDC_MOVEBUTTON  102

#define IDC_STOP            103
#define IDC_COPY            104
#define IDC_MOVE            105
#define IDC_DIVIDER         106
#define IDC_DIVOPEN         107


/*
 * Cursor values 108 - 119 are used by
 * the ReaderMode cursors.  They are defined
 * in commctrl.w
 *
#define IDC_HAND_INTERNAL   108
#define IDC_VERTICALONLY    109
#define IDC_HORIZONTALONLY  110
#define IDC_MOVE2D          111
#define IDC_NORTH           112
#define IDC_SOUTH           113
#define IDC_EAST            114
#define IDC_WEST            115
#define IDC_NORTHEAST       116
#define IDC_NORTHWEST       117
#define IDC_SOUTHEAST       118
#define IDC_SOUTHWEST       119
 */

#define IDB_STDTB_SMALL_COLOR   120
#define IDB_STDTB_LARGE_COLOR   121



#define IDB_VIEWTB_SMALL_COLOR  124
#define IDB_VIEWTB_LARGE_COLOR  125

#define IDB_CAL_SPIRAL          126
#define IDB_CAL_PAGETURN        127

#define IDB_HISTTB_SMALL_COLOR  130
#define IDB_HISTTB_LARGE_COLOR  131

/*
 * Bitmap values 132-134 are used by
 * applications that use ReaderMode.
 * They are used for the "origin bitmap"
 * that is overlayed on the document they
 * are scrolling.
#define IDB_2DSCROLL    132
#define IDB_VSCROLL     133
#define IDB_HSCROLL     134
 */
#define IDC_DIVOPENV    135

/* Image used by the filter bar */
#define IDB_FILTERIMAGE 140

/* Icon ID's
 */
#define IDI_INSERT      150

/* AdjustDlgProc stuff
 */
#define ADJUSTDLG       200
#define IDC_BUTTONLIST  201
#define IDC_RESET       202
#define IDC_CURRENT     203
#define IDC_REMOVE      204
#define IDC_APPHELP     205
#define IDC_MOVEUP      206
#define IDC_MOVEDOWN    207

/// ================ WARNING: ====
/// these ids are loaded directly by ISV's.  do not change them.
// property sheet stuff
#define DLG_PROPSHEET           1006
#define DLG_PROPSHEETTABS       1007
#define DLG_PROPSHEET95         1008


// wizard property sheet stuff
#define DLG_WIZARD              1020
#define DLG_WIZARD95            1021
/// ================ WARNING: ====


// if this id changes, it needs to change in shelldll as well.
// we need to find a better way of dealing with this.
#define IDS_CLOSE               0x1040
#define IDS_OK                  0x1041
#define IDS_PROPERTIESFOR       0x1042

// stuff for the moth/datetime pickers
#define IDS_TODAY        0x1043
#define IDS_GOTOTODAY    0x1044
#define IDS_DELIMETERS   0x1045
#define IDS_MONTHFMT     0x1046
#define IDS_MONTHYEARFMT 0x1047

// stuff used by filter bar in header
#define IDS_ENTERTEXTHERE 0x1050

#define IDS_PROPERTIES          0x1051

#define IDD_PAGELIST            0x3020
#define IDD_APPLYNOW            0x3021
#define IDD_DLGFRAME            0x3022
#define IDD_BACK                0x3023
#define IDD_NEXT                0x3024
#define IDD_FINISH              0x3025
#define IDD_DIVIDER             0x3026
#define IDD_TOPDIVIDER          0x3027

// Tool Tip title icons
#define IDI_TITLE_ERROR     0x5000
#define IDI_TITLE_INFO      0x5001
#define IDI_TITLE_WARNING   0x5002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\reader.c ===
#include "ctlspriv.h"

static struct {
    WPARAM vk1;
    WPARAM vk2;
    int dx;
    int dy;
} arrNumMaps[] = 
{ 
    { VK_NUMPAD1, VK_END,   -RM_SCROLLUNIT, RM_SCROLLUNIT,},
    { VK_NUMPAD2, VK_DOWN,  0,              RM_SCROLLUNIT},
    { VK_NUMPAD3, VK_NEXT,  RM_SCROLLUNIT,  RM_SCROLLUNIT},
    { VK_NUMPAD4, VK_LEFT,  -RM_SCROLLUNIT, 0},
    { VK_NUMPAD5, VK_CLEAR, 0,              0},
    { VK_NUMPAD6, VK_RIGHT, RM_SCROLLUNIT,  0},
    { VK_NUMPAD7, VK_HOME,  -RM_SCROLLUNIT, -RM_SCROLLUNIT},
    { VK_NUMPAD8, VK_UP,    0,              -RM_SCROLLUNIT},
    { VK_NUMPAD9, VK_PRIOR, RM_SCROLLUNIT,  -RM_SCROLLUNIT},
};

// do some keyboard handling...
// this works like USER's arrow keys for resizing 
// bugbug, diagonals don't work right now
void RM_HandleKeyDown(LPRECT prcHot, WPARAM wParam, LPARAM lParam)
{
    int i;
    POINT pt;
    
    GetCursorPos(&pt);
    
    for (i = ARRAYSIZE(arrNumMaps) - 1 ; i >= 0; i--) {
        if (wParam == arrNumMaps[i].vk1 || 
            wParam == arrNumMaps[i].vk2) {
            break;
        }
    }
    
    if (i == -1) {
        ReleaseCapture();
        return;
    }

    // this deals with if the cursor is within the bounds of the rect
    if (pt.x < prcHot->right &&
        pt.x >= prcHot->left && 
        arrNumMaps[i].dx) {
        
        if (arrNumMaps[i].dx > 0)
            pt.x = prcHot->right - 2;
        else 
            pt.x = prcHot->left + 1;
        
    }
    
    if (pt.y < prcHot->bottom &&
        pt.y >= prcHot->top && 
        arrNumMaps[i].dy) {
        
        if (arrNumMaps[i].dy > 0)
            pt.y = prcHot->bottom - 2;
        else 
            pt.y = prcHot->top + 1;
        
    }
    
    pt.x += arrNumMaps[i].dx;
    pt.y += arrNumMaps[i].dy;

    if (!arrNumMaps[i].dx && !arrNumMaps[i].dy) {
        // special case this for centering
        pt.x = (prcHot->right + prcHot->left) / 2;
        pt.y = (prcHot->top + prcHot->bottom) / 2;
    }

    // all we do is move the cursor.. the RM_CheckScroll will do the actual
    // scrolling for us.
    SetCursorPos(pt.x, pt.y);
}

void RM_GetScrollXY(PREADERMODEINFO prmi, LPRECT prcHot, LPINT pdx, LPINT pdy)
{

    POINT pt;
    
    GetCursorPos(&pt);
    
    *pdx = 0;
    *pdy = 0;
    
    if (pt.x <= prcHot->left) {
        *pdx = ((pt.x - prcHot->left) / RM_SCROLLUNIT) - 1;
    } else if (pt.x >= prcHot->right) {
        *pdx = ((pt.x - prcHot->right) / RM_SCROLLUNIT) + 1;
    }
    
    if (pt.y <= prcHot->top) {
        *pdy = ((pt.y - prcHot->top) / RM_SCROLLUNIT) - 1;
    } else if (pt.y >= prcHot->bottom) {
        *pdy = ((pt.y - prcHot->bottom) / RM_SCROLLUNIT) + 1;
    }

    if (prmi->fFlags & RMF_VERTICALONLY)
        *pdx = 0;

    if (prmi->fFlags & RMF_HORIZONTALONLY)
        *pdy = 0;
}

void RM_CheckScroll(PREADERMODEINFO prmi, LPRECT prcHot)
{
    int dx;
    int dy;

    RM_GetScrollXY(prmi, prcHot, &dx, &dy);
    prmi->pfnScroll(prmi, dx, dy);
}

void RM_SetCursor(PREADERMODEINFO prmi, LPRECT prcHot)
{
    int dx;
    int dy;
    LPCTSTR pRes;
    
    RM_GetScrollXY(prmi, prcHot, &dx, &dy);

    // default is center
    if (prmi->fFlags & RMF_VERTICALONLY)
        pRes = IDC_VERTICALONLY;
    else if (prmi->fFlags & RMF_HORIZONTALONLY)
        pRes = IDC_HORIZONTALONLY;
    else
        pRes = IDC_MOVE2D;

    // multiply to figure out if either is zero and also the sign parity
    if (dy * dx) {
        // diagonal case
        if (dy > 0) {
            if (dx > 0)
                pRes = IDC_SOUTHEAST;
            else
                pRes = IDC_SOUTHWEST;
        } else {
            if (dx > 0)
                pRes = IDC_NORTHEAST;
            else
                pRes = IDC_NORTHWEST;
        }
    } else {
        // simple horizontal or vertical case
        if (dy > 0)
            pRes = IDC_SOUTH;
        else if (dy < 0)
            pRes = IDC_NORTH;
        else if (dx < 0)
            pRes = IDC_WEST;
        else if (dx > 0)
            pRes = IDC_EAST;
    }
    
    SetCursor(LoadCursor(HINST_THISDLL, pRes));
    
}

void DoReaderMode(PREADERMODEINFO prmi)
{
    RECT rcHot;
    
    if (!prmi->hwnd || prmi->cbSize != sizeof(*prmi))
        return;
    
    SetCapture(prmi->hwnd);
    
    // if they didn't pass in a rect, then use the window
    if (!prmi->prc) {
        GetWindowRect(prmi->hwnd, &rcHot );
    } else {
        rcHot = *prmi->prc;
        MapWindowPoints(prmi->hwnd, HWND_DESKTOP, (LPPOINT)&rcHot, 2);
    }
    
    
    // set the cursor to the center of the hot rect if they ask us to
    if (prmi->fFlags & RMF_ZEROCURSOR) {
        SetCursorPos((rcHot.left + rcHot.right)/2, 
                     (rcHot.top + rcHot.bottom)/2);
    }
    
    while (GetCapture() == prmi->hwnd) {
        
        BOOL  fMessage;
        MSG32 msg32;
        RM_CheckScroll(prmi, &rcHot);

        // Try to peek keyboard message first, then mouse message,
        // and finally, other message. This is for raid 44392.
        // During scrolling, Trident might generate too many WM_PAINT
        // messages that push keyboard/mouse message (that DoReaderMode()
        // uses to stop auto-scroll mode) down in message pump, and we can
        // not get those messages until we peek and process all these
        // WM_PAINT messages. This is way cuto-scroll mode can be stopped
        // only by moving cursor back to origin circle (Trident does not
        // scroll, so no need to paint). Trident's scroll performance
        // issue will be worked on after RTM (raid 33232).
        //
        fMessage = PeekMessage32(&msg32, NULL, WM_KEYFIRST, WM_KEYLAST,
                        PM_REMOVE, TRUE);
        if (!fMessage)
        {
            fMessage = PeekMessage32(&msg32, NULL, WM_MOUSEFIRST, WM_MOUSELAST,
                            PM_REMOVE, TRUE);
            if (!fMessage)
            {
                fMessage = PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE);
            }
        }

        if (fMessage) {
            if (!prmi->pfnTranslateDispatch || 
                !prmi->pfnTranslateDispatch((LPMSG)&msg32)) {

                if (msg32.message == g_msgMSWheel)
                    goto BailOut;

                switch(msg32.message) {
                case WM_LBUTTONUP:
                case WM_RBUTTONUP:
                case WM_MBUTTONUP:
                case WM_LBUTTONDOWN:
                case WM_RBUTTONDOWN:
                case WM_MBUTTONDOWN:
                case WM_SYSKEYDOWN:
BailOut:
                    ReleaseCapture();
                    break;

                case WM_KEYDOWN:
                    // if it's an arrow key, move the mouse cursor
                    RM_HandleKeyDown(&rcHot, msg32.wParam, msg32.lParam);
                    break;

                case WM_MOUSEMOVE:
                case WM_SETCURSOR:
                    RM_SetCursor(prmi, &rcHot);
                    break;

                default:
                    TranslateMessage32(&msg32, TRUE);
                    DispatchMessage32(&msg32, TRUE);
                }
                
            }
        }
        else WaitMessage();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\rebar.h ===
typedef struct tagREBARBAND
{
    UINT        fStyle;
    COLORREF    clrFore;
    COLORREF    clrBack;
    LPTSTR      lpText;
    UINT        cxText;         // width of header text
    int         iImage;
    HWND        hwndChild;
    UINT        cxMinChild;     // min width for hwndChild
    UINT        cyMinChild;     // min height for hwndChild
    UINT        cxBmp;
    UINT        cyBmp;
    HBITMAP     hbmBack;
    int         x;              // left edge of band, relative to rebar
    int         y;              // top edge of band, relative to rebar
    int         cx;             // total width of band
    int         cy;             // height of band
    int         cxRequest;      // 'requested' width for band; either requested by host or 
                                // used as temp var during size recalculation
    int         cxMin;          // min width for band
    int         cxIdeal;        // hwndChild's desired width
    UINT        wID;
    UINT        cyMaxChild;     // hwndChild's max height
    UINT        cyIntegral;     // ??
    UINT        cyChild;        // this differs from cyMinChild only in RBBS_VARIABLEHEIGHT mode
    LPARAM      lParam;

    BITBOOL     fChevron:1;     // band is showing chevron button
    RECT        rcChevron;      // chevron button rect
    UINT        wChevState;     // chevron button state (DFCS_PUSHED, etc.)
} RBB, NEAR *PRBB;

typedef struct tagREBAR
{
    CONTROLINFO ci;
    HPALETTE    hpal;
    BITBOOL     fResizeRecursed:1;
    BITBOOL     fResizePending:1;
    BITBOOL     fResizeNotify:1;
    BITBOOL     fRedraw:1;
    BITBOOL     fRecalcPending:1;
    BITBOOL     fRecalc:1;
    BITBOOL     fParentDrag:1;
    BITBOOL     fRefreshPending:1;
    BITBOOL     fResizing:1;
    BITBOOL     fUserPalette:1;
    BITBOOL     fFontCreated:1;
    BITBOOL     fFullOnDrag:1;
    HDRAGPROXY  hDragProxy;
    HWND        hwndToolTips;
    UINT        cBands;
    int         xBmpOrg;
    int         yBmpOrg;
    HIMAGELIST  himl;
    UINT        cxImage;
    UINT        cyImage;
    HFONT       hFont;
    UINT        cyFont;
    UINT        cy;
    int         iCapture;
    POINT       ptCapture;
    int         xStart;
    PRBB        rbbList;
    COLORREF    clrBk;
    COLORREF    clrText;
    UINT        uResizeNext;    // this marks the next band to resize vertically if needed and allowed (VARIABLEHEIGHT set)
    DWORD       dwStyleEx;
    COLORSCHEME clrsc;
    POINT       ptLastDragPos;
    PRBB        prbbHot;        // band w/ hot chevron
} RB, NEAR *PRB;

void NEAR PASCAL RBPaint(PRB prb, HDC hdc);
void NEAR PASCAL RBDrawBand(PRB prb, PRBB prbb, HDC hdc);
void NEAR PASCAL RBResize(PRB prb, BOOL fForceHeightChange);
BOOL NEAR PASCAL RBSetFont(PRB prb, WPARAM wParam);

BOOL NEAR PASCAL RBGetBandInfo(PRB prb, UINT uBand, LPREBARBANDINFO lprbbi);
BOOL NEAR PASCAL RBSetBandInfo(PRB prb, UINT uBand, LPREBARBANDINFO lprbbi, BOOL fAllowRecalc);
BOOL NEAR PASCAL RBInsertBand(PRB prb, UINT uBand, LPREBARBANDINFO lprbbi);
BOOL NEAR PASCAL RBDeleteBand(PRB prb, UINT uBand);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\rebar.c ===
#include "ctlspriv.h"
#include "rebar.h"
#include "image.h"

#ifdef DEBUG
int ExprASSERT(int e);
BOOL RBCheckRangePtr(PRB prb, PRBB prbb);
BOOL RBCheckRangeInd(PRB prb, INT_PTR i);
#else
#define ExprASSERT(e)   0
#define RBCheckRangePtr(prb, prbb)  0
#define RBCheckRangeInd(prb, i)     0
#endif

#define RBBUSECHEVRON(prb, prbb)    ((prbb->fStyle & RBBS_USECHEVRON) &&              \
                                    !((prbb)->fStyle & RBBS_FIXEDSIZE) &&          \
                                    ((UINT)(prbb)->cxIdeal > (prbb)->cxMinChild))

#define RBSHOWTEXT(prbb) (!(prbb->fStyle&RBBS_HIDETITLE) && prbb->lpText && prbb->lpText[0])

#define CX_CHEVRON (5 * g_cxEdge + 2)
#define CX_OFFSET (2 * g_cxEdge)
#define RB_GRABWIDTH 5
#define RB_ISVERT(prb)  ((prb)->ci.style & CCS_VERT)
#define RB_ISVERTICALGRIPPER(prb) (RB_ISVERT(prb) && (prb)->ci.style & RBS_VERTICALGRIPPER)
#define RB_GETLASTBAND(prb) ((prb)->cBands ? RBGETBAND(prb, (prb)->cBands -1) : NULL)

#define RBISBANDSTARTOFROW(prbb) (!((prbb)->x) && !((prbb)->fStyle & RBBS_HIDDEN))
#define RBGETBAND(prb, i) (ExprASSERT(RBCheckRangeInd(prb, i)), &(prb)->rbbList[i])
#define RBISSTARTOFROW(prb, i) (RBISBANDSTARTOFROW( RBGETBAND((prb), (i))))
#define RBGETFIRSTBAND(prb) (RBGETBAND(prb, 0))
#define RBBANDTOINDEX(prb, prbb) ((int)((prbb) - (prb)->rbbList))
#define RBBHEADERWIDTH(prbb) ((prbb)->cxMin - ((prbb)->cxMinChild + ((RBBUSECHEVRON(prb, prbb) ? CX_CHEVRON : 0))))
#define RBISBANDVISIBLE(prbb)  (!((prbb)->fStyle & RBBS_HIDDEN))
#define RBROWATMINHEIGHT(prb, pprbb) (!RBGetRowHeightExtra(prb, pprbb, NULL))
#define RBGETBARHEIGHT(prb) (((prb)->cBands && !(prb)->cy) ? RBRecalc(prb) : (prb)->cy)

#define RB_ISVALIDINDEX(prb, i)     ((UINT)i < (prb)->cBands)
#define RB_ISVALIDBAND(prb, prbb)   RB_ISVALIDINDEX(prb, RBBANDTOINDEX(prb, prbb))

#define RB_ANIMSTEPS 10
#define RB_ANIMSTEPTIME 5

void FlipRect(LPRECT prc);

void RBPassBreak(PRB prb, PRBB prbbSrc, PRBB prbbDest);
int RBHitTest(PRB prb, LPRBHITTESTINFO prbht);
BOOL RBSizeBandsToRect(PRB prb, LPRECT prc);
BOOL RBShouldDrawGripper(PRB prb, PRBB prbb);
void RBAutoSize(PRB prb);
void RBSizeBandsToRowHeight(PRB prb);
void RBSizeBandToRowHeight(PRB prb, int i, UINT uRowHeight);
BOOL RBSetBandPos(PRB prb, PRBB prbb, int xLeft);
BOOL RBSetBandPosAnim(PRB prb, PRBB prbb, int xLeft);
PRBB RBGetFirstInRow(PRB prb, PRBB prbbRow);
PRBB RBGetLastInRow(PRB prb, PRBB prbbRow, BOOL fStopAtFixed);
PRBB RBGetPrev(PRB prb, PRBB prbb, UINT uStyleSkip);
PRBB RBGetNext(PRB prb, PRBB prbb, UINT uStyleSkip);
PRBB RBEnumBand(PRB prb, int i, UINT uStyleSkip);
int RBCountBands(PRB prb, UINT uStyleSkip);
BOOL RBMaximizeBand(PRB prb, UINT uBand, BOOL fIdeal, BOOL fAnim);
PRBB RBGetNextVisible(PRB prb, PRBB prbb);
PRBB RBGetPrevVisible(PRB prb, PRBB prbb);
PRBB RBBNextVisible(PRB prb, PRBB prbb);
BOOL  RBShowBand(PRB prb, UINT uBand, BOOL fShow);
void RBGetClientRect(PRB prb, LPRECT prc);
int RBGetRowHeightExtra(PRB prb, PRBB *pprbb, PRBB prbbSkip);
void RBOnBeginDrag(PRB prb, UINT uBand);

#define RBBANDWIDTH(prb, prbb)  _RBBandWidth(prb, prbb->cx)
#ifdef DEBUG
#undef  RBBANDWIDTH
#define RBBANDWIDTH(prb, prbb) \
    ((prbb->fStyle & RBBS_HIDDEN) ? (ExprASSERT(0), -1) : \
    _RBBandWidth(prb, prbb->cx))
#endif

#define RBBANDMINWIDTH(prb, prbb) _RBBandWidth(prb, prbb->cxMin)
#ifdef DEBUG
#undef  RBBANDMINWIDTH
#define RBBANDMINWIDTH(prb, prbb) \
    ((prbb->fStyle & RBBS_HIDDEN) ? (ExprASSERT(0), -1) : \
    _RBBandWidth(prb, prbb->cxMin))
#endif

//***   RBC_* -- commands
#define RBC_QUERY   0
#define RBC_SET     1

#ifdef DEBUG
int ExprASSERT(int e)
{
    ASSERT(e);
    return 0;
}
#endif

HBRUSH g_hDPFRBrush = NULL;

__inline COLORREF RB_GetBkColor(PRB prb)
{
    if (prb->clrBk == CLR_DEFAULT)
        return g_clrBtnFace;
    else
        return prb->clrBk;
}

__inline COLORREF RB_GetTextColor(PRB prb)
{
    if (prb->clrText == CLR_DEFAULT)
        return g_clrBtnText;
    else
        return prb->clrText;
}

__inline COLORREF RBB_GetBkColor(PRB prb, PRBB prbb)
{
    switch(prbb->clrBack)
    {
    case CLR_NONE:
        // CLR_NONE means "use our dad's color"
        return RB_GetBkColor(prb);

    case CLR_DEFAULT:
        return g_clrBtnFace;

    default:
        return prbb->clrBack;
    }
}

__inline COLORREF RBB_GetTextColor(PRB prb, PRBB prbb)
{
    switch (prbb->clrFore)
    {
    case CLR_NONE:
        // CLR_NONE means "use our dad's color"
        return RB_GetTextColor(prb);

    case CLR_DEFAULT:
        return g_clrBtnText;

    default:
        return prbb->clrFore;
    }
}

//
// Our use of CLR_DEFAULT for the band background colors is new for 
// version 5.01.  Since we don't want to confuse apps by returning
// CLR_DEFAULT when they used to see a real colorref, we convert it
// before returning it to them.  If the background color is CLR_NONE, 
// though, we need to return it without conversion (like version 4 did).
// The *_External functions handle these cases.
//
__inline COLORREF RBB_GetTextColor_External(PRB prb, PRBB prbb)
{
    if (prbb->clrFore == CLR_NONE)
        return CLR_NONE;
    else
        return RBB_GetTextColor(prb, prbb);
}

__inline COLORREF RBB_GetBkColor_External(PRB prb, PRBB prbb)
{
    if (prbb->clrBack == CLR_NONE)
        return CLR_NONE;
    else
        return RBB_GetBkColor(prb, prbb);
}


///
//
// Implement MapWindowPoints as if the hwndFrom and hwndTo aren't
// mirrored. This is used when any of the windows (hwndFrom or hwndTo)
// are mirrored. See below. [samera]
//
int TrueMapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lppt, UINT cPoints)
{
    int dx, dy;
    RECT rcFrom={0,0,0,0}, rcTo={0,0,0,0};

    if (hwndFrom) {
        GetClientRect(hwndFrom, &rcFrom);
        MapWindowPoints(hwndFrom, NULL, (LPPOINT)&rcFrom.left, 2);
    }

    if (hwndTo) {
        GetClientRect(hwndTo, &rcTo);
        MapWindowPoints(hwndTo, NULL, (LPPOINT)&rcTo.left, 2);
    }

    dx = rcFrom.left - rcTo.left;
    dy = rcFrom.top  - rcTo.top;

    /*
     * Map the points
     */
    while (cPoints--) {
        lppt->x += dx;
        lppt->y += dy;
        ++lppt;
    }
    
    return MAKELONG(dx, dy);
}

///
//
// Map a rect to parent should be based on the visual right edge
// for calculating the client coordinates for a RTL mirrored windows.
// This routine should only be used when calculating client
// coordinates in a RTL mirrored window. [samera]
//
BOOL MapRectInRTLMirroredWindow( LPRECT lprc, HWND hwnd)
{
    int iWidth  = lprc->right - lprc->left;
    int iHeight = lprc->bottom- lprc->top;
    RECT rc={0,0,0,0};


    if (hwnd) {
        GetClientRect(hwnd, &rc);
        MapWindowPoints(hwnd, NULL, (LPPOINT)&rc.left, 2);
    }

    lprc->left = rc.right - lprc->right;
    lprc->top  = lprc->top-rc.top;

    lprc->bottom = lprc->top + iHeight;
    lprc->right  = lprc->left + iWidth;

    return TRUE;
}

int _RBBandWidth(PRB prb, int x)
{
    if (prb->ci.style & RBS_BANDBORDERS)
        x += g_cxEdge;
    return x;
}

void RBRealize(PRB prb, HDC hdcParam, BOOL fBackground, BOOL fForceRepaint)
{
    if (prb->hpal)
    {
        HDC hdc = hdcParam ? hdcParam : GetDC(prb->ci.hwnd);

        if (hdc)
        {
            BOOL fRepaint;
            
            SelectPalette(hdc, prb->hpal, fBackground);
            fRepaint = RealizePalette(hdc) || fForceRepaint;

            if (!hdcParam)
                ReleaseDC(prb->ci.hwnd, hdc);

            if (fRepaint)
            {
                InvalidateRect(prb->ci.hwnd, NULL, TRUE);
            }
        }
    }
}


//////////////////////////////////////////////////////////////////
// RBSendNotify
//
// sends a wm_notify of code iCode and packages up all the data for you
// for band uBand
//
//////////////////////////////////////////////////////////////////
LRESULT RBSendNotify(PRB prb, UINT uBand, int iCode)
{
    NMREBAR nm = {0};
    
    nm.uBand = uBand;
    if (uBand != (UINT)-1) {
        nm.dwMask = RBNM_ID | RBNM_STYLE | RBNM_LPARAM;

        nm.wID = RBGETBAND(prb, uBand)->wID;
        nm.fStyle = RBGETBAND(prb, uBand)->fStyle;
        nm.lParam = RBGETBAND(prb, uBand)->lParam;
    }
    return CCSendNotify(&prb->ci, iCode, &nm.hdr);
}


BOOL RBInvalidateRect(PRB prb, RECT* prc)
{
    if (prb->fRedraw) 
    {
        RECT rc;

        if (prc && RB_ISVERT(prb))
        {
            CopyRect(&rc, prc);
            FlipRect(&rc);
            prc = &rc;
        }

        prb->fRefreshPending = FALSE;
        InvalidateRect(prb->ci.hwnd, prc, TRUE);
        return TRUE;
    }
    else 
    {
        prb->fRefreshPending = TRUE;
        return FALSE;
    }
}

LRESULT RebarDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    PRB prb = (PRB)GetWindowPtr(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            int iBand;
            RBHITTESTINFO rbht;

            rbht.pt.x = ((POINTL *)lp)->x;
            rbht.pt.y = ((POINTL *)lp)->y;

            MapWindowPoints(NULL, prb->ci.hwnd, &rbht.pt, 1);

            iBand = RBHitTest(prb, &rbht);
            *(DWORD*)wp = rbht.flags;
            lres = (LRESULT)(iBand != -1 ? prb->rbbList[iBand].wID : -1);
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&prb->ci, RBN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}

// ----------------------------------------------------------------------------
//
// RBCanBandMove
//
// returns TRUE if the given band can be moved and FALSE if it cannot
//
// ----------------------------------------------------------------------------
BOOL  RBCanBandMove(PRB prb, PRBB prbb)
{
    // If there is only one visible band it cannot move
    if (RBEnumBand(prb, 1, RBBS_HIDDEN) > RB_GETLASTBAND(prb))
        return FALSE;

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
        
    if ((prb->ci.style & RBS_FIXEDORDER)
      && (prbb == RBEnumBand(prb, 0, RBBS_HIDDEN)))
        // the first (visible) band in fixed order rebars can't be moved
        return(FALSE);
    
    // fixed size bands can't be moved
    return(!(prbb->fStyle & RBBS_FIXEDSIZE));
}

// ----------------------------------------------------------------------------
//
// RBBCalcMinWidth
//
// calculates minimum width for the given band
//
// ----------------------------------------------------------------------------
void  RBBCalcMinWidth(PRB prb, PRBB prbb)
{
    BOOL fDrawGripper = RBShouldDrawGripper(prb, prbb);
    BOOL fVertical;
    int  cEdge;
    BOOL fEmpty = ((prbb->iImage == -1) && (!RBSHOWTEXT(prbb)));

    if (prbb->fStyle & RBBS_HIDDEN) {
        ASSERT(0);
        return;
    }

    // did the user specify the size explicitly?
    if (prbb->fStyle & RBBS_FIXEDHEADERSIZE)
        return;

    prbb->cxMin = prbb->cxMinChild;

    if (RBBUSECHEVRON(prb, prbb))
        prbb->cxMin += CX_CHEVRON;

    if (!fDrawGripper && fEmpty)
        return;

    fVertical = (prb->ci.style & CCS_VERT);
    if (RB_ISVERTICALGRIPPER(prb)) {
        
        prbb->cxMin += 4 * g_cyEdge;
        prbb->cxMin += max(prb->cyImage, prb->cyFont);
        
    } else {
        cEdge = fVertical ? g_cyEdge : g_cxEdge;

        prbb->cxMin += 2 * cEdge;

        if (fDrawGripper)
        {
            prbb->cxMin += RB_GRABWIDTH * (fVertical ? g_cyBorder : g_cxBorder);
            if (fEmpty)
                return;
        }

        prbb->cxMin += 2 * cEdge;

        if (prbb->iImage != -1)
            prbb->cxMin += (fVertical ? prb->cyImage : prb->cxImage);

        if (RBSHOWTEXT(prbb))
        {
            if (fVertical)
                prbb->cxMin += prb->cyFont;
            else
                prbb->cxMin += prbb->cxText;
            if (prbb->iImage != -1)
                // has both image and text -- add in edge between 'em
                prbb->cxMin += cEdge;
        }
    }
}

BOOL RBShouldDrawGripper(PRB prb, PRBB prbb)
{
    if (prbb->fStyle & RBBS_NOGRIPPER)
        return FALSE;

    if ((prbb->fStyle & RBBS_GRIPPERALWAYS) || RBCanBandMove(prb, prbb))
        return TRUE;
    
    return FALSE;
        
}

// ----------------------------------------------------------------------------
//
// RBBCalcTextExtent
//
// computes the horizontal extent of the given band's title text in the current
// title font for the rebar
//
// returns TRUE if text extent changed, FALSE otherwise
//
// ----------------------------------------------------------------------------
BOOL  RBBCalcTextExtent(PRB prb, PRBB prbb, HDC hdcIn)
{
    HDC     hdc = hdcIn;
    HFONT   hFontOld;
    UINT    cx;

    if (prbb->fStyle & RBBS_HIDDEN)
    {
        ASSERT(0);      // caller should have skipped
        return FALSE;
    }

    if (!RBSHOWTEXT(prbb))
    {
        cx = 0;
    }
    else
    {
        if (!hdcIn && !(hdc = GetDC(prb->ci.hwnd)))
            return FALSE;

        hFontOld = SelectObject(hdc, prb->hFont);

        // for clients >= v5, we draw text with prefix processing (& underlines next char)
        if (prb->ci.iVersion >= 5)
        {
            RECT rc = {0,0,0,0};
            DrawText(hdc, prbb->lpText, lstrlen(prbb->lpText), &rc, DT_CALCRECT);
            cx = RECTWIDTH(rc);
        }
        else
        {
            SIZE size;
            GetTextExtentPoint(hdc, prbb->lpText, lstrlen(prbb->lpText), &size);
            cx = size.cx;
        }
        SelectObject(hdc, hFontOld);

        if (!hdcIn)
            ReleaseDC(prb->ci.hwnd, hdc);
    }

    if (prbb->cxText != cx)
    {
        prbb->cxText = cx;
        RBBCalcMinWidth(prb, prbb);

        return TRUE;
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
// RBBGetHeight
//
// returns minimum height for the given band
// TODO: make this a field in the band structure instead of always calling this
//
// ----------------------------------------------------------------------------
UINT  RBBGetHeight(PRB prb, PRBB prbb)
{
    UINT cy = 0;
    BOOL fVertical = (prb->ci.style & CCS_VERT);
    UINT cyCheck, cyBorder;

    cyBorder = (fVertical ? g_cxEdge : g_cyEdge) * 2;

    if (prbb->hwndChild)
    {
        cy = prbb->cyChild;
        if (!(prbb->fStyle & RBBS_CHILDEDGE))
            // add edge to top and bottom of child window
            cy -= cyBorder;
    }

    if (RBSHOWTEXT(prbb) && !fVertical)
    {
        cyCheck = prb->cyFont;

        if (cyCheck > cy)
            cy = cyCheck;
    }

    if (prbb->iImage != -1)
    {
        cyCheck = (fVertical) ? prb->cxImage : prb->cyImage;

        if (cyCheck > cy)
            cy = cyCheck;
    }

    return(cy + cyBorder);
}

// ----------------------------------------------------------------------------
//
// RBGetRowCount
//
// returns the number of rows in the rebar's current configuration
//
// ----------------------------------------------------------------------------
UINT  RBGetRowCount(PRB prb)
{
    UINT i;
    UINT cRows = 0;

    for (i = 0; i < prb->cBands; i++) {
        if (RBGETBAND(prb, i)->fStyle & RBBS_HIDDEN)
            continue;

        if (RBISSTARTOFROW(prb, i))
            cRows++;
    }

    return(cRows);
}

// ----------------------------------------------------------------------------
//
// RBGetLineHeight
//
// returns the height of the line of bands from iStart to iEnd, inclusively
//
// ----------------------------------------------------------------------------
UINT  RBGetLineHeight(PRB prb, UINT iStart, UINT iEnd)
{
    UINT cy = 0;
    PRBB prbb;
    UINT cyBand;

    if (!(prb->ci.style & RBS_VARHEIGHT))
    {
        // for fixed height bars, line height is maximum height of ALL bands
        iStart = 0;
        iEnd = prb->cBands - 1;
    }

    for (prbb = prb->rbbList + iStart; iStart <= iEnd; prbb++, iStart++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;

        cyBand = RBBGetHeight(prb, prbb);
        cy = max(cy, cyBand);
    }

    return(cy);
}

// RBRecalcChevron: update & refresh chevron
void RBRecalcChevron(PRB prb, PRBB prbb, BOOL fChevron)
{
    RECT rcChevron;

    if (fChevron)
    {
        rcChevron.right = prbb->x + prbb->cx;
        rcChevron.left = rcChevron.right - CX_CHEVRON;
        rcChevron.top = prbb->y;
        rcChevron.bottom = rcChevron.top + prbb->cy;
    }
    else
        SetRect(&rcChevron, -1, -1, -1, -1);

    if (!EqualRect(&rcChevron, &prbb->rcChevron))
    {
        if (prbb->fChevron)
            RBInvalidateRect(prb, &prbb->rcChevron);

        prbb->fChevron = fChevron;
        CopyRect(&prbb->rcChevron, &rcChevron);

        if (prbb->fChevron)
            RBInvalidateRect(prb, &prbb->rcChevron);
    }
}

// ----------------------------------------------------------------------------
//
// RBResizeChildren
//
// resizes children to fit properly in their respective bands' bounding rects
//
// ----------------------------------------------------------------------------
void  RBResizeChildren(PRB prb)
{
    int     cx, cy, x, y, cxHeading;
    HDWP    hdwp;
    BOOL    fVertical = (prb->ci.style & CCS_VERT);
    PRBB prbb, prbbEnd;

    if (!prb->cBands || !prb->fRedraw)
        return;

    hdwp = BeginDeferWindowPos(prb->cBands);

    prbb = RBGETBAND(prb, 0);
    prbbEnd = RB_GETLASTBAND(prb);

    for ( ; prbb <= prbbEnd ; prbb++)
    {
        NMREBARCHILDSIZE nm;
        BOOL fChevron = FALSE;

        if (prbb->fStyle & RBBS_HIDDEN)
            continue;
        
        if (!prbb->hwndChild)
            continue;

        cxHeading = RBBHEADERWIDTH(prbb);
        x = prbb->x + cxHeading;

        cx = prbb->cx - cxHeading;

        // if we're not giving child ideal size, make space for chevron button
        if ((cx < prbb->cxIdeal) && RBBUSECHEVRON(prb, prbb))
        {
            fChevron = TRUE;
            cx -= CX_CHEVRON;
        }

        if (!(prbb->fStyle & RBBS_FIXEDSIZE)) {
            if (fVertical) {
                PRBB prbbNext = RBBNextVisible(prb, prbb);
                if (prbbNext && !RBISBANDSTARTOFROW(prbbNext))
                    cx -= g_cyEdge * 2;
            } else 
                cx -= CX_OFFSET;
        }

        if (cx < 0)
            cx = 0;
        y = prbb->y;
        cy = prbb->cy;
        if (prbb->cyChild && (prbb->cyChild < (UINT) cy))
        {
            y += (cy - prbb->cyChild) / 2;
            cy = prbb->cyChild;
        }

        nm.rcChild.left = x;
        nm.rcChild.top = y;
        nm.rcChild.right = x + cx;
        nm.rcChild.bottom = y + cy;
        nm.rcBand.left = prbb->x + RBBHEADERWIDTH(prbb);
        nm.rcBand.right = prbb->x + prbb->cx;
        nm.rcBand.top = prbb->y;
        nm.rcBand.bottom = prbb->y + prbb->cy;

        nm.uBand = RBBANDTOINDEX(prb, prbb);
        nm.wID = prbb->wID;
        if (fVertical) {
            FlipRect(&nm.rcChild);
            FlipRect(&nm.rcBand);
        }
        
        CCSendNotify(&prb->ci, RBN_CHILDSIZE, &nm.hdr);

        if (!RB_ISVALIDBAND(prb, prbb)) {
            // somebody responded to notify by nuking bands; bail
            break;
        }

        RBRecalcChevron(prb, prbb, fChevron);

        DeferWindowPos(hdwp, prbb->hwndChild, NULL, nm.rcChild.left, nm.rcChild.top, 
                       RECTWIDTH(nm.rcChild), RECTHEIGHT(nm.rcChild), SWP_NOZORDER);
    }

    EndDeferWindowPos(hdwp);

    //
    //  The SQL 7.0 Enterprise Manager Data Transformation Services MMC Snap-In
    //  (and the Visual Basic Coolbar Sample App, too) has problems.
    //  It hosts a rebar but doesn't set the WS_CLIPCHILDREN flag,
    //  so when it erases its background, it wipes out the rebar.  So don't
    //  call UpdateWindow() here, or we will paint *first*, then SQL will
    //  erase us by mistake.  We have to leave our paint pending, so that
    //  when SQL erases us by mistake, we will eventually get a WM_PAINT
    //  message afterwards.
    //
#if 0
    UpdateWindow(prb->ci.hwnd);
#endif
}

// ----------------------------------------------------------------------------
//
// RBMoveBand
//
// moves the band from one position to another in the rebar's band array,
// updating the rebar's iCapture field as needed
//
// returns TRUE or FALSE if something moved
// ----------------------------------------------------------------------------
BOOL  RBMoveBand(PRB prb, UINT iFrom, UINT iTo)
{
    RBB rbbMove;
    int iShift;
    BOOL fCaptureChanged = (prb->iCapture == -1);

    if (iFrom != iTo)
    {
        rbbMove = *RBGETBAND(prb, iFrom);
        if (prb->iCapture == (int) iFrom)
        {
            prb->iCapture = (int) iTo;
            fCaptureChanged = TRUE;
        }

        iShift = (iFrom > iTo) ? -1 : 1;

        while (iFrom != iTo)
        {
            if (!fCaptureChanged && (prb->iCapture == (int) (iFrom + iShift)))
            {
                prb->iCapture = (int) iFrom;
                fCaptureChanged = TRUE;
            }

            *RBGETBAND(prb, iFrom) = *RBGETBAND(prb, iFrom + iShift);
            iFrom += iShift;
        }
        *RBGETBAND(prb, iTo) = rbbMove;
        return TRUE;
    }
    return(FALSE);
}

// ----------------------------------------------------------------------------
//
// RBRecalc
//
// recomputes bounding rects for all bands in given rebar
//
// ----------------------------------------------------------------------------
UINT  RBRecalc(PRB prb)
{
    PRBB    prbb = RBGETBAND(prb, 0);
    PRBB    prbbWalk;
    UINT    cHidden;    // # of hidden guys we've seen in current row
    UINT    cxRow;
    UINT    cxMin;
    UINT    i;
    UINT    j;
    UINT    k;
    UINT    iFixed = 0xFFFF;
    int     cy;
    int     y;
    int     x;
    UINT    cxBar;
    RECT    rc;
    HWND    hwndSize;
    BOOL    fNewLine = FALSE;
    BOOL    fChanged;
    BOOL    fVertical = (prb->ci.style & CCS_VERT);
    BOOL    fBandBorders;
    int     iBarWidth;

    if (!prb->cBands)
        return(0);

    if ((prb->ci.style & CCS_NORESIZE) || (prb->ci.style & CCS_NOPARENTALIGN))
        // size based on rebar window itself
        hwndSize = prb->ci.hwnd;
    else if (!(hwndSize = prb->ci.hwndParent))
        // size based on parent window -- if no parent window, bail now
        return(0);

    if (!prb->fRecalc) {
        // defer this recalc
        prb->fRecalcPending = TRUE;
        return 0;
    } else {
        prb->fRecalcPending = FALSE;
    }

    GetClientRect(hwndSize, &rc);

    iBarWidth = (fVertical ? (rc.bottom - rc.top) : (rc.right - rc.left));
    // this can happen because we adjust the client rect, but wedon't change 
    // the getminmaxinfo.
    if (iBarWidth <= 0)
        iBarWidth = 1;

    cxBar = (UINT) iBarWidth;    

    fBandBorders = (prb->ci.style & RBS_BANDBORDERS);

    for (i = 0; i < prb->cBands; i++) {
        prb->rbbList[i].cx = prb->rbbList[i].cxRequest;
    }

    y = 0;
    i = 0;
    // Main Loop -- loop until all bands are calculated
    while (i < prb->cBands)
    {
        TraceMsg(TF_REBAR, "RBRecalc: outer loop i=%d", i);
        
        if (fBandBorders && (y > 0))
            y += g_cyEdge;

ReLoop:
        cxRow = 0;
        cxMin = 0;

        x = 0;
        cHidden = 0;

        // Row Loop -- loop until hard line break is found or soft line break
        // is necessary
        for (j = i, prbbWalk = prbb; j < prb->cBands; j++, prbbWalk++)
        {
            TraceMsg(TF_REBAR, "RBRecalc: inner loop j=%d", j);
            
            if (prbbWalk->fStyle & RBBS_HIDDEN) {
                ++cHidden;
                continue;
            }

            if (j > i + cHidden)
            {
                // not the first band in the row -- check for break style
                if ((prbbWalk->fStyle & RBBS_BREAK) && !(prbbWalk->fStyle & RBBS_FIXEDSIZE))
                    break;

                if (fBandBorders)
                    // add in space for vertical etch on palettized display
                    cxMin += g_cxEdge;
            }

            if (prbbWalk->fStyle & RBBS_FIXEDSIZE)
            {
                // remember location of branding brick
                iFixed = j;
             
                // if this is the first band, the next band cannot have a forced break.
                if (i + cHidden == j) {
                    // if the first index in the row (i) plus the number of hidden items (cHidden) leaves us at this band,
                    // then it's the first visible in this row.
                    PRBB prbbNextVis = RBBNextVisible(prb, prbbWalk);
                    if (prbbNextVis && (prbbNextVis->fStyle & RBBS_BREAK)) {
                        // can't do this unilaterally because on startup
                        // some folks (net meeting) initialize it in reverse order
                        // and we whack off this break bit incorrectly
                        if (prb->fRedraw && IsWindowVisible(prb->ci.hwnd))
                            prbbNextVis->fStyle &= ~RBBS_BREAK;
                    }
                }
                
                prbbWalk->cx = prbbWalk->cxMin;
            }

            if (prbbWalk->cx < prbbWalk->cxMin)
                prbbWalk->cx = prbbWalk->cxMin;

            cxMin += prbbWalk->cxMin; // update running total of min widths

            // read the assert comment below
            if (j > i + cHidden)
            {
                // not the first band in row -- check for need to autobreak
                if (cxMin > cxBar)
                    // autobreak here
                    break;


                if (fBandBorders)
                    // add in space for vertical etch on palettized display
                    cxRow += g_cxEdge;
            }

            cxRow += prbbWalk->cx; // update running total of current widths
        }

        if (!i)
        {
            // first row -- handle proper placement of branding band
            if (iFixed == 0xFFFF)
            {
                // branding band not yet found; look in the remaining bands
                k = j;
                for ( ; j < prb->cBands; j++)
                {
                    if (RBGETBAND(prb, j)->fStyle & RBBS_HIDDEN)
                        continue;

                    if (RBGETBAND(prb, j)->fStyle & RBBS_FIXEDSIZE)
                    {
                        // branding band found; move to 1st row and recompute
                        ASSERT(j != k);                        
                        RBMoveBand(prb, j, k);
                        goto ReLoop;
                    }
                }
                // no branding band found -- reset j and continue on
                j = k;
            }
            else
                // we have a branding band; move it to
                // the rightmost position in the row
                RBMoveBand(prb, iFixed, j - 1);

            TraceMsg(TF_REBAR, "RBRecalc: after brand i=%d", i);            
        }

        // variant:
        // now the current row of bands is from i to j - 1
        // n.b. i (and some following bands) might be hidden

        // assert that j != i because then the above variant won't be true
        ASSERT(j != i);     // BUGBUG RBBS_HIDDEN?

        if (cxRow > cxBar)
        {
            // bands are too long -- shrink bands from right to left
            for (k = i; k < j; k++)
            {
                prbbWalk--;
                if (prbbWalk->fStyle & RBBS_HIDDEN)
                    continue;

                if (prbbWalk->cx > prbbWalk->cxMin)
                {
                    cxRow -= prbbWalk->cx - prbbWalk->cxMin;
                    prbbWalk->cx = prbbWalk->cxMin;
                    if (cxRow <= cxBar)
                    {
                        prbbWalk->cx += cxBar - cxRow;
                        break;
                    }
                }
            }
            TraceMsg(TF_REBAR, "RBRecalc: after shrink i=%d", i);            
        }
        else if (cxRow < cxBar)
        {
            // bands are too short -- grow rightmost non-minimized band
            for (k = j - 1; k >= i; k--)
            {
                ASSERT(k != (UINT)-1);  // catch infinite loop
                prbbWalk--;
                if ((k == i) || 
                    (!(prbbWalk->fStyle & (RBBS_HIDDEN | RBBS_FIXEDSIZE)) &&
                     (prbbWalk->cx > prbb->cxMin)))
                {
                    // the k == i check  means we've made it to the first
                    // band on this row and so he has to get the cx change
                    if (prbbWalk->fStyle & RBBS_HIDDEN) 
                    {
                        ASSERT(k == i);
                        prbbWalk = RBBNextVisible(prb, prbbWalk);
                        if (!prbbWalk)
                            break;
                    }
                    prbbWalk->cx += cxBar - cxRow;
                    break;
                }
            }
            TraceMsg(TF_REBAR, "RBRecalc: after grow i=%d", i);            
        }

        // items from index i to index j-1 (inclusive) WILL fit on one line
        cy = RBGetLineHeight(prb, i, j - 1);

        fChanged = FALSE; // set if any bands on current row changed position

        for ( ; i < j; i++, prbb++)
        {
            if (prbb->fStyle & RBBS_HIDDEN)
                continue;

            // go through row of bands, updating positions and heights,
            // invalidating as needed
            if ((prbb->y != y) || (prbb->x != x) || (prbb->cy != cy))
            {
                TraceMsg(TF_REBAR, "RBRecalc: invalidate i=%d", RBBANDTOINDEX(prb, prbb));
                fChanged = TRUE;
                rc.left = min(prbb->x, x);
                rc.top = min(prbb->y, y);
                rc.right = cxBar;
                rc.bottom = max(prbb->y + prbb->cy, y + cy);
                if (fBandBorders)
                {
                    // acount for etch line that will need to move
                    rc.left -= g_cxEdge;
                    rc.bottom += g_cyEdge/2;
                }
                RBInvalidateRect(prb, &rc);
            }

            prbb->x = x;
            prbb->y = y;
            prbb->cy = cy;

            x += RBBANDWIDTH(prb, prbb);
        }

        // i and prbb now refer to the first band in the next row of bands
        y += cy;
    }

    prb->cy = y;
    return(y);
}

// ----------------------------------------------------------------------------
//
// RBResize
//
// recomputes bounding rects for all bands and then resizes rebar and children
// based on these rects
//
// ----------------------------------------------------------------------------
void  RBResizeNow(PRB prb)
{
    RECT rc;
    BOOL bMirroredWnd=(prb->ci.dwExStyle&RTL_MIRRORED_WINDOW);

    if (!prb || !prb->ci.hwndParent)
        return;

    GetWindowRect(prb->ci.hwnd, &rc);

    //
    // If this is a mirrored window, we don't won't to refect the
    // coordinates since they are coming from the screen coord
    // which they are not mirrored. [samera]
    //
    if (bMirroredWnd)
        MapRectInRTLMirroredWindow(&rc, prb->ci.hwndParent);
    else 
        MapWindowPoints(HWND_DESKTOP, prb->ci.hwndParent, (LPPOINT)&rc, 2);

    RBResizeChildren(prb);

    NewSize(prb->ci.hwnd, prb->cy, prb->ci.style, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc));

    if (prb->fResizeNotify) 
        CCSendNotify(&prb->ci, RBN_HEIGHTCHANGE, NULL);
    prb->fResizeNotify = FALSE;
    prb->fResizePending = FALSE;
}

void  RBResize(PRB prb, BOOL fForceHeightChange)
{
    UINT cy;

StartOver:
    // lots of the code relies on having cy calculated synchronously with RBResize,
    // but we're going to delay the actual changing of the window
    cy = prb->cy;
    if (prb->fResizing)
    {
        prb->fResizeRecursed = TRUE;
        return;
    }
    prb->fResizing = TRUE;
    
    RBRecalc(prb);    

   // true overrides always
    if (fForceHeightChange || (cy != prb->cy))
        prb->fResizeNotify = TRUE;

    if (prb->fRedraw) {
        RBResizeNow(prb);
    } else 
        prb->fResizePending = TRUE;
        
    prb->fResizing = FALSE;
    
    // we do this to avoid infinite loop...  RBResize can cause NewSize which causes 
    // a notify in which the parent sizes us, which causes us to loop.
    // if the parent does any message pumping during the NewSize, we're in a loop 
    if (prb->fResizeRecursed) {
        prb->fResizeRecursed = FALSE;
        fForceHeightChange = FALSE;
        goto StartOver;
    }     
}

void RBSetRecalc(PRB prb, BOOL fRecalc)
{
    prb->fRecalc = fRecalc;
    if (fRecalc) {
        if (prb->fRecalcPending)
            RBRecalc(prb);
    }
}

BOOL RBSetRedraw(PRB prb, BOOL fRedraw)
{
    BOOL fOld = prb->fRedraw;
    if (prb) {
        prb->fRedraw = BOOLIFY(fRedraw);
        if (fRedraw) {
            // save off prb->fRefreshPending since this can
            // get changed by call to RBResizeNow
            BOOL fRefreshPending = prb->fRefreshPending;

            if (prb->fResizePending)
                RBResizeNow(prb);

            if (fRefreshPending)
                RBInvalidateRect(prb, NULL);
        }
    }
    
    return fOld;
}

BOOL RBAfterSetFont(PRB prb)
{
    TEXTMETRIC tm;
    BOOL fChange = FALSE;
    UINT        i;
    HFONT hOldFont;
    
    HDC hdc = GetDC(prb->ci.hwnd);
    if (!hdc)
        return FALSE;

    hOldFont = SelectObject(hdc, prb->hFont);
    GetTextMetrics(hdc, &tm);

    if (prb->cyFont != (UINT) tm.tmHeight)
    {
        prb->cyFont = tm.tmHeight;
        fChange = TRUE;
    }

    // adjust bands
    for (i = 0; i < prb->cBands; i++)
    {
        if (RBGETBAND(prb, i)->fStyle & RBBS_HIDDEN)
            continue;

        fChange |= RBBCalcTextExtent(prb, RBGETBAND(prb, i), hdc);
    }

    SelectObject(hdc, hOldFont);
    ReleaseDC(prb->ci.hwnd, hdc);

    if (fChange)
    {
        RBResize(prb, FALSE);
        // invalidate, o.w. title doesn't redraw 1st time after font growth
        RBInvalidateRect(prb, NULL);
    }

    return TRUE;
}

BOOL RBOnSetFont(PRB prb, HFONT hFont)
{
    if (prb->fFontCreated) {
        DeleteObject(prb->hFont);
    }
    
    prb->hFont = hFont;
    prb->fFontCreated = FALSE;
    if (!prb->hFont)
        RBSetFont(prb, 0);
    else 
        return RBAfterSetFont(prb);
    
    return TRUE;
}

// ----------------------------------------------------------------------------
//
// RBSetFont
//
// sets the rebar band title font to the current system-wide caption font
//
// ----------------------------------------------------------------------------
BOOL  RBSetFont(PRB prb, WPARAM wParam)
{
    NONCLIENTMETRICS ncm;
    HFONT hOldFont;

    if ((wParam != 0) && (wParam != SPI_SETNONCLIENTMETRICS))
        return(FALSE);

    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, ncm.cbSize, &ncm, 0))
        return(FALSE);

    hOldFont = prb->hFont;

    ncm.lfCaptionFont.lfWeight = FW_NORMAL;
    if (!(prb->hFont = CreateFontIndirect(&ncm.lfCaptionFont)))
    {
        prb->hFont = hOldFont;
        return(FALSE);
    }

    prb->fFontCreated = TRUE;
    if (hOldFont)
        DeleteObject(hOldFont);
    
    return RBAfterSetFont(prb);
}

// ----------------------------------------------------------------------------
//
//  Draws a horizontal or vertical dotted line from the given (x,y) location
//  for the given length (c). (From TReeView's TV_DrawDottedLine)
//
// ----------------------------------------------------------------------------

void RBVertMungeGripperRect(PRB prb, LPRECT lprc)
{
    if (RB_ISVERTICALGRIPPER(prb)) {
        OffsetRect(lprc, -lprc->left + lprc->top, -lprc->top + lprc->left);
        lprc->bottom -= g_cyEdge;
    } else {
        FlipRect(lprc);
    }
}

void RBDrawChevron(PRB prb, PRBB prbb, HDC hdc)
{
    RECT rc;
    DWORD dwFlags = prbb->wChevState | DCHF_HORIZONTAL | DCHF_TRANSPARENT;

    CopyRect(&rc, &prbb->rcChevron);
    if (RB_ISVERT(prb))
        FlipRect(&rc);
    else
        dwFlags |= DCHF_TOPALIGN;

    DrawChevron(hdc, &rc, dwFlags);
}

void RBUpdateChevronState(PRB prb, PRBB prbb, WORD wControlState)
{
    if (!prb || !prbb)
        return;

    // if no change in state, bail
    if (!(wControlState ^ prbb->wChevState))
        return;

    prbb->wChevState = wControlState;

    // if active (pushed or hottracked)
    if (!(wControlState & DCHF_INACTIVE)) {
        // then we're now the hot band
        prb->prbbHot = prbb;
    }
    // else if we were the hot band then clear
    else if (prbb == prb->prbbHot) {
        prb->prbbHot = NULL;
    }

    // clear background & repaint
    RBInvalidateRect(prb, &prbb->rcChevron);
    UpdateWindow(prb->ci.hwnd);
}

// ----------------------------------------------------------------------------
//
// RBDrawBand
//
// draws the title icon and title text of the given band into the given DC;
// also the band's chevron
//
// ----------------------------------------------------------------------------
void  RBDrawBand(PRB prb, PRBB prbb, HDC hdc)
{
    int                 xStart, yCenter;
    COLORREF            clrBackSave, clrForeSave;
    int                 iModeSave;
    BOOL                fVertical = RB_ISVERT(prb);
    BOOL                fDrawHorizontal = (!fVertical || RB_ISVERTICALGRIPPER(prb));
    NMCUSTOMDRAW        nmcd;
    LRESULT             dwRet;

    if (prbb->fStyle & RBBS_HIDDEN) {
        ASSERT(0);
        return;
    }

    clrForeSave = SetTextColor(hdc, RBB_GetTextColor(prb, prbb));
    clrBackSave = SetBkColor(hdc, RBB_GetBkColor(prb, prbb));
    if (prbb->hbmBack)
        iModeSave = SetBkMode(hdc, TRANSPARENT);

    nmcd.hdc = hdc;
    nmcd.dwItemSpec = prbb->wID;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = prbb->lParam;
    nmcd.rc.top = prbb->y;
    nmcd.rc.left = prbb->x;
    nmcd.rc.bottom = nmcd.rc.top + prbb->cy;
    nmcd.rc.right = nmcd.rc.left + RBBHEADERWIDTH(prbb);
    if (prb->ci.style & CCS_VERT)
    {
        FlipRect(&nmcd.rc);
    }
#ifdef KEYBOARDCUES
#if 0
    // BUGBUG: Custom draw stuff for UISTATE (stephstm)
    if (CCGetUIState(&(prb->ci), KC_TBD))
        nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
#endif
#endif
    dwRet = CICustomDrawNotify(&prb->ci, CDDS_ITEMPREPAINT, &nmcd);

    if (!(dwRet & CDRF_SKIPDEFAULT))
    {
        int cy;
        
        if (RB_ISVERTICALGRIPPER(prb)) {
            cy = RBBHEADERWIDTH(prbb);
            yCenter = prbb->x + (cy / 2);
        } else {
            cy = prbb->cy;
            yCenter = prbb->y + (cy / 2);
        }

        xStart = prbb->x;
        if (RBShouldDrawGripper(prb, prbb))
        {
            RECT rc;
            int  c;
            int dy;

            c = 3 * g_cyBorder;
            xStart += 2 * g_cxBorder;
            dy = g_cxEdge;

            SetRect(&rc, xStart, prbb->y + dy, xStart + c, prbb->y + cy - dy);

            if (fVertical)
            {
                RBVertMungeGripperRect(prb, &rc);
                if (RB_ISVERTICALGRIPPER(prb))
                    xStart = rc.left;
            }

            CCDrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_RECT | BF_MIDDLE, &(prb->clrsc));

            xStart += c;
        }

        xStart += 2 * (fVertical ? g_cyEdge : g_cxEdge);


        if (prbb->iImage != -1)
        { 
            UINT                yStart;
            IMAGELISTDRAWPARAMS imldp = {0};

            yStart = yCenter - ((!fDrawHorizontal ? prb->cxImage : prb->cyImage) / 2);
            imldp.cbSize = sizeof(imldp);
            imldp.himl   = prb->himl;
            imldp.i      = prbb->iImage;
            imldp.hdcDst = hdc;
            imldp.x      = (!fDrawHorizontal ? yStart : xStart);
            imldp.y      = (!fDrawHorizontal ? xStart : yStart);
            imldp.rgbBk  = CLR_DEFAULT;
            imldp.rgbFg  = CLR_DEFAULT;
            imldp.fStyle = ILD_TRANSPARENT;

            ImageList_DrawIndirect(&imldp);
            xStart +=  (fDrawHorizontal ? (prb->cxImage + g_cxEdge) : (prb->cyImage + g_cyEdge));
        }

        if (RBSHOWTEXT(prbb))
        {
            HFONT hFontSave = SelectObject(hdc, prb->hFont);
            RECT rcText;
            
            rcText.left = fDrawHorizontal ? xStart : yCenter - (prbb->cxText / 2);
            rcText.top = fDrawHorizontal ? yCenter - (prb->cyFont / 2) : xStart;
            if (fDrawHorizontal)
                rcText.top -= 1;    // fudge
            rcText.right = rcText.left + prbb->cxText;
            rcText.bottom = rcText.top + prb->cyFont;

            // for clients >= v5, we draw text with prefix processing (& underlines next char)
            if (prb->ci.iVersion >= 5)
            {
                UINT uFormat=0;
#ifdef KEYBOARDCUES
                if (CCGetUIState(&(prb->ci)) & UISF_HIDEACCEL)
                   uFormat= DT_HIDEPREFIX;
#endif
                DrawText(hdc, prbb->lpText, lstrlen(prbb->lpText), &rcText, uFormat);
            }
            else
                TextOut(hdc, rcText.left, rcText.top, prbb->lpText, lstrlen(prbb->lpText));

            SelectObject(hdc, hFontSave);
        }

        // maybe draw chevron
        if (RBBUSECHEVRON(prb, prbb) && prbb->fChevron)
            RBDrawChevron(prb, prbb, hdc);
    }

    if (dwRet & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&prb->ci, CDDS_ITEMPOSTPAINT, &nmcd);

    if (prbb->hbmBack)
        SetBkMode(hdc, iModeSave);
    SetTextColor(hdc, clrForeSave);
    SetBkColor(hdc, clrBackSave);

}

// ----------------------------------------------------------------------------
//
// RBPaint
//
// processes WM_PAINT message
//
// ----------------------------------------------------------------------------
void  RBPaint(PRB prb, HDC hdcIn)
{
    HDC         hdc = hdcIn;
    PAINTSTRUCT ps;
    UINT        i;
    NMCUSTOMDRAW    nmcd;

    if (!hdcIn)
        hdc = BeginPaint(prb->ci.hwnd, &ps);
    else
        GetClientRect(prb->ci.hwnd, &ps.rcPaint);

    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = ps.rcPaint;
    prb->ci.dwCustom = CICustomDrawNotify(&prb->ci, CDDS_PREPAINT, &nmcd);

    if (!(prb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        for (i = 0; i < prb->cBands; i++) {
            if (RBGETBAND(prb, i)->fStyle & RBBS_HIDDEN)
                continue;

            RBDrawBand(prb, RBGETBAND(prb, i), hdc);
        }
    }

    if (prb->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&prb->ci, CDDS_POSTPAINT, &nmcd);

    if (!hdcIn)
        EndPaint(prb->ci.hwnd, &ps);
}

// ----------------------------------------------------------------------------
//
// RBTileBlt
//
// Fills the given rectangle with the rebar's background bitmap, tiling if
// necessary
//
// ----------------------------------------------------------------------------
void  RBTileBlt(PRB prb, PRBB prbb, UINT x, UINT y, UINT cx, UINT cy, HDC hdcDst, HDC hdcSrc)
{
    UINT xOff = 0;
    UINT yOff = 0;
    BOOL fxTile, fyTile;
    int cxPart, cyPart;
    int iPixelOffset = 0;

#ifndef WINNT
    // On Win98 BiDi, Bitblt has off-by-one bug in mirroring
    if(IS_DC_RTL_MIRRORED(hdcSrc))
    {
        iPixelOffset = 1;
    }
#endif // WINNT
    if (!(prbb->fStyle & RBBS_FIXEDBMP))
    {
        if (prb->ci.style & CCS_VERT)
        {
            xOff = -prbb->y;
            yOff = -prbb->x;
        }
        else
        {
            xOff = -prbb->x;
            yOff = -prbb->y;
        }
    }

    xOff += x;
    if (xOff >= prbb->cxBmp)
        xOff %= prbb->cxBmp;

    yOff += y;
    if (yOff >= prbb->cyBmp)
        yOff %= prbb->cyBmp;

ReCheck:
    fxTile = ((xOff + cx) > prbb->cxBmp);
    fyTile = ((yOff + cy) > prbb->cyBmp);

    if (!fxTile && !fyTile)
    {
        // no tiling needed -- blt and leave
        BitBlt(hdcDst, x , y, cx, cy, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        return;
    }

    if (!fxTile)
    {
        // vertically tile
        cyPart = prbb->cyBmp - yOff;
        BitBlt(hdcDst, x, y, cx, cyPart, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        y += cyPart;
        cy -= cyPart;
        yOff = 0;
        goto ReCheck;
    }

    if (!fyTile)
    {
        // horizontally tile
        cxPart = prbb->cxBmp - xOff;
        BitBlt(hdcDst, x, y, cxPart, cy, hdcSrc, xOff + iPixelOffset, yOff, SRCCOPY);
        x += cxPart;
        cx -= cxPart;
        xOff = 0;
        goto ReCheck;
    }

    // tile both ways
    cyPart = prbb->cyBmp - yOff;
    RBTileBlt(prb, prbb, x, y, cx, cyPart, hdcDst, hdcSrc);
    y += cyPart;
    cy -= cyPart;
    yOff = 0;
    goto ReCheck;
}

// this is using virtual coordinate space (internal always horizontal)
int _RBHitTest(PRB prb, LPRBHITTESTINFO prbht, int x, int y)
{
    BOOL fVert = (prb->ci.style & CCS_VERT);
    int i;
    PRBB prbb = RBGETBAND(prb, 0);
    int  cx;
    RBHITTESTINFO rbht;
    
    if (!prbht)
        prbht = &rbht;

    for (i = 0; i < (int) prb->cBands; i++, prbb++)
    {
        if (prbb->fStyle & RBBS_HIDDEN)
            continue;

        if ((x >= prbb->x) && (y >= prbb->y) &&
            (x <= (prbb->x + prbb->cx)) && (y <= (prbb->y + prbb->cy)))
        {
            cx = RBBHEADERWIDTH(prbb);
            if (x <= (int) (prbb->x + cx))
            {
                prbht->flags = RBHT_CAPTION;
                
                if (RB_ISVERTICALGRIPPER(prb)) {
                    if (y - prbb->y < RB_GRABWIDTH)
                        prbht->flags = RBHT_GRABBER;
                } else {
                    cx = RB_GRABWIDTH * (fVert ? g_cyBorder : g_cxBorder);
                    if (RBShouldDrawGripper(prb, RBGETBAND(prb, i)) &&
                        (x <= (int) (prbb->x + cx)))
                        prbht->flags = RBHT_GRABBER;
                }
            }
            else
            {
                POINT pt;

                pt.x = x;
                pt.y = y;

                if (RBBUSECHEVRON(prb, prbb) && prbb->fChevron && PtInRect(&prbb->rcChevron, pt))
                    prbht->flags = RBHT_CHEVRON;
                else
                    prbht->flags = RBHT_CLIENT;
            }

            prbht->iBand = i;
            return(i);
            break;
        }
    }

    prbht->flags = RBHT_NOWHERE;
    prbht->iBand = -1;
    return(-1);
}

// ----------------------------------------------------------------------------
//
// RBHitTest
//
// returns the index to the band that the given point lies in, or -1 if outside
// of all bands.  Also, sets flags to indicate which part of the band the
// point lies in.
//
// ----------------------------------------------------------------------------
int RBHitTest(PRB prb, LPRBHITTESTINFO prbht)
{
    BOOL fVert = (prb->ci.style & CCS_VERT);
    POINT pt;

    if (fVert)
    {
        pt.x = prbht->pt.y;
        pt.y = prbht->pt.x;
    }
    else
        pt = prbht->pt;
    
    return _RBHitTest(prb, prbht, pt.x, pt.y);
}


// ----------------------------------------------------------------------------
//
// RBEraseBkgnd
//
// processes WM_ERASEBKGND message by drawing band borders, if necessary, and
// filling in the rebar bands with their background color
//
// ----------------------------------------------------------------------------
BOOL  RBEraseBkgnd(PRB prb, HDC hdc, int iBand)
{
    BOOL fVertical = (prb->ci.style & CCS_VERT);
    NMCUSTOMDRAW    nmcd;
    LRESULT         dwItemRet;
    BOOL            fBandBorders;
    RECT            rcClient;
    HDC             hdcMem = NULL;
    UINT            i;
    PRBB            prbb = RBGETBAND(prb, 0);

    nmcd.hdc = hdc;
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    prb->ci.dwCustom = CICustomDrawNotify(&prb->ci, CDDS_PREERASE, &nmcd);

    if (!(prb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        COLORREF clrBk;

        fBandBorders = (prb->ci.style & RBS_BANDBORDERS);
        GetClientRect(prb->ci.hwnd, &rcClient);

        clrBk = RB_GetBkColor(prb);
        if (clrBk != CLR_NONE) {
            FillRectClr(hdc, &rcClient, clrBk);
        }

        for (i = 0; i < prb->cBands; i++, prbb++)
        {
            if (prbb->fStyle & RBBS_HIDDEN)
                continue;

            if (fVertical)
                SetRect(&nmcd.rc, prbb->y, prbb->x, prbb->y + prbb->cy, prbb->x + prbb->cx);
            else
                SetRect(&nmcd.rc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);

            if (fBandBorders)
            {
                if (prbb->x)
                {
                    // draw etch between bands on same row
                    if (fVertical)
                    {
                        nmcd.rc.right += g_cxEdge / 2;
                        nmcd.rc.top -= g_cyEdge;
                        CCDrawEdge(hdc, &nmcd.rc, EDGE_ETCHED, BF_TOP, &(prb->clrsc));
                        nmcd.rc.right -= g_cxEdge / 2;
                        nmcd.rc.top += g_cyEdge;
                    }
                    else
                    {
                        nmcd.rc.bottom += g_cyEdge / 2;
                        nmcd.rc.left -= g_cxEdge;
                        CCDrawEdge(hdc, &nmcd.rc, EDGE_ETCHED, BF_LEFT, &(prb->clrsc));
                        nmcd.rc.bottom -= g_cyEdge / 2;
                        nmcd.rc.left += g_cxEdge;
                    }
                }
                else
                {
                    // draw etch between rows
                    if (fVertical)
                    {
                        rcClient.right = prbb->y + prbb->cy + g_cxEdge;
                        CCDrawEdge(hdc, &rcClient, EDGE_ETCHED, BF_RIGHT, &(prb->clrsc));
                    }
                    else
                    {
                        rcClient.bottom = prbb->y + prbb->cy + g_cyEdge;
                        CCDrawEdge(hdc, &rcClient, EDGE_ETCHED, BF_BOTTOM, &(prb->clrsc));
                    }
                }
            }

            nmcd.dwItemSpec = prbb->wID;
            nmcd.uItemState = 0;
            dwItemRet = CICustomDrawNotify(&prb->ci, CDDS_ITEMPREERASE, &nmcd);

            if (!(dwItemRet & CDRF_SKIPDEFAULT))
            {
                if (prbb->hbmBack)
                {
                    if (!hdcMem)
                    {
                        if (!(hdcMem = CreateCompatibleDC(hdc)))
                            continue;

                        RBRealize(prb, hdc, TRUE, FALSE);
                    }

                    SelectObject(hdcMem, prbb->hbmBack);

                    RBTileBlt(prb, prbb, nmcd.rc.left, nmcd.rc.top, nmcd.rc.right - nmcd.rc.left,
                            nmcd.rc.bottom - nmcd.rc.top, hdc, hdcMem);
                }
                else
                {
                    // if the color for this band is the same as the 
                    // rebar's default background color, then we
                    // don't need to paint this specially
                    COLORREF clr = RBB_GetBkColor(prb, prbb);
                    if (clr != RB_GetBkColor(prb)) {
                        FillRectClr(hdc, &nmcd.rc, clr);
                    }
                }
            }

            if (dwItemRet & CDRF_NOTIFYPOSTERASE)
                CICustomDrawNotify(&prb->ci, CDDS_ITEMPOSTERASE, &nmcd);
        }

        if (hdcMem)
        {
            DeleteDC(hdcMem);
        }
    }

    if (prb->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
    {
        nmcd.uItemState = 0;
        nmcd.dwItemSpec = 0;
        nmcd.lItemlParam = 0;
        CICustomDrawNotify(&prb->ci, CDDS_POSTERASE, &nmcd);
    }

    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// RBGetBarInfo
//
// retrieves the indicated values from the rebar's internal structure
//
// ----------------------------------------------------------------------------
BOOL  RBGetBarInfo(PRB prb, LPREBARINFO lprbi)
{
    if (!prb || (lprbi->cbSize != sizeof(REBARINFO)))
        return(FALSE);

    if (lprbi->fMask & RBIM_IMAGELIST)
        lprbi->himl = prb->himl;

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
// RBSetBarInfo
//
// sets the indicated values in the rebar's internal structure, recalculating
// and refreshing as needed
//
// ----------------------------------------------------------------------------
BOOL  RBSetBarInfo(PRB prb, LPREBARINFO lprbi)
{
    if (!prb || (lprbi->cbSize != sizeof(REBARINFO)))
        return(FALSE);

    if (lprbi->fMask & RBIM_IMAGELIST)
    {
        HIMAGELIST himl = prb->himl;
        UINT    cxOld, cyOld;

        //todo:validate lprbi->himl
        prb->himl = lprbi->himl;
        cxOld = prb->cxImage;
        cyOld = prb->cyImage;
        ImageList_GetIconSize(prb->himl, (LPINT)&prb->cxImage, (LPINT)&prb->cyImage);
        if ((prb->cxImage != cxOld) || (prb->cyImage != cyOld))
        {
            UINT i;

            for (i = 0; i < prb->cBands; i++) {
                if (RBGETBAND(prb, i)->fStyle & RBBS_HIDDEN)
                    continue;

                RBBCalcMinWidth(prb, RBGETBAND(prb, i));
            }

            RBResize(prb, FALSE);
        }
        else
            RBInvalidateRect(prb, NULL);
        lprbi->himl = himl;
    }

    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// RBGetBandInfo
//
// retrieves the indicated values from the specified band's internal structure
//
// ----------------------------------------------------------------------------
BOOL  RBGetBandInfo(PRB prb, UINT uBand, LPREBARBANDINFO lprbbi)
{
    PRBB prbb;

    if (!prb || (!RB_ISVALIDINDEX(prb, uBand)) || (lprbbi->cbSize > SIZEOF(REBARBANDINFO)))
        return(FALSE);

    prbb = RBGETBAND(prb, uBand);

    if (lprbbi->fMask & RBBIM_SIZE) {
        if (prbb->fStyle & RBBS_FIXEDSIZE)
            lprbbi->cx = prbb->cx;
        else 
            lprbbi->cx = prbb->cxRequest;
    }
    
    if (lprbbi->fMask & RBBIM_HEADERSIZE) 
        lprbbi->cxHeader = RBBHEADERWIDTH(prbb);
    
    if (lprbbi->fMask & RBBIM_IDEALSIZE)
        // HACKHACK: (tjgreen) Subtract the offset we added in SetBandInfo (see 
        // comments there).
        lprbbi->cxIdeal = prbb->cxIdeal ? prbb->cxIdeal - CX_OFFSET : 0;

    if (lprbbi->fMask & RBBIM_STYLE)
        lprbbi->fStyle = prbb->fStyle;

    if (lprbbi->fMask & RBBIM_COLORS)
    {
        lprbbi->clrFore = RBB_GetTextColor_External(prb, prbb);
        lprbbi->clrBack = RBB_GetBkColor_External(prb, prbb);
    }

    if (lprbbi->fMask & RBBIM_TEXT)
    {
        UINT cch = prbb->lpText ? lstrlen(prbb->lpText) : 0;

        if (!lprbbi->cch || !lprbbi->lpText || (lprbbi->cch <= cch))
            lprbbi->cch = cch + 1;
        else if (prbb->lpText)
            lstrcpy(lprbbi->lpText, prbb->lpText);
        else
            // no text -- so just make it an empty string
            lprbbi->lpText[0] = 0;
    }

    if (lprbbi->fMask & RBBIM_IMAGE)
        lprbbi->iImage = prbb->iImage;

    if (lprbbi->fMask & RBBIM_CHILD)
        lprbbi->hwndChild = prbb->hwndChild;

    if (lprbbi->fMask & RBBIM_CHILDSIZE)
    {
        // HACKHACK: (tjgreen) Subtract the offset we added in SetBandInfo (see
        // comments there).
        lprbbi->cxMinChild = prbb->cxMinChild ? prbb->cxMinChild - CX_OFFSET : 0;
        lprbbi->cyMinChild = prbb->cyMinChild;
        
        if (prbb->fStyle & RBBS_VARIABLEHEIGHT) {
            lprbbi->cyIntegral = prbb->cyIntegral;
            lprbbi->cyMaxChild = prbb->cyMaxChild;
            lprbbi->cyChild = prbb->cyChild;
        }
    }

    if (lprbbi->fMask & RBBIM_BACKGROUND)
        lprbbi->hbmBack = prbb->hbmBack;

    if (lprbbi->fMask & RBBIM_ID)
        lprbbi->wID = prbb->wID;

    if (lprbbi->fMask & RBBIM_LPARAM)
        lprbbi->lParam = prbb->lParam;

    return(TRUE);
}

BOOL RBValidateBandInfo(LPREBARBANDINFO *pprbbi, LPREBARBANDINFO prbbi)
{
    BOOL fRet = ((*pprbbi)->cbSize == sizeof(REBARBANDINFO));
    
    if (!fRet) {
        
        if ((*pprbbi)->cbSize < SIZEOF(REBARBANDINFO)) {
            hmemcpy(prbbi, (*pprbbi), (*pprbbi)->cbSize);
            (*pprbbi) = prbbi;
            prbbi->cbSize = SIZEOF(REBARBANDINFO);
            fRet = TRUE;
        }
    }

    return fRet;
}

// ----------------------------------------------------------------------------
//
// RBSetBandInfo
//
// sets the indicated values in the specified band's internal structure,
// recalculating and refreshing as needed
//
// ----------------------------------------------------------------------------
BOOL  RBSetBandInfo(PRB prb, UINT uBand, LPREBARBANDINFO lprbbi, BOOL fAllowRecalc)
{
    PRBB    prbb;
    BOOL    fRefresh = FALSE;
    BOOL    fRecalc  = FALSE;
    BOOL    fRecalcMin = FALSE;
    BOOL    fTextChanged = FALSE;
    REBARBANDINFO rbbi = {0};
    RECT    rc;

    if (!prb || (!RB_ISVALIDINDEX(prb, uBand)) || 
        !RBValidateBandInfo(&lprbbi, &rbbi))
        return(FALSE);

    prbb = RBGETBAND(prb, uBand);

    if (lprbbi->fMask & RBBIM_TEXT)
    {
        if (!lprbbi->lpText || !prbb->lpText || lstrcmp(lprbbi->lpText, prbb->lpText))
        {
            if (lprbbi->lpText != prbb->lpText) {
                Str_Set(&prbb->lpText, lprbbi->lpText);
                fTextChanged = TRUE;
            }
        }
    }

    if (lprbbi->fMask & RBBIM_STYLE)
    {
        UINT fStylePrev = prbb->fStyle;
        UINT fChanged = lprbbi->fStyle ^ fStylePrev;

        prbb->fStyle = lprbbi->fStyle;

        if (fChanged)
            fRecalc = TRUE;

        if ((prbb->fStyle & RBBS_FIXEDSIZE) && !(fStylePrev & RBBS_FIXEDSIZE))
            prbb->cxMin = prbb->cx;
        else if (fChanged & RBBS_FIXEDSIZE)
            fRecalcMin = TRUE;
        
        if (fChanged & RBBS_GRIPPERALWAYS)
            fRecalcMin = TRUE;
        
        if (fChanged & RBBS_HIDDEN) 
            RBShowBand(prb, uBand, !(prbb->fStyle & RBBS_HIDDEN));

        if (fChanged & RBBS_HIDETITLE)
            fTextChanged = TRUE;

        // can't have both of these
        if (prbb->fStyle & RBBS_FIXEDSIZE)
            prbb->fStyle &= ~RBBS_BREAK;
        
    }

    // RBBIM_TEXT does calculations that want to take some RBBIM_STYLE bits
    // into account, so delay those calculations until we grab the style bits.
    //
    if (fTextChanged && !(prbb->fStyle & RBBS_HIDDEN))
    {
        if (RBBCalcTextExtent(prb, prbb, NULL))
            fRecalc = TRUE;
        else
            fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_IDEALSIZE)
    {
        // HACKHACK: (tjgreen) Add an offset to the width the caller specifies.
        // This offset gets clipped off in RBResizeChildren, so the child window is  
        // rendered with the width specified by caller, and we get a little space on 
        // the toolbar after the buttons.  If caller specifies zero-width, though, 
        // we don't want this extra space, so don't add offset.
        int cxIdeal = lprbbi->cxIdeal ? lprbbi->cxIdeal + CX_OFFSET : 0;
        if (cxIdeal != prbb->cxIdeal) {
            prbb->cxIdeal = cxIdeal;
            fRecalcMin = TRUE;
            fRecalc = TRUE;
        }
    }
    
    if (lprbbi->fMask & RBBIM_SIZE)
    {
        if (prbb->cxRequest != (int) lprbbi->cx)
        {
            fRecalc = TRUE;
            prbb->cxRequest = (int) lprbbi->cx;
        }

        if (prbb->fStyle & RBBS_FIXEDSIZE)
            prbb->cxMin = prbb->cxRequest;
    }
    
    if (lprbbi->fMask & RBBIM_HEADERSIZE)
    {
        if ((lprbbi->cxHeader == -1) ||
            !(prbb->fStyle & RBBS_FIXEDHEADERSIZE) ||
            ((UINT)prbb->cxMin != lprbbi->cxHeader + prbb->cxMinChild)) {

            if (lprbbi->cxHeader == -1) {
                prbb->fStyle &= ~RBBS_FIXEDHEADERSIZE;
                fRecalcMin = TRUE;
            } else {
                prbb->fStyle |= RBBS_FIXEDHEADERSIZE;
                prbb->cxMin = lprbbi->cxHeader + prbb->cxMinChild;
            }

            fRecalc = TRUE;
            fRefresh = TRUE;
        }
    }

    if (lprbbi->fMask & RBBIM_COLORS)
    {
        prbb->clrFore = lprbbi->clrFore;
        prbb->clrBack = lprbbi->clrBack;
        fRefresh = TRUE;
    }

    if ((lprbbi->fMask & RBBIM_IMAGE) && (prbb->iImage != lprbbi->iImage))
    {
        BOOL fToggleBmp = ((prbb->iImage == -1) || (lprbbi->iImage == -1));

        prbb->iImage = lprbbi->iImage;

        if (fToggleBmp)
        {
            fRecalc = TRUE;
            fRecalcMin = TRUE;
        }
        else
            fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_CHILD &&
        lprbbi->hwndChild != prbb->hwndChild &&
        (NULL == lprbbi->hwndChild || 
         !IsChild(lprbbi->hwndChild, prb->ci.hwnd)))
    {
        if (IsWindow(prbb->hwndChild))
            ShowWindow(prbb->hwndChild, SW_HIDE);        

        prbb->hwndChild = lprbbi->hwndChild;

        if (prbb->hwndChild)
        {
            SetParent(prbb->hwndChild, prb->ci.hwnd);
            ShowWindow(prbb->hwndChild, SW_SHOW);
        }
        fRecalc = TRUE;
    }

    if (lprbbi->fMask & RBBIM_CHILDSIZE)
    {
        UINT cyChildOld = prbb->cyChild;

        if (lprbbi->cyMinChild != -1)
            prbb->cyMinChild = lprbbi->cyMinChild;

        if (prbb->fStyle & RBBS_VARIABLEHEIGHT) {
            
            if (lprbbi->cyIntegral != -1)
                prbb->cyIntegral = lprbbi->cyIntegral;
            
            if (lprbbi->cyMaxChild != -1)
                prbb->cyMaxChild = lprbbi->cyMaxChild;
            
            if (lprbbi->cyChild != -1)
                prbb->cyChild = lprbbi->cyChild;

            if (prbb->cyChild < prbb->cyMinChild)
                prbb->cyChild = prbb->cyMinChild;
            if (prbb->cyChild > prbb->cyMaxChild)
                prbb->cyChild = prbb->cyMaxChild;

            // validate the child size.  cyChild must be cyMinChild plux n*cyIntegral
            if (prbb->cyIntegral) {
                int iExtra;
                iExtra = (prbb->cyChild - prbb->cyMinChild) % prbb->cyIntegral;
                prbb->cyChild -= iExtra;
            }
            
        } else {
            // if we're not in variable height mode, then 
            // the cyChild is the same as cyMinChild.  
            // this is a little peculiar, but done this way for backcompat.
            // cyMinChild came before cyChild
            prbb->cyChild = lprbbi->cyMinChild;
        }

        if (lprbbi->cxMinChild != (UINT)-1) {
            // HACKHACK: (tjgreen) Add an offset to the width the caller specifies.
            // This offset gets clipped off in RBResizeChildren, so the child window is  
            // rendered with the width specified by caller, and we get a little space on 
            // the toolbar after the buttons.  However, if caller specifies zero-width or
            // if the band is fixed size, we don't want this extra space, so don't add offset.
            UINT cxMinChild = lprbbi->cxMinChild;
            if ((lprbbi->cxMinChild != 0) && !(prbb->fStyle & RBBS_FIXEDSIZE))
                cxMinChild += CX_OFFSET;

            if (prbb->cxMinChild != cxMinChild) {
                int cxOldHeaderMin = RBBHEADERWIDTH(prbb);
                
                if (prbb->fStyle & RBBS_FIXEDSIZE)
                    fRecalc = TRUE;
                    
                prbb->cxMinChild = cxMinChild;
                
                if (prbb->fStyle & RBBS_FIXEDHEADERSIZE)
                    prbb->cxMin = cxOldHeaderMin + prbb->cxMinChild;
                
                fRecalcMin = TRUE;
            }
            
            if (cyChildOld != prbb->cyChild) {
                // TODO:  revisit optimization:
                // if (RBBGetHeight(prb, prbb) != (UINT) prbb->cy)
                fRecalc = TRUE;
            }
        }
            
    }

    if (lprbbi->fMask & RBBIM_BACKGROUND)
    {
        DIBSECTION  dib;

        if (lprbbi->hbmBack && !GetObject(lprbbi->hbmBack, sizeof(DIBSECTION), &dib))
            return(FALSE);

        prbb->hbmBack = lprbbi->hbmBack;
        prbb->cxBmp = dib.dsBm.bmWidth;
        prbb->cyBmp = dib.dsBm.bmHeight;
        fRefresh = TRUE;
    }

    if (lprbbi->fMask & RBBIM_ID)
        prbb->wID = lprbbi->wID;

    if (lprbbi->fMask & RBBIM_LPARAM)
        prbb->lParam = lprbbi->lParam;

    if (fRecalcMin && !(prbb->fStyle & RBBS_HIDDEN))
        RBBCalcMinWidth(prb, prbb);

    if (fAllowRecalc) {

        if (fRecalc)
            RBResize(prb, FALSE);
        if (fRefresh || fRecalc)
        {
            // '|| fRecalc' so we catch add/grow of text.
            // testcase: remove title from band; add back; make sure the text
            // shows up (used to just leave old band contents there)
            SetRect(&rc, prbb->x, prbb->y, prbb->x + prbb->cx, prbb->y + prbb->cy);
            RBInvalidateRect(prb, &rc);
        }
    }
    
    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// RBReallocBands
//
// reallocates the array of bands pointed to by prb->rbbList to the given
// number of bands
//
// ----------------------------------------------------------------------------
BOOL  RBReallocBands(PRB prb, UINT cBands)
{
    PRBB rbbList;

    if (!(rbbList = (PRBB) CCLocalReAlloc(prb->rbbList, sizeof(RBB) * cBands)) && cBands)
        return(FALSE);

    prb->rbbList = rbbList;
    return(TRUE);
}

//
// NOTES
//  for now caller does this in two calls (query, set).  eventually we
//  should be able to have it do everything up front.
RBRecalcFirst(int nCmd, PRB prb, PRBB prbbDelHide)
{
    switch (nCmd) {
    case RBC_QUERY:
    {
        BOOL fRecalcFirst;
        // if we're nuking the 1st visible guy,
        // and there are visible guys after us,
        // then we need to recompute stuff
        //
        // for a testcase, start w/:
        //  row1: 'standard buttons' + 'brand'
        //  row2: 'address' + 'links'
        // now hide 'standard buttons', you should end up w/:
        //  row1: 'address' + 'links' + 'brand'
        // if there's a bug, you'll end up w/ (since the break isn't recomputed):
        //  row1: 'brand'
        //  row2: 'address' + 'links'
        // fRecalcFirst = (!uBand && prb->cBands);

        // if brbbDelHide is the first non-hidden band, and there are other non-hidden bands after it, fRecalcFirst = TRUE;
        fRecalcFirst = (RBEnumBand(prb, 0, RBBS_HIDDEN) == prbbDelHide) &&
                       (RBGetNextVisible(prb, prbbDelHide) <= RB_GETLASTBAND(prb));

        return fRecalcFirst;
    }

    case RBC_SET: // set
    {
        PRBB prbb1, prbb2;

        prbb1 = RBEnumBand(prb, 0, RBBS_HIDDEN);
        if ((prbb1->fStyle & RBBS_FIXEDSIZE)
          && (prbb2 = RBEnumBand(prb, 1, RBBS_HIDDEN)) <= RB_GETLASTBAND(prb)) {
            // get rid of line break on NEW first item
            prbb2->fStyle &= ~RBBS_BREAK;
        }

        if (prb->ci.style & RBS_FIXEDORDER) {
            // BUGBUG not sure what this does...
            // this is because the min width is now based on it's movability --
            // and since we are deleting (or hiding) the first item,
            // the new first item becomes immovable
            RBBCalcMinWidth(prb, prbb1);
        }
        return TRUE;
    }
    
    default:
        ASSERT(0);
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
// RBShowBand
//
// updates show/hide state for the indicated band in the rebar's band array
// (rbbList).
//
// ----------------------------------------------------------------------------
BOOL  RBShowBand(PRB prb, UINT uBand, BOOL fShow)
{
    PRBB prbb;
    BOOL fRecalcFirst;

    if (!prb || (!RB_ISVALIDINDEX(prb, uBand)))
        return(FALSE);

    prbb = RBGETBAND(prb, uBand);

    // if we're nuking the 1st visible guy,
    // then we need to recompute stuff
    fRecalcFirst = RBRecalcFirst(RBC_QUERY, prb, prbb);

    if (fShow)
    {
        prbb->fStyle &= ~RBBS_HIDDEN;

        if (!RBBCalcTextExtent(prb, prbb, NULL))
            RBBCalcMinWidth(prb, prbb);

        if (prbb->hwndChild)
            ShowWindow(prbb->hwndChild, SW_SHOW);
    }
    else
    {
        prbb->fStyle |= RBBS_HIDDEN;
        if (prbb->hwndChild)
            ShowWindow(prbb->hwndChild, SW_HIDE);        
    }

    if (fRecalcFirst)
        RBRecalcFirst(RBC_SET, prb, NULL);

    RBInvalidateRect(prb, NULL);
    RBResize(prb, FALSE);
    RBAutoSize(prb);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
// RBDeleteBand
//
// deletes the indicated band from the rebar's band array (rbbList) and
// decrements the rebar's band count (cBands)
//
// ----------------------------------------------------------------------------
BOOL  RBDeleteBand(PRB prb, UINT uBand)
{
    PRBB prbb;
    PRBB prbbStop;
    BOOL fRecalcFirst;
    NMREBAR nm = {0};

    ASSERT(prb);

    // we need to clean up
    //
    // a) captured band and
    // b) hottracked band
    //
    // before we delete this band

    if (prb->iCapture != -1) {
        RBSendNotify(prb, prb->iCapture, RBN_ENDDRAG);
        RBOnBeginDrag(prb, (UINT)-1);
    }

    if (!RB_ISVALIDINDEX(prb, uBand))
        return FALSE;

    prbb = RBGETBAND(prb, uBand);

    // Notify the client of the delete
    RBSendNotify(prb, uBand, RBN_DELETINGBAND);

    nm.dwMask = RBNM_ID;
    nm.wID = RBGETBAND(prb, uBand)->wID;        // Save this

    Str_Set(&prbb->lpText, NULL);

    // don't destroy the hbmBack 'cause it's given to us by app

    // if we're nuking the 1st visible guy,
    // then we need to recompute stuff

    // if this is the first visible guy and there are other visible bands after it, fRecalcFirst = TRUE
    fRecalcFirst = RBRecalcFirst(RBC_QUERY, prb, prbb);

    if (IsWindow(prbb->hwndChild))
        ShowWindow(prbb->hwndChild, SW_HIDE);    
    
    // prbbStop gets the address of the last band
    prbbStop = RB_GETLASTBAND(prb);

    for ( ; prbb < prbbStop; prbb++)
        *prbb = *(prbb + 1);

    prb->cBands--;

    if (prb->uResizeNext >= uBand && prb->uResizeNext > 0) {
        // (defer RBBS_HIDDEN stuff to use of uResizeNext)
        prb->uResizeNext--;
    }


    // Notify the client of the delete
    CCSendNotify(&prb->ci, RBN_DELETEDBAND, &nm.hdr);

    if (fRecalcFirst)
        RBRecalcFirst(RBC_SET, prb, NULL);

    RBReallocBands(prb, prb->cBands);

    RBInvalidateRect(prb, NULL);
    RBResize(prb, FALSE);
    RBAutoSize(prb);
    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// RBInsertBand
//
// inserts a new band at the given position in the rebar's band array (rbbList),
// increments the rebar's band count (cBands), and sets the band's structure
// based on the given REBARBANDINFO structure.
//
// ----------------------------------------------------------------------------
BOOL  RBInsertBand(PRB prb, UINT uBand, LPREBARBANDINFO lprbbi)
{
    PRBB prbb;
    REBARBANDINFO rbbi = {0};

    if (!prb || !RBValidateBandInfo(&lprbbi, &rbbi))
        return(FALSE);
    
    if (uBand == -1)
        uBand = prb->cBands;
    else if (uBand > prb->cBands)
        return(FALSE);

    if (!RBReallocBands(prb, prb->cBands + 1))
        return(FALSE);

    ++prb->cBands;
    MoveMemory(RBGETBAND(prb, uBand + 1), RBGETBAND(prb, uBand), (prb->cBands-1-uBand) * sizeof(prb->rbbList[0]));

    prbb = RBGETBAND(prb, uBand);

    // movememory does not zero init for us...
    ZeroMemory(prbb, SIZEOF(RBB));


    // Init text color
    if (prb->clrText == CLR_NONE)
    {
        // Default to system text color
        prbb->clrFore = CLR_DEFAULT;
    }
    else
    {
        // Default to rebar's custom text color
        prbb->clrFore = CLR_NONE;
    }


    // Init background color
    if (prb->clrBk == CLR_NONE)
    {
        // Default to system background color
        prbb->clrBack = CLR_DEFAULT;
    }
    else
    {
        // Default to rebar's custom background color
        prbb->clrBack = CLR_NONE;
    }

    
    prbb->iImage = -1;
    prbb->cyMaxChild = MAXINT;
    prbb->wChevState = DCHF_INACTIVE;
    
    ASSERT(prbb->fStyle == 0);
    ASSERT(prbb->lpText == NULL);
    ASSERT(prbb->cxText == 0);
    ASSERT(prbb->hwndChild == NULL);
    ASSERT(prbb->cxMinChild == 0);
    ASSERT(prbb->cyMinChild == 0);
    ASSERT(prbb->hbmBack == 0);
    ASSERT(prbb->x == 0);
    ASSERT(prbb->y == 0);
    ASSERT(prbb->cx == 0);
    ASSERT(prbb->cy == 0);
    
    if (!RBSetBandInfo(prb, uBand, lprbbi, FALSE))
    {
        RBDeleteBand(prb, uBand);
        return(FALSE);
    }
    
    if (!(prbb->fStyle & RBBS_HIDDEN)) {
        PRBB prbbFirst = RBEnumBand(prb, 0, RBBS_HIDDEN);
        
        if (!prbb->cxMin)
            RBBCalcMinWidth(prb, prbb);

        if (prbbFirst != prbb) {
            int cxMin = prbbFirst->cxMin;
            RBBCalcMinWidth(prb, prbbFirst);
        }
        RBResize(prb, FALSE);
    }

    RBSizeBandToRowHeight(prb, uBand, (UINT)-1);

    if (RBCountBands(prb, RBBS_HIDDEN) == 1) {
        // typcially, when you insert a band, we put it in a row with another band.
        // thus the total bounding rect doesn't change.  however, on the addition of the first band,
        // the bound rect does change, so we need to autosize as necessary.
        RBAutoSize(prb);
    }

    return(TRUE);
}

#pragma code_seg(CODESEG_INIT)

LRESULT CALLBACK ReBarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

BOOL InitReBarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, c_szReBarClass, &wc))
    {
#ifndef WIN32
        extern LRESULT CALLBACK _ReBarWndProc(HWND, UINT, WPARAM, LPARAM);
        wc.lpfnWndProc  = _ReBarWndProc;
#else
        wc.lpfnWndProc  = ReBarWndProc;
#endif

        wc.lpszClassName= c_szReBarClass;
        wc.style        = CS_GLOBALCLASS | CS_DBLCLKS;
        wc.cbClsExtra   = 0;
        wc.cbWndExtra   = sizeof(PRB);
        wc.hInstance    = hInstance;   // use DLL instance if in DLL
        wc.hIcon        = NULL;
        wc.hCursor      = NULL;
        wc.hbrBackground= (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszMenuName = NULL;

        if (!RegisterClass(&wc))
            return(FALSE);
    }

    return(TRUE);
}
#pragma code_seg()

// get the first band in the same row as rbbRow
// n.b. we may return an RBBS_HIDDEN band!
PRBB RBGetFirstInRow(PRB prb, PRBB prbbRow)
{
    // n.b. we don't pay attention to hidden here, that's up to caller.
    // in fact we *can't*, since there might be no non-hidden guys left
    // (e.g. when RBDestroy is deleting all the bands), in which case
    // we'd loop forever.
    while (prbbRow > RBGETBAND(prb, 0) && !RBISBANDSTARTOFROW(prbbRow)) {
        RBCheckRangePtr(prb, prbbRow);
        prbbRow--;
    }
    
    return prbbRow;
}

// get the last band in the same row as rbbRow.
// fStopAtFixed says whether to continue over fixed bands or 
// stop at them
// n.b. we may return an RBBS_HIDDEN band!
PRBB RBGetLastInRow(PRB prb, PRBB prbbRow, BOOL fStopAtFixed)
{
    do {
        prbbRow++;
    } while (prbbRow <= RB_GETLASTBAND(prb) && !RBISBANDSTARTOFROW(prbbRow) && 
        (!fStopAtFixed || (prbbRow->fStyle & (RBBS_FIXEDSIZE|RBBS_HIDDEN)) == RBBS_FIXEDSIZE));

    // loop steps to the start of the NEXT line
    prbbRow--;
    
    return prbbRow;
}

#ifdef DEBUG
BOOL RBCheckRangePtr(PRB prb, PRBB prbb)
{
    if (prbb < RBGETBAND(prb, 0)) {
        ASSERT(0);
        return FALSE;
    }

    if (RB_GETLASTBAND(prb) + 1 < prbb) {
        // +1 to allow for "p = first; p < last+1; p++" kinds of loops
        ASSERT(0);
        return FALSE;
    }

    return TRUE;
}

BOOL RBCheckRangeInd(PRB prb, INT_PTR i)
{
    if (i < 0) {
        ASSERT(0);
        return FALSE;
    }

    if ((int) prb->cBands < i) {
        // +1 to allow for "p = first; p < last+1; p++" kinds of loops
        ASSERT(0);
        return FALSE;
    }

    return TRUE;
}
#endif

//***   RBGetPrev, RBGetNext -- get prev (next) band, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
PRBB RBGetPrev(PRB prb, PRBB prbb, UINT uStyleSkip)
{
    while (--prbb >= RBGETBAND(prb, 0)) {
        if (prbb->fStyle & uStyleSkip)
            continue;
        break;
    }

    return prbb;
}

// when called with prbb=lastband, returns prbb++
// which is one past the end...
PRBB RBGetNext(PRB prb, PRBB prbb, UINT uStyleSkip)
{
    while (++prbb <= RB_GETLASTBAND(prb)) {
        if (prbb->fStyle & uStyleSkip)
            continue;
        break;
    }

    return prbb;
}

// this returns NULL when it hits the end
PRBB RBBNextVisible(PRB prb, PRBB prbb)
{
    prbb = RBGetNextVisible(prb, prbb);
    if (prbb > RB_GETLASTBAND(prb))
        return NULL;
    
    return prbb;
}

// this returns null when it hits the end
PRBB RBBPrevVisible(PRB prb, PRBB prbb)
{
    prbb = RBGetPrevVisible(prb, prbb);
    if (prbb < prb->rbbList)
        return NULL;
    
    return prbb;
}

//***   RBCountBands -- get count of bands, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
int RBCountBands(PRB prb, UINT uStyleSkip)
{
    int i;
    PRBB prbb;

    if (prb->cBands == 0)
        return 0;

    i = 0;
    for (prbb = RBGETBAND(prb, 0); prbb <= RB_GETLASTBAND(prb); prbb++) {
        if (prbb->fStyle & uStyleSkip)
            continue;
        i++;
    }

    return i;
}

//***   RBEnumBand -- get Nth band, skipping guys
// of style uStyleSkip (e.g. RBBS_HIDDEN)
// 'skipping' means don't include in count
PRBB RBEnumBand(PRB prb, int i, UINT uStyleSkip)
{
    PRBB prbb;

    for (prbb = RBGETBAND(prb, 0); prbb <= RB_GETLASTBAND(prb); prbb++) {
        if (prbb->fStyle & uStyleSkip)
            continue;
        if (i-- == 0)
            break;
    }

    // if we found it, this is the band;
    // if we ran out of bands, this is 1 past the end
    return prbb;
}

// returns the minimum x position prbb can be
int RBMinX(PRB prb, PRBB prbb)
{
    int xLimit = 0;

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));  // o.w. might loop forever
    while (!RBISBANDSTARTOFROW(prbb))
    {
        prbb--;
        if (!(prbb->fStyle & RBBS_HIDDEN))
            xLimit += _RBBandWidth(prb, prbb->cxMin);
    }
    
    return xLimit;
}

int RBMaxX(PRB prb, PRBB prbb)
{
    PRBB    prbbLast = prb->rbbList + prb->cBands;
    int xLimit = 0;
    PRBB prbbWalk;
    for (prbbWalk = prbb; prbbWalk < prbbLast; prbbWalk++) {
        if (prbbWalk->fStyle & RBBS_HIDDEN)
            continue;
        if (RBISBANDSTARTOFROW(prbbWalk))
            break;

        if (prbbWalk != prbb)
            xLimit += _RBBandWidth(prb, prbbWalk->cxMin);
        else 
            xLimit += prbbWalk->cxMin;
    }
    prbbWalk = RBGetPrevVisible(prb, prbbWalk);   // prbbWalk--;
    xLimit = prbbWalk->x + prbbWalk->cx - xLimit;
    return xLimit;
}

PRBB RBGetPrevVisible(PRB prb, PRBB prbb)
{
    return RBGetPrev(prb, prbb, RBBS_HIDDEN);
}

PRBB RBGetNextVisible(PRB prb, PRBB prbb)
{
    return RBGetNext(prb, prbb, RBBS_HIDDEN);
}

BOOL RBMinimizeBand(PRB prb, UINT uBand, BOOL fAnim)
{
    PRBB prbb;

    if (!RB_ISVALIDINDEX(prb, uBand))
        return FALSE;
    prbb=RBGETBAND(prb,uBand);
    if (prbb->fStyle & RBBS_FIXEDSIZE)
        return FALSE;
    
    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
    if (RBISBANDSTARTOFROW(prbb)) {
        // if it's the start of a row, the way to minimize it is to maximize the next guy
        // if it's on the same row
        prbb = RBGetNextVisible(prb, prbb);
        if (prbb > RB_GETLASTBAND(prb) || RBISBANDSTARTOFROW(prbb)) 
            return FALSE;
        
        return RBMaximizeBand(prb, RBBANDTOINDEX(prb,prbb), FALSE, fAnim);
    }
    if (fAnim)
        return RBSetBandPosAnim(prb, prbb, prbb->x + (prbb->cx - prbb->cxMin));
    else
        return RBSetBandPos(prb, prbb, prbb->x + (prbb->cx - prbb->cxMin));

}


// fIdeal - FALSE == full maximization...  
//          TRUE == go to cxIdeal
// fAnim - TRUE means we were called due to UI action (via RBToggleBand), so animate

BOOL RBMaximizeBand(PRB prb, UINT uBand, BOOL fIdeal, BOOL fAnim)
{
    int x, dx;
    BOOL fChanged = FALSE;
    PRBB prbbMaximize;

    if (!RB_ISVALIDINDEX(prb, uBand))
        return FALSE;

    prbbMaximize = RBGETBAND(prb,uBand);

    if (prbbMaximize->fStyle & RBBS_FIXEDSIZE)
        return FALSE;

    dx = prbbMaximize->cxIdeal + RBBHEADERWIDTH(prbbMaximize) - prbbMaximize->cx;
    
    if (fIdeal && dx > 0) 
    {
        PRBB prbb;
        
        // first move the next guy over if possible.

        prbb = RBBNextVisible(prb, prbbMaximize);
        if (prbb && (!RBISBANDSTARTOFROW(prbb)))
        {
            int dxRbb;

            x = RBMaxX(prb, prbb);
            // dxRbb is the maximum that prbb can move
            dxRbb = x - prbb->x;

            if (dxRbb > dx) {
                // if that's more than enough space, then limit dx
                dxRbb = dx;
            }

            x = prbb->x + dxRbb;
            fChanged |= (fAnim)?RBSetBandPosAnim(prb, prbb, x):RBSetBandPos(prb,prbb,x);
            dx -= dxRbb;
        }

        if (dx) {
            int dxRbb;

            // the one on the right didn't move enough.
            // now move us back
            x = RBMinX(prb, prbbMaximize);
            dxRbb = prbbMaximize->x - x;

            if (dxRbb > dx) {
                x = prbbMaximize->x - dx;
            }
            fChanged |= (fAnim)?RBSetBandPosAnim(prb, prbbMaximize, x):RBSetBandPos(prb, prbbMaximize, x);
        }
        
    } else {    
        x = RBMinX(prb, prbbMaximize);
        fChanged |= (fAnim)?RBSetBandPosAnim(prb, prbbMaximize, x):RBSetBandPos(prb, prbbMaximize, x);
        prbbMaximize = RBBNextVisible(prb, prbbMaximize);
        if (prbbMaximize && !RBISBANDSTARTOFROW(prbbMaximize)) {
            x = RBMaxX(prb, prbbMaximize);
            fChanged |= (fAnim)?RBSetBandPosAnim(prb, prbbMaximize, x):RBSetBandPos(prb, prbbMaximize, x);
        }
    }
            
    return fChanged;
}


// ----------------------------------------------------------------------------
//
// RBToggleBand
//
// switches a band between it's maximized and minimized state, based on where
// the user clicked
//
// ----------------------------------------------------------------------------
void  RBToggleBand(PRB prb, BOOL fAnim)
{
    BOOL fDidSomething = FALSE;

    // try to maximize this band.  if failed (meaning already maximize)
    // then minimize

    if (CCSendNotify(&prb->ci, RBN_MINMAX, NULL))
        return;            

    fDidSomething = RBMaximizeBand(prb, prb->iCapture, TRUE,fAnim);
    if (!fDidSomething)
        fDidSomething = RBMinimizeBand(prb, prb->iCapture,fAnim);

    if (fDidSomething)
        CCPlaySound(TEXT("ShowBand"));
}


// ----------------------------------------------------------------------------
//
// RBSetCursor
//
// sets the cursor to either the move cursor or the arrow cursor, depending
// on whether or not the cursor is on a band's caption
//
// ----------------------------------------------------------------------------
void  RBSetCursor(PRB prb, int x, int y, BOOL fMouseDown)
{

    int             iBand;
    RBHITTESTINFO   rbht;
    rbht.pt.x = x;
    rbht.pt.y = y;
    iBand = RBHitTest(prb, &rbht);
    if (rbht.flags == RBHT_GRABBER)
    {
        if (fMouseDown)
            SetCursor(LoadCursor(HINST_THISDLL, (prb->ci.style & CCS_VERT) ? MAKEINTRESOURCE(IDC_DIVOPENV) : MAKEINTRESOURCE(IDC_DIVOPEN) ));
        else
            SetCursor(LoadCursor(NULL, (prb->ci.style & CCS_VERT) ? IDC_SIZENS : IDC_SIZEWE));
        return;
    }

    if ((fMouseDown) && ((rbht.flags == RBHT_GRABBER) || (rbht.flags == RBHT_CAPTION) && RBShouldDrawGripper(prb, RBGETBAND(prb, iBand))))
    {
        // No longer IE3 compatible, per RichSt
        SetCursor(LoadCursor(NULL, IDC_SIZEALL));
        return;
    }

    SetCursor(LoadCursor(NULL, IDC_ARROW));
}

// adjust's a band's (prbb) starting location to the given location
BOOL RBSetBandPos(PRB prb, PRBB prbb, int xLeft)
{
    RECT    rc;
    PRBB    prbbPrev;
    int     xRight;
    BOOL    fBandBorders = (prb->ci.style & RBS_BANDBORDERS);
    BOOL    fRight;

    ASSERT(!(prbb->fStyle & RBBS_HIDDEN));
    ASSERT((xLeft >= 0)); // We've got problems if someone is trying to set us negative

    if (prbb->x == xLeft)
        return(FALSE);

    prbbPrev = RBGetPrevVisible(prb, prbb);

    // band has moved within valid range -- adjust band sizes and redraw
    // window
    fRight = (prbb->x < xLeft);

    SetRect(&rc, prbb->x, prbb->y, prbb->x + prbb->cxMin, prbb->y + prbb->cy);
    xRight = prbb->x + prbb->cx;
    prbb->x = xLeft;
    prbb->cx = xRight - xLeft;
    prbb->cxRequest = prbb->cx;

    if (fRight)
    {
        //moving right
        prbbPrev->cx = prbb->x - prbbPrev->x;
        if (fBandBorders)
        {
            prbbPrev->cx -= g_cxEdge;
            rc.left -= g_cxEdge;
        }
        prbbPrev->cxRequest = prbbPrev->cx;

        //check for compacting of following bands

        while (prbb->cx < prbb->cxMin)
        {
            prbb->cx = prbb->cxMin;
            prbb->cxRequest = prbb->cx;
            xLeft += RBBANDWIDTH(prb, prbb);
            prbb = RBGetNextVisible(prb, prbb);   // prbb++;
            xRight = prbb->x + prbb->cx;
            prbb->x = xLeft;
            prbb->cx = xRight - xLeft;
            prbb->cxRequest = prbb->cx;
        }
        rc.right = xLeft + prbb->cxMin;
    }
    else
    {
        //moving left

        //check for compacting of preceding bands
CompactPrevious:
        if (fBandBorders)
            xLeft -= g_cxEdge;
        prbbPrev->cx = xLeft - prbbPrev->x;
        prbbPrev->cxRequest = prbbPrev->cx;
        if (prbbPrev->cx < prbbPrev->cxMin)
        {
            prbbPrev->x = xLeft - prbbPrev->cxMin;
            prbbPrev->cx = prbbPrev->cxMin;
            prbbPrev->cxRequest = prbbPrev->cx;
            xLeft = prbbPrev->x;
            prbbPrev = RBGetPrevVisible(prb, prbbPrev);   // prbbPrev--
            goto CompactPrevious;
        }
        rc.left = xLeft;
    }

    if (fBandBorders)
        rc.bottom += g_cyEdge / 2;

    RBResizeChildren(prb);
    if (RBInvalidateRect(prb, &rc))
        UpdateWindow(prb->ci.hwnd);
    return(TRUE);

}

BOOL RBSetBandPosAnim(PRB prb, PRBB prbb, int xLeft)
{
    int ctr=0,dx, xCur = prbb->x;
    DWORD dwStartTime;

    if (xCur == xLeft)
        return FALSE;

    dwStartTime=GetTickCount();
    dx = (xLeft - xCur)/RB_ANIMSTEPS;

    if (dx != 0)
    {
        if (xCur < xLeft) {
            // move right
            for (; xCur < (xLeft-dx); ctr++,xCur += dx) {
                RBSetBandPos(prb, prbb, xCur);
                // If something caused us to take more than 10 times the time we
                // should be, break out, and let the final RBSetBandPos finish
                if (GetTickCount() > (dwStartTime + 10*RB_ANIMSTEPS*RB_ANIMSTEPTIME))
                    break;

                Sleep(RB_ANIMSTEPTIME);
                // Start slowing us down 80% of the way through
                // Cut speed by 2/3 each time, but never move less than 4 pixels
                if ((ctr >= 4*RB_ANIMSTEPS/5) && (dx >= 4))
                    dx = 2*dx/3; 
            }
        }
        else {
            // move left
            for (; xCur > (xLeft-dx); ctr++, xCur += dx) {
                RBSetBandPos(prb, prbb, xCur);
                if (GetTickCount() > (dwStartTime + 10*RB_ANIMSTEPS*RB_ANIMSTEPTIME))
                    break;
                Sleep(RB_ANIMSTEPTIME);
                if ((ctr >= 4*RB_ANIMSTEPS/5) && (dx <= -4))
                    dx = 2*dx/3;
            }
        }
    }
    RBSetBandPos(prb, prbb, xLeft);
    return TRUE;
}

// ----------------------------------------------------------------------------
//
// RBDragSize
//
// adjust the captured band's starting location to the given location and
// redraw
//
// ----------------------------------------------------------------------------
BOOL RBDragSize(PRB prb, int xLeft)
{
    return RBSetBandPos(prb, RBGETBAND(prb, prb->iCapture), xLeft);
}

void RBOnBeginDrag(PRB prb, UINT uBand)
{
    prb->iCapture = (int)uBand;
    prb->ptLastDragPos.x = -1;
    prb->ptLastDragPos.y = -1;
    if (prb->iCapture == -1) {
       // aborting drag
        prb->fParentDrag = FALSE;
        prb->fFullOnDrag = FALSE;

        // we could have unwrapped rows, in which case, we need to grow bands (but not wrap)
        // to fill the empty space.
        if (prb->ci.style & RBS_AUTOSIZE) {
            RBSizeBandsToRect(prb, NULL);
            RBSizeBandsToRowHeight(prb);
        }
        
    } else {
        prb->fParentDrag = TRUE;
        prb->fFullOnDrag = TRUE;
    }
}

int minmax(int x, int min, int max)
{
    x = max(x, min);
    x = min(x, max);
    return x;
}

// pass the break bit along
void RBPassBreak(PRB prb, PRBB prbbSrc, PRBB prbbDest)
{
    if (prbbSrc->fStyle & RBBS_BREAK) {
        prbbSrc->fStyle &= ~RBBS_BREAK;
        if (prbbDest)
            prbbDest->fStyle |= RBBS_BREAK;
    }
}

void RBGetClientRect(PRB prb, LPRECT prc)
{
    GetClientRect(prb->ci.hwnd, prc);
    if (prb->ci.style & CCS_VERT)
        FlipRect(prc);
}

//tells if prbb is the first band and the next band is fixed.
// if this is true then we need to do a recalc if we move prbb
BOOL RBRecalcIfMove(PRB prb, PRBB prbb)
{
    if (RBEnumBand(prb, 0, RBBS_HIDDEN) == prbb) {
        PRBB prbbNext = RBBNextVisible(prb, prbb);
        if (prbbNext && prbbNext->fStyle & RBBS_FIXEDSIZE)
            return TRUE;
    }
    return FALSE;
}

// find out if the prbb at it's min height could fit within the current window
// if all the others shrunk as much as they could
BOOL RBRoomForBandVert(PRB prb, PRBB prbbSkip)
{
    int yExtra = 0;
    int cBands = prb->cBands;
    int iNewRowHeight = prbbSkip->cyMinChild;
    PRBB prbb = RBGETBAND(prb, 0);
    
    if (prb->ci.style & RBS_BANDBORDERS)
        iNewRowHeight += g_cyEdge;
    
    while (prbb) {
        if (RBISBANDVISIBLE(prbb)) {
            if (RBISBANDSTARTOFROW(prbb)) {
                yExtra += RBGetRowHeightExtra(prb, &prbb, prbbSkip);
                if (yExtra >= iNewRowHeight)
                    return TRUE;
                continue;
            }
        }
        prbb = RBBNextVisible(prb, prbb);
    }
    
    return FALSE;
}

// we should make a new row if prbb isn't the start of the row already
// and we're off the end of the control
//
// poweruser hack of holding the control down will make a new row if you hit the border between lines

BOOL RBMakeNewRow(PRB prb, PRBB prbb, int y)
{
    BOOL fRet = FALSE;
    RECT rc;

    // if we're off the top of the control, move this band to the end (or beginning)
    RBGetClientRect(prb, &rc);
    InflateRect(&rc, 0, -g_cyEdge);

    if (!(prb->ci.style & RBS_FIXEDORDER)) {

        int iOutsideLimit = g_cyEdge * 4; // how far do you have to move outside the bounds of the window to force a new row
        
        if (RBRoomForBandVert(prb, prbb)) {
            iOutsideLimit = -g_cyEdge;
        }
        
        if (y < rc.top - iOutsideLimit) { // top of control
            
            PRBB prbbNext = RBEnumBand(prb, 0, RBBS_HIDDEN);
            if (prbbNext == prbb) 
                prbbNext = RBBNextVisible(prb, prbb);
            fRet |= RBMoveBand(prb, RBBANDTOINDEX(prb, prbb), 0);
            ASSERT(prbbNext <= RB_GETLASTBAND(prb));
            if (prbbNext && !(prbbNext->fStyle & RBBS_BREAK)) {
                prbbNext->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }
        } else if (y >= rc.bottom + iOutsideLimit) { // move to the end
            if (!(prbb->fStyle & RBBS_BREAK)) {
                prbb->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }
            fRet |= RBMoveBand(prb, RBBANDTOINDEX(prb, prbb), prb->cBands-1);
        } else {

            // create a new row in the middle
            if (!RBISBANDSTARTOFROW(prbb) && GetAsyncKeyState(VK_CONTROL) < 0) {
                // make sure they're on different rows and on the border
                if (y > prbb->y + prbb->cy && (y < prbb->y + prbb->cy + g_cyEdge)) {

                    PRBB prbbLast = RBGetLastInRow(prb, prbb, FALSE);  // move it right before the first in this row
                    prbb->fStyle |= RBBS_BREAK;
                    RBMoveBand(prb, RBBANDTOINDEX(prb, prbb), RBBANDTOINDEX(prb, prbbLast));
                    fRet = TRUE;
                }
            }
        }

    } else {
        // fixed guys can't move, they can only make a new row
        if (!RBISBANDSTARTOFROW(prbb)) {
            if (y > prbb->y + prbb->cy) {
                prbb->fStyle |= RBBS_BREAK;
                fRet = TRUE;
            }
        }
    }
    
    if (fRet)
        RBResize(prb, FALSE);
    return fRet;
}


// ----------------------------------------------------------------------------
//
// RBDragBand
//
// resizes the currently tracked band based on the user's mouse movement as
// indicated in the given point (x, y)
//
// ----------------------------------------------------------------------------
void RBDragBand(PRB prb, int x, int y)
{
    PRBB prbb = RBGETBAND(prb, prb->iCapture);
    int iHit;
    // Do nothing if the mouse didn't actually move
    // otherwise, multiple WM_MOUSEMOVE messages will be generated by resizing windows
    if (x==prb->ptLastDragPos.x && y==prb->ptLastDragPos.y)
        return;
    else
    {
        prb->ptLastDragPos.x = x;
        prb->ptLastDragPos.y = y;
    }

    if (prb->ci.style & CCS_VERT)
        SWAP(x,y, int);

    if (!prb->fFullOnDrag)
    {
        // don't begin dragging until mouse is moved outside of an edge-thick
        // tolerance border
        if ((y < (prb->ptCapture.y - g_cyEdge)) || (y > (prb->ptCapture.y + g_cyEdge)) ||
            (x < (prb->ptCapture.x - g_cxEdge)) || (x > (prb->ptCapture.x + g_cxEdge))) {

            // did parent abort?
            if (RBSendNotify(prb, prb->iCapture, RBN_BEGINDRAG))
                return;

            if (!RB_ISVALIDBAND(prb, prbb)) {
                // somebody responded to RBN_BEGINDRAG by nuking bands; bail
                return;
            }
            
            prb->fFullOnDrag = TRUE;
        } else
            return;
    }
    
    // bail for right now on fRecalcIfMoved (ie3 did the same thing). nice feature for later
    if (!RBCanBandMove(prb, prbb))
        return;
    
   /* what type of drag operation depends on what we drag hit on.

        if we hit on the band before us, or ourself
          and it's the same row
          and we're not the first band of the row
             then we just to a size move
             
        otherwise if we hit on a band then we do a move 
        
        if we hit outside of any band, we grow to meet the cursor
        
        in all of the above, a band that's hit must be NOT fixed and not hidden
    */
    iHit = _RBHitTest(prb, NULL, x, y);
    
    if (iHit != -1) {
        BOOL fResize = FALSE;
        PRBB prbbPrev = RBBPrevVisible(prb, prbb);
        PRBB prbbHit = RBGETBAND(prb, iHit);
        prbbHit = RBGetPrev(prb, ++prbbHit, RBBS_FIXEDSIZE); // skip over fixed guys

        ASSERT(prbbHit >= prb->rbbList);
        // this should never happen.
        if (prbbHit < prb->rbbList) 
            return;
        
        iHit = RBBANDTOINDEX(prb, prbbHit);
        
        // if we're on the same row ...  and it's us or the previous one
        if (prbbHit->y == prbb->y && (prbbHit == prbb || prbbHit == prbbPrev)) {

            if (x < RB_GRABWIDTH && !(prb->ci.style & RBS_FIXEDORDER)) {
                // special case dragging to the far left. there's no other way to move to first in row
                RBPassBreak(prb, prbbHit, prbb);
                if (RBMoveBand(prb, prb->iCapture, iHit))                
                    fResize = TRUE;

            } else if (!RBISBANDSTARTOFROW(prbb)) {
                // and we're not the first band of the row
                // then just size it
                int xLeft = prb->xStart + (x - prb->ptCapture.x);
                xLeft = minmax(xLeft, RBMinX(prb, prbb), RBMaxX(prb, prbb));
                RBDragSize(prb, xLeft);
            }

        } else if (RBMakeNewRow(prb, prbb, y)) {
        } else {            // otherwise do a move if we're not in a fixed order
            if (!(prb->ci.style & RBS_FIXEDORDER)) {
                if (iHit < RBBANDTOINDEX(prb, prbb)) 
                    iHit++; // +1 because if you hit a band, you're moving to the right of him

                // if one with a break is moving, the next one inherits the break
                RBPassBreak(prb, prbb, RBBNextVisible(prb, prbb));
                RBMoveBand(prb, prb->iCapture, iHit);
            } else {
                if (iHit < RBBANDTOINDEX(prb, prbb))
                    RBPassBreak(prb, prbb, RBBNextVisible(prb, prbb));
            }
            fResize = TRUE;
        }
        if (fResize)
            RBResize(prb, FALSE);        
        
    } else 
        RBMakeNewRow(prb, prbb, y);    
}

HPALETTE RBSetPalette(PRB prb, HPALETTE hpal)
{
    HPALETTE hpalOld = prb->hpal;

    if (hpal != hpalOld) {
        if (!prb->fUserPalette) {
            if (prb->hpal) {
                DeleteObject(prb->hpal);
                prb->hpal = NULL;
            }
        }

        if (hpal) {
            prb->fUserPalette = TRUE;
            prb->hpal = hpal;
        }

        RBInvalidateRect(prb, NULL);
    }
    return hpalOld;
}

// ----------------------------------------------------------------------------
//
// RBDestroy
//
// frees all memory allocated by rebar, including rebar structure
//
// ----------------------------------------------------------------------------
BOOL  RBDestroy(PRB prb)
{
    UINT c = prb->cBands;

    RBSetRedraw(prb, FALSE);
    RBSetRecalc(prb, FALSE);
    
    while (c--)
        RBDeleteBand(prb, c);

    // so that we don't keep trying to autosize
    prb->ci.style &= ~RBS_AUTOSIZE;
    
    ASSERT(!prb->rbbList);

    RBSetPalette(prb, NULL);
    
    if (prb->hFont && prb->fFontCreated) {
        DeleteObject(prb->hFont);
    }

    if ((prb->ci.style & RBS_TOOLTIPS) && IsWindow(prb->hwndToolTips))
    {
        DestroyWindow (prb->hwndToolTips);
        prb->hwndToolTips = NULL;
    }


    // don't destroy the himl 'cause it's given to us by app

    SetWindowPtr(prb->ci.hwnd, 0, 0);


    if (prb->hDragProxy)
        DestroyDragProxy(prb->hDragProxy);

    LocalFree((HLOCAL) prb);
    return(TRUE);
}

// ----------------------------------------------------------------------------
//
// RBInitPaletteHack
//
// this is a hack to use the halftone palette until we have a way of asking
// the client what palette they are using
//
// ----------------------------------------------------------------------------
void  RBInitPaletteHack(PRB prb)
{
    if (!prb->fUserPalette) {
        HDC hdc = CreateCompatibleDC(NULL);
        if (hdc) {
            if (GetDeviceCaps(hdc, BITSPIXEL) <= 8) {
                if (prb->hpal)
                    DeleteObject(prb->hpal);
                prb->hpal = CreateHalftonePalette(hdc);  // this is a hack
            }
            DeleteDC(hdc);
        }
    }
}

LRESULT RBIDToIndex(PRB prb, UINT id)
{
    UINT i;
    REBARBANDINFO   rbbi;

    rbbi.cbSize = sizeof(REBARBANDINFO);
    rbbi.fMask = RBBIM_ID;

    for (i = 0; i < prb->cBands; i++) {

        if (RBGetBandInfo(prb, i, &rbbi)) {

            if (rbbi.wID == (WORD)id)
                return i;
        }
    }

    return -1;
}

LRESULT RBGetRowHeight(PRB prb, UINT uRow)
{
    if (uRow < prb->cBands)
    {
        // move back to start of line
        PRBB prbbFirst = RBGetFirstInRow(prb, RBGETBAND(prb, uRow));
        PRBB prbbLast = RBGetLastInRow(prb, RBGETBAND(prb, uRow), FALSE);

        return RBGetLineHeight(prb, RBBANDTOINDEX(prb, prbbFirst), RBBANDTOINDEX(prb, prbbLast));
    }

    return (LRESULT)-1;
}

// fOneStep == whether to allow  only one cyIntegral or as many as will fit to 
//     fill dy
int RBGrowBand(PRB prb, PRBB prbb, int dy, BOOL fOneStep)
{
    int iDirection = dy / ABS(dy);
    int dyBand = 0; // how much the band changes
    int cyNewHeight;


    if (prbb->cyIntegral &&
        prbb->cyIntegral <= (UINT)ABS(dy)) {
        
        // get the proposed new size
        if (fOneStep)
            dyBand = (prbb->cyIntegral * iDirection);
        else {
            int iNumOfIntegrals;
            
            // don't let it grow more than the max allowed
            if (dy >= 0) {
                if ((int)(prbb->cyMaxChild - prbb->cyChild) < dy) {
                    dy = (int)(prbb->cyMaxChild - prbb->cyChild);
                }
            } else {
                if ((int)(prbb->cyMinChild - prbb->cyChild) > dy) {
                    dy = (int)(prbb->cyMinChild - prbb->cyChild);
                }
            }
            
            iNumOfIntegrals = (dy / (int) prbb->cyIntegral);
            dyBand = (prbb->cyIntegral * iNumOfIntegrals);
                
        }
        
        cyNewHeight = ((int)prbb->cyChild) + dyBand;

        // make sure the new size is legal
        
        if ((int)prbb->cyMinChild <= cyNewHeight && ((UINT)cyNewHeight) <= prbb->cyMaxChild) {
            prbb->cyChild = cyNewHeight;
            RBResize(prb, TRUE);
        } else
            dyBand = 0;
    }
    return dyBand;
}

// returns the delta in size that the rebar is from prc.
// taking into account vertical mode
int RBSizeDifference(PRB prb, LPRECT prc)
{
    int d;

    d = (RB_ISVERT(prb) ? RECTWIDTH(*prc) : RECTHEIGHT(*prc))
        - prb->cy;
    
    return d;
}

// returns how much this row could shrink
int RBGetRowHeightExtra(PRB prb, PRBB *pprbb, PRBB prbbSkip)
{
    // this is the largest minimum child size for the row. 
    // even if something is not at it's min size, if it's smaller than this
    // then it doesn't matter because someone else on that row can't be sized
    int yLimit = 0;
    int yExtra = 0;
    PRBB prbb = *pprbb;
            
    while (prbb) {
        
        if (prbb != prbbSkip) {
            int yMin;
            int yExtraBand = 0;

            // the min height is the cyChild if it's not variable height
            yMin = prbb->cyChild;
            if (prbb->fStyle & RBBS_VARIABLEHEIGHT)
            {
                // if it is variable height, and there's still room to shrink, then cyMinChild is
                // the minimum.  
                if (prbb->cyChild > prbb->cyMinChild + prbb->cyIntegral) {
                    yMin = prbb->cyMinChild;
                    yExtraBand = prbb->cyChild - prbb->cyMinChild;
                }
            }

            if (yMin == yLimit) {
                if (yExtraBand > yExtra)
                    yExtra = yExtraBand;
            } else if (yMin > yLimit) {
                yExtra = yExtraBand;
            }
        }
        
        prbb = RBBNextVisible(prb, prbb);
    }
    
    *pprbb = prbb;
    
    return yExtra;
}

// are allt he bands at the minimum size? 
BOOL RBBandsAtMinHeight(PRB prb)
{
    BOOL fRet = TRUE;
    int cBands = prb->cBands;
    
    PRBB prbb = RBGETBAND(prb, 0);
    while (prbb) {
        if (RBISBANDVISIBLE(prbb)) {
            if (RBISBANDSTARTOFROW(prbb)) {
                fRet = RBROWATMINHEIGHT(prb, &prbb);
                if (!fRet)
                    break;
                continue;
            }
        }
        prbb = RBBNextVisible(prb, prbb);
    }
    
    return fRet;
}

// this is like RBSizeBarToRect except that it resizes theactual bands if they
// are VARIABLEHEIGHT
BOOL RBSizeBandsToRect(PRB prb, LPRECT prc)
{
    int dy;
    int iDirection = 0;
    BOOL fChanged = FALSE;
    BOOL fChangedThisLoop;
    UINT cBands;
    RECT rc;
    BOOL fRedrawOld;
    
    if (prc)
        rc = *prc;
    else {
        GetClientRect(prb->ci.hwnd, &rc);
    }
    
    fRedrawOld = RBSetRedraw(prb, FALSE);

    
    // this is the amount we need to grow by

    do {
        BOOL fOneStep = TRUE;
        
        cBands = prb->cBands;
        fChangedThisLoop = FALSE;

        // if there's only one row, we don't need to iterate through all the rows slowly
        if (RBGetRowCount(prb) == 1)
            fOneStep = FALSE;
        
        dy = RBSizeDifference(prb, &rc);
        
        // ensure that we alway size in the same direction.
        // it's possible to get on the border and flip flop in an infinite
        // loop.  this happens when we size both horizontally and vertically down
        // beyond the minimum.  
        if (iDirection == 0)
            iDirection = dy;
        else if (dy * iDirection < 0)
            break;
        
        while (cBands-- && dy) {
            // when we're resizing the entire rebar,  we want to divvy up
            // the growth among all the bands (rather than give it all to
            // a single guy).  uResizeNext goes round-robin thru the bands.
            PRBB prbb = RBGETBAND(prb, prb->uResizeNext);

            if (prb->uResizeNext == 0) 
                prb->uResizeNext = prb->cBands -1;
            else
                prb->uResizeNext--;
            
            if (prbb->fStyle & RBBS_HIDDEN)
                continue;

            if (prbb->fStyle & RBBS_VARIABLEHEIGHT) {
                int d;
                // if it's a variable height kind of guy, grow/shrink it
                d = RBGrowBand(prb, prbb, dy, fOneStep);
                dy -= d;
                if (d) {
                    fChanged = TRUE;
                    fChangedThisLoop = TRUE;
                    break;
                }
            }
        }

        // if we're shrinking 
        // and we didn't get completely satisfied. we need to overshoot
        // so that no bands hang off the end and get cut off
        if (dy < 0 && !fChangedThisLoop && !RBBandsAtMinHeight(prb)) {
            if (rc.bottom > rc.top) {
                rc.bottom -= 1;
                fChangedThisLoop = TRUE;
            }
        }
        
    } while (fChangedThisLoop);

    RBSetRedraw(prb, fRedrawOld);
    
    return fChanged;
}

void RBSizeBandToRowHeight(PRB prb, int i, UINT uRowHeight)
{
    PRBB prbb = RBGETBAND(prb, i);
    
    if (prbb && prbb->fStyle & RBBS_VARIABLEHEIGHT) {
        if (uRowHeight == (UINT)-1)
            uRowHeight = (UINT) RBGetRowHeight(prb, i);

        if (uRowHeight > prbb->cyChild) {
            RBGrowBand(prb, prbb, (uRowHeight - prbb->cyChild),
                       FALSE);
        }
    }
}

// in the process of sizing, one band in a row of several bands might have
// grow pretty large.  we need to let the other bands have a chance to fill
// the extra space as well
void RBSizeBandsToRowHeight(PRB prb)
{
    UINT i;
    UINT iRowHeight = (UINT)-1;
    
    for (i = 0; i < prb->cBands; i++) {
        PRBB prbb = RBGETBAND(prb, i);

        if (prbb->fStyle & RBBS_HIDDEN)
            continue;
        
        if (RBISBANDSTARTOFROW(prbb))
            iRowHeight = (UINT) RBGetRowHeight(prb, i);

        RBSizeBandToRowHeight(prb, i, iRowHeight);
    }
}

// this will add/remove rebar band breaks to get to the requested size.
// it returns TRUE/FALSE whether something was done or not.
LRESULT RBSizeBarToRect(PRB prb, LPRECT prc)
{
    BOOL fChanged = FALSE;
    RECT rc;
    BOOL fRedrawOld = RBSetRedraw(prb, FALSE);

    if (!prc) {
        GetClientRect(prb->ci.hwnd, &rc);
        prc = &rc;
    }
    
    if (prb->cBands) {
        int c;
        UINT cBands = prb->cBands;
        BOOL fChangedThisLoop = TRUE;
        BOOL fGrowing = TRUE;
        
        // if we're shrinking the rebar, we first want to shrink the bands before we start 
        // removing breaks
        c = RBSizeDifference(prb, prc);
        if (c < 0) 
            fGrowing = FALSE;
        
        if (!fGrowing) {
            fChanged = RBSizeBandsToRect(prb, prc);
            
            if (!RBBandsAtMinHeight(prb)) {
                // if we're shrinking and all the bands are not down to
                // the minimum height, don't try doing any of the breaking stuff
                goto Bail;
            }
        } else if (RB_ISVERT(prb)) {

            // if we're in vertical mode, give preference to 
            // sizing bands before breaking
            fChanged = RBSizeBandsToRect(prb, prc);
        }

        while (fChangedThisLoop && prb->cBands) {

            int cyRowHalf  = (int) RBGetRowHeight(prb, prb->cBands-1) / 2 ;
            REBARBANDINFO   rbbi;
            PRBB prbb;

            fChangedThisLoop = FALSE;

            rbbi.cbSize = sizeof(REBARBANDINFO);
            rbbi.fMask = RBBIM_STYLE;

            c = RBSizeDifference(prb, prc);

            if (c < -cyRowHalf) {

                // we've shrunk the rebar, try to remove breaks
                while (--cBands)
                {
                    prbb = RBGETBAND(prb, cBands);
                    if (prbb->fStyle & RBBS_HIDDEN)
                        continue;

                    if (prbb->fStyle & RBBS_BREAK)
                    {
                        fChanged = TRUE;
                        fChangedThisLoop = TRUE;
                        rbbi.fStyle = prbb->fStyle & ~RBBS_BREAK;
                        RBSetBandInfo(prb, cBands, &rbbi, TRUE);
                        break;
                    }
                }
            } else if (c > cyRowHalf) {

                // we're enlarging the rebar
                while (--cBands)
                {
                    prbb = RBGETBAND(prb, cBands);
                    if (prbb->fStyle & RBBS_HIDDEN)
                        continue;

                    if (!(prbb->fStyle & (RBBS_BREAK | RBBS_FIXEDSIZE)))
                    {
                        // no break here, add it
                        fChanged = TRUE;
                        fChangedThisLoop = TRUE;
                        rbbi.fStyle = (prbb->fStyle | RBBS_BREAK);
                        RBSetBandInfo(prb, cBands, &rbbi, TRUE);
                        break;
                    }
                }
            }
        };

        // if we did as much breaking as we could
        // and we walked all the way down to the 0th band (we start at the Nth band)
        // then we try to grow the bands that are VARIABLEHEIGHT
        // for fGrowing, see comment at top of function
        // 
        // wedo the % because cBands == prb->cBands if we didn't go through
        // any of the breaking loops at all
        if (!(cBands % prb->cBands) && fGrowing) 
            fChanged |= RBSizeBandsToRect(prb, prc);

    }

Bail:
    RBSizeBandsToRowHeight(prb);
    RBSetRedraw(prb, fRedrawOld);
    
    return (LRESULT)fChanged;
}

void RBAutoSize(PRB prb)
{
    NMRBAUTOSIZE nm;
    
    // if this is an internal autosize call, but we're not in autosize mode
    // do nothing
    
    if (!(prb->ci.style & RBS_AUTOSIZE))
        return;
    
    
    GetClientRect(prb->ci.hwnd, &nm.rcTarget);

    nm.fChanged = (BOOL) RBSizeBarToRect(prb, &nm.rcTarget);

    GetClientRect(prb->ci.hwnd, &nm.rcActual);
    CCSendNotify(&prb->ci, RBN_AUTOSIZE, &nm.hdr);
}

LRESULT RBGetBandBorders(PRB prb, int wParam, LPRECT prc)
{
    BOOL fBandBorders = (prb->ci.style & RBS_BANDBORDERS);

    PRBB prbb = &prb->rbbList[wParam];
    prc->left = RBBHEADERWIDTH(prbb);
    
    if (fBandBorders) {
        prc->left += 2*g_cxEdge;
        prc->right = 0;
        prc->top = g_cyEdge/2;
        prc->bottom = g_cyEdge /2;
    }
    if (prb->ci.style & CCS_VERT)
        FlipRect(prc);
    return 0;
}

void RBOnStyleChanged(PRB prb, WPARAM wParam, LPSTYLESTRUCT lpss)
{
    if (wParam == GWL_STYLE)
    {
        DWORD dwChanged;
        
        prb->ci.style = lpss->styleNew;
        
        dwChanged = (lpss->styleOld ^ lpss->styleNew);
        // update to reflect style change
#ifndef WINNT
        TraceMsg(TF_REBAR, "rebar window style changed %x", prb->ci.style);
#endif
        if (dwChanged & CCS_VERT)
        {
            UINT i;
            for (i = 0; i < prb->cBands; i++) {
                if (RBGETBAND(prb, i)->fStyle & RBBS_HIDDEN)
                    continue;

                RBBCalcMinWidth(prb, RBGETBAND(prb, i));
            }
            RBResize(prb, TRUE);
            RBInvalidateRect(prb, NULL);
        }
        
        if (dwChanged & RBS_REGISTERDROP) {
            
            if (prb->ci.style & RBS_REGISTERDROP) {
                ASSERT(!prb->hDragProxy);
                prb->hDragProxy = CreateDragProxy(prb->ci.hwnd, RebarDragCallback, TRUE);
            } else {
                ASSERT(prb->hDragProxy);
                DestroyDragProxy(prb->hDragProxy);
            }
        }
    } else if (wParam == GWL_EXSTYLE) {
        //
        // If the RTL_MIRROR extended style bit had changed, let's
        // repaint the control window
        //
        if ((prb->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=  (lpss->styleNew&RTL_MIRRORED_WINDOW)) {
            RBInvalidateRect(prb, NULL);
        }

        //
        // Save the new ex-style bits
        //
        prb->ci.dwExStyle = lpss->styleNew;
    }
}

void RBOnMouseMove(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, PRB prb)
{
    RelayToToolTips(prb->hwndToolTips, hwnd, uMsg, wParam, lParam);

    if (prb->iCapture != -1)
    {
        // captured band -- mouse is down
        if (hwnd != GetCapture() && !prb->fParentDrag)
        {
            RBSendNotify(prb, prb->iCapture, RBN_ENDDRAG);
            RBOnBeginDrag(prb, (UINT)-1);
        }
        else
            RBDragBand(prb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    }
    else
    {
        // hottracking
        int iBand;
        PRBB prbb = NULL;
        PRBB prbbHotOld = prb->prbbHot;
        RBHITTESTINFO rbht;

        rbht.pt.x = GET_X_LPARAM(lParam);
        rbht.pt.y = GET_Y_LPARAM(lParam);

        iBand = RBHitTest(prb, &rbht);
        if (iBand != -1)
            prbb = RBGETBAND(prb, iBand);

        if (prbbHotOld && (prbbHotOld->wChevState & DCHF_PUSHED))
            return;

        if (prbb && (rbht.flags & RBHT_CHEVRON))
        {
            SetCapture(hwnd);
            RBUpdateChevronState(prb, prbb, DCHF_HOT);
            if (prbb == prbbHotOld)
                prbbHotOld = NULL;
        }

        if (prbbHotOld)
        {
            CCReleaseCapture(&prb->ci);
            RBUpdateChevronState(prb, prbbHotOld, DCHF_INACTIVE);
        }
    }
}

void RBOnPushChevron(HWND hwnd, PRB prb, PRBB prbb, LPARAM lParamNM)
{
    NMREBARCHEVRON nm;
    nm.uBand = RBBANDTOINDEX(prb, prbb);
    nm.wID = prbb->wID;
    nm.lParam = prbb->lParam;
    nm.lParamNM = lParamNM;
    CopyRect(&nm.rc, &prbb->rcChevron);
    if (RB_ISVERT(prb))
        FlipRect(&nm.rc);
    RBUpdateChevronState(prb, prbb, DCHF_PUSHED);
    CCReleaseCapture(&prb->ci);
    CCSendNotify(&prb->ci, RBN_CHEVRONPUSHED, &nm.hdr);
    RBUpdateChevronState(prb, prb->prbbHot, DCHF_INACTIVE);
}

LRESULT CALLBACK ReBarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PRB     prb = (PRB) GetWindowPtr(hwnd, 0);
    int     iBand;

    // bail if no prb unless at creation time
    if (!prb && !(uMsg == WM_NCCREATE))
        goto CallDWP;

    switch (uMsg)
    {
    case WM_SETREDRAW:
        if (prb->ci.iVersion >= 5)
            RBSetRecalc(prb, BOOLFROMPTR(wParam));

        return RBSetRedraw(prb, BOOLFROMPTR(wParam));

    case WM_NCCREATE:
#define lpcs ((LPCREATESTRUCT) lParam)
        CCCreateWindow();
        InitGlobalColors();

        if (!(prb = (PRB) LocalAlloc(LPTR, sizeof(RB))))
            return(0L);

        SetWindowPtr(hwnd, 0, prb);
 
        prb->iCapture = -1;
        prb->clrBk = CLR_NONE;
        prb->clrText = CLR_NONE;

        // Init the dwSize because we block-copy it back to the app
        prb->clrsc.dwSize = sizeof(COLORSCHEME);
        prb->clrsc.clrBtnHighlight = prb->clrsc.clrBtnShadow = CLR_DEFAULT;

        prb->fRedraw = TRUE;
        prb->fRecalc = TRUE;

        // note, zero init memory from above
        CIInitialize(&prb->ci, hwnd, lpcs);

        if (!(prb->ci.style & (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)))
        {
            prb->ci.style |= CCS_TOP;
            SetWindowLong(hwnd, GWL_STYLE, prb->ci.style);
        }

        RBSetFont(prb, 0);

        if (lpcs->lpCreateParams)
            RBSetBarInfo(prb, (LPREBARINFO) (lpcs->lpCreateParams));
#undef lpcs
        return TRUE;

    case WM_DESTROY:
        CCDestroyWindow();

        RBDestroy(prb);
        SetWindowPtr(hwnd, 0, 0);
        break;

    case WM_CREATE:
        // Do delayed stuff for speed.
        PostMessage(hwnd, RB_PRIV_DODELAYEDSTUFF, 0, 0);
        goto CallDWP;

    case RB_PRIV_DODELAYEDSTUFF:
        // Delay done stuff for speed:

        if (prb->ci.style & RBS_REGISTERDROP)
            prb->hDragProxy = CreateDragProxy(prb->ci.hwnd, RebarDragCallback, TRUE);
                
        if (prb->ci.style & RBS_TOOLTIPS)
        {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in FlushToolTipsMgr;
            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_IDISHWND;
            ti.hwnd = hwnd;
            ti.uId = (UINT_PTR)hwnd;
            ti.lpszText = 0;

            prb->hwndToolTips = CreateWindow(c_szSToolTipsClass, NULL,
                    WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    hwnd, NULL, (HINSTANCE)GetWindowLongPtr(hwnd, GWLP_HINSTANCE), NULL);

            SendMessage(prb->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO) &ti);
        }
        RBInitPaletteHack(prb);
        break;

    case WM_NCHITTEST:
        {
            RBHITTESTINFO rbht;
            int iBand;
            
            rbht.pt.x = GET_X_LPARAM(lParam);
            rbht.pt.y = GET_Y_LPARAM(lParam);
            ScreenToClient(prb->ci.hwnd, &rbht.pt);

            iBand = RBHitTest(prb, &rbht);
            {
                NMMOUSE nm;
                LRESULT lres;
                
                nm.dwItemSpec = iBand;
                nm.pt = rbht.pt;
                nm.dwHitInfo = rbht.flags;
                
                // send to the parent to give them a chance to override
                lres = CCSendNotify(&prb->ci, NM_NCHITTEST, &nm.hdr);
                if (lres)
                    return lres;
                
            }
        }
        return HTCLIENT;

    case WM_NCCALCSIZE:
        if (prb->ci.style & WS_BORDER)
        {
            InflateRect((LPRECT) lParam, -g_cxEdge, -g_cyEdge);
            break;
        }
        goto CallDWP;

    case WM_NCPAINT:
        if (prb->ci.style & WS_BORDER)
        {
            RECT rc;
            HDC hdc;

            GetWindowRect(hwnd, &rc);
            OffsetRect(&rc, -rc.left, -rc.top);
            hdc = GetWindowDC(hwnd);
            CCDrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT, &(prb->clrsc));
            ReleaseDC(hwnd, hdc);
            break;
        }
        goto CallDWP;

    case WM_PALETTECHANGED:
        if ((HWND)wParam == hwnd)
            break;

    case WM_QUERYNEWPALETTE:
        // Want to pass FALSE if WM_QUERYNEWPALETTE...
        RBRealize(prb, NULL, uMsg == WM_PALETTECHANGED, uMsg == WM_PALETTECHANGED);
        return TRUE;

    case WM_PAINT:
    case WM_PRINTCLIENT:
        RBPaint(prb, (HDC)wParam);
        break;

    case WM_ERASEBKGND:
        if (RBEraseBkgnd(prb, (HDC) wParam, -1))
            return(TRUE);
        goto CallDWP;

    case WM_SYSCOLORCHANGE:
        RBInitPaletteHack(prb);

        if (prb->hwndToolTips)
            SendMessage(prb->hwndToolTips, uMsg, wParam, lParam);

        InitGlobalColors();
        InvalidateRect(prb->ci.hwnd, NULL, TRUE);

        break;


    case RB_SETPALETTE:
        return (LRESULT)RBSetPalette(prb, (HPALETTE)lParam);

    case RB_GETPALETTE:
        return (LRESULT)prb->hpal;

    case WM_SIZE:
        RBAutoSize(prb);
        RBResize(prb, FALSE);
        break;

    case WM_GETFONT:
        return((LRESULT) (prb ? prb->hFont : NULL));

    case WM_COMMAND:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        SendMessage(prb->ci.hwndParent, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONDBLCLK:  // DBLCLK sent in place of LBUTTONDOWN
    case WM_RBUTTONDOWN:    // right button drags too
    case WM_LBUTTONDOWN:
        {
            RBHITTESTINFO rbht;
            PRBB prbb = NULL;

            rbht.pt.x = GET_X_LPARAM(lParam);
            rbht.pt.y = GET_Y_LPARAM(lParam);

            RelayToToolTips(prb->hwndToolTips, hwnd, uMsg, wParam, lParam);

            iBand = RBHitTest(prb, &rbht);
            if (iBand != -1)
                prbb = RBGETBAND(prb, iBand);

            if (!prbb)
                /* nothing */ ;
            else if (rbht.flags & RBHT_CHEVRON)
            {
                RBOnPushChevron(hwnd, prb, prbb, 0);
            }
            else if (rbht.flags != RBHT_CLIENT && RBShouldDrawGripper(prb, prbb))
            {
                prb->iCapture = iBand;
                prb->ptCapture = rbht.pt;
                if (prb->ci.style & CCS_VERT) 
                    SWAP(prb->ptCapture.x, prb->ptCapture.y, int);
                prb->xStart = prbb->x;
                SetCapture(hwnd);
                prb->fFullOnDrag = FALSE;

                if (uMsg == WM_LBUTTONDBLCLK && (prb->ci.style & RBS_DBLCLKTOGGLE))
                    RBToggleBand(prb,TRUE);
            }
        }
        break;

    case WM_SETCURSOR:
        // Give the parent first crack, if it sets the cursor then
        // leave it at that.  Otherwise if the cursor is over our
        // window then set it to what we want it to be.
        if (!DefWindowProc(hwnd, uMsg, wParam, lParam) && (hwnd == (HWND)wParam))
        {
            POINT   pt;
            GetMessagePosClient(prb->ci.hwnd, &pt);
            RBSetCursor(prb, pt.x, pt.y,  (HIWORD(lParam) == WM_LBUTTONDOWN || HIWORD(lParam) == WM_RBUTTONDOWN));
        }
        return TRUE;

    case WM_MOUSEMOVE:
        RBOnMouseMove(hwnd, uMsg, wParam, lParam, prb);
        break;

    case WM_RBUTTONUP:
        if (!prb->fFullOnDrag && !prb->fParentDrag) {
            CCReleaseCapture(&prb->ci);

            // if we're not doing drag drop, go to def window proc so that
            // wm_contextmenu gets propagated
            RBOnBeginDrag(prb, (UINT)-1);
            goto CallDWP;
        }
        // fall through

    case WM_LBUTTONUP:
        RelayToToolTips(prb->hwndToolTips, hwnd, uMsg, wParam, lParam);

        if (prb->iCapture != -1)
        {
            UINT uiIndex;

            if (!prb->fParentDrag)
                CCReleaseCapture(&prb->ci);
            // if there was no significant mouse motion, treat as a click
            if (!(prb->ci.style & RBS_DBLCLKTOGGLE) && !prb->fFullOnDrag)
                RBToggleBand(prb,TRUE);

            RBGETBAND(prb, prb->iCapture)->fStyle &= ~RBBS_DRAGBREAK;
            CCSendNotify(&prb->ci, RBN_LAYOUTCHANGED, NULL);
            RBSendNotify(prb, prb->iCapture, RBN_ENDDRAG);
            RBOnBeginDrag(prb, (UINT)-1);
            for (uiIndex = 0; uiIndex < prb->cBands; uiIndex++) {
                if (RBGETBAND(prb, uiIndex)->fStyle & RBBS_HIDDEN)
                    continue;

                RBBCalcMinWidth(prb, RBGETBAND(prb, uiIndex));
            }

            RBSizeBandsToRect(prb, NULL);
            RBInvalidateRect(prb, NULL);
        }
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if (prb->fFontCreated)
            RBSetFont(prb, wParam);

        if (prb->hwndToolTips)
            SendMessage(prb->hwndToolTips, uMsg, wParam, lParam);

        break;

    case WM_SETFONT:
        RBOnSetFont(prb, (HFONT)wParam);
        break;

    case WM_NOTIFYFORMAT:
        return(CIHandleNotifyFormat(&prb->ci, lParam));

    case WM_NOTIFY:
        // We are just going to pass this on to the real parent
        // Note that -1 is used as the hwndFrom.  This prevents SendNotifyEx
        // from updating the NMHDR structure.
        return(SendNotifyEx(prb->ci.hwndParent, (HWND) -1,
                 ((LPNMHDR) lParam)->code, (LPNMHDR) lParam, prb->ci.bUnicode));

    case WM_STYLECHANGED:
        RBOnStyleChanged(prb, wParam, (LPSTYLESTRUCT)lParam);
        break;

#ifdef KEYBOARDCUES
    case WM_UPDATEUISTATE:
        if (CCOnUIState(&(prb->ci), WM_UPDATEUISTATE, wParam, lParam))
        {
            InvalidateRect(hwnd, NULL, TRUE);
        }
        goto CallDWP;
#endif
#ifdef UNICODE
    case RB_SETBANDINFOA:
    case RB_INSERTBANDA:
        if (EVAL(lParam))
        {
            LPWSTR lpStrings = NULL;
            LPSTR  lpAnsiString;
            int    iResult;

            // lParam starts out pointing to a REBARBANDINFOA, and
            // we secretly change it into a REBARBANDINFOW, and then
            // change it back.

            LPREBARBANDINFOW prbiW = (LPREBARBANDINFOW)lParam;
            LPREBARBANDINFOA prbiA = (LPREBARBANDINFOA)lParam;

            COMPILETIME_ASSERT(sizeof(REBARBANDINFOW) == sizeof(REBARBANDINFOA));

            // BUGBUG - raymondc - Is it safe to modify the incoming
            // REBARBANDINFOA structure?

            lpAnsiString = prbiA->lpText;
            if ((prbiA->fMask & RBBIM_TEXT) && prbiA->lpText) {

                lpStrings = ProduceWFromA(prb->ci.uiCodePage, lpAnsiString);
                if (!lpStrings)
                    return -1;

                // Presto!  Now it's a REBARBANDINFOW!
                prbiW->lpText = lpStrings;
            }

            if (uMsg == RB_INSERTBANDA)
                iResult = RBInsertBand(prb, (UINT) wParam, prbiW);
            else
                iResult = RBSetBandInfo(prb, (UINT) wParam, prbiW, TRUE);

            // Change-o!  Now it's a REBARBANDINFOA!
            prbiA->lpText = lpAnsiString;

            if (lpStrings)
                FreeProducedString(lpStrings);

            return iResult;
        }
#endif

    case RB_INSERTBAND:
        return(RBInsertBand(prb, (UINT) wParam, (LPREBARBANDINFO) lParam));

    case RB_DELETEBAND:
        return(RBDeleteBand(prb, (UINT) wParam));

    case RB_SHOWBAND:
        return(RBShowBand(prb, (UINT) wParam, BOOLFROMPTR(lParam)));

#ifdef UNICODE
    case RB_GETBANDINFOA:
        {
            LPREBARBANDINFOA prbbi = (LPREBARBANDINFOA)lParam;
            LPWSTR pszW = NULL;
            LPSTR  lpAnsiString = prbbi->lpText;
            int    iResult;

            if (prbbi->fMask & RBBIM_TEXT) {
                pszW = LocalAlloc(LPTR, prbbi->cch * sizeof(WCHAR));
                if (!pszW)
                    return 0;
                prbbi->lpText = (LPSTR)pszW;
            }

            iResult = RBGetBandInfo(prb, (UINT)wParam, (LPREBARBANDINFO)lParam);

            if (pszW) {
                ConvertWToAN(prb->ci.uiCodePage, lpAnsiString, prbbi->cch, (LPWSTR)prbbi->lpText, -1);
                prbbi->lpText = lpAnsiString;
                LocalFree(pszW);
            }

            return iResult;
        }
#endif

        // we have getbandinfoold because in ie3, we did not thunk
        // and getbandinfo always return OS native string (dumb)
    case RB_GETBANDINFOOLD:
    case RB_GETBANDINFO:
        return(RBGetBandInfo(prb, (UINT) wParam, (LPREBARBANDINFO) lParam));
            
    case RB_GETTOOLTIPS:
        return (LPARAM)prb->hwndToolTips;
            
    case RB_SETTOOLTIPS:
        prb->hwndToolTips = (HWND)wParam;
        break;
            
    case RB_SETBKCOLOR:
        {
            COLORREF clr = prb->clrBk;
            prb->clrBk = (COLORREF)lParam;
            if (clr != prb->clrBk)
                InvalidateRect(prb->ci.hwnd, NULL, TRUE);
            return clr;
        }
            
    case RB_GETBKCOLOR:
        return prb->clrBk;
            
    case RB_SETTEXTCOLOR:
        {
            COLORREF clr = prb->clrText;
            prb->clrText = (COLORREF)lParam;
            return clr;
        }
            
    case RB_GETTEXTCOLOR:
        return prb->clrText;

    case RB_IDTOINDEX:
        return RBIDToIndex(prb, (UINT) wParam);

    case RB_GETROWCOUNT:
        return(RBGetRowCount(prb));

    case RB_GETROWHEIGHT:
        return RBGetRowHeight(prb, (UINT)wParam);
        
    case RB_GETBANDBORDERS:
        return RBGetBandBorders(prb, (UINT)wParam, (LPRECT)lParam);

    case RB_GETBANDCOUNT:
        return(prb->cBands);

    case RB_SETBANDINFO:
        return(RBSetBandInfo(prb, (UINT) wParam, (LPREBARBANDINFO) lParam, TRUE));

    case RB_GETBARINFO:
        return(RBGetBarInfo(prb, (LPREBARINFO) lParam));

    case RB_SETBARINFO:
        return(RBSetBarInfo(prb, (LPREBARINFO) lParam));

    case RB_SETPARENT:
        {
            HWND hwndOld = prb->ci.hwndParent;
            prb->ci.hwndParent = (HWND) wParam;
            return (LRESULT)hwndOld;
        }
        break;

    case RB_GETRECT:
        if (RB_ISVALIDINDEX(prb, wParam))
        {
            PRBB prbb = RBGETBAND(prb, (int) wParam);
            LPRECT lprc = (LPRECT) lParam;

            lprc->left = prbb->x;
            lprc->top = prbb->y;
            lprc->right = prbb->x + prbb->cx;
            lprc->bottom = prbb->y + prbb->cy;

            return(TRUE);
        }
        break;

    case RB_HITTEST:
        return(RBHitTest(prb, (LPRBHITTESTINFO) lParam));

    case RB_SIZETORECT:
        return RBSizeBarToRect(prb, (LPRECT)lParam);

    case RB_BEGINDRAG:

        if (RB_ISVALIDINDEX(prb, wParam)) {
            // -1 means do it yourself.
            // -2 means use what you had saved before
            if (lParam != (LPARAM)-2) {
                if (lParam == (LPARAM)-1) {
                    GetMessagePosClient(prb->ci.hwnd, &prb->ptCapture);
                } else {
                    prb->ptCapture.x = GET_X_LPARAM(lParam);
                    prb->ptCapture.y = GET_Y_LPARAM(lParam);
                }
                if (prb->ci.style & CCS_VERT) 
                    SWAP(prb->ptCapture.x, prb->ptCapture.y, int);
            }

            prb->xStart = RBGETBAND(prb, (UINT)wParam)->x;

            RBOnBeginDrag(prb, (UINT)wParam);
        }
        break;
        
    case RB_GETBARHEIGHT:
        return RBGETBARHEIGHT(prb);
        
    case RB_ENDDRAG:
        RBOnBeginDrag(prb, (UINT)-1);
        break;
        
    case RB_DRAGMOVE:
        if (prb->iCapture != -1) {
            if (lParam == (LPARAM)-1) {
                lParam = GetMessagePosClient(prb->ci.hwnd, NULL);
            }
            RBDragBand(prb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        }
        break;
        
    case RB_MINIMIZEBAND:
        RBMinimizeBand(prb, (UINT) wParam,FALSE);
        break;

    case RB_MAXIMIZEBAND:
        RBMaximizeBand(prb, (UINT)wParam, BOOLFROMPTR(lParam),FALSE);
        break;

    case RB_MOVEBAND:
        if (!RB_ISVALIDINDEX(prb,wParam) || !RB_ISVALIDINDEX(prb,lParam))
            break;
        return RBMoveBand(prb, (UINT) wParam, (UINT) lParam);

    case RB_GETDROPTARGET:
        if (!prb->hDragProxy)
            prb->hDragProxy = CreateDragProxy(prb->ci.hwnd, RebarDragCallback, FALSE);

        GetDragProxyTarget(prb->hDragProxy, (IDropTarget**)lParam);
        break;

    case RB_GETCOLORSCHEME:
        {
            LPCOLORSCHEME lpclrsc = (LPCOLORSCHEME) lParam;
            if (lpclrsc) {
                if (lpclrsc->dwSize == sizeof(COLORSCHEME))
                    *lpclrsc = prb->clrsc;
            }
            return (LRESULT) lpclrsc;
        }

    case RB_SETCOLORSCHEME:
        if (lParam) {
            if (((LPCOLORSCHEME) lParam)->dwSize == sizeof(COLORSCHEME)) {
                prb->clrsc.clrBtnHighlight = ((LPCOLORSCHEME) lParam)->clrBtnHighlight;
                prb->clrsc.clrBtnShadow = ((LPCOLORSCHEME) lParam)->clrBtnShadow;        
                InvalidateRect(hwnd, NULL, FALSE);
                if (prb->ci.style & WS_BORDER)
                    CCInvalidateFrame(hwnd);
            }
        }
        break;

    case RB_PUSHCHEVRON:
        if (RB_ISVALIDINDEX(prb, wParam)) {
            PRBB prbb = RBGETBAND(prb, wParam);
            RBOnPushChevron(hwnd, prb, prbb, lParam);
        }
        break;

    default:
        {
            LRESULT lres;
            if (CCWndProc(&prb->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }
        
CallDWP:
        return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\rlefile.h ===
//
//  handle AVI RLE files with custom code.
//
//  use this code to deal with .AVI files without the MCIAVI runtime
//
//  restrictions:
//
//          AVI file must be a native DIB format (RLE or none)
//          AVI file must fit into memory.
//

#define FOURCC DWORD
#if defined(WIN32) && !defined(WINNT)
#include <vfw.h>
#else
// HACK to build for now under NT
#include <avifmt.h>
#endif

#ifdef WIN32
#define PTR
#else
#define PTR _huge   /* or FAR */
#endif

typedef struct _RLEFILE {
    int                 NumFrames;      // number of frames
    int                 Width;          // width in pixels
    int                 Height;         // height in pixels
    int                 Rate;           // mSec per frame

    HPALETTE            hpal;           // palete for drawing

    HANDLE              hRes;           // resource handle
    LPVOID              pFile;          // bits of file.

    int                 iFrame;         // current frame
    int                 iKeyFrame;      // nearest key
    int                 nFrame;         // index pos of frame.
    LPVOID              pFrame;         // current frame data
    DWORD               cbFrame;        // size in bytes of frame

    DWORD               FullSizeImage;  // full-frame size
    BITMAPINFOHEADER    bi;             // DIB format
    DWORD               rgbs[256];      // the colors
    MainAVIHeader PTR  *pMainHeader;    // main header
    int                 iStream;        // stream number of video
    AVIStreamHeader PTR*pStream;        // video stream
    LPBITMAPINFOHEADER  pFormat;        // format of video stream
    LPVOID              pMovie;         // movie chunk
    UNALIGNED AVIINDEXENTRY PTR * pIndex; // master index

}   RLEFILE;

extern BOOL RleFile_OpenFromFile(RLEFILE *prle, LPCTSTR szFile);
extern BOOL RleFile_OpenFromResource(RLEFILE *prle, HINSTANCE hInstance, LPCTSTR szName, LPCTSTR szType);
extern BOOL RleFile_Close(RLEFILE  *prle);
extern BOOL RleFile_SetColor(RLEFILE  *prle, int iColor, COLORREF rgb);
extern BOOL RleFile_ChangeColor(RLEFILE  *prle, COLORREF rgbS, COLORREF rgbD);
extern BOOL RleFile_Seek(RLEFILE  *prle, int iFrame);
extern BOOL RleFile_Paint(RLEFILE  *prle, HDC hdc, int iFrame, int x, int y);
extern BOOL RleFile_Draw(RLEFILE  *prle, HDC hdc, int iFrame, int x, int y);

#define RleFile_New()       ((RLEFILE *)LocalAlloc(LPTR, sizeof(RLEFILE)))
#define RleFile_Free(pavi)  (RleFile_Close(pavi), LocalFree((HLOCAL)(pavi)))

#define RleFile_NumFrames(prle)     ((prle)->NumFrames)
#define RleFile_Width(prle)         ((prle)->Width)
#define RleFile_Height(prle)        ((prle)->Height)
#define RleFile_Rate(prle)          ((prle)->Rate)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\scdttime.h ===
#define INCRSYS_YEAR    0x0001
#define INCRSYS_MONTH   0x0002
#define INCRSYS_WEEK    0x0004
#define INCRSYS_DAY     0x0008
#define INCRSYS_HOUR    0x0010
#define INCRSYS_MINUTE  0x0020
#define INCRSYS_SECOND  0x0040

int GetWeekNumber(const SYSTEMTIME *pst, int dowFirst, int woyFirst);
int CmpDate(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2);
int CmpSystemtime(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2);
void IncrSystemTime(SYSTEMTIME *pstSrc, SYSTEMTIME *pstDest, LONG delta, LONG flags);
int GetDaysForMonth(int year, int month);
int GetStartDowForMonth(int year, int month);
DWORD DaysBetweenDates(const SYSTEMTIME *pstStart, const SYSTEMTIME *pstEnd);
int DowFromDate(const SYSTEMTIME *pst);

BOOL IsValidDate(const SYSTEMTIME *pst);
BOOL IsValidTime(const SYSTEMTIME *pst);
BOOL IsValidSystemtime(const SYSTEMTIME *pst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\rlefile.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  handle AVI RLE files with custom code.
//
//  use this code to deal with .AVI files without the MCIAVI runtime
//
//  restrictions:
//          AVI file must be a simple DIB format (RLE or none)
//          AVI file must fit into memory.
//
//  ToddLa
//
//////////////////////////////////////////////////////////////////////////


#include "ctlspriv.h"
extern "C" {
#include "rlefile.h"
}

#ifdef UNIX
#include <mwavi.h>
#include "unixstuff.h"
#endif

#include <lendian.hpp>

extern "C"
BOOL RleFile_Init(RLEFILE *prle, LPVOID pFile, HANDLE hRes, DWORD dwFileLen);

//////////////////////////////////////////////////////////////////////////
//
//////////////////////////////////////////////////////////////////////////

LPVOID LoadFile(LPCTSTR szFile, DWORD * pFileLength)
{
    LPVOID pFile;
    HANDLE hFile;
    HANDLE h;
    DWORD  FileLength;

#ifdef WIN32

#ifndef MAINWIN
    hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
#else
    // sunos5 does not want to map NFS files when there is locking on them
    hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
#endif
    if (hFile == INVALID_HANDLE_VALUE)
        return 0;

    FileLength = (LONG)GetFileSize(hFile, NULL);

    if (pFileLength)
       *pFileLength = FileLength ;

    h = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!h)
    {
        CloseHandle(hFile);
        return 0;
    }

    pFile = MapViewOfFile(h, FILE_MAP_READ, 0, 0, 0);
    CloseHandle(hFile);
    CloseHandle(h);

    if (pFile == NULL)
        return 0;
#else
    hFile = (HANDLE)_lopen(szFile, OF_READ);

    if (hFile == (HANDLE)-1)
        return 0;

    FileLength = _llseek((int)hFile, 0, SEEK_END);
    _llseek((int)hFile, 0, SEEK_SET);

    pFile = GlobalAllocPtr(GHND, FileLength);

    if (pFile && _hread((int)hFile, pFile, FileLength) != FileLength)
    {
        GlobalFreePtr(pFile);
        pFile = NULL;
    }
    _lclose((int)hFile);
#endif
    return pFile;
}


//////////////////////////////////////////////////////////////////////////
//
//  RleFile_OpenFromFile
//
//  load a .AVI file into memory and setup all of our pointers so we
//  know how to deal with it.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_OpenFromFile(RLEFILE *prle, LPCTSTR szFile)
{
    DWORD dwFileLen;
    LPVOID pFile;

    // MAKEINTRESOURCE() things can't come from files
    if (IS_INTRESOURCE(szFile))	
	return FALSE;

    if (pFile = LoadFile(szFile, &dwFileLen))
        return RleFile_Init(prle, pFile, NULL, dwFileLen);
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_OpenFromResource
//
//  load a .AVI file into memory and setup all of our pointers so we
//  know how to deal with it.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_OpenFromResource(RLEFILE *prle, HINSTANCE hInstance, LPCTSTR szName, LPCTSTR szType)
{
    HRSRC h;
    HANDLE hRes;

    // not a MAKEINTRESOURCE(), and points to NULL
#ifndef MAINWIN
    if (!IS_INTRESOURCE(szName) && (*szName == 0))
        return FALSE;
#else
    if (!MwIsIntegerResource(szName) && (*szName == 0))
	return FALSE;
#endif

    h = FindResource(hInstance, szName, szType);

    if (h == NULL)
        return FALSE;

    if (hRes = LoadResource(hInstance, h))
        return RleFile_Init(prle, LockResource(hRes), hRes, 0);
    else
        return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Close
//
//  nuke all stuff we did to open the file.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Close(RLEFILE *prle)
{
    if (prle->hpal)
        DeleteObject(prle->hpal);

    if (prle->pFile)
    {
#ifdef WIN32
        if (prle->hRes)
        {
#ifdef UNIX
            UnlockResource(prle->hRes);
#endif
            FreeResource(prle->hRes);
        }
        else
            UnmapViewOfFile(prle->pFile);
#else
        GlobalFreePtr(prle->pFile);
#endif
    }

#ifdef UNIX
    CHECK_FREE( prle->pStream );
    CHECK_FREE( prle->pFormat );
#endif

    prle->hpal = NULL;
    prle->pFile = NULL;
    prle->hRes = NULL;
    prle->pMainHeader = NULL;
    prle->pStream = NULL;
    prle->pFormat = NULL;
    prle->pMovie = NULL;
    prle->pIndex = NULL;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Init
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Init(RLEFILE *prle, LPVOID pFile, HANDLE hRes, DWORD dwFileLen)
{
    DWORD_LENDIAN UNALIGNED *pdw;
    DWORD_LENDIAN UNALIGNED *pdwEnd;
    DWORD dwRiff;
    DWORD dwType;
    DWORD dwLength;
    int stream;

    if (prle->pFile == pFile)
        return TRUE;

    RleFile_Close(prle);
    prle->pFile = pFile;
    prle->hRes = hRes;

    if (prle->pFile == NULL)
        return FALSE;

    //
    //  now that the file is in memory walk the memory image filling in
    //  interesting stuff.
    //
    pdw = (DWORD_LENDIAN UNALIGNED *)prle->pFile;
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

#ifndef UNIX
    if ((dwFileLen > 0) && (dwLength > dwFileLen)) {
        // File is physically shorter than the length written in its header.
        // Can't handle it.
        goto exit;
    }
#endif

    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
        goto exit;      // not even a RIFF file

    if (dwType != formtypeAVI)
        goto exit;      // not a AVI file

    pdwEnd = (DWORD_LENDIAN UNALIGNED *)((BYTE PTR *)pdw + dwLength-4);
    stream = 0;

    while (pdw < pdwEnd)
    {
        dwType = *pdw++;
        dwLength = *pdw++;

        switch (dwType)
        {
            case mmioFOURCC('L', 'I', 'S', 'T'):
                dwType = *pdw++;
                dwLength -= 4;

                switch (dwType)
                {
                    case listtypeAVIMOVIE:
                        prle->pMovie = (LPVOID)pdw;
                        break;

                    case listtypeSTREAMHEADER:
                    case listtypeAVIHEADER:
                        dwLength = 0;           // decend
                        break;

                    default:
                        break;                  // ignore
                }
                break;

            case ckidAVIMAINHDR:
            {
#ifdef UNIX
                MainAVIHeader mavih;
                prle->pMainHeader=&mavih;
                MwReadMainAVIHeader( (BYTE*) pdw,
                                     sizeof(*prle->pMainHeader),
                                     prle->pMainHeader );
#else
                prle->pMainHeader = (MainAVIHeader PTR *)pdw;
#endif
                prle->NumFrames = (int)prle->pMainHeader->dwTotalFrames;
                prle->Width     = (int)prle->pMainHeader->dwWidth;
                prle->Height    = (int)prle->pMainHeader->dwHeight;
                prle->Rate      = (int)(prle->pMainHeader->dwMicroSecPerFrame/1000);

                if (prle->pMainHeader->dwInitialFrames != 0)
                    goto exit;

                if (prle->pMainHeader->dwStreams > 2)
                    goto exit;

            }
                break;

            case ckidSTREAMHEADER:
            {
#ifdef UNIX
                AVIStreamHeader *paviSH;
#endif

                stream++;

                if (prle->pStream != NULL)
                    break;

#ifndef UNIX
                if (((AVIStreamHeader PTR *)pdw)->fccType != streamtypeVIDEO)
                    break;
#else
                paviSH = (AVIStreamHeader*) malloc(sizeof(AVIStreamHeader));
                if ( paviSH == NULL )
                    break;

                MwReadAVIStreamHeader( (BYTE*) pdw,sizeof(*paviSH),paviSH );
                if (paviSH->fccType != streamtypeVIDEO) {
                    CHECK_FREE( paviSH );
                    break;
                }
#endif

                prle->iStream = stream-1;

#ifndef UNIX
                prle->pStream = (AVIStreamHeader PTR*)pdw;
#else
                prle->pStream = paviSH;
#endif

                if (prle->pStream->dwFlags & AVISF_VIDEO_PALCHANGES)
                    goto exit;
            }
            break;

            case ckidSTREAMFORMAT:
                if (prle->pFormat != NULL)
                    break;

                if (prle->pStream == NULL)
                    break;

#ifdef UNIX
                prle->pFormat = (LPBITMAPINFOHEADER) malloc( dwLength );
                if ( prle->pFormat == NULL )
                   goto exit;

                MwReadBITMAPINFO( (BYTE*) pdw, dwLength,
                                  (BITMAPINFO*) prle->pFormat );
#else
                prle->pFormat = (LPBITMAPINFOHEADER)pdw;
#endif

                if (prle->pFormat->biSize != sizeof(BITMAPINFOHEADER))
                    goto exit;

                if (prle->pFormat->biCompression != 0 &&
                    prle->pFormat->biCompression != BI_RLE8)
                    goto exit;

                if (prle->pFormat->biWidth != prle->Width)
                    goto exit;

                if (prle->pFormat->biHeight != prle->Height)
                    goto exit;

                hmemcpy(&prle->bi, prle->pFormat, dwLength);
                prle->bi.biSizeImage = 0;
                prle->FullSizeImage = ((prle->bi.biWidth * prle->bi.biBitCount + 31) & ~31)/8U * prle->bi.biHeight;
                break;

            case ckidAVINEWINDEX:
                // we dont convert indexes because we dont know how many there are
                // but we will have to convert each usage of it
                prle->pIndex = (AVIINDEXENTRY PTR *)pdw;
                break;
        }

        pdw = (DWORD_LENDIAN *)((BYTE PTR *)pdw + ((dwLength+1)&~1));
    }

    //
    //  if the file has nothing in it we care about get out, note
    //  we dont need a index, we do need some data though.
    //
    if (prle->NumFrames == 0 ||
        prle->pMainHeader == NULL ||
        prle->pStream == NULL ||
        prle->pFormat == NULL ||
        prle->pMovie == NULL )
    {
        goto exit;
    }

    //
    //  if we cared about a palette we would create it here.
    //

    //
    //  file open'ed ok seek to the first frame.
    //
    prle->iFrame = -42;
    RleFile_Seek(prle, 0);
    return TRUE;

exit:
    RleFile_Close(prle);
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_ChangeColor
//
//  change the color table of the AVI
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_ChangeColor(RLEFILE *prle, COLORREF rgbS, COLORREF rgbD)
{
#ifndef UNIX

    DWORD dwS;
    DWORD dwD;
    DWORD PTR *ColorTable;
    int i;

    dwS = RGB(GetBValue(rgbS), GetGValue(rgbS), GetRValue(rgbS));
    dwD = RGB(GetBValue(rgbD), GetGValue(rgbD), GetRValue(rgbD));

    if (prle == NULL || prle->pFormat == NULL)
        return FALSE;

    ColorTable = (DWORD PTR *)((BYTE PTR *)&prle->bi + prle->bi.biSize);

    for (i=0; i<(int)prle->bi.biClrUsed; i++)
    {
        if (ColorTable[i] == dwS)
            ColorTable[i] = dwD;
    }

    return TRUE;

#else

    RGBQUAD dwS;
    RGBQUAD dwD;
    RGBQUAD PTR *ColorTable;
    int i;

    dwS.rgbRed      = GetRValue(rgbS);
    dwS.rgbGreen    = GetGValue(rgbS);
    dwS.rgbBlue     = GetBValue(rgbS);
    dwS.rgbReserved = 0;

    dwD.rgbRed   = GetRValue(rgbD);
    dwD.rgbGreen = GetGValue(rgbD);
    dwD.rgbBlue  = GetBValue(rgbD);

    // Support for CDE colormap index colors (davidd)
    dwD.rgbReserved = (BYTE)(rgbD >> 24);

    if (prle == NULL || prle->pFormat == NULL)
        return FALSE;

    ColorTable = (RGBQUAD PTR *)((BYTE PTR *)&prle->bi + prle->bi.biSize);

    for (i=0; i<(int)prle->bi.biClrUsed; i++)
    {
        if ((ColorTable[i].rgbRed == dwS.rgbRed) &&
	    (ColorTable[i].rgbGreen == dwS.rgbGreen) &&
	    (ColorTable[i].rgbBlue == dwS.rgbBlue)) {
            ColorTable[i] = dwD;
	}
    }

    return TRUE;
#endif

}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Seek
//
//  find the data for the specifed frame.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Seek(RLEFILE *prle, int iFrame)
{
    int n;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

#if 0
    if (iFrame == FRAME_CURRENT)
        iFrame = prle->iFrame;

    if (iFrame == FRAME_NEXT)
    {
        iFrame = prle->iFrame+1;
        if (iFrame >= prle->NumFrames)
            iFrame = 0;
    }

    if (iFrame == FRAME_PREV)
    {
        iFrame = prle->iFrame-1;
        if (iFrame == -1)
            iFrame = prle->NumFrames-1;
    }
#endif

    if (iFrame >= prle->NumFrames)
        return FALSE;

    if (iFrame < 0)
        return FALSE;

    if (iFrame == prle->iFrame)
        return TRUE;

    if (prle->iFrame >= 0 && prle->iFrame < iFrame)
    {
        n = prle->nFrame;       // start where you left off last time
    }
    else
    {
        n = -1;                 // start at the begining
        prle->iFrame = -1;      // current frame
        prle->iKeyFrame = 0;    // current key
    }

    while (prle->iFrame < iFrame)
    {
        n++;
        if (StreamFromFOURCC(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].ckid)) == (UINT)prle->iStream)
        {
            prle->iFrame++;         // new frame

            if ((long)(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwFlags)) & AVIIF_KEYFRAME)
                prle->iKeyFrame = prle->iFrame;     /* // new key frame */
        }
    }

    prle->nFrame = n;
/* warning this points to bitmap bits in wintel format ! */
    prle->pFrame = (BYTE PTR *)prle->pMovie +
	(int)(*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwChunkOffset)) + 4;
    prle->cbFrame = *(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].dwChunkLength);

    ASSERT( (DWORD)(*(DWORD_LENDIAN UNALIGNED *)&(((DWORD PTR *)prle->pFrame)[-1])) == (DWORD)prle->cbFrame);
    ASSERT( (DWORD)(*(DWORD_LENDIAN UNALIGNED *)&(((DWORD PTR *)prle->pFrame)[-2])) == (DWORD)*(DWORD_LENDIAN UNALIGNED *)(&prle->pIndex[n].ckid));

    prle->bi.biSizeImage = prle->cbFrame;

    if (prle->cbFrame == prle->FullSizeImage)
        prle->bi.biCompression = 0;
    else
        prle->bi.biCompression = BI_RLE8;
		
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Paint
//
//  draw the specifed frame, makes sure the entire frame is updated
//  dealing with non-key frames correctly.
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Paint(RLEFILE *prle, HDC hdc, int iFrame, int x, int y)
{
    int i;
    BOOL f;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (f = RleFile_Seek(prle, iFrame))
    {
        iFrame = prle->iFrame;

        for (i=prle->iKeyFrame; i<=iFrame; i++)
            RleFile_Draw(prle, hdc, i, x, y);
    }

    return f;
}

//////////////////////////////////////////////////////////////////////////
//
//  RleFile_Draw
//
//  draw the data for a specifed frame
//
//////////////////////////////////////////////////////////////////////////

extern "C"
BOOL RleFile_Draw(RLEFILE *prle, HDC hdc, int iFrame, int x, int y)
{
    BOOL f;

    if (prle == NULL || prle->pMovie == NULL)
        return FALSE;

    if (prle->hpal)
    {
        SelectPalette(hdc, prle->hpal, FALSE);
        RealizePalette(hdc);
    }

    if (f = RleFile_Seek(prle, iFrame))
    {
        if (prle->cbFrame > 0)
        {
            StretchDIBits(hdc,
                    x, y, prle->Width, prle->Height,
                    0, 0, prle->Width, prle->Height,
                    prle->pFrame, (LPBITMAPINFO)&prle->bi,
                    DIB_RGB_COLORS, SRCCOPY);
        }
    }

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\scdttime.c ===
#include "ctlspriv.h"
#include "scdttime.h"

// BUGBUG? remove references to 1750 and 1752 as they
// are not needed -- the minimal year we allow is 1753
// to avoid such problems. (We don't care about
// pre-revised-Gregorian dates! If you want to develop
// a history application, then you can deal with these problems)

int mpcdymoAccum[13] =
{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };

/*
 -    LIncrWord
 -
 *    Purpose:
 *        Increment (or decrement) an integer by a specified amount,
 *        given the constraints nMic and nMac.
 *        Returns the amount of carry into the following (or preceding)
 *        field, or zero if none.
 *
 *        Intended for use with incrementing date/times.
 *
 *    Arguments:
 *        pn        Pointer to integer to be modified.
 *        nDelta    Amount by which to modify *pn; may be positive,
 *                negative or zero.
 *        nMic    Minimum value for *pn;  if decrementing below this,
 *                a carry is performed.
 *        nMac    Maximum value for *pn;  if incrementing above this,
 *                a carry is performed.
 *
 *    Returns:
 *        Zero if modification done within constraints, otherwise the
 *        amount of carry (positive in incrementing, negative if
 *        decrementing).
 *
 */
LONG LIncrWord(WORD *pn, LONG nDelta, int nMic, int nMac)
    {
    LONG lNew, lIncr;

    lIncr = 0;
    lNew = *pn + nDelta;

    while (lNew >= nMac)
        {
        lNew -= nMac - nMic;
        lIncr++;
        }

    if (!lIncr)
        {
        while (lNew < nMic)
            {
            lNew += nMac - nMic;
            lIncr--;
            }
        }

    *pn = (WORD)lNew;

    return(lIncr);
    }

void IncrSystemTime(SYSTEMTIME *pstSrc, SYSTEMTIME *pstDest, LONG nDelta, LONG flag)
    {
    int cdyMon;

    if (pstSrc != pstDest)
        *pstDest = *pstSrc;

    switch (flag)
        {
        case INCRSYS_SECOND:
            if (!(nDelta = LIncrWord(&pstDest->wSecond, nDelta, 0, 60)))
                break;

        case INCRSYS_MINUTE:
            if (!(nDelta = LIncrWord(&pstDest->wMinute, nDelta, 0, 60)))
                break;

        case INCRSYS_HOUR:
            if (!(nDelta = LIncrWord(&pstDest->wHour, nDelta, 0, 24)))
                break;

        case INCRSYS_DAY:
IDTday:
            if (nDelta >= 0)
                {
                cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                while (pstDest->wDay + nDelta > cdyMon)
                    {
                    nDelta -= cdyMon + 1 - pstDest->wDay;
                    pstDest->wDay = 1;
                    IncrSystemTime(pstDest, pstDest, 1, INCRSYS_MONTH);
                    cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                    }
                }
            else
                {
                while (pstDest->wDay <= -nDelta)
                    {
                    nDelta += pstDest->wDay;
                    IncrSystemTime(pstDest, pstDest, -1, INCRSYS_MONTH);
                    cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                    pstDest->wDay = (WORD) cdyMon;
                    }
                }

            pstDest->wDay += (WORD)nDelta;
            break;

        case INCRSYS_MONTH:
            if (!(nDelta = LIncrWord(&pstDest->wMonth, nDelta, 1, 13)))
                {
                cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
                if (pstDest->wDay > cdyMon)
                    pstDest->wDay = (WORD) cdyMon;
                break;
                }

        case INCRSYS_YEAR:
            pstDest->wYear += (WORD)nDelta;
            cdyMon = GetDaysForMonth(pstDest->wYear, pstDest->wMonth);
            if (pstDest->wDay > cdyMon)
                pstDest->wDay = (WORD) cdyMon;
            break;

        case INCRSYS_WEEK:
            nDelta *= 7;
            goto IDTday;
            break;
        }
    }

CmpDate(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
    {
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else
        iRet = 0;

    return(iRet);
    }

CmpSystemtime(const SYSTEMTIME *pst1, const SYSTEMTIME *pst2)
    {
    int iRet;

    if (pst1->wYear < pst2->wYear)
        iRet = -1;
    else if (pst1->wYear > pst2->wYear)
        iRet = 1;
    else if (pst1->wMonth < pst2->wMonth)
        iRet = -1;
    else if (pst1->wMonth > pst2->wMonth)
        iRet = 1;
    else if (pst1->wDay < pst2->wDay)
        iRet = -1;
    else if (pst1->wDay > pst2->wDay)
        iRet = 1;
    else if (pst1->wHour < pst2->wHour)
        iRet = -1;
    else if (pst1->wHour > pst2->wHour)
        iRet = 1;
    else if (pst1->wMinute < pst2->wMinute)
        iRet = -1;
    else if (pst1->wMinute > pst2->wMinute)
        iRet = 1;
    else if (pst1->wSecond < pst2->wSecond)
        iRet = -1;
    else if (pst1->wSecond > pst2->wSecond)
        iRet = 1;
    else
        iRet = 0;

    return(iRet);
    }

/*
 -    CdyBetweenYmd
 -
 *    Purpose:
 *        Calculate the number of days between two dates as expressed
 *        in YMD's.
 *
 *    Parameters:
 *        pymdStart        start day of range.
 *        pymdEnd            end day of range.
 *
 *    Returns:
 *        Number of days between two dates.  The number
 *        of days does not include the starting day, but does include
 *        the last day. ie 1/24/1990-1/25/1990 = 1 day.
 */
DWORD DaysBetweenDates(const SYSTEMTIME *pstStart, const SYSTEMTIME *pstEnd)
    {
    DWORD cday;
    WORD yr;

    // Calculate number of days between the start month/day and the
    // end month/day as if they were in the same year - since cday
    // is unsigned, cday could be really large if the end month/day
    // is before the start month.day.
    // This will be cleared up when we account for the days between
    // the years.
    ASSERT(pstEnd->wMonth >= 1 && pstEnd->wMonth <= 12);
    cday = mpcdymoAccum[pstEnd->wMonth - 1] - mpcdymoAccum[pstStart->wMonth - 1] +
             pstEnd->wDay - pstStart->wDay;
    yr = pstStart->wYear;

    // Check to see if the start year is before the end year,
    // and if the end month is after February and
    // if the end year is a leap year, then add an extra day
    // for to account for Feb. 29 in the end year.
    if ( ((yr < pstEnd->wYear) || (pstStart->wMonth <= 2)) &&
         pstEnd->wMonth > 2 &&
        (pstEnd->wYear & 03) == 0 &&
        (pstEnd->wYear <= 1750 || pstEnd->wYear % 100 != 0 || pstEnd->wYear % 400 == 0))
        {
        cday++;
        }

    // Now account for the leap years in between the start and end dates
    // as well as accounting for the days in each year.
    if (yr < pstEnd->wYear)
        {
        // If the start date is before march and the start year is
        // a leap year then add an extra day to account for Feb. 29.
        if ( pstStart->wMonth <= 2 &&
            (yr & 03) == 0 &&
            (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
            {
            cday++;
            }

        // Account for the days in each year (disregarding leap years).
        cday += 365;
        yr++;

        // Keep on accounting for the days in each year including leap
        // years until we reach the end year.
        while (yr < pstEnd->wYear)
            {
            cday += 365;
            if ((yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
                cday++;
            yr++;
            }
        }

    return(cday);
    }

/*
 -    DowStartOfYrMo
 -
 *    Purpose:
 *        Find the day of the week the indicated month begins on
 *
 *    Parameters:
 *        yr        year, must be > 0
 *        mo        month, number 1-12
 *
 *    Returns:
 *        day of the week (0-6) on which the month begins
 *        (0 = Sunday, 1 = Monday etc.)
 */
int GetStartDowForMonth(int yr, int mo)
    {
    int dow;

    // we want monday = 0, sunday = 6
    // dow = 6 + (yr - 1) + ((yr - 1) >> 2);
    dow = 5 + (yr - 1) + ((yr - 1) >> 2);
    if (yr > 1752)
        dow += ((yr - 1) - 1600) / 400 - ((yr - 1) - 1700) / 100 - 11;
    else if (yr == 1752 && mo > 9)
        dow -= 11;
    dow += mpcdymoAccum[mo - 1];
    if (mo > 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        dow++;
    dow %= 7;

    return(dow);
    }

int DowFromDate(const SYSTEMTIME *pst)
    {
    int dow;

    dow = GetStartDowForMonth(pst->wYear, pst->wMonth);
    dow = (dow + pst->wDay - 1) % 7;

    return(dow);
    }

int GetDaysForMonth(int yr, int mo)
    {
    int cdy;

    if (yr == 1752 && mo == 9)
        return(19);
    cdy = mpcdymoAccum[mo] - mpcdymoAccum[mo - 1];
    if (mo == 2 && (yr & 03) == 0 && (yr <= 1750 || yr % 100 != 0 || yr % 400 == 0))
        cdy++;

    return(cdy);
    }

/*
 -    NweekNumber
 -
 *    Purpose:
 *        Calculates week number in which a given date occurs, based
 *        on a specified start-day of week.
 *        Adjusts based on how a calendar would show this week
 *        (ie. week 53 is probably week 1 on the calendar).
 *
 *    Arguments:
 *        pdtm            Pointer to date in question
 *        dowStartWeek    Day-of-week on which weeks starts (0 - 6).
 *
 *    Returns:
 *        Week number of the year, in which *pdtr occurs.
 *
 */
// TODO: this currently ignores woyFirst
// it uses the 1st week containing 4+ days as the first week (woyFirst = 2)
// need to make appropriate changes so it handles woyFirst = 0 and = 1...
int GetWeekNumber(const SYSTEMTIME *pst, int dowFirst, int woyFirst)
    {
    int day, ddow, ddowT, nweek;
    SYSTEMTIME st;
    
    st.wYear = pst->wYear;
    st.wMonth = 1;
    st.wDay = 1;

    ddow = GetStartDowForMonth(st.wYear, st.wMonth) - dowFirst;
    if (ddow < 0)
        ddow += 7;

    if (pst->wMonth == 1 && pst->wDay < 8 - ddow)
        {
        nweek = 0;
        }
    else
        {
        if (ddow)
            st.wDay = 8 - ddow;

        nweek = (DaysBetweenDates(&st, pst) / 7) + 1;
        }
    if (ddow && ddow <= 3)
        nweek++;

    // adjust if necessary for calendar
    if (!nweek)
        {
        if (!ddow)
            return(1);

        // check what week Dec 31 is on
        st.wYear--;
        st.wMonth = 12;
        st.wDay = 31;
        return(GetWeekNumber(&st, dowFirst, woyFirst));
        }
    else if (nweek >= 52)
        {
        ddowT = (GetStartDowForMonth(pst->wYear, pst->wMonth) +
                    pst->wDay - 1 + 7 -    dowFirst) % 7;
        day = pst->wDay + (7 - ddowT);
        if (day > 31 + 4)
            nweek = 1;
        }

    return(nweek);
    }

// ignores day of week and time-related fields...
// BUGBUG also validate years in range
BOOL IsValidDate(const SYSTEMTIME *pst)
    {
    int cDay;

    if (pst && pst->wMonth >= 1 && pst->wMonth <= 12)
        {
        cDay = GetDaysForMonth(pst->wYear, pst->wMonth);
        if (pst->wDay >= 1 && pst->wDay <= cDay)
            return(TRUE);
        }
    return(FALSE);
    }

// ignores milliseconds and date-related fields...
BOOL IsValidTime(const SYSTEMTIME *pst)
    {
    return(pst->wHour <= 23 &&
            pst->wMinute <= 59 &&
            pst->wSecond <= 59);
    }

// ignores day of week
BOOL IsValidSystemtime(const SYSTEMTIME *pst)
    {
    if (pst && pst->wMonth >= 1 && pst->wMonth <= 12)
        {
        int cDay = GetDaysForMonth(pst->wYear, pst->wMonth);
        if (pst->wDay >= 1 &&
            pst->wDay <= cDay &&
            pst->wHour <= 23 &&
            pst->wMinute <= 59 &&
            pst->wSecond <= 59 &&
            pst->wMilliseconds < 1000)
            return(TRUE);
        }
    return(FALSE);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\selrange.h ===
//-------------------------------------------------------------------
//
// File: SelRange.h
//
// Contents:
//    This file contians Selection Range handling definitions.
//
// History:
//    14-Oct-94   MikeMi   Created
//
//-------------------------------------------------------------------

#ifndef __SELRANGE_H__
#define __SELRANGE_H__

#include <windows.h>
#include <limits.h>

#define SELRANGE_MINVALUE  0
#define SELRANGE_MAXVALUE  LONG_MAX - 2
#define SELRANGE_ERROR      LONG_MAX



typedef HANDLE HSELRANGE;

#ifdef __cplusplus
extern "C"
{
#endif

ILVRange *LVRange_Create( );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\sources.inc ===
BUILD_PRIVLIB   = 1

SELFREGNAME     = $(O)\selfreg_comctl32.inf
NTTARGETFILE0   = $(SELFREGNAME)
MISCFILES       = $(MISCFILES) $(SELFREGNAME)

!include $(CCSHELL_DIR)\comctl32\v5\comctl32.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\comctl32\v5\comctl32.inc

NO_BROWSER_FILE = 1

SYNCHRONIZE_DRAIN = 1

TARGETLIBS      = $(SDK_LIB_PATH)\gdi32.lib             \
                  $(SDK_LIB_PATH)\kernel32.lib          \
                  $(SDK_LIB_PATH)\user32.lib            \
                  $(WINDOWS_LIB_PATH)\user32p.lib       \
                  $(CCSHELL_DIR)\lib\$(O)\shguid.lib    \
                  $(SDK_LIB_PATH)\advapi32.lib          \
                  $(CCSHELL_DIR)\lib\$(O)\shguidp.lib   \
                  $(SDK_LIB_PATH)\uuid.lib

DLLDEF          = $(O)\comctl32.def
PRIVDEF         = $(O)\comctlp.def
PRIVDEFSRC      = ..\comctl32.src

DLLENTRY        = LibMain

SYNCHRONIZE_DRAIN=1

LINKLIBS        = ..\ntcpp\$(O)\srccpp.lib    \
                  ..\nt5api\$(O)\apithk.lib   \
                  ..\ntc\$(O)\srcc.lib        \
                  $(CCSHELL_DIR)\lib\$(O)\stock4.lib                  

SOURCES         = ..\olestuff.cpp   \
                  ..\commctrl.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\selrange.cpp ===
//-------------------------------------------------------------------
//
// File: SelRange.cpp
//
// Contents:
//      This file contians Selection Range handling code.
//
//-------------------------------------------------------------------

#include "ctlspriv.h"
#include "selrange.h"
#include "stdio.h"
#include <shguidp.h>

#define MINCOUNT 6      // number of sel ranges to start with amd maintain
#define GROWSIZE 150    // percent to grow when needed

#define COUNT_SELRANGES_NONE 2     // When count of selranges really means none

typedef struct tag_SELRANGEITEM
{
    LONG iBegin;
    LONG iEnd;
} SELRANGEITEM, *PSELRANGEITEM;


class CLVRange : public ILVRange

{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** ILVRange methods ***
    STDMETHODIMP IncludeRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP ExcludeRange(LONG iBegin, LONG iEnd);    
    STDMETHODIMP InvertRange(LONG iBegin, LONG iEnd);
    STDMETHODIMP InsertItem(LONG iItem);
    STDMETHODIMP RemoveItem(LONG iItem);

    STDMETHODIMP Clear();
    STDMETHODIMP IsSelected(LONG iItem);
    STDMETHODIMP IsEmpty();
    STDMETHODIMP NextSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP NextUnSelected(LONG iItem, LONG *piItem);
    STDMETHODIMP CountIncluded(LONG *pcIncluded);

protected:
    // Helper Functions.
    friend ILVRange *LVRange_Create();
                CLVRange();
                ~CLVRange();

    BOOL        _Enlarge();
    BOOL        _Shrink();
    BOOL        _InsertRange(LONG iAfterItem, LONG iBegin, LONG iEnd);
    HRESULT     _RemoveRanges(LONG iStartItem, LONG iStopItem, LONG *p);
    BOOL        _FindValue(LONG Value, LONG* piItem);
    void        _InitNew();

    int           _cRef;
    PSELRANGEITEM _VSelRanges;  // Vector of sel ranges
    LONG          _cSize;       // size of above vector in sel ranges
    LONG          _cSelRanges;  // count of sel ranges used
    LONG          _cIncluded;   // Count of Included items...
};

//-------------------------------------------------------------------
//
// Function: _Enlarge
//
// Summary:
//      This will enlarge the number of items the Sel Range can have.
//
// Arguments:
//      PSELRANGE [in]  - SelRange to Enlarge
//
// Return: FALSE if failed.
//
// Notes: Though this function may fail, pselrange structure is still valid
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_Enlarge()
{
    LONG cNewSize;
    PSELRANGEITEM pTempSelRange;
    BOOL frt = FALSE;


    cNewSize = _cSize * GROWSIZE / 100;
    pTempSelRange = (PSELRANGEITEM) GlobalReAlloc( (HGLOBAL)_VSelRanges,
                                                   cNewSize * sizeof( SELRANGEITEM ),
                                                   GMEM_ZEROINIT | GMEM_MOVEABLE );
    if (NULL != pTempSelRange)
    {
        _VSelRanges = pTempSelRange;
        _cSize = cNewSize;
        frt = TRUE;
    }
    return( frt );
}

//-------------------------------------------------------------------
//
// Function: _Shrink
//
// Summary:
//      This will reduce the number of items the Sel Range can have.
//
// Arguments:
//
// Return: FALSE if failed
//
// Notes: Shrink only happens when a significant size below the next size
//  is obtained and the new size is at least the minimum size.
//      Though this function may fail, pselrange structure is still valid
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_Shrink()
{
    LONG cNewSize;
    LONG cTriggerSize;
    PSELRANGEITEM pTempSelRange;
    BOOL frt = TRUE;


    // check if we are below last grow area by a small percent
    cTriggerSize = _cSize * 90 / GROWSIZE;
    cNewSize = _cSize * 100 / GROWSIZE;

    if ((_cSelRanges < cTriggerSize) && (cNewSize >= MINCOUNT))
    {
        pTempSelRange = (PSELRANGEITEM) GlobalReAlloc( (HGLOBAL)_VSelRanges,
                                                       cNewSize * sizeof( SELRANGEITEM ),
                                                       GMEM_ZEROINIT | GMEM_MOVEABLE );
        if (NULL != pTempSelRange)
        {
            _VSelRanges = pTempSelRange;
            _cSize = cNewSize;
        }
        else
        {
            frt = FALSE;
        }
    }
    return( frt );
}

//-------------------------------------------------------------------
//
// Function: _InsertRange
//
// Summary:
//      inserts a single range item into the range vector       
//
// Arguments:
//      iAfterItem [in] - Index to insert range after, -1 means insert as first item
//      iBegin [in]     - begin of range
//      iEnd [in]       - end of the range
//
// Return:
//      TRUE if succesful, otherwise FALSE
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_InsertRange(LONG iAfterItem,
                             LONG iBegin,
                             LONG iEnd )
{
    LONG iItem;
    BOOL frt = TRUE;

    ASSERT( iAfterItem >= -1 );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd >= iBegin );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );
    ASSERT( _cSelRanges < _cSize );

    // shift all over one
    for (iItem = _cSelRanges; iItem > iAfterItem + 1; iItem--)
    {
        _VSelRanges[iItem] = _VSelRanges[iItem-1];
    }
    _cSelRanges++;

    // make the insertion
    _VSelRanges[iAfterItem+1].iBegin = iBegin;
    _VSelRanges[iAfterItem+1].iEnd = iEnd;

    // make sure we have room next time
    if (_cSelRanges == _cSize)
    {
        frt = _Enlarge();
    }
    return( frt );
}

//-------------------------------------------------------------------
//
// Function: _RemoveRanges
//
// Summary:
//      Removes all ranged between and including the speicifed indexes      
//
// Arguments:
//      iStartItem [in] - Index to start removal
//      iStopItem [in]  - Index to stop removal
//
// Return:
//      SELRANGE_ERROR on memory allocation error
//      The number of items that are unselected by this removal
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::_RemoveRanges(LONG iStartItem, LONG iStopItem, LONG *pc )
{
    LONG iItem;
    LONG diff;
    LONG cUnSelected = 0;
    HRESULT hres = S_OK;

    ASSERT( iStartItem > 0 );
    ASSERT( iStopItem >= iStartItem );
    ASSERT( iStartItem < _cSelRanges - 1 );
    ASSERT( iStopItem < _cSelRanges - 1 );
    
    diff = iStopItem - iStartItem + 1;
        
    for (iItem = iStartItem; iItem <= iStopItem; iItem++)
        cUnSelected += _VSelRanges[iItem].iEnd -
                       _VSelRanges[iItem].iBegin + 1;

    // shift all over the difference
    for (iItem = iStopItem+1; iItem < _cSelRanges; iItem++, iStartItem++)
        _VSelRanges[iStartItem] = _VSelRanges[iItem];

    _cSelRanges -= diff;
    
    if (!_Shrink())
    {
        hres = E_FAIL;
    }
    else if (pc)
        *pc = cUnSelected;
    return( hres );
}


//-------------------------------------------------------------------
//
// Function: SelRange_FindValue
//
// Summary:
//      This function will search the ranges for the value, returning true
//  if the value was found within a range.  The piItem will contain the
//  the index at which it was found or the index before where it should be
//  The piItem may be set to -1, meaning that there are no ranges in the list
//      This functions uses a non-recursive binary search algorithm.
//
// Arguments:
//      piItem [out]    - Return of found range index, or one before
//      Value [in]      - Value to find within a range
//
// Return: True if found, False if not found
//
// Notes: The piItem will return one before if return is false.
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

BOOL CLVRange::_FindValue(LONG Value, LONG* piItem )
{
    LONG First;
    LONG Last;
    LONG Item;
    BOOL fFound = FALSE;

    ASSERT( piItem );
    ASSERT( _cSize >= COUNT_SELRANGES_NONE );
    ASSERT( Value >= SELRANGE_MINVALUE );
    ASSERT( Value <= SELRANGE_MAXVALUE );
    

    First = 0;
    Last = _cSelRanges - 1;
    Item = Last / 2;

    do
    {
        if (_VSelRanges[Item].iBegin > Value)
        {   // Value before this Item
            Last = Item;
            Item = (Last - First) / 2 + First;
            if (Item == Last)
            {
                Item = First;   
                break;
            }
        }
        else if (_VSelRanges[Item].iEnd < Value)
        {   // Value after this Item
            First = Item;
            Item = (Last - First) / 2 + First;
            if (Item == First)
            {
                break;
            }
        }
        else
        {   // Value at this Item
            fFound = TRUE;
        }
    } while (!fFound);

    *piItem = Item;
    return( fFound );
}

//-------------------------------------------------------------------
//
// Function: _InitNew
//
// Summary:
//      This function will initialize a SelRange object.
//
// Arguments:
//
// Return:
//
// Notes:
//              
// History:
//      18-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

void CLVRange::_InitNew()
{
    _cSize = MINCOUNT;
    _cSelRanges = COUNT_SELRANGES_NONE;

    _VSelRanges[0].iBegin = LONG_MIN;
    // -2 and +2 below are to stop consecutive joining of end markers
    _VSelRanges[0].iEnd = SELRANGE_MINVALUE - 2;  
    _VSelRanges[1].iBegin =  SELRANGE_MAXVALUE + 2;
    _VSelRanges[1].iEnd = SELRANGE_MAXVALUE + 2;
    _cIncluded = 0;
}

//-------------------------------------------------------------------
//
// Function: SelRange_Create
//
// Summary:
//      This function will create and initialize a SelRange object.
//
// Arguments:
//
// Return: HSELRANGE that is created or NULL if it failed.
//
// Notes:
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

ILVRange *LVRange_Create( )
{
    CLVRange *pselrange = new CLVRange;

    if (NULL != pselrange)
    {
        pselrange->_VSelRanges = (PSELRANGEITEM) GlobalAlloc( GPTR,
                                       sizeof( SELRANGEITEM ) * MINCOUNT );
        if (NULL != pselrange->_VSelRanges)
        {
            pselrange->_InitNew();
        }
        else
        {
            delete pselrange;
            pselrange = NULL;
        }
    }

    return( pselrange? SAFECAST(pselrange, ILVRange*) : NULL);
}


//-------------------------------------------------------------------
//
// Function: Constructor
//
//-------------------------------------------------------------------
CLVRange::CLVRange()
{
    _cRef = 1;
}

//-------------------------------------------------------------------
//
// Function: Destructor
//
//-------------------------------------------------------------------
CLVRange::~CLVRange()
{
    GlobalFree( _VSelRanges );
}


//-------------------------------------------------------------------
//
// Function: QueryInterface
//
//-------------------------------------------------------------------
HRESULT CLVRange::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_ILVRange) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, ILVRange *);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

//-------------------------------------------------------------------
//
// Function: AddRef
//
//-------------------------------------------------------------------
ULONG CLVRange::AddRef()
{
    return ++_cRef;
}

//-------------------------------------------------------------------
//
// Function: Release
//
//-------------------------------------------------------------------
ULONG CLVRange::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

                
//-------------------------------------------------------------------
//
// Function: IncludeRange
//
// Summary:
//      This function will include the range defined into the current
//  ranges, compacting as needed.
//
// Arguments:
//      hselrange [in]  - Handle to the SelRange
//      iBegin [in]     - Begin of new range
//      iEnd [in]       - End of new range
//
// Notes:
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::IncludeRange(LONG iBegin, LONG iEnd )
{
    LONG iFirst;   // index before or contains iBegin value
    LONG iLast;    // index before or contains iEnd value
    BOOL fExtendFirst;  // do we extend the iFirst or create one after it
    LONG iRemoveStart;  // start of ranges that need to be removed
    LONG iRemoveFinish; // end of ranges that need to be removed

    LONG iNewEnd;   // calculate new end value as we go
    BOOL fEndFound; // was the iEnd found in a range already
    BOOL fBeginFound; // was the iEnd found in a range already

    LONG cSelected = 0;
    HRESULT hres = S_OK;

    ASSERT( iEnd >= iBegin );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );

    // find approximate locations
    fBeginFound = _FindValue( iBegin, &iFirst );
    fEndFound = _FindValue( iEnd, &iLast );


    //
    // Find First values
    //
    // check for consecutive End-First values
    if ((_VSelRanges[iFirst].iEnd == iBegin - 1) ||
        (fBeginFound))
    {
        // extend iFirst
        fExtendFirst = TRUE;
        iRemoveStart = iFirst + 1;  
    }
    else
    {   
        // create one after the iFirst
        fExtendFirst = FALSE;
        iRemoveStart = iFirst + 2;
    }

    //
    // Find Last values
    //
    if (fEndFound)
    {
        // Use [iLast].iEnd value
        iRemoveFinish = iLast;
        iNewEnd = _VSelRanges[iLast].iEnd;

    }
    else
    {
        // check for consecutive First-End values
        if (_VSelRanges[iLast + 1].iBegin == iEnd + 1)
        {
            // Use [iLast + 1].iEnd value
            iNewEnd = _VSelRanges[iLast+1].iEnd;
            iRemoveFinish = iLast + 1;
        }
        else
        {
            // Use iEnd value
            iRemoveFinish = iLast;
            iNewEnd = iEnd;
        }
    }

    //
    // remove condenced items if needed
    //
    if (iRemoveStart <= iRemoveFinish)
    {
        LONG cChange;

        hres = _RemoveRanges(iRemoveStart, iRemoveFinish, &cChange );
        if (FAILED(hres))
            return hres;
        else
        {
            cSelected -= cChange;
        }
    }
                
    //
    // insert item and reset values as needed
    //          
    if (fExtendFirst)
    {
        cSelected += iNewEnd - _VSelRanges[iFirst].iEnd;
        _VSelRanges[iFirst].iEnd = iNewEnd;   
    }
    else
    {
        if (iRemoveStart > iRemoveFinish + 1)
        {
            cSelected += iEnd - iBegin + 1;
            // create one
            if (!_InsertRange(iFirst, iBegin, iNewEnd ))
            {
                hres = E_FAIL;
            }
        }       
        else
        {
            cSelected += iNewEnd - _VSelRanges[iFirst+1].iEnd;
            cSelected += _VSelRanges[iFirst+1].iBegin - iBegin;
            // no need to create one since the Removal would have left us one
            _VSelRanges[iFirst+1].iEnd = iNewEnd; 
            _VSelRanges[iFirst+1].iBegin = iBegin;
        }
    }
    
    _cIncluded += cSelected;
    return( hres );
}



//-------------------------------------------------------------------
//
// Function: SelRange_ExcludeRange
//
// Summary:
//      This function will exclude the range defined from the current
//  ranges, compacting and enlarging as needed.
//
// Arguments:
//      hselrange [in]  - Handle to the SelRange
//      iBegin [in]     - Begin of range to remove
//      iEnd [in]       - End of range to remove
//
// Return:
//      SELRANGE_ERROR if memory allocation error
//      the number actual items that changed state
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::ExcludeRange( LONG iBegin, LONG iEnd )
{
    LONG iFirst;   // index before or contains iBegin value
    LONG iLast;    // index before or contains iEnd value
    LONG iRemoveStart;  // start of ranges that need to be removed
    LONG iRemoveFinish; // end of ranges that need to be removed

    LONG iFirstNewEnd;  // calculate new end value as we go
    BOOL fBeginFound; // was the iBegin found in a range already
    BOOL fEndFound;   // was the iEnd found in a range already
    LONG cUnSelected = 0;
    HRESULT hres = S_OK;

    ASSERT( iEnd >= iBegin );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );

    // find approximate locations
    fBeginFound = _FindValue( iBegin, &iFirst );
    fEndFound = _FindValue( iEnd, &iLast );

    //
    // Find First values
    //

    // start removal after first
    iRemoveStart = iFirst + 1;
    // save FirstEnd as we may need to modify it
    iFirstNewEnd = _VSelRanges[iFirst].iEnd;

    if (fBeginFound)
    {
        // check for complete removal of first
        //    (first is a single selection or match?)
        if (_VSelRanges[iFirst].iBegin == iBegin)
        {
            iRemoveStart = iFirst;  
        }
        else
        {
            // otherwise truncate iFirst
            iFirstNewEnd = iBegin - 1;
        }
    }
    
    //
    // Find Last values
    //
                
    // end removal on last
    iRemoveFinish = iLast;

    if (fEndFound)
    {
        // check for complete removal of last
        //   (first/last is a single selection or match?)
        if (_VSelRanges[iLast].iEnd != iEnd)
        {   
            if (iFirst == iLast)
            {
                // split
                if (!_InsertRange(iFirst, iEnd + 1, _VSelRanges[iFirst].iEnd ))
                {
                    return( E_FAIL );
                }
                cUnSelected -= _VSelRanges[iFirst].iEnd - iEnd;
            }
            else
            {
                // truncate Last
                iRemoveFinish = iLast - 1;
                cUnSelected += (iEnd + 1) - _VSelRanges[iLast].iBegin;
                _VSelRanges[iLast].iBegin = iEnd + 1;
            }
        }
    }

    // Now set the new end, since Last code may have needed the original values
    cUnSelected -= iFirstNewEnd - _VSelRanges[iFirst].iEnd;
    _VSelRanges[iFirst].iEnd = iFirstNewEnd;


    //
    // remove items if needed
    //
    if (iRemoveStart <= iRemoveFinish)
    {
        LONG cChange;

        if (SUCCEEDED(hres = _RemoveRanges(iRemoveStart, iRemoveFinish, &cChange )))
            cUnSelected += cChange;
    }

    _cIncluded -= cUnSelected;
    return( hres );
}

//-------------------------------------------------------------------
//
// Function: SelRange_Clear
//
// Summary:
//      This function will remove all ranges within the SelRange object.
//
// Arguments:
//      hselrange [in]  - the hselrange object to clear
//
// Return:  FALSE if failed.
//
// Notes:
//      This function may return FALSE on memory allocation problems, but
//  will leave the SelRange object in the last state before this call.  
//
// History:
//      14-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::Clear()
{
    PSELRANGEITEM pNewItems;
    HRESULT hres = S_OK;

    pNewItems = (PSELRANGEITEM) GlobalAlloc( GPTR,
                                       sizeof( SELRANGEITEM ) * MINCOUNT );
    if (NULL != pNewItems)
    {
        GlobalFree( _VSelRanges );
        _VSelRanges = pNewItems;

        _InitNew();
    }
    else
    {
        hres = E_FAIL;
    }
    return( hres );
}

//-------------------------------------------------------------------
//
// Function: SelRange_IsSelected
//
// Summary:
//      This function will return if the value iItem is within a
//  selected range.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to check for
//
// Return:  TRUE if selected, FALSE if not.
//
// Notes:
//
// History:
//      17-Oct-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::IsSelected( LONG iItem )
{   
    LONG iFirst;

    ASSERT( iItem >= 0 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    return( _FindValue( iItem, &iFirst ) ? S_OK : S_FALSE);
}


//-------------------------------------------------------------------
//
// Function: SelRange_IsEmpty
//
// Summary:
//      This function will return TRUE if the range is empty
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//
// Return:  TRUE if empty
//
// Notes:
//
// History:
//
//-------------------------------------------------------------------
HRESULT CLVRange::IsEmpty()
{   
    return (_cSelRanges == COUNT_SELRANGES_NONE)? S_OK : S_FALSE;
}

HRESULT CLVRange::CountIncluded(LONG *pcIncluded)
{
    *pcIncluded = _cIncluded;
    return S_OK;
}


//-------------------------------------------------------------------
//
// Function: SelRange_InsertItem
//
// Summary:
//      This function will insert a unselected item at the location,
//      which will push all selections up one index.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to check for
//
// Return:
//      False on memory allocation error
//      otherwise TRUE
//
// Notes:
//
// History:
//      20-Dec-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::InsertItem( LONG iItem )
{
    LONG iFirst;
    LONG i;
    LONG iBegin;
    LONG iEnd;

    ASSERT( iItem >= 0 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (_FindValue( iItem, &iFirst ) )
    {
        // split it
        if ( _VSelRanges[iFirst].iBegin == iItem )
        {
            // but don't split if starts with value
            iFirst--;
        }
        else
        {
            if (!_InsertRange(iFirst, iItem, _VSelRanges[iFirst].iEnd ))
            {
                return( E_FAIL );
            }
            _VSelRanges[iFirst].iEnd = iItem - 1;
        }
    }

    // now walk all ranges past iFirst, incrementing all values by one
    for (i = _cSelRanges-2; i > iFirst; i--)
    {
        iBegin = _VSelRanges[i].iBegin;
        iEnd = _VSelRanges[i].iEnd;

        iBegin = min( SELRANGE_MAXVALUE, iBegin + 1 );
        iEnd = min( SELRANGE_MAXVALUE, iEnd + 1 );

        _VSelRanges[i].iBegin = iBegin;
        _VSelRanges[i].iEnd = iEnd;
    }
    return( S_OK );
}

//-------------------------------------------------------------------
//
// Function: SelRange_RemoveItem
//
// Summary:
//      This function will remove an item at the location,
//      which will pull all selections down one index.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to check for
//      pfWasSelected [out] - was the removed item selected before the removal
//
// Return:
//      TRUE if the item was removed
//      FALSE if the an error happend
//
// Notes:
//
// History:
//      20-Dec-94   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::RemoveItem(LONG iItem )
{
    LONG iFirst;
    LONG i;
    LONG iBegin;
    LONG iEnd;
    HRESULT hres = S_OK;

    ASSERT( iItem >= SELRANGE_MINVALUE );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (_FindValue( iItem, &iFirst ) )
    {
        // item within, change the end value
        iEnd = _VSelRanges[iFirst].iEnd;
        iEnd = min( SELRANGE_MAXVALUE, iEnd - 1 );
        _VSelRanges[iFirst].iEnd = iEnd;

        _cIncluded--;
    }
    else
    {
        // check for merge situation
        if ((iFirst < _cSelRanges - 1) &&
            (_VSelRanges[iFirst].iEnd == iItem - 1) &&
            (_VSelRanges[iFirst+1].iBegin == iItem + 1))
        {
            _VSelRanges[iFirst].iEnd =
                    _VSelRanges[iFirst + 1].iEnd - 1;
            if (FAILED(hres = _RemoveRanges(iFirst + 1, iFirst + 1, NULL )))
                return( hres );
        }
    }

    // now walk all ranges past iFirst, decrementing all values by one
    for (i = _cSelRanges-2; i > iFirst; i--)
    {
        iBegin = _VSelRanges[i].iBegin;
        iEnd = _VSelRanges[i].iEnd;

        iBegin = min( SELRANGE_MAXVALUE, iBegin - 1 );
        iEnd = min( SELRANGE_MAXVALUE, iEnd - 1 );

        _VSelRanges[i].iBegin = iBegin;
        _VSelRanges[i].iEnd = iEnd;
    }
    return( hres );
}

//-------------------------------------------------------------------
//
// Function: NextSelected
//
// Summary:
//      This function will start with given item and find the next
//      item that is selected.  If the given item is selected, that
//      item number will be returned.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to start check at
//
// Return:
//      -1 if none found, otherwise the item
//
// Notes:
//
// History:
//      04-Jan-95   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::NextSelected( LONG iItem, LONG *piItem )
{
    LONG i;

    ASSERT( iItem >= SELRANGE_MINVALUE );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (!_FindValue( iItem, &i ) )
    {
        i++;
        if (i < _cSelRanges-1)
        {
            iItem = _VSelRanges[i].iBegin;
        }
        else
        {
            iItem = -1;
        }
    }

    ASSERT( iItem >= -1 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );
    *piItem = iItem;
    return S_OK;
}

//-------------------------------------------------------------------
//
// Function: NextUnSelected
//
// Summary:
//      This function will start with given item and find the next
//      item that is not selected.  If the given item is not selected, that
//      item number will be returned.
//
// Arguments:
//      hselrange [in]  - the hselrange object to use
//      iItem [in]      - value to start check at
//
// Return:
//      -1 if none found, otherwise the item
//
// Notes:
//
// History:
//      04-Jan-95   MikeMi  Created
//
//-------------------------------------------------------------------

HRESULT CLVRange::NextUnSelected( LONG iItem, LONG *piItem )
{
    LONG i;

    ASSERT( iItem >= SELRANGE_MINVALUE );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    if (_FindValue( iItem, &i ) )
    {
        if (i < _cSelRanges-1)
        {
            iItem = _VSelRanges[i].iEnd + 1;
            if (iItem > SELRANGE_MAXVALUE)
            {
                iItem = -1;
            }
        }
        else
        {
            iItem = -1;
        }
    }

    ASSERT( iItem >= -1 );
    ASSERT( iItem <= SELRANGE_MAXVALUE );

    *piItem = iItem;
    return S_OK;
}

//-------------------------------------------------------------------
//
// Function: InvertRange
//
// Summary:
//      This function will invert the range defined from the current
//  ranges, compacting and enlarging as needed.
//
// Arguments:
//      iBegin [in]     - Begin of range to invert
//      iEnd [in]       - End of range to invert
//
// Return:
//      SELRANGE_ERROR on memory error
//      The difference in items selected from previous to current.
//      negative values means less items are selected in that range now.
//
// Notes:
//
// History:
//      13-Dec-95   MikeMi  Created
//
//-------------------------------------------------------------------

LONG CLVRange::InvertRange( LONG iBegin, LONG iEnd )
{
    LONG iFirst;   // index before or contains iBegin value
    BOOL fSelect;  // are we selecting or unselecting
    LONG iTempE;
    LONG iTempB;
    HRESULT hres = S_OK;

    ASSERT( iEnd >= iBegin );
    ASSERT( iBegin >= SELRANGE_MINVALUE );
    ASSERT( iEnd <= SELRANGE_MAXVALUE );

    // find if first is selected or not
    fSelect = !_FindValue( iBegin, &iFirst );
    
    iTempE = iBegin - 1;

    do
    {
        iTempB = iTempE + 1;

        if (fSelect)
            NextSelected( iTempB, &iTempE );
        else
            NextUnSelected( iTempB, &iTempE );

        if (-1 == iTempE)
        {
            iTempE = SELRANGE_MAXVALUE;
        }
        else
        {
            iTempE--;
        }

        iTempE = min( iTempE, iEnd );

        if (fSelect)
        {
            if (FAILED(hres = IncludeRange( iTempB, iTempE )))
            {
                return( hres );
            }
        }
        else
        {
            if (FAILED(hres = ExcludeRange( iTempB, iTempE )))
            {
                return( hres );
            }
        }

        fSelect = !fSelect;
    } while (iTempE < iEnd );

    return( hres );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\strings.c ===
//============================================================================
//
// DBCS aware string routines...
//
//
//============================================================================

//#if defined(UNIX) && !defined(UNICODE)
//#define UNICODE
//#endif


#include "ctlspriv.h"

#ifdef WINNT
#include <winnlsp.h>    // Get private NORM_ flag for StrEqIntl()
#endif

// for those of us who don't ssync to nt's build headers
#ifndef NORM_STOP_ON_NULL
#define NORM_STOP_ON_NULL   0x10000000
#endif

// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand thid

#ifdef UNIX

#ifdef BIG_ENDIAN
#define READNATIVEWORD(x) MAKEWORD(*(char*)(x), *(char*)((char*)(x) + 1))
#else
#define READNATIVEWORD(x) MAKEWORD(*(char*)((char*)(x) + 1), *(char*)(x))
#endif

#else

#define READNATIVEWORD(x) (*(UNALIGNED WORD *)x)

#endif


/*
 * StrEndN - Find the end of a string, but no more than n bytes
 * Assumes   lpStart points to start of null terminated string
 *           nBufSize is the maximum length
 * returns ptr to just after the last byte to be included
 */
LPSTR lstrfns_StrEndNA(LPCSTR lpStart, int nBufSize)
{
  LPCSTR lpEnd;

  for (lpEnd = lpStart + nBufSize; *lpStart && OFFSETOF(lpStart) < OFFSETOF(lpEnd);
	lpStart = AnsiNext(lpStart))
    continue;   /* just getting to the end of the string */
  if (OFFSETOF(lpStart) > OFFSETOF(lpEnd))
    {
      /* We can only get here if the last byte before lpEnd was a lead byte
       */
      lpStart -= 2;
    }
  return((LPSTR)lpStart);
}

LPWSTR lstrfns_StrEndNW(LPCWSTR lpStart, int nBufSize)
{
#ifdef UNICODE
  LPCWSTR lpEnd;

  for (lpEnd = lpStart + nBufSize; *lpStart && (lpStart < lpEnd);
	lpStart++)
    continue;   /* just getting to the end of the string */

  return((LPWSTR)lpStart);

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return NULL;

#endif
}


// REVIEW WIN32 HACK - Convert to 32bit asm.
#ifndef WIN32
/*
 * ReverseScan - Find last occurrence of a byte in a string
 * Assumes   lpSource points to first byte to check (end of the string)
 *           uLen is the number of bytes to check
 *           bMatch is the byte to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR PASCAL ReverseScan(LPCSTR lpSource, UINT uLen, BYTE bMatch)
{
  _asm
    {
	/* Load count */
	mov     cx,uLen
	jcxz ReverseScanFail    ; count is zero, return failure.

	/* Load up es:di, ax */
	les     di,lpSource
	mov     al,bMatch
	/* Set the direction flag based on bBackward
	 * Perform the search; return 0 if we reached the end of the string
	 * otherwise, return es:di+1
	 */
	std
	repne   scasb
	jne     ReverseScanFail     ; check result of last compare.

	inc     di
	mov     dx,es
	mov     ax,di
	jmp ReverseScanExit

ReverseScanFail:
	xor     ax,ax
	xor     dx,dx

	/* clear the direction flag and return
	 */
ReverseScanExit:
	cld
    }
    if (0) return 0;        // suppress warning, optimized out
}
#endif

/*
 * ChrCmp -  Case sensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared
 * Return    FALSE if they match, TRUE if no match
 */
__inline BOOL ChrCmpA_inline(WORD w1, WORD wMatch)
{
  /* Most of the time this won't match, so test it first for speed.
   */
  if (LOBYTE(w1) == LOBYTE(wMatch))
    {
      if (IsDBCSLeadByte(LOBYTE(w1)))
	{
	  return(w1 != wMatch);
	}
      return FALSE;
    }
  return TRUE;
}

BOOL ChrCmpA(WORD w1, WORD wMatch)
{
  return ChrCmpA_inline(w1, wMatch);
}

#ifdef UNICODE
__inline BOOL ChrCmpW_inline(WCHAR w1, WCHAR wMatch)
{
    return(!(w1 == wMatch));
}
#endif

BOOL ChrCmpW(WCHAR w1, WCHAR wMatch)
{
#ifdef UNICODE
   return ChrCmpW_inline(w1, wMatch);
#else
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return FALSE;
#endif
}



/*
 * ChrCmpI - Case insensitive character comparison for DBCS
 * Assumes   w1, wMatch are characters to be compared;
 *           HIBYTE of wMatch is 0 if not a DBC
 * Return    FALSE if match, TRUE if not
 */
BOOL ChrCmpIA(WORD w1, WORD wMatch)
{
  char sz1[3], sz2[3];

  if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
    {
      sz1[1] = HIBYTE(w1);
      sz1[2] = '\0';
    }
  else
      sz1[1] = '\0';

#if defined(BIG_ENDIAN)
  sz2[0] = LOBYTE(wMatch);
  sz2[1] = HIBYTE(wMatch);
#else
  *(WORD FAR *)sz2 = wMatch;
#endif
  sz2[2] = '\0';
  return lstrcmpiA(sz1, sz2);
}

BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch)
{
#ifdef UNICODE
  WCHAR sz1[2], sz2[2];

  sz1[0] = w1;
  sz1[1] = TEXT('\0');
  sz2[0] = wMatch;
  sz2[1] = TEXT('\0');

  return lstrcmpiW(sz1, sz2);

#else
  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return FALSE;

#endif
}

LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;
    do {
        *psz1 = *psz2;
        psz1++;
    } while(*psz2++);
    return psz;
}


LPWSTR StrCpyNW(LPWSTR psz1, LPCWSTR psz2, int cchMax)
{
    LPWSTR psz = psz1;

    ASSERT(psz1);
    ASSERT(psz2);

    if (0 < cchMax)
    {
        // Leave room for the null terminator
        while (0 < --cchMax)
        {
            if ( !(*psz1++ = *psz2++) )
                break;
        }

        if (0 == cchMax)
            *psz1 = '\0';
    }

    return psz;
}

/*
 * StrChr - Find first occurrence of character in string
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL StrChrA(LPCSTR lpStart, WORD wMatch)
{
  for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
      {
	  return((LPSTR)lpStart);
      }
   }
   return (NULL);
}

#ifdef ALIGNMENT_SCENARIO

LPWSTR StrChrSlowW(const UNALIGNED WCHAR *lpStart, WCHAR wMatch)
{
    for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }
    return NULL;
}
#endif

LPWSTR FAR PASCAL StrChrW(LPCWSTR lpStart, WCHAR wMatch)
{
#ifdef UNICODE
    //
    //  BUGBUG raymondc
    //  Apparently, somebody is passing unaligned strings to StrChrW.
    //  Find out who and make them stop.
    //
    ASSERT(!((ULONG_PTR)lpStart & 1)); // Assert alignedness

#ifdef ALIGNMENT_SCENARIO
    //
    //  Since unaligned strings arrive so rarely, put the slow
    //  version in a separate function so the common case stays
    //  fast.  Believe it or not, we call StrChrW so often that
    //  it is now a performance-sensitive function!
    //
    if ((ULONG_PTR)lpStart & 1)
        return StrChrSlowW(lpStart, wMatch);
#endif

    for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
        {
            return((LPWSTR)lpStart);
        }
    }

  return (NULL);

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return NULL;

#endif
}

/*
 * StrRChr - Find last occurrence of character in string
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenA(lpStart);

  for ( ; OFFSETOF(lpStart) < OFFSETOF(lpEnd); lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpA_inline(READNATIVEWORD(lpStart), wMatch))
	  lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}

LPWSTR FAR PASCAL StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
#ifdef UNICODE

  LPCWSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenW(lpStart);

  for ( ; lpStart < lpEnd; lpStart++)
    {
      if (!ChrCmpW_inline(*lpStart, wMatch))
	  lpFound = lpStart;
    }
  return ((LPWSTR)lpFound);

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return NULL;

#endif
}


/*
 * StrRChrI - Find last occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of string
 *           lpEnd   points to end of string (NOT included in search)
 *           wMatch  is the character to match
 * returns ptr to the last occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch)
{
  LPCSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenA(lpStart);

  wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

  for ( ; OFFSETOF(lpStart) < OFFSETOF(lpEnd); lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
          lpFound = lpStart;
    }
  return ((LPSTR)lpFound);
}

LPWSTR FAR PASCAL StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WCHAR wMatch)
{
#ifdef UNICODE

  LPCWSTR lpFound = NULL;

  if (!lpEnd)
      lpEnd = lpStart + lstrlenW(lpStart);

  for ( ; lpStart < lpEnd; lpStart++)
    {
      if (!ChrCmpIW(*lpStart, wMatch))
          lpFound = lpStart;
    }
  return ((LPWSTR)lpFound);

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return NULL;

#endif
}


// StrCSpn: return index to first char of lpStr that is present in lpSet.
// Includes the NUL in the comparison; if no lpSet chars are found, returns
// the index to the NUL in lpStr.
// Just like CRT strcspn.
//
int FAR PASCAL StrCSpnA(LPCSTR lpStr, LPCSTR lpSet)
{
	// nature of the beast: O(lpStr*lpSet) work
	LPCSTR lp = lpStr;
	if (!lpStr || !lpSet)
		return 0;

	while (*lp)
	{
 		if (StrChrA(lpSet, READNATIVEWORD(lp)))
			return (int)(lp-lpStr);
		lp = AnsiNext(lp);
	}

	return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int FAR PASCAL StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet)
{
#ifdef UNICODE

	// nature of the beast: O(lpStr*lpSet) work
	LPCWSTR lp = lpStr;
	if (!lpStr || !lpSet)
		return 0;

	while (*lp)
	{
		if (StrChrW(lpSet, *lp))
			return (int)(lp-lpStr);
		lp++;
	}

	return (int)(lp-lpStr); // ==lstrlen(lpStr)

#else

        SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
	return -1;

#endif
}


// StrCSpnI: case-insensitive version of StrCSpn.
//
int FAR PASCAL StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet)
{
        // nature of the beast: O(lpStr*lpSet) work
        LPCSTR lp = lpStr;
        if (!lpStr || !lpSet)
                return 0;

        while (*lp)
        {
                if (StrChrIA(lpSet, READNATIVEWORD(lp)))
                        return (int)(lp-lpStr);
                lp = AnsiNext(lp);
        }

        return (int)(lp-lpStr); // ==lstrlen(lpStr)
}

int FAR PASCAL StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet)
{
#ifdef UNICODE
        // nature of the beast: O(lpStr*lpSet) work
        LPCWSTR lp = lpStr;
        if (!lpStr || !lpSet)
                return 0;

        while (*lp)
        {
                if (StrChrIW(lpSet, *lp))
                        return (int)(lp-lpStr);
                lp++;
        }

        return (int)(lp-lpStr); // ==lstrlen(lpStr)

#else

        SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
        return -1;

#endif
}


/*
 * StrCmpN      - Compare n bytes
 *
 * returns   See lstrcmp return values.
 * BUGBUG, won't work if source strings are in ROM
 */
int FAR PASCAL StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    char sz1[4];
    char sz2[4];
    LPCSTR lpszEnd = lpStr1 + nChar;

    //DebugMsg(DM_TRACE, "StrCmpN: %s %s %d returns:", lpStr1, lpStr2, nChar);

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1 = AnsiNext(lpStr1), lpStr2 = AnsiNext(lpStr2)) {
        WORD wMatch;


        wMatch = (WORD) (*lpStr2 | (*(lpStr2+1)<<8));

        if (ChrCmpA_inline(READNATIVEWORD(lpStr1), wMatch)) {
            int iRet;

            (*(WORD FAR *)sz1) = READNATIVEWORD(lpStr1);
            (*(WORD FAR *)sz2) = wMatch;
#ifndef UNIX
            *AnsiNext(sz1) = 0;
            *AnsiNext(sz2) = 0;
#else
            *AnsiNext((LPWORD)sz1) = 0;
            *AnsiNext((LPWORD)sz2) = 0;
#endif

            iRet = lstrcmpA(sz1, sz2);
            //DebugMsg(DM_TRACE, ".................... %d", iRet);
            return iRet;
        }
    }

    //DebugMsg(DM_TRACE, ".................... 0");
    return 0;
}

int FAR PASCAL StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
#ifdef UNICODE

    WCHAR sz1[2];
    WCHAR sz2[2];
    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    //DebugMsg(DM_TRACE, "StrCmpN: %s %s %d returns:", lpStr1, lpStr2, nChar);

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        i = ChrCmpW_inline(*lpStr1, *lpStr2);
        if (i) {
            int iRet;

            sz1[0] = *lpStr1;
            sz2[0] = *lpStr2;
            sz1[1] = TEXT('\0');
            sz2[1] = TEXT('\0');
            iRet = lstrcmpW(sz1, sz2);
            //DebugMsg(DM_TRACE, ".................... %d", iRet);
            return iRet;
        }
    }

    //DebugMsg(DM_TRACE, ".................... 0");
    return 0;

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return -1;

#endif
}

/*
 * StrCmpNI     - Compare n bytes, case insensitive
 *
 * returns   See lstrcmpi return values.
 */

 #ifndef WINNT
__inline BOOL IsAsciiA(char ch)
{
    return !(ch & 0x80);
}

__inline char Ascii_ToLowerA(char ch)
{
    return (ch >= 'A' && ch <= 'Z') ? (ch - 'A' + 'a') : ch;
}

#ifdef UNICODE
__inline BOOL IsAsciiW(WCHAR ch)
{
    return ch < 128;
}

__inline WCHAR Ascii_ToLowerW(WCHAR ch)
{
    return (ch >= L'A' && ch <= L'Z') ? (ch - L'A' + L'a') : ch;
}
#endif

int FAR PASCAL StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    LPCSTR lpszEnd = lpStr1 + nChar;

    //DebugMsg(DM_TRACE, "StrCmpNI: %s %s %d returns:", lpStr1, lpStr2, nChar);

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); (lpStr1 = AnsiNext(lpStr1)), (lpStr2 = AnsiNext(lpStr2))) {
        WORD wMatch;

        if (IsAsciiA(*lpStr1) && IsAsciiA(*lpStr2))
        {
            i = Ascii_ToLowerA(*lpStr1) - Ascii_ToLowerA(*lpStr2);
        }
        else
        {
#ifndef UNIX
            wMatch = (UINT)(IsDBCSLeadByte(*lpStr2)) ? *(WORD FAR *)lpStr2 : (WORD)(BYTE)(*lpStr2);
#else
            wMatch = (UINT)(IsDBCSLeadByte(*lpStr2)) ? (*lpStr2 | (*(lpStr2+1)<<8)) : (WORD)(BYTE)(*lpStr2);
#endif

            i = ChrCmpIA(READNATIVEWORD(lpStr1), wMatch);
        }
        if (i) {
            //DebugMsg(DM_TRACE, ".................... %d", i);
            if (i < 0)
            {
                return -1;
            }
            else
            {
                return 1;
            }
        }
    }
    //DebugMsg(DM_TRACE, ".................... 0");
    return 0;
}

int FAR PASCAL StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
#ifdef UNICODE

    int i;
    LPCWSTR lpszEnd = lpStr1 + nChar;

    //DebugMsg(DM_TRACE, "StrCmpNI: %s %s %d returns:", lpStr1, lpStr2, nChar);

    for ( ; (lpszEnd > lpStr1) && (*lpStr1 || *lpStr2); lpStr1++, lpStr2++) {
        if (IsAsciiW(*lpStr1) && IsAsciiW(*lpStr2))
        {
            i = Ascii_ToLowerW(*lpStr1) - Ascii_ToLowerW(*lpStr2);
        }
        else
        {
            i = ChrCmpIW(*lpStr1, *lpStr2);
        }
        if (i) {
            //DebugMsg(DM_TRACE, ".................... %d", i);
           if (i < 0)
           {
               return -1;
           }
           else
           {
               return 1;
           }
           return i;
        }
    }
    //DebugMsg(DM_TRACE, ".................... 0");
    return 0;

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return -1;

#endif
}

#else // WINNT

int StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar)
{
    int i;
    
    //  Win95 doesn't support NORM_STOP_ON_NULL
    i = CompareStringA(GetThreadLocale(), NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                       lpStr1, nChar, lpStr2, nChar);

    if (!i)
    {
        i = CompareStringA(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                             lpStr1, nChar, lpStr2, nChar);
    }

    return i - CSTR_EQUAL;    
}

int StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar)
{
    int i;

    //  Win95 doesn't support NORM_STOP_ON_NULL
    i = CompareStringW(GetThreadLocale(), NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                       lpStr1, nChar, lpStr2, nChar);

    if (!i)
    {
        i = CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE | NORM_STOP_ON_NULL, 
                             lpStr1, nChar, lpStr2, nChar);
    }

    return i - CSTR_EQUAL;    
}

#endif //   WINNT


/*
 * IntlStrEq
 *
 * returns TRUE if strings are equal, FALSE if not
 */
BOOL IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar) {
    int retval;
    DWORD dwFlags = fCaseSens ? LOCALE_USE_CP_ACP : (NORM_IGNORECASE | LOCALE_USE_CP_ACP);

#ifdef WINNT
    //
    // On NT we can tell CompareString to stop at a '\0' if one is found before nChar chars
    //
    dwFlags |= NORM_STOP_ON_NULL;
#else
    //
    // On Win9x we have to do the check manually
    //
    if (nChar != -1) {
        LPCSTR psz1, psz2;
        int cch = 0;

        psz1 = lpString1;
        psz2 = lpString2;

        while( *psz1 != '\0' && *psz2 != '\0' && cch < nChar) {
#ifdef DBCS
            psz1 = CharNextA(psz1);
            psz2 = CharNextA(psz2);

            cch = min(psz1 - lpString1, psz2 - lpString2);
#else
            psz1++;
            psz2++;
            cch++;
#endif
        }

        // add one in for terminating '\0'
        cch++;

        if (cch < nChar) {
            nChar = cch;
        }
    }
#endif

    retval = CompareStringA( GetThreadLocale(),
                             dwFlags,
                             lpString1,
                             nChar,
                             lpString2,
                             nChar );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringA( GetSystemDefaultLCID(),
                                 dwFlags,
                                 lpString1,
                                 nChar,
                                 lpString2,
                                 nChar );
    }

    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            if (fCaseSens)
                retval = StrCmpNA(lpString1, lpString2, nChar) + 2;
            else {
                retval = StrCmpNIA(lpString1, lpString2, nChar) + 2;
            }
        }
        else
        {
            retval = 2;
        }
    }

    return (retval == 2);

}


BOOL IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar) {

#ifdef UNICODE
    int retval;
    DWORD dwFlags = fCaseSens ? 0 : NORM_IGNORECASE;

#ifdef WINNT
    //
    // On NT we can tell CompareString to stop at a '\0' if one is found before nChar chars
    //
    dwFlags |= NORM_STOP_ON_NULL;
#else
    //
    // On Win9x we have to do the check manually
    //
    if (nChar != -1) {
        LPCWSTR psz1, psz2;
        int cch = 0;

        psz1 = lpString1;
        psz2 = lpString2;

        while( *psz1 != TEXT('\0') && *psz2 != TEXT('\0') && cch < nChar) {
            psz1++;
            psz2++;
            cch++;
        }

        // add one in for terminating '\0'
        cch++;

        if (cch < nChar) {
            nChar = cch;
        }
    }
#endif


    retval = CompareStringW( GetThreadLocale(),
                             dwFlags,
                             lpString1,
                             nChar,
                             lpString2,
                             nChar );
    if (retval == 0)
    {
        //
        // The caller is not expecting failure.  Try the system
        // default locale id.
        //
        retval = CompareStringW( GetSystemDefaultLCID(),
                                 dwFlags,
                                 lpString1,
                                 nChar,
                                 lpString2,
                                 nChar );
    }

    if (retval == 0)
    {
        if (lpString1 && lpString2)
        {
            //
            // The caller is not expecting failure.  We've never had a
            // failure indicator before.  We'll do a best guess by calling
            // the C runtimes to do a non-locale sensitive compare.
            //
            if (fCaseSens)
                retval = StrCmpNW(lpString1, lpString2, nChar) + 2;
            else {
                retval = StrCmpNIW(lpString1, lpString2, nChar) + 2;
            }
        }
        else
        {
            retval = 2;
        }
    }

    return (retval == 2);

#else
  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return FALSE;
#endif
}



/*
 * StrRStrI      - Search for last occurrence of a substring
 *
 * Assumes   lpSource points to the null terminated source string
 *           lpLast points to where to search from in the source string
 *           lpLast is not included in the search
 *           lpSrch points to string to search for
 * returns   last occurrence of string if successful; NULL otherwise
 */
LPSTR FAR PASCAL StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch)
{
    LPCSTR lpFound = NULL;
    LPSTR lpEnd;
    char cHold;

    if (!lpLast)
        lpLast = lpSource + lstrlenA(lpSource);

    if (lpSource >= lpLast || *lpSrch == 0)
        return NULL;

    lpEnd = lstrfns_StrEndNA(lpLast, (UINT)(lstrlenA(lpSrch)-1));
    cHold = *lpEnd;
    *lpEnd = 0;

    while ((lpSource = StrStrIA(lpSource, lpSrch))!=0 &&
          OFFSETOF(lpSource) < OFFSETOF(lpLast))
    {
        lpFound = lpSource;
        lpSource = AnsiNext(lpSource);
    }
    *lpEnd = cHold;
    return((LPSTR)lpFound);
}

LPWSTR FAR PASCAL StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch)
{
#ifdef UNICODE
    LPCWSTR lpFound = NULL;
    LPWSTR lpEnd;
    WCHAR cHold;

    if (!lpLast)
        lpLast = lpSource + lstrlenW(lpSource);

    if (lpSource >= lpLast || *lpSrch == 0)
        return NULL;

    lpEnd = lstrfns_StrEndNW(lpLast, (UINT)(lstrlenW(lpSrch)-1));
    cHold = *lpEnd;
    *lpEnd = 0;

    while ((lpSource = StrStrIW(lpSource, lpSrch))!=0 &&
          lpSource < lpLast)
    {
        lpFound = lpSource;
        lpSource++;
    }
    *lpEnd = cHold;
    return((LPWSTR)lpFound);

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return NULL;

#endif
}



/*
 * StrStr      - Search for first occurrence of a substring
 *
 * Assumes   lpSource points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR FAR PASCAL StrStrA(LPCSTR lpFirst, LPCSTR lpSrch)
{
  UINT uLen;
  WORD wMatch;

  uLen = (UINT)lstrlenA(lpSrch);
  wMatch = READNATIVEWORD(lpSrch);

  for ( ; (lpFirst=StrChrA(lpFirst, wMatch))!=0 && !IntlStrEqNA(lpFirst, lpSrch, uLen);
        lpFirst=AnsiNext(lpFirst))
    continue; /* continue until we hit the end of the string or get a match */

  return((LPSTR)lpFirst);
}

LPWSTR FAR PASCAL StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
#ifdef UNICODE

  UINT uLen;
  WCHAR wMatch;

  uLen = (UINT)lstrlenW(lpSrch);
  wMatch = *lpSrch;

  for ( ; (lpFirst=StrChrW(lpFirst, wMatch))!=0 && !IntlStrEqNW(lpFirst, lpSrch, uLen);
        lpFirst++)
    continue; /* continue until we hit the end of the string or get a match */

  return((LPWSTR)lpFirst);

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return NULL;

#endif
}

/*
 * StrChrI - Find first occurrence of character in string, case insensitive
 * Assumes   lpStart points to start of null terminated string
 *           wMatch  is the character to match
 * returns ptr to the first occurrence of ch in str, NULL if not found.
 */
LPSTR FAR PASCAL StrChrIA(LPCSTR lpStart, WORD wMatch)
{
  wMatch = (UINT)(IsDBCSLeadByte(LOBYTE(wMatch)) ? wMatch : LOBYTE(wMatch));

  for ( ; *lpStart; lpStart = AnsiNext(lpStart))
    {
      if (!ChrCmpIA(READNATIVEWORD(lpStart), wMatch))
	  return((LPSTR)lpStart);
    }
  return (NULL);
}

LPWSTR FAR PASCAL StrChrIW(LPCWSTR lpStart, WCHAR wMatch)
{
  for ( ; *lpStart; lpStart++)
    {
      if (!ChrCmpIW(*lpStart, wMatch))
	  return((LPWSTR)lpStart);
    }
  return (NULL);
}


/*
 * StrStrI   - Search for first occurrence of a substring, case insensitive
 *
 * Assumes   lpFirst points to source string
 *           lpSrch points to string to search for
 * returns   first occurrence of string if successful; NULL otherwise
 */
LPSTR FAR PASCAL StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch)
{
  UINT uLen;
  WORD wMatch;

  uLen = (UINT)lstrlenA(lpSrch);
  wMatch = READNATIVEWORD(lpSrch);

  for ( ; (lpFirst = StrChrIA(lpFirst, wMatch)) != 0 && !IntlStrEqNIA(lpFirst, lpSrch, uLen);
        lpFirst=AnsiNext(lpFirst))
      continue; /* continue until we hit the end of the string or get a match */

  return((LPSTR)lpFirst);
}

LPWSTR FAR PASCAL StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch)
{
#ifdef UNICODE

  UINT uLen;
  WCHAR wMatch;

  uLen = (UINT)lstrlenW(lpSrch);
  wMatch = *lpSrch;

  for ( ; (lpFirst = StrChrIW(lpFirst, wMatch)) != 0 && !IntlStrEqNIW(lpFirst, lpSrch, uLen);
        lpFirst++)
      continue; /* continue until we hit the end of the string or get a match */

  return((LPWSTR)lpFirst);

#else

  SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
  return NULL;

#endif
}
#ifndef UNICODE

// TruncateString - bugbug: the same logic in shdocvw
//
// purpose: cut a string at the given length in dbcs safe manner
//          the string may be truncated at cch-1 if the sz[cch] points
//          to a lead byte that would result in cutting in the middle
//          of double byte character.
//          It is caller's responsibility to reserve enough buffer for
//          sz so we can put sz[cch]=0 safely.
//
//          *Note this logic is not much perf hit when called with sbcs
//          string, as it just bails out at the tail character always.
//
void  TruncateString(char *sz, int cchBufferSize)
{
    int cch = cchBufferSize - 1;
    LPSTR psz = &sz[cch];
    
    if (!sz || cchBufferSize <= 0) return;
    
    while (psz > sz)
    {
        psz--;
        if (!IsDBCSLeadByte(*psz))
        {
            // Found non-leadbyte for the first time.
            // This is either a trail byte of double byte char
            // or a single byte character we've first seen.
            // Thus, the next pointer must be at either of a leadbyte
            // or &sz[cch]
            psz++;
            break;
        }
    }
    if (((&sz[cch] - psz) & 1) && cch > 0)
    {
        // we're truncating the string in the middle of dbcs
        cch--;
    }
    sz[cch] = '\0';
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\status.c ===
/*
**    STATUS.C
**
**    Status bar code
**
*/

#include "ctlspriv.h"

#ifdef UNIX
#include <mainwin.h>
extern eLook MwLook;
extern const CLSID CLSID_CMultiLanguage;
#endif

#define MAX_TOOLTIP_STRING 80
#define SB_HITTEST_NOITEM  -2

typedef struct {
    ULONG_PTR dwString;
    UINT uType;
    int right;
    HICON hIcon;
    SIZE  sizeIcon;
    LPTSTR pszToolTip;
    BOOL fNeedToTip;
} STRINGINFO, NEAR *PSTRINGINFO;

typedef struct {
    CONTROLINFO ci;
    HWND hwndToolTips;
    HFONT hStatFont;
    BOOL bDefFont;

    int nFontHeight;
    int nMinHeight;
    int nBorderX, nBorderY, nBorderPart;
    int nLastX;                 // for invalidating unclipped right side
    int dxGripper;                // 0 if no gripper
#ifdef UNIX
    BOOL bHasGripper;           // TRUE if the status control was created with a gripper.
#endif
    UINT uiCodePage;            // code page

    STRINGINFO sSimple;

    int nParts;
    COLORREF _clrBk;    

    PSTRINGINFO sInfo;
} STATUSINFO, NEAR *PSTATUSINFO;


#define SBT_NORMAL        0xf000
#define SBT_NULL        0x0000    /* Some code depends on this being 0 */
#define SBT_ALLTYPES    0xf000    /* WINDOWS_ME: this does NOT include rtlred */
#define SBT_NOSIMPLE    0x00ff    /* Flags to indicate normal status bar */


#define MAXPARTS 256
// BUGBUG raymondc v6: This limit isn't big enough on large res screens
#define MAX_STATUS_TEXT_LEN 128

#ifdef UNICODE
#define CharNextEx(cp, sz, f) ((sz)+1)
#else
#define CharNextEx CharNextExA
#endif

BOOL NEAR PASCAL SBSetText(PSTATUSINFO pStatusInfo, WPARAM wParam, LPCTSTR lpsz);
void NEAR PASCAL SBSetBorders(PSTATUSINFO pStatusInfo, LPINT lpInt);
void NEAR PASCAL SBSetFont(PSTATUSINFO pStatusInfo, HFONT hFont, BOOL bInvalidate);
void WINAPI DrawStatusTextEx(PSTATUSINFO pStatusInfo, HDC hDC, LPRECT lprc, LPCTSTR pszText, STRINGINFO * psi,  UINT uFlags);
void RecalcTooltipRects(PSTATUSINFO pStatusinfo);
PSTRINGINFO GetStringInfo(PSTATUSINFO pStatusInfo, int nIndex);
int  IndexFromPt(PSTATUSINFO pStatusInfo, POINT pt);
void StatusUpdateToolTips(PSTATUSINFO psi);

void NEAR PASCAL GetNewMetrics(PSTATUSINFO pStatusInfo, HDC hDC, HFONT hNewFont)
{
    HFONT hOldFont;
    /* HACK! Pass in -1 to just delete the old font
     */
    if (hNewFont != (HFONT)-1)
    {
        TEXTMETRIC tm;

        hOldFont = 0;
        if (hNewFont)
        hOldFont = SelectObject(hDC, hNewFont);

        GetTextMetrics(hDC, &tm);

        if (hOldFont)
        SelectObject(hDC, hOldFont);

        pStatusInfo->nFontHeight = tm.tmHeight + tm.tmInternalLeading;

        // For far east font which has no internal leading
        if ( !tm.tmInternalLeading )
             pStatusInfo->nFontHeight += g_cyBorder * 2;

    }
}

void NEAR PASCAL NewFont(PSTATUSINFO pStatusInfo, HFONT hNewFont, BOOL fResize)
{
    HFONT hOldFont;
    BOOL bDelFont;
    HDC hDC;

    hOldFont = pStatusInfo->hStatFont;
    bDelFont = pStatusInfo->bDefFont;

    hDC = GetDC(pStatusInfo->ci.hwnd);

    if (hNewFont) {
        pStatusInfo->hStatFont = hNewFont;
        pStatusInfo->bDefFont = FALSE;
        pStatusInfo->uiCodePage = GetCodePageForFont(hNewFont);
    } else {
        if (bDelFont) {
            /* I will reuse the default font, so don't delete it later
             */
            hNewFont = pStatusInfo->hStatFont;
            bDelFont = FALSE;
        } else {
#ifndef DBCS_FONT
            hNewFont = CCCreateStatusFont();
            if (!hNewFont)
#endif // DBCS_FONT
                hNewFont = g_hfontSystem;


            pStatusInfo->hStatFont = hNewFont;
            pStatusInfo->bDefFont = BOOLFROMPTR(hNewFont);
        }
    }

#ifndef DBCS_FONT
    /* We delete the old font after creating the new one in case they are
     * the same; this should help GDI a little
     */
    if (bDelFont)
        DeleteObject(hOldFont);
#endif

    GetNewMetrics(pStatusInfo, hDC, hNewFont);

    ReleaseDC(pStatusInfo->ci.hwnd, hDC);

    // My font changed, so maybe I should resize to match
    if (fResize)
        SendMessage(pStatusInfo->ci.hwnd, WM_SIZE, 0, 0L);
}

/* We should send messages instead of calling things directly so we can
 * be subclassed more easily.
 */
LRESULT NEAR PASCAL InitStatusWnd(HWND hWnd, LPCREATESTRUCT lpCreate)
{
    int nBorders[3];
    PSTATUSINFO pStatusInfo = (PSTATUSINFO)LocalAlloc(LPTR, sizeof(STATUSINFO));
    if (!pStatusInfo)
        return -1;        // fail the window create

    // Start out with one part
    pStatusInfo->sInfo = (PSTRINGINFO)LocalAlloc(LPTR, sizeof(STRINGINFO));
    if (!pStatusInfo->sInfo)
    {
        LocalFree(pStatusInfo);
        return -1;        // fail the window create
    }

    SetWindowPtr(hWnd, 0, pStatusInfo);
    CIInitialize(&pStatusInfo->ci, hWnd, lpCreate);
    

    pStatusInfo->sSimple.uType = SBT_NOSIMPLE | SBT_NULL;
    pStatusInfo->sSimple.right = -1;
    pStatusInfo->uiCodePage = CP_ACP;

    pStatusInfo->nParts = 1;
    pStatusInfo->sInfo[0].uType = SBT_NULL;
    pStatusInfo->sInfo[0].right = -1;

    pStatusInfo->_clrBk = CLR_DEFAULT;

    // Save the window text in our struct, and let USER store the NULL string
#ifdef UNICODE_WIN9x
    {
        // We force CP_ACP because that's what we used to thunk it up in the first place
        LPWSTR pwsz = ProduceWFromA(CP_ACP, (LPCSTR)lpCreate->lpszName);
        SBSetText(pStatusInfo, 0, pwsz);
        FreeProducedString(pwsz);
    }
#else
    SBSetText(pStatusInfo, 0, lpCreate->lpszName);
#endif
    lpCreate->lpszName = c_szNULL;

    // Don't resize because MFC doesn't like getting funky
    // messages before the window is fully created.  USER will send
    // us a WM_SIZE message after the WM_CREATE returns, so we'll
    // get it sooner or later.
    NewFont(pStatusInfo, 0, FALSE);

    nBorders[0] = -1;     // use default border widths
    nBorders[1] = -1;
    nBorders[2] = -1;

    SBSetBorders(pStatusInfo, nBorders);

#define GRIPSIZE (g_cxVScroll + g_cxBorder)     // make the default look good

    if ((lpCreate->style & SBARS_SIZEGRIP) ||
        ((GetWindowStyle(lpCreate->hwndParent) & WS_THICKFRAME) &&
         !(lpCreate->style & (CCS_NOPARENTALIGN | CCS_TOP | CCS_NOMOVEY))))
#ifdef UNIX
         pStatusInfo->bHasGripper = TRUE;
    else
         pStatusInfo->bHasGripper = FALSE;
    if (!pStatusInfo->bHasGripper || (MwLook == LOOK_MOTIF))
         pStatusInfo->dxGripper = 0;
    else
         pStatusInfo->dxGripper = GRIPSIZE;
#else
        pStatusInfo->dxGripper = GRIPSIZE;
#endif

    return 0;     // success
}

// lprc is left unchanged, but used as scratch
void WINAPI DrawStatusText(HDC hDC, LPRECT lprc, LPCTSTR pszText, UINT uFlags)
{
    DrawStatusTextEx(NULL, hDC, lprc, pszText, NULL, uFlags);
}    

#ifdef UNICODE
void WINAPI DrawStatusTextA(HDC hDC, LPRECT lprc, LPCSTR pszText, UINT uFlags)
{
     INT     cch;
     LPWSTR     lpw;

     cch = lstrlenA(pszText);
     lpw = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, ((cch + 1) * sizeof(TCHAR)));

     if (!lpw) {
#ifdef DEBUG
        OutputDebugString(TEXT("Alloc failed: DrawStatusTextA\r\n"));
#endif
        return;
     }

     MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pszText, cch, lpw, cch);
     DrawStatusTextW(hDC, lprc, lpw, uFlags);

     LocalFree((LPVOID)lpw);
}

#else

//
//    Stub Unicode function for DrawStatusTextW when this
//    code is built ANSI.
//

void WINAPI DrawStatusTextW(HDC hDC, LPRECT lprc, LPCWSTR pszText, UINT uFlags)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return;
}


#endif

BOOL NEAR PASCAL Status_GetRect(PSTATUSINFO pStatusInfo, int nthPart, LPRECT lprc)
{
    PSTRINGINFO pStringInfo = pStatusInfo->sInfo;

    if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
    {
        RECT rc;
        int nRightMargin, i;

        /* Get the client rect and inset the top and bottom.    Then set
         * up the right side for entry into the loop
         */
        GetClientRect(pStatusInfo->ci.hwnd, &rc);

        if (pStatusInfo->dxGripper && !IsZoomed(pStatusInfo->ci.hwndParent))
        {
            rc.right = rc.right - pStatusInfo->dxGripper + pStatusInfo->nBorderX;
        }

        rc.top += pStatusInfo->nBorderY;

        nRightMargin = rc.right - pStatusInfo->nBorderX;
        rc.right = pStatusInfo->nBorderX - pStatusInfo->nBorderPart;

        for (i = 0; i < pStatusInfo->nParts; ++i, ++pStringInfo)
        {
            // WARNING!  This pixel computation is also in PaintStatusWnd,
            // so make sure the two algorithms are in sync.

            if (pStringInfo->right == 0)
                continue;

            rc.left = rc.right + pStatusInfo->nBorderPart;

            rc.right = pStringInfo->right;

            // size the right-most one to the end with room for border
            if (rc.right < 0 || rc.right > nRightMargin)
                rc.right = nRightMargin;

            // if the part is real small, don't show it
            // Bug keep the rc.left valid in case this item happens to
            // be the nthPart.
            if ((rc.right - rc.left) < pStatusInfo->nBorderPart)
                rc.left = rc.right;

            if (i == nthPart)
            {
                *lprc = rc;
                return TRUE;
            }
        }
    }

    return FALSE;

}

void NEAR PASCAL PaintStatusWnd(PSTATUSINFO pStatusInfo, HDC hdcIn, PSTRINGINFO pStringInfo, int nParts, int nBorderX)
{
    PAINTSTRUCT ps;
    RECT rc, rcGripper;
    int nRightMargin, i;
    HFONT hOldFont = NULL;
    UINT uType;
    BOOL bDrawGrip;

    // paint the whole client area
    GetClientRect(pStatusInfo->ci.hwnd, &rc);

    if (hdcIn)
    {
        ps.rcPaint = rc;
        ps.hdc = hdcIn;
    }
    else
        BeginPaint(pStatusInfo->ci.hwnd, &ps);


    rc.top += pStatusInfo->nBorderY;

    bDrawGrip = pStatusInfo->dxGripper && !IsZoomed(pStatusInfo->ci.hwndParent);

    if (bDrawGrip)
        rcGripper = rc;

    nRightMargin = rc.right - nBorderX;
    rc.right = nBorderX - pStatusInfo->nBorderPart;

    if (pStatusInfo->hStatFont)
        hOldFont = SelectObject(ps.hdc, pStatusInfo->hStatFont);

    for (i=0; i<nParts; ++i, ++pStringInfo)
    {
        // WARNING!  This pixel computation is also in Status_GetRect,
        // so make sure the two algorithms are in sync.
        if (pStringInfo->right == 0)
            continue;

        rc.left = rc.right + pStatusInfo->nBorderPart;
        rc.right = pStringInfo->right;

        // size the right-most one to the end with room for border
        if (rc.right < 0 || rc.right > nRightMargin)
            rc.right = nRightMargin;

#ifdef WINDOWS_ME
        if(g_fMEEnabled && (rc.right > (nRightMargin-pStatusInfo->dxGripper)))
            //
            // for MidEast we DONT overpaint the rhs with the grip, this will
            // lose the begining of the text.
            //
            rc.right = nRightMargin-pStatusInfo->dxGripper;
#endif
        
        DebugMsg(TF_STATUS, TEXT("SBPaint: part=%d, x/y=%d/%d"), i, rc.left, rc.right);

        // if the part is real small, don't show it
        if (((rc.right - rc.left) < pStatusInfo->nBorderPart) || !RectVisible(ps.hdc, &rc))
            continue;

        uType = pStringInfo->uType;

        if ((uType&SBT_ALLTYPES) == SBT_NORMAL)
        {
            DrawStatusTextEx(pStatusInfo, ps.hdc, &rc, (LPTSTR)OFFSETOF(pStringInfo->dwString), pStringInfo, uType);
        }
        else
        {
            DrawStatusTextEx(pStatusInfo, ps.hdc, &rc, c_szNULL, pStringInfo, uType);

            if (uType & SBT_OWNERDRAW)
            {
                DRAWITEMSTRUCT di;

                di.CtlID = GetWindowID(pStatusInfo->ci.hwnd);
                di.itemID = i;
                di.hwndItem = pStatusInfo->ci.hwnd;
                di.hDC = ps.hdc;
                di.rcItem = rc;
                InflateRect(&di.rcItem, -g_cxBorder, -g_cyBorder);
                di.itemData = pStringInfo->dwString;

                SaveDC(ps.hdc);
                IntersectClipRect(ps.hdc, di.rcItem.left, di.rcItem.top,
                                    di.rcItem.right, di.rcItem.bottom);
                SendMessage(pStatusInfo->ci.hwndParent, WM_DRAWITEM, di.CtlID,
                            (LPARAM)(LPTSTR)&di);
                RestoreDC(ps.hdc, -1);
            }
        }
    }

    if (bDrawGrip)
    {
        RECT rcTemp;
        COLORREF crBkColorOld;
        COLORREF crBkColor;
        
        pStatusInfo->dxGripper = min(pStatusInfo->dxGripper, pStatusInfo->nFontHeight);

        // draw the grip
        rcGripper.right -= g_cxBorder;                    // inside the borders
        rcGripper.bottom -= g_cyBorder;

        rcGripper.left = rcGripper.right - pStatusInfo->dxGripper;        // make it square
        rcGripper.top += g_cyBorder;
        // rcGripper.top    = rcGripper.bottom - pStatusInfo->dxGripper;

        crBkColor = g_clrBtnFace;
        if ((pStatusInfo->_clrBk != CLR_DEFAULT))
            crBkColor = pStatusInfo->_clrBk;
        
        crBkColorOld = SetBkColor(ps.hdc, crBkColor);
        // BUGBUG:we need to call our own drawframecontrol here
        // because user doesn't obey the bkcolro set
        DrawFrameControl(ps.hdc, &rcGripper, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);

        // clear out the border edges to make this appear on the same level

        // NOTE: these values line up right only for the default scroll bar
        // width. for others this is close enough...

        // right border
        rcTemp.top = rcGripper.bottom - pStatusInfo->dxGripper + g_cyBorder + g_cyEdge;
        rcTemp.left = rcGripper.right;
        rcTemp.bottom = rcGripper.bottom;
        rcTemp.right = rcGripper.right + g_cxBorder;
        FillRectClr(ps.hdc, &rcTemp, crBkColor);
        
        // bottom border
        rcTemp.top = rcGripper.bottom;
        rcTemp.left = rcGripper.left + g_cyBorder + g_cxEdge;
        rcTemp.bottom = rcGripper.bottom +    g_cyBorder;
        rcTemp.right = rcGripper.right + g_cxBorder;
        FillRectClr(ps.hdc, &rcTemp, crBkColor);
        
        SetBkColor(ps.hdc, crBkColorOld);
    }
    
    if (hOldFont)
        SelectObject(ps.hdc, hOldFont);

    if (hdcIn == NULL)
        EndPaint(pStatusInfo->ci.hwnd, &ps);
}


BOOL NEAR PASCAL SetStatusText(PSTATUSINFO pStatusInfo, PSTRINGINFO pStringInfo, UINT uPart, LPCTSTR lpStr)
{
    PTSTR pString;
    UINT wLen;
    int nPart;
    RECT rc;

    nPart = LOBYTE(uPart);

    /* Note it is up to the app the dispose of the previous itemData for
     * SBT_OWNERDRAW
     */
    if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL)
        LocalFree((HLOCAL)OFFSETOF(pStringInfo->dwString));

    /* Set to the NULL string in case anything goes wrong
     *
     * But be careful to preserve simple-ness if this is the simple
     * pane being updated.
     */
    if (nPart == 0xFF)
    {
        pStringInfo->uType = (uPart & 0xff00) | (pStringInfo->uType & 0x00ff);
        nPart = 0;          // There is only one simple part, so we are part 0
    }
    else
    {
        pStringInfo->uType = uPart & 0xff00;
    }
    pStringInfo->uType &= ~SBT_ALLTYPES;
    pStringInfo->uType |= SBT_NULL;

    /* Invalidate the rect of this pane.
     *
     * Note that we don't check whether the pane is actually visible
     * in the current status bar mode.  The result is some gratuitous
     * invalidates and updates.  Oh well.
     */
    GetClientRect(pStatusInfo->ci.hwnd, &rc);
    if (nPart)
        rc.left = pStringInfo[-1].right;
    if (pStringInfo->right > 0)
        rc.right = pStringInfo->right;
    InvalidateRect(pStatusInfo->ci.hwnd, &rc, FALSE);

    switch (uPart&SBT_ALLTYPES)
    {
        case 0:
            /* If lpStr==NULL, we have the NULL string
             */
            if (HIWORD64(lpStr))
            {
                wLen = lstrlen(lpStr);
                if (wLen)
                {
                    pString = (PTSTR)LocalAlloc(LPTR, (wLen+1)*sizeof(TCHAR));
                    pStringInfo->dwString = (ULONG_PTR)(LPTSTR)pString;
                    if (pString)
                    {
                        pStringInfo->uType |= SBT_NORMAL;

                        /* Copy the string
                         */
                        lstrcpy(pString, lpStr);

                        /* Replace unprintable characters (like CR/LF) with spaces
                         */
                        for ( ; *pString;
                              pString=(PTSTR)OFFSETOF(CharNextEx((WORD)pStatusInfo->uiCodePage, pString, 0)))
                            if ((unsigned)(*pString)<(unsigned)TEXT(' ') && *pString!= TEXT('\t'))
                                *pString = TEXT(' ');
                    }
                    else
                    {
                        /* We return FALSE to indicate there was an error setting
                         * the string
                         */
                        return(FALSE);
                    }
                }
            }
            else if (LOWORD(lpStr))
            {
                /* We don't allow this anymore; the app needs to set the ownerdraw
                 * bit for ownerdraw.
                 */
                return(FALSE);
            }
            break;

        case SBT_OWNERDRAW:
            pStringInfo->uType |= SBT_OWNERDRAW;
            pStringInfo->dwString = (ULONG_PTR)lpStr;
            break;

        default:
            return(FALSE);
    }

    UpdateWindow(pStatusInfo->ci.hwnd);
    return(TRUE);
}

BOOL NEAR PASCAL SetStatusParts(PSTATUSINFO pStatusInfo, int nParts, LPINT lpInt)
{
    int i;
    int prev;
    PSTRINGINFO pStringInfo, pStringInfoTemp;
    BOOL bRedraw = FALSE;

    if (nParts != pStatusInfo->nParts)
    {
        TOOLINFO ti = {0};
        int n;

        if (pStatusInfo->hwndToolTips)
        {
            ti.cbSize = sizeof(ti);
            ti.hwnd = pStatusInfo->ci.hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
    
            for(n = 0; n < pStatusInfo->nParts; n++)
            {
                ti.uId = n;
                SendMessage(pStatusInfo->hwndToolTips, TTM_DELTOOL, 0, (LPARAM)&ti);
            }
        }

        bRedraw = TRUE;

        /* Note that if nParts > pStatusInfo->nParts, this loop
         * does nothing
         */
        for (i=pStatusInfo->nParts-nParts,
            pStringInfo=&pStatusInfo->sInfo[nParts]; i>0;
            --i, ++pStringInfo)
        {
            if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL)
                LocalFree((HLOCAL)OFFSETOF(pStringInfo->dwString));
            pStringInfo->uType = SBT_NULL;
        }

        /* Realloc to the new size and store the new pointer
         */
        pStringInfoTemp = (PSTRINGINFO)CCLocalReAlloc(pStatusInfo->sInfo,
                                             nParts * sizeof(STRINGINFO));
        if (!pStringInfoTemp)
            return(FALSE);
        pStatusInfo->sInfo = pStringInfoTemp;

        /* Note that if nParts < pStatusInfo->nParts, this loop
         * does nothing
         */
        for (i=nParts-pStatusInfo->nParts,
             pStringInfo=&pStatusInfo->sInfo[pStatusInfo->nParts]; i>0;
             --i, ++pStringInfo)
        {
            pStringInfo->uType = SBT_NULL;
            pStringInfo->right = 0;
        }
        pStatusInfo->nParts = nParts;

        StatusUpdateToolTips(pStatusInfo);
    }

    //
    //  Under stress, apps such as Explorer might pass coordinates that
    //  result in status bar panes with negative width, so make sure
    //  each edge is at least as far to the right as the previous.
    //
    prev = 0;
    for (i=0, pStringInfo=pStatusInfo->sInfo; i<nParts;
         ++i, ++pStringInfo, ++lpInt)
    {
        int right = *lpInt;
        // The last component is allowed to have *lpInt = -1.
        // Otherwise, make sure the widths are nondecreasing.
        if (!(right == -1 && i == nParts - 1) && right < prev)
            right = prev;
        DebugMsg(TF_STATUS, TEXT("SBSetParts: part=%d, rlimit=%d (%d)"), i, right, *lpInt);
        if (pStringInfo->right != right)
        {
            bRedraw = TRUE;
            pStringInfo->right = right;
        }
        prev = right;
    }

    /* Only redraw if necesary (if the number of parts has changed or
     * a border has changed)
     */
    if (bRedraw)
        InvalidateRect(pStatusInfo->ci.hwnd, NULL, TRUE);

    RecalcTooltipRects(pStatusInfo);

    return TRUE;
}

void NEAR PASCAL SBSetFont(PSTATUSINFO pStatusInfo, HFONT hFont, BOOL bInvalidate)
{
    NewFont(pStatusInfo, hFont, TRUE);
    if (bInvalidate)
    {
        // BUGBUG do we need the updatenow flag?
        RedrawWindow(pStatusInfo->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
    }
}

BOOL NEAR PASCAL SBSetText(PSTATUSINFO pStatusInfo, WPARAM wParam, LPCTSTR lpsz)
{
    BOOL bRet;
    UINT idChild;

    DebugMsg(TF_STATUS, TEXT("SBSetText(%04x, [%s])"), wParam, lpsz);

    /* This is the "simple" status bar pane
     */
    if (LOBYTE(wParam) == 0xff)
    {
        UINT uSimple;

        // Note that we do not allow OWNERDRAW for a "simple" status bar
        if (wParam & SBT_OWNERDRAW)
            return FALSE;

        //
        //  IE4 BUG-FOR-BUG COMPATIBILITY:  In IE4, changing the SIMPLE
        //  status bar text while you were in complex mode caused the simple
        //  text to be painted briefly.  It would get cleaned up the next time
        //  the window got invalidated.
        //
        //  Corel Gallery actually RELIES ON THIS BUG!
        //
        //  Since the bad text got cleaned up on every invalidate, they
        //  "worked around" their bug by doing SB_SETTEXT in their idle loop,
        //  so the "correct" text gets repainted no matter what.
        //
        //  So if we have an old status bar, emulate the bug by temporarily
        //  setting the status bar into SIMPLE mode for the duration of the
        //  SetStatusText call.

        uSimple = pStatusInfo->sSimple.uType;
        if (pStatusInfo->ci.iVersion < 5)
            pStatusInfo->sSimple.uType = (uSimple & 0xFF00);

        bRet = SetStatusText(pStatusInfo, &pStatusInfo->sSimple,
                             (UINT) wParam, lpsz);

        if (pStatusInfo->ci.iVersion < 5)
            pStatusInfo->sSimple.uType |= LOBYTE(uSimple);

        idChild = 0;
    }
    else
    {

        if ((UINT)pStatusInfo->nParts <= (UINT)LOBYTE(wParam))
            bRet = FALSE;
        else
            bRet = SetStatusText(pStatusInfo, &pStatusInfo->sInfo[LOBYTE(wParam)],
                                 (UINT) wParam, lpsz);

        idChild = LOBYTE(wParam);
    }

    if (bRet)
        MyNotifyWinEvent(EVENT_OBJECT_NAMECHANGE, pStatusInfo->ci.hwnd,
            OBJID_CLIENT, idChild+1);

    return bRet;
}

//
//  iPart - which part we are querying
//  lpOutBuf - output buffer, NULL if no output desired
//  cchOutBuf - size of output buffer in characters
//  flags - zero or more of the following flags
//
//      SBGT_ANSI       - Output buffer is ANSI
//      SBGT_UNICODE    - Output buffer is unicode
//      SBGT_TCHAR      - Output buffer is TCHAR
//      SBGT_OWNERDRAWOK- Return refdata for owner-draw
//
//  If item is a string, and output buffer is provided, then returns
//  output string length (not including null) in low word, flags in
//  high word.
//
//  If item is a string, and no output buffer is provided, then returns
//  source string length (not including null) in low word, flags in
//  high word.
//
//  If item is owner-draw and SBGT_OWNERDRAWOK is set, then return the
//  refdata for the owner-draw item.
//
//  If item is owner-draw and SBGT_OWNERDRAWOK is clear, then treats
//  string as if it were empty.
//

#define     SBGT_ANSI           0
#define     SBGT_UNICODE        1
#define     SBGT_OWNERDRAWOK    2

#ifdef UNICODE
#define     SBGT_TCHAR          SBGT_UNICODE
#else
#define     SBGT_TCHAR          SBGT_ANSI
#endif

// Value for cchOutBuf to indicate largest possible output buffer size
// We cannot use -1 because StrCpyNW thinks -1 means a negative-size buffer.
// Since the maximum value we return is 0xFFFF (LOWORD), and the return value
// doesn't include the trailing null, the largest incoming buffer is one
// greater.
#define     SBGT_INFINITE       0x00010000

LRESULT SBGetText(PSTATUSINFO pStatusInfo, WPARAM iPart, LPVOID lpOutBuf, int cchOutBuf, UINT flags)
{
    UINT uType;
    PTSTR pString;
    ULONG_PTR dwString;
    UINT wLen;

    if (!pStatusInfo || (UINT)pStatusInfo->nParts<=iPart)
        return(0);

    if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE) {
        uType = pStatusInfo->sInfo[iPart].uType;
        dwString = pStatusInfo->sInfo[iPart].dwString;
    } else {
        uType = pStatusInfo->sSimple.uType;
        dwString = pStatusInfo->sSimple.dwString;
    }

    // Catch the boundary condition early so we only have to check lpOutBuf
    if (cchOutBuf == 0)
        lpOutBuf = NULL;

    if ((uType&SBT_ALLTYPES) == SBT_NORMAL)
    {
        pString = (PTSTR)dwString;
#ifdef UNICODE
        if (flags & SBGT_UNICODE)
        {
            if (lpOutBuf)
            {
                StrCpyNW(lpOutBuf, pString, cchOutBuf);
                wLen = lstrlenW(lpOutBuf);
            }
            else
                wLen = lstrlen(pString);
        }
        else
        {
            // We have to use ProduceAFromW because WideCharToMultiByte
            // will simply fail if the output buffer isn't big enough,
            // but we want to copy as many as will fit.
            LPSTR pStringA = ProduceAFromW(pStatusInfo->ci.uiCodePage, pString);
            if (pStringA)
            {
                if (lpOutBuf)
                {
                    lstrcpynA(lpOutBuf, pStringA, cchOutBuf);
                    wLen = lstrlenA(lpOutBuf);
                }
                else
                    wLen = lstrlenA(pStringA);  // Return required ANSI buf size
                FreeProducedString(pStringA);
            }
            else
            {
                if (lpOutBuf)
                    *(LPSTR)lpOutBuf = '\0';
                wLen = 0;               // Eek, horrible memory problem
            }
        }
#else
        if (lpOutBuf)
        {
            lstrcpyn(lpOutBuf, pString, cchOutBuf);
            wLen = lstrlen(lpOutBuf);
        }
        else
            wLen = lstrlen(pString);
#endif

        /* Set this back to 0 to return to the app
         */
        uType &= ~SBT_ALLTYPES;
    }
    else
    {
        if (lpOutBuf)
        {
#ifdef UNICODE
            if (flags & SBGT_UNICODE)
                *(LPWSTR)lpOutBuf = L'\0';
            else
                *(LPSTR)lpOutBuf = '\0';
#else
            *(LPTSTR)lParam = TEXT('\0');
#endif
        }
        wLen = 0;

        // Only SB_GETTEXT[AW] returns the raw owner-draw refdata
        if ((uType&SBT_ALLTYPES)==SBT_OWNERDRAW && (flags & SBGT_OWNERDRAWOK))
            return(dwString);
    }

    return(MAKELONG(wLen, uType));
}

void NEAR PASCAL SBSetBorders(PSTATUSINFO pStatusInfo, LPINT lpInt)
{
    // pStatusInfo->nBorderX = lpInt[0] < 0 ? 0 : lpInt[0];
    pStatusInfo->nBorderX = 0;

    // pStatusInfo->nBorderY = lpInt[1] < 0 ? 2 * g_cyBorder : lpInt[1];
    pStatusInfo->nBorderY = g_cyEdge;

    // pStatusInfo->nBorderPart = lpInt[2] < 0 ? 2 * g_cxBorder : lpInt[2];
    pStatusInfo->nBorderPart = g_cxEdge;
}

void StatusUpdateToolTips(PSTATUSINFO psi)
{
    if (psi->hwndToolTips)
    {
        TOOLINFO ti = {0};
        int n;

        ti.cbSize = sizeof(ti);
        ti.hwnd = psi->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        for(n = 0; n < psi->nParts; n++)
        {
            ti.uId = n;
            SendMessage(psi->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)&ti);
        }

    }
}
void StatusForceCreateTooltips(PSTATUSINFO psi)
{
    if (psi->ci.style & SBT_TOOLTIPS && !psi->hwndToolTips) 
    {
        TOOLINFO ti = {0};
#ifdef UNIX
        // IEUNIX : CreateWindowEx is used with special extended flag to get
        // rid of unwanted border around the tooltip.
        DWORD dwExStyle = 0;
        dwExStyle |= WS_EX_MW_UNMANAGED_WINDOW;
        psi->hwndToolTips = CreateWindowEx(dwExStyle, c_szSToolTipsClass, NULL, WS_POPUP | TTS_ALWAYSTIP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, psi->ci.hwnd, NULL, HINST_THISDLL, NULL);
#else
        psi->hwndToolTips = CreateWindow(c_szSToolTipsClass, NULL, WS_POPUP | TTS_ALWAYSTIP, 
                                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                    psi->ci.hwnd, NULL, HINST_THISDLL, NULL);

#endif

        ti.cbSize = sizeof(ti);
        ti.hwnd = psi->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.uId = SB_SIMPLEID;
        SendMessage(psi->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)&ti);
        StatusUpdateToolTips(psi);
        RecalcTooltipRects(psi);
    }
}

LRESULT CALLBACK StatusWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PSTATUSINFO pStatusInfo = GetWindowPtr(hWnd, 0);
    NMCLICK nm;
    int nNotification;

    if (!pStatusInfo && uMsg != WM_CREATE) 
        goto DoDefault;
    
    switch (uMsg)
    {
        case WM_CREATE:
            CCCreateWindow();

            return InitStatusWnd(hWnd, (LPCREATESTRUCT)lParam);
                
        case WM_SYSCOLORCHANGE:
#ifdef UNIX
            InitGlobalColors();
            InitGlobalMetrics(0);
#endif
            if (pStatusInfo->hwndToolTips)
                SendMessage(pStatusInfo->hwndToolTips, uMsg, wParam, lParam);
            break;

        case WM_MOUSEMOVE:  
        case WM_LBUTTONDOWN:
            StatusForceCreateTooltips(pStatusInfo);
            RelayToToolTips(pStatusInfo->hwndToolTips, hWnd, uMsg, wParam, lParam);
            break;
#ifdef UNIX
        case WM_LOOKSWITCH:
            InitGlobalMetrics(0);
            if (pStatusInfo->bHasGripper)
                pStatusInfo->dxGripper = (MwLook == LOOK_MOTIF) ? 0 : GRIPSIZE;
            break;
#endif
        case WM_STYLECHANGED:
        {
            if (wParam == GWL_EXSTYLE)
            {
                //
                // If the RTL_MIRROR extended style bit had changed, let's
                // repaint the control window
                //
                if ((pStatusInfo->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=  
                    (((LPSTYLESTRUCT)lParam)->styleNew&RTL_MIRRORED_WINDOW))
                    InvalidateRect(pStatusInfo->ci.hwnd, NULL, TRUE);

                //
                // Save the new ex-style bits
                //
                pStatusInfo->ci.dwExStyle = ((LPSTYLESTRUCT)lParam)->styleNew;
            }
        }
        return 0;

#ifdef WINNT
#     if WM_SETTINGCHANGE != WM_WININICHANGE
#         pragma error( WM_SETTINGCHANGE value is not WM_WININICHANGE)
#     endif
#endif
        case WM_SETTINGCHANGE:
            InitGlobalColors();
            InitGlobalMetrics(wParam);

            if (pStatusInfo->hwndToolTips)
                SendMessage(pStatusInfo->hwndToolTips, uMsg, wParam, lParam);
                
            if (pStatusInfo->dxGripper)
                pStatusInfo->dxGripper = GRIPSIZE;

            if (wParam == SPI_SETNONCLIENTMETRICS)
            {
                if (pStatusInfo->bDefFont)
                {
                    if (pStatusInfo->hStatFont)
                    {
                        DeleteObject(pStatusInfo->hStatFont);
                        pStatusInfo->hStatFont = NULL;
                        pStatusInfo->bDefFont = FALSE;
                        SBSetFont(pStatusInfo, 0, TRUE);
                    }
                }
            }
            break;

        case WM_DESTROY:
            CCDestroyWindow();
            if (pStatusInfo)
            {
                int i;
                PSTRINGINFO pStringInfo;

                // FALSE = Don't resize while being destroyed...
                NewFont(pStatusInfo, (HFONT)-1, FALSE);
                for (i=pStatusInfo->nParts-1, pStringInfo=pStatusInfo->sInfo;
                     i>=0; --i, ++pStringInfo)
                {
                    if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL)
                        LocalFree((HLOCAL)OFFSETOF(pStringInfo->dwString));
                    Str_Set(&pStringInfo->pszToolTip, NULL);
                }

                if ((pStatusInfo->sSimple.uType&SBT_ALLTYPES) == SBT_NORMAL)
                    LocalFree((HLOCAL)OFFSETOF(pStatusInfo->sSimple.dwString));

                if (IsWindow(pStatusInfo->hwndToolTips))
                    DestroyWindow(pStatusInfo->hwndToolTips);

                Str_Set(&pStatusInfo->sSimple.pszToolTip, NULL);

                if (pStatusInfo->sInfo)
                    LocalFree(pStatusInfo->sInfo);
                LocalFree((HLOCAL)pStatusInfo);
                SetWindowInt(hWnd, 0, 0);

            }
            break;

        case WM_NCHITTEST:
            if (pStatusInfo->dxGripper && !IsZoomed(pStatusInfo->ci.hwndParent))
            {
                RECT rc;

                // already know height is valid.    if the width is in the grip,
                // show the sizing cursor
                GetWindowRect(pStatusInfo->ci.hwnd, &rc);
                
                //
                // If this is a RTL mirrored status window, then measure
                // from the near edge (screen coordinates) since Screen
                // Coordinates are not RTL mirrored.
                // [samera]
                //
                if (pStatusInfo->ci.dwExStyle&RTL_MIRRORED_WINDOW) {
                    if (GET_X_LPARAM(lParam) < (rc.left + pStatusInfo->dxGripper))
                        return HTBOTTOMLEFT;
                } else if (GET_X_LPARAM(lParam) > (rc.right - pStatusInfo->dxGripper)) {
                    return HTBOTTOMRIGHT;
                }
            }
            goto DoDefault;

        case WM_SETTEXT:
        {
#ifndef WINNT
#ifdef UNICODE
            LPTSTR lpsz;
#endif
#endif
            wParam = 0;
            uMsg = SB_SETTEXT;
#ifndef WINNT
#ifdef UNICODE
            lpsz = ProduceWFromA(pStatusInfo->uiCodePage, (LPSTR)lParam);
            if (lpsz)
            {
                BOOL bRet;

                bRet = SBSetText(pStatusInfo, wParam, (LPCTSTR)lpsz);
                FreeProducedString(lpsz);
                return bRet;
            }
#endif
#endif
        }
            /* Fall through */
        case SB_SETTEXT:
            return SBSetText(pStatusInfo, wParam, (LPCTSTR)lParam);

#ifdef UNICODE
        case SB_SETTEXTA:
        {
            BOOL bRet, bAlloced = FALSE;
            LPTSTR lpsz;

            if (!(wParam & SBT_OWNERDRAW)) {
                lpsz = ProduceWFromA(pStatusInfo->uiCodePage, (LPSTR)lParam);
                bAlloced = TRUE;
            } else {
                lpsz = (LPTSTR)lParam;
            }

            if (!pStatusInfo)
                bRet = FALSE;
            else
            {
                bRet = SBSetText(pStatusInfo, wParam, (LPCTSTR)lpsz);
            }

            if (bAlloced) {
                FreeProducedString(lpsz);
            }
            return bRet;
        }
#elif WIN32
        case SB_SETTEXTW:
        {
            BOOL bRet = FALSE;
            LPSTR lpsz = NULL;
            
            lpsz = ProduceAFromW(CP_ACP, (LPCWSTR)lParam);
            
            if (lpsz)
            {
                bRet = SBSetText(pStatusInfo, wParam, lpsz);
                FreeProducedString(lpsz);
            }
            return bRet;
        }
#endif

        // The WM_GETTEXT and WM_GETTEXTLENGTH messages must return a
        // character count, no flags.  (Otherwise USER gets mad at us.)
        // So we throw away the flags by returning only the LOWORD().
#ifdef UNICODE_WIN9x
        case WM_GETTEXT:
            return LOWORD(SBGetText(pStatusInfo, 0, (LPVOID)lParam, (int)wParam, SBGT_ANSI));
        case WM_GETTEXTLENGTH:
            return LOWORD(SBGetText(pStatusInfo, 0, NULL, 0, SBGT_ANSI));
#else
        case WM_GETTEXT:
            return LOWORD(SBGetText(pStatusInfo, 0, (LPVOID)lParam, (int)wParam, SBGT_TCHAR));
        case WM_GETTEXTLENGTH:
            return LOWORD(SBGetText(pStatusInfo, 0, NULL, 0, SBGT_TCHAR));
#endif

        case SB_GETTEXT:
            /* We assume the buffer is large enough to hold the string, just
             * as listboxes do; the app should call SB_GETTEXTLEN first
             */
            return SBGetText(pStatusInfo, wParam, (LPVOID)lParam, SBGT_INFINITE, SBGT_TCHAR | SBGT_OWNERDRAWOK);

        case SB_GETTEXTLENGTH:
            return SBGetText(pStatusInfo, wParam, NULL, 0, SBGT_TCHAR);


#ifdef UNICODE
        case SB_GETTEXTA:
            /* We assume the buffer is large enough to hold the string, just
             * as listboxes do; the app should call SB_GETTEXTLEN first
             */
            return SBGetText(pStatusInfo, wParam, (LPVOID)lParam, SBGT_INFINITE, SBGT_ANSI | SBGT_OWNERDRAWOK);

        case SB_GETTEXTLENGTHA:
            return SBGetText(pStatusInfo, wParam, NULL, 0, SBGT_ANSI);
#endif

        case SB_SETBKCOLOR:
        {
            COLORREF clr = pStatusInfo->_clrBk;
            pStatusInfo->_clrBk = (COLORREF)lParam;
            InvalidateRect(hWnd, NULL, TRUE);
            return clr;
        }

        case SB_SETPARTS:
            if (!wParam || wParam>MAXPARTS)
                return FALSE;

            return SetStatusParts(pStatusInfo, (int) wParam, (LPINT)lParam);

        case SB_GETPARTS:
            if (lParam)
            {
                PSTRINGINFO pStringInfo;
                LPINT lpInt;

                /* Fill in the lesser of the number of entries asked for or
                 * the number of entries there are
                 */
                if (wParam > (WPARAM)pStatusInfo->nParts)
                    wParam = pStatusInfo->nParts;

                for (pStringInfo=pStatusInfo->sInfo, lpInt=(LPINT)lParam;
                    wParam>0; --wParam, ++pStringInfo, ++lpInt)
                    *lpInt = pStringInfo->right;
            }

            /* Always return the number of actual entries
             */
            return(pStatusInfo->nParts);

        case SB_GETBORDERS:
            ((LPINT)lParam)[0] = pStatusInfo->nBorderX;
            ((LPINT)lParam)[1] = pStatusInfo->nBorderY;
            ((LPINT)lParam)[2] = pStatusInfo->nBorderPart;
            return TRUE;
            
        case SB_ISSIMPLE:
            return !(pStatusInfo->sSimple.uType & SBT_NOSIMPLE);

        case SB_GETRECT:
            return Status_GetRect(pStatusInfo, (int)wParam, (LPRECT)lParam);

        case SB_SETMINHEIGHT:     // this is a substitute for WM_MEASUREITEM
            pStatusInfo->nMinHeight = (int) wParam;
            RecalcTooltipRects(pStatusInfo);
            break;

        case SB_SIMPLE:
        {
            BOOL bInvalidate = FALSE;

            if (wParam)
            {
                if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
                {
                    pStatusInfo->sSimple.uType &= ~SBT_NOSIMPLE;
                    bInvalidate = TRUE;
                }
            }
            else
            {
                if ((pStatusInfo->sSimple.uType & SBT_NOSIMPLE) == 0)
                {
                    pStatusInfo->sSimple.uType |= SBT_NOSIMPLE;
                    bInvalidate = TRUE;
                }
            }

            if (bInvalidate) {
                DebugMsg(TF_STATUS, TEXT("SB_SIMPLE: %d"), wParam);
                RecalcTooltipRects(pStatusInfo);
                SendNotifyEx(pStatusInfo->ci.hwndParent, pStatusInfo->ci.hwnd, SBN_SIMPLEMODECHANGE, NULL, FALSE);
                InvalidateRect(pStatusInfo->ci.hwnd, NULL, TRUE);
            }
            break;
        }

        case SB_SETICON:
        case SB_GETICON:
        {
            PSTRINGINFO pStringInfo = NULL;

            // -1 implies we are setting the icon for sSimple
            if ((UINT_PTR)-1 == wParam)
                pStringInfo = &pStatusInfo->sSimple;
            else if(wParam < (UINT)pStatusInfo->nParts)
                pStringInfo = &pStatusInfo->sInfo[wParam];
                
            if (uMsg == SB_GETICON)
                return (LRESULT)(pStringInfo ? pStringInfo->hIcon : NULL);
                
            if (pStringInfo && (pStringInfo->hIcon != (HICON)lParam))
            {
                BITMAP bm = {0};
                RECT rc;

                if (lParam)
                {
                    ICONINFO ii;

                    // Save the dimensions of the icon
                    GetIconInfo((HICON)lParam, &ii);
                    GetObject(ii.hbmColor, sizeof(BITMAP), &bm);
                    DeleteObject(ii.hbmColor);
                    DeleteObject(ii.hbmMask);
                }

                pStringInfo->sizeIcon.cx = bm.bmWidth;
                pStringInfo->sizeIcon.cy = bm.bmHeight;
                pStringInfo->hIcon = (HICON)lParam;
                
                Status_GetRect(pStatusInfo, (int)wParam, &rc);
                InvalidateRect(pStatusInfo->ci.hwnd, &rc, TRUE);
                UpdateWindow(pStatusInfo->ci.hwnd);
            }
            return TRUE;
        }

        // HIWORD(wParam) is the cbChar
        // LOWORD(wParam) is the nPart 
        case SB_GETTIPTEXT:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, LOWORD(wParam));

            if (pStringInfo)
                lstrcpyn((LPTSTR)lParam, pStringInfo->pszToolTip,  HIWORD(wParam));
                
            break;
        }
        
        case SB_SETTIPTEXT:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, (int) wParam);

            if (pStringInfo)
                Str_Set(&pStringInfo->pszToolTip, (LPCTSTR)lParam);

            break;    
        }    
#ifdef UNICODE
        case SB_GETTIPTEXTA:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, LOWORD(wParam));

            if (pStringInfo)
                WideCharToMultiByte(CP_ACP, 0, pStringInfo->pszToolTip, -1, (LPSTR)lParam,
                                        HIWORD(wParam), NULL, NULL);
            break;
        }
        
        case SB_SETTIPTEXTA:
        {
            PSTRINGINFO pStringInfo = GetStringInfo(pStatusInfo, (int) wParam);
            LPTSTR lpsz;

            lpsz = ProduceWFromA(pStatusInfo->uiCodePage, (LPSTR)lParam);
                
            if (pStringInfo)
                Str_Set(&pStringInfo->pszToolTip, (LPCTSTR)lpsz);

            LocalFree(lpsz);
            break;    
        }    
#endif

#define lpNmhdr ((LPNMHDR)(lParam))
#define lpnmTT ((LPTOOLTIPTEXT) lParam)
#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (HIWORD64(lpszText)))
        case WM_NOTIFY:
        {
            PSTRINGINFO pStringInfo = NULL;
            if (lpNmhdr->code == TTN_NEEDTEXT) 
            {
                pStringInfo = GetStringInfo(pStatusInfo, (int) lpNmhdr->idFrom);
                if (!pStringInfo || !pStringInfo->fNeedToTip)
                    break;
            }
            //
            // We are just going to pass this on to the
            // real parent.  Note that -1 is used as
            // the hwndFrom.  This prevents SendNotifyEx
            // from updating the NMHDR structure.
            //
            SendNotifyEx(pStatusInfo->ci.hwndParent, (HWND) -1,
                   lpNmhdr->code, lpNmhdr, pStatusInfo->ci.bUnicode);

            if ((lpNmhdr->code == TTN_NEEDTEXT) && lpnmTT->lpszText 
                && IsTextPtr(lpnmTT->lpszText) && !lpnmTT->lpszText[0])
            {    
                if (pStringInfo)
                    lpnmTT->lpszText = pStringInfo->pszToolTip;
            }
            break;
        }    

        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&pStatusInfo->ci, lParam);
            
        case WM_SETFONT:
            if (!pStatusInfo)
                return FALSE;

            SBSetFont(pStatusInfo, (HFONT)wParam, (BOOL)lParam);
            return TRUE;
            
        case WM_LBUTTONUP:
            nNotification = NM_CLICK;
            StatusForceCreateTooltips(pStatusInfo);
            RelayToToolTips(pStatusInfo->hwndToolTips, hWnd, uMsg, wParam, lParam);
            goto SendNotify;
        
        case WM_LBUTTONDBLCLK:
            nNotification = NM_DBLCLK;
            goto SendNotify;
        
        case WM_RBUTTONDBLCLK:
            nNotification = NM_RDBLCLK;
            goto SendNotify;
        
        case WM_RBUTTONUP:
            nNotification = NM_RCLICK;
SendNotify:
            LPARAM_TO_POINT(lParam, nm.pt);
            nm.dwItemSpec = IndexFromPt(pStatusInfo, nm.pt);
            if (!SendNotifyEx(pStatusInfo->ci.hwndParent, pStatusInfo->ci.hwnd, nNotification, (LPNMHDR)&nm,FALSE))
                goto DoDefault;
            return 0;

        case WM_GETFONT:
            if (!pStatusInfo)
                return 0;

            return (LRESULT)pStatusInfo->hStatFont;

        case WM_SIZE:
        {
            int nHeight;
            RECT rc;
            LPTSTR lpStr;
            PSTRINGINFO pStringInfo;
            int i, nTabs;

            if (!pStatusInfo)
                return 0;

            GetWindowRect(pStatusInfo->ci.hwnd, &rc);
            rc.right -= rc.left;    // -> dx
            rc.bottom -= rc.top;    // -> dy

            // If there is no parent, then this is a top level window
            if (pStatusInfo->ci.hwndParent)
            {
                ScreenToClient(pStatusInfo->ci.hwndParent, (LPPOINT)&rc);

                //
                // Places the status bar properly
                //
                if (pStatusInfo->ci.dwExStyle&RTL_MIRRORED_WINDOW)
                    rc.left -= rc.right;  
            }

            // need room for text, 3d border, and extra edge
            nHeight = 
                max(pStatusInfo->nFontHeight, g_cySmIcon) + 2 * g_cyBorder ;

            if (nHeight < pStatusInfo->nMinHeight)
                nHeight = pStatusInfo->nMinHeight;
             nHeight += pStatusInfo->nBorderY;

            // we don't have a divider thing -> force CCS_NODIVIDER

            NewSize(pStatusInfo->ci.hwnd, nHeight, GetWindowStyle(pStatusInfo->ci.hwnd) | CCS_NODIVIDER,
                rc.left, rc.top, rc.right, rc.bottom);

            // If the pane is right aligned then we need to invalidate all the pane
            // to force paint the entire pane. because the system will invalidate none if 
            // the status bar get shrieked or only the new added part if the status bar 
            // get grow and this does not work with the right justified text.
            pStringInfo = pStatusInfo->sInfo;
            for (i = 0; i < pStatusInfo->nParts; ++i, ++pStringInfo)
            {
                if ((pStringInfo->uType&SBT_ALLTYPES) == SBT_NORMAL &&
                    (lpStr = (LPTSTR)(pStringInfo->dwString)) != NULL)
                {
                    for ( nTabs = 0; (lpStr = StrChr(lpStr, TEXT('\t'))) != NULL; lpStr++) 
                    {
                        nTabs++;
                    }
                    if ( nTabs >= 2)
                    {
                        Status_GetRect(pStatusInfo, i, &rc);
                        InvalidateRect(pStatusInfo->ci.hwnd, &rc, FALSE);
                    }
                }
            }

            // need to invalidate the right end of the status bar
            // to maintain the finished edge look.
            GetClientRect(pStatusInfo->ci.hwnd, &rc);

            if (rc.right > pStatusInfo->nLastX)
                rc.left = pStatusInfo->nLastX;
            else
                rc.left = rc.right;
            rc.left -= (g_cxBorder + pStatusInfo->nBorderX);
            if (pStatusInfo->dxGripper)
                rc.left -= pStatusInfo->dxGripper;
            else
                rc.left -= pStatusInfo->nBorderPart;
            
#ifdef WINNT
            //
            // REVIEW:    Should we have to erase the bkgnd ?
            //

            InvalidateRect(pStatusInfo->ci.hwnd, &rc, TRUE);
#else
            InvalidateRect(pStatusInfo->ci.hwnd, &rc, FALSE);
#endif
            RecalcTooltipRects(pStatusInfo);
            pStatusInfo->nLastX = rc.right;
            break;
        }

        case WM_PRINTCLIENT:
        case WM_PAINT:
            if (!pStatusInfo)
                break;

            if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
                PaintStatusWnd(pStatusInfo, (HDC)wParam, pStatusInfo->sInfo, pStatusInfo->nParts, pStatusInfo->nBorderX);
            else
                PaintStatusWnd(pStatusInfo, (HDC)wParam, &pStatusInfo->sSimple, 1, 0);

            return 0;       

        case WM_ERASEBKGND:
            if (pStatusInfo) {                    
               if (pStatusInfo->_clrBk != CLR_DEFAULT) {
                    RECT rc;
                    GetClientRect(hWnd, &rc);            
                    FillRectClr((HDC)wParam, &rc, pStatusInfo->_clrBk);        
                    return 1;
                }
            }
            goto DoDefault;

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_STATUS;
            goto DoDefault;

        default:
        {
            LRESULT lres;
            if (CCWndProc(&pStatusInfo->ci, uMsg, wParam, lParam, &lres))
                return lres;
        }
            break;
    }

DoDefault:
    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

#pragma code_seg(CODESEG_INIT)

BOOL FAR PASCAL InitStatusClass(HINSTANCE hInstance)
{
    WNDCLASS rClass;

    if (!GetClassInfo(hInstance, c_szStatusClass, &rClass))
    {
#ifndef WIN32
        extern LRESULT CALLBACK _StatusWndProc(HWND, UINT, WPARAM, LPARAM);
        rClass.lpfnWndProc        = _StatusWndProc;
#else
        rClass.lpfnWndProc        = StatusWndProc;
#endif
        rClass.style            = CS_DBLCLKS | CS_GLOBALCLASS |    CS_VREDRAW;
        rClass.cbClsExtra         = 0;
        rClass.cbWndExtra         = sizeof(PSTATUSINFO);
        rClass.hInstance        = hInstance;
        rClass.hIcon            = NULL;
        rClass.hCursor            = LoadCursor(NULL, IDC_ARROW);
        rClass.hbrBackground    = (HBRUSH)(COLOR_BTNFACE+1);
        rClass.lpszMenuName     = NULL;
        rClass.lpszClassName    = c_szStatusClass;

        return RegisterClass(&rClass);
    }
    return TRUE;
}
#pragma code_seg()


HWND WINAPI CreateStatusWindow(LONG style, LPCTSTR pszText, HWND hwndParent, UINT uID)
{
    // remove border styles to fix capone and other apps

    return CreateWindowEx(0, c_szStatusClass, pszText, style & ~(WS_BORDER | CCS_NODIVIDER),
        -100, -100, 10, 10, hwndParent, IntToPtr_(HMENU, uID), HINST_THISDLL, NULL);
}

#ifdef UNICODE
HWND WINAPI CreateStatusWindowA(LONG style, LPCSTR pszText, HWND hwndParent,
        UINT uID)
{
    // remove border styles to fix capone and other apps

    return CreateWindowExA(0, STATUSCLASSNAMEA, pszText, style & ~(WS_BORDER | CCS_NODIVIDER),
        -100, -100, 10, 10, hwndParent, IntToPtr_(HMENU, uID), HINST_THISDLL, NULL);
}
#else
HWND WINAPI CreateStatusWindowW(LONG style, LPCWSTR pszText, HWND hwndParent,
        UINT uID)
{
    SetLastErrorEx(ERROR_CALL_NOT_IMPLEMENTED, SLE_WARNING);
    return NULL;
}

#endif

void WINAPI DrawStatusTextEx(PSTATUSINFO pStatusInfo, HDC hDC, LPRECT lprc, LPCTSTR pszText, STRINGINFO * psi,  UINT uFlags)
{
    int len, nWidth = 0, nHeight = 0;
    HBRUSH hFaceBrush=NULL;
    COLORREF crTextColor, crBkColor;
    UINT uOpts = 0;
    BOOL bNull;
    int nOldMode;
    int i = 0, left = 0;
    LPTSTR lpTab, lpNext;
    TCHAR szBuf[MAX_STATUS_TEXT_LEN];
#if defined(WINDOWS_ME)
    int oldAlign;
#endif
    BOOL fDrawnIcon = FALSE;
    RECT rc = * lprc;

    //
    // IMPORTANT NOTE:
    // pStatusInfo can be NULL, please check before reference.
    //

#if defined(WINDOWS_ME)
    if (uFlags & SBT_RTLREADING)
    {
        oldAlign = GetTextAlign(hDC);
        SetTextAlign(hDC, oldAlign | TA_RTLREADING);
    }
#endif
    if (pszText)
        lstrcpyn(szBuf, pszText, ARRAYSIZE(szBuf));
    else
        szBuf[0] = TEXT('\0');

    //
    // Create the three brushes we need.    If the button face is a solid
    // color, then we will just draw in opaque, instead of using a
    // brush to avoid the flash
    //
    if (GetNearestColor(hDC, g_clrBtnFace) == g_clrBtnFace ||
        !(hFaceBrush = CreateSolidBrush(g_clrBtnFace)))
    {
        uOpts = ETO_CLIPPED | ETO_OPAQUE;
        nOldMode = SetBkMode(hDC, OPAQUE);
    }
    else
    {
        uOpts = ETO_CLIPPED;
        nOldMode = SetBkMode(hDC, TRANSPARENT);
    }
    crTextColor = SetTextColor(hDC, g_clrBtnText);
    if (pStatusInfo && (pStatusInfo->_clrBk != CLR_DEFAULT))
        crBkColor = SetBkColor(hDC, pStatusInfo->_clrBk);
    else
        crBkColor = SetBkColor(hDC, g_clrBtnFace);

    // Draw the hilites

    if (!(uFlags & SBT_NOBORDERS))
        // BF_ADJUST does the InflateRect stuff
        DrawEdge(hDC, &rc, (uFlags & SBT_POPOUT) ? BDR_RAISEDINNER : BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);
    else
        InflateRect(&rc, -g_cxBorder, -g_cyBorder);
        
    if (hFaceBrush)
    {
        HBRUSH hOldBrush = SelectObject(hDC, hFaceBrush);
        if (hOldBrush)
        {
            PatBlt(hDC, rc.left, rc.top,
                   rc.right-rc.left, rc.bottom-rc.top, PATCOPY);
            SelectObject(hDC, hOldBrush);
        }
    }

    for (i=0, lpNext=szBuf, bNull=FALSE; i<3; ++i)
    {
        int cxIcon = 0;
        int leftIcon;
        UINT uiCodePage = pStatusInfo? pStatusInfo->uiCodePage: CP_ACP;
        /* Optimize for NULL left or center strings
         */
        if (!(uFlags & SBT_NOTABPARSING)) {
            if (*lpNext==TEXT('\t') && i<=1)
            {
                ++lpNext;
                continue;
            }
        }

        /* Determine the end of the current string
         */
        for (lpTab=lpNext; ; lpTab=CharNextEx((WORD)uiCodePage, lpTab, 0))
        {
            if (!*lpTab) {
                bNull = TRUE;
                break;
            } else if (!(uFlags & SBT_NOTABPARSING)) {
                if (*lpTab == TEXT('\t'))
                    break;
            }
        }
        *lpTab = TEXT('\0');
        len = lstrlen(lpNext);

        /* i=0 means left, 1 means center, and 2 means right justified text
         */
        MGetTextExtent(hDC, lpNext, len, &nWidth, &nHeight);

        if (psi) {
            if (psi->hIcon && !fDrawnIcon) {
                cxIcon = psi->sizeIcon.cx + g_cxEdge * 2;
                fDrawnIcon = TRUE;
            }
        }

        switch (i) {
            case 0:
                leftIcon = lprc->left + g_cxEdge;
                break;

            case 1:
                leftIcon = (lprc->left + lprc->right - (nWidth + cxIcon)) / 2;
                break;

            default:
                leftIcon = lprc->right - g_cxEdge - (nWidth + cxIcon);
                break;
        }    
        
        left = leftIcon + cxIcon;

        if (psi)
        {
            if (cxIcon) {
                int nTop = rc.top + ((rc.bottom - rc.top)  - (psi->sizeIcon.cy )) / 2 ;

                if (leftIcon > lprc->left)
                {
                    if (psi->hIcon)
                    {
                        DrawIconEx(hDC, leftIcon, nTop, psi->hIcon,
                                   psi->sizeIcon.cx, psi->sizeIcon.cy, 
                                   0, NULL, DI_NORMAL);
                    }
                }
                rc.left = leftIcon + cxIcon;
            }

            if (!*lpNext && cxIcon)
                psi->fNeedToTip = TRUE;
            else 
                psi->fNeedToTip  = (BOOL)(nWidth >= (rc.right - rc.left));
        }

        ExtTextOut(hDC, left, (rc.bottom - nHeight + rc.top) / 2, uOpts, &rc, lpNext, len, NULL);

        /* Now that we have drawn text once, take off the OPAQUE flag
         */
        uOpts = ETO_CLIPPED;

        if (bNull)
            break;

        *lpTab = TEXT('\t');
        lpNext = lpTab + 1;
    }

#if defined(WINDOWS_ME)
    if (uFlags & SBT_RTLREADING)
        SetTextAlign(hDC, oldAlign);
#endif

    SetTextColor(hDC, crTextColor);
    SetBkColor(hDC, crBkColor);
    SetBkMode(hDC, nOldMode);

    if (hFaceBrush)
        DeleteObject(hFaceBrush);

}

void RecalcTooltipRects(PSTATUSINFO pStatusInfo)
{
    if(pStatusInfo->hwndToolTips) 
    {
        UINT i;
        TOOLINFO ti;
        STRINGINFO * psi;

        ti.cbSize = sizeof(ti);
        ti.hwnd = pStatusInfo->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;

        if (pStatusInfo->sSimple.uType & SBT_NOSIMPLE)
        {
            for ( i = 0, psi = pStatusInfo->sInfo; i < (UINT)pStatusInfo->nParts; i++, psi++) 
            {
                ti.uId = i;
                Status_GetRect(pStatusInfo, i, &ti.rect);
                SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            }
            SetRect(&ti.rect, 0,0,0,0);
            ti.uId = SB_SIMPLEID;
            SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
        }
        else
        {

            GetClientRect(pStatusInfo->ci.hwnd, &ti.rect);
            InflateRect(&ti.rect, -g_cxBorder, -g_cyBorder);
            ti.uId = SB_SIMPLEID;
            SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            SetRect(&ti.rect, 0,0,0,0);
            for ( i = 0, psi = pStatusInfo->sInfo; i < (UINT)pStatusInfo->nParts; i++, psi++) 
            {
                ti.uId = i;
                SendMessage(pStatusInfo->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            }
        }
    }    
   return;
}

PSTRINGINFO GetStringInfo(PSTATUSINFO pStatusInfo, int nIndex)
{
    PSTRINGINFO pRet = NULL;

    if (nIndex == SB_SIMPLEID)
        pRet = &pStatusInfo->sSimple;
    else if (nIndex < pStatusInfo->nParts)
        pRet = &pStatusInfo->sInfo[nIndex];

    return pRet;
}

int  IndexFromPt(PSTATUSINFO pStatusInfo, POINT pt)
{
    RECT rc;
    int nPart = 0;

    //
    //  More IE4 bug-for-bug compatibility.  IE4 tested for simple mode
    //  incorrectly.
    //
    if (pStatusInfo->ci.iVersion < 5)
    {
        // This is not a typo!  Well, actually, it *is* a typo, but it's
        // a typo we have to preserve for compatibility.  I don't know if
        // anybody relied on the typo, but I'm playing it safe.
        //
        // The bug was that in IE4, a click on a simple status bar usually
        // came back as SB_HITTEST_NOITEM instead of SB_SIMPLEID.
        //
        // I re-parenthesized the test so typo.pl won't trigger.  The original
        // IE4 code lacked the parentheses.

        if ((!pStatusInfo->sSimple.uType) & SBT_NOSIMPLE)
            return SB_SIMPLEID;
    }
    else
    {
        if (!(pStatusInfo->sSimple.uType & SBT_NOSIMPLE))
            return SB_SIMPLEID;
    }

    for(nPart = 0; nPart < pStatusInfo->nParts; nPart++)
    {
        Status_GetRect(pStatusInfo, nPart, &rc);
        if (PtInRect(&rc, pt))
            return nPart;
    }
    return SB_HITTEST_NOITEM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\subclass.c ===
#include "ctlspriv.h"

///////////////////////////////////////////////////////////////////////////////
// SUBCLASS.C -- subclassing helper functions
//
//      SetWindowSubclass
//      GetWindowSubclass
//      RemoveWindowSubclass
//      DefSubclassProc
//
//  This module defines helper functions that make subclassing windows safe(er)
// and easy(er).  The code maintains a single property on the subclassed window
// and dispatches various "subclass callbacks" to its clients a required.  The
// client is provided reference data and a simple "default processing" API.
//
// Semantics:
//  A "subclass callback" is identified by a unique pairing of a callback
// function pointer and an unsigned ID value.  Each callback can also store a
// single DWORD of reference data, which is passed to the callback function
// when it is called to filter messages.  No reference counting is performed
// for the callback, it may repeatedly call the SetWindowSubclass API to alter
// the value of its reference data element as desired.
//
// Warning: You cannot use these to subclass a window across threads since
//          the critical sections have been removed. 05-May-97
//
// History:
//  26-April-96  francish        Created.
//  05-May  -97  davidds         Stopped serializing the world.
///////////////////////////////////////////////////////////////////////////////
//
// NOTE: Although a linked list would have made the code slightly simpler, this
// module uses a packed callback array to avoid unneccessary fragmentation.  fh
//
struct _SUBCLASS_HEADER;

typedef struct
{
    SUBCLASSPROC    pfnSubclass;        // subclass procedure
    WPARAM          uIdSubclass;        // unique subclass identifier
    DWORD_PTR        dwRefData;          // optional ref data

} SUBCLASS_CALL;

typedef struct _SUBCLASS_FRAME
{
    UINT uCallIndex;                    // index of next callback to call
    UINT uDeepestCall;                  // deepest uCallIndex on stack
    struct _SUBCLASS_FRAME *pFramePrev; // previous subclass frame pointer
    struct _SUBCLASS_HEADER *pHeader;   // header associated with this frame

} SUBCLASS_FRAME;

typedef struct _SUBCLASS_HEADER
{
    UINT uRefs;                         // subclass count
    UINT uAlloc;                        // allocated subclass call nodes
    UINT uCleanup;                      // index of call node to clean up
    DWORD dwThreadId;                   // thread id of window we are hooking
    SUBCLASS_FRAME *pFrameCur;          // current subclass frame pointer
    SUBCLASS_CALL CallArray[1];         // base of packed call node array

} SUBCLASS_HEADER;

#define CALLBACK_ALLOC_GRAIN (3)        // 1 defproc, 1 subclass, 1 spare


#ifdef DEBUG
BOOL IsValidPSUBCLASS_CALL(SUBCLASS_CALL * pcall)
{
    return (IS_VALID_WRITE_PTR(pcall, SUBCLASS_CALL) &&
            (NULL == pcall->pfnSubclass || IS_VALID_CODE_PTR(pcall->pfnSubclass, SUBCLASSPROC)));
}   


BOOL IsValidPSUBCLASS_FRAME(SUBCLASS_FRAME * pframe)
{
    return (IS_VALID_WRITE_PTR(pframe, SUBCLASS_FRAME) && 
            IS_VALID_WRITE_PTR(pframe->pHeader, SUBCLASS_HEADER) &&
            (NULL == pframe->pFramePrev || IS_VALID_WRITE_PTR(pframe->pFramePrev, SUBCLASS_FRAME)));
}    
 

BOOL IsValidPSUBCLASS_HEADER(SUBCLASS_HEADER * phdr)
{
    BOOL bRet = (IS_VALID_WRITE_PTR(phdr, SUBCLASS_HEADER) &&
                 (NULL == phdr->pFrameCur || IS_VALID_STRUCT_PTR(phdr->pFrameCur, SUBCLASS_FRAME)) &&
                 IS_VALID_WRITE_BUFFER(phdr->CallArray, SUBCLASS_CALL, phdr->uAlloc));

    if (bRet)
    {
        UINT i;
        SUBCLASS_CALL * pcall = phdr->CallArray;

        for (i = 0; i < phdr->uRefs; i++, pcall++)
        {
            if (!IS_VALID_STRUCT_PTR(pcall, SUBCLASS_CALL))
                return FALSE;
        }
    }
    return bRet;
}    

#endif

///////////////////////////////////////////////////////////////////////////////
// DEBUG CODE TO CHECK IF WINDOW IS ON SAME THREAD AS CALLER
// Since we don't do any serialization, we need this to make sure of this.
///////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG
BOOL IsWindowOnCurrentThread(HWND hWnd)
{
    DWORD foo;

    if (!IsWindow(hWnd))
        // bail if the window is dead so we dont bogusly rip
        return(TRUE);
    
    if (GetCurrentThreadId() != GetWindowThreadProcessId(hWnd, &foo))
    {
        DebugMsg(TF_ALWAYS, TEXT("wn: WindowSubclass - Called from wrong thread %08X"), hWnd);
        return(FALSE);
    }
    else
        return(TRUE);
              
}
#endif

///////////////////////////////////////////////////////////////////////////////
LRESULT CALLBACK MasterSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam);
LRESULT CallNextSubclassProc(SUBCLASS_HEADER *pHeader, HWND hWnd, UINT uMsg,
    WPARAM wParam, LPARAM lParam);

//-----------------------------------------------------------------------------
// RETAIL_ZOMBIE_MESSAGE_WNDPROC
//
// this macro controls the generation of diagnostic code for an error condition
// in the subclass code (see the SubclassDeath function below).
//
// commenting out this macro will zombie windows using DefWindowProc instead.
//
//-----------------------------------------------------------------------------
//#define RETAIL_ZOMBIE_MESSAGE_WNDPROC

#if defined(RETAIL_ZOMBIE_MESSAGE_WNDPROC) || defined(DEBUG)
#ifndef DEBUG
#pragma message("\r\nWARNING: disable retail ZombieWndProc before final release\r\n")
#endif
LRESULT ZombieWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#else
#define ZombieWndProc DefWindowProc
#endif

//-----------------------------------------------------------------------------
// SubclassDeath
//
// this function is called if we ever enter one of our subclassing procedures
// without our reference data (and hence without the previous wndproc).
//
// hitting this represents a catastrophic failure in the subclass code.
//
// the function resets the wndproc of the window to a 'zombie' window
// procedure to avoid faulting.  the RETAIL_ZOMBIE_MESSAGE_WNDPROC macro above
// controls the generation of diagnostic code for this wndproc.
//
//-----------------------------------------------------------------------------
LRESULT SubclassDeath(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    // WE SHOULD NEVER EVER GET HERE
    // if we do please find francish to debug it immediately
    //
    DebugMsg(TF_ALWAYS, TEXT("fatal: SubclassDeath in window %08X"), hWnd);

#ifdef DEBUG    
    //
    // if we are in a debugger, stop now regardless of break flags
    //
    __try { DebugBreak(); } __except(EXCEPTION_EXECUTE_HANDLER) {;} __endexcept
#endif
    
    //
    // we call the outside world so prepare to deadlock if we have the critsec
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL
#endif

    //
    // in theory we could save the original wndproc in a separate property
    // but that just wastes memory for something that should never happen
    //
    // convert this window to a zombie in hopes that it will get debugged
    //
    InvalidateRect(hWnd, NULL, TRUE);
    SubclassWindow(hWnd, ZombieWndProc);
    return ZombieWndProc(hWnd, uMsg, wParam, lParam);
}

//-----------------------------------------------------------------------------
// GetWindowProc
//
// this inline function returns the current wndproc for the specified window.
//
//-----------------------------------------------------------------------------
__inline WNDPROC GetWindowProc(HWND hWnd)
{
    return (WNDPROC)GetWindowLongPtr(hWnd, GWLP_WNDPROC);
}

//-----------------------------------------------------------------------------
// g_aCC32Subclass
//
// This is the global ATOM we use to store our SUBCLASS_HEADER property on
// random windows that come our way.
//
//  HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK
//
//  Win95's property code is BROKEN.  If you SetProp using a text string, USER
// adds and removes atoms for the property symmetrically, including when the
// window is destroyed with properties lying around (good).  Unfortunately, if
// you SetProp using a global atom, USER doesn't do things quite right in the
// window cleanup case.  It uses the atom without adding references in SetProp
// calls and without deleting them in RemoveProp calls (good so far).  However,
// when a window with one of these properties lying around is cleaned up, USER
// will delete the atom on you.  This tends to break apps that do the
// following:
//
//  - MyAtom = GlobalAddAtom("foo");            // at app startup
//  - SetProp(SomeWindow, MyAtom, MyData);
//  - <window gets destroyed, USER deletes atom>
//  - <time passes>
//  - SetProp(SomeOtherWindow, MyAtom, MyData); // fails or uses random atom
//  - GlobalDeleteAtom(MyAtom);                 // fails or deletes random atom
//
//  One might be tempted to ask why this file uses atom properties if they are
// so broken.  Put simply, it is the only way to defend yourself against other
// apps that use atom properties (like the one described above).  Imagine that
// we call SetProp(OurWindow, "bar", OurData) in some other app at about the
// <time passes> point in the sequence above.  USER has just nuked some poor
// app's atom, and we wander into SetProp, which calls GlobalAddAtom, which
// just happens to give us the free slot created by USER's window cleanup code.
// Now we have a real problem because the very same atom is sitting in some
// global variable in the other app, just waiting to be deleted when that app
// exits (Peachtree Accounting tends to be very good at this...)  Of course the
// ultimate outcome of this is that we will call GetProp in some critical
// routine and our data will have vanished (it's actually still in the window's
// property table but GetProp("bar") calls GlobalFindAtom("bar") to get the
// atom to scan the property table for; and that call will fail so the property
// will be missed and we'll get back NULL).
//
//  Basically, we create an atom and aggressively increment its reference count
// so that it can withstand a few GlobalDeleteAtom calls every now and then.
// Since we are using an atom property, we need to worry about USER's cleanup
// code nuking us too.  Thus we just keep incrementing the reference count
// until it pegs.
//
// IEUNIX 
// We doesn't have the above problems, but MainWin SetProp implementation
// doesn't create GlobalAtom when it gets 2nd argument as a string.
// And it doesn't have to - that's non-documented NT/Win95 implementation.
// So, if UNIX, we will use the ATOM in all the cases, marking #ifdef MAINWIN.
//
//  HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK
//
//-----------------------------------------------------------------------------
extern ATOM g_aCC32Subclass;

//-----------------------------------------------------------------------------
// FastGetSubclassHeader
//
// this inline function returns the subclass header for the specified window.
// if the window has no subclass header the return value is NULL.
//
//-----------------------------------------------------------------------------
__inline SUBCLASS_HEADER *FastGetSubclassHeader(HWND hWnd)
{
    return  (g_aCC32Subclass ?
            ((SUBCLASS_HEADER *)GetProp(hWnd, MAKEINTATOM(g_aCC32Subclass))) :
            NULL);
}

//-----------------------------------------------------------------------------
// GetSubclassHeader
//
// this function returns the subclass header for the specified window.  it
// fails if the caller is on the wrong process, but will allow the caller to
// get the header from a thread other than the specified window's thread.
//
//-----------------------------------------------------------------------------
SUBCLASS_HEADER *GetSubclassHeader(HWND hWnd)
{
    DWORD dwProcessId;

    //
    // only return the header if we are in the right process
    //
    if (!GetWindowThreadProcessId(hWnd, &dwProcessId))
        dwProcessId = 0;

    if (dwProcessId != GetCurrentProcessId())
    {
        if (dwProcessId)
            DebugMsg(TF_ALWAYS, TEXT("error: XxxWindowSubclass - wrong process for window %08X"), hWnd);

        ASSERT(FALSE);
        return NULL;
    }

    //
    // return the header
    //
    return FastGetSubclassHeader(hWnd);
}

//-----------------------------------------------------------------------------
// SetSubclassHeader
//
// this function sets the subclass header for the specified window.
//
//-----------------------------------------------------------------------------
BOOL SetSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader,
    SUBCLASS_FRAME *pFrameFixup)
{
    ATOM a;
    BOOL fResult = TRUE;    // assume success

    ASSERT(NULL == pHeader || IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));
    ASSERT(NULL == pFrameFixup || IS_VALID_STRUCT_PTR(pFrameFixup, SUBCLASS_FRAME));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we are partying on the header and frame list
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));
#endif


    if (g_aCC32Subclass == 0) {
        //
        // HACK: we are intentionally incrementing the refcount on this atom
        // WE DO NOT WANT IT TO GO BACK DOWN so we will not delete it in process
        // detach (see comments for g_aCC32Subclass in subclass.c for more info)
        //
        if ((a = GlobalAddAtom(c_szCC32Subclass)) != 0)
            g_aCC32Subclass = a;    // in case the old atom got nuked
    }


    //
    // update the frame list if required
    //
    while (pFrameFixup)
    {
        pFrameFixup->pHeader = pHeader;
        pFrameFixup = pFrameFixup->pFramePrev;
    }

    //
    // do we have a window to update?
    //
    if (hWnd)
    {
        //
        // update/remove the property as required
        //
        if (!pHeader)
        {
            //
            // HACK: we remove with an ATOM so the refcount won't drop
            //          (see comments for g_aCC32Subclass above)
            //
            RemoveProp(hWnd, MAKEINTATOM(g_aCC32Subclass));
        }
        else
        {
            LPCTSTR lpPropAtomOrStr;
#ifndef MAINWIN
            //
            // HACK: we add using a STRING so the refcount will go up
            //          (see comments for g_aCC32Subclass above)
            //
            lpPropAtomOrStr = c_szCC32Subclass;
#else
            if (! g_aCC32Subclass) 
                g_aCC32Subclass = GlobalAddAtom(c_szCC32Subclass);
        
            if (! g_aCC32Subclass) {
                DebugMsg(TF_ALWAYS, TEXT("wn: SetWindowSubclass - couldn't subclass window %08X\
                         GlobalAddAtom failed for %s"), hWnd, c_szCC32Subclass);
                return FALSE;
            }
            lpPropAtomOrStr = g_aCC32Subclass;
#endif
            if (!SetProp(hWnd, lpPropAtomOrStr, (HANDLE)pHeader))
            {
                DebugMsg(TF_ALWAYS, TEXT("wn: SetWindowSubclass - couldn't subclass window %08X"), hWnd);
                fResult = FALSE;
            }
        }
    }

    return fResult;
}

//-----------------------------------------------------------------------------
// FreeSubclassHeader
//
// this function frees the subclass header for the specified window.
//
//-----------------------------------------------------------------------------
void FreeSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;                 // we will be removing the subclass header
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // sanity
    //
    if (!pHeader)
    {
        ASSERT(FALSE);
        return;
    }

    //
    // clean up the header
    //
    SetSubclassHeader(hWnd, NULL, pHeader->pFrameCur);
    LocalFree((HANDLE)pHeader);
}

//-----------------------------------------------------------------------------
// ReAllocSubclassHeader
//
// this function allocates/reallocates a subclass header for the specified
// window.
//
//-----------------------------------------------------------------------------
SUBCLASS_HEADER *ReAllocSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader,
    UINT uCallbacks)
{
    UINT uAlloc;

    ASSERT(NULL == pHeader || IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we will be replacing the subclass header
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // granularize the allocation
    //
    uAlloc = CALLBACK_ALLOC_GRAIN *
        ((uCallbacks + CALLBACK_ALLOC_GRAIN - 1) / CALLBACK_ALLOC_GRAIN);

    //
    // do we need to change the allocation?
    //
    if (!pHeader || (uAlloc != pHeader->uAlloc))
    {
        //
        // compute bytes required
        //
        uCallbacks = uAlloc * sizeof(SUBCLASS_CALL) + sizeof(SUBCLASS_HEADER);

        //
        // and try to alloc
        //
        pHeader = CCLocalReAlloc(pHeader, uCallbacks);

        //
        // did it work?
        //
        if (pHeader)
        {
            //
            // yup, update info
            //
            pHeader->uAlloc = uAlloc;

            if (!SetSubclassHeader(hWnd, pHeader, pHeader->pFrameCur))
            {
                FreeSubclassHeader(hWnd, pHeader);
                pHeader = NULL;
            }

        }
    }

    ASSERT(pHeader);
    return pHeader;
}

//-----------------------------------------------------------------------------
// CallOriginalWndProc
//
// this procedure is the default SUBCLASSPROC which is always installed when we
// subclass a window.  the original window procedure is installed as the
// reference data for this callback.  it simply calls the original wndproc and
// returns its result.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK CallOriginalWndProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    //
    // dwRefData should be the original window procedure
    //
    ASSERT(dwRefData);

    //
    // and call it
    //
    return CallWindowProc((WNDPROC)dwRefData, hWnd, uMsg, wParam, lParam);
}

//-----------------------------------------------------------------------------
// AttachSubclassHeader
//
// this procedure makes sure that a given window is subclassed by us.  it
// maintains a reference count on the data structures associated with our
// subclass.  if the window is not yet subclassed by us then this procedure
// installs our subclass procedure and associated data structures.
//
//-----------------------------------------------------------------------------
SUBCLASS_HEADER *AttachSubclassHeader(HWND hWnd)
{
    SUBCLASS_HEADER *pHeader;
    DWORD dwThreadId;

    //
    // we party on the subclass call chain here
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // we only call SetWindowLong for the first caller, which would cause this
    // operation to work out of context sometimes and fail others...
    // artifically prevent people from subclassing from the wrong thread
    //  
    if ((dwThreadId = GetWindowThreadProcessId(hWnd, NULL)) !=
        GetCurrentThreadId())
    {
        AssertMsg(FALSE, TEXT("error: SetWindowSubclass - wrong thread for window %08X"), hWnd);
        return NULL;
    }

    //
    // if haven't already subclassed the window then do it now
    //
    if ((pHeader = GetSubclassHeader(hWnd)) == NULL)
    {
        WNDPROC pfnOldWndProc;
        SUBCLASS_CALL *pCall;

        //
        // attach our header data to the window
        // we need space for two callbacks; the subclass and the original proc
        //
        if ((pHeader = ReAllocSubclassHeader(hWnd, NULL, 2)) == NULL)
            return NULL;

        pHeader->dwThreadId = dwThreadId;

        //
        // actually subclass the window
        //
        if ((pfnOldWndProc = SubclassWindow(hWnd, MasterSubclassProc)) == NULL)
        {
            // clean up and get out
            FreeSubclassHeader(hWnd, pHeader);
            return NULL;
        }

        //
        // set up the first node in the array to call the original wndproc
        //
        ASSERT(pHeader->uAlloc);

        pCall = pHeader->CallArray;
        pCall->pfnSubclass = CallOriginalWndProc;
        pCall->uIdSubclass = 0;
        pCall->dwRefData   = (DWORD_PTR)pfnOldWndProc;

        //
        // init our subclass refcount...
        //
        pHeader->uRefs = 1;
    }

    return pHeader;
}

//-----------------------------------------------------------------------------
// DetachSubclassHeader
//
// this procedure attempts to detach the subclass header from the specified
// window
//
//-----------------------------------------------------------------------------
void DetachSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader, BOOL fForce)
{
    WNDPROC pfnOldWndProc;
#ifdef DEBUG
    SUBCLASS_CALL *pCall;
    UINT uCur;
#endif

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we party on the subclass call chain here
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    ASSERT(pHeader);        // fear

    //
    // if we are not being forced to remove and the window is still valid then
    // sniff around a little and decide if it's a good idea to detach now
    //
    if (!fForce && hWnd)
    {
        ASSERT(pHeader == FastGetSubclassHeader(hWnd)); // paranoia

        //
        // do we still have active clients?
        //
        if (pHeader->uRefs > 1)
            return;

        ASSERT(pHeader->uRefs); // should always have the "call original" node

        //
        // are people on our stack?
        //
        if (pHeader->pFrameCur)
            return;

        //
        // if we are out of context then we should try again later
        //
        if (pHeader->dwThreadId != GetCurrentThreadId())
        {
            SendNotifyMessage(hWnd, WM_NULL, 0, 0L);
            return;
        }

        //
        // we keep the original window procedure as refdata for our
        // CallOriginalWndProc subclass callback
        //
        pfnOldWndProc = (WNDPROC)pHeader->CallArray[0].dwRefData;
        ASSERT(pfnOldWndProc);

        //
        // if somebody else is subclassed after us then we can't detach now
        //
        if (GetWindowProc(hWnd) != MasterSubclassProc)
            return;

        //
        // go ahead and try to detach
        //
        if (!SubclassWindow(hWnd, pfnOldWndProc))
        {
            ASSERT(FALSE);      // just plain shouldn't happen
            return;
        }
    }

    //
    // warn about anybody who hasn't unhooked yet
    //
#ifdef DEBUG
    uCur = pHeader->uRefs;
    pCall = pHeader->CallArray + uCur;
    while (--uCur)          // don't complain about our 'call original' node
    {
        pCall--;
        if (pCall->pfnSubclass)
        {
            //
            // always warn about these they could be leaks
            //
            DebugMsg(TF_ALWAYS, TEXT("warning: orphan subclass: fn %08X, id %08X, dw %08X"),
                pCall->pfnSubclass, pCall->uIdSubclass, pCall->dwRefData);
        }
    }
#endif

    //
    // free the header now
    //
    FreeSubclassHeader(hWnd, pHeader);
}

//-----------------------------------------------------------------------------
// PurgeSingleCallNode
//
// this procedure purges a single dead node in the call array
//
//-----------------------------------------------------------------------------
void PurgeSingleCallNode(HWND hWnd, SUBCLASS_HEADER *pHeader)
{
    UINT uRemain;

    ASSERT(IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we will try to re-arrange the call array
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    
    if (!pHeader->uCleanup) // a little sanity
    {
        ASSERT(FALSE);      // nothing to do!
        return;
    }

    //
    // and a little paranoia
    //
    ASSERT(!pHeader->pFrameCur ||
        (pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall));

    //
    // are there any call nodes above the one we're about to remove?
    //
    if ((uRemain = (pHeader->uRefs - pHeader->uCleanup)) > 0)
    {
        //
        // yup, need to fix up the array the hard way
        //
        SUBCLASS_CALL *pCall;
        SUBCLASS_FRAME *pFrame;
        UINT uCur, uMax;

        //
        // move the remaining nodes down into the empty space
        //
        pCall = pHeader->CallArray + pHeader->uCleanup;
        MoveMemory(pCall, pCall + 1, uRemain * sizeof(SUBCLASS_CALL));

        ASSERT(IS_VALID_STRUCT_PTR(pCall, SUBCLASS_CALL));

        //
        // update the call indices of any active frames
        //
        uCur = pHeader->uCleanup;
        pFrame = pHeader->pFrameCur;
        while (pFrame)
        {
            if (pFrame->uCallIndex >= uCur)
            {
                pFrame->uCallIndex--;

                if (pFrame->uDeepestCall >= uCur)
                    pFrame->uDeepestCall--;
            }

            pFrame = pFrame->pFramePrev;
        }

        //
        // now search for any other dead call nodes in the reamining area
        //
        uMax = pHeader->uRefs - 1;  // we haven't decremented uRefs yet
        while (uCur < uMax)
        {
            if (!pCall->pfnSubclass)
                break;

            pCall++;
            uCur++;
        }
        pHeader->uCleanup = (uCur < uMax)? uCur : 0;
    }
    else
    {
        //
        // nope, this case is easy
        //
        pHeader->uCleanup = 0;
    }

    //
    // finally, decrement the client count
    //
    pHeader->uRefs--;
}

//-----------------------------------------------------------------------------
// CompactSubclassHeader
//
// this procedure attempts to compact the subclass call array, freeing the
// subclass header if the array is empty
//
//-----------------------------------------------------------------------------
void CompactSubclassHeader(HWND hWnd, SUBCLASS_HEADER *pHeader)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we will try to re-arrange the call array
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    ASSERT(IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

    //
    // we must handle the "window destroyed unexpectedly during callback" case
    //
    if (hWnd)
    {
        //
        // clean out as many dead callbacks as possible
        //
        while (pHeader->uCleanup && (!pHeader->pFrameCur ||
            (pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall)))
        {
            PurgeSingleCallNode(hWnd, pHeader);
        }

        //
        // do we still have clients?
        //
        if (pHeader->uRefs > 1)
        {
            //
            // yes, shrink our allocation, leaving room for at least one client
            //
            ReAllocSubclassHeader(hWnd, pHeader, pHeader->uRefs + 1);
            return;
        }
    }

    //
    // try to detach and free
    //
    DetachSubclassHeader(hWnd, pHeader, FALSE);
}

//-----------------------------------------------------------------------------
// FindCallRecord
//
// this procedure searches for a call record with the specified subclass proc
// and id, and returns its address.  if no such call record is found then NULL
// is returned.
//
//-----------------------------------------------------------------------------
SUBCLASS_CALL *FindCallRecord(SUBCLASS_HEADER *pHeader,
    SUBCLASSPROC pfnSubclass, WPARAM uIdSubclass)
{
    SUBCLASS_CALL *pCall;
    UINT uCallIndex;

    ASSERT(IS_VALID_STRUCT_PTR(pHeader, SUBCLASS_HEADER));

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;         // we'll be scanning the call array
#endif

    //
    // scan the call array.  note that we assume there is always at least
    // one member in the table (our CallOriginalWndProc record)
    //
    pCall = pHeader->CallArray + (uCallIndex = pHeader->uRefs);
    do
    {
        uCallIndex--;
        pCall--;
        if ((pCall->pfnSubclass == pfnSubclass) &&
            (pCall->uIdSubclass == uIdSubclass))
        {
            return pCall;
        }
    }
    while (uCallIndex != (UINT)-1);

    return NULL;
}

//-----------------------------------------------------------------------------
// GetWindowSubclass
//
// this procedure retrieves the reference data for the specified window
// subclass callback
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL) GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR *pdwRefData)
{
    SUBCLASS_HEADER *pHeader;
    SUBCLASS_CALL *pCall;
    BOOL fResult = FALSE;
    DWORD_PTR dwRefData = 0;

    //
    // sanity
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("error: GetWindowSubclass - %08X not a window"), hWnd);
        goto ReturnResult;
    }

    //
    // more sanity
    //
    if (!pfnSubclass
#ifdef DEBUG
        || IsBadCodePtr((PROC)pfnSubclass)
#endif
        )
    {
        AssertMsg(FALSE, TEXT("error: GetWindowSubclass - invalid callback %08X"), pfnSubclass);
        goto ReturnResult;
    }

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    
    //
    // if we've subclassed it and they are a client then get the refdata
    //
    if (((pHeader = GetSubclassHeader(hWnd)) != NULL) &&
        ((pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) != NULL))
    {
        //
        // fetch the refdata and note success
        //
        dwRefData = pCall->dwRefData;
        fResult = TRUE;
    }

#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // we always fill in/zero pdwRefData regradless of result
    //
ReturnResult:
    if (pdwRefData)
        *pdwRefData = dwRefData;

    return fResult;
}

//-----------------------------------------------------------------------------
// SetWindowSubclass
//
// this procedure installs/updates a window subclass callback.  subclass
// callbacks are identified by their callback address and id pair.  if the
// specified callback/id pair is not yet installed then the procedure installs
// the pair.  if the callback/id pair is already installed then this procedure
// changes the refernce data for the pair.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL) SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData)
{
    SUBCLASS_HEADER *pHeader;
    SUBCLASS_CALL *pCall;
    BOOL bResult;

    //
    // some sanity
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("error: SetWindowSubclass - %08X not a window"), hWnd);
        return FALSE;
    }

    //
    // more sanity
    //
    if (!pfnSubclass
#ifdef DEBUG
        || IsBadCodePtr((PROC)pfnSubclass)
#endif
        )
    {
        AssertMsg(FALSE, TEXT("error: SetWindowSubclass - invalid callback %08X"), pfnSubclass);
        return FALSE;
    }

    bResult = FALSE;    // assume failure


    //
    // we party on the subclass call chain here

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    //
    // actually subclass the window
    //
    if ((pHeader = AttachSubclassHeader(hWnd)) == NULL)
        goto bail;

    //
    // find a call node for this caller
    //
    if ((pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) == NULL)
    {
        //
        // not found, alloc a new one
        //
        SUBCLASS_HEADER *pHeaderT =
            ReAllocSubclassHeader(hWnd, pHeader, pHeader->uRefs + 1);

        if (!pHeaderT)
        {
            //
            // re-query in case it is already gone
            //
            if ((pHeader = FastGetSubclassHeader(hWnd)) != NULL)
                CompactSubclassHeader(hWnd, pHeader);

            goto bail;
        }

        pHeader = pHeaderT;
        pCall = pHeader->CallArray + pHeader->uRefs;
        pHeader->uRefs++;
    }

    //
    // fill in the subclass call data
    //
    pCall->pfnSubclass = pfnSubclass;
    pCall->uIdSubclass = uIdSubclass;
    pCall->dwRefData   = dwRefData;

    bResult = TRUE;

bail:
    //
    // release the critical section and return the result
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    return bResult;
}

//-----------------------------------------------------------------------------
// RemoveWindowSubclass
//
// this procedure removes a subclass callback from a window.  subclass
// callbacks are identified by their callback address and id pair.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL) RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass)
{
    SUBCLASS_HEADER *pHeader;
    SUBCLASS_CALL *pCall;
    BOOL bResult;
    UINT uCall;

    //
    // some sanity
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("error: RemoveWindowSubclass - %08X not a window"), hWnd);
        return FALSE;
    }

    //
    // more sanity
    //
    if (!pfnSubclass
#ifdef DEBUG
        || IsBadCodePtr((PROC)pfnSubclass)
#endif
        )
    {
        AssertMsg(FALSE, TEXT("error: RemoveWindowSubclass - invalid callback %08X"), pfnSubclass);
        return FALSE;
    }

    bResult = FALSE;    // assume failure

    //
    // we party on the subclass call chain here

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // obtain our subclass data
    //
    if ((pHeader = GetSubclassHeader(hWnd)) == NULL)
        goto bail;

    //
    // find the callback to remove
    //
    if ((pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) == NULL)
        goto bail;

    //
    // disable this node and remember that we have something to clean up
    //
    pCall->pfnSubclass = NULL;

    uCall = (UINT) (pCall - pHeader->CallArray);

    if (!pHeader->uCleanup || (uCall < pHeader->uCleanup))
        pHeader->uCleanup = uCall;

    //
    // now try to clean up any unused nodes
    //
    CompactSubclassHeader(hWnd, pHeader);
#ifdef DEBUG
    // the call above can realloc or free the subclass header for this window
    pHeader = NULL;
#endif

    bResult = TRUE;     // it worked

bail:
    //
    // release the critical section and return the result
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    return bResult;
}

//-----------------------------------------------------------------------------
// DefSubclassProc
//
// this procedure calls the next handler in the window's subclass chain.  the
// last handler in the subclass chain is installed by us, and calls the
// original window procedure for the window.
//
//-----------------------------------------------------------------------------
STDAPI_(LRESULT) DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult = 0L;

    //
    // make sure the window is still valid
    //
    if (!IsWindow(hWnd))
    {
        AssertMsg(FALSE, TEXT("warning: DefSubclassProc - %08X not a window"), hWnd);
        goto BailNonCritical;
    }

    //
    // take the critical section while we figure out who to call next
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
        
    //
    // complain if we are being called improperly
    //
    if ((pHeader = FastGetSubclassHeader(hWnd)) == NULL)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - window %08X not subclassed"), hWnd);
        goto BailCritical;
    }
    else if (GetCurrentThreadId() != pHeader->dwThreadId)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - wrong thread for window %08X"), hWnd);
        goto BailCritical;
    }
    else if (!pHeader->pFrameCur)
    {
        AssertMsg(FALSE, TEXT("error: DefSubclassProc - window %08X not in callback"), hWnd);
        goto BailCritical;
    }

    //
    // call the next proc in the subclass chain
    //
    // WARNING: this call temporarily releases the critical section
    // WARNING: pHeader is invalid when this call returns
    //
    lResult = CallNextSubclassProc(pHeader, hWnd, uMsg, wParam, lParam);
#ifdef DEBUG
    pHeader = NULL;
#endif

    //
    // return the result
    //
BailCritical:
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

BailNonCritical:
    return lResult;
}

//-----------------------------------------------------------------------------
// UpdateDeepestCall
//
// this procedure updates the deepest call index for the specified frame
//
//-----------------------------------------------------------------------------
void UpdateDeepestCall(SUBCLASS_FRAME *pFrame)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the frame list
#endif

    if (pFrame->pFramePrev &&
        (pFrame->pFramePrev->uDeepestCall < pFrame->uCallIndex))
    {
        pFrame->uDeepestCall = pFrame->pFramePrev->uDeepestCall;
    }
    else
        pFrame->uDeepestCall = pFrame->uCallIndex;
}

//-----------------------------------------------------------------------------
// EnterSubclassFrame
//
// this procedure sets up a new subclass frame for the specified header, saving
// away the previous one
//
//-----------------------------------------------------------------------------
__inline void EnterSubclassFrame(SUBCLASS_HEADER *pHeader,
    SUBCLASS_FRAME *pFrame)
{
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the header and frame list
#endif

    //
    // fill in the frame and link it into the header
    //
    pFrame->uCallIndex   = pHeader->uRefs;
    pFrame->pFramePrev   = pHeader->pFrameCur;
    pFrame->pHeader      = pHeader;
    pHeader->pFrameCur   = pFrame;

    //
    // initialize the deepest call index for this frame
    //
    UpdateDeepestCall(pFrame);
}

//-----------------------------------------------------------------------------
// LeaveSubclassFrame
//
// this procedure cleans up the current subclass frame for the specified
// header, restoring the previous one
//
//-----------------------------------------------------------------------------
__inline SUBCLASS_HEADER *LeaveSubclassFrame(SUBCLASS_FRAME *pFrame)
{
    SUBCLASS_HEADER *pHeader;

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // we are partying on the header
#endif

    //
    // unlink the frame from its header (if it still exists)
    //
    if ((pHeader = pFrame->pHeader) != NULL)
        pHeader->pFrameCur = pFrame->pFramePrev;

    return pHeader;
}

//-----------------------------------------------------------------------------
// SubclassFrameException
//
// this procedure cleans up when an exception is thrown from a subclass frame
//
//-----------------------------------------------------------------------------
void SubclassFrameException(SUBCLASS_FRAME *pFrame)
{
    //
    // clean up the current subclass frame
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    DebugMsg(TF_ALWAYS, TEXT("warning: cleaning up subclass frame after exception"));
    LeaveSubclassFrame(pFrame);
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
}

//-----------------------------------------------------------------------------
// MasterSubclassProc
//
// this is the window procedure we install to dispatch subclass callbacks.
// it maintains a linked list of 'frames' through the stack which allow
// DefSubclassProc to call the right subclass procedure in multiple-message
// scenarios.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK MasterSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    SUBCLASS_FRAME Frame;
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult = 0;

    //
    // prevent people from partying on the callback chain while we look at it
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif
    //
    // we're in big trouble if we got here and we don't have our data
    //
    if ((pHeader = FastGetSubclassHeader(hWnd)) == NULL)
    {
#ifdef FREETHREADEDSUBCLASSGOOP
        LEAVECRITICAL;
#else
        ASSERT(IsWindowOnCurrentThread(hWnd));        
#endif
        return SubclassDeath(hWnd, uMsg, wParam, lParam);
    }

    //
    // set up a new subclass frame and save away the previous one
    //
    EnterSubclassFrame(pHeader, &Frame);

    __try   // protect our state information from exceptions
    {
        //
        // go ahead and call the subclass chain on this frame
        //
        // WARNING: this call temporarily releases the critical section
        // WARNING: pHeader is invalid when this call returns
        //
        lResult =
            CallNextSubclassProc(pHeader, hWnd, uMsg, wParam, lParam);
#ifdef DEBUG
        pHeader = NULL;
#endif
    }
    __except ((SubclassFrameException(&Frame), EXCEPTION_CONTINUE_SEARCH))
    {
        ASSERT(FALSE);
    }
    __endexcept

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#else
    ASSERT(IsWindowOnCurrentThread(hWnd));    
#endif

    //
    // restore the previous subclass frame
    //
    pHeader = LeaveSubclassFrame(&Frame);

    //
    // if the header is gone we have already cleaned up in a nested frame
    //
    if (!pHeader)
        goto BailOut;

    //
    // was the window nuked (somehow) without us seeing the WM_NCDESTROY?
    //
    if (!IsWindow(hWnd))
    {
        //
        // EVIL! somebody subclassed after us and didn't pass on WM_NCDESTROY
        //
        AssertMsg(FALSE, TEXT("unknown subclass proc swallowed a WM_NCDESTROY"));

        // go ahead and clean up now
        hWnd = NULL;
        uMsg = WM_NCDESTROY;
    }

    //
    // if we are returning from a WM_NCDESTROY then we need to clean up
    //
    if (uMsg == WM_NCDESTROY)
    {
        DetachSubclassHeader(hWnd, pHeader, TRUE);
        goto BailOut;
    }

    //
    // is there any pending cleanup, or are all our clients gone?
    //
    if (pHeader->uCleanup || (!pHeader->pFrameCur && (pHeader->uRefs <= 1)))
    {
        CompactSubclassHeader(hWnd, pHeader);
#ifdef DEBUG
        pHeader = NULL;
#endif
    }

    //
    // all done
    //
BailOut:
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL;
#endif
    return lResult;
}

//-----------------------------------------------------------------------------
// EnterSubclassCallback
//
// this procedure finds the next callback in the subclass chain and updates
// pFrame to indicate that we are calling it
//
//-----------------------------------------------------------------------------
UINT EnterSubclassCallback(SUBCLASS_HEADER *pHeader, SUBCLASS_FRAME *pFrame,
    SUBCLASS_CALL *pCallChosen)
{
    SUBCLASS_CALL *pCall;
    UINT uDepth;

    //
    // we will be scanning the subclass chain and updating frame data
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#endif

    //
    // scan the subclass chain for the next callable subclass callback
    //
    pCall = pHeader->CallArray + pFrame->uCallIndex;
    uDepth = 0;
    do
    {
        uDepth++;
        pCall--;

    } while (!pCall->pfnSubclass);

    //
    // copy the callback information for the caller
    //
    pCallChosen->pfnSubclass = pCall->pfnSubclass;
    pCallChosen->uIdSubclass = pCall->uIdSubclass;
    pCallChosen->dwRefData   = pCall->dwRefData;

    //
    // adjust the frame's call index by the depth we entered
    //
    pFrame->uCallIndex -= uDepth;

    //
    // keep the deepest call index up to date
    //
    UpdateDeepestCall(pFrame);

    return uDepth;
}

//-----------------------------------------------------------------------------
// LeaveSubclassCallback
//
// this procedure finds the next callback in the cal
//
//-----------------------------------------------------------------------------
__inline void LeaveSubclassCallback(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    //
    // we will be updating subclass frame data
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;
#endif

    //
    // adjust the frame's call index by the depth we entered and return
    //
    pFrame->uCallIndex += uDepth;

    //
    // keep the deepest call index up to date
    //
    UpdateDeepestCall(pFrame);
}

//-----------------------------------------------------------------------------
// SubclassCallbackException
//
// this procedure cleans up when a subclass callback throws an exception
//
//-----------------------------------------------------------------------------
void SubclassCallbackException(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    //
    // clean up the current subclass callback
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    DebugMsg(TF_ALWAYS, TEXT("warning: cleaning up subclass callback after exception"));
    LeaveSubclassCallback(pFrame, uDepth);
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
}

//-----------------------------------------------------------------------------
// CallNextSubclassProc
//
// this procedure calls the next subclass callback in the subclass chain
//
// WARNING: this call temporarily releases the critical section
// WARNING: pHeader is invalid when this call returns
//
//-----------------------------------------------------------------------------
LRESULT CallNextSubclassProc(SUBCLASS_HEADER *pHeader, HWND hWnd, UINT uMsg,
    WPARAM wParam, LPARAM lParam)
{
    SUBCLASS_CALL Call;
    SUBCLASS_FRAME *pFrame;
    LRESULT lResult;
    UINT uDepth;

#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTCRITICAL;     // sanity
#endif
    ASSERT(pHeader);    // paranoia

    //
    // get the current subclass frame
    //
    pFrame = pHeader->pFrameCur;
    ASSERT(pFrame);

    //
    // get the next subclass call we need to make
    //
    uDepth = EnterSubclassCallback(pHeader, pFrame, &Call);

    //
    // leave the critical section so we don't deadlock in our callback
    //
    // WARNING: pHeader is invalid when this call returns
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    LEAVECRITICAL;
#endif
#ifdef DEBUG
    pHeader = NULL;
#endif

    //
    // we call the outside world so prepare to deadlock if we have the critsec
    //
#ifdef FREETHREADEDSUBCLASSGOOP
    ASSERTNONCRITICAL;
#endif

    __try   // protect our state information from exceptions
    {
        //
        // call the chosen subclass proc
        //
        ASSERT(Call.pfnSubclass);

        lResult = Call.pfnSubclass(hWnd, uMsg, wParam, lParam,
            Call.uIdSubclass, Call.dwRefData);
    }
    __except ((SubclassCallbackException(pFrame, uDepth),
        EXCEPTION_CONTINUE_SEARCH))
    {
        ASSERT(FALSE);
    }
    __endexcept

    //
    // we left the critical section before calling out so re-enter it
    //

#ifdef FREETHREADEDSUBCLASSGOOP
    ENTERCRITICAL;
#endif
    
    //
    // finally, clean up and return
    //
    LeaveSubclassCallback(pFrame, uDepth);
    return lResult;
}

///////////////////////////////////////////////////////////////////////////////

#if defined(RETAIL_ZOMBIE_MESSAGE_WNDPROC) || defined(DEBUG)
#ifdef DEBUG
static const TCHAR c_szZombieMessage[] =                                     \
    TEXT("This window has encountered an internal error which is preventing ")    \
    TEXT("it from operating normally.\r\n\nPlease report this problem to ")       \
    TEXT("FrancisH immediately.");
#else
static const TCHAR c_szZombieMessage[] =                                     \
    TEXT("This window has encountered an internal error which is preventing ")    \
    TEXT("it from operating normally.\r\n\nPlease report this as a bug in the ")  \
    TEXT("COMCTL32 library.");
#endif

LRESULT ZombieWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_ERASEBKGND:
        {
            HDC hDC = (HDC)wParam;
            HBRUSH hBrush = CreateSolidBrush(RGB(255,255,0));

            if (hBrush)
            {
                RECT rcErase;

                switch (GetClipBox(hDC, &rcErase))
                {
                default:
                    FillRect(hDC, &rcErase, hBrush);
                    break;
                case NULLREGION:
                case ERROR:
                    break;
                }

                DeleteBrush(hBrush);
            }
        }
        return 1;

    case WM_PAINT:
        {
            RECT rcClient;
            PAINTSTRUCT ps;
            HDC hDC = BeginPaint(hWnd, &ps);

            if (hDC && GetClientRect(hWnd, &rcClient))
            {
                COLORREF clrBkSave = SetBkColor(hDC, RGB(255,255,0));
                COLORREF clrFgSave = SetTextColor(hDC, RGB(255,0,0));

                DrawText(hDC, c_szZombieMessage, -1, &rcClient,
                    DT_LEFT | DT_TOP | DT_NOPREFIX | DT_WORDBREAK |
                    DT_WORD_ELLIPSIS);

                SetTextColor(hDC, clrFgSave);
                SetBkColor(hDC, clrBkSave);
            }

            EndPaint(hWnd, &ps);
        }
        return 0;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}
#endif

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\tab.h ===
typedef struct { // ti
    RECT rc;        // for hit testing and drawing
    int iImage;     // image index
    int xLabel;     // position of the text for drawing (relative to rc)
    int yLabel;     // (relative to rc)
    int cxLabel;    // width of the label.  this is needed if we're drawing in vertical mode
    
    int xImage;     // Position of the icon for drawing (relative to rc)
    int yImage;
    int iRow;           // what row is it in?
    LPTSTR pszText;
    
    DWORD dwState;
    
#if defined(WINDOWS_ME)
    UINT etoRtlReading;
#endif
    
    union {
        LPARAM lParam;
        BYTE   abExtra[1];
    }DUMMYUNIONNAME;
} TABITEM, FAR *LPTABITEM;

typedef struct {
    CONTROLINFO ci;
    
    HWND hwndArrows;    // Hwnd Arrows.
    HDPA hdpa;          // item array structure
    UINT flags;         // TCF_ values (internal state bits)
    int  cbExtra;       // extra bytes allocated for each item
    DWORD dwStyleEx;    // set by TCM_SETEXTENDEDSTYLE
    HFONT hfontLabel;   // font to use for labels
    int iSel;           // index of currently-focused item
    int iNewSel;        // index of next potential selection

    int cxItem;         // width of all tabs
    int cxMinTab;       // width of minimum tab
    int cyTabs;         // height of a row of tabs
    int cxTabs;     // The right hand edge where tabs can be painted.

    int cxyArrows;      // width and height to draw arrows
    int iFirstVisible;  // the index of the first visible item.
                        // wont fit and we need to scroll.
    int iLastVisible;   // Which one was the last one we displayed?

    int cxPad;           // Padding space between edges and text/image
    int cyPad;           // should be a multiple of c?Edge

    int iTabWidth;      // size of each tab in fixed width mode
    int iTabHeight;     // settable size of each tab
    int iLastRow;       // number of the last row.
    int iLastTopRow;    // the number of the last row that's on top (SCROLLOPPOSITE mode)

    int cyText;         // where to put the text vertically
    int cyIcon;         // where to put the icon vertically

    HIMAGELIST himl;    // images,
    HWND hwndToolTips;
#if defined(FE_IME) || !defined(WINNT)
    HIMC hPrevImc;      // previous input context handle
#endif

    HDRAGPROXY hDragProxy;
    DWORD dwDragDelay;  // delay for auto page-change during drag
    int iDragTab;       // last tab dragged over

    int tmHeight;    // text metric height
    BOOL fMinTabSet:1;  // have they set the minimum tab width
    BOOL fTrackSet:1;
    
    int iHot; 
} TC, NEAR *PTC;

#ifndef TCS_MULTISELECT 
#define TCS_MULTISELECT  0x0004
#endif

#define HASIMAGE(ptc, pitem) (ptc->himl && pitem->iImage != -1)

// tab control flag values
#define TCF_FOCUSED     0x0001
#define TCF_MOUSEDOWN   0x0002
#define TCF_DRAWSUNKEN  0x0004
#define TCF_REDRAW      0x0010  /* Value from WM_SETREDRAW message */
#define TCF_BUTTONS     0x0020  /* draw using buttons instead of tabs */

#define TCF_FONTSET     0x0040  /* if this is set, they set the font */
#define TCF_FONTCREATED 0x0080  

#define ID_ARROWS       1

#define TAB_DRAGDELAY   500

// Some helper macros for checking some of the flags...
#define Tab_RedrawEnabled(ptc)          (ptc->flags & TCF_REDRAW)
#define Tab_Count(ptc)                  DPA_GetPtrCount((ptc)->hdpa)
#define Tab_GetItemPtr(ptc, i)          ((LPTABITEM)DPA_GetPtr((ptc)->hdpa, (i)))
#define Tab_FastGetItemPtr(ptc, i)      ((LPTABITEM)DPA_FastGetPtr((ptc)->hdpa, (i)))
#define Tab_IsItemOnBottom(ptc, pitem)  ((BOOL)pitem->iRow > ptc->iLastTopRow)
#define Tab_DrawSunken(ptc)             ((BOOL)(ptc)->flags & TCF_DRAWSUNKEN)

#define Tab_DrawButtons(ptc)            ((BOOL)(ptc->ci.style & TCS_BUTTONS))
#define Tab_MultiLine(ptc)              ((BOOL)(ptc->ci.style & TCS_MULTILINE))
#define Tab_RaggedRight(ptc)            ((BOOL)(ptc->ci.style & TCS_RAGGEDRIGHT))
#define Tab_FixedWidth(ptc)             ((BOOL)(ptc->ci.style & TCS_FIXEDWIDTH))
#define Tab_Vertical(ptc)               ((BOOL)(ptc->ci.style & TCS_VERTICAL))
#define Tab_Bottom(ptc)                 ((BOOL)(ptc->ci.style & TCS_BOTTOM))
#define Tab_ScrollOpposite(ptc)        ((BOOL)(ptc->ci.style & TCS_SCROLLOPPOSITE))
#define Tab_ForceLabelLeft(ptc)         ((BOOL)(ptc->ci.style & TCS_FORCELABELLEFT))
#define Tab_ForceIconLeft(ptc)          ((BOOL)(ptc->ci.style & TCS_FORCEICONLEFT))
#define Tab_FocusOnButtonDown(ptc)      ((BOOL)(ptc->ci.style & TCS_FOCUSONBUTTONDOWN))
#define Tab_OwnerDraw(ptc)              ((BOOL)(ptc->ci.style & TCS_OWNERDRAWFIXED))
#define Tab_FocusNever(ptc)             ((BOOL)(ptc->ci.style & TCS_FOCUSNEVER))
#define Tab_HotTrack(ptc)             ((BOOL)(ptc->ci.style & TCS_HOTTRACK))
#define Tab_MultiSelect(ptc)            ((BOOL)(ptc->ci.style & TCS_MULTISELECT))
#define Tab_FlatButtons(ptc)            ((BOOL)((ptc)->ci.style & TCS_FLATBUTTONS))

#define Tab_FlatSeparators(ptc)         ((BOOL)((ptc)->dwStyleEx & TCS_EX_FLATSEPARATORS))

#ifdef __cplusplus
extern "C"
{
#endif

LRESULT CALLBACK Tab_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void NEAR PASCAL Tab_InvalidateItem(PTC ptc, int iItem, BOOL bErase);
void NEAR PASCAL CalcPaintMetrics(PTC ptc, HDC hdc);
void NEAR PASCAL Tab_OnHScroll(PTC ptc, HWND hwndCtl, UINT code, int pos);
void NEAR PASCAL Tab_OnAdjustRect(PTC ptc, BOOL fGrow, LPRECT prc);
BOOL NEAR Tab_FreeItem(PTC ptc, TABITEM FAR* pitem);
void NEAR Tab_UpdateArrows(PTC ptc, BOOL fSizeChanged);
int NEAR PASCAL ChangeSel(PTC ptc, int iNewSel,  BOOL bSendNotify, BOOL bUpdateCursorPos);
BOOL NEAR PASCAL RedrawAll(PTC ptc, UINT uFlags);
BOOL FAR PASCAL Tab_Init(HINSTANCE hinst);
void NEAR PASCAL UpdateToolTipRects(PTC ptc);
BOOL NEAR Tab_OnGetItem(PTC ptc, int iItem, TC_ITEM FAR* ptci);
int NEAR Tab_OnHitTest(PTC ptc, int x, int y, UINT FAR *lpuFlags);

#ifdef UNICODE
//
// ANSI <=> UNICODE thunks
//

TC_ITEMW * ThunkItemAtoW (PTC ptc, TC_ITEMA * pItemA);
BOOL ThunkItemWtoA (PTC ptc, TC_ITEMW * pItemW, TC_ITEMA * pItemA);
BOOL FreeItemW (TC_ITEMW *pItemW);
BOOL FreeItemA (TC_ITEMA *pItemA);
#endif

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\thunk.c ===
#include "ctlspriv.h"
#include <limits.h>

/*
 * Creates a buffer for a unicode string, and then copies the ANSI text
 * into it (converting it to unicode in the process)
 *
 * The returned pointer should be freed with LocalFree after use.
 */
LPWSTR ProduceWFromA( UINT uiCodePage, LPCSTR psz ) {
    LPWSTR pszW;
    int cch;

    if (psz == NULL || psz == LPSTR_TEXTCALLBACKA)
        return (LPWSTR)psz;

    // The old code would call lstrlen and lstrcpy which would fault internal to the
    // api, this should do about the same...
    if (IsBadReadPtr(psz,1))
        return NULL;    // For now lets try not setting a string...

    cch = MultiByteToWideChar(uiCodePage, 0, psz, -1, NULL, 0);

    if (cch == 0)
        cch = 1;

    pszW = LocalAlloc( LMEM_FIXED, cch * sizeof(WCHAR) );

    if (pszW != NULL ) {
         if (MultiByteToWideChar( uiCodePage, MB_PRECOMPOSED, psz, -1, pszW,
                cch ) == FALSE) {
            LocalFree(pszW);
            pszW = NULL;
        }
    }

    return pszW;

}


/*
 * Creates a buffer for a unicode string, and then copies the ANSI text
 * into it (converting it to unicode in the process)
 *
 * The returned pointer should be freed with LocalFree after use.
 */
LPSTR ProduceAFromW( UINT uiCodePage, LPCWSTR psz ) {
    LPSTR pszA;
    int cch;

    if (psz == NULL || psz == LPSTR_TEXTCALLBACKW)
        return (LPSTR)psz;

    cch = WideCharToMultiByte(uiCodePage, 0, psz, -1, NULL, 0, NULL, NULL);

    if (cch == 0)
        cch = 1;

    pszA = LocalAlloc( LMEM_FIXED, cch * sizeof(char) );

    if (pszA != NULL ) {
         if (WideCharToMultiByte(uiCodePage, 0, psz, -1, pszA, cch, NULL, NULL) ==
                                                                       FALSE) {
            LocalFree(pszA);
            pszA = NULL;
        }
    }

    return pszA;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\tbcust.c ===
#include "ctlspriv.h"
#include "toolbar.h"
#include "help.h" // Help IDs

#define SEND_WM_COMMAND(hwnd, id, hwndCtl, codeNotify) \
    (void)SendMessage((hwnd), WM_COMMAND, MAKEWPARAM((UINT)(id),(UINT)(codeNotify)), (LPARAM)(HWND)(hwndCtl))

#define SPACESTRLEN 20

#define FLAG_NODEL  0x8000
#define FLAG_HIDDEN 0x4000
#define FLAG_SEP    0x2000
#define FLAG_ALLFLAGS   (FLAG_NODEL|FLAG_HIDDEN|FLAG_SEP)

typedef struct {        /* instance data for toolbar edit dialog */
    HWND hDlg;          /* dialog hwnd */
    PTBSTATE ptb;       // current toolbar state
    int iPos;           /* position to insert into */
} ADJUSTDLGDATA, *LPADJUSTDLGDATA;


int g_dyButtonHack = 0;     // to pass on before WM_INITDIALOG

LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton);

int GetPrevButton(PTBSTATE ptb, int iPos)
{
    /* This means to delete the preceding space
     */
    for (--iPos; ; --iPos)
    {
        if (iPos < 0)
            break;

        if (!(ptb->Buttons[iPos].fsState & TBSTATE_HIDDEN))
            break;;
    }

    return(iPos);
}

BOOL GetAdjustInfo(PTBSTATE ptb, int iItem, LPTBBUTTONDATA ptbButton, LPTSTR lpString, int cbString)
{
    TBNOTIFY tbn;
    tbn.pszText = lpString;
    tbn.cchText = cbString;
    tbn.iItem = iItem;

    if (lpString)
        *lpString = 0;

    if ((BOOL)CCSendNotify(&ptb->ci, TBN_GETBUTTONINFO, &tbn.hdr))
    {
        TBInputStruct(ptb, ptbButton, &tbn.tbButton);
        return TRUE;
    }
    return FALSE;
}

LRESULT SendItemNotify(PTBSTATE ptb, int iItem, int code)
{
    TBNOTIFY tbn = {0};
    tbn.iItem = iItem;

    switch (code) {

    case TBN_QUERYDELETE:
    case TBN_QUERYINSERT:
        // The following is to provide the parent app with information
        // about the button that information is being requested for...
        // Otherwise it's really awful trying to have control over
        // certain aspects of toolbar customization... [t-mkim]
        // IE4.0's toolbar wants this information.
        //      Should ONLY be done for TBN_QUERY* notifications BECAUSE
        //      this can be either a zero-based index _or_ Command ID depending
        //      on the particular notification code.
        if (iItem < ptb->iNumButtons)
            CopyMemory (&tbn.tbButton, &ptb->Buttons[iItem], sizeof (TBBUTTON));
        break;

    case TBN_DROPDOWN:
        TB_GetItemRect(ptb, PositionFromID(ptb, iItem), &tbn.rcButton);
        break;
    }

    // default return from SendNotify is false
    // this actually shouldnt return a bool, TBN_DROPDOWN needs to return 0, 1, or 2.
    return CCSendNotify(&ptb->ci, code, &tbn.hdr);
}

#define SendCmdNotify(ptb, code)   CCSendNotify(&ptb->ci, code, NULL)


// this is used to deal with the case where the ptb structure is re-alloced
// after a TBInsertButtons()

PTBSTATE FixPTB(HWND hwnd)
{
    PTBSTATE ptb = (PTBSTATE)GetWindowInt(hwnd, 0);

    if (ptb->hdlgCust)
    {
        LPADJUSTDLGDATA lpad = (LPADJUSTDLGDATA)GetWindowPtr(ptb->hdlgCust, DWLP_USER);
#ifdef DEBUG
        if (lpad->ptb != ptb)
            DebugMsg(DM_TRACE, TEXT("Fixing busted ptb pointer"));
#endif
        lpad->ptb = ptb;
    }
    return ptb;
}


void MoveButton(PTBSTATE ptb, int nSource)
{
    int nDest;
    RECT rc;
    HCURSOR hCursor;
    MSG32 msg32;

    /* You can't move separators like this
     */
    if (nSource < 0)
        return;

    // Make sure it is all right to "delete" the selected button
    if (!SendItemNotify(ptb, nSource, TBN_QUERYDELETE))
        return;

    hCursor = SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_MOVEBUTTON)));
    SetCapture(ptb->ci.hwnd);

    // Get the dimension of the window.
    GetClientRect(ptb->ci.hwnd, &rc);
    for ( ; ; )
    {
        while (!PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE))
            ;

        if (GetCapture() != ptb->ci.hwnd)
            goto AbortMove;

        // See if the application wants to process the message...
        if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_TOOLBARCUST, TRUE) != 0)
            continue;


        switch (msg32.message)
        {
        case WM_KEYDOWN:
        case WM_KEYUP:
        case WM_CHAR:
#ifdef KEYBOARDCUES
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS);
#endif
            break;

        case WM_LBUTTONUP:
            RelayToToolTips(ptb->hwndToolTips, ptb->ci.hwnd, msg32.message, msg32.wParam, msg32.lParam);
            if ((GET_Y_LPARAM(msg32.lParam) > (short)(rc.bottom+ptb->iButWidth)) ||
                (GET_X_LPARAM(msg32.lParam) > (short)(rc.right+ptb->iButWidth)) ||
                (GET_Y_LPARAM(msg32.lParam) < -ptb->iButWidth) ||
                (GET_X_LPARAM(msg32.lParam) < -ptb->iButWidth))

            {
                /* If the button was dragged off the toolbar, delete it.
                 */
DeleteSrcButton:
                DeleteButton(ptb, nSource);
                SendCmdNotify(ptb, TBN_TOOLBARCHANGE);
                TBInvalidateItemRects(ptb);
            }
            else
            {
                TBBUTTONDATA tbbAdd;

                /* Add half a button to X so that it looks like it is centered
                 * over the target button, iff we have a horizontal layout.
                 * Add half a button to Y otherwise.
                 */
                if (rc.right!=ptb->iButWidth)
                    nDest = TBHitTest(ptb,
                                      GET_X_LPARAM(msg32.lParam) + ptb->iButWidth / 2,
                                      GET_Y_LPARAM(msg32.lParam));
                else
                    nDest = TBHitTest(ptb,
                                      GET_X_LPARAM(msg32.lParam),
                                      GET_Y_LPARAM(msg32.lParam) + ptb->iButHeight / 2);

                if (nDest < 0)
                    nDest = -1 - nDest;

                if (nDest>0 &&
                    (ptb->Buttons[nDest-1].fsState & TBSTATE_WRAP) &&
                    GET_X_LPARAM(msg32.lParam)>ptb->iButWidth &&
                    SendItemNotify(ptb, --nDest, TBN_QUERYINSERT))
                {
                    tbbAdd = ptb->Buttons[nSource];
                    DeleteButton(ptb, nSource);
                    if (nDest>nSource)
                        --nDest;

                    /* Insert before spaces, but after buttons. */
                    if (!(ptb->Buttons[nDest].fsStyle & TBSTYLE_SEP))
                        nDest++;

                    goto InsertSrcButton;
                }
                else if (nDest == nSource)
                {
                    /* This means to delete the preceding space, or to move a
                    button to the previous row.
                    */
                    nSource = GetPrevButton(ptb, nSource);
                    if (nSource < 0)
                        goto AbortMove;

                    // If the preceding item is a space with no ID, and
                    // the app says it's OK, then delete it.
                    if ((ptb->Buttons[nSource].fsStyle & TBSTYLE_SEP)
                        && !ptb->Buttons[nSource].idCommand
                        && SendItemNotify(ptb, nSource, TBN_QUERYDELETE))
                        goto DeleteSrcButton;
                }
                else if (nDest == nSource+1)
                {
                    // This means to add a preceding space
                    --nDest;
                    if (SendItemNotify(ptb, nDest, TBN_QUERYINSERT))
                    {
                        tbbAdd.DUMMYUNION_MEMBER(iBitmap) = 0;
                        tbbAdd.idCommand = 0;
                        tbbAdd.iString = -1;
                        tbbAdd.fsState = 0;
                        tbbAdd.fsStyle = TBSTYLE_SEP;
                        goto InsertSrcButton;
                    }
                }
                else if (SendItemNotify(ptb, nDest, TBN_QUERYINSERT))
                {
                    HWND hwndT;
                    TBBUTTON tbbAddExt;

                    /* This is a normal move operation
                     */
                    tbbAdd = ptb->Buttons[nSource];

                    ptb->Buttons[nSource].iString = -1;
                    DeleteButton(ptb, nSource);
                    if (nDest > nSource)
                        --nDest;
InsertSrcButton:
                    hwndT = ptb->ci.hwnd;

                    TBOutputStruct(ptb, &tbbAdd, &tbbAddExt);
                    TBInsertButtons(ptb, nDest, 1, &tbbAddExt, TRUE);

                    ptb = FixPTB(hwndT);

                    SendCmdNotify(ptb, TBN_TOOLBARCHANGE);
                    TBInvalidateItemRects(ptb);
                }
                else
                {
AbortMove:
                    ;
                }
            }
            goto AllDone;

        case WM_RBUTTONDOWN:
            goto AbortMove;

        default:
            TranslateMessage32(&msg32, TRUE);
            DispatchMessage32(&msg32, TRUE);
            break;
        }
    }
AllDone:

    SetCursor(hCursor);
    CCReleaseCapture(&ptb->ci);
}


#define GNI_HIGH    0x0001
#define GNI_LOW     0x0002

int GetNearestInsert(PTBSTATE ptb, int iPos, int iNumButtons, UINT uFlags)
{
    int i;
    BOOL bKeepTrying;

    // Find the nearest index where we can actually insert items
    for (i = iPos; ; ++i, --iPos)
    {
        bKeepTrying = FALSE;

        // Notice we favor going high if both flags are set
        if ((uFlags & GNI_HIGH) && i <= iNumButtons)
        {
            bKeepTrying = TRUE;

            if (SendItemNotify(ptb, i, TBN_QUERYINSERT))
                return i;
        }

        if ((uFlags & GNI_LOW) && iPos >= 0)
        {
            bKeepTrying = TRUE;

            if (SendItemNotify(ptb, iPos, TBN_QUERYINSERT))
                return iPos;
        }

        if (!bKeepTrying)
            return -1;   // There was no place to add buttons
    }
}


BOOL InitAdjustDlg(HWND hDlg, LPADJUSTDLGDATA lpad)
{
    HDC hDC;
    HFONT hFont;
    HWND hwndCurrent, hwndNew;
    LPTBBUTTONDATA ptbButton;
    int i, iPos, nItem, nWid, nMaxWid;
    TBBUTTONDATA tbAdjust;
    TCHAR szDesc[128];
    NMTBCUSTOMIZEDLG nm;
    TCHAR szSeparator[MAX_PATH];

    szSeparator[0] = 0;
    LocalizedLoadString(IDS_SPACE, szSeparator, ARRAYSIZE(szSeparator));

    lpad->hDlg = hDlg;
    lpad->ptb->hdlgCust = hDlg;

    /* Determine the item nearest the desired item that will allow
     * insertion.
     */
    iPos = GetNearestInsert(lpad->ptb, lpad->iPos, lpad->ptb->iNumButtons,
                            GNI_HIGH | GNI_LOW);
    if (iPos < 0)
    /* No item allowed insertion, so leave the dialog */
    {
        return(FALSE);
    }

    /* Reset the lists of used and available items.
     */
    hwndCurrent = GetDlgItem(hDlg, IDC_CURRENT);
    SendMessage(hwndCurrent, LB_RESETCONTENT, 0, 0L);

    hwndNew = GetDlgItem(hDlg, IDC_BUTTONLIST);
    SendMessage(hwndNew, LB_RESETCONTENT, 0, 0L);

    nm.hDlg = hDlg;
    if (CCSendNotify(&lpad->ptb->ci, TBN_INITCUSTOMIZE, &nm.hdr) == TBNRF_HIDEHELP) {
        ShowWindow(GetDlgItem(hDlg, IDC_APPHELP), SW_HIDE);
    }

    for (i=0, ptbButton = lpad->ptb->Buttons; i < lpad->ptb->iNumButtons; ++i, ++ptbButton)
    {
        UINT uFlags;
        int iBitmap;
        LPTSTR pszStr = NULL;

        uFlags = 0;

        // Non-deletable and hidden items show up grayed.

        if (!SendItemNotify(lpad->ptb, i, TBN_QUERYDELETE))
        {
            uFlags |= FLAG_NODEL;
        }
        if (ptbButton->fsState & TBSTATE_HIDDEN)
        {
            uFlags |= FLAG_HIDDEN;
        }

        /* Separators have no bitmaps (even ones with IDs).  Only set
         * the separator flag if there is no ID (it is a "real"
         * separator rather than an owner item).
         */
        if (ptbButton->fsStyle&TBSTYLE_SEP)
        {
            if (!(ptbButton->idCommand))
            {
                uFlags |= FLAG_SEP;
            }
            iBitmap = -1;

            pszStr = szSeparator;
        }
        else
        {
            iBitmap = ptbButton->DUMMYUNION_MEMBER(iBitmap);
            // this specifies an imagelist.
            // pack this into the loword of the ibitmap.
            // this causes a restriction of max 16 imagelists, and 4096 images in any imagelist
            iBitmap = LOWORD(iBitmap) | (HIWORD(iBitmap) << 12);

            /* Add the item and the data
             * Note: A negative number in the LOWORD indicates no bitmap;
             * otherwise it is the bitmap index.
             */
            pszStr = TB_StrForButton(lpad->ptb, ptbButton);
        }

        if ((int)SendMessage(hwndCurrent, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)(pszStr ? pszStr : (LPTSTR)c_szNULL)) != i)
        {
            return(FALSE);
        }
        SendMessage(hwndCurrent, LB_SETITEMDATA, i, MAKELPARAM(iBitmap, uFlags));
    }

    /* Add a dummy "nodel" space at the end so things can be inserted at the end.
     */
    if ((int)SendMessage(hwndCurrent, LB_ADDSTRING, 0,(LPARAM)(LPTSTR)szSeparator) == i)
    {
        SendMessage(hwndCurrent, LB_SETITEMDATA, i, MAKELPARAM(-1, FLAG_NODEL|FLAG_SEP));
    }

    /* Now add a space at the beginning of the "new" list.
     */
        if (SendMessage(hwndNew, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)szSeparator) == LB_ERR)
            return(FALSE);
            
        SendMessage(hwndNew, LB_SETITEMDATA, 0, MAKELPARAM(-1, FLAG_SEP));

    /* We need this to determine the widest (in pixels) item string.
     */
    hDC = GetDC(hwndCurrent);
    hFont = (HFONT)(INT_PTR)SendMessage(hwndCurrent, WM_GETFONT, 0, 0L);
    if (hFont)
    {
        hFont = SelectObject(hDC, hFont);
    }
    nMaxWid = 0;

    for (i=0; ; ++i)
    {
        // Get the info about the i'th item from the app.
        if (!GetAdjustInfo(lpad->ptb, i, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
            break;
        
        if (!szDesc[0]) {
            LPTSTR psz = TB_StrForButton(lpad->ptb, &tbAdjust);
            if (psz) {
                lstrcpyn(szDesc, psz, ARRAYSIZE(szDesc));
            }
        }

        /* Don't show separators that don't have commands
         */
        if (!(tbAdjust.fsStyle & TBSTYLE_SEP) || tbAdjust.idCommand)
        {
            
            /* Get the maximum width of a string.
             */
            MGetTextExtent(hDC, szDesc, lstrlen(szDesc), &nWid, NULL);

            if (nMaxWid < nWid)
            {
                nMaxWid = nWid;
            }

            nItem = PositionFromID(lpad->ptb, tbAdjust.idCommand);
            if (nItem < 0)
            /* If the item is not on the toolbar already */
            {
#ifdef UNIX
                if (!lstrcmp(szDesc, TEXT("Folders")) || !lstrcmp(szDesc, TEXT("Edit")))
                    continue;
#endif

                /* Don't show hidden buttons
                 */
                if (!(tbAdjust.fsState & TBSTATE_HIDDEN))
                {
                    nItem = (int)SendMessage(hwndNew, LB_ADDSTRING, 0,
                                             (LPARAM)(LPTSTR)szDesc);
                    if (nItem != LB_ERR)
                    {
                        
                        if (tbAdjust.fsStyle & TBSTYLE_SEP)
                            SendMessage(hwndNew, LB_SETITEMDATA, nItem,
                                        MAKELPARAM(-1, i));
                        else {
                            int iBitmap = tbAdjust.DUMMYUNION_MEMBER(iBitmap);
                            iBitmap = LOWORD(iBitmap) | (HIWORD(iBitmap) << 12);
                            SendMessage(hwndNew, LB_SETITEMDATA, nItem,
                                        MAKELPARAM(iBitmap, i));
                        }
                    }
                }
            }
            else
            /* The item is on the toolbar already */
            {
                /* Preserve the flags and bitmap.
                 */
                DWORD dwTemp = (DWORD)SendMessage(hwndCurrent, LB_GETITEMDATA, nItem, 0L);

                if (szDesc[0]) {
                    SendMessage(hwndCurrent, LB_DELETESTRING, nItem, 0L);

                    if ((int)SendMessage(hwndCurrent, LB_INSERTSTRING, nItem,
                                         (LPARAM)(LPTSTR)szDesc) != nItem)
                    {
                        ReleaseDC(hwndCurrent, hDC);
                        return(FALSE);
                    }
                }
                SendMessage(hwndCurrent, LB_SETITEMDATA, nItem,
                    MAKELPARAM(LOWORD(dwTemp), HIWORD(dwTemp)|i));
            }
        }
    }

    if (hFont)
    {
        SelectObject(hDC, hFont);
    }
    ReleaseDC(hwndCurrent, hDC);

    /* Add on some extra and set the extents for both lists.
     */
    nMaxWid += lpad->ptb->iButWidth + 2 + 1;
    SendMessage(hwndNew, LB_SETHORIZONTALEXTENT, nMaxWid, 0L);
    SendMessage(hwndCurrent, LB_SETHORIZONTALEXTENT, nMaxWid, 0L);

    /* Set the sels and return.
     */
    SendMessage(hwndNew, LB_SETCURSEL, 0, 0L);
    SendMessage(hwndCurrent, LB_SETCURSEL, iPos, 0L);
    SEND_WM_COMMAND(hDlg, IDC_CURRENT, hwndCurrent, LBN_SELCHANGE);

    return(TRUE);
}


#define IsSeparator(x) (HIWORD(x) & FLAG_SEP)

void PaintAdjustLine(PTBSTATE ptb, DRAWITEMSTRUCT *lpdis)
{
    HDC hdc = lpdis->hDC;
    HWND hwndList = lpdis->hwndItem;
    PTSTR pszText;
    RECT rc = lpdis->rcItem;
    int nBitmap, nLen, nItem = lpdis->itemID;
    COLORREF oldBkColor, oldTextColor;
    BOOL bSelected, bHasFocus;
    int wHeight;
    int x;


    if (lpdis->CtlID != IDC_BUTTONLIST && lpdis->CtlID != IDC_CURRENT)
        return;

    nBitmap = LOWORD(lpdis->itemData);
    // unpack the nBitmap.  we stored the imagelist spec in the hi char of loword
    if (nBitmap != 0xFFFF)
        nBitmap = (nBitmap & 0x0FFF) | ((nBitmap & 0xF000) << 4);

    nLen = (int)SendMessage(hwndList, LB_GETTEXTLEN, nItem, 0L);
    if (nLen < 0)
        return;

    pszText = (PTSTR)LocalAlloc(LPTR, (nLen+1)*sizeof(TCHAR));
    if (!pszText)
        return;

    // This needs to work for separators also or ActiveAccessibility
    // won't work.
    SendMessage(hwndList, LB_GETTEXT, nItem, (LPARAM)(LPTSTR)pszText);
    if (lpdis->itemAction != ODA_FOCUS)
    {
        COLORREF clr;
        TCHAR szSample[2];

        /* We don't care about focus if the item is not selected.
        */
        bSelected = lpdis->itemState & ODS_SELECTED;
        bHasFocus = bSelected && (GetFocus() == hwndList);

        if (HIWORD(lpdis->itemData) & (FLAG_NODEL | FLAG_HIDDEN))
            clr = g_clrGrayText;
        else if (bHasFocus)
            clr = g_clrHighlightText;
        else
            clr = g_clrWindowText;

        oldTextColor = SetTextColor(hdc, clr);
        oldBkColor = SetBkColor(hdc, bHasFocus ? g_clrHighlight : g_clrWindow);

        szSample[0] = TEXT('W');
        szSample[1] = TEXT('\0');

        MGetTextExtent(hdc, szSample, 1, NULL, &wHeight);

        x = rc.left + 2;
        x += (ptb->ci.style & TBSTYLE_FLAT) ? (ptb->iDxBitmap + g_cxEdge) : ptb->iButWidth;
        ExtTextOut(hdc, x,
                   (rc.top + rc.bottom-wHeight) / 2,
                   ETO_CLIPPED | ETO_OPAQUE, &rc, pszText, nLen, NULL);

        /* We really care about the bitmap value here; this is not just an
        * indicator for the separator.
        */
        if (nBitmap >= 0)
        {
            TBBUTTONDATA tbbAdd = {0};
            TBDRAWITEM tbdraw = {0};

            tbbAdd.DUMMYUNION_MEMBER(iBitmap) = nBitmap;
            tbbAdd.iString = -1;
            tbbAdd.fsStyle = TBSTYLE_BUTTON;
            tbbAdd.fsState = (BYTE)((HIWORD(lpdis->itemData) & FLAG_HIDDEN) ? 0 : TBSTATE_ENABLED);

            InitTBDrawItem(&tbdraw, ptb, &tbbAdd, tbbAdd.fsState, 0, 0, 0);

            if (ptb->ci.style & TBSTYLE_FLAT)
                DrawFace(hdc, rc.left + 1, rc.top + 1, 0, 0, 0, 0, &tbdraw);
            else
                DrawButton(hdc, rc.left + 1, rc.top + 1, ptb, &tbbAdd, TRUE);
            ReleaseMonoDC(ptb);
        }

        SetBkColor(hdc, oldBkColor);
        SetTextColor(hdc, oldTextColor);

        /* Frame the item if it is selected but does not have the focus.
        */
        if (bSelected && !bHasFocus)
        {
            nLen = rc.left + (int)SendMessage(hwndList,
            LB_GETHORIZONTALEXTENT, 0, 0L);
            if (rc.right < nLen)
                rc.right = nLen;

            FrameRect(hdc, &rc, g_hbrHighlight);
        }
    }

    if ((lpdis->itemAction == ODA_FOCUS || (lpdis->itemState & ODS_FOCUS))
#ifdef KEYBOARDCUES
        && !(CCGetUIState(&(ptb->ci)) & UISF_HIDEFOCUS)
#endif
        )
        DrawFocusRect(hdc, &rc); 

    LocalFree((HLOCAL)pszText);
}


void LBMoveButton(LPADJUSTDLGDATA lpad, UINT wIDSrc, int iPosSrc,
      UINT wIDDst, int iPosDst, int iSelOffset)
{
    HWND hwndSrc, hwndDst;
    DWORD dwDataSrc;
    PTSTR pStr;
    TBBUTTONDATA tbAdjust = {0};
    TBBUTTON tbbAddExt;
    int iTopDst;
    TCHAR szDesc[128];

    hwndSrc = GetDlgItem(lpad->hDlg, wIDSrc);
    hwndDst = GetDlgItem(lpad->hDlg, wIDDst);

    // Make sure we can delete the source and insert at the dest
    //
    dwDataSrc = (DWORD)SendMessage(hwndSrc, LB_GETITEMDATA, iPosSrc, 0L);
    if (iPosSrc < 0 || (HIWORD(dwDataSrc) & FLAG_NODEL))
        return;
    if (wIDDst == IDC_CURRENT && 
        !SendItemNotify(lpad->ptb, iPosDst, TBN_QUERYINSERT))
        return;

    // Get the string for the source
    //
    pStr = (PTSTR)LocalAlloc(LPTR,
        ((int)(SendMessage(hwndSrc, LB_GETTEXTLEN, iPosSrc, 0L))+1)*sizeof(TCHAR));
    if (!pStr)
        return;
    SendMessage(hwndSrc, LB_GETTEXT, iPosSrc, (LPARAM)(LPTSTR)pStr);

    SendMessage(hwndSrc, WM_SETREDRAW, 0, 0L);
    SendMessage(hwndDst, WM_SETREDRAW, 0, 0L);
    iTopDst = (int)SendMessage(hwndDst, LB_GETTOPINDEX, 0, 0L);

    // If we are inserting into the available button list, we need to determine
    // the insertion point
    //
    if (wIDDst == IDC_BUTTONLIST)
    {
        // Insert this back in the available list if this is not a space or a
        // hidden button.
        //
        if (HIWORD(dwDataSrc)&(FLAG_SEP|FLAG_HIDDEN))
        {
            iPosDst = 0;
            goto DelTheSrc;
        }
        else
        {
            UINT uCmdSrc = HIWORD(dwDataSrc) & ~(FLAG_ALLFLAGS);

            // This just does a linear search for where to put the
            // item.  Slow, but this only happens when the user clicks
            // the "Remove" button.
            //
            iPosDst = 1;
            
            for ( ; ; ++iPosDst)
            {
                // Notice that this will break out when iPosDst is
                // past the number of items, since -1 will be returned
                //
                if ((UINT)HIWORD(SendMessage(hwndDst, LB_GETITEMDATA,
                    iPosDst, 0L)) >= uCmdSrc)
                break;
            }
        }
    }
    else if (iPosDst < 0)
        goto CleanUp;

    // Attempt to insert the new string
    //
    if ((int)SendMessage(hwndDst, LB_INSERTSTRING, iPosDst, (LPARAM)(LPTSTR)pStr)
      == iPosDst)
    {
        // Attempt to sync up the actual toolbar.
        //
        if (wIDDst == IDC_CURRENT)
        {
            HWND hwndT;

            if (IsSeparator(dwDataSrc))
            {
                // Make up a dummy lpInfo if this is a space
                //
                tbAdjust.DUMMYUNION_MEMBER(iBitmap) = 0;
                tbAdjust.idCommand = 0;
                tbAdjust.fsState = 0;
                tbAdjust.fsStyle = TBSTYLE_SEP;
            }
            else
            {
                // Call back to client to get the source button info
                //
                int iCmdSrc = HIWORD(dwDataSrc) & ~FLAG_ALLFLAGS;
                if (!GetAdjustInfo(lpad->ptb, iCmdSrc, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
                    goto DelTheDst;
            }

            hwndT = lpad->ptb->ci.hwnd;

            TBOutputStruct(lpad->ptb, &tbAdjust, &tbbAddExt);
            if (!TBInsertButtons(lpad->ptb, iPosDst, 1, &tbbAddExt, TRUE))
            {
DelTheDst:
                SendMessage(hwndDst, LB_DELETESTRING, iPosDst, 0L);
                goto CleanUp;
            }
            else
            {
                lpad->ptb = FixPTB(hwndT);
            }

            if (wIDSrc == IDC_CURRENT && iPosSrc >= iPosDst)
                ++iPosSrc;
        }

        SendMessage(hwndDst, LB_SETITEMDATA, iPosDst, dwDataSrc);

DelTheSrc:
        // Don't delete the "Separator" in the new list
        //
        if ((wIDSrc != IDC_BUTTONLIST) || (iPosSrc != 0))
        {
            SendMessage(hwndSrc, LB_DELETESTRING, iPosSrc, 0L);
            if (wIDSrc == wIDDst)
            {
                if (iPosSrc < iPosDst)
                    --iPosDst;
                if (iPosSrc < iTopDst)
                    --iTopDst;
            }
        }

        // Delete the corresponding button
        //
        if (wIDSrc == IDC_CURRENT)
            DeleteButton(lpad->ptb, iPosSrc);

        // Only set the src index if the two windows are different
        //
        if (wIDSrc != wIDDst)
        {
            if (iPosSrc >= SendMessage(hwndSrc, LB_GETCOUNT, 0, 0L))
            {
                // HACKHACK: workaround for funkdified listbox scrolling behavior.
                // Select the first item (to force scroll back to top of list),
                // then select the item we really want selected.
                SendMessage(hwndSrc, LB_SETCURSEL, 0, 0L);
            }

            if (SendMessage(hwndSrc, LB_SETCURSEL, iPosSrc, 0L) == LB_ERR)
                SendMessage(hwndSrc, LB_SETCURSEL, iPosSrc-1, 0L);
            SEND_WM_COMMAND(lpad->hDlg, wIDSrc, hwndSrc, LBN_SELCHANGE);
        }

        // Send the final SELCHANGE message after everything else is done
        //
        SendMessage(hwndDst, LB_SETCURSEL, iPosDst+iSelOffset, 0L);
        SEND_WM_COMMAND(lpad->hDlg, wIDDst, hwndDst, LBN_SELCHANGE);
    }

CleanUp:

    LocalFree((HLOCAL)pStr);

    if (wIDSrc == wIDDst)
    {
        SendMessage(hwndDst, LB_SETTOPINDEX, iTopDst, 0L);
        //make sure that the selected item is still  visible
        SendMessage(hwndDst, LB_SETCURSEL, (int)SendMessage(hwndDst, LB_GETCURSEL, 0, 0L), 0);
    }
    SendMessage(hwndSrc, WM_SETREDRAW, 1, 0L);
    SendMessage(hwndDst, WM_SETREDRAW, 1, 0L);

    InvalidateRect(hwndDst, NULL, TRUE);

    SendCmdNotify(lpad->ptb, TBN_TOOLBARCHANGE);
}


void SafeEnableWindow(HWND hDlg, UINT wID, HWND hwndDef, BOOL bEnable)
{
    HWND hwndEnable;

    hwndEnable = GetDlgItem(hDlg, wID);

    if (!bEnable && GetFocus()==hwndEnable)
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)hwndDef, 1L);
    EnableWindow(hwndEnable, bEnable);
}

int InsertIndex(LPADJUSTDLGDATA lpad, POINT pt, BOOL bDragging)
{
    HWND hwndCurrent = GetDlgItem(lpad->hDlg, IDC_CURRENT);
    int nItem = LBItemFromPt(hwndCurrent, pt, bDragging);
    if (nItem >= 0)
    {
        if (!SendItemNotify(lpad->ptb, nItem, TBN_QUERYINSERT))
            nItem = -1;
    }

    DrawInsert(lpad->hDlg, hwndCurrent, bDragging ? nItem : -1);

    return(nItem);
}


BOOL IsInButtonList(HWND hDlg, POINT pt)
{
    ScreenToClient(hDlg, &pt);

    return(ChildWindowFromPoint(hDlg, pt) == GetDlgItem(hDlg, IDC_BUTTONLIST));
}


BOOL HandleDragMsg(LPADJUSTDLGDATA lpad, HWND hDlg, WPARAM wID, LPDRAGLISTINFO lpns)
{
    switch (wID)
    {
    case IDC_CURRENT:
        switch (lpns->uNotification)
        {
        case DL_BEGINDRAG:
            {
                int nItem = (int)SendMessage(lpns->hWnd, LB_GETCURSEL, 0, 0L);
                if (HIWORD(SendMessage(lpns->hWnd, LB_GETITEMDATA, nItem, 0L)) & FLAG_NODEL)
                    return SetDlgMsgResult(hDlg, WM_COMMAND, FALSE);
                return SetDlgMsgResult(hDlg, WM_COMMAND, TRUE);
            }
            
        case DL_DRAGGING:
            {
                int nDropIndex;

DraggingSomething:
                nDropIndex = InsertIndex(lpad, lpns->ptCursor, TRUE);
                if (nDropIndex>=0 || IsInButtonList(hDlg, lpns->ptCursor))
                {
                    SetCursor(LoadCursor(HINST_THISDLL,
                        MAKEINTRESOURCE(IDC_MOVEBUTTON)));
                    return SetDlgMsgResult(hDlg, WM_COMMAND, 0);
                }
                return SetDlgMsgResult(hDlg, WM_COMMAND, DL_STOPCURSOR);
            }
            
        case DL_DROPPED:
            {
                int nDropIndex, nSrcIndex;
                
                nDropIndex = InsertIndex(lpad, lpns->ptCursor, FALSE);
                nSrcIndex = (int)SendMessage(lpns->hWnd, LB_GETCURSEL, 0, 0L);
                
                if (nDropIndex >= 0)
                {
                    if ((UINT)(nDropIndex-nSrcIndex) > 1)
                        LBMoveButton(lpad, IDC_CURRENT, nSrcIndex,
                        IDC_CURRENT, nDropIndex, 0);
                }
                else if (IsInButtonList(hDlg, lpns->ptCursor))
                {
                    LBMoveButton(lpad, IDC_CURRENT, nSrcIndex, IDC_BUTTONLIST, 0, 0);
                }
                break;
            }
            
        case DL_CANCELDRAG:
CancelDrag:
            /* This erases the insert icon if it exists.
             */
            InsertIndex(lpad, lpns->ptCursor, FALSE);
            break;
            
        default:
            break;
        }
        break;
        
        case IDC_BUTTONLIST:
            switch (lpns->uNotification)
            {
            case DL_BEGINDRAG:
                return SetDlgMsgResult(hDlg, WM_COMMAND, TRUE);
                
            case DL_DRAGGING:
                goto DraggingSomething;
                
            case DL_DROPPED:
                {
                    int nDropIndex;
                    
                    nDropIndex = InsertIndex(lpad, lpns->ptCursor, FALSE);
                    if (nDropIndex >= 0)
                        LBMoveButton(lpad, IDC_BUTTONLIST,
                            (int)SendMessage(lpns->hWnd,LB_GETCURSEL,0,0L),
                            IDC_CURRENT, nDropIndex, 0);
                    break;
                }
                
            case DL_CANCELDRAG:
                goto CancelDrag;
                
            default:
                break;
            }
            break;
            
            default:
                break;
    }
    
    return(0);
}


#ifndef WINNT
#pragma data_seg(DATASEG_READONLY)
#endif
const static DWORD aAdjustHelpIDs[] = {  // Context Help IDs
    IDC_RESET,       IDH_COMCTL_RESET,
    IDC_APPHELP,     IDH_HELP,
    IDC_MOVEUP,      IDH_COMCTL_MOVEUP,
    IDC_MOVEDOWN,    IDH_COMCTL_MOVEDOWN,
    IDC_BUTTONLIST,  IDH_COMCTL_AVAIL_BUTTONS,
    IDOK,            IDH_COMCTL_ADD,
    IDC_REMOVE,      IDH_COMCTL_REMOVE,
    IDC_CURRENT,     IDH_COMCTL_BUTTON_LIST,
    IDCANCEL,        IDH_COMCTL_CLOSE,
    0, 0
};
#ifndef WINNT
#pragma data_seg()
#endif

BOOL_PTR CALLBACK AdjustDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPADJUSTDLGDATA lpad = (LPADJUSTDLGDATA)GetWindowPtr(hDlg, DWLP_USER);
    switch (uMsg)
    {
    case WM_INITDIALOG:
        
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);  /* LPADJUSTDLGDATA pointer */
        if (!InitAdjustDlg(hDlg, (LPADJUSTDLGDATA)lParam))
            EndDialog(hDlg, FALSE);
        
        ShowWindow(hDlg, SW_SHOW);
        UpdateWindow(hDlg);
        SetFocus(GetDlgItem(hDlg, IDC_CURRENT));
        
        MakeDragList(GetDlgItem(hDlg, IDC_CURRENT));
        MakeDragList(GetDlgItem(hDlg, IDC_BUTTONLIST));
        
        return FALSE;
        
    case WM_MEASUREITEM:
#define lpmis ((MEASUREITEMSTRUCT *)lParam)
        
        if (lpmis->CtlID == IDC_BUTTONLIST || lpmis->CtlID == IDC_CURRENT)
        {
            int nHeight;
            HWND hwndList = GetDlgItem(hDlg, lpmis->CtlID);
            HDC hDC = GetDC(hwndList);
            TCHAR szSample[2];
            
            szSample[0] = TEXT('W');
            szSample[1] = TEXT('\0');
            
            MGetTextExtent(hDC, szSample, 1, NULL, &nHeight);
            
            // note, we use this hack because we get WM_MEASUREITEMS
            // before our WM_INITDIALOG where we get the lpad setup
            
            if (nHeight < g_dyButtonHack + 2)
                nHeight = g_dyButtonHack + 2;
            
            lpmis->itemHeight = nHeight;
            ReleaseDC(hwndList, hDC);
        }
        break;
        
    case WM_DRAWITEM:
        PaintAdjustLine(lpad->ptb, (DRAWITEMSTRUCT *)lParam);
        break;
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aAdjustHelpIDs);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID) aAdjustHelpIDs);
        break;
        
    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_APPHELP:
            SendCmdNotify(lpad->ptb, TBN_CUSTHELP);
            break;
            
        case IDOK:
            {
                int iPos, nItem;
                
                nItem = (int)SendDlgItemMessage(hDlg, IDC_BUTTONLIST,
                    LB_GETCURSEL, 0, 0L);
                
                iPos = (int)SendDlgItemMessage(hDlg, IDC_CURRENT,
                    LB_GETCURSEL, 0, 0L);
                
                if (iPos == -1)
                    iPos = 0;
                
                LBMoveButton(lpad, IDC_BUTTONLIST, nItem, IDC_CURRENT, iPos, 1);
                break;
            }
            
        case IDC_BUTTONLIST:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_DBLCLK:
                SendMessage(hDlg, WM_COMMAND, IDOK, 0L);
                break;
                
            case LBN_SETFOCUS:
            case LBN_KILLFOCUS:
                {
                    RECT rc;
                    
                    if (SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETITEMRECT,
                        (int)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETCURSEL,
                        0, 0L), (LPARAM)(LPRECT)&rc) != LB_ERR)
                        InvalidateRect(GET_WM_COMMAND_HWND(wParam, lParam), &rc, FALSE);
                }
                
            default:
                break;
            }
            break;
            
        case IDC_CURRENT:
            switch (GET_WM_COMMAND_CMD(wParam, lParam))
            {
            case LBN_SELCHANGE:
                {
                    BOOL bDelOK;
                    HWND hwndList = GET_WM_COMMAND_HWND(wParam, lParam);
                    int iPos = (int)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
                    
                    SafeEnableWindow(hDlg, IDOK, hwndList, BOOLFROMPTR(SendItemNotify(lpad->ptb, iPos, TBN_QUERYINSERT)));
                    
                    bDelOK = !(HIWORD(SendMessage(hwndList, LB_GETITEMDATA, iPos, 0L)) & FLAG_NODEL);
                    
                    SafeEnableWindow(hDlg, IDC_REMOVE, hwndList, bDelOK);
                    
                    SafeEnableWindow(hDlg, IDC_MOVEUP, hwndList, bDelOK &&
                        GetNearestInsert(lpad->ptb, iPos - 1, 0, GNI_LOW) >= 0);
                    
                    SafeEnableWindow(hDlg, IDC_MOVEDOWN, hwndList, bDelOK &&
                        GetNearestInsert(lpad->ptb, iPos + 2,
                        lpad->ptb->iNumButtons, GNI_HIGH) >=0 );
                    break;
                }
                
            case LBN_DBLCLK:
                SendMessage(hDlg, WM_COMMAND, IDC_REMOVE, 0L);
                break;
                
            case LBN_SETFOCUS:
            case LBN_KILLFOCUS:
                {
                    RECT rc;

                    if (SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETITEMRECT,
                        (int)SendMessage(GET_WM_COMMAND_HWND(wParam, lParam), LB_GETCURSEL,
                        0, 0L), (LPARAM)(LPRECT)&rc) != LB_ERR)
                        InvalidateRect(GET_WM_COMMAND_HWND(wParam, lParam), &rc, FALSE);
                }
                
            default:
                break;
            }
            break;
            
        case IDC_REMOVE:
            {
                int iPos = (int)SendDlgItemMessage(hDlg, IDC_CURRENT, LB_GETCURSEL, 0, 0);
                
                LBMoveButton(lpad, IDC_CURRENT, iPos, IDC_BUTTONLIST, 0, 0);
                break;
            }
            
        case IDC_MOVEUP:
        case IDC_MOVEDOWN:
            {
                int iPosSrc, iPosDst;
                
                iPosSrc = (int)SendDlgItemMessage(hDlg, IDC_CURRENT, LB_GETCURSEL, 0, 0L);
                if (wParam == IDC_MOVEUP)
                    iPosDst = GetNearestInsert(lpad->ptb, iPosSrc - 1, 0, GNI_LOW);
                else
                    iPosDst = GetNearestInsert(lpad->ptb, iPosSrc + 2, lpad->ptb->iNumButtons, GNI_HIGH);
                
                LBMoveButton(lpad, IDC_CURRENT, iPosSrc, IDC_CURRENT,iPosDst,0);
                break;
            }
            
        case IDC_RESET:
            {
                // ptb will change across call below
                HWND hwndT = lpad->ptb->ci.hwnd;
                BOOL fClose = FALSE;
                NMTBCUSTOMIZEDLG nm;
                nm.hDlg = hDlg;
                if (CCSendNotify(&lpad->ptb->ci, TBN_RESET, &nm.hdr) == TBNRF_ENDCUSTOMIZE)
                    fClose = TRUE;
                
                // ptb probably changed across above call
                lpad->ptb = FixPTB(hwndT);
            
                /* Reset the dialog, but exit if something goes wrong. */
                lpad->iPos = 0;
                if (!fClose && InitAdjustDlg(hDlg, lpad))
                    break;
            }
            
            /* We have to fall through because we won't know where to insert
             * buttons after resetting.
             */
        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            break;
            
        default:
            return(FALSE);
        }
        break;
        
    default:
        if (uMsg == uDragListMsg)
            return HandleDragMsg(lpad, hDlg, wParam, (LPDRAGLISTINFO)lParam);
        
        return(FALSE);
    }
    
    return(TRUE);
}

// BUGBUG: this should support saving to an IStream

/* This saves the state of the toolbar.  Spaces are saved as -1 (-2 if hidden)
 * and other buttons are just saved as the command ID.  When restoring, all
 * ID's are filled in, and the app is queried for all buttons so that the
 * bitmap and state information may be filled in.  Button ID's that are not
 * returned from the app are removed.
 */

BOOL SaveRestoreFromReg(PTBSTATE ptb, BOOL bWrite, HKEY hkr, LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    BOOL bRet = FALSE;
    TCHAR szDesc[128];
    
    if (bWrite)
    {
        UINT uSize = ptb->iNumButtons * sizeof(DWORD);
        NMTBSAVE nmtbs;
        BOOL fAlloced = FALSE;
        nmtbs.pData = NULL;
        nmtbs.cbData = uSize;
        nmtbs.pCurrent = NULL;
        nmtbs.iItem = -1; // signal pre saving
        nmtbs.cButtons = ptb->iNumButtons;
        CCSendNotify(&ptb->ci, TBN_SAVE, &nmtbs.hdr);
        if (!nmtbs.pData) {
            nmtbs.pData = (DWORD *)LocalAlloc(LPTR, nmtbs.cbData);
            fAlloced = TRUE;
        }

        // BUGBUG -- Somebody could've changed ptb->iNumButtons
        // during the CCSendNotify

        if (!nmtbs.pCurrent)
            nmtbs.pCurrent = nmtbs.pData;
        
        if (nmtbs.pData)
        {
            HKEY hkeySave;
            if (RegCreateKey(hkr, pszSubKey, &hkeySave) == ERROR_SUCCESS)
            {
                int i;
                for (i = 0; i < ptb->iNumButtons; i++)
                {
                    if (ptb->Buttons[i].idCommand)
                        *nmtbs.pCurrent = ptb->Buttons[i].idCommand;
                    else
                    {
                        // If the separator has an ID, then it is an "owner" item.
                        if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                            *nmtbs.pCurrent = (DWORD)-2;   // hidden
                        else
                            *nmtbs.pCurrent = (DWORD)-1;   // normal seperator
                    }
                    nmtbs.pCurrent++;
                    nmtbs.iItem = i;
                    TBOutputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                    CCSendNotify(&ptb->ci, TBN_SAVE, &nmtbs.hdr);
                }
                if (RegSetValueEx(hkeySave, (LPTSTR)pszValueName, 0, REG_BINARY, (LPVOID)nmtbs.pData, nmtbs.cbData) == ERROR_SUCCESS)
                    bRet = TRUE;
                RegCloseKey(hkeySave);
            }
            
            if (fAlloced)
                LocalFree((HLOCAL)nmtbs.pData);
        }
    }
    else
    {
        HKEY hkey;
        
        if (RegOpenKey(hkr, pszSubKey, &hkey) == ERROR_SUCCESS)
        {
            DWORD cbSize = 0;
            
            if ((RegQueryValueEx(hkey, (LPTSTR)pszValueName, 0, NULL, NULL, &cbSize) == ERROR_SUCCESS) &&
                (cbSize > sizeof(DWORD)))
            {
                UINT uSize = (UINT)cbSize;
                DWORD *pData = (DWORD *)LocalAlloc(LPTR, uSize);
                if (pData)
                {
                    DWORD dwType;
                    DWORD cbSize = (DWORD)uSize;
                    
                    if ((RegQueryValueEx(hkey, (LPTSTR)pszValueName, 0, &dwType, (LPVOID)pData, &cbSize) == ERROR_SUCCESS) &&
                        (dwType == REG_BINARY) &&
                        (cbSize == (DWORD)uSize))
                    {
                        int iButtonIndex;

                        NMTBRESTORE nmtbs;
                        BOOL fAlloced = FALSE;
                        nmtbs.pData = pData;
                        nmtbs.pCurrent = pData;
                        nmtbs.iItem = -1; // signal pre saving
                        nmtbs.cButtons = (int)uSize / SIZEOF(DWORD);
                        nmtbs.cbBytesPerRecord = SIZEOF(DWORD);
                        nmtbs.cbData = uSize;
                        // since we don't know the cButtons if they've added on extra data to pData,
                        // we'll use whatever they fill for cButtons
                        if (!CCSendNotify(&ptb->ci, TBN_RESTORE, &nmtbs.hdr)) {

                            //
                            // Before reloading the buttons, delete the tooltips
                            // of the previous buttons (if they exist).
                            //
                            if (ptb && ptb->hwndToolTips) {
                                TOOLINFO ti;

                                ti.cbSize = sizeof(ti);
                                ti.hwnd = ptb->ci.hwnd;

                                for (iButtonIndex = 0;
                                     iButtonIndex < ptb->iNumButtons; iButtonIndex++) {

                                    if (!(ptb->Buttons[iButtonIndex].fsStyle & TBSTYLE_SEP)) {
                                        ti.uId = ptb->Buttons[iButtonIndex].idCommand;
                                        SendMessage(ptb->hwndToolTips, TTM_DELTOOL,
                                            0, (LPARAM)(LPTOOLINFO)&ti);
                                    }
                                }
                            }

                            // BUGBUG -- can ptb be NULL here? - raymondc
                            // BUGBUG -- what if pCaptureButton != NULL?

                            // grow (or maybe shrink) pbt to hold new buttons
                            if (TBReallocButtons(ptb, nmtbs.cButtons))
                            {
                                int i;
                                if (ptb->iNumButtons < nmtbs.cButtons)
                                    ZeroMemory(&ptb->Buttons[ptb->iNumButtons], (nmtbs.cButtons - ptb->iNumButtons) * sizeof(TBBUTTON));
                                ptb->iNumButtons = nmtbs.cButtons;

                                for (i = 0; i < ptb->iNumButtons; i++)
                                {
                                    nmtbs.iItem = i;

                                    if ((long)*nmtbs.pCurrent < 0)
                                    {
                                        ptb->Buttons[i].fsStyle = TBSTYLE_SEP;
                                        ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) = g_dxButtonSep;
                                        ptb->Buttons[i].idCommand = 0;
                                        if (*nmtbs.pCurrent == (DWORD)-1)
                                            ptb->Buttons[i].fsState = 0;
                                        else
                                        {
                                            ASSERT(*nmtbs.pCurrent == (DWORD)-2);
                                            ptb->Buttons[i].fsState = TBSTATE_HIDDEN;
                                        }
                                    }
                                    else
                                    {
                                        ptb->Buttons[i].fsStyle = 0;
                                        ptb->Buttons[i].idCommand = *nmtbs.pCurrent;
                                        ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) = -1;
                                    }
                                    
                                    nmtbs.pCurrent++;
                                    
                                    TBOutputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                                    CCSendNotify(&ptb->ci, TBN_RESTORE, &nmtbs.hdr);
                                    ASSERT(nmtbs.tbButton.iString == -1 || !HIWORD(nmtbs.tbButton.iString));
                                    // we don't thunk.  only allow string index in string pool here
                                    if (HIWORD(nmtbs.tbButton.iString))
                                        nmtbs.tbButton.iString = 0;
                                    TBInputStruct(ptb, &ptb->Buttons[i], &nmtbs.tbButton);
                                }

                                // Now query for all buttons, and fill in the rest of the info

                                // For backward compatibility, ignore return value of TBN_BEGINADJUST
                                // if client is older than version 5 (NT5 #185499).
                                if (!SendCmdNotify(ptb, TBN_BEGINADJUST) || (ptb->ci.iVersion < 5)) {
                                    for (i = 0; ; i++)
                                    {
                                        TBBUTTONDATA tbAdjust;

                                        tbAdjust.idCommand = 0;

                                        if (!GetAdjustInfo(ptb, i, &tbAdjust, szDesc, ARRAYSIZE(szDesc)))
                                            break;

                                        if (!(tbAdjust.fsStyle & TBSTYLE_SEP) || tbAdjust.idCommand)
                                        {
                                            int iPos = PositionFromID(ptb, tbAdjust.idCommand);
                                            if (iPos >= 0) {
                                                ptb->Buttons[iPos] = tbAdjust;

                                            }
                                        }

                                    }
                                    SendCmdNotify(ptb, TBN_ENDADJUST);
                                }

                                // cleanup all the buttons that were not recognized
                                // do this backwards to minimize data movement (and nmtbs.cButtons changes)
                                for (i = ptb->iNumButtons - 1; i >= 0; i--)
                                {
                                    // DeleteButton does no realloc, so ptb will not move
                                    if (ptb->Buttons[i].DUMMYUNION_MEMBER(iBitmap) < 0)
                                        DeleteButton(ptb, (UINT)i);
                                    else {
                                        // the rest, add to tooltips 
                                        if(ptb->hwndToolTips &&
                                          (!(ptb->Buttons[i].fsStyle & TBSTYLE_SEP || !ptb->Buttons[i].idCommand))) {
                                            TOOLINFO ti;
                                            // don't bother setting the rect because we'll do it below
                                            // in TBInvalidateItemRects;
                                            ti.cbSize = sizeof(ti);
                                            ti.uFlags = 0;
                                            ti.hwnd = ptb->ci.hwnd;
                                            ti.uId = ptb->Buttons[i].idCommand;
                                            ti.lpszText = LPSTR_TEXTCALLBACK;

                                            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
                                        }
                                    }

                                }
                                bRet = (ptb->iNumButtons != 0); // success

                                // bugbug: break autosize to a function and call it
                                SendMessage(ptb->ci.hwnd, TB_AUTOSIZE, 0, 0);
                                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
                                TBInvalidateItemRects(ptb);
                            }
                        }
                    }
                    LocalFree((HLOCAL)pData);
                }
            }
            RegCloseKey(hkey);
        }
    }
    
    return bRet;
}

#ifndef WIN32

#ifndef WINNT
#pragma data_seg(DATASEG_READONLY)
#endif
#ifdef WINNT
const TCHAR c_szToolbarStates[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ToolbarState");
#else
const TCHAR c_szToolbarStates[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\ToolbarState");
#endif
#ifndef WINNT
#pragma data_seg()
#endif
BOOL SaveRestore(PTBSTATE ptb, BOOL bWrite, LPTSTR *lpNames)
{
    // note, we ignore lpNames[1] (the ini file name)
    // ... we hope we don't get conflicts with lpNames[0] entires
    
    return SaveRestoreFromReg(ptb, bWrite, HKEY_CURRENT_USER, c_szToolbarStates, lpNames[0]);
}

#endif


void CustomizeTB(PTBSTATE ptb, int iPos)
{
    ADJUSTDLGDATA ad;
    HWND hwndT = ptb->ci.hwnd;  // ptb will change across call below
    HRSRC hrsrc;
    LANGID wLang;
    LPVOID pTemplate;

    if (ptb->hdlgCust)      // We are already customizing this toolbar
        return;
    
    ad.ptb = ptb;
    ad.iPos = iPos;
    
    // REVIEW: really should be per thread data, but not likely to cause a problem
    
    // see note in WM_MEASUREITEM code
    g_dyButtonHack = (ptb->ci.style & TBSTYLE_FLAT) ? ptb->iDyBitmap : ptb->iButHeight;
    
    SendCmdNotify(ptb, TBN_BEGINADJUST);

    //
    //  Do locale-specific futzing.
    //
    wLang = LANGIDFROMLCID(CCGetProperThreadLocale(NULL));
    hrsrc = FindResourceExRetry(HINST_THISDLL, RT_DIALOG, MAKEINTRESOURCE(ADJUSTDLG), wLang);
    if (hrsrc &&
        (pTemplate = (LPVOID)LoadResource(HINST_THISDLL, hrsrc)))
    {
        DialogBoxIndirectParam(HINST_THISDLL, pTemplate,
                   ptb->ci.hwndParent, AdjustDlgProc, (LPARAM)(LPADJUSTDLGDATA)&ad);
    }

    // ptb probably changed across above call
    ptb = (PTBSTATE)GetWindowInt(hwndT, 0);
    ptb->hdlgCust = NULL;
    
    SendCmdNotify(ptb, TBN_ENDADJUST);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\thunk.h ===
/*************************************************************************\
*
* thunk.h
*
* These are helper functions to make thunking easier.
*
* 18-Aug-1994 JonPa     Created it.
*
\ *************************************************************************/

/*
 * Creates a buffer for a unicode string, and then copies the ANSI text
 * into it (converting it to unicode in the process)
 *
 * The returned pointer should be freed with FreeProducedString after use.
 */
LPWSTR ProduceWFromA( UINT uiCodePage, LPCSTR pszAnsi );

/*
 * Creates a buffer for a ANSI string, and then copies the UNICODE text
 * into it (converting it to ANSI in the process)
 *
 * The returned pointer should be freed with FreeProducedString after use.
 */
LPSTR ProduceAFromW( UINT uiCodePage, LPCWSTR pszW );


/*
 * FreeProducedString
 *
 * Takes a pointer returned from Produce?From?() and frees it.  No
 * validity checking is needed before calling this function.  (ie, any
 * value returned by Produce?From?() can be safely sent to this function)
 */
#define FreeProducedString( psz )   \
    if((psz) != NULL && ((LPSTR)psz) != LPSTR_TEXTCALLBACKA) {LocalFree(psz);} else


/*
 * Converts a UNICODE string to ANSI
 */
#define ConvertWToAN( uiCodePage, pszABuf, cchA, pszW, cchW )         \
    WideCharToMultiByte(uiCodePage, 0, pszW, cchW, pszABuf, cchA, NULL, NULL)

#define ConvertWToA( uiCodePage, pszABuf, pszW )     \
    ConvertWToAN( uiCodePage, pszABuf, INT_MAX, pszW, -1 )

/*
 * Converts an ANSI string to UNICODE
 */
#define ConvertAToWN( uiCodePage, pszWBuf, cchW, pszA, cchA )         \
    MultiByteToWideChar( uiCodePage, MB_PRECOMPOSED, pszA, cchA, pszWBuf, cchW )

#define ConvertAToW( uiCodePage, pszWBuf, pszAnsi )     \
    ConvertAToWN( uiCodePage, pszWBuf, INT_MAX, pszAnsi, -1 )


/*
 * IsFlagPtr
 *  Returns TRUE if the pointer == NULL or -1
 */
#define IsFlagPtr( p )  ((p) == NULL || (LPSTR)(p) == LPSTR_TEXTCALLBACKA)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\tab.c ===
#include "ctlspriv.h"
#include "tab.h"
#if defined(MAINWIN)
#include <mainwin.h>
#endif

#define BMOVECURSORONCLICK  FALSE
#define BMOVECURSORONDRAG   TRUE

#pragma code_seg(CODESEG_INIT)
BOOL NEAR PASCAL Tab_OnGetItemRect(PTC ptc, int iItem, LPRECT lprc);

BOOL FAR PASCAL Tab_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hinst, c_szTabControlClass, &wc)) {
#ifndef WIN32
        extern LRESULT CALLBACK _Tab_WndProc(HWND, UINT, WPARAM, LPARAM);
        wc.lpfnWndProc     = _Tab_WndProc;
#else
        wc.lpfnWndProc     = Tab_WndProc;
#endif

        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon           = NULL;
        wc.lpszMenuName    = NULL;
        wc.hInstance       = hinst;
        wc.lpszClassName   = c_szTabControlClass;
        wc.hbrBackground   = (HBRUSH)(COLOR_3DFACE + 1);
        wc.style           = CS_GLOBALCLASS | CS_DBLCLKS | CS_HREDRAW |  CS_VREDRAW;
        wc.cbWndExtra      = sizeof(PTC);
        wc.cbClsExtra      = 0;

        return RegisterClass(&wc);
    }

    return TRUE;
}

#pragma code_seg()

void Tab_VFlipRect(PTC ptc, LPRECT prc);
void FAR PASCAL FlipRect(LPRECT prc);
void FAR PASCAL VertInvalidateRect(HWND hwnd, LPRECT qrc, BOOL b, BOOL fVert);
void FAR PASCAL VertDrawEdge(HDC hdc, LPRECT qrc, UINT edgeType, UINT grfFlags,
                               BOOL fVert);
void FAR PASCAL VertPatBlt(HDC hdc1, int x1, int y1, int w, int h,
                          DWORD rop, BOOL fVert);


LRESULT TabDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    PTC ptc = (PTC)GetWindowInt(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_ENTER:
    case DPX_LEAVE:
        ptc->iDragTab = -1;
        ptc->dwDragDelay = 0;
        lres = 1;
        break;

    case DPX_DRAGHIT:
        if (lp)
        {
            BOOL fResetDelay = TRUE;
            int iTab;
            POINT pt;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;


            MapWindowPoints(NULL, ptc->ci.hwnd, &pt, 1);
            iTab = Tab_OnHitTest(ptc, pt.x, pt.y, NULL);

            if ((iTab != ptc->iSel))
            {
                if (iTab >= 0)
                {
                    DWORD dwHitTime = GetTickCount();

                    if (dwHitTime >= ptc->dwDragDelay)
                    {
                        if (ptc->dwDragDelay)
                        {
                            ChangeSel(ptc, iTab, TRUE, BMOVECURSORONDRAG);

                            // present no target if validation failed
                            // this will prevent accidental drops
                            if (ptc->iSel != iTab)
                                iTab = -1;
                        }
                        else
                        {
                            ptc->dwDragDelay = dwHitTime + TAB_DRAGDELAY;
                            fResetDelay = FALSE;
                        }
                    }
                    else if (iTab == ptc->iDragTab)
                        fResetDelay = FALSE;
                }

                ptc->iDragTab = iTab;
            }

            if (fResetDelay)
                ptc->dwDragDelay = 0;

            lres = (LRESULT)iTab;
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&ptc->ci, TCN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    case DPX_SELECT:
        if (((int)wp) >= 0)
        {
            SendMessage(ptc->ci.hwnd, TCM_HIGHLIGHTITEM, wp,
                MAKELPARAM((lp != DROPEFFECT_NONE), 0));
        }
        lres = 0;
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}


void VertSmoothScrollWindow(HWND hwnd, int dx, int dy, LPCRECT lprcSrc, LPCRECT lprcClip, HRGN hrgn, LPRECT lprcUpdate, UINT fuScroll, BOOL fVert, UINT uScrollMin)
{
    RECT rcSrc;
    RECT rcClip;
    
    if (fVert) {
        SWAP(dx, dy, int);
        
        if (lprcSrc) {
            rcSrc = *lprcSrc;
            lprcSrc = &rcSrc;
            FlipRect(&rcSrc);
        }
        if (lprcClip) {
            rcClip = *lprcClip;
            lprcClip = &rcClip;
            FlipRect(&rcClip);
        }
        
    }
    {
#ifndef UNIX
        SMOOTHSCROLLINFO si = 
        {
            sizeof(si),
            SSIF_MINSCROLL,
            hwnd, 
            dx, 
            dy, 
            lprcSrc, 
            lprcClip, 
            hrgn, 
            lprcUpdate, 
            fuScroll,
            SSI_DEFAULT,
            uScrollMin,
            uScrollMin
        };
#else
        SMOOTHSCROLLINFO si;
        si.cbSize=sizeof(si);
        si.fMask= SSIF_MINSCROLL;
        si.hwnd= hwnd;
        si.dx=dx;
        si.dy=dy;
        si.lprcSrc=lprcSrc;
        si.lprcClip=lprcClip;
        si.hrgnUpdate=hrgn;
        si.lprcUpdate=lprcUpdate;
        si.fuScroll=fuScroll;
        si.uMaxScrollTime=SSI_DEFAULT;
        si.cxMinScroll=uScrollMin;
        si.cyMinScroll= uScrollMin;
        si.pfnScrollProc = NULL;
#endif
        SmoothScrollWindow(&si);
    }
    
    if (fVert) {
        
        if (lprcUpdate)
            FlipRect(lprcUpdate);
    }
}

void Tab_SmoothScrollWindow(PTC ptc, int dx, int dy, LPRECT lprcSrc, LPRECT lprcClip, 
                            HRGN hrgn, LPRECT lprcUpdate, UINT fuScroll, UINT uScrollMin) 
{
    RECT rcSrc;
    RECT rcClip;
    if (Tab_Bottom(ptc)) {
        dy *= -1;
        if (lprcSrc) {
            rcSrc = *lprcSrc;
            lprcSrc = &rcSrc;
            Tab_VFlipRect(ptc, lprcSrc);
        }
        
        if (lprcClip) {
            rcClip = *lprcClip;
            lprcClip = &rcClip;
            Tab_VFlipRect(ptc, lprcClip);
        }
        
    }
    
    VertSmoothScrollWindow(ptc->ci.hwnd, dx, dy, lprcSrc, lprcClip, hrgn, lprcUpdate, fuScroll, Tab_Vertical(ptc), uScrollMin);

    if (lprcUpdate) {
        Tab_VFlipRect(ptc, lprcClip);
    }

}


void Tab_InvalidateRect(PTC ptc, LPRECT prc, BOOL b) 
{
    RECT rc = *prc;
    Tab_VFlipRect(ptc, &rc);
    VertInvalidateRect((ptc)->ci.hwnd, &rc, b, Tab_Vertical(ptc));
}

void Tab_DrawEdge(HDC hdc, LPRECT prc, UINT uType, UINT uFlags, PTC ptc) 
{
    RECT rc = *prc;
    Tab_VFlipRect(ptc, &rc);
    if (Tab_Bottom(ptc)) {
        
        
        UINT uNewFlags;

        if (uFlags & BF_DIAGONAL) {
            uNewFlags = uFlags & ~(BF_RIGHT | BF_LEFT);
            if (uFlags & BF_LEFT)
                uNewFlags |= BF_RIGHT;
            if (uFlags & BF_RIGHT) 
                uNewFlags |= BF_LEFT;
        } else {

            uNewFlags = uFlags & ~(BF_TOP | BF_BOTTOM);
            if (uFlags & BF_TOP)
                uNewFlags |= BF_BOTTOM;
            if (uFlags & BF_BOTTOM) 
                uNewFlags |= BF_TOP;
        }
        uFlags = uNewFlags;
    }
    VertDrawEdge(hdc, &rc, uType, uFlags, Tab_Vertical(ptc));
}
        
void Tab_PatBlt(HDC hdc, int x1, int y1, int w, int h, UINT rop, PTC ptc) 
{
    RECT rc;
    rc.top = y1;
    rc.left = x1;
    rc.right = x1+w;
    rc.bottom = y1+h;
    Tab_VFlipRect(ptc, &rc);
    VertPatBlt(hdc, rc.left, rc.top, RECTWIDTH(rc) , RECTHEIGHT(rc), rop, Tab_Vertical(ptc));
}
        

void NormalizeRect(LPRECT prc)
{
    if (prc->right < prc->left) {
        SWAP(prc->right, prc->left, int);
    }
    
    if (prc->bottom < prc->top) {
        SWAP(prc->bottom, prc->top, int);
    }
}

void VFlipRect(LPRECT prcClient, LPRECT prc)
{
    int iTemp = prc->bottom;
    
    prc->bottom = prcClient->bottom - (prc->top - prcClient->top);
    prc->top = prcClient->bottom - (iTemp - prcClient->top);
}

// diagonal flip.
void Tab_DFlipRect(PTC ptc, LPRECT prc)
{
    if (Tab_Vertical(ptc)) {
        FlipRect(prc);
    }
}

// vertical support is done much like the trackbar control.  we're going
// to flip the coordinate system.  this means that tabs will be added from top down.
void Tab_GetClientRect(PTC ptc, LPRECT prc)
{
    GetClientRect(ptc->ci.hwnd, prc);
    Tab_DFlipRect(ptc, prc);
}

// vertical flip
void Tab_VFlipRect(PTC ptc, LPRECT prc)
{
    if (Tab_Bottom(ptc)) {
        RECT rcClient;
        Tab_GetClientRect(ptc, &rcClient);
        VFlipRect(&rcClient, prc);

    }
}

void Tab_VDFlipRect(PTC ptc, LPRECT prc)
{
    Tab_VFlipRect(ptc, prc);
    Tab_DFlipRect(ptc, prc);
}

// real coordinates to tab coordinates
void Tab_DVFlipRect(PTC ptc, LPRECT prc)
{
    Tab_DFlipRect(ptc, prc);
    Tab_VFlipRect(ptc, prc);
}


#define Tab_ImageList_GetIconSize(ptc, pcx, pcy) VertImageList_GetIconSize((ptc)->himl, pcx, pcy, Tab_Vertical(ptc))
void FAR PASCAL VertImageList_GetIconSize(HIMAGELIST himl, LPINT pcx, LPINT pcy, BOOL fVert)
{
    ImageList_GetIconSize(himl, pcx, pcy);
    if (fVert) {
                
        // if we're in vertical mode, the width is really the height.
        // we won't draw the bitmaps sideways.  we'll rely on people
        // authoring them that way.
        int iTemp = *pcy;
        *pcy = *pcx;
        *pcx = iTemp;
        
    }
}

void FAR PASCAL VertImageList_Draw(HIMAGELIST himl, int iIndex, HDC hdc, int x, int y, UINT uFlags, BOOL fVert)
{
    if (fVert) {
        int iTemp;

        iTemp = y;
        y = x;
        x = iTemp;

        // since we draw from the upper left, flipping the x/y axis means we still draw from the upper left.
        // all we need to do is swap x and y.  we don't need to offset
    }
        
    ImageList_Draw( himl,  iIndex,  hdc,  x,  y,  uFlags);
}
void Tab_ImageList_Draw(PTC ptc, int iImage, HDC hdc, int x, int y, UINT uFlags) 
{
    RECT rc;
    int cxImage, cyImage;
    
    Tab_ImageList_GetIconSize(ptc, &cxImage, &cyImage);

    if (Tab_Bottom(ptc)) {
        y += cyImage;
    }
    rc.top = rc.bottom = y;
    Tab_VFlipRect(ptc, &rc);
    y = rc.top;
    
    VertImageList_Draw((ptc)->himl, iImage, hdc, x, y, uFlags, Tab_Vertical(ptc));
}

#if 1 // DRAWTEXT_DOES_VERTICAL

void Tab_DrawText(HDC hdc, LPTSTR lpsz, int nCount, LPRECT lprc, UINT uFormat, PTC ptc)
{
    RECT rcTemp = *lprc;
    Tab_VDFlipRect(ptc, &rcTemp);
    if (Tab_Vertical(ptc))
        uFormat |= DT_BOTTOM;
   
#ifdef KEYBOARDCUES
    if (CCGetUIState(&(ptc->ci)) & UISF_HIDEACCEL)
    {
        uFormat |= DT_HIDEPREFIX;
    }
#endif

    DrawText(hdc, lpsz, nCount, &rcTemp, uFormat);
}

void Tab_DrawTextEx(HDC hdc, LPTSTR lpsz, int nCount, LPRECT lprc, UINT uFormat, LPDRAWTEXTPARAMS lpParams, PTC ptc)
{
    RECT rcTemp = *lprc;
    Tab_VDFlipRect(ptc, &rcTemp);
    if (Tab_Vertical(ptc))
        uFormat |= DT_BOTTOM;
   
#ifdef KEYBOARDCUES
    if (CCGetUIState(&(ptc->ci)) & UISF_HIDEACCEL)
    {
        uFormat |= DT_HIDEPREFIX;
    }
#endif

    DrawTextEx(hdc, lpsz, nCount, &rcTemp, uFormat, lpParams);
}

#else

#define Tab_DrawText(hdc, lpsz, nCount, lprc, uFormat, ptc) DrawText(hdc, lpsz, nCount, lprc, uFormat)
#define Tab_DrawTextEx(hdc, lpsz, nCount, lprc, uFormat, lpParam, ptc) DrawTextEx(hdc, lpsz, nCount, lprc, uFormat, lpParam)

#endif

void NEAR PASCAL Tab_ExtTextOut(HDC hdc, int x, int y, UINT uFlags, LPRECT prc, 
                                LPTSTR lpsz, UINT cch, CONST INT *pdw, PTC ptc)
{
    RECT rcTemp;

    rcTemp.left = rcTemp.right = x;
    if (Tab_Bottom(ptc) && !Tab_Vertical(ptc)) {

        // first we need to move the top point because if we're drawing on Tab_Bottom, then
        // text won't extend down from y.
        y += ptc->tmHeight;
    }
    rcTemp.top = rcTemp.bottom = y;
    Tab_VDFlipRect(ptc, &rcTemp);
    x = rcTemp.left;
    y = rcTemp.bottom;
    
    rcTemp = *prc;
    Tab_VDFlipRect(ptc, &rcTemp);
    ExtTextOut(hdc, x, y, uFlags, &rcTemp, lpsz, cch, pdw);
}

void NEAR PASCAL VertDrawFocusRect(HDC hdc, LPRECT lprc, BOOL fVert)
{
    
    RECT rc;
    
    rc = *lprc;
    if (fVert)
        FlipRect(&rc);
    
    DrawFocusRect(hdc, &rc);
}

void Tab_DrawFocusRect(HDC hdc, LPRECT lprc, PTC ptc) 
{
    RECT rc = *lprc;
    Tab_VFlipRect(ptc, &rc);
    VertDrawFocusRect(hdc, &rc, Tab_Vertical(ptc));
}


void NEAR PASCAL Tab_Scroll(PTC ptc, int dx, int iNewFirstIndex)
{
    int i;
    int iMax;
    RECT rc;
    LPTABITEM pitem = NULL;

    // don't stomp on edge unless first item is selected
    rc.left = g_cxEdge;
    rc.right = ptc->cxTabs;   // Dont scroll beyond tabs.
    rc.top = 0;
    rc.bottom = ptc->cyTabs + 2 * g_cyEdge;  // Only scroll in the tab area
    
    // See if we can scroll the window...
    // DebugMsg(DM_TRACE, TEXT("Tab_Scroll dx=%d, iNew=%d\n\r"), dx, iNewFirstIndex);
    Tab_SmoothScrollWindow(ptc, dx, 0, NULL, &rc,
            NULL, NULL, SW_INVALIDATE | SW_ERASE, SSI_DEFAULT);

    // We also need to update the item rectangles and also
    // update the internal variables...
    iMax = Tab_Count(ptc) - 1;
    for (i = iMax; i >= 0; i--)
    {
        pitem = Tab_FastGetItemPtr(ptc, i);
        OffsetRect(&pitem->rc, dx, 0);
    }

    // If the previously last visible item is not fully visible
    // now, we need to invalidate it also.
    //
    if (ptc->iLastVisible > iMax)
        ptc->iLastVisible = iMax;

    for (i = ptc->iLastVisible; i>= 0; i--)
    {
        pitem = Tab_GetItemPtr(ptc, i);
        if (pitem) {
            if (pitem->rc.right <= ptc->cxTabs)
                break;
            Tab_InvalidateItem(ptc, ptc->iLastVisible, TRUE);
        }
    }

    if ((i == ptc->iLastVisible) && pitem)
    {
        // The last previously visible item is still fully visible, so
        // we need to invalidate to the right of it as there may have been
        // room for a partial item before, that will now need to be drawn.
        rc.left = pitem->rc.right;
        Tab_InvalidateRect(ptc, &rc, TRUE);
    }

    ptc->iFirstVisible = iNewFirstIndex;

    if (ptc->hwndArrows)
        SendMessage(ptc->hwndArrows, UDM_SETPOS, 0, MAKELPARAM(iNewFirstIndex, 0));

    UpdateToolTipRects(ptc);
}


void NEAR PASCAL Tab_OnHScroll(PTC ptc, HWND hwndCtl, UINT code, int pos)
{
    // Now process the Scroll messages
    if (code == SB_THUMBPOSITION)
    {
        //
        // For now lets simply try to set that item as the first one
        //
        {
            // If we got here we need to scroll
            LPTABITEM pitem = Tab_GetItemPtr(ptc, pos);
            int dx = 0;

            if (pitem)
                dx = -pitem->rc.left + g_cxEdge;

            if (dx || !pitem) {
                Tab_Scroll(ptc, dx, pos);
                UpdateWindow(ptc->ci.hwnd);
            }
        }
    }
}

void NEAR Tab_OnSetRedraw(PTC ptc, BOOL fRedraw)
{
    if (fRedraw) {
        ptc->flags |= TCF_REDRAW;
        RedrawAll(ptc, RDW_INVALIDATE);
    } else {
        ptc->flags &= ~TCF_REDRAW;
    }
}

void NEAR Tab_OnSetFont(PTC ptc, HFONT hfont, BOOL fRedraw)
{
    ASSERT(ptc);

    if (!ptc->hfontLabel || hfont != ptc->hfontLabel)
    {
        if (ptc->flags & TCF_FONTCREATED) {
            DeleteObject(ptc->hfontLabel);
            ptc->flags &= ~TCF_FONTCREATED;
            ptc->hfontLabel = NULL;
        }
        
        if (!hfont) {
            // set back to system font
            ptc->hfontLabel = g_hfontSystem;
        } else {
            ptc->flags |= TCF_FONTSET;
            ptc->hfontLabel = hfont;
            ptc->ci.uiCodePage = GetCodePageForFont(hfont);
        }
        ptc->cxItem = ptc->cyTabs = RECOMPUTE;
        

        if (Tab_Vertical(ptc)) {
            // make sure that the font is drawn vertically
            LOGFONT lf;
            GetObject(ptc->hfontLabel, sizeof(lf), &lf);
            
            if (Tab_Bottom(ptc)) {
                lf.lfEscapement = 2700;
            } else {
                lf.lfEscapement = 900; // 90 degrees
            }
            lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
            
            ptc->hfontLabel = CreateFontIndirect(&lf);
            ptc->flags |= TCF_FONTCREATED;
        }

        RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
    }
}


BOOL NEAR Tab_OnCreate(PTC ptc)
{
    HDC hdc;

#ifdef MAINWIN
        // IEUNIX : Using CreateWindowEx with special style to get rid of unwanted border.
        // Mainwin problem
        DWORD exStyle = WS_EX_MW_UNMANAGED_WINDOW;
#else
        DWORD exStyle = 0;
#endif

    ptc->hdpa = DPA_Create(4);
    if (!ptc->hdpa)
        return FALSE;

#ifdef DEBUG
#if 0
    if ((GetAsyncKeyState(VK_SHIFT) < 0) &&
        (GetAsyncKeyState(VK_CONTROL) < 0))
        ptc->ci.style |= TCS_SCROLLOPPOSITE;
    
    if ((GetAsyncKeyState(VK_SHIFT) < 0) &&
        (GetAsyncKeyState(VK_MENU) < 0))
        ptc->ci.style |= TCS_VERTICAL;

    if ((GetAsyncKeyState(VK_SHIFT) < 0) &&
        (GetAsyncKeyState(VK_MENU) < 0))
        ptc->ci.style |= TCS_VERTICAL;
    
    if ((GetAsyncKeyState(VK_SHIFT) < 0) &&
        (GetAsyncKeyState(VK_CONTROL) < 0))
        ptc->ci.style |= TCS_BOTTOM;

#endif

#endif

#ifdef DEBUG
    if (IsFlagSet(g_dwPrototype, PTF_FLATLOOK))
    {
        TraceMsg(TF_GENERAL, "Using flat look for tab controls.");
        ptc->ci.style |= TCS_FLATBUTTONS | TCS_HOTTRACK;
    }
#endif

    // make sure we don't have invalid bits set
    if (!Tab_FixedWidth(ptc)) {
        ptc->ci.style &= ~(TCS_FORCEICONLEFT | TCS_FORCELABELLEFT);
    }
    
    if (Tab_Vertical(ptc)) {
        ptc->ci.style |= TCS_MULTILINE;
        //ptc->ci.style &= ~TCS_BUTTONS;
    }
    
    if (Tab_ScrollOpposite(ptc)) {
        ptc->ci.style |= TCS_MULTILINE;
        ptc->ci.style &= ~TCS_BUTTONS;
    }

    if (Tab_FlatButtons(ptc)) {
        ptc->dwStyleEx |= TCS_EX_FLATSEPARATORS;
    }

    // make us always clip siblings
    SetWindowLong(ptc->ci.hwnd, GWL_STYLE, WS_CLIPSIBLINGS | ptc->ci.style);

    ptc->flags = TCF_REDRAW;        // enable redraw
    ptc->cbExtra = sizeof(LPARAM);  // default extra size
    ptc->iSel = -1;
    ptc->iHot = -1;
    ptc->cxItem = ptc->cyTabs = RECOMPUTE;
    ptc->cxPad = g_cxEdge * 3;
    ptc->cyPad = (g_cyEdge * 3/2);
    ptc->iFirstVisible = 0;
    ptc->hwndArrows = NULL;
    ptc->iLastRow = -1;
    ptc->iNewSel = -1;
    ptc->iLastTopRow = -1;

    hdc = GetDC(NULL);
    ptc->iTabWidth = GetDeviceCaps(hdc, LOGPIXELSX);
    ReleaseDC(NULL, hdc);

    //BUGBUG remove this after move to commctrl
    InitDitherBrush();

    if (ptc->ci.style & TCS_TOOLTIPS) {
        TOOLINFO ti;
        // don't bother setting the rect because we'll do it below
        // in FlushToolTipsMgr;
        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd = ptc->ci.hwnd;
        ti.uId = (UINT_PTR)ptc->ci.hwnd;
        ti.lpszText = 0;

        ptc->hwndToolTips = CreateWindowEx(exStyle, c_szSToolTipsClass, TEXT(""),
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              ptc->ci.hwnd, NULL, HINST_THISDLL,
                                              NULL);
        if (ptc->hwndToolTips)
            SendMessage(ptc->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);
        else
            ptc->ci.style &= ~(TCS_TOOLTIPS);
    }

#if defined(FE_IME) || !defined(WINNT)
    if (g_fDBCSInputEnabled)
        ptc->hPrevImc = ImmAssociateContext(ptc->ci.hwnd, 0L);
#endif
    return TRUE;
}


void NEAR Tab_OnDestroy(PTC ptc)
{
    int i;

#if defined(FE_IME) || !defined(WINNT)
    if (g_fDBCSInputEnabled)
        ImmAssociateContext(ptc->ci.hwnd, ptc->hPrevImc);
#endif

    if ((ptc->ci.style & TCS_TOOLTIPS) && IsWindow(ptc->hwndToolTips)) {
        DestroyWindow(ptc->hwndToolTips);
    }

    for (i = 0; i < Tab_Count(ptc); i++)
        Tab_FreeItem(ptc, Tab_FastGetItemPtr(ptc, i));

    DPA_Destroy(ptc->hdpa);

    if (ptc->hDragProxy)
        DestroyDragProxy(ptc->hDragProxy);

    if (ptc->flags & TCF_FONTCREATED) {
        DeleteObject(ptc->hfontLabel);
    }
    
    if (ptc) {
        SetWindowInt(ptc->ci.hwnd, 0, 0);
        NearFree((HLOCAL)ptc);
    }

    //BUGBUG remove this after move to commctrl
    TerminateDitherBrush();
}

// returns true if it actually moved

void NEAR PASCAL PutzRowToBottom(PTC ptc, int iRowMoving)
{
    int i;
    LPTABITEM pitem;
    int dy;
    RECT rcTabs;
    

    Tab_GetClientRect(ptc, &rcTabs);
    
    if (Tab_ScrollOpposite(ptc)) {
        // in scroll mode, the iRow doesn't change.  only the rc's do.
        int yOldTop;
        int yNewTop;
        
        int iLastTopRow = ptc->iLastTopRow == -1 ? ptc->iLastRow : ptc->iLastTopRow;

        if (iRowMoving == iLastTopRow) {
            if (ptc->iLastTopRow == -1)
                ptc->iLastTopRow = iRowMoving;
            return; // already at the bottom;
        }

            
        
        // this is the height of the tab's empty area... which is the amount
        // of space a tab must move to get from the top to the bottom
        dy = rcTabs.bottom - rcTabs.top - (ptc->cyTabs * (ptc->iLastRow + 1)) - g_cyEdge;
        
        for (i = Tab_Count(ptc) - 1; i >= 0; i--) {
            pitem = Tab_FastGetItemPtr(ptc, i);
            DebugMsg(DM_TRACE, TEXT("Putzing %s %d %d %d %d"), pitem->pszText, pitem->rc.left, pitem->rc.top, pitem->rc.right, pitem->rc.bottom);
            
            // save this for scrolling below
            if (pitem->iRow == iRowMoving) {
                yNewTop = pitem->rc.bottom;
            } else if (pitem->iRow == iLastTopRow) {
                yOldTop = pitem->rc.bottom;
            }
            
            if (pitem->iRow > iRowMoving) {
                // this item should be on the bottom
                
                if (pitem->iRow <= iLastTopRow) {
                    // but it's not...
                    OffsetRect(&pitem->rc, 0, dy);
                    
                }
                
            } else {
                // this item should be on the top
                
                if (pitem->iRow > iLastTopRow) {
                    // but it's not... so move it
                    OffsetRect(&pitem->rc, 0, -dy);
                }
            }
            
            if ((pitem->iRow == iLastTopRow) && iLastTopRow > iRowMoving) {
                // in this case, we need to get the yOldTop AFTER it's moved.
                yOldTop = pitem->rc.bottom;
            }
            DebugMsg(DM_TRACE, TEXT("Putzing %s %d %d %d %d"), pitem->pszText, pitem->rc.left, pitem->rc.top, pitem->rc.right, pitem->rc.bottom);
            
        }
        
        if (ptc->iLastTopRow != -1) {
            // if it wasn't a full recalc, then we need to do some scrollwindow stuff.
            int dy;
            // first find the topmost parent
            
            dy = yOldTop - yNewTop;
            if (yNewTop > yOldTop) {
                rcTabs.top = yOldTop;
                rcTabs.bottom = yNewTop;
            } else {
                rcTabs.top = yNewTop;
                rcTabs.bottom = yOldTop;
            }
            
            Tab_SmoothScrollWindow(ptc, 0, dy, NULL, &rcTabs, NULL, NULL, SW_ERASE |SW_INVALIDATE, 1);
            InflateRect(&rcTabs, g_cxEdge, g_cyEdge);
            Tab_InvalidateRect(ptc, &rcTabs, FALSE);
        }

        ptc->iLastTopRow = iRowMoving;
        
    } else {
        
        if (iRowMoving == ptc->iLastRow)
            return; // already at the bottom;

        // no scrolling.  just set the iRow var appropriatesly

        for (i = Tab_Count(ptc) -1 ;i >= 0; i--) {
            pitem = Tab_FastGetItemPtr(ptc, i);
            if (pitem->iRow > iRowMoving) {
                
                // if the row is higher than the row that's being selected,
                // it drops one.
                pitem->iRow--;
                dy = -ptc->cyTabs;
                
            } else if (pitem->iRow == iRowMoving) {
                // save this
                rcTabs.top = pitem->rc.top;
                
                // if it's on the row that's moving down, we assign it to iLastRow and
                //calculate how far it needs to go.
                dy = ptc->cyTabs * (ptc->iLastRow - iRowMoving);
                pitem->iRow = ptc->iLastRow;

            } else
                continue;

            pitem->rc.top += dy;
            pitem->rc.bottom += dy;
        }
        
        rcTabs.bottom = ptc->cyTabs * (ptc->iLastRow + 1);
            
        Tab_SmoothScrollWindow(ptc, 0, rcTabs.bottom - rcTabs.top, NULL, &rcTabs, NULL, NULL, SW_ERASE |SW_INVALIDATE, 1);
        UpdateWindow(ptc->ci.hwnd);
        // invalidate the little bit below the
        rcTabs.bottom += 2*g_cyEdge;
        rcTabs.top = rcTabs.bottom - 3 * g_cyEdge;
        Tab_InvalidateRect(ptc, &rcTabs, TRUE);
    }
    UpdateToolTipRects(ptc);
}

__inline int Tab_InterButtonGap(PTC ptc)
{
    ASSERT(Tab_DrawButtons(ptc));

    if (Tab_FlatButtons(ptc)) {
        return (g_cxEdge * 5);
    } else {
        return (g_cxEdge * 3)/2;
    }
}

//
//  BADNESS is the amount of unused space in the row
//
#define BADNESS(ptc, i) (ptc->cxTabs - Tab_FastGetItemPtr(ptc, i)->rc.right)

// borrow one tab from the prevous row
BOOL NEAR PASCAL BorrowOne(PTC ptc, int iCurLast, int iPrevLast, int iBorrow)
{
    LPTABITEM pitem, pitem2;
    int i;
    int dx;

    // is there room to move the prev item? (might now be if iPrev is huge)
    pitem = Tab_FastGetItemPtr(ptc, iPrevLast);
    pitem2 = Tab_FastGetItemPtr(ptc, iCurLast);

    // dx is the number of extra pixels that aren't part of the pitem->rc.
    // The non-button case of 2 * g_cxEdge is maniacally hard-coded
    // all over the place.  Change it at your own risk.
    if (Tab_DrawButtons(ptc))
        dx = Tab_InterButtonGap(ptc);
    else
        dx = 2 * g_cxEdge;              // inflate by g_cxEdge

    // if the size of the item is greaterthan the badness
    if (BADNESS(ptc, iCurLast) < (pitem->rc.right - pitem->rc.left + dx))
        return FALSE;

    // otherwise do it.
    // move this one down
    dx = pitem->rc.left - Tab_FastGetItemPtr(ptc, iPrevLast + 1)->rc.left;
    pitem->rc.left -= dx;
    pitem->rc.right -= dx;
    pitem->rc.top = pitem2->rc.top;
    pitem->rc.bottom = pitem2->rc.bottom;
    pitem->iRow = pitem2->iRow;

    // and move all the others over.
    dx = pitem->rc.right - pitem->rc.left;
    for(i = iPrevLast + 1 ; i <= iCurLast ; i++ ) {
        pitem = Tab_FastGetItemPtr(ptc, i);
        pitem->rc.left += dx;
        pitem->rc.right += dx;
    }

    if (iBorrow) {
        if (pitem->iRow > 1) {

            // borrow one from the next row up.
            // setup the new iCurLast as the one right before the one we moved
            // (the one we moved is now the current row's first
            // and hunt backwards until we find an iPrevLast
            iCurLast = iPrevLast - 1;
            while (iPrevLast-- &&
                   Tab_FastGetItemPtr(ptc, iPrevLast)->iRow == (pitem->iRow - 1))
            {
                if (iPrevLast <= 0)
                {
                    // sanity check
                    return FALSE;
                }
            }
            return BorrowOne(ptc, iCurLast, iPrevLast, iBorrow - 1 );
        } else
            return FALSE;

    }
    return TRUE;
}


// fill last row will fiddle around borrowing from the previous row(s)
// to keep from having huge huge bottom tabs
void NEAR PASCAL FillLastRow(PTC ptc)
{
    int hspace;
    int cItems = Tab_Count(ptc);
    int iPrevLast;
    int iBorrow = 0;

    // if no items or one row
    if (!cItems)
        return;


    for (iPrevLast = cItems - 2;
         Tab_FastGetItemPtr(ptc, iPrevLast)->iRow == ptc->iLastRow;
         iPrevLast--)
    {
        // sanity check
        if (iPrevLast <= 0)
        {
            ASSERT(FALSE);
            return;
        }
    }

    while (iPrevLast &&  (hspace = BADNESS(ptc, cItems-1)) &&
           (hspace > ((ptc->cxTabs/8) + BADNESS(ptc, iPrevLast))))
    {
        // if borrow fails, bail
        if (!BorrowOne(ptc, cItems - 1, iPrevLast, iBorrow++))
            return;
        iPrevLast--;
    }
}

void NEAR PASCAL RightJustify(PTC ptc)
{
    int i;
    LPTABITEM pitem;
    int j;
    int k;
    int n;
    int cItems = Tab_Count(ptc);
    int hspace, dwidth, dremainder, moved;

    // don't justify if only one row
    if (ptc->iLastRow < 1)
        return;

    FillLastRow(ptc);

    for ( i = 0; i < cItems; i++ ) {
        int iRow;
        pitem = Tab_FastGetItemPtr(ptc, i) ;
        iRow = pitem->iRow;

        // find the last item in this row
        for( j = i ; j < cItems; j++) {
            if(Tab_FastGetItemPtr(ptc, j)->iRow != iRow)
                break;
        }

        // count the number of items
        for(n=0,k=i ; k < j ; k++ ) {
            pitem = Tab_FastGetItemPtr(ptc, k);
            if (!(pitem->dwState & TCIS_HIDDEN))
                n++;
        }

        // how much to fill
        hspace = ptc->cxTabs - Tab_FastGetItemPtr(ptc, j-1)->rc.right - g_cxEdge;
        dwidth = hspace/n;  // amount to increase each by.
        dremainder =  hspace % n; // the remnants
        moved = 0;  // how much we've moved already

        for( ; i < j ; i++ ) {
            int iHalf = dwidth/2;
            pitem = Tab_FastGetItemPtr(ptc, i);

            if (!(pitem->dwState & TCIS_HIDDEN)) {
                pitem->rc.left += moved;
                pitem->xLabel += iHalf;
                pitem->xImage += iHalf;
                moved += dwidth + (dremainder ? 1 : 0);
                if ( dremainder )  dremainder--;
                pitem->rc.right += moved;
            }
        }
        i--; //dec because the outter forloop incs again.
    }
}

BOOL NEAR Tab_OnDeleteAllItems(PTC ptc)
{
    int i;

    for (i = Tab_Count(ptc); i-- > 0; i) {
        if(ptc->hwndToolTips) {
            TOOLINFO ti;
            ti.cbSize = sizeof(ti);
            ti.hwnd = ptc->ci.hwnd;
            ti.uId = i;
            SendMessage(ptc->hwndToolTips, TTM_DELTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);
        }
        Tab_FreeItem(ptc, Tab_FastGetItemPtr(ptc, i));
    }

    DPA_DeleteAllPtrs(ptc->hdpa);

    ptc->cxItem = RECOMPUTE;    // force recomputing of all tabs
    ptc->iSel = -1;
    ptc->iFirstVisible = 0;

    RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
    return TRUE;
}

BOOL NEAR Tab_OnSetItemExtra(PTC ptc, int cbExtra)
{
    if (Tab_Count(ptc) >0 || cbExtra<0)
        return FALSE;

    ptc->cbExtra = cbExtra;

    return TRUE;
}

BOOL NEAR Tab_OnSetItem(PTC ptc, int iItem, const TC_ITEM FAR* ptci)
{
    TABITEM FAR* pitem;
    UINT mask;
    BOOL fChanged = FALSE;
    BOOL fFullRedraw = FALSE;

    mask = ptci->mask;
    if (!mask)
        return TRUE;

    pitem = Tab_GetItemPtr(ptc, iItem);
    if (!pitem)
        return FALSE;

    if (mask & TCIF_TEXT)
    {
        if (!Str_Set(&pitem->pszText, ptci->pszText))
            return FALSE;
        fFullRedraw = TRUE;
        fChanged = TRUE;
#if defined(WINDOWS_ME)
        pitem->etoRtlReading = (mask & TCIF_RTLREADING) ?ETO_RTLREADING :0;
#endif
    }

    if (mask & TCIF_IMAGE) {

        if (pitem->iImage == -1 || 
            ptci->iImage == -1) {
            // went from no image to image... or vice versa
            // means needs full redraw
            
            fFullRedraw = TRUE;
        }
        pitem->iImage = ptci->iImage;
        fChanged = TRUE;
    }

    if ((mask & TCIF_PARAM) && ptc->cbExtra)
    {
        hmemcpy(pitem->DUMMYUNION_MEMBER(abExtra), &ptci->lParam, ptc->cbExtra);
    }
    
    if (mask & TCIF_STATE) {
        DWORD dwOldState = pitem->dwState;
        
        pitem->dwState = 
            (ptci->dwState & ptci->dwStateMask) | 
                (pitem->dwState & ~ptci->dwStateMask);
        
        if (dwOldState != pitem->dwState)
            fChanged = TRUE;

        if ((dwOldState ^ pitem->dwState) & TCIS_HIDDEN)
            fFullRedraw = TRUE;
        
        if ((ptci->dwStateMask & TCIS_BUTTONPRESSED) &&
            !(ptci->dwState & TCIS_BUTTONPRESSED)) {
            // if they turned OFF being pushed and we were pushed because of
            // selection, nuke it now.
            if (ptc->iNewSel == iItem) {
                ptc->iNewSel = -1;
                fChanged = TRUE;
            }
            
            if (ptc->iSel == iItem) {
                ChangeSel(ptc, -1, TRUE, FALSE);
                fChanged = TRUE;
            }
        }
    }

    if (fChanged) {
        if (Tab_FixedWidth(ptc) || !fFullRedraw) {
            Tab_InvalidateItem(ptc, iItem, FALSE);
        } else {
            ptc->cxItem = ptc->cyTabs = RECOMPUTE;
            RedrawAll(ptc, RDW_INVALIDATE | RDW_NOCHILDREN | RDW_ERASE);
        }
    }
    return TRUE;
}

void NEAR PASCAL Tab_OnMouseMove(PTC ptc, WPARAM fwKeys, int x, int y)
{
    POINT pt;
    int iHit;
    pt.x=x; pt.y=y;

    iHit = Tab_OnHitTest(ptc, x, y, NULL);
    
    if (Tab_HotTrack(ptc)) {
        if (iHit != ptc->iHot) {
            Tab_InvalidateItem(ptc, iHit, FALSE);
            Tab_InvalidateItem(ptc, ptc->iHot, FALSE);
            ptc->iHot = iHit;
        }
        
    }
    
    if (fwKeys & MK_LBUTTON && Tab_DrawButtons(ptc)) {

        UINT uFlags;

        if (ptc->iNewSel == -1)
            return;

        if (iHit == ptc->iNewSel) {
            uFlags = TCF_DRAWSUNKEN;

        } else {
            uFlags = 0;
        }

        if ((ptc->flags & TCF_DRAWSUNKEN) != uFlags) {

            // the bit isn't what it should be
            ptc->flags ^=  TCF_DRAWSUNKEN;

            // we need to invalidate on flat buttons because we go from one pixes to 2 pixel edge
            Tab_InvalidateItem(ptc, ptc->iNewSel, Tab_FlatButtons(ptc));
            
        }
    }
}

void NEAR PASCAL Tab_OnButtonUp(PTC ptc, int x, int y, BOOL fNotify)
{
    BOOL fAllow = TRUE;


    if (fNotify) {
        // pass NULL for parent because W95 queryied each time and some
        // folks reparent
        fAllow = !SendNotifyEx(NULL, ptc->ci.hwnd, NM_CLICK, NULL, ptc->ci.bUnicode);
    }

    if (Tab_DrawSunken(ptc)) {
        
        // nothing selected (its empty)
        // only do this if something is selected...
        // otherwise we still do need to go below and release capture though
        if (ptc->iNewSel != -1) {

            
            if (Tab_OnHitTest(ptc, x, y, NULL) == ptc->iNewSel) {

                int iNewSel = ptc->iNewSel;
                // use iNewSel instead of ptc->iNewSel because the SendNotify could have nuked us

                if (fAllow)
                    ChangeSel(ptc, iNewSel, TRUE, BMOVECURSORONCLICK);

                Tab_InvalidateItem(ptc, iNewSel, FALSE);

            } else {
                Tab_InvalidateItem(ptc, ptc->iNewSel, FALSE);
                Tab_InvalidateItem(ptc, ptc->iNewSel, FALSE);
            }

            // the changsel forces an updatewindow,
            // but we might have a border to unpaint(because of the TCF_DRAWSUNKEN
            // so we do another invalidate with just redraw 
            ptc->flags &= ~TCF_DRAWSUNKEN;
            ptc->iNewSel = -1;
        }
    }

    // don't worry about checking DrawButtons because TCF_MOUSEDOWN
    // wouldn't be set otherwise.
    if (ptc->flags & TCF_MOUSEDOWN) {
        int iOldSel = ptc->iNewSel;
        ptc->flags &= ~TCF_MOUSEDOWN; // do this before release  to avoid reentry
        ptc->iNewSel = -1;
        Tab_InvalidateItem(ptc, iOldSel, FALSE);
        CCReleaseCapture(&ptc->ci);
    }

}

int NEAR Tab_OnHitTest(PTC ptc, int x, int y, UINT FAR *lpuFlags)
{
    int i;
    int iLast = Tab_Count(ptc);
    RECT rc;
    POINT pt;
    UINT uTemp;


    rc.left = rc.right = x;
    rc.top = rc.bottom = y;
    Tab_DVFlipRect(ptc, &rc);
    pt.x = rc.left;
    pt.y = rc.top;

    if (!lpuFlags) lpuFlags = &uTemp;

    for (i = 0; i < iLast; i++) {
        LPTABITEM pitem = Tab_FastGetItemPtr(ptc, i);
        if (PtInRect(&pitem->rc, pt)) {
            
            // x now needs to be in pitem coordinates
            x -= pitem->rc.left;
           
            *lpuFlags = TCHT_ONITEM;
            if (!Tab_OwnerDraw(ptc)) {
                if ((x > pitem->xLabel) && x < pitem->xLabel + pitem->cxLabel) {
                    *lpuFlags = TCHT_ONITEMLABEL;
                } else if (HASIMAGE(ptc, pitem)) {
                    int cxImage, cyImage;
                    Tab_ImageList_GetIconSize(ptc, &cxImage, &cyImage);
                    if ((x > pitem->xImage) && (x < (pitem->xImage + cxImage)))
                        *lpuFlags = TCHT_ONITEMICON;
                }
            }
            return i;
        }
    }
    *lpuFlags = TCHT_NOWHERE;
    return -1;
}

void Tab_DeselectAll(PTC ptc, BOOL fExcludeFocus)
{
    int iMax = Tab_Count(ptc) - 1;
    int i;

    if (Tab_DrawButtons(ptc)) {
        for (i = iMax; i >= 0; i--)
        {
            LPTABITEM pitem;

            pitem = Tab_FastGetItemPtr(ptc, i);
            if (!fExcludeFocus || (pitem->dwState & TCIS_BUTTONPRESSED)) {
                TCITEM tci;
                tci.mask = TCIF_STATE;
                tci.dwStateMask = TCIS_BUTTONPRESSED;
                tci.dwState = 0;
                Tab_OnSetItem(ptc, i, &tci);
            }
        }
    }
}

void NEAR Tab_OnRButtonDown(PTC ptc, int x, int y, WPARAM keyFlags)
{
    int i;
    int iOldSel = -1;

    
    if (Tab_Vertical(ptc)) {
        
        if (y > ptc->cxTabs) 
            return;
        
    } else {

        if (x > ptc->cxTabs)
            return;     // outside the range of the visible tabs
    }

    i = Tab_OnHitTest(ptc, x,y, NULL); // we don't swap x,y here because OnHitTest will

    if (i != -1) {

        if (Tab_DrawButtons(ptc) && Tab_MultiSelect(ptc)) {
            TCITEM tci;
            tci.mask = TCIF_STATE;
            tci.dwStateMask = TCIS_BUTTONPRESSED;

            Tab_OnGetItem(ptc, i, &tci);

            // as with the listview, don't deselect anything on right button
            if (!(tci.dwState & TCIS_BUTTONPRESSED)) {
                if (!(GetAsyncKeyState(VK_CONTROL) < 0)) {
                    Tab_DeselectAll(ptc, FALSE);
                }

                // just toggle the pushed state.
                tci.dwState = TCIS_BUTTONPRESSED;
                Tab_OnSetItem(ptc, i, &tci);
            }
        }
    }
}

void NEAR Tab_OnLButtonDown(PTC ptc, int x, int y, WPARAM keyFlags)
{
    int i;
    int iOldSel = -1;

    
    if (Tab_Vertical(ptc)) {
        
        if (y > ptc->cxTabs) 
            return;
        
    } else {

        if (x > ptc->cxTabs)
            return;     // outside the range of the visible tabs
    }

    i = Tab_OnHitTest(ptc, x,y, NULL); // we don't swap x,y here because OnHitTest will

    if (i != -1) {
        
        if (Tab_MultiSelect(ptc) && (GetAsyncKeyState(VK_CONTROL) < 0) && Tab_DrawButtons(ptc) ) {
            // just toggle the pushed state.
            TCITEM tci;
            tci.mask = TCIF_STATE;
            tci.dwStateMask = TCIS_BUTTONPRESSED;
            
            Tab_OnGetItem(ptc, i, &tci);
            tci.dwState ^= TCIS_BUTTONPRESSED;
            Tab_OnSetItem(ptc, i, &tci);
            
        } else {
            
            iOldSel = ptc->iSel;

            if ((!Tab_FocusNever(ptc))
                && Tab_FocusOnButtonDown(ptc))
            {
                SetFocus(ptc->ci.hwnd);
            }

            if (Tab_DrawButtons(ptc)) {
                ptc->iNewSel = i;
                ptc->flags |= (TCF_DRAWSUNKEN|TCF_MOUSEDOWN);
                SetCapture(ptc->ci.hwnd);
                // we need to invalidate on flat buttons because we go from one pixes to 2 pixel edge
                Tab_InvalidateItem(ptc, i, Tab_FlatButtons(ptc));
            } else {
                iOldSel = ChangeSel(ptc, i, TRUE, BMOVECURSORONCLICK);
            }
        }
    }

    if ((!Tab_FocusNever(ptc)) &&
        (iOldSel == i))  // reselect current selection
        // this also catches i == -1 because iOldSel started as -1
    {
        SetFocus(ptc->ci.hwnd);
        UpdateWindow(ptc->ci.hwnd);
    }
}


TABITEM FAR* NEAR Tab_CreateItem(PTC ptc, const TC_ITEM FAR* ptci)
{
    TABITEM FAR* pitem;

    if (pitem = Alloc(sizeof(TABITEM)-sizeof(LPARAM)+ptc->cbExtra))
    {
        if (ptci->mask & TCIF_IMAGE)
            pitem->iImage = ptci->iImage;
        else
            pitem->iImage = -1;

        pitem->xLabel = pitem->yLabel = RECOMPUTE;

        // If specified, copy extra block of memory.
        if (ptci->mask & TCIF_PARAM) {
            if (ptc->cbExtra) {
                hmemcpy(pitem->DUMMYUNION_MEMBER(abExtra), &ptci->lParam, ptc->cbExtra);
            }
        }

        if (ptci->mask & TCIF_TEXT)  {
            if (!Str_Set(&pitem->pszText, ptci->pszText))
            {
                Tab_FreeItem(ptc, pitem);
                return NULL;
            }
#if defined(WINDOWS_ME)
            pitem->etoRtlReading = (ptci->mask & TCIF_RTLREADING) ?ETO_RTLREADING :0;
#endif
        }
    }
    return pitem;
}


void NEAR Tab_UpdateArrows(PTC ptc, BOOL fSizeChanged)
{
    RECT rc;
    BOOL fArrow;

    Tab_GetClientRect(ptc, &rc);

    if (IsRectEmpty(&rc))
        return;     // Nothing to do yet!

    // See if all of the tabs will fit.
    ptc->cxTabs = rc.right;     // Assume can use whole area to paint

    if (Tab_MultiLine(ptc))
        fArrow = FALSE;
    else {
        CalcPaintMetrics(ptc, NULL);
        fArrow = (ptc->cxItem >= rc.right);
    }

    if (!fArrow)
    {
    NoArrows:
        // Don't need arrows
        if (ptc->hwndArrows)
        {
            ShowWindow(ptc->hwndArrows, SW_HIDE);
            // BUGBUG:: This is overkill should only invalidate portion
            // that may be impacted, like the last displayed item..
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        }
        if (ptc->iFirstVisible > 0) {
#ifdef DEBUG
            if (!ptc->hwndArrows) {
                DebugMsg(DM_TRACE, TEXT("Scrolling where we wouldnt' have scrolled before"));
            }
#endif
            Tab_OnHScroll(ptc, NULL, SB_THUMBPOSITION, 0);
            // BUGBUG:: This is overkill should only invalidate portion
            // that may be impacted, like the last displayed item..
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        }
    }
    else
    {
        int cx;
        int cy;
        int iMaxBtnVal;
        int xSum;
        TABITEM FAR * pitem;


        // We need the buttons as not all of the items will fit
        // BUGBUG:: Should handle big ones...
#if 0
        cx = g_cxVScroll;
        cy = g_cyHScroll;
#else
        cy = ptc->cxyArrows;
        cx = cy * 2;
#endif
        ptc->cxTabs = rc.right - cx;   // Make buttons square

        //  See how many tabs we have to remove until the last tab becomes
        //  fully visible.
        xSum = 0;                       // Number of pixels in removed tabs
        for (iMaxBtnVal=0; (ptc->cxTabs + xSum) < ptc->cxItem; iMaxBtnVal++)
        {
            pitem = Tab_GetItemPtr(ptc, iMaxBtnVal);
            if (!pitem)
                break;
            xSum += pitem->rc.right - pitem->rc.left;
        }

        // If we removed *all* the tabs, then put the last one back.
        // This happens if the last tab is so huge it doesn't fit into
        // the requisite space no matter how many tabs you remove.
        if (iMaxBtnVal >= Tab_Count(ptc))
        {
            iMaxBtnVal = Tab_Count(ptc) - 1;
        }

        //  If we don't need to remove any tabs, then we guessed wrong about
        //  arrows.  This can happen if there is exactly one tab that doesn't
        //  fit in the requisite space.  No arrow since there is nothing to
        //  scroll to!
        //
        if (iMaxBtnVal <= 0)
        {
            ptc->cxTabs = rc.right;     // Can use whole area to paint
            goto NoArrows;
        }

        if (!ptc->hwndArrows) {
            
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
            ptc->hwndArrows = CreateUpDownControl
                (Tab_Vertical(ptc) ? (HDS_VERT | WS_CHILD) : (UDS_HORZ | WS_CHILD), 0, 0, 0, 0,
                 ptc->ci.hwnd, 1, HINST_THISDLL, NULL, iMaxBtnVal, 0,
                 ptc->iFirstVisible);
        }

        // DebugMsg(DM_TRACE, TEXT("Tabs_UpdateArrows iMax=%d\n\r"), iMaxBtnVal);
        if (ptc->hwndArrows)
        {
            rc.left = rc.right - cx;
            rc.top = ptc->cyTabs - cy;
            rc.bottom = ptc->cyTabs;
            Tab_VDFlipRect(ptc, &rc);
            
            if (fSizeChanged || !IsWindowVisible(ptc->hwndArrows))
                SetWindowPos(ptc->hwndArrows, NULL,
                             rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                             SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);
            // Make sure the range is set
            SendMessage(ptc->hwndArrows, UDM_SETRANGE, 0,
                        MAKELPARAM(iMaxBtnVal, 0));

        }
    }
}

int NEAR Tab_OnInsertItem(PTC ptc, int iItem, const TC_ITEM FAR* ptci)
{
    TABITEM FAR* pitem;
    int i;

    pitem = Tab_CreateItem(ptc, ptci);
    if (!pitem)
        return -1;

    i = iItem;

    i = DPA_InsertPtr(ptc->hdpa, i, pitem);
    if (i == -1)
    {
        Tab_FreeItem(ptc, pitem);
        return -1;
    }

    if (ptc->iSel < 0)
        ptc->iSel = i;
    else if (ptc->iSel >= i)
        ptc->iSel++;

    if (ptc->iFirstVisible > i)
        ptc->iFirstVisible++;

    ptc->cxItem = RECOMPUTE;    // force recomputing of all tabs

    //Add tab to tooltips..  calculate the rect later
    if(ptc->hwndToolTips) {
        TOOLINFO ti;
        // don't bother setting the rect because we'll do it below
        // in FlushToolTipsMgr;
        ti.cbSize = sizeof(ti);
#ifdef WINDOWS_ME
        ti.uFlags = ptci->mask & TCIF_RTLREADING ?TTF_RTLREADING :0;
#else
        ti.uFlags = 0;
#endif
        ti.hwnd = ptc->ci.hwnd;
        ti.uId = Tab_Count(ptc) - 1 ;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        SendMessage(ptc->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
    }

    if (Tab_RedrawEnabled(ptc)) {
        RECT rcInval;
        LPTABITEM pitem;

        if (Tab_DrawButtons(ptc)) {

            if (Tab_FixedWidth(ptc)) {

                CalcPaintMetrics(ptc, NULL);
                if (i == Tab_Count(ptc) - 1) {
                    Tab_InvalidateItem(ptc, i, FALSE);
                } else {
                    pitem = Tab_GetItemPtr(ptc, i);
                    GetClientRect(ptc->ci.hwnd, &rcInval);

                    if (pitem) {
                        rcInval.top = pitem->rc.top;
                        if (ptc->iLastRow == 0) {
                            rcInval.left = pitem->rc.left;
                        }
                        Tab_UpdateArrows(ptc, FALSE);
                        RedrawWindow(ptc->ci.hwnd, &rcInval, NULL, RDW_INVALIDATE |RDW_NOCHILDREN);
                    }
                }

                MyNotifyWinEvent(EVENT_OBJECT_CREATE, ptc->ci.hwnd, OBJID_CLIENT, i+1);
                return i;
            }

        } else {

            // in tab mode Clear the selected item because it may move
            // and it sticks high a bit.
            if (ptc->iSel > i) {
                // update now because invalidate erases
                // and the redraw below doesn't.
                Tab_InvalidateItem(ptc, ptc->iSel, TRUE);
                UpdateWindow(ptc->ci.hwnd);
            }
        }

        RedrawAll(ptc, RDW_INVALIDATE | RDW_NOCHILDREN);

    }

    MyNotifyWinEvent(EVENT_OBJECT_CREATE, ptc->ci.hwnd, OBJID_CLIENT, i+1);
    return i;
}

// Add/remove/replace item

BOOL NEAR Tab_FreeItem(PTC ptc, TABITEM FAR* pitem)
{
    if (pitem)
    {
        Str_Set(&pitem->pszText, NULL);
        Free(pitem);
    }
    return FALSE;
}

void NEAR PASCAL Tab_OnRemoveImage(PTC ptc, int iItem)
{
    if (ptc->himl && iItem >= 0) {
        int i;
        LPTABITEM pitem;

        ImageList_Remove(ptc->himl, iItem);
        for( i = Tab_Count(ptc)-1 ; i >= 0; i-- ) {
            pitem = Tab_FastGetItemPtr(ptc, i);
            if (pitem->iImage > iItem)
                pitem->iImage--;
            else if (pitem->iImage == iItem) {
                pitem->iImage = -1; // if we now don't draw something, inval
                Tab_InvalidateItem(ptc, i, FALSE);
            }
        }
    }
}

BOOL NEAR Tab_OnDeleteItem(PTC ptc, int i)
{
    TABITEM FAR* pitem;
    UINT uRedraw;
    RECT rcInval;
    rcInval.left = -1; // special flag...

    if (i >= Tab_Count(ptc))
        return FALSE;

    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, ptc->ci.hwnd, OBJID_CLIENT, i+1);

    if (!Tab_DrawButtons(ptc) && (Tab_RedrawEnabled(ptc) || ptc->iSel >= i)) {
        // in tab mode, Clear the selected item because it may move
        // and it sticks high a bit.
        Tab_InvalidateItem(ptc, ptc->iSel, TRUE);
    }

    // if its fixed width, don't need to erase everything, just the last one
    if (Tab_FixedWidth(ptc)) {
        int j;

        uRedraw = RDW_INVALIDATE | RDW_NOCHILDREN;
        j = Tab_Count(ptc) -1;
        Tab_InvalidateItem(ptc, j, TRUE);

        // update optimization
        if (Tab_DrawButtons(ptc)) {

            if (i == Tab_Count(ptc) - 1) {
                rcInval.left = 0;
                uRedraw = 0;
            } else {
                pitem = Tab_GetItemPtr(ptc, i);
                GetClientRect(ptc->ci.hwnd, &rcInval);

                if (pitem) {
                    rcInval.top = pitem->rc.top;
                    if (ptc->iLastRow == 0) {
                        rcInval.left = pitem->rc.left;
                    }
                }
            }
        }

    } else {
        uRedraw = RDW_INVALIDATE | RDW_NOCHILDREN | RDW_ERASE;
    }
    pitem = DPA_DeletePtr(ptc->hdpa, i);
    if (!pitem)
        return FALSE;


    Tab_FreeItem(ptc, pitem);

    if (ptc->iSel == i)
        ptc->iSel = -1;       // deleted the focus item
    else if (ptc->iSel > i)
        ptc->iSel--;          // slide the foucs index down

    // maintain the first visible
    if (ptc->iFirstVisible > i)
        ptc->iFirstVisible--;

    ptc->cxItem = RECOMPUTE;    // force recomputing of all tabs
    ptc->iLastTopRow = -1;
    if(ptc->hwndToolTips) {
        TOOLINFO ti;
        ti.cbSize = sizeof(ti);
        ti.hwnd = ptc->ci.hwnd;
        ti.uId = Tab_Count(ptc) ;
        SendMessage(ptc->hwndToolTips, TTM_DELTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }

    if (Tab_RedrawEnabled(ptc)) {
        if (rcInval.left == -1) {
            RedrawAll(ptc, uRedraw);
        } else {

            Tab_UpdateArrows(ptc, FALSE);
            if (uRedraw)
                RedrawWindow(ptc->ci.hwnd, &rcInval, NULL, uRedraw);
        }
    }

    return TRUE;
}



BOOL NEAR Tab_OnGetItem(PTC ptc, int iItem, TC_ITEM FAR* ptci)
{
    UINT mask = ptci->mask;
    const TABITEM FAR* pitem = Tab_GetItemPtr(ptc, iItem);

    if (!pitem)
    {
        // NULL init the the tci struct incase there is no pitem.
        // This is incase the dude calling doesn't check the return
        // from this function. Bug # 7105
        if (mask & TCIF_PARAM)
            ptci->lParam = 0;
        else if (mask & TCIF_TEXT)
            ptci->pszText = 0;
        else if (mask & TCIF_IMAGE)
            ptci->iImage = 0;

        return FALSE;
    }

    if (mask & TCIF_TEXT) {
        if (pitem->pszText)
            lstrcpyn(ptci->pszText, pitem->pszText, ptci->cchTextMax);
        else
            ptci->pszText = 0;
    }
    
    if (mask & TCIF_STATE) {
        ptci->dwState = pitem->dwState & ptci->dwStateMask;
        
        // REViEW... maybe we should maintain the state in the statemask...
        if (ptci->dwStateMask & TCIS_BUTTONPRESSED) {
            if ((ptc->iSel == iItem) ||
                ((ptc->iNewSel == iItem) && Tab_DrawSunken(ptc))) {
                
                ptci->dwState |= TCIS_BUTTONPRESSED;
                
            }
        }
    }


    if ((mask & TCIF_PARAM) && ptc->cbExtra)
        hmemcpy(&ptci->lParam, pitem->DUMMYUNION_MEMBER(abExtra), ptc->cbExtra);

    if (mask & TCIF_IMAGE)
        ptci->iImage = pitem->iImage;
#ifdef WINDOWS_ME
    // A-MSADEK, BUGBUG:
    // TC_ITEM does not have room for querying TCIF_RTLREADING !!
    // it only allows you to set it.
    // This is a hack to return info about tab item reading order
    if((mask & TCIF_RTLREADING) && !(mask & TCIF_TEXT)) {
        if(pitem->etoRtlReading)
            ptci->cchTextMax = 1;
    }       
#endif // WINDOWS_ME

    return TRUE;
}

void NEAR PASCAL Tab_InvalidateItem(PTC ptc, int iItem, BOOL bErase)
{
    if (iItem != -1) {
        LPTABITEM pitem = Tab_GetItemPtr(ptc, iItem);

        if (pitem) {
            RECT rc = pitem->rc;
            if (rc.right > ptc->cxTabs)
                rc.right = ptc->cxTabs;  // don't invalidate past our end
            InflateRect(&rc, g_cxEdge, g_cyEdge);
            if (Tab_FlatButtons(ptc)) {
                rc.right += 2 * g_cxEdge;
            }
            Tab_InvalidateRect(ptc, &rc, bErase);
        }
    }
}

BOOL NEAR PASCAL RedrawAll(PTC ptc, UINT uFlags)
{
    if (ptc && Tab_RedrawEnabled(ptc)) {
        Tab_UpdateArrows(ptc, FALSE);
        RedrawWindow(ptc->ci.hwnd, NULL, NULL, uFlags);
        return TRUE;
    }
    return FALSE;
}

int NEAR PASCAL ChangeSel(PTC ptc, int iNewSel, BOOL bSendNotify,
    BOOL bUpdateCursorPos)
{
    BOOL bErase;
    int iOldSel;
    HWND hwnd;
    SIZE screenDelta;
    RECT rcT;

    if (iNewSel == ptc->iSel)
        return ptc->iSel;

    if (bUpdateCursorPos && Tab_OnGetItemRect(ptc, iNewSel, &rcT))
    {
        screenDelta.cx = rcT.left;
        screenDelta.cy = rcT.top;
    }
    else
    {
        screenDelta.cx = screenDelta.cy = 0;
        bUpdateCursorPos = FALSE;
    }

    hwnd = ptc->ci.hwnd;
    // make sure in range
    if (iNewSel < 0) {
        iOldSel = ptc->iSel;
        ptc->iSel = -1;
    } else if (iNewSel < Tab_Count(ptc)) {

        LPTABITEM pitem = Tab_GetItemPtr(ptc, iNewSel);
        ASSERT(pitem);
        if (!pitem)
            return -1;

        //
        // dont allow a hidden item to get the focus
        //
        // BUGBUG this is not 100% correct, focus will only
        // BUGBUG work right if hidden items are at the begining
        // BUGBUG or end (user will not be able to arrow past it)
        //
        // BUGBUG currenly this is not a bad restriction
        // BUGBUG only desk.cpl uses this flag, and it
        // BUGBUG always hides the last item.
        //
        // BUGBUG if we make this a general flag we will need to
        // BUGBUG fix this.
        //
        if (pitem->dwState & TCIS_HIDDEN)
            return -1;

        // make sure this is a change that's wanted
        if (bSendNotify)
        {
            // pass NULL for parent because W95 queryied each time and some
            // folks reparent
            if (SendNotifyEx(NULL, hwnd, TCN_SELCHANGING, NULL, ptc->ci.bUnicode))
                return ptc->iSel;
        }

        iOldSel = ptc->iSel;
        ptc->iSel = iNewSel;

        // See if we need to make sure the item is visible
        if (Tab_MultiLine(ptc)) {
            if( !Tab_DrawButtons(ptc) && ptc->iLastRow > 0 && iNewSel != -1) {
                // In multiLineTab Mode bring the row to the bottom.
                PutzRowToBottom(ptc, Tab_FastGetItemPtr(ptc, iNewSel)->iRow);
            }
        } else   {
            // In single line mode, slide things over to  show selection
            RECT rcClient;
            int xOffset = 0;
            int iNewFirstVisible = 0;

            GetClientRect(ptc->ci.hwnd, &rcClient);
            if (pitem->rc.left < g_cxEdge)
            {
                xOffset = -pitem->rc.left + g_cxEdge;        // Offset to get back to zero
                iNewFirstVisible = iNewSel;
            }
            else if ((iNewSel != ptc->iFirstVisible) &&
                    (pitem->rc.right > ptc->cxTabs))
            {
                // A little more tricky new to scroll each tab until we
                // fit on the end
                for (iNewFirstVisible = ptc->iFirstVisible;
                        iNewFirstVisible < iNewSel;)
                {
                    LPTABITEM pitemT = Tab_FastGetItemPtr(ptc, iNewFirstVisible);
                    xOffset -= (pitemT->rc.right - pitemT->rc.left);
                    iNewFirstVisible++;
                    if ((pitem->rc.right + xOffset) < ptc->cxTabs)
                        break;      // Found our new top index
                }
                // If we end up being the first item shown make sure our left
                // end is showing correctly
                if (iNewFirstVisible == iNewSel)
                    xOffset = -pitem->rc.left + g_cxEdge;
            }

            if (xOffset != 0)
            {
                Tab_Scroll(ptc, xOffset, iNewFirstVisible);
            }
        }
    } else
        return -1;

    Tab_DeselectAll(ptc, TRUE);
    
    // repaint opt: we don't need to erase for buttons because their paint covers all.
    bErase = (!Tab_DrawButtons(ptc) || Tab_FlatButtons(ptc));
    if (bErase)
        UpdateWindow(hwnd);
    Tab_InvalidateItem(ptc, iOldSel, bErase);
    Tab_InvalidateItem(ptc, iNewSel, bErase);
    // mfc4.2 relies upon this update window.  they do something that
    // forces the window invalid bit to be false on the TCN_SELCHANGE and
    // thereby making us lose this update window
    UpdateWindow(hwnd);

    if (bUpdateCursorPos && Tab_OnGetItemRect(ptc, iNewSel, &rcT))
    {
        POINT ptCursor;

        screenDelta.cx = rcT.left - screenDelta.cx;
        screenDelta.cy = rcT.top  - screenDelta.cy;

        GetCursorPos(&ptCursor);
        SetCursorPos(ptCursor.x + screenDelta.cx, ptCursor.y + screenDelta.cy);
    }

    // if they are buttons, we send the message on mouse up
    if (bSendNotify)
    {
        // pass NULL for parent because W95 queryied each time and some
        // folks reparent
        SendNotifyEx(NULL, hwnd, TCN_SELCHANGE, NULL, ptc->ci.bUnicode);
    }

    MyNotifyWinEvent(EVENT_OBJECT_SELECTION, hwnd, OBJID_CLIENT, ptc->iSel+1);
    // We might've been destroyed during the notify, but GetFocus
    // couldn't possibly return our hwnd in that case, so we're still safe.
    if (GetFocus() == hwnd)
        MyNotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, ptc->iSel+1);

    return iOldSel;
}



void NEAR PASCAL CalcTabHeight(PTC ptc, HDC hdc)
{
    BOOL bReleaseDC = FALSE;

    if (ptc->cyTabs == RECOMPUTE) {
        TEXTMETRIC tm;
        int iYExtra;
        int cx, cy = 0;

        if (!hdc)
        {
            bReleaseDC = TRUE;
            hdc = GetDC(NULL);
            SelectObject(hdc, ptc->hfontLabel);
        }

        GetTextMetrics(hdc, &tm);
        if (!ptc->fMinTabSet) {
            ptc->cxMinTab = tm.tmAveCharWidth * 6 + ptc->cxPad * 2;
        }
        ptc->cxyArrows = tm.tmHeight + 2 * g_cyEdge;

        if (ptc->himl)
            Tab_ImageList_GetIconSize(ptc, &cx, &cy);

        if (ptc->iTabHeight) {
            ptc->cyTabs = ptc->iTabHeight;
            if (Tab_DrawButtons(ptc))
                iYExtra = 3 * g_cyEdge; // (for the top edge, button edge and room to drop down)
            else
                iYExtra = 2 * g_cyEdge - 1;

        } else {
            // the height is the max of image or label plus padding.
            // where padding is 2*cypad-edge but at lease an edges
            iYExtra = ptc->cyPad*2;
            if (iYExtra < 2*g_cyEdge)
                iYExtra = 2*g_cyEdge;

            if (!Tab_DrawButtons(ptc))
                iYExtra -= (1 + g_cyEdge);

            // add an edge to the font height because we want a bit of
            // space under the text
            ptc->cyTabs = max(tm.tmHeight + g_cyEdge, cy) + iYExtra;
        }

        ptc->tmHeight = tm.tmHeight;
        // add one so that if it's odd, we'll round up.
        ptc->cyText = (ptc->cyTabs - iYExtra - tm.tmHeight + 1) / 2;
        ptc->cyIcon = (ptc->cyTabs - iYExtra - cy) / 2;

        if (bReleaseDC)
        {
            ReleaseDC(NULL, hdc);
        }
    }
}

void NEAR PASCAL UpdateToolTipRects(PTC ptc)
{
    if(ptc->hwndToolTips) {
        int i;
        TOOLINFO ti;
        int iMax;
        LPTABITEM pitem;

        ti.cbSize = sizeof(ti);
#if defined(WINDOWS_ME)
        // bugbug: should this be rtlreading?
#endif
        ti.uFlags = 0;
        ti.hwnd = ptc->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        for ( i = 0, iMax = Tab_Count(ptc); i < iMax;  i++) {
            pitem = Tab_FastGetItemPtr(ptc, i);

            ti.uId = i;
            ti.rect = pitem->rc;
            Tab_VDFlipRect(ptc, &ti.rect);
            SendMessage(ptc->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
        }
    }
}

void PASCAL Tab_GetTextExtentPoint(PTC ptc, HDC hdc, LPTSTR lpszText, int iCount, LPSIZE lpsize)
{
    TCHAR szBuffer[128];

    if (iCount < ARRAYSIZE(szBuffer) && !Tab_Vertical(ptc)) {
        StripAccelerators(lpszText, szBuffer, TRUE);
        lpszText = szBuffer;
        iCount = lstrlen(lpszText);
    }
    GetTextExtentPoint(hdc, lpszText, iCount, lpsize);
}

void PASCAL Tab_InvertRows(PTC ptc)
{
    int i;
    int yTop = g_cyEdge;
    int yNew;
    int iNewRow;
    
    // we want the first item to be on the bottom.
    for (i = Tab_Count(ptc) - 1; i >= 0; i--) {
        LPTABITEM pitem = Tab_FastGetItemPtr(ptc, i);
        iNewRow = ptc->iLastRow - pitem->iRow;
        yNew = yTop + iNewRow * ptc->cyTabs;
        pitem->iRow = iNewRow;
        OffsetRect(&pitem->rc, 0, yNew - pitem->rc.top);
    }
}

void NEAR PASCAL CalcPaintMetrics(PTC ptc, HDC hdc)
{
    SIZE siz;
    LPTABITEM pitem;
    int i, x, y;
    int xStart;
    int iRow = 0;
    int cItems = Tab_Count(ptc);
    BOOL bReleaseDC = FALSE;

    if (ptc->cxItem == RECOMPUTE) {
        
        // if the font hasn't been created yet, let's do it now
        if (!ptc->hfontLabel)
            Tab_OnSetFont(ptc, NULL, FALSE);
        
        if (!hdc)
        {
            bReleaseDC = TRUE;
            hdc = GetDC(NULL);
            SelectObject(hdc, ptc->hfontLabel);
        }

        CalcTabHeight(ptc, hdc);

        if (Tab_DrawButtons(ptc)) {
            // start at the edge;
            xStart = 0;
            y = 0;
        } else {
            xStart = g_cxEdge;
            y = g_cyEdge;
        }
        x = xStart;

        for (i = 0; i < cItems; i++) {
            int cxImage = 0, cy;
            int cxBounds = 0;
            pitem = Tab_FastGetItemPtr(ptc, i);

            if (pitem->pszText) {
                Tab_GetTextExtentPoint(ptc, hdc, pitem->pszText, lstrlen(pitem->pszText), &siz);
            } else  {
                siz.cx = 0;
                siz.cy = 0;
            }

            pitem->cxLabel = siz.cx;

            // if there's an image, count that too
            if (HASIMAGE(ptc, pitem)) {
                Tab_ImageList_GetIconSize(ptc, &cxImage, &cy);

                cxImage += ptc->cxPad;
                siz.cx += cxImage;
            }
            cxBounds = siz.cx;

            if (Tab_FixedWidth(ptc)) {
                siz.cx = ptc->iTabWidth;
            } else {

                siz.cx += ptc->cxPad * 2;
                // Make sure the tab has a least a minimum width
                if (siz.cx < ptc->cxMinTab)
                    siz.cx = ptc->cxMinTab;
            }

            // handle hidden items
            if (pitem->dwState & TCIS_HIDDEN) {
                siz.cx = 0;
                siz.cy = 0;
            }

            // should we wrap?
            if (Tab_MultiLine(ptc)) {
                // two cases to wrap around:
                // case 2: is our right edge past the end but we ourselves
                //   are shorter than the width?
                // case 1: are we already past the end? (this happens if
                //      the previous line had only one item and it was longer
                //      than the tab's width.
                int iTotalWidth = ptc->cxTabs - g_cxEdge;
                if (x > iTotalWidth ||
                    (x+siz.cx >= iTotalWidth &&
                     (siz.cx < iTotalWidth))) {
                    x = xStart;
                    y += ptc->cyTabs;
                    iRow++;

                    if (Tab_DrawButtons(ptc))
                        y += ((g_cyEdge * 3)/2);
                }
                pitem->iRow = iRow;
            }

            pitem->rc.left = x;
            pitem->rc.right = x + siz.cx;
            pitem->rc.top = y;
            pitem->rc.bottom = ptc->cyTabs + y;

            if (!Tab_FixedWidth(ptc) || Tab_ForceLabelLeft(ptc) ||
                Tab_ForceIconLeft(ptc)) {

                pitem->xImage = ptc->cxPad;

            } else {
                // in fixed width mode center it
                pitem->xImage = (siz.cx - cxBounds)/2;
            }

            if (pitem->xImage < g_cxEdge)
                pitem->xImage = g_cxEdge;

            if (Tab_ForceIconLeft(ptc)) {
                // Center the text in the space remaining after the icon
                // The math here gets kind of crazy so I'm going to draw
                // a picture.
                //
                //     xImage
                //     |
                //   ->|   |<- cxImage
                //   +-----------------------------------------------+
                //   |  @@@           text text text                 |
                //   |  @@@                                          |
                //   +-----------------------------------------------+
                //   |<----------------- siz.cx -------------------->|
                //         |<-magic->|<--cxLabel--->|
                //                   xLabel
                //
                //  Therefore,
                //
                //  remaining space = siz.cx - cxImage - xImage - cxLabel.
                //  magic = remaining space / 2
                //  xLabel = xImage + cxImage + magic.
                //
                int cxImageTotal = pitem->xImage + cxImage;
                int cxRemaining = siz.cx - cxImageTotal - pitem->cxLabel;
                int cxMagic = cxRemaining / 2;
                pitem->xLabel = cxImageTotal + cxMagic;
            } else {
                // Place the text immediately after the icon
                pitem->xLabel = pitem->xImage + cxImage;

            }
            

            pitem->yImage = ptc->cyPad + ptc->cyIcon - (g_cyEdge/2);
            pitem->yLabel = ptc->cyPad + ptc->cyText - (g_cyEdge/2);

            x = pitem->rc.right;

            if (Tab_DrawButtons(ptc))
                x += Tab_InterButtonGap(ptc);
        }

        ptc->cxItem = x;        // total width of all tabs

        // if we added a line in non-button mode, we need to do a full refresh
        if (ptc->iLastRow != -1 &&
            ptc->iLastRow != iRow &&
            !Tab_DrawButtons(ptc)) {
            InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        }
        ptc->iLastRow = (cItems > 0) ? iRow : -1;

        if (Tab_MultiLine(ptc)) {
            if (!Tab_RaggedRight(ptc) && !Tab_FixedWidth(ptc))
                RightJustify(ptc);
            
            if (Tab_ScrollOpposite(ptc)) {
                Tab_InvertRows(ptc);
                                // if we have no selection, then the last row is the last top row
                                if (ptc->iSel == -1) 
                                        ptc->iLastTopRow = ptc->iLastRow;
            }

            if (!Tab_DrawButtons(ptc) && ptc->iSel != -1) {
                ptc->iLastTopRow = -1;
                PutzRowToBottom(ptc, Tab_FastGetItemPtr(ptc, ptc->iSel)->iRow);
            }

        } else if ( cItems > 0) {
            // adjust x's to the first visible
            int dx;
            pitem = Tab_GetItemPtr(ptc, ptc->iFirstVisible);
            if (pitem) {
                dx = -pitem->rc.left + g_cxEdge;
                for ( i = cItems - 1; i >=0  ; i--) {
                    pitem = Tab_FastGetItemPtr(ptc, i);
                    OffsetRect(&pitem->rc, dx, 0);
                }
            }
        }

        if (bReleaseDC)
        {
            ReleaseDC(NULL, hdc);
        }

        UpdateToolTipRects(ptc);
    }
}

void NEAR PASCAL DoCorners(HDC hdc, LPRECT prc, PTC ptc, BOOL fBottom)
{
    RECT rc;
    COLORREF iOldColor;

    iOldColor = SetBkColor(hdc, g_clrBtnFace);

    if (fBottom) {
        // lower right;
        rc = *prc;
        rc.left = rc.right - 2;
        rc.top = rc.bottom - 3;
        
        Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
        rc.bottom--;
        Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDBOTTOMLEFT, ptc);

        
        // lower left

        rc = *prc;
        rc.right = rc.left + 2;
        rc.top = rc.bottom - 3;
        Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
        rc.bottom--;
        Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDTOPLEFT, ptc);
        
    } else {
        // upper right
        rc = *prc;
        rc.left = rc.right - 2;
        rc.bottom = rc.top + 3;
        Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
        rc.top++;
        Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDBOTTOMRIGHT, ptc);


        // upper left

        rc = *prc;
        rc.right = rc.left + 2;
        rc.bottom = rc.top + 3;
        Tab_ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL, ptc);
        rc.top++;
        Tab_DrawEdge(hdc, &rc, EDGE_RAISED, BF_SOFT | BF_DIAGONAL_ENDTOPRIGHT, ptc);
    }
}

void NEAR PASCAL RefreshArrows(PTC ptc, HDC hdc)
{
    RECT rcClip, rcArrows, rcIntersect;

    if (ptc->hwndArrows && IsWindowVisible(ptc->hwndArrows)) {

        GetClipBox(hdc, &rcClip);
        GetWindowRect(ptc->hwndArrows, &rcArrows);
        MapWindowRect(NULL, ptc->ci.hwnd, &rcArrows);
        if (IntersectRect(&rcIntersect, &rcClip, &rcArrows))
            RedrawWindow(ptc->hwndArrows, NULL, NULL, RDW_INVALIDATE);
    }
}

// BUGBUG: the way highlighted tabs (TCIS_HIGHLIGHTED) are drawn right
// now are incredibly ugly. This should be fixed.
//
void NEAR PASCAL DrawBody(HDC hdc, PTC ptc, LPTABITEM pitem, LPRECT lprc, int i,
                          BOOL fTransparent, int dx, int dy)
{
    BOOL fSelected = (i == ptc->iSel);

    if (i == ptc->iHot) {
        if ( !Tab_FlatButtons(ptc) ) {
            SetTextColor(hdc, GetSysColor(COLOR_HOTLIGHT));
        }
    }
    
    if (Tab_OwnerDraw(ptc)) {
        DRAWITEMSTRUCT dis;
        WORD wID = (WORD) GetWindowID(ptc->ci.hwnd);

        dis.CtlType = ODT_TAB;
        dis.CtlID = wID;
        dis.itemID = i;
        dis.itemAction = ODA_DRAWENTIRE;
        if (fSelected)
            dis.itemState = ODS_SELECTED;
        else
            dis.itemState = 0;
        dis.hwndItem = ptc->ci.hwnd;
        dis.hDC = hdc;
        dis.rcItem = *lprc;
        Tab_VDFlipRect(ptc, &dis.rcItem);
        dis.itemData =
            (ptc->cbExtra <= sizeof(LPARAM)) ?
                (DWORD)pitem->DUMMYUNION_MEMBER(lParam) : (ULONG_PTR)(LPBYTE)&pitem->DUMMYUNION_MEMBER(abExtra);

        SendMessage( ptc->ci.hwndParent , WM_DRAWITEM, wID,
                    (LPARAM)(DRAWITEMSTRUCT FAR *)&dis);

    } else {
        // draw the text and image
        // draw even if pszText == NULL to blank it out
        int xLabel;
        int xIcon;
        BOOL fUseDrawText = FALSE;
        if (pitem->pszText) {

            // only use draw text if there's any underlining to do.
            // Draw text does not support vertical drawing, so only do this in horz mode
            if (!Tab_Vertical(ptc) &&
                StrChr(pitem->pszText, CH_PREFIX)) {
                fUseDrawText = TRUE;
            }
        }

        // DrawTextEx will not clear the entire area, so we need to.
        // or if there's no text, we need to blank it out
        if ((fUseDrawText || !pitem->pszText) && !fTransparent)
            Tab_ExtTextOut(hdc, 0, 0,
                       ETO_OPAQUE, lprc, NULL, 0, NULL, ptc);

#if defined(WINDOWS_ME)
#define ETO_ME_CLIPPED (ETO_CLIPPED | pitem->etoRtlReading | (ptc->ci.dwExStyle & WS_EX_RTLREADING ? ETO_RTLREADING : 0 ))
#else 
#define ETO_ME_CLIPPED ETO_CLIPPED
#endif
        xLabel = pitem->rc.left + pitem->xLabel + dx;
        xIcon = pitem->rc.left + pitem->xImage + dx;
        
        if (pitem->pszText) {

            int xVertOffset = 0;

            int oldMode;
            COLORREF oldBkColor;
            COLORREF oldTextColor;

            if (Tab_Vertical(ptc) && !Tab_Bottom(ptc)) {
                
                // add this offset because we need to draw from the bottom up
                xLabel += pitem->cxLabel;
                
                // if we're drawing vertically (on the left)
                // the icon needs to go below (flipped coordinate, on the right)
                if (HASIMAGE(ptc, pitem)) {
                    int cxIcon;
                    int cyIcon;
                    int xLabelNew;
                    
                    Tab_ImageList_GetIconSize(ptc, &cxIcon, &cyIcon);
                    xLabelNew = xIcon + pitem->cxLabel;
                    xIcon = xLabel - cxIcon;
                    xLabel = xLabelNew;
                }                
            }

            if (pitem->dwState & TCIS_HIGHLIGHTED)
            {
                oldMode = SetBkMode (hdc, OPAQUE);
                oldBkColor = SetBkColor (hdc, g_clrHighlight);
                oldTextColor = SetTextColor (hdc, g_clrHighlightText);
            }
            if (fUseDrawText) {
                DRAWTEXTPARAMS dtp;
                int topPrev;
                dtp.cbSize = sizeof(DRAWTEXTPARAMS);
                dtp.iLeftMargin = xLabel - lprc->left;
                dtp.iRightMargin = 0;

                // There is no dtp.iTopMargin so we have to adjust the
                // rectangle instead.  The opaqueing has already been done,
                // so isn't not a problem if we "miss" some pixels since
                // they've already been erased.
                topPrev = lprc->top;
                lprc->top = pitem->rc.top + pitem->yLabel + dy;

#ifdef WINNT
                Tab_DrawTextEx(hdc, pitem->pszText, -1, lprc, DT_SINGLELINE | DT_TOP, &dtp, ptc);
#else   // WINNT
                
#   if defined(WINDOWS_ME)
                Tab_DrawTextEx(hdc, pitem->pszText, -1, lprc,
                         (pitem->etoRtlReading ?DT_RTLREADING :0) |
                         (ptc->ci.dwExStyle & WS_EX_RTLREADING ? DT_RTLREADING : 0 ) |
                         DT_END_ELLIPSIS | DT_SINGLELINE | DT_TOP, &dtp, ptc);
#   else  // WINDOWS_ME
                Tab_DrawTextEx(hdc, pitem->pszText, -1, lprc, DT_END_ELLIPSIS | DT_SINGLELINE | DT_TOP, &dtp, ptc);
#   endif  // WINDOWS_ME
#endif // WINNT

                // Undo our changes to lprc before anybody (else) notices.
                lprc->top = topPrev;
            } else {
                UINT uETOFlags = ETO_ME_CLIPPED;

                if (!fTransparent || (pitem->dwState & TCIS_HIGHLIGHTED))
                    uETOFlags |= ETO_OPAQUE;

                Tab_ExtTextOut(hdc, xLabel, pitem->rc.top + pitem->yLabel + dy,
                    uETOFlags, lprc, pitem->pszText, lstrlen(pitem->pszText),
                    NULL, ptc);
            }

            if (pitem->dwState & TCIS_HIGHLIGHTED) {
                SetBkMode(hdc, oldMode);
                SetBkColor (hdc, oldBkColor);
                SetTextColor (hdc, oldTextColor);
            }

#ifdef WANNA_BLUR_ME
            // blurring
            if (fSelected) {
                if (!fTransparent) {
                    SetBkMode(hdc, TRANSPARENT);

                    // guaranteed to be buttons if we got here
                    // becaues can't iSel==i is rejected for tabs in this loop
                    Tab_ExtTextOut(hdc, xLabel +  1, pitem->rc.top + pitem->yLabel + dy,
                               ETO_ME_CLIPPED, lprc, pitem->pszText, lstrlen(pitem->pszText),
                               NULL, ptc);

                    SetBkMode(hdc, OPAQUE);
                }
            }
#endif

        }

        if (HASIMAGE(ptc, pitem)) {
            UINT uFlags = fTransparent ? ILD_TRANSPARENT : ILD_NORMAL;

            if (pitem->dwState & TCIS_HIGHLIGHTED)
                uFlags |= ILD_BLEND50;

            Tab_ImageList_Draw(ptc, pitem->iImage, hdc, xIcon,
                pitem->rc.top + pitem->yImage + dy, uFlags);
        }

    }
    if (i == ptc->iHot) {
        if ( !Tab_FlatButtons(ptc) ) {
            SetTextColor(hdc, g_clrBtnText);
        }
    }
}

void NEAR PASCAL Tab_DrawItemFrame(PTC ptc, HDC hdc, UINT edgeType, LPTABITEM pitem, int i)
{
    UINT uWhichEdges;
    BOOL fBottom = FALSE;

    if (Tab_DrawButtons(ptc)) {

        if (Tab_FlatButtons(ptc)) {
            if ((edgeType == EDGE_SUNKEN) ||
                (edgeType == BDR_RAISEDINNER)) {
                uWhichEdges = BF_RECT;
            } else {

                if ((ptc->ci.style & TCS_HOTTRACK) &&
                    (i == ptc->iHot))  {
                    edgeType = BDR_RAISEDINNER;
                    uWhichEdges = BF_RECT;
                } else {

                    HPEN hPen, hOldPen;
                    RECT rcEdge;

                    CopyRect (&rcEdge, &pitem->rc);
                    //InflateRect (&rcEdge, -g_cxEdge, -g_cyEdge);

                    hPen = CreatePen (PS_SOLID, 2 * g_cyEdge, GetSysColor(COLOR_3DFACE));
                    hOldPen = SelectObject (hdc, hPen);

                    //
                    // Remove any border in the x direction
                    //

                    MoveToEx (hdc, rcEdge.left, rcEdge.top, NULL);
                    LineTo (hdc, rcEdge.right, rcEdge.top);
                    MoveToEx (hdc, rcEdge.left, rcEdge.bottom, NULL);
                    LineTo (hdc, rcEdge.right, rcEdge.bottom);

                    SelectObject (hdc, hOldPen);
                    DeleteObject (hPen);

                    //
                    // Remove any border in the y direction
                    //

                    hPen = CreatePen (PS_SOLID, 2 * g_cxEdge, GetSysColor(COLOR_3DFACE));
                    hOldPen = SelectObject (hdc, hPen);

                    MoveToEx (hdc, rcEdge.left, rcEdge.top, NULL);
                    LineTo (hdc, rcEdge.left, rcEdge.bottom);
                    MoveToEx (hdc, rcEdge.right, rcEdge.top, NULL);
                    LineTo (hdc, rcEdge.right, rcEdge.bottom);

                    SelectObject (hdc, hOldPen);
                    DeleteObject (hPen);

                    goto DrawCorners;
                }
            }
        } else {
            uWhichEdges = BF_RECT | BF_SOFT;
        }
    } else {
        uWhichEdges = BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT;
        
        if (Tab_ScrollOpposite(ptc)) {
            ASSERT(ptc->iLastTopRow != -1);
            if (Tab_IsItemOnBottom(ptc, pitem)) {
                fBottom = TRUE;
                uWhichEdges = BF_LEFT | BF_BOTTOM | BF_RIGHT | BF_SOFT;
            }
        }
    }
    
    Tab_DrawEdge(hdc, &pitem->rc, edgeType, uWhichEdges, ptc);
    
DrawCorners:

    if (!Tab_DrawButtons(ptc)) {
        DoCorners(hdc, &pitem->rc, ptc, fBottom);
    } else {
        if (Tab_FlatButtons(ptc) && Tab_FlatSeparators(ptc)) {
           RECT rcEdge;

           CopyRect (&rcEdge, &pitem->rc);
           rcEdge.right += (3 * g_cxEdge);
           DrawEdge(hdc, &rcEdge, EDGE_ETCHED, BF_RIGHT);
        }
    }
}

void NEAR Tab_Paint(PTC ptc, HDC hdcIn)
{
    PAINTSTRUCT ps;
    HDC hdc;
    RECT rcClient, rcClipBox, rcTest, rcBody;
    int cItems, i;
    int fnNewMode = OPAQUE;
    LPTABITEM pitem;
    HWND hwnd = ptc->ci.hwnd;
    HBRUSH hbrOld = NULL;

    GetClientRect(hwnd, &rcClient);
    if (!rcClient.right)
        return;

    if (hdcIn)
    {
        hdc = hdcIn;
        ps.rcPaint = rcClient;
    }
    else
        hdc = BeginPaint(hwnd, &ps);
    
    // select font first so metrics will have the right size
    if (!ptc->hfontLabel)
        Tab_OnSetFont(ptc, NULL, FALSE);
    SelectObject(hdc, ptc->hfontLabel);
    CalcPaintMetrics(ptc, hdc);

    // now put it in our native orientation if it was vertical
    Tab_DFlipRect(ptc, &rcClient);
    
    Tab_OnAdjustRect(ptc, FALSE, &rcClient);
    InflateRect(&rcClient, g_cxEdge * 2, g_cyEdge * 2);
    rcClient.top += g_cyEdge;

    if(!Tab_DrawButtons(ptc)) {
        DebugMsg(DM_TRACE, TEXT("Drawing at %d %d %d %d"), rcClient.left, rcClient.top, rcClient.right, rcClient.bottom);
        Tab_DrawEdge(hdc, &rcClient, EDGE_RAISED, BF_SOFT | BF_RECT, ptc);
    }

    cItems = Tab_Count(ptc);
    if (cItems) {

        RefreshArrows(ptc, hdc);
        SetBkColor(hdc, g_clrBtnFace);
        SetTextColor(hdc, g_clrBtnText);

        if (!Tab_MultiLine(ptc))
            IntersectClipRect(hdc, 0, 0,
                              ptc->cxTabs, rcClient.bottom);

        GetClipBox(hdc, &rcClipBox);
        Tab_DVFlipRect(ptc, &rcClipBox);

        // draw all but the selected item
        for (i = ptc->iFirstVisible; i < cItems; i++) {

            pitem = Tab_FastGetItemPtr(ptc, i);

            if (pitem->dwState & TCIS_HIDDEN)
                continue;

            if (!Tab_MultiLine(ptc)) {
                // if not multiline, and we're off the screen... we're done
                if (pitem->rc.left > ptc->cxTabs)
                    break;
            }

            // should we bother drawing this?
            if (i != ptc->iSel || Tab_DrawButtons(ptc)) {
                if (IntersectRect(&rcTest, &rcClipBox, &pitem->rc)) {

                    int dx = 0, dy = 0;  // shift variables if button sunken;
                    UINT edgeType;

                    
                    rcBody = pitem->rc;

                    // Draw the edge around each item
                    if(Tab_DrawButtons(ptc) &&
                       ((ptc->iNewSel == i && Tab_DrawSunken(ptc)) ||
                        (ptc->iSel == i) ||
                        (pitem->dwState & TCIS_BUTTONPRESSED))) {

                        dx = g_cxEdge/2;
                        dy = g_cyEdge/2;
                        if (Tab_FlatButtons(ptc) &&
                            (ptc->iNewSel == i && Tab_DrawSunken(ptc))) {
                            edgeType = BDR_RAISEDINNER;
                        } else {
                            edgeType =  EDGE_SUNKEN;
                        }

                    } else
                        edgeType = EDGE_RAISED;

                    if (Tab_DrawButtons(ptc) && !Tab_OwnerDraw(ptc)) {

                        // if drawing buttons, show selected by dithering  background
                        // which means we need to draw transparent.
                        if (ptc->iSel == i) {
                            fnNewMode = TRANSPARENT;
                            SetBkMode(hdc, TRANSPARENT);
                            hbrOld = SelectObject(hdc, g_hbrMonoDither);
                            SetTextColor(hdc, g_clrBtnHighlight);
                            Tab_PatBlt(hdc, pitem->rc.left, pitem->rc.top, pitem->rc.right - pitem->rc.left,
                                       pitem->rc.bottom - pitem->rc.top, PATCOPY, ptc);
                            SetTextColor(hdc, g_clrBtnText);
                        }
                    }

                    InflateRect(&rcBody, -g_cxEdge, -g_cyEdge);
                    if (!Tab_DrawButtons(ptc)) {
                        
                        // move the bottom (or top) by an edge to draw where the tab doesn't have an edge.
                        // by doing this, we fill the entire area and don't need to do as many inval with erase
                        if (Tab_IsItemOnBottom(ptc, pitem)) {
                            rcBody.top -= g_cyEdge;
                        } else {
                            rcBody.bottom += g_cyEdge;
                        }
                    }
                    DrawBody(hdc, ptc, pitem, &rcBody, i, fnNewMode == TRANSPARENT,
                             dx, dy);


                    Tab_DrawItemFrame(ptc, hdc, edgeType, pitem, i);

                    if (fnNewMode == TRANSPARENT) {
                        fnNewMode = OPAQUE;
                        SelectObject(hdc, hbrOld);
                        SetBkMode(hdc, OPAQUE);
                    }
                }
            }
        }

        if (!Tab_MultiLine(ptc))
            ptc->iLastVisible = i - 1;
        else
            ptc->iLastVisible = cItems - 1;

        // draw the selected one last to make sure it is on top
        pitem = Tab_GetItemPtr(ptc, ptc->iSel);
        if (pitem && (pitem->rc.left <= ptc->cxTabs)) {
            rcBody = pitem->rc;

            if (!Tab_DrawButtons(ptc)) {
                UINT uWhichEdges;
                
                InflateRect(&rcBody, g_cxEdge, g_cyEdge);

                if (IntersectRect(&rcTest, &rcClipBox, &rcBody)) {

                    DrawBody(hdc, ptc, pitem, &rcBody, ptc->iSel, FALSE, 0,-g_cyEdge);

                    rcBody.bottom--;  //because of button softness
                    Tab_DrawEdge(hdc, &rcBody, EDGE_RAISED, 
                                 BF_LEFT | BF_TOP | BF_RIGHT | BF_SOFT,
                                 ptc);
                    DoCorners(hdc, &rcBody, ptc, FALSE);

                    // draw that extra bit on the left or right side
                    // if we're on the edge
                    rcBody.bottom++;
                    rcBody.top = rcBody.bottom-1;
                    if (rcBody.right == rcClient.right) {
                        uWhichEdges = BF_SOFT | BF_RIGHT;

                    } else if (rcBody.left == rcClient.left) {
                        uWhichEdges = BF_SOFT | BF_LEFT;
                    } else
                        uWhichEdges = 0;

                    if (uWhichEdges)
                        Tab_DrawEdge(hdc, &rcBody, EDGE_RAISED, uWhichEdges, ptc);
                }
            }

        }

        // draw the focus rect
        if (GetFocus() == hwnd) {

            if (!pitem && (ptc->iNewSel != -1)) {
                pitem = Tab_GetItemPtr(ptc, ptc->iNewSel);
            }

            if (pitem
#ifdef KEYBOARDCUES
                && !(CCGetUIState(&(ptc->ci))& UISF_HIDEFOCUS)
#endif
                )
            {
                rcBody = pitem->rc;
                if (Tab_DrawButtons(ptc))
                    InflateRect(&rcBody, -g_cxEdge, -g_cyEdge);
                else
                    InflateRect(&rcBody, -(g_cxEdge/2), -(g_cyEdge/2));
                Tab_DrawFocusRect(hdc, &rcBody, ptc);
            }
        }
    }

    if (hdcIn == NULL)
        EndPaint(hwnd, &ps);
}

int PASCAL Tab_FindTab(PTC ptc, int iStart, UINT vk)
{
    int iRow;
    int x;
    int i;
    LPTABITEM pitem = Tab_GetItemPtr(ptc, iStart);

    if (!pitem)
    {
        return(0);
    }

    iRow=  pitem->iRow  + ((vk == VK_UP) ? -1 : 1);
    x = (pitem->rc.right + pitem->rc.left) / 2;

    // find the and item on the iRow at horizontal x
    if (iRow > ptc->iLastRow || iRow < 0)
        return iStart;

    // this relies on the ordering of tabs from left to right , but
    // not necessarily top to bottom.
    for (i = Tab_Count(ptc) - 1 ; i >= 0; i--) {
        pitem = Tab_FastGetItemPtr(ptc, i);
        if (pitem->iRow == iRow) {
            if (pitem->rc.left < x)
                return i;
        }
    }

    // this should never happen.. we should have caught this case in the iRow check
    // right before the for loop.
    ASSERT(0);
    return iStart;
}

void NEAR PASCAL Tab_SetCurFocus(PTC ptc, int iStart)
{

    if (Tab_DrawButtons(ptc)) {
        if ((iStart >= 0) && (iStart < Tab_Count(ptc)) && (ptc->iNewSel != iStart)) {
            if (ptc->iNewSel != -1)
                Tab_InvalidateItem(ptc, ptc->iNewSel, FALSE);
            Tab_InvalidateItem(ptc, iStart, FALSE);
            ptc->iNewSel = iStart;
            ptc->flags |= TCF_DRAWSUNKEN;
            
            if (!Tab_MultiLine(ptc)) {
                // scroll into view if necessary
                RECT rc;
                do {
                    Tab_OnGetItemRect(ptc, iStart, &rc);
                    if (rc.right > ptc->cxTabs) {
                        Tab_OnHScroll(ptc, NULL, SB_THUMBPOSITION, ptc->iFirstVisible + 1);
                    } else if (rc.left < 0) {
                        Tab_OnHScroll(ptc, NULL, SB_THUMBPOSITION, iStart);
                        break;
                    } else {
                        break;
                    }
                } while (1);
            }
            
            CCSendNotify(&ptc->ci, TCN_FOCUSCHANGE, NULL);
            MyNotifyWinEvent(EVENT_OBJECT_FOCUS, ptc->ci.hwnd, OBJID_CLIENT,
                iStart+1);
        }
    } else
    {
        int iOld = ptc->iSel;

        ChangeSel(ptc, iStart, TRUE, FALSE);

        if ((iOld != ptc->iSel) && (GetFocus() == ptc->ci.hwnd))
            MyNotifyWinEvent(EVENT_OBJECT_FOCUS, ptc->ci.hwnd, OBJID_CLIENT,
                ptc->iSel+1);
    }
}

void NEAR PASCAL Tab_OnKeyDown(PTC ptc, UINT vk, BOOL fDown, int cRepeat, UINT flags)
{
    int iStart;
    TC_KEYDOWN nm;

    // Notify
    nm.wVKey = (WORD) vk;
    nm.flags = flags;
    // pass NULL for parent because W95 queryied each time and some
    // folks reparent
    SendNotifyEx(NULL, ptc->ci.hwnd, TCN_KEYDOWN, &nm.hdr, ptc->ci.bUnicode);

    if (Tab_DrawButtons(ptc)) {
        ptc->flags |= (TCF_DRAWSUNKEN|TCF_MOUSEDOWN);
        if (ptc->iNewSel != -1) {
            iStart = ptc->iNewSel;
        } else {
            iStart = ptc->iSel;
        }
    } else {
        iStart = ptc->iSel;
    }

    vk = RTLSwapLeftRightArrows(&ptc->ci, vk);

    if (Tab_Vertical(ptc)) {
        // remap arrow keys if we're in vertial mode
        switch(vk) {
        case VK_LEFT:
            vk = VK_DOWN;
            break;
            
        case VK_RIGHT:
            vk = VK_UP;
            break;
            
        case VK_DOWN:
            vk = VK_RIGHT;
            break;
            
        case VK_UP:
            vk = VK_LEFT;
            break;
        }
    }

    switch (vk) {

    case VK_LEFT:
        iStart--;
        break;

    case VK_RIGHT:
        iStart++;
        break;

    case VK_UP:
    case VK_DOWN:
        if (iStart != -1) {
            iStart = Tab_FindTab(ptc, iStart, vk);
            break;
        } // else fall through to set iStart = 0;

    case VK_HOME:
        iStart = 0;
        break;

    case VK_END:
        iStart = Tab_Count(ptc) - 1;
        break;

    case VK_SPACE:
        if (!Tab_DrawButtons(ptc))
            return;
        // else fall through...  in button mode space does selection

    case VK_RETURN:
        ChangeSel(ptc, iStart, TRUE, FALSE);
        ptc->iNewSel = -1;
        ptc->flags &= ~TCF_DRAWSUNKEN;
#ifdef KEYBOARDCUES
        //notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(ptc->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
#endif
        return;

    default:
        return;
    }

    if (iStart < 0)
        iStart = 0;

    Tab_SetCurFocus(ptc, iStart);
#ifdef KEYBOARDCUES
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptc->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
#endif
}

void NEAR Tab_Size(PTC ptc)
{
    ptc->cxItem = RECOMPUTE;
    Tab_UpdateArrows(ptc, TRUE);
}

BOOL NEAR PASCAL Tab_OnGetItemRect(PTC ptc, int iItem, LPRECT lprc)
{
    LPTABITEM pitem = Tab_GetItemPtr(ptc, iItem);
    BOOL fRet = FALSE;

    if (lprc) {
        CalcPaintMetrics(ptc, NULL);
        if (pitem) {

            // Make sure all the item rects are up-to-date

            *lprc = pitem->rc;
            fRet = TRUE;
        } else {
            lprc->top = 0;
            lprc->bottom = ptc->cyTabs;
            lprc->right = 0;
            lprc->left = 0;
        }

        Tab_VDFlipRect(ptc, lprc);
        
    }
    return fRet;
}

void PASCAL Tab_StyleChanged(PTC ptc, UINT gwl,  LPSTYLESTRUCT pinfo)
{
#define STYLE_MASK   (TCS_BUTTONS | TCS_VERTICAL | TCS_MULTILINE | TCS_RAGGEDRIGHT | TCS_FIXEDWIDTH | TCS_FORCELABELLEFT | TCS_FORCEICONLEFT | TCS_BOTTOM | TCS_RIGHT | TCS_FLATBUTTONS | TCS_OWNERDRAWFIXED | TCS_HOTTRACK)
    if (ptc && (gwl == GWL_STYLE)) {

        DWORD dwChanged = (ptc->ci.style & STYLE_MASK) ^ (pinfo->styleNew & STYLE_MASK);
        // special case.  this is "Insider Trading" app (by papyrus, now kanisa).  they set the 3 on the low byte in ie3 comctl32 when it
        // had no meaning anyways. so we bail on that.
        if (ptc->ci.style == 0x50004000 && pinfo->styleNew == 0x54004003)
            return;
        if (dwChanged) {
            ptc->ci.style = (ptc->ci.style & ~STYLE_MASK)  | (pinfo->styleNew & STYLE_MASK);

            // make sure we don't have invalid bits set
            if (!Tab_FixedWidth(ptc)) {
                ptc->ci.style &= ~(TCS_FORCEICONLEFT | TCS_FORCELABELLEFT);
            }
            ptc->cxItem = RECOMPUTE;
            ptc->cyTabs = RECOMPUTE;
            
            //if the left/right orientation changed
            // we need to re-create the font (if we own it)
            // becaus the text orientation needs to flip by 180
            if ((dwChanged & TCS_VERTICAL) ||
                ((dwChanged & TCS_RIGHT) && Tab_Vertical(ptc))) {
                if (!(ptc->flags & TCF_FONTSET))
                    Tab_OnSetFont(ptc, NULL, FALSE);
            }
                
            if (Tab_RedrawEnabled(ptc))
                Tab_UpdateArrows(ptc, TRUE);
            RedrawAll(ptc, RDW_ERASE | RDW_INVALIDATE);
        }

#define FOCUS_MASK (TCS_FOCUSONBUTTONDOWN | TCS_FOCUSNEVER)
        if ( (ptc->ci.style &  FOCUS_MASK) ^ (pinfo->styleNew & FOCUS_MASK)) {
            ptc->ci.style = (ptc->ci.style & ~FOCUS_MASK)  | (pinfo->styleNew & FOCUS_MASK);
        }
    }
 #ifdef WINDOWS_ME
    if (gwl == GWL_EXSTYLE) {
        ptc->ci.dwExStyle &= ~WS_EX_RTLREADING;
        ptc->ci.dwExStyle |= (pinfo->styleNew & WS_EX_RTLREADING);       
       }
#endif //WINDOWS_ME
}


DWORD Tab_ExtendedStyleChange(PTC ptc, DWORD dwNewStyle, DWORD dwExMask)
{
    DWORD dwOldStyle = ptc->dwStyleEx;

    if (ptc->hDragProxy) {
        DestroyDragProxy(ptc->hDragProxy);
        ptc->hDragProxy = NULL;
    }

    if (dwExMask) 
        dwNewStyle = (ptc->dwStyleEx & ~ dwExMask) | (dwNewStyle & dwExMask);
    
    ptc->dwStyleEx = dwNewStyle;

    // do any invalidation or whatever is needed here.
    if ((dwOldStyle ^ dwNewStyle) & TCS_EX_FLATSEPARATORS) {
        InvalidateRect (ptc->ci.hwnd, NULL, TRUE);
    }

    if (ptc->dwStyleEx & TCS_EX_REGISTERDROP)
        ptc->hDragProxy = CreateDragProxy(ptc->ci.hwnd, TabDragCallback, TRUE);

    return dwOldStyle;
}


//
// APPCOMPAT Assumes that the tab control is on top.  Returns bogus values for
// left, bottom or right.  For app compat reasons, we can't change this
// buggy behavior. (Apps might be relying on the wrong values and fixing them
// up, so if we fix the function, they end up trying to "fix" something that
// wasn't broken, thereby breaking it.)  But we might want to add
// TCM_ADJUSTRECT2 that can handle the left/right/bottom cases.
//
void NEAR PASCAL Tab_OnAdjustRect(PTC ptc, BOOL fGrow, LPRECT prc)
{
    int idy;
    CalcPaintMetrics(ptc, NULL);

    if (Tab_DrawButtons(ptc)) {
        if (Tab_Count(ptc)) {
            RECT rc;
            Tab_OnGetItemRect(ptc, Tab_Count(ptc) - 1, &rc);
            idy = rc.bottom;
        } else {
            idy = 0;
        }
    } else {
        idy = (ptc->cyTabs * (ptc->iLastRow + 1));
    }
    
    if (fGrow) {
        // calc a larger rect from the smaller
        prc->top -= idy;
        InflateRect(prc, g_cxEdge * 2, g_cyEdge * 2);
    } else {
        prc->top += idy;
        // given the bounds, calc the "client" area
        InflateRect(prc, -g_cxEdge * 2, -g_cyEdge * 2);
    }

    if (Tab_ScrollOpposite(ptc)) {
        // the sizes are the same, it's just offset wrong vertically
        idy = ptc->cyTabs * (ptc->iLastRow - ptc->iLastTopRow);
        ASSERT(ptc->iLastTopRow != -1);

        if (!fGrow) {
            idy *= -1;
        }
        DebugMsg(DM_TRACE, TEXT("Tab_AdjustRect %d %d %d %d"), prc->left, prc->top, prc->right, prc->bottom);
        OffsetRect(prc, 0, idy);
        DebugMsg(DM_TRACE, TEXT("Tab_AdjustRect %d %d %d %d"), prc->left, prc->top, prc->right, prc->bottom);
    }
}

LRESULT CALLBACK Tab_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PTC ptc = (PTC)GetWindowInt((hwnd), 0);

    if (ptc) {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            Tab_HotTrack(ptc) && !ptc->fTrackSet) {

            TRACKMOUSEEVENT tme;

            ptc->fTrackSet = TRUE;
            tme.cbSize = sizeof(tme);
            tme.hwndTrack = ptc->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
    } else if (uMsg != WM_CREATE)
        goto DoDefault;
    
    switch (uMsg) {

    HANDLE_MSG(ptc, WM_HSCROLL, Tab_OnHScroll);
    
    case WM_MOUSELEAVE:
        Tab_InvalidateItem(ptc, ptc->iHot, FALSE);
        ptc->iHot = -1;
        ptc->fTrackSet = FALSE;
        break;

    case WM_CREATE:
        CCCreateWindow();
        InitGlobalColors();
        ptc = (PTC)NearAlloc(sizeof(TC));
        if (!ptc)
            return -1;  // fail the window create

        SetWindowPtr(hwnd, 0, ptc);
        CIInitialize(&ptc->ci, hwnd, (LPCREATESTRUCT)lParam);

        if (!Tab_OnCreate(ptc))
            return -1;

        break;

    case WM_DESTROY:
        CCDestroyWindow();
        Tab_OnDestroy(ptc);
        break;

    case WM_SIZE:
        Tab_Size(ptc);
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (!(ptc->flags & TCF_FONTSET))
            Tab_OnSetFont(ptc, NULL, FALSE);
        RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if ((wParam == SPI_SETNONCLIENTMETRICS) ||
            (!wParam && !lParam))
            RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        Tab_Paint(ptc, (HDC)wParam);
        break;

    case WM_STYLECHANGED:
        Tab_StyleChanged(ptc, (UINT) wParam, (LPSTYLESTRUCT)lParam);
        break;

    case WM_MOUSEMOVE:
        RelayToToolTips(ptc->hwndToolTips, hwnd, uMsg, wParam, lParam);
        Tab_OnMouseMove(ptc, wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        break;

    case WM_LBUTTONDOWN:
        RelayToToolTips(ptc->hwndToolTips, hwnd, uMsg, wParam, lParam);
        Tab_OnLButtonDown(ptc, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), wParam);
        break;
        
    case WM_LBUTTONDBLCLK:
        if (Tab_DrawButtons(ptc)) {
            MSG msg;
            // on the double click, grab capture until we get the lbutton up and
            // eat it.
            SetCapture(ptc->ci.hwnd);
            while (GetCapture() == ptc->ci.hwnd && 
                   !PeekMessage(&msg, ptc->ci.hwnd, WM_LBUTTONUP, WM_LBUTTONUP, PM_REMOVE)) 
            {
            }
            CCReleaseCapture(&ptc->ci);
        }
        break;

    case WM_MBUTTONDOWN:
        SetFocus(hwnd);
        break;

    case WM_RBUTTONDOWN:
        Tab_OnRButtonDown(ptc, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), wParam);
        break;
        
    case WM_RBUTTONUP:
        // pass NULL for parent because W95 queryied each time and some
        // folks reparent
        if (!SendNotifyEx(NULL, ptc->ci.hwnd, NM_RCLICK, NULL, ptc->ci.bUnicode))
            goto DoDefault;
        break;

    case WM_CAPTURECHANGED:
        lParam = -1L; // fall through to LBUTTONUP

    case WM_LBUTTONUP:
        if (uMsg == WM_LBUTTONUP) {
            RelayToToolTips(ptc->hwndToolTips, hwnd, uMsg, wParam, lParam);
        }

        Tab_OnButtonUp(ptc, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), (uMsg == WM_LBUTTONUP));
        break;

#ifdef KEYBOARDCUES
    case WM_SYSKEYDOWN:
        //notify of navigation key usage
        if (HIWORD(lParam) & KF_ALTDOWN)
            CCNotifyNavigationKeyUsage(&(ptc->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
        goto DoDefault;
#endif

    case WM_KEYDOWN:
        HANDLE_WM_KEYDOWN(ptc, wParam, lParam, Tab_OnKeyDown);
        break;

    case WM_KILLFOCUS:

        if (ptc->iNewSel != -1) {
            int iOldSel = ptc->iNewSel;
            ptc->iNewSel = -1;
            Tab_InvalidateItem(ptc, iOldSel, FALSE);
            ptc->flags &= ~TCF_DRAWSUNKEN;
        }
        // fall through
    case WM_SETFOCUS:
        Tab_InvalidateItem(ptc, ptc->iSel, Tab_OwnerDraw(ptc));
        if ((uMsg == WM_SETFOCUS) && (ptc->iSel != -1))
            MyNotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, ptc->iSel+1);
        break;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS | DLGC_WANTCHARS;

    HANDLE_MSG(ptc, WM_SETREDRAW, Tab_OnSetRedraw);
    HANDLE_MSG(ptc, WM_SETFONT, Tab_OnSetFont);

    case WM_GETFONT:
        return (LRESULT)ptc->hfontLabel;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ptc->ci, lParam);

    case WM_NOTIFY: {
        LPNMHDR lpNmhdr = (LPNMHDR)(lParam);

        //
        // We are just going to pass this on to the
        // real parent.  Note that -1 is used as
        // the hwndFrom.  This prevents SendNotifyEx
        // from updating the NMHDR structure.
        //

        SendNotifyEx(GetParent(ptc->ci.hwnd), (HWND) -1,
                     lpNmhdr->code, lpNmhdr, ptc->ci.bUnicode);
        }
        break;

#ifdef KEYBOARDCUES
    case WM_UPDATEUISTATE:
        if (CCOnUIState(&(ptc->ci), WM_UPDATEUISTATE, wParam, lParam))
        {
            if (UISF_HIDEFOCUS == HIWORD(wParam))
            {
                // We erase only if we are removing the focus rect or the accel
                Tab_InvalidateItem(ptc, ptc->iSel,
                    (UIS_CLEAR == LOWORD(wParam)) ? TRUE : FALSE);
            }
            else
            {
                if ((UISF_HIDEFOCUS | UISF_HIDEACCEL) & HIWORD(wParam))
                {
                    int i;

                    for (i = ptc->iFirstVisible; i <= ptc->iLastVisible; ++i)
                    {
                        Tab_InvalidateItem(ptc, i,
                            (UIS_CLEAR == LOWORD(wParam)) ? TRUE : FALSE);
                    }
                }
            }
        }

        goto DoDefault;
#endif
    case TCM_SETITEMEXTRA:
        return (LRESULT)Tab_OnSetItemExtra(ptc, (int)wParam);

    case TCM_GETITEMCOUNT:
        return (LRESULT)Tab_Count(ptc);

#ifdef UNICODE
    case TCM_SETITEMA:
        {
        LRESULT lResult;
        TC_ITEMW * pItemW;

        if (!lParam) {
            return FALSE;
        }

        pItemW = ThunkItemAtoW(ptc, (TC_ITEMA FAR*)lParam);

        if (!pItemW) {
            return FALSE;
        }

        lResult = (LRESULT)Tab_OnSetItem(ptc, (int)wParam, pItemW);

        FreeItemW(pItemW);

        return lResult;
        }
#endif

    case TCM_SETITEM:
        if (!lParam) {
            return FALSE;
        }

        return (LRESULT)Tab_OnSetItem(ptc, (int)wParam, (const TC_ITEM FAR*)lParam);

#ifdef UNICODE
    case TCM_GETITEMA:
        {
        LRESULT lResult;
        TC_ITEMW * pItemW;
        LPWSTR pszTextW = NULL;
        TC_ITEMA * pItemA = (TC_ITEMA FAR*)lParam;

        if (!ptc || !pItemA) {
            return FALSE;
        }

        pItemW = GlobalAlloc (GPTR, sizeof(TC_ITEMW) + ptc->cbExtra);

        if (!pItemW) {
            return FALSE;
        }

        if (pItemA->mask & TCIF_TEXT) {
            pszTextW = GlobalAlloc (GPTR, pItemA->cchTextMax * sizeof (TCHAR));

            if (!pszTextW) {
                GlobalFree (pItemW);
                return FALSE;
            }
            pItemW->pszText = pszTextW;
        }

        pItemW->mask       = pItemA->mask;
        pItemW->cchTextMax = pItemA->cchTextMax;
        pItemW->dwStateMask = pItemA->dwStateMask;

        lResult = (LRESULT)Tab_OnGetItem(ptc, (int)wParam, pItemW);

        if (!ThunkItemWtoA (ptc, pItemW, pItemA)) {
            lResult = (LRESULT)FALSE;
        }

        if (pszTextW) {
            GlobalFree (pszTextW);
        }
        GlobalFree (pItemW);

        return lResult;
        }
#endif

    case TCM_GETITEM:
        if (!ptc || !lParam) {
            return FALSE;
        }

        return (LRESULT)Tab_OnGetItem(ptc, (int)wParam, (TC_ITEM FAR*)lParam);

#ifdef UNICODE
    case TCM_INSERTITEMA:
        {
        LRESULT  lResult;
        TC_ITEMW * pItemW;

        if (!lParam) {
            return FALSE;
        }

        pItemW = ThunkItemAtoW(ptc, (TC_ITEMA FAR*)lParam);

        if (!pItemW) {
            return FALSE;
        }

        lResult =  (LRESULT)Tab_OnInsertItem(ptc, (int)wParam, pItemW);

        FreeItemW(pItemW);

        return lResult;
        }
#endif

    case TCM_INSERTITEM:
        if (!lParam) {
            return FALSE;
        }
        return (LRESULT)Tab_OnInsertItem(ptc, (int)wParam, (const TC_ITEM FAR*)lParam);

    case TCM_DELETEITEM:
        return (LRESULT)Tab_OnDeleteItem(ptc, (int)wParam);

    case TCM_DELETEALLITEMS:
        return (LRESULT)Tab_OnDeleteAllItems(ptc);

    case TCM_SETCURFOCUS:
        Tab_SetCurFocus(ptc, (int) wParam);
        break;

    case TCM_GETCURFOCUS:
        if (ptc->iNewSel != -1)
            return ptc->iNewSel;
        // else fall through

    case TCM_GETCURSEL:
        return ptc->iSel;

    case TCM_SETCURSEL:
        return (LRESULT)ChangeSel(ptc, (int)wParam, FALSE, FALSE);

    case TCM_GETTOOLTIPS:
        return (LRESULT)ptc->hwndToolTips;

    case TCM_SETTOOLTIPS:
        ptc->hwndToolTips = (HWND)wParam;
        break;

    case TCM_ADJUSTRECT:
        if (lParam) {
#define prc ((RECT FAR *)lParam)
            Tab_DVFlipRect(ptc, prc);
            Tab_OnAdjustRect(ptc, BOOLFROMPTR( wParam), (LPRECT)lParam);
            Tab_VDFlipRect(ptc, prc);
#undef prc
        } else
            return -1;
        break;
        
    case TCM_GETITEMRECT:
        return Tab_OnGetItemRect(ptc, (int)wParam, (LPRECT)lParam);

    case TCM_SETIMAGELIST: {
        HIMAGELIST himlOld = ptc->himl;
        ptc->himl = (HIMAGELIST)lParam;
        ptc->cxItem = ptc->cyTabs = RECOMPUTE;
        RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE);
        return (LRESULT)himlOld;
    }

    case TCM_GETIMAGELIST:
        return (LRESULT)ptc->himl;

    case TCM_REMOVEIMAGE:
        Tab_OnRemoveImage(ptc, (int)wParam);
        break;

    case TCM_SETITEMSIZE: {
        int iOldWidth = ptc->iTabWidth;
        int iOldHeight = ptc->iTabHeight;
        int iNewWidth = LOWORD(lParam);
        int iNewHeight = HIWORD(lParam);

        if (ptc->himl) {
            int cx, cy;
            Tab_ImageList_GetIconSize(ptc, &cx, &cy);
            if (iNewWidth < (cx + (2*g_cxEdge)))
                iNewWidth = cx + (2*g_cxEdge);

        }
        ptc->iTabWidth = iNewWidth;
        ptc->iTabHeight = iNewHeight;

        if (iNewWidth != iOldWidth ||
            iNewHeight != iOldHeight) {
            ptc->cxItem = RECOMPUTE;
            ptc->cyTabs = RECOMPUTE;
            RedrawAll(ptc, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);
        }

        return (LRESULT)MAKELONG(iOldWidth, iOldHeight);
    }

    case TCM_SETPADDING:
        ptc->cxPad = GET_X_LPARAM(lParam);
        ptc->cyPad = GET_Y_LPARAM(lParam);
        break;

    case TCM_GETROWCOUNT:
        CalcPaintMetrics(ptc, NULL);
        return (LRESULT)ptc->iLastRow + 1;
        
    case TCM_SETMINTABWIDTH:
    {
        int iOld = ptc->cxMinTab;
        if ((int)lParam >= 0) {
            ptc->cxMinTab = (int)lParam;
            ptc->fMinTabSet = TRUE;
        } else {
            ptc->fMinTabSet = FALSE;
        }
        ptc->cyTabs = RECOMPUTE;
        ptc->cxItem = RECOMPUTE;
        InvalidateRect(ptc->ci.hwnd, NULL, TRUE);
        return iOld;
    }
        
    case TCM_DESELECTALL:
        Tab_DeselectAll(ptc, BOOLFROMPTR( wParam));
        break;

    case TCM_SETEXTENDEDSTYLE:
        return Tab_ExtendedStyleChange(ptc, (DWORD) lParam, (DWORD) wParam);

    case TCM_GETEXTENDEDSTYLE:
        return ptc->dwStyleEx;

    case TCM_HITTEST: {
#define lphitinfo  ((LPTC_HITTESTINFO)lParam)
        return Tab_OnHitTest(ptc, lphitinfo->pt.x, lphitinfo->pt.y, &lphitinfo->flags);
    }

    case TCM_HIGHLIGHTITEM:
    {
        LPTABITEM pitem = Tab_GetItemPtr(ptc, (int)wParam);

        if (pitem)
        {
            BOOL fHighlight = LOWORD(lParam) != 0;

            // Don't do anything if state hasn't changed.
            if (fHighlight == ((pitem->dwState & TCIS_HIGHLIGHTED) != 0))
                break;

            if (fHighlight)
                pitem->dwState |= TCIS_HIGHLIGHTED;
            else
                pitem->dwState &= ~TCIS_HIGHLIGHTED;

            Tab_InvalidateItem(ptc, (int)wParam, TRUE);
            return TRUE;
        }
        break;
    }

    case WM_NCHITTEST:
    {
        POINT pt;
            
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(ptc->ci.hwnd, &pt);
        if (Tab_OnHitTest(ptc, pt.x, pt.y, NULL) == -1)
            return(HTTRANSPARENT);
        else {
            goto DoDefault;
        }
    }

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_TAB;
        break;

    default:
    {
        LRESULT lres;
        if (CCWndProc(&ptc->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
    
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

#ifdef UNICODE

//
// ANSI <=> UNICODE thunks
//

TC_ITEMW * ThunkItemAtoW (PTC ptc, TC_ITEMA * pItemA)
{
    TC_ITEMW *pItemW;
    UINT      cbTextW;
    INT       iResult;

    pItemW = (TC_ITEMW *) GlobalAlloc (GPTR, sizeof(TC_ITEMW) + ptc->cbExtra);

    if (!pItemW) {
        return NULL;
    }

    pItemW->mask        = pItemA->mask;
    pItemW->dwState = pItemA->dwState;
    pItemW->dwStateMask = pItemA->dwStateMask;

    if ((pItemA->mask & TCIF_TEXT) && pItemA->pszText) {
        cbTextW = lstrlenA(pItemA->pszText) + 1;

        pItemW->pszText = (LPWSTR)GlobalAlloc (GPTR, cbTextW * sizeof(TCHAR));

        if (!pItemW->pszText) {
            GlobalFree (pItemW);
            return NULL;
        }

        iResult = MultiByteToWideChar (CP_ACP, 0, pItemA->pszText, -1,
                                       pItemW->pszText, cbTextW);

        if (!iResult) {
            if (GetLastError()) {
                GlobalFree (pItemW->pszText);
                GlobalFree (pItemW);
                return NULL;
            }
        }
    }

    pItemW->cchTextMax = pItemA->cchTextMax;

    if (pItemA->mask & TCIF_IMAGE) {
        pItemW->iImage = pItemA->iImage;
    }

    if (pItemA->mask & TCIF_PARAM) {
        hmemcpy(&pItemW->lParam, &pItemA->lParam, ptc->cbExtra);
    }

    return (pItemW);
}

BOOL ThunkItemWtoA (PTC ptc, TC_ITEMW * pItemW, TC_ITEMA * pItemA)
{
    INT        iResult;


    if (!pItemA) {
        return FALSE;
    }

    pItemA->mask        = pItemW->mask;
    pItemA->dwState = pItemW->dwState;
    pItemA->dwStateMask = pItemW->dwStateMask;

    if ((pItemW->mask & TCIF_TEXT) && pItemW->pszText && pItemW->cchTextMax) {

        iResult = WideCharToMultiByte (CP_ACP, 0, pItemW->pszText, -1,
                                       pItemA->pszText, pItemW->cchTextMax, NULL, NULL);

        if (!iResult) {
            if (GetLastError()) {
                return FALSE;
            }
        }
    }

    pItemA->cchTextMax = pItemW->cchTextMax;

    if (pItemW->mask & TCIF_IMAGE) {
        pItemA->iImage = pItemW->iImage;
    }

    if (pItemW->mask & TCIF_PARAM) {
        hmemcpy(&pItemA->lParam, &pItemW->lParam, ptc->cbExtra);
    }

    return TRUE;
}

BOOL FreeItemW (TC_ITEMW *pItemW)
{

    if ((pItemW->mask & TCIF_TEXT) && pItemW->pszText) {
        GlobalFree (pItemW->pszText);
    }

    GlobalFree (pItemW);

    return TRUE;
}

BOOL FreeItemA (TC_ITEMA *pItemA)
{

    if ((pItemA->mask & TCIF_TEXT) && pItemA->pszText) {
        GlobalFree (pItemA->pszText);
    }

    GlobalFree (pItemA);

    return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\toolbar.h ===
// common stuff for the toolbar control

#ifndef _TOOLBAR_H
#define _TOOLBAR_H

#define TBHIGHLIGHT_BACK
#define TBHIGHLIGHT_GLYPH

typedef struct {        /* info for recreating the bitmaps */
    int nButtons;
    HINSTANCE hInst;
    UINT_PTR wID;
} TBBMINFO, NEAR *PTBBMINFO;

typedef struct _TBBUTTONDATA {
    union
    {
        // Someone wanted to conserve space.  This is a union to make 
        // the code easier to read.
        int iBitmap;
        int cxySep;         // Used by separators
    }DUMMYUNIONNAME;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
    WORD cx;                // BUGBUG raymondc: Can we change this INT?
    DWORD_PTR dwData;
    INT_PTR iString;
    POINT pt;               // top left corner of this button
} TBBUTTONDATA, * LPTBBUTTONDATA;

#define HIML_NORMAL 0
#define HIML_HOT    1   // Image list for the hot-tracked image
#define HIML_DISABLED 2 // Image list for the hot-tracked image
#define HIML_MAX        2

typedef struct {
    HIMAGELIST himl[3];
} TBIMAGELISTS, *LPTBIMAGELISTS;

typedef struct {            /* instance data for toolbar window */
    CONTROLINFO ci;
    DWORD dwStyleEx;
    HDC hdcMono;
    HBITMAP hbmMono;
    LPTBBUTTONDATA Buttons;     // Array of actual buttons
    LPTBBUTTONDATA pCaptureButton;
    POINT   ptCapture;
    HWND hwndToolTips;
    LPTSTR      pszTip;         // store current tooltip string.
    HWND hdlgCust;
    HFONT hfontIcon;
    int nBitmaps;
#ifdef GLYPHCACHE
    int nSelectedBM;            // currently selected pBitmaps index
#endif
    PTBBMINFO pBitmaps;
#ifdef FACECACHE
    HBITMAP hbmCache;
#endif
    PTSTR *pStrings;
    int nStrings;
    int nTextRows;              // # Rows of text per button
    UINT uStructSize;
    int iDxBitmap;
    int iDyBitmap;
    int iButWidth;
    int iButHeight;
    int iButMinWidth;           // The min and max width of the button. If the app does not
    int iButMaxWidth;           // have an opinion on what the min and max should be, these will be 0
    int iYPos;
    int iNumButtons;
    int dyIconFont;
    int dxDDArrowChar;
    int xFirstButton;
    int xPad;
    int yPad;
    int iListGap;               // space between icon and text on list-style buttons
    int iDropDownGap;           // padding after text on list-style drop-down buttons
    SIZE szCached;
    
#ifndef UNICODE
    BYTE bLeadByte;             // Save DBCS Lead Byte
#endif

    HDRAGPROXY hDragProxy;
    
    UINT uDrawText;
    UINT uDrawTextMask;

    COLORSCHEME clrsc;

    TBIMAGELISTS* pimgs;
    int cPimgs;
    
    int iHot;                   // Index of the currently Hot Tracked Button
    int iPressedDD;             // Index of the currently pressed dropdown button
    int iInsert;                // Index of the insertion mark, or -1 if none
    COLORREF    clrim;          // current insert mark color
    RECT rcInvalid;             // Saved invalid rectangle

    BITBOOL fHimlValid : 1;
    BITBOOL fHimlNative : 1;
    BITBOOL fFontCreated: 1;
    BITBOOL fNoStringPool :1;
    BITBOOL fTTNeedsFlush :1;

    BITBOOL fMouseTrack: 1;     // Are we currently tracking Mouse over this toolbar ?
    BITBOOL fActive: 1;
    BITBOOL fAnchorHighlight: 1;// TRUE: anchor the highlight to current position 
                                //       when mouse goes out of toolbar
    BITBOOL fRightDrag: 1;      // TRUE if current drag is right drag
    BITBOOL fDragOutNotify: 1;  // FALSE from start of drag until mouse leaves button
                                //       at which point it is TRUE until next drag
    BITBOOL fInsertAfter: 1;    // insert after (TRUE) or before (FALSE) button at iInsert?

    BITBOOL fRedrawOff : 1;     // did we get a WM_SETREDRAW = FALSE
    BITBOOL fInvalidate : 1;    // did we get any paint messages whilst we were fRedrawOff
    BITBOOL fRecalc : 1;        // did we try to call TBRecalc while we were fRedrawOff?
    
    BITBOOL fRequeryCapture :1; // app hack see comment on lbutton up
    BITBOOL fShowPrefix: 1;     // Show the underline of an item. Set with WM_KEYBOARDCUES

    BITBOOL fItemRectsValid:1;  // Are the cached button item rects valid?
    BITBOOL fAntiAlias: 1;    // Turn off AntiAliasing durning the create of a drag image.
    
    RECT rc;                    // cache rc of toolbar. (used only for TBSTYLE_EX_MULTICOL and TBSTYLE_EX_HIDECLIPPEDBUTTONS)
    SIZE sizeBound;             // largest bounding size in vertical multicolumn mode.
    
} TBSTATE, NEAR *PTBSTATE;

typedef struct {
/*REVIEW: index, command, flag words, resource ids should be UINT */
    int iBitmap;    /* index into bitmap of this button's picture */
    int idCommand;  /* WM_COMMAND menu ID that this button sends */
    BYTE fsState;   /* button's state */
    BYTE fsStyle;   /* button's style */
    int idsHelp;    /* string ID for button's status bar help */
} OLDTBBUTTON, FAR* LPOLDTBBUTTON;


typedef struct _TBDRAWITEM
{
    TBSTATE * ptb;
    LPTBBUTTONDATA pbutton;

    UINT state;
    BOOL fHotTrack;

    // himl and image index
    int iIndex;
    int iImage;

    DWORD dwCustom;
    NMTBCUSTOMDRAW tbcd;
} TBDRAWITEM, * PTBDRAWITEM;


#ifdef __cplusplus
extern "C" {
#endif
    
HIMAGELIST TBGetImageList(PTBSTATE ptb, int iMode, int iIndex);
HIMAGELIST TBSetImageList(PTBSTATE ptb, int iMode, int iIndex, HIMAGELIST himl);
#define GET_HIML_INDEX GET_Y_LPARAM
#define GET_IMAGE_INDEX GET_X_LPARAM

HBITMAP FAR PASCAL SelectBM(HDC hDC, PTBSTATE pTBState, int nButton);
void FAR PASCAL DrawButton(HDC hdc, int x, int y, PTBSTATE pTBState, LPTBBUTTONDATA ptButton, BOOL fActive);
void DrawFace(HDC hdc, int x, int y, int offx, int offy, int dxText, 
              int dyText, TBDRAWITEM * ptbdraw);
int  FAR PASCAL TBHitTest(PTBSTATE pTBState, int xPos, int yPos);
int  FAR PASCAL PositionFromID(PTBSTATE pTBState, LONG_PTR id);
void FAR PASCAL BuildButtonTemplates(void);
void FAR PASCAL TBInputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt);
void NEAR PASCAL TBOutputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt);

BOOL FAR PASCAL SaveRestore(PTBSTATE pTBState, BOOL bWrite, LPTSTR FAR *lpNames);
BOOL FAR PASCAL SaveRestoreFromReg(PTBSTATE ptb, BOOL bWrite, HKEY hkr, LPCTSTR pszSubKey, LPCTSTR pszValueName);

void FAR PASCAL CustomizeTB(PTBSTATE pTBState, int iPos);
void FAR PASCAL MoveButton(PTBSTATE pTBState, int nSource);
BOOL FAR PASCAL DeleteButton(PTBSTATE ptb, UINT uIndex);
BOOL FAR PASCAL TBReallocButtons(PTBSTATE ptb, UINT uButtons);
BOOL FAR PASCAL TBInsertButtons(PTBSTATE ptb, UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons, BOOL fNative);

LRESULT FAR PASCAL SendItemNotify(PTBSTATE ptb, int iItem, int code);
void TBInvalidateItemRects(PTBSTATE ptb);
void PASCAL ReleaseMonoDC(PTBSTATE ptb);
void InitTBDrawItem(TBDRAWITEM * ptbdraw, PTBSTATE ptb, LPTBBUTTONDATA pbutton, 
                    UINT state, BOOL fHotTrack, int dxText, int dyText);
BOOL TBGetInfoTip(PTBSTATE ptb, LPTOOLTIPTEXT lpttt, LPTBBUTTONDATA pTBButton);
extern const int g_dxButtonSep;

BOOL TB_GetItemRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect);

#ifdef __cplusplus
}
#endif

#endif // _TOOLBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\trackbar.c ===
//----------------------------------------------------------
//
// BUGBUG: make sure this stuff really works with the DWORD
//         ranges
//
//----------------------------------------------------------

#include "ctlspriv.h"
#include "limits.h"
#include "image.h"          // for CreateColorBitmap

#if defined(MAINWIN)
#include <mainwin.h>
#endif

//#define TB_DEBUG
//#define FEATURE_DEBUG     // Ctrl+Shift force-enables rare features for debugging

typedef struct {

    // standard header information for each control
    CONTROLINFO ci;

    HDC     hdc;            // current DC
    HBITMAP hbmBuffer;      // double buffer

    LONG    lLogMin;        // Logical minimum
    LONG    lLogMax;        // Logical maximum
    LONG    lLogPos;        // Logical position

    LONG    lSelStart;      // Logical selection start
    LONG    lSelEnd;        // Logical selection end

    int     iThumbWidth;    // Width of the thumb
    int     iThumbHeight;   // Height of the thumb

    int     iSizePhys;      // Size of where thumb lives
    RECT    rc;             // track bar rect.

    RECT    rcThumb;          // Rectangle we current thumb
    DWORD   dwDragPos;      // Logical position of mouse while dragging.
    int     dwDragOffset;   // how many pixels off the center did they click

    int     nTics;          // number of ticks.
    PDWORD  pTics;          // the tick marks.

    int     ticFreq;        // the frequency of ticks

    LONG     lPageSize;      // how much to thumb up and down.
    LONG     lLineSize;      // how muhc to scroll up and down on line up/down

    HWND     hwndToolTips;

    // these should probably be word or bytes
    UINT     wDirtyFlags;
    UINT     uTipSide;   // which side should the tip be on?
    UINT     Flags;          // Flags for our window
    UINT     Cmd;            // The command we're repeating.


#if defined(FE_IME) || !defined(WINNT)
    HIMC    hPrevImc;       // previous input context handle
#endif


    HWND        hwndBuddyLeft;
    HWND        hwndBuddyRight;

} TRACKBAR, *PTRACKBAR;

// Trackbar flags

#define TBF_NOTHUMB     0x0001  // No thumb because not wide enough.
#define TBF_SELECTION   0x0002  // a selection has been established (draw the range)

#define MIN_THUMB_HEIGHT (2 * g_cxEdge)

/*
        useful constants.
*/

#define REPEATTIME      500     // mouse auto repeat 1/2 of a second
#define TIMER_ID        1

/*
        Function Prototypes
*/

void   NEAR PASCAL DoTrack(PTRACKBAR, int, DWORD);
WORD   NEAR PASCAL WTrackType(PTRACKBAR, LONG);
void   NEAR PASCAL TBTrackInit(PTRACKBAR, LPARAM);
void   NEAR PASCAL TBTrackEnd(PTRACKBAR);
void   NEAR PASCAL TBTrack(PTRACKBAR, LPARAM);
void   NEAR PASCAL DrawThumb(PTRACKBAR, LPRECT, BOOL);

HBRUSH NEAR PASCAL SelectColorObjects(PTRACKBAR, BOOL);
void   NEAR PASCAL SetTBCaretPos(PTRACKBAR);

#define TICKHEIGHT 3
#define BORDERSIZE 2

#define ISVERT(tb) (tb->ci.style & TBS_VERT)

#define TBC_TICS        0x1
#define TBC_THUMB       0x2
#define TBC_ALL         0xF


// this is called internally when the trackbar has
// changed and we need to update the double buffer bitmap
// we only set a flag.  we do the actual draw
// during WM_PAINT.  This prevents wasted efforts drawing.
#define TBChanged(ptb, wFlags) ((ptb)->wDirtyFlags |= (wFlags))

//
// Function Prototypes
//
LPARAM FAR CALLBACK TrackBarWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void NEAR PASCAL FlushChanges(PTRACKBAR tb);

//--------------------------------------------------------------------------;
//
//  LONG MulDiv32(a,b,c)    = (a * b + c/2) / c
//
//--------------------------------------------------------------------------;

#ifdef WIN32

#define MulDiv32 MulDiv     // use KERNEL32 version (it rounds)

#else // WIN32

#define ASM66 _asm _emit 0x66 _asm
#define DB    _asm _emit

#define EAX_TO_DXAX \
    DB      0x66    \
    DB      0x0F    \
    DB      0xA4    \
    DB      0xC2    \
    DB      0x10

#pragma warning(disable:4035 4704)

static LONG MulDiv32(LONG a,LONG b,LONG c)
{
    ASM66   mov     ax,word ptr c   //  mov  eax, c
    ASM66   sar     ax,1            //  sar  eax,1
    ASM66   cwd                     //  cdq
    ASM66   mov     bx,ax           //  mov  ebx,eax
    ASM66   mov     cx,dx           //  mov  ecx,edx
    ASM66   mov     ax,word ptr a   //  mov  eax, a
    ASM66   imul    word ptr b      //  imul b
    ASM66   add     ax,bx           //  add  eax,ebx
    ASM66   adc     dx,cx           //  adc  edx,ecx
    ASM66   idiv    word ptr c      //  idiv c
    EAX_TO_DXAX

} // MulDiv32()

#pragma warning(default:4035 4704)

#endif // WIN32

//--------------------------------------------------------------------------;
//--------------------------------------------------------------------------;

//
//  convert a logical scroll-bar position to a physical pixel position
//
int NEAR PASCAL TBLogToPhys(PTRACKBAR tb, DWORD dwPos)
{
    int x;
    x = tb->rc.left;
    if (tb->lLogMax == tb->lLogMin)
        return x;

    return (int)MulDiv32(dwPos - tb->lLogMin, tb->iSizePhys - 1,
                          tb->lLogMax - tb->lLogMin) + x;
}

LONG NEAR PASCAL TBPhysToLog(PTRACKBAR ptb, int iPos)
{
    int min, max, x;
    min = ptb->rc.left;
    max = ptb->rc.right;
    x = ptb->rc.left;

    if (ptb->iSizePhys <= 1)
        return ptb->lLogMin;

    if (iPos <= min)
        return ptb->lLogMin;

    if (iPos >= max)
        return ptb->lLogMax;

    return MulDiv32(iPos - x, ptb->lLogMax - ptb->lLogMin,
                    ptb->iSizePhys - 1) + ptb->lLogMin;
}



#pragma code_seg(CODESEG_INIT)
/*
 * Initialize the trackbar code
 */

BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance)
{
    WNDCLASS wc;

    // See if we must register a window class
    if (!GetClassInfo(hInstance, s_szSTrackBarClass, &wc)) {
#ifndef WIN32
        extern LRESULT CALLBACK _TrackBarWndProc(HWND, UINT, WPARAM, LPARAM);
        wc.lpfnWndProc = _TrackBarWndProc;
#else
        wc.lpfnWndProc = TrackBarWndProc;
#endif

        wc.lpszClassName = s_szSTrackBarClass;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon = NULL;
        wc.lpszMenuName = NULL;
        wc.hbrBackground = (HBRUSH)(COLOR_3DFACE + 1);
        wc.hInstance = hInstance;
        wc.style = CS_GLOBALCLASS;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = sizeof(PTRACKBAR);

        return RegisterClass(&wc);
    }
    return TRUE;
}
#pragma code_seg()



/* 
 * To add vertical capabilities, I'm using a virtual coordinate
 * system.  the ptb->rcThumb and ptb->rc are in the virtual space (which
 * is just a horizontal trackbar).  Draw routines use PatRect and
 * TBBitBlt which switch to the real coordinate system as needed.
 *
 * The one gotcha is that the Thumb Bitmap has the pressed bitmap
 * to the real right, and the masks to the real right again for both
 * the vertical and horizontal Thumbs.  So those cases are hardcoded.
 * Do a search for ISVERT to find these dependancies.
 *                              -Chee
 */

/*
  FlipRect Function is moved to cutils.c as  other controls  were also using it.
  -Arul

*/

void TBFlipPoint(PTRACKBAR ptb, LPPOINT lppt)
{
    if (ISVERT(ptb)) {
        FlipPoint(lppt);
    }
}


/* added trackbar variable to do auto verticalization */
void NEAR PASCAL PatRect(HDC hdc,int x,int y,int dx,int dy, PTRACKBAR ptb)
{
    RECT    rc;

    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    if (ISVERT(ptb))
        FlipRect(&rc);
    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#define TBInvalidateRect(hwnd, prc, bErase, ptb) VertInvalidateRect(hwnd, prc, bErase, ISVERT(ptb))
void FAR PASCAL VertInvalidateRect(HWND hwnd, LPRECT qrc, BOOL b, BOOL fVert)
{
    RECT rc;
    rc = *qrc;
    if (fVert) FlipRect(&rc);
    InvalidateRect(hwnd, &rc, b);
}

#define TBDrawEdge(hdc, prc, uType, grfFlags, ptb) VertDrawEdge(hdc, prc, uType, grfFlags, ISVERT(ptb))
void FAR PASCAL VertDrawEdge(HDC hdc, LPRECT qrc, UINT edgeType, UINT grfFlags,
                               BOOL fVert)
{
    RECT temprc;
    UINT uFlags = grfFlags;

    temprc = *qrc;
    if (fVert) {
        FlipRect(&temprc);

        if (!(uFlags & BF_DIAGONAL)) {
            if (grfFlags & BF_TOP) uFlags |= BF_LEFT;
            else uFlags &= ~BF_LEFT;

            if (grfFlags & BF_LEFT) uFlags |= BF_TOP;
            else uFlags &= ~BF_TOP;

            if (grfFlags & BF_BOTTOM) uFlags |= BF_RIGHT;
            else uFlags &= ~BF_RIGHT;

            if (grfFlags & BF_RIGHT) uFlags |= BF_BOTTOM;
            else uFlags &= ~BF_BOTTOM;
        } else {
            if ((grfFlags & (BF_BOTTOM | BF_RIGHT)) == (BF_BOTTOM | BF_RIGHT)) {
                uFlags = BF_TOP | BF_LEFT;

                if (edgeType == EDGE_RAISED) {
                    edgeType = EDGE_SUNKEN;
                } else {
                    edgeType = EDGE_RAISED;
                }


                uFlags |= grfFlags & (~BF_RECT);
                uFlags ^= BF_SOFT;
            }
        }
    }
    DrawEdge(hdc, &temprc, edgeType, uFlags);
}

void NEAR PASCAL TBBitBlt(HDC hdc1, int x1, int y1, int w, int h,
                          HDC hdc2, int x2, int y2, DWORD rop, PTRACKBAR ptb)
{
    if (ISVERT(ptb))
        BitBlt(hdc1, y1, x1, h, w, hdc2, x2, y2, rop);
    else
        BitBlt(hdc1, x1, y1, w, h, hdc2, x2, y2, rop);
}

#define TBPatBlt(hdc1, x1, y1, w, h, rop, ptb) VertPatBlt(hdc1, x1, y1, w, h, rop, ISVERT(ptb))
void FAR PASCAL VertPatBlt(HDC hdc1, int x1, int y1, int w, int h,
                          DWORD rop, BOOL fVert)
{
    if (fVert)
        PatBlt(hdc1, y1, x1, h, w, rop);
    else
        PatBlt(hdc1, x1, y1, w, h, rop);
}


void NEAR PASCAL DrawTic(PTRACKBAR ptb, int x, int y, int dir)
{
    if (dir == -1) y -= TICKHEIGHT;
    SetBkColor(ptb->hdc, g_clrBtnText);
    PatRect(ptb->hdc,x,y,1,TICKHEIGHT, ptb);
}

// dir = direction multiplier (drawing up or down)
// yTic = where (vertically) to draw the line of tics
void NEAR PASCAL DrawTicsOneLine(PTRACKBAR ptb, int dir, int yTic)
{
    PDWORD pTics;
    int    iPos;
    int    i;

    DrawTic(ptb, ptb->rc.left, yTic, dir);             // first
    DrawTic(ptb, ptb->rc.left, yTic+ (dir * 1), dir);
    DrawTic(ptb, ptb->rc.right-1, yTic, dir);            // last
    DrawTic(ptb, ptb->rc.right-1, yTic+ (dir * 1), dir);

    // those inbetween
    pTics = ptb->pTics;
    if (ptb->ticFreq && pTics) {
        for (i = 0; i < ptb->nTics; ++i) {
            if (((i+1) % ptb->ticFreq) == 0) {
                iPos = TBLogToPhys(ptb,pTics[i]);
                DrawTic(ptb, iPos, yTic, dir);
            }
        }
    }

    // draw the selection range (triangles)

    if ((ptb->Flags & TBF_SELECTION) &&
        (ptb->lSelStart <= ptb->lSelEnd) && (ptb->lSelEnd >= ptb->lLogMin)) {

        SetBkColor(ptb->hdc, g_clrBtnText);

        iPos = TBLogToPhys(ptb,ptb->lSelStart);

        for (i = 0; i < TICKHEIGHT; i++)
            PatRect(ptb->hdc,iPos-i,yTic+(dir==1 ? i : -TICKHEIGHT),
                    1,TICKHEIGHT-i, ptb);

        iPos = TBLogToPhys(ptb,ptb->lSelEnd);

        for (i = 0; i < TICKHEIGHT; i++)
            PatRect(ptb->hdc,iPos+i,yTic+(dir==1 ? i : -TICKHEIGHT),
                    1,TICKHEIGHT-i, ptb);
    }

}

/* DrawTics() */
/* There is always a tick at the beginning and end of the bar, but you can */
/* add some more of your own with a TBM_SETTIC message.  This draws them.  */
/* They are kept in an array whose handle is a window word.  The first     */
/* element is the number of extra ticks, and then the positions.           */

void NEAR PASCAL DrawTics(PTRACKBAR ptb)
{
    // do they even want this?
    if (ptb->ci.style & TBS_NOTICKS) return;

    if ((ptb->ci.style & TBS_BOTH) || !(ptb->ci.style & TBS_TOP)) {
        DrawTicsOneLine(ptb, 1, ptb->rc.bottom + 1);
    }

    if ((ptb->ci.style & (TBS_BOTH | TBS_TOP))) {
        DrawTicsOneLine(ptb, -1, ptb->rc.top - 1);
    }
}

void NEAR PASCAL GetChannelRect(PTRACKBAR ptb, LPRECT lprc)
{
        int iwidth, iheight;

        if (!lprc)
            return;

        lprc->left = ptb->rc.left - ptb->iThumbWidth / 2;
        iwidth = ptb->iSizePhys + ptb->iThumbWidth - 1;
        lprc->right = lprc->left + iwidth;

        if (ptb->ci.style & TBS_ENABLESELRANGE) {
                iheight =  ptb->iThumbHeight / 4 * 3; // this is Scrollheight
        } else {
                iheight = 4;
        }

        lprc->top = (ptb->rc.top + ptb->rc.bottom - iheight) /2;
        if (!(ptb->ci.style & TBS_BOTH))
            if (ptb->ci.style & TBS_TOP) lprc->top++;
            else lprc->top--;

        lprc->bottom = lprc->top + iheight;

}

/* This draws the track bar itself */

void NEAR PASCAL DrawChannel(PTRACKBAR ptb, LPRECT lprc)
{

        TBDrawEdge(ptb->hdc, lprc, EDGE_SUNKEN, BF_RECT,ptb);

        SetBkColor(ptb->hdc, g_clrBtnHighlight);
        // Fill the center
        PatRect(ptb->hdc, lprc->left+2, lprc->top+2, (lprc->right-lprc->left)-4,
                (lprc->bottom-lprc->top)-4, ptb);


        // now highlight the selection range
        if ((ptb->Flags & TBF_SELECTION) &&
            (ptb->lSelStart <= ptb->lSelEnd) && (ptb->lSelEnd > ptb->lLogMin)) {
                int iStart, iEnd;

                iStart = TBLogToPhys(ptb,ptb->lSelStart);
                iEnd   = TBLogToPhys(ptb,ptb->lSelEnd);

                if (iStart + 2 <= iEnd) {
                        SetBkColor(ptb->hdc, g_clrHighlight);
                        PatRect(ptb->hdc, iStart+1, lprc->top+3,
                                iEnd-iStart-1, (lprc->bottom-lprc->top)-6, ptb);
                }
        }
}

void NEAR PASCAL DrawThumb(PTRACKBAR ptb, LPRECT lprc, BOOL fSelected)
{

    // iDpt direction from middle to point of thumb
    // a negative value inverts things.
    // this allows one code path..
    int iDpt = 0;
    int i = 0;  // size of point triangle
    int iYpt = 0;       // vertical location of tip;
    int iXmiddle = 0;
    int icount;  // just a loop counter
    UINT uEdgeFlags;
    RECT rcThumb = *lprc;

    if (ptb->Flags & TBF_NOTHUMB ||
        ptb->ci.style & TBS_NOTHUMB)            // If no thumb, just leave.
        return;

    ASSERT(ptb->iThumbHeight >= MIN_THUMB_HEIGHT);
    ASSERT(ptb->iThumbWidth > 1);


    // draw the rectangle part
    if (!(ptb->ci.style & TBS_BOTH))  {
        int iMiddle;
        // do -3  because wThumb is odd (triangles ya know)
        // and because draw rects draw inside the rects passed.
        // actually should be (width-1)/2-1, but this is the same...

        i = (ptb->iThumbWidth - 3) / 2;
        iMiddle = ptb->iThumbHeight / 2 + rcThumb.top;

        //draw the rectangle part
        if (ptb->ci.style & TBS_TOP) {
            iMiddle++; //correction because drawing routines
            iDpt = -1;
            rcThumb.top += (i+1);
            uEdgeFlags = BF_SOFT | BF_LEFT | BF_RIGHT | BF_BOTTOM;
        } else {
            iDpt = 1;
            rcThumb.bottom -= (i+1);
            // draw on the inside, not on the bottom and rt edge
            uEdgeFlags = BF_SOFT | BF_LEFT | BF_RIGHT | BF_TOP;
        }

        iYpt = iMiddle + (iDpt * (ptb->iThumbHeight / 2));
        iXmiddle = rcThumb.left + i;
    }  else {
        uEdgeFlags = BF_SOFT | BF_RECT;
    }

    // fill in the center
    if (fSelected || !IsWindowEnabled(ptb->ci.hwnd)) {
        HBRUSH hbrTemp;
        // draw the dithered insides;
        hbrTemp = SelectObject(ptb->hdc, g_hbrMonoDither);
        if (hbrTemp) {
            SetTextColor(ptb->hdc, g_clrBtnHighlight);
            SetBkColor(ptb->hdc, g_clrBtnFace);
            TBPatBlt(ptb->hdc, rcThumb.left +2 , rcThumb.top,
                     rcThumb.right-rcThumb.left -4, rcThumb.bottom-rcThumb.top,
                     PATCOPY,ptb);

            if (!(ptb->ci.style & TBS_BOTH)) {

                for (icount = 1;  icount <= i;  icount++) {
                    TBPatBlt(ptb->hdc, iXmiddle-icount+1,
                         iYpt - (iDpt*icount),
                         icount*2, 1, PATCOPY, ptb);
                }
            }
            SelectObject(ptb->hdc, hbrTemp);
        }

    } else {


        SetBkColor(ptb->hdc, g_clrBtnFace);
        PatRect(ptb->hdc, rcThumb.left+2, rcThumb.top,
                rcThumb.right-rcThumb.left-4, rcThumb.bottom-rcThumb.top, ptb);

        if (!(ptb->ci.style & TBS_BOTH)) {
            for (icount = 1; icount <= i; icount++) {
                PatRect(ptb->hdc, iXmiddle-icount+1,
                        iYpt - (iDpt*icount),
                        icount*2, 1, ptb);
            }
        }

    }

    TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags, ptb);


    //now draw the point
    if (!(ptb->ci.style & TBS_BOTH)) {
        UINT uEdgeFlags2;

        // uEdgeFlags is now used to switch between top and bottom.
        // we'll or it in with the diagonal and left/right flags below
        if (ptb->ci.style & TBS_TOP) {
            rcThumb.bottom = rcThumb.top + 1;
            rcThumb.top = rcThumb.bottom - (i + 2);
            uEdgeFlags = BF_TOP | BF_RIGHT | BF_DIAGONAL | BF_SOFT;
            uEdgeFlags2 = BF_BOTTOM | BF_RIGHT | BF_DIAGONAL;
        } else {
            rcThumb.top = rcThumb.bottom - 1;
            rcThumb.bottom = rcThumb.top + (i + 2);

            uEdgeFlags = BF_TOP | BF_LEFT | BF_DIAGONAL | BF_SOFT;
            uEdgeFlags2 = BF_BOTTOM | BF_LEFT | BF_DIAGONAL;
        }

        rcThumb.right = rcThumb.left + (i + 2);
        // do the left side first
        TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags , ptb);
        // then do th right side
        OffsetRect(&rcThumb, i + 1, 0);
        TBDrawEdge(ptb->hdc, &rcThumb, EDGE_RAISED, uEdgeFlags2 , ptb);
    }
}
void NEAR PASCAL TBInvalidateAll(PTRACKBAR ptb)
{
    if (ptb) {
        TBChanged(ptb, TBC_ALL);
        InvalidateRect(ptb->ci.hwnd, NULL, FALSE);
    }
}

void NEAR PASCAL MoveThumb(PTRACKBAR ptb, LONG lPos)
{
    long    lOld = ptb->lLogPos;

    TBInvalidateRect(ptb->ci.hwnd, &ptb->rcThumb, FALSE,ptb);

    ptb->lLogPos  = BOUND(lPos,ptb->lLogMin,ptb->lLogMax);
    ptb->rcThumb.left   = TBLogToPhys(ptb, ptb->lLogPos) - ptb->iThumbWidth / 2;
    ptb->rcThumb.right  = ptb->rcThumb.left + ptb->iThumbWidth;

    TBInvalidateRect(ptb->ci.hwnd, &ptb->rcThumb, FALSE,ptb);
    TBChanged(ptb, TBC_THUMB);
    UpdateWindow(ptb->ci.hwnd);

    if (lOld != ptb->lLogPos)
        MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, ptb->ci.hwnd, OBJID_CLIENT, 0);
}


void NEAR PASCAL DrawFocus(PTRACKBAR ptb, HBRUSH hbrBackground)
{
    RECT rc;
    if (ptb->ci.hwnd == GetFocus()
#ifdef KEYBOARDCUES
        && !(CCGetUIState(&(ptb->ci)) & UISF_HIDEFOCUS)
#endif
        )
    {
        SetBkColor(ptb->hdc, g_clrBtnHighlight);
        GetClientRect(ptb->ci.hwnd, &rc);

        // Successive calls to DrawFocusRect will invert it thereby erasing it.
        // To avoid this, whenever we process WM_PAINT, we erase the focus rect ourselves
        // before we draw it below.
        if (hbrBackground)
            FrameRect(ptb->hdc, &rc, hbrBackground);

        DrawFocusRect(ptb->hdc, &rc);
    }
}

void NEAR PASCAL DoAutoTics(PTRACKBAR ptb)
{
    LONG NEAR *pl;
    LONG l;

    if (!(ptb->ci.style & TBS_AUTOTICKS))
        return;

    if (ptb->pTics)
        LocalFree((HLOCAL)ptb->pTics);

    ptb->nTics = (int)(ptb->lLogMax - ptb->lLogMin - 1);

    if (ptb->nTics > 0)
        ptb->pTics = (DWORD NEAR *)LocalAlloc(LPTR, sizeof(DWORD) * ptb->nTics);
    else
        ptb->pTics = NULL;

    if (!ptb->pTics) {
        ptb->nTics = 0;
        return;
    }

    for (pl = (LONG NEAR *)ptb->pTics, l = ptb->lLogMin + 1; l < ptb->lLogMax; l++)
        *pl++ = l;
}


void NEAR PASCAL ValidateThumbHeight(PTRACKBAR ptb)
{
    if (ptb->iThumbHeight < MIN_THUMB_HEIGHT)
        ptb->iThumbHeight = MIN_THUMB_HEIGHT;

    ptb->iThumbWidth = ptb->iThumbHeight / 2;
    ptb->iThumbWidth |= 0x01;  // make sure it's odd at at least 3

    if (ptb->ci.style & TBS_ENABLESELRANGE) {
        if (ptb->ci.style & TBS_FIXEDLENGTH) {
            // half of 9/10
            ptb->iThumbWidth = (ptb->iThumbHeight * 9) / 20;
            ptb->iThumbWidth |= 0x01;
        } else {
            ptb->iThumbHeight += (ptb->iThumbWidth * 2) / 9;
        }
    }
}

void TBPositionBuddies(PTRACKBAR ptb)
{
    POINT pt;
    HWND hwndParent;
    RECT rcBuddy;
    RECT rcClient;
    RECT rcChannel;

    int yMid;

    GetChannelRect(ptb, &rcChannel);
    yMid = (rcChannel.top + rcChannel.bottom) / 2;

    GetClientRect(ptb->ci.hwnd, &rcClient);
    if (ISVERT(ptb))
        FlipRect(&rcClient);


    if (ptb->hwndBuddyLeft) {
        GetClientRect(ptb->hwndBuddyLeft, &rcBuddy);
        if (ISVERT(ptb))
            FlipRect(&rcBuddy);

        pt.y = yMid - ((RECTHEIGHT(rcBuddy))/2);
        pt.x = rcClient.left - RECTWIDTH(rcBuddy) - g_cxEdge;

        // x and y are now in trackbar's coordinates.
        // convert them to the parent of the buddy's coordinates
        hwndParent = GetParent(ptb->hwndBuddyLeft);
        TBFlipPoint(ptb, &pt);
        MapWindowPoints(ptb->ci.hwnd, hwndParent, &pt, 1);
        SetWindowPos(ptb->hwndBuddyLeft, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE |SWP_NOZORDER | SWP_NOACTIVATE);
    }

    if (ptb->hwndBuddyRight) {
        GetClientRect(ptb->hwndBuddyRight, &rcBuddy);
        if (ISVERT(ptb))
            FlipRect(&rcBuddy);

        pt.y = yMid - ((RECTHEIGHT(rcBuddy))/2);
        pt.x = rcClient.right + g_cxEdge;

        // x and y are now in trackbar's coordinates.
        // convert them to the parent of the buddy's coordinates
        hwndParent = GetParent(ptb->hwndBuddyRight);
        TBFlipPoint(ptb, &pt);
        MapWindowPoints(ptb->ci.hwnd, hwndParent, &pt, 1);
        SetWindowPos(ptb->hwndBuddyRight, NULL, pt.x, pt.y, 0, 0, SWP_NOSIZE |SWP_NOZORDER | SWP_NOACTIVATE);
    }

}

void NEAR PASCAL TBNukeBuffer(PTRACKBAR ptb)
{
    if (ptb->hbmBuffer) {
        DeleteObject(ptb->hbmBuffer);
        ptb->hbmBuffer = NULL;
        TBChanged(ptb, TBC_ALL);            // Must do a full repaint
    }
}

void NEAR PASCAL TBResize(PTRACKBAR ptb)
{
    GetClientRect(ptb->ci.hwnd, &ptb->rc);

    if (ISVERT(ptb))
        FlipRect(&ptb->rc);


    if (!(ptb->ci.style & TBS_FIXEDLENGTH)) {
        ptb->iThumbHeight = (g_cyHScroll * 4) / 3;

        ValidateThumbHeight(ptb);
        if ((ptb->iThumbHeight > MIN_THUMB_HEIGHT) && (ptb->rc.bottom < (int)ptb->iThumbHeight)) {
            ptb->iThumbHeight = ptb->rc.bottom - 3*g_cyEdge; // top, bottom, and tic
            if (ptb->ci.style & TBS_ENABLESELRANGE)
                ptb->iThumbHeight = (ptb->iThumbHeight * 3 / 4);
            ValidateThumbHeight(ptb);
        }
    } else {
        ValidateThumbHeight(ptb);
    }


    if (ptb->ci.style & (TBS_BOTH | TBS_TOP) && !(ptb->ci.style & TBS_NOTICKS))
        ptb->rc.top += TICKHEIGHT + BORDERSIZE + 3;
    ptb->rc.top   += BORDERSIZE;
    ptb->rc.bottom  = ptb->rc.top + ptb->iThumbHeight;
    ptb->rc.left   += (ptb->iThumbWidth + BORDERSIZE);
    ptb->rc.right  -= (ptb->iThumbWidth + BORDERSIZE);

    ptb->rcThumb.top = ptb->rc.top;
    ptb->rcThumb.bottom = ptb->rc.bottom;

    // Figure out how much room we have to move the thumb in
    ptb->iSizePhys = ptb->rc.right - ptb->rc.left;

    // Elevator isn't there if there's no room.
    if (ptb->iSizePhys == 0) {
        // Lost our thumb.
        ptb->Flags |= TBF_NOTHUMB;
        ptb->iSizePhys = 1;
    } else {
        // Ah. We have a thumb.
        ptb->Flags &= ~TBF_NOTHUMB;
    }

    TBNukeBuffer(ptb);

    MoveThumb(ptb, ptb->lLogPos);
    TBInvalidateAll(ptb);

    TBPositionBuddies(ptb);
}

LRESULT NEAR PASCAL TrackOnCreate(HWND hwnd, LPCREATESTRUCT lpCreate)
{
    PTRACKBAR       ptb;

#ifdef MAINWIN
    DWORD exStyle = WS_EX_MW_UNMANAGED_WINDOW;
#else
    DWORD exStyle = 0;
#endif

    InitDitherBrush();
    InitGlobalColors();

    // Get us our window structure.
    ptb = (PTRACKBAR)LocalAlloc(LPTR, sizeof(TRACKBAR));
    if (!ptb)
        return -1;

    SetWindowPtr(hwnd, 0, ptb);
    CIInitialize(&ptb->ci, hwnd, lpCreate);

    ptb->Cmd = (UINT)-1;
    ptb->lLogMax = 100;
    ptb->ticFreq = 1;
    // ptb->hbmBuffer = 0;
    ptb->lPageSize = -1;
    ptb->lLineSize = 1;
    // initial size;
    ptb->iThumbHeight = (g_cyHScroll * 4) / 3;
#if defined(FE_IME) || !defined(WINNT)
    if (g_fDBCSInputEnabled)
        ptb->hPrevImc = ImmAssociateContext(hwnd, 0L);
#endif

#ifdef FEATURE_DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0)
        ptb->ci.style |= TBS_TOOLTIPS;
#endif

    if (ISVERT(ptb)) {
        if (ptb->ci.style & TBS_TOP) {
            ptb->uTipSide = TBTS_RIGHT;
        } else {
            ptb->uTipSide = TBTS_LEFT;
        }
    } else {
        if (ptb->ci.style & TBS_TOP) {
            ptb->uTipSide = TBTS_BOTTOM;
        } else {
            ptb->uTipSide = TBTS_TOP;
        }
    }

    if (ptb->ci.style & TBS_TOOLTIPS) {
        ptb->hwndToolTips = CreateWindowEx(exStyle, 
                                              c_szSToolTipsClass, TEXT(""),
                                              WS_POPUP,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              CW_USEDEFAULT, CW_USEDEFAULT,
                                              ptb->ci.hwnd, NULL, HINST_THISDLL,
                                              NULL);
        if (ptb->hwndToolTips) {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in FlushToolTipsMgr;
            ti.cbSize = sizeof(ti);
            ti.uFlags = TTF_TRACK | TTF_IDISHWND | TTF_CENTERTIP;
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = (UINT_PTR)ptb->ci.hwnd;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0; // update this on size
            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);
        } else
            ptb->ci.style &= ~(TBS_TOOLTIPS);
    }


    TBResize(ptb);

#ifdef FEATURE_DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0 )
    {
        HWND hwnd =
            CreateWindowEx(WS_EX_STATICEDGE, TEXT("static"), TEXT("left"), WS_CHILD | WS_VISIBLE, 0, 0, 30, 20, GetParent(ptb->ci.hwnd), NULL, HINST_THISDLL, NULL);
        HWND hwnd2 =
            CreateWindowEx(WS_EX_STATICEDGE, TEXT("static"), TEXT("right"), WS_CHILD |WS_VISIBLE, 0, 0, 50, 20, GetParent(ptb->ci.hwnd), NULL, HINST_THISDLL, NULL);

        SendMessage(ptb->ci.hwnd, TBM_SETBUDDY, TRUE, (LPARAM)hwnd);
        SendMessage(ptb->ci.hwnd, TBM_SETBUDDY, FALSE, (LPARAM)hwnd2);
    }
#endif


    return 0;
}

void NEAR PASCAL TrackOnNotify(PTRACKBAR ptb, LPNMHDR lpnm)
{
    if (lpnm->hwndFrom == ptb->hwndToolTips) {
        switch (lpnm->code) {
        case TTN_NEEDTEXT:
#define lpttt ((LPTOOLTIPTEXT)lpnm)
            wsprintf(lpttt->szText, TEXT("%d"), ptb->lLogPos);

        default:
            SendNotifyEx(ptb->ci.hwndParent, (HWND)-1,
                         lpnm->code, lpnm, ptb->ci.bUnicode);
            break;
        }
    }
}

HWND TBSetBuddy(PTRACKBAR ptb, BOOL fLeft, HWND hwndBuddy)
{
    HWND hwndOldBuddy;

    if (fLeft) {
        hwndOldBuddy = ptb->hwndBuddyLeft;
        ptb->hwndBuddyLeft = hwndBuddy;
    } else {
        hwndOldBuddy = ptb->hwndBuddyRight;
        ptb->hwndBuddyRight = hwndBuddy;
    }

    TBResize(ptb);

    return hwndOldBuddy;
}

LPARAM FAR CALLBACK TrackBarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
        PTRACKBAR       ptb;
        PAINTSTRUCT     ps;
        HLOCAL          h;

        ptb = GetWindowPtr(hwnd, 0);
        if (!ptb) {
            if (uMsg == WM_CREATE)
                return TrackOnCreate(hwnd, (LPCREATESTRUCT)lParam);

            goto DoDefault;
        }

        switch (uMsg) {

        // If color depth changes, the old buffer is no longer any good
        case WM_DISPLAYCHANGE:
            TBNukeBuffer(ptb);
            break;

        case WM_WININICHANGE:

            InitGlobalMetrics(wParam);
            // fall through to WM_SIZE

        case WM_SIZE:
            TBResize(ptb);
            break;

        case WM_SYSCOLORCHANGE:
            InitGlobalColors();
            TBInvalidateAll(ptb);
            break;

        case WM_NOTIFYFORMAT:
            return CIHandleNotifyFormat(&ptb->ci,lParam);

        case WM_NOTIFY:
            TrackOnNotify(ptb, (LPNMHDR)lParam);
            break;

        case WM_DESTROY:
            TerminateDitherBrush();
            if (ptb) {
#if defined(FE_IME) || !defined(WINNT)
                if (g_fDBCSInputEnabled)
                    ImmAssociateContext(hwnd, ptb->hPrevImc);
#endif
                if ((ptb->ci.style & TBS_TOOLTIPS) && IsWindow(ptb->hwndToolTips)) {
                    DestroyWindow (ptb->hwndToolTips);
                }

                TBNukeBuffer(ptb);

                if (ptb->pTics)
                    LocalFree((HLOCAL)ptb->pTics);

                LocalFree((HLOCAL)ptb);
                SetWindowPtr(hwnd, 0, 0);
            }
            break;

        case WM_KILLFOCUS:
            // Reset wheel scroll amount
            gcWheelDelta = 0;
            // fall-through

        case WM_SETFOCUS:
            ASSERT(gcWheelDelta == 0);
            if (ptb)
                TBInvalidateAll(ptb);
            break;

        case WM_ENABLE:
            if (wParam) {
                ptb->ci.style &= ~WS_DISABLED;
            } else {
                ptb->ci.style |= WS_DISABLED;
            }
            TBChanged(ptb, TBC_THUMB);
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case WM_PRINTCLIENT:
        case WM_PAINT: {
            RECT rc;
            HBITMAP hbmOld;
            HDC hdc;

            hdc = wParam ?  (HDC)wParam : BeginPaint(hwnd, &ps);

            //DebugMsg(DM_TRACE, "NumTics = %d", SendMessage(ptb->ci.hwnd, TBM_GETNUMTICS, 0, 0));

            //ptb->hdc = GetDC(NULL);
            ptb->hdc = CreateCompatibleDC(hdc);
            if (!ptb->hbmBuffer) {
                GetClientRect(hwnd, &rc);
                ptb->hbmBuffer = CreateColorBitmap(rc.right, rc.bottom);
            }

            hbmOld = SelectObject(ptb->hdc, ptb->hbmBuffer);
            FlushChanges(ptb);

            //only copy the area that's changable.. ie the clip box
            switch(GetClipBox(hdc, &rc)) {
                case NULLREGION:
                case ERROR:
                    GetClientRect(ptb->ci.hwnd, &rc);
            }
            BitBlt(hdc, rc.left, rc.top,
                     rc.right - rc.left, rc.bottom - rc.top,
                     ptb->hdc, rc.left, rc.top, SRCCOPY);

#ifdef TB_DEBUG
            {
                HDC hdcScreen;
                RECT rcClient;
                hdcScreen = GetDC(NULL);
                GetClientRect(ptb->ci.hwnd, &rcClient);
                BitBlt(hdcScreen, 0, 0, rcClient.right, rcClient.bottom, ptb->hdc, 0,0, SRCCOPY);
                ReleaseDC(NULL, hdcScreen);
            }
#endif

            SelectObject(ptb->hdc, hbmOld);
            DeleteDC(ptb->hdc);
            //ReleaseDC(NULL, ptb->hdc);
            if (wParam == 0)
                EndPaint(hwnd, &ps);

            ptb->hdc = NULL;
            break;
        }

        case WM_GETDLGCODE:
            return DLGC_WANTARROWS;

        case WM_LBUTTONDOWN:
            /* Give ourselves focus */
            if (!(ptb->ci.style & WS_DISABLED)) {
                SetFocus(hwnd); // REVIEW: we may not want to do this
                TBTrackInit(ptb, lParam);
            }
            break;

        case WM_LBUTTONUP:
            // We're through doing whatever we were doing with the
            // button down.
            if (!(ptb->ci.style & WS_DISABLED)) {
                TBTrackEnd(ptb);
                if (GetCapture() == hwnd)
                    CCReleaseCapture(&ptb->ci);
            }
            break;

        case WM_TIMER:
            // The only way we get a timer message is if we're
            // autotracking.
            lParam = GetMessagePosClient(ptb->ci.hwnd, NULL);
            // fall through to WM_MOUSEMOVE

        case WM_MOUSEMOVE:
            // We only care that the mouse is moving if we're
            // tracking the bloody thing.
            if ((ptb->Cmd != (UINT)-1) && (!(ptb->ci.style & WS_DISABLED)))
                TBTrack(ptb, lParam);
            break;

        case WM_CAPTURECHANGED:
            // someone is stealing the capture from us
            TBTrackEnd(ptb);
            break;

        case WM_KEYUP:
            if (!(ptb->ci.style & WS_DISABLED)) {
                // If key was any of the keyboard accelerators, send end
                // track message when user up clicks on keyboard
                switch (wParam) {
                case VK_HOME:
                case VK_END:
                case VK_PRIOR:
                case VK_NEXT:
                case VK_LEFT:
                case VK_UP:
                case VK_RIGHT:
                case VK_DOWN:
                    DoTrack(ptb, TB_ENDTRACK, 0);
                    break;
                default:
                    break;
                }
            }
            break;

        case WM_KEYDOWN:
            if (!(ptb->ci.style & WS_DISABLED)) {

                // Swap the left and right arrow key if the control is mirrored.
                wParam = RTLSwapLeftRightArrows(&ptb->ci, wParam);

                // If TBS_DOWNISLEFT, then swap left/right or up/down
                // depending on whether we are vertical or horizontal.
                // Some horizontal trackbars (e.g.) prefer that
                // UpArrow=TB_PAGEDOWN.
                if (ptb->ci.style & TBS_DOWNISLEFT) {
                    if (ISVERT(ptb)) {
                        wParam = CCSwapKeys(wParam, VK_LEFT, VK_RIGHT);
                    } else {
                        wParam = CCSwapKeys(wParam, VK_UP, VK_DOWN);
                        wParam = CCSwapKeys(wParam, VK_PRIOR, VK_NEXT);
                    }
                }

                switch (wParam) {
                case VK_HOME:
                    wParam = TB_TOP;
                    goto KeyTrack;

                case VK_END:
                    wParam = TB_BOTTOM;
                    goto KeyTrack;

                case VK_PRIOR:
                    wParam = TB_PAGEUP;
                    goto KeyTrack;

                case VK_NEXT:
                    wParam = TB_PAGEDOWN;
                    goto KeyTrack;

                case VK_LEFT:
                case VK_UP:
                    wParam = TB_LINEUP;
                    goto KeyTrack;

                case VK_RIGHT:
                case VK_DOWN:
                    wParam = TB_LINEDOWN;
                KeyTrack:
                    DoTrack(ptb, (int) wParam, 0);
#ifdef KEYBOARDCUES
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS);
#endif
                    break;

                default:
                    break;
                }
            }
            break;

        case WM_MBUTTONDOWN:
            SetFocus(hwnd);
            break;

        case WM_STYLECHANGED:
            if (wParam == GWL_STYLE) {
                ptb->ci.style = ((LPSTYLESTRUCT)lParam)->styleNew;
                TBResize(ptb);
            }
            break;

#ifdef KEYBOARDCUES
        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(ptb->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
                InvalidateRect(hwnd, NULL, TRUE);

            goto DoDefault;
        }
#endif
        case TBM_GETPOS:
            return ptb->lLogPos;

        case TBM_GETSELSTART:
            return ptb->lSelStart;

        case TBM_GETSELEND:
            return ptb->lSelEnd;

        case TBM_GETRANGEMIN:
            return ptb->lLogMin;

        case TBM_GETRANGEMAX:
            return ptb->lLogMax;

        case TBM_GETPTICS:
            return (LRESULT)ptb->pTics;

        case TBM_CLEARSEL:
            ptb->Flags &= ~TBF_SELECTION;
            ptb->lSelStart = -1;
            ptb->lSelEnd   = -1;
            goto RedrawTB;

        case TBM_CLEARTICS:
            if (ptb->pTics)
                LocalFree((HLOCAL)ptb->pTics);

            ptb->pTics = NULL;
            ptb->nTics = 0;
            goto RedrawTB;

        case TBM_GETTIC:

            if (ptb->pTics == NULL || (int)wParam >= ptb->nTics)
                return -1L;

            return ptb->pTics[wParam];

        case TBM_GETTICPOS:

            if (ptb->pTics == NULL || (int)wParam >= ptb->nTics)
                return -1L;

            return TBLogToPhys(ptb,ptb->pTics[wParam]);

        case TBM_GETNUMTICS:
            if (ptb->ci.style & TBS_NOTICKS)
                return 0;

            if (ptb->ticFreq) {
                // first and last +
                return 2 + (ptb->nTics / ptb->ticFreq);
            }

            // if there's no ticFreq, then we fall down here.
            // 2 for the first and last tics that we always draw
            // when NOTICS isn't set.
            return 2;


        case TBM_SETTIC:
            /* not a valid position */
            if (((LONG)lParam) < ptb->lLogMin || ((LONG)lParam) > ptb->lLogMax)
                break;

            h = CCLocalReAlloc(ptb->pTics,
                                 sizeof(DWORD) * (ptb->nTics + 1));
            if (!h)
                return (LONG)FALSE;
            
            ptb->pTics = (PDWORD)h;
            ptb->pTics[ptb->nTics++] = (DWORD)lParam;

            TBInvalidateAll(ptb);
            return (LONG)TRUE;

        case TBM_SETTICFREQ:
            ptb->ticFreq = (int) wParam;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETPOS:
            /* Only redraw if it will physically move */
            if (wParam && TBLogToPhys(ptb, (DWORD) lParam) !=
                TBLogToPhys(ptb, ptb->lLogPos))
                MoveThumb(ptb, (DWORD) lParam);
            else
                ptb->lLogPos = BOUND((LONG)lParam,ptb->lLogMin,ptb->lLogMax);
            break;

        case TBM_SETSEL:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;

            if (((LONG)(SHORT)LOWORD(lParam)) < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            else
                ptb->lSelStart = (LONG)(SHORT)LOWORD(lParam);

            if (((LONG)(SHORT)HIWORD(lParam)) > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            else
                ptb->lSelEnd   = (LONG)(SHORT)HIWORD(lParam);

            if (ptb->lSelEnd < ptb->lSelStart)
                ptb->lSelEnd = ptb->lSelStart;
            goto RedrawTB;

        case TBM_SETSELSTART:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;
            if (lParam < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            else
                ptb->lSelStart = (LONG) lParam;
            if (ptb->lSelEnd < ptb->lSelStart || ptb->lSelEnd == -1)
                ptb->lSelEnd = ptb->lSelStart;
            goto RedrawTB;

        case TBM_SETSELEND:

            if (!(ptb->ci.style & TBS_ENABLESELRANGE)) break;
            ptb->Flags |= TBF_SELECTION;
            if (lParam > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            else
                ptb->lSelEnd = (LONG) lParam;
            if (ptb->lSelStart > ptb->lSelEnd || ptb->lSelStart == -1)
                ptb->lSelStart = ptb->lSelEnd;
            goto RedrawTB;

        case TBM_SETRANGE:

            ptb->lLogMin = (LONG)(SHORT)LOWORD(lParam);
            ptb->lLogMax = (LONG)(SHORT)HIWORD(lParam);
            if (ptb->lSelStart < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            if (ptb->lSelEnd > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETRANGEMIN:
            ptb->lLogMin = (LONG)lParam;
            if (ptb->lSelStart < ptb->lLogMin)
                ptb->lSelStart = ptb->lLogMin;
            DoAutoTics(ptb);
            goto RedrawTB;

        case TBM_SETRANGEMAX:
            ptb->lLogMax = (LONG)lParam;
            if (ptb->lSelEnd > ptb->lLogMax)
                ptb->lSelEnd = ptb->lLogMax;
            DoAutoTics(ptb);

RedrawTB:
            ptb->lLogPos = BOUND(ptb->lLogPos, ptb->lLogMin,ptb->lLogMax);
            TBChanged(ptb, TBC_ALL);
            /* Only redraw if flag says so */
            if (wParam) {
                InvalidateRect(hwnd, NULL, FALSE);
                MoveThumb(ptb, ptb->lLogPos);
            }
            break;

        case TBM_SETTHUMBLENGTH:
            if (ptb->ci.style & TBS_FIXEDLENGTH) {
                ptb->iThumbHeight = (UINT)wParam;
                TBResize(ptb);
            }
            break;

        case TBM_GETTHUMBLENGTH:
            return ptb->iThumbHeight;

        case TBM_SETPAGESIZE: {
            LONG lOldPage = ptb->lPageSize == -1 ? (ptb->lLogMax - ptb->lLogMin)/5 : ptb->lPageSize;
            ptb->lPageSize = (LONG)lParam;
            return lOldPage;
        }

        case TBM_GETPAGESIZE:
            return ptb->lPageSize == -1 ? (ptb->lLogMax - ptb->lLogMin)/5 : ptb->lPageSize;

        case TBM_SETLINESIZE:  {
            LONG lOldLine = ptb->lLineSize;
            ptb->lLineSize = (LONG)lParam;
            return lOldLine;
        }

        case TBM_GETLINESIZE:
            return ptb->lLineSize;

        case TBM_GETTHUMBRECT:
            if (lParam) {
                *((LPRECT)lParam) = ptb->rcThumb;
                if (ISVERT(ptb)) FlipRect((LPRECT)lParam);
            }
            break;

        case TBM_GETTOOLTIPS:
            return (LRESULT)ptb->hwndToolTips;

        case TBM_SETTOOLTIPS:
            ptb->hwndToolTips = (HWND)wParam;
            break;

        case TBM_SETTIPSIDE:
        {
            UINT uOldSide = ptb->uTipSide;
            
            ptb->uTipSide = (UINT) wParam;
            return uOldSide;
        }

        case TBM_GETCHANNELRECT:
            GetChannelRect(ptb, (LPRECT)lParam);
            break;

        case TBM_SETBUDDY:
            return (LRESULT)TBSetBuddy(ptb, (BOOL)wParam, (HWND)lParam);

        case TBM_GETBUDDY:
            return (LRESULT)(wParam ? ptb->hwndBuddyLeft : ptb->hwndBuddyRight);

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_TRACKBAR;
            goto DoDefault;

        default:
            if (uMsg == g_msgMSWheel) {
                int   iWheelDelta;
                int   cDetants;
                long  lPos;
                ULONG ulPos;

                if (g_bRunOnNT || g_bRunOnMemphis)
                    iWheelDelta = (int)(short)HIWORD(wParam);
                else
                    iWheelDelta = (int)wParam;

                // Update count of scroll amount
                gcWheelDelta -= iWheelDelta;
                cDetants = gcWheelDelta / WHEEL_DELTA;
                if (cDetants != 0) {
                    gcWheelDelta %= WHEEL_DELTA;
                }

                if (g_bRunOnNT || g_bRunOnMemphis)
                {
                    if (wParam & (MK_SHIFT | MK_CONTROL))
                        goto DoDefault;
                }
                else
                {
                    if (GetKeyState(VK_SHIFT) < 0 || GetKeyState(VK_CONTROL) < 0)
                        goto DoDefault;
                }

                if (SHRT_MIN <= ptb->lLogPos && ptb->lLogPos <= SHRT_MAX) {
                    lPos = ptb->lLogPos + cDetants;
                    lPos = BOUND(lPos, ptb->lLogMin, ptb->lLogMax);
                    ulPos = BOUND(lPos, SHRT_MIN, SHRT_MAX);
                    if ((long) ulPos != ptb->lLogPos) {
                        MoveThumb(ptb, (long) ulPos);
                        DoTrack(ptb, TB_THUMBPOSITION, ulPos);
                    }
                }

                return TRUE;
            } else {
                LRESULT lres;
                if (CCWndProc(&ptb->ci, uMsg, wParam, lParam, &lres))
                    return lres;
            }

DoDefault:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

/* DoTrack() */

void NEAR PASCAL DoTrack(PTRACKBAR ptb, int cmd, DWORD dwPos)
{
    LONG dpos;
    switch(cmd) {
        case TB_LINEDOWN:
            dpos = ptb->lLineSize;
            goto DMoveThumb;

        case TB_LINEUP:
            dpos = -ptb->lLineSize;
            goto DMoveThumb;

        case TB_PAGEUP:
        case TB_PAGEDOWN:
            if (ptb->lPageSize == -1) {
                dpos = (ptb->lLogMax - ptb->lLogMin) / 5;
                if (!dpos)
                    dpos = 1;
            } else {
                dpos = ptb->lPageSize;
            }

            if (cmd == TB_PAGEUP)
                dpos *= -1;

DMoveThumb: // move delta
            MoveThumb(ptb, ptb->lLogPos + dpos);
            break;

        case TB_BOTTOM:
            dpos = ptb->lLogMax; // the BOUND will take care of this;
            goto ABSMoveThumb;

        case TB_TOP:
            dpos = ptb->lLogMin; // the BOUND will take care of this;

ABSMoveThumb: // move absolute
            MoveThumb(ptb, dpos);
            break;

        default:  // do nothing
            break;

    }

    // BUGBUG:  for now, send both in vertical mode
    // note: we only send back a WORD worth of the position.
    if (ISVERT(ptb)) {
        FORWARD_WM_VSCROLL(ptb->ci.hwndParent, ptb->ci.hwnd, cmd, LOWORD(dwPos), SendMessage);
    } else
        FORWARD_WM_HSCROLL(ptb->ci.hwndParent, ptb->ci.hwnd, cmd, LOWORD(dwPos), SendMessage);
}

/* WTrackType() */

WORD NEAR PASCAL WTrackType(PTRACKBAR ptb, LONG lParam)
{
    POINT pt;

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    if (ptb->Flags & TBF_NOTHUMB ||
        ptb->ci.style & TBS_NOTHUMB)            // If no thumb, just leave.
        return 0;

    if (ISVERT(ptb)) {
        // put point in virtual coordinates
        int temp;
        temp = pt.x;
        pt.x = pt.y;
        pt.y = temp;
    }

    if (PtInRect(&ptb->rcThumb, pt))
        return TB_THUMBTRACK;

    if (!PtInRect(&ptb->rc, pt))
        return 0;

    if (pt.x >= ptb->rcThumb.left)
        return TB_PAGEDOWN;
    else
        return TB_PAGEUP;
}

/* TBTrackInit() */

void NEAR PASCAL TBTrackInit(PTRACKBAR ptb, LPARAM lParam)
{
        WORD wCmd;

        if (ptb->Flags & TBF_NOTHUMB ||
            ptb->ci.style & TBS_NOTHUMB)         // No thumb:  just leave.
            return;

        wCmd = WTrackType(ptb, (LONG) lParam);
        if (!wCmd)
            return;

        SetCapture(ptb->ci.hwnd);

        ptb->Cmd = wCmd;
        ptb->dwDragPos = (DWORD)-1;

        // Set up for auto-track (if needed).
        if (wCmd != TB_THUMBTRACK) {
                // Set our timer up
                SetTimer(ptb->ci.hwnd, TIMER_ID, REPEATTIME, NULL);
        } else {
            int xPos;
            // thumb tracking...

            // store the offset between the cursor's position and the center of the thumb
            xPos = TBLogToPhys(ptb, ptb->lLogPos);
            ptb->dwDragOffset = (ISVERT(ptb) ? HIWORD(lParam) : LOWORD(lParam)) - xPos;

            if (ptb->hwndToolTips) {
                TOOLINFO ti;
                // don't bother setting the rect because we'll do it below
                // in FlushToolTipsMgr;
                ti.cbSize = sizeof(ti);
                ti.uFlags = TTF_TRACK | TTF_CENTERTIP;
                ti.hwnd = ptb->ci.hwnd;
                ti.uId = (UINT_PTR)ptb->ci.hwnd;
                SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
            }
        }

        TBTrack(ptb, lParam);
}

/* EndTrack() */

void NEAR PASCAL TBTrackEnd(PTRACKBAR ptb)
{
        // Decide how we're ending this thing.
        if (ptb->Cmd == TB_THUMBTRACK) {

            if (ptb->hwndToolTips)
                SendMessage(ptb->hwndToolTips, TTM_TRACKACTIVATE, (WPARAM)FALSE, 0);

            DoTrack(ptb, TB_THUMBPOSITION, ptb->dwDragPos);

        }

        KillTimer(ptb->ci.hwnd, TIMER_ID);

        // Always send TB_ENDTRACK message if there's some sort of command tracking.
        if (ptb->Cmd != (UINT)-1) {
            DoTrack(ptb, TB_ENDTRACK, 0);

            // Nothing going on.
            ptb->Cmd = (UINT)-1;
        }

        MoveThumb(ptb, ptb->lLogPos);
}

#define TBTS_RIGHTLEFT   1   // low bit means it's on the right or left

void NEAR PASCAL TBTrack(PTRACKBAR ptb, LPARAM lParam)
{
    DWORD dwPos;
    WORD pos;


    // See if we're tracking the thumb
    if (ptb->Cmd == TB_THUMBTRACK) {


        pos = (ISVERT(ptb)) ? HIWORD(lParam) : LOWORD(lParam);
        pos -= (WORD) ptb->dwDragOffset;
        dwPos = TBPhysToLog(ptb, (int)(SHORT)pos);

        // Tentative position changed -- notify the guy.
        if (dwPos != ptb->dwDragPos) {
            ptb->dwDragPos = dwPos;
            MoveThumb(ptb, dwPos);
            DoTrack(ptb, TB_THUMBTRACK, dwPos);
        }

        if (ptb->hwndToolTips) {
            RECT rc;
            POINT pt;
            int iPixel;
            UINT uTipSide = ptb->uTipSide;

            // find the center of the window
            GetClientRect(ptb->ci.hwnd, &rc);
            pt.x = rc.right / 2;
            pt.y = rc.bottom / 2;

            //find the position of the thumb
            iPixel = TBLogToPhys(ptb, dwPos);
            if (ISVERT(ptb)) {
                pt.y = iPixel;
                uTipSide |= TBTS_RIGHTLEFT;
            } else {
                pt.x = iPixel;
                uTipSide &= ~TBTS_RIGHTLEFT;
            }
            
            // move it out to the requested side
            switch (uTipSide) {

            case TBTS_TOP:
                pt.y = -1;
                break;

            case TBTS_LEFT:
                pt.x = -1;
                break;

            case TBTS_BOTTOM:
                pt.y = rc.bottom + 1;
                break;

            case TBTS_RIGHT:
                pt.x = rc.right + 1;
                break;
            }

            // map it to screen coordinates
            MapWindowPoints(ptb->ci.hwnd, HWND_DESKTOP, &pt, 1);

            SendMessage(ptb->hwndToolTips, TTM_TRACKPOSITION, 0, MAKELONG(pt.x, pt.y));
        }

    }
    else {
        if (ptb->Cmd != WTrackType(ptb, (LONG) lParam))
            return;

        DoTrack(ptb, ptb->Cmd, 0);
    }
}




void NEAR PASCAL FlushChanges(PTRACKBAR ptb)
{
    HBRUSH hbr;
    NMCUSTOMDRAW nmcd;

#ifdef WIN32
    hbr = FORWARD_WM_CTLCOLORSTATIC(ptb->ci.hwndParent, ptb->hdc, ptb->ci.hwnd, SendMessage);
#else
    hbr = FORWARD_WM_CTLCOLOR(ptb->ci.hwndParent, ptb->hdc, ptb->ci.hwnd, CTLCOLOR_STATIC, SendMessage);
#endif

    if (hbr) {
        RECT rc;
        BOOL fClear = FALSE;

        if ( ptb->wDirtyFlags == TBC_ALL ) {
            GetClientRect(ptb->ci.hwnd, &rc);
            fClear = TRUE;
        } else if (ptb->wDirtyFlags & TBC_THUMB) {
            rc = ptb->rc;
            rc.left = 0;
            rc.right += ptb->iThumbWidth;
            if (ISVERT(ptb))
                FlipRect(&rc);
            fClear = TRUE;
        }
        if (fClear)
            FillRect(ptb->hdc, &rc, hbr);
    }

    nmcd.hdc = ptb->hdc;
    if (ptb->ci.hwnd == GetFocus())
        nmcd.uItemState = CDIS_FOCUS;
    else
        nmcd.uItemState = 0;

#ifdef KEYBOARDCUES
#if 0
    // BUGBUG: Custom draw stuff for UISTATE (stephstm)
    if (CCGetUIState(&(ptb->ci), KC_TBD))
        nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
#endif
#endif
    nmcd.lItemlParam = 0;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, &nmcd);

    // for skip default, no other flags make sense..  only allow that one
    if (!(ptb->ci.dwCustom == CDRF_SKIPDEFAULT)) {
        DWORD dwRet = 0;
        // do the actual drawing

        if (nmcd.uItemState & CDIS_FOCUS)
        {
            DrawFocus(ptb, hbr);
        }

        nmcd.uItemState = 0;
        if (ptb->wDirtyFlags & TBC_TICS) {

            nmcd.dwItemSpec = TBCD_TICS;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) {
                DrawTics(ptb);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) {
                    nmcd.dwItemSpec = TBCD_TICS;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }
        }

        if (ptb->wDirtyFlags & TBC_THUMB) {


            // the channel
            GetChannelRect(ptb, &nmcd.rc);
            if (ISVERT(ptb))
                FlipRect(&nmcd.rc);
            nmcd.dwItemSpec = TBCD_CHANNEL;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) {

                // flip it back from the last notify
                if (ISVERT(ptb))
                    FlipRect(&nmcd.rc);

                // the actual drawing
                DrawChannel(ptb, &nmcd.rc);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) {

                    if (ISVERT(ptb))
                        FlipRect(&nmcd.rc);
                    nmcd.dwItemSpec = TBCD_CHANNEL;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }


            // the thumb
            nmcd.rc = ptb->rcThumb;
            if (ptb->Cmd == TB_THUMBTRACK) {
                nmcd.uItemState = CDIS_SELECTED;
            }

            if (ISVERT(ptb))
                FlipRect(&nmcd.rc);
            nmcd.dwItemSpec = TBCD_THUMB;
            dwRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, &nmcd);

            if (!(dwRet == CDRF_SKIPDEFAULT)) {

                if (ISVERT(ptb))
                    FlipRect(&nmcd.rc);

                // the actual drawing
                DrawThumb(ptb, &nmcd.rc, nmcd.uItemState & CDIS_SELECTED);

                if (dwRet & CDRF_NOTIFYPOSTPAINT) {
                    if (ISVERT(ptb))
                        FlipRect(&nmcd.rc);
                    nmcd.dwItemSpec = TBCD_THUMB;
                    CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, &nmcd);
                }
            }

        }
        ptb->wDirtyFlags = 0;

        // notify parent afterwards if they want us to
        if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
            CICustomDrawNotify(&ptb->ci, CDDS_POSTPAINT, &nmcd);
        }
    }

#ifdef TB_DEBUG
    DebugMsg(DM_TRACE, TEXT("DrawDone"));
    {
        HDC hdcScreen;
        RECT rcClient;
        hdcScreen = GetDC(NULL);
        GetClientRect(ptb->ci.hwnd, &rcClient);
        BitBlt(hdcScreen, 200, 0, 200 + rcClient.right, rcClient.bottom, ptb->hdc, 0,0, SRCCOPY);
        ReleaseDC(NULL, hdcScreen);
    }
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\trackme.c ===
//---------------------------------------------------------------------------
//
//     TrackME.C   (TrackMouseEvent)
//
// Created by:  Sankar  on 1/24/96
//
// What:
//     This emulates the TrackMouseEvent() API for the Nashville project
//     in comctl32.dll
//
// How:
//     This subclasses the given window to get mouse messages and uses a 
//     high frequency timer to learn about mouse leaves.
//
//---------------------------------------------------------------------------

#include "ctlspriv.h"

#ifdef TrackMouseEvent
#undef TrackMouseEvent
#endif

extern const TCHAR FAR c_szTMEdata[];

extern DWORD g_dwHoverSelectTimeout;

#define ID_MOUSEHOVER          0xFFFFFFF0L
#define ID_MOUSELEAVE          0xFFFFFFF1L

#define TME_MOUSELEAVE_TIME    (GetDoubleClickTime() / 5)

#define IsKeyDown(Key)   (GetKeyState(Key) & 0x8000)

// This is the structure whose pointer gets added as a property of a window
// being tracked.
typedef struct  tagTMEDATA {
       TRACKMOUSEEVENT TrackMouseEvent;
       RECT            rcMouseHover;  //In screen co-ordinates.
   }  TMEDATA, FAR *LPTMEDATA;


void NEAR TME_ResetMouseHover(LPTRACKMOUSEEVENT lpTME, LPTMEDATA lpTMEdata);
LRESULT CALLBACK TME_SubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

LPTMEDATA NEAR GetTMEdata(HWND hwnd)
{
    LPTMEDATA lpTMEdata;

    GetWindowSubclass(hwnd, TME_SubclassProc, 0, (ULONG_PTR *)&lpTMEdata);

    return lpTMEdata;
}

void NEAR TME_PostMouseLeave(HWND hwnd)
{
  PostMessage(hwnd, WM_MOUSELEAVE, 0, 0L);
}

void NEAR TME_CancelMouseLeave(LPTMEDATA lpTMEdata)
{
  if(!(lpTMEdata->TrackMouseEvent.dwFlags & TME_LEAVE))
      return;

  // Remove the flag.
  lpTMEdata->TrackMouseEvent.dwFlags &= ~(TME_LEAVE);

  // We leave the timer set here since our hover implementation uses it too.
  // TME_CancelTracking will kill it later.
}

void NEAR TME_CancelMouseHover(LPTMEDATA lpTMEdata)
{
  if(!(lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER))
      return;

  lpTMEdata->TrackMouseEvent.dwFlags &= ~(TME_HOVER);

  KillTimer(lpTMEdata->TrackMouseEvent.hwndTrack, ID_MOUSEHOVER);
}

void NEAR TME_CancelTracking(LPTMEDATA lpTMEdata)
{
  HWND hwndTrack;

  //If either MouseLeave or MouseHover is ON, don't cancel tracking.
  if(lpTMEdata->TrackMouseEvent.dwFlags & (TME_HOVER | TME_LEAVE))
      return;

  hwndTrack = lpTMEdata->TrackMouseEvent.hwndTrack;

  // Uninstall our subclass callback.
  RemoveWindowSubclass(hwndTrack, TME_SubclassProc, 0);

  // Kill the mouseleave timer.
  KillTimer(hwndTrack, ID_MOUSELEAVE);

  // Free the tracking data.
  LocalFree((HANDLE)lpTMEdata);
}

void NEAR TME_RemoveAllTracking(LPTMEDATA lpTMEdata)
{
  TME_CancelMouseLeave(lpTMEdata);
  TME_CancelMouseHover(lpTMEdata);
  TME_CancelTracking(lpTMEdata);
}

//---------------------------------------------------------------------------
//
// TME_MouseHasLeft()
//     The mouse has left the region being tracked. Send the MOUSELEAVE msg
// and then cancel all tracking.
//
//---------------------------------------------------------------------------
void NEAR TME_MouseHasLeft(LPTMEDATA  lpTMEdata)
{
  DWORD  dwFlags;

  //Is WM_MOUSELEAVE notification requied?
  if((dwFlags = lpTMEdata->TrackMouseEvent.dwFlags) & TME_LEAVE)
      TME_PostMouseLeave(lpTMEdata->TrackMouseEvent.hwndTrack); //Then, do it!

  // Cancel all the tracking since the mouse has left.
  TME_RemoveAllTracking(lpTMEdata);
}

// --------------------------------------------------------------------------
//  
//  TME_SubclassWndProc()
//  
//  The subclass proc used for TrackMouseEvent()...!
//
// --------------------------------------------------------------------------

LRESULT CALLBACK TME_SubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
      LPTMEDATA lpTMEdata = (LPTMEDATA)dwRefData;

      ASSERT(lpTMEdata);

      switch(message)
        {
          case WM_DESTROY:
          case WM_NCDESTROY:
              TME_RemoveAllTracking(lpTMEdata);
              break;

          case WM_ENTERMENULOOP:
              // If the window being tracked enters menu mode, then we need to
              // act asif the mouse has left.
              // NOTE: Because when we are in menu mode, the SCREEN_CAPTURE has occurred
              // and we don't see any mouse moves. This is the only way out!

              // Post mouse leave and cancel all tracking!
              TME_MouseHasLeft(lpTMEdata);
              break;

          case WM_LBUTTONDOWN:
          case WM_LBUTTONUP:
          case WM_MBUTTONDOWN:
          case WM_MBUTTONUP:
          case WM_RBUTTONDOWN:
          case WM_RBUTTONUP:
          case WM_NCLBUTTONDOWN:
          case WM_NCLBUTTONUP:
          case WM_NCMBUTTONDOWN:
          case WM_NCMBUTTONUP:
          case WM_NCRBUTTONDOWN:
          case WM_NCRBUTTONUP:
              //Whenever there is a mouse click, reset mouse hover.
              if(lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER)
                  TME_ResetMouseHover(&(lpTMEdata->TrackMouseEvent), lpTMEdata);
              break;

          case WM_NCMOUSEMOVE:
              TME_MouseHasLeft(lpTMEdata);
              break;

          case WM_MOUSEMOVE:
              {
                POINT Pt;

                Pt.x = GET_X_LPARAM(lParam);
                Pt.y = GET_Y_LPARAM(lParam);

                ClientToScreen(hwnd, &Pt);
 
                //Check if the mouse is within the hover rect.
                if((lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER) &&
                   !PtInRect(&(lpTMEdata->rcMouseHover), Pt))
                    TME_ResetMouseHover(&(lpTMEdata->TrackMouseEvent), lpTMEdata);
              }
              break;
        }

      return DefSubclassProc(hwnd, message, wParam, lParam);
}

// --------------------------------------------------------------------------
//  
//  TME_CheckInWindow()
//  
//  This get the current cursor position and checks if it still lies in the
//  "valid" area.
//   Returns TRUE, if it lies in the valid area.
//   FALSE, otherwise.
//
// --------------------------------------------------------------------------

BOOL NEAR TME_CheckInWindow(LPTRACKMOUSEEVENT lpTME, LPPOINT lpPt)
{
    POINT      pt;
    HWND       hwnd;   // Given window.
    HWND       hwndPt; //Window from the given point.
    HWND       hwndCapture;

    hwnd = lpTME->hwndTrack;  //Given window handle.

    //See if anyone has captured the mouse input.
    if((hwndCapture = GetCapture()) && IsWindow(hwndCapture))
      {
        // If tracking is required for a window other than the one that
        // has the capture, forget it! It is not possible!

        if(hwndCapture != hwnd)
            return(FALSE);
      }

    GetCursorPos(&pt);  //Get cursor point in screen co-ordinates.

    if (!hwndCapture)
    {
        hwndPt = WindowFromPoint(pt);

        if (!hwndPt || !IsWindow(hwndPt) || (hwnd != hwndPt))
            return FALSE;

        if (SendMessage(hwnd, WM_NCHITTEST, 0,
            MAKELPARAM((SHORT)pt.x, (SHORT)pt.y)) != HTCLIENT)
        {
            return FALSE;
        }
    }

    // The current point falls on the same area of the same window.
    // It is a valid location.
    if (lpPt)
        *lpPt = pt;

    return(TRUE);
}

// --------------------------------------------------------------------------
//  TME_MouseLeaveTimer()
//
//  Timer callback for WM_MOUSELEAVE generation and cancelling HOVER!
//
// --------------------------------------------------------------------------
VOID CALLBACK TME_MouseLeaveTimer(HWND hwnd, UINT msg, UINT_PTR id, DWORD dwTime)
{
    LPTMEDATA  lpTMEdata;

    if(!(lpTMEdata = GetTMEdata(hwnd)))
        return;

    // YIELD!!!
    if(TME_CheckInWindow(&(lpTMEdata->TrackMouseEvent), NULL))
        return;  //The mouse is still in the valid region. So, do nothing.

    if (!IsWindow(hwnd))
        return;

    //The mouse has left the valid region. So, post mouse-leave if requested
    //Because we are cancelling mouse-leave, we need to cancel mouse-hover too!
    // There can be no hover tracking, if the mouse has already left!

    TME_MouseHasLeft(lpTMEdata);
}


WPARAM NEAR GetMouseKeyFlags()
{
    WPARAM wParam = 0;

    if (IsKeyDown(VK_LBUTTON))
        wParam |= MK_LBUTTON;
    if (IsKeyDown(VK_RBUTTON))
        wParam |= MK_RBUTTON;
    if (IsKeyDown(VK_MBUTTON))
        wParam |= MK_MBUTTON;
    if (IsKeyDown(VK_SHIFT))
        wParam |= MK_SHIFT;
    if (IsKeyDown(VK_CONTROL))
        wParam |= MK_CONTROL;

    return wParam;
}

// --------------------------------------------------------------------------
//  TME_MouseHoverTimer()
//
//  Timer callback for WM_MOUSEHOVER/WM_NCMOUSEHOVER generation.
//
// --------------------------------------------------------------------------
VOID CALLBACK TME_MouseHoverTimer(HWND hwnd, UINT msg, UINT_PTR id, DWORD dwTime)
{
    POINT pt;
    WPARAM wParam;
    LPTMEDATA lpTMEdata;

    if (!(lpTMEdata = GetTMEdata(hwnd)))
        return;

    //BOGUS: we can not detect hwndSysModal from here!
    //Also, tracking is for a per-window basis now!
    //
    // BOGUS: We don't have to worry about JournalPlayback?
    //pt = fJournalPlayback? Lpq(hwnd->hq)->ptLast : ptTrueCursor;

    // YIELD!!!
    if(!TME_CheckInWindow(&(lpTMEdata->TrackMouseEvent), &pt))
      {
        // Mouse has left the valid region of the window. So, cancel all
        // the tracking.
        TME_MouseHasLeft(lpTMEdata);
        return;
      }

    if (!IsWindow(hwnd))
        return;

    if (!PtInRect(&(lpTMEdata->rcMouseHover), pt))
      {
        // Mouse has gone out of the hover rectangle. Reset the hovering.
        TME_ResetMouseHover(&(lpTMEdata->TrackMouseEvent), lpTMEdata);
        return;
      }

    //
    // set up to check the tolerance and 
    //
    wParam = GetMouseKeyFlags();
    ScreenToClient(hwnd, &pt);

    //Mouse is still within the hover rectangle. Let's post hover msg
    PostMessage(hwnd, WM_MOUSEHOVER, wParam, MAKELPARAM(pt.x, pt.y));

    //And then cancel the hovering.
    TME_CancelMouseHover(lpTMEdata);
    TME_CancelTracking(lpTMEdata);  //Cancel the tracking, if needed.
}

BOOL NEAR TME_SubclassWnd(LPTMEDATA lpTMEdata)
{
    BOOL fResult;

    fResult = SetWindowSubclass(lpTMEdata->TrackMouseEvent.hwndTrack,
        TME_SubclassProc, 0, (ULONG_PTR)lpTMEdata);

    ASSERT(fResult);
    return fResult;
}

void NEAR TME_ResetMouseLeave(LPTRACKMOUSEEVENT lpTME, LPTMEDATA lpTMEdata)
{
  //See if already MouseLeave is being tracked.
  if(lpTMEdata->TrackMouseEvent.dwFlags & TME_LEAVE)
      return;   // Nothing else to do.
  
  //Else, set the flag.
  lpTMEdata ->TrackMouseEvent.dwFlags |= TME_LEAVE;

  //Set the high frequency Timer.
  SetTimer(lpTME->hwndTrack, ID_MOUSELEAVE, TME_MOUSELEAVE_TIME, TME_MouseLeaveTimer);
}

void NEAR TME_ResetMouseHover(LPTRACKMOUSEEVENT lpTME, LPTMEDATA lpTMEdata)
{
    DWORD  dwMouseHoverTime;
    POINT  pt;

    // Even if the hover tracking is already happening, the caller might 
    // change the timer value, restart the timer or change the hover 
    // rectangle.
    lpTMEdata->TrackMouseEvent.dwFlags |= TME_HOVER;

    dwMouseHoverTime = lpTME->dwHoverTime;
    if (!dwMouseHoverTime || (dwMouseHoverTime == HOVER_DEFAULT))
        dwMouseHoverTime = (g_dwHoverSelectTimeout ? g_dwHoverSelectTimeout : GetDoubleClickTime()*4/5); // BUGBUG: Can't we remember this?
    GetCursorPos(&pt);

    //
    // update the tolerance rectangle for the hover window.
    //
    *((POINT *)&(lpTMEdata->rcMouseHover.left)) = *((POINT *)&(lpTMEdata->rcMouseHover.right)) = pt;

    //BOGUS: Can we use globals to remeber these metrics. What about NT?
    InflateRect(&(lpTMEdata->rcMouseHover), g_cxDoubleClk/2, g_cyDoubleClk/2);
                       
    // We need to remember the timer interval we are setting. This value
    // needs to be returned when TME_QUERY is used.
    lpTME->dwHoverTime = dwMouseHoverTime;
    lpTMEdata->TrackMouseEvent.dwHoverTime = dwMouseHoverTime;
    SetTimer(lpTME->hwndTrack, ID_MOUSEHOVER, dwMouseHoverTime, TME_MouseHoverTimer);
}

// --------------------------------------------------------------------------
//  QueryTrackMouseEvent()
//
//  Fills in a TRACKMOUSEEVENT structure describing current tracking state
//  for a given window. The given window is in lpTME->hwndTrack.
//
// --------------------------------------------------------------------------
BOOL NEAR QueryTrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    HWND hwndTrack;
    LPTMEDATA lpTMEdata;

    //
    // if there isn't anything being tracked get out
    //
    if((!(hwndTrack = lpTME->hwndTrack)) || !IsWindow(hwndTrack))
        goto Sorry;

    if(!(lpTMEdata = GetTMEdata(hwndTrack)))
        goto Sorry;

    if(!(lpTMEdata->TrackMouseEvent.dwFlags & (TME_HOVER | TME_LEAVE)))
        goto Sorry;

    //
    // fill in the requested information
    //
    lpTME->dwFlags = lpTMEdata->TrackMouseEvent.dwFlags;

    if (lpTMEdata->TrackMouseEvent.dwFlags & TME_HOVER)
        lpTME->dwHoverTime = lpTMEdata->TrackMouseEvent.dwHoverTime;
    else
        lpTME->dwHoverTime = 0;

    goto Done;

Sorry:
    // zero out the struct
    lpTME->dwFlags = 0;
    lpTME->hwndTrack = NULL;
    lpTME->dwHoverTime = 0;

Done:
    return TRUE;
}


// --------------------------------------------------------------------------
//  EmulateTrackMouseEvent()
//
//  emulate API for requesting extended mouse notifications (hover, leave...)
//
// --------------------------------------------------------------------------
BOOL WINAPI EmulateTrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    HWND    hwnd;
    DWORD   dwFlags;
    LPTMEDATA  lpTMEdata;

    if (lpTME->dwFlags & ~TME_VALID)
        return FALSE;

#ifdef TME_NONCLIENT
    //
    // this implementation does not handle TME_NONCLIENT (anymore)
    // we agreed with the NT team to rip it out until the system uses it...
    //
    if (lpTME->dwFlags & TME_NONCLIENT)
        return FALSE;
#endif

    //
    // implement queries separately
    //
    if (lpTME->dwFlags & TME_QUERY)
        return QueryTrackMouseEvent(lpTME);
    
    // 
    // Check the validity of the request.
    //
    hwnd = lpTME->hwndTrack;
    dwFlags = lpTME->dwFlags;

    if (!IsWindow(hwnd))
        return FALSE;

    // Check if the mouse is currently in a valid position
    // Use GetCursorPos() to get the mouse position and then check if
    // it lies within the client/non-client portion of the window as
    // defined in this call;

    // YIELD!!!
    if(!TME_CheckInWindow(lpTME, NULL))
      {
        //If the mouse leave is requested when the mouse is already outside
        // the window, then generate one mouse leave immly.
        if((dwFlags & TME_LEAVE) && !(dwFlags & TME_CANCEL))
            TME_PostMouseLeave(hwnd);
        
        //Because it is an invalid request, we return immly.
        return(TRUE);
      }

    if (!IsWindow(hwnd))
        return FALSE;

    //It is a valid request, either to install or remove tracking.

    //See if we already have tracking for this window.
    if(!(lpTMEdata = GetTMEdata(hwnd)))
      {
        //We are not tracking this window already.
        if(dwFlags & TME_CANCEL)
            return(TRUE);   //There is nothing to cancel; Ignore!
        
        //Do they want any tracking at all?
        ASSERT(dwFlags & (TME_HOVER | TME_LEAVE));

        //Allocate global mem to remember the tracking data
        if(!(lpTMEdata = (LPTMEDATA)LocalAlloc(LPTR, sizeof(TMEDATA))))
            return(FALSE);

        // copy in the hwnd
        lpTMEdata->TrackMouseEvent.hwndTrack = lpTME->hwndTrack;

        // Make sure our subclass callback is installed.
        if (!TME_SubclassWnd(lpTMEdata))
          {
            TME_CancelTracking(lpTMEdata);
            return(FALSE);
          }
      }

    //Else fall through!

    if(dwFlags & TME_CANCEL)
      {
        if(dwFlags & TME_HOVER)
            TME_CancelMouseHover(lpTMEdata);
        
        if(dwFlags & TME_LEAVE)
            TME_CancelMouseLeave(lpTMEdata);

        // If both hover and leave are cancelled, then we don't need any
        // tracking.
        TME_CancelTracking(lpTMEdata);

        return(TRUE); // Cancelled whatever they asked for.
      }

    if(dwFlags & TME_HOVER)
        TME_ResetMouseHover(lpTME, lpTMEdata);

    if(dwFlags & TME_LEAVE)
        TME_ResetMouseLeave(lpTME, lpTMEdata);

    return(TRUE);
}

typedef BOOL (WINAPI* PFNTME)(LPTRACKMOUSEEVENT);

PFNTME g_pfnTME = NULL;

// --------------------------------------------------------------------------
//  _TrackMouseEvent() entrypoint
//
//  calls TrackMouseEvent if present, otherwise uses EmulateTrackMouseEvent
//
// --------------------------------------------------------------------------
BOOL WINAPI _TrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    if (!g_pfnTME)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));

        if (hmod)
            g_pfnTME = (PFNTME)GetProcAddress(hmod, "TrackMouseEvent");

        if (!g_pfnTME)
            g_pfnTME = EmulateTrackMouseEvent;
    }

    return g_pfnTME(lpTME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\toolbar.c ===
/*
** Toolbar.c
**
** This is it, the incredibly famous toolbar control.  Most of
** the customization stuff is in another file.
*/

#include "ctlspriv.h"
#include "toolbar.h"
#include "image.h"
#include <limits.h>
#include "apithk.h"

#define __IOleControl_INTERFACE_DEFINED__       // There is a conflich with the IOleControl's def of CONTROLINFO
#include "shlobj.h"


#ifdef MAINWIN
#include <mainwin.h>
void TBSetHotItemWithoutNotification(PTBSTATE ptb, int iPos, DWORD dwReason);
extern void  TruncateString(char *sz, int cch);
#endif

#define TBP_ONRELEASECAPTURE (WM_USER + 0x500)

#define TBIMAGELIST
// these values are defined by the UI gods...
#define DEFAULTBITMAPX 16
#define DEFAULTBITMAPY 15

#define LIST_GAP        (g_cxEdge * 2)
#define DROPDOWN_GAP    (g_cxEdge * 2)
#define CX_TOP_FUDGE    (g_cxEdge * 2)

#define SMALL_DXYBITMAP     16      // new dx dy for sdt images
#define LARGE_DXYBITMAP     24

#define DEFAULTBUTTONX      24
#define DEFAULTBUTTONY      22
// the insert mark is 6 pixels high/wide depending on horizontal or vertical mode...
#define INSERTMARKSIZE      6

const int g_dxButtonSep = 8;
const int s_xFirstButton = 0;   // was 8 in 3.1
#define s_dxOverlap 0           // was 1 in 3.1
#define USE_MIXED_BUTTONS(ptb) (((ptb)->dwStyleEx & TBSTYLE_EX_MIXEDBUTTONS) && ((ptb)->ci.style & TBSTYLE_LIST))
#define BTN_NO_SHOW_TEXT(ptb, ptbb) (!(ptb)->nTextRows || (USE_MIXED_BUTTONS(ptb) && !((ptbb)->fsStyle & BTNS_SHOWTEXT)))
#define BTN_IS_AUTOSIZE(ptb, ptbb) (((ptbb)->fsStyle & BTNS_AUTOSIZE) || (USE_MIXED_BUTTONS(ptb) && !((ptbb)->fsStyle & BTNS_SEP)))
#define DRAW_MONO_BTN(ptb, state)   (!(state & TBSTATE_ENABLED) || ((ptb->ci.style & WS_DISABLED) && ptb->ci.iVersion >= 5))

// Globals - since all of these globals are used durring a paint we have to
// take a criticial section around all toolbar paints.  can we do better?
//

const UINT wStateMasks[] = {
    TBSTATE_ENABLED,
    TBSTATE_CHECKED,
    TBSTATE_PRESSED,
    TBSTATE_HIDDEN,
    TBSTATE_INDETERMINATE,
    TBSTATE_MARKED
};

#define TBISSTRINGPTR(iString)  (((iString) != -1) && (!IS_INTRESOURCE(iString)))

#define TBDraw_State(ptbdraw)   ((ptbdraw)->tbcd.nmcd.uItemState)

LRESULT CALLBACK ToolbarWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void TBOnButtonStructSize(PTBSTATE ptb, UINT uStructSize);
BOOL SetBitmapSize(PTBSTATE ptb, int width, int height);
int  AddBitmap(PTBSTATE ptb, int nButtons, HINSTANCE hBMInst, UINT_PTR wBMID);
void TBBuildImageList(PTBSTATE ptb);
BOOL GetInsertMarkRect(PTBSTATE ptb, LPRECT lpRect, BOOL fHorizMode);
LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton);
UINT TBGetDrawTextFlags(PTBSTATE ptb, UINT uiStyle, LPTBBUTTONDATA);
BOOL TBGetMaxSize( PTBSTATE ptb, LPSIZE lpsize );
void TBGetItem(PTBSTATE ptb,LPTBBUTTONDATA ptButton, LPNMTBDISPINFO ptbdi);

#define GT_INSIDE       0x0001
#define GT_MASKONLY     0x0002
BOOL GrowToolbar(PTBSTATE ptb, int newButWidth, int newButHeight, UINT flags);


//Pager Control Functions
LRESULT TB_OnScroll(PTBSTATE ptb, LPNMHDR pnm);
LRESULT TB_OnPagerControlNotify(PTBSTATE ptb,LPNMHDR pnm);
void TBAutoSize(PTBSTATE ptb);
LRESULT TB_OnCalcSize(PTBSTATE ptb, LPNMHDR pnm);

#define TBInvalidateImageList(ptb)  ((ptb)->fHimlValid = FALSE)
#define TBHasStrings(ptb)  ((ptb)->nStrings || (ptb)->fNoStringPool)

#ifdef DEBUG
#if 0
void _InvalidateRect(HWND hwnd, LPRECT prc, BOOL fInval)
{
    if (!(GetAsyncKeyState(VK_SHIFT) < 0) )
        InvalidateRect(hwnd, prc, fInval);
}
void _RedrawWindow(HWND hwnd, LPRECT prc, HANDLE hrgn, UINT uFlags)
{
    if (!(GetAsyncKeyState(VK_SHIFT) < 0) )
        RedrawWindow(hwnd, prc, hrgn, uFlags);
}

void _SetWindowPos(HWND hwnd, HWND hwnd2, int x, int y, int cx, int cy, UINT uFlags)
{
    if (GetAsyncKeyState(VK_SHIFT) < 0)
        uFlags &= ~( SWP_FRAMECHANGED);
    SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags);
}

#define InvalidateRect(hwnd, prc, fInval) _InvalidateRect(hwnd, prc, fInval)
#define RedrawWindow(hwnd, prc, hrgn, uFlags) _RedrawWindow(hwnd, prc, hrgn, uFlags)
#define SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags) _SetWindowPos(hwnd, hwnd2, x, y, cx, cy, uFlags)
#endif
#endif


__inline BOOL TB_IsDropDown(LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (ptbb->fsStyle & (BTNS_DROPDOWN | BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (((ptb->dwStyleEx & TBSTYLE_EX_DRAWDDARROWS) &&
                        (ptbb->fsStyle & BTNS_DROPDOWN)) ||
                  (ptbb->fsStyle & BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasSplitDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    // If the button is both BTNS_DROPDOWN and BTNS_WHOLEDROPDOWN,
    // BTNS_WHOLEDROPDOWN wins.

    BOOL fRet = ((ptb->dwStyleEx & TBSTYLE_EX_DRAWDDARROWS) &&
                (ptbb->fsStyle & BTNS_DROPDOWN) &&
                !(ptbb->fsStyle & BTNS_WHOLEDROPDOWN));

    return fRet;
}

__inline BOOL TB_HasUnsplitDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (ptbb->fsStyle & BTNS_WHOLEDROPDOWN);

    return fRet;
}

__inline BOOL TB_HasTopDDArrow(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    BOOL fRet = (!(ptb->ci.style & TBSTYLE_LIST) &&
                TB_HasUnsplitDDArrow(ptb, ptbb) &&
                (ptb->nTextRows > 0) && TB_StrForButton(ptb, ptbb));

    return fRet;
}


BOOL TBIsHotTrack(PTBSTATE ptb, LPTBBUTTONDATA ptButton, UINT state)
{
    BOOL fHotTrack = FALSE;

    if ((ptb->ci.style & TBSTYLE_FLAT) && (&ptb->Buttons[ptb->iHot]==ptButton))
        fHotTrack = TRUE;

    // The following is in place to prevent hot tracking during the following conds:
    //  - drag & drop toolbar customization
    //  - when the mouse capture is on a particular button-press.
    // This does _not_ drop out of the loop because we don't want to break update
    // behavior; thus we'll have a little flickering on refresh as we pass over
    // these buttons.
    if (!(state & TBSTATE_PRESSED) && (GetKeyState (VK_LBUTTON) < 0) &&
        GetCapture() == ptb->ci.hwnd)
    {
        fHotTrack = FALSE;
    }

    if (!fHotTrack && (ptb->iPressedDD == ptButton - ptb->Buttons))
        fHotTrack = TRUE;

    return fHotTrack;
}


UINT StateFromCDIS(UINT uItemState)
{
    UINT state = 0;

    if (uItemState & CDIS_CHECKED)
        state |= TBSTATE_CHECKED;

    if (uItemState & CDIS_SELECTED)
        state |= TBSTATE_PRESSED;

    if (!(uItemState & CDIS_DISABLED))
        state |= TBSTATE_ENABLED;

    if (uItemState & CDIS_MARKED)
        state |= TBSTATE_MARKED;

    if (uItemState & CDIS_INDETERMINATE)
        state |= TBSTATE_INDETERMINATE;

    return state;
}


UINT CDISFromState(UINT state)
{
    UINT uItemState = 0;

    // Here are the TBSTATE - to - CDIS mappings:
    //
    //  TBSTATE_CHECKED         = CDIS_CHECKED
    //  TBSTATE_PRESSED         = CDIS_SELECTED
    // !TBSTATE_ENABLED         = CDIS_DISABLED
    //  TBSTATE_MARKED          = CDIS_MARKED
    //  TBSTATE_INDETERMINATE   = CDIS_INDETERMINATE
    //
    //  Hot tracked item        = CDIS_HOT
    //

    if (state & TBSTATE_CHECKED)
        uItemState |= CDIS_CHECKED;

    if (state & TBSTATE_PRESSED)
        uItemState |= CDIS_SELECTED;

    if (!(state & TBSTATE_ENABLED))
        uItemState |= CDIS_DISABLED;

    if (state & TBSTATE_MARKED)
        uItemState |= CDIS_MARKED;

    if (state & TBSTATE_INDETERMINATE)
        uItemState |= CDIS_INDETERMINATE;

    return uItemState;
}

void FlushToolTipsMgrNow(PTBSTATE ptb);

void TB_ForceCreateTooltips(PTBSTATE ptb)
{
    if (ptb->ci.style & TBSTYLE_TOOLTIPS && !ptb->hwndToolTips)
    {
        TOOLINFO ti;
        // don't bother setting the rect because we'll do it below
        // in TBInvalidateItemRects;
        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND;
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = (UINT_PTR)ptb->ci.hwnd;
        ti.lpszText = 0;

#ifndef UNIX
        ptb->hwndToolTips = CreateWindow(c_szSToolTipsClass, NULL,
                                         WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                         ptb->ci.hwnd, NULL, HINST_THISDLL, NULL);
#else
        ptb->hwndToolTips = CreateWindowEx( WS_EX_MW_UNMANAGED_WINDOW, c_szSToolTipsClass, NULL,
                                         WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                         ptb->ci.hwnd, NULL, HINST_THISDLL, NULL);
#endif

        if (ptb->hwndToolTips) {
            int i;
            NMTOOLTIPSCREATED nm;

            CCSetInfoTipWidth(ptb->ci.hwnd, ptb->hwndToolTips);

            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                        (LPARAM)(LPTOOLINFO)&ti);

            nm.hwndToolTips = ptb->hwndToolTips;
            CCSendNotify(&ptb->ci, NM_TOOLTIPSCREATED, &nm.hdr);

            // don't bother setting the rect because we'll do it below
            // in TBInvalidateItemRects;
            ti.uFlags = 0;
            ti.lpszText = LPSTR_TEXTCALLBACK;

            for (i = 0; i < ptb->iNumButtons; i++) {
                if (!(ptb->Buttons[i].fsStyle & BTNS_SEP)) {
                    ti.uId = ptb->Buttons[i].idCommand;
                    SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                                (LPARAM)(LPTOOLINFO)&ti);
                }
            }

            FlushToolTipsMgrNow(ptb);
        }
    }
}

void TBRelayToToolTips(PTBSTATE ptb, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    TB_ForceCreateTooltips(ptb);
    if (ptb->hwndToolTips) {
        RelayToToolTips(ptb->hwndToolTips, ptb->ci.hwnd, wMsg, wParam, lParam);
    }
}


LRESULT ToolbarDragCallback(HWND hwnd, UINT code, WPARAM wp, LPARAM lp)
{
    PTBSTATE ptb = (PTBSTATE)GetWindowInt(hwnd, 0);
    LRESULT lres;

    switch (code)
    {
    case DPX_DRAGHIT:
        if (lp)
        {
            POINT pt;
            int item;
            pt.x = ((POINTL *)lp)->x;
            pt.y = ((POINTL *)lp)->y;
            MapWindowPoints(NULL, ptb->ci.hwnd, &pt, 1);
            item = TBHitTest(ptb, pt.x, pt.y);

            if (0 <= item && item < ptb->iNumButtons)
                lres = (LRESULT)ptb->Buttons[item].idCommand;
            else
                lres = (LRESULT)-1;
        }
        else
            lres = -1;
        break;

    case DPX_GETOBJECT:
        lres = (LRESULT)GetItemObject(&ptb->ci, TBN_GETOBJECT, &IID_IDropTarget, (LPNMOBJECTNOTIFY)lp);
        break;

    case DPX_SELECT:
        if ((int)wp >= 0)
        {
            NMTBHOTITEM nmhi;
            nmhi.idNew = (int) wp;
            if (!CCSendNotify(&ptb->ci, TBN_DRAGOVER, &nmhi.hdr))
            {
                SendMessage(ptb->ci.hwnd, TB_MARKBUTTON, wp,
                    MAKELPARAM((lp != DROPEFFECT_NONE), 0));
            }
        }
        lres = 0;
        break;

    default:
        lres = -1;
        break;
    }

    return lres;
}

int TBMixedButtonHeight(PTBSTATE ptb, int iIndex)
{
    int iHeight;
    LPTBBUTTONDATA ptbb = &(ptb->Buttons[iIndex]);

    if (ptbb->fsStyle & BTNS_SHOWTEXT)                      // text and icon
        iHeight = max(ptb->iDyBitmap, ptb->dyIconFont);
    else                                                    // icon, no text
        iHeight = ptb->iDyBitmap;

    return iHeight;
}

int TBMixedButtonsHeight(PTBSTATE ptb)
{
    int i;
    int iHeightMax = 0;
    int iHeight;
    ASSERT(ptb->ci.style & TBSTYLE_LIST);
    ASSERT(USE_MIXED_BUTTONS(ptb));
    for (i = 0; i < ptb->iNumButtons; i++) {
        iHeight = TBMixedButtonHeight(ptb, i);
        iHeightMax = max(iHeightMax, iHeight);
    }
    return iHeightMax;
}

int HeightWithString(PTBSTATE ptb, int h)
{
    if (USE_MIXED_BUTTONS(ptb))
    {
        int hMixed = TBMixedButtonsHeight(ptb);
        return (max(h, hMixed));
    }
    else if (ptb->ci.style & TBSTYLE_LIST)
        return (max(h, ptb->dyIconFont));
    else if (ptb->dyIconFont)
        return (h + ptb->dyIconFont + 1);
    else
        return (h);
}

int TBGetSepHeight(PTBSTATE ptb, LPTBBUTTONDATA pbtn)
{
    ASSERT(pbtn->fsStyle & BTNS_SEP);

    if (ptb->ci.style & (CCS_VERT | TBSTYLE_FLAT) )
        return pbtn->DUMMYUNION_MEMBER(cxySep);
    else
        return pbtn->DUMMYUNION_MEMBER(cxySep) * 2 / 3;
}

UINT TBWidthOfString(PTBSTATE ptb, LPTBBUTTONDATA ptbb, HDC hdc)
{
    UINT uiWidth = 0;

    LPTSTR pstr = TB_StrForButton(ptb, ptbb);
    if (pstr)
    {
        HDC hdcCreated = NULL;
        HFONT hOldFont;
        UINT uiStyle;
        RECT rcText = {0,0,1000,10};

        if (!hdc)
        {
            hdcCreated = GetDC(ptb->ci.hwnd);
            hdc = hdcCreated;
        }
        hOldFont = SelectObject(hdc, ptb->hfontIcon);

        uiStyle = DT_CALCRECT | TBGetDrawTextFlags(ptb, 0, ptbb);
        DrawText(hdc, pstr, -1, &rcText, uiStyle);

        uiWidth += rcText.right;

        SelectObject(hdc, hOldFont);
        if (hdcCreated)
            ReleaseDC(ptb->ci.hwnd, hdcCreated);
    }

    return uiWidth;
}

// TBDDArrowAdjustment(ptb, ptbb): the amount by which we change the width of
// this button to accomodate the drop-down arrow.  not necessarily the same as
// ptb->dxDDArrowChar.
int TBDDArrowAdjustment(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    int iAdjust = 0;

    if (TB_HasDDArrow(ptb, ptbb))
    {
        // If a whole dd, non-autosize button, then we'll just use the standard
        // button width which ought to have room for this button (i.e., return 0).

        if (!TB_HasTopDDArrow(ptb, ptbb) || BTN_IS_AUTOSIZE(ptb, ptbb))
        {
            iAdjust += (WORD)ptb->dxDDArrowChar;

            if (TB_HasUnsplitDDArrow(ptb, ptbb))
            {
                // subtract off a bit since there won't be a border
                // around dd arrow part of this button
                iAdjust -= 2 * g_cxEdge;

                if (ptbb->iBitmap != I_IMAGENONE)
                {
                    // nudge over a bit more to overlap bitmap border padding
                    iAdjust -= g_cxEdge;
                }
            }

            if (TB_HasTopDDArrow(ptb, ptbb))
            {
                // If string width >= icon width + iAdjust, then no need
                // to add extra space for the arrow.

                if ((int)TBWidthOfString(ptb, ptbb, NULL) >= ptb->iDxBitmap + iAdjust)
                    iAdjust = 0;
            }
        }
    }

    return max(iAdjust, 0);
}

int TBWidthOfButton(PTBSTATE ptb, LPTBBUTTONDATA pButton, HDC hdc)
{
    RECT rc;
    if (BTN_IS_AUTOSIZE(ptb, pButton)) {
        // if they've set this button for autosize, calculate it and cache
        // it in cx
        if (BTN_NO_SHOW_TEXT(ptb, pButton)) {
            pButton->cx = 0;
            goto CalcIconWidth;
        }

        if (pButton->cx == 0) {
            UINT uiStringWidth = TBWidthOfString(ptb, pButton, hdc);
            pButton->cx = (WORD) ptb->xPad + uiStringWidth;

            if (uiStringWidth) {
                // Since we have a string for this button, we need to add
                // some padding around it.
                if ((ptb->ci.style & TBSTYLE_LIST) && TB_HasSplitDDArrow(ptb, pButton))
                    pButton->cx += (WORD) ptb->iDropDownGap;
                else
                    pButton->cx += 2 * g_cxEdge;
            }

CalcIconWidth:
            if (pButton->iBitmap != I_IMAGENONE) {

                if (ptb->ci.style & TBSTYLE_LIST) {
                    pButton->cx += ptb->iDxBitmap + ptb->iListGap;
                    if (BTN_NO_SHOW_TEXT(ptb, pButton))
                        pButton->cx += g_cxEdge * 2;
                }
                else {
                    // Use wider of string width (pButton->cx so far) and bitmap width.
                    pButton->cx = max(pButton->cx, ptb->iDxBitmap + ptb->xPad);
                }
            }

            pButton->cx += (USHORT)TBDDArrowAdjustment(ptb, pButton);
        }
    }

    if (pButton->cx) {
        return (int)pButton->cx;
    } else if (pButton->fsStyle & BTNS_SEP) {
        if (ptb->ci.style & CCS_VERT) {
            GetWindowRect(ptb->ci.hwnd, &rc);
            return RECTWIDTH(rc);
        } else {
            // Compat: Corel (Font navigator) expects the separators to be
            // 8 pixels wide.  So do not return pButton->cxySep here, since
            // that can be calculated differently depending on the flat style.
            //
            // No.  owner draw items are added by specifying separator, and
            // the iBitmap width which is then copied down to cxySep.
            // the preserving of size for corel needs to be done at that point.
            return pButton->DUMMYUNION_MEMBER(cxySep);
        }
    } else if (!(TBSTYLE_EX_VERTICAL & ptb->dwStyleEx)) {
        return ptb->iButWidth + TBDDArrowAdjustment(ptb, pButton);
    } else {
        return ptb->iButWidth;
    }
}

UINT TBGetDrawTextFlags(PTBSTATE ptb, UINT uiStyle, TBBUTTONDATA* ptbb)
{
    if (ptb->nTextRows > 1)
        uiStyle |= DT_WORDBREAK | DT_EDITCONTROL;
    else
        uiStyle |= DT_SINGLELINE;


    if (ptb->ci.style & TBSTYLE_LIST)
    {
        uiStyle |= DT_LEFT | DT_VCENTER | DT_SINGLELINE;
    }
    else
    {
        uiStyle |= DT_CENTER;
    }

    uiStyle &= ~(ptb->uDrawTextMask);
    uiStyle |= ptb->uDrawText;
    if (ptbb->fsStyle & BTNS_NOPREFIX)
        uiStyle |= DT_NOPREFIX;

#ifndef KEYBOARDCUES
    // This flag tells User's DrawText/Ex NOT to show the prefixes at all
    // when rendering. This only works on NT5.
    if (!ptb->fShowPrefix && g_bRunOnNT5)
#else
    if (CCGetUIState(&(ptb->ci)) & UISF_HIDEACCEL)
#endif
    {
        uiStyle |= DT_HIDEPREFIX;
    }
    return uiStyle;
}

BOOL TBRecalc(PTBSTATE ptb)
{
    TEXTMETRIC tm = {0};
    int i;
    HDC hdc;
    int cxMax = 0, cxMask, cy;
    HFONT hOldFont=NULL;

    if (ptb->fRedrawOff) {
        // redraw is off; defer recalc until redraw is turned back on
        ptb->fRecalc = TRUE;
        return TRUE;    // The recalc "succeeded" - actual work will happen later
    }

    ptb->dyIconFont = 0;
    if (!TBHasStrings(ptb) || !ptb->nTextRows ) {

        cxMax = ptb->iDxBitmap;
        cxMask = cxMax;

    } else {

        SIZE size = {0};
        LPCTSTR pstr;
        RECT rcText = {0,0,0,0};
        int cxExtra = ptb->xPad;

        ptb->iButWidth = 0;

        hdc = GetDC(ptb->ci.hwnd);
        if (!hdc)
            return(FALSE);

        if (ptb->hfontIcon)
            hOldFont = SelectObject(hdc, ptb->hfontIcon);
        GetTextMetrics(hdc, &tm);
        if (ptb->nTextRows)
            ptb->dyIconFont = (tm.tmHeight * ptb->nTextRows) +
                (tm.tmExternalLeading * (ptb->nTextRows - 1)); // add an edge ?

        if (ptb->ci.style & TBSTYLE_LIST)
            cxExtra += ptb->iDxBitmap + ptb->iListGap;

        // default to the image size...
        cxMax = ptb->iDxBitmap;

        // walk strings to find max width
        for (i = 0; i < ptb->iNumButtons; i++)
        {
            if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                continue;

            if (BTN_IS_AUTOSIZE(ptb, &ptb->Buttons[i]))
                ptb->Buttons[i].cx = 0;

            pstr = TB_StrForButton(ptb, &ptb->Buttons[i]);
            if (pstr) 
            {
                if ( ptb->ci.iVersion < 5 )
                {
                    // we used to use GetTextExtentPoint instead of DrawText.  This function would include the width
                    // of the "&" character if it was present.  As a result, it returned larger values and thus created
                    // wider buttons.  Without this extra fudge certain buttons will be about 6 pixels too narrow.
                    GetTextExtentPoint(hdc, pstr, lstrlen(pstr), &size);
                }
                else
                {
                    // wordbreak is not allowed in the calcrect w/ singleline
                    UINT uiStyle = DT_CALCRECT | DT_SINGLELINE | (TBGetDrawTextFlags(ptb, 0, &ptb->Buttons[i]) & ~DT_WORDBREAK);
                    RECT rcTemp = {0,0,0,0};
                    rcTemp.bottom = ptb->dyIconFont;

                    DrawText(hdc, pstr, -1, &rcTemp, uiStyle);
                    size.cx = RECTWIDTH(rcTemp);
                    size.cy = RECTHEIGHT(rcTemp);
                    // BUGBUG: size.cy stuff is fishy -- last one wins
                }
            }
            else
            {
                size.cx = 0;
            }

            if (TB_HasTopDDArrow(ptb, &ptb->Buttons[i])) {
                int iBmpWithArrow = CX_TOP_FUDGE + ptb->iDxBitmap + ptb->dxDDArrowChar;
                size.cx = max(size.cx, iBmpWithArrow);
            }
            else if ((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) && 
                TB_HasDDArrow(ptb, &ptb->Buttons[i])) {

                // for vertical toolbars, buttons with drop-down arrows
                // are drawn with the same width as normal buttons, so
                // we need to figure them into our max width calculation.

                size.cx += ptb->dxDDArrowChar;
            }

            if (cxMax < size.cx)
                cxMax = size.cx;
        }

        // if cxMax is less than the iButMinWidth - dxBitmap (if LIST) then
        // cxMax = iButMinWidth
        if (ptb->iButMinWidth && (ptb->iButMinWidth > (cxMax + cxExtra)))
            cxMax = ptb->iButMinWidth - cxExtra;

        cxMask = cxMax;

        // Is the cxMax +  dxBitmap (if LIST) more than the max width ?
        if (ptb->iButMaxWidth && (ptb->iButMaxWidth < (cxMax + cxExtra)))
        {
            int cyMax = 0;
            int cxTemp = 0;

            cxMax = ptb->iButMaxWidth - cxExtra;

            // But leave cxMask at its old value since AUTOSIZE buttons
            // are exempt from button truncation.  This exemption is a bug,
            // but IE4 shipped that way so we're stuck with it.  (You can
            // tell it's a bug because we go ahead and flip TBSTATE_ELLIPSIS
            // even on AUTOSIZE buttons, only to "forget" about the ellipsis
            // in TBWidthOfString().)

            // walk strings to set the TBSTATE_ELLIPSES
            for (i = 0; i < ptb->iNumButtons; i++)
            {
                BOOL fEllipsed = FALSE;
                UINT uiStyle;

                if (ptb->Buttons[i].fsState & TBSTATE_HIDDEN)
                    continue;

                if (BTN_NO_SHOW_TEXT(ptb, &ptb->Buttons[i]))
                    pstr = NULL;
                else
                {
                    pstr = TB_StrForButton(ptb, &ptb->Buttons[i]);
                    uiStyle = DT_CALCRECT | TBGetDrawTextFlags(ptb, 0, &ptb->Buttons[i]);
                }

                if (pstr) 
                {
                    int cxMaxText;
                    if ((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) && 
                        TB_HasDDArrow(ptb, &ptb->Buttons[i]))
                    {
                        // if a drop-down button on a vertical toolbar,
                        // need to make space for drop-down arrow
                        cxMaxText = cxMax - ptb->dxDDArrowChar;
                    } 
                    else 
                    {
                        cxMaxText = cxMax;
                    }
                    // DrawText doesn't like it when cxMaxText <= 0
                    cxMaxText = max(cxMaxText, 1);

                    rcText.bottom = ptb->dyIconFont;
                    rcText.right = cxMaxText;

                    DrawText(hdc, pstr, -1, &rcText, uiStyle);
                    if (ptb->nTextRows > 1)
                    {
                        // width is width of text plus width we might
                        // have lopped off for drop-down arrow
                        int cx = rcText.right + (cxMax - cxMaxText);
                        if (cx > cxTemp)
                        {
                            // this is our new multiline text hack max
                            cxTemp = cx;
                        }
                        fEllipsed = (BOOL)(rcText.bottom > ptb->dyIconFont);
                    }
                    else
                        fEllipsed = (BOOL)(rcText.right > cxMaxText);

                    if (cyMax < rcText.bottom)
                        cyMax = rcText.bottom;
                }

                if (fEllipsed)
                    ptb->Buttons[i].fsState |= TBSTATE_ELLIPSES;
                else
                    ptb->Buttons[i].fsState &= ~TBSTATE_ELLIPSES;
            }

            if (cxTemp && (ptb->nTextRows > 1 ))
                cxMax = cxTemp;

            // Set the text height to the tallest text, with the top end being the number
            // of rows specified by MAXTEXTROWS
            if (ptb->dyIconFont > cyMax)
                ptb->dyIconFont = cyMax;
        }
        else
        {
            for (i = 0; i < ptb->iNumButtons; i++)
                ptb->Buttons[i].fsState &= ~TBSTATE_ELLIPSES;

            if ((ptb->nTextRows) && ptb->iNumButtons && (ptb->dyIconFont > size.cy))
                ptb->dyIconFont = size.cy;
        }

        if (ptb->iButMinWidth && (ptb->iButMinWidth > (cxMax + cxExtra)))
            cxMax = ptb->iButMinWidth - cxExtra;

        if (hOldFont)
            SelectObject(hdc, hOldFont);
        ReleaseDC(ptb->ci.hwnd, hdc);
    }

    //
    //  Need to call GrowToolbar twice, once to grow the mask, and again
    //  to grow the buttons.  (Yes, this is sick.)
    //
    cy = HeightWithString(ptb, ptb->iDyBitmap);

    if (!GrowToolbar(ptb, max(cxMax, cxMask), cy, GT_INSIDE | GT_MASKONLY))
        return(FALSE);

    return(GrowToolbar(ptb, cxMax, cy, GT_INSIDE));
}

BOOL TBChangeFont(PTBSTATE ptb, WPARAM wParam, HFONT hFont)
{
    LOGFONT lf;
    BOOL fWasFontCreated = ptb->fFontCreated;

    if ((wParam != 0) && (wParam != SPI_SETICONTITLELOGFONT) && (wParam != SPI_SETNONCLIENTMETRICS))
        return(FALSE);

    if (!SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0))
        return(FALSE);

    if (!hFont) {
        if (!(hFont = CreateFontIndirect(&lf)))
            return(FALSE);
        ptb->fFontCreated = TRUE;
    } else {
        ptb->fFontCreated = FALSE;
    }

    if (ptb->hfontIcon && fWasFontCreated)
        DeleteObject(ptb->hfontIcon);

    ptb->hfontIcon = hFont;

    return(TBRecalc(ptb));
}

void TBSetFont(PTBSTATE ptb, HFONT hFont, BOOL fInval)
{
    TBChangeFont(ptb, 0, hFont);
    if (fInval)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

}

HWND WINAPI CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
            HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons,
            int iNumButtons, int dxButton, int dyButton,
            int dxBitmap, int dyBitmap, UINT uStructSize)
{
    HWND hwndToolbar = CreateWindow(c_szToolbarClass, NULL, WS_CHILD | ws,
          0, 0, 100, 30, hwnd, IntToPtr_(HMENU, wID), HINST_THISDLL, NULL);
    if (hwndToolbar)
    {
        TBADDBITMAP tbab;

        // Need to send messages, instead of call our internal functions, because we may have created
        // a v6 window above.
        SendMessage(hwndToolbar, TB_BUTTONSTRUCTSIZE, (WPARAM)uStructSize, (LPARAM)0);

        if ((dxBitmap && dyBitmap &&
            !SendMessage(hwndToolbar, TB_SETBITMAPSIZE, (WPARAM)0, MAKELPARAM(dxBitmap, dyBitmap))) ||
            (dxButton && dyButton &&
            !SendMessage(hwndToolbar, TB_SETBITMAPSIZE, (WPARAM)0, MAKELPARAM(dxButton, dyButton))))
        {
            //!!!! do we actually need to deal with this?
            DestroyWindow(hwndToolbar);
            hwndToolbar = NULL;
            goto Error;
        }
        
        tbab.hInst = hBMInst;
        tbab.nID = wBMID;
        SendMessage(hwndToolbar, TB_ADDBITMAP, (WPARAM)nBitmaps, (LPARAM)&tbab);

        SendMessage(hwndToolbar, TB_ADDBUTTONS, (WPARAM)iNumButtons, (LPARAM)lpButtons);
    }
Error:
    return hwndToolbar;
}

/* This is no longer declared in COMMCTRL.H.  It only exists for compatibility
** with existing apps; new apps must use CreateToolbarEx.
*/
HWND WINAPI CreateToolbar(HWND hwnd, DWORD ws, UINT wID, int nBitmaps, HINSTANCE hBMInst, UINT_PTR wBMID, LPCTBBUTTON lpButtons, int iNumButtons)
{
    // old-style toolbar, so no divider.
    return CreateToolbarEx(hwnd, ws | CCS_NODIVIDER, wID, nBitmaps, hBMInst, wBMID,
                lpButtons, iNumButtons, 0, 0, 0, 0, sizeof(OLDTBBUTTON));
}

#pragma code_seg(CODESEG_INIT)

BOOL InitToolbarClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, c_szToolbarClass, &wc))
    {
        wc.lpfnWndProc   = ToolbarWndProc;

        wc.lpszClassName = c_szToolbarClass;
        wc.style     = CS_DBLCLKS | CS_GLOBALCLASS;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(PTBSTATE);
        wc.hInstance     = hInstance;   // use DLL instance if in DLL
        wc.hIcon     = NULL;
        wc.hCursor   = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
        wc.lpszMenuName  = NULL;

        if (!RegisterClass(&wc))
            return FALSE;
    }

    return TRUE;
}
#pragma code_seg()

void PatB(HDC hdc,int x,int y,int dx,int dy, DWORD rgb)
{
    RECT    rc;

    SetBkColor(hdc,rgb);
    rc.left   = x;
    rc.top    = y;
    rc.right  = x + dx;
    rc.bottom = y + dy;

    ExtTextOut(hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
}

#ifndef UNICODE
// Get actual number of characters that will be drawn into the given
// rectangle by DrawTextEx. This is to avoid using DT_END_ELLIPSIS
// on FarEast Win95 (golden) as it could sometimes put more characters
// than what the rect actually could hold.
UINT GetLengthDrawn(PTBSTATE ptb, HDC hdc, LPSTR psz, int cch, LPRECT lprc, UINT uiStyle)
{
    DRAWTEXTPARAMS dtParams = {0};
    HDC hdcMem;
    HFONT hfontOld;

    ASSERT(psz);
    ASSERT(lprc);
    ASSERT(ptb);

    hdcMem = CreateCompatibleDC(hdc);

    hfontOld=SelectObject(hdcMem, ptb->hfontIcon);

    dtParams.cbSize = sizeof (dtParams);
    DrawTextEx(hdcMem, (LPSTR)psz, cch, lprc, uiStyle, &dtParams);

    SelectObject(hdcMem, hfontOld);
    DeleteDC(hdcMem);

    return dtParams.uiLengthDrawn;
}
#endif
// Parameter fHighlight determines whether to draw text highlighted, for
// new TBSTATE_MARKED
//
void DrawString(HDC hdc, int x, int y, int dx, int dy, PTSTR pszString,
                            BOOL fHighlight, TBDRAWITEM * ptbdraw)
{
    int oldMode;
    COLORREF oldBkColor;
    COLORREF oldTextColor;
    RECT rcText;
    UINT uiStyle = 0;
    PTBSTATE ptb;
    LPTBBUTTONDATA ptbb;

    ASSERT(ptbdraw);

    ptb = ptbdraw->ptb;
    ptbb = ptbdraw->pbutton;

    if (!(ptb->ci.style & TBSTYLE_LIST) && ((ptb->iDyBitmap + ptb->yPad + g_cyEdge) >= ptb->iButHeight))
        // there's no room to show the text -- bail out
        return;

    if (BTN_NO_SHOW_TEXT(ptb, ptbb))
        // don't show text for this button -- bail out
        return;

    if (fHighlight)
    {
        oldMode = SetBkMode (hdc, ptbdraw->tbcd.nHLStringBkMode);
        oldBkColor = SetBkColor (hdc, ptbdraw->tbcd.clrMark);
        oldTextColor = SetTextColor (hdc, ptbdraw->tbcd.clrTextHighlight);
    }
    else
        oldMode = SetBkMode(hdc, ptbdraw->tbcd.nStringBkMode);

    uiStyle = TBGetDrawTextFlags(ptb, DT_END_ELLIPSIS, ptbb);

    // If we're ex_vertical want to center the text
    if (!(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
    {
        if (ptb->ci.style & TBSTYLE_LIST)
        {
            dy = max(ptb->dyIconFont, ptb->iDyBitmap);
        }
        else
        {
            if (!dy || ptb->dyIconFont < dy)
                dy = ptb->dyIconFont;
        }
    }


    SetRect( &rcText, x, y, x + dx, y + dy);

#ifndef UNICODE
    if (g_fDBCSEnabled && !g_bRunOnMemphis
       && (ptbb->fsState & TBSTATE_ELLIPSES)
       && (ptb->nTextRows > 1))
    {
        LPSTR psz;
        UINT uiLengthDrawn;
        // FarEast Win95 has a bug that DT_END_ELLIPSIS can
        // miscalculate the number of characters that fit in
        // the specified rectangle. We have to avoid to use
        // DT_END_ELLIPSIS for the platform putting ellipsis
        // ourselves. Memphis will fix the bug so we won't do
        // this for them.
        //
        uiStyle &= ~DT_END_ELLIPSIS;

        psz = StrDup(pszString);
        if (psz)
        {
            uiLengthDrawn = GetLengthDrawn(ptb, hdc, psz, -1, &rcText, uiStyle);
            if (uiLengthDrawn > 3)
            {
                TruncateString(psz, uiLengthDrawn-2);
                lstrcat(psz, "...");
            }
            DrawText(hdc, (LPTSTR)psz, -1, &rcText, uiStyle);
            LocalFree(psz);
        }
    }
    else
#endif
    DrawText(hdc, (LPTSTR)pszString, -1, &rcText, uiStyle);

    SetBkMode(hdc, oldMode);
    if (fHighlight)
    {
        SetBkColor (hdc, oldBkColor);
        SetTextColor (hdc, oldTextColor);
    }
}

LPTSTR TB_StrForButton(PTBSTATE ptb, LPTBBUTTONDATA pTBButton)
{
    if (TBISSTRINGPTR(pTBButton->iString))
        return (LPTSTR)pTBButton->iString;
    else {
        if (pTBButton->iString != -1 &&
            pTBButton->iString < ptb->nStrings)
            return ptb->pStrings[pTBButton->iString];
        return NULL;
    }
}

HIMAGELIST TBGetImageList(PTBSTATE ptb, int iMode, int iIndex)
{
    HIMAGELIST himl = NULL;

    ASSERT(iMode <= HIML_MAX);
    if (iIndex >= 0 && iIndex < ptb->cPimgs) {
        himl = ptb->pimgs[iIndex].himl[iMode];
    }

    return himl;
}

//
//  v5 toolbars support multiple imagelists.  To use images from an alternate
//  imagelist, set the imagelist handle via TB_SETIMAGELIST(iIndex, himlAlt)
//  and set your button's iImage to MAKELONG(iImage, iIndex).
//
//  APP COMPAT:  GroupWise 5.5 passes garbage as the iIndex (even though it
//  was documented as "must be zero"), so we enable this functionality
//  only for v5 toolbars.  IE4 ignored the iIndex, which is why they got
//  away with it up until now.
//
#define MAX_TBIMAGELISTS 20             // arbitrary limit

HIMAGELIST TBSetImageList(PTBSTATE ptb, int iMode, int iIndex, HIMAGELIST himl)
{
    HIMAGELIST himlOld = NULL;

    // Watch out for app compat or for totally bogus parameters
    if (ptb->ci.iVersion < 5 || iIndex < 0 || iIndex >= MAX_TBIMAGELISTS)
        iIndex = 0;

    ASSERT(iMode <= HIML_MAX);
    if (iIndex >= ptb->cPimgs) {
        // asking for more than we have, realloc.

        void *p = CCLocalReAlloc(ptb->pimgs, (iIndex+1) * SIZEOF(TBIMAGELISTS));
        if (p) {
            ptb->pimgs = (TBIMAGELISTS*)p;
            ZeroMemory(&ptb->pimgs[ptb->cPimgs], (iIndex + 1 - ptb->cPimgs) * sizeof(TBIMAGELISTS));
            ptb->cPimgs = iIndex + 1;  // iIndex is 0 based, but cPimgs is 1 based (it's a count, not an index)
        }
    }

    if (iIndex < ptb->cPimgs) {
        himlOld = ptb->pimgs[iIndex].himl[iMode];
        ptb->pimgs[iIndex].himl[iMode] = himl;
    }

    return himlOld;
}

// create a mono bitmap mask:
//   1's where color == COLOR_BTNFACE || COLOR_3DHILIGHT
//   0's everywhere else

void CreateMask(int xoffset, int yoffset, int dx, int dy, BOOL fDrawGlyph, TBDRAWITEM * ptbdraw)
{
    LPTSTR psz;
    IMAGELISTDRAWPARAMS imldp;
    HIMAGELIST himl;
    PTBSTATE ptb = ptbdraw->ptb;
    LPTBBUTTONDATA pTBButton = ptbdraw->pbutton;
    // initalize whole area with 1's
    PatBlt(ptb->hdcMono, 0, 0, dx, dy, WHITENESS);

    // create mask based on color bitmap
    // convert this to 1's

    himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex);
    if (fDrawGlyph && himl)
    {
        imldp.cbSize = sizeof(imldp);
        imldp.himl   = himl;
        imldp.i      = ptbdraw->iImage;
        imldp.hdcDst = ptb->hdcMono;
        imldp.x      = xoffset;
        imldp.y      = yoffset;
        imldp.cx     = 0;
        imldp.cy     = 0;
        imldp.xBitmap= 0;
        imldp.yBitmap= 0;
        imldp.rgbBk  = g_clrBtnFace;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_ROP | ILD_MASK;
        imldp.dwRop  = SRCCOPY;

        ImageList_DrawIndirect(&imldp);

        imldp.fStyle = ILD_ROP | ILD_IMAGE;
        imldp.rgbBk  = g_clrBtnHighlight;
        imldp.dwRop  = SRCPAINT;
        ImageList_DrawIndirect(&imldp);
    }

    psz = TB_StrForButton(ptb, pTBButton);
    if (psz)
    {
        xoffset = 1;
        yoffset = 1;

        if (ptb->ci.style & TBSTYLE_LIST)
        {
            if (!(pTBButton->iBitmap == I_IMAGENONE &&
                (pTBButton->fsStyle & BTNS_AUTOSIZE)))
            {
                xoffset += ptb->iDxBitmap + ptb->iListGap;
                dx -= ptb->iDxBitmap + ptb->iListGap;
            }
        }
        else 
        {
            yoffset += ptb->iDyBitmap + 1;
            dy -= ptb->iDyBitmap + 1;
        }

        if (!(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
        {
            dx -= g_cxEdge;
            dy -= g_cyEdge;
        }

        // The FALSE in 4th param is so we don't get a box in the mask.
        DrawString(ptb->hdcMono, xoffset, yoffset, dx, dy, psz,
                   FALSE, ptbdraw);
    }
}

void DrawBlankButton(HDC hdc, int x, int y, int dx, int dy, TBDRAWITEM * ptbdraw)
{
    RECT r1;
    UINT state;

    // face color
    // The Office toolbar sends us bitmaps that are smaller than they claim they are
    // So we need to do the PatB or the window background shows through around the
    // edges of the button bitmap  -jjk
    ASSERT(ptbdraw);

    state = ptbdraw->state;

    if (!(state & TBSTATE_CHECKED))
        PatB(hdc, x, y, dx, dy, ptbdraw->tbcd.clrBtnFace);

    if  ( !(ptbdraw->dwCustom & TBCDRF_NOEDGES))
    {
        r1.left = x;
        r1.top = y;
        r1.right = x + dx;
        r1.bottom = y + dy;

        DrawEdge(hdc, &r1, (state & (TBSTATE_CHECKED | TBSTATE_PRESSED)) ? EDGE_SUNKEN : EDGE_RAISED, BF_RECT | BF_SOFT);
    }
}

// these are raster ops
#define DSPDxax     0x00E20746  // BUGBUG: not used
#define PSDPxax     0x00B8074A

HWND g_hwndDebug = NULL;

void DrawFace(HDC hdc, int x, int y, int offx, int offy, int dxText,
              int dyText, TBDRAWITEM * ptbdraw)
{
    LPTSTR psz;
    IMAGELISTDRAWPARAMS imldp;
    BOOL fHotTrack = FALSE;
    UINT state;
    PTBSTATE ptb;
    LPTBBUTTONDATA ptButton;
    BOOL fImage;        // !fImage means no image (as opposed to a blank image)

    ASSERT(ptbdraw);

    ptb = ptbdraw->ptb;
    ptButton = ptbdraw->pbutton;

    // AutosizeTextNoImage
    if ((ptb->ci.style & TBSTYLE_LIST) &&
        (ptbdraw->iImage == I_IMAGENONE) &&
        (ptButton->fsStyle & BTNS_AUTOSIZE)) {
        fImage = FALSE;
    } else {
        fImage = TRUE;
    }

    state = ptbdraw->state;

    if (state & TBSTATE_ENABLED)
    {
        fHotTrack = ptbdraw->fHotTrack;

        if (ptb->ci.style & TBSTYLE_FLAT)
        {
            UINT bdr = 0;

            if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED))
                bdr = BDR_SUNKENOUTER;
            else if (fHotTrack)
                bdr = BDR_RAISEDINNER;

            if (bdr)
            {
                RECT rc;
                TB_GetItemRect(ptb, (UINT)(ptButton - ptb->Buttons), &rc);

                if (TB_HasSplitDDArrow(ptb, ptButton))
                    rc.right -= ptb->dxDDArrowChar;

                if (!(ptbdraw->dwCustom & TBCDRF_NOEDGES) && ptb)
                    CCDrawEdge(hdc, &rc, bdr, BF_RECT, &(ptb->clrsc));
            }
        }
    }

    imldp.himl = NULL;

    if (fHotTrack || (state & TBSTATE_CHECKED)) {
        imldp.himl   = TBGetImageList(ptb, HIML_HOT, ptbdraw->iIndex);
        if (!imldp.himl)
            imldp.himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex);
    } else if (DRAW_MONO_BTN(ptb, state) && (imldp.himl = TBGetImageList(ptb, HIML_DISABLED, ptbdraw->iIndex))) {
        // assigned in if statement
    } else if (imldp.himl = TBGetImageList(ptb, HIML_NORMAL, ptbdraw->iIndex)) {
        // assigned in if statement
    }

    if (imldp.himl && (ptbdraw->iImage != -1) && fImage)
    {
        COLORREF rgbBk = ptbdraw->tbcd.clrBtnFace;
        if (ptb->ci.style & TBSTYLE_TRANSPARENT) 
            rgbBk = CLR_NONE;
        
        if (ptb->dwStyleEx & TBSTYLE_EX_INVERTIBLEIMAGELIST)
            rgbBk = CLR_DEFAULT;

        imldp.cbSize = sizeof(imldp);
        imldp.i      = ptbdraw->iImage;
        imldp.hdcDst = hdc;
        imldp.x      = x + offx;
        imldp.y      = y + offy;
        imldp.cx     = 0;
        imldp.cy     = 0;
        imldp.xBitmap= 0;
        imldp.yBitmap= 0;
        imldp.rgbBk  = rgbBk;
        imldp.rgbFg  = CLR_DEFAULT;
        imldp.fStyle = ILD_NORMAL;
        if (state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE))
            imldp.fStyle = ILD_TRANSPARENT;

#ifdef TBHIGHLIGHT_GLYPH
        if ((state & TBSTATE_MARKED) && !(ptbdraw->dwCustom & TBCDRF_NOMARK))
            imldp.fStyle = ILD_TRANSPARENT | ILD_BLEND50;
#endif

        if (ptbdraw->dwCustom & TBCDRF_BLENDICON)
            imldp.fStyle = ILD_TRANSPARENT | ILD_BLEND50;

        ImageList_DrawIndirect(&imldp);
#ifdef DEBUG
        if (g_hwndDebug == ptb->ci.hwnd) {
            imldp.hdcDst = GetDC(NULL);
            ImageList_DrawIndirect(&imldp);
            ReleaseDC(NULL, imldp.hdcDst);
        }
#endif
    }

    psz = TB_StrForButton(ptb, ptButton);
    if (psz)
    {
        BOOL bHighlight = (state & TBSTATE_MARKED) && (ptb->ci.style & TBSTYLE_LIST) &&
                          !(ptbdraw->dwCustom & TBCDRF_NOMARK);

        if ((state & (TBSTATE_PRESSED | TBSTATE_CHECKED)) &&
            !(ptbdraw->dwCustom & TBCDRF_NOOFFSET))
        {
            x++;
            if (ptb->ci.style & TBSTYLE_LIST)
                y++;
        }

        if (ptb->ci.style & TBSTYLE_LIST)
        {
            if (fImage)
            {
                x += ptb->iDxBitmap + ptb->iListGap;
                dxText -= ptb->iDxBitmap + ptb->iListGap;
            }
            else
            {
                // fudge for I_IMAGENONE buttons
                x += g_cxEdge;
            }
        }
        else
        {
            y += offy + ptb->iDyBitmap;
            dyText -= offy + ptb->iDyBitmap;
        }

        DrawString(hdc, x + 1, y + 1, dxText, dyText, psz, bHighlight, ptbdraw);
    }
}

void InitTBDrawItem(TBDRAWITEM * ptbdraw, PTBSTATE ptb, LPTBBUTTONDATA pbutton,
                    UINT state, BOOL fHotTrack, int dxText, int dyText)
{
    NMTBCUSTOMDRAW * ptbcd;
    NMCUSTOMDRAW * pnmcd;

    ASSERT(ptbdraw);

    ptbdraw->ptb = ptb;
    ptbdraw->pbutton = pbutton;
    ptbdraw->fHotTrack = fHotTrack;
    ptbdraw->iIndex = GET_HIML_INDEX(pbutton->DUMMYUNION_MEMBER(iBitmap));
    ptbdraw->iImage = GET_IMAGE_INDEX(pbutton->DUMMYUNION_MEMBER(iBitmap));
    ptbdraw->state = state;

    ptbcd = &ptbdraw->tbcd;

    ptbcd->hbrMonoDither = g_hbrMonoDither;
    ptbcd->hbrLines = GetStockObject(BLACK_BRUSH);
    ptbcd->hpenLines = GetStockObject(BLACK_PEN);
    ptbcd->clrMark = g_clrHighlight;
    ptbcd->clrBtnHighlight = g_clrBtnHighlight;
    ptbcd->clrTextHighlight = g_clrHighlightText;
    ptbcd->clrBtnFace = g_clrBtnFace;
    ptbcd->nStringBkMode = TRANSPARENT;
    ptbcd->nHLStringBkMode = OPAQUE;
    ptbcd->clrText = g_clrBtnText;
    SetRect(&ptbcd->rcText, 0, 0, dxText, dyText);

    pnmcd = (NMCUSTOMDRAW *)ptbcd;

    pnmcd->uItemState = CDISFromState(state);

#ifdef KEYBOARDCUES
#if 0
    // BUGBUG: Custom draw stuff for UISTATE (stephstm)
    if (CCGetUIState(&(ptb->ci), KC_TBD))
        pnmcd->uItemState |= CDIS_SHOWKEYBOARDCUES;
#endif
#endif
    if ((ptb->ci.style & TBSTYLE_FLAT) && fHotTrack)
        pnmcd->uItemState |= CDIS_HOT;
}

void DrawButton(HDC hdc, int x, int y, PTBSTATE ptb, LPTBBUTTONDATA ptButton, BOOL fActive)
{
    // BUGBUG: cleanup -- separate layout calculation & rendering

    int yOffset;
    HBRUSH hbrOld;
    UINT state;
    int dxFace, dyFace;
    int dxText, dyText;
    int xCenterOffset;
    int dx = TBWidthOfButton(ptb, ptButton, hdc);
    HFONT oldhFont;
    int dy = ptb->iButHeight;
    TBDRAWITEM tbdraw = { 0 };
    NMTBCUSTOMDRAW * ptbcd = &tbdraw.tbcd;
    NMCUSTOMDRAW * pnmcd = (NMCUSTOMDRAW *)ptbcd;
    COLORREF clrSave;
    BOOL fHotTrack;
    HFONT hFontNoAntiAlias = NULL;

    state = (UINT)ptButton->fsState;
    // make local copy of state and do proper overriding
    if (state & TBSTATE_INDETERMINATE) {
        if (state & TBSTATE_PRESSED)
            state &= ~TBSTATE_INDETERMINATE;
        else if (state & TBSTATE_ENABLED)
            state = TBSTATE_INDETERMINATE;
        else
            state &= ~TBSTATE_INDETERMINATE;
    }

    if (!fActive) {
        state &= ~TBSTATE_ENABLED;
    }

    fHotTrack = TBIsHotTrack(ptb, ptButton, state);

    pnmcd->hdc = hdc;
    pnmcd->dwItemSpec = ptButton->idCommand;
    pnmcd->uItemState = 0;
    pnmcd->lItemlParam = (LPARAM)ptButton->dwData;
    SetRect(&pnmcd->rc, x, y, x + dx, y + dy);

    dxText = dx - (3 * g_cxEdge);

    if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
    {
        dyText = dy;
    }
    else
    {
        dyText = dy - (2 * g_cyEdge);
    }

    InitTBDrawItem(&tbdraw, ptb, ptButton, state, fHotTrack, dxText, dyText);

    tbdraw.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, (NMCUSTOMDRAW *)ptbcd);

    // We gotta update our concept of hotness
    tbdraw.fHotTrack = fHotTrack = pnmcd->uItemState & CDIS_HOT;

    if (!(tbdraw.dwCustom & CDRF_SKIPDEFAULT ))
    {
        // Get the state back from what custom draw may have set
        state = tbdraw.state = StateFromCDIS(pnmcd->uItemState);

        dxFace = dx - (2 * g_cxEdge);
        dyFace = dy - (2 * g_cyEdge);
        dxText = ptbcd->rcText.right - ptbcd->rcText.left;
        dyText = ptbcd->rcText.bottom - ptbcd->rcText.top;

        if (TB_HasDDArrow(ptb, ptButton) && !TB_HasTopDDArrow(ptb, ptButton)) {
            int iAdjust = TBDDArrowAdjustment(ptb, ptButton);
            dxFace -= iAdjust;
            dxText -= iAdjust;
        }

        // Should we display the font using the GDI AntiAliasing?
        if (!ptb->fAntiAlias)
        {
            // No. Must be doing drag and drop. We don't want to AntiAlias because the
            // Purple color key will show through and it looks ugly.
            LOGFONT lfFont;

            if (GetObject(ptb->hfontIcon, sizeof(lfFont), &lfFont))
            {
                lfFont.lfQuality = NONANTIALIASED_QUALITY;
                hFontNoAntiAlias = CreateFontIndirect(&lfFont);
            }
        }

        if (hFontNoAntiAlias)
            oldhFont = SelectObject(hdc, hFontNoAntiAlias);
        else
            oldhFont = SelectObject(hdc, ptb->hfontIcon);

        clrSave = SetTextColor(hdc, ptbcd->clrText);

        if (!(ptb->ci.style & TBSTYLE_FLAT))
            DrawBlankButton(hdc, x, y, dx, dy, &tbdraw);


        // move coordinates inside border and away from upper left highlight.
        // the extents change accordingly.
        x += g_cxEdge;
        y += g_cyEdge;

        if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
        {
            yOffset = (ptb->iButHeight - ptb->iDyBitmap) / 2;
        }
        else
        {
            // calculate offset of face from (x,y).  y is always from the top,
            // so the offset is easy.  x needs to be centered in face.
            // center it taking the padding into account the padding area
            yOffset = (ptb->yPad - (2 * g_cyEdge)) / 2;
        }

        if (yOffset < 0)
            yOffset = 0;


        if ((ptb->ci.style & TBSTYLE_LIST) && !BTN_NO_SHOW_TEXT(ptb, ptButton)) {
            xCenterOffset = ptb->xPad / 2;
        } else if (TB_HasTopDDArrow(ptb, ptButton)) {
            //
            // Layout of "top dropdown" buttons looks like this:
            //
            //       icon            
            // fudge   |  dropdown arrow
            //    |    |    |
            //    v    v    v
            // +-+-+-------+--+-+
            // | | |       |  | |
            // | | |       |  | |
            // +-+-+-------+--+-+
            // |     <text>     |
            // +----------------+
            //
            // |<--- dxFace --->|
            //
            // xCenterOffset is the offset at which to start drawing the icon.
            //
            xCenterOffset = (dxFace + CX_TOP_FUDGE - (ptb->iDxBitmap + ptb->dxDDArrowChar)) / 2;
        } else {
            xCenterOffset = (dxFace - ptb->iDxBitmap) / 2;
        }

        if (state & (TBSTATE_PRESSED | TBSTATE_CHECKED) &&
            !(tbdraw.dwCustom & TBCDRF_NOOFFSET))
        {
            // pressed state moves down and to the right
            xCenterOffset++;
            yOffset++;
        }


        // draw the dithered background
        if  ((!fHotTrack || ptb->ci.iVersion < 5) &&
             (((state & (TBSTATE_CHECKED | TBSTATE_INDETERMINATE)) ||
              ((state & TBSTATE_MARKED) &&
               !(ptb->ci.style & TBSTYLE_FLAT) &&
               !(tbdraw.dwCustom & TBCDRF_NOMARK)))))
        {

            //Custom Draw can set hbrMonoDither to be NULL. Validate it before using it
            hbrOld = ptbcd->hbrMonoDither ? SelectObject(hdc, ptbcd->hbrMonoDither) : NULL;
            if (hbrOld)
            {
                COLORREF clrText, clrBack;

#ifdef TBHIGHLIGHT_BACK
                if (state & TBSTATE_MARKED)
                    clrText = SetTextColor(hdc, ptbcd->clrMark);
                else
#endif
                clrText = SetTextColor(hdc, ptbcd->clrBtnHighlight); // 0 -> 0
                clrBack = SetBkColor(hdc, ptbcd->clrBtnFace);        // 1 -> 1

                // only draw the dither brush where the mask is 1's
                PatBlt(hdc, x, y, dxFace, dyFace, PATCOPY);

                SelectObject(hdc, hbrOld);
                SetTextColor(hdc, clrText);
                SetBkColor(hdc, clrBack);
            }
        }

        // Paint the background of the hot-tracked item if the
        // custom draw said so
        if ((tbdraw.dwCustom & TBCDRF_HILITEHOTTRACK) && fHotTrack)
        {
            PatB(hdc, pnmcd->rc.left, pnmcd->rc.top,
                 pnmcd->rc.right - pnmcd->rc.left, pnmcd->rc.bottom - pnmcd->rc.top,
                 ptbcd->clrHighlightHotTrack);
        }

        tbdraw.iImage = ptButton->DUMMYUNION_MEMBER(iBitmap);
        if((ptButton->DUMMYUNION_MEMBER(iBitmap) == I_IMAGECALLBACK) && ptb->fHimlNative)
        {
            NMTBDISPINFO  tbgdi = {0};
            tbgdi.dwMask  = TBNF_IMAGE;
            TBGetItem(ptb,ptButton,&tbgdi);
            tbdraw.iImage = tbgdi.iImage;
        }
        tbdraw.iIndex = GET_HIML_INDEX(tbdraw.iImage);
        tbdraw.iImage = GET_IMAGE_INDEX(tbdraw.iImage);

        // Now put on the face.
        // TODO: Validate himlDisabled and ensure that the index is in range
        if (!DRAW_MONO_BTN(ptb, state) ||
            TBGetImageList(ptb, HIML_DISABLED, tbdraw.iIndex))
        {
            // regular version
            int yStart = y;

            if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
                yStart -= g_cyEdge;

            DrawFace(hdc, x, yStart, xCenterOffset, yOffset, dxText, dyText, &tbdraw);
        }

        if (DRAW_MONO_BTN(ptb, state))
        {
            HBITMAP hbmOld;

            //initialize the monochrome dc
            if (!ptb->hdcMono) {
                ptb->hdcMono = CreateCompatibleDC(hdc);
                if (!ptb->hdcMono)
                    return;
                SetTextColor(ptb->hdcMono, 0L);
                SelectObject(ptb->hdcMono, ptb->hfontIcon);
            }

            hbmOld = SelectObject(ptb->hdcMono, ptb->hbmMono);

            //
            // If we a mirrored DC, mirror the Memory DC so that
            // text written on the bitmap won't get flipped.
            //
            if ((IS_DC_RTL_MIRRORED(hdc)) &&
                (!(IS_DC_RTL_MIRRORED(ptb->hdcMono))))
            {
                SET_DC_RTL_MIRRORED(ptb->hdcMono);
            }


            // disabled version (or indeterminate)
            CreateMask(xCenterOffset, yOffset, dxFace, dyFace, (TBGetImageList(ptb, HIML_DISABLED, tbdraw.iIndex) == NULL), &tbdraw);

            SetTextColor(hdc, 0L);       // 0's in mono -> 0 (for ROP)
            SetBkColor(hdc, 0x00FFFFFF); // 1's in mono -> 1

            // draw glyph's etched-effect
            if (!(state & TBSTATE_INDETERMINATE) &&
                !(tbdraw.dwCustom & TBCDRF_NOETCHEDEFFECT)) {

                hbrOld = SelectObject(hdc, g_hbrBtnHighlight);
                if (hbrOld) {
                    // draw hilight color where we have 0's in the mask
                    BitBlt(hdc, x + 1, y + 1, dxFace, dyFace, ptb->hdcMono, 0, 0, PSDPxax);
                    SelectObject(hdc, hbrOld);
                }
            }

            // gray out glyph
            hbrOld = SelectObject(hdc, g_hbrBtnShadow);
            if (hbrOld) {
                // draw the shadow color where we have 0's in the mask
                BitBlt(hdc, x, y, dxFace, dyFace, ptb->hdcMono, 0, 0, PSDPxax);
                SelectObject(hdc, hbrOld);
            }

            if (state & TBSTATE_CHECKED) {
                BitBlt(ptb->hdcMono, 1, 1, dxFace - 1, dyFace - 1, ptb->hdcMono, 0, 0, SRCAND);
            }

            SelectObject(ptb->hdcMono, hbmOld);
        }

        if (TB_HasDDArrow(ptb, ptButton))
        {
            WORD wDSAFlags = DCHF_TRANSPARENT | DCHF_FLIPPED;
            BOOL fPressedDD = ((ptb->Buttons + ptb->iPressedDD) == ptButton);

            RECT rc;
            if (TB_HasTopDDArrow(ptb, ptButton)) {
                // position the dd arrow up next to the bitmap
                rc.left = x + xCenterOffset + ptb->iDxBitmap;
                rc.right = rc.left + ptb->dxDDArrowChar;
                rc.top = y + yOffset;
                rc.bottom = rc.top + ptb->iDyBitmap;
            }
            else 
            {
                // position the dd arrow to the right of the text & bitmap
                TB_GetItemRect(ptb, (UINT)(ptButton - ptb->Buttons), &rc);
                rc.left = rc.right - ptb->dxDDArrowChar;
            }

            if (TB_HasUnsplitDDArrow(ptb, ptButton)) {
                // if a non-split dd arrow, don't draw a border.
                wDSAFlags |= DCHF_NOBORDER;
            }

            if (DRAW_MONO_BTN(ptb, state)) {
                // DFCS_INACTIVE means "draw the arrow part grayed"
                wDSAFlags |= DCHF_INACTIVE;
            }
            // if TB_HasTopDDArrow, we've already offset rect, so don't draw DCHF_PUSHED
            else if ((fPressedDD || (state & (TBSTATE_CHECKED | TBSTATE_PRESSED))) &&
                   !TB_HasTopDDArrow(ptb, ptButton)) {
                // DCHF_PUSHED means "offset the arrow and draw indented border"
                wDSAFlags |= DCHF_PUSHED;
            } 
            else if (fHotTrack || !(ptb->ci.style & TBSTYLE_FLAT)) {
                // DCHF_HOT means "draw raised border"
                // non-flat dropdown arrows are either pushed or hot
                wDSAFlags |= DCHF_HOT;
            }

            DrawScrollArrow(hdc, &rc, wDSAFlags);
        }

        SelectObject(hdc, oldhFont);
        SetTextColor(hdc, clrSave);

        if (hFontNoAntiAlias)
        {
            DeleteObject(hFontNoAntiAlias);
        }
    }

    if (tbdraw.dwCustom & CDRF_NOTIFYPOSTPAINT)
        CICustomDrawNotify(&ptb->ci, CDDS_ITEMPOSTPAINT, (NMCUSTOMDRAW *)ptbcd);
}

// make sure that g_hbmMono is big enough to do masks for this
// size of button.  if not, fail.
BOOL CheckMonoMask(PTBSTATE ptb, int width, int height)
{
    BITMAP bm;
    HBITMAP hbmTemp;

    if (ptb->hbmMono) {
        GetObject(ptb->hbmMono, sizeof(BITMAP), &bm);
        if (width <= bm.bmWidth && height <= bm.bmHeight) {
            return TRUE;
        }
    }


    // Add a bit of fudge to keep this from being reallocated too often.
    hbmTemp = CreateMonoBitmap(width+8, height+8);
    if (!hbmTemp)
        return FALSE;

    if (ptb->hbmMono)
        DeleteObject(ptb->hbmMono);
    ptb->hbmMono = hbmTemp;
    return TRUE;
}

/*
** GrowToolbar
**
** Attempt to grow the button size.
**
** The calling function can either specify a new internal measurement
** (GT_INSIDE) or a new external measurement.
**
** GT_MASKONLY updates the mono mask and nothing else.
*/
BOOL GrowToolbar(PTBSTATE ptb, int newButWidth, int newButHeight, UINT flags)
{
    if (!newButWidth)
        newButWidth = DEFAULTBUTTONX;
    if (!newButHeight)
        newButHeight = DEFAULTBUTTONY;

    // if growing based on inside measurement, get full size
    if (flags & GT_INSIDE)
    {
        if (ptb->ci.style & TBSTYLE_LIST)
            newButWidth += ptb->iDxBitmap + ptb->iListGap;

        newButHeight += ptb->yPad;
        newButWidth += ptb->xPad;

        // if toolbar already has strings, don't shrink width it because it
        // might clip room for the string
        if ((newButWidth < ptb->iButWidth) && ptb->nStrings &&
            (ptb->ci.iVersion < 5 || ptb->nTextRows > 0))
            newButWidth = ptb->iButWidth;
    }
    else {
        if (newButHeight == -1)
            newButHeight = ptb->iButHeight;
        if (newButWidth == -1)
            newButWidth = ptb->iButWidth;

        if (newButHeight < ptb->iDyBitmap + ptb->yPad)
            newButHeight = ptb->iDyBitmap + ptb->yPad;
        if (newButWidth < ptb->iDxBitmap + ptb->xPad)
            newButWidth = ptb->iDxBitmap + ptb->xPad;
    }

    // if the size of the toolbar is actually growing, see if shadow
    // bitmaps can be made sufficiently large.
    if (!ptb->hbmMono || (newButWidth > ptb->iButWidth) || (newButHeight > ptb->iButHeight)) {
        if (!CheckMonoMask(ptb, newButWidth, newButHeight))
            return(FALSE);
    }

    if (flags & GT_MASKONLY)
        return(TRUE);

    if (!(flags & GT_INSIDE) && ((ptb->iButWidth != newButWidth) || (ptb->iButHeight != newButHeight)))
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    ptb->iButWidth = newButWidth;
    ptb->iButHeight = newButHeight;

    // bar height has 2 pixels above, 2 below
    if (ptb->ci.style & TBSTYLE_FLAT)
        ptb->iYPos = 0;
    else
        ptb->iYPos = 2;

    TBInvalidateItemRects(ptb);

    return TRUE;
}

BOOL SetBitmapSize(PTBSTATE ptb, int width, int height)
{
    int realh;

    if (!width)
        width = 1;
    if (!height)
        height = 1;

    if (width == -1)
        width = ptb->iDxBitmap;

    if (height == -1)
        height = ptb->iDyBitmap;

    realh = height;

    if ((ptb->iDxBitmap == width) && (ptb->iDyBitmap == height))
        return TRUE;

    if (TBHasStrings(ptb))
        realh = HeightWithString(ptb, height);

    if (GrowToolbar(ptb, width, realh, GT_INSIDE)) {
        ptb->iDxBitmap = width;
        ptb->iDyBitmap = height;

        // the size changed, we need to rebuild the imagelist
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
        TBInvalidateImageList(ptb);
        return TRUE;
    }
    return FALSE;
}

void TB_OnSysColorChange(PTBSTATE ptb)
{

    int i;
    InitGlobalColors();
    //  Reset all of the bitmaps

    for (i = 0; i < ptb->cPimgs; i++) {
        HIMAGELIST himl = TBGetImageList(ptb, HIML_NORMAL, i);
        if (himl)
            ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
        himl = TBGetImageList(ptb, HIML_HOT, i);
        if (himl)
            ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
    }
}

#define CACHE 0x01
#define BUILD 0x02


void PASCAL ReleaseMonoDC(PTBSTATE ptb)
{
    if (ptb->hdcMono) {
        SelectObject(ptb->hdcMono, g_hfontSystem);
        DeleteDC(ptb->hdcMono);
        ptb->hdcMono = NULL;
    }
}

void TB_OnEraseBkgnd(PTBSTATE ptb, HDC hdc)
{
    NMTBCUSTOMDRAW  tbcd = { 0 };
    DWORD           dwRes = FALSE;

    tbcd.nmcd.hdc = hdc;

    if (ptb->ci.style & TBSTYLE_CUSTOMERASE) {
        ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREERASE, (NMCUSTOMDRAW *)&tbcd);
    } else {
        ptb->ci.dwCustom = CDRF_DODEFAULT;
    }

    if (!(ptb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        // for transparent toolbars, forward erase background to parent
        // but handle thru DefWindowProc in the event parent doesn't paint
        if (!(ptb->ci.style & TBSTYLE_TRANSPARENT) ||
            !CCForwardEraseBackground(ptb->ci.hwnd, hdc))
            DefWindowProc(ptb->ci.hwnd, WM_ERASEBKGND, (WPARAM) hdc, 0);
    }

    if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
        CICustomDrawNotify(&ptb->ci, CDDS_POSTERASE, (NMCUSTOMDRAW *)&tbcd);
}

void PASCAL DrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr)
{
    HPEN hPnMark = CreatePen(PS_SOLID, 1, clr);
    HPEN hOldPn;
    POINT rgPoint[4];
    if (!hPnMark)
        hPnMark = (HPEN)GetStockObject(BLACK_PEN);    // fallback to draw with black pen
    hOldPn = (HPEN)SelectObject(hdc, (HGDIOBJ)hPnMark);

    if ( fHorizMode )
    {
        int iXCentre = (prc->left + prc->right) /2;

        rgPoint[0].x = iXCentre + 1;
        rgPoint[0].y = prc->top + 2;
        rgPoint[1].x = iXCentre + 3;
        rgPoint[1].y = prc->top;
        rgPoint[2].x = iXCentre - 2;
        rgPoint[2].y = prc->top;
        rgPoint[3].x = iXCentre;
        rgPoint[3].y = prc->top + 2;

        // draw the top bit...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = iXCentre;
        rgPoint[0].y = prc->top;
        rgPoint[1].x = iXCentre;
        rgPoint[1].y = prc->bottom - 1;
        rgPoint[2].x = iXCentre + 1;
        rgPoint[2].y = prc->bottom - 1;
        rgPoint[3].x = iXCentre + 1;
        rgPoint[3].y = prc->top;

        // draw the middle...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = iXCentre + 1;
        rgPoint[0].y = prc->bottom - 3;
        rgPoint[1].x = iXCentre + 3;
        rgPoint[1].y = prc->bottom - 1;
        rgPoint[2].x = iXCentre - 2;
        rgPoint[2].y = prc->bottom - 1;
        rgPoint[3].x = iXCentre;
        rgPoint[3].y = prc->bottom - 3;

        // draw the bottom bit...
        Polyline( hdc, rgPoint, 4 );
    }
    else
    {
        int iYCentre = (prc->top + prc->bottom) /2;

        rgPoint[0].x = prc->left + 2;
        rgPoint[0].y = iYCentre;
        rgPoint[1].x = prc->left;
        rgPoint[1].y = iYCentre - 2;
        rgPoint[2].x = prc->left;
        rgPoint[2].y = iYCentre + 3;
        rgPoint[3].x = prc->left + 2;
        rgPoint[3].y = iYCentre + 1;

        // draw the top bit...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = prc->left;
        rgPoint[0].y = iYCentre;
        rgPoint[1].x = prc->right - 1;
        rgPoint[1].y = iYCentre;
        rgPoint[2].x = prc->right - 1;
        rgPoint[2].y = iYCentre + 1;
        rgPoint[3].x = prc->left;
        rgPoint[3].y = iYCentre + 1;

        // draw the middle...
        Polyline( hdc, rgPoint, 4 );

        rgPoint[0].x = prc->right - 3;
        rgPoint[0].y = iYCentre;
        rgPoint[1].x = prc->right - 1;
        rgPoint[1].y = iYCentre - 2;
        rgPoint[2].x = prc->right - 1;
        rgPoint[2].y = iYCentre + 3;
        rgPoint[3].x = prc->right - 3;
        rgPoint[3].y = iYCentre + 1;

        // draw the bottom bit...
        Polyline( hdc, rgPoint, 4 );
    }

    SelectObject( hdc, hOldPn );
    DeleteObject((HGDIOBJ)hPnMark);
}

BOOL TBIsRectClipped(PTBSTATE ptb, LPRECT prc)
{
    RECT rc;
    RECT rcTB;

    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
        CopyRect(&rcTB, &ptb->rc);
    else
        GetClientRect(ptb->ci.hwnd, &rcTB);

    if (IntersectRect(&rc, &rcTB, prc)) {
        if (EqualRect(prc, &rc))
            return FALSE;
    }

    return TRUE;
}

BOOL TBShouldDrawButton(PTBSTATE ptb, LPRECT prcBtn, HDC hdc)
{
    // don't bother drawing buttons that aren't in the dc clipping region
    if (RectVisible(hdc, prcBtn)) {
        if (ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
            return !TBIsRectClipped(ptb, prcBtn);
        else
            return TRUE;
    }

    return FALSE;
}

// goin horizontal . . .
void DrawToolbarH(PTBSTATE ptb, HDC hdc, LPRECT prc)
{
    int iButton, xButton, yButton, cxBar;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    cxBar = prc->right - prc->left;

    yButton   = ptb->iYPos;
    prc->top    = ptb->iYPos;
    prc->bottom = ptb->iYPos + ptb->iButHeight;   // BUGBUG (scotth): what if first btn is a separator?


    for (iButton = 0, xButton = ptb->xFirstButton;
            iButton < ptb->iNumButtons; iButton++)
    {
        LPTBBUTTONDATA pButton = &pAllButtons[iButton];
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            int cxButton = TBWidthOfButton(ptb, pButton, hdc);

            // Is there anything to draw?
            if (!(pButton->fsStyle & BTNS_SEP) || (ptb->ci.style & TBSTYLE_FLAT))
            {
                // Yes
                prc->left = xButton;
                prc->right = xButton + cxButton;

                if (TBShouldDrawButton(ptb, prc, hdc))
                {
                    // Draw separator?
                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        // Yes; must be a flat separator.  Is this toolbar vertical?
                        if (ptb->ci.style & CCS_VERT)
                        {
                            // Yes; draw a horizontal separator.  Center w/in the
                            // button rect
                            int iSave = prc->top;
                            prc->top += (TBGetSepHeight(ptb, pButton) - 1) / 2;
                            InflateRect(prc, -g_cxEdge, 0);
                            CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                            InflateRect(prc, g_cxEdge, 0);
                            prc->top = iSave;
                        }
                        else
                        {
                            // No; draw a vertical separator
                            prc->left += (cxButton - 1) / 2;
                            InflateRect(prc, 0, -g_cyEdge);
                            CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_LEFT, &(ptb->clrsc));
                            InflateRect(prc, 0, g_cyEdge);
                        }
                    }
                    else
                    {
                        // No
                        DrawButton(hdc, xButton, yButton, ptb, pButton, ptb->fActive);
                    }
                }
            }

            xButton += (cxButton - s_dxOverlap);

            if (pButton->fsState & TBSTATE_WRAP)
            {
                int dy;

                if (pButton->fsStyle & BTNS_SEP)
                {
                    if (ptb->ci.style & CCS_VERT)
                        dy = TBGetSepHeight(ptb, pButton);
                    else
                    {
                        if (ptb->ci.style & TBSTYLE_FLAT)
                        {
                            // Draw a separator across the entire toolbar to separate rows.
                            // For horizontal toolbars only.
                            RECT rcMid;
                            rcMid.top = prc->top + ptb->iButHeight + ((TBGetSepHeight(ptb, pButton) - 1) / 2);
                            rcMid.bottom = rcMid.top + g_cxEdge;
                            rcMid.left = g_cxEdge;
                            rcMid.right = cxBar - g_cxEdge;

                            CCDrawEdge(hdc, &rcMid, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                        }

                        dy = ptb->iButHeight + TBGetSepHeight(ptb, pButton);
                    }
                }
                else
                    dy = ptb->iButHeight;

                xButton = ptb->xFirstButton;
                yButton   += dy;
                prc->top    += dy;
                prc->bottom += dy;
            }
        }
    }
}

// goin vertical . . .
void DrawToolbarV(PTBSTATE ptb, HDC hdc, LPRECT prc)
{
    int iButton, xButton, yButton, cyBar;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    NMTBCUSTOMDRAW  tbcd = { 0 };
    LPTBBUTTONDATA pButton = pAllButtons;

    cyBar = prc->bottom - prc->top;

    xButton = ptb->xFirstButton;
    prc->left = xButton;
    prc->right = prc->left + ptb->iButWidth;

    for (iButton = 0, yButton = 0;
            iButton < ptb->iNumButtons; iButton++, pButton++)
    {
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            // Is there anything to draw?
            if (!(pButton->fsStyle & BTNS_SEP) || (ptb->ci.style & TBSTYLE_FLAT))
            {
                int cyButton;
                
                if (pButton->fsStyle & BTNS_SEP)
                    cyButton = TBGetSepHeight(ptb, pButton);
                else
                    cyButton = ptb->iButHeight;

                prc->top = yButton;
                prc->bottom = yButton + cyButton;

                if (TBShouldDrawButton(ptb, prc, hdc))
                {
                    // Draw separator?
                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        DWORD dwCustRet;
                        NMTBCUSTOMDRAW  tbcd = { 0 };

                        tbcd.nmcd.hdc = hdc;
                        tbcd.nmcd.dwItemSpec = -1;
                        CopyRect(&tbcd.nmcd.rc, prc);

                        dwCustRet = CICustomDrawNotify(&ptb->ci, CDDS_ITEMPREPAINT, (NMCUSTOMDRAW *)&tbcd);

                        if ( !(CDRF_SKIPDEFAULT &  dwCustRet) )
                        {
                            // Yes; must be a flat separator.
                            InflateRect(prc, -g_cxEdge, 0);
                            CCDrawEdge(hdc, prc, EDGE_ETCHED, BF_TOP, &(ptb->clrsc));
                            InflateRect(prc, g_cxEdge, 0);
                        }
                    }
                    else
                    {
                        // No
                        DrawButton(hdc, xButton, yButton, ptb, pButton, ptb->fActive);
                    }
                }
                
                yButton += cyButton;
            }

            if (pButton->fsState & TBSTATE_WRAP)
            {
                int dx;
            
                if (ptb->ci.style & TBSTYLE_FLAT)
                {
                    // Draw a separator vertival across the entire toolbar to separate cols.
                    // For vertical toolbars only.

                    RECT rcMid;

                    rcMid.top = ptb->rc.top + g_cxEdge;
                    rcMid.bottom = ptb->rc.bottom - g_cxEdge;
                    rcMid.left = xButton + ptb->iButWidth;
                    rcMid.right = rcMid.left + g_cxEdge;
                    CCDrawEdge(hdc, &rcMid, EDGE_ETCHED, BF_LEFT, &(ptb->clrsc));
                }

                dx = ptb->iButWidth + g_cxEdge;

                yButton  = 0;
                xButton += dx;
                prc->left += dx;
                prc->right += dx;
            }
        }
    }
}

COLORREF TB_GetInsertMarkColor(PTBSTATE ptb)
{
    if (ptb->clrim == CLR_DEFAULT)
        return g_clrBtnText;
    else
        return ptb->clrim;
}

void TBPaint(PTBSTATE ptb, HDC hdcIn)
{
    RECT rc;
    HDC hdc;
    PAINTSTRUCT ps;
    NMTBCUSTOMDRAW  tbcd = { 0 };

    GetClientRect(ptb->ci.hwnd, &rc);
    if (hdcIn)
    {
        hdc = hdcIn;
    }
    else
        hdc = BeginPaint(ptb->ci.hwnd, &ps);

    if (!rc.right)
        goto Error1;

    tbcd.nmcd.hdc = hdc;
    tbcd.nmcd.rc = rc;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, (NMCUSTOMDRAW *)&tbcd);

    if (!(ptb->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        if (!ptb->fHimlValid)
            TBBuildImageList(ptb);

        if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            DrawToolbarV(ptb, hdc, &rc);
        else
            DrawToolbarH(ptb, hdc, &rc);

        if (ptb->iInsert!=-1)
        {
            BOOL fHorizMode = !(ptb->ci.style & CCS_VERT);
            RECT rc;
            if (GetInsertMarkRect(ptb, &rc, fHorizMode))
            {
                DrawInsertMark(hdc, &rc, fHorizMode, TB_GetInsertMarkColor(ptb));
            }
        }

        ReleaseMonoDC(ptb);
    }

    if (ptb->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
    {
        tbcd.nmcd.hdc = hdc;
        tbcd.nmcd.uItemState = 0;
        tbcd.nmcd.lItemlParam = 0;
        CICustomDrawNotify(&ptb->ci, CDDS_POSTPAINT, (NMCUSTOMDRAW *)&tbcd);
    }

Error1:
    if (hdcIn == NULL)
        EndPaint(ptb->ci.hwnd, &ps);

}

void TB_GetItemDropDownRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect)
{
    TB_GetItemRect(ptb,uButton,lpRect);
    lpRect->left = lpRect->right - ptb->dxDDArrowChar;
}

int TBHeightOfButton(PTBSTATE ptb, LPTBBUTTONDATA ptbb)
{
    int dy;

	if ((ptbb->fsStyle & BTNS_SEP)  && 
		(ptbb->fsState & TBSTATE_WRAP || ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
	{
		if (!(ptb->ci.style & CCS_VERT) && !(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)) 
		{
			dy = TBGetSepHeight(ptb, ptbb) + ptb->iButHeight;
		} 
		else 
		{
			dy = TBGetSepHeight(ptb, ptbb);
		}
	}
	else
	{
		dy = ptb->iButHeight;
	}

    return dy;
}

void TB_CalcItemRects(PTBSTATE ptb)
{
    int iButton, xPos, yPos;

    ASSERT(!ptb->fItemRectsValid);

    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;

    for (iButton = 0; iButton < ptb->iNumButtons; iButton++)
    {
        int xPosButton;
        LPTBBUTTONDATA pButton = &ptb->Buttons[iButton];

        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            if ((pButton->fsState & TBSTATE_WRAP) && (pButton->fsStyle & BTNS_SEP))
                xPosButton = ptb->xFirstButton;
            else
                xPosButton = xPos;

            pButton->pt.x = xPosButton;
            pButton->pt.y = yPos;

            if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            {
                if (pButton->fsState & TBSTATE_WRAP)
                {
                    xPos += (ptb->iButWidth + g_cxEdge);    // to not overwrite the edge.
                    yPos = 0;
                }
                else if (pButton->fsStyle & BTNS_SEP)
                    yPos += (TBGetSepHeight(ptb, pButton));
                else
                    yPos += ptb->iButHeight;
            }
            else // standard horizontal toolbar.
            {
                xPos += TBWidthOfButton(ptb, pButton, NULL) - s_dxOverlap;

                if (pButton->fsState & TBSTATE_WRAP)
                {
                    yPos += ptb->iButHeight;

                    if (pButton->fsStyle & BTNS_SEP)
                    {
                        if (ptb->ci.style & CCS_VERT) {
                            yPos -= ptb->iButHeight;
                        }
                        yPos += (TBGetSepHeight(ptb, pButton));
                    }

                    xPos = ptb->xFirstButton;
                }
            }
        }
    }
}

BOOL TB_GetItemRect(PTBSTATE ptb, UINT uButton, LPRECT lpRect)
{
    int dy = ptb->iButHeight;

    if (uButton >= (UINT)ptb->iNumButtons
        || (ptb->Buttons[uButton].fsState & TBSTATE_HIDDEN))
    {
        return FALSE;
    }

    if (!ptb->fItemRectsValid) {
        TB_CalcItemRects(ptb);
        ptb->fItemRectsValid = TRUE;
    }

    lpRect->left   = ptb->Buttons[uButton].pt.x;
    lpRect->right  = lpRect->left + TBWidthOfButton(ptb, &ptb->Buttons[uButton], NULL);
    lpRect->top    = ptb->Buttons[uButton].pt.y;
    lpRect->bottom = lpRect->top + TBHeightOfButton(ptb, &ptb->Buttons[uButton]);

    return TRUE;
}

void InvalidateButton(PTBSTATE ptb, LPTBBUTTONDATA pButtonToPaint, BOOL fErase)
{
    RECT rc;

    if (TB_GetItemRect(ptb, (UINT) (pButtonToPaint - ptb->Buttons), &rc))
    {
        InvalidateRect(ptb->ci.hwnd, &rc, fErase);
    }
}

/*----------------------------------------------------------
Purpose: Toggles the button as a dropdown

Returns: TRUE if handled
*/
BOOL TBToggleDropDown(PTBSTATE ptb, int iPos, BOOL fEatMsg)
{
    BOOL bRet = FALSE;
    LPTBBUTTONDATA ptbButton = &ptb->Buttons[iPos];

    ASSERT(TB_IsDropDown(ptbButton));

    if (ptbButton->fsState & TBSTATE_ENABLED)
    {
        UINT nVal;

        ptb->iPressedDD = iPos;

        if (TB_HasUnsplitDDArrow(ptb, ptbButton))
            ptbButton->fsState |= TBSTATE_PRESSED;

        InvalidateButton(ptb, ptbButton, TRUE);
        UpdateWindow(ptb->ci.hwnd);

        MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, ptb->ci.hwnd, OBJID_CLIENT, iPos+1);

        nVal = (UINT) SendItemNotify(ptb, ptbButton->idCommand, TBN_DROPDOWN);
        if (TBDDRET_DEFAULT == nVal || TBDDRET_TREATPRESSED == nVal)
        {
            if (fEatMsg)
            {
                MSG msg;

                PeekMessage(&msg, ptb->ci.hwnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
            }

            ptb->iPressedDD = -1;

            if (TB_HasUnsplitDDArrow(ptb, ptbButton))
                ptbButton->fsState &= ~TBSTATE_PRESSED;

            InvalidateButton(ptb, ptbButton, TRUE);
            UpdateWindow(ptb->ci.hwnd);

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, ptb->ci.hwnd, OBJID_CLIENT, iPos+1);
        }

        bRet = (TBDDRET_DEFAULT == nVal);
    }
    return bRet;
}


void TBInvalidateButton(PTBSTATE ptb, int i, BOOL fErase)
{
    if (i != -1) {
        InvalidateButton(ptb, &ptb->Buttons[i], fErase);
   }
}


void TBSetHotItem(PTBSTATE ptb, int iPos, DWORD dwReason)
{
    HWND hwnd;

    if ((ptb->ci.style & TBSTYLE_FLAT) ) {

        // Either one of these values can be -1, but refrain
        // from processing if both are negative b/c it is wasteful
        // and very common

        if ((ptb->iHot != iPos || (dwReason & HICF_RESELECT)) &&
            (0 <= ptb->iHot || 0 <= iPos) &&
            iPos < ptb->iNumButtons)
        {
            NMTBHOTITEM nmhot = {0};

            // Has the mouse moved away from the toolbar but
            // do we still anchor the highlight?
            if (0 > iPos && ptb->fAnchorHighlight && (dwReason & HICF_MOUSE))
                return ;        // Yes; deny the hot item change

            // Send a notification about the hot item change
            if (0 > ptb->iHot)
            {
                if (iPos >= 0)
                    nmhot.idNew = ptb->Buttons[iPos].idCommand;
                nmhot.dwFlags = HICF_ENTERING;
            }
            else if (0 > iPos)
            {
                if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
                    nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
                nmhot.dwFlags = HICF_LEAVING;
            }
            else
            {
                if (ptb->iHot < ptb->iNumButtons)
                    nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
                nmhot.idNew = ptb->Buttons[iPos].idCommand;
            }
            nmhot.dwFlags |= dwReason;

            // must save this for revalidation
            hwnd = ptb->ci.hwnd;

            if (CCSendNotify(&ptb->ci, TBN_HOTITEMCHANGE, &nmhot.hdr))
                return;         // deny the hot item change

            // Revalidate the window
            if (!IsWindow(hwnd)) return;

            TBInvalidateButton(ptb, ptb->iHot, TRUE);
            if ((iPos < 0) || !(ptb->Buttons[iPos].fsState & TBSTATE_ENABLED))
                iPos = -1;

            ptb->iHot = iPos;

            if (GetFocus() == ptb->ci.hwnd)
                MyNotifyWinEvent(EVENT_OBJECT_FOCUS, ptb->ci.hwnd, OBJID_CLIENT, iPos + 1);

            TBInvalidateButton(ptb, ptb->iHot, TRUE);

            if ((iPos >= 0 && iPos < ptb->iNumButtons) &&
                (TB_IsDropDown(&ptb->Buttons[iPos])) &&
                (dwReason & HICF_TOGGLEDROPDOWN))
            {
                TBToggleDropDown(ptb, iPos, FALSE);
            }
        }
    }
}

BOOL GetInsertMarkRect(PTBSTATE ptb, LPRECT prc, BOOL fHorizMode)
{
    BOOL fRet = TB_GetItemRect(ptb, ptb->iInsert, prc);
    if (fRet)
    {
        // if we are in horizontal mode, we need a vertical insertion marker
        if ( fHorizMode )
        {
            if (ptb->fInsertAfter)
                prc->left = prc->right;
            else
                prc->right = prc->left;

            prc->left -= INSERTMARKSIZE/2;
            prc->right += INSERTMARKSIZE/2 + 1;
        }
        else
        {
            if (ptb->fInsertAfter)
                prc->top = prc->bottom;
            else
                prc->bottom = prc->top;

            prc->top -= INSERTMARKSIZE/2;
            prc->bottom += INSERTMARKSIZE/2 + 1;
        }
    }
    return fRet;
}

void TBInvalidateMark(PTBSTATE ptb)
{
    RECT rc;

    if (GetInsertMarkRect(ptb, &rc, !(ptb->ci.style & CCS_VERT)))
    {
        InvalidateRect(ptb->ci.hwnd, &rc, TRUE);
    }
}

void TBSetInsertMark(PTBSTATE ptb, LPTBINSERTMARK ptbim)
{
    if (ptbim->iButton != ptb->iInsert ||
        BOOLIFY(ptb->fInsertAfter) != BOOLIFY(ptbim->dwFlags & TBIMHT_AFTER))
    {
        if (ptb->iInsert != -1)
            TBInvalidateMark(ptb);

        ptb->iInsert = ptbim->iButton;
        ptb->fInsertAfter = BOOLIFY(ptbim->dwFlags & TBIMHT_AFTER);

        if (ptb->iInsert != -1)
            TBInvalidateMark(ptb);
    }
}

void TBCycleHotItem(PTBSTATE ptb, int iStart, int iDirection, UINT nReason)
{
    int i;
    int iPrev;
    NMTBWRAPHOTITEM nmwh;

    nmwh.iDir = iDirection;
    nmwh.nReason = nReason;


    //When cycling around the menu, without this check, the second to last menu
    //item would be selected.
    if (iStart == -1 && iDirection == -1)
        iStart = 0;

    for (i = 0; i < ptb->iNumButtons; i++)
    {
        iPrev = iStart;
        iStart += iDirection + ptb->iNumButtons;
        iStart %= ptb->iNumButtons;

        if ( ( iPrev + iDirection >= ptb->iNumButtons) || (iPrev + iDirection < 0) )
        {
            nmwh.iStart = iStart;
            if (CCSendNotify(&ptb->ci, TBN_WRAPHOTITEM, &nmwh.hdr))
                return;
        }

        if (ptb->Buttons[iStart].fsState & TBSTATE_ENABLED &&
            !(ptb->Buttons[iStart].fsState & TBSTATE_HIDDEN) &&
            !(ptb->Buttons[iStart].fsStyle & BTNS_SEP))
        {
            // if the old hot item was dropped down, undrop it.
            if (ptb->iHot != -1 && ptb->iHot == ptb->iPressedDD)
                TBToggleDropDown(ptb, ptb->iHot, FALSE);

            TBSetHotItem(ptb, iStart, nReason);
            break;
        }
    }
}


// Do hit testing by sliding the origin of the supplied point
//
// returns:
//  >= 0    index of non separator item hit
//  < 0     index of separator or nearest non separator item (area
//          just below and to the left)
//
// +--------------------------------------
// |      -1    -1    -1    -1
// |      btn   sep   btn
// |    +-----+     +-----+
// |    |     |     |     |
// | -1 |  0  | -1  |  2  | -3
// |    |     |     |     |
// |    +-----+     +-----+
// |
// | -1   -1    -1    -2    -3
//

int TBHitTest(PTBSTATE ptb, int xPos, int yPos)
{
    int prev = 0;
    int last = 0;
    int i;
    RECT rc;

    if (ptb->iNumButtons == 0)
        return(-1);

    for (i=0; i<ptb->iNumButtons; i++)
    {
        if (TB_GetItemRect(ptb, i, &rc))
        {
            // ignore this button if hidden because of HideClippedButtons style
            if (!(ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) || !(TBIsRectClipped(ptb, &rc)))
            {
                // From PtInRect docs:
                //   A point is within a rectangle if it lies on the left or top
                //   side or is within all four sides. A point on the right or
                //   bottom side is considered outside the rectangle.

                if (yPos >= rc.top && yPos < rc.bottom)
                {
                    if (xPos >= rc.left && xPos < rc.right)
                    {
                        if (ptb->Buttons[i].fsStyle & BTNS_SEP)
                            return - i - 1;
                        else
                            return i;
                    }
                    else
                    {
                        prev = i + 1;
                    }
                }
                else
                {
                    last = i;
                }
            }
        }
    }

    if (prev)
        return -1 - prev;
    else if (yPos > rc.bottom)
        // this means that we are off the bottom of the toolbar
        return(- i - 1);

    return last + 1;
}

// Same as above except:
//  - returns TRUE if the cursor is on the button edge.
//  - returns FALSE is the cursor is b/t buttons or on the button itself

BOOL TBInsertMarkHitTest(PTBSTATE ptb, int xPos, int yPos, LPTBINSERTMARK ptbim)
{
    TBINSERTMARK prev = {-1, TBIMHT_AFTER|TBIMHT_BACKGROUND}; // best guess if we hit a row
    TBINSERTMARK last = {-1, TBIMHT_AFTER|TBIMHT_BACKGROUND}; // best guess if we don't
    int i;

    // restrict hit testing depending upon whether we are vertical or horizontal
    BOOL fHorizMode = !(ptb->ci.style & CCS_VERT);

    for (i=0; i<ptb->iNumButtons; i++)
    {
        RECT rc;

        if (TB_GetItemRect(ptb, i, &rc))
        {
            if (yPos >= rc.top && yPos < rc.bottom)
            {
                if (xPos >= rc.left && xPos < rc.right)
                {
                    ptbim->iButton = i;

                    if ( fHorizMode )
                    {
                        if (xPos < rc.left + g_cxEdge*4)
                        {
                            ptbim->dwFlags = 0;
                            return TRUE;
                        }
                        else if (xPos > rc.right - g_cxEdge*4)
                        {
                            ptbim->dwFlags = TBIMHT_AFTER;
                            return TRUE;
                        }
                    }
                    else
                    {
                        // vertical....
                        if (yPos < rc.top + g_cyEdge*4)
                        {
                            ptbim->dwFlags = 0;
                            return TRUE;
                        }
                        else if (yPos > rc.bottom - g_cyEdge*4)
                        {
                            ptbim->dwFlags = TBIMHT_AFTER;
                            return TRUE;
                        }
                    }

                    // else we are just on a button...
                    ptbim->dwFlags = 0;
                    return FALSE;
                }
                else
                {
                    if (xPos < rc.left)
                    {
                        // since buttons are laid out left to right
                        // and rows are laid out top to bottom,
                        // if we ever hit this case, we can't hit anything else
                        ptbim->iButton = i;
                        ptbim->dwFlags = TBIMHT_BACKGROUND;
                        return FALSE;
                    }
                    else // (xPos > rc.right)
                    {
                        // remember the last one we've seen on this row
                        prev.iButton = i;
                    }
                }
            }
            else
            {
                if (yPos < rc.top)
                {
                    if (prev.iButton != -1)
                    {
                        *ptbim = prev;
                    }
                    else
                    {
                        ptbim->iButton = i;
                        ptbim->dwFlags = TBIMHT_BACKGROUND;
                    }
                }
                else
                {
                    // remember the last one we've seen
                    last.iButton = i;
                }
            }
        }
    }

    if (prev.iButton != -1)
        *ptbim = prev;
    else
        *ptbim = last;

    return FALSE;
}

int CountRows(PTBSTATE ptb)
{
    LPTBBUTTONDATA pButton, pBtnLast;
    int rows = 1;

    // BUGBUG (scotth): this doesn't look vertical-friendly
    // chrisny:  semantically no, technically it will work like a charm :-)

    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    for (pButton = ptb->Buttons; pButton<pBtnLast; pButton++) {
        if (pButton->fsState & TBSTATE_WRAP) {
            rows++;
            if (pButton->fsStyle & BTNS_SEP)
                rows++;
        }
    }

    return rows;
}

#define CountCols(ptb)  CountRows(ptb)

void WrapToolbarCol(PTBSTATE ptb, int dy, LPRECT lpRect, int *pCols)
{
    LPTBBUTTONDATA pButton, pBtnLast, pBtnPrev;
    LPTBBUTTONDATA pbtnLastVisible = NULL;
    LPTBBUTTONDATA pbtnPrev = NULL;
    int xPos, yPos;
    int dyButton;
    int yPosWrap = 0;
    int cCols = 1;

    DEBUG_CODE( int cItemsPerCol = 0; )

    ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
    TraceMsg(TF_TOOLBAR, "Toolbar: calculating WrapToolbar");

    // dy must be at least the button height, otherwise the final
    // rect is mis-calculated and will be too big.
    if (dy < ptb->iButHeight)
        dy = ptb->iButHeight;

    dyButton = ptb->iButHeight;
    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;

    if (pCols)
        (*pCols) = 1;

    pBtnPrev = ptb->Buttons;

    for (pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        DEBUG_CODE( cItemsPerCol++; )

        // we nuke the wrap state at the start of the loop.
        // so we don't know if/when we are adding on a wrap bit that wasn't there
        // before.  we overstep the button, then back up when we've gone too far,
        pButton->fsState &= ~TBSTATE_WRAP;
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            if (pButton->fsStyle & BTNS_SEP)
                yPos += (TBGetSepHeight(ptb, pButton));
            else
                yPos += dyButton;
            // Is this button out of bounds?
            if (yPos > dy)
            {
                // Yes; wrap it.
                if ((pButton->fsStyle & BTNS_SEP) &&
                    yPos - TBGetSepHeight(ptb, pButton) > yPosWrap)
                {
                    yPosWrap = yPos - TBGetSepHeight(ptb, pButton); // wrap at first in next col.
                }
                else if (yPos - dyButton > yPosWrap)
                    yPosWrap = yPos - dyButton; // wrap at first in next col.

                if (xPos + ptb->iButWidth <= ptb->sizeBound.cx)
                    xPos += ptb->iButWidth;
                yPos = dyButton;
                cCols++;
                pBtnPrev->fsState |= TBSTATE_WRAP;

                DEBUG_CODE( cItemsPerCol = 0; )
            }
           // button in bounds gets handled above.
            pBtnPrev = pButton; // save previous for wrap point
        }
    }
    yPos = yPosWrap ? yPosWrap : yPos;
    if (pCols)
        *pCols = cCols;
    ptb->rc.left = 0;
    ptb->rc.right = xPos + ptb->iButWidth;
    ptb->rc.top = 0;
    ptb->rc.bottom = yPos;

    if (lpRect)
        CopyRect(lpRect, &ptb->rc);

    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
}

/**** WrapToolbar: * The buttons in the toolbar is layed out from left to right,
 * top to bottom. If adding another button to the current row,
 * while computing the layout, would cause that button to extend
 * beyond the right edge or the client area, then locate a break-
 * point (marked with the TBSTATE_WRAP flag). A break-point is:
 *
 * a) The right-most separator on the current row.
 *
 * b) The right-most button if there is no separator on the current row.
 *
 * A new row is also started at the end of any button group (sequence
 * of buttons that are delimited by separators) that are taller than
 * or equal to two rows.
 */

void WrapToolbar(PTBSTATE ptb, int dx, LPRECT lpRect, int *pRows)
{
    BOOL fInvalidate = FALSE;
    LPTBBUTTONDATA pButton, pBtnT, pBtnLast;
    LPTBBUTTONDATA pbtnLastVisible = NULL;
    LPTBBUTTONDATA pbtnPrev = NULL;
    BOOL fLastVisibleWrapped = FALSE;
    int xPos, yPos, xMax;
    int dyButton;
    BOOL bWrapAtNextSeparator = FALSE;

    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL));
    TraceMsg(TF_TOOLBAR, "Toolbar: calculating WrapToolbar");

    if (ptb->iNumButtons == 0) {
        // no buttons, so we're not going to go through the loop below; initialize 
        // dyButton to 0 so that we fill in lpRect with 0 height.  this fixes ideal 
        // size calculation for empty toolbars (NT5 #180430)
        dyButton = 0;
    } else {
        if (dx < ptb->iButWidth) {
            // dx must be at least the button width, otherwise the final
            // rect is mis-calculated and will be too big.
            dx = ptb->iButWidth;
        }
        dyButton = ptb->iButHeight;
    }

    xMax = 0;
    xPos = ptb->xFirstButton;
    yPos = ptb->iYPos;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;

    if (pRows)
        (*pRows)=1;

    for (pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        // we nuke the wrap state at the start of the loop.
        // so we don't know if/when we are adding on a wrap bit that wasn't there
        // before.  we overstep the button, then back up when we've gone too far,
        // so we can't simply keep the at the start of the loop
        // we need to keep it over to the next iteration
        BOOL fNextLastVisibleWrapped = (pButton->fsState & TBSTATE_WRAP);
        LPTBBUTTONDATA pbtnSav = pButton;

        pButton->fsState &= ~TBSTATE_WRAP;

        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            LPTBBUTTONDATA pbtnNextLastVisible = pButton;

            xPos += TBWidthOfButton(ptb, pButton, NULL) - s_dxOverlap;

            // Is this a normal button and is the button out of bounds?
            if (!(pButton->fsStyle & BTNS_SEP) && (xPos > dx)) {

                // Yes; wrap it.  Go back to the first non-hidden separator
                // as a break-point candidate.
                for (pBtnT=pButton;
                     pBtnT>ptb->Buttons && !(pBtnT->fsState & TBSTATE_WRAP);
                     pBtnT--)
                {
                    if ((pBtnT->fsStyle & BTNS_SEP) &&
                        !(pBtnT->fsState & TBSTATE_HIDDEN))
                    {
                        yPos += (TBGetSepHeight(ptb, pBtnT)) + dyButton;
                        bWrapAtNextSeparator = FALSE;
                        if (pRows)
                            (*pRows)++;

                        goto SetWrapHere;
                    }
                }

                pBtnT = pButton;

                // Are we at the first button?
                if (pButton != ptb->Buttons) {
                    // No; back up to first non-hidden button
                    do {
                        pBtnT--;
                    } while ((pBtnT>ptb->Buttons) &&
                             (pBtnT->fsState & TBSTATE_HIDDEN));

                    // Is it already wrapped?
                    if (pBtnT->fsState & TBSTATE_WRAP)
                    {
                        // Yes; wrap the button we were looking at originally
                        pBtnT = pButton;
                    }
                }

                // Wrap at the next separator because we've now wrapped in the middle
                // of a group of buttons.
                bWrapAtNextSeparator = TRUE;
                yPos += dyButton;

SetWrapHere:
                pBtnT->fsState |= TBSTATE_WRAP;

                // find out if this wrap bit is new...
                // it isn't if this button was the last visible button
                // and that last visible button started off wrapped
                if (pBtnT != pbtnLastVisible || !fLastVisibleWrapped)
                    fInvalidate = TRUE;

                xPos = ptb->xFirstButton;
                pButton = pBtnT;

                // Count another row.
                if (pRows)
                    (*pRows)++;
            }
            else
            {
                // No; this is a separator (in or out of bounds) or a button that is in-bounds.

                if (pButton->fsStyle & BTNS_SEP)
                {
                    if (ptb->ci.style & CCS_VERT)
                    {
                        if (pbtnPrev && !(pbtnPrev->fsState & TBSTATE_WRAP))
                        {
                            pbtnPrev->fsState |= TBSTATE_WRAP;
                            yPos += dyButton;
                        }
                        xPos = ptb->xFirstButton;
                        yPos += TBGetSepHeight(ptb, pButton);
                        pButton->fsState |= TBSTATE_WRAP;
                        if (pRows)
                            (*pRows)++;
                    }
                    else if (bWrapAtNextSeparator)
                    {
                        bWrapAtNextSeparator = FALSE;
                        pButton->fsState |= TBSTATE_WRAP;
                        xPos = ptb->xFirstButton;
                        yPos += dyButton + (TBGetSepHeight(ptb, pButton));
                        if (pRows)
                            (*pRows)+=2;
                    }
                }

                // This button is visible and it's one we cached at the top of the loop
                // set it for the next loop
                if (pButton == pbtnNextLastVisible) {
                    ASSERT(!(pButton->fsState & TBSTATE_HIDDEN));
                    if (!(pButton->fsState & TBSTATE_HIDDEN)) {

                        // we don't know that we're not going to re-wrap an item that was initially wrapped
                        // until this point
                        if (pbtnLastVisible && fLastVisibleWrapped && !(pbtnLastVisible->fsState & TBSTATE_WRAP))
                            fInvalidate = TRUE;

                        pbtnLastVisible = pButton;
                        fLastVisibleWrapped = fNextLastVisibleWrapped;
                    }
                }
            }
            if (!(pButton->fsStyle&BTNS_SEP))
                xMax = max(xPos, xMax);

            pbtnPrev = pbtnSav;
        }
    }

    if (lpRect)
    {
        lpRect->left = 0;
        lpRect->right = xMax;
        lpRect->top = 0;
        lpRect->bottom = yPos + ptb->iYPos + dyButton;
    }

    if (fInvalidate)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
}


// only called from TB_SETROWS so no worry's about TBSTYLE_EX_MULTICOLUMN
BOOL BoxIt(PTBSTATE ptb, int height, BOOL fLarger, LPRECT lpRect)
{
    int dx, bwidth;
    int rows, prevRows, prevWidth;
    RECT rcCur;

    if (height<1)
        height = 1;

    rows = CountRows(ptb);
    if (height==rows || ptb->iNumButtons==0)
    {
        GetClientRect(ptb->ci.hwnd, lpRect);
        return FALSE;
    }

    bwidth = ptb->iButWidth-s_dxOverlap;
    prevRows = ptb->iNumButtons+1;
    prevWidth = bwidth;
    for (rows=height+1, dx = bwidth; rows>height;dx+=bwidth/4)
    {
        WrapToolbar(ptb, dx, &rcCur, &rows);
        if (rows<prevRows && rows>height)
        {
            prevWidth = dx;
            prevRows = rows;
        }
    }

    if (rows<height && fLarger)
    {
        WrapToolbar(ptb, prevWidth, &rcCur, NULL);
    }

    if (lpRect)
        *lpRect = rcCur;

    return TRUE;
}


int PositionFromID(PTBSTATE ptb, LONG_PTR id)
{
    int i;

    // Handle case where this is sent at the wrong time..
    if (ptb == NULL || id == -1)
        return -1;

    // note, we don't skip separators, so you better not have conflicting
    // cmd ids and separator ids.
    for (i = 0; i < ptb->iNumButtons; i++)
        if (ptb->Buttons[i].idCommand == id)
            return i;       // position found

    return -1;      // ID not found!
}

// check a radio button by button index.
// the button matching idCommand was just pressed down.  this forces
// up all other buttons in the group.
// this does not work with buttons that are forced up with

void MakeGroupConsistant(PTBSTATE ptb, int idCommand)
{
    int i, iFirst, iLast, iButton;
    int cButtons = ptb->iNumButtons;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;

    iButton = PositionFromID(ptb, idCommand);

    if (iButton < 0)
        return;

    // assertion

//    if (!(pAllButtons[iButton].fsStyle & BTNS_CHECK))
//  return;

    // did the pressed button just go down?
    if (!(pAllButtons[iButton].fsState & TBSTATE_CHECKED))
        return;         // no, can't do anything

    // find the limits of this radio group

    // there was a bug here since win95 days -- ; there was no ; at the end of for loop
    // and if was part of it -- some apps may rely on that (reljai 6/16/98)
    for (iFirst = iButton; (iFirst > 0) && (pAllButtons[iFirst].fsStyle & BTNS_GROUP); iFirst--);
    
    if (!(pAllButtons[iFirst].fsStyle & BTNS_GROUP))
        iFirst++;

    cButtons--;
    for (iLast = iButton; (iLast < cButtons) && (pAllButtons[iLast].fsStyle & BTNS_GROUP); iLast++);

    if (!(pAllButtons[iLast].fsStyle & BTNS_GROUP))
        iLast--;

    // search for the currently down button and pop it up
    for (i = iFirst; i <= iLast; i++) {
        if (i != iButton) {
            // is this button down?
            if (pAllButtons[i].fsState & TBSTATE_CHECKED) {
                pAllButtons[i].fsState &= ~TBSTATE_CHECKED;     // pop it up
                TBInvalidateButton(ptb, i, TRUE);
                break;          // only one button is down right?
            }
        }
    }
}

void DestroyStrings(PTBSTATE ptb)
{
    PTSTR *p;
    PTSTR end = 0, start = 0;
    int i;

    p = ptb->pStrings;
    for (i = 0; i < ptb->nStrings; i++) {
        if (!((*p < end) && (*p > start))) {
            start = (*p);
            end = start + (LocalSize((HANDLE)*p) / sizeof(TCHAR));
            LocalFree((HANDLE)*p);
        }
    p++;
    }

    LocalFree((HANDLE)ptb->pStrings);
}

// gets the iString from pStrings and copies it to pszText.
// returns the lstrlen.
// pszText can be null to just fetch the length.
int TBGetString(PTBSTATE ptb, int iString, int cchText, LPTSTR pszText)
{
    int iRet = -1;
    if (iString < ptb->nStrings) {
        iRet = lstrlen(ptb->pStrings[iString]);
        if (pszText) {
            lstrcpyn(pszText, ptb->pStrings[iString], cchText);
        }
    }

    return iRet;
}

#ifdef UNICODE

// gets the iString from pStrings and copies it to pszText.
// returns the lstrlen.
// pszText can be null to just fetch the length.
int TBGetStringA(PTBSTATE ptb, int iString, int cchText, LPSTR pszText)
{
    int iRet = -1;
    if (iString < ptb->nStrings) {

        iRet = lstrlenW(ptb->pStrings[iString]);
        if (pszText) {
            WideCharToMultiByte (CP_ACP, 0, ptb->pStrings[iString],
                                 -1, pszText, cchText, NULL, NULL);
        }
    }

    return iRet;
}
#endif

#define MAXSTRINGSIZE 1024
int TBAddStrings(PTBSTATE ptb, WPARAM wParam, LPARAM lParam)
{
    int i = 0,j = 0, cxMax = 0;
    LPTSTR lpsz;
    PTSTR  pString, pStringAlloc, psz;
    int numstr;
    PTSTR *pFoo;
    PTSTR *pOffset;
    TCHAR cSeparator;
    int len;

    // read the string as a resource
    if (wParam != 0) {
        pString = (PTSTR)LocalAlloc(LPTR, (MAXSTRINGSIZE * sizeof (TCHAR)));
        if (!pString)
            return -1;
        i = LoadString((HINSTANCE)wParam, LOWORD(lParam), (LPTSTR)pString, MAXSTRINGSIZE);
        if (!i) {
            LocalFree(pString);
            return -1;
        }
        // realloc string buffer to actual needed size
        psz = LocalReAlloc(pString, (i+1) * sizeof (TCHAR), LMEM_MOVEABLE);
        if (psz)
            pString = psz;

        // convert separators to '\0' and count number of strings
        cSeparator = *pString;
#ifndef UNICODE
        for (numstr = 0, psz = pString + 1, i--; i; i--, psz++ ) {
            if (*psz == cSeparator) {
                if (i != 1)     // We don't want to count the second terminator as another string
                    numstr++;

                *psz = 0;    // terminate with 0
            }
            // extra i-- if DBCS
            if (IsDBCSLeadByte(*psz))
            {
                *(WORD *)(psz-1) = *(WORD *)psz;
                psz++;
                i--;
            }
            else
            {
                // shift string to the left to overwrite separator identifier
                *(psz - 1) = *psz;
            }
        }
#else
        for (numstr = 0, psz = pString + 1, i--; i; i--, psz++) {
            if (*psz == cSeparator) {
                if (i != 1)     // We don't want to count the second terminator as another string
                    numstr++;

                *psz = 0;   // terminate with 0
            }
            // shift string to the left to overwrite separator identifier
            *(psz - 1) = *psz;
        }
#endif
    }
    // read explicit string.  copy it into local memory, too.
    else {

        // Common mistake is to forget to check the return value of
        // LoadLibrary and accidentally pass wParam=NULL.
        if (IS_INTRESOURCE(lParam))
            return -1;

        // find total length and number of strings
        for (i = 0, numstr = 0, lpsz = (LPTSTR)lParam;;) {
            i++;
            if (*lpsz == 0) {
                numstr++;
                if (*(lpsz + 1) == 0)
                    break;
            }
            lpsz++;
        }

        pString = (PTSTR)LocalAlloc(LPTR, (i * sizeof (TCHAR)));
        if (!pString)
            return -1;
        hmemcpy(pString, (void *)lParam, i * sizeof(TCHAR));
    }

    pStringAlloc = pString;         // in case something bad happens

    // make room for increased string pointer table
    pFoo = (PTSTR *)CCLocalReAlloc(ptb->pStrings,
            (ptb->nStrings + numstr) * sizeof(PTSTR));
    if (!pFoo) {
        goto Failure;
    }

    ptb->pStrings = pFoo;
    // pointer to next open slot in string index table.
    pOffset = ptb->pStrings + ptb->nStrings;

    for (i = 0; i < numstr; i++, pOffset++)
    {
        *pOffset = pString;
        len = lstrlen(pString);
        pString += len + 1;
    }
    // is the world big enough to handle the larger buttons?
    i = ptb->nStrings;
    ptb->nStrings += numstr;
    if (!TBRecalc(ptb))
    {
        ptb->nStrings -= numstr;
        // back out changes.
        pFoo = (PTSTR *)CCLocalReAlloc(ptb->pStrings,
                    ptb->nStrings * sizeof(PTSTR));
        if (pFoo)
            ptb->pStrings = pFoo;
         // don't get mad if pFoo == NULL; it means the shrink failed, no big deal

Failure:
        LocalFree(pStringAlloc);
        return -1;
    }

    return i;               // index of first added string
}

void MapToStandardBitmaps(HINSTANCE *phinst, UINT_PTR *pidBM, int *pnButtons)
{
    if (*phinst == HINST_COMMCTRL) {
        *phinst = g_hinst;

        // low 2 bits are coded M(mono == ~color) L(large == ~small)
        //  0 0   -> color small
        //  0 1   -> color large
        //  ...
        //  1 1   -> mono  large

        switch (*pidBM)
        {
        case IDB_STD_SMALL_COLOR:
        case IDB_STD_LARGE_COLOR:
        case IDB_STD_SMALL_MONO:
        case IDB_STD_LARGE_MONO:
            *pidBM = IDB_STDTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = STD_PRINT + 1;
            break;

        case IDB_HIST_SMALL_COLOR:
        case IDB_HIST_LARGE_COLOR:
        //case IDB_HIST_SMALL_MONO:
        //case IDB_HIST_LARGE_MONO:
            *pidBM = IDB_HISTTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = HIST_LAST + 1;
            break;

        case IDB_VIEW_SMALL_COLOR:
        case IDB_VIEW_LARGE_COLOR:
        case IDB_VIEW_SMALL_MONO:
        case IDB_VIEW_LARGE_MONO:
            *pidBM = IDB_VIEWTB_SMALL_COLOR + (*pidBM & 1);
            *pnButtons = VIEW_NEWFOLDER + 1;
            break;
        }
    }
}

//
//  the PBITMAP points to the BITMAP structure that was GetObject'd from
//  the hbm, except that pbm->bmWidth and pbm->bmHeight have been adjusted
//  to represent the *desired* height and width, not the actual height
//  and width.
//
HBITMAP _CopyBitmap(PTBSTATE ptb, HBITMAP hbm, PBITMAP pbm)
{
    HBITMAP hbmCopy = NULL;
    HDC hdcWin;
    HDC hdcSrc, hdcDest;

    // Old code called CreateColorBitmap, which is bad on multimon systems
    // because it will create a bitmap that ImageList_AddMasked can't handle,
    // resulting in disabled toolbar buttons looking bad.

    // so we have to create the bitmap copy in the same format as the source

    hdcWin = GetDC(ptb->ci.hwnd);
    hdcSrc = CreateCompatibleDC(hdcWin);
    hdcDest = CreateCompatibleDC(hdcWin);
    if (hdcWin && hdcSrc && hdcDest) {

        SelectObject(hdcSrc, hbm);

        if (pbm->bmBits) {
            // Source was a DIB section.  Create a DIB section in the same
            // color format with the same palette.
            //
            // Man, creating a DIB section is so annoying.

            struct {                    // Our private version of BITMAPINFO
                BITMAPINFOHEADER bmiHeader;
                RGBQUAD bmiColors[256];
            } bmi;
            UINT cBitsPixel;
            LPVOID pvDummy;

            ZeroMemory(&bmi.bmiHeader, sizeof(bmi.bmiHeader));

            bmi.bmiHeader.biSize = sizeof(bmi.bmiHeader);
            bmi.bmiHeader.biWidth = pbm->bmWidth;
            bmi.bmiHeader.biHeight = pbm->bmHeight;
            bmi.bmiHeader.biPlanes = 1;

            // DIB color depths must be exactly 1, 4, 8 or 24.
            cBitsPixel = pbm->bmPlanes * pbm->bmBitsPixel;
            if (cBitsPixel <= 1)
                bmi.bmiHeader.biBitCount = 1;
            else if (cBitsPixel <= 4)
                bmi.bmiHeader.biBitCount = 4;
            else if (cBitsPixel <= 8)
                bmi.bmiHeader.biBitCount = 8;
            else
                goto CreateDDB; // ImageList_AddMasked doesn't like DIBs deeper than 8bpp

            // And get the color table too
            ASSERT(bmi.bmiHeader.biBitCount <= 8);
            bmi.bmiHeader.biClrUsed = GetDIBColorTable(hdcSrc, 0, 1 << bmi.bmiHeader.biBitCount, bmi.bmiColors);

            ASSERT(bmi.bmiHeader.biCompression == BI_RGB);
            ASSERT(bmi.bmiHeader.biSizeImage == 0);

            hbmCopy = CreateDIBSection(hdcWin, (LPBITMAPINFO)&bmi, DIB_RGB_COLORS, &pvDummy, NULL, 0);

        } else {
            // Source was a DDB.  Create a duplicate DDB.
        CreateDDB:
            // Since the caller may have dorked the bmWidth,
            // we have to recompute the bmWidthBytes, because GDI
            // gets mad if it's not exactly right, even in the bmBits == NULL
            // case.
            pbm->bmBits = NULL;
            pbm->bmWidthBytes = ((pbm->bmBitsPixel * pbm->bmWidth + 15) >> 4) << 1;
            hbmCopy = CreateBitmapIndirect(pbm);

        }

        SelectObject(hdcDest, hbmCopy);

        // fill the background
        PatB(hdcDest, 0, 0, pbm->bmWidth, pbm->bmHeight, g_clrBtnFace);

        BitBlt(hdcDest, 0, 0, pbm->bmWidth, pbm->bmHeight,
               hdcSrc, 0, 0, SRCCOPY);

    }

    if (hdcWin)
        ReleaseDC(ptb->ci.hwnd, hdcWin);

    if (hdcSrc)
        DeleteDC(hdcSrc);
    if (hdcDest)
        DeleteDC(hdcDest);
    return hbmCopy;
}

BOOL TBAddBitmapToImageList(PTBSTATE ptb, PTBBMINFO pTemp)
{
    HBITMAP hbm = NULL, hbmTemp = NULL;
    HIMAGELIST himl = TBGetImageList(ptb, HIML_NORMAL, 0);
    if (!himl) {
        himl = ImageList_Create(ptb->iDxBitmap, ptb->iDyBitmap, ILC_MASK | ILC_COLORDDB, 4, 4);
        if (!himl)
            return(FALSE);
        TBSetImageList(ptb, HIML_NORMAL, 0, himl);
        ImageList_SetBkColor(himl, (ptb->ci.style & TBSTYLE_TRANSPARENT) ? CLR_NONE : g_clrBtnFace);
    }

    if (pTemp->hInst) {
        // can't use LoadImage(..., LR_MAP3DCOLORS) - more than 3 colors
        hbm = hbmTemp = CreateMappedBitmap(pTemp->hInst, pTemp->wID, CMB_DIBSECTION, NULL, 0);

    } else if (pTemp->wID) {
        hbm = (HBITMAP)pTemp->wID;
    }

    if (hbm) {

        //
        // Fix up bitmaps that aren't iDxBitmap x iDyBitmap
        //

        BITMAP bm;

        GetObject( hbm, sizeof(bm), &bm);

        if (bm.bmWidth < ptb->iDxBitmap) {
            bm.bmWidth = ptb->iDxBitmap;
        }

        if (bm.bmHeight < ptb->iDyBitmap) {
            bm.bmHeight = ptb->iDyBitmap;
        }

        // The error cases we are catching are:
        // If the pTemp->nButtons is 0 then we assume there is one button
        // If width of the bitmap is less than what it is supposed to be, we fix it.
        if (!pTemp->nButtons)
            bm.bmWidth = ptb->iDxBitmap;
        else if (pTemp->nButtons > (bm.bmWidth / ptb->iDxBitmap))
            bm.bmWidth = ptb->iDxBitmap * pTemp->nButtons;

        // Must preserve color depth to keep ImageList_AddMasked happy
        // And if we started with a DIB section, then create a DIB section.
        // (Curiously, CopyImage does not preserve DIB-ness.)
        hbm = (HBITMAP)_CopyBitmap(ptb, hbm, &bm);

    }

    // AddMasked parties on the bitmap, so we want to use a local copy
    if (hbm) {
        ImageList_AddMasked(himl, hbm, g_clrBtnFace);

        DeleteObject(hbm);
    }

    if (hbmTemp) {
        DeleteObject(hbmTemp);
    }

    return(TRUE);

}

void TBBuildImageList(PTBSTATE ptb)
{
    int i;
    PTBBMINFO pTemp;
    HIMAGELIST himl;

    ptb->fHimlValid = TRUE;

    // is the parent dealing natively with imagelists?  if so,
    // don't do this back compat building
    if (ptb->fHimlNative)
        return;

    himl = TBSetImageList(ptb, HIML_NORMAL, 0, NULL);
    ImageList_Destroy(himl);

    for (i = 0, pTemp = ptb->pBitmaps; i < ptb->nBitmaps; i++, pTemp++) {

        TBAddBitmapToImageList(ptb, pTemp);
    }

}

/* Adds a new bitmap to the list of BMs available for this toolbar.
 * Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */
int AddBitmap(PTBSTATE ptb, int nButtons, HINSTANCE hBMInst, UINT_PTR idBM)
{
    PTBBMINFO pTemp;
    int nBM, nIndex;

    // map things to the standard toolbar images
    if (hBMInst == HINST_COMMCTRL)        // -1
    {
        // set the proper dimensions...
        if (idBM & 1)
            SetBitmapSize(ptb, LARGE_DXYBITMAP, LARGE_DXYBITMAP);
        else
            SetBitmapSize(ptb, SMALL_DXYBITMAP, SMALL_DXYBITMAP);

        MapToStandardBitmaps(&hBMInst, &idBM, &nButtons);
    }

    if (ptb->pBitmaps)
    {
      /* Check if the bitmap has already been added
       */
        for (nBM=ptb->nBitmaps, pTemp=ptb->pBitmaps, nIndex=0;
            nBM>0; --nBM, ++pTemp)
        {
            if (pTemp->hInst==hBMInst && pTemp->wID==idBM)
            {
                /* We already have this bitmap, but have we "registered" all
                 * the buttons in it?
                 */
                if (pTemp->nButtons >= nButtons)
                    return(nIndex);
                if (nBM == 1)
                {
                /* If this is the last bitmap, we can easily increase the
                 * number of buttons without messing anything up.
                 */
                    pTemp->nButtons = nButtons;
                    return(nIndex);
                }
            }

            nIndex += pTemp->nButtons;
        }

    }

    pTemp = (PTBBMINFO)CCLocalReAlloc(ptb->pBitmaps,
            (ptb->nBitmaps + 1)*sizeof(TBBMINFO));
    if (!pTemp)
        return(-1);
    ptb->pBitmaps = pTemp;

    pTemp = ptb->pBitmaps + ptb->nBitmaps;

    pTemp->hInst = hBMInst;
    pTemp->wID = idBM;
    pTemp->nButtons = nButtons;

    if (!TBAddBitmapToImageList(ptb, pTemp))
        return(-1);

    ++ptb->nBitmaps;

    for (nButtons=0, --pTemp; pTemp>=ptb->pBitmaps; --pTemp)
        nButtons += pTemp->nButtons;


    return(nButtons);
}

/* Adds a bitmap to the list of  BMs available for this
 * toolbar. Returns the index of the first button in the bitmap or -1 if there
 * was an error.
 */

int PASCAL TBLoadImages(PTBSTATE ptb, UINT_PTR id, HINSTANCE hinst)
{
    int iTemp;
    TBBMINFO bmi;
    HIMAGELIST himl;

    MapToStandardBitmaps(&hinst, &id, &iTemp);

    bmi.hInst = hinst;
    bmi.wID = id;
    bmi.nButtons = iTemp;

    himl = TBGetImageList(ptb, HIML_NORMAL, 0);
    if (himl)
        iTemp = ImageList_GetImageCount(himl);
    else
        iTemp = 0;

    if (!TBAddBitmapToImageList(ptb, &bmi))
        return(-1);

    ptb->fHimlNative = TRUE;
    return iTemp;
}

BOOL ReplaceBitmap(PTBSTATE ptb, LPTBREPLACEBITMAP lprb)
{
    int nBM;
    PTBBMINFO pTemp;

    int iTemp;

    MapToStandardBitmaps(&lprb->hInstOld, &lprb->nIDOld, &iTemp);
    MapToStandardBitmaps(&lprb->hInstNew, &lprb->nIDNew, &lprb->nButtons);

    for (nBM=ptb->nBitmaps, pTemp=ptb->pBitmaps;
         nBM>0; --nBM, ++pTemp)
    {
        if (pTemp->hInst==lprb->hInstOld && pTemp->wID==lprb->nIDOld)
        {
            // number of buttons must match
            pTemp->hInst = lprb->hInstNew;
            pTemp->wID = lprb->nIDNew;
            pTemp->nButtons = lprb->nButtons;
            TBInvalidateImageList(ptb);
            return TRUE;
        }
    }

    return FALSE;
}


void TBInvalidateItemRects(PTBSTATE ptb)
{
    // Invalidate item rect cache
    ptb->fItemRectsValid = FALSE;

    // Invalidate the tooltips
    ptb->fTTNeedsFlush = TRUE;

    // Invalidate the ideal size cache
    ptb->szCached.cx = -1;
    ptb->szCached.cy = -1;
}

void FlushToolTipsMgrNow(PTBSTATE ptb) {

    // change all the rects for the tool tips mgr.  this is
    // cheap, and we don't do it often, so go ahead
    // and do them all.
    if(ptb->hwndToolTips) {
        UINT i;
        TOOLINFO ti;
        LPTBBUTTONDATA pButton;

        ti.cbSize = SIZEOF(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        for ( i = 0, pButton = ptb->Buttons;
             i < (UINT)ptb->iNumButtons;
             i++, pButton++) {

            if (!(pButton->fsStyle & BTNS_SEP)) {
                ti.uId = pButton->idCommand;

                if (!TB_GetItemRect(ptb, i, &ti.rect) ||
                   ((ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) && TBIsRectClipped(ptb, &ti.rect))) {

                    ti.rect.left = ti.rect.right = ti.rect.top = ti.rect.bottom = 0;
                }

                SendMessage(ptb->hwndToolTips, TTM_NEWTOOLRECT, 0, (LPARAM)((LPTOOLINFO)&ti));
            }
        }

        ptb->fTTNeedsFlush = FALSE;
    }
}

BOOL TBReallocButtons(PTBSTATE ptb, UINT uButtons)
{
    LPTBBUTTONDATA ptbbNew;
    LPTBBUTTONDATA pOldCaptureButton;

    if (!ptb || !ptb->uStructSize)
        return FALSE;

    // When we realloc the Button array, make sure all interior pointers
    //  move with it.  (This should probably be an index.)
    pOldCaptureButton = ptb->pCaptureButton;

    // realloc the button table
    ptbbNew = (LPTBBUTTONDATA)CCLocalReAlloc(ptb->Buttons,
                                             uButtons * sizeof(TBBUTTONDATA));

    if (!ptbbNew) return FALSE;

    if (pOldCaptureButton)
        ptb->pCaptureButton = (LPTBBUTTONDATA)(
                        (LPBYTE)ptbbNew +
                          ((LPBYTE)pOldCaptureButton - (LPBYTE)ptb->Buttons));
    ptb->Buttons = ptbbNew;

    return TRUE;
}

BOOL TBInsertButtons(PTBSTATE ptb, UINT uWhere, UINT uButtons, LPTBBUTTON lpButtons, BOOL fNative)
{
    LPTBBUTTONDATA pOut;
    LPTBBUTTONDATA ptbbIn;
    UINT    uAdded;
    UINT    uStart;
    BOOL fRecalc;
    int idHot = -1;

    if (!TBReallocButtons(ptb, ptb->iNumButtons + uButtons))
        return FALSE;

    // comments by chee (not the original author) so they not be
    // exactly right... be warned.

    // if where points beyond the end, set it at the end
    if (uWhere > (UINT)ptb->iNumButtons)
        uWhere = ptb->iNumButtons;

    // Need to save these since the values gues toasted.
    uAdded = uButtons;
    uStart = uWhere;

    // Correct the hot item when we add something something. Since the hot item is index based, the index
    // has probrably changed
    if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
        idHot = ptb->Buttons[ptb->iHot].idCommand;

    // move buttons above uWhere up uButton spaces
    // the uWhere gets inverted and counts to zero..
    //
    // REVIEW: couldn't this be done with MoveMemory?
    //  MoveMemory(&ptb->Buttons[uWhere], &ptb->Buttons[uWhere+uButtons], sizeof(ptb->Buttons[0])*(ptb->iNumButtons - uWhere));
    //
    for (ptbbIn = &ptb->Buttons[ptb->iNumButtons-1], pOut = ptbbIn+uButtons,
         uWhere=(UINT)ptb->iNumButtons-uWhere; uWhere>0;
     --ptbbIn, --pOut, --uWhere)
        *pOut = *ptbbIn;

    // only need to recalc if there are strings & room enough to actually show them
    fRecalc = (TBHasStrings(ptb) && ((ptb->ci.style & TBSTYLE_LIST) || ((ptb->iDyBitmap + ptb->yPad + g_cyEdge) < ptb->iButHeight)));

    // now do the copy.
    for (lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons+ptb->uStructSize*(uButtons-1)),
        ptb->iNumButtons+=(int)uButtons;  // init
        uButtons>0; //test
        --pOut, lpButtons=(LPTBBUTTON)((LPBYTE)lpButtons-ptb->uStructSize), --uButtons)
    {
        TBInputStruct(ptb, pOut, lpButtons);

        // If this button is a seperator, then should not use the string
        // buffer passed in, because it could be bogus data.
        if (pOut->fsStyle & BTNS_SEP)
            pOut->iString = -1;

        if (TBISSTRINGPTR(pOut->iString)) {
            LPTSTR psz = (LPTSTR)pOut->iString;
#ifdef UNICODE
            if (!fNative) {
                psz = ProduceWFromA(ptb->ci.uiCodePage, (LPSTR)psz);
            }
#endif
            pOut->iString = 0;
            Str_Set((LPTSTR*)&pOut->iString, psz);

#ifdef UNICODE
            if (!fNative)
                FreeProducedString(psz);
#endif
            if (!ptb->fNoStringPool)
                fRecalc = TRUE;

            ptb->fNoStringPool = TRUE;
        }

        if(ptb->hwndToolTips && !(lpButtons->fsStyle & BTNS_SEP)) {
            TOOLINFO ti;
            // don't bother setting the rect because we'll do it below
            // in TBInvalidateItemRects;
            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            ti.hwnd = ptb->ci.hwnd;
            ti.uId = lpButtons->idCommand;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                (LPARAM)(LPTOOLINFO)&ti);
        }

        if (pOut->fsStyle & BTNS_SEP && pOut->DUMMYUNION_MEMBER(cxySep) <= 0)
        {

            // Compat: Corel (Font navigator) expects the separators to be
            // 8 pixels wide.
            // as do many old apps.
            //
            // so if it's not flat or not vertical, put it to defautl to win95 size
            pOut->DUMMYUNION_MEMBER(cxySep) = g_dxButtonSep;
        }
    }

    // Re-compute layout if toolbar is wrappable.
    if ((ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN) || 
        (ptb->ci.style & TBSTYLE_WRAPABLE))
    {
        // NOTE: we used to do send ourself a message instead of call directly...
        //SendMessage(ptb->ci.hwnd, TB_AUTOSIZE, 0, 0);
        TBAutoSize(ptb);
    }

    TBInvalidateItemRects(ptb);

    // adding and removing buttons during toolbar customization shouldn't
    // result in recalcing the sizes of buttons.
    if (fRecalc && !ptb->hdlgCust)
        TBRecalc(ptb);

    //
    // Reorder notification so apps can go requery what's on the toolbar if
    // more than 1 button was added; otherwise, just say create.
    //
    if (uAdded == 1)
        MyNotifyWinEvent(EVENT_OBJECT_CREATE, ptb->ci.hwnd, OBJID_CLIENT,
            uWhere+1);
    else
        MyNotifyWinEvent(EVENT_OBJECT_REORDER, ptb->ci.hwnd, OBJID_CLIENT, 0);

    // was there a hot item before the delete?
    if (idHot != -1)
    {
        // Yes; Then update it to the current index
        ptb->iHot = PositionFromID(ptb, idHot);
    }

    TBInvalidateItemRects(ptb);

    // We need to completely redraw the toolbar at this point.
    // this MUST be done last!
    // tbrecalc and others will nuke out invalid area and we won't paint if this isn't last
    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
    return(TRUE);
}


/* Notice that the state structure is not realloc'ed smaller at this
 * point.  This is a time optimization, and the fact that the structure
 * will not move is used in other places.
 */
BOOL DeleteButton(PTBSTATE ptb, UINT uIndex)
{
    TBNOTIFY tbn = { 0 };
    LPTBBUTTONDATA pIn, pOut;
    BOOL fRecalc;
    int idHot = -1;



    if (uIndex >= (UINT)ptb->iNumButtons)
        return FALSE;

    if (&ptb->Buttons[uIndex] == ptb->pCaptureButton) {
        if (ptb->uStructSize == 0x14)
            ptb->fRequeryCapture = TRUE;
        if (!CCReleaseCapture(&ptb->ci)) return FALSE;
        ptb->pCaptureButton = NULL;
    }

    // Correct the hot item when we remove something. Since the hot item is index based, the index
    // has probrably changed
    if (ptb->iHot >= 0 && ptb->iHot < ptb->iNumButtons)
        idHot = ptb->Buttons[ptb->iHot].idCommand;

    // Notify Active Accessibility of the delete
    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, ptb->ci.hwnd, OBJID_CLIENT, uIndex+1);

    // Notify client of the delete
    tbn.iItem = ptb->Buttons[uIndex].idCommand;
    TBOutputStruct(ptb, &ptb->Buttons[uIndex], &tbn.tbButton);
    CCSendNotify(&ptb->ci, TBN_DELETINGBUTTON, &tbn.hdr);


    if (TBISSTRINGPTR(ptb->Buttons[uIndex].iString))
        Str_Set((LPTSTR*)&ptb->Buttons[uIndex].iString, NULL);

    if (ptb->hwndToolTips) {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = ptb->Buttons[uIndex].idCommand;
        SendMessage(ptb->hwndToolTips, TTM_DELTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
    }

    --ptb->iNumButtons;

    pOut = ptb->Buttons + uIndex;

    fRecalc = (pOut->fsState & TBSTATE_WRAP);

    for (pIn = pOut + 1; uIndex<(UINT)ptb->iNumButtons; ++uIndex, ++pIn, ++pOut)
    {
        fRecalc |= (pIn->fsState & TBSTATE_WRAP);
        *pOut = *pIn;
    }

    // We need to completely recalc or redraw the toolbar at this point.
    if (((ptb->ci.style & TBSTYLE_WRAPABLE)
            || (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)) && fRecalc)
    {
        RECT rc;
        HWND hwnd = ptb->ci.hwnd;

        if (!(ptb->ci.style & CCS_NORESIZE) && !(ptb->ci.style & CCS_NOPARENTALIGN))
            hwnd = GetParent(hwnd);

        GetWindowRect(hwnd, &rc);

        if (ptb->ci.style & TBSTYLE_WRAPABLE)
            WrapToolbar(ptb, rc.right - rc.left, &rc, NULL);
        else
            WrapToolbarCol(ptb, ptb->sizeBound.cy, &rc, NULL);
    }

    // was there a hot item before the delete?
    if (idHot != -1)
    {
        // Yes; Then update it to the current index
        ptb->iHot = PositionFromID(ptb, idHot);
    }


    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    TBInvalidateItemRects(ptb);

    return TRUE;
}

// move button at location iOld to location iNew, sliding everything
// after iNew UP.
BOOL PASCAL TBMoveButton(PTBSTATE ptb, UINT iOld, UINT iNew)
{
    TBBUTTONDATA tbd, *ptbdOld, *ptbdNew;

    if (iOld >= (UINT)ptb->iNumButtons)
        return FALSE;

    if (iNew > (UINT)ptb->iNumButtons-1)
        iNew = (UINT)ptb->iNumButtons-1;

    if (iOld == iNew)
        return FALSE;

    TBInvalidateItemRects(ptb);

    ptbdOld = &(ptb->Buttons[iOld]);
    ptbdNew = &(ptb->Buttons[iNew]);

    tbd = *ptbdOld;

#if 0
    if (iOld < iNew)
        MoveMemory(ptbdOld+1, ptbdOld, (iNew - iOld) * SIZEOF(tbd));
    else
        MoveMemory(ptbdNew, ptbdNew+1, (iOld - iNew) * SIZEOF(tbd));
#else
    {
        TBBUTTONDATA *ptbdSrc;
        TBBUTTONDATA *ptbdDst;
        int iCount, iInc;

        if (iOld < iNew)
        {
            // move [iOld+1..iNew] to [iOld..iNew-1]
            iCount = iNew - iOld;
            iInc = 1;
            ptbdSrc = ptbdOld + 1;
            ptbdDst = ptbdOld;

            if (ptb->pCaptureButton > ptbdOld && ptb->pCaptureButton <= ptbdNew)
                ptb->pCaptureButton--;
        }
        else
        {
            ASSERT(iNew < iOld);

            // move [iNew..iOld-1] to [iNew+1..iOld]
            iCount = iOld - iNew;
            iInc = -1;
            ptbdSrc = ptbdNew + iCount - 1;
            ptbdDst = ptbdNew + iCount;

            if (ptb->pCaptureButton >= ptbdNew && ptb->pCaptureButton < ptbdOld)
                ptb->pCaptureButton++;
        }

        do {
            *ptbdDst = *ptbdSrc;
            ptbdDst += iInc;
            ptbdSrc += iInc;
            iCount--;
        } while (iCount);
    }
#endif

    *ptbdNew = tbd;

    if (ptb->pCaptureButton == ptbdOld)
        ptb->pCaptureButton = ptbdNew;

    TBAutoSize(ptb);
    InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    return TRUE;
}


// deal with old TBBUTON structs for compatibility
void TBInputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt)
{
    pButtonInt->DUMMYUNION_MEMBER(iBitmap) = pButtonExt->iBitmap;
    pButtonInt->idCommand = pButtonExt->idCommand;
    pButtonInt->fsState = pButtonExt->fsState;
    pButtonInt->fsStyle = pButtonExt->fsStyle;
    pButtonInt->cx = 0;

    if (ptb->uStructSize >= sizeof(TBBUTTON))
    {
        pButtonInt->dwData = pButtonExt->dwData;
        pButtonInt->iString = pButtonExt->iString;
    }
    else
    {
        /* It is assumed the only other possibility is the OLDBUTTON struct */
        /* We don't care about dwData */
        pButtonInt->dwData = 0;
        pButtonInt->iString = -1;
    }
}


void TBOutputStruct(PTBSTATE ptb, LPTBBUTTONDATA pButtonInt, LPTBBUTTON pButtonExt)
{
    ZeroMemory(pButtonExt, ptb->uStructSize);
    pButtonExt->iBitmap = pButtonInt->DUMMYUNION_MEMBER(iBitmap);
    pButtonExt->idCommand = pButtonInt->idCommand;
    pButtonExt->fsState = pButtonInt->fsState;
    pButtonExt->fsStyle = pButtonInt->fsStyle;

    // We're returning cx in the bReserved field
    COMPILETIME_ASSERT(FIELD_OFFSET(TBBUTTONDATA, cx) == FIELD_OFFSET(TBBUTTON, bReserved));
    COMPILETIME_ASSERT(sizeof(pButtonInt->cx) <= sizeof(pButtonExt->bReserved));
    ((LPTBBUTTONDATA)pButtonExt)->cx = pButtonInt->cx;

    if (ptb->uStructSize >= sizeof(TBBUTTON))
    {
        pButtonExt->dwData = pButtonInt->dwData;
        pButtonExt->iString = pButtonInt->iString;
    }
}

void TBOnButtonStructSize(PTBSTATE ptb, UINT uStructSize)
{
    /* You are not allowed to change this after adding buttons.
    */
    if (ptb && !ptb->iNumButtons)
    {
        ptb->uStructSize = uStructSize;
    }
}

void TBAutoSize(PTBSTATE ptb)
{
    HWND hwndParent;
    RECT rc;
    int nTBThickness = 0;

    if (ptb->fRedrawOff) {
        // redraw is off; defer autosize until redraw is turned back on
        ptb->fRecalc = TRUE;
        return;
    }

    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
        nTBThickness = ptb->iButWidth * CountCols(ptb) + g_cyEdge * 2;
    }
    else
        nTBThickness = ptb->iButHeight * CountRows(ptb) + g_cxEdge * 2;

    hwndParent = GetParent(ptb->ci.hwnd);
    if (!hwndParent)
        return;

    if ((ptb->ci.style & TBSTYLE_WRAPABLE)
                    || (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN))
    {
        RECT rcNew;

        if ((ptb->ci.style & CCS_NORESIZE) || (ptb->ci.style & CCS_NOPARENTALIGN))
            GetWindowRect(ptb->ci.hwnd, &rc);
        else
            GetWindowRect(hwndParent, &rc);

        if (ptb->ci.style & TBSTYLE_WRAPABLE)
            WrapToolbar(ptb, rc.right - rc.left, &rcNew, NULL);
        else
            WrapToolbarCol(ptb, ptb->sizeBound.cy, &rcNew, NULL);

        // Some sample app found a bug in our autosize code which this line
        // fixes. Unfortunately Carbon Copy 32 (IE4 bug 31943) relies on the
        // broken behavior and fixing this clips the buttons.
        //
        //nTBThickness = rcNew.bottom - rcNew.top + g_cxEdge;
    }

    if ((ptb->ci.style & TBSTYLE_WRAPABLE) ||
        (ptb->dwStyleEx & (TBSTYLE_EX_MULTICOLUMN | TBSTYLE_EX_HIDECLIPPEDBUTTONS)))
    {
        TBInvalidateItemRects(ptb);
    }

    GetWindowRect(ptb->ci.hwnd, &rc);
    MapWindowPoints(HWND_DESKTOP, hwndParent, (LPPOINT)&rc, 2);
    NewSize(ptb->ci.hwnd, nTBThickness, ptb->ci.style,
            rc.left, rc.top, rc.right, rc.bottom);
}

void TBSetStyle(PTBSTATE ptb, DWORD dwStyle)
{
    BOOL fSizeChanged = FALSE;

    if ((BOOL)(ptb->ci.style & TBSTYLE_WRAPABLE) != (BOOL)(dwStyle & TBSTYLE_WRAPABLE))
    {
        int i;
        fSizeChanged = TRUE;

        for (i=0; i<ptb->iNumButtons; i++)
            ptb->Buttons[i].fsState &= ~TBSTATE_WRAP;
    }

    ptb->ci.style = dwStyle;

    if (fSizeChanged)
        TBRecalc(ptb);

    TBAutoSize(ptb);

    TraceMsg(TF_TOOLBAR, "toolbar window style changed %x", ptb->ci.style);
}

void TBSetStyleEx(PTBSTATE ptb, DWORD dwStyleEx, DWORD dwStyleMaskEx)
{
    BOOL fSizeChanged = FALSE;

    if (dwStyleMaskEx)
        dwStyleEx = (ptb->dwStyleEx & ~dwStyleMaskEx) | (dwStyleEx & dwStyleMaskEx);

    // Second, we can validate a few of the bits:
    // Multicolumn should never be set w/o the vertical style...
    ASSERT((ptb->dwStyleEx & TBSTYLE_EX_VERTICAL) || !(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));
    // also can't be set with hide clipped buttons style (for now)
    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS) || !(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));
    // ...but just in case someone gets it wrong, we'll set the vertical
    // style and rip off the hide clipped buttons style
    if (dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        dwStyleEx |= TBSTYLE_EX_VERTICAL;
        dwStyleEx &= ~TBSTYLE_EX_HIDECLIPPEDBUTTONS;
    }

    // Then, some things need to be tweaked when they change
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_MULTICOLUMN)
    {
        int i;
        // Clear all the wrap states if we're changing multicolumn styles
        for (i = 0; i < ptb->iNumButtons; i++)
            ptb->Buttons[i].fsState &= ~TBSTATE_WRAP;

        fSizeChanged = TRUE;
    }
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_MIXEDBUTTONS)
    {
        int i;
        for (i = 0; i < ptb->iNumButtons; i++)
            (ptb->Buttons[i]).cx = 0;

        fSizeChanged = TRUE;
        
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
    }
    if ((ptb->dwStyleEx ^ dwStyleEx) & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
        InvalidateRect(ptb->ci.hwnd, NULL, TRUE);

    ptb->dwStyleEx = dwStyleEx;

    if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
        TBSetStyle(ptb, CCS_VERT);      // vertical sep and insert mark orientation

    if (fSizeChanged)
    {
        TBRecalc(ptb);
        TBAutoSize(ptb);
    }

    TraceMsg(TF_TOOLBAR, "toolbar window extended style changed %x", ptb->dwStyleEx);
}


LRESULT TB_OnSetImage(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, int iImage)
{
    if (!ptb->fHimlNative) {
        if (ptb->fHimlValid) {
            if (!TBGetImageList(ptb, HIML_NORMAL, 0) ||
                iImage >= ImageList_GetImageCount(TBGetImageList(ptb, HIML_NORMAL, 0)))
                return FALSE;
        } else {

            PTBBMINFO pTemp;
            int nBitmap;
            UINT nTot;

            // we're not natively himl and we've got some invalid
            // image state, so we need to count the bitmaps ourselvesa
            pTemp = ptb->pBitmaps;
            nTot = 0;

            for (nBitmap=0; nBitmap < ptb->nBitmaps; nBitmap++) {
                nTot += pTemp->nButtons;
                pTemp++;
            }

            if (iImage >= (int)nTot)
                return FALSE;
        }
    }

    ptbButton->DUMMYUNION_MEMBER(iBitmap) = iImage;

    InvalidateButton(ptb, ptbButton, FALSE);
    UpdateWindow(ptb->ci.hwnd);
    return TRUE;
}

void TB_OnDestroy(PTBSTATE ptb)
{
    HWND hwnd = ptb->ci.hwnd;
    int i;

    for (i = 0; i < ptb->iNumButtons; i++) {
        if (TBISSTRINGPTR(ptb->Buttons[i].iString))
            Str_Set((LPTSTR*)&ptb->Buttons[i].iString, NULL);
    }

    //
    // If the toolbar created tooltips, then destroy them.
    //
    if ((ptb->ci.style & TBSTYLE_TOOLTIPS) && IsWindow(ptb->hwndToolTips)) {
        DestroyWindow (ptb->hwndToolTips);
        ptb->hwndToolTips = NULL;
    }

    if (ptb->hDragProxy)
        DestroyDragProxy(ptb->hDragProxy);

    if (ptb->hbmMono)
        DeleteObject(ptb->hbmMono);

    ReleaseMonoDC(ptb);

    if (ptb->nStrings > 0)
        DestroyStrings(ptb);

    if (ptb->hfontIcon && ptb->fFontCreated)
        DeleteObject(ptb->hfontIcon);

    // only do this destroy if pBitmaps exists..
    // this is our signal that it was from an old style toolba
    // and we created it ourselves.
    if (ptb->pBitmaps)
        ImageList_Destroy(TBGetImageList(ptb, HIML_NORMAL, 0));

    if (ptb->pBitmaps)
        LocalFree(ptb->pBitmaps);

    // couldn't have created tb if pimgs creation failed
    CCLocalReAlloc(ptb->pimgs, 0);

    Str_Set(&ptb->pszTip, NULL);
    if (ptb->Buttons) LocalFree(ptb->Buttons);
    LocalFree((HLOCAL)ptb);
    SetWindowInt(hwnd, 0, 0);

    TerminateDitherBrush();
}

void TB_OnSetState(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, BYTE bState, int iPos)
{
    BYTE fsState;
    fsState = bState ^ ptbButton->fsState;
    ptbButton->fsState = bState;

    if (fsState)
    {
        if (ptb->fRedrawOff)
        {
            ptb->fInvalidate = ptb->fRecalc = TRUE;
        }
        else
        {
            if (fsState & TBSTATE_HIDDEN)
            {
                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
                TBRecalc(ptb);
            }
            else
                InvalidateButton(ptb, ptbButton, TRUE);

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, ptb->ci.hwnd, OBJID_CLIENT,
                             iPos+1);
        }
    }
}

void TB_OnSetCmdID(PTBSTATE ptb, LPTBBUTTONDATA ptbButton, UINT idCommand)
{
    UINT uiOldID;

    uiOldID = ptbButton->idCommand;
    ptbButton->idCommand = idCommand;

    //
    // If the app was using tooltips, then
    // we need to update the command id there also.
    //

    if(ptb->hwndToolTips) {
        TOOLINFO ti;

        //
        // Query the old information
        //

        ti.cbSize = sizeof(ti);
        ti.hwnd = ptb->ci.hwnd;
        ti.uId = uiOldID;
        SendMessage(ptb->hwndToolTips, TTM_GETTOOLINFO, 0,
                    (LPARAM)(LPTOOLINFO)&ti);

        //
        // Delete the old tool since we can't just
        // change the command id.
        //

        SendMessage(ptb->hwndToolTips, TTM_DELTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);

        //
        // Add the new tool with the new command id.
        //

        ti.uId = idCommand;
        SendMessage(ptb->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
    }
}



LRESULT TB_OnSetButtonInfo(PTBSTATE ptb, int idBtn, LPTBBUTTONINFO ptbbi)
{
    int iPos;
    BOOL fInvalidateAll = FALSE;

    if (ptbbi->cbSize != SIZEOF(TBBUTTONINFO))
        return 0;

    if (ptbbi->dwMask & TBIF_BYINDEX)
        iPos = idBtn;
    else
        iPos = PositionFromID(ptb, idBtn);

    if (iPos != -1)
    {
        LPTBBUTTONDATA ptbButton;
        BOOL fInvalidate = FALSE;

        ptbButton = ptb->Buttons + iPos;

        if (ptbbi->dwMask & TBIF_STYLE) {
            if ((ptbButton->fsStyle ^ ptbbi->fsStyle) & (BTNS_DROPDOWN | BTNS_WHOLEDROPDOWN))
            {
                // Width may have changed!
                fInvalidateAll = TRUE;
            }
            if ((ptbButton->fsStyle ^ ptbbi->fsStyle) & BTNS_AUTOSIZE)
                ptbButton->cx = 0;

            ptbButton->fsStyle = ptbbi->fsStyle;
            fInvalidate = TRUE;
        }

        if (ptbbi->dwMask & TBIF_STATE) {
            TB_OnSetState(ptb, ptbButton, ptbbi->fsState, iPos);
        }

        if (ptbbi->dwMask & TBIF_IMAGE) {
            TB_OnSetImage(ptb, ptbButton, ptbbi->iImage);
        }

        if (ptbbi->dwMask & TBIF_SIZE) {
            ptbButton->cx = ptbbi->cx;
            fInvalidate = TRUE;
            fInvalidateAll = TRUE;
        }

        if (ptbbi->dwMask & TBIF_TEXT) {

            // changing the text on an autosize button means recalc
            if (BTN_IS_AUTOSIZE(ptb, ptbButton)) {
                fInvalidateAll = TRUE;
                ptbButton->cx = (WORD)0;
            }

            ptb->fNoStringPool = TRUE;
            if (!TBISSTRINGPTR(ptbButton->iString)) {
                ptbButton->iString = 0;
            }

            Str_Set((LPTSTR*)&ptbButton->iString, ptbbi->pszText);
            fInvalidate = TRUE;

        }

        if (ptbbi->dwMask & TBIF_LPARAM) {
            ptbButton->dwData = ptbbi->lParam;
        }

        if (ptbbi->dwMask & TBIF_COMMAND) {
            TB_OnSetCmdID(ptb, ptbButton, ptbbi->idCommand);
        }

        if (fInvalidateAll || fInvalidate) {
            TBInvalidateItemRects(ptb);
            if (fInvalidateAll)
                InvalidateRect(ptb->ci.hwnd, NULL, TRUE);
            else
                InvalidateButton(ptb, ptbButton, TRUE);
        }

        return TRUE;
    }

    return FALSE;
}

LRESULT TB_OnGetButtonInfo(PTBSTATE ptb, int idBtn, LPTBBUTTONINFO ptbbi)
{
    int iPos;

    if (ptbbi->cbSize != SIZEOF(TBBUTTONINFO))
        return -1;

    if (ptbbi->dwMask & TBIF_BYINDEX)
        iPos = idBtn;
    else
        iPos = PositionFromID(ptb, idBtn);
    if (iPos >= 0 && iPos < ptb->iNumButtons)
    {
        LPTBBUTTONDATA ptbButton;
        ptbButton = ptb->Buttons + iPos;

        if (ptbbi->dwMask & TBIF_STYLE) {
            ptbbi->fsStyle = ptbButton->fsStyle;
        }

        if (ptbbi->dwMask & TBIF_STATE) {
            ptbbi->fsState = ptbButton->fsState;
        }

        if (ptbbi->dwMask & TBIF_IMAGE) {
            ptbbi->iImage = ptbButton->DUMMYUNION_MEMBER(iBitmap);
        }

        if (ptbbi->dwMask & TBIF_SIZE) {
            ptbbi->cx = (WORD) ptbButton->cx;
        }

        if (ptbbi->dwMask & TBIF_TEXT) {

            if (TBISSTRINGPTR(ptbButton->iString)) {
                lstrcpyn(ptbbi->pszText, (LPCTSTR)ptbButton->iString, ptbbi->cchText);
            }
        }

        if (ptbbi->dwMask & TBIF_LPARAM) {
            ptbbi->lParam = ptbButton->dwData;
        }

        if (ptbbi->dwMask & TBIF_COMMAND) {
            ptbbi->idCommand = ptbButton->idCommand;
        }
    } else
        iPos = -1;

    return iPos;
}

UINT GetAccelerator(LPTSTR psz)
{
    UINT ch = (UINT)-1;
    LPTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = FastCharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = FastCharNext(pszAccel);
        }
    } 
    while (pszAccel && (ch == (UINT)-1));

    return ch;
}


UINT TBButtonAccelerator(PTBSTATE ptb, LPTBBUTTONDATA ptbn)
{
    UINT ch = (UINT)-1;
    LPTSTR psz = TB_StrForButton(ptb, ptbn);

    if (psz && *psz) {
        if (!(ptb->uDrawTextMask & ptb->uDrawText & DT_NOPREFIX)) {
            ch = GetAccelerator(psz);
        }

        if (ch == (UINT)-1) {
            // no prefix found.  use the first char
#ifndef UNICODE
            if (IsDBCSLeadByte((BYTE)*psz))
                ch = ((BYTE)*psz << 8) | (BYTE)*(psz + 1);
            else
#endif
            ch = (UINT)*psz;
        }
    }
    return (UINT)ch;
}


/*----------------------------------------------------------
Purpose: Returns the number of buttons that have the passed
            in char as their accelerator

*/
int TBHasAccelerator(PTBSTATE ptb, UINT ch)
{
    int i;
    int c = 0;
    for (i = 0; i < ptb->iNumButtons; i++)
    {
        if (!ChrCmpI((WORD)TBButtonAccelerator(ptb, &ptb->Buttons[i]), (WORD)ch))
            c++;
    }

    if (c == 0)
    {
        NMCHAR nm = {0};
        nm.ch = ch;
        nm.dwItemPrev = 0;
        nm.dwItemNext = -1;

        // The duplicate accelerator is used to expand or execute a menu item,
        // if we determine that there are no items, we still want to ask the 
        // owner if there are any...

        if (CCSendNotify(&ptb->ci, TBN_MAPACCELERATOR, &nm.hdr) &&
            nm.dwItemNext != -1)
        {
            c++;
        }
    }

    return c;
}

/*----------------------------------------------------------
Purpose: Returns TRUE if the character maps to more than one
         button.

*/
BOOL TBHasDupChar(PTBSTATE ptb, UINT ch)
{
    BOOL bRet = FALSE;
    NMTBDUPACCELERATOR nmda;

    int c = 0;

    nmda.ch = ch;

    // BUGBUG (lamadio): this is going away
    if (CCSendNotify(&ptb->ci, TBN_DUPACCELERATOR, &nmda.hdr))
    {
        bRet = nmda.fDup;
    }
    else
    {
        if (TBHasAccelerator(ptb, ch) > 1)
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Returns the index of the item whose accelerator matches
         the given character.  Starts at the current hot item.

Returns: -1 if nothing found

*/
int TBItemFromAccelerator(PTBSTATE ptb, UINT ch, BOOL * pbDup)
{
    int iRet = -1;
    int i;
    int iStart = ptb->iHot;

    NMTBWRAPACCELERATOR nmwa;
    NMCHAR nm = {0};
    nm.ch = ch;
    nm.dwItemPrev = iStart;
    nm.dwItemNext = -1;

    // Ask the client if they want to handle this keyboard press
    if (CCSendNotify(&ptb->ci, TBN_MAPACCELERATOR, &nm.hdr) &&
        (int)nm.dwItemNext > iStart && (int)nm.dwItemNext < ptb->iNumButtons)
    {
        // They handled it, so we're just going to return the position
        // that they said.
        iRet =  nm.dwItemNext;
    }
    else for (i = 0; i < ptb->iNumButtons; i++)
    {

        if ( iStart + 1 >= ptb->iNumButtons )
        {
            nmwa.ch = ch;
            if (CCSendNotify(&ptb->ci, TBN_WRAPACCELERATOR, &nmwa.hdr))
                return nmwa.iButton;
        }

        iStart += 1 + ptb->iNumButtons;
        iStart %= ptb->iNumButtons;

        if ((ptb->Buttons[iStart].fsState & TBSTATE_ENABLED) &&
            !ChrCmpI((WORD)TBButtonAccelerator(ptb, &ptb->Buttons[iStart]), (WORD)ch))
        {
            iRet = iStart;
            break;
        }

    }

    *pbDup = TBHasDupChar(ptb, ch);

    return iRet;
}


BOOL TBOnChar(PTBSTATE ptb, UINT ch)
{
    NMCHAR nm = {0};
    BOOL bDupChar;
    int iPos = TBItemFromAccelerator(ptb, ch, &bDupChar);
    BOOL fHandled = FALSE;

    // Send the notification.  Parent may want to change the next button.
    nm.ch = ch;
    nm.dwItemPrev = (0 <= ptb->iHot) ? ptb->Buttons[ptb->iHot].idCommand : -1;
    nm.dwItemNext = (0 <= iPos) ? ptb->Buttons[iPos].idCommand : -1;
    if (CCSendNotify(&ptb->ci, NM_CHAR, (LPNMHDR)&nm))
        return TRUE;

    iPos = PositionFromID(ptb, nm.dwItemNext);

    if (-1 != iPos)
    {
        DWORD dwFlags = HICF_ACCELERATOR;

        if (ptb->iHot == iPos)
            dwFlags |= HICF_RESELECT;

        if (bDupChar)
            dwFlags |= HICF_DUPACCEL;

        TBSetHotItem(ptb, iPos, dwFlags);

        if (bDupChar)
            iPos = -1;

        fHandled = TRUE;
    } else {

        // handle this here instead of VK_KEYDOWN
        // because a typical thing to do is to pop down a menu
        // which will beep when it gets the WM_CHAR resulting from
        // the VK_KEYDOWN
        switch (ch) {
        case ' ':
        case 13:
            if (ptb->iHot != -1)
            {
                LPTBBUTTONDATA ptbButton = &ptb->Buttons[ptb->iHot];
                if (TB_IsDropDown(ptbButton) &&
                    !TB_HasSplitDDArrow(ptb, ptbButton))
                {
                    iPos = ptb->iHot;
                    fHandled = TRUE;
                }
                break;
            }
        }
    }

    if (-1 != iPos) {
        LPTBBUTTONDATA ptbButton = &ptb->Buttons[iPos];
        if (TB_IsDropDown(ptbButton))
            TBToggleDropDown(ptb, iPos, FALSE);
    }
#ifdef KEYBOARDCUES
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
#endif

    return fHandled;
}


BOOL TBOnMapAccelerator(PTBSTATE ptb, UINT ch, UINT * pidCmd)
{
    int iPos;
    BOOL bDupChar;

    ASSERT(IS_VALID_WRITE_PTR(pidCmd, UINT));

    iPos = TBItemFromAccelerator(ptb, ch, &bDupChar);
    if (-1 != iPos)
    {
        *pidCmd = ptb->Buttons[iPos].idCommand;
        return TRUE;
    }
    return FALSE;
}


BOOL TBOnKey(PTBSTATE ptb, int nVirtKey, UINT uFlags)
{
    NMKEY nm;

    // Send the notification
    nm.nVKey = nVirtKey;
    nm.uFlags = uFlags;
    if (CCSendNotify(&ptb->ci, NM_KEYDOWN, &nm.hdr))
        return TRUE;

    // Swap the left and right arrow key if the control is mirrored.
    nVirtKey = RTLSwapLeftRightArrows(&ptb->ci, nVirtKey);

    if (ptb->iHot != -1 && TB_IsDropDown(&ptb->Buttons[ptb->iHot])) {
        // if we're on a dropdown button and you hit the up/down arrow (left/rigth in vert mode)
        // then drop the button down.
        // escape undrops it if it's dropped
        switch (nVirtKey) {
        case VK_RIGHT:
        case VK_LEFT:
            if (!(ptb->ci.style & CCS_VERT))
                break;
            goto DropDown;

        case VK_DOWN:
        case VK_UP:
            if ((ptb->ci.style & CCS_VERT) || (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL))
                break;
            goto DropDown;


        case VK_ESCAPE:
            if (ptb->iHot != ptb->iPressedDD)
                break;
DropDown:
            TBToggleDropDown(ptb, ptb->iHot, FALSE);
#ifdef KEYBOARDCUES
            //notify of navigation key usage
            CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
#endif
            return TRUE;
        }
    }


    switch (nVirtKey) {
    case VK_RIGHT:
    case VK_DOWN:
        TBCycleHotItem(ptb, ptb->iHot, 1, HICF_ARROWKEYS);
        break;

    case VK_LEFT:
    case VK_UP:
        TBCycleHotItem(ptb, ptb->iHot, -1, HICF_ARROWKEYS);
        break;

    case VK_SPACE:
    case VK_RETURN:
        if (ptb->iHot != -1)
        {
            FORWARD_WM_COMMAND(ptb->ci.hwndParent, ptb->Buttons[ptb->iHot].idCommand, ptb->ci.hwnd, BN_CLICKED, SendMessage);
        }
        break;

    default:
        return FALSE;
    }

#ifdef KEYBOARDCUES
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(ptb->ci), UISF_HIDEFOCUS | UISF_HIDEACCEL);
#endif
    return TRUE;
}

#ifdef UNICODE
LRESULT TB_OnSetButtonInfoA(PTBSTATE ptb, int idBtn, LPTBBUTTONINFOA ptbbiA)
{
    TBBUTTONINFO tbbi = *(LPTBBUTTONINFO)ptbbiA;
    WCHAR szText[256];

    if ((ptbbiA->dwMask & TBIF_TEXT) && ptbbiA->pszText)
    {
        tbbi.pszText = szText;
        tbbi.cchText = ARRAYSIZE(szText);

        MultiByteToWideChar(CP_ACP, 0, (LPCSTR) ptbbiA->pszText, -1,
                            szText, ARRAYSIZE(szText));
    }

    return TB_OnSetButtonInfo(ptb, idBtn, (LPTBBUTTONINFO)&tbbi);
}

LRESULT TB_OnGetButtonInfoA(PTBSTATE ptb, int idBtn, LPTBBUTTONINFOA ptbbiA)
{
    LPTBBUTTONDATA ptbButton;
    int iPos;
    DWORD dwMask = ptbbiA->dwMask;

    ptbbiA->dwMask &= ~TBIF_TEXT;

    iPos = (int) TB_OnGetButtonInfo(ptb, idBtn, (LPTBBUTTONINFO)ptbbiA);

    if (iPos != -1)
    {
        ptbButton = ptb->Buttons + iPos;

        ptbbiA->dwMask = dwMask;
        if (ptbbiA->dwMask & TBIF_TEXT) {
            if (TBISSTRINGPTR(ptbButton->iString)) {
                WideCharToMultiByte (CP_ACP, 0, (LPCTSTR)ptbButton->iString,
                                     -1, ptbbiA->pszText , ptbbiA->cchText, NULL, NULL);
            } else {
                ptbbiA->pszText[0] = 0;
            }
        }
    }

    return iPos;
}

#endif


void TBOnMouseMove(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    if (ptb->fActive)
    {
        BOOL fSameButton;
        BOOL fDragOut = FALSE;
        int iPos;

        // do drag notifies/drawing first
        if (ptb->pCaptureButton != NULL)
        {
            if (hwnd != GetCapture())
            {
                //DebugMsg(DM_TRACE, TEXT("capture isn't us"));
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_ENDDRAG);

                // Revalidate after calling out
                if (!IsWindow(hwnd)) return;

                // if the button is still pressed, unpress it.
                if (EVAL(ptb->pCaptureButton) &&
                    (ptb->pCaptureButton->fsState & TBSTATE_PRESSED))
                    SendMessage(hwnd, TB_PRESSBUTTON, ptb->pCaptureButton->idCommand, 0L);
                ptb->pCaptureButton = NULL;
                ptb->fRightDrag = FALSE; // just in case we were right dragging
            }
            else
            {
                //DebugMsg(DM_TRACE, TEXT("capture IS us, and state is enabled"));
                iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
                fSameButton = (iPos >= 0 && ptb->pCaptureButton == ptb->Buttons + iPos);

                // notify on first drag out
                if (!fSameButton && !ptb->fDragOutNotify)
                {
                    ptb->fDragOutNotify = TRUE;
                    fDragOut = (BOOL)SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_DRAGOUT);

                    // Revalidate after calling out
                    if (!IsWindow(hwnd)) return;

                }

                // Check for ptb->pCaptureButton in case it was somehow nuked
                // in TBN_DRAGOUT.
                // This happens in the case when dragging an item out of start menu. When the
                // notify TBN_DRAGOUT is received, they go into a modal drag drop loop. Before
                // This loop finishes, the file is moved, causing a shell change notify to nuke
                // the button, which invalidates pCatpure button. So I'm getting rid of the
                // eval (lamadio) 4.14.98

                if (ptb->pCaptureButton &&
                    (ptb->pCaptureButton->fsState & TBSTATE_ENABLED) &&
                    (fSameButton == !(ptb->pCaptureButton->fsState & TBSTATE_PRESSED)) &&
                    !ptb->fRightDrag)
                {
                    //DebugMsg(DM_TRACE, TEXT("capture IS us, and Button is different"));

                    ptb->pCaptureButton->fsState ^= TBSTATE_PRESSED;

                    InvalidateButton(ptb, ptb->pCaptureButton, TRUE);

                    MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,
                        OBJID_CLIENT, (ptb->pCaptureButton - ptb->Buttons) + 1);
                }
            }
        }

        if (!fDragOut)
        {
            TBRelayToToolTips(ptb, wMsg, wParam, lParam);

            // Support hot tracking?
            if ((ptb->ci.style & TBSTYLE_FLAT) )
            {
                // Yes; set the hot item
                iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
#ifdef UNIX
                if (wParam & MK_LBUTTON)
                   TBSetHotItem(ptb, iPos, HICF_MOUSE | HICF_LMOUSE);
                else
#endif
                TBSetHotItem(ptb, iPos, HICF_MOUSE);

                // Track mouse events now?
                if (!ptb->fMouseTrack && !ptb->fAnchorHighlight)
                {
                    // Yes
                    TRACKMOUSEEVENT tme;

                    tme.cbSize = sizeof(TRACKMOUSEEVENT);
                    tme.dwFlags = TME_LEAVE;
                    tme.hwndTrack = hwnd;
                    ptb->fMouseTrack = TRUE;
                    TrackMouseEvent(&tme);
                }
            }
        }
    }

}


void TBHandleLButtonDown(PTBSTATE ptb, LPARAM lParam, int iPos)
{
    LPTBBUTTONDATA ptbButton;
    HWND hwnd = ptb->ci.hwnd;
    if (iPos >= 0 && iPos < ptb->iNumButtons)
    {
        POINT pt;
        RECT rcDropDown;

        LPARAM_TO_POINT(lParam, pt);

#ifdef UNIX
        TBSetHotItemWithoutNotification(ptb, iPos, HICF_MOUSE | HICF_LMOUSE);
#endif /* UNIX */

        // should this check for the size of the button struct?
        ptbButton = ptb->Buttons + iPos;

        if (TB_IsDropDown(ptbButton))
            TB_GetItemDropDownRect(ptb, iPos, &rcDropDown);

        if (TB_IsDropDown(ptbButton) &&
            (!TB_HasSplitDDArrow(ptb, ptbButton) || PtInRect(&rcDropDown, pt))) {

            // Was the dropdown handled?
            if (!TBToggleDropDown(ptb, iPos, TRUE))
            {
                // No; consider it a drag-out
                ptb->pCaptureButton = ptbButton;
                SetCapture(hwnd);

                ptb->fDragOutNotify = FALSE;
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
                GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);
            }

        } else {
            ptb->pCaptureButton = ptbButton;
            SetCapture(hwnd);

            if (ptbButton->fsState & TBSTATE_ENABLED)
            {
                ptbButton->fsState |= TBSTATE_PRESSED;
                InvalidateButton(ptb, ptbButton, TRUE);
                UpdateWindow(hwnd);         // immediate feedback

                MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,
                    OBJID_CLIENT, iPos+1);
            }

            ptb->fDragOutNotify = FALSE;

            // pCaptureButton may have changed
            if (ptb->pCaptureButton)
                SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
            GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);
        }
    }
}


void TBOnLButtonDown(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int iPos;
    NMCLICK nm = {0};

    ptb->fRequeryCapture = FALSE;
    TBRelayToToolTips(ptb, wMsg, wParam, lParam);

    iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    if ((ptb->ci.style & CCS_ADJUSTABLE) &&
        (((wParam & MK_SHIFT) && !(ptb->ci.style & TBSTYLE_ALTDRAG)) ||
         ((GetKeyState(VK_MENU) & ~1) && (ptb->ci.style & TBSTYLE_ALTDRAG))))
    {
        MoveButton(ptb, iPos);
    }
    else {
        TBHandleLButtonDown(ptb, lParam, iPos);
    }

    if ((iPos >= 0) && (iPos < ptb->iNumButtons))
    {
        nm.dwItemSpec = ptb->Buttons[iPos].idCommand;
        nm.dwItemData = ptb->Buttons[iPos].dwData;
    }
    else
        nm.dwItemSpec = (UINT_PTR) -1;

    LPARAM_TO_POINT(lParam, nm.pt);

    CCSendNotify(&ptb->ci, NM_LDOWN, (LPNMHDR )&nm);
}


void TBOnLButtonUp(PTBSTATE ptb, HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    int iPos = -1;
    NMCLICK nm = { 0 };

    TBRelayToToolTips(ptb, wMsg, wParam, lParam);
    if (lParam != (LPARAM)-1)
        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    if (ptb->fRequeryCapture && iPos >= 0) {
        // hack for broderbund (and potentially mand mfc apps.
        // on button down, they delete the pressed button and insert another one right underneat that
        // has pretty much the same characteristics.
        // on win95, we allowed pCaptureButton to temporarily point to garbage.
        // now we validate against it.
        // we detect this case on delete now and if the creation size (uStructSize == old 0x14 size)
        // we reget the capture button here
        ptb->pCaptureButton = &ptb->Buttons[iPos];
    }

    if (ptb->pCaptureButton != NULL) {

        int idCommand = ptb->pCaptureButton->idCommand;

        if (!CCReleaseCapture(&ptb->ci)) return;

        SendItemNotify(ptb, idCommand, TBN_ENDDRAG);
        if (!IsWindow(hwnd)) return;

        if (ptb->pCaptureButton && (ptb->pCaptureButton->fsState & TBSTATE_ENABLED) && iPos >=0
            && (ptb->pCaptureButton == ptb->Buttons+iPos)) {

            ptb->pCaptureButton->fsState &= ~TBSTATE_PRESSED;

            if (ptb->pCaptureButton->fsStyle & BTNS_CHECK) {
                if (ptb->pCaptureButton->fsStyle & BTNS_GROUP) {

                    // group buttons already checked can't be force
                    // up by the user.

                    if (ptb->pCaptureButton->fsState & TBSTATE_CHECKED) {
                        ptb->pCaptureButton = NULL;
                        return; // bail!
                    }

                    ptb->pCaptureButton->fsState |= TBSTATE_CHECKED;
                    MakeGroupConsistant(ptb, idCommand);
                } else {
                    ptb->pCaptureButton->fsState ^= TBSTATE_CHECKED; // toggle
                }
            }
            InvalidateButton(ptb, ptb->pCaptureButton, TRUE);
            ptb->pCaptureButton = NULL;

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd,  OBJID_CLIENT,
                iPos+1);

            FORWARD_WM_COMMAND(ptb->ci.hwndParent, idCommand, hwnd, BN_CLICKED, SendMessage);

#ifdef UNIX
                /* There is a special toolbar code depended on WM_MOUSEMOVE
                 * message (mfc400/barcore.c CControlBar::PreTranslateMessage)
                 * MS Windows Posts WM_MOUSEMOVE message after WM_LBUTTONDOWN.
                 * but MainWin does not post this message.
                 * MS Windows always Post WM_MOUSEMOVE message while MainWin
                 * always Send WM_MOUSEMOVE message.
                 * We need Post this message in order for toolbar to work
                 * correctly */
                PostMessage(hwnd, WM_MOUSEMOVE, 0x0000, lParam);
#endif

            // do not dereference ptb... it might have been destroyed on the WM_COMMAND.
            // if the window has been destroyed, bail out.
            if (!IsWindow(hwnd))
                return;

            goto SendUpClick;
        }
        else {
            ptb->pCaptureButton = NULL;
        }
    }
    else
    {
SendUpClick:
        if ((iPos >= 0) && (iPos < ptb->iNumButtons)) {
            nm.dwItemSpec = ptb->Buttons[iPos].idCommand;
            nm.dwItemData = ptb->Buttons[iPos].dwData;
        } else
            nm.dwItemSpec = (UINT_PTR) -1;

        LPARAM_TO_POINT(lParam, nm.pt);

        CCSendNotify(&ptb->ci, NM_CLICK, (LPNMHDR )&nm);
    }
}


BOOL CALLBACK GetUpdateRectEnumProc(HWND hwnd, LPARAM lParam)
{
    PTBSTATE ptb = (PTBSTATE)lParam;

    if (IsWindowVisible(hwnd))
    {
        RECT rcInvalid;

        if (GetUpdateRect(hwnd, &rcInvalid, FALSE))
        {
            RECT rcNew;

            MapWindowPoints(hwnd, ptb->ci.hwnd, (LPPOINT)&rcInvalid, 2);
            UnionRect(&rcNew, &rcInvalid, &ptb->rcInvalid);
            ptb->rcInvalid = rcNew;
        }
    }

    return TRUE;
}

void TB_OnSize(PTBSTATE ptb, int nWidth, int nHeight)
{
    if (ptb->dwStyleEx & TBSTYLE_EX_HIDECLIPPEDBUTTONS)
    {
        // figure out which buttons intersect the resized region
        // and invalidate the rects for those buttons
        //
        // +---------------+------+
        // |               |     <--- rcResizeH
        // |               |      |
        // +---------------+------+
        // |   ^           |      |
        // +---|-----------+------+
        //     rcResizeV
        
        int i;
        RECT rcResizeH, rcResizeV;

        SetRect(&rcResizeH, min(ptb->rc.right, nWidth),
                            ptb->rc.top,
                            max(ptb->rc.right, nWidth),
                            min(ptb->rc.bottom, nHeight));

        SetRect(&rcResizeV, ptb->rc.left,
                            min(ptb->rc.bottom, nHeight),
                            min(ptb->rc.right, nWidth),
                            max(ptb->rc.bottom, nHeight));

        for (i = 0; i < ptb->iNumButtons; i++)
        {
            RECT rc, rcBtn;
            TB_GetItemRect(ptb, i, &rcBtn);
            if (IntersectRect(&rc, &rcBtn, &rcResizeH) ||
                IntersectRect(&rc, &rcBtn, &rcResizeV))
            {
                InvalidateRect(ptb->ci.hwnd, &rcBtn, TRUE);
            }
        }

        SetRect(&ptb->rc, 0, 0, nWidth, nHeight);
    }
}

BOOL TB_TranslateAccelerator(HWND hwnd, LPMSG lpmsg)
{
    if (!lpmsg)
        return FALSE;

    if (GetFocus() != hwnd)
        return FALSE;

    switch (lpmsg->message) {

    case WM_KEYUP:
    case WM_KEYDOWN:

        switch (lpmsg->wParam) {

        case VK_RIGHT:
        case VK_LEFT:
        case VK_UP:
        case VK_DOWN:
        case VK_ESCAPE:
        case VK_SPACE:
        case VK_RETURN:
            TranslateMessage(lpmsg);
            DispatchMessage(lpmsg);
            return TRUE;
        }
        break;

    case WM_CHAR:
        switch (lpmsg->wParam) {

        case VK_ESCAPE:
        case VK_SPACE:
        case VK_RETURN:
            TranslateMessage(lpmsg);
            DispatchMessage(lpmsg);
            return TRUE;
        }
        break;

    }

    return FALSE;
}

void TBInitMetrics(PTBSTATE ptb)
{
    // init our g_clr's
    InitGlobalColors();

    // get the size of a drop down arrow
    ptb->dxDDArrowChar = GetSystemMetrics(SM_CYMENUCHECK);
}

LRESULT TBGenerateDragImage(PTBSTATE ptb, SHDRAGIMAGE* pshdi)
{
    HBITMAP hbmpOld = NULL;
    NMTBCUSTOMDRAW  tbcd = { 0 };
    HDC  hdcDragImage;
    // Do we have a hot item?
    if (ptb->iHot == -1)
        return 0;       // No? Return...

    hdcDragImage = CreateCompatibleDC(NULL);

    if (!hdcDragImage)
        return 0;

    //
    // Mirror the the DC, if the toolbar is mirrored.
    //
    if (ptb->ci.dwExStyle & RTL_MIRRORED_WINDOW)
    {
        SET_DC_RTL_MIRRORED(hdcDragImage);
    }

    tbcd.nmcd.hdc = hdcDragImage;
    ptb->ci.dwCustom = CICustomDrawNotify(&ptb->ci, CDDS_PREPAINT, (NMCUSTOMDRAW *)&tbcd);
    pshdi->sizeDragImage.cx = TBWidthOfButton(ptb, &ptb->Buttons[ptb->iHot], hdcDragImage);
    pshdi->sizeDragImage.cy = ptb->iButHeight;
    pshdi->hbmpDragImage = CreateBitmap( pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy,
        GetDeviceCaps(hdcDragImage, PLANES), GetDeviceCaps(hdcDragImage, BITSPIXEL),
        NULL);

    if (pshdi->hbmpDragImage)
    {
        DWORD dwStyle;
        RECT  rc = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};
        hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

        pshdi->crColorKey = RGB(0xFF, 0x00, 0x55);

        FillRectClr(hdcDragImage, &rc, pshdi->crColorKey);

        // We want the button to be drawn transparent. This is a hack, because I
        // don't want to rewrite the draw code. Fake a transparent draw.
        dwStyle = ptb->ci.style;
        ptb->ci.style |= TBSTYLE_TRANSPARENT;
        ptb->fAntiAlias = FALSE;

        DrawButton(hdcDragImage, 0, 0, ptb, &ptb->Buttons[ptb->iHot], TRUE);

        ptb->fAntiAlias = TRUE;
        ptb->ci.style = dwStyle;

        TB_GetItemRect(ptb, ptb->iHot, &rc);
        if (PtInRect(&rc, ptb->ptCapture))
        {
           if (ptb->ci.dwExStyle & RTL_MIRRORED_WINDOW)
               pshdi->ptOffset.x = rc.right - ptb->ptCapture.x;
           else
               pshdi->ptOffset.x = ptb->ptCapture.x - rc.left;
           pshdi->ptOffset.y = ptb->ptCapture.y - rc.top;
        }

        SelectObject(hdcDragImage, hbmpOld);
        DeleteDC(hdcDragImage);

        // We're passing back the created HBMP.
        return 1;
    }

    return 0;
}

LRESULT CALLBACK ToolbarWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPTBBUTTONDATA ptbButton;
    int iPos;
    LRESULT dw;
    PTBSTATE ptb = (PTBSTATE)GetWindowPtr0(hwnd);   // GetWindowPtr(hwnd, 0)

    if (uMsg == WM_NCCREATE)
    {
        LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;

        CCCreateWindow();

        InitDitherBrush();

        // create the state data for this toolbar

        ptb = (PTBSTATE)LocalAlloc(LPTR, sizeof(TBSTATE));
        if (!ptb)
            return 0;   // WM_NCCREATE failure is 0

        // note, zero init memory from above
        CIInitialize(&ptb->ci, hwnd, lpcs);
        ptb->xFirstButton = s_xFirstButton;
        ptb->iHot = -1;
        ptb->iPressedDD = -1;
        ptb->iInsert = -1;
        ptb->clrim = CLR_DEFAULT;
        ptb->fAntiAlias = TRUE; // Anti Alias fonts by default.
        // initialize system metric-dependent stuff
        TBInitMetrics(ptb);

        // horizontal/vertical space taken up by button chisel, sides,
        // and a 1 pixel margin.  used in GrowToolbar.
        ptb->xPad = 7;
        ptb->yPad = 6;
        ptb->fShowPrefix = TRUE;

        ptb->iListGap = LIST_GAP;
        ptb->iDropDownGap = DROPDOWN_GAP;

        ptb->clrsc.clrBtnHighlight = ptb->clrsc.clrBtnShadow = CLR_DEFAULT;

        ASSERT(ptb->uStructSize == 0);
        ASSERT(ptb->hfontIcon == NULL);  // initialize to null.
        ASSERT(ptb->iButMinWidth == 0);
        ASSERT(ptb->iButMaxWidth == 0);
#ifndef UNICODE
        ASSERT(ptb->bLeadByte == 0);
#endif

        ptb->nTextRows = 1;
        ptb->fActive = TRUE;

        // IE 3 passes in TBSTYLE_FLAT, but they really
        // wanted TBSTYLE_TRANSPARENT also.
        //
        if (ptb->ci.style & TBSTYLE_FLAT) {
            ptb->ci.style |= TBSTYLE_TRANSPARENT;
        }

#ifdef DEBUG
        if (IsFlagSet(g_dwPrototype, PTF_FLATLOOK))
        {
            TraceMsg(TF_TOOLBAR, "Using flat look for toolbars.");
            ptb->ci.style |= TBSTYLE_FLAT;
        }
#endif

        // Now Initialize the hfont we will use.
        TBChangeFont(ptb, 0, NULL);

        // grow the button size to the appropriate girth
        if (!SetBitmapSize(ptb, DEFAULTBITMAPX, DEFAULTBITMAPX))
        {
            goto Failure;
        }

        SetWindowPtr(hwnd, 0, ptb);

        if (!(ptb->ci.style & (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)))
        {
            ptb->ci.style |= CCS_TOP;
            SetWindowLong(hwnd, GWL_STYLE, ptb->ci.style);
        }

        return TRUE;

Failure:
        if (ptb) {
            ASSERT(!ptb->Buttons);  // App hasn't had a change to AddButtons yet
            LocalFree(ptb);
        }
        return FALSE;
    }

    if (!ptb)
        goto DoDefault;

    switch (uMsg) {

    case WM_CREATE:
        if (ptb->ci.style & TBSTYLE_REGISTERDROP)
        {
            ptb->hDragProxy = CreateDragProxy(ptb->ci.hwnd, ToolbarDragCallback, TRUE);
        }
        goto DoDefault;

    case WM_DESTROY:
        CCDestroyWindow();
        TB_OnDestroy(ptb);
        break;

    case WM_KEYDOWN:
        if (TBOnKey(ptb, (int) wParam, HIWORD(lParam)))
            break;
        goto DoDefault;

#ifdef KEYBOARDCUES
    case WM_UPDATEUISTATE:
    {
        if (CCOnUIState(&(ptb->ci), WM_UPDATEUISTATE, wParam, lParam))
        {
            BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
            SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif
            // We erase background only if we are removing underscores or focus rect,
            // or if Font smooting is enabled
            InvalidateRect(hwnd, NULL, 
                 fSmooth || ((UIS_SET == LOWORD(wParam)) ? TRUE : FALSE));
        }

        goto DoDefault;
    }
#else
    case WM_KEYBOARDCUES:
    {
        // This message is sent by a window when that window know that it is being accessed
        // by the keyboard. We default to Show Keyboard Cues until this message is sent.
        // Then we respect that setting.

        LRESULT lres = (ptb->fShowPrefix)? KC_ON : KC_OFF;
        
        switch(LOWORD(wParam))
        {
        case KC_ON:     ptb->fShowPrefix = TRUE; break;    // Turn on Keyboard Cues
        case KC_OFF:    ptb->fShowPrefix = FALSE; break;    // Turn off Keyboard Cues
        // case KC_QUERY: For this we just return the previous state.
        }

        // If the current state is different then the last state, 
        // then we want to repaint
        if ((KC_ON == lres) ^ ptb->fShowPrefix)
            RedrawWindow(hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE | RDW_UPDATENOW);

        return lres;
    }
#endif

    case WM_GETDLGCODE:
        return (LRESULT) (DLGC_WANTARROWS | DLGC_WANTCHARS);

    case WM_SYSCHAR:
    case WM_CHAR:
#ifndef UNICODE
        if (ptb->bLeadByte)
        {
            wParam = (ptb->bLeadByte << 8) | (wParam & 0x00FF);
            ptb->bLeadByte = 0;
        }
        else if (IsDBCSLeadByte((BYTE)wParam))
        {
            ptb->bLeadByte = (BYTE)wParam;
            break;
        }
#endif
        if (!TBOnChar(ptb, (UINT) wParam) &&
            (ptb->ci.iVersion >= 5))
        {
            // didn't handle it & client is >= v5
            // forward to default handler
            goto DoDefault;
        }
        break;

    case WM_SETFOCUS:
        if (ptb->iHot == -1) {
            // set hot the first enabled button
            TBCycleHotItem(ptb, -1, 1, HICF_OTHER);
        }
        break;

    case WM_KILLFOCUS:
        TBSetHotItem(ptb, -1, HICF_OTHER);
        break;

    case WM_SETFONT:
        TBSetFont(ptb, (HFONT)wParam, (BOOL)lParam);
        return TRUE;

    case WM_NCCALCSIZE:
        // let defwindowproc handle the standard borders etc...
        dw = DefWindowProc(hwnd, uMsg, wParam, lParam ) ;

        // add the extra edge at the top of the toolbar to seperate from the menu bar
        if (!(ptb->ci.style & CCS_NODIVIDER))
        {
            ((NCCALCSIZE_PARAMS *)lParam)->rgrc[0].top += g_cyEdge;
        }

        return dw;

    case WM_NCHITTEST:
        return HTCLIENT;

    case WM_NCACTIVATE:

        // only make sense to do this stuff if we're top level
        if ((BOOLIFY(ptb->fActive) != (BOOL)wParam && !GetParent(hwnd))) {
            int iButton;

            ptb->fActive = (BOOL) wParam;

            for (iButton = 0; iButton < ptb->iNumButtons; iButton++) {
                ptbButton = &ptb->Buttons[iButton];
                InvalidateButton(ptb, ptbButton, FALSE);
            }
        }
        // fall through...

    case WM_NCPAINT:
        // old-style toolbars are forced to be without dividers above
        if (!(ptb->ci.style & CCS_NODIVIDER))
        {
            RECT rc;
            HDC hdc = GetWindowDC(hwnd);
            GetWindowRect(hwnd, &rc);
            MapWindowRect(NULL, hwnd, &rc); // screen -> client

                rc.bottom = -rc.top;                // bottom of NC area
                rc.top = rc.bottom - g_cyEdge;

            CCDrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_TOP | BF_BOTTOM, &(ptb->clrsc));
            ReleaseDC(hwnd, hdc);
        }
        goto DoDefault;

    case WM_ENABLE:
        if (wParam) {
            ptb->ci.style &= ~WS_DISABLED;
        } else {
            ptb->ci.style |= WS_DISABLED;
        }
        InvalidateRect(hwnd, NULL, ptb->ci.style & TBSTYLE_TRANSPARENT);
        goto DoDefault;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        if (ptb->fTTNeedsFlush)
            FlushToolTipsMgrNow(ptb);

        if (ptb->fRedrawOff)
        {
            if (!wParam)
            {
                HDC hdcPaint;
                PAINTSTRUCT ps;

                hdcPaint = BeginPaint(hwnd, &ps);
                EndPaint(hwnd, &ps);
            }

            // we got a paint region, so invalidate
            // when we get redraw back on...
            ptb->fInvalidate = TRUE;
        }
        else
        {
            TBPaint(ptb, (HDC)wParam);
        }
        break;

    case WM_SETREDRAW:
        {
            // HACKHACK: only respect WM_SETREDRAW message if tbstyle is flat
            // HACKHACK: fixes appcompat bug #60120
            if (ptb->ci.style & TBSTYLE_FLAT || 
                ptb->dwStyleEx & TBSTYLE_EX_VERTICAL || 
                (ptb->ci.iVersion >= 5))
            {
                BOOL fRedrawOld = !ptb->fRedrawOff;

                if ( wParam && ptb->fRedrawOff )
                {
                    if ( ptb->fInvalidate )
                    {
                        // If font smoothing is enabled, then we need to erase the background too.
                        BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
                        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif


                        // invalidate before turning back on ...
                        RedrawWindow( hwnd, NULL, NULL, (fSmooth? RDW_ERASE: 0)  | RDW_INVALIDATE );
                        ptb->fInvalidate = FALSE;
                    }
                    ptb->fRedrawOff = FALSE;

                    if ( ptb->fRecalc )
                    {
                        // recalc & autosize after turning back on
                        TBRecalc(ptb);
                        TBAutoSize(ptb);
                        ptb->fRecalc = FALSE;
                    }
                }
                else
                {
                    ptb->fRedrawOff = !wParam;
                }

                if (ptb->ci.iVersion >= 5)
                    return fRedrawOld;
            }
            else
            {
                goto DoDefault;
            }
        }
        break;

    case WM_ERASEBKGND:
        TB_OnEraseBkgnd(ptb, (HDC) wParam);
        return(TRUE);

    case WM_SYSCOLORCHANGE:
        TB_OnSysColorChange(ptb);
        if (ptb->hwndToolTips)
            SendMessage(ptb->hwndToolTips, uMsg, wParam, lParam);
        break;

    case TB_GETROWS:
        return CountRows(ptb);
        break;

    case TB_GETPADDING:
        lParam = MAKELONG(-1, -1);
        // fall through
    case TB_SETPADDING:
    {
        LRESULT lres = MAKELONG(ptb->xPad, ptb->yPad);
        int xPad = GET_X_LPARAM(lParam);
        int yPad = GET_Y_LPARAM(lParam);
        if (xPad != -1)
            ptb->xPad = xPad;
        if (yPad != -1)
            ptb->yPad = yPad;
        return lres;
    }


    case TB_SETROWS:
        {
            RECT rc;

            if (BoxIt(ptb, LOWORD(wParam), HIWORD(wParam), &rc))
            {
                TBInvalidateItemRects(ptb);
                SetWindowPos(hwnd, NULL, 0, 0, rc.right, rc.bottom,
                             SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);
                InvalidateRect(hwnd, NULL, TRUE);
            }
            if (lParam)
                *((RECT *)lParam) = rc;
        }
        break;

    case WM_MOVE:
        // JJK TODO: This needs to be double buffered to get rid of the flicker
        if (ptb->ci.style & TBSTYLE_TRANSPARENT)
            InvalidateRect(hwnd, NULL, TRUE);
        goto DoDefault;

    case WM_SIZE:
        TB_OnSize(ptb, LOWORD(lParam), HIWORD(lParam));
        // fall through
    case TB_AUTOSIZE:
        TBAutoSize(ptb);
        break;

    case WM_COMMAND:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_VKEYTOITEM:
    case WM_CHARTOITEM:
        SendMessage(ptb->ci.hwndParent, uMsg, wParam, lParam);
        break;

    case WM_RBUTTONDBLCLK:
        if (!CCSendNotify(&ptb->ci, NM_RDBLCLK, NULL))
            goto DoDefault;
        break;

    case WM_RBUTTONUP:
        {
            NMCLICK nm = {0};
            int iIndex;

            if (ptb->pCaptureButton != NULL)
            {
                if (!CCReleaseCapture(&ptb->ci)) break;
                ptb->pCaptureButton = NULL;
                ptb->fRightDrag = FALSE;
            }

            iIndex = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            if ((iIndex >= 0) && (iIndex < ptb->iNumButtons)) {
                nm.dwItemSpec = ptb->Buttons[iIndex].idCommand;
                nm.dwItemData = ptb->Buttons[iIndex].dwData;
            } else
                nm.dwItemSpec = (UINT_PTR) -1;

            LPARAM_TO_POINT(lParam, nm.pt);

            if (!CCSendNotify(&ptb->ci, NM_RCLICK, (LPNMHDR )&nm))
                goto DoDefault;
        }
        break;

    case WM_LBUTTONDBLCLK:
        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        if (iPos < 0 && (ptb->ci.style & CCS_ADJUSTABLE))
        {
            iPos = -1 - iPos;
            CustomizeTB(ptb, iPos);
        } else {
            TBHandleLButtonDown(ptb, lParam, iPos);
        }
        break;

    case WM_LBUTTONDOWN:
        TBOnLButtonDown(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_CAPTURECHANGED:
        // do this only for newer apps because some apps
        // do things like delete a button when you
        // mouse down and add it back in immediately.
        // also do it on a post because we call ReleaseCapture
        // internally and only want to catch this on external release
        if (ptb->ci.iVersion >= 5)
            PostMessage(hwnd, TBP_ONRELEASECAPTURE, 0, 0);

        //
        //  QFE fix for Autodesk.  We used to hold capture
        //  even though the app wanted it back.  Oops.
        //
        else if (ptb->fRightDrag && ptb->pCaptureButton) {
            CCReleaseCapture(&ptb->ci);
            ptb->fRightDrag = FALSE;
        }

        break;

    case TBP_ONRELEASECAPTURE:
        if (ptb->pCaptureButton) {
            // abort current capture
            // simulate a lost capture mouse move.  this will restore state
            TBOnMouseMove(ptb, hwnd, WM_MOUSEMOVE, 0, (LPARAM)-1);
            ptb->pCaptureButton = NULL;
        }
        break;


    case WM_RBUTTONDOWN:

        if (ptb->pCaptureButton) {
            // abort current capture
            if (hwnd == GetCapture()) {
                // we were left clicking.   abort that now
                if (!CCReleaseCapture(&ptb->ci)) break;
                // simulate a lost capture mouse move.  this will restore state
                TBOnMouseMove(ptb, hwnd, WM_MOUSEMOVE, 0, (LPARAM)-1);
            }
        }

        iPos = TBHitTest(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

        // we need to check VK_RBUTTON because some apps subclass us to pick off rbuttondown to do their menu
        // (instead of up, or the notify, or wm_contextmenu)
        // then after it's done and the button is up, they then send us a button down
        if ((iPos >= 0) && (iPos < ptb->iNumButtons) && (GetAsyncKeyState(VK_RBUTTON) < 0))
        {
            ptb->pCaptureButton = ptb->Buttons + iPos;
            ptb->fRightDrag = TRUE;
            SetCapture(hwnd);
            GetMessagePosClient(ptb->ci.hwnd, &ptb->ptCapture);

            SendItemNotify(ptb, ptb->pCaptureButton->idCommand, TBN_BEGINDRAG);
            if (!IsWindow(hwnd)) break;
            ptb->fDragOutNotify = FALSE;
        }
        break;

    case WM_MOUSELEAVE:
        {
            TRACKMOUSEEVENT tme;

            // We only track mouse events on the flat style (for
            // hot tracking)
            ASSERT(ptb->ci.style & TBSTYLE_FLAT);

            // Cancel the mouse event tracking
            tme.cbSize = sizeof(TRACKMOUSEEVENT);
            tme.dwFlags = TME_CANCEL | TME_LEAVE;
            tme.hwndTrack = hwnd;
            TrackMouseEvent(&tme);
            ptb->fMouseTrack = FALSE;

#ifdef UNIX
            TBSetHotItem(ptb, -1, HICF_MOUSE | HICF_LMOUSE);
#else
            TBSetHotItem(ptb, -1, HICF_MOUSE);
#endif /* UNIX */
        }
        break;

    case WM_MOUSEMOVE:
        TBOnMouseMove(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_LBUTTONUP:
        TBOnLButtonUp(ptb, hwnd, uMsg, wParam, lParam);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if (ptb->fFontCreated)
            TBChangeFont(ptb, wParam, NULL);
        if (ptb->hwndToolTips)
            SendMessage(ptb->hwndToolTips, uMsg, wParam, lParam);

        // recalc & redraw
        TBInitMetrics(ptb);
        TBRecalc(ptb);
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&ptb->ci, lParam);
        break;


    case WM_NOTIFY:
#define lpNmhdr ((LPNMHDR)(lParam))
        //The following statement traps all pager control notification messages.
        if((lpNmhdr->code <= PGN_FIRST)  && (lpNmhdr->code >= PGN_LAST)) {
            return TB_OnPagerControlNotify(ptb, lpNmhdr);
        }
    {
        LRESULT lres = 0;
        if (lpNmhdr->code == TTN_NEEDTEXT) {
            int i = PositionFromID(ptb, lpNmhdr->idFrom);
            BOOL fEllipsied = FALSE;
            LRESULT lres;
            LPTOOLTIPTEXT lpnmTT = ((LPTOOLTIPTEXT) lParam);

            if (i != -1) {
                // if infotip not supported, try for TTN_NEEDTEXT in client.
                if (!TBGetInfoTip(ptb, lpnmTT, &ptb->Buttons[i]))
                    lres = SendNotifyEx(ptb->ci.hwndParent, (HWND) -1,
                                        lpNmhdr->code, lpNmhdr, ptb->ci.bUnicode);

#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (!IS_INTRESOURCE(lpszText)))

                fEllipsied = (BOOL)(ptb->Buttons[i].fsState & TBSTATE_ELLIPSES);

                // if we don't get a string from TTN_NEEDTEXT try to use the title text.
                if ((lpNmhdr->code == TTN_NEEDTEXT) &&
                    (BTN_NO_SHOW_TEXT(ptb, &ptb->Buttons[i]) || fEllipsied) &&
                    lpnmTT->lpszText && IsTextPtr(lpnmTT->lpszText) &&
                    !lpnmTT->lpszText[0])
                {
                    LPCTSTR psz = TB_StrForButton(ptb, &ptb->Buttons[i]);
                    if (psz)
                        lpnmTT->lpszText = (LPTSTR)psz;
                }
            }
        } else {
            //
            // We are just going to pass this on to the
            // real parent.  Note that -1 is used as
            // the hwndFrom.  This prevents SendNotifyEx
            // from updating the NMHDR structure.
            //
            lres = SendNotifyEx(ptb->ci.hwndParent, (HWND) -1,
                                lpNmhdr->code, lpNmhdr, ptb->ci.bUnicode);
        }
        return(lres);
    }

    case WM_STYLECHANGING:
        if (wParam == GWL_STYLE)
        {
            LPSTYLESTRUCT lpStyle = (LPSTYLESTRUCT) lParam;

            // is MFC dorking with just our visibility bit?
            if ((lpStyle->styleOld ^ lpStyle->styleNew) == WS_VISIBLE)
            {
                if (lpStyle->styleNew & WS_VISIBLE)
                {
                    BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
                    SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif

                    // MFC trying to make us visible,
                    // convert it to WM_SETREDRAW instead.
                    DefWindowProc(hwnd, WM_SETREDRAW, TRUE, 0);

                    // Reinvalidate everything we lost when we
                    // did the WM_SETREDRAW stuff.
                    RedrawWindow(hwnd, &ptb->rcInvalid, NULL, (fSmooth? RDW_ERASE: 0)  | RDW_INVALIDATE | RDW_ALLCHILDREN);
                    ZeroMemory(&ptb->rcInvalid, SIZEOF(ptb->rcInvalid));
                }
                else
                {
                    // Save the invalid rectangle in ptb->rcInvalid since
                    // WM_SETREDRAW will blow it away.
                    ZeroMemory(&ptb->rcInvalid, SIZEOF(ptb->rcInvalid));
                    GetUpdateRect(ptb->ci.hwnd, &ptb->rcInvalid, FALSE);
                    EnumChildWindows(ptb->ci.hwnd, GetUpdateRectEnumProc, (LPARAM)ptb);

                    // MFC trying to make us invisible,
                    // convert it to WM_SETREDRAW instead.
                    DefWindowProc(hwnd, WM_SETREDRAW, FALSE, 0);
                }
            }
        }
        break;

    case WM_STYLECHANGED:
        if (wParam == GWL_STYLE)
        {
            TBSetStyle(ptb, ((LPSTYLESTRUCT)lParam)->styleNew);
        }
        else if (wParam == GWL_EXSTYLE)
        {
            //
            // If the RTL_MIRROR extended style bit had changed, let's
            // repaint the control window
            //
            if ((ptb->ci.dwExStyle&RTL_MIRRORED_WINDOW) !=
                (((LPSTYLESTRUCT)lParam)->styleNew&RTL_MIRRORED_WINDOW))
                TBAutoSize(ptb);

            //
            // Save the new ex-style bits
            //
            ptb->ci.dwExStyle = ((LPSTYLESTRUCT)lParam)->styleNew;

        }
        return 0;

    case TB_GETIDEALSIZE:
        {
            NMPGCALCSIZE nm;
            LPSIZE psize = (LPSIZE) lParam;
            ASSERT(psize);  // This should never be NULL
            nm.dwFlag = wParam ? PGF_CALCHEIGHT : PGF_CALCWIDTH;
            nm.iWidth = psize->cx;
            nm.iHeight = psize->cy;
            TB_OnCalcSize(ptb, (LPNMHDR)&nm);

            // Since both values may have changed, reset the out-param.
            psize->cy = nm.iHeight;
            psize->cx = nm.iWidth;
            return 1;
        }

    case TB_SETSTYLE:
        TBSetStyle(ptb, (DWORD) lParam);
        break;

    case TB_GETSTYLE:
        return (ptb->ci.style);

    case TB_GETBUTTONSIZE:
        return (MAKELONG(ptb->iButWidth,ptb->iButHeight));

    case TB_SETBUTTONWIDTH:
        if (ptb->iButMinWidth  != LOWORD(lParam) ||
            ptb->iButMaxWidth != HIWORD(lParam)) {

            ptb->iButMinWidth  = LOWORD(lParam);
            ptb->iButMaxWidth = HIWORD(lParam);
            ptb->iButWidth = 0;
            TBRecalc(ptb);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return TRUE;

    case TB_TRANSLATEACCELERATOR:
        return TB_TranslateAccelerator(hwnd, (LPMSG)lParam);

    case TB_SETSTATE:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return FALSE;
        ptbButton = ptb->Buttons + iPos;

        TB_OnSetState(ptb, ptbButton, (BYTE)(LOWORD(lParam)), iPos);
        TBInvalidateItemRects(ptb);
        return TRUE;

    // set the cmd ID of a button based on its position
    case TB_SETCMDID:
        if (wParam >= (UINT)ptb->iNumButtons)
            return FALSE;

        TB_OnSetCmdID(ptb, &ptb->Buttons[wParam], (UINT)lParam);
        return TRUE;

    case TB_GETSTATE:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return -1L;
        return ptb->Buttons[iPos].fsState;

#ifdef UNICODE
    case TB_MAPACCELERATORA:
    {
        char szAcl[2];
        WCHAR wszAcl[2];
        szAcl[0] = (BYTE)wParam;
        szAcl[1] = '\0';
        MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szAcl, ARRAYSIZE(szAcl),
                                               wszAcl, ARRAYSIZE(wszAcl));
        // no need to check return we just take junk if MbtoWc has failed
        wParam = (WPARAM)wszAcl[0];
    }
    // fall through...
#endif
    case TB_MAPACCELERATOR:
#ifndef UNICODE
        // prevent sign extension of high ansi chars
        wParam = (WORD)(BYTE)wParam;
#endif
        return TBOnMapAccelerator(ptb, (UINT)wParam, (UINT *)lParam);

    case TB_ENABLEBUTTON:
    case TB_CHECKBUTTON:
    case TB_PRESSBUTTON:
    case TB_HIDEBUTTON:
    case TB_INDETERMINATE:
    case TB_MARKBUTTON:
    {
        BYTE fsState;

        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return FALSE;
        ptbButton = &ptb->Buttons[iPos];
        fsState = ptbButton->fsState;

        if (LOWORD(lParam))
            ptbButton->fsState |= wStateMasks[uMsg - TB_ENABLEBUTTON];
        else
            ptbButton->fsState &= ~wStateMasks[uMsg - TB_ENABLEBUTTON];

        // did this actually change the state?
        if (fsState != ptbButton->fsState) {
            // is this button a member of a group?
            if ((uMsg == TB_CHECKBUTTON) && (ptbButton->fsStyle & BTNS_GROUP))
                MakeGroupConsistant(ptb, (int)wParam);

            if (uMsg == TB_HIDEBUTTON) {
                InvalidateRect(hwnd, NULL, TRUE);
                TBInvalidateItemRects(ptb);
            } else
                InvalidateButton(ptb, ptbButton, TRUE);

            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, iPos+1);
        }
        return(TRUE);
    }

    case TB_ISBUTTONENABLED:
    case TB_ISBUTTONCHECKED:
    case TB_ISBUTTONPRESSED:
    case TB_ISBUTTONHIDDEN:
    case TB_ISBUTTONINDETERMINATE:
    case TB_ISBUTTONHIGHLIGHTED:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(-1L);
        return (LRESULT)ptb->Buttons[iPos].fsState & wStateMasks[uMsg - TB_ISBUTTONENABLED];

    case TB_ADDBITMAP:
    case TB_ADDBITMAP32:    // only for compatibility with mail
        {
            LPTBADDBITMAP pab = (LPTBADDBITMAP)lParam;
            return AddBitmap(ptb, (int) wParam, pab->hInst, pab->nID);
        }

    case TB_REPLACEBITMAP:
        return ReplaceBitmap(ptb, (LPTBREPLACEBITMAP)lParam);

#ifdef UNICODE
    case TB_ADDSTRINGA:
        {
        LPWSTR lpStrings;
        UINT   uiCount;
        LPSTR  lpAnsiString = (LPSTR) lParam;
        int    iResult;
        BOOL   bAllocatedMem = FALSE;

        if (!wParam && !IS_INTRESOURCE(lpAnsiString)) {
            //
            // We have to figure out how many characters
            // are in this string.
            //
            
            uiCount = 0;

            while (TRUE) {
               uiCount++;
               if ((*lpAnsiString == 0) && (*(lpAnsiString+1) == 0)) {
                  uiCount++;  // needed for double null
                  break;
               }

               lpAnsiString++;
            }

            lpStrings = LocalAlloc(LPTR, uiCount * sizeof(TCHAR));

            if (!lpStrings)
                return -1;

            bAllocatedMem = TRUE;

            MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lParam, uiCount,
                                lpStrings, uiCount);

        } else {
            lpStrings = (LPWSTR)lParam;
        }

        iResult = TBAddStrings(ptb, wParam, (LPARAM)lpStrings);

        if (bAllocatedMem)
            LocalFree(lpStrings);

        return iResult;
        }
#endif

    case TB_ADDSTRING:
        return TBAddStrings(ptb, wParam, lParam);

    case TB_GETSTRING:
        return TBGetString(ptb, HIWORD(wParam), LOWORD(wParam), (LPTSTR)lParam);

#ifdef UNICODE
    case TB_GETSTRINGA:
        return TBGetStringA(ptb, HIWORD(wParam), LOWORD(wParam), (LPSTR)lParam);

    case TB_ADDBUTTONSA:
        return TBInsertButtons(ptb, (UINT)-1, (UINT) wParam, (LPTBBUTTON)lParam, FALSE);

    case TB_INSERTBUTTONA:
        return TBInsertButtons(ptb, (UINT) wParam, 1, (LPTBBUTTON)lParam, FALSE);
#endif

    case TB_ADDBUTTONS:
        return TBInsertButtons(ptb, (UINT)-1, (UINT) wParam, (LPTBBUTTON)lParam, TRUE);

    case TB_INSERTBUTTON:
        return TBInsertButtons(ptb, (UINT) wParam, 1, (LPTBBUTTON)lParam, TRUE);

    case TB_DELETEBUTTON:
        return DeleteButton(ptb, (UINT) wParam);

    case TB_GETBUTTON:
        if (wParam >= (UINT)ptb->iNumButtons)
            return(FALSE);

        TBOutputStruct(ptb, ptb->Buttons + wParam, (LPTBBUTTON)lParam);
        return TRUE;

    case TB_SETANCHORHIGHLIGHT:
        BLOCK
        {
            BOOL bAnchor = BOOLIFY(ptb->fAnchorHighlight);
            ptb->fAnchorHighlight = BOOLFROMPTR(wParam);
            return bAnchor;
        }
        break;

    case TB_GETANCHORHIGHLIGHT:
        return BOOLIFY(ptb->fAnchorHighlight);

    case TB_HASACCELERATOR:
        ASSERT(IS_VALID_WRITE_PTR(lParam, int*));
        *((int*)lParam) = TBHasAccelerator(ptb, (UINT)wParam);
        break;

    case TB_SETHOTITEM:
        lParam = HICF_OTHER;
        // Fall through
    case TB_SETHOTITEM2:
        BLOCK
        {
            int iPos = ptb->iHot;

            TBSetHotItem(ptb, (int)wParam, (DWORD)lParam);
            return iPos;
        }
        break;

    case TB_GETHOTITEM:
        return ptb->iHot;

    case TB_SETINSERTMARK:
        TBSetInsertMark(ptb, (LPTBINSERTMARK)lParam);
        break;

    case TB_GETINSERTMARK:
    {
        LPTBINSERTMARK ptbim = (LPTBINSERTMARK)lParam;

        ptbim->iButton = ptb->iInsert;
        ptbim->dwFlags = ptb->fInsertAfter ? TBIMHT_AFTER : 0;
        return TRUE;
    }

    case TB_SETINSERTMARKCOLOR:
    {
        LRESULT lres = (LRESULT)TB_GetInsertMarkColor(ptb);
        ptb->clrim = (COLORREF) lParam;
        return lres;
    }

    case TB_GETINSERTMARKCOLOR:
        return TB_GetInsertMarkColor(ptb);

    case TB_INSERTMARKHITTEST:
    return (LRESULT)TBInsertMarkHitTest(ptb, ((LPPOINT)wParam)->x, ((LPPOINT)wParam)->y, (LPTBINSERTMARK)lParam);

    case TB_MOVEBUTTON:
        return (LRESULT)TBMoveButton(ptb, (UINT)wParam, (UINT)lParam);

    case TB_GETMAXSIZE:
        return (LRESULT)TBGetMaxSize(ptb, (LPSIZE) lParam );

    case TB_BUTTONCOUNT:
        return ptb->iNumButtons;

    case TB_COMMANDTOINDEX:
        return PositionFromID(ptb, wParam);

#ifdef UNICODE
    case TB_SAVERESTOREA:
        {
        LPWSTR lpSubKeyW, lpValueNameW;
        TBSAVEPARAMSA * lpSaveA = (TBSAVEPARAMSA *) lParam;
        BOOL bResult;

        lpSubKeyW = ProduceWFromA (CP_ACP, lpSaveA->pszSubKey);
        lpValueNameW = ProduceWFromA (CP_ACP, lpSaveA->pszValueName);

        bResult = SaveRestoreFromReg(ptb, (BOOL) wParam, lpSaveA->hkr, lpSubKeyW, lpValueNameW);

        FreeProducedString(lpSubKeyW);
        FreeProducedString(lpValueNameW);

        return bResult;
        }
#endif

    case TB_SAVERESTORE:
        {
            TBSAVEPARAMS* psr = (TBSAVEPARAMS *)lParam;
            return SaveRestoreFromReg(ptb, (BOOL) wParam, psr->hkr, psr->pszSubKey, psr->pszValueName);
        }

    case TB_CUSTOMIZE:
        CustomizeTB(ptb, ptb->iNumButtons);
        break;

    case TB_GETRECT:
        // PositionFromID() accepts NULL ptbs!
        wParam = PositionFromID(ptb, wParam);
        // fall through
    case TB_GETITEMRECT:
        if (!lParam)
            break;
        return TB_GetItemRect(ptb, (UINT) wParam, (LPRECT)lParam);

    case TB_BUTTONSTRUCTSIZE:
        TBOnButtonStructSize(ptb, (UINT) wParam);
        break;

    case TB_SETBUTTONSIZE:
        return GrowToolbar(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0);

    case TB_SETBITMAPSIZE:
        return SetBitmapSize(ptb, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    case TB_SETIMAGELIST:
    {
        HIMAGELIST himl = (HIMAGELIST)lParam;
        HIMAGELIST himlOld = TBSetImageList(ptb, HIML_NORMAL, (int) wParam, himl);
        ptb->fHimlNative = TRUE;

        if (!ptb->uStructSize) {
            // let people get away without calling TB_BUTTONSTRUCTSIZE... no other control requires this
            ptb->uStructSize = 20;
            ASSERT(ptb->uStructSize == SIZEOF(TBBUTTON));
        }

        // The bitmap size is based on the primary image list
        if (wParam == 0)
        {
            int cx = 0, cy = 0;
            if (himl) {
                // Update the bitmap size based on this image list
                ImageList_GetIconSize(himl, &cx, &cy);
            }
            SetBitmapSize(ptb, cx, cy);
        }

        return (LRESULT)himlOld;
    }

    case TB_GETIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_NORMAL, (int) wParam);

    case TB_GETIMAGELISTCOUNT:
        return ptb->cPimgs;

    case TB_SETHOTIMAGELIST:
        return (LRESULT)TBSetImageList(ptb, HIML_HOT, (int) wParam, (HIMAGELIST)lParam);

    case TB_GETHOTIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_HOT, (int) wParam);

    case TB_GETDISABLEDIMAGELIST:
        return (LRESULT)TBGetImageList(ptb, HIML_DISABLED, (int) wParam);

    case TB_SETDISABLEDIMAGELIST:
        return (LRESULT)TBSetImageList(ptb, HIML_DISABLED, (int) wParam, (HIMAGELIST)lParam);

    case TB_GETOBJECT:
        if (IsEqualIID((IID *)wParam, &IID_IDropTarget))
        {
            // if we have not already registered create an unregistered target now
            if (ptb->hDragProxy == NULL)
                ptb->hDragProxy = CreateDragProxy(ptb->ci.hwnd, ToolbarDragCallback, FALSE);

            if (ptb->hDragProxy)
                return (LRESULT)GetDragProxyTarget(ptb->hDragProxy, (IDropTarget **)lParam);
        }
        return E_FAIL;

    case WM_GETFONT:
        return (LRESULT)(ptb? ptb->hfontIcon : 0);

    case TB_LOADIMAGES:
        return TBLoadImages(ptb, (UINT_PTR) wParam, (HINSTANCE)lParam);

    case TB_GETTOOLTIPS:
        TB_ForceCreateTooltips(ptb);
        return (LRESULT)ptb->hwndToolTips;

    case TB_SETTOOLTIPS:
        ptb->hwndToolTips = (HWND)wParam;
        break;

    case TB_SETPARENT:
        {
            HWND hwndOld = ptb->ci.hwndParent;

        ptb->ci.hwndParent = (HWND)wParam;
        return (LRESULT)hwndOld;
        }


#ifdef UNICODE
    case TB_GETBUTTONINFOA:
        return TB_OnGetButtonInfoA(ptb, (int)wParam, (LPTBBUTTONINFOA)lParam);

    case TB_SETBUTTONINFOA:
        return TB_OnSetButtonInfoA(ptb, (int)wParam, (LPTBBUTTONINFOA)lParam);
#endif

    case TB_GETBUTTONINFO:
        return TB_OnGetButtonInfo(ptb, (int)wParam, (LPTBBUTTONINFO)lParam);

    case TB_SETBUTTONINFO:
        return TB_OnSetButtonInfo(ptb, (int)wParam, (LPTBBUTTONINFO)lParam);

    case TB_CHANGEBITMAP:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(FALSE);

        //
        // Check to see if the new bitmap ID is
        // valid.
        //
        ptbButton = &ptb->Buttons[iPos];
        return TB_OnSetImage(ptb, ptbButton, LOWORD(lParam));

    case TB_GETBITMAP:
        iPos = PositionFromID(ptb, wParam);
        if (iPos < 0)
            return(FALSE);
        ptbButton = &ptb->Buttons[iPos];
        return ptbButton->DUMMYUNION_MEMBER(iBitmap);

#ifdef UNICODE
    case TB_GETBUTTONTEXTA:
        iPos = PositionFromID(ptb, wParam);
        if (iPos >= 0) {
            LPTSTR psz;

            ptbButton = &ptb->Buttons[iPos];
            psz = TB_StrForButton(ptb, ptbButton);
            if (psz)
            {
                // Passing a 0 for the length of the buffer when the
                // buffer is NULL returns the number bytes required
                // to convert the string.
                int cbBuff = WideCharToMultiByte (CP_ACP, 0, psz,
                    -1, NULL, 0, NULL, NULL);

                // We used to pass an obscenly large number for the buffer length,
                // but on checked builds, this causes badness. So no we double-dip
                // into WideCharToMultiByte to calculate the real size required.
                if (lParam)
                {
                    WideCharToMultiByte (CP_ACP, 0, psz,
                        -1, (LPSTR)lParam, cbBuff, NULL, NULL);
                }

                // WideChar include a trailing NULL but we don't want to.
                return cbBuff - 1;
            }
        }
        return -1;
#endif

    case TB_GETBUTTONTEXT:
        iPos = PositionFromID(ptb, wParam);
        if (iPos >= 0) {
            LPCTSTR psz;

            ptbButton = &ptb->Buttons[iPos];
            psz = TB_StrForButton(ptb, ptbButton);
            if (psz) {
                if (lParam) {
                    lstrcpy((LPTSTR)lParam, psz);
                }
                return lstrlen(psz);
            }
        }
        return -1;


    case TB_GETBITMAPFLAGS:
        {
            DWORD fFlags = 0;
            HDC hdc = GetDC(NULL);

            if (GetDeviceCaps(hdc, LOGPIXELSY) >= 120)
                fFlags |= TBBF_LARGE;

            ReleaseDC(NULL, hdc);

            return fFlags;
        }

    case TB_SETINDENT:
        ptb->xFirstButton = (int) wParam;
        InvalidateRect (hwnd, NULL, TRUE);
        TBInvalidateItemRects(ptb);
        return 1;

    case TB_SETMAXTEXTROWS:

        if (ptb->nTextRows != (int)wParam) {
            ptb->nTextRows = (int) wParam;
            TBRecalc(ptb);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        return 1;

    case TB_SETLISTGAP:
        ptb->iListGap = (int) wParam;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case TB_SETDROPDOWNGAP:
        ptb->iDropDownGap = (int) wParam;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case TB_GETTEXTROWS:
        return ptb->nTextRows;

    case TB_HITTEST:
        return TBHitTest(ptb, ((LPPOINT)lParam)->x, ((LPPOINT)lParam)->y);

    case TB_SETDRAWTEXTFLAGS:
    {
        UINT uOld = ptb->uDrawText;
        ptb->uDrawText = (UINT) (lParam & wParam);
        ptb->uDrawTextMask = (UINT) wParam;
        return uOld;
    }

    case TB_GETEXTENDEDSTYLE:
        return (ptb->dwStyleEx);

    case TB_SETEXTENDEDSTYLE:
    {
        DWORD dwRet = ptb->dwStyleEx;
        TBSetStyleEx(ptb, (DWORD) lParam, (DWORD) wParam);
        return dwRet;
    }
    case TB_SETBOUNDINGSIZE:
    {
        LPSIZE lpSize = (LPSIZE)lParam;
        ptb->sizeBound = *lpSize;
        break;
    }
    case TB_GETCOLORSCHEME:
    {
        LPCOLORSCHEME lpclrsc = (LPCOLORSCHEME) lParam;
        if (lpclrsc) {
            if (lpclrsc->dwSize == sizeof(COLORSCHEME))
                *lpclrsc = ptb->clrsc;
        }
        return (LRESULT) lpclrsc;
    }

    case TB_SETCOLORSCHEME:
    {
        if (lParam) {
            if (((LPCOLORSCHEME) lParam)->dwSize == sizeof(COLORSCHEME)) {
                ptb->clrsc.clrBtnHighlight = ((LPCOLORSCHEME) lParam)->clrBtnHighlight;
                ptb->clrsc.clrBtnShadow = ((LPCOLORSCHEME) lParam)->clrBtnShadow;
                InvalidateRect(hwnd, NULL, FALSE);
                if (ptb->ci.style & WS_BORDER)
                    CCInvalidateFrame(hwnd);
            }
        }
    }
    break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_TOOLBAR;
        goto DoDefault;

    case WM_NULL:
            // Trap failed RegsiterWindowMessages;
        break;

    default:
    {
        LRESULT lres;
        if (g_uDragImages == uMsg)
            return TBGenerateDragImage(ptb, (SHDRAGIMAGE*)lParam);

        if (CCWndProc(&ptb->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}


int TB_CalcWidth(PTBSTATE ptb, int iHeight)
{
    RECT rc;
    int iWidth = 0;
    int iMaxBtnWidth = 0;  // ptb->iButWidth isn't always width of widest button
    LPTBBUTTONDATA pButton, pBtnLast;
    pBtnLast = &(ptb->Buttons[ptb->iNumButtons]);

    for(pButton = ptb->Buttons; pButton < pBtnLast; pButton++)
    {
        if (!(pButton->fsState & TBSTATE_HIDDEN))
        {
            int iBtnWidth = TBWidthOfButton(ptb, pButton, NULL);
            iWidth += iBtnWidth - s_dxOverlap;
            iMaxBtnWidth = max(iMaxBtnWidth, iBtnWidth);
        }

    }

    if (ptb->ci.style & TBSTYLE_WRAPABLE) {
        //Make sure the height is a multiple of button height
        iHeight -= (iHeight % ptb->iButHeight);
        if (iHeight < ptb->iButHeight)
            iHeight = ptb->iButHeight;

        WrapToolbar(ptb, iWidth, &rc, NULL);

        // if wrapping at full width gives us a height that's too big,
        // then there's nothing we can do because widening it still keeps us at 1 row
        if (iHeight > RECTHEIGHT(rc)) {
            int iPrevWidth;
            BOOL fDivide = TRUE; //first start by dividing for speed, then narrow it down by subtraction

            TraceMsg(TF_TOOLBAR, "Toolbar: performing expensive width calculation!");

            while (iMaxBtnWidth < iWidth) {
                iPrevWidth = iWidth;
                if (fDivide)
                    iWidth = (iWidth * 2) / 3;
                else
                    iWidth -= ptb->iButWidth;

                if (iWidth == iPrevWidth)
                    break;

                WrapToolbar(ptb, iWidth, &rc, NULL);

                if (iHeight < RECTHEIGHT(rc)) {
                    iWidth = iPrevWidth;
                    if (fDivide) {
                        // we've overstepped on dividing.  go to the previous width
                        // that was ok, and now try subtracting one button at a time
                        fDivide = FALSE;
                    } else
                        break;
                }
            };

            WrapToolbar(ptb, iWidth, &rc, NULL);
            iWidth = max(RECTWIDTH(rc), iMaxBtnWidth);
        }


        // WrapToolbar above has the side effect of actually modifying
        // the layout.  we need to restore it after doing all this calculations
        TBAutoSize(ptb);
    }

    return iWidth;
}


LRESULT TB_OnScroll(PTBSTATE ptb, LPNMHDR pnm)
{
    POINT pt, ptTemp;
    LPNMPGSCROLL pscroll = (LPNMPGSCROLL)pnm;
    int iDir = pscroll->iDir;
    RECT rcTemp, rc = pscroll->rcParent;
    int parentsize = 0;
    int scroll = pscroll->iScroll;
    int iButton = 0;
    int iButtonSize  = ptb->iButHeight;
    int y = 0;
    int iCurrentButton = 0;
   //This variable holds the number of buttons in a row
    int iButInRow = 0;

    pt.x = pscroll->iXpos;
    pt.y = pscroll->iYpos;
    ptTemp = pt;

    //We need to add the offset of the toolbar to the scroll position to get the
    //correct scroll positon in terms of toolbar window
    pt.x += ptb->xFirstButton;
    pt.y += ptb->iYPos;
    ptTemp = pt;


    if ((iDir == PGF_SCROLLUP) || (iDir == PGF_SCROLLDOWN))
    {
        //Vertical Mode
        if (ptb->iButWidth == 0 )
        {
            iButInRow = 1;
        }
        else
        {
            iButInRow = RECTWIDTH(rc) / ptb->iButWidth;
        }

    }
    else
    {
        //Horizontal Mode
        iButInRow =  1;
    }
    // if the parent height/width is less than button height/width then set the  number of
    // buttons in a row to be 1
    if (0 == iButInRow)
    {
        iButInRow = 1;
    }

    iCurrentButton = TBHitTest(ptb, pt.x + 1, pt.y + 1);

    //if the button is negative then we have hit a seperator.
    //Convert the index of the seperator into button index
    if (iCurrentButton < 0)
         iCurrentButton = -iCurrentButton - 1;

    switch ( iDir )
    {
    case PGF_SCROLLUP:
    case PGF_SCROLLLEFT:
        if(iDir == PGF_SCROLLLEFT)
        {
            FlipRect(&rc);
            FlipPoint(&pt);
            FlipPoint(&ptTemp);
            iButtonSize = ptb->iButWidth;
        }

        //Check if any button is partially visible at the left/top. if so then set the bottom
        // of that button to be our current offset and then scroll. This avoids skipping over
        // certain buttons when partial buttons are displayed at the left or top
        y = pt.y;
        TB_GetItemRect(ptb, iCurrentButton, &rcTemp);
        if(iDir == PGF_SCROLLLEFT)
        {
            FlipRect(&rcTemp);
        }

        if (rcTemp.top  <  y-1)
        {
            iCurrentButton += iButInRow;
        }

        //Now do the actual calculation

        parentsize = RECTHEIGHT(rc);

        //if  the control key is down and we have more than parentsize size of child window
        // then scroll by that amount
        if (pscroll->fwKeys & PGK_CONTROL)

        {
            if ((y - parentsize) > 0 )
            {
                scroll = parentsize;
            }
            else
            {
                scroll = y;
                return 0L;
            }

        } else  if ((y - iButtonSize) > 0 ){
        // we dont have control key down so scroll by one buttonsize
            scroll = iButtonSize;

        } else {
            scroll = pt.y;
            return 0L;
        }
        ptTemp.y -= scroll;

        if(iDir == PGF_SCROLLLEFT)
        {
            FlipPoint(&ptTemp);
        }

        iButton = TBHitTest(ptb, ptTemp.x, ptTemp.y);

        //if the button is negative then we have hit a seperator.
        //Convert the index of the seperator into button index
        if (iButton < 0)
            iButton = -iButton -1 ;

       // if  the hit test gives us the same button as our prevbutton then set the button
       // to one button to the left  of the prev button

       if ((iButton == iCurrentButton) && (iButton >= iButInRow))
       {
           iButton -= iButInRow;
           if ((ptb->Buttons[iButton].fsStyle & BTNS_SEP)  && (iButton >= iButInRow))
           {
               iButton -= iButInRow;
           }
       }
       //When scrolling left if we end up in the middle of some button then we align it to the
       //right of that button this is to avoid scrolling more than the pager window width but if the
       // button happens to be the left button of  our current button then we end up in not scrolling
       //if thats the case then move one more button to the left.


       if (iButton == iCurrentButton-iButInRow)
       {
           iButton -= iButInRow;
       }

       TB_GetItemRect(ptb, iButton, &rcTemp);
       if(iDir == PGF_SCROLLLEFT)
       {
           FlipRect(&rcTemp);
       }
       scroll = pt.y - rcTemp.bottom;
       //Set the scroll value
       pscroll->iScroll = scroll;
       break;

    case PGF_SCROLLDOWN:
    case PGF_SCROLLRIGHT:
        {
            RECT rcChild;
            int childsize;

            GetWindowRect(ptb->ci.hwnd, &rcChild);
            if( iDir == PGF_SCROLLRIGHT)
            {
                FlipRect(&rcChild);
                FlipRect(&rc);
                FlipPoint(&pt);
                FlipPoint(&ptTemp);
                iButtonSize = ptb->iButWidth;
            }

            childsize = RECTHEIGHT(rcChild);
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount

            if (pscroll->fwKeys & PGK_CONTROL)
            {
                if ((childsize - pt.y - parentsize) > parentsize)
                {
                    scroll = parentsize;
                }
                else
                {
                    scroll = childsize - pt.y - parentsize;
                    return 0L;
                }

            } else if (childsize - pt.y - parentsize > iButtonSize) {
            // we dont have control key down so scroll by one buttonsize
                scroll = iButtonSize;

            } else {
                pscroll->iScroll = childsize - pt.y - parentsize;
                return 0L;
            }
            ptTemp.y += scroll;

            if(iDir == PGF_SCROLLRIGHT)
            {
                FlipPoint(&ptTemp);
            }

            iButton = TBHitTest(ptb, ptTemp.x, ptTemp.y);

            //if the button is negative then we have hit a seperator.
            //Convert the index of the seperator into button index
                if (iButton < 0)
                iButton = -iButton - 1 ;

            if ((iButton == iCurrentButton) && ((iButton + iButInRow) < ptb->iNumButtons))
            {
                iButton += iButInRow;
                if ((ptb->Buttons[iButton].fsStyle & BTNS_SEP)  && ((iButton + iButInRow) < ptb->iNumButtons))
                {
                    iButton += iButInRow;
                }
            }

            TB_GetItemRect(ptb, iButton, &rcTemp);
            if(iDir == PGF_SCROLLRIGHT)
            {
                FlipRect(&rcTemp);
            }
            scroll = rcTemp.top  - pt.y ;

            //Set the scroll value
            pscroll->iScroll = scroll;
            break;
        }
    }
    return 0L;
}

int TB_CalcHeight(PTBSTATE ptb)
{
    int iHeight = 0;
    int i;

    ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
    ASSERT(!(ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN));

    for (i = 0; i < ptb->iNumButtons; i++)
    {
        if (!(ptb->Buttons[i].fsState & TBSTATE_HIDDEN))
        {
            if (ptb->Buttons[i].fsStyle & BTNS_SEP)
                iHeight += (TBGetSepHeight(ptb, &ptb->Buttons[i]));
            else
                iHeight += ptb->iButHeight;
        }
    }

    return iHeight;
}

LRESULT TB_OnCalcSize(PTBSTATE ptb, LPNMHDR pnm)
{
    LPNMPGCALCSIZE pcalcsize = (LPNMPGCALCSIZE)pnm;
    RECT rc;

    switch(pcalcsize->dwFlag)
    {
    case PGF_CALCHEIGHT:

        if (ptb->szCached.cx == pcalcsize->iWidth)
            pcalcsize->iHeight = ptb->szCached.cy;
        else
        {
            if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
            {
                WrapToolbarCol(ptb, ptb->sizeBound.cy,  &rc, NULL);
                pcalcsize->iWidth = RECTWIDTH(rc);
                pcalcsize->iHeight = RECTHEIGHT(rc);
            }
            else if (ptb->dwStyleEx & TBSTYLE_EX_VERTICAL)
            {
                pcalcsize->iHeight = TB_CalcHeight(ptb);
            }
            else
            {
                // BUGBUG: this WrapToolbar call can modify toolbar layout ...
                // seems busted.  should perhaps call TBAutoSize after to restore.
                WrapToolbar(ptb, pcalcsize->iWidth,  &rc, NULL);
                pcalcsize->iHeight = RECTHEIGHT(rc);
            }
        }
        break;

    case PGF_CALCWIDTH:
        if (ptb->szCached.cy == pcalcsize->iHeight) {
            pcalcsize->iWidth = ptb->szCached.cx;
        } else {
            pcalcsize->iWidth = TB_CalcWidth(ptb, pcalcsize->iHeight);
        }
        break;
    }

    ptb->szCached.cx = pcalcsize->iWidth;
    ptb->szCached.cy = pcalcsize->iHeight;
    return 0L;
}

LRESULT TB_OnPagerControlNotify(PTBSTATE ptb, LPNMHDR pnm)
{
    switch(pnm->code) {
    case PGN_SCROLL:
        return TB_OnScroll(ptb, pnm);
        break;
    case PGN_CALCSIZE:
        return TB_OnCalcSize(ptb, pnm);
        break;
    }
    return 0L;
}


BOOL TBGetMaxSize( PTBSTATE ptb, LPSIZE lpsize )
{
    // need to calc the number of buttons and then the number of separators...
    int iButton;
    LPTBBUTTONDATA pAllButtons = ptb->Buttons;
    int iRealButtons = 0;
    int iSeparators = 0;

    if ( !lpsize )
        return FALSE;
    if (ptb->dwStyleEx & TBSTYLE_EX_MULTICOLUMN)
    {
        ASSERT(ptb->dwStyleEx & TBSTYLE_EX_VERTICAL);
        lpsize->cx = RECTWIDTH(ptb->rc);
        lpsize->cy = RECTHEIGHT(ptb->rc);
        return TRUE;
    }
    for (iButton = 0; iButton < ptb->iNumButtons; iButton++)
    {
        LPTBBUTTONDATA pButton = &pAllButtons[iButton];

        if (!( pButton->fsState & TBSTATE_HIDDEN ))
        {
            if ( pButton->fsStyle & BTNS_SEP )
                iSeparators ++;
            else
                iRealButtons ++;
        }
    }

    // BUGBUG: g_dxButtonSep is handy, but what if the separator style changes,
    // BUGBUG: for example we don't distinguish between flat and non-flat separators..
    if ( ptb->ci.style & CCS_VERT )
    {
        // we are vertical ...
        lpsize->cx = ptb->iButWidth;
        lpsize->cy = ptb->iButHeight * iRealButtons + g_dxButtonSep * iSeparators;
    }
    else
    {
        lpsize->cx = ptb->iButWidth * iRealButtons + g_dxButtonSep * iSeparators;
        lpsize->cy = ptb->iButHeight;
    }
    return TRUE;
}


void TBGetItem(PTBSTATE ptb, LPTBBUTTONDATA ptButton, LPNMTBDISPINFO ptbdi)
{

    ptbdi->idCommand = ptButton->idCommand;
    ptbdi->iImage  =  -1;
    ptbdi->lParam  = ptButton->dwData;


    CCSendNotify(&ptb->ci, TBN_GETDISPINFO, &(ptbdi->hdr));

    if(ptbdi->dwMask & TBNF_DI_SETITEM) {
        if(ptbdi->dwMask & TBNF_IMAGE)
            ptButton->DUMMYUNION_MEMBER(iBitmap) = ptbdi->iImage;
    }

}

BOOL TBGetInfoTip(PTBSTATE ptb, LPTOOLTIPTEXT lpttt, LPTBBUTTONDATA pTBButton)
{
    NMTBGETINFOTIP git;
    TCHAR   szBuf[INFOTIPSIZE];

    szBuf[0] = 0;
    git.pszText = szBuf;
    git.cchTextMax = ARRAYSIZE(szBuf);
    git.iItem = pTBButton->idCommand;
    git.lParam = pTBButton->dwData;

    CCSendNotify(&ptb->ci, TBN_GETINFOTIP, &git.hdr);

    if (git.pszText && git.pszText[0]) {
        // if they didn't fill anything in, go to the default stuff
        // without modifying the notify structure

        Str_Set(&ptb->pszTip, git.pszText);
        lpttt->lpszText = ptb->pszTip;
        return lpttt->lpszText && lpttt->lpszText[0];
    }

    return FALSE;
}
#ifdef UNIX
void TBSetHotItemWithoutNotification(PTBSTATE ptb, int iPos, DWORD dwReason)
{
    if ((ptb->ci.style & TBSTYLE_FLAT) ) {

        // Either one of these values can be -1, but refrain
        // from processing if both are negative b/c it is wasteful
        // and very common

        if ((ptb->iHot != iPos || (dwReason & HICF_RESELECT)) &&
            (0 <= ptb->iHot || 0 <= iPos) &&
            iPos < ptb->iNumButtons)
        {
            NMTBHOTITEM nmhot = {0};

            // Has the mouse moved away from the toolbar but
            // do we still anchor the highlight?
            if (0 > iPos && ptb->fAnchorHighlight && (dwReason & HICF_MOUSE))
                return ;        // Yes; deny the hot item change

            // Send a notification about the hot item change
            if (0 > ptb->iHot)
            {
                if (iPos >= 0)
                    nmhot.idNew = ptb->Buttons[iPos].idCommand;
                nmhot.dwFlags = HICF_ENTERING;
            }
            else if (0 > iPos)
            {
                if (ptb->iHot >= 0)
                    nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
                nmhot.dwFlags = HICF_LEAVING;
            }
            else
            {
                nmhot.idOld = ptb->Buttons[ptb->iHot].idCommand;
                nmhot.idNew = ptb->Buttons[iPos].idCommand;
            }
            nmhot.dwFlags |= dwReason;

            //if (CCSendNotify(&ptb->ci, TBN_HOTITEMCHANGE, &nmhot.hdr))
            //    return;         // deny the hot item change

            TBInvalidateButton(ptb, ptb->iHot, TRUE);
            if ((iPos < 0) || !(ptb->Buttons[iPos].fsState & TBSTATE_ENABLED))
                iPos = -1;

            ptb->iHot = iPos;

            TBInvalidateButton(ptb, ptb->iHot, TRUE);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\tooltips.c ===
#include "ctlspriv.h"

#define TF_TT 0x10

//#define TTDEBUG

#define ACTIVE          0x10
#define BUTTONISDOWN    0x20
#define BUBBLEUP        0x40
#define VIRTUALBUBBLEUP 0x80  // this is for dead areas so we won't
                                //wait after moving through dead areas
#define TRACKMODE       0x01

#define MAXTIPSIZE       128
#define INITIALTIPSIZE    80
#define XTEXTOFFSET        2
#define YTEXTOFFSET        1
#define XBALLOONOFFSET    10
#define YBALLOONOFFSET     8
#define BALLOON_X_CORNER  13
#define BALLOON_Y_CORNER  13
#define STEMOFFSET        16
#define STEMHEIGHT        20
#define STEMWIDTH         14
#define MINBALLOONWIDTH   30 // min width for stem to show up

#define TTT_INITIAL        1
#define TTT_RESHOW         2
#define TTT_POP            3
#define TTT_AUTOPOP        4

#define TIMEBETWEENANIMATE  2000        // 2 Seconds between animates

#define MAX_TIP_CHARACTERS 100
#define TITLEICON_WIDTH   16
#define TITLEICON_HEIGHT  16
#define TITLEICON_DIST    8     // Distance from Icon to Title
#define TITLE_INFO_DIST   6     // Distance from the Title to the Tip Text
#define MAX_TIP_WIDTH     300   // Seems kind of arbitrary. Width of the tip.


typedef struct tagWIN95TOOLINFO {
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPSTR lpszText;
} WIN95TTTOOLINFO;


/* tooltips.c */

typedef struct {
    CONTROLINFO ci;
    //HWND hwnd;       // in ci
    int iNumTools;
    int iDelayTime;
    int iReshowTime;
    int iAutoPopTime;
    PTOOLINFO tools;
    PTOOLINFO pCurTool;
    BOOL fMyFont;
    HFONT hFont;
    //UINT uiCodePage; // in ci
    DWORD dwFlags;
    //DWORD dwStyle;   // in ci

    // Timer info;
    UINT_PTR idTimer;
    POINT pt;

    UINT_PTR idtAutoPop;

    // Tip buffer
    LPTSTR lpTipText;
    UINT   cchTipText;

    LPTSTR lpTipTitle;
    UINT   cchTipTitle; 
    UINT   uTitleBitmap;
    int    iTitleHeight;
    HIMAGELIST himlTitleBitmaps;

    POINT ptTrack; // the saved track point from TTM_TRACKPOSITION

    BOOL fBkColorSet :1;
    BOOL fTextColorSet :1;
    BOOL fUnderStem : 1;        // true if stem is under the balloon
    BOOL fInWindowFromPoint:1;  // handling a TTM_WINDOWFROMPOINT message
    BOOL fEverShown:1;          // Have we ever been shown before?
    COLORREF clrTipBk;          // This is joeb's idea...he wants it
    COLORREF clrTipText;        // to be able to _blend_ more, so...
    
    int  iMaxTipWidth;          // the maximum tip width
    RECT rcMargin;              // margin offset b/t border and text
    int  iStemHeight;           // balloon mode stem/wedge height
    DWORD dwLastDisplayTime;    // The tick count taken at the last display. Used for animate puroposes.
} CToolTipsMgr, NEAR *PToolTipsMgr;

#define TTToolHwnd(pTool)  ((pTool->uFlags & TTF_IDISHWND) ? (HWND)pTool->uId : pTool->hwnd)
#define IsTextPtr(lpszText)  (((lpszText) != LPSTR_TEXTCALLBACK) && (!IS_INTRESOURCE(lpszText)))

//
// Function prototypes
//
LRESULT WINAPI ToolTipsWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void NEAR PASCAL TTSetDelayTime(PToolTipsMgr pTtm, WPARAM wParam, LPARAM lParam);
int NEAR PASCAL TTGetDelayTime(PToolTipsMgr pTtm, WPARAM wParam);

#ifdef UNICODE
BOOL ThunkToolInfoAtoW (LPTOOLINFOA lpTiA, LPTOOLINFOW lpTiW, BOOL bThunkText, UINT uiCodePage);
BOOL ThunkToolInfoWtoA (LPTOOLINFOW lpTiW, LPTOOLINFOA lpTiA, UINT uiCodePage);
BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage);
#endif

#pragma code_seg(CODESEG_INIT)

BOOL FAR PASCAL InitToolTipsClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    // See if we must register a window class
    if (!GetClassInfo(hInstance, c_szSToolTipsClass, &wc)) {
#ifndef WIN32
    extern LRESULT CALLBACK _ToolTipsWndProc(HWND, UINT, WPARAM, LPARAM);
    wc.lpfnWndProc = _ToolTipsWndProc;
#else
    wc.lpfnWndProc = ToolTipsWndProc;
#endif

    wc.lpszClassName = c_szSToolTipsClass;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = NULL;
    wc.lpszMenuName = NULL;
    wc.hbrBackground = (HBRUSH)(NULL);
    wc.hInstance = hInstance;
    wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_SAVEBITS;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PToolTipsMgr);

    return RegisterClass(&wc);
    }
    return TRUE;
}
#pragma code_seg()


/* _  G E T  H C U R S O R  P D Y 3 */
/*-------------------------------------------------------------------------
 %%Function: _GetHcursorPdy3
 %%Contact: migueldc

 With the new mouse drivers that allow you to customize the mouse
 pointer size, GetSystemMetrics returns useless values regarding
 that pointer size.

 Assumptions:
 1. The pointer's width is equal to its height. We compute
 its height and infer its width.
 2. The pointer's leftmost pixel is located in the 0th column
 of the bitmap describing it.
 3. The pointer's topmost pixel is located in the 0th row
 of the bitmap describing it.

 This function looks at the mouse pointer bitmap,
 to find out the height of the mouse pointer (not returned),
 the vertical distance between the cursor's hot spot and
 the cursor's lowest visible pixel (pdyBottom),
 the horizontal distance between the hot spot and the pointer's
 left edge (pdxLeft) annd the horizontal distance between the
 hot spot and the pointer's right edge (pdxRight).
 -------------------------------------------------------------------------*/
typedef WORD CURMASK;
#define _BitSizeOf(x) (sizeof(x)*8)

void NEAR PASCAL _GetHcursorPdy3(int *pdxRight, int *pdyBottom)
{
    int i;
    int iXOR = 0;
    int dy, dx;
    CURMASK CurMask[16*8];
    ICONINFO iconinfo;
    BITMAP bm;
    HCURSOR hCursor = GetCursor();

    *pdyBottom = 16; //best guess
    *pdxRight = 16;  //best guess
    if (!GetIconInfo(hCursor, &iconinfo))
        return;
    if (!GetObject(iconinfo.hbmMask, sizeof(bm), (LPSTR)&bm))
        return;
    if (!GetBitmapBits(iconinfo.hbmMask, sizeof(CurMask), CurMask))
        return;
    i = (int)(bm.bmWidth * bm.bmHeight / _BitSizeOf(CURMASK) );
    
    if (!iconinfo.hbmColor) 
    {
        // if no color bitmap, then the hbmMask is a double height bitmap
        // with the cursor and the mask stacked.
        iXOR = i - 1;
        i /= 2;    
    } 
    
    if ( i >= sizeof(CurMask)) i = sizeof(CurMask) -1;
    if (iXOR >= sizeof(CurMask)) iXOR = 0;
    
    for (i--; i >= 0; i--)
    {
        if (CurMask[i] != 0xFFFF || (iXOR && (CurMask[iXOR--] != 0)))
            break;
    }
    
    if (iconinfo.hbmColor) DeleteObject(iconinfo.hbmColor);
    if (iconinfo.hbmMask) DeleteObject(iconinfo.hbmMask);

    // Compute the pointer height
    dy = (i + 1) * _BitSizeOf(CURMASK) / (int)bm.bmWidth;
    dx = (i + 1) * _BitSizeOf(CURMASK) / (int)bm.bmHeight;

    // Compute the distance between the pointer's lowest, left, rightmost
    //  pixel and the HotSpotspot
    *pdyBottom = dy - (int)iconinfo.yHotspot;
#if defined(UNIX)
    if ((int)iconinfo.yHotspot > dy)
    {
        *pdyBottom = 16; //best guess
    }
#endif
    *pdxRight  = dx - (int)iconinfo.xHotspot;
}

// this returns the values in work area coordinates because
// that's what set window placement uses
void NEAR PASCAL _GetCursorLowerLeft(int *piLeft, int *piTop, int *piWidth, int *piHeight)
{
    DWORD dwPos;
    
    dwPos = GetMessagePos();
    _GetHcursorPdy3(piWidth, piHeight);
    *piLeft = GET_X_LPARAM(dwPos);
    *piTop  = GET_Y_LPARAM(dwPos) + *piHeight;
}

void NEAR PASCAL ToolTips_NewFont(PToolTipsMgr pTtm, HFONT hFont)
{
    if (pTtm->fMyFont && pTtm->hFont)
    {
        DeleteObject(pTtm->hFont);
        pTtm->fMyFont = FALSE;
    }

    if ( !hFont )
    {
        hFont = CCCreateStatusFont();
        pTtm->fMyFont = TRUE;
        
        if (!hFont) {
            hFont = g_hfontSystem;
            pTtm->fMyFont = FALSE;
        }
    }

    pTtm->hFont = hFont;
    pTtm->ci.uiCodePage = GetCodePageForFont(hFont);
}

BOOL NEAR PASCAL ChildOfActiveWindow(HWND hwndChild)
{
    HWND hwnd = hwndChild;
    HWND hwndActive = GetForegroundWindow();

    while (hwnd)    {
        if (hwnd == hwndActive)
            return TRUE;
        else
            hwnd = GetParent(hwnd);
    }
    return FALSE;
}

void NEAR PASCAL PopBubble(PToolTipsMgr pTtm)
{
    // we're at least waiting to show;
    DebugMsg(TF_TT, TEXT("PopBubble (killing timer)"));
    if(pTtm->idTimer) {
        KillTimer(pTtm->ci.hwnd, pTtm->idTimer);
        pTtm->idTimer = 0;
    }

    if (pTtm->idtAutoPop) {
        KillTimer(pTtm->ci.hwnd, pTtm->idtAutoPop);
        pTtm->idtAutoPop = 0;
    }


    if (IsWindowVisible(pTtm->ci.hwnd) && pTtm->pCurTool) {
        NMHDR nmhdr;
        nmhdr.hwndFrom = pTtm->ci.hwnd;
        nmhdr.idFrom = pTtm->pCurTool->uId;
        nmhdr.code = TTN_POP;

        SendNotifyEx(pTtm->pCurTool->hwnd, (HWND)-1,
                     TTN_POP, &nmhdr,
                     (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
    }

    KillTimer(pTtm->ci.hwnd, TTT_POP);
    ShowWindow(pTtm->ci.hwnd, SW_HIDE);
    pTtm->dwFlags &= ~(BUBBLEUP|VIRTUALBUBBLEUP);
    pTtm->pCurTool = NULL;

}

PToolTipsMgr NEAR PASCAL ToolTipsMgrCreate(HWND hwnd, CREATESTRUCT FAR* lpCreateStruct)
{
    PToolTipsMgr pTtm = (PToolTipsMgr)LocalAlloc(LPTR, sizeof(CToolTipsMgr));
    if (pTtm) {

        CIInitialize(&pTtm->ci, hwnd, lpCreateStruct);

        // LPTR zeros the rest of the struct for us
        TTSetDelayTime(pTtm, TTDT_AUTOMATIC, (LPARAM)-1);
        pTtm->dwFlags = ACTIVE;
        pTtm->iMaxTipWidth = -1;
        
        // These are the defaults (straight from cutils.c), 
        // but you can always change them...
        pTtm->clrTipBk = g_clrInfoBk;
        pTtm->clrTipText = g_clrInfoText;

        // Setup the default tooltip text buffer
        pTtm->lpTipText = LocalAlloc (LPTR, INITIALTIPSIZE * sizeof(TCHAR));

        if (pTtm->lpTipText) {
            pTtm->cchTipText = INITIALTIPSIZE;

        } else {
            LocalFree (pTtm);
            pTtm = NULL;
        }
    }
    return pTtm;
}

void NEAR PASCAL TTSetTimer(PToolTipsMgr pTtm, int id)
{
    int iDelayTime = 0;

    if(pTtm->idTimer) {
        KillTimer(pTtm->ci.hwnd, pTtm->idTimer);
    }

    switch (id) {
        case TTT_POP:
        case TTT_RESHOW:
            iDelayTime = pTtm->iReshowTime;
            if (iDelayTime < 0)
                iDelayTime = GetDoubleClickTime() / 5;
            break;

        case TTT_INITIAL:
            iDelayTime = pTtm->iDelayTime;
            if (iDelayTime < 0)
                iDelayTime = GetDoubleClickTime();
            break;

    case TTT_AUTOPOP:
        iDelayTime = pTtm->iAutoPopTime;
        if (iDelayTime < 0)
            iDelayTime = GetDoubleClickTime() * 10;
        pTtm->idtAutoPop = SetTimer(pTtm->ci.hwnd, id, iDelayTime, NULL);
        return;
    }

    
    DebugMsg(TF_TT, TEXT("TTSetTimer %d for %d ms"), id, iDelayTime);
    
    if (SetTimer(pTtm->ci.hwnd, id, iDelayTime, NULL) &&
        (id != TTT_POP)) {
        pTtm->idTimer = id;
        GetCursorPos(&pTtm->pt);
    }
}

//
//  Double-hack to solve blinky-tooltips problems.
//
//  fInWindowFromPoint makes us temporarily transparent.
//
//  Clear the WS_DISABLED flag to trick USER into hit-testing against us.
//  USER by default skips disabled windows.  Restore the flag afterwards.
//  VB in particular likes to run around disabling all top-level windows
//  owned by his process.
//
//  We must use SetWindowBits() instead of EnableWindow() because
//  EnableWindow() will mess with the capture and focus.
//
HWND TTWindowFromPoint(PToolTipsMgr pTtm, LPPOINT ppt)
{
    HWND hwnd;
    DWORD dwStyle;
    dwStyle = SetWindowBits(pTtm->ci.hwnd, GWL_STYLE, WS_DISABLED, 0);
    pTtm->fInWindowFromPoint = TRUE;
    hwnd = (HWND)SendMessage(pTtm->ci.hwnd, TTM_WINDOWFROMPOINT, 0, (LPARAM)ppt);
    pTtm->fInWindowFromPoint = FALSE;
    SetWindowBits(pTtm->ci.hwnd, GWL_STYLE, WS_DISABLED, dwStyle);
    return hwnd;
}

BOOL NEAR PASCAL ToolHasMoved(PToolTipsMgr pTtm)
{
    // this is in case Raymond pulls something sneaky like moving
    // the tool out from underneath the cursor.

    HWND hwnd;
    RECT rc;
    PTOOLINFO pTool = pTtm->pCurTool;

    if (!pTool)
        return TRUE;

    hwnd = TTToolHwnd(pTool);

    // if the window is no longer visible, or is no long a child
    // of the active (without the always tip flag)
    // also check window at point to ensure that the window isn't covered
    if (IsWindowVisible(hwnd) &&
        ((pTtm->ci.style & TTS_ALWAYSTIP) || ChildOfActiveWindow(hwnd)) &&
        (hwnd == TTWindowFromPoint(pTtm, &pTtm->pt))) {

        GetWindowRect(hwnd, &rc);
        if(PtInRect(&rc, pTtm->pt) )
            return FALSE;
    }

    return TRUE;
}

BOOL NEAR PASCAL MouseHasMoved(PToolTipsMgr pTtm)
{
    POINT pt;
    GetCursorPos(&pt);
    return ( (pt.x != pTtm->pt.x) || (pt.y != pTtm->pt.y) );
}

PTOOLINFO NEAR PASCAL FindTool(PToolTipsMgr pTtm, LPTOOLINFO lpToolInfo)
{
    int i;
    PTOOLINFO pTool;
    
    
#ifdef WINDOWS_ME
    if(!(pTtm && lpToolInfo))
    {
    DebugMsg(TF_ALWAYS, TEXT("FindTool passed invalid argumnet. Exiting..."));
    return NULL;
    }
#endif //WINDOWS_ME
    // BUGBUG: in win95, this was NOT validated... by doing so now, we may
    // cause some compat problems... if so, we need to assume for 4.0 marked
    // guys that cbSize == &(0->lParam)
    if (lpToolInfo->cbSize > sizeof(TOOLINFO))
        return NULL;
        
    // you can pass in an index or a toolinfo descriptor
    if (IS_INTRESOURCE(lpToolInfo)) {
        i = PtrToUlong(lpToolInfo);
        if (i < pTtm->iNumTools) {
            return &pTtm->tools[i];
        } else
            return NULL;
        
    }
    
    for(i = 0 ; i < pTtm->iNumTools; i++) {
    pTool = &pTtm->tools[i];
    if((pTool->hwnd == lpToolInfo->hwnd) &&
       (pTool->uId == lpToolInfo->uId))
        return pTool;        
    }
    return NULL;
}


LRESULT WINAPI TTSubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

void NEAR PASCAL TTUnsubclassHwnd(HWND hwnd, HWND hwndTT, BOOL fForce)
{
    ULONG_PTR dwRefs;
    
    if (IsWindow(hwnd) &&
        GetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, (PULONG_PTR) &dwRefs))
    {
        if (!fForce && (dwRefs > 1))
            SetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, dwRefs - 1);
        else
            RemoveWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT);
    }
}

LRESULT WINAPI TTSubclassProc(HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    if (((message >= WM_MOUSEFIRST) && (message <= WM_MOUSELAST)) ||
        (message == WM_NCMOUSEMOVE))
    {
        RelayToToolTips((HWND)uIdSubclass, hwnd, message, wParam, lParam);
    }
    else if (message == WM_NCDESTROY)
    {
        TTUnsubclassHwnd(hwnd, (HWND)uIdSubclass, TRUE);
    }

    return DefSubclassProc(hwnd, message, wParam, lParam);
}

void NEAR PASCAL TTSubclassHwnd(PTOOLINFO pTool, HWND hwndTT)
{
    HWND hwnd;
    
    if (IsWindow(hwnd = TTToolHwnd(pTool)))
    {
        ULONG_PTR dwRefs;

        GetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, &dwRefs);
        SetWindowSubclass(hwnd, TTSubclassProc, (UINT_PTR)hwndTT, dwRefs + 1);
    }
}
    
    
void NEAR PASCAL TTSetTipText(LPTOOLINFO pTool, LPTSTR lpszText)
{
    // if it wasn't alloc'ed before, set it to NULL now so we'll alloc it
    // otherwise, don't touch it and it will be realloced
    if (!IsTextPtr(pTool->lpszText)) {
        pTool->lpszText = NULL;
    }
    
    if (IsTextPtr(lpszText)) {
        DebugMsg(TF_TT, TEXT("TTSetTipText %s"), lpszText);
        Str_Set(&pTool->lpszText, lpszText);
    } else {
        // if it was alloc'ed before free it now.
        Str_Set(&pTool->lpszText, NULL);
        pTool->lpszText = lpszText;
    }
}

LRESULT NEAR PASCAL AddTool(PToolTipsMgr pTtm, LPTOOLINFO lpToolInfo)
{
    PTOOLINFO pTool;
    PTOOLINFO ptoolsNew;
    LRESULT lResult;

    // bail for right now;
    
    if (lpToolInfo->cbSize > sizeof(TOOLINFO)) {
        ASSERT(0);
        return 0L;
    }

    // on failure to alloc do nothing.
    ptoolsNew = CCLocalReAlloc(pTtm->tools,
                               sizeof(TOOLINFO)*(pTtm->iNumTools+1));
    if ( !ptoolsNew )
            return 0L;
    
    if(pTtm->tools) {
        // realloc could have moved stuff around.  repoint pCurTool
        if (pTtm->pCurTool) {
            pTtm->pCurTool = ((PTOOLINFO)ptoolsNew) + (pTtm->pCurTool - pTtm->tools);
        }
    }
    
    pTtm->tools = ptoolsNew;
    

    pTool = &pTtm->tools[pTtm->iNumTools];
    pTtm->iNumTools++;
    hmemcpy(pTool, lpToolInfo, lpToolInfo->cbSize); 
    pTool->lpszText = NULL;

    //
    // If the tooltip will be displayed within a RTL mirrored window, then
    // simulate mirroring the tooltip. [samera]
    // 
    //
    if (IS_WINDOW_RTL_MIRRORED(lpToolInfo->hwnd) &&
        (!(pTtm->ci.dwExStyle & RTL_MIRRORED_WINDOW)))
    {
        // toggle (mirror) the flags
        pTool->uFlags ^= (TTF_RTLREADING | TTF_RIGHT);
    }

    TTSetTipText(pTool, lpToolInfo->lpszText);
    if (pTool->uFlags & TTF_SUBCLASS) {
        TTSubclassHwnd(pTool, pTtm->ci.hwnd);
    }

    if (!lpToolInfo->hwnd || !IsWindow(lpToolInfo->hwnd)) {
#ifdef UNICODE
        lResult = NFR_UNICODE;
#else
        lResult = NFR_ANSI;
#endif
    } else if (pTool->uFlags & TTF_UNICODE) {
        lResult = NFR_UNICODE;
    } else {
        lResult = SendMessage (pTool->hwnd, WM_NOTIFYFORMAT,
                               (WPARAM)pTtm->ci.hwnd, NF_QUERY);
    }

    if (lResult == NFR_UNICODE) {
        pTool->uFlags |= TTF_UNICODE;
    }

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("Tool Added: ptr=%d, uFlags=%d, wid=%d, hwnd=%d"),
             pTool, pTool->uFlags, pTool->uId, pTool->hwnd);
#endif

    return 1L;
}

void NEAR PASCAL TTBeforeFreeTool(PToolTipsMgr pTtm, LPTOOLINFO pTool)
{
    if (pTool->uFlags & TTF_SUBCLASS) 
        TTUnsubclassHwnd(TTToolHwnd(pTool), pTtm->ci.hwnd, FALSE);

    // clean up
    TTSetTipText(pTool, NULL);
}

void NEAR PASCAL DeleteTool(PToolTipsMgr pTtm, LPTOOLINFO lpToolInfo)
{
    PTOOLINFO pTool;

    // bail for right now;
    if (lpToolInfo->cbSize > sizeof(TOOLINFO)) {
        ASSERT(0);
        return;
    }

    pTool = FindTool(pTtm, lpToolInfo);
    if(pTool) {
        if (pTtm->pCurTool == pTool)
            PopBubble(pTtm);

        TTBeforeFreeTool(pTtm, pTool);

        // replace it with the last one.. no need to waste cycles in realloc
        pTtm->iNumTools--;
        *pTool = pTtm->tools[pTtm->iNumTools]; // struct copy

        //cleanup if we moved the current tool
        if(pTtm->pCurTool == &pTtm->tools[pTtm->iNumTools])
            pTtm->pCurTool = pTool;
    }
}

// this strips out & markers so that people can use menu text strings
void NEAR PASCAL StripAccels(PToolTipsMgr pTtm)
{
    if (!(pTtm->ci.style & TTS_NOPREFIX)) {
        StripAccelerators(pTtm->lpTipText, pTtm->lpTipText, FALSE);
    }
}


//
//  The way we detect if a window is a toolbar or not is by asking it
//  for its MSAA class ID.  We cannot use GetClassWord(GCL_ATOM) because
//  Microsoft LiquidMotion **superclasses** the toolbar, so the classname
//  won't match.
//
#define IsToolbarWindow(hwnd) \
    (SendMessage(hwnd, WM_GETOBJECT, 0, OBJID_QUERYCLASSNAMEIDX) == MSAA_CLASSNAMEIDX_TOOLBAR)

LPTSTR NEAR PASCAL GetToolText(PToolTipsMgr pTtm, PTOOLINFO pTool)
{
    int id;
    HINSTANCE hinst;
    DWORD dwStrLen;
    TOOLTIPTEXT ttt;
    
    if (!pTool)
        return NULL;

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("        **Enter GetToolText: ptr=%d, wFlags=%d, wid=%d, hwnd=%d"),
             pTool, pTool->uFlags, pTool->uId, pTool->hwnd);
#endif

    if (pTtm->lpTipText) {
        *pTtm->lpTipText = TEXT('\0');
    } else {
        pTtm->lpTipText = LocalAlloc (LPTR, INITIALTIPSIZE * sizeof(TCHAR));
        pTtm->cchTipText = INITIALTIPSIZE;
    }

    if (pTool->lpszText == LPSTR_TEXTCALLBACK) {

        ttt.hdr.idFrom = pTool->uId;
        ttt.hdr.code = TTN_NEEDTEXT;
        ttt.hdr.hwndFrom = pTtm->ci.hwnd;

        ttt.szText[0] = TEXT('\0');
        ttt.lpszText = ttt.szText;
        ttt.uFlags = pTool->uFlags;
        ttt.lParam = pTool->lParam;
        ttt.hinst = NULL;

        SendNotifyEx(pTool->hwnd, (HWND) -1,
                     0, (NMHDR FAR *)&ttt,
                     (pTool->uFlags & TTF_UNICODE) ? 1 : 0);

        // APPHACK for Elcom Advanced Disk Catalog and for Microsoft
        // LiquidMotion:
        // they subclass toolbar & expect this notification to
        // be ANSI.  So if the UNICODE notification failed,
        // and our parent is a toolbar, then try again in ANSI.

        if (ttt.lpszText == ttt.szText && ttt.szText[0] == TEXT('\0') &&
            (pTool->uFlags & TTF_UNICODE) && pTtm->ci.iVersion < 5 &&
            IsToolbarWindow(pTool->hwnd)) {
            SendNotifyEx(pTool->hwnd, (HWND) -1,
                     0, (NMHDR FAR *)&ttt,
                     FALSE);
        }

        if (ttt.uFlags & TTF_DI_SETITEM) {
            if (IS_INTRESOURCE(ttt.lpszText)) {
                pTool->lpszText = ttt.lpszText;
                pTool->hinst = ttt.hinst;
            } else if (ttt.lpszText != LPSTR_TEXTCALLBACK) {
                TTSetTipText(pTool, ttt.lpszText);
            }
        }
        
        if (IsFlagPtr(ttt.lpszText))
            return NULL;

#if defined(WINDOWS_ME)
        //
        // we allow the RtlReading flag ONLY to be changed here.
        //
    if (ttt.uFlags & TTF_RTLREADING)
            pTool->uFlags |= TTF_RTLREADING;
    else
            pTool->uFlags &= ~TTF_RTLREADING;
#endif

        if (IS_INTRESOURCE(ttt.lpszText)) {
            id = PtrToUlong(ttt.lpszText);
            hinst = ttt.hinst;
            ttt.lpszText = ttt.szText;
            goto LoadFromResource;
        }
        
        if (*ttt.lpszText == TEXT('\0'))
            return NULL;


        dwStrLen = lstrlen(ttt.lpszText) + 1;
        if (pTtm->cchTipText < dwStrLen)
        {
            LPTSTR psz = LocalReAlloc (pTtm->lpTipText,
                                       dwStrLen * sizeof(TCHAR),
                                       LMEM_MOVEABLE);
            if (psz)
            {
                pTtm->lpTipText = psz;
                pTtm->cchTipText = dwStrLen;
            }
        }

        if (pTtm->lpTipText)
        {
            lstrcpyn(pTtm->lpTipText, ttt.lpszText, pTtm->cchTipText);
        }

#ifdef UNICODE
        //
        //  if ttt.lpszText != ttt.szText and the ttt.uFlags has TTF_MEMALLOCED, then
        //  the ANSI thunk allocated the buffer for us, so free it.
        //

        if ((ttt.lpszText != ttt.szText) && (ttt.uFlags & TTF_MEMALLOCED)) {
            LocalFree (ttt.lpszText);
        }
#endif

        StripAccels(pTtm);

    } else if (pTool->lpszText && IS_INTRESOURCE(pTool->lpszText)) {
        id = PtrToLong(pTool->lpszText);
        hinst = pTool->hinst;

LoadFromResource:

        if (pTtm->lpTipText) {
            if (!LoadString(hinst, id, pTtm->lpTipText, pTtm->cchTipText))
                return NULL;

            StripAccels(pTtm);
        }

    } else  {
        // supplied at creation time.
#ifdef TTDEBUG
        DebugMsg(TF_TT, TEXT("GetToolText returns %s"), pTool->lpszText);
#endif

        if (pTool->lpszText && *pTool->lpszText) {

            dwStrLen = lstrlen(pTool->lpszText) + 1;
            if (pTtm->cchTipText < dwStrLen)
            {
                LPTSTR psz = LocalReAlloc (pTtm->lpTipText,
                                           dwStrLen * sizeof(TCHAR),
                                           LMEM_MOVEABLE);
                if (psz)
                {
                    pTtm->lpTipText = psz;
                    pTtm->cchTipText = dwStrLen;
                }
            }

            if (pTtm->lpTipText) {
                lstrcpyn(pTtm->lpTipText, pTool->lpszText, pTtm->cchTipText);
                StripAccels(pTtm);
            }
        }
    }

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("        **GetToolText returns %s"), pTtm->lpTipText ? pTtm->lpTipText : TEXT("NULL"));
#endif
    return pTtm->lpTipText;
}

LPTSTR NEAR PASCAL GetCurToolText(PToolTipsMgr pTtm)
{
    LPTSTR psz = NULL;
    if (pTtm->pCurTool)
        psz = GetToolText(pTtm, pTtm->pCurTool);

    // this could have changed during the WM_NOTIFY back
    if (!pTtm->pCurTool)
        psz = NULL;
    
    return psz;
}

void NEAR PASCAL GetToolRect(PTOOLINFO pTool, LPRECT lprc)
{
    if (pTool->uFlags & TTF_IDISHWND) {
        GetWindowRect((HWND)pTool->uId, lprc);
    } else {
        *lprc = pTool->rect;
        MapWindowPoints(pTool->hwnd, HWND_DESKTOP, (LPPOINT)lprc, 2);
    }
}

BOOL NEAR PASCAL PointInTool(PTOOLINFO pTool, HWND hwnd, int x, int y)
{
    // We never care if the point is in a track tool or we're using
    // a hit-test.
    if (pTool->uFlags & (TTF_TRACK | TTF_USEHITTEST))
        return FALSE;
    

    if (pTool->uFlags & TTF_IDISHWND) {
        if (hwnd == (HWND)pTool->uId) {
            return TRUE;
        }
    } else if(hwnd == pTool->hwnd) {
    POINT pt;
    pt.x = x;
    pt.y = y;
    if (PtInRect(&pTool->rect, pt)) {
        return TRUE;
    }
    }
    return FALSE;
}

#ifdef TTDEBUG
void NEAR PASCAL DebugDumpTool(PTOOLINFO pTool)
{
    if (pTool) {
        DebugMsg(TF_TT, TEXT("                DumpTool: (%d) hwnd = %d %d, %d %d %d %d"),pTool,
                 pTool->hwnd,
                 (UINT)pTool->uFlags,
                 pTool->rect.left, pTool->rect.top,
                 pTool->rect.right, pTool->rect.bottom);
    } else {
        DebugMsg(TF_TT, TEXT("                DumpTool: (NULL)"));
    }
}
#else
#define DebugDumpTool(p)
#endif

#define HittestInTool(pTool, hwnd, ht) \
    ((pTool->uFlags & TTF_USEHITTEST) && pTool->hwnd == hwnd && ht == pTool->rect.left)

PTOOLINFO NEAR PASCAL GetToolAtPoint(PToolTipsMgr pTtm, HWND hwnd, int x, int y, 
        int ht, BOOL fCheckText)
{
    PTOOLINFO pToolReturn = NULL;
    PTOOLINFO pTool;

    // short cut..  if we're in the same too, and the bubble is up (not just virtual)
    // return it.  this prevents us from having to poll all the time and
    // prevents us from switching to another tool when this one is good
    if ((pTtm->dwFlags & BUBBLEUP) && pTtm->pCurTool != NULL &&
        (HittestInTool(pTtm->pCurTool, hwnd, ht) ||
         PointInTool(pTtm->pCurTool, hwnd, x, y)))
    {
        return pTtm->pCurTool;
    }

#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("******Entering GetToolAtPoint"));
#endif
    if(pTtm->iNumTools) {
        for(pTool = &pTtm->tools[pTtm->iNumTools-1];
            pTool >= pTtm->tools;
            pTool--) {

#ifdef TTDEBUG
            //DebugMsg(TF_TT, TEXT("    Point in Tool Check"));
            //DebugDumpTool(pTool);
#endif

        if(HittestInTool(pTool, hwnd, ht) || PointInTool(pTool, hwnd, x, y)) {
#ifdef TTDEBUG
                //DebugMsg(TF_TT, TEXT("        yes"));
#endif

                // if this tool has text, return it.
                // otherwise, save it away as a dead area tool,
                // and keep looking
                if (fCheckText) {
                    if (GetToolText(pTtm, pTool)) {
#ifdef TTDEBUG
                        //DebugMsg(TF_TT, TEXT("            Return! case it Has text"));
                        //DebugDumpTool(pTool);
#endif
                        return pTool;
                    } else if (pTtm->dwFlags & (BUBBLEUP|VIRTUALBUBBLEUP)) {
                        // only return this (only allow a virutal tool
                        // if there was previously a tool up.
                        // IE, we can't start things off with a virutal tool
                        pToolReturn = pTool;
                    }
                } else {
#ifdef TTDEBUG
                    //DebugMsg(TF_TT, TEXT("            Return! No text check"));
                    //DebugDumpTool(pTool);
#endif
                    return pTool;
                }
            }
    }
    }
#ifdef TTDEBUG
    DebugMsg(TF_TT, TEXT("            Return! no text but returning anyways"));
    DebugDumpTool(pToolReturn);
#endif
    return pToolReturn;
}

void NEAR PASCAL ShowVirtualBubble(PToolTipsMgr pTtm)
{
    PTOOLINFO pTool = pTtm->pCurTool;

    DebugMsg(TF_TT, TEXT("Entering ShowVirtualBubble so popping bubble"));
    PopBubble(pTtm);

    // Set this back in so that while we're in this tool's area,
    // we won't keep querying for info
    pTtm->pCurTool = pTool;
    pTtm->dwFlags |= VIRTUALBUBBLEUP;
}

#define TRACK_TOP    0
#define TRACK_LEFT   1
#define TRACK_BOTTOM 2
#define TRACK_RIGHT  3 


void NEAR PASCAL TTGetTipPosition(PToolTipsMgr pTtm, LPRECT lprc, int cxText, int cyText, int *pxStem, int *pyStem)
{
    RECT rcWorkArea;
    // ADJUSTRECT!  Keep TTAdjustRect and TTM_GETBUBBLESIZE in sync.
    int cxMargin = pTtm->rcMargin.left + pTtm->rcMargin.right;
    int cyMargin = pTtm->rcMargin.top + pTtm->rcMargin.bottom;
    int iBubbleWidth =  2*XTEXTOFFSET * g_cxBorder + cxText + cxMargin;
    int iBubbleHeight = 2*YTEXTOFFSET * g_cyBorder + cyText + cyMargin;
    UINT uSide = (UINT)-1;
    RECT rcTool;
    MONITORINFO mi;
    HMONITOR    hMonitor;
    POINT pt;
    BOOL bBalloon = pTtm->ci.style & TTS_BALLOON;
    int  xStem, yStem;
    int iCursorHeight=0;
    int iCursorWidth=0;
        
    if (bBalloon  || pTtm->cchTipTitle)
    {
        // ADJUSTRECT!  Keep TTAdjustRect and TTM_GETBUBBLESIZE in sync.
        iBubbleWidth += 2*XBALLOONOFFSET;
        iBubbleHeight += 2*YBALLOONOFFSET;

        if (bBalloon)
        {
            if (iBubbleWidth < MINBALLOONWIDTH)
                pTtm->iStemHeight = 0;
            else
            {
                pTtm->iStemHeight = STEMHEIGHT;
                if (pTtm->iStemHeight > iBubbleHeight/3)
                    pTtm->iStemHeight = iBubbleHeight/3; // don't let the stem be longer than the bubble -- looks ugly
            }
        }
    }
    
    GetToolRect(pTtm->pCurTool, &rcTool);
    
    if (pTtm->pCurTool->uFlags & TTF_TRACK) {

        lprc->left = pTtm->ptTrack.x;
        lprc->top = pTtm->ptTrack.y;
        if (bBalloon)
        {
            // adjust the desired left hand side
            xStem = pTtm->ptTrack.x;
            yStem = pTtm->ptTrack.y;
        }

        // BUGBUG: should we not do this in case of TTS_BALLOON?
        if (pTtm->pCurTool->uFlags & TTF_CENTERTIP) {
            // center the bubble around the ptTrack
            lprc->left -= (iBubbleWidth / 2);
            if (!bBalloon)
                lprc->top -=  (iBubbleHeight / 2);
        }
        
        if (pTtm->pCurTool->uFlags & TTF_ABSOLUTE)
        {
            // with goto bellow we'll skip adjusting
            // bubble height -- so do it here
            if (bBalloon)
                iBubbleHeight += pTtm->iStemHeight;
            goto CompleteRect;
        }

        // in balloon style the positioning depends on the position
        // of the stem and we don't try to position the tooltip
        // next to the tool rect
        if (!bBalloon)
        {
            // now align it so that the tip sits beside the rect.
            if (pTtm->ptTrack.y > rcTool.bottom) 
            {
                uSide = TRACK_BOTTOM;
                if (lprc->top < rcTool.bottom)
                    lprc->top = rcTool.bottom;    
            }
            else if (pTtm->ptTrack.x < rcTool.left) 
            {
                uSide = TRACK_LEFT;
                if (lprc->left + iBubbleWidth > rcTool.left)
                    lprc->left = rcTool.left - iBubbleWidth;
            } 
            else if (pTtm->ptTrack.y < rcTool.top) 
            {    
                uSide = TRACK_TOP;
                if (lprc->top + iBubbleHeight > rcTool.top) 
                    lprc->top = rcTool.top - iBubbleHeight;    
            } 
            else 
            {    
                uSide = TRACK_RIGHT;
                if (lprc->left < rcTool.right)
                    lprc->left = rcTool.right;
            }
        }        
    } 
    else if (pTtm->pCurTool->uFlags & TTF_CENTERTIP) 
    {
        lprc->left = (rcTool.right + rcTool.left - iBubbleWidth)/2;
        lprc->top = rcTool.bottom;
        if (bBalloon)
        {
            xStem = (rcTool.left + rcTool.right)/2;
            yStem = rcTool.bottom;
        }
    } 
    else 
    {
        // now set it
        _GetCursorLowerLeft((LPINT)&lprc->left, (LPINT)&lprc->top, &iCursorWidth, &iCursorHeight);
        if (bBalloon)
        {
            HMONITOR  hMon1, hMon2;
            POINT     pt;
            BOOL      bOnSameMonitor = FALSE;
            int iTop = lprc->top - (iCursorHeight + iBubbleHeight + pTtm->iStemHeight);

            xStem = lprc->left;
            yStem = lprc->top;

            pt.x = xStem;
            pt.y = lprc->top;
            hMon1 = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
            pt.y = iTop;
            hMon2 = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

            if (hMon1 == hMon2)
            {
                // the hmons are the same but maybe iTop is off any monitor and we just defaulted 
                // to the nearest one -- check if it's really on the monitor
                mi.cbSize = sizeof(mi);
                GetMonitorInfo(hMon1, &mi);

                if (PtInRect(&mi.rcMonitor, pt))
                {
                    // we'd like to show balloon above the cursor so that wedge/stem points
                    // to tip of the cursor not its bottom left corner
                    yStem -= iCursorHeight;
                    lprc->top = iTop;
                    bOnSameMonitor = TRUE;
                }   
            }

            if (!bOnSameMonitor)
            {
                xStem += iCursorWidth/2;
                iCursorHeight = iCursorWidth = 0;
            }
        }
    }

    //
    //  At this point, (lprc->left, lprc->top) is the position
    //  at which we would prefer that the tooltip appear.
    //
    if (bBalloon)
    {
        // adjust the left point now that all calculations are done
        // but only if we're not in the center tip mode
        // note we use height as width so we can have 45 degree angle that looks nice
        if (!(pTtm->pCurTool->uFlags & TTF_CENTERTIP) && iBubbleWidth > STEMOFFSET + pTtm->iStemHeight)
            lprc->left -= STEMOFFSET;
        // adjust the height to include stem
        iBubbleHeight += pTtm->iStemHeight;
    }

    pt.x = lprc->left;
    pt.y = lprc->top;
    hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    
    if (GetWindowLong(pTtm->ci.hwnd, GWL_EXSTYLE) & WS_EX_TOPMOST)
    {
        CopyRect(&rcWorkArea, &mi.rcMonitor);
    } else {
        CopyRect(&rcWorkArea, &mi.rcWork);
    }

    //
    //  At this point, rcWorkArea is the rectangle within which
    //  the tooltip should finally appear.
    //
    //  Now fiddle with the coordinates to try to find a sane location
    //  for the tip.
    //


    // move it up if it's at the bottom of the screen
    if ((lprc->top + iBubbleHeight) >= (rcWorkArea.bottom)) {
        if (uSide == TRACK_BOTTOM) 
            lprc->top = rcTool.top - iBubbleHeight;     // flip to top
        else 
        {
            //
            //  We can't "stick to bottom" because that would cause
            //  our tooltip to lie under the mouse cursor, causing it
            //  to pop immediately!  So go just above the mouse cursor.
            //
            // cannot do that in the track mode -- tooltip randomly on the 
            // screen, not even near the button
            //
            // BUGBUG raymondc v6: This messes up Lotus SmartCenter.
            // Need to be smarter about when it is safe to flip up.
            // Perhaps by checking if the upflip would put the tip too
            // far away from the mouse.
            if (pTtm->pCurTool->uFlags & TTF_TRACK)
                lprc->top = pTtm->ptTrack.y - iBubbleHeight;
            else
            {            
                int y = GET_Y_LPARAM(GetMessagePos());
                lprc->top = y - iBubbleHeight;
                if (bBalloon)
                    yStem = y;
            }
        }
    }
    
    // If above the top of the screen...
    if (lprc->top < rcWorkArea.top) 
    {
        if (uSide == TRACK_TOP) 
            lprc->top = rcTool.bottom;      // flip to bottom
        else 
            lprc->top = rcWorkArea.top;     // stick to top
    }

    // move it over if it extends past the right.
    if ((lprc->left + iBubbleWidth) >= (rcWorkArea.right)) 
    {
        // flipping is not the right thing to do with balloon style
        // because the wedge/stem can stick out of the window and 
        // would therefore be clipped so
        if (bBalloon)
        {
            // move it to the left so that stem appears on the right side of the balloon
            // again we use height as width so we can have 45 degree angle
            if (iBubbleWidth >= MINBALLOONWIDTH)
                lprc->left = xStem + min(STEMOFFSET, (iBubbleWidth-pTtm->iStemHeight)/2) - iBubbleWidth;
            // are we still out?
            if (lprc->left + iBubbleWidth >= rcWorkArea.right)
                lprc->left = rcWorkArea.right - iBubbleWidth - 1;
        }
        else if (uSide == TRACK_RIGHT) 
            lprc->left = rcTool.left - iBubbleWidth;    // flip to left
        else 
            // not in right tracking mode, just scoot it over
            lprc->left = rcWorkArea.right - iBubbleWidth - 1; // stick to right
    }

    // if too far left...
    if (lprc->left < rcWorkArea.left) 
    {
        if (uSide == TRACK_LEFT)
        {
            // flipping is not the right thing to do with balloon style
            // because the wedge/stem can stick out of the window and 
            // would therefore be clipped so
            if (bBalloon)
                lprc->left = rcWorkArea.left; //pTtm->ptTrack.x;
            else
                lprc->left = rcTool.right;          // flip to right
        }
        else 
            lprc->left = rcWorkArea.left;       // stick to left
    }
    
CompleteRect:
    lprc->right = lprc->left + iBubbleWidth;
    lprc->bottom = lprc->top + iBubbleHeight;
    if (bBalloon && pxStem && pyStem)
    {
        *pxStem = xStem;
        *pyStem = yStem;
    }
}

BOOL TTCreateTitleBitmaps(PToolTipsMgr pTtm)
{
    if (pTtm->himlTitleBitmaps)
        return TRUE;

    pTtm->himlTitleBitmaps = ImageList_Create(TITLEICON_WIDTH, TITLEICON_HEIGHT, ILC_COLOR24 | ILC_MASK, 3, 1);
    if (pTtm->himlTitleBitmaps)
    {
        HICON hicon;
        
        hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_TITLE_INFO), IMAGE_ICON, 
                  TITLEICON_WIDTH, TITLEICON_HEIGHT, LR_DEFAULTCOLOR);
        ImageList_AddIcon(pTtm->himlTitleBitmaps, hicon);
        DestroyIcon(hicon);
        hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_TITLE_WARNING), IMAGE_ICON, 
                  TITLEICON_WIDTH, TITLEICON_HEIGHT, LR_DEFAULTCOLOR);
        ImageList_AddIcon(pTtm->himlTitleBitmaps, hicon);
        DestroyIcon(hicon);
        hicon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_TITLE_ERROR), IMAGE_ICON, 
                  TITLEICON_WIDTH, TITLEICON_HEIGHT, LR_DEFAULTCOLOR);
        ImageList_AddIcon(pTtm->himlTitleBitmaps, hicon);
        DestroyIcon(hicon);
        return TRUE;
    }

    return FALSE;
}

// Called when caclulating the size of a "titled tool tip" or actually drawing
// based on the boolean value bCalcRect.
BOOL TTRenderTitledTip(PToolTipsMgr pTtm, HDC hdc, BOOL bCalcRect, RECT* prc, UINT uDrawFlags)
{
    RECT rc;
    int lWidth=0, lHeight=0;
    HFONT hfont;
    COLORREF crOldTextColor;
    int iOldBKMode;

    // If we don't have a title, we don't need to be here.
    if (pTtm->cchTipTitle == 0)
        return FALSE;

    CopyRect(&rc, prc);
    if (pTtm->uTitleBitmap != TTI_NONE)
    {
        lWidth    = TITLEICON_WIDTH + TITLEICON_DIST;
        lHeight  += TITLEICON_HEIGHT;
        if (!bCalcRect && pTtm->himlTitleBitmaps)
        {
            ImageList_Draw(pTtm->himlTitleBitmaps, pTtm->uTitleBitmap - 1, hdc, rc.left, rc.top, ILD_TRANSPARENT);
        }
        rc.left  += lWidth;
    }

    if (!bCalcRect)
    {
        crOldTextColor = SetTextColor(hdc, pTtm->clrTipText);
        iOldBKMode = SetBkMode(hdc, TRANSPARENT);
    }
    
    if (pTtm->lpTipTitle[0] != TEXT('\0'))
    {
        LOGFONT lf;
        HFONT   hfTitle;
        UINT    uFlags = uDrawFlags | DT_SINGLELINE; // title should be on one line only

        hfont = GetCurrentObject(hdc, OBJ_FONT);
        GetObject(hfont, sizeof(lf), &lf);
        lf.lfWeight = FW_BOLD;
        hfTitle = CreateFontIndirect(&lf);
        // hfont should already be set to this
        hfont = SelectObject(hdc, hfTitle);

        // drawtext does not calculate the height if these are specified
        if (!bCalcRect)
            uFlags |= DT_BOTTOM;

        // we need to calc title height -- either we did it before or we'll do it now
        ASSERT(pTtm->iTitleHeight != 0 || uFlags & DT_CALCRECT);

        // adjust the rect so we can stick the title to the bottom of it
        rc.bottom = rc.top + max(pTtm->iTitleHeight, TITLEICON_HEIGHT);
        // problems in DrawText if margins make rc.right < rc.left
        // even though we are asking for calculation of the rect nothing happens, so ...
        if (bCalcRect)
            rc.right = rc.left + MAX_TIP_WIDTH;

        DrawText(hdc, pTtm->lpTipTitle, lstrlen(pTtm->lpTipTitle), &rc, uFlags);

        if (pTtm->iTitleHeight == 0)
            pTtm->iTitleHeight = RECTHEIGHT(rc);    // Use rc instead of lfHeight, because it can be Negative.

        lHeight  = max(lHeight, pTtm->iTitleHeight) + TITLE_INFO_DIST;
        lWidth  += RECTWIDTH(rc);
        
        SelectObject(hdc, hfont);
        DeleteObject(hfTitle);
    }

    // adjust the rect for the info text
    CopyRect(&rc, prc);
    rc.top += lHeight;

    // we want multi line text -- tooltip will give us single line if we did not set MAXWIDTH
    uDrawFlags &= ~DT_SINGLELINE;
    DrawText(hdc, pTtm->lpTipText, lstrlen(pTtm->lpTipText), &rc, uDrawFlags);
    lHeight += RECTHEIGHT(rc);
    lWidth   = max(lWidth, RECTWIDTH(rc));

    if (bCalcRect)
    {
        prc->right = prc->left + lWidth;
        prc->bottom = prc->top + lHeight;
    }
    else
    {
        SetTextColor(hdc, crOldTextColor);
        SetBkMode(hdc, iOldBKMode);
    }

    return TRUE;
}

void NEAR PASCAL TTGetTipSize(PToolTipsMgr pTtm, PTOOLINFO pTool,LPTSTR lpstr, LPINT pcxText, LPINT pcyText)
{

    // get the size it will be
    HDC hdc  = GetDC(pTtm->ci.hwnd);
    HFONT hOldFont;
    
    if(pTtm->hFont) hOldFont = SelectObject(hdc, pTtm->hFont);

    /* If need to fire off the pre-DrawText notify then do so, otherwise use the
       original implementation that just called MGetTextExtent */


    {
        NMTTCUSTOMDRAW nm;
        DWORD dwCustom;
        UINT  uDefDrawFlags = 0;

        nm.nmcd.hdr.hwndFrom = pTtm->ci.hwnd;
        nm.nmcd.hdr.idFrom = pTool->uId;
        nm.nmcd.hdr.code = NM_CUSTOMDRAW;
        nm.nmcd.hdc = hdc;
        // TTGetTipSize must use CDDS_PREPAINT so the client can tell
        // whether we are measuring or painting
        nm.nmcd.dwDrawStage = CDDS_PREPAINT;
        nm.nmcd.rc.left = nm.nmcd.rc.top = 0;

        if (pTtm->ci.style & TTS_NOPREFIX)
            uDefDrawFlags = DT_NOPREFIX;

        if (pTtm->iMaxTipWidth == -1) 
        {
            uDefDrawFlags |= DT_CALCRECT|DT_SINGLELINE |DT_LEFT;
            MGetTextExtent(hdc, lpstr, -1, pcxText, pcyText);
            nm.nmcd.rc.right = *pcxText;
            nm.nmcd.rc.bottom = *pcyText;
            
        }
        else 
        {    
            uDefDrawFlags |= DT_CALCRECT | DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS | DT_EXTERNALLEADING;
            nm.nmcd.rc.right = pTtm->iMaxTipWidth;
            nm.nmcd.rc.bottom = 0;
            DrawText( hdc, lpstr, lstrlen(lpstr), &nm.nmcd.rc, uDefDrawFlags );
            *pcxText = nm.nmcd.rc.right;
            *pcyText = nm.nmcd.rc.bottom;
        }

#if defined(WINDOWS_ME)
        if ( (pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->ci.dwExStyle & WS_EX_RTLREADING) )
            uDefDrawFlags |= DT_RTLREADING;
#endif
        //
        // Make it right aligned, if requested. [samera]
        //
        if (pTool->uFlags & TTF_RIGHT)
            uDefDrawFlags |= DT_RIGHT;

        nm.uDrawFlags = uDefDrawFlags;

        dwCustom = (DWORD)SendNotifyEx(pTool->hwnd, (HWND) -1,
                     0, (NMHDR*) &nm,
                     (pTool->uFlags & TTF_UNICODE) ? 1 : 0);

        if (TTRenderTitledTip(pTtm, hdc, TRUE, &nm.nmcd.rc, uDefDrawFlags))
        {
            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }
        else if ((dwCustom & CDRF_NEWFONT) || nm.uDrawFlags != uDefDrawFlags)
        {
            DrawText( hdc, lpstr, lstrlen(lpstr), &nm.nmcd.rc, nm.uDrawFlags );

            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }
        // did the owner specify the size?
        else if (pTtm->ci.iVersion >= 5 && (nm.nmcd.rc.right - nm.nmcd.rc.left != *pcxText || 
                                            nm.nmcd.rc.bottom - nm.nmcd.rc.top != *pcyText))
        {
            *pcxText = nm.nmcd.rc.right - nm.nmcd.rc.left;
            *pcyText = nm.nmcd.rc.bottom - nm.nmcd.rc.top;
        }

        // notify parent afterwards if they want us to
        if (!(dwCustom & CDRF_SKIPDEFAULT) &&
            dwCustom & CDRF_NOTIFYPOSTPAINT) {
            nm.nmcd.dwDrawStage = CDDS_POSTPAINT;
            SendNotifyEx(pTool->hwnd, (HWND) -1,
                         0, (NMHDR*) &nm,
                         (pTool->uFlags & TTF_UNICODE) ? 1 : 0);
        }

    }


    if(pTtm->hFont) SelectObject(hdc, hOldFont);
    ReleaseDC(pTtm->ci.hwnd, hdc);

    // after the calc rect, add a little space on the right
    *pcxText += g_cxEdge;
    *pcyText += g_cyEdge;
}

//
//  Given an inner rectangle, return the coordinates of the outer,
//  or vice versa.
//
//  "outer rectangle" = window rectangle.
//  "inner rectangle" = the area where we draw the text.
//
//  This allows people like listview and treeview to position
//  the tooltip so the inner rectangle exactly coincides with
//  their existing text.
//
//  All the places we do rectangle adjusting are marked with
//  the comment
//
//      // ADJUSTRECT!  Keep TTAdjustRect in sync.
//
LRESULT TTAdjustRect(PToolTipsMgr pTtm, BOOL fLarger, LPRECT prc)
{
    RECT rc;

    if (!prc)
        return 0;

    //
    //  Do all the work on our private little rectangle on the
    //  assumption that everything is getting bigger.  At the end,
    //  we'll flip all the numbers around if in fact we're getting
    //  smaller.
    //
    rc.top = rc.left = rc.bottom = rc.right = 0;

    // TTRender adjustments -
    rc.left   -= XTEXTOFFSET*g_cxBorder + pTtm->rcMargin.left;
    rc.right  += XTEXTOFFSET*g_cxBorder + pTtm->rcMargin.right;
    rc.top    -= YTEXTOFFSET*g_cyBorder + pTtm->rcMargin.top;
    rc.bottom += YTEXTOFFSET*g_cyBorder + pTtm->rcMargin.bottom;

    // Compensate for the hack in TTRender that futzes all the rectangles
    // by one pixel.  Look for "Account for off-by-one."
    rc.bottom--;
    rc.right--;

    if (pTtm->ci.style & TTS_BALLOON || pTtm->cchTipTitle)
    {
        InflateRect(&rc, XBALLOONOFFSET, YBALLOONOFFSET);
    }

    //
    //  Ask Windows how much adjusting he will do to us.
    //
    //  Since we don't track WM_STYLECHANGED/GWL_EXSTYLE, we have to ask USER
    //  for our style information, since the app may have changed it.
    //
    AdjustWindowRectEx(&rc,
                       pTtm->ci.style,
                       BOOLFROMPTR(GetMenu(pTtm->ci.hwnd)),
                       GetWindowLong(pTtm->ci.hwnd, GWL_EXSTYLE));

    //
    //  Now adjust our caller's rectangle.
    //
    if (fLarger)
    {
        prc->left   += rc.left;
        prc->right  += rc.right;
        prc->top    += rc.top;
        prc->bottom += rc.bottom;
    }
    else
    {
        prc->left   -= rc.left;
        prc->right  -= rc.right;
        prc->top    -= rc.top;
        prc->bottom -= rc.bottom;
    }

    return TRUE;
}

#define CSTEMPOINTS 3
// bMirrored does not mean a mirrored tooltip.
// It means simulating the behavior or a mirrored tooltip for a tooltip created with a mirrored parent.
HRGN CreateBalloonRgn(int xStem, int yStem, int iWidth, int iHeight, int iStemHeight, BOOL bUnderStem, BOOL bMirrored)
{
    int  y = 0, yHeight = iHeight;
    HRGN rgn;

    if (bUnderStem)
        yHeight -= iStemHeight;
    else
        y = iStemHeight;
        
    rgn = CreateRoundRectRgn(0, y, iWidth, yHeight, BALLOON_X_CORNER, BALLOON_Y_CORNER);
    if (rgn)
    {
        // create wedge/stem rgn
        if (iWidth >= MINBALLOONWIDTH)
        {
            HRGN rgnStem;
            POINT aptStemRgn[CSTEMPOINTS];
            POINT *ppt = aptStemRgn;
            POINT pt;
            BOOL  bCentered;
            int   iStemWidth = iStemHeight+1; // for a 45 degree angle

            // we center the stem if we have TTF_CENTERTIP or the width
            // of the balloon is not big enough to offset the stem by 
            // STEMOFFSET
            // can't quite center the tip on TTF_CENTERTIP because it may be
            // moved left or right it did not fit on the screen: just check
            // if xStem is in the middle
            bCentered = (xStem == iWidth/2) || (iWidth < 2*STEMOFFSET + iStemWidth);

            if (bCentered)
                pt.x = (iWidth - iStemWidth)/2;
            else if (xStem > iWidth/2)
            {
                if(bMirrored)
                {
                    pt.x = STEMOFFSET + iStemWidth;
                }
                else
                {
                    pt.x = iWidth - STEMOFFSET - iStemWidth;
                }    
            }    
            else
            {
                if(bMirrored)
                {
                    pt.x = iWidth - STEMOFFSET;
                }
                else
                {
                    pt.x = STEMOFFSET;
                }    
            }    

            if (bMirrored && (ABS(pt.x - (iWidth - xStem)) <= 2))
            {
                pt.x = iWidth - xStem; // avoid rough edges, have a straight line
                
            }
            else if (!bMirrored && (ABS(pt.x - xStem) <= 2))
            {
                pt.x = xStem; // avoid rough edges, have a straight line
            }    
            if (bUnderStem)
                pt.y = iHeight - iStemHeight - 2;
            else
                pt.y = iStemHeight + 2;
            *ppt++ = pt;
            if(bMirrored)
            {
                pt.x -= iStemWidth;            
            }
            else
            {
                pt.x += iStemWidth;
            }    
            if (bMirrored && (ABS(pt.x - (iWidth - xStem)) <= 2))
            {
                pt.x = iWidth - xStem; // avoid rough edges, have a straight line
                
            }
            else if (!bMirrored && (ABS(pt.x - xStem) <= 2))
            {
                pt.x = xStem; // avoid rough edges, have a straight line
            }    
            *ppt++ = pt;
            if(bMirrored)
            {
                pt.x = iWidth - xStem;
            }
            else
            {
                pt.x = xStem;                
            }
            pt.y = yStem;
            *ppt = pt;

            rgnStem = CreatePolygonRgn(aptStemRgn, CSTEMPOINTS, ALTERNATE);
            if (rgnStem)
            {
                CombineRgn(rgn, rgn, rgnStem, RGN_OR);
                DeleteObject(rgnStem);
            }
        }
    }
    return rgn;
}

void NEAR PASCAL DoShowBubble(PToolTipsMgr pTtm)
{
    HFONT hFontPrev;
    RECT rc;
    int cxText, cyText;
    int xStem, yStem;
    LPTSTR lpstr;
    NMTTSHOWINFO si;
    
    DebugMsg(TF_TT, TEXT("Entering DoShowBubble"));
    
    lpstr = GetCurToolText(pTtm);

    if (pTtm->dwFlags & TRACKMODE) {
        
        if (!lpstr || !*lpstr) {
            PopBubble(pTtm);
            pTtm->dwFlags &= ~TRACKMODE;
            return;
        }
        
    } else {

        TTSetTimer(pTtm, TTT_POP);
        if( !lpstr || !*lpstr ) {

            ShowVirtualBubble(pTtm);
            return;
        }
        TTSetTimer(pTtm, TTT_AUTOPOP);
    }
    

    do {
        // get the size it will be
        TTGetTipSize(pTtm, pTtm->pCurTool, lpstr, &cxText, &cyText);
        TTGetTipPosition(pTtm, &rc, cxText, cyText, &xStem, &yStem);

#ifdef MAINWIN
        // IEUNIX : Mainwin Z-ordering problems.
        SetWindowPos(pTtm->ci.hwnd, HWND_TOPMOST, rc.left, rc.top,
                     rc.right-rc.left, rc.bottom-rc.top,
                     SWP_NOACTIVATE);
#else
        {
            UINT uFlags = SWP_NOACTIVATE | SWP_NOZORDER;

            if (pTtm->ci.style & TTS_BALLOON)
                uFlags |= SWP_HIDEWINDOW;
            SetWindowPos(pTtm->ci.hwnd, NULL, rc.left, rc.top,
                         rc.right-rc.left, rc.bottom-rc.top, uFlags);
        }
#endif

        // BUGBUG: chicago id was busted.  I *hope* no one relied on it...
        // bzzzz...  folks did.  we're stuck with it
        si.hdr.hwndFrom = pTtm->ci.hwnd;
        si.hdr.idFrom = pTtm->pCurTool->uId;
        si.hdr.code = TTN_SHOW;
        si.dwStyle = pTtm->ci.style;

        hFontPrev = pTtm->hFont;
        if (!SendNotifyEx(pTtm->pCurTool->hwnd, (HWND)-1,
                          TTN_SHOW, &si.hdr,
                          (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0)) {

            // Bring to top only if we are an unowned tooltip, since we
            // may have sunken below our tool in the Z-order.  Do this
            // only if unowned; if we are owned, then USER will make sure
            // we are above our owner.
            //
            // We must scrupulously avoid messing with our Z-order in the
            // owned case, because Office curiously creates a tooltip
            // owned by toplevel window 1, but attached to a tool on
            // toplevel window 2.  When you hover over window 2, the
            // tooltip from window 1 wants to appear.  If we brought
            // ourselves to the top, this would also bring window 1
            // to the top (because USER raises and lowers owned/owner
            // windows as a group).  Result:  Window 1 covers window 2.

            UINT uFlags = SWP_NOACTIVATE | SWP_NOSIZE;
            if (GetWindow(pTtm->ci.hwnd, GW_OWNER))
                uFlags |= SWP_NOZORDER;

            SetWindowPos(pTtm->ci.hwnd, HWND_TOP, rc.left, rc.top,
                         0, 0, uFlags);
        }
    
    } while (hFontPrev != pTtm->hFont);

    // create the balloon region if necessary
    // Note: Don't use si.dwStyle here, since other parts of comctl32
    // look at pTtm->ci.style to decide what to do
    if (pTtm->ci.style & TTS_BALLOON)
    {
        HRGN rgn;
        BOOL bMirrored = FALSE;
        if(pTtm->pCurTool)
        {
            bMirrored = (IS_WINDOW_RTL_MIRRORED(pTtm->pCurTool->hwnd) && (!(pTtm->ci.dwExStyle & RTL_MIRRORED_WINDOW)));
        }
        pTtm->fUnderStem = yStem >= rc.bottom-1;
        rgn = CreateBalloonRgn(bMirrored ? (rc.right - xStem) : (xStem - rc.left), yStem-rc.top, rc.right-rc.left, rc.bottom-rc.top, 
                               pTtm->iStemHeight, pTtm->fUnderStem, bMirrored);

        if (rgn && !SetWindowRgn(pTtm->ci.hwnd, rgn, FALSE))
            DeleteObject(rgn);
         // AnimateWindow does not support regions so we must do SetWindowPos    
        SetWindowPos(pTtm->ci.hwnd,HWND_TOP,0,0,0,0,SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE);
    }
    else
    {
        BOOL fAllowFade = !(si.dwStyle & TTS_NOFADE);
        BOOL fAllowAnimate = !(si.dwStyle & TTS_NOANIMATE);
        DWORD dwCurrentTime = (pTtm->dwLastDisplayTime == 0)? TIMEBETWEENANIMATE : GetTickCount();
        DWORD dwDelta = dwCurrentTime - pTtm->dwLastDisplayTime;


        // If we're under the minimum time between animates, then we don't animate
        if (dwDelta < TIMEBETWEENANIMATE)
            fAllowFade = fAllowAnimate = FALSE;

        CoolTooltipBubble(pTtm->ci.hwnd, &rc, fAllowFade, fAllowAnimate);

        pTtm->dwLastDisplayTime = GetTickCount();

        //
        //  HACK! for MetaStock 6.5.  They superclass the tooltips class and install
        //  their own class which takes over WM_PAINT completely.  Animation causes
        //  them to get confused because that causes us to receive a WM_PRINTCLIENT,
        //  which causes TTRender to send a TTN_NEEDTEXT, and they never expected
        //  to receive that notification at that time.
        //
        //  We used to show ourselves with an empty window region, then see if the
        //  WM_PAINT ever reached us.  Unfortunately, that roached Outlook.  So we
        //  just look at the flag afterwards.  This means that MetaStock's first
        //  tooltip will look bad, but the rest will be okay.
        //
        if (pTtm->ci.iVersion < 4 && !pTtm->fEverShown &&
            (si.dwStyle & (TTS_NOFADE | TTS_NOANIMATE)) == 0) {
            // Force a WM_PAINT message so we can check if we got it
            InvalidateRect(pTtm->ci.hwnd, NULL, TRUE);
            UpdateWindow(pTtm->ci.hwnd);
            if (!pTtm->fEverShown) {
                // Detected a hacky app.  Turn off animation.
                SetWindowBits(pTtm->ci.hwnd, GWL_STYLE, TTS_NOFADE | TTS_NOANIMATE,
                                                        TTS_NOFADE | TTS_NOANIMATE);
                pTtm->fEverShown = TRUE;        // don't make this check again
            }
        }
    }

    pTtm->dwFlags |= BUBBLEUP;
    RedrawWindow(pTtm->ci.hwnd, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW);
}

void NEAR PASCAL ShowBubbleForTool(PToolTipsMgr pTtm, PTOOLINFO pTool)
{
    DebugMsg(TF_TT, TEXT("ShowBubbleForTool"));
    // if there's a bubble up for a different tool, pop it.
    if ((pTool != pTtm->pCurTool) && (pTtm->dwFlags & BUBBLEUP)) {
        PopBubble(pTtm);
    }

    // if the bubble was for a different tool, or no bubble, show it
    if ((pTool != pTtm->pCurTool) || !(pTtm->dwFlags & (VIRTUALBUBBLEUP|BUBBLEUP))) {
        
        pTtm->pCurTool = pTool;
        DoShowBubble(pTtm);

    } else {
        DebugMsg(TF_TT, TEXT("ShowBubbleForTool not showinb bubble"));
    }
}

void NEAR PASCAL HandleRelayedMessage(PToolTipsMgr pTtm, HWND hwnd, 
        UINT message, WPARAM wParam, LPARAM lParam)
{
    int ht = HTERROR;

    if (pTtm->dwFlags & TRACKMODE) {
        // punt all messages if we're in track mode
        return;
    }
    
    if (pTtm->dwFlags & BUTTONISDOWN) {
        // verify that the button is down
        // this can happen if the tool didn't set capture so it didn't get the up message
        if (GetKeyState(VK_LBUTTON) >= 0 &&
            GetKeyState(VK_RBUTTON) >= 0 &&
            GetKeyState(VK_MBUTTON) >= 0)
            pTtm->dwFlags &= ~BUTTONISDOWN;
    }
    
    switch(message) {
    case WM_NCLBUTTONUP:
    case WM_NCRBUTTONUP:
    case WM_NCMBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
    case WM_LBUTTONUP:
        pTtm->dwFlags &= ~BUTTONISDOWN;
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCRBUTTONDOWN:
    case WM_NCMBUTTONDOWN:
    case WM_MBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        pTtm->dwFlags |= BUTTONISDOWN;
        ShowVirtualBubble(pTtm);
        break;

    case WM_NCMOUSEMOVE:
    {
        // convert to client coords
        POINT pt;
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(hwnd, &pt);
        lParam = MAKELONG(pt.x, pt.y);
        ht = (int) wParam;

        // Fall thru...
    }
    case WM_MOUSEMOVE: {

        PTOOLINFO pTool;
        // to prevent us from popping up when some
        // other app is active
        if(((!(pTtm->ci.style & TTS_ALWAYSTIP)) && !(ChildOfActiveWindow(hwnd))) ||
           !(pTtm->dwFlags & ACTIVE) ||
           (pTtm->dwFlags & BUTTONISDOWN))
        {
            break;
        }

        pTool = GetToolAtPoint(pTtm, hwnd, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), ht, FALSE);
        if(pTool) {
            int id;
            // show only if another is showing
            if (pTtm->dwFlags & (VIRTUALBUBBLEUP | BUBBLEUP)) {
                // call show if bubble is up to make sure we're showing
                // for the right tool
                if (pTool != pTtm->pCurTool) {

                    DebugMsg(TF_TT, TEXT("showing virtual bubble"));
                    PopBubble(pTtm);
                    pTtm->pCurTool = pTool;
                    ShowVirtualBubble(pTtm);
                    id = TTT_RESHOW;
                } else {
                    if (pTtm->idTimer == TTT_RESHOW) {
                        // if the timer is currently waiting to reshow,
                        // don't reset the timer on mouse moves
                        id = 0;
                    } else {
                        // if we're looking to pop the bubble,
                        // any mouse move within the same window
                        // should reset our timer.
                        id = TTT_POP;
                    }
                }

                if (pTtm->idtAutoPop)
                    TTSetTimer(pTtm, TTT_AUTOPOP);

            } else {
                pTtm->pCurTool = pTool;
                id = TTT_INITIAL;
            }

            DebugMsg(TF_TT, TEXT("MouseMove over pTool id = %d"), id);
            if (id)
                TTSetTimer(pTtm, id);

        } else {
            
            DebugMsg(TF_TT, TEXT("MouseMove over non-tool"));
            PopBubble(pTtm);
        }
        break;
        }
    }
}

void NEAR PASCAL TTUpdateTipText(PToolTipsMgr pTtm, LPTOOLINFO lpti)
{
    LPTOOLINFO lpTool;

    lpTool = FindTool(pTtm, lpti);
    if (lpTool) {
        lpTool->hinst = lpti->hinst;
        TTSetTipText(lpTool, lpti->lpszText);
        if (pTtm->dwFlags & TRACKMODE) {
            // if track mode is in effect and active, then
            // redisplay the bubble.
            if (pTtm->pCurTool)
                DoShowBubble(pTtm);
        } else
        if (lpTool == pTtm->pCurTool) {

            // set the current position to our saved position.
            // ToolHasMoved will return false for us if those this point
            // is no longer within pCurTool's area
            GetCursorPos(&pTtm->pt);
            if (!ToolHasMoved(pTtm)) {
                if (pTtm->dwFlags & ( VIRTUALBUBBLEUP | BUBBLEUP)) 
                    DoShowBubble(pTtm);
            } else {
                
                DebugMsg(TF_TT, TEXT("TTUpdateTipText popping bubble"));
                PopBubble(pTtm);
            }
        }
    }
}

void NEAR PASCAL TTSetFont(PToolTipsMgr pTtm, HFONT hFont, BOOL fInval)
{
    ToolTips_NewFont(pTtm, hFont);
    if (fInval)
    {
        // is a balloon up and is it in the track mode?
        if ((pTtm->dwFlags & ACTIVE) && pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRACK))
        {
            PTOOLINFO pCurTool = pTtm->pCurTool;
            
            PopBubble(pTtm); // sets pTtm->pCurTool to NULL
            ShowBubbleForTool(pTtm, pCurTool);
        }
        else
            InvalidateRect(pTtm->ci.hwnd, NULL, FALSE);
    }
}

void NEAR PASCAL TTSetDelayTime(PToolTipsMgr pTtm, WPARAM wParam, LPARAM lParam)
{
    int iDelayTime = GET_X_LPARAM(lParam);

    switch (wParam) 
    {
    case TTDT_INITIAL:
        pTtm->iDelayTime = iDelayTime;
        break;

    case TTDT_AUTOPOP:
        pTtm->iAutoPopTime = iDelayTime;
        break;

    case TTDT_RESHOW:
        pTtm->iReshowTime = iDelayTime;
        break;

    case TTDT_AUTOMATIC:
        if (iDelayTime > 0)
        {
            pTtm->iDelayTime = iDelayTime;
            pTtm->iReshowTime = pTtm->iDelayTime / 5;
            pTtm->iAutoPopTime = pTtm->iDelayTime * 10;
        }
        else
        {
            pTtm->iDelayTime = -1;
            pTtm->iReshowTime = -1;
            pTtm->iAutoPopTime = -1;
        }
        break;
    }
}

int NEAR PASCAL TTGetDelayTime(PToolTipsMgr pTtm, WPARAM wParam)
{
    switch (wParam) {

    case TTDT_AUTOMATIC:
    case TTDT_INITIAL:
        return (pTtm->iDelayTime < 0 ? GetDoubleClickTime() : pTtm->iDelayTime);

    case TTDT_AUTOPOP:
        return (pTtm->iAutoPopTime < 0 ? GetDoubleClickTime()*10 : pTtm->iAutoPopTime);

    case TTDT_RESHOW:
        return (pTtm->iReshowTime < 0 ? GetDoubleClickTime()/5 : pTtm->iReshowTime);

    default:
        return -1;
    }
}

#ifdef UNICODE
BOOL NEAR PASCAL CopyToolInfoA(PTOOLINFO pToolSrc, PTOOLINFOA lpTool, UINT uiCodePage)
{
    if (pToolSrc && lpTool) {
        if (lpTool->cbSize >= sizeof(TOOLINFOA) - sizeof(LPARAM)) {
            lpTool->uFlags = pToolSrc->uFlags;
            lpTool->hwnd = pToolSrc->hwnd;
            lpTool->uId = pToolSrc->uId;
            lpTool->rect = pToolSrc->rect;
            lpTool->hinst = pToolSrc->hinst;
            if ((pToolSrc->lpszText != LPSTR_TEXTCALLBACK) &&
                !IS_INTRESOURCE(pToolSrc->lpszText)) {

                if (lpTool->lpszText) {
                    WideCharToMultiByte (uiCodePage, 0,
                                                 pToolSrc->lpszText,
                                                 -1,
                                                 lpTool->lpszText,
                                                 80, NULL, NULL);
                }
            } 
            else 
                lpTool->lpszText = (LPSTR)pToolSrc->lpszText;
        }

        if (lpTool->cbSize > FIELD_OFFSET(TOOLINFOA, lParam))
            lpTool->lParam = pToolSrc->lParam;
        
        if (lpTool->cbSize > sizeof(TOOLINFOA))
            return FALSE;
            
        return TRUE;
    } 
    else
        return FALSE;
}
#endif

BOOL NEAR PASCAL CopyToolInfo(PTOOLINFO pToolSrc, PTOOLINFO lpTool)
{
    if (pToolSrc && lpTool && lpTool->cbSize <= sizeof(TOOLINFO)) {
        if (lpTool->cbSize >= sizeof(TOOLINFO) - sizeof(LPARAM)) {
            lpTool->uFlags = pToolSrc->uFlags;
            lpTool->hwnd = pToolSrc->hwnd;
            lpTool->uId = pToolSrc->uId;
            lpTool->rect = pToolSrc->rect;
            lpTool->hinst = pToolSrc->hinst;
            if ((pToolSrc->lpszText != LPSTR_TEXTCALLBACK) && !IS_INTRESOURCE(pToolSrc->lpszText)) 
            {
                if (lpTool->lpszText) 
                    lstrcpy(lpTool->lpszText, pToolSrc->lpszText);
            }
            else 
                lpTool->lpszText = pToolSrc->lpszText;
        }
        if (lpTool->cbSize > FIELD_OFFSET(TOOLINFO, lParam))
            lpTool->lParam = pToolSrc->lParam;
        
        if (lpTool->cbSize > sizeof(TOOLINFO))
            return FALSE;
    
        return TRUE;
    }
    else
        return FALSE;
}

PTOOLINFO TTToolAtMessagePos(PToolTipsMgr pTtm)
{
    PTOOLINFO pTool;
    HWND hwndPt;
    POINT pt;
    DWORD dwPos = GetMessagePos();
    //int ht;

    pt.x = GET_X_LPARAM(dwPos);
    pt.y = GET_Y_LPARAM(dwPos);
    hwndPt = TTWindowFromPoint(pTtm, &pt);
    //ht = SendMessage(hwndPt, WM_NCHITTEST, 0, MAKELONG(pt.x, pt.y));
    ScreenToClient(hwndPt, &pt);
    pTool = GetToolAtPoint(pTtm, hwndPt, pt.x, pt.y, HTERROR, TRUE);

    return pTool;
}

void TTCheckCursorPos(PToolTipsMgr pTtm)
{
    PTOOLINFO pTool;

    pTool = TTToolAtMessagePos(pTtm);
    if ((pTtm->pCurTool != pTool) || 
        ToolHasMoved(pTtm)) {
        PopBubble(pTtm);

        DebugMsg(TF_TT, TEXT("TTCheckCursorPos popping bubble"));
    }
}

void NEAR PASCAL TTHandleTimer(PToolTipsMgr pTtm, UINT_PTR id)
{
    PTOOLINFO pTool;
    
    // punt all timers in track mode
    if (pTtm->dwFlags & TRACKMODE)
        return;

    switch (id) {

    case TTT_AUTOPOP:
        TTCheckCursorPos(pTtm); 
        if (pTtm->pCurTool) {
            DebugMsg(TF_TT, TEXT("ToolTips: Auto popping"));
            ShowVirtualBubble(pTtm);
        }
        break;

    case TTT_POP:

        // this could be started up again by a slight mouse touch
        if (pTtm->dwFlags & VIRTUALBUBBLEUP) {
            KillTimer(pTtm->ci.hwnd, TTT_POP);
        }

        TTCheckCursorPos(pTtm); 
        break;
        
    case TTT_INITIAL:
        if(ToolHasMoved(pTtm)) {
            // this means the timer went off
            // without us getting a mouse move
            // which means they left our tools.
            PopBubble(pTtm);
            break;
        }

        // else fall through

    case TTT_RESHOW:

        pTool = TTToolAtMessagePos(pTtm);
        if (!pTool) {
            if (pTtm->pCurTool) 
                PopBubble(pTtm);
        } else if (pTtm->dwFlags & ACTIVE) {
            if (id == TTT_RESHOW) {
                // this will force a re-show
                pTtm->dwFlags &= ~(BUBBLEUP|VIRTUALBUBBLEUP);
            }
            ShowBubbleForTool(pTtm, pTool);
        }
        break;  
    }
}    

BOOL TTRender(PToolTipsMgr pTtm, HDC hdc)
{
    BOOL bRet = FALSE;
    RECT rc;
    LPTSTR lpszStr;

    if (pTtm->pCurTool &&
        (lpszStr = GetCurToolText(pTtm)) &&
        *lpszStr) {
        UINT uFlags;
        NMTTCUSTOMDRAW nm;
        UINT uDefDrawFlags = 0;
        BOOL bUseDrawText;
        LPRECT prcMargin = &pTtm->rcMargin;

        HBRUSH hbr;
        DWORD  dwCustomDraw;

        uFlags = 0;

#if defined(WINDOWS_ME)
        if ( (pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->ci.dwExStyle & WS_EX_RTLREADING) )
            uFlags |= ETO_RTLREADING;
#endif

        SelectObject(hdc, pTtm->hFont);
        GetClientRect(pTtm->ci.hwnd, &rc);
        SetTextColor(hdc, pTtm->clrTipText);

        /* If we support pre-Draw text then call the client allowing them to modify
         /  the item, and then render.  Otherwise just use ExTextOut */
        nm.nmcd.hdr.hwndFrom = pTtm->ci.hwnd;
        nm.nmcd.hdr.idFrom = pTtm->pCurTool->uId;
        nm.nmcd.hdr.code = NM_CUSTOMDRAW;
        nm.nmcd.hdc = hdc;
        nm.nmcd.dwDrawStage = CDDS_PREPAINT;

        // ADJUSTRECT!  Keep TTAdjustRect and TTGetTipPosition in sync.
        nm.nmcd.rc.left   = rc.left   + XTEXTOFFSET*g_cxBorder + prcMargin->left;
        nm.nmcd.rc.right  = rc.right  - XTEXTOFFSET*g_cxBorder - prcMargin->right;
        nm.nmcd.rc.top    = rc.top    + YTEXTOFFSET*g_cyBorder + prcMargin->top;
        nm.nmcd.rc.bottom = rc.bottom - YTEXTOFFSET*g_cyBorder - prcMargin->bottom;

        if (pTtm->ci.style & TTS_BALLOON)
        {
            InflateRect(&(nm.nmcd.rc), -XBALLOONOFFSET, -YBALLOONOFFSET);
            if (!pTtm->fUnderStem)
                OffsetRect(&(nm.nmcd.rc), 0, pTtm->iStemHeight);
        }

        if (pTtm->iMaxTipWidth == -1) 
            uDefDrawFlags = DT_SINGLELINE |DT_LEFT;
        else 
            uDefDrawFlags = DT_LEFT | DT_WORDBREAK | DT_EXPANDTABS | DT_EXTERNALLEADING;

        if (pTtm->ci.style & TTS_NOPREFIX)
            uDefDrawFlags |= DT_NOPREFIX;

#if defined(WINDOWS_ME)
        if ( (pTtm->pCurTool->uFlags & TTF_RTLREADING) || (pTtm->ci.dwExStyle & WS_EX_RTLREADING) )
            uDefDrawFlags |= DT_RTLREADING;
#endif
        //
        // Make it right aligned, if requested. [samera]
        //
        if (pTtm->pCurTool->uFlags & TTF_RIGHT)
            uDefDrawFlags |= DT_RIGHT;
 
        nm.uDrawFlags = uDefDrawFlags;

        dwCustomDraw = (DWORD)SendNotifyEx(pTtm->pCurTool->hwnd, (HWND) -1,
                     0, (NMHDR*) &nm,
                     (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
        // did the owner do custom draw? yes, we're done
        if (pTtm->ci.iVersion >= 5 && dwCustomDraw == CDRF_SKIPDEFAULT)
            return TRUE;

        bUseDrawText = (nm.uDrawFlags != uDefDrawFlags ||
                        !(uDefDrawFlags & DT_SINGLELINE) ||
                        (uDefDrawFlags & (DT_RTLREADING|DT_RIGHT)) ||
                        (pTtm->cchTipTitle != 0));

        if (pTtm->clrTipBk != GetNearestColor(hdc, pTtm->clrTipBk) ||
            bUseDrawText) 
        {
            // if this fails, it may be the a dither...
            // in which case, we can't set the bk color
            hbr = CreateSolidBrush(pTtm->clrTipBk);
            FillRect(hdc, &rc, hbr);
            DeleteObject(hbr);

            SetBkMode(hdc, TRANSPARENT);
            uFlags |= ETO_CLIPPED;
        } 
        else 
        {
            uFlags |= ETO_OPAQUE;
            SetBkColor(hdc, pTtm->clrTipBk);
        }

        if (bUseDrawText) 
        {
            // Account for off-by-one.  Something wierd about DrawText
            // clips the bottom-most pixelrow, so increase one more
            // into the margin space.

            // ADJUSTRECT!  Keep TTAdjustRect in sync.
            nm.nmcd.rc.bottom++;
            nm.nmcd.rc.right++;
            // if in balloon style the text is already indented so no need for inflate..
            if (pTtm->cchTipTitle > 0 && !(pTtm->ci.style & TTS_BALLOON))
                InflateRect(&nm.nmcd.rc, -XBALLOONOFFSET, -YBALLOONOFFSET);

            if (!TTRenderTitledTip(pTtm, hdc, FALSE, &nm.nmcd.rc, uDefDrawFlags))
                DrawText(hdc, lpszStr, lstrlen(lpszStr), &nm.nmcd.rc, nm.uDrawFlags);
        }
        else
        {
            // ADJUSTRECT!  Keep TTAdjustRect and TTGetTipPosition in sync.
            int x = XTEXTOFFSET*g_cxBorder + prcMargin->left;
            int y = YTEXTOFFSET*g_cyBorder + prcMargin->top;

            if (pTtm->ci.style & TTS_BALLOON)
            {
                HRGN rgn;
                
                x += XBALLOONOFFSET;
                y += YBALLOONOFFSET;
                InflateRect(&rc, -XBALLOONOFFSET, -YBALLOONOFFSET);
                if (!pTtm->fUnderStem)
                {
                    y += pTtm->iStemHeight;
                    OffsetRect(&rc, 0, pTtm->iStemHeight);
                }
                
                rgn = CreateRectRgn(1,1,2,2);
                if (rgn)
                {
                    int iRet = GetWindowRgn(pTtm->ci.hwnd, rgn);
                    if (iRet != ERROR)
                    {
                        // ExtTextOut only fills the rect specified and that
                        // only if uFlags & ETO_OPAQUE
                        HBRUSH hbr = CreateSolidBrush(pTtm->clrTipBk);
                        FillRgn(hdc, rgn, hbr);
                        DeleteObject(hbr);
                    }
                    DeleteObject(rgn);
                }
            }
            else if (pTtm->cchTipTitle > 0)
            {
                InflateRect(&rc, -XBALLOONOFFSET, -YBALLOONOFFSET);
            }

            if (!TTRenderTitledTip(pTtm, hdc, FALSE, &rc, uDefDrawFlags))
                ExtTextOut(hdc, x, y, uFlags, &rc, lpszStr, lstrlen(lpszStr), NULL);
        }

        if (pTtm->ci.style & TTS_BALLOON)
        {
            HRGN rgn = CreateRectRgn(1,1,2,2);

            if (rgn)
            {
                int iRet = GetWindowRgn(pTtm->ci.hwnd, rgn);
                if (iRet != ERROR)
                {
                    HBRUSH hbr = CreateSolidBrush(pTtm->clrTipText);
                    FrameRgn(hdc, rgn, hbr, 1, 1);
                    DeleteObject(hbr);
                }
                DeleteObject(rgn);
            }
        }

        // notify parent afterwards if they want us to
        if (!(dwCustomDraw & CDRF_SKIPDEFAULT) &&
            dwCustomDraw & CDRF_NOTIFYPOSTPAINT) {
            // Convert PREPAINT to POSTPAINT and ITEMPREPAINT to ITEMPOSTPAINT
            COMPILETIME_ASSERT(CDDS_POSTPAINT - CDDS_PREPAINT ==
                               CDDS_ITEMPOSTPAINT - CDDS_ITEMPREPAINT);
            nm.nmcd.dwDrawStage += CDDS_POSTPAINT - CDDS_PREPAINT;
            SendNotifyEx(pTtm->pCurTool->hwnd, (HWND) -1,
                         0, (NMHDR*) &nm,
                         (pTtm->pCurTool->uFlags & TTF_UNICODE) ? 1 : 0);
        }

        bRet = TRUE;
    }

    return bRet;
}

void TTOnPaint(PToolTipsMgr pTtm)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(pTtm->ci.hwnd, &ps);

    if (!TTRender(pTtm, hdc)) {
        DebugMsg(TF_TT, TEXT("TTOnPaint render failed popping bubble"));
        PopBubble(pTtm);
    }

    EndPaint(pTtm->ci.hwnd, &ps);
    pTtm->fEverShown = TRUE;                // See TTOnFirstShow
}

LRESULT WINAPI ToolTipsWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PTOOLINFO pTool;
    PTOOLINFO pToolSrc;
    PToolTipsMgr pTtm = GetWindowPtr(hwnd, 0);
    
    if (!pTtm && uMsg != WM_CREATE)
        goto DoDefault;

    switch(uMsg)
    {
    case TTM_ACTIVATE:
        if (wParam) {
            pTtm->dwFlags |= ACTIVE;
        } else {
            PopBubble(pTtm);
            pTtm->dwFlags &= ~(ACTIVE | TRACKMODE);
        }
        break;

    case TTM_SETDELAYTIME:
        TTSetDelayTime(pTtm, wParam, lParam);
        break;

    case TTM_GETDELAYTIME:
        return (LRESULT)(UINT)TTGetDelayTime(pTtm, wParam);
        
#ifdef UNICODE
    case TTM_ADDTOOLA:
        {
        LRESULT res;
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->ci.uiCodePage)) {
            return FALSE;
        }

        res = AddTool(pTtm, &ti);

        if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) {
            LocalFree (ti.lpszText);
        }

        return res;
        }
#endif

    case TTM_ADDTOOL:
        if (!lParam)
            return FALSE;

        return AddTool(pTtm, (LPTOOLINFO)lParam);

#ifdef UNICODE
    case TTM_DELTOOLA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage)) {
            break;
        }
        DeleteTool(pTtm, &ti);

        break;
        }
#endif
        
    case TTM_DELTOOL:
        if (!lParam)
            return FALSE;

        DeleteTool(pTtm, (LPTOOLINFO)lParam);
        break;

#ifdef UNICODE
    case TTM_NEWTOOLRECTA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage)) {
            break;
        }

        pTool = FindTool(pTtm, &ti);
        if(pTool) {
            pTool->rect = ((LPTOOLINFOA)lParam)->rect;
        }

        break;
        }
#endif
        
    case TTM_NEWTOOLRECT:
        if (!lParam)
            return FALSE;

        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        if(pTool) {
            pTool->rect = ((LPTOOLINFO)lParam)->rect;
        }

        break;

    case TTM_GETTOOLCOUNT:
        return pTtm->iNumTools;

#ifdef UNICODE
    case TTM_GETTOOLINFOA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage)) {
            return FALSE;
        }

        pToolSrc = FindTool(pTtm, &ti);

        return (LRESULT)(UINT)CopyToolInfoA(pToolSrc, (LPTOOLINFOA)lParam, pTtm->ci.uiCodePage);
        }

    case TTM_GETCURRENTTOOLA:
        if (lParam) 
            return (LRESULT)(UINT)CopyToolInfoA(pTtm->pCurTool, (LPTOOLINFOA)lParam, pTtm->ci.uiCodePage);
        else
            return BOOLFROMPTR(pTtm->pCurTool);

    case TTM_ENUMTOOLSA:
    {
        if (wParam < (UINT)pTtm->iNumTools) {
            pToolSrc = &pTtm->tools[wParam];
            return (LRESULT)(UINT)CopyToolInfoA(pToolSrc, (LPTOOLINFOA)lParam, pTtm->ci.uiCodePage);
        }
        return FALSE;
    }
#endif

    case TTM_GETTOOLINFO:
        if (!lParam)
            return FALSE;
        pToolSrc = FindTool(pTtm, (LPTOOLINFO)lParam);
        return (LRESULT)(UINT)CopyToolInfo(pToolSrc, (LPTOOLINFO)lParam);

    case TTM_GETCURRENTTOOL:
        if (lParam)
            return (LRESULT)(UINT)CopyToolInfo(pTtm->pCurTool, (LPTOOLINFO)lParam);
        else 
            return BOOLFROMPTR(pTtm->pCurTool);

    case TTM_ENUMTOOLS:
    {
        if (wParam < (UINT)pTtm->iNumTools) {
            pToolSrc = &pTtm->tools[wParam];
            return (LRESULT)(UINT)CopyToolInfo(pToolSrc, (LPTOOLINFO)lParam);
        }
        return FALSE;
    }

#ifdef UNICODE
    case TTM_SETTOOLINFOA:
        {
        TOOLINFOW ti;

        if (!lParam) {
            return FALSE;
        }

        if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->ci.uiCodePage)) {
            return FALSE;
        }

        pTool = FindTool(pTtm, &ti);
        if (pTool) {
            TTSetTipText(pTool, NULL);
            hmemcpy(pTool, &ti, ti.cbSize);
            pTool->lpszText = NULL;
            TTSetTipText(pTool, ti.lpszText);

            if (pTool == pTtm->pCurTool) {
                DoShowBubble(pTtm);
            }
        }


        if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) {
            LocalFree (ti.lpszText);
        }

        break;
        }
#endif

    case TTM_SETTOOLINFO:
        if (!lParam)
            return FALSE;
        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        if (pTool) {
            TTSetTipText(pTool, NULL);
            hmemcpy(pTool,(LPTOOLINFO)lParam, ((LPTOOLINFO)lParam)->cbSize); 
            pTool->lpszText = NULL;
            TTSetTipText(pTool, ((LPTOOLINFO)lParam)->lpszText);
            
            if (pTool == pTtm->pCurTool) {
                DoShowBubble(pTtm);
            }
        }
        break;

#ifdef UNICODE
    case TTM_HITTESTA:
#define lphitinfoA ((LPHITTESTINFOA)lParam)
        if (!lParam)
            return FALSE;
        pTool = GetToolAtPoint(pTtm, lphitinfoA->hwnd, lphitinfoA->pt.x, lphitinfoA->pt.y, HTERROR, TRUE);
        if (pTool) {
            ThunkToolInfoWtoA(pTool, (LPTOOLINFOA)(&(lphitinfoA->ti)), pTtm->ci.uiCodePage);
            return TRUE;
        }
        return FALSE;
#endif

    case TTM_HITTEST:
#define lphitinfo ((LPHITTESTINFO)lParam)
        if (!lParam)
            return FALSE;
        pTool = GetToolAtPoint(pTtm, lphitinfo->hwnd, lphitinfo->pt.x, lphitinfo->pt.y, HTERROR, TRUE);
        if (pTool) {
            
            // for back compat...  if thesize isn't set right, we only give
            // them the win95 amount.
            if (lphitinfo->ti.cbSize != sizeof(TTTOOLINFO)) {
                *((WIN95TTTOOLINFO*)&lphitinfo->ti) = *(WIN95TTTOOLINFO*)pTool;
            } else {
                lphitinfo->ti = *pTool;
            }
            return TRUE;
        }
        return FALSE;

#ifdef UNICODE
    case TTM_GETTEXTA: {
        LPWSTR lpszTemp;
        TOOLINFOW ti;

        if (!lParam || !((LPTOOLINFOA)lParam)->lpszText)
            return FALSE;

        if (!ThunkToolInfoAtoW((LPTOOLINFOA)lParam, &ti, FALSE, pTtm->ci.uiCodePage))
            break;
                       
        ((LPTOOLINFOA)lParam)->lpszText[0] = 0;
        pTool = FindTool(pTtm, &ti);
        lpszTemp = GetToolText(pTtm, pTool);
        if (lpszTemp) 
            WideCharToMultiByte (pTtm->ci.uiCodePage,
                                 0,
                                 lpszTemp,
                                 -1,
                                 (((LPTOOLINFOA)lParam)->lpszText),
                                 80, NULL, NULL);
        
        break;
    }
#endif

    case TTM_GETTEXT: {
        LPTSTR lpszTemp;
        if (!lParam || !pTtm || !((LPTOOLINFO)lParam)->lpszText)
            return FALSE;

        ((LPTOOLINFO)lParam)->lpszText[0] = 0;
        pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
        lpszTemp = GetToolText(pTtm, pTool);
        if (lpszTemp) 
            lstrcpy((((LPTOOLINFO)lParam)->lpszText), lpszTemp);
    }
        break;


    case WM_GETTEXTLENGTH:
    case WM_GETTEXT:
    {
        LPTSTR lpszStr;
#ifdef UNICODE_WIN9x
        char *pszDest = uMsg == WM_GETTEXT ? (char *)lParam : NULL;
#else
        TCHAR *pszDest = uMsg == WM_GETTEXT ? (TCHAR *)lParam : NULL;
#endif
        LRESULT lres;

        // Pre-terminate the string just in case
        if (pszDest && wParam)
            pszDest[0] = 0;

        if (pTtm && (lpszStr = GetCurToolText(pTtm))) {
#ifdef UNICODE_WIN9x
            LPSTR pStringA = ProduceAFromW(pTtm->ci.uiCodePage, lpszStr);
            if (pStringA) {
                if (pszDest && wParam) {
                    lstrcpynA(pszDest, pStringA, (int) wParam);
                    lres = lstrlenA(pszDest);
                } else {
                    lres = lstrlenA(pStringA);
                }
                FreeProducedString(pStringA);
            } else {                // out of memory
                lres = 0;
            }
#else
            if (pszDest && wParam) {
                StrCpyN(pszDest, lpszStr, (int) wParam);
                lres = lstrlen(pszDest);
            } else {
                lres = lstrlen(lpszStr);
            }
#endif
        } else {                    // No current tool
            lres = 0;
        }
        return lres;
    }

    case TTM_RELAYEVENT:
#define lpmsg ((LPMSG)lParam)
        if (!lParam)
            return FALSE;
        HandleRelayedMessage(pTtm, lpmsg->hwnd, lpmsg->message, lpmsg->wParam,
                lpmsg->lParam);
#undef lpmsg
        break;

        // this is here for people to subclass and fake out what we
        // think the window from point is.  this facilitates "transparent" windows
        case TTM_WINDOWFROMPOINT: {
            HWND hwndPt = WindowFromPoint(*((POINT FAR *)lParam));
            DebugMsg(TF_TT, TEXT("TTM_WINDOWFROMPOINT %x"), hwndPt);
            return (LRESULT)hwndPt;
        }

#ifdef UNICODE
        case TTM_UPDATETIPTEXTA:
            {
            TOOLINFOW ti;

            if (lParam) {
                if (!ThunkToolInfoAtoW ((LPTOOLINFOA)lParam, &ti, TRUE, pTtm->ci.uiCodePage)) {
                    break;
                }
                TTUpdateTipText(pTtm, &ti);

                if ((ti.uFlags & TTF_MEMALLOCED) && (ti.lpszText != LPSTR_TEXTCALLBACK)) {
                    LocalFree (ti.lpszText);
                }
            }
            break;
            }
#endif

    case TTM_UPDATETIPTEXT:
        if (lParam)
            TTUpdateTipText(pTtm, (LPTOOLINFO)lParam);
        break;

    /* Pop the current tooltip if there is one displayed, ensuring that the virtual
    /  bubble is also discarded. */

    case TTM_POP:
    {
        if ( pTtm ->dwFlags & BUBBLEUP )
            PopBubble( pTtm );

        pTtm ->dwFlags &= ~VIRTUALBUBBLEUP;

        break;
    }


    case TTM_TRACKPOSITION:
        if ((GET_X_LPARAM(lParam) != pTtm->ptTrack.x) || 
            (GET_Y_LPARAM(lParam) != pTtm->ptTrack.y)) 
        {
            pTtm->ptTrack.x = GET_X_LPARAM(lParam); 
            pTtm->ptTrack.y = GET_Y_LPARAM(lParam);
        
            // if track mode is in effect, update the position
            if ((pTtm->dwFlags & TRACKMODE) && 
                pTtm->pCurTool) {
                DoShowBubble(pTtm);
            }
        }
        break;
        
    case TTM_UPDATE:
        if (!lParam ||
            lParam == (LPARAM)pTtm->pCurTool) {
            DoShowBubble(pTtm);
        }
        break;

    case TTM_TRACKACTIVATE:
        if (pTtm->dwFlags & ACTIVE) {
            if (wParam && lParam)
                wParam = TRACKMODE;
            else 
                wParam = 0;
            
            if ((wParam ^ pTtm->dwFlags) & TRACKMODE) {
                // if the trackmode changes by this..
                PopBubble(pTtm);

                pTtm->dwFlags ^= TRACKMODE;
                if (wParam) {

                    // turning on track mode
                    pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
                    if (pTool) {
                        // only if the tool is found
                        ShowBubbleForTool(pTtm, pTool);
                    }
                }
            }
        }
        return TRUE;
        
    case TTM_SETTIPBKCOLOR:
        if (pTtm->clrTipBk != (COLORREF)wParam) {
            pTtm->clrTipBk = (COLORREF)wParam;
            InvalidateRgn(pTtm->ci.hwnd,NULL,TRUE);
        }
        pTtm->fBkColorSet = TRUE;
        break;
        
    case TTM_GETTIPBKCOLOR:
        return (LRESULT)(UINT)pTtm->clrTipBk;
        
    case TTM_SETTIPTEXTCOLOR:
        if (pTtm->clrTipText != (COLORREF)wParam) {
            InvalidateRgn(pTtm->ci.hwnd,NULL,TRUE);
            pTtm->clrTipText = (COLORREF)wParam;
        }
        pTtm->fTextColorSet = TRUE;
        break;
        
    case TTM_GETTIPTEXTCOLOR:
        return (LRESULT)(UINT)pTtm->clrTipText;
        
    case TTM_SETMAXTIPWIDTH:
    {
        int iOld = pTtm->iMaxTipWidth;
        pTtm->iMaxTipWidth = (int)lParam;
        return iOld;
    }
        
    case TTM_GETMAXTIPWIDTH:
        return pTtm->iMaxTipWidth;
        
    case TTM_SETMARGIN:
        if (lParam)
            pTtm->rcMargin = *(LPRECT)lParam;
        break;

    case TTM_GETMARGIN:
        if (lParam)
            *(LPRECT)lParam = pTtm->rcMargin;
        break;

    case TTM_GETBUBBLESIZE:
        if (lParam)
        {
            pTool = FindTool(pTtm, (LPTOOLINFO)lParam);
            if (pTool)
            {
                LPTSTR lpstr = GetToolText(pTtm, pTool);
                int    cxText, cyText, cxMargin, cyMargin, iBubbleWidth, iBubbleHeight;

                TTGetTipSize(pTtm, pTool, lpstr, &cxText, &cyText);

                cxMargin = pTtm->rcMargin.left + pTtm->rcMargin.right;
                cyMargin = pTtm->rcMargin.top + pTtm->rcMargin.bottom;
                iBubbleWidth =  2*XTEXTOFFSET * g_cxBorder + cxText + cxMargin;
                iBubbleHeight = 2*YTEXTOFFSET * g_cyBorder + cyText + cyMargin;

                if (pTtm->ci.style & TTS_BALLOON)
                {
                    iBubbleWidth += 2*XBALLOONOFFSET;
                    iBubbleHeight += 2*YBALLOONOFFSET;
                }   
                return MAKELONG(iBubbleWidth, iBubbleHeight);
            }
        }
        break;

    case TTM_ADJUSTRECT:
        return TTAdjustRect(pTtm, BOOLFROMPTR(wParam), (LPRECT)lParam);

#ifdef UNICODE
    case TTM_SETTITLEA:
        {
            TCHAR szTitle[MAX_TIP_CHARACTERS];
            pTtm->uTitleBitmap = (UINT)wParam;
            Str_Set(&pTtm->lpTipTitle, NULL);
            pTtm->iTitleHeight = 0;

            TTCreateTitleBitmaps(pTtm);

            if (lParam)
            {
                pTtm->cchTipTitle = lstrlenA((LPCSTR)lParam);
                if (pTtm->cchTipTitle < ARRAYSIZE(szTitle))
                {
                    ConvertAToWN(pTtm->ci.uiCodePage, szTitle, ARRAYSIZE(szTitle),
                        (LPCSTR)lParam, -1);
                    Str_Set(&pTtm->lpTipTitle, szTitle);
                    return TRUE;
                }
            }
            pTtm->cchTipTitle = 0;
            return FALSE;
        }
        break;
#endif
    case TTM_SETTITLE:
        {
            pTtm->uTitleBitmap = (UINT)wParam;
            Str_Set(&pTtm->lpTipTitle, NULL);
            pTtm->iTitleHeight = 0;

            TTCreateTitleBitmaps(pTtm);

            if (lParam)
            {
                pTtm->cchTipTitle = lstrlen((LPCTSTR)lParam);
                if (pTtm->cchTipTitle < MAX_TIP_CHARACTERS)
                {
                    Str_Set(&pTtm->lpTipTitle, (LPCTSTR)lParam);
                    return TRUE;
                }
            }
            pTtm->cchTipTitle = 0;
            return FALSE;
        }
        break;


        /* uMsgs that REALLY came for me. */
    case WM_CREATE:
        {
            DWORD dwBits, dwValue;
            
            CCCreateWindow();
            pTtm = ToolTipsMgrCreate(hwnd, (LPCREATESTRUCT)lParam);
            if (!pTtm)
                return -1;
            
            SetWindowPtr(hwnd, 0, pTtm);
            SetWindowBits(hwnd, GWL_EXSTYLE, WS_EX_TOOLWINDOW, WS_EX_TOOLWINDOW);

            dwBits = WS_CHILD | WS_POPUP | WS_BORDER | WS_DLGFRAME;
            dwValue = WS_POPUP | WS_BORDER;
            // we don't want border for balloon style
            if (pTtm->ci.style & TTS_BALLOON)
                dwValue &= ~WS_BORDER;
            SetWindowBits(hwnd, GWL_STYLE, dwBits, dwValue);
            
            TTSetFont(pTtm, 0, FALSE);
            break;
        }

    case WM_TIMER:  
        TTHandleTimer(pTtm, wParam);
        break;

        
    case WM_NCHITTEST:
        // we should not return HTTRANSPARENT here because then we don't receive the mouse events
        // and we cannot forward them down to our parent. but because of the backcompat we keep doing
        // it unless we are using comctl32 v5 or greater
        //
        // If we are inside TTWindowFromPoint, then respect transparency
        // even on v5 clients.
        //
        // Otherwise, your tooltips flicker because the tip appears,
        // then WM_NCHITTEST says "not over the tool any more" (because
        // it's over the tooltip), so the bubble pops, and then the tip
        // reappears, etc.
        if (pTtm && (pTtm->ci.iVersion < 5 || pTtm->fInWindowFromPoint) &&
            pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
        {
            return HTTRANSPARENT;
        } 
        goto DoDefault;
        
    case WM_MOUSEMOVE:
        // the cursor moved onto the tips window.
        if (!(pTtm->dwFlags & TRACKMODE) && pTtm->pCurTool && !(pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
            PopBubble(pTtm);
        // fall through

    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
    case WM_MBUTTONDOWN:
        if (pTtm->pCurTool && (pTtm->pCurTool->uFlags & TTF_TRANSPARENT))
        {
            POINT pt;
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);
            
            MapWindowPoints(pTtm->ci.hwnd, pTtm->pCurTool->hwnd, &pt, 1);
            SendMessage(pTtm->pCurTool->hwnd, uMsg, wParam, MAKELPARAM(pt.x, pt.y));
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        if (pTtm) {
            if (!pTtm->fBkColorSet)
                pTtm->clrTipBk = g_clrInfoBk;
            if (!pTtm->fTextColorSet)
                pTtm->clrTipText = g_clrInfoText;
        }
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        if (pTtm->fMyFont)
            TTSetFont(pTtm, 0, FALSE);
        break;

    case WM_PAINT: 
        TTOnPaint(pTtm);
        break;

    case WM_SETFONT:
        TTSetFont(pTtm, (HFONT)wParam, (BOOL)lParam);
        return(TRUE);

    case WM_GETFONT:
        if (pTtm) {
           return((LRESULT)pTtm->hFont);
        }
        break;

    case WM_NOTIFYFORMAT:
        if (lParam == NF_QUERY) {
#ifdef UNICODE
            return NFR_UNICODE;
#else
            return NFR_ANSI;
#endif
        } else if (lParam == NF_REQUERY) {
            int i;

            for(i = 0 ; i < pTtm->iNumTools; i++) {
                pTool = &pTtm->tools[i];

                if (SendMessage (pTool->hwnd, WM_NOTIFYFORMAT,
                                 (WPARAM)hwnd, NF_QUERY) == NFR_UNICODE) {
                    pTool->uFlags |= TTF_UNICODE;
                } else {
                    pTool->uFlags &= ~TTF_UNICODE;
                }
            }

            return CIHandleNotifyFormat(&pTtm->ci, lParam);
        }
        return 0;

    case WM_ERASEBKGND:
        break;
        
    case WM_STYLECHANGED:
        if ((wParam == GWL_STYLE) && pTtm) 
        {
            DWORD dwNewStyle = ((LPSTYLESTRUCT)lParam)->styleNew;
            if ( pTtm->ci.style & TTS_BALLOON &&    // If the old style was a balloon,
                !(dwNewStyle & TTS_BALLOON))        // And the new style is not a balloon,
            {
                // Then we need to unset the region.
                SetWindowRgn(pTtm->ci.hwnd, NULL, FALSE);
            }

            pTtm->ci.style = ((LPSTYLESTRUCT)lParam)->styleNew;
        }
        break;
        
    case WM_DESTROY: 
        {
            CCDestroyWindow();
            if (pTtm->tools) 
            {
                int i;
            
                // free the tools
                for(i = 0 ; i < pTtm->iNumTools; i++) 
                {
                    TTBeforeFreeTool(pTtm, &pTtm->tools[i]);
                }
            
                LocalFree((HANDLE)pTtm->tools);
            }
        
            TTSetFont(pTtm, (HFONT)1, FALSE); // delete font if we made one.

            Str_Set(&pTtm->lpTipText, NULL);
            Str_Set(&pTtm->lpTipTitle, NULL);

            if (pTtm->himlTitleBitmaps)
                ImageList_Destroy(pTtm->himlTitleBitmaps);
        
            LocalFree((HANDLE)pTtm);
            SetWindowPtr(hwnd, 0, 0);
        }
        break;

    case WM_PRINTCLIENT:
        TTRender(pTtm, (HDC)wParam);
        break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_TOOLTIPS;
        goto DoDefault;

    default:
    {
        LRESULT lres;
        if (CCWndProc(&pTtm->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }
DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

#ifdef UNICODE
//========================================================================
//
// Ansi <=> Unicode Thunk Routines
//
//========================================================================


//*************************************************************
//
//  ThunkToolInfoAtoW()
//
//  Purpose:    Thunks a TOOLINFOA structure to a TOOLINFOW
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//*************************************************************

BOOL ThunkToolInfoAtoW (LPTOOLINFOA lpTiA, LPTOOLINFOW lpTiW, BOOL bThunkText, UINT uiCodePage)
{

    //
    // Copy the constants to the new structure.
    //

    lpTiW->uFlags      = lpTiA->uFlags;
    lpTiW->hwnd        = lpTiA->hwnd;
    lpTiW->uId         = lpTiA->uId;

    lpTiW->rect.left   = lpTiA->rect.left;
    lpTiW->rect.top    = lpTiA->rect.top;
    lpTiW->rect.right  = lpTiA->rect.right;
    lpTiW->rect.bottom = lpTiA->rect.bottom;

    lpTiW->hinst       = lpTiA->hinst;

    //
    //  Set the size properly and optionally copy the new fields if the
    //  structure is large enough.
    //
    if (lpTiA->cbSize <= TTTOOLINFOA_V1_SIZE) {
        lpTiW->cbSize  = TTTOOLINFOW_V1_SIZE;
    } else {
        lpTiW->cbSize  = sizeof(TOOLINFOW);
        lpTiW->lParam  = lpTiA->lParam;
    }

    if (bThunkText) {
        //
        // Thunk the string to the new structure.
        // Special case LPSTR_TEXTCALLBACK.
        //

        if (lpTiA->lpszText == LPSTR_TEXTCALLBACKA) {
            lpTiW->lpszText = LPSTR_TEXTCALLBACKW;

        } else if (!IS_INTRESOURCE(lpTiA->lpszText)) {

            DWORD dwBufSize;
            int iResult;

            dwBufSize = lstrlenA(lpTiA->lpszText) + 1;
            lpTiW->lpszText = LocalAlloc (LPTR, dwBufSize * sizeof(WCHAR));

            if (!lpTiW->lpszText) {
                return FALSE;
            }

            iResult = MultiByteToWideChar (uiCodePage, 0, lpTiA->lpszText, -1,
                                           lpTiW->lpszText, dwBufSize);

            //
            // If iResult is 0, and GetLastError returns an error code,
            // then MultiByteToWideChar failed.
            //

            if (!iResult) {
                if (GetLastError()) {
                    return FALSE;
                }
            }

            lpTiW->uFlags |= TTF_MEMALLOCED;

        } else {
            lpTiW->lpszText = (LPWSTR)lpTiA->lpszText;
        }

    }
    return TRUE;
}

//*************************************************************
//
//  ThunkToolInfoWtoA()
//
//  Purpose:    Thunks a TOOLINFOW structure to a TOOLINFOA
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//*************************************************************

BOOL ThunkToolInfoWtoA (LPTOOLINFOW lpTiW, LPTOOLINFOA lpTiA, UINT uiCodePage)
{
    int iResult = 1;

    //
    // Copy the constants to the new structure.
    //

    lpTiA->uFlags      = lpTiW->uFlags;
    lpTiA->hwnd        = lpTiW->hwnd;
    lpTiA->uId         = lpTiW->uId;

    lpTiA->rect.left   = lpTiW->rect.left;
    lpTiA->rect.top    = lpTiW->rect.top;
    lpTiA->rect.right  = lpTiW->rect.right;
    lpTiA->rect.bottom = lpTiW->rect.bottom;

    lpTiA->hinst       = lpTiW->hinst;

    //
    //  Set the size properly and optionally copy the new fields if the
    //  structure is large enough.
    //
    if (lpTiW->cbSize <= TTTOOLINFOW_V1_SIZE) {
        lpTiA->cbSize  = TTTOOLINFOA_V1_SIZE;
    } else {
        lpTiA->cbSize  = sizeof(TOOLINFOA);
        lpTiA->lParam  = lpTiA->lParam;
    }

    //
    // Thunk the string to the new structure.
    // Special case LPSTR_TEXTCALLBACK.
    //

    if (lpTiW->lpszText == LPSTR_TEXTCALLBACKW) {
        lpTiA->lpszText = LPSTR_TEXTCALLBACKA;

    } else if (!IS_INTRESOURCE(lpTiW->lpszText)) {

        //
        // It is assumed that lpTiA->lpszText is already setup to
        // a valid buffer, and that buffer is 80 characters.
        // 80 characters is defined in the TOOLTIPTEXT structure.
        //

        iResult = WideCharToMultiByte (uiCodePage, 0, lpTiW->lpszText, -1,
                                       lpTiA->lpszText, 80, NULL, NULL);
    } else {
        lpTiA->lpszText = (LPSTR)lpTiW->lpszText;
    }

    //
    // If iResult is 0, and GetLastError returns an error code,
    // then WideCharToMultiByte failed.
    //

    if (!iResult) {
        if (GetLastError()) {
            return FALSE;
        }
    }

    return TRUE;
}


//*************************************************************
//
//  ThunkToolTipTextAtoW()
//
//  Purpose:    Thunks a TOOLTIPTEXTA structure to a TOOLTIPTEXTW
//              structure.
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//*************************************************************

BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage)
{
    int iResult;


    if (!lpTttA || !lpTttW)
        return FALSE;

    //
    // Thunk the NMHDR structure.
    //
    lpTttW->hdr.hwndFrom = lpTttA->hdr.hwndFrom;
    lpTttW->hdr.idFrom   = lpTttA->hdr.idFrom;
    lpTttW->hdr.code     = TTN_NEEDTEXTW;

    lpTttW->hinst  = lpTttA->hinst;
    lpTttW->uFlags = lpTttA->uFlags;
    lpTttW->lParam = lpTttA->lParam;

    //
    // Thunk the string to the new structure.
    // Special case LPSTR_TEXTCALLBACK.
    //

    if (lpTttA->lpszText == LPSTR_TEXTCALLBACKA) {
        lpTttW->lpszText = LPSTR_TEXTCALLBACKW;

    } else if (!IS_INTRESOURCE(lpTttA->lpszText)) {

        //
        //  Transfer the lpszText into the lpTttW...
        //
        //  First see if it fits into the buffer, and optimistically assume
        //  it will.
        //
        lpTttW->lpszText = lpTttW->szText;
        iResult = MultiByteToWideChar (uiCodePage, 0, lpTttA->lpszText, -1,
                                       lpTttW->szText, ARRAYSIZE(lpTttW->szText));
        if (!iResult) {
            //
            //  Didn't fit into the small buffer; must alloc our own.
            //
            lpTttW->lpszText = ProduceWFromA(uiCodePage, lpTttA->lpszText);
            lpTttW->uFlags |= TTF_MEMALLOCED;
        }

    } else {
        lpTttW->lpszText = (LPWSTR)lpTttA->lpszText;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\treeview.h ===
#include "listview.h"   // for some helper routines and border metrics
#define __IOleControl_INTERFACE_DEFINED__       // There is a conflich with the IOleControl's def of CONTROLINFO
#include "shlobj.h"

//
//  Definitions missing from commctrl.h
//
typedef const TVITEMEX *LPCTVITEMEX;

//
//  Private definitions
//
#define MAGIC_MININDENT 5
#define MAGIC_INDENT    3
#define MAGIC_HORZLINE  5

// flags for TV_DrawItem
#define TVDI_NOIMAGE    0x0001  // don't draw image
#define TVDI_NOTREE     0x0002  // don't draw indent, lines, +/-
#define TVDI_TRANSTEXT  0x0004  // draw text transparently in black
#define TVDI_ERASE      0x0008  // erase while drawing
#define TVDI_GRAYTEXT   0x0010  // text is gray (disabled item)
#define TVDI_GRAYCTL    0x0020  // text and background is gray (disabled control)
#define TVDI_FORCEIMAGE 0x0040  // Always draw image
#define TVDI_NOBK       0x0080

// Internal flags for TV_SelectItem
#define TVC_INTERNAL   0x1000

typedef struct _TREE {
    CONTROLINFO ci;

    // Flags
    BITBOOL        fHorz:1;        // horizontal scrollbar present
    BITBOOL        fVert:1;        // vertical scrollbar present
    BITBOOL        fFocus:1;       // currently has focus
    BITBOOL        fNameEditPending:1;  // Is a name edit pending?
    BITBOOL        fRedraw:1;      // should redraw?
    BITBOOL        fScrollWait:1;  // are we waiting for a dblclk to not scroll?
    BITBOOL        fCreatedFont:1; // we created our font
    BITBOOL        fNoDismissEdit:1; // don't dismiss in-place edit control
    BITBOOL        fIndentSet:1;    // is the parent managing the indent size?
    BITBOOL        fTrackSet:1;    // have we set a track event?
    BITBOOL        fPlaceTooltip:1; // should we do the placement of tooltip over the text?
    BITBOOL        fCyItemSet:1;    // the the parent set our item height?
    BITBOOL        fInsertAfter:1; // insert mark should be after htiInsert instead of before
    BITBOOL        fRestoreOldDrop:1; // hOldDrop needs to be restored to hDropTarget

    // Handles
    HTREEITEM   hRoot;          // tree root item
    HTREEITEM   hCaret;         // item with focus caret
    HTREEITEM   hDropTarget;    // item which is the drop target
    HTREEITEM   hOldDrop;       // item which used to be the drop target
    HTREEITEM   htiEdit;        // The item that is being edited.
    HTREEITEM   hHot;           // the currently hottracked item
    HTREEITEM   hToolTip;       // the current item set in tooltips
    HTREEITEM   htiInsert;      // item that is relative to the insert mark
    HTREEITEM   htiSearch;      // item active in most recent incremental search
    HTREEITEM   htiDrag;        // item that's being dragged.
    HDPA        hdpaWatch;      // array of PTVWATCHEDITEMs - items being watched
    HIMAGELIST  hImageList;     // image list
    HIMAGELIST  himlState;      // state image list

    HCURSOR hCurHot; // the cursor when we're over a hot item

    int         iPuntChar;      // number of wm_char's to punt
    int         cxState;
    int         cyState;

    UINT        uDBCSChar;      // DBCS character for incremental search

    HBRUSH      hbrBk;          // background brush
    HFONT       hFont;          // tree font
    HFONT       hFontHot;       // underlined for hot tracking
    HFONT       hFontBold;      // bold tree font
    HFONT       hFontBoldHot;       // underlined for hot tracking
    HBITMAP     hStartBmp;      // initial DC mono bitmap
    HBITMAP     hBmp;           // indent bitmaps in hdcBits
    HDC         hdcBits;        // HDC for drawing indent bitmaps
    HTREEITEM   hItemPainting;  // the guy we are currently painting
    HANDLE      hheap;          // heap for allocs for win32

    POINT       ptCapture;      // Point where the mouse was capture

    COLORREF    clrText;
    COLORREF    clrBk; 
    COLORREF    clrim;          // insert mark color.
    COLORREF    clrLine;        // line color

    // Dimensions
    SHORT       cxImage;        // image width
    SHORT       cyImage;        // image height
    SHORT       cyText;         // text height
    SHORT       cyItem;         // item height
    SHORT       cxBorder;   // horizontal item border
    SHORT       cyBorder;   // vert item border
    SHORT       cxIndent;       // indent width
    SHORT       cxWnd;          // window width
    SHORT       cyWnd;          // window height

    // Scroll Positioners
    WORD        cxMax;          // width of longest item
    WORD        cFullVisible;   // number of items that CAN fully fit in window
    SHORT       xPos;           // horizontal scrolled position
    UINT        cShowing;       // number of showing (non-collapsed) items
    UINT        cItems;         // total number of items
    HTREEITEM   hTop;           // first visible item (i.e., at top of client rect)
    UINT        uMaxScrollTime; // the maximum smooth scroll timing

    // stuff for edit in place
    HWND        hwndEdit;       // Edit window for name editing.
    WNDPROC     pfnEditWndProc; // edit field subclass proc

    //tooltip stuff
    HWND        hwndToolTips;
    LPTSTR      pszTip;         // store current tooltip/infotip string.
#ifdef UNICODE
    LPSTR       pszTipA;        // store current ANSI tooltip/infotip string.
#endif

    //incremental search stuff
    ISEARCHINFO is;

} TREE, NEAR *PTREE;

#define TV_StateIndex(pitem) ((int)(((DWORD)((pitem)->state) >> 12) & 0xF))

#define KIDS_COMPUTE            0    // use hKids to determine if a node has children
#define KIDS_FORCE_YES          1    // force a node to have kids (ignore hKids)
#define KIDS_FORCE_NO           2    // force a node to not have kids (ignore hKids)
#define KIDS_CALLBACK           3    // callback to see if a node has kids
#define KIDS_INVALID            4    // all values this and above are bogus

#define MAXLABELTEXT            MAX_PATH

// BUGBUG: OINK OINK

//
//  Note that there are multiple senses of "visible" going on.
//
//  TREE.hTop tracks visibility in the sense of "will it be painted?"
//
//  TREEITEM.iShownIndex tracks visibility in the sense of "not collapsed".
//  You can be off the screen but as long as your parent is expanded
//  you get an iShownIndex.
//
//

typedef struct _TREEITEM {
    HTREEITEM hParent;          // allows us to walk back out of the tree
    HTREEITEM hNext;            // next sibling
    HTREEITEM hKids;            // first child
    LPTSTR    lpstr;            // item text, can be LPSTR_TEXTCALLBACK
    LPARAM lParam;              // item data

    WORD      state;            // TVIS_ state flags
    WORD      iImage;           // normal state image at iImage
    WORD      iSelectedImage;   // selected state image
    WORD      iWidth;           // cached: width of text area (for hit test, drawing)
    WORD      iShownIndex;      // cached: -1 if not visible, otherwise nth visible item
                                // invisible = parent is invisible or collapsed
    BYTE      iLevel;           // cached: level of item (indent)
    BYTE      fKids;            // KIDS_ values
    WORD      iIntegral;        // integral height
    WORD      wSignature;       // for parameter validation, put at end of struct

} TREEITEM;

//
//  The signature is intentionally not ASCII characters, so it's
//  harder to run into by mistake.  I choose a value greater than
//  0x8000 so it can't be the high word of a pointer.
//
#define TV_SIG      0xABCD

#define TV_MarkAsDead(hti)      ((hti)->wSignature = 0)

#define ITEM_VISIBLE(hti) ((hti)->iShownIndex != (WORD)-1)

// get the parent, avoiding the hidden root node
#define VISIBLE_PARENT(hItem) (!(hItem)->iLevel ? NULL : (hItem)->hParent)

// REVIEW: make this a function if the optimizer doesn't do well with this
#define FULL_WIDTH(pTree, hItem)  (ITEM_OFFSET(pTree,hItem) + hItem->iWidth)
int FAR PASCAL ITEM_OFFSET(PTREE pTree, HTREEITEM hItem);

#define VTI_NULLOK      1
BOOL ValidateTreeItem(HTREEITEM hItem, UINT flags);

#ifdef DEBUG
#define DBG_ValidateTreeItem(hItem, flags) ValidateTreeItem(hItem, flags)
#else
#define DBG_ValidateTreeItem(hItem, flags)
#endif

//
//  TVWATCHEDITEM
//
//  Structure that tracks items being watched.
//
//  See TV_StartWatch for more information, and TV_DoExpandRecurse
//  for an example.
//
//  The hti field is a bit odd.
//
//  if fStale == FALSE, then hti is the item being watched.
//  if fStale == TRUE , then hti is the item *after* the item being watched.
//
//  We keep this strange semantic for fStale==TRUE so that TV_NextWatchItem
//  can successfully step to the item after a deleted item.  (Normally,
//  trying to do anything with a deleted item will fault.)
//

typedef struct TVWATCHEDITEM {
    HTREEITEM   hti;                    // current item
    BOOL        fStale;                 // has the original item been deleted?
} TVWATCHEDITEM, *PTVWATCHEDITEM;

BOOL TV_StartWatch(PTREE pTree, PTVWATCHEDITEM pwi, HTREEITEM htiStart);
BOOL TV_EndWatch(PTREE pTree, PTVWATCHEDITEM pwi);
#define TV_GetWatchItem(pTree, pwi) ((pwi)->hti)
#define TV_RestartWatch(pTree, pwi, htiStart) \
                        ((pwi)->hti = (htiStart), (pwi)->fStale = FALSE)
#define TV_IsWatchStale(pTree, pwi) ((pwi)->fStale)
#define TV_IsWatchValid(pTree, pwi) (!(pwi)->fStale)

//
//  TV_NextWatchItem - Enumerate the item after the watched item.
//                     This works even if the watched item was deleted.
//
#define TV_NextWatchItem(pTree, pwi) \
    ((pwi)->fStale || ((pwi)->hti = (pwi)->hti->hNext)), \
     (pwi)->fStale = FALSE

// in TVSCROLL.C
BOOL      NEAR  TV_ScrollBarsAfterAdd       (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollBarsAfterRemove    (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollBarsAfterExpand    (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollBarsAfterCollapse  (PTREE, HTREEITEM);
void      NEAR  TV_ScrollBarsAfterResize    (PTREE, HTREEITEM, int, UINT);
BOOL      NEAR  TV_ScrollBarsAfterSetWidth  (PTREE, HTREEITEM);
BOOL      NEAR  TV_HorzScroll               (PTREE, UINT, UINT);
BOOL      NEAR  TV_VertScroll               (PTREE, UINT, UINT);
BOOL      NEAR  TV_SetLeft                  (PTREE, int);
#define TV_SetTopItem(pTree, i) TV_SmoothSetTopItem(pTree, i, 0)
BOOL      NEAR  TV_SmoothSetTopItem               (PTREE, UINT, UINT);
BOOL      NEAR  TV_CalcScrollBars           (PTREE);
BOOL      NEAR  TV_ScrollIntoView           (PTREE, HTREEITEM);
BOOL      NEAR  TV_ScrollVertIntoView       (PTREE, HTREEITEM);
HTREEITEM NEAR  TV_GetShownIndexItem        (HTREEITEM, UINT);
UINT      NEAR  TV_ScrollBelow              (PTREE, HTREEITEM, BOOL, BOOL);
BOOL      NEAR  TV_SortChildren(PTREE, HTREEITEM, BOOL);
BOOL      NEAR  TV_SortChildrenCB(PTREE, LPTV_SORTCB, BOOL);
void      NEAR  TV_ComputeItemWidth(PTREE pTree, HTREEITEM hItem, HDC hdc);

// in TVPAINT.C
void       NEAR  TV_GetBackgroundBrush       (PTREE pTree, HDC hdc);
void       NEAR  TV_UpdateTreeWindow         (PTREE, BOOL);
void       NEAR  TV_ChangeColors             (PTREE);
void       NEAR  TV_CreateIndentBmps         (PTREE);
void       NEAR  TV_Paint                    (PTREE, HDC);
HIMAGELIST NEAR  TV_CreateDragImage          (PTREE pTree, HTREEITEM hItem);
BOOL       NEAR  TV_ShouldItemDrawBlue       (PTREE pTree, TVITEMEX *ti, UINT flags);
LRESULT    NEAR  TV_GenerateDragImage        (PTREE ptree, SHDRAGIMAGE* pshdi);

BOOL TV_GetInsertMarkRect(PTREE pTree, LPRECT prc);

// in TVMEM.C

#define TVDI_NORMAL             0x0000  // TV_DeleteItem flags
#define TVDI_NONOTIFY           0x0001
#define TVDI_CHILDRENONLY       0x0002
#define TVDI_NOSELCHANGE        0x0004

BOOL      NEAR  TV_DeleteItem(PTREE, HTREEITEM, UINT);
HTREEITEM NEAR  TV_InsertItem(PTREE pTree, LPTV_INSERTSTRUCT lpis);
void      NEAR  TV_DestroyTree(PTREE);
LRESULT   NEAR  TV_OnCreate(HWND, LPCREATESTRUCT);


#ifdef UNICODE
HTREEITEM NEAR  TV_InsertItemA(PTREE pTree, LPTV_INSERTSTRUCTA lpis);
#endif


// in TREEVIEW.C
BOOL      NEAR TV_GetItemRect(PTREE, HTREEITEM, LPRECT, BOOL);
BOOL      NEAR TV_Expand(PTREE pTree, WPARAM wCode, TREEITEM FAR * hItem, BOOL fNotify);
HTREEITEM NEAR TV_GetNextItem(PTREE, HTREEITEM, WPARAM);
void      NEAR TV_GetItem(PTREE pTree, HTREEITEM hItem, UINT mask, LPTVITEMEX lpItem);
void      TV_PopBubble(PTREE pTree);

// Flags for TV_SelectItem
#define TVSIF_NOTIFY            0x0001
#define TVSIF_UPDATENOW         0x0002
#define TVSIF_NOSINGLEEXPAND    0x0004

BOOL      NEAR TV_SelectItem(PTREE, WPARAM, HTREEITEM, UINT, UINT);
BOOL      NEAR TV_SendChange(PTREE, HTREEITEM, int, UINT, UINT, UINT, int, int);
HTREEITEM NEAR TV_GetNextVisItem(HTREEITEM);
HTREEITEM NEAR TV_GetPrevItem(HTREEITEM);
HTREEITEM NEAR TV_GetPrevVisItem(HTREEITEM);
void      NEAR TV_CalcShownItems(PTREE, HTREEITEM hItem);
void      NEAR TV_OnSetFont(PTREE, HFONT, BOOL);
BOOL      NEAR TV_SizeWnd(PTREE, UINT, UINT);
void      NEAR TV_InvalidateItem(PTREE, HTREEITEM, UINT uFlags);
VOID NEAR PASCAL TV_CreateBoldFont(PTREE pTree);
BOOL TV_SetInsertMark(PTREE pTree, HTREEITEM hItem, BOOL fAfter);

LRESULT CALLBACK _export TV_EditWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK _export TV_WndProc(HWND, UINT, WPARAM, LPARAM);
BOOL FAR                 TV_Init(HINSTANCE hinst);
void FAR                 TV_Terminate(BOOL fSystemExit);

LRESULT   NEAR  TV_Timer                    (PTREE pTree, UINT uTimerId);
HWND      NEAR  TV_OnEditLabel              (PTREE pTree, HTREEITEM hItem);
void      NEAR  TV_SetEditSize              (PTREE pTree);
BOOL      NEAR  TV_DismissEdit              (PTREE pTree, BOOL fCancel);
void      NEAR  TV_CancelPendingEdit        (PTREE pTree);
int       NEAR  TV_UpdateShownIndexes       (PTREE pTree, HTREEITEM hWalk);


void NEAR TV_UnsubclassToolTips(PTREE pTree);
LRESULT WINAPI TV_SubClassWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
void NEAR TV_SubclassToolTips(PTREE pTree);
BOOL TV_UpdateToolTip(PTREE pTree);
BOOL TV_SetToolTipTarget(PTREE pTree, HTREEITEM hItem);
void TV_OnSetBkColor(PTREE pTree, COLORREF clr);
void TV_InitCheckBoxes(PTREE pTree);

#define TVMP_CALCSCROLLBARS (TV_FIRST + 0x1000)

// Fake customdraw.  See comment block in tvscroll.c

typedef struct TVFAKEDRAW {
    NMTVCUSTOMDRAW nmcd;
    PTREE pTree;
    HFONT hfontPrev;
    DWORD dwCustomPrev;
    DWORD dwCustomItem;
} TVFAKEDRAW, *PTVFAKEDRAW;

void TreeView_BeginFakeCustomDraw(PTREE pTree, PTVFAKEDRAW ptvfd);
DWORD TreeView_BeginFakeItemDraw(PTVFAKEDRAW plvfd, HTREEITEM hitem);
void TreeView_EndFakeItemDraw(PTVFAKEDRAW ptvfd);
void TreeView_EndFakeCustomDraw(PTVFAKEDRAW ptvfd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\treeview.c ===
#include "ctlspriv.h"
#include "treeview.h"
#include "listview.h"

// BUGBUG -- penwin.h is messed up; define local stuff for now
#define HN_BEGINDIALOG                  40              // Lens/EditText/garbage detection dialog is about
                                    // to come up on this hedit/bedit
#define HN_ENDDIALOG                       41           // Lens/EditText/garbage detection dialog has
                                    // just been destroyed

//---------------------------------------------------------
#define IDT_SCROLLWAIT 43

//-----------------------
// ToolTip stuff...
//
#define REPEATTIME      SendMessage(pTree->hwndToolTips,TTM_GETDELAYTIME,(WPARAM)TTDT_RESHOW, 0)
#define CHECKFOCUSTIME  (REPEATTIME)
#define IDT_TOOLTIPWAIT   2
#define IDT_FOCUSCHANGE   3
// in tooltips.c
BOOL ChildOfActiveWindow(HWND hwnd);
void TV_HandleStateIconClick(PTREE pTree, HTREEITEM hItem);

HWND TV_EditLabel(PTREE pTree, HTREEITEM hItem, LPTSTR pszInitial);
void TV_CancelEditTimer(PTREE pTree);
BOOL TV_SetItem(PTREE pTree, LPCTVITEMEX ptvi);
void TV_DeleteHotFonts(PTREE pTree);
BOOL TV_IsShowing(HTREEITEM hItem);

LRESULT TV_OnScroll(PTREE ptv, LPNMHDR pnm);

#define TVBD_FROMWHEEL      0x0001
#define TVBD_WHEELFORWARD   0x0002
#define TVBD_WHEELBACK      0x0004

BOOL ValidateTreeItem(TREEITEM FAR * hItem, UINT flags)
{
    BOOL fValid = TRUE;

    /*
     *  Check the values to make sure the new Win64-compatible values
     *  are consistent with the old Win32 values.
     */
    COMPILETIME_ASSERT(
           (DWORD)(ULONG_PTR)TVI_ROOT  == 0xFFFF0000 &&
           (DWORD)(ULONG_PTR)TVI_FIRST == 0xFFFF0001 &&
           (DWORD)(ULONG_PTR)TVI_LAST  == 0xFFFF0002 &&
           (DWORD)(ULONG_PTR)TVI_SORT  == 0xFFFF0003);

    if (hItem) {
        if (HIWORD64(hItem) == HIWORD64(TVI_ROOT)) {
            switch (LOWORD(hItem)) {
//#pragma warning(disable:4309)
            case LOWORD(TVI_ROOT):
            case LOWORD(TVI_FIRST):
            case LOWORD(TVI_LAST):
            case LOWORD(TVI_SORT):
//#pragma warning(default:4309)
                break;

            default:
                AssertMsg(FALSE, TEXT("ValidateTreeItem() Invalid special item"));
                fValid = FALSE;
                break;
            }
        } else {
            __try {
                // Use "volatile" to force memory access at start of struct
                *(volatile LPVOID *)hItem;
                fValid = hItem->wSignature == TV_SIG;
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                fValid = FALSE;
            } __endexcept
        }

    } else if (!flags) {            // The only flag is VTI_NULLOK
        DebugMsg(DM_ERROR, TEXT("ValidateTreeItem(): NULL HTREEITEM"));
        fValid = FALSE;
    }

    return fValid;
}

// ----------------------------------------------------------------------------
//
//  Initialize TreeView on library entry -- register SysTreeView class
//
// ----------------------------------------------------------------------------

#pragma code_seg(CODESEG_INIT)

BOOL FAR TV_Init(HINSTANCE hinst)
{
    WNDCLASS wc;

    if (!GetClassInfo(hinst, c_szTreeViewClass, &wc)) {
#ifndef WIN32
        //
        // Use stab WndProc to avoid loading segment on init.
        //
        LRESULT CALLBACK _TV_WndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
        wc.lpfnWndProc     = _TV_WndProc;
#else
        wc.lpfnWndProc     = TV_WndProc;
#endif
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hIcon           = NULL;
        wc.lpszMenuName    = NULL;
        wc.hInstance       = hinst;
        wc.lpszClassName   = c_szTreeViewClass;
        wc.hbrBackground   = NULL;
        wc.style           = CS_DBLCLKS | CS_GLOBALCLASS;
        wc.cbWndExtra      = sizeof(PTREE);
        wc.cbClsExtra      = 0;

        return RegisterClass(&wc);
    }

    return TRUE;
}
#pragma code_seg()


// ----------------------------------------------------------------------------
//
// If the tooltip bubble is up, then pop it.
//
// ----------------------------------------------------------------------------

void TV_PopBubble(PTREE pTree)
{
    if (pTree->hwndToolTips && pTree->hToolTip)
    {
        pTree->hToolTip = NULL;
        SendMessage(pTree->hwndToolTips, TTM_POP, 0L, 0L);
    }
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_BEGINDRAG or TVN_BEGINRDRAG notification with information in the ptDrag and
//  itemNew fields of an NM_TREEVIEW structure
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SendBeginDrag(PTREE pTree, int code, TREEITEM FAR * hItem, int x, int y)
{
    NM_TREEVIEW nm;
        
    TV_PopBubble(pTree);            // dismiss the infotip if we start to drag

    nm.itemNew.hItem = hItem;
    nm.itemNew.state = hItem->state;
    nm.itemNew.lParam = hItem->lParam;
    nm.itemNew.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);
    nm.itemOld.mask = 0;
    nm.ptDrag.x = x;
    nm.ptDrag.y = y;

    return (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_ITEMEXPANDING or TVN_ITEMEXPANDED notification with information
//  in the action and itemNew fields of an NM_TREEVIEW structure
//
//  Returns FALSE to allow processing to continue, or TRUE to stop.
//
//  If the hItem is destroyed by the callback, then we always return TRUE.
//
//  Note that the application cannot stop a TVN_ITEMEXPANDED, so the only
//  way a TVN_ITEMEXPANDED can return "Stop" is if the item got destroyed.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SendItemExpand(PTREE pTree, int code, TREEITEM FAR * hItem, WPARAM action)
{
    NM_TREEVIEW nm;
    TVWATCHEDITEM wi;
    BOOL fResult;
    BOOL fWatched;

    ASSERT(code == TVN_ITEMEXPANDING || code == TVN_ITEMEXPANDED);

    nm.itemNew.mask = 0;
    nm.itemNew.hItem = hItem;
    if (hItem == TVI_ROOT)
        hItem = pTree->hRoot;
    nm.itemNew.state = hItem->state;
    nm.itemNew.lParam = hItem->lParam;
    nm.itemNew.iImage = hItem->iImage;
    nm.itemNew.iSelectedImage = hItem->iSelectedImage;
    switch(hItem->fKids) {
        case KIDS_CALLBACK:
        case KIDS_FORCE_YES:
            nm.itemNew.cChildren = 1;
            nm.itemNew.mask = TVIF_CHILDREN;
            break;
        case KIDS_FORCE_NO:
            nm.itemNew.cChildren = 0;
            nm.itemNew.mask = TVIF_CHILDREN;
            break;
    }
    nm.itemNew.mask |= (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE);
    nm.itemOld.mask = 0;

    nm.action = (UINT)(action & TVE_ACTIONMASK);

    //
    //  Some apps will delete the item while it is being expanded, since
    //  during expansion, they will realize, "Hey, the thing represented
    //  by this item no longer exists, I'd better delete it."  (E.g,.
    //  Explorer.)  So keep an eye on the item so we don't fault when
    //  this happens.
    //

    // If we can't start a watch, then tough, just send the notification
    // the unsafe way.
    fWatched = TV_StartWatch(pTree, &wi, hItem);

    fResult = (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);

    // The app return code from TVN_ITEMEXPANDED is ignored.
    // You can't stop a TVN_ITEMEXPANDED; it's already happened.
    if (code == TVN_ITEMEXPANDED)
        fResult = FALSE;                // Continue processing

    if (fWatched) {
        if (!TV_IsWatchValid(pTree, &wi))
            fResult = TRUE;             // Oh no!  Stop!

        TV_EndWatch(pTree, &wi);
    }

    return fResult;
}


// ----------------------------------------------------------------------------
//
//  Sends a TVN_SELCHANGING or TVN_SELCHANGED notification with information in
//  the itemOld and itemNew fields of an NM_TREEVIEW structure
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SendSelChange(PTREE pTree, int code, TREEITEM FAR * hOldItem, TREEITEM FAR * hNewItem, UINT action)
{
    NM_TREEVIEW nm;

    nm.action = action;

    nm.itemNew.hItem = hNewItem;
    nm.itemNew.state = hNewItem ? hNewItem->state : 0;
    nm.itemNew.lParam = hNewItem ? hNewItem->lParam : 0;
    nm.itemNew.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);

    nm.itemOld.hItem = hOldItem;
    nm.itemOld.state = hOldItem ? hOldItem->state : 0;
    nm.itemOld.lParam = hOldItem ? hOldItem->lParam : 0;
    nm.itemOld.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM);

    return (BOOL)CCSendNotify(&pTree->ci, code, &nm.hdr);
}
// ----------------------------------------------------------------------------
//
//  Returns the first visible item above the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetPrevVisItem(TREEITEM FAR * hItem)
{
    TREEITEM FAR * hParent = hItem->hParent;
    TREEITEM FAR * hWalk;

    DBG_ValidateTreeItem(hItem, 0);

    if (hParent->hKids == hItem)
        return VISIBLE_PARENT(hItem);

    for (hWalk = hParent->hKids; hWalk->hNext != hItem; hWalk = hWalk->hNext);

checkKids:
    if (hWalk->hKids && (hWalk->state & TVIS_EXPANDED))
    {
        for (hWalk = hWalk->hKids; hWalk->hNext; hWalk = hWalk->hNext);

        goto checkKids;
    }
    return(hWalk);
}


// ----------------------------------------------------------------------------
//
//  Returns the first visible item below the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetNextVisItem(TREEITEM FAR * hItem)
{
    DBG_ValidateTreeItem(hItem, 0);

    if (hItem->hKids && (hItem->state & TVIS_EXPANDED))
        return hItem->hKids;

checkNext:
    if (hItem->hNext)
        return(hItem->hNext);

    hItem = hItem->hParent;
    if (hItem)
        goto checkNext;

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Determine what part of what item is at the given (x,y) location in the
//  tree's client area.  If the location is outside the client area, NULL is
//  returned with the TVHT_TOLEFT, TVHT_TORIGHT, TVHT_ABOVE, and/or TVHT_BELOW
//  flags set in the wHitCode as appropriate.  If the location is below the
//  last item, NULL is returned with wHitCode set to TVHT_NOWHERE.  Otherwise,
//  the item is returned with wHitCode set to either TVHT_ONITEMINDENT,
//  TVHT_ONITEMBUTTON, TVHT_ONITEMICON, TVHT_ONITEMLABEL, or TVHT_ONITEMRIGHT
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_CheckHit(PTREE pTree, int x, int y, UINT FAR *wHitCode)
{
    TREEITEM FAR * hItem = pTree->hTop;
    int cxState;

    TVITEMEX sItem;

    *wHitCode = 0;

    if (x < 0)
        *wHitCode |= TVHT_TOLEFT;
    else if (x > (int) pTree->cxWnd)
        *wHitCode |= TVHT_TORIGHT;

    if (y < 0)
        *wHitCode |= TVHT_ABOVE;
    else if (y > (int) pTree->cyWnd)
        *wHitCode |= TVHT_BELOW;

    if (*wHitCode)
        return NULL;

    {
        int index = y / pTree->cyItem;

        while (hItem && index >= hItem->iIntegral) {
            index -= hItem->iIntegral;
            hItem = TV_GetNextVisItem(hItem);
        }
    }

    if (!hItem)
    {
        *wHitCode = TVHT_NOWHERE;
        return NULL;
    }

    x -= (pTree->cxBorder + (hItem->iLevel * pTree->cxIndent));
    x += pTree->xPos;

    if ((pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)) &&
        (pTree->ci.style &TVS_LINESATROOT))
    {
        // Subtract some more to make up for the pluses at the root
        x -= pTree->cxIndent;
    }

    TV_GetItem(pTree, hItem, TVIF_CHILDREN, &sItem);
    cxState = TV_StateIndex(&sItem) ? pTree->cxState : 0;
    if (x <= (int) (hItem->iWidth + pTree->cxImage + cxState))
    {

        if (x >= 0) {
            if (pTree->himlState &&  (x < cxState)) {
                *wHitCode = TVHT_ONITEMSTATEICON;
            } else if (pTree->hImageList && (x < (int) pTree->cxImage + cxState)) {
                *wHitCode = TVHT_ONITEMICON;
            } else {
                *wHitCode = TVHT_ONITEMLABEL;
            }
        } else if ((x >= -pTree->cxIndent) && sItem.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
            *wHitCode = TVHT_ONITEMBUTTON;
        else
            *wHitCode = TVHT_ONITEMINDENT;
    }
    else
        *wHitCode = TVHT_ONITEMRIGHT;

    return hItem;
}

//  This is tricky because CheckForDragBegin yields and the app may have
//  destroyed the item we are thinking about dragging
//
//  To give the app some feedback, we give the hItem the drop highlight
//  if it isn't already the caret.  This also allows us to check if the
//  item got deleted behind our back - TV_DeleteItemRecurse makes sure
//  that deleted items are never the hCaret or hDropTarget.
//
//  After TV_CheckForDragBegin, the caller must call TV_FinishCheckDrag
//  to clean up the UI changes that TV_CheckForDragBegin temporarily
//  performed.
//
BOOL TV_CheckForDragBegin(PTREE pTree, HTREEITEM hItem, int x, int y)
{
    BOOL fDrag;

    //
    //  If the item is not the caret, then make it the (temporary)
    //  drop target so the user gets some feedback.
    //
    //  BUGBUG raymondc - If hItem == pTree->hCaret, it still might not
    //  be visible if the control doesn't yet have focus and the treeview
    //  is not marked showselalways.  Maybe we should just always set
    //  hItem to DROPHILITE.
    //
    if (hItem == pTree->hCaret)
    {
        pTree->hOldDrop = NULL;
        pTree->fRestoreOldDrop = FALSE;
    }
    else
    {
        pTree->hOldDrop = pTree->hDropTarget;
        pTree->fRestoreOldDrop = TRUE;
        TV_SelectItem(pTree, TVGN_DROPHILITE, hItem, 0, TVC_BYMOUSE);
        ASSERT(hItem == pTree->hDropTarget);
    }

    //
    //  We are dragging the hItem if CheckForDragBegin says okay,
    //  and TV_DeleteItemRecurse didn't wipe us out.
    //
    fDrag = CheckForDragBegin(pTree->ci.hwnd, x, y) &&
           (hItem == pTree->hDropTarget || hItem == pTree->hCaret);

    return fDrag;
}

void TV_FinishCheckDrag(PTREE pTree)
{
    //
    //  Clean up our temporary UI changes that happened when we started
    //  dragging.
    //
    if (pTree->fRestoreOldDrop)
    {
        HTREEITEM hOldDrop = pTree->hOldDrop;
        pTree->fRestoreOldDrop = FALSE;
        pTree->hOldDrop = NULL;
        TV_SelectItem(pTree, TVGN_DROPHILITE, hOldDrop, 0, TVC_BYMOUSE);
    }
}

void NEAR TV_SendRButtonDown(PTREE pTree, int x, int y)
{
    BOOL fRet = FALSE;
    UINT wHitCode;
    TREEITEM FAR * hItem = TV_CheckHit(pTree, x, y, &wHitCode);
    HWND hwnd = pTree->ci.hwnd;

    if (!TV_DismissEdit(pTree, FALSE))   // end any previous editing (accept it)
        return;     // Something happened such that we should not process button down

    //
    // Need to see if the user is going to start a drag operation
    //

    GetMessagePosClient(pTree->ci.hwnd, &pTree->ptCapture);

    if (TV_CheckForDragBegin(pTree, hItem, x, y))
    {
        // let them start dragging
        if (hItem)
        {
            pTree->htiDrag = hItem;
            TV_SendBeginDrag(pTree, TVN_BEGINRDRAG, hItem, x, y);
        }
    }
    else if (!IsWindow(hwnd))
    {
        return;             // bail!
    }
    else
    {
        SetFocus(pTree->ci.hwnd);  // Activate this window like listview...
        fRet = !CCSendNotify(&pTree->ci, NM_RCLICK, NULL);
    }

    // Don't finish the CheckForDragBegin until after the NM_RCLICK
    // because apps want to display the context menu while the
    // temporary drag UI is still active.
    TV_FinishCheckDrag(pTree);

    if (fRet)
        SendMessage(pTree->ci.hwndParent, WM_CONTEXTMENU, (WPARAM)pTree->ci.hwnd, GetMessagePos());
}


// ----------------------------------------------------------------------------
//
//  If the given item is visible in the client area, the rectangle that
//  surrounds that item is invalidated
//
// ----------------------------------------------------------------------------

void NEAR TV_InvalidateItem(PTREE pTree, TREEITEM FAR * hItem, UINT fRedraw)
{
    RECT rc;

    if (hItem && pTree->fRedraw && TV_GetItemRect(pTree, hItem, &rc, FALSE))
    {
        RedrawWindow(pTree->ci.hwnd, &rc, NULL, fRedraw);
    }
}

//
//  Given an item, compute where the text of this item ends up being painted.
//  Basically, stare at TV_DrawItem and dutifully reproduce all the code that
//  messes with the x-coordinate.
//
int FAR PASCAL ITEM_OFFSET(PTREE pTree, HTREEITEM hItem)
{
    int x = pTree->cxBorder + (hItem->iLevel * pTree->cxIndent);

    // state image
    // BUGBUG -- doesn't handle TVCDRF_NOIMAGES - whose idea was that?
    if (pTree->himlState && TV_StateIndex(hItem))
        x += pTree->cxState;

    // image
    if (pTree->hImageList) {
        // even if not drawing image, draw text in right place
        x += pTree->cxImage;
    }
    
    // "plus" at the front of the tree
    if ((pTree->ci.style & TVS_LINESATROOT) &&
        (pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)))
        x += pTree->cxIndent;


    return x;
}

// ----------------------------------------------------------------------------
//
//  If the given item is visible in the client area, the rectangle that
//  surrounds that item is filled into lprc
//
//  Returns TRUE if the item is shown, FALSE otherwise
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_GetItemRect(PTREE pTree, TREEITEM FAR * hItem, LPRECT lprc, BOOL bItemRect)
{
    UINT iOffset;

    if (!hItem)
        return FALSE;

    DBG_ValidateTreeItem(hItem, 0);

    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    iOffset = hItem->iShownIndex - pTree->hTop->iShownIndex;

    if (bItemRect) {
        // Calculate where X position should start...
        lprc->left = -pTree->xPos + ITEM_OFFSET(pTree, hItem);
        lprc->right = lprc->left + hItem->iWidth;
    } else {
        lprc->left = 0;
        lprc->right = pTree->cxWnd;
    }

    lprc->top = iOffset * pTree->cyItem;
    lprc->bottom = lprc->top + (pTree->cyItem * hItem->iIntegral) ;

    return TRUE;
}

void NEAR TV_OnSetRedraw(PTREE pTree, BOOL fRedraw)
{
    pTree->fRedraw = TRUE && fRedraw;
    if (pTree->fRedraw)
    {
        // This use to only refresh the items from hTop down, this is bad as if items are inserted
        // before the visible point within the tree then we would fail!
        if ( pTree->hRoot )
            pTree->cShowing = TV_UpdateShownIndexes(pTree,pTree->hRoot);

        //  Must force recalculation of all tree items to get the right cxMax.
        TV_ScrollBarsAfterSetWidth(pTree, NULL);
        InvalidateRect(pTree->ci.hwnd, NULL, TRUE); //REVIEW: could be smarter
    }
}

//  Treeview item watching implementation
//
//  You need to "watch" an item any time you hold onto its HTREEITEM
//  and then yield control to the application.  If you didn't watch
//  the item, then if the app deletes the item, you end up with a
//  stale HTREEITEM pointer and fault.
//
//  To begin watching an item, call TV_StartWatch with the item you
//  want to start watching.  When finished watching, call TV_EndWatch.
//
//  In between, you can call TV_IsWatchStale() which tells you if the
//  item has been deleted behind your back and you shouldn't use it.
//  Alternatively, use TV_IsWatchValid() which says if it's okay.
//
//  Additional bonus behavior for enumeration:  If the watched item
//  is deleted, we cache the hNext item so that you can step to the
//  item after the one that got deleted.  Note that this works even
//  if the hNext item gets deleted before you get a chance to look,
//  because we just move the cached item to the hNext's hNext.
//
//  Sample usage for watching:
//
//  TVWATCHEDITEM wi;
//  if (TV_StartWatch(pTree, &wi, htiStartHere)) {
//      FunctionThatYields();
//      if (TV_IsWatchValid(pTree, &wi)) {
//          KeepUsing(htiStartHere);
//      } else {
//          // item was deleted while we yielded; stop using it
//      }
//      TV_EndWatch(pTree, &wi);
//  }
//
//  Sample usage for enumerating:
//
//  TVWATCHEDITEM wi;
//  if (TV_StartWatch(pTree, &wi, htiFirst)) {
//      while (TV_GetWatchItem(pTree, &wi)) {
//          FunctionThatYields(TV_GetWatchItem(pTree, &wi));
//          if (TV_IsWatchValid(pTree, &wi)) {
//              KeepUsing(htiStartHere);
//          } else {
//              // item was deleted while we yielded; stop using it
//          }
//          TV_NextWatchItem(pTree, &wi);
//      }
//      TV_EndWatch(pTree, &wi);
//  }
//
//
//

//
//  TV_StartWatch - Begin watching an item.
//
//  Returns FALSE if out of memory.
//
BOOL TV_StartWatch(PTREE pTree, PTVWATCHEDITEM pwi, HTREEITEM htiStart)
{
    pwi->hti = htiStart;
    pwi->fStale = FALSE;
    return DPA_AppendPtr(pTree->hdpaWatch, pwi) != -1;
}

//
//  TV_EndWatch - Remove the item from the watch list.
//
BOOL TV_EndWatch(PTREE pTree, PTVWATCHEDITEM pwi)
{
    int i = DPA_GetPtrCount(pTree->hdpaWatch);
    while (--i >= 0)
    {
        PTVWATCHEDITEM pwiT = DPA_FastGetPtr(pTree->hdpaWatch, i);
        ASSERT(pwiT);
        if (pwi == pwiT)
        {
            DPA_DeletePtr(pTree->hdpaWatch, i);
            return TRUE;
        }
    }
    ASSERT(!"TV_EndWatch: Item not in list");
    return FALSE;
}

//  End of treeview item watching implementation

void NEAR TV_SetItemRecurse(PTREE pTree, TREEITEM FAR *hItem, LPTVITEMEX ptvi)
{
    // Note:  This code assumes nobody will try to delete an item
    //        during a SetItem notification.
    while (hItem) {
        ptvi->hItem = hItem;
        TV_SetItem(pTree, ptvi);
        if (hItem->hKids) {
            TV_SetItemRecurse(pTree, hItem->hKids, ptvi);
        }

        hItem = hItem->hNext;
    }
}

BOOL NEAR TV_DoExpandRecurse(PTREE pTree, TREEITEM FAR *hItem, BOOL fNotify)
{
    TVWATCHEDITEM wi;
    BOOL fRc = FALSE;

    if (TV_StartWatch(pTree, &wi, hItem))
    {
        while ((hItem = TV_GetWatchItem(pTree, &wi))) {

            // was the escape key pressed at any point since the last check?
            if (GetAsyncKeyState(VK_ESCAPE) & 0x1)
                goto failed;

            TV_Expand(pTree, TVE_EXPAND, hItem, fNotify); // yields
            if (TV_IsWatchValid(pTree, &wi)) {
                if (hItem->hKids) {
                    if (!TV_DoExpandRecurse(pTree, hItem->hKids, fNotify))
                        goto failed;
                }
            }
            TV_NextWatchItem(pTree, &wi);
        }
        fRc = TRUE;
    failed:
        TV_EndWatch(pTree, &wi);
    }
    return fRc;
}


void NEAR TV_ExpandRecurse(PTREE pTree, TREEITEM FAR *hItem, BOOL fNotify)
{
    BOOL fRedraw = pTree->fRedraw;

    TV_OnSetRedraw(pTree, FALSE);
    
    // we're going to check this after each expand so clear it first
    GetAsyncKeyState(VK_ESCAPE);
    
    TV_Expand(pTree, TVE_EXPAND, hItem, fNotify);
    // BUGBUG hItem may have gone bad during that TV_Expand
    TV_DoExpandRecurse(pTree, hItem->hKids, fNotify);
    TV_OnSetRedraw(pTree, fRedraw);
}

void NEAR TV_ExpandParents(PTREE pTree, TREEITEM FAR *hItem, BOOL fNotify)
{
    hItem = hItem->hParent;
    if (hItem) {
        TVWATCHEDITEM wi;
        if (TV_StartWatch(pTree, &wi, hItem)) {
            TV_ExpandParents(pTree, hItem, fNotify);

            // Item may have gone invalid during expansion
            if (TV_IsWatchValid(pTree, &wi) &&

                // make sure this item is not in a collapsed branch
                !(hItem->state & TVIS_EXPANDED)) {

                TV_Expand(pTree, TVE_EXPAND, hItem, fNotify);
            }
            TV_EndWatch(pTree, &wi);
        }
    }
}

// makes sure an item is expanded and scrolled into view

BOOL NEAR TV_EnsureVisible(PTREE pTree, TREEITEM FAR * hItem)
{
    TV_ExpandParents(pTree, hItem, TRUE);
    return TV_ScrollIntoView(pTree, hItem);
}

//
//  Walk up the tree towards the root until we find the item at level iLevel.
//  Note the cast to (char) because iLevel is a BYTE, so the root's level is
//  0xFF.  Casting to (char) turns 0xFF it into -1.
//
HTREEITEM TV_WalkToLevel(HTREEITEM hWalk, int iLevel)
{
    int i;
    for (i = (char)hWalk->iLevel - iLevel; i > 0; i--)
        hWalk = hWalk->hParent;
    return hWalk;
}

// this is to handle single expand mode.
// The new selection is toggled, and the old selection is collapsed

// assume that parents of hNewSel are already fully expanded
// to do this, we build a parent dpa for the old and new
// then go through find the first parent node of the old selection that's not in
// the new sel tree.  and expand that.
void TV_ExpandOnSelChange(PTREE pTree, TREEITEM *hNewSel, TREEITEM *hOldSel)
{
    LRESULT dwAbort;
    NM_TREEVIEW nm;
    BOOL fCollapsing;
    TVWATCHEDITEM wiOld, wiNew;

    // Revalidate hNewSel and hOldSel since they may have been deleted
    // during all the notifications that occurred in the meantime.
    if (!ValidateTreeItem(hOldSel, VTI_NULLOK) ||
        !ValidateTreeItem(hNewSel, VTI_NULLOK))
        return;

    if (TV_StartWatch(pTree, &wiOld, hOldSel))
    {
        if (TV_StartWatch(pTree, &wiNew, hNewSel))
        {
            // Let the app clean up after itself
            nm.itemOld.hItem = hOldSel;
            if (hOldSel)
                nm.itemOld.lParam = hOldSel->lParam;
            nm.itemOld.mask = (TVIF_HANDLE | TVIF_PARAM);

            nm.itemNew.hItem = hNewSel;
            if (hNewSel)
                nm.itemNew.lParam = hNewSel->lParam;
            nm.itemNew.mask = (TVIF_HANDLE | TVIF_PARAM);

            dwAbort = CCSendNotify(&pTree->ci, TVN_SINGLEEXPAND, &nm.hdr);

            UpdateWindow(pTree->ci.hwnd);

            // Revalidate hNewSel and hOldSel since they may have been deleted
            // by that notification.
            if (!TV_IsWatchValid(pTree, &wiOld) ||
                !TV_IsWatchValid(pTree, &wiNew))
                goto cleanup;

            // Collapse if the NewSel currently expanded.
            fCollapsing = hNewSel && (hNewSel->state & TVIS_EXPANDED);

            // Note that Ctrl+select allows the user to suppress the collapse
            // of the old selection.
            if ((!(dwAbort & TVNRET_SKIPOLD)) && hOldSel  && (GetKeyState(VK_CONTROL) >= 0)) {

                //
                //  Collapse parents until we reach the common ancestor between
                //  hOldSel and hNewSel.  Note carefully that we don't cache
                //  any HTREEITEMs to avoid revalidation problems.
                //

                //
                //  Find the common ancestor, which might be the tree root.
                //
                int iLevelCommon;

                if (!hNewSel)
                    iLevelCommon = -1;          // common ancestor is root
                else
                {
                    HTREEITEM hItemO, hItemN;
                    iLevelCommon = min((char)hOldSel->iLevel, (char)hNewSel->iLevel);
                    hItemO = TV_WalkToLevel(hOldSel, iLevelCommon);
                    hItemN = TV_WalkToLevel(hNewSel, iLevelCommon);
                    while (iLevelCommon >= 0 && hItemO != hItemN) {
                        iLevelCommon--;
                        hItemO = hItemO->hParent;
                        hItemN = hItemN->hParent;
                    }
                }

                //
                //  Now walk up the tree from hOldSel, collapsing everything
                //  until we reach the common ancestor.  Do not collapse the
                //  common ancestor.
                //

                while ((char)hOldSel->iLevel > iLevelCommon)
                {
                    TV_Expand(pTree, TVE_COLLAPSE, hOldSel, TRUE);
                    if (!TV_IsWatchValid(pTree, &wiOld))
                        break;
                    hOldSel = hOldSel->hParent;
                    TV_RestartWatch(pTree, &wiOld, hOldSel);
                }

            }

            if ((!(dwAbort & TVNRET_SKIPNEW)) && hNewSel && TV_IsWatchValid(pTree, &wiNew)) {
                TV_Expand(pTree, TVE_TOGGLE, hNewSel, TRUE);
                UpdateWindow(pTree->ci.hwnd);

            }

cleanup:
            TV_EndWatch(pTree, &wiNew);
        }
        TV_EndWatch(pTree, &wiOld);
    }
}

// ----------------------------------------------------------------------------
//
//  Notify the parent that the selection is about to change.  If the change is
//  accepted, de-select the current selected item and select the given item
//
//  sets hCaret
//
// in:
//      hItem   item to become selected
//      wType   TVGN_ values (TVGN_CARET, TVGN_DROPHILIGHT are only valid values)
//      flags   combination of flags
//          TVSIF_NOTIFY        - send notify to parent window
//          TVSIF_UPDATENOW     - do UpdateWindow() to force sync painting
//          TVSIF_NOSINGLEEXPAND- don't do single-expand stuff
//      action  action code to send identifying how selection is being made
//
//  NOTE: Multiple Selection still needs to be added -- this multiplesel code
//        is garbage
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SelectItem(PTREE pTree, WPARAM wType, TREEITEM FAR * hItem, UINT flags, UINT action)
{
    UINT uRDWFlags = RDW_INVALIDATE;

    if (pTree->hImageList && (ImageList_GetBkColor(pTree->hImageList) == (COLORREF)-1))
        uRDWFlags |= RDW_ERASE;

    if (!ValidateTreeItem(hItem, VTI_NULLOK))
        return FALSE;                   // Invalid parameter

    switch (wType) {

    case TVGN_FIRSTVISIBLE:
        if (!hItem)
            return FALSE;

        TV_EnsureVisible(pTree, hItem);
        if (pTree->fVert) TV_SetTopItem(pTree, hItem->iShownIndex);
        break;

    case TVGN_DROPHILITE:

        ASSERT(hItem == NULL || ITEM_VISIBLE(hItem));

        if (hItem != pTree->hDropTarget) {
            if (pTree->hDropTarget) {
                pTree->hDropTarget->state &= ~TVIS_DROPHILITED;
                TV_InvalidateItem(pTree, pTree->hDropTarget, uRDWFlags);
            }

            if (hItem) {
                hItem->state |= TVIS_DROPHILITED;
                TV_InvalidateItem(pTree, hItem, uRDWFlags);
            }
            pTree->hDropTarget = hItem;

            if (pTree->hCaret) {
                TV_InvalidateItem(pTree, pTree->hCaret, uRDWFlags);
            }


            if (flags & TVSIF_UPDATENOW)
                UpdateWindow(pTree->ci.hwnd);
        }
        break;

    case TVGN_CARET:

        // REVIEW: we may want to scroll into view in this case
        // it's already the selected item, just return
        if (pTree->hCaret != hItem) {

            TREEITEM FAR * hOldSel;

            if ((flags & TVSIF_NOTIFY) && TV_SendSelChange(pTree, TVN_SELCHANGING, pTree->hCaret, hItem, action))
                return FALSE;

            if (pTree->hCaret) {
                pTree->hCaret->state &= ~TVIS_SELECTED;
                TV_InvalidateItem(pTree, pTree->hCaret, uRDWFlags);
            }

            hOldSel = pTree->hCaret;
            pTree->hCaret = hItem;

            if (hItem) {
                hItem->state |= TVIS_SELECTED;

                // make sure this item is not in a collapsed branch
                TV_ExpandParents(pTree, hItem, (flags & TVSIF_NOTIFY));

                TV_InvalidateItem(pTree, hItem, uRDWFlags );

                if (action == TVC_BYMOUSE) {
                    // if selected by mouse, let's wait a doubleclick sec before scrolling
                    SetTimer(pTree->ci.hwnd, IDT_SCROLLWAIT, GetDoubleClickTime(), NULL);
                    pTree->fScrollWait = TRUE;
                } else if (pTree->fRedraw)
                    TV_ScrollVertIntoView(pTree, hItem);
            }
            if (pTree->hwndToolTips)
                TV_Timer(pTree, IDT_TOOLTIPWAIT);

            if (flags & TVSIF_NOTIFY)
                TV_SendSelChange(pTree, TVN_SELCHANGED, hOldSel, hItem, action);

            if ((pTree->ci.style & TVS_SINGLEEXPAND) &&
                !(flags & TVSIF_NOSINGLEEXPAND) &&
                action != TVC_BYKEYBOARD)
            {
                    TV_ExpandOnSelChange(pTree, pTree->hCaret, hOldSel);
            }

            if (flags & TVSIF_UPDATENOW)
                UpdateWindow(pTree->ci.hwnd);

            MyNotifyWinEvent(EVENT_OBJECT_FOCUS, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
            MyNotifyWinEvent(EVENT_OBJECT_SELECTION, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
        }
        break;

    default:
        DebugMsg(DM_TRACE, TEXT("Invalid type passed to TV_SelectItem"));
        return FALSE;
    }

    return TRUE;        // success
}

// remove all the children, but pretend they are still there

BOOL NEAR TV_ResetItem(PTREE pTree, HTREEITEM hItem)
{
    TV_DeleteItem(pTree, hItem, TVDI_CHILDRENONLY);

    hItem->state &= ~TVIS_EXPANDEDONCE;
    hItem->fKids = KIDS_FORCE_YES;      // force children

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Expand or collapse an item's children
//  Returns TRUE if any change took place and FALSE if unchanged
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_Expand(PTREE pTree, WPARAM wCode, TREEITEM FAR * hItem, BOOL fNotify)
{
    WORD fOldState;
    UINT cntVisDescendants;
    TVITEMEX sItem;
    TREEITEM FAR * hItemExpanding;

// deal with the evil invisible root for multiple root trees.
    hItemExpanding = hItem;
    if ((hItem == NULL) || (hItem == TVI_ROOT))
        hItem = pTree->hRoot;

    DBG_ValidateTreeItem(hItem, 0);

    TV_GetItem(pTree, hItem, TVIF_CHILDREN, &sItem);

    if (!(wCode & TVE_ACTIONMASK) || sItem.cChildren == 0)
        return FALSE;           // no children to expand or collapse

    if ((wCode & TVE_ACTIONMASK) == TVE_TOGGLE) {
        wCode = (wCode & ~TVE_ACTIONMASK);

        // if it's not expaned, or not fully expanded, expand now
        wCode |=
            (((!(hItem->state & TVIS_EXPANDED)) ||
              hItem->state & TVIS_EXPANDPARTIAL) ?
             TVE_EXPAND : TVE_COLLAPSE);
    }

    if (((wCode & TVE_ACTIONMASK) == TVE_EXPAND) && !(hItem->state & TVIS_EXPANDEDONCE))
    {
        // if its the first expand, ALWAYS notify the parent
        fNotify = TRUE;
    }

    // at this point the children may be added if they aren't already there (callback)

    if (fNotify && TV_SendItemExpand(pTree, TVN_ITEMEXPANDING, hItemExpanding, wCode))
        return FALSE;

    // if (!hItem->hKids && (hItem->fKids == KIDS_FORCE_NO))    // this may be right, but I don't
                                                                // have proof now.
    if (!hItem->hKids)
    {
        // kids we removed, or never there
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE);
        return FALSE;
    }

    fOldState = hItem->state;

    if (hItem->hParent) // never turn off TVIS_EXPANED for the invisible root
    {
        if ((wCode & TVE_ACTIONMASK) == TVE_EXPAND)
           hItem->state |= TVIS_EXPANDED;
        else
           hItem->state &= ~(TVIS_EXPANDED | TVIS_EXPANDPARTIAL);

        if (wCode & TVE_EXPANDPARTIAL) {
            hItem->state |= TVIS_EXPANDPARTIAL;
        } else {
            hItem->state &= ~(TVIS_EXPANDPARTIAL);
        }
    }

    // if we're not changing the expanded state
    // check to see if we're supposed to collapse reset
    if (!(fOldState & TVIS_EXPANDED) &&
        !(hItem->state & TVIS_EXPANDED))
    {
        if ((wCode & (TVE_ACTIONMASK | TVE_COLLAPSERESET)) == (TVE_COLLAPSE | TVE_COLLAPSERESET))
        {
            TV_ResetItem(pTree, hItem);
        }

        return FALSE;
    }

    // if we changed expaneded states, recalc the scrolling
    if ((fOldState ^ hItem->state) & TVIS_EXPANDED) {

        cntVisDescendants = TV_ScrollBelow(pTree, hItem, TRUE, hItem->state & TVIS_EXPANDED);

        if (hItem->state & TVIS_EXPANDED)
        {
            UINT wNewTop, wTopOffset, wLastKid;

            TV_ScrollBarsAfterExpand(pTree, hItem);

            wNewTop = pTree->hTop->iShownIndex;
            wTopOffset = hItem->iShownIndex - wNewTop;

            wLastKid = wTopOffset + cntVisDescendants + 1;

            if (wLastKid > pTree->cFullVisible)
            {
                wNewTop += min(wLastKid - pTree->cFullVisible, wTopOffset);
                TV_SetTopItem(pTree, wNewTop);
            }
        }
        else
        {
            TV_ScrollBarsAfterCollapse(pTree, hItem);
            TV_ScrollVertIntoView(pTree, hItem);

            // If we collapsed the subtree that contains the caret, then
            // pop the caret back to the last visible ancestor
            // Pass TVIS_NOSINGLEEXPAND so we won't expand an item right
            // after we collapsed it (d'oh!)
            if (pTree->hCaret)
            {
                TREEITEM FAR * hWalk = TV_WalkToLevel(pTree->hCaret, hItem->iLevel);

                if (hWalk == hItem)
                    TV_SelectItem(pTree, TVGN_CARET, hItem, (fNotify ? TVSIF_NOTIFY : 0) | TVSIF_UPDATENOW | TVSIF_NOSINGLEEXPAND, TVC_UNKNOWN);
            }

        }
    } else if ((fOldState ^ hItem->state) & TVIS_EXPANDPARTIAL) {
        // we didn't change the expanded state, only the expand partial
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE);
    }

    if (fNotify && TV_SendItemExpand(pTree, TVN_ITEMEXPANDED, hItem, wCode))
        return FALSE;

    hItem->state |= TVIS_EXPANDEDONCE;

    if ((wCode & (TVE_ACTIONMASK | TVE_COLLAPSERESET)) == (TVE_COLLAPSE | TVE_COLLAPSERESET))
    {
        TV_ResetItem(pTree, hItem);
    }

    // BUGBUG raymondc v6 we generate a notification even if nothing happened,
    // which cunfuses accessibility.  E.g., app tried to expand something
    // that was already expanded.  Explorer Band does this when you navigate.
    MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
        (LONG_PTR)hItem);

    return TRUE;
}

BOOL PASCAL BetweenItems(PTREE pTree, HTREEITEM hItem, HTREEITEM hItemStart, HTREEITEM hItemEnd)
{
    if (hItemStart) {
        while ((hItemStart = TV_GetNextVisItem(hItemStart)) && (hItemEnd != hItemStart))
        {
            if (hItem == hItemStart)
                return TRUE;
        }
    }
    return FALSE;
}

#ifdef  FE_IME
// Now only Korean version is interested in incremental search with composition string.

#define FREE_COMP_STRING(pszCompStr)    LocalFree((HLOCAL)(pszCompStr))

BOOL NEAR TV_OnImeComposition(PTREE pTree, WPARAM wParam, LPARAM lParam)
{
    LPTSTR lpsz;
    int iCycle = 0;
    HTREEITEM hItem;
    TCHAR szTemp[MAXLABELTEXT];
    TVITEMEX ti;
    LPTSTR lpszAlt = NULL; // use only if SameChar
    int iLen;
    HIMC hImc;
    TCHAR *pszCompStr;
    BOOL fRet = TRUE;

    if (hImc = ImmGetContext(pTree->ci.hwnd))
    {
        if (lParam & GCS_RESULTSTR)
        {
            fRet = FALSE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_RESULTSTR);
            if (pszCompStr)
            {
                IncrementSearchImeCompStr(&pTree->is, FALSE, pszCompStr, &lpsz);
                FREE_COMP_STRING(pszCompStr);
            }
        }
        if (lParam & GCS_COMPSTR)
        {
            fRet = TRUE;
            pszCompStr = GET_COMP_STRING(hImc, GCS_COMPSTR);
            if (pszCompStr)
            {
                if (IncrementSearchImeCompStr(&pTree->is, TRUE, pszCompStr, &lpsz)) {
                    if (pTree->hCaret) {
                        pTree->htiSearch = pTree->hCaret;
                    } else if (pTree->hRoot && pTree->hRoot->hKids) {
                        pTree->htiSearch = pTree->hRoot->hKids;
                    } else
                        return fRet;
                }

                if (!lpsz || !*lpsz || !pTree->hRoot || !pTree->hRoot->hKids)
                    return fRet;

                hItem = pTree->htiSearch;
                ti.cchTextMax  = sizeof(szTemp);
                iLen = lstrlen(lpsz);
#ifdef UNICODE
                if (iLen > 1 && SameChars(lpsz, lpsz[0]))
                    lpszAlt = lpsz + iLen - 1;
#else
                if (iLen > 2 && SameDBCSChars(lpsz, (WORD)((BYTE)lpsz[0] << 8 | (BYTE)lpsz[1])))
                    lpszAlt = lpsz + iLen - 2;
#endif

                do {
                    ti.pszText = szTemp;
                    hItem = TV_GetNextVisItem(hItem);
                    if (!hItem) {
                        iCycle++;
                        hItem = pTree->hRoot->hKids;
                    }

                    TV_GetItem(pTree, hItem, TVIF_TEXT, &ti);
                    if ((ti.pszText != LPSTR_TEXTCALLBACK) &&
                        HIWORD64(ti.pszText)) {
                        // DebugMsg(DM_TRACE, "treesearch %d %s %s", (LPSTR)lpsz, (LPSTR)lpsz, (LPSTR)ti.pszText);
                        if (IntlStrEqNI(lpsz, ti.pszText, iLen) ||
#ifdef UNICODE
                            (lpszAlt && IntlStrEqNI(lpszAlt, ti.pszText, 1) &&
#else
                            (lpszAlt && IntlStrEqNI(lpszAlt, ti.pszText, 2) &&
#endif
                             BetweenItems(pTree, hItem, pTree->hCaret, pTree->htiSearch)))
                        {
                            DebugMsg(DM_TRACE, TEXT("Selecting"));
                            TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYKEYBOARD);
#ifdef KEYBOARDCUES
                            //notify of navigation key usage
                            CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
#endif
                            return fRet;
                        }
                    }
                }  while(iCycle < 2);

                // if they hit the same key twice in a row at the beginning of
                // the search, and there was no item found, they likely meant to
                // retstart the search
                if (lpszAlt) {

                    // first clear out the string so that we won't recurse again
                    IncrementSearchString(&pTree->is, 0, NULL);
                    TV_OnImeComposition(pTree, wParam, lParam);
                } else {
                    IncrementSearchBeep(&pTree->is);
                }
#ifdef KEYBOARDCUES
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
#endif
                FREE_COMP_STRING(pszCompStr);
            }
        }
        ImmReleaseContext(pTree->ci.hwnd, hImc);
    }
    return fRet;
}
#endif


void NEAR TV_OnChar(PTREE pTree, UINT ch, int cRepeat)
{
    LPTSTR lpsz;
    int iCycle = 0;
    HTREEITEM hItem;
    TCHAR szTemp[MAXLABELTEXT];
    TVITEMEX ti;
    LPTSTR lpszAlt = NULL; // use only if SameChar
    int iLen;

#ifdef UNICODE_WIN9x
    if (g_fDBCSEnabled && (IsDBCSLeadByteEx(pTree->ci.uiCodePage, (BYTE)ch) || pTree->uDBCSChar))
    {
        WCHAR wch;

        if (!pTree->uDBCSChar)
        {
            // Save DBCS LeadByte character
            pTree->uDBCSChar = ch & 0x00ff;
            return;
        }
        else
        {
            // Combine DBCS characters
            pTree->uDBCSChar |=  ((ch & 0x00ff) << 8);

            // Convert to UNICODE
            if (MultiByteToWideChar(pTree->ci.uiCodePage, MB_ERR_INVALID_CHARS, (LPCSTR)&pTree->uDBCSChar, 2, &wch, 1))
            {
                ch = wch;
            }

            pTree->uDBCSChar = 0;
        }
    }
    else
    {
        if (ch >= 0x80)     // no need conversion for low ansi character
        {
            WCHAR wch;

            if (MultiByteToWideChar(pTree->ci.uiCodePage, 0, (LPCSTR)&ch, 1, &wch, 1))
                ch = wch;
        }
    }
#endif

    if (IncrementSearchString(&pTree->is, ch, &lpsz) || !pTree->htiSearch) {
        if (pTree->hCaret) {
            pTree->htiSearch = pTree->hCaret;
        } else if (pTree->hRoot && pTree->hRoot->hKids) {
            pTree->htiSearch = pTree->hRoot->hKids;
        } else
            return;
    }

    if (!lpsz || !*lpsz || !pTree->hRoot || !pTree->hRoot->hKids)
        return;

    hItem = pTree->htiSearch;
    ti.cchTextMax  = ARRAYSIZE(szTemp);
    iLen = lstrlen(lpsz);
    if (iLen > 1 && SameChars(lpsz, lpsz[0]))
        lpszAlt = lpsz + iLen - 1;

    do {
        ti.pszText = szTemp;
        hItem = TV_GetNextVisItem(hItem);
        if (!hItem) {
            iCycle++;
            hItem = pTree->hRoot->hKids;
        }

        TV_GetItem(pTree, hItem, TVIF_TEXT, &ti);
        if ((ti.pszText != LPSTR_TEXTCALLBACK) &&
            HIWORD64(ti.pszText)) {
            // DebugMsg(DM_TRACE, TEXT("treesearch %d %s %s"), (LPTSTR)lpsz, (LPTSTR)lpsz, (LPTSTR)ti.pszText);
            if (IntlStrEqNI(lpsz, ti.pszText, iLen) ||
                (lpszAlt && IntlStrEqNI(lpszAlt, ti.pszText, 1) &&
                 BetweenItems(pTree, hItem, pTree->hCaret, pTree->htiSearch)))
            {
                DebugMsg(DM_TRACE, TEXT("Selecting"));
                TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYKEYBOARD);
#ifdef KEYBOARDCUES
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
#endif
                return;
            }
        }
    }  while(iCycle < 2);

    // if they hit the same key twice in a row at the beginning of
    // the search, and there was no item found, they likely meant to
    // retstart the search
    if (lpszAlt) {

        // first clear out the string so that we won't recurse again
        IncrementSearchString(&pTree->is, 0, NULL);
        TV_OnChar(pTree, ch, cRepeat);
    } else {
        IncrementSearchBeep(&pTree->is);
    }
#ifdef KEYBOARDCUES
    //notify of navigation key usage
    CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
#endif
}

// ----------------------------------------------------------------------------
//
//  Handle WM_KEYDOWN messages
//  If control key is down, treat keys as scroll codes; otherwise, treat keys
//  as caret position changes.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_KeyDown(PTREE pTree, WPARAM wKey, LPARAM dwKeyData)
{
    TREEITEM FAR * hItem;
    UINT wShownIndex;
    TV_KEYDOWN nm;
    BOOL fPuntChar;
    BOOL ret = TRUE;

    // Notify
    nm.wVKey = (WORD)wKey;
    fPuntChar = (BOOL)CCSendNotify(&pTree->ci, TVN_KEYDOWN, &nm.hdr);

    wKey = RTLSwapLeftRightArrows(&pTree->ci, wKey);

    if (GetKeyState(VK_CONTROL) < 0)
    {
        // control key is down
        UINT wScrollCode;

        switch (wKey)
        {
            case VK_LEFT:
                TV_HorzScroll(pTree, SB_LINEUP, 0);
                break;

            case VK_RIGHT:
                TV_HorzScroll(pTree, SB_LINEDOWN, 0);
                break;

            case VK_PRIOR:
                wScrollCode = SB_PAGEUP;
                goto kdVertScroll;

            case VK_HOME:
                wScrollCode = SB_TOP;
                goto kdVertScroll;

            case VK_NEXT:
                wScrollCode = SB_PAGEDOWN;
                goto kdVertScroll;

            case VK_END:
                wScrollCode = SB_BOTTOM;
                goto kdVertScroll;

            case VK_UP:
                wScrollCode = SB_LINEUP;
                goto kdVertScroll;

            case VK_DOWN:
                wScrollCode = SB_LINEDOWN;
kdVertScroll:
                TV_VertScroll(pTree, wScrollCode, 0);
                break;

            default:
                ret = FALSE;
        }

    } else {

        switch (wKey)
        {
        case VK_RETURN:
            fPuntChar = (BOOL)CCSendNotify(&pTree->ci, NM_RETURN, NULL);
            break;

        case VK_PRIOR:
            if (pTree->hCaret && (pTree->hCaret->iShownIndex > (pTree->cFullVisible - 1)))
            {
                wShownIndex = pTree->hCaret->iShownIndex - (pTree->cFullVisible - 1);
                goto selectIndex;
            }
            // fall thru

        case VK_HOME:
            wShownIndex = 0;
            goto selectIndex;

        case VK_NEXT:
            if (!pTree->hCaret)
            {
                wShownIndex = 0;
                goto selectIndex;
            }
            wShownIndex = pTree->hCaret->iShownIndex + (pTree->cFullVisible - 1);
            if (wShownIndex < pTree->cShowing)
                goto selectIndex;
            // fall thru

        case VK_END:
            wShownIndex = pTree->cShowing - 1;
selectIndex:
            hItem = TV_GetShownIndexItem(pTree->hRoot->hKids, wShownIndex);
            goto kdSetCaret;
            break;

        case VK_SUBTRACT:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_Expand(pTree, TVE_COLLAPSE, pTree->hCaret, TRUE);
            }
            break;

        case VK_ADD:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_Expand(pTree, TVE_EXPAND, pTree->hCaret, TRUE);
            }
            break;

        case VK_MULTIPLY:
            if (pTree->hCaret) {
                fPuntChar = TRUE;
                TV_ExpandRecurse(pTree, pTree->hCaret, TRUE);
            }
            break;

        case VK_LEFT:
            if (pTree->hCaret && (pTree->hCaret->state & TVIS_EXPANDED)) {
                TV_Expand(pTree, TVE_COLLAPSE, pTree->hCaret, TRUE);
                break;
            } else if (pTree->hCaret) {
                hItem = VISIBLE_PARENT(pTree->hCaret);
                goto kdSetCaret;
            }
            break;

        case VK_BACK:
            // get the parent, avoiding the root item
            fPuntChar = TRUE;
            if (pTree->hCaret) {
                hItem = VISIBLE_PARENT(pTree->hCaret);
                goto kdSetCaret;
            }
            break;

        case VK_UP:
            if (pTree->hCaret)
                hItem = TV_GetPrevVisItem(pTree->hCaret);
            else
                hItem = pTree->hRoot->hKids;

            goto kdSetCaret;
            break;


        case VK_RIGHT:
            if (pTree->hCaret && !(pTree->hCaret->state & TVIS_EXPANDED)) {
                TV_Expand(pTree, TVE_EXPAND, pTree->hCaret, TRUE);
                break;
            } // else fall through

        case VK_DOWN:
            if (pTree->hCaret)
                hItem = TV_GetNextVisItem(pTree->hCaret);
            else
                hItem = pTree->hRoot->hKids;

kdSetCaret:
            if (hItem)
                TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYKEYBOARD);

            break;

        case VK_SPACE:
            if ((pTree->ci.style & TVS_CHECKBOXES) && pTree->hCaret)
            {
                TV_HandleStateIconClick(pTree, pTree->hCaret);
                fPuntChar = TRUE; // don't beep
            }
            break;

        default:
            ret = FALSE;
        }
    }

    if (fPuntChar) {
        pTree->iPuntChar++;
    } else if (pTree->iPuntChar){
        // this is tricky...  if we want to punt the char, just increment the
        // count.  if we do NOT, then we must clear the queue of WM_CHAR's
        // this is to preserve the iPuntChar to mean "punt the next n WM_CHAR messages
        MSG msg;
        while((pTree->iPuntChar > 0) && PeekMessage(&msg, pTree->ci.hwnd, WM_CHAR, WM_CHAR, PM_REMOVE)) {
            pTree->iPuntChar--;
        }
        ASSERT(!pTree->iPuntChar);
    }

#ifdef KEYBOARDCUES
    if(VK_MENU!=wKey)
    {//notify of navigation key usage
        CCNotifyNavigationKeyUsage(&(pTree->ci), UISF_HIDEFOCUS);
    }
#endif
    return ret;

}


// ----------------------------------------------------------------------------
//
//  Sets the tree's indent width per hierarchy level and recompute widths.
//
//  sets cxIndent
//
// ----------------------------------------------------------------------------

void NEAR TV_SetIndent(PTREE pTree, WPARAM cxIndent)
{
    if (pTree->hImageList) {
        if ((SHORT)cxIndent < pTree->cxImage)
            cxIndent = pTree->cxImage;
    }

    if ((SHORT)cxIndent < pTree->cyText)
        cxIndent = pTree->cyText;

    if (cxIndent < MAGIC_MININDENT)
        cxIndent = MAGIC_MININDENT;

    pTree->cxIndent = (SHORT)cxIndent;

    TV_CreateIndentBmps(pTree);
    TV_ScrollBarsAfterSetWidth(pTree, NULL);
}

// ----------------------------------------------------------------------------
//
//  Sets the tree's item height to be the maximum of the image height and text
//  height.  Then recompute the tree's full visible count.
//
//  sets cyItem, cFullVisible
//
// ----------------------------------------------------------------------------

void NEAR TV_SetItemHeight(PTREE pTree)
{
    // height MUST be even with TVS_HASLINES -- go ahead and make it always even
    if (!pTree->fCyItemSet)
        pTree->cyItem = (max(pTree->cyImage, pTree->cyText) + 1);
    // height not always even not, only on haslines style.
    if (pTree->cyItem <= 1) {
        pTree->cyItem = 1;          // Don't let it go zero or negative!
    } else if (!(pTree->ci.style & TVS_NONEVENHEIGHT))
        pTree->cyItem &= ~1;

    pTree->cFullVisible = pTree->cyWnd / pTree->cyItem;

    TV_CreateIndentBmps(pTree);
    TV_CalcScrollBars(pTree);
}

// BUGBUG: does not deal with hfont == NULL

void NEAR TV_OnSetFont(PTREE pTree, HFONT hNewFont, BOOL fRedraw)
{
    HDC hdc;
    HFONT hfontSel;
    TCHAR c = TEXT('J');       // for bog
    SIZE size;

    if (pTree->fCreatedFont && pTree->hFont) {
        DeleteObject(pTree->hFont);
        pTree->fCreatedFont = FALSE;
    }

    if (hNewFont == NULL) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
#ifdef WINNT
        // B#210235 - because NT4 initializes icontitle logfont with Ansi charset
        // no matter what font is selected, following A/W conversion would fail
        // on non US environment if we use this logfont to get codepage. 
        // The ACP is guaranteed to work with any Ansi apps because these apps
        // assume ACP to be matching to their desired codepage.
        if (staticIsOS(OS_NT4ORGREATER) && !staticIsOS(OS_WIN2000ORGREATER))
        {
            CHARSETINFO csi;
            TranslateCharsetInfo(IntToPtr_(DWORD *, g_uiACP), &csi, TCI_SRCCODEPAGE);
            lf.lfCharSet = (BYTE)csi.ciCharset;
        }
#endif
        hNewFont = CreateFontIndirect(&lf);
        pTree->fCreatedFont = TRUE;         // make sure we delete it
    }

    hdc = GetDC(pTree->ci.hwnd);

    hfontSel = hNewFont ? SelectObject(hdc, hNewFont) : NULL;

    // Office9 Setup had a bug where they installed a bogus font,
    // which created okay but all APIs against it (e.g., GetTextExtentPoint)
    // failed!  Protect against failure by pre-setting the value to something
    // non-garbage.
    size.cy = 0;
    GetTextExtentPoint(hdc, &c, 1, &size);
    pTree->cyText = (SHORT)(size.cy + (g_cyBorder * 2));

    if (hfontSel)
        SelectObject(hdc, hfontSel);

    ReleaseDC(pTree->ci.hwnd, hdc);

    pTree->hFont = hNewFont;
    if (pTree->hFontBold) {
        TV_CreateBoldFont(pTree);
    }
    pTree->ci.uiCodePage = GetCodePageForFont(hNewFont);

    TV_DeleteHotFonts(pTree);

    if (pTree->cxIndent == 0)   // first time init?
    {
        if (!pTree->cyItem) pTree->cyItem = pTree->cyText;
        TV_SetIndent(pTree, 16 /*g_cxSmIcon*/ + MAGIC_INDENT);
    }

    TV_ScrollBarsAfterSetWidth(pTree, NULL);
    TV_SetItemHeight(pTree);

    if (pTree->hwndToolTips)
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)pTree->hFont, (LPARAM)TRUE);

    // REVIEW: does this happen as a result of the above?
    // if (fRedraw)
    //    RedrawWindow(pTree->ci.hwnd, NULL, NULL, RDW_INVALIDATE | RDW_ERASE);
}

VOID NEAR PASCAL TV_CreateBoldFont(PTREE pTree)
{
    LOGFONT lf;

    if (pTree->hFontBold)
        DeleteObject (pTree->hFontBold);

    GetObject(pTree->hFont, sizeof (lf), &lf);
    lf.lfWeight = FW_BOLD;
    pTree->hFontBold = CreateFontIndirect(&lf);
}


HIMAGELIST NEAR TV_SetImageList(PTREE pTree, HIMAGELIST hImage, int iImageIndex)
{
    int cx, cy;
    HIMAGELIST hImageOld = NULL;

    switch (iImageIndex) {

        case TVSIL_STATE:

            hImageOld = pTree->himlState;
            pTree->himlState = hImage;
            if (hImage) {
                ImageList_GetIconSize(hImage, &pTree->cxState , &pTree->cyState);
            } else {
                pTree->cxState = 0;
            }
            break;

        case TVSIL_NORMAL:
            hImageOld = pTree->hImageList;
            if (hImage && ImageList_GetIconSize(hImage, &cx, &cy))
            {
                pTree->cxImage = (cx + MAGIC_INDENT);
                pTree->cyImage = (SHORT)cy;
                if (pTree->cxIndent < pTree->cxImage)
                    TV_SetIndent(pTree, pTree->cxImage);
                pTree->hImageList = hImage;

                if (!hImageOld && pTree->ci.style & TVS_CHECKBOXES) {
                    TV_InitCheckBoxes(pTree);
                }
            }
            else
            {
                pTree->cxImage = pTree->cyImage = 0;
                pTree->hImageList = NULL;
            }
            break;

        default:
            DebugMsg(DM_TRACE, TEXT("sh TR - TVM_SETIMAGELIST: unrecognized iImageList"));
            break;

    }

    TV_ScrollBarsAfterSetWidth(pTree, NULL);
    TV_SetItemHeight(pTree);

    return hImageOld;
}


// ----------------------------------------------------------------------------
//
//  Gets the item with the described relationship to the given item, NULL if
//  no item can be found with that relationship.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetNextItem(PTREE pTree, TREEITEM FAR * hItem, WPARAM wGetCode)
{
    switch (wGetCode) {
    case TVGN_ROOT:
        return pTree->hRoot->hKids;

    case TVGN_DROPHILITE:
        return pTree->hDropTarget;

    case TVGN_CARET:
        return pTree->hCaret;

    case TVGN_FIRSTVISIBLE:
        return pTree->hTop;

    case TVGN_LASTVISIBLE:
        return TV_GetShownIndexItem(pTree->hRoot->hKids, pTree->cShowing-1);

    case TVGN_CHILD:
        if (!hItem || (hItem == TVI_ROOT))
            return pTree->hRoot->hKids;
        break;
    }

    // all of these require a valid hItem
    if (!ValidateTreeItem(hItem, 0))
        return NULL;

    switch (wGetCode) {
    case TVGN_NEXTVISIBLE:
        return TV_GetNextVisItem(hItem);

    case TVGN_PREVIOUSVISIBLE:
        return TV_GetPrevVisItem(hItem);

    case TVGN_NEXT:
        return hItem->hNext;

    case TVGN_PREVIOUS:
        if (hItem->hParent->hKids == hItem)
            return NULL;
        else {
            TREEITEM FAR * hWalk;
            for (hWalk = hItem->hParent->hKids; hWalk->hNext != hItem; hWalk = hWalk->hNext);
            return hWalk;
        }

    case TVGN_PARENT:
        return VISIBLE_PARENT(hItem);

    case TVGN_CHILD:
        return hItem->hKids;
    }

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Returns the number of items (including the partially visible item at the
//  bottom based on the given flag) that fit in the tree's client window.
//
// ----------------------------------------------------------------------------

LRESULT NEAR TV_GetVisCount(PTREE pTree, BOOL fIncludePartial)
{
    int  i;

    if (!fIncludePartial)
        return(MAKELRESULTFROMUINT(pTree->cFullVisible));

    i = pTree->cFullVisible;

    if (pTree->cyWnd - (i * pTree->cyItem))
        i++;

    return i;
}


void TV_InvalidateInsertMarkRect(PTREE pTree, BOOL fErase)
{
    RECT rc;
    if (TV_GetInsertMarkRect(pTree, &rc))
        InvalidateRect(pTree->ci.hwnd, &rc, fErase);
}

// ----------------------------------------------------------------------------
//
//  recomputes tree's fields that rely on the tree's client window size
//
//  sets cxWnd, cyWnd, cFullVisible
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SizeWnd(PTREE pTree, UINT cxWnd, UINT cyWnd)
{
    RECT rc;
    UINT cxOld = pTree->cxWnd;
    if (!cxWnd || !cyWnd)
    {
        GetClientRect(pTree->ci.hwnd, &rc);
        cxWnd = rc.right;
        cyWnd = rc.bottom;
    }
    pTree->cxWnd = (SHORT)cxWnd;
    pTree->cyWnd = (SHORT)cyWnd;
    pTree->cFullVisible = cyWnd / pTree->cyItem;
    
    if (pTree->ci.style & TVS_NOSCROLL)
        pTree->cxMax = (WORD) cxWnd;
    
    TV_CalcScrollBars(pTree);
    if (pTree->cxBorder)
    {
        rc.top = 0;
        rc.bottom = cyWnd;
        rc.right = cxOld;
        rc.left = cxOld - pTree->cxBorder;
        if (rc.left < (int)cxWnd) {
            // invalidate so clipping happens on right on size.
            InvalidateRect(pTree->ci.hwnd, &rc, TRUE);  
        }
    }

    TV_InvalidateInsertMarkRect(pTree, TRUE);

    return TRUE;
}


void TV_HandleStateIconClick(PTREE pTree, HTREEITEM hItem)
{
    TVITEMEX tvi;
    int iState;

    tvi.stateMask = TVIS_STATEIMAGEMASK;
    TV_GetItem(pTree, hItem, TVIF_STATE, &tvi);

    iState = STATEIMAGEMASKTOINDEX(tvi.state & tvi.stateMask);
    iState %= (ImageList_GetImageCount(pTree->himlState) - 1);
    iState++;

    tvi.mask = TVIF_STATE;
    tvi.state = INDEXTOSTATEIMAGEMASK(iState);
    tvi.hItem = hItem;
    TV_SetItem(pTree, &tvi);

}


//
//  Eudora is a piece of work.
//
//  When they get a NM_DBLCLK notification from a treeview, they say,
//  "Oh, I know that treeview allocates its NMHDR from the stack, and
//  there's this local variable on Treeview's stack I'm really interested
//  in, so I'm going to hard-code an offset from the pnmhdr and read the
//  DWORD at that location so I can get at the local variable.  I will then
//  stop working if this value is zero."
//
//  The conversion to UNICODE changed our stack layout enough that they
//  end up always getting zero -- it's the NULL parameter which is the
//  final argument to CCSendNotify.  Since all this stack layout stuff is
//  sensitive to how the compiler's optimizer feels today, we create a
//  special notify structure Just For Eudora which mimics the stack layout
//  they expected to see in Win95.
//
typedef struct NMEUDORA {
    NMHDR   nmhdr;
    BYTE    Padding[48];
    DWORD   MustBeNonzero;      // Eudora fails to install if this is zero
} NMEUDORA;

// ----------------------------------------------------------------------------
//
//  WM_LBUTTONDBLCLK message -- toggle expand/collapse state of item's children
//  WM_LBUTTONDOWN message -- on item's button, do same as WM_LBUTTONDBLCLK,
//  otherwise select item and ensure that item is fully visible
//
// ----------------------------------------------------------------------------

void NEAR TV_ButtonDown(PTREE pTree, UINT wMsg, UINT wFlags, int x, int y, UINT TVBD_flags)
{
    UINT wHitCode;
    TREEITEM FAR * hItem;
    HWND hwndTree;
    LRESULT lResult;
#ifdef _X86_
    NMEUDORA nmeu;
    nmeu.MustBeNonzero = 1;
    COMPILETIME_ASSERT(FIELD_OFFSET(NMEUDORA, MustBeNonzero) == 0x3C);
#endif

    GetMessagePosClient(pTree->ci.hwnd, &pTree->ptCapture);

    if (!TV_DismissEdit(pTree, FALSE))   // end any previous editing (accept it)
        return;     // Something happened such that we should not process button down


    hItem = TV_CheckHit(pTree, x, y, &wHitCode);

    // Excel likes to destroy the entire tree when it gets a double-click
    // so we need to watch the item in case it vanishes behind our back.
    hwndTree = pTree->ci.hwnd;

    if (wMsg == WM_LBUTTONDBLCLK)
    {
        //
        // Cancel any name editing that might happen.
        //

        TV_CancelEditTimer(pTree);

        if (wHitCode & (TVHT_ONITEM | TVHT_ONITEMBUTTON)) {
            goto ExpandItem;
        }

        //
        // Collapses node above the line double clicked on
        //
        else if ((pTree->ci.style & TVS_HASLINES) && (wHitCode & TVHT_ONITEMINDENT) &&
            (abs(x % pTree->cxIndent - pTree->cxIndent/2) <= g_cxDoubleClk)) {

            int i;

            for (i = hItem->iLevel - x/pTree->cxIndent + ((pTree->ci.style & TVS_LINESATROOT)?1:0); i > 1; i--)
                hItem = hItem->hParent;

ExpandItem:
#ifdef _X86_
            lResult = CCSendNotify(&pTree->ci, wFlags & MK_RBUTTON ? NM_RDBLCLK : NM_DBLCLK, &nmeu.nmhdr);
#else
            lResult = CCSendNotify(&pTree->ci, wFlags & MK_RBUTTON ? NM_RDBLCLK : NM_DBLCLK, NULL);
#endif
            if (!IsWindow(hwndTree))
                goto bail;
            if (!lResult) {
                // don't auto expand this if we're in single expand mode because the first click did it already
                if (!(pTree->ci.style & TVS_SINGLEEXPAND))
                    TV_Expand(pTree, TVE_TOGGLE, hItem, TRUE);
            }

        }

        pTree->fScrollWait = FALSE;

    } else {    // WM_LBUTTONDOWN

        if (wHitCode == TVHT_ONITEMBUTTON)
        {
            if (!CCSendNotify(&pTree->ci, NM_CLICK, NULL)) {
                if (TVBD_flags & TVBD_FROMWHEEL)
                    TV_Expand(pTree, (TVBD_flags & TVBD_WHEELFORWARD) ? TVE_EXPAND : TVE_COLLAPSE, hItem, TRUE);
                else
                    TV_Expand(pTree, TVE_TOGGLE, hItem, TRUE);
            }
        }
        else if (wHitCode & TVHT_ONITEM ||
                ((pTree->ci.style & TVS_FULLROWSELECT) && (wHitCode & (TVHT_ONITEMRIGHT | TVHT_ONITEMINDENT))))
        {
            BOOL fSameItem, bDragging;

            ASSERT(hItem);

            fSameItem = (hItem == pTree->hCaret);

            if (TVBD_flags & TVBD_FROMWHEEL)
                bDragging = FALSE;
            else if (pTree->ci.style & TVS_DISABLEDRAGDROP)
                bDragging = FALSE;
            else {
                bDragging = TV_CheckForDragBegin(pTree, hItem, x, y);
                TV_FinishCheckDrag(pTree);
            }

            if (bDragging)
            {
                pTree->htiDrag = hItem;
                TV_SendBeginDrag(pTree, TVN_BEGINDRAG, hItem, x, y);
                return;
            }

            if (!CCSendNotify(&pTree->ci, NM_CLICK, NULL)) {

                if (wHitCode == TVHT_ONITEMSTATEICON &&
                    (pTree->ci.style & TVS_CHECKBOXES)) {
                    TV_HandleStateIconClick(pTree, hItem);
                } else {

                    // Only set the caret (selection) if not dragging
                    TV_SelectItem(pTree, TVGN_CARET, hItem, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_BYMOUSE);

                    if (fSameItem && (wHitCode & TVHT_ONITEMLABEL) && pTree->fFocus)
                    {
                        //
                        // The item and window are currently selected and user clicked
                        // on label.  Try to enter into name editing mode.
                        //
                        SetTimer(pTree->ci.hwnd, IDT_NAMEEDIT, GetDoubleClickTime(), NULL);
                        pTree->fNameEditPending = TRUE;
                    }

                    if (fSameItem && pTree->ci.style & TVS_SINGLEEXPAND) {
                        // single click on the focus item toggles expand state
                        TV_Expand(pTree, TVE_TOGGLE, pTree->hCaret, TRUE);
                    }
                }
            }
        } else {
            CCSendNotify(&pTree->ci, NM_CLICK, NULL);
        }
    }

    if (!pTree->fFocus)
        SetFocus(pTree->ci.hwnd);

bail:;
}


// ----------------------------------------------------------------------------
//
//  Gets the item's text, data, and/or image.
//
// ----------------------------------------------------------------------------
BOOL NEAR TV_OnGetItem(PTREE pTree, LPTVITEMEX ptvi)
{
    if (!ptvi)
        return FALSE;

    if (!ValidateTreeItem(ptvi->hItem, 0))
        return FALSE;           // Invalid parameter

    TV_GetItem(pTree, ptvi->hItem, ptvi->mask, ptvi);

    return TRUE;        // success
}

#ifdef UNICODE
BOOL NEAR TV_OnGetItemA(PTREE pTree, LPTVITEMEXA ptvi)
{
    BOOL bRet;
    LPSTR pszA = NULL;
    LPWSTR pszW = NULL;

    //HACK Alert!  This code assumes that TVITEMA is exactly the same
    // as TVITEMW except for the text pointer in the TVITEM
    ASSERT(sizeof(TVITEMA) == sizeof(TVITEMW));

    if (!IsFlagPtr(ptvi) && (ptvi->mask & TVIF_TEXT) && !IsFlagPtr(ptvi->pszText)) {
        pszA = ptvi->pszText;
        pszW = LocalAlloc(LMEM_FIXED, ptvi->cchTextMax * sizeof(WCHAR));
        if (pszW == NULL) {
            return FALSE;
        }
        ptvi->pszText = (LPSTR)pszW;
    }
    bRet = TV_OnGetItem(pTree, (LPTVITEMEXW)ptvi);
    if (pszA) {
        if (bRet && ptvi->cchTextMax)
            ConvertWToAN(pTree->ci.uiCodePage, pszA, ptvi->cchTextMax, (LPWSTR)(ptvi->pszText), -1);
        LocalFree(pszW);
        ptvi->pszText = pszA;
    }
    return bRet;
}
#endif

// ----------------------------------------------------------------------------
//
//  Sets the item's text, data, and/or image.
//
// ----------------------------------------------------------------------------

#ifdef UNICODE
BOOL NEAR TV_SetItemA(PTREE pTree, LPTVITEMEXA ptvi)
{
    LPSTR pszA = NULL;
    BOOL lRet;

    //HACK Alert!  This code assumes that TVITEMA is exactly the same
    // as TVITEMW except for the text pointer in the TVITEM
    ASSERT(sizeof(TVITEMA) == sizeof(TVITEMW));

    if (!IsFlagPtr(ptvi) && (ptvi->mask & TVIF_TEXT) && !IsFlagPtr(ptvi->pszText)) {
        pszA = ptvi->pszText;
        ptvi->pszText = (LPSTR)ProduceWFromA(pTree->ci.uiCodePage, pszA);

        if (ptvi->pszText == NULL) {
            ptvi->pszText = pszA;
            return -1;
        }
    }

    lRet = TV_SetItem(pTree, (LPCTVITEMEX)ptvi);

    if (pszA) {
        FreeProducedString(ptvi->pszText);
        ptvi->pszText = pszA;
    }

    return lRet;
}
#endif

BOOL NEAR TV_SetItem(PTREE pTree, LPCTVITEMEX ptvi)
{
    UINT uRDWFlags = RDW_INVALIDATE;
    BOOL fEraseIfTransparent = FALSE;
    HTREEITEM hItem;
    BOOL bActualChange = FALSE; // HACK: We want to keep track of which
                                // attributes were changed from CALLBACK to
                                // "real", and don't invalidate if those were
                                // the only changes
    int iIntegralPrev;
    BOOL fName = FALSE;
    BOOL fFocusSel = FALSE;
    BOOL fRecalcWidth = FALSE;
    BOOL fStateImageChange = FALSE;

    if (!ptvi)
        return FALSE;

    hItem = ptvi->hItem;

    // deal with the evil invisible root for multiple root trees.
    if (hItem == TVI_ROOT)
    {
        hItem = pTree->hRoot;
    }

    if (!ValidateTreeItem(hItem, 0))
        return FALSE;

    iIntegralPrev = hItem->iIntegral;

    // BUGBUG: send ITEMCHANING and ITEMCHANGED msgs

    if (ptvi->mask & TVIF_TEXT)
    {
        uRDWFlags = RDW_INVALIDATE |RDW_ERASE;
        bActualChange = TRUE;

        if (!ptvi->pszText)
        {
            Str_Set(&hItem->lpstr, LPSTR_TEXTCALLBACK);
        }
        else
        {
            if (!Str_Set(&hItem->lpstr, ptvi->pszText))
            {
                //
                // Memory allocation failed -  The best we can do now
                // is to set the item back to callback, and hope that
                // the top level program can handle it.
                //
                DebugMsg(DM_ERROR, TEXT("TreeView: Out of memory"));
                hItem->lpstr = LPSTR_TEXTCALLBACK;
            }
        }

        fRecalcWidth = TRUE;
        fName = TRUE;
    }

    if (ptvi->mask & TVIF_PARAM)
    {
        bActualChange = TRUE;
        hItem->lParam = ptvi->lParam;
    }

    if (ptvi->mask & TVIF_IMAGE)
    {
        if (hItem->iImage != (WORD)I_IMAGECALLBACK) {
            bActualChange = TRUE;
            fEraseIfTransparent = TRUE;
            if (pTree->hImageList && (ImageList_GetBkColor(pTree->hImageList) == (COLORREF)-1))
                uRDWFlags |= RDW_ERASE;

        }
        hItem->iImage = (SHORT)ptvi->iImage;
    }

    if (ptvi->mask & TVIF_SELECTEDIMAGE)
    {
        if (hItem->iSelectedImage != (WORD)I_IMAGECALLBACK)
            bActualChange = TRUE;
        hItem->iSelectedImage = (SHORT)ptvi->iSelectedImage;
    }

    if (ptvi->mask & TVIF_CHILDREN)
    {
        if (hItem->fKids != KIDS_CALLBACK)
            bActualChange = TRUE;

        if (ptvi->cChildren == I_CHILDRENCALLBACK) {
            hItem->fKids = KIDS_CALLBACK;
        } else {
            if (ptvi->cChildren)
                hItem->fKids = KIDS_FORCE_YES;
            else
                hItem->fKids = KIDS_FORCE_NO;
        }

        //
        // If this item currently has no kid, reset the item.
        //
        if ((ptvi->cChildren == I_CHILDRENCALLBACK) && (hItem->hKids == NULL))
        {
            hItem->state &= ~TVIS_EXPANDEDONCE;
            if (hItem->hParent)
                hItem->state &= ~TVIS_EXPANDED;
        }
    }

    if (ptvi->mask & TVIF_INTEGRAL)
    {
        if (LOWORD(ptvi->iIntegral) > 0)
            hItem->iIntegral = LOWORD(ptvi->iIntegral);
    }

    if (ptvi->mask & TVIF_STATE)
    {
        // don't & ptvi->state with TVIS_ALL because win95 didn't
        // and setting TVIS_FOCUS was retrievable even though we don't use it
        UINT change = (hItem->state ^ ptvi->state) & ptvi->stateMask;

        if (change)
        {
            // BUGBUG: (TVIS_SELECTED | TVIS_DROPHILITED) changes
            // should effect tree state
            hItem->state ^= change;
            bActualChange = TRUE;
            fEraseIfTransparent = TRUE;

            if (hItem->state & TVIS_BOLD) {
                if (!pTree->hFontBold)
                    TV_CreateBoldFont(pTree);
             }

            if (change & TVIS_BOLD){
                // do this because changing the boldness
                uRDWFlags |= RDW_ERASE;
                fRecalcWidth = TRUE;
            }

            fStateImageChange = change & TVIS_STATEIMAGEMASK;
            if (fStateImageChange) {
                uRDWFlags |= RDW_ERASE;
                // Adding/removing a state image changes the ITEM_OFFSET
                // If old image was 0, then we are adding.
                // If new image is 0, then we are removing.
                // (If old=new, then we don't get into this code path, so we
                // don't have to worry about that case.)
                if (!(hItem->state & TVIS_STATEIMAGEMASK) || // new
                    !((hItem->state ^ change) & TVIS_STATEIMAGEMASK)) { // old
                    fRecalcWidth = TRUE;
                }
            }

            fFocusSel = ((change & TVIS_SELECTED) != 0);
        }
    }

    if (fRecalcWidth) {
        hItem->iWidth = 0;          // Invalidate old width
        if (TV_IsShowing(hItem)) {
            TV_ScrollBarsAfterSetWidth(pTree, hItem);
        }
    }

    // force a redraw if something changed AND if we are not
    // inside of a paint of this guy (callbacks will set the
    // item on the paint callback to implement lazy data schemes)

    if (bActualChange && (pTree->hItemPainting != hItem))
    {
        if (fEraseIfTransparent) {
            if (pTree->hImageList) {
                if (ImageList_GetBkColor(pTree->hImageList) == CLR_NONE) {
                    uRDWFlags |= RDW_ERASE;
                }
            }

        }

        // If item height changed, then we've got a lot of cleaning up
        // to do.
        if (hItem->iIntegral != iIntegralPrev)
        {
            TV_ScrollBarsAfterResize(pTree, hItem, iIntegralPrev, uRDWFlags);
        }
        else
        {
            TV_InvalidateItem(pTree, hItem, uRDWFlags);
        }

        // REVIEW: we might need to update the scroll bars if the
        // text length changed!
    }

    if (bActualChange)
    {
        if (fName)
            MyNotifyWinEvent(EVENT_OBJECT_NAMECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);

        if (fFocusSel)
        {
            MyNotifyWinEvent(EVENT_OBJECT_FOCUS, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
            MyNotifyWinEvent(((hItem->state & TVIS_SELECTED) ?
                EVENT_OBJECT_SELECTIONADD : EVENT_OBJECT_SELECTIONREMOVE),
                pTree->ci.hwnd, OBJID_CLIENT, (LONG_PTR)hItem);
        }

        if (fStateImageChange)
            MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, pTree->ci.hwnd, OBJID_CLIENT,
                (LONG_PTR)hItem);
    }
    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Calls TV_CheckHit to get the hit test results and then package it in a
//  structure back to the app.
//
// ----------------------------------------------------------------------------

HTREEITEM NEAR TV_OnHitTest(PTREE pTree, LPTV_HITTESTINFO lptvh)
{
    if (!lptvh)
        return 0; //BUGBUG: Validate LPTVHITTEST

    lptvh->hItem = TV_CheckHit(pTree, lptvh->pt.x, lptvh->pt.y, &lptvh->flags);

    return lptvh->hItem;
}

BOOL TV_IsItemTruncated(PTREE pTree, TREEITEM *hItem, LPRECT lprc)
{
    if (TV_GetItemRect(pTree,hItem,lprc,TRUE)) {
        lprc->left -= g_cxEdge;
        lprc->top -= g_cyBorder;
        if ((lprc->left + hItem->iWidth) > pTree->cxWnd) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL TV_HandleTTNShow(PTREE pTree, LPNMHDR lpnm)
{
    if (pTree->hToolTip && pTree->fPlaceTooltip) {
        LPNMTTSHOWINFO psi = (LPNMTTSHOWINFO)lpnm;
        RECT rc;
        TVITEMEX item;

        // Now get the text associated with that item
        item.stateMask = TVIS_BOLD;
        TV_GetItem(pTree, pTree->hToolTip, TVIF_STATE, &item);
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)((item.state & TVIS_BOLD) ? pTree->hFontBold : pTree->hFont), 0);

        TV_GetItemRect(pTree, pTree->hToolTip, &rc, TRUE);

        MapWindowRect(pTree->ci.hwnd, HWND_DESKTOP, &rc);
        // We draw the text with margins, so take those into account too.
        // These values come from TV_DrawItem...
        rc.top += g_cyBorder;
        rc.left += g_cxLabelMargin;

        //
        //  At this point, (rc.left, rc.top) are the coordinates we pass
        //  to DrawText.  Ask the tooltip how we should position it so the
        //  tooltip text shows up in precisely the same location.
        //
        // BUGBUG raymondc v6: wrong coordinates if app has used TVM_SETITEMHEIGHT

        SendMessage(pTree->hwndToolTips, TTM_ADJUSTRECT, TRUE, (LPARAM)&rc);
        SetWindowPos(pTree->hwndToolTips, NULL, rc.left, rc.top,0,0,
                     SWP_NOACTIVATE|SWP_NOSIZE|SWP_NOZORDER);
        // This is an inplace tooltip, so disable animation.
        psi->dwStyle |= TTS_NOANIMATE;
        // handled!
        return TRUE;
    }

    return FALSE;
}

//
//  Copy the font from the treeview item into the tooltip so the tooltip
//  shows up in the correct font.
//
BOOL TV_HandleTTCustomDraw(PTREE pTree, LPNMTTCUSTOMDRAW pnm)
{
    if (pTree->hToolTip && pTree->fPlaceTooltip &&
        (pnm->nmcd.dwDrawStage == CDDS_PREPAINT ||
         pnm->nmcd.dwDrawStage == CDDS_ITEMPREPAINT))
    {
        //
        //  Set up the customdraw DC to match the font of the TV item.
        //
        TVFAKEDRAW tvfd;
        DWORD dwCustom = 0;
        TreeView_BeginFakeCustomDraw(pTree, &tvfd);
        dwCustom = TreeView_BeginFakeItemDraw(&tvfd, pTree->hToolTip);

        // If client changed the font, then transfer the font
        // from our private hdc into the tooltip's HDC.  We use
        // a private HDC because we only want to let the app change
        // the font, not the colors or anything else.
        if (dwCustom & CDRF_NEWFONT)
        {
            SelectObject(pnm->nmcd.hdc, GetCurrentObject(tvfd.nmcd.nmcd.hdc, OBJ_FONT));
        }
        TreeView_EndFakeItemDraw(&tvfd);
        TreeView_EndFakeCustomDraw(&tvfd);

        // Don't return other wacky flags to TT, since all we
        // did was change the font (if even that)
        return dwCustom & CDRF_NEWFONT;

    }
    return CDRF_DODEFAULT;

}

BOOL TV_SetToolTipTarget(PTREE pTree, HTREEITEM hItem)
{
    // update the item we're showing the bubble for...
    if (pTree->hToolTip != hItem) {
        // the hide will keep us from flashing
        ShowWindow(pTree->hwndToolTips, SW_HIDE);
        UpdateWindow(pTree->hwndToolTips);
        pTree->hToolTip = hItem;
        SendMessage(pTree->hwndToolTips, TTM_UPDATE, 0, 0);
        return TRUE;
    }
    return FALSE;
}

TREEITEM* TV_ItemAtCursor(PTREE pTree, LPRECT prc)
{
    RECT rc;
    UINT wHitCode;
    TREEITEM* hItem;

    GetCursorPos((LPPOINT)&rc);
    ScreenToClient(pTree->ci.hwnd, (LPPOINT)&rc);
    hItem = TV_CheckHit(pTree,rc.left,rc.top,&wHitCode);

    if (prc)
        *prc = rc;
    if (!(wHitCode & TVHT_ONITEM))
        hItem = NULL;

    return hItem;
}

BOOL TV_UpdateToolTipTarget(PTREE pTree)
{
    RECT rc;
    TREEITEM *hItem = TV_ItemAtCursor(pTree, &rc);

    if (!(pTree->ci.style & TVS_NOTOOLTIPS) 
            && !TV_IsItemTruncated(pTree, hItem, &rc)
            && !(pTree->ci.style & TVS_INFOTIP))
        hItem = NULL;
//    else if (!(pTree->ci.style & TVS_NOTOOLTIPS)
//                    || (pTree->ci.style & TVS_INFOTIP))
    return TV_SetToolTipTarget(pTree, hItem);
}

BOOL TV_UpdateToolTip(PTREE pTree)
{
    if (pTree->hwndToolTips && pTree->fRedraw)
       return (TV_UpdateToolTipTarget(pTree));
    return TRUE;
}

BOOL TV_SetInsertMark(PTREE pTree, HTREEITEM hItem, BOOL fAfter)
{
    if (!ValidateTreeItem(hItem, VTI_NULLOK))   // NULL means remove insert mark
        return FALSE;

    TV_InvalidateInsertMarkRect(pTree, TRUE); // Make sure the old one gets erased

    pTree->fInsertAfter = BOOLIFY(fAfter);
    pTree->htiInsert = hItem;

    TV_InvalidateInsertMarkRect(pTree, FALSE); // Make sure the new one gets drawn

    return TRUE;
}

BOOL TV_GetInfoTip(PTREE pTree, LPTOOLTIPTEXT lpttt, HTREEITEM hti, LPTSTR szBuf, int cch)
{
    NMTVGETINFOTIP git;

    szBuf[0] = 0;
    git.pszText = szBuf;
    git.cchTextMax = cch;
    git.hItem = hti;
    git.lParam = hti->lParam;

    // for folded items pszText is prepopulated with the
    // item text, clients should append to this

    CCSendNotify(&pTree->ci, TVN_GETINFOTIP, &git.hdr);

    CCSetInfoTipWidth(pTree->ci.hwnd, pTree->hwndToolTips);
    Str_Set(&pTree->pszTip, git.pszText);
    lpttt->lpszText = pTree->pszTip;
#ifdef WINDOWS_ME
    if(pTree->ci.style & TVS_RTLREADING){
    lpttt->uFlags |= TTF_RTLREADING;
    }
#endif // WINDOWS_ME
    return lpttt->lpszText && lpttt->lpszText[0];
}




void TV_HandleNeedText(PTREE pTree, LPTOOLTIPTEXT lpttt)
{
    TVITEMEX tvItem;
    TCHAR szBuf[INFOTIPSIZE];
    RECT rc;
    HTREEITEM hItem;

    // No distracting tooltips while in-place editing, please
    if (pTree->htiEdit)
    {
        return;
    }

    // If the cursor isn't over anything, then stop
    hItem = TV_ItemAtCursor(pTree, &rc);
    if (!hItem)
        return;

    // If the item has an infotip, then use it
    if (pTree->ci.style & TVS_INFOTIP) {
        if (hItem && TV_GetInfoTip(pTree, lpttt, hItem, szBuf, ARRAYSIZE(szBuf))) {
            pTree->fPlaceTooltip = FALSE;
            pTree->hToolTip = hItem;
            return;
        }
    }

    // Else it isn't an infotip
    CCResetInfoTipWidth(pTree->ci.hwnd, pTree->hwndToolTips);

    // If the item is not truncated, then no need for a tooltip
    if (!TV_IsItemTruncated(pTree, hItem, &rc))
    {
        tvItem.hItem = NULL;
        return;
    }

    // Display an in-place tooltip for the item
    pTree->fPlaceTooltip = TRUE;
    pTree->hToolTip = hItem;
    tvItem.hItem = hItem;
    tvItem.mask = TVIF_TEXT | TVIF_STATE;
    tvItem.pszText = szBuf;
    tvItem.stateMask = TVIS_DROPHILITED | TVIS_SELECTED;
    COMPILETIME_ASSERT(MAXLABELTEXT <= ARRAYSIZE(szBuf));
    tvItem.cchTextMax = MAXLABELTEXT;
    TV_OnGetItem(pTree,&tvItem);

    Str_Set(&pTree->pszTip, tvItem.pszText);
    lpttt->lpszText = pTree->pszTip;
    DebugMsg(DM_TRACE, TEXT("TV_HandleNeedText for %d returns %s"), tvItem.hItem, lpttt->szText);
}

#ifdef UNICODE
//
//  Visual Studio 5.0 Books Online (part of VB 5.0) subclasses
//  us and responds NFR_ANSI, so we end up getting TTN_NEEDTEXTA
//  instead of TTN_NEEDTEXTW.  We can't risk forcing the tooltip
//  to UNICODE because some other apps may have done this on purpose
//  (because they intend to intercept TTN_NEEDTEXTA and do custom tooltips).
//  So support the ANSI tooltip notification so VB stays happy.
//  Note: This doesn't have to be efficient, as it's an error case anyway.
//
void TV_HandleNeedTextA(PTREE pTree, LPTOOLTIPTEXTA lptttA)
{
    TOOLTIPTEXT ttt;
    ttt.szText[0] = TEXT('\0');
    ttt.hdr       = lptttA->hdr;
    ttt.lpszText  = ttt.szText;
    ttt.hinst     = lptttA->hinst;
    ttt.uFlags    = lptttA->uFlags;
    ttt.lParam    = lptttA->lParam;

    TV_HandleNeedText(pTree, &ttt);
    if (pTree->pszTipA)
        LocalFree(pTree->pszTipA);
    pTree->pszTipA = ProduceAFromW(pTree->ci.uiCodePage, ttt.lpszText);
    lptttA->lpszText = pTree->pszTipA;
    lptttA->uFlags  = ttt.uFlags;
}
#endif

// ----------------------------------------------------------------------------
//
//  TV_Timer
//
//  Checks to see if it is our name editing timer.  If so it  calls of to
//  do name editing
//
// ----------------------------------------------------------------------------
LRESULT NEAR TV_Timer(PTREE pTree, UINT uTimerId)
{
    switch (uTimerId)
    {
        case IDT_NAMEEDIT:
            // Kill the timer as we wont need any more messages from it.
            KillTimer(pTree->ci.hwnd, IDT_NAMEEDIT);

            if (pTree->fNameEditPending)
            {
                // And start name editing mode.
                if (!TV_EditLabel(pTree, pTree->hCaret, NULL))
                {
                    TV_DismissEdit(pTree, FALSE);
                }

                // remove the flag...
                pTree->fNameEditPending = FALSE;
            }
            break;
            
        case IDT_SCROLLWAIT:
            KillTimer(pTree->ci.hwnd, IDT_SCROLLWAIT);
            if (pTree->fScrollWait)
            {
                if (pTree->hCaret) {
                    TV_ScrollVertIntoView(pTree, pTree->hCaret);
                }
                pTree->fScrollWait = FALSE;
            }
            break;


    }
    return 0;
}

// ----------------------------------------------------------------------------
//
//  TV_Command
//
//  Process the WM_COMMAND.  See if it is an input from our edit windows.
//  if so we may want to dismiss it, and or set it is being dirty...
//
// ----------------------------------------------------------------------------
void NEAR TV_Command(PTREE pTree, int id, HWND hwndCtl, UINT codeNotify)
{
    if ((pTree != NULL) && (hwndCtl == pTree->hwndEdit))
    {
        switch (codeNotify)
        {
        case EN_UPDATE:
            // We will use the ID of the window as a Dirty flag...
            SetWindowID(pTree->hwndEdit, 1);
            TV_SetEditSize(pTree);
            break;

        case EN_KILLFOCUS:
            // We lost focus, so dismiss edit and save changes
            // (Note that the owner might reject the change and restart
            // edit mode, which traps the user.  Owners need to give the
            // user a way to get out.)

#if 0       // BUGBUG raymondc v6.0
            //
            //  Fix horrible undocumented hanging problem:  LVN_ENDLABELEDIT
            //  is sent in response to EN_KILLFOCUS, which is send in response
            //  to WM_KILLFOCUS, and it is undocumented that you cannot display
            //  UI during WM_KILLFOCUS when a journal record hook is active,
            //  because the presence of a hook forces serialization of activation,
            //  and so when you put up UI, you generate activation changes, which
            //  get stuck because you haven't finished responding to the previous
            //  WM_KILLFOCUS message yet.
            //
            //  See NT bug 414634.
            //
            if (InSendMessage())
                ReplyMessage(0);
#endif

            if (!TV_DismissEdit(pTree, FALSE))
               return;
            break;

        case HN_BEGINDIALOG: // penwin is bringing up a dialog
            ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
            pTree->fNoDismissEdit = TRUE;
            break;

        case HN_ENDDIALOG: // penwin has destroyed dialog
            ASSERT(GetSystemMetrics(SM_PENWINDOWS)); // only on a pen system
            pTree->fNoDismissEdit = FALSE;
            break;
        }

        // Forward edit control notifications up to parent
        //
        if (IsWindow(hwndCtl))
            FORWARD_WM_COMMAND(pTree->ci.hwndParent, id, hwndCtl, codeNotify, SendMessage);
    }
}

HIMAGELIST CreateCheckBoxImagelist(HIMAGELIST himl, BOOL fTree, BOOL fUseColorKey, BOOL fMirror);
void TV_CreateToolTips(PTREE pTree);

void TV_InitCheckBoxes(PTREE pTree)
{
    HIMAGELIST himl;
    TVITEMEX ti;
    BOOL fNoColorKey = FALSE;    // Backwards: If Cleartype is turned on, then we don't use colorkey.

    if (g_bRunOnNT5)
    {
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fNoColorKey, 0);
#endif
    }

    himl = CreateCheckBoxImagelist(pTree->hImageList, TRUE, !fNoColorKey, IS_WINDOW_RTL_MIRRORED(pTree->ci.hwnd));
    if (pTree->hImageList) 
    {
        COLORREF cr = ImageList_GetBkColor(pTree->hImageList);
        ImageList_SetBkColor(himl, fNoColorKey? (CLR_NONE) : (cr));
    }

    TV_SetImageList(pTree, himl, TVSIL_STATE);

    ti.mask = TVIF_STATE;
    ti.state = INDEXTOSTATEIMAGEMASK(1);
    ti.stateMask = TVIS_STATEIMAGEMASK;
    TV_SetItemRecurse(pTree, pTree->hRoot, &ti);
}

void NEAR TV_OnStyleChanged(PTREE pTree, WPARAM gwl, LPSTYLESTRUCT pinfo)
{
    // Style changed: redraw everything...
    //
    // try to do this smartly, avoiding unnecessary redraws
    if (gwl == GWL_STYLE)
    {
        DWORD changeFlags;
        DWORD styleNew;

        TV_DismissEdit(pTree, FALSE);   // BUGBUG:  FALSE == accept changes.  Is this right?

        // You cannot combine TVS_HASLINES and TVS_FULLROWSELECT
        // because it doesn't work
        styleNew = pinfo->styleNew;
        if (styleNew & TVS_HASLINES) {
            if (styleNew & TVS_FULLROWSELECT) {
                DebugMsg(DM_ERROR, TEXT("Cannot combine TVS_HASLINES and TVS_FULLROWSELECT"));
            }
            styleNew &= ~TVS_FULLROWSELECT;
        }

        changeFlags = pTree->ci.style ^ styleNew; // those that changed
        pTree->ci.style = styleNew;               // change our version

#ifdef WINDOWS_ME
        pTree->ci.style &= ~TVS_RTLREADING;
        pTree->ci.style |= (pinfo->styleNew & TVS_RTLREADING);       
#endif

        if (changeFlags & (TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT))
            TV_CreateIndentBmps(pTree);

        if (changeFlags & TVS_CHECKBOXES) {
            if (pTree->ci.style & TVS_CHECKBOXES) {
                TV_InitCheckBoxes(pTree);
            }
        }

        if (changeFlags & TVS_NOTOOLTIPS) {
            if (pTree->ci.style & TVS_NOTOOLTIPS) {
                DestroyWindow(pTree->hwndToolTips);
                pTree->hwndToolTips = NULL;
            } else {
                TV_CreateToolTips(pTree);
            }
        }

        if (changeFlags & TVS_TRACKSELECT) {
            if (!(pTree->ci.style & TVS_TRACKSELECT)) {
                if (pTree->hHot) {
                    TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE | RDW_ERASE);
                    pTree->hHot = NULL;
                }
            }
        }
        // Checkboxes and stuff may have changed width - go recompute
        TV_ScrollBarsAfterSetWidth(pTree, NULL);
    }
#ifdef WINDOWS_ME
    else if (gwl == GWL_EXSTYLE)
    {
        DWORD changeFlags;
        changeFlags = (pinfo->styleNew & WS_EX_RTLREADING) ?TVS_RTLREADING :0;

        if (changeFlags ^ (pTree->ci.style & TVS_RTLREADING))
        {
            pTree->ci.style ^= TVS_RTLREADING;
            TV_DismissEdit(pTree, FALSE);   // Cancels edits

            DestroyWindow(pTree->hwndToolTips);
            pTree->hwndToolTips = NULL;
            TV_CreateToolTips(pTree);
        }
    }
#endif

}

void TV_OnMouseMove(PTREE pTree, DWORD dwPos, WPARAM wParam)
{
    if (pTree->ci.style & TVS_TRACKSELECT) {
        POINT pt;
        HTREEITEM hHot;
        UINT wHitCode;

        pt.x = GET_X_LPARAM(dwPos);
        pt.y = GET_Y_LPARAM(dwPos);

        hHot = TV_CheckHit(pTree,pt.x,pt.y,&wHitCode);

        if (!(pTree->ci.style & TVS_FULLROWSELECT) &&
            !(wHitCode & TVHT_ONITEM)) {
            hHot = NULL;
        }

        if (hHot != pTree->hHot) {
            TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE);
            TV_InvalidateItem(pTree, hHot, RDW_INVALIDATE);
            pTree->hHot = hHot;
            // update now so that we won't have an invalid area
            // under the tooltips
            UpdateWindow(pTree->ci.hwnd);
        }
    }

    if (pTree->hwndToolTips) {

        if (!TV_UpdateToolTip(pTree)) {
            RelayToToolTips(pTree->hwndToolTips, pTree->ci.hwnd, WM_MOUSEMOVE, wParam, dwPos);
        }
    }
}

void NEAR TV_OnWinIniChange(PTREE pTree, WPARAM wParam)
{
    if (!wParam ||
        (wParam == SPI_SETNONCLIENTMETRICS) ||
        (wParam == SPI_SETICONTITLELOGFONT)) {

        if (pTree->fCreatedFont)
            TV_OnSetFont(pTree, NULL, TRUE);

        if (!pTree->fIndentSet) {
            // this will validate against the minimum
            TV_SetIndent(pTree, 0);
        }
    }
}

void TV_OnSetBkColor(PTREE pTree, COLORREF clr)
{
    if (pTree->clrBk != (COLORREF)-1) {
        DeleteObject(pTree->hbrBk);
    }

    pTree->clrBk = clr;
    if (clr != (COLORREF)-1) {
        pTree->hbrBk = CreateSolidBrush(clr);
    }
    TV_CreateIndentBmps(pTree); // This also invalidates
}

BOOL TV_TranslateAccelerator(HWND hwnd, LPMSG lpmsg)
{
    if (!lpmsg)
        return FALSE;

    if (GetFocus() != hwnd)
        return FALSE;

    switch (lpmsg->message) {

    case WM_KEYUP:
    case WM_KEYDOWN:

        if (GetKeyState(VK_CONTROL) < 0) {
            switch (lpmsg->wParam) {
            case VK_LEFT:
            case VK_RIGHT:
            case VK_PRIOR:
            case VK_HOME:
            case VK_NEXT:
            case VK_END:
            case VK_UP:
            case VK_DOWN:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                return TRUE;
            }
        } else {

            switch (lpmsg->wParam) {

            case VK_RETURN:
            case VK_PRIOR:
            case VK_HOME:
            case VK_NEXT:
            case VK_END:
            case VK_SUBTRACT:
            case VK_ADD:
            case VK_MULTIPLY:
            case VK_LEFT:
            case VK_BACK:
            case VK_UP:
            case VK_RIGHT:
            case VK_DOWN:
            case VK_SPACE:
                TranslateMessage(lpmsg);
                DispatchMessage(lpmsg);
                return TRUE;
            }
        }
        break;
    }

    return FALSE;
}

// ----------------------------------------------------------------------------
//
//  TV_WndProc
//
//  Take a guess.
//
// ----------------------------------------------------------------------------

LRESULT CALLBACK TV_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PTREE pTree = (PTREE)GetWindowPtr(hwnd, 0);

    if (pTree) 
    {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (pTree->ci.style & TVS_TRACKSELECT) && !pTree->fTrackSet) 
        {

            TRACKMOUSEEVENT tme;

            pTree->fTrackSet = TRUE;
            tme.cbSize = sizeof(tme);
            tme.hwndTrack = pTree->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
        else if (uMsg == g_uDragImages)
        {
            return TV_GenerateDragImage(pTree, (SHDRAGIMAGE*)lParam);
        }

    } 
    else 
    {
        if (uMsg == WM_CREATE) 
        {
            CCCreateWindow();
            return TV_OnCreate(hwnd, (LPCREATESTRUCT)lParam);
        }

        goto DoDefault;
    }



    switch (uMsg)
    {
        case WM_MOUSELEAVE:
            pTree->fTrackSet = FALSE;
            TV_InvalidateItem(pTree, pTree->hHot, RDW_INVALIDATE);
            pTree->hHot = NULL;
            TV_PopBubble(pTree);
            break;
            
        case TVMP_CALCSCROLLBARS:
            TV_CalcScrollBars(pTree);
            break;
            

        case TVM_GETITEMSTATE:
            {
                TVITEMEX tvi;

                tvi.mask = TVIF_STATE;
                tvi.stateMask = (UINT) lParam;
                tvi.hItem = (HTREEITEM)wParam;
                if (!TV_OnGetItem(pTree, &tvi))
                    return 0;

                return tvi.state;
            }
            
        case TVM_SETBKCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrBk;
            TV_OnSetBkColor(pTree, (COLORREF)lParam);
            return lres;
        }

        case TVM_SETTEXTCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrText;
            pTree->clrText = (COLORREF)lParam;
            TV_CreateIndentBmps(pTree); // This also invalidates
            return lres;
        }

        case TVM_GETBKCOLOR:
            return (LRESULT)pTree->clrBk;

        case TVM_GETTEXTCOLOR:
            return (LRESULT)pTree->clrText;

        case TVM_GETSCROLLTIME:
            return (LRESULT)pTree->uMaxScrollTime;

        case TVM_SETSCROLLTIME:
        {
            UINT u = pTree->uMaxScrollTime;
            pTree->uMaxScrollTime = (UINT)wParam;
            return (LRESULT)u;
        }


#ifdef UNICODE
        case TVM_INSERTITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_InsertItemA(pTree, (LPTV_INSERTSTRUCTA)lParam);

        case TVM_GETITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_OnGetItemA(pTree, (LPTVITEMEXA)lParam);

        case TVM_SETITEMA:
            if (!lParam)
                return 0;

            return (LRESULT)TV_SetItemA(pTree, (LPTVITEMEXA)lParam);

#endif
        case TVM_INSERTITEM:
            return (LRESULT)TV_InsertItem(pTree, (LPTV_INSERTSTRUCT)lParam);

        case TVM_DELETEITEM:
            // Assume if items are being deleted that name editing is invalid.
            TV_DismissEdit(pTree, TRUE);
            return TV_DeleteItem(pTree, (TREEITEM FAR *)lParam, TVDI_NORMAL);

        case TVM_GETNEXTITEM:
            return (LRESULT)TV_GetNextItem(pTree, (TREEITEM FAR *)lParam, wParam);

        case TVM_GETITEMRECT:
            // lParam points to hItem to get rect from on input
            if (!lParam)
                return 0;
            if (!ValidateTreeItem(*(HTREEITEM FAR *)lParam, 0))
                return 0;               // Invalid parameter
            return (LRESULT)TV_GetItemRect(pTree, *(HTREEITEM FAR *)lParam, (LPRECT)lParam, (BOOL)wParam);

        case TVM_GETITEM:
            return (LRESULT)TV_OnGetItem(pTree, (LPTVITEMEX)lParam);

        case TVM_SETITEM:
            return (LRESULT)TV_SetItem(pTree, (LPCTVITEMEX)lParam);

        case TVM_ENSUREVISIBLE:
            if (!ValidateTreeItem((HTREEITEM)lParam, 0))
                return 0;
            return TV_EnsureVisible(pTree, (TREEITEM FAR *)lParam);

        case TVM_SETIMAGELIST:
            return (LRESULT)(ULONG_PTR)TV_SetImageList(pTree, (HIMAGELIST)lParam, (int)wParam);

        case TVM_EXPAND:
            if (!ValidateTreeItem((HTREEITEM)lParam, 0))
                return FALSE;               // invalid parameter
            return TV_Expand(pTree, wParam, (TREEITEM FAR *)lParam, FALSE);

        case TVM_HITTEST:
            return (LRESULT)TV_OnHitTest(pTree, (LPTV_HITTESTINFO)lParam);

        case TVM_GETCOUNT:
            return MAKELRESULTFROMUINT(pTree->cItems);

        case TVM_GETIMAGELIST:
            switch (wParam) {
            case TVSIL_NORMAL:
                return MAKELRESULTFROMUINT(pTree->hImageList);
            case TVSIL_STATE:
                return MAKELRESULTFROMUINT(pTree->himlState);
            default:
                return 0;
            }

#ifdef UNICODE
        case TVM_GETISEARCHSTRINGA:
            if (GetFocus() == pTree->ci.hwnd)
                return (LRESULT)GetIncrementSearchStringA(&pTree->is, pTree->ci.uiCodePage, (LPSTR)lParam);
            else
                return 0;
#endif

        case TVM_GETISEARCHSTRING:
            if (GetFocus() == pTree->ci.hwnd)
                return (LRESULT)GetIncrementSearchString(&pTree->is, (LPTSTR)lParam);
            else
                return 0;

#ifdef UNICODE
        case TVM_EDITLABELA:
            {
            LPWSTR lpEditString = NULL;
            HWND   hRet;

            if (wParam) {
                lpEditString = ProduceWFromA(pTree->ci.uiCodePage, (LPSTR)wParam);
            }

            hRet = TV_EditLabel(pTree, (HTREEITEM)lParam, lpEditString);

            if (lpEditString) {
                FreeProducedString(lpEditString);
            }

            return MAKELRESULTFROMUINT(hRet);
            }
#endif

        case TVM_EDITLABEL:
            return MAKELRESULTFROMUINT(TV_EditLabel(pTree, (HTREEITEM)lParam,
                    (LPTSTR)wParam));


        case TVM_GETVISIBLECOUNT:
            return TV_GetVisCount(pTree, (BOOL) wParam);

        case TVM_SETINDENT:
            TV_SetIndent(pTree, wParam);
            pTree->fIndentSet = TRUE;
            break;

        case TVM_GETINDENT:
            return MAKELRESULTFROMUINT(pTree->cxIndent);

        case TVM_CREATEDRAGIMAGE:
            return MAKELRESULTFROMUINT(TV_CreateDragImage(pTree, (TREEITEM FAR *)lParam));

        case TVM_GETEDITCONTROL:
            return (LRESULT)(ULONG_PTR)pTree->hwndEdit;

        case TVM_SORTCHILDREN:
            return TV_SortChildren(pTree, (TREEITEM FAR *)lParam, (BOOL)wParam);

        case TVM_SORTCHILDRENCB:
            return TV_SortChildrenCB(pTree, (TV_SORTCB FAR *)lParam, (BOOL)wParam);

        case TVM_SELECTITEM:
            return TV_SelectItem(pTree, wParam, (TREEITEM FAR *)lParam, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_UNKNOWN);

        case TVM_ENDEDITLABELNOW:
            return TV_DismissEdit(pTree, (BOOL)wParam);

        case TVM_GETTOOLTIPS:
            return (LRESULT)(ULONG_PTR)pTree->hwndToolTips;

        case TVM_SETTOOLTIPS:{
            HWND hwndOld = pTree->hwndToolTips;

            pTree->hwndToolTips = (HWND)wParam;
            return (LRESULT)(ULONG_PTR)hwndOld;
        }

        case TVM_GETITEMHEIGHT:
            return pTree->cyItem;

        case TVM_SETITEMHEIGHT:
        {
            int iOld = pTree->cyItem;
            pTree->fCyItemSet = (wParam != (WPARAM)-1);
            pTree->cyItem = (SHORT)wParam; // must be even
            TV_SetItemHeight(pTree);
            return iOld;
        }
        case TVM_SETBORDER:
        {
            int cyOld = pTree->cyBorder
                , cxOld = pTree->cxBorder;

            if (wParam & TVSBF_YBORDER)
                pTree->cyBorder = HIWORD(lParam);
            if (wParam & TVSBF_XBORDER)
                pTree->cxBorder = LOWORD(lParam);

            TV_CalcScrollBars(pTree);
            return MAKELONG(cxOld, cyOld);
        }
        case TVM_GETBORDER:
            return MAKELONG(pTree->cxBorder, pTree->cyBorder);
        case TVM_SETINSERTMARK:
            return TV_SetInsertMark(pTree, (TREEITEM FAR *)lParam, (BOOL) wParam);
        
        case TVM_SETINSERTMARKCOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrim;
            pTree->clrim = (COLORREF) lParam;
            TV_InvalidateInsertMarkRect(pTree, FALSE); // Repaint in new color
            return lres;
        }
        case TVM_GETINSERTMARKCOLOR:
            return pTree->clrim;

        case TVM_TRANSLATEACCELERATOR:
            return TV_TranslateAccelerator(hwnd, (LPMSG)lParam);

        case TVM_SETLINECOLOR:
        {
            LRESULT lres = (LRESULT)pTree->clrLine;
            pTree->clrLine = (COLORREF)lParam;
            TV_CreateIndentBmps(pTree); // This also invalidates
            return lres;
        }

        case TVM_GETLINECOLOR:
            return (LRESULT)pTree->clrLine;

#if defined(FE_IME) || !defined(WINNT)
        case WM_IME_COMPOSITION:
            // Now only Korean version is interested in incremental search with composition string.
            if (g_fDBCSInputEnabled) {
            if (((ULONG_PTR)GetKeyboardLayout(0L) & 0xF000FFFFL) == 0xE0000412L)
            {
                if (TV_OnImeComposition(pTree, wParam, lParam))
                {
                    lParam &= ~GCS_RESULTSTR;
                    goto DoDefault;
                }
                else
                    break;
            }
            }
            goto DoDefault;
#endif

        case WM_CHAR:
            if (pTree->iPuntChar) {
                pTree->iPuntChar--;
                return TRUE;
            } else {
                return HANDLE_WM_CHAR(pTree, wParam, lParam, TV_OnChar);
            }

        case WM_DESTROY:
            CCDestroyWindow();
            TV_DestroyTree(pTree);
            break;

        case WM_SETCURSOR:
            {
                NMMOUSE nm;
                HTREEITEM hItem;
                nm.dwHitInfo = lParam;
                hItem = TV_ItemAtCursor(pTree, NULL);
                if(hItem)
                {
                    nm.dwItemSpec = (ULONG_PTR)hItem;
                    nm.dwItemData = (ULONG_PTR)(hItem->lParam);
                }
                else
                {
                    nm.dwItemSpec = 0;
                    nm.dwItemData = 0;
                }
                             
#ifdef UNIX
		if (pTree->hwndEdit != (HWND)wParam)
#endif
                if (CCSendNotify(&pTree->ci, NM_SETCURSOR, &nm.hdr)) 
                {
                    return 0;
                }
            }
            if (pTree->ci.style & TVS_TRACKSELECT) {
                if (pTree->hHot) {
                    if (!pTree->hCurHot)
                        pTree->hCurHot = LoadHandCursor(0);
                    SetCursor(pTree->hCurHot);
                    return TRUE;
                }
            }
            goto DoDefault;
            break;

        case WM_WININICHANGE:
            TV_OnWinIniChange(pTree, wParam);
            break;

        case WM_STYLECHANGED:
            TV_OnStyleChanged(pTree, wParam, (LPSTYLESTRUCT)lParam);
            break;

        case WM_SETREDRAW:
            TV_OnSetRedraw(pTree, (BOOL)wParam);
            break;

        case WM_PRINTCLIENT:
        case WM_PAINT:
            TV_Paint(pTree, (HDC)wParam);
            break;

        case WM_ERASEBKGND:
            {
                RECT rc;

                TV_GetBackgroundBrush(pTree, (HDC) wParam);
                GetClipBox((HDC) wParam, &rc);
                FillRect((HDC)wParam, &rc, pTree->hbrBk);
            }
            return TRUE;

        case WM_GETDLGCODE:
            return (LRESULT) (DLGC_WANTARROWS | DLGC_WANTCHARS);

        case WM_HSCROLL:
            TV_HorzScroll(pTree, GET_WM_HSCROLL_CODE(wParam, lParam), GET_WM_HSCROLL_POS(wParam, lParam));
            break;

        case WM_VSCROLL:
            TV_VertScroll(pTree, GET_WM_VSCROLL_CODE(wParam, lParam), GET_WM_VSCROLL_POS(wParam, lParam));
            break;

        case WM_KEYDOWN:
            if (TV_KeyDown(pTree, wParam, lParam))
                IncrementSearchString(&pTree->is, 0, NULL);
                goto DoDefault;


        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONDOWN:
            TV_ButtonDown(pTree, uMsg, (UINT) wParam, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), 0);
            break;

        case WM_KILLFOCUS:
            // Reset wheel scroll amount
            gcWheelDelta = 0;

            pTree->fFocus = FALSE;
            if (pTree->hCaret)
            {
                TV_InvalidateItem(pTree, pTree->hCaret, RDW_INVALIDATE);
                UpdateWindow(pTree->ci.hwnd);
            }
            CCSendNotify(&pTree->ci, NM_KILLFOCUS, NULL);
            IncrementSearchString(&pTree->is, 0, NULL);
            break;

        case WM_SETFOCUS:
            ASSERT(gcWheelDelta == 0);

            pTree->fFocus = TRUE;
            if (pTree->hCaret)
            {
                TV_InvalidateItem(pTree, pTree->hCaret, RDW_INVALIDATE);
                MyNotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, (LONG_PTR)pTree->hCaret);
            }
            else
                TV_SelectItem(pTree, TVGN_CARET, pTree->hTop, TVSIF_NOTIFY | TVSIF_UPDATENOW, TVC_INTERNAL);

            CCSendNotify(&pTree->ci, NM_SETFOCUS, NULL);
            break;

        case WM_GETFONT:
            return MAKELRESULTFROMUINT(pTree->hFont);

        case WM_SETFONT:
            TV_OnSetFont(pTree, (HFONT) wParam, (BOOL) lParam);
            break;

        case WM_SIZE:
            TV_SizeWnd(pTree, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;

        case WM_ENABLE:
            // HACK: we don't get WM_STYLECHANGE on EnableWindow()
            if (wParam)
                pTree->ci.style &= ~WS_DISABLED;        // enabled
            else
                pTree->ci.style |= WS_DISABLED; // disabled
            TV_CreateIndentBmps(pTree); // This invalidates the whole window!
            break;

        case WM_SYSCOLORCHANGE:
            InitGlobalColors();
#if 0
            if(pTree->hwndToolTips) {
                SendMessage(pTree->hwndToolTips, TTM_SETTIPBKCOLOR, (WPARAM)GetSysColor(COLOR_WINDOW), 0);
                SendMessage(pTree->hwndToolTips, TTM_SETTIPTEXTCOLOR, (WPARAM)GetSysColor(COLOR_WINDOWTEXT), 0);
            }
#endif

            TV_CreateIndentBmps(pTree); // This invalidates the whole window!
            break;

        case WM_RBUTTONDOWN:
            TV_SendRButtonDown(pTree, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            break;

        case WM_TIMER:
            TV_Timer(pTree, (UINT) wParam);
            break;

    case WM_MOUSEMOVE:
        TV_OnMouseMove(pTree, (DWORD) lParam, wParam);
        break;

        case WM_COMMAND:
            TV_Command(pTree, (int)GET_WM_COMMAND_ID(wParam, lParam), GET_WM_COMMAND_HWND(wParam, lParam),
                    (UINT)GET_WM_COMMAND_CMD(wParam, lParam));
            break;

        case WM_NOTIFY: {
            LPNMHDR lpnm = (LPNMHDR)lParam;

            if ((lpnm->code <= PGN_FIRST) && (PGN_LAST <= lpnm->code)) {
                LRESULT TV_OnPagerControlNotify(PTREE pTree, LPNMHDR pnm);

                return TV_OnPagerControlNotify(pTree, lpnm);
            }
            if (lpnm->hwndFrom == pTree->hwndToolTips) {
                switch (lpnm->code) {
                case TTN_NEEDTEXT:
                    TV_HandleNeedText(pTree, (LPTOOLTIPTEXT)lpnm);
                    break;

#ifdef UNICODE
                case TTN_NEEDTEXTA:
                    TV_HandleNeedTextA(pTree, (LPTOOLTIPTEXTA)lpnm);
                    break;
#endif

                case TTN_SHOW:
                    return TV_HandleTTNShow(pTree, lpnm);

                case NM_CUSTOMDRAW:
                    return TV_HandleTTCustomDraw(pTree, (LPNMTTCUSTOMDRAW)lpnm);
                }
            }
            break;
        }

        case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pTree->ci, lParam);

        case WM_MBUTTONDOWN:
            SetFocus(hwnd);
            goto DoDefault;

        case WM_GETOBJECT:
            if( lParam == OBJID_QUERYCLASSNAMEIDX )
                return MSAA_CLASSNAMEIDX_TREEVIEW;
            goto DoDefault;

#ifdef KEYBOARDCUES
        case WM_UPDATEUISTATE:
        {
            DWORD dwUIStateMask = MAKEWPARAM(0xFFFF, UISF_HIDEFOCUS);

            if (CCOnUIState(&(pTree->ci), WM_UPDATEUISTATE, wParam & dwUIStateMask, lParam))
                if (pTree->hCaret)
                    TV_InvalidateItem(pTree, pTree->hCaret, TRUE);

            goto DoDefault;
        }
#endif
        case WM_SYSKEYDOWN:
            TV_KeyDown(pTree, wParam, lParam);
            //fall through

        default:
            // Special handling of magellan mouse message
            if (uMsg == g_msgMSWheel) {
                BOOL  fScroll;
                BOOL  fDataZoom;
                DWORD dwStyle;
                int   cScrollLines;
                int   cPage;
                int   pos;
                int   cDetants;
                int iWheelDelta;

                if (g_bRunOnNT || g_bRunOnMemphis)
                {
                    iWheelDelta = (int)(short)HIWORD(wParam);
                    fScroll = !(wParam & (MK_SHIFT | MK_CONTROL));
                    fDataZoom = (BOOL) (wParam & MK_SHIFT);
                }
                else
                {
                    iWheelDelta = (int)wParam;
                    fDataZoom = (GetKeyState(VK_SHIFT) < 0);
                    fScroll = !fDataZoom && GetKeyState(VK_CONTROL) >= 0;
                }

                // Update count of scroll amount
                gcWheelDelta -= iWheelDelta;
                cDetants = gcWheelDelta / WHEEL_DELTA;
                if (cDetants != 0) {
                    gcWheelDelta %= WHEEL_DELTA;
                }

                if (fScroll) {
                    if (    g_ucScrollLines > 0 &&
                            cDetants != 0 &&
                            (WS_VSCROLL | WS_HSCROLL) & (dwStyle = GetWindowStyle(hwnd))) {

                        if (dwStyle & WS_VSCROLL) {
                            cPage = max(1, (pTree->cFullVisible - 1));
                            cScrollLines =
                                          cDetants *
                                          min(g_ucScrollLines, (UINT) cPage);

                            pos = max(0, pTree->hTop->iShownIndex + cScrollLines);
                            TV_VertScroll(pTree, SB_THUMBPOSITION, pos);
                        } else {
                            cPage = max(MAGIC_HORZLINE,
                                        (pTree->cxWnd - MAGIC_HORZLINE)) /
                                    MAGIC_HORZLINE;

                            cScrollLines =
                                          cDetants *
                                          (int) min((ULONG) cPage, g_ucScrollLines) *
                                          MAGIC_HORZLINE;

                            pos = max(0, pTree->xPos + cScrollLines);
                            TV_HorzScroll(pTree, SB_THUMBPOSITION, pos);
                        }
                    }
                    return 1;
                } else if (fDataZoom) {
                    UINT wHitCode;
                    POINT pt;

                    pt.x = GET_X_LPARAM(lParam);
                    pt.y = GET_Y_LPARAM(lParam);
                    ScreenToClient(hwnd, &pt);

                    // If we are rolling forward and hit an item then navigate into that
                    // item or expand tree (simulate lbuttondown which will do it).  We
                    // also need to handle rolling backwards over the ITEMBUTTON so
                    // that we can collapse the tree in that case.  Otherwise
                    // just fall through so it isn't handled.  In that case if we
                    // are being hosted in explorer it will do a backwards
                    // history navigation.
                    if (TV_CheckHit(pTree, pt.x, pt.y, &wHitCode) &&
                        (wHitCode & (TVHT_ONITEM | TVHT_ONITEMBUTTON))) {
                        UINT uFlags = TVBD_FROMWHEEL;
                        uFlags |= (iWheelDelta > 0) ? TVBD_WHEELFORWARD : TVBD_WHEELBACK;

                        if ((uFlags & TVBD_WHEELFORWARD) || (wHitCode == TVHT_ONITEMBUTTON)) {
                            TV_ButtonDown(pTree, WM_LBUTTONDOWN, 0, pt.x, pt.y, uFlags);
                            return 1;
                        }
                    }
                    // else fall through
                }
            } else {
                LRESULT lres;
                if (CCWndProc(&pTree->ci, uMsg, wParam, lParam, &lres))
                    return lres;
            }

DoDefault:
            return(DefWindowProc(hwnd, uMsg, wParam, lParam));
    }

    return(0L);
}

// NOTE: there is very similar code in the listview
//
// Totally disgusting hack in order to catch VK_RETURN
// before edit control gets it.
//
LRESULT CALLBACK TV_EditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PTREE pTree = (PTREE)GetWindowInt(GetParent(hwnd), 0);
    ASSERT(pTree);

    if (!pTree)
        return 0L;  // wierd cases can get here...

    switch (msg) {
    case WM_KEYDOWN:
        switch (wParam) {
        case VK_RETURN:
            TV_DismissEdit(pTree, FALSE);
            return 0L;

        case VK_ESCAPE:
            TV_DismissEdit(pTree, TRUE);
            return 0L;
        }
        break;

    case WM_CHAR:
        switch (wParam) {
        case VK_RETURN:
            // Eat the character, so edit control wont beep!
            return 0L;
        }
    }

    return CallWindowProc(pTree->pfnEditWndProc, hwnd, msg, wParam, lParam);
}


void NEAR TV_SetEditSize(PTREE pTree)
{
    RECT rcLabel;
    UINT seips;

    if (pTree->htiEdit == NULL)
        return;

    TV_GetItemRect(pTree, pTree->htiEdit, &rcLabel, TRUE);

    // get exact the text bounds (acount for borders used when drawing)

    InflateRect(&rcLabel, -g_cxLabelMargin, -g_cyBorder);

    seips = 0;
#ifdef DEBUG
    // If we are in one of the no-scroll modes then it's possible for the
    // resulting rectangle not to be visible.  Similarly, if the item itself
    // isn't visible, then the resulting rectangle is definitely not visible.
    // Tell SetEditInPlaceSize not to get upset in those cases.
    if ((pTree->ci.style & (TVS_NOSCROLL | TVS_NOHSCROLL)) ||
        !ITEM_VISIBLE(pTree->htiEdit))
        seips |= SEIPS_NOSCROLL;
#endif

    SetEditInPlaceSize(pTree->hwndEdit, &rcLabel, (HFONT)SendMessage(pTree->hwndEdit, WM_GETFONT, 0, 0), seips);
}


void NEAR TV_CancelEditTimer(PTREE pTree)
{
    if (pTree->fNameEditPending)
    {
        KillTimer(pTree->ci.hwnd, IDT_NAMEEDIT);
        pTree->fNameEditPending = FALSE;
    }
}

// BUGBUG: very similar code in lvicon.c


HWND NEAR TV_EditLabel(PTREE pTree, HTREEITEM hItem, LPTSTR pszInitial)
{
    TCHAR szLabel[MAXLABELTEXT];
    TV_DISPINFO nm;

    if (!(pTree->ci.style & TVS_EDITLABELS))
        return NULL;

    if (!ValidateTreeItem(hItem, 0))
        return NULL;

    TV_DismissEdit(pTree, FALSE);


    // Now get the text associated with that item
    nm.item.pszText = szLabel;
    nm.item.cchTextMax = ARRAYSIZE(szLabel);
    nm.item.stateMask = TVIS_BOLD;
    // this cast is ok as long as TVIF_INTEGRAL or anything past it isn't asked for
    TV_GetItem(pTree, hItem, TVIF_TEXT | TVIF_STATE, (LPTVITEMEX)&nm.item);

    // Must subtract one from ARRAYSIZE(szLabel) because Edit_LimitText
    // doesn't include the terminating NULL
    pTree->hwndEdit = CreateEditInPlaceWindow(pTree->ci.hwnd,
        pszInitial? pszInitial : nm.item.pszText, ARRAYSIZE(szLabel) - 1,
        WS_BORDER | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT | ES_AUTOHSCROLL,
        (nm.item.state & TVIS_BOLD) ? pTree->hFontBold : pTree->hFont);

    if (pTree->hwndEdit) {
        if (pszInitial)     // if initialized, it's dirty.
            SetWindowID(pTree->hwndEdit, 1);
        //
        // Now notify the parent of this window and see if they want it.
        // We do it after we cretae the window, but before we show it
        // such that our parent can query for it and do things like limit
        // the number of characters that are input
        nm.item.hItem = hItem;
        nm.item.state = hItem->state;
        nm.item.lParam = hItem->lParam;
        nm.item.mask = (TVIF_HANDLE | TVIF_STATE | TVIF_PARAM | TVIF_TEXT);

        if ((BOOL)CCSendNotify(&pTree->ci, TVN_BEGINLABELEDIT, &nm.hdr))
        {
            DestroyWindow(pTree->hwndEdit);
            pTree->hwndEdit = NULL;
            return NULL;
        }

        TV_PopBubble(pTree);

        TV_ScrollIntoView(pTree, hItem);

        pTree->pfnEditWndProc = SubclassWindow(pTree->hwndEdit, TV_EditWndProc);

        pTree->htiEdit = hItem;

        TV_SetEditSize(pTree);

        // Show the window and set focus to it.  Do this after setting the
        // size so we don't get flicker.
        SetFocus(pTree->hwndEdit);
        ShowWindow(pTree->hwndEdit, SW_SHOW);
        TV_InvalidateItem(pTree, hItem, RDW_INVALIDATE | RDW_ERASE);

        RescrollEditWindow(pTree->hwndEdit);
    }

    return pTree->hwndEdit;
}


// BUGBUG: very similar code in lvicon.c

BOOL NEAR TV_DismissEdit(PTREE pTree, BOOL fCancel)
{
    HWND hwndEdit;
    BOOL fOkToContinue = TRUE;
    HTREEITEM htiEdit;

    if (pTree->fNoDismissEdit)
        return FALSE;

    hwndEdit = pTree->hwndEdit;

    if (!hwndEdit) {
        // Also make sure there are no pending edits...
        TV_CancelEditTimer(pTree);
        return TRUE;
    }

    // Assume that if we are not visible that the window is in the
    // process of being destroyed and we should not process the
    // editing of the window...
    if (!IsWindowVisible(pTree->ci.hwnd))
        fCancel = TRUE;

    //
    // We are using the Window ID of the control as a BOOL to
    // state if it is dirty or not.
    switch (GetWindowID(hwndEdit)) {
    case 0:
        // The edit control is not dirty so act like cancel.
        fCancel = TRUE;
        //  FALL THROUGH
    case 1:
        // The edit control is dirty so continue.
        SetWindowID(hwndEdit, 2);    // Don't recurse
        break;
    case 2:
        // We are in the process of processing an update now, bail out
        return TRUE;
    }

    // TV_DeleteItemRecurse will set htiEdit to NULL if the program
    // deleted the items out from underneath us (while we are waiting
    // for the edit timer).
    htiEdit = pTree->htiEdit;

    if (htiEdit != NULL)
    {
        TV_DISPINFO nm;
        TCHAR szLabel[MAXLABELTEXT];

        DBG_ValidateTreeItem(htiEdit, 0);

        // Initialize notification message.
        nm.item.hItem = htiEdit;
        nm.item.lParam = htiEdit->lParam;
        nm.item.mask = 0;

        if (fCancel)
            nm.item.pszText = NULL;
        else {
            Edit_GetText(hwndEdit, szLabel, ARRAYSIZE(szLabel));
            nm.item.pszText = szLabel;
            nm.item.cchTextMax = ARRAYSIZE(szLabel);
            nm.item.mask |= TVIF_TEXT;
        }

        // Make sure the text redraws properly
        TV_InvalidateItem(pTree, htiEdit, RDW_INVALIDATE | RDW_ERASE);
        pTree->fNoDismissEdit = TRUE; // this is so that we don't recurse due to killfocus
        ShowWindow(hwndEdit, SW_HIDE);
        pTree->fNoDismissEdit = FALSE;

        //
        // Notify the parent that we the label editing has completed.
        // We will use the LV_DISPINFO structure to return the new
        // label in.  The parent still has the old text available by
        // calling the GetItemText function.
        //

        fOkToContinue = (BOOL)CCSendNotify(&pTree->ci, TVN_ENDLABELEDIT, &nm.hdr);
        if (fOkToContinue && !fCancel)
        {
            // BUGBUG raymondc: The caller might have deleted the item in
            // response to the edit.  We should revalidate here (or make
            // delete item invalidate our edit item).  Treat a deletion
            // as if it were a rejected edit.

            //
            // If the item has the text set as CALLBACK, we will let the
            // ower know that they are supposed to set the item text in
            // their own data structures.  Else we will simply update the
            // text in the actual view.
            //
            // Note: The callee may have set the handle to null to tell
            // us that the handle to item is no longer valid.
            if (nm.item.hItem != NULL)
            {
                if (htiEdit->lpstr != LPSTR_TEXTCALLBACK)
                {
                    // Set the item text (everything's set up in nm.item)
                    //
                    nm.item.mask = TVIF_TEXT;
                    TV_SetItem(pTree, (LPTVITEMEX)&nm.item);
                }
                else
                {
                    CCSendNotify(&pTree->ci, TVN_SETDISPINFO, &nm.hdr);
                }
            }
        }
    }

    // If we did not reenter edit mode before now reset the edit state
    // variables to NULL
    if (hwndEdit == pTree->hwndEdit)
    {
        pTree->htiEdit = NULL;
        pTree->hwndEdit = NULL; // so we don't get reentered on the kill focus
    }

    // done with the edit control
    DestroyWindow(hwndEdit);

    return fOkToContinue;
}

LRESULT TV_OnCalcSize(PTREE pTree, LPNMHDR pnm)
{
    LPNMPGCALCSIZE pcalcsize = (LPNMPGCALCSIZE)pnm;

    switch(pcalcsize->dwFlag) {
    case PGF_CALCHEIGHT:
        pcalcsize->iHeight = pTree->cShowing * pTree->cyItem;
        TraceMsg(TF_WARNING, "tv.PGF_CALCHEIGHT: cShow=%d cShow*cyItem=%d AWR()=%d",
            pTree->cShowing, pTree->cShowing * pTree->cyItem, pcalcsize->iHeight);
        break;

    case PGF_CALCWIDTH:
        break;
    }
    return 0L;
}

LRESULT TV_OnPagerControlNotify(PTREE pTree, LPNMHDR pnm)
{
    switch(pnm->code) {
    case PGN_SCROLL:
        return TV_OnScroll(pTree, pnm);
        break;
    case PGN_CALCSIZE:
        return TV_OnCalcSize(pTree, pnm);
        break;
    }
    return 0L;
}

LRESULT TV_OnScroll(PTREE pTree, LPNMHDR pnm)
{
  
    LPNMPGSCROLL pscroll = (LPNMPGSCROLL)pnm;
    RECT rc = pscroll->rcParent;
    RECT rcTemp;
    int iDir = pscroll->iDir;
    int dyScroll = pscroll->iScroll;
    TREEITEM FAR * hItem;
    UINT uCode;
    int parentsize;
    TREEITEM FAR *  hPrevItem;
    TREEITEM FAR *  hNextItem;
    int y;
    
#ifndef UNIX
    POINT pt = {pscroll->iXpos, pscroll->iYpos};
    POINT ptTemp = pt;
    TREEITEM FAR *  hCurrentItem = TV_CheckHit(pTree, pt.x + 1, pt.y + 1 , &uCode);
#else
    POINT pt; 
    POINT ptTemp;
    TREEITEM FAR *  hCurrentItem;

    pt.x = pscroll->iXpos;
    pt.y = pscroll->iYpos;

    ptTemp = pt;
    hCurrentItem = TV_CheckHit(pTree, pt.x + 1, pt.y + 1 , &uCode);
#endif

    switch(iDir)
    {
        case PGF_SCROLLUP:
            //Check if any Item is partially visible at the left/top. if so then set the bottom 
            // of that Item to be our current offset and then scroll. This avoids skipping over
            // certain Items when partial Items are displayed at the left or top
            y = pt.y;       
            TV_GetItemRect(pTree,hCurrentItem,&rcTemp, TRUE);
 
            if (rcTemp.top  <  y-1)
            {
                hCurrentItem =TV_GetNextItem(pTree,hCurrentItem,TVGN_NEXTVISIBLE);
            }

            // Now do the calculation
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount
            if ((pscroll->fwKeys & PGK_CONTROL) && ((pt.y - parentsize) > 0))
            {
                dyScroll = parentsize;
            } else if ((pt.y - pTree->cyItem) > 0) {
            // we dont have control key down so scroll by one buttonsize    
                dyScroll = pTree->cyItem;
            } else {
                pscroll->iScroll = pt.y;
                return 0L;
            }
            ptTemp.y -= dyScroll;
            hItem = TV_CheckHit(pTree, ptTemp.x, ptTemp.y, &uCode);

            if (hItem)
            {
                // if  the hit test gives us the same Item as our CurrentItem then set the Item 
                // to one Item to the top/left  of the  CurrentItem 

                hPrevItem = TV_GetNextItem(pTree,hCurrentItem, TVGN_PREVIOUSVISIBLE);
                if ((hItem == hCurrentItem) && ( hPrevItem != NULL))
                {
                    hItem = hPrevItem;
                }

                //When scrolling left if we end up in the middle of some Item then we align it to the 
                //right of that Item this is to avoid scrolling more than the pager window width but if the
                // Item happens to be the left Item of  our current Item then we end up in not scrolling
                //if thats the case then move one more Item to the left.


                if (hItem == hPrevItem) 
                {
                    hItem = TV_GetNextItem(pTree, hItem, TVGN_PREVIOUSVISIBLE);
                    if(!hItem)
                    {
                        dyScroll = pt.y;
                        break;
                    }
                }

                TV_GetItemRect(pTree,hItem,&rcTemp, TRUE);
                dyScroll = pt.y - rcTemp.bottom;
            }
            break;
        case PGF_SCROLLDOWN:
        {
            RECT rcChild;
            int childsize;

            GetWindowRect(pTree->ci.hwnd, &rcChild);
            childsize = RECTHEIGHT(rcChild);
            parentsize = RECTHEIGHT(rc);

            //if  the control key is down and we have more than parentsize size of child window
            // then scroll by that amount
            if ((pscroll->fwKeys & PGK_CONTROL) && ((childsize - pt.y - parentsize) > parentsize))
            {
                dyScroll = parentsize;
            } else if ( (childsize - pt.y - parentsize) > (pTree->cyItem * hCurrentItem->iIntegral) ) {
            // we dont have control key down so scroll by one buttonsize    
                dyScroll = pTree->cyItem * hCurrentItem->iIntegral;
            } else {
                pscroll->iScroll = childsize - pt.y - parentsize;
                return 0L;
            }
            ptTemp.y += dyScroll;

            hItem = TV_CheckHit(pTree, ptTemp.x, ptTemp.y, &uCode);

            if (hItem)
            {
                if ((hItem == hCurrentItem) && 
                    ((hNextItem = TV_GetNextItem(pTree,hItem,TVGN_NEXTVISIBLE)) != NULL))
                {
                    hItem = hNextItem;
                }
                TV_GetItemRect(pTree, hItem, &rcTemp, TRUE);
                dyScroll = rcTemp.top  - pt.y ;
            }

            break;
        }
    }
    //Set the scroll value
    pscroll->iScroll = dyScroll;
    return 0L;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\tvmem.c ===
#include "ctlspriv.h"
#include "treeview.h"
#if defined(MAINWIN)
#include <mainwin.h>
#endif

void TV_ScrollItems(PTREE pTree, int nItems, int iTopShownIndex, BOOL fDown);


// in:
//      hItem   item to delete
//      flags   controls how/what to delete
//              TVDI_NORMAL             delete this node and all children
//              TVDI_NONOTIFY           don't send notify messages
//              TVDI_CHILDRENONLY       just delete the kids (not the item)

void NEAR TV_DeleteItemRecurse(PTREE pTree, TREEITEM FAR * hItem, UINT flags)
{
    TREEITEM FAR *hKid;
    TREEITEM FAR *hNext;
    TREEITEM FAR *hParent;
    int i;

    DBG_ValidateTreeItem(hItem, 0);

    //
    // We do this from DeleteItemRecurse(), kind of like how USER sends
    // Destroy notifications from its FreeWindow() code, so that we get
    // deletes for parent and children both.
    //
    MyNotifyWinEvent(EVENT_OBJECT_DESTROY, pTree->ci.hwnd, OBJID_CLIENT,
        (LONG_PTR)hItem);

    //
    //  While the item is still valid, clean up if it's the insertion point.
    //  The item needs to be valid because we're going to call other
    //  functions that validate their parameters...
    //
    if (hItem == pTree->htiInsert)
    {
        TV_SetInsertMark(pTree, NULL, FALSE);
        ASSERT(pTree->htiInsert == NULL);
    }

    // remove all kids (and their kids)
    for (hKid = hItem->hKids; hKid; hKid = hNext) {
        hNext = hKid->hNext;

        // recurse on each child
        TV_DeleteItemRecurse(pTree, hKid, flags & ~TVDI_CHILDRENONLY);
    }

    if ((flags & TVDI_CHILDRENONLY) || !hItem->hParent)
        return;

    if (!(flags & TVDI_NONOTIFY))    // BUGBUG: this is not set by anyone
    {
        NM_TREEVIEW nm;
        // Let the app clean up after itself
        nm.itemOld.hItem = hItem;
        nm.itemOld.lParam = hItem->lParam;
        nm.itemNew.mask = 0;
        nm.itemOld.mask = (TVIF_HANDLE | TVIF_PARAM);
        CCSendNotify(&pTree->ci, TVN_DELETEITEM, &nm.hdr);
    }

    //
    // If anybody has a watch on our item, let him know that it's gone.
    //
    i = DPA_GetPtrCount(pTree->hdpaWatch);
    while (--i >= 0)
    {
        PTVWATCHEDITEM pwi = DPA_FastGetPtr(pTree->hdpaWatch, i);
        ASSERT(pwi);
        if (pwi->hti == hItem) {
            pwi->hti = hItem->hNext;
            pwi->fStale = TRUE;
        }
    }

    hParent = hItem->hParent;
    ASSERT(hParent);

    // unlink ourselves from the parent child chain

    if (hParent->hKids == hItem) {
        hParent->hKids = hItem->hNext;
        hKid = NULL; 
    } else {
        // not the first child, find our previous item (linear search!)
        hKid = TV_GetNextItem(pTree, hItem, TVGN_PREVIOUS);
        ASSERT(hKid);
        hKid->hNext = hItem->hNext;
    }

    pTree->cItems--;

    TV_ScrollBarsAfterRemove(pTree, hItem);

    // reset tooltip after unlink from the parent child chain
    if (pTree->hToolTip == hItem)
        TV_SetToolTipTarget(pTree, NULL);

    Str_Set(&hItem->lpstr, NULL);

    TV_MarkAsDead(hItem);

    // be careful from here down.  hItem is unlinked but
    // still has some valid fields

    // Check to see if the user has deleted one of the
    // special items that is stored in the main tree structure.
    if (hItem == pTree->htiEdit)
        pTree->htiEdit = NULL;

    if (hItem == pTree->hDropTarget)
        pTree->hDropTarget = NULL;

    if (hItem == pTree->hOldDrop)
        pTree->hOldDrop = NULL;

    if (hItem == pTree->hHot )
        pTree->hHot = NULL;

    if (hItem == pTree->htiSearch )
        pTree->htiSearch = NULL;

    // if the caret escaped the collapsed area and landed on us, push it away
    if (pTree->hCaret == hItem) {
        HTREEITEM hTemp;
        if (hItem->hNext)
            hTemp = hItem->hNext;
        else {
            hTemp = VISIBLE_PARENT(hItem);
            if (!hTemp) 
                hTemp = hKid;  // set above when we unlinked from the previous item
        }
        // Reset the caret to NULL as to not try to reference our
        // invalidated item.
        pTree->hCaret = NULL;
        TV_SelectItem(pTree, TVGN_CARET, hTemp, (flags & TVDI_NOSELCHANGE) ? 0 : TVSIF_NOTIFY, 0);
        ASSERT(pTree->hCaret != hItem);
    }

    // BUGBUG: might want to really do this
    ASSERT(pTree->hItemPainting != hItem);

    ControlFree(pTree->hheap, hItem);
}


// ----------------------------------------------------------------------------
//
//  Removes the given item and all children from the tree.
//  Special case: if the given item is the hidden root, all children are
//  removed, but the hidden root is NOT removed.
//
//  sets cItems
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_DeleteItem(PTREE pTree, TREEITEM FAR * hItem, UINT flags)
{
    if (hItem == TVI_ROOT || !hItem)
        hItem = pTree->hRoot;

    // BUGUBG: send TVN_DELETEALLITEMS and TVDI_NONOTIFY if they respond
    // if (hItem == pTree->hRoot)
    //     etc.

    if (!ValidateTreeItem(hItem, 0))
        return FALSE;

    // Collapse first to speed things up (not as much scroll bar recalcs) and
    // to set the top index correctly after the remove.
    if (hItem != pTree->hRoot)
        TV_Expand(pTree, TVE_COLLAPSE, hItem, FALSE);
    else
    {
        // TV_Expand punts on the root item, so manually iterate through it's kids
        TREEITEM *hKid = hItem->hKids;
        while (hKid)
        {
            TV_Expand(pTree, TVE_COLLAPSE, hKid, FALSE);
            if (!ValidateTreeItem(hKid, 0)) break;      // callback during collapse could delete
            hKid = hKid->hNext;
        }
    }

    // Invalidate everything below this item; must be done AFTER setting the
    // selection
    if (hItem->hParent == pTree->hRoot || hItem == pTree->hRoot || ITEM_VISIBLE(hItem->hParent)) {
        if (pTree->fRedraw) {
            InvalidateRect(pTree->ci.hwnd, NULL, TRUE);
        }
    } else {
        TV_ScrollBelow(pTree, hItem->hParent, FALSE, FALSE);
    }

    // We can pass in the root to clear all items
    if (hItem == pTree->hRoot)
        flags |= TVDI_CHILDRENONLY;

    TV_DeleteItemRecurse(pTree, hItem, flags);

    ASSERT(pTree->hRoot); // didn't go too far, did we?

    // maybe everything's gone...
    // check out our cleanup job
    if (!pTree->hRoot->hKids) {
        // the tree itself
        ASSERT(pTree->cItems == 0);
        pTree->cItems = 0; // just removed it all, didn't we?

        // BUGBUG: this fails because we don't touch hTop if redraw is off
        // in TV_DeleteItemRecurse()
        // AssertMsg(pTree->hTop == NULL, TEXT("hTop not NULL, but empty tree"));
        pTree->hTop = NULL;

        AssertMsg(pTree->hCaret == NULL, TEXT("hCaret not NULL, but empty tree"));
        pTree->hCaret = NULL;

        pTree->fNameEditPending = FALSE;
        pTree->cxMax = 0;
        pTree->xPos = 0;

        // the invisible root
        ASSERT(pTree->hRoot->hNext == NULL);            
        pTree->hRoot->hNext = NULL;
        ASSERT(pTree->hRoot->hParent == NULL);          
        pTree->hRoot->hParent = NULL;
        ASSERT(pTree->hRoot->hKids == NULL);            
        pTree->hRoot->hKids = NULL;
        ASSERT(pTree->hRoot->state & TVIS_EXPANDED);
        pTree->hRoot->state |= (TVIS_EXPANDED | TVIS_EXPANDEDONCE);
        ASSERT(pTree->hRoot->iLevel == (BYTE)-1);
        pTree->hRoot->iLevel = (BYTE) -1;
        ASSERT(pTree->hRoot->iShownIndex == (WORD)-1);
        pTree->hRoot->iShownIndex = (WORD) -1;
    }

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Creates the hidden root node for the tree -- all items will trace up to
//  this root, and the first child of the root is the first item in the tree.
//
//  sets hRoot
//
// ----------------------------------------------------------------------------

BOOL NEAR PASCAL TV_CreateRoot(PTREE pTree)
{
    TREEITEM FAR * hRoot = ControlAlloc(pTree->hheap, sizeof(TREEITEM));
    if (!hRoot)
        return FALSE;

    // hRoot->hNext        = NULL;
    // hRoot->hKids        = NULL;
    // hRoot->hParent      = NULL;
    hRoot->iLevel = (BYTE) -1;
    hRoot->state = (TVIS_EXPANDED | TVIS_EXPANDEDONCE);
    hRoot->iShownIndex = (WORD)-1;
    hRoot->wSignature      = TV_SIG;

    pTree->hRoot = hRoot;

    // OLEACC asks for the text of the root item (d'oh!)
    Str_Set(&hRoot->lpstr, c_szNULL);
    return TRUE;
}

#ifdef DEBUG

void NEAR DumpItem(TREEITEM FAR *hItem)
{
    LPTSTR p;

    if (hItem->lpstr == LPSTR_TEXTCALLBACK)
        p = TEXT("(callback)");
    else if (hItem->lpstr == NULL)
        p = TEXT("(null)");
    else
        p = hItem->lpstr;

    TraceMsg(TF_TREEVIEW, "%s", p);
    TraceMsg(TF_TREEVIEW, "\tstate:%4.4x show index:%3d level:%2d kids:%ld lparam:%4.4x",
            hItem->state, hItem->iShownIndex,
            hItem->iLevel, hItem->fKids, hItem->lParam);

}

#else
#define DumpItem(hItem)
#endif


// ----------------------------------------------------------------------------
//
//  Adds the item described by the given arguments to the tree.
//
//  sets hTop, cItems
//
// ----------------------------------------------------------------------------

#ifdef UNICODE
TREEITEM FAR * NEAR TV_InsertItemA(PTREE pTree, LPTV_INSERTSTRUCTA lpis) {
    LPSTR pszA = NULL;
    TREEITEM *ptvi;

    //HACK Alert!  This code assumes that TV_INSERTSTRUCTA is exactly the same
    // as TV_INSERTSTRUCTW except for the text pointer in the TVITEM
    COMPILETIME_ASSERT(sizeof(TV_INSERTSTRUCTA) == sizeof(TV_INSERTSTRUCTW));

    if (!IsFlagPtr(lpis) && (lpis->DUMMYUNION_MEMBER(item).mask & TVIF_TEXT) && !IsFlagPtr(lpis->DUMMYUNION_MEMBER(item).pszText)) {

        pszA = lpis->DUMMYUNION_MEMBER(item).pszText;
        lpis->DUMMYUNION_MEMBER(item).pszText = (LPSTR)ProduceWFromA(pTree->ci.uiCodePage, lpis->DUMMYUNION_MEMBER(item).pszText);

        if (lpis->DUMMYUNION_MEMBER(item).pszText == NULL) {
            lpis->DUMMYUNION_MEMBER(item).pszText = pszA;
            return NULL;
        }
    }

    ptvi = TV_InsertItem( pTree, (LPTV_INSERTSTRUCTW)lpis );

    if (pszA) {
        FreeProducedString(lpis->DUMMYUNION_MEMBER(item).pszText);
        lpis->DUMMYUNION_MEMBER(item).pszText = pszA;
    }

    return ptvi;
}
#endif

TREEITEM FAR * NEAR TV_InsertItem(PTREE pTree, LPTV_INSERTSTRUCT lpis)
{
    TREEITEM FAR *hNewItem, FAR *hItem;
    TREEITEM FAR *hParent;
    TREEITEM FAR *hInsertAfter;
    UINT mask;

    if (!lpis)
        return NULL; //BUGBUG: Validate LPTV_INSERTSTRUCT

    // initialize _after_ the check for NULL!
    hParent      = lpis->hParent;
    hInsertAfter = lpis->hInsertAfter;
    mask         = lpis->DUMMYUNION_MEMBER(item).mask;
           
    // don't allow undefined bits
    AssertMsg((lpis->DUMMYUNION_MEMBER(item).mask & ~TVIF_ALL) == 0, TEXT("Invalid TVIF mask specified"));
    if (mask & ~TVIF_ALL) {
        // if they used bogus bits,
        // restrict to win95 bits only
        // I'd like to fail completely, but for win95 compat, we can't
        //
        // this fixes  QuaterDesk's CleanSweep which has bogus garbage on the stack for a mask
        mask = (TVIF_WIN95 & mask);
    }

    TV_DismissEdit(pTree, FALSE);

    //
    //  Zillions of apps pass garbage for hInsertAfter, so don't fail if
    //  it's invalid.  Fortunately, we never dereference hInsertAfter, so
    //  garbage is okay.

    if (!ValidateTreeItem(hParent, VTI_NULLOK))     // NULL means TVI_ROOT
        return NULL;

    DBG_ValidateTreeItem(hInsertAfter, 0);

    hNewItem = ControlAlloc(pTree->hheap, sizeof(TREEITEM));
    if (!hNewItem)
    {
        TraceMsg(TF_ERROR, "TreeView: Out of memory");
        return NULL;
    }

    hNewItem->wSignature = TV_SIG;

    if (mask & TVIF_TEXT)
    {
        //
        // We will setup the text string next, before we link our self in
        // as to handle the case where we run out of memory and need to
        // destroy ourself without having to unlink.
        //
        if (!lpis->DUMMYUNION_MEMBER(item).pszText)
        {
            hNewItem->lpstr = LPSTR_TEXTCALLBACK;
        }
        else
        {
            if (!Str_Set(&hNewItem->lpstr, lpis->DUMMYUNION_MEMBER(item).pszText))
            {
                // Memory allocation failure...
                TraceMsg(TF_ERROR, "TreeView: Out of memory");
                TV_MarkAsDead(hNewItem);
                ControlFree(pTree->hheap, hNewItem);
                return NULL;
            }
        }
    } else
        Str_Set(&hNewItem->lpstr, c_szNULL);

    AssertMsg(hNewItem->lpstr != NULL, TEXT("Item added with NULL text"));

    if ((hParent == NULL) || (hParent == TVI_ROOT))
    {
        hParent = pTree->hRoot;
        if (!pTree->hTop)
            pTree->hTop = hNewItem;
    }
    else if (!pTree->hRoot->hKids)
    {
        TV_MarkAsDead(hNewItem);
        ControlFree(pTree->hheap, hNewItem);
        return NULL;
    }

    // We will do the sort later, so we can handle TEXTCALLBACK things
    if ((hInsertAfter == TVI_FIRST || hInsertAfter == TVI_SORT) || !hParent->hKids)
    {
        hNewItem->hNext = hParent->hKids;
        hParent->hKids = hNewItem;
    }
    else
    {
        // BUGBUG: we should cache the last insert after pointer to try to
        // catch the case of consecutive adds to the end of a node

        if (hInsertAfter == TVI_LAST)
            for (hItem = hParent->hKids; hItem->hNext; hItem = hItem->hNext)
                ;
        else
        {
            for (hItem = hParent->hKids; hItem->hNext; hItem = hItem->hNext)
                if (hItem == hInsertAfter)
                    break;
        }

        hNewItem->hNext = hItem->hNext;
        hItem->hNext = hNewItem;
    }

    // hNewItem->hKids     = NULL;
    hNewItem->hParent   = hParent;
    hNewItem->iLevel    = hParent->iLevel + 1;
    // hNewItem->iWidth = 0;
    // hNewItem->state = 0;
    if ((mask & TVIF_INTEGRAL) &&
        LOWORD(lpis->DUMMYUNION_MEMBER(itemex).iIntegral) > 0) {
        hNewItem->iIntegral = LOWORD(lpis->DUMMYUNION_MEMBER(itemex).iIntegral);
    } else {
#ifdef CHEEDEBUG
        // just to get some variety
        hNewItem->iIntegral = ((((int)hNewItem) /100) % 2) + 1;
#else
        hNewItem->iIntegral = 1;
#endif
    }
    
    if (pTree->hTop == hNewItem)
        hNewItem->iShownIndex = 0; // calc me please!
    else
        hNewItem->iShownIndex = (WORD)-1; // calc me please!

    if (mask & TVIF_IMAGE)
        hNewItem->iImage = (WORD) lpis->DUMMYUNION_MEMBER(item).iImage;

    if (mask & TVIF_SELECTEDIMAGE)
        hNewItem->iSelectedImage = (WORD) lpis->DUMMYUNION_MEMBER(item).iSelectedImage;

    if (mask & TVIF_PARAM)
        hNewItem->lParam = lpis->DUMMYUNION_MEMBER(item).lParam;

    if (mask & TVIF_STATE)
        hNewItem->state = lpis->DUMMYUNION_MEMBER(item).state & lpis->DUMMYUNION_MEMBER(item).stateMask;
    
    // if we're in check box mode, inforce that it has a check box
    if (pTree->ci.style & TVS_CHECKBOXES) {
        if ((hNewItem->state & TVIS_STATEIMAGEMASK) == 0) {
            hNewItem->state |= INDEXTOSTATEIMAGEMASK(1);
        }
    }
    
    
    

    if ((hNewItem->state & TVIS_BOLD) && !pTree->hFontBold) //$BOLD
        TV_CreateBoldFont(pTree);                           //$BOLD

    // TraceMsg(TF_TRACE, "Tree: Inserting i = %d state = %d", TV_StateIndex(&lpis->item), lpis->item.state);

    if (mask & TVIF_CHILDREN) {
        switch (lpis->DUMMYUNION_MEMBER(item).cChildren) {
        case I_CHILDRENCALLBACK:
            hNewItem->fKids = KIDS_CALLBACK;
            break;

        case 0:
            hNewItem->fKids = KIDS_FORCE_NO;
            break;

        default:
            hNewItem->fKids = KIDS_FORCE_YES;
            break;
        }
    }

    // accept state bits on create?
    // mask & TVIF_STATE

    pTree->cItems++;

    // I don't want to do any callbacks until the item is completed
    // so sorting waits until the end
    // special case an only child for speed
    // (hKids && hKids->hNext means more than one child)
    if ((hInsertAfter == TVI_SORT) && hParent->hKids && hParent->hKids->hNext)
    {
        TVITEMEX sThisItem, sNextItem;
        TCHAR szThis[64], szNext[64];    // BUGBUG: these are too small

        sThisItem.pszText = szThis;
        sThisItem.cchTextMax  = ARRAYSIZE(szThis);
        TV_GetItem(pTree, hNewItem, TVIF_TEXT, &sThisItem);

        // We know that the first kid of hParent is hNewItem
        for (hItem = hNewItem->hNext; hItem; hItem = hItem->hNext)
        {

            sNextItem.pszText = szNext;
            sNextItem.cchTextMax  = ARRAYSIZE(szNext);

            TV_GetItem(pTree, hItem, TVIF_TEXT, &sNextItem);

            if (lstrcmpi(sThisItem.pszText, sNextItem.pszText) < 0)
                break;

            hInsertAfter = hItem;
        }

        // Check if this is still the first item
        if (hInsertAfter != TVI_SORT)
        {
            // Move this item from the beginning to where it
            // should be
            hParent->hKids = hNewItem->hNext;
            hNewItem->hNext = hInsertAfter->hNext;
            hInsertAfter->hNext = hNewItem;
        }
    }

    
    if ((hNewItem->hNext == pTree->hTop) && !pTree->fVert) {
        
        // there's no scrollbars and we got added before the top 
        // item.  we're now the top.
        hNewItem->iShownIndex = 0;
        pTree->hTop = hNewItem;
    }

    if (pTree->fRedraw)
    {
        BOOL fVert = pTree->fVert;
        RECT rc;
        RECT rc2;

        if (TV_ScrollBarsAfterAdd(pTree, hNewItem)) {
            // scroll everything down one
            if (ITEM_VISIBLE(hNewItem)) {
                int iTop = hNewItem->iShownIndex - pTree->hTop->iShownIndex;

                // if there wasn't a scrollbar and we're the 0th item,
                // TV_ScrollBarsAfterAdd already scrolled us
                if (iTop > 0 || !fVert)
                    TV_ScrollItems(pTree, hNewItem->iIntegral, iTop + hNewItem->iIntegral - 1, TRUE);
            }
        }

        // connect the lines, add the buttons, etc. on the item above
        // TV_GetPrevVisItem only works after TV_Scroll* stuff is done
            
        if (TV_GetItemRect(pTree, hNewItem, &rc, FALSE)) {

            // find the previous sibling or the parent if no prev sib.
            if (hParent->hKids == hNewItem) {
                hItem = hParent;
            } else {
                hItem = hParent->hKids;
                while ( hItem->hNext != hNewItem ) {
                    ASSERT(hItem->hNext);
                    hItem = hItem->hNext;
                }
            }

            // invalidate from there to the new one
            if (TV_GetItemRect(pTree, hItem, &rc2, FALSE)) {
                rc.top = rc2.top;
            }
            RedrawWindow(pTree->ci.hwnd, &rc, NULL, RDW_INVALIDATE | RDW_ERASE);
        }
    }

    // DumpItem(hNewItem);

    MyNotifyWinEvent(EVENT_OBJECT_CREATE, pTree->ci.hwnd, OBJID_CLIENT, (LONG_PTR)hNewItem);

    if (pTree->hToolTip)
    {
        TV_PopBubble(pTree);
    }

    return hNewItem;
}

void TV_DeleteHotFonts(PTREE pTree)
{
    if (pTree->hFontHot)
        DeleteObject(pTree->hFontHot);
    
    if (pTree->hFontBoldHot)
        DeleteObject(pTree->hFontBoldHot);
    
    pTree->hFontHot = pTree->hFontBoldHot = NULL;
}

// ----------------------------------------------------------------------------
//
//  Frees all allocated memory and objects associated with the tree.
//
// ----------------------------------------------------------------------------

void NEAR TV_DestroyTree(PTREE pTree)
{
    HWND hwnd = pTree->ci.hwnd;

    ASSERT(pTree->hRoot);

    pTree->fRedraw = FALSE;
    
    TV_OnSetBkColor(pTree, (COLORREF)-1);
    
    if (pTree->hCurHot)
        DestroyCursor(pTree->hCurHot);

    if (IsWindow(pTree->hwndToolTips)) {
        DestroyWindow(pTree->hwndToolTips);
    }

    pTree->hwndToolTips = NULL;

    if (IsWindow(pTree->hwndEdit)) {
        DestroyWindow(pTree->hwndEdit);
    }
    pTree->hwndEdit = NULL;


    // BUGUBG: send TVN_DELETEALLITEMS and TVDI_NONOTIFY if they respond
    TV_DeleteItem(pTree, pTree->hRoot, TVDI_CHILDRENONLY | TVDI_NOSELCHANGE);

    if (pTree->hRoot)
    {
        Str_Set(&pTree->hRoot->lpstr, NULL);

        // No point in marking dead since the entire control is going away
        ControlFree(pTree->hheap, pTree->hRoot);
    }

    if (pTree->hdcBits)
    {
        if (pTree->hBmp)
        {
            SelectObject(pTree->hdcBits, pTree->hStartBmp);
            DeleteObject(pTree->hBmp);
        }

        DeleteDC(pTree->hdcBits);
    }

    if (pTree->fCreatedFont && pTree->hFont)
        DeleteObject(pTree->hFont);

    if (pTree->hFontBold)                    //$BOLD
        DeleteObject(pTree->hFontBold);      //$BOLD
    Str_Set(&pTree->pszTip, NULL);
#ifdef UNICODE
    if (pTree->pszTipA)
        LocalFree(pTree->pszTipA);
#endif
    TV_DeleteHotFonts(pTree);

    if (pTree->hdpaWatch)
        DPA_Destroy(pTree->hdpaWatch);

    IncrementSearchFree(&pTree->is);

    NearFree(pTree);

    // Don't try to use this var when window is destroyed...
    SetWindowInt(hwnd, 0, 0);
}

void TV_CreateToolTips(PTREE pTree);

// ----------------------------------------------------------------------------
//
//  Allocates space for the tree and initializes the tree's data
//
// ----------------------------------------------------------------------------

LRESULT NEAR TV_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreate)
{
    PTREE pTree = NearAlloc(sizeof(TREE));

    if (!pTree)
        return -1;      // fail the create window

#ifdef WIN32
    pTree->hheap = GetProcessHeap();
#endif

    if (!TV_CreateRoot(pTree)) {
        NearFree((HLOCAL)pTree);
        return -1;      // fail the create window
    }

    pTree->hdpaWatch = DPA_Create(8);
    if (!pTree->hdpaWatch) {
        // No point in marking dead since the entire control is going away
        ControlFree(pTree->hheap, pTree->hRoot);
        NearFree((HLOCAL)pTree);
        return -1;      // fail the create window
    }

    SetWindowPtr(hwnd, 0, pTree);

    CIInitialize(&pTree->ci, hwnd, lpCreate);

#ifdef WINDOWS_ME
    if (lpCreate->dwExStyle & WS_EX_RTLREADING)
        pTree->ci.style |= TVS_RTLREADING;
#endif
    
#ifdef DEBUG
    if (GetAsyncKeyState(VK_SHIFT) < 0 &&
        GetAsyncKeyState(VK_CONTROL) < 0) {
        pTree->ci.style |= TVS_SHOWSELALWAYS; // | TVS_CHECKBOXES;
        SetWindowLong(pTree->ci.hwnd, GWL_STYLE, pTree->ci.style);
    }
#endif
    pTree->fRedraw    = TRUE;
    pTree->clrBk = (COLORREF)-1;
    pTree->clrText = (COLORREF)-1;
    pTree->clrim = CLR_DEFAULT;
    pTree->clrLine = CLR_DEFAULT;

    // pTree->fHorz        = FALSE;
    // pTree->fVert        = FALSE;
    // pTree->fFocus       = FALSE;
    // pTree->fNameEditPending = FALSE;
    // pTree->cxMax        = 0;
    // pTree->cxWnd        = 0;
    // pTree->cyWnd        = 0;
    // pTree->hTop         = NULL;
    // pTree->hCaret       = NULL;
    // pTree->hDropTarget  = NULL;
    // pTree->hOldDrop     = NULL;
    // pTree->cItems       = 0;
    // pTree->cShowing     = 0;
    pTree->cFullVisible = 1;
    // pTree->hdcBits      = NULL;
    // pTree->hBmp         = NULL;
    // pTree->hbrBk        = NULL;
    // pTree->xPos         = 0;
    // pTree->cxIndent     = 0; // init this for real in TV_OnSetFont()
    // pTree->dwCDDepth    = 0;
    pTree->uMaxScrollTime = SSI_DEFAULT;
    
    TV_OnSetFont(pTree, NULL, TRUE);
    
    // You cannot combine TVS_HASLINES and TVS_FULLROWSELECT
    // because it doesn't work
    if (pTree->ci.style & TVS_HASLINES) {
        if (pTree->ci.style & TVS_FULLROWSELECT) {
            DebugMsg(DM_ERROR, TEXT("Cannot combine TVS_HASLINES and TVS_FULLROWSELECT"));
        }
        pTree->ci.style &= ~TVS_FULLROWSELECT;
    }

    if (!(pTree->ci.style & TVS_NOTOOLTIPS)) {
        TV_CreateToolTips(pTree);
    }

    SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE);
    SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE);

    return 0;   // success
}


void TV_CreateToolTips(PTREE pTree)
{
#if defined(MAINWIN)
    /* IUENIX : On CDE, when tooltip comes up, WM activates tooltip window causing some
       flashing due to activation/deactivation of various other windows.  Hence asking WM
       not to manage such tooltip windows */
    DWORD exStyle = WS_EX_MW_UNMANAGED_WINDOW;
#else
    DWORD exStyle = 0;
#endif

#ifdef WINDOWS_ME
    if(pTree->ci.style & TVS_RTLREADING) {
        exStyle |= WS_EX_RTLREADING;
    }
#endif // WINDOWS_ME

    pTree->hwndToolTips = CreateWindowEx(exStyle, c_szSToolTipsClass, NULL,
                                       WS_POPUP | TTS_NOPREFIX,
                                       CW_USEDEFAULT, CW_USEDEFAULT,
                                       CW_USEDEFAULT, CW_USEDEFAULT,
                                       pTree->ci.hwnd, NULL, HINST_THISDLL,
                                       NULL);
    if (pTree->hwndToolTips) {
        TOOLINFO ti;

        ti.cbSize = sizeof(ti);
        ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT;
        ti.hwnd = pTree->ci.hwnd;
        ti.uId = (UINT_PTR)pTree->ci.hwnd; 
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.lParam = 0;
        SendMessage(pTree->hwndToolTips, TTM_ADDTOOL, 0,
                    (LPARAM)(LPTOOLINFO)&ti);
        SendMessage(pTree->hwndToolTips, WM_SETFONT, (WPARAM)pTree->hFont, (LPARAM)TRUE);
#if 0
        SendMessage(pTree->hwndToolTips, TTM_SETTIPBKCOLOR, (WPARAM)GetSysColor(COLOR_WINDOW), 0);
        SendMessage(pTree->hwndToolTips, TTM_SETTIPTEXTCOLOR, (WPARAM)GetSysColor(COLOR_WINDOWTEXT),0);
#endif
        SendMessage(pTree->hwndToolTips, TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM)500);
    } else
        pTree->ci.style |= (TVS_NOTOOLTIPS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\tvpaint.c ===
#include "ctlspriv.h"
#include "treeview.h"
#include "image.h"

extern void  TruncateString(char *sz, int cch);

void NEAR TV_GetBackgroundBrush(PTREE pTree, HDC hdc)
{
    if (pTree->clrBk == (COLORREF)-1) {
        if (pTree->ci.style & WS_DISABLED)
            pTree->hbrBk = FORWARD_WM_CTLCOLORSTATIC(pTree->ci.hwndParent, hdc, pTree->ci.hwnd, SendMessage);
        else
            pTree->hbrBk = FORWARD_WM_CTLCOLOREDIT(pTree->ci.hwndParent, hdc, pTree->ci.hwnd, SendMessage);
    }
}

// ----------------------------------------------------------------------------
//
//  Draws a horizontal or vertical dotted line from the given (x,y) location
//  for the given length (c).
//
// ----------------------------------------------------------------------------

void NEAR TV_DrawDottedLine(HDC hdc, int x, int y, int c, BOOL fVert)
{
    while (c > 0)
    {
        PatBlt(hdc, x, y, 1, 1, PATCOPY);
        if (fVert)
            y += 2;
        else
            x += 2;
        c -= 2;
    }
}


// ----------------------------------------------------------------------------
//
//  Draws a plus or minus sign centered around the given (x,y) location and
//  extending out from that location the given distance (c).
//
// ----------------------------------------------------------------------------

void NEAR TV_DrawPlusMinus(HDC hdc, int x, int y, int c, HBRUSH hbrSign, HBRUSH hbrBox, HBRUSH hbrBk, BOOL fPlus)
{
    int n;
    int p = (c * 7) / 10;
    
    n = p * 2 + 1;
    
    SelectObject(hdc, hbrSign);
    
    if (p >= 5)
    {
        PatBlt(hdc, x - p, y - 1, n, 3, PATCOPY);
        if (fPlus)
            PatBlt(hdc, x - 1, y - p, 3, n, PATCOPY);
        
        SelectObject(hdc, hbrBk);
        p--;
        n -= 2;
    }
    
    PatBlt(hdc, x - p, y, n, 1, PATCOPY);
    if (fPlus)
        PatBlt(hdc, x, y - p, 1, n, PATCOPY);
    
    n = c * 2 + 1;
    
    SelectObject(hdc, hbrBox);
    
    PatBlt(hdc, x - c, y - c, n, 1, PATCOPY);
    PatBlt(hdc, x - c, y - c, 1, n, PATCOPY);
    PatBlt(hdc, x - c, y + c, n, 1, PATCOPY);
    PatBlt(hdc, x + c, y - c, 1, n, PATCOPY);
}


// ----------------------------------------------------------------------------
//
//  Create the bitmaps for the indent area of the tree as follows
//  if  fHasLines &&  fHasButtons --> 7 bitmaps
//  if  fHasLines && !fHasButtons --> 3 bitmaps
//  if !fHasLines &&  fHasButtons --> 2 bitmaps
//
//  sets hStartBmp, hBmp, hdcBits
//
//  If "has lines" then there are three basic bitmaps.
//
//      |       |       |
//      |       +---    +---
//      |       |
//
//  (The plan vertical line does not get buttons.)
//
//  Otherwise, there are no lines, so the basic bitmaps are blank.
//
//  If "has buttons", then the basic bitmaps are augmented with buttons.
//
//       [+]      [-]
//
//  And if you have "lines at root", you get
//
//      __
//
//
//  And if you have "lines at root" with "has buttons", then you also get
//
//      --[+]   --[-]
//
//  So, there are twelve image types.  Here they are, with the code names
//  written underneath.
//
//      |       |       |       |       |       |       |
//      |       +---    +---   [+]--   [+]--   [-]--   [-]--
//      |       |               |               |
//
//     "|"     "|-"    "L"     "|-+"   "L+"    "|--"   "L-"
//
//      ---    [+]--   [-]--   [+]     [-]
//
//     ".-"    ".-+"   ".--"   "+"     "-"
//
//      And the master table of which styles get which images.
//
//
//  LINES   BTNS    ROOT    |   |-  L   |-+ L+  |-- L-  .-  .-+ .-- +   -
//
//           x                                                      0   1
//    x                     0   1   2                   3
//    x                     0   1   2                   3
//    x      x              0   1   2   3   4   5   6
//    x              x      0   1   2                   3
//    x      x       x      0   1   2   3   4   5   6   7   8   9
//
// ----------------------------------------------------------------------------

void NEAR TV_CreateIndentBmps(PTREE pTree)
{
    int  cnt;
    RECT rc;
    HBRUSH hbrOld;
    int xMid, yMid;
    int x, c;
    HBITMAP hBmpOld;
    HBRUSH hbrLine;
    HBRUSH hbrText;
    HDC hdc;

    if (pTree->fRedraw)
        InvalidateRect(pTree->ci.hwnd, NULL, TRUE);
    
    if (pTree->ci.style & TVS_HASLINES)
    {
        if (pTree->ci.style & TVS_HASBUTTONS)
            cnt = 7;  //   | |-  L   |-+ L+  |-- L-
        else
            cnt = 3;  //   | |-  L
        
        if (pTree->ci.style & TVS_LINESATROOT) {
            if (pTree->ci.style & TVS_HASBUTTONS)
                cnt += 3;    // -  -+ --
            else 
                cnt += 1;    // -
        }
    }
    else if (pTree->ci.style & TVS_HASBUTTONS)
        cnt = 2;
    else
        return;

    if (!pTree->hdcBits)
        pTree->hdcBits = CreateCompatibleDC(NULL);
    
    hdc = pTree->hdcBits;
    
    // Get a new background brush, just like an Edit does.
    
    TV_GetBackgroundBrush(pTree, hdc);
    
    hBmpOld = pTree->hBmp;
    pTree->hBmp = CreateColorBitmap(cnt * pTree->cxIndent, pTree->cyItem);
    if (hBmpOld) {
        SelectObject(hdc, pTree->hBmp);
        DeleteObject(hBmpOld);
    } else
        pTree->hStartBmp = SelectObject(hdc, pTree->hBmp);

    if (pTree->clrLine != CLR_DEFAULT)
        hbrLine = CreateSolidBrush(pTree->clrLine);
    else
        hbrLine = g_hbrGrayText;

    if (pTree->clrText != (COLORREF)-1)
        hbrText = CreateSolidBrush(pTree->clrText);
    else
        hbrText = g_hbrWindowText;

    hbrOld = SelectObject(hdc, hbrLine);

    rc.top = 0;
    rc.left = 0;
    rc.right = cnt * pTree->cxIndent;
    rc.bottom = pTree->cyItem;

    FillRect(hdc, &rc, pTree->hbrBk);
    x = 0;
    
    if (pTree->hImageList)
        xMid = (pTree->cxImage - MAGIC_INDENT) / 2;
    else
        xMid = pTree->cxIndent / 2;
    
    yMid = ((pTree->cyItem / 2) + 1) & ~1;
    
    c = (min(xMid, yMid)) / 2;
    
    if (pTree->ci.style & TVS_HASLINES)
    {
        TV_DrawDottedLine(hdc, x + xMid, 0, pTree->cyItem, TRUE);
        x += pTree->cxIndent;
        
        TV_DrawDottedLine(hdc, x + xMid, 0, pTree->cyItem, TRUE);
        TV_DrawDottedLine(hdc, x + xMid, yMid, pTree->cxIndent - xMid, FALSE);
        x += pTree->cxIndent;
        
        TV_DrawDottedLine(hdc, x + xMid, 0, yMid, TRUE);
        TV_DrawDottedLine(hdc, x + xMid, yMid, pTree->cxIndent - xMid, FALSE);
        x += pTree->cxIndent;
    }
    
    if (pTree->ci.style & TVS_HASBUTTONS)
    {
        BOOL fPlus = TRUE;
        
        x += xMid;
        
doDrawPlusMinus:
        TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, fPlus);
        
        if (pTree->ci.style & TVS_HASLINES)
        {
            TV_DrawDottedLine(hdc, x, 0, yMid - c, TRUE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
            TV_DrawDottedLine(hdc, x, yMid + c, yMid - c, TRUE);
            
            x += pTree->cxIndent;
            
            TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, fPlus);
            
            TV_DrawDottedLine(hdc, x, 0, yMid - c, TRUE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
        }
        
        x += pTree->cxIndent;
        
        if (fPlus)
        {
            fPlus = FALSE;
            goto doDrawPlusMinus;
        }
        x -= xMid;
    }
    
    if (pTree->ci.style & TVS_LINESATROOT) {
        
        // -
        TV_DrawDottedLine(hdc, x + xMid, yMid, pTree->cxIndent - xMid, FALSE);
        x += pTree->cxIndent;
        
        if (pTree->ci.style & TVS_HASBUTTONS) {
            x += xMid;
            TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, TRUE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
            x += pTree->cxIndent;
            
            TV_DrawPlusMinus(hdc, x, yMid, c, hbrText, hbrLine, pTree->hbrBk, FALSE);
            TV_DrawDottedLine(hdc, x + c, yMid, pTree->cxIndent - xMid - c, FALSE);
            //  uncomment if there's more to be added
            //x += pTree->cxIndent - xMid;
            
        }
    }
    
    if (hbrOld)
        SelectObject(pTree->hdcBits, hbrOld);
    
    if (pTree->clrLine != CLR_DEFAULT)
        DeleteObject(hbrLine);
    if (pTree->clrText != (COLORREF)-1)
        DeleteObject(hbrText);
}


// ----------------------------------------------------------------------------
//
//  fills in a TVITEM structure based by coying data from the item or
//  by calling the callback to get it.
//
//  in:
//	hItem	item to get TVITEM struct for
//	mask	which bits of the TVITEM struct you want (TVIF_ flags)
//  out:
//	lpItem	TVITEM filled in
//
// ----------------------------------------------------------------------------

void NEAR TV_GetItem(PTREE pTree, HTREEITEM hItem, UINT mask, LPTVITEMEX lpItem)
{
    TV_DISPINFO nm;
    
    if (!hItem || !lpItem)
        return;
    
    DBG_ValidateTreeItem(hItem, FALSE);

    nm.item.mask = 0;
    
    // We need to check the mask to see if lpItem->pszText is valid
    // And even then, it might not be, so be paranoid
    if ((mask & TVIF_TEXT) && lpItem->pszText && lpItem->cchTextMax) {
        if (hItem->lpstr == LPSTR_TEXTCALLBACK) {
            nm.item.mask |= TVIF_TEXT;
            // caller had to fill in pszText and cchTextMax with valid data
            nm.item.pszText = lpItem->pszText;
            nm.item.cchTextMax = lpItem->cchTextMax;
            nm.item.pszText[0] = 0;

        } else {
            ASSERT(hItem->lpstr);
            // we could do this but this is dangerous (when responding
            // to TVM_GETITEM we would be giving the app a pointer to our data)
            // lpItem->pszText = hItem->lpstr;
            lstrcpyn(lpItem->pszText, hItem->lpstr, lpItem->cchTextMax);
#ifndef UNICODE
            // only call truncate string if the source string is larger than the dest buffer
            // this is to deal with corel draw who passes in a bogus cchTextMax value
            //
            // We used to always call TruncateString when cchTextMax is MAX_PATH, but
            // McAfee Virus program (QFE1381) passes MAX_PATH with a smaller than MAX_PATH buffer
            // so we must always check the string length first.  They luck out
            // and lstrlen(hItem->lpstr) is smaller than max path so we don't truncate.
            //
            if (lstrlen(hItem->lpstr) >= lpItem->cchTextMax) {
                // takes care of broken dbcs sequence, note lstrcpyn puts nul at
                // cchTextMax-1 if exceeded
                TruncateString(lpItem->pszText, lpItem->cchTextMax);
            }
#endif
        }

    }
    
    if (mask & TVIF_IMAGE) {
        if (hItem->iImage == (WORD)I_IMAGECALLBACK)
            nm.item.mask |= TVIF_IMAGE;
        else
            lpItem->iImage = hItem->iImage;
    }
    
    if (mask & TVIF_SELECTEDIMAGE) {
        if (hItem->iSelectedImage == (WORD)I_IMAGECALLBACK)
            nm.item.mask |= TVIF_SELECTEDIMAGE;
        else
            lpItem->iSelectedImage = hItem->iSelectedImage;
    }
    
    if (mask & TVIF_INTEGRAL) {
        lpItem->iIntegral = hItem->iIntegral;
    }
    
    if (mask & TVIF_CHILDREN) {
        switch (hItem->fKids) {
        case KIDS_COMPUTE:
            lpItem->cChildren = hItem->hKids ? 1 : 0;// the actual count doesn't matter
            break;
            
        case KIDS_FORCE_YES:
            lpItem->cChildren = 1;// the actual count doesn't matter
            break;
            
        case KIDS_FORCE_NO:
            lpItem->cChildren = 0;
            break;
            
        case KIDS_CALLBACK:
            nm.item.mask |= TVIF_CHILDREN;
            break;
        }
    }

    // copy out constant parameters (and prepare for callback)
    // IE4 and IE5.0 did this unconditionally
    lpItem->state = nm.item.state = hItem->state;

    //
    //  NOTICE!  We do not set TVIF_STATE nm.item.mask and we do not
    //  check for TVIF_STATE in the "any items need to be filled in
    //  by callback?" test a few lines below.  This is necessary for
    //  backwards compat.  IE5 and earlier did not call the app back
    //  if the only thing you asked for was TVIF_STATE.  You can't
    //  change this behavior unless you guard it with a version check, or
    //  apps will break.  (They'll get callbacks when they didn't used to.)
    //  Besides, nobody knows that they can customize the state, so it's
    //  not like we're missing out on anything.
    //

#ifdef DEBUG_TEST_BOLD
    if ((((int)hItem) / 100) % 2)
        lpItem->state |= TVIS_BOLD;
    if (!pTree->hFontBold)
        TV_CreateBoldFont(pTree);
#endif
    
    lpItem->lParam = nm.item.lParam = hItem->lParam;
    
    // any items need to be filled in by callback?
    if (nm.item.mask & (TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_CHILDREN)) {
        nm.item.hItem = hItem;
        
        CCSendNotify(&pTree->ci, TVN_GETDISPINFO, &nm.hdr);

        // copy out things that may have been filled in on the callback
        if (nm.item.mask & TVIF_CHILDREN)
            lpItem->cChildren = nm.item.cChildren;

        if (nm.item.mask & TVIF_IMAGE)
            lpItem->iImage = nm.item.iImage;

        if (nm.item.mask & TVIF_SELECTEDIMAGE)
            lpItem->iSelectedImage = nm.item.iSelectedImage;

        // callback may have redirected pszText to point into its own buffer
        if (nm.item.mask & TVIF_TEXT)
        {
            if (mask & TVIF_TEXT) // did the *original* mask specify TVIF_TEXT?
                lpItem->pszText = CCReturnDispInfoText(nm.item.pszText, lpItem->pszText, lpItem->cchTextMax);
            else
                lpItem->pszText = nm.item.pszText;   // do what we used to do
        }

        if (nm.item.mask & TVIF_STATE) {
            lpItem->state = (nm.item.state & nm.item.stateMask) | (lpItem->state & ~nm.item.stateMask);
            if ((lpItem->state & TVIS_BOLD) && !pTree->hFontBold)
                TV_CreateBoldFont(pTree);
        }
        
        
        if (nm.item.mask & TVIF_DI_SETITEM) {
            
            if (nm.item.mask & TVIF_TEXT)
                if (nm.item.pszText) {
                    ASSERT(hItem->lpstr == LPSTR_TEXTCALLBACK);
                    Str_Set(&hItem->lpstr, nm.item.pszText);
                }
                if (nm.item.mask & TVIF_STATE) {
                    // if the bold bit changed, then the width changed
                    if ((hItem->state ^ lpItem->state) & TVIS_BOLD)
                        hItem->iWidth = 0;
                    hItem->state = (WORD) lpItem->state;
                }
                if (nm.item.mask & TVIF_IMAGE)
                    hItem->iImage = (WORD) lpItem->iImage;
                if (nm.item.mask & TVIF_SELECTEDIMAGE)
                    hItem->iSelectedImage = (WORD) lpItem->iSelectedImage;
                if (nm.item.mask & TVIF_CHILDREN) {
                    switch(nm.item.cChildren) {
                    case I_CHILDRENCALLBACK:
                        hItem->fKids = KIDS_CALLBACK;
                        break;
                        
                    case 0:
                        hItem->fKids = KIDS_FORCE_NO;
                        break;
                        
                    default:
                        hItem->fKids = KIDS_FORCE_YES;
                        break;
                    }
                    
                }
        }
    }
}


// ----------------------------------------------------------------------------
//
//  Draws the given item starting at the given (x,y) and extending down and to
//  the right.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ShouldItemDrawBlue(PTREE pTree, TVITEMEX *ti, UINT flags) 
{
    return  ( (ti->state & TVIS_DROPHILITED) ||
        (!pTree->hDropTarget && 
        !(flags & TVDI_GRAYCTL) &&
        (ti->state & TVIS_SELECTED) &&
        pTree->fFocus));
}

#define TV_ShouldItemDrawDisabled(pTree, pti, flags) (flags & TVDI_GRAYCTL)

//
//  Caution:  Depending on the user's color scheme, a Gray item may
//  end up looking Blue if Gray would otherwise be invisible.  So make
//  sure that there are other cues that the user can use to tell whether
//  the item is "Really Blue" or "Gray masquerading as Blue".
//
//  For example, you might get both is if the treeview is
//  participating in drag/drop while it is not the active window,
//  because the selected item gets "Gray masquerading as Blue" and
//  the drop target gets "Really Blue".  But we special-case that
//  and turn off the selection while we are worrying about drag/drop,
//  so there is no confusion after all.
//
BOOL TV_ShouldItemDrawGray(PTREE pTree, TVITEMEX *pti, UINT flags) 
{
    return  ((flags & TVDI_GRAYCTL) ||
        (!pTree->hDropTarget && 
        ((pti->state & TVIS_SELECTED) &&
        (!pTree->fFocus && (pTree->ci.style & TVS_SHOWSELALWAYS)) )));
}

//
//  Draw a descender line for the item.  It is the caller's job to
//  draw the appropriate glyph at level 0.
//
void
TV_DrawDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem)
{
    int i;
    for (i = 1; i < hItem->iIntegral; i++)
        BitBlt(hdc, x, y + i * pTree->cyItem, pTree->cxIndent, pTree->cyItem, pTree->hdcBits, 0, 0, SRCCOPY);

}

//
//  Erase any previous descender line for the item.
//
void
TV_EraseDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem)
{
    RECT rc;
    rc.left = x;
    rc.right = x + pTree->cxIndent;
    rc.top = y + pTree->cyItem;
    rc.bottom = y + hItem->iIntegral * pTree->cyItem;
    FillRect(hdc, &rc, pTree->hbrBk);
}

//
//  Draw (or erase) descenders for siblings and children.
//
void TV_DrawKinDescender(PTREE pTree, HDC hdc, int x, int y, HTREEITEM hItem, UINT state)
{
    if (hItem->hNext)   // Connect to next sibling
        TV_DrawDescender(pTree, hdc, x, y, hItem);
    else
        TV_EraseDescender(pTree, hdc, x, y, hItem);

    // If any bonus images, then need to connect the image to the kids.
    if (pTree->himlState || pTree->hImageList) {
        if (state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) // Connect to expanded kids
            TV_DrawDescender(pTree, hdc, x + pTree->cxIndent, y, hItem);
        else
            TV_EraseDescender(pTree, hdc, x + pTree->cxIndent, y, hItem);
    }
}

void NEAR TV_DrawItem(PTREE pTree, HTREEITEM hItem, HDC hdc, int x, int y, UINT flags)
{
    UINT cxIndent = pTree->cxIndent;
    COLORREF rgbOldBack = 0, rgbOldText;
    COLORREF clrBk = CLR_DEFAULT;
    RECT rc;
    int iBack, iText;
    HTREEITEM hItemSave = hItem;
    LPTSTR lpstr;
    int cch;
    UINT etoFlags = ETO_OPAQUE | ETO_CLIPPED;
    TVITEMEX ti;
    TCHAR szTemp[MAX_PATH];
    int iState = 0;
    HFONT hFont;                        //$BOLD
    DWORD dwRet;
    NMTVCUSTOMDRAW nmcd;
    BOOL fItemFocused = ((pTree->fFocus) && (hItem == pTree->hCaret));
    DWORD clrTextTemp, clrTextBkTemp;
    BOOL fSelectedIcon = FALSE;

    rc.top = y;
    rc.bottom = rc.top + (pTree->cyItem * hItem->iIntegral);
    rc.left = 0;
    rc.right = pTree->cxWnd;
    
    if (flags & TVDI_ERASE) {
        // Opaque the whole item
        FillRect(hdc, &rc, pTree->hbrBk);
    }
    
    
    // make sure the callbacks don't invalidate this item
    pTree->hItemPainting = hItem;	
    
    ti.pszText = szTemp;
    ti.cchTextMax  = ARRAYSIZE(szTemp);
    ti.stateMask = TVIS_OVERLAYMASK | TVIS_CUT | TVIS_BOLD; //$BOLD
    TV_GetItem(pTree, hItem, TVIF_IMAGE | TVIF_STATE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN | TVIF_PARAM, &ti);
    
    pTree->hItemPainting = NULL;
    
    
    ////////////////
    // set up the HDC

    if (TV_ShouldItemDrawBlue(pTree,&ti,flags)) {
        // selected 
        iBack = COLOR_HIGHLIGHT;
        iText = COLOR_HIGHLIGHTTEXT;
    } else if (TV_ShouldItemDrawDisabled(pTree, &pti, flags)) {
        iBack = COLOR_3DFACE;
        iText = COLOR_GRAYTEXT;
    } else if  (TV_ShouldItemDrawGray(pTree, &ti, flags)) {
        // On some color schemes, the BTNFACE color equals the WINDOW color,
        // and our gray comes out invisible.  In such case, change from gray
        // to blue so you can see it at all.
        if (GetSysColor(COLOR_WINDOW) != GetSysColor(COLOR_BTNFACE))
        {
            iBack = COLOR_BTNFACE;
            iText = COLOR_BTNTEXT;
        }
        else
        {
            iBack = COLOR_HIGHLIGHT;
            iText = COLOR_HIGHLIGHTTEXT;
        }
    } else {
        // not selected
        iBack = COLOR_WINDOW;
        iText = COLOR_WINDOWTEXT;
        if (hItem == pTree->hHot) {
            iText = COLOR_HOTLIGHT;
        }
    }
    
    if (iBack == COLOR_WINDOW && (pTree->clrBk != (COLORREF)-1))
        nmcd.clrTextBk = clrTextBkTemp = pTree->clrBk;
    else
        nmcd.clrTextBk = clrTextBkTemp = GetSysColor(iBack);

    if (iText == COLOR_WINDOWTEXT && (pTree->clrText != (COLORREF)-1))
        nmcd.clrText = clrTextTemp = pTree->clrText;
    else
        nmcd.clrText = clrTextTemp = GetSysColor(iText);

    // if forcing black and transparent, do so.  dc's BkMode should
    // already be set to TRANSPARENT by caller
    if (flags & TVDI_TRANSTEXT)
    {
        nmcd.clrText = clrTextTemp = 0x000000;
        etoFlags = 0;			// don't opaque nothin'
    }
    
    rgbOldBack = SetBkColor(hdc, nmcd.clrTextBk);
    rgbOldText = SetTextColor(hdc, nmcd.clrText);
    
    
#ifdef WINDOWS_ME
    if (pTree->ci.style & TVS_RTLREADING)
        etoFlags |= ETO_RTLREADING;
#endif
    
    // Figure out which font to use.    
    if (ti.state & TVIS_BOLD) {         
        hFont = pTree->hFontBold;
        if (hItem == pTree->hHot) {
            hFont = CCGetHotFont(pTree->hFontBold, &pTree->hFontBoldHot);
        }
    } else {                            
        hFont = pTree->hFont;
        if (hItem == pTree->hHot) {
            hFont = CCGetHotFont(pTree->hFont, &pTree->hFontHot);
        }
    }                                   
    hFont = SelectObject(hdc, hFont);   
    // End HDC setup
    ////////////////
    
    
    // notify on custom draw then do it!
    nmcd.nmcd.hdc = hdc;
    nmcd.nmcd.dwItemSpec = (DWORD_PTR)hItem;
    nmcd.nmcd.uItemState = 0;
    nmcd.nmcd.rc = rc;
    if (flags & TVDI_NOTREE)
        nmcd.iLevel = 0;
    else 
        nmcd.iLevel = hItem->iLevel;
    
    if (ti.state & TVIS_SELECTED) {
        
        fSelectedIcon = TRUE;
        
        if (pTree->fFocus || (pTree->ci.style & TVS_SHOWSELALWAYS))
            nmcd.nmcd.uItemState |= CDIS_SELECTED;
    }
    if (fItemFocused)
        nmcd.nmcd.uItemState |= CDIS_FOCUS;
    if (hItem == pTree->hHot)
        nmcd.nmcd.uItemState |= CDIS_HOT;

#ifdef KEYBOARDCUES
#if 0
    // BUGBUG: Custom draw stuff for UISTATE (stephstm)
    if (CCGetUIState(&(pTree->ci), KC_TBD))
        nmcd.nmcd.uItemState |= CDIS_SHOWKEYBOARDCUES;
#endif
#endif
    nmcd.nmcd.lItemlParam = ti.lParam;
    
    dwRet = CICustomDrawNotify(&pTree->ci, CDDS_ITEMPREPAINT, &nmcd.nmcd);
    if (dwRet & CDRF_SKIPDEFAULT) 
        return;
    
    fItemFocused = (nmcd.nmcd.uItemState & CDIS_FOCUS);
    if (nmcd.nmcd.uItemState & CDIS_SELECTED)
        ti.state |= TVIS_SELECTED;
    else {
        ti.state &= ~TVIS_SELECTED;
    }
    
    if (nmcd.clrTextBk != clrTextBkTemp)
        SetBkColor(hdc, nmcd.clrTextBk);
    
    if (nmcd.clrText != clrTextTemp)
        SetTextColor(hdc, nmcd.clrText);
    
    if (pTree->ci.style & TVS_FULLROWSELECT && 
         !(flags & TVDI_TRANSTEXT)) 
    {
        FillRectClr(hdc, &nmcd.nmcd.rc, GetBkColor(hdc));
        etoFlags |= ETO_OPAQUE;
        clrBk = CLR_NONE;
    }
    
    if (!(flags & TVDI_NOTREE)) {
        if ((pTree->ci.style & (TVS_HASLINES | TVS_HASBUTTONS)) &&
            (pTree->ci.style & TVS_LINESATROOT))
            // Make room for the "plus" at the front of the tree
            x += cxIndent;
    }
    
    
    // deal with margin, etc.
    x += (pTree->cxBorder + (nmcd.iLevel * cxIndent));
    y += pTree->cyBorder;
    
    // draw image
    if ((!(flags & TVDI_NOTREE) && !(dwRet & TVCDRF_NOIMAGES)) || (flags & TVDI_FORCEIMAGE))
    {
        int dx, dy;     // to clip the images within the borders.
        COLORREF clrImage = CLR_HILIGHT;
        COLORREF clrBkImage = clrBk;

        if (flags & TVDI_NOBK)
        {
            clrBkImage = CLR_NONE;
        }


        if (pTree->himlState) {
            iState = TV_StateIndex(&ti);
            // go figure.  in the treeview, 0 for the state image index
            // means draw nothing... the 0th item is unused.
            // the listview is 0 based and uses the 0th item.  
            if (iState) {
                dx = min(pTree->cxState, pTree->cxMax - pTree->cxBorder - x);
                dy = min(pTree->cyState, pTree->cyItem - (2 * pTree->cyBorder));
                ImageList_DrawEx(pTree->himlState, iState, hdc, x, 
                    y + max(pTree->cyItem - pTree->cyState, 0), dx, dy, clrBk, CLR_DEFAULT, ILD_NORMAL);
                x += pTree->cxState;            
            }
        }
        
        if (pTree->hImageList) {
            UINT fStyle = 0;
            int i = (fSelectedIcon) ? ti.iSelectedImage : ti.iImage;
            
            if (ti.state & TVIS_CUT) {
                fStyle |= ILD_BLEND50;
                clrImage = ImageList_GetBkColor(pTree->hImageList);
            }
            
            dx = min(pTree->cxImage - MAGIC_INDENT, pTree->cxMax - pTree->cxBorder - x);
            dy = min(pTree->cyImage, pTree->cyItem - (2 * pTree->cyBorder));
            ImageList_DrawEx(pTree->hImageList, i, hdc,
                x, y + (max(pTree->cyItem - pTree->cyImage, 0) / 2), dx, dy,
                clrBkImage, clrImage,
                fStyle | (ti.state & TVIS_OVERLAYMASK));
            
        }
    }
    
    if (pTree->hImageList) {
        // even if not drawing image, draw text in right place
        x += pTree->cxImage;
    }
    
    // draw text
    lpstr = ti.pszText;
    cch = lstrlen(lpstr);
    
    if (!hItem->iWidth || (hItem->lpstr == LPSTR_TEXTCALLBACK))
    {
        TV_ComputeItemWidth(pTree, hItem, hdc); //$BOLD
    }
    
    rc.left = x;
    rc.top = y + pTree->cyBorder;
    rc.right = min((x + hItem->iWidth),
                   (pTree->cxMax - pTree->cxBorder));
    rc.bottom-= pTree->cyBorder;
    
    // Draw the text, unless it's the one we are editing
    if (pTree->htiEdit != hItem || !IsWindow(pTree->hwndEdit) || !IsWindowVisible(pTree->hwndEdit))
    {
        ExtTextOut(hdc, x + g_cxLabelMargin, y + ((pTree->cyItem - pTree->cyText) / 2) + g_cyBorder,
            etoFlags, &rc, lpstr, cch, NULL);
    
        // Draw the focus rect, if appropriate.
        if (pTree->fFocus && (fItemFocused) && 
            !(pTree->ci.style & TVS_FULLROWSELECT) &&
            !(flags & (TVDI_TRANSTEXT | TVDI_GRAYCTL))
#ifdef KEYBOARDCUES
			&& !(CCGetUIState(&(pTree->ci)) & UISF_HIDEFOCUS)
#endif
			)
            DrawFocusRect(hdc, &rc);
    }
    
    SetBkColor(hdc, rgbOldBack);
    SetTextColor(hdc, rgbOldText);
    
    // Restore the original font.       //$BOLD
    SelectObject(hdc, hFont);           //$BOLD
    
    // Notice that we should have opaque'd the rest of the line above if no tree
    if (!(flags & TVDI_NOTREE))
    {
        int dx, dy;
        
        if (pTree->hImageList)
            x -= pTree->cxImage;
        
        if (iState)
            x -= pTree->cxState;
        
        if (pTree->ci.style & TVS_HASLINES)
        {
            int i;

            x -= cxIndent;
            if (nmcd.iLevel-- || (pTree->ci.style & TVS_LINESATROOT))
            {
                // HACK: Special case the first root
                // We will draw a "last" sibling button upside down
                if (nmcd.iLevel == -1 && hItem == hItem->hParent->hKids)
                {
                    if (hItem->hNext) {
                        i = 2;              // "L"
                        if (ti.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
                        {
                            i += 2;         // "L+"
                            if ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED)
                                i += 2;     // "L-"
                        }
                        
                        dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                        dy = pTree->cyItem - (2 * pTree->cyBorder);
                        StretchBlt(hdc, x, y + pTree->cyItem, cxIndent, -pTree->cyItem, pTree->hdcBits
                            , i * cxIndent, 0, dx, dy, SRCCOPY);
                        i = -1;
                    }
                    else 
                    {
                        // first root no siblings
                        // if there's no other item, draw just the button if button mode,
                        if (pTree->ci.style & TVS_HASBUTTONS)
                        {
                            if (ti.cChildren) {
                                // hasbuttons, has lines, lines at root
                                i = ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED) ? 
                                    9 : 8;  // ".--" : ".-+"
                            } else {
                                i = 7;      // ".-"
                            }
                        }
                        else
                        {
                            i = 3;          // ".-"
                        }
                    }
                }
                else
                {
                    i = (hItem->hNext) ? 1 : 2; // "|-" (rep) : "L"
                    if (ti.cChildren && (pTree->ci.style & TVS_HASBUTTONS))
                    {
                        i += 2;                 // "|-+" (rep) : "L+"
                        if ((ti.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL)) == TVIS_EXPANDED)
                            i += 2;             // "|--" (rep) : "L-"
                    }
                }
                if (hItem->iIntegral > 1)
                    TV_DrawKinDescender(pTree, hdc, x, y, hItem, ti.state);

                if (i != -1)
                {
                    dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                    dy = pTree->cyItem - (2 * pTree->cyBorder);
                    if ((dx > 0) && (dy > 0))
                        BitBlt(hdc, x, y, dx, dy, pTree->hdcBits
                            , i * cxIndent, 0, SRCCOPY);
                }
                
                while ((--nmcd.iLevel >= 0) || ((pTree->ci.style & TVS_LINESATROOT) && nmcd.iLevel >= -1))
                {
                    hItem = hItem->hParent;
                    x -= cxIndent;
                    if (hItem->hNext)
                    {
                        dx = min((int)cxIndent, (pTree->cxMax - pTree->cxBorder - x));
                        dy = min(pTree->cyItem, pTree->cyWnd - pTree->cyBorder - y);
                        if ((dx > 0) && (dy > 0))
                            BitBlt(hdc, x, y, dx, dy, pTree->hdcBits, 0, 0, SRCCOPY);
                        TV_DrawDescender(pTree, hdc, x, y, hItemSave);
                    }
                }
            }
        }
        else
        {               // no lines
            if ((pTree->ci.style & TVS_HASBUTTONS) && (nmcd.iLevel || pTree->ci.style & TVS_LINESATROOT)
                && ti.cChildren)
            {
                int i = (ti.state & TVIS_EXPANDED) ? cxIndent : 0;
                
                x -= cxIndent;
                dx = min((int)cxIndent, pTree->cxMax - pTree->cxBorder - x);
                dy = min(pTree->cyItem, pTree->cyWnd - pTree->cyBorder - y);
                if ((dx > 0) && (dy > 0))
                    BitBlt(hdc, x, y, dx, dy, pTree->hdcBits, i, 0, SRCCOPY);
            }
        }
    }
    
    
    if (dwRet & CDRF_NOTIFYPOSTPAINT) {
        nmcd.nmcd.dwItemSpec = (DWORD_PTR)hItemSave;
        CICustomDrawNotify(&pTree->ci, CDDS_ITEMPOSTPAINT, &nmcd.nmcd);
    }
}

#define INSERTMARKSIZE      6

BOOL TV_GetInsertMarkRect(PTREE pTree, LPRECT prc)
{
    ASSERT(pTree);

    if(pTree->htiInsert && TV_GetItemRect(pTree, pTree->htiInsert, prc, TRUE))
    {
        if (pTree->fInsertAfter)
            prc->top = prc->bottom;
        else
            prc->bottom = prc->top;
        
        prc->top -= INSERTMARKSIZE/2;
        prc->bottom += INSERTMARKSIZE/2 + 1;
        prc->right = pTree->cxWnd - INSERTMARKSIZE;      // should always go all the way to right with pad.
        prc->left -= pTree->cxImage;
        
        return TRUE;
    }
    return FALSE;
}

//  this is implemented in toolbar.c, but we should be able to use 
//  as well as long as we always set fHorizMode to FALSE
void PASCAL DrawInsertMark(HDC hdc, LPRECT prc, BOOL fHorizMode, COLORREF clr);

__inline COLORREF TV_GetInsertMarkColor(PTREE pTree)
{
    if (pTree->clrim == CLR_DEFAULT)
        return g_clrWindowText;
    else
        return pTree->clrim;
}

void NEAR TV_DrawTree(PTREE pTree, HDC hdc, BOOL fErase, LPRECT lprc)
{
    int x;
    int iStart, iCnt;
    UINT uFlags;
    RECT rc;
    NMCUSTOMDRAW nmcd;
    
    if (!pTree->fRedraw)
        return;

    if (pTree->ci.style & TVS_CHECKBOXES)
        if (!pTree->himlState)
            TV_InitCheckBoxes(pTree);
    
    x = -pTree->xPos;
    
    TV_GetBackgroundBrush(pTree, hdc);
    
    rc = *lprc;
    
#ifdef MAINWIN
    if (lprc->top <= 0) { /* fix microsoft BUG */
        iStart = 0;
    } else {
        iStart = lprc->top / pTree->cyItem;
    }
#else
    iStart = lprc->top / pTree->cyItem;
#endif

    if (pTree->cItems && pTree->hTop) {
        ASSERT(ITEM_VISIBLE(pTree->hTop));

        iCnt = pTree->cShowing - pTree->hTop->iShownIndex;
    } else {
        iCnt = 0;                   // Nothing to draw
    }

    nmcd.hdc = hdc;
    /// not implemented yet
    //if (ptb->ci.hwnd == GetFocus()) 
    //nmcd.uItemState = CDIS_FOCUS;
    //else 
    nmcd.uItemState = 0;
    nmcd.lItemlParam = 0;
    nmcd.rc = rc;
    pTree->ci.dwCustom = CICustomDrawNotify(&pTree->ci, CDDS_PREPAINT, &nmcd);
    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        
        if (iStart < iCnt)
        {
            HTREEITEM   hItem;
            HFONT       hOldFont;
            RECT        rcT;
            int y = 0;
            
            for (hItem = pTree->hTop; hItem; ) {
                if (iStart > hItem->iIntegral) {
                    iStart -= hItem->iIntegral;
                    y += hItem->iIntegral * pTree->cyItem;
                    hItem = TV_GetNextVisItem(hItem);
                } else
                    break;
            }
            
            hOldFont = pTree->hFont ? SelectObject(hdc, pTree->hFont) : NULL;
            
            // TVDI_* for all items
            uFlags = (pTree->ci.style & WS_DISABLED) ? TVDI_GRAYCTL : 0;
            if (fErase)
                uFlags |= TVDI_ERASE;
            
            // loop from the first visible item until either all visible items are
            // drawn or there are no more items to draw
            for ( ; hItem && y < lprc->bottom; hItem = TV_GetNextVisItem(hItem))
            {
                TV_DrawItem(pTree, hItem, hdc, x, y, uFlags);
                y += pTree->cyItem * hItem->iIntegral;
            }
            
            //
            // handle drawing the InsertMark next to this item.
            //
            if(TV_GetInsertMarkRect(pTree, &rcT))
                DrawInsertMark(hdc, &rcT, FALSE, TV_GetInsertMarkColor(pTree));

            
            if (hOldFont)
                SelectObject(hdc, hOldFont);
            
            rc.top = y;
        }
        
        if (fErase)
            // Opaque out everything we have not drawn explicitly
            FillRect(hdc, &rc, pTree->hbrBk);
        
        // notify parent afterwards if they want us to
        if (pTree->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
            CICustomDrawNotify(&pTree->ci, CDDS_POSTPAINT, &nmcd);
        }
    }

}


// ----------------------------------------------------------------------------
//
//  Set up for paint, call DrawTree, and clean up after paint.
//
// ----------------------------------------------------------------------------

void NEAR TV_Paint(PTREE pTree, HDC hdc)
{
    PAINTSTRUCT ps;
    
    if (hdc)
    {
        // hdc != 0 indicates a subclassed paint -- use the hdc passed in
        SetRect(&ps.rcPaint, 0, 0, pTree->cxWnd, pTree->cyWnd);
        TV_DrawTree(pTree, hdc, TRUE, &ps.rcPaint);
    }
    else
    {
        BeginPaint(pTree->ci.hwnd, &ps);
        TV_DrawTree(pTree, ps.hdc, ps.fErase, &ps.rcPaint);
        EndPaint(pTree->ci.hwnd, &ps);
    }
}

// ----------------------------------------------------------------------------
// Create an imagelist to be used for dragging.
//
// 1) create mask and image bitmap matching the select bounds size
// 2) draw the text to both bitmaps (in black for now)
// 3) create an imagelist with these bitmaps
// 4) make a dithered copy of the image onto the new imagelist
// ----------------------------------------------------------------------------

HIMAGELIST NEAR TV_CreateDragImage(PTREE pTree, HTREEITEM hItem)
{
    HDC hdcMem = NULL;
    HBITMAP hbmImage = NULL;
    HBITMAP hbmMask = NULL;
    HBITMAP hbmOld;
    HIMAGELIST himl = NULL;
    BOOL bMirroredWnd = (pTree->ci.dwExStyle&RTL_MIRRORED_WINDOW);
    int dx, dy;
    int iSrc;

    TVITEMEX ti;

    if (!pTree->hImageList)
        return NULL;

    if (hItem == NULL)
        hItem = pTree->htiDrag;

    if (hItem == NULL)
        return NULL;

    
    // BUGBUG??? we know it's already been drawn, so is iWidth valid???
    dx = hItem->iWidth + pTree->cxImage;
    dy = pTree->cyItem;
    
    if (!(hdcMem = CreateCompatibleDC(NULL)))
        goto CDI_Exit;
    if (!(hbmImage = CreateColorBitmap(dx, dy)))
        goto CDI_Exit;
    if (!(hbmMask = CreateMonoBitmap(dx, dy)))
        goto CDI_Exit;
    
    //
    // Mirror the memory DC so that the transition from
    // mirrored(memDC)->non-mirrored(imagelist DCs)->mirrored(screenDC)
    // is consistent. [samera]
    //
    if (bMirroredWnd) {
        SET_DC_RTL_MIRRORED(hdcMem);
    }

    // prepare for drawing the item
    if (pTree->hFont)
        SelectObject(hdcMem, pTree->hFont);
    SetBkMode(hdcMem, TRANSPARENT);
    
    /*
    ** draw the text to both bitmaps
    */
    hbmOld = SelectObject(hdcMem, hbmImage);
    // fill image with black for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, BLACKNESS);
    TV_DrawItem(pTree, hItem, hdcMem, 0, 0,
        TVDI_NOIMAGE | TVDI_NOTREE | TVDI_TRANSTEXT);

    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmImage);

    SelectObject(hdcMem, hbmMask);
    // fill mask with white for transparency
    PatBlt(hdcMem, 0, 0, dx, dy, WHITENESS);
    TV_DrawItem(pTree, hItem, hdcMem, 0, 0,
        TVDI_NOIMAGE | TVDI_NOTREE | TVDI_TRANSTEXT);
    
    //
    // If the header is RTL mirrored, then
    // mirror the Memory DC, so that when copying back
    // we don't get any image-flipping. [samera]
    //
    if (bMirroredWnd)
        MirrorBitmapInDC(hdcMem, hbmMask);

    // unselect objects that we used
    SelectObject(hdcMem, hbmOld);
    SelectObject(hdcMem, g_hfontSystem);
    
    /*
    ** make an image list that for now only has the text
    */
    //
    // BUGBUG: To fix a pri-1 M7 bug, we create a shared image list.
    //
    if (!(himl = ImageList_Create(dx, dy, ILC_MASK, 1, 0)))
        goto CDI_Exit;
    ImageList_SetBkColor(himl, CLR_NONE);
    ImageList_Add(himl, hbmImage, hbmMask);
    
    /*
    ** make a dithered copy of the image part onto our bitmaps
    ** (need both bitmap and mask to be dithered)
    */
    TV_GetItem(pTree, hItem, TVIF_IMAGE, &ti);
    iSrc = ti.iImage;
    
    ImageList_CopyDitherImage(himl, 0, 0, (pTree->cyItem - pTree->cyImage) / 2,
        pTree->hImageList, iSrc, ((pTree->ci.dwExStyle & dwExStyleRTLMirrorWnd) ? ILD_MIRROR : 0L) | (hItem->state & TVIS_OVERLAYMASK));

CDI_Exit:
    if (hdcMem)
        DeleteObject(hdcMem);
    if (hbmImage)
        DeleteObject(hbmImage);
    if (hbmMask)
        DeleteObject(hbmMask);
    
    return himl;
}

#define COLORKEY RGB(0xF4, 0x0, 0x0)

LRESULT TV_GenerateDragImage(PTREE pTree, SHDRAGIMAGE* pshdi)
{
    LRESULT lRet = 0;
    HBITMAP hbmpOld = NULL;
    HTREEITEM hItem = pTree->htiDrag;
    RECT rc;
    HDC  hdcDragImage;

    if (hItem == NULL)
        return FALSE;

    hdcDragImage = CreateCompatibleDC(NULL);

    if (!hdcDragImage)
        return 0;

    // After this rc contains the bounds of all the items in Client Coordinates.
    //
    // Mirror the the DC, if the listview is mirrored.
    //
    if (pTree->ci.dwExStyle & RTL_MIRRORED_WINDOW)
    {
        SET_DC_RTL_MIRRORED(hdcDragImage);
    }

    TV_GetItemRect(pTree, hItem, &rc, TRUE);

    // Subtract off the image...
    rc.left -= pTree->cxImage;

    pshdi->sizeDragImage.cx = RECTWIDTH(rc);
    pshdi->sizeDragImage.cy = RECTHEIGHT(rc);
    pshdi->hbmpDragImage = CreateBitmap( pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy,
        GetDeviceCaps(hdcDragImage, PLANES), GetDeviceCaps(hdcDragImage, BITSPIXEL),
        NULL);

    if (pshdi->hbmpDragImage)
    {
        COLORREF clrBkSave;
        RECT  rcImage = {0, 0, pshdi->sizeDragImage.cx, pshdi->sizeDragImage.cy};

        hbmpOld = SelectObject(hdcDragImage, pshdi->hbmpDragImage);

        pshdi->crColorKey = COLORKEY;
        FillRectClr(hdcDragImage, &rcImage, pshdi->crColorKey);

        // Calculate the offset... The cursor should be in the bitmap rect.

        if (pTree->ci.dwExStyle & RTL_MIRRORED_WINDOW)
            pshdi->ptOffset.x = rc.right - pTree->ptCapture.x;
        else
            pshdi->ptOffset.x = pTree->ptCapture.x - rc.left;

        pshdi->ptOffset.y = pTree->ptCapture.y - rc.top;

        clrBkSave = pTree->clrBk;

        pTree->clrBk = COLORKEY;

        TV_DrawItem(pTree, hItem, hdcDragImage, 0, 0,
            TVDI_NOTREE | TVDI_TRANSTEXT | TVDI_FORCEIMAGE | TVDI_NOBK);

        pTree->clrBk = clrBkSave;

        SelectObject(hdcDragImage, hbmpOld);
        DeleteDC(hdcDragImage);

        // We're passing back the created HBMP.
        return 1;
    }


    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\unicwrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       unicwrap.h
//
//  Contents:   Wrappers for all Unicode functions used in the Forms^3 project.
//
//----------------------------------------------------------------------------

#ifndef _UNICWRAP_H_
#define _UNICWRAP_H_

HFONT WINAPI CreateFontIndirectWrap(CONST LOGFONTW * plfw);

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStr (CStr)
//
//  Purpose:    Base class for conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStr
{
public:
    operator char *();

protected:
    CConvertStr(UINT uCP);
    ~CConvertStr();
    void Free();

    UINT    _uCP;
    LPSTR   _pstr;
    char    _ach[MAX_PATH * 2];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::CConvertStr
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::CConvertStr(UINT uCP)
{
    _uCP = uCP;
    _pstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::~CConvertStr
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::~CConvertStr()
{
    Free();
}





//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CConvertStr::operator char *()
{
    return _pstr;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrIn (CStrI)
//
//  Purpose:    Converts string function arguments which are passed into
//              a Windows API.
//
//----------------------------------------------------------------------------

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr);
    CStrIn(LPCWSTR pwstr, int cwch);
    CStrIn(UINT uCP, LPCWSTR pwstr);
    CStrIn(UINT uCP, LPCWSTR pwstr, int cwch);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch);

    int _cchLen;
};




//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class with a given length
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn(LPCWSTR pwstr, int cwch) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwch);
}

inline
CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr, int cwch) : CConvertStr(uCP)
{
    Init(pwstr, cwch);
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn() : CConvertStr(CP_ACP)
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrIn::strlen()
{
    return _cchLen;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIM)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr);
};



//+---------------------------------------------------------------------------
//
//  Class:      CStrOut (CStrO)
//
//  Purpose:    Converts string function arguments which are passed out
//              from a Windows API.
//
//----------------------------------------------------------------------------

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();

private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOut::BufSize()
{
    return _cwchBuf * 2;
}





//
//      Multi-Byte ---> Unicode conversion
//

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStrW (CStr)
//
//  Purpose:    Base class for multibyte conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * 2];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::CConvertStrW
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::~CConvertStrW
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::~CConvertStrW()
{
    Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::operator WCHAR *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline 
CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}


//+---------------------------------------------------------------------------
//
//  Class:      CStrInW (CStrI)
//
//  Purpose:    Converts multibyte strings into UNICODE
//
//----------------------------------------------------------------------------

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr) { Init(pstr, -1); }
    CStrInW(LPCSTR pstr, int cch) { Init(pstr, cch); }
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch);

    int _cwchLen;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrInW::CStrInW()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrInW::strlen()
{
    return _cwchLen;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOutW (CStrO)
//
//  Purpose:    Converts returned unicode strings into ANSI.  Used for [out]
//                              params (so we initialize with a buffer that should later be
//                              filled with the correct ansi data)
//                      
//
//----------------------------------------------------------------------------

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf);
    ~CStrOutW();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();

private:
    LPSTR       _pstr;
    int     _cchBuf;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOutW::BufSize()
{
    return _cchBuf;
}



#endif // _UNICWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\multilingual\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\tvscroll.c ===
#include "ctlspriv.h"
#include "treeview.h"

BOOL NEAR TV_EnsureVisible(PTREE pTree, TREEITEM FAR * hItem);

// ----------------------------------------------------------------------------
//
//  Updates the iShownIndex for every item below (in list order) a given item
//
// ----------------------------------------------------------------------------

int NEAR TV_UpdateShownIndexes(PTREE pTree, HTREEITEM hWalk)
{
    WORD iShownIndex;

    if (hWalk == pTree->hRoot) {
        hWalk = pTree->hRoot->hKids;
        if (hWalk) {
            hWalk->iShownIndex = 0;
        } else {
            return -1;
        }
    }

    iShownIndex = hWalk->iShownIndex + hWalk->iIntegral;
    if (iShownIndex <= 0)
    {
        // BUGBUG: We should #define the special TVITEM_HIDDEN value and check
        // for it explicitly
        // This can happen if TV_SortCB passes in a hidden item
        return(-1);
    }

    while ((hWalk = TV_GetNextVisItem(hWalk)) != NULL) {
        hWalk->iShownIndex = iShownIndex;
        iShownIndex += (WORD) hWalk->iIntegral;
    }

//#ifdef DEBUG
//      TraceMsg(TF_TREEVIEW, "tv: updated show indexes (now %d items)", (int)iShownIndex);
//#endif
    return (int)iShownIndex;
}

//
// in:
//      hItem   expanded node to count decendants of
//
// returns:
//      total number of expanded descendants below the given item.
//

UINT NEAR TV_CountVisibleDescendants(HTREEITEM hItem)
{
    UINT cnt;

    for (cnt = 0, hItem = hItem->hKids; hItem; hItem = hItem->hNext)
    {
        cnt += hItem->iIntegral;
        if (hItem->hKids && (hItem->state & TVIS_EXPANDED))
            cnt += TV_CountVisibleDescendants(hItem);
    }
    return cnt;
}

//  scrolls nItems in the direction of fDown starting from iTopShownIndex
void TV_ScrollItems(PTREE pTree, int nItems, int iTopShownIndex, BOOL fDown)
{
    RECT rc;
    rc.left = 0;
    rc.top = (iTopShownIndex+1) * pTree->cyItem;
    rc.right = pTree->cxWnd;
    rc.bottom = pTree->cyWnd;

    {
#ifndef UNIX
        SMOOTHSCROLLINFO si =
        {
            sizeof(si),
            SSIF_MINSCROLL | SSIF_MAXSCROLLTIME,
            pTree->ci.hwnd,
            0,
            ((fDown)?1:-1) * nItems * pTree->cyItem,
            &rc,
            &rc,
            NULL,
            NULL,
            SW_ERASE|SW_INVALIDATE,
            pTree->uMaxScrollTime,
            1,
            1
        };
#else
        SMOOTHSCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SSIF_MINSCROLL | SSIF_MAXSCROLLTIME;
        si.hwnd = pTree->ci.hwnd;
        si.dx = 0;
        si.dy = ((fDown)?1:-1) * nItems * pTree->cyItem;
        si.lprcSrc = &rc;
        si.lprcClip = &rc;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_ERASE|SW_INVALIDATE;
        si.uMaxScrollTime = pTree->uMaxScrollTime;
        si.cxMinScroll = 1;
        si.cyMinScroll = 1;
        si.pfnScrollProc = NULL;
#endif

        SmoothScrollWindow(&si);
    }
    TV_UpdateToolTip(pTree);
}

//
//  If fRedrawParent is FALSE, then the return value is garbage.
//  If fRedrawParent is TRUE, then returns the number of children scrolled.
//
//  Does not update iShownIndex for any items.
//
UINT NEAR TV_ScrollBelow(PTREE pTree, HTREEITEM hItem, BOOL fRedrawParent, BOOL fDown)
{
    int     iTop;
    UINT    cnt;

    // Do nothing if the item is not visible
    if (!ITEM_VISIBLE(hItem))
        return 0;
    
    cnt = hItem->iIntegral; // default return val
    if (pTree->fRedraw) {
        UINT cVisDesc;
        BOOL fEffect;

        // iTop is the top edge (client coordinates) of the bottom integral
        // cell of the item that just got expanded/contracted.
        // (Confused yet?  I sure am.)
        iTop = hItem->iShownIndex - pTree->hTop->iShownIndex + hItem->iIntegral - 1;
        cVisDesc = TV_CountVisibleDescendants(hItem);

        // See if the item being expanded/contracted has any effect on the
        // screen.  If not, then don't TV_ScrollItems or we will end up
        // double-counting them when we do post-scroll adjustment.
        if (fDown)
        {
            // When scrolling down, we have an effect if the item that just
            // got expanded was below the top of the screen
            fEffect = iTop >= 0;
        }
        else
        {
            // When scrolling up, we have an effect if any of the items
            // that just got collapsed out were below the top of the screen
            fEffect = (int)(iTop + cVisDesc) >= 0;
        }

        if (fEffect)
            TV_ScrollItems(pTree, cVisDesc, iTop, fDown);
        TV_InvalidateItem(pTree, hItem, TRUE);

        if (fRedrawParent)
            cnt = cVisDesc;

    } else {

        if (fRedrawParent)
            cnt = TV_CountVisibleDescendants(hItem);

    }

    return(cnt);
}

// The FakeCustomDraw functions are used when you want the customdraw client
// to set up a HDC so you can do stuff like GetTextExtent.
//
//  Usage:
//
//      TVFAKEDRAW tvfd;
//      TreeView_BeginFakeCustomDraw(pTree, &tvfd);
//      for each item you care about {
//          TreeView_BeginFakeItemDraw(&tvfd, hitem);
//          <party on the HDC in tvfd.nmcd.nmcd.hdc>
//          TreeView_EndFakeItemDraw(&tvfd);
//      }
//      TreeView_EndFakeCustomDraw(&tvfd);
//

void TreeView_BeginFakeCustomDraw(PTREE pTree, PTVFAKEDRAW ptvfd)
{
    ptvfd->nmcd.nmcd.hdc = GetDC(pTree->ci.hwnd);
    ptvfd->nmcd.nmcd.uItemState = 0;
    ptvfd->nmcd.nmcd.dwItemSpec = 0;
    ptvfd->nmcd.nmcd.lItemlParam = 0;
    ptvfd->hfontPrev = (HFONT)GetCurrentObject(ptvfd->nmcd.nmcd.hdc, OBJ_FONT);

    //
    //  Since we aren't actually painting anything, we pass an empty
    //  paint rectangle.  Gosh, I hope no app faults when it sees an
    //  empty paint rectangle.
    //
    SetRectEmpty(&ptvfd->nmcd.nmcd.rc);

    ptvfd->pTree = pTree;
    ptvfd->dwCustomPrev = pTree->ci.dwCustom;

    pTree->ci.dwCustom = CIFakeCustomDrawNotify(&pTree->ci, CDDS_PREPAINT, &ptvfd->nmcd.nmcd);
}

DWORD TreeView_BeginFakeItemDraw(PTVFAKEDRAW ptvfd, HTREEITEM hitem)
{
    PTREE pTree = ptvfd->pTree;

    // Note that if the client says CDRF_SKIPDEFAULT (i.e., is owner-draw)
    // we measure the item anyway, because that's what IE4 did.

    ptvfd->nmcd.nmcd.dwItemSpec = (DWORD_PTR)hitem;
    ptvfd->nmcd.nmcd.lItemlParam = hitem->lParam;

    if (hitem->state & TVIS_BOLD) {
        SelectFont(ptvfd->nmcd.nmcd.hdc, pTree->hFontBold);
    } else {
        SelectFont(ptvfd->nmcd.nmcd.hdc, pTree->hFont);
    }

    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT)) {
        // Font should not depend on colors or flags since those change
        // dynamically but we cache the width info forever.  So we don't
        // need to set up uItemState.
        ptvfd->nmcd.clrText = pTree->clrText;
        ptvfd->nmcd.clrTextBk = pTree->clrBk;
        ptvfd->nmcd.iLevel = hitem->iLevel;
        ptvfd->dwCustomItem = CIFakeCustomDrawNotify(&pTree->ci, CDDS_ITEMPREPAINT, &ptvfd->nmcd.nmcd);
    } else {
        ptvfd->dwCustomItem = CDRF_DODEFAULT;
    }

    return ptvfd->dwCustomItem;
}

void TreeView_EndFakeItemDraw(PTVFAKEDRAW ptvfd)
{
    PTREE pTree = ptvfd->pTree;

    if (!(ptvfd->dwCustomItem & CDRF_SKIPDEFAULT) &&
         (ptvfd->dwCustomItem & CDRF_NOTIFYPOSTPAINT)) {
        CIFakeCustomDrawNotify(&pTree->ci, CDDS_ITEMPOSTPAINT, &ptvfd->nmcd.nmcd);
    }
}

void TreeView_EndFakeCustomDraw(PTVFAKEDRAW ptvfd)
{
    PTREE pTree = ptvfd->pTree;

    // notify parent afterwards if they want us to
    if (!(pTree->ci.dwCustom & CDRF_SKIPDEFAULT) &&
        pTree->ci.dwCustom & CDRF_NOTIFYPOSTPAINT) {
        CIFakeCustomDrawNotify(&pTree->ci, CDDS_POSTPAINT, &ptvfd->nmcd.nmcd);
    }

    // Restore previous state
    pTree->ci.dwCustom = ptvfd->dwCustomPrev;
    SelectObject(ptvfd->nmcd.nmcd.hdc, ptvfd->hfontPrev);
    ReleaseDC(pTree->ci.hwnd, ptvfd->nmcd.nmcd.hdc);
}


// ----------------------------------------------------------------------------
//
//  Returns the width of the widest shown item in the tree
//
// ----------------------------------------------------------------------------

UINT NEAR TV_RecomputeMaxWidth(PTREE pTree)
{
    if (!(pTree->ci.style & TVS_NOSCROLL)) {
        HTREEITEM hItem;
        WORD wMax = 0;

        // REVIEW: this might not be the most efficient traversal of the tree

        for (hItem = pTree->hRoot->hKids; hItem; hItem = TV_GetNextVisItem(hItem))
        {
            if (wMax < FULL_WIDTH(pTree, hItem))
                wMax = FULL_WIDTH(pTree, hItem);
        }

        return((UINT)wMax);
    } else {
        return pTree->cxWnd;
    }
}


// ----------------------------------------------------------------------------
//
//  Returns the horizontal text extent of the given item's text
//
// ----------------------------------------------------------------------------

WORD NEAR TV_GetItemTextWidth(HDC hdc, PTREE pTree, HTREEITEM hItem)
{
    TVITEMEX sItem;
    TCHAR szTemp[MAX_PATH];
    SIZE size = {0,0};

    sItem.pszText = szTemp;
    sItem.cchTextMax = ARRAYSIZE(szTemp);

    TV_GetItem(pTree, hItem, TVIF_TEXT, &sItem);

    GetTextExtentPoint(hdc, sItem.pszText, lstrlen(sItem.pszText), &size);
    return (WORD)(size.cx + (g_cxLabelMargin * 2));
}


// ----------------------------------------------------------------------------
//
//  Compute the text extent and the full width (indent, image, and text) of
//  the given item.
//
//  If there is a HDC, then we assume that the HDC has been set up with
//  the proper attributes (specifically, the font).  If there is no HDC,
//  then we will set one up, measure the text, then tear it down.
//  If you will be measuring more than one item, it is recommended that
//  the caller set up the HDC and keep re-using it, because creating,
//  initializing, then destroy the HDC is rather slow.
//
// ----------------------------------------------------------------------------

void NEAR TV_ComputeItemWidth(PTREE pTree, HTREEITEM hItem, HDC hdc)
{
    TVFAKEDRAW  tvfd;                    // in case client uses customdraw
    int iOldWidth = hItem->iWidth;

    if (hdc == NULL) {
        TreeView_BeginFakeCustomDraw(pTree, &tvfd);
        TreeView_BeginFakeItemDraw(&tvfd, hItem);
    }
    else
    {
        tvfd.nmcd.nmcd.hdc = hdc;
    }
    
    hItem->iWidth = TV_GetItemTextWidth(tvfd.nmcd.nmcd.hdc, pTree, hItem);

    if (!(pTree->ci.style & TVS_NOSCROLL) && iOldWidth != hItem->iWidth)
        if (pTree->cxMax < FULL_WIDTH(pTree, hItem)) {
            PostMessage(pTree->ci.hwnd, TVMP_CALCSCROLLBARS, 0, 0);
            pTree->cxMax = FULL_WIDTH(pTree, hItem);
        }
    
    if (hdc == NULL)
    {
        TreeView_EndFakeItemDraw(&tvfd);
        TreeView_EndFakeCustomDraw(&tvfd);
    }
}


// ----------------------------------------------------------------------------
//
//  Returns TRUE if the item is expanded, FALSE otherwise
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_IsShowing(HTREEITEM hItem)
{
    for (hItem = hItem->hParent; hItem; hItem = hItem->hParent)
        if (!(hItem->state & TVIS_EXPANDED))
            return FALSE;

    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  If the added item is showing, update the shown (expanded) count, the max
//  item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterAdd(PTREE pTree, HTREEITEM hItem)
{
    HTREEITEM   hPrev;

    if (!TV_IsShowing(hItem))
    {
        // item isn't visible -- set index to NOTVISIBLE and return
        hItem->iShownIndex = (WORD)-1;
        return FALSE;
    }

    hPrev = TV_GetPrevVisItem(hItem);

    // increment every shown index after newly added item

    hItem->iShownIndex = (hPrev) ? hPrev->iShownIndex + hPrev->iIntegral : 0;

    TV_UpdateShownIndexes(pTree, hItem);

    pTree->cShowing += hItem->iIntegral;

    TV_ComputeItemWidth(pTree, hItem, NULL);

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  If the removed item was showing, update the shown (expanded) count, the max
//  item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterRemove(PTREE pTree, HTREEITEM hItem)
{
    HTREEITEM hWalk;
    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    // decrement every shown index after removed item
    hItem->iShownIndex = (WORD)-1;

    hWalk = TV_GetNextVisItem(hItem);
    if (hWalk) {
        hWalk->iShownIndex -= (WORD) hItem->iIntegral;
        TV_UpdateShownIndexes(pTree, hWalk);

        // If we delete the top item, the tree scrolls to the end, so ...
        if (pTree->hTop == hItem) {
            TV_SetTopItem(pTree, hWalk->iShownIndex);
            ASSERT(pTree->hTop != hItem);
        }
    }

    pTree->cShowing -= hItem->iIntegral;

    if (pTree->fRedraw) {
        if (!hItem->iWidth)
            TV_ComputeItemWidth(pTree, hItem, NULL);


        if (!(pTree->ci.style & TVS_NOSCROLL))
            if (pTree->cxMax == FULL_WIDTH(pTree, hItem))
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);

        TV_CalcScrollBars(pTree);
    }
    return TRUE;
}


// ----------------------------------------------------------------------------
//
//  Common worker function for
//  TV_ScrollBarsAfterExpand and TV_ScrollBarsAfterCollapse, since they
//  are completely identical save for two lines of code.
//
//  If the expanded items are / collapsed items were showing, update
//  the shown (expanded) count, the max item width -- then recompute
//  the scroll bars.
//
// ----------------------------------------------------------------------------

#define SBAEC_COLLAPSE  0
#define SBAEC_EXPAND    1

BOOL NEAR TV_ScrollBarsAfterExpandCollapse(PTREE pTree, HTREEITEM hParent, UINT flags)
{
    WORD cxMax = 0;
    HTREEITEM hWalk;
    TVFAKEDRAW tvfd;

    if (!ITEM_VISIBLE(hParent))
        return FALSE;

    //
    // We're going to be measuring a lot of items, so let's set up
    // our DC ahead of time.
    //
    TreeView_BeginFakeCustomDraw(pTree, &tvfd);

    for (hWalk = hParent->hKids;
         hWalk && (hWalk->iLevel > hParent->iLevel);
         hWalk = TV_GetNextVisItem(hWalk))
    {
         if (flags == SBAEC_COLLAPSE)
            hWalk->iShownIndex = (WORD)-1;
         if (!hWalk->iWidth)
         {
            TreeView_BeginFakeItemDraw(&tvfd, hWalk);
            TV_ComputeItemWidth(pTree, hWalk, tvfd.nmcd.nmcd.hdc);
            TreeView_EndFakeItemDraw(&tvfd);
         }
         if (cxMax < FULL_WIDTH(pTree, hWalk))
             cxMax = FULL_WIDTH(pTree, hWalk);
    }

    TreeView_EndFakeCustomDraw(&tvfd);

    // update every shown index after expanded parent
    pTree->cShowing = TV_UpdateShownIndexes(pTree, hParent);

    // Update the pTree->cxMax if it is affected by the items we
    // expanded/collapsed.

    if (!(pTree->ci.style & TVS_NOSCROLL))
    {
        if (flags == SBAEC_COLLAPSE)
        {
            // If one of our newly-hidden items was responsible for
            // the width being what it is, recompute the max width
            // since we hid those items.
            if (cxMax == pTree->cxMax)
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
        }
        else
        {
            // If one of our newly-shown items was responsible is wider
            // then the previous max, then we have set a new max.
            if (cxMax > pTree->cxMax)
                pTree->cxMax = cxMax;
        }
    }

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  If the expanded items are showing, update the shown (expanded) count,
//  the max item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterExpand(PTREE pTree, HTREEITEM hParent)
{
    return TV_ScrollBarsAfterExpandCollapse(pTree, hParent, SBAEC_EXPAND);
}


// ----------------------------------------------------------------------------
//
//  If the collapsed items were showing, update the shown (expanded) count,
//  the max item width -- then recompute the scroll bars.
//
//  sets cxMax, cShowing
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterCollapse(PTREE pTree, HTREEITEM hParent)
{
    return TV_ScrollBarsAfterExpandCollapse(pTree, hParent, SBAEC_COLLAPSE);
}

// ----------------------------------------------------------------------------
//
//  If the added item changed height, then scroll thing around,
//  update the shown (expanded) count, recompute the scroll bars.
//
//  sets cShowing
//
// ----------------------------------------------------------------------------

void NEAR TV_ScrollBarsAfterResize(PTREE pTree, HTREEITEM hItem, int iIntegralPrev, UINT uRDWFlags)
{
    int iMaxIntegral = max(hItem->iIntegral, iIntegralPrev);

    ASSERT(hItem->iIntegral != iIntegralPrev);

    if (pTree->fRedraw)
    {
        int iTop = hItem->iShownIndex - pTree->hTop->iShownIndex +
                    iMaxIntegral - 1;
        if (iTop >= 0)
        {
            int iGrowth = hItem->iIntegral - iIntegralPrev;
            TV_ScrollItems(pTree, abs(iGrowth), iTop, iGrowth > 0);
        }
    }

    // update every shown index after resized item
    pTree->cShowing = TV_UpdateShownIndexes(pTree, hItem);
    TV_CalcScrollBars(pTree);

    // Invalidate based on the worst-case height so we handle
    // both the grow and shrink cases.
    if (pTree->fRedraw)
    {
        RECT rc;
        if (TV_GetItemRect(pTree, hItem, &rc, FALSE))
        {
            rc.bottom = rc.top + pTree->cyItem * iMaxIntegral;
            RedrawWindow(pTree->ci.hwnd, &rc, NULL, uRDWFlags);
        }
    }
}



// ----------------------------------------------------------------------------
//
//  Returns the item just below the given item in the tree.
//
// ----------------------------------------------------------------------------

TREEITEM FAR * NEAR TV_GetNext(TREEITEM FAR * hItem)
{
    DBG_ValidateTreeItem(hItem, FALSE);

    if (hItem->hKids)
        return hItem->hKids;

checkNext:
    if (hItem->hNext)
        return hItem->hNext;

    hItem = hItem->hParent;
    if (hItem)
        goto checkNext;

    return NULL;
}


// ----------------------------------------------------------------------------
//
//  Go through all the items in the tree, recomputing each item's text extent
//  and full width (indent, image, and text).
//
// ----------------------------------------------------------------------------

void NEAR TV_RecomputeItemWidths(PTREE pTree)
{
    HTREEITEM hItem;
    TVFAKEDRAW tvfd;

    TreeView_BeginFakeCustomDraw(pTree, &tvfd);

    hItem = pTree->hRoot->hKids;
    while (hItem)
    {
        TreeView_BeginFakeItemDraw(&tvfd, hItem);
        TV_ComputeItemWidth(pTree, hItem, tvfd.nmcd.nmcd.hdc);
        TreeView_EndFakeItemDraw(&tvfd);
        hItem = TV_GetNext(hItem);
    }
    TreeView_EndFakeCustomDraw(&tvfd);
}


// ----------------------------------------------------------------------------
//
//  If a single item's width changed, alter the max width if needed.
//  If all widths changed, recompute widths and max width.
//  Then recompute the scroll bars.
//
//  sets cxMax
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollBarsAfterSetWidth(PTREE pTree, HTREEITEM hItem)
{
    if (hItem)
    {
        UINT iOldWidth = FULL_WIDTH(pTree, hItem);
        TV_ComputeItemWidth(pTree, hItem, NULL);

        if (!(pTree->ci.style & TVS_NOSCROLL)) {
            if (pTree->cxMax == iOldWidth)
                pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
            else
                return(FALSE);
        }
    }
    else
    {
        TV_RecomputeItemWidths(pTree);
        pTree->cxMax = (WORD) TV_RecomputeMaxWidth(pTree);
    }

    TV_CalcScrollBars(pTree);
    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Scroll window vertically as needed to make given item fully visible
//  vertically
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollVertIntoView(PTREE pTree, HTREEITEM hItem)
{
    // This function has crashed in stress before, so we need to assert the incoming parameters.
    ASSERT(hItem);
    ASSERT(pTree && pTree->hTop);

    // Do nothing if the parameters are invalid
    if (!hItem || !pTree || !(pTree->hTop))
        return FALSE;

    // Do nothing if this item is not visible
    if (!ITEM_VISIBLE(hItem))
        return FALSE;

    if (hItem->iShownIndex < pTree->hTop->iShownIndex)
        return(TV_SetTopItem(pTree, hItem->iShownIndex));

    if (hItem->iShownIndex >= (pTree->hTop->iShownIndex + pTree->cFullVisible))
        return(TV_SetTopItem(pTree, hItem->iShownIndex + 1 - pTree->cFullVisible));

    return FALSE;
}


// ----------------------------------------------------------------------------
//
//  Scroll window vertically and horizontally as needed to make given item
//  fully visible vertically and horizontally
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_ScrollIntoView(PTREE pTree, HTREEITEM hItem)
{
    UINT iWidth, iOffset;
    BOOL fChange;

    fChange = TV_ScrollVertIntoView(pTree, hItem);

    // ensure that item's text is fully visible horizontally
    iWidth = pTree->cxImage + pTree->cxState + hItem->iWidth;
    if (iWidth > (UINT)pTree->cxWnd)
        iWidth = pTree->cxWnd; //hItem->iWidth;

    iOffset = ITEM_OFFSET(pTree, hItem);

    if ((int) (iOffset) < pTree->xPos)
        fChange |= TV_SetLeft(pTree, iOffset);
    else if ((iOffset + iWidth) > (UINT)(pTree->xPos + pTree->cxWnd))
        fChange |= TV_SetLeft(pTree, iOffset + iWidth - pTree->cxWnd);

    return fChange;
}


// ----------------------------------------------------------------------------
//
//  Sets position of horizontal scroll bar and scrolls window to match that
//  position
//
//  sets xPos
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SetLeft(PTREE pTree, int x)
{
    if (!pTree->fHorz || pTree->ci.style & (TVS_NOSCROLL | TVS_NOHSCROLL))
        return(FALSE);

    if (x > (int) (pTree->cxMax - pTree->cxWnd))
        x = (pTree->cxMax - pTree->cxWnd);
    if (x < 0)
        x = 0;

    if (x == pTree->xPos)
        return(FALSE);

    if (pTree->fRedraw) {
#ifndef UNIX
        SMOOTHSCROLLINFO si =
        {
            sizeof(si),
            SSIF_MINSCROLL | SSIF_MAXSCROLLTIME,
            pTree->ci.hwnd,
            pTree->xPos - x,
            0,
            NULL,
            NULL,
            NULL,
            NULL,
            SW_INVALIDATE | SW_ERASE,
            pTree->uMaxScrollTime,
            1,
            1
        };
#else
        SMOOTHSCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SSIF_MINSCROLL | SSIF_MAXSCROLLTIME;
        si.hwnd = pTree->ci.hwnd;
        si.dx = pTree->xPos - x;
        si.dy = 0;
        si.lprcSrc = NULL;
        si.lprcClip = NULL;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_INVALIDATE | SW_ERASE;
        si.uMaxScrollTime = pTree->uMaxScrollTime;
        si.cxMinScroll = 1;
        si.cyMinScroll = 1;
        si.pfnScrollProc = NULL;
#endif
        SmoothScrollWindow(&si);
    }

    pTree->xPos = (SHORT) x;

    SetScrollPos(pTree->ci.hwnd, SB_HORZ, x, TRUE);
    TV_UpdateToolTip(pTree);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Returns the tree's item that has the given shown index, NULL if no item
//  found with that index.
//
// ----------------------------------------------------------------------------

HTREEITEM NEAR TV_GetShownIndexItem(HTREEITEM hItem, UINT wShownIndex)
{
    HTREEITEM hWalk;

    if (hItem == NULL)
        return NULL;

    ASSERT((int)wShownIndex >= 0);

    for (hWalk = hItem;
         hWalk && (hWalk->iShownIndex <= wShownIndex);
         hWalk = hWalk->hNext) {
        
         hItem = hWalk;
         
         if (hWalk->iShownIndex + (UINT)hWalk->iIntegral > wShownIndex) 
             return hWalk;
    }

    return TV_GetShownIndexItem(hItem->hKids, wShownIndex);
}


// ----------------------------------------------------------------------------
//
//  Sets position of vertical scroll bar and scrolls window to match that
//  position
//
//  sets hTop
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_SmoothSetTopItem(PTREE pTree, UINT wNewTop, UINT uSmooth)
{
    HTREEITEM hItem = pTree->hRoot->hKids;
    UINT wOldTop;

    if (!hItem)
        return FALSE;
    
    if ((pTree->ci.style & TVS_NOSCROLL) || (wNewTop == (UINT)-1) || (pTree->cShowing <= pTree->cFullVisible)) {
        // we've wrapped around (treat as a negative index) -- use min pos
        // or there aren't enough items to scroll
        wNewTop = 0;
    } else if (wNewTop > (UINT)(pTree->cShowing - pTree->cFullVisible)) {
        // we've gone too far down -- use max pos
        wNewTop = (pTree->cShowing - pTree->cFullVisible);

    }

    // if there's no room for anything to show. peg at the end
    if (wNewTop > 0 && wNewTop >= pTree->cShowing) {
        wNewTop = pTree->cShowing - 1;
    }

    hItem = TV_GetShownIndexItem(hItem, wNewTop);

    if (NULL == hItem || pTree->hTop == hItem)
        return FALSE;
    // need to refetch because wNewTop couldhave pointed to the middle of this item,
    // which is not allowed
    wNewTop = hItem->iShownIndex;
    
    wOldTop = pTree->hTop->iShownIndex;

    pTree->hTop = hItem;

    if (pTree->fRedraw) {
#ifndef UNIX
        SMOOTHSCROLLINFO si =
        {
            sizeof(si),
            SSIF_MINSCROLL | SSIF_MAXSCROLLTIME,
            pTree->ci.hwnd,
            0,
            (int) (wOldTop - wNewTop) * (int) pTree->cyItem,
            NULL,
            NULL,
            NULL,
            NULL,
            SW_INVALIDATE | SW_ERASE | uSmooth,
            pTree->uMaxScrollTime,
            1,
            1
        };
#else
        SMOOTHSCROLLINFO si;
        si.cbSize = sizeof(si);
        si.fMask = SSIF_MINSCROLL | SSIF_MAXSCROLLTIME;
        si.hwnd = pTree->ci.hwnd;
        si.dx = 0;
        si.dy = (int) (wOldTop - wNewTop) * (int) pTree->cyItem;
        si.lprcSrc = NULL;
        si.lprcClip = NULL;
        si.hrgnUpdate = NULL;
        si.lprcUpdate = NULL;
        si.fuScroll = SW_INVALIDATE | SW_ERASE | uSmooth;
        si.uMaxScrollTime = pTree->uMaxScrollTime;
        si.cxMinScroll = 1;
        si.cyMinScroll = 1;
        si.pfnScrollProc = NULL;
#endif
        SmoothScrollWindow(&si);
    }

    SetScrollPos(pTree->ci.hwnd, SB_VERT, wNewTop, TRUE);
    TV_UpdateToolTip(pTree);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Computes the horizontal and vertical scroll bar ranges, pages, and
//  positions, adding or removing the scroll bars as needed.
//
//  sets fHorz, fVert
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_CalcScrollBars(PTREE pTree)
{
    // UINT wMaxPos;
    BOOL fChange = FALSE;
    SCROLLINFO si;
    
    if (pTree->ci.style & TVS_NOSCROLL)
        return FALSE;

    si.cbSize = sizeof(SCROLLINFO);

    if (!(pTree->ci.style & TVS_NOHSCROLL))
    {
        if ((SHORT)pTree->cxMax > (SHORT)pTree->cxWnd)
        {
            if (!pTree->fHorz)
            {
                fChange = TRUE;
                pTree->fHorz = TRUE;
            }

            si.fMask = SIF_PAGE | SIF_RANGE;
            si.nMin = 0;
            si.nMax = pTree->cxMax - 1;
            si.nPage = pTree->cxWnd;

            TV_SetLeft(pTree, (UINT)SetScrollInfo(pTree->ci.hwnd, SB_HORZ, &si, TRUE));
        }
        else if (pTree->fHorz)
        {
            TV_SetLeft(pTree, 0);
            SetScrollRange(pTree->ci.hwnd, SB_HORZ, 0, 0, TRUE);

            pTree->fHorz = FALSE;
            fChange = TRUE;
        }
    }

    if (pTree->cShowing > pTree->cFullVisible)
    {
        if (!pTree->fVert)
        {
            pTree->fVert = TRUE;
            fChange = TRUE;
        }

        si.fMask = SIF_PAGE | SIF_RANGE;
        si.nMin = 0;
        si.nMax = pTree->cShowing - 1;
        si.nPage = pTree->cFullVisible;

        TV_SetTopItem(pTree, (UINT)SetScrollInfo(pTree->ci.hwnd, SB_VERT, &si, TRUE));

    }
    else if (pTree->fVert)
    {
        TV_SetTopItem(pTree, 0);
        SetScrollRange(pTree->ci.hwnd, SB_VERT, 0, 0, TRUE);

        pTree->fVert = FALSE;
        fChange = TRUE;
    }

    if (fChange)
        TV_SizeWnd(pTree, 0, 0);

    return(TRUE);
}


// ----------------------------------------------------------------------------
//
//  Handles horizontal scrolling.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_HorzScroll(PTREE pTree, UINT wCode, UINT wNewPos)
{
    BOOL fChanged;

    TV_DismissEdit(pTree, FALSE);

    switch (wCode)
    {
        case SB_BOTTOM:
            wNewPos = pTree->cxMax - pTree->cxWnd;
            break;

        case SB_ENDSCROLL:
            wNewPos = pTree->xPos;
            break;

        case SB_LINEDOWN:
            wNewPos = pTree->xPos + MAGIC_HORZLINE;
            break;

        case SB_LINEUP:
            wNewPos = pTree->xPos - MAGIC_HORZLINE;
            break;

        case SB_PAGEDOWN:
            wNewPos = pTree->xPos + (pTree->cxWnd - MAGIC_HORZLINE);
            break;

        case SB_PAGEUP:
            wNewPos = pTree->xPos - (pTree->cxWnd - MAGIC_HORZLINE);
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            break;

        case SB_TOP:
            wNewPos = 0;
            break;
    }

    if (fChanged = TV_SetLeft(pTree, wNewPos))
        UpdateWindow(pTree->ci.hwnd);

    return(fChanged);
}


// ----------------------------------------------------------------------------
//
//  Handles vertical scrolling.
//
// ----------------------------------------------------------------------------

BOOL NEAR TV_VertScroll(PTREE pTree, UINT wCode, UINT wPos)
{
    UINT wNewPos = 0;
    UINT wOldPos;
    BOOL fChanged;
    UINT uSmooth = 0;

    if (!pTree->hTop)
        return FALSE;
    
    wOldPos = pTree->hTop->iShownIndex;
    TV_DismissEdit(pTree, FALSE);

    switch (wCode)
    {
        case SB_BOTTOM:
            wNewPos = pTree->cShowing - pTree->cFullVisible;
            break;

        case SB_ENDSCROLL:
            wNewPos = wOldPos;
            break;

        case SB_LINEDOWN:
            wNewPos = wOldPos + pTree->hTop->iIntegral;
            break;

        case SB_LINEUP:
            wNewPos = wOldPos - 1;
            if (wNewPos > wOldPos)
                wNewPos = 0;
            break;

        case SB_PAGEDOWN:
            wNewPos = wOldPos + (pTree->cFullVisible - 1);
            break;

        case SB_PAGEUP:
            wNewPos = wOldPos - (pTree->cFullVisible - 1);
            if (wNewPos > wOldPos)
                wNewPos = 0;
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            uSmooth = SSW_EX_IMMEDIATE;
            wNewPos = wPos;
            break;

        case SB_TOP:
            wNewPos = 0;
            break;
    }

    if (fChanged = TV_SmoothSetTopItem(pTree, wNewPos, uSmooth))
        UpdateWindow(pTree->ci.hwnd);
    return(fChanged);
}


#ifdef DEBUG
static int nCompares;
#endif

typedef struct {
    LPTSTR lpstr;
    BOOL bCallBack;
    HTREEITEM hItem;
} TVCOMPARE, FAR *LPTVCOMPARE;

// Pointer comparision function for Sort and Search functions.
// lParam is lParam passed to sort/search functions.  Returns
// -1 if p1 < p2, 0 if p1 == p2, and 1 if p1 > p2.
//
int CALLBACK TV_DefCompare(LPTVCOMPARE sCmp1, LPTVCOMPARE sCmp2, LPARAM lParam)
{
#ifdef DEBUG
        ++nCompares;
#endif

        return lstrcmpi(sCmp1->lpstr, sCmp2->lpstr);
}


int CALLBACK TV_CompareItems(LPTVCOMPARE sCmp1, LPTVCOMPARE sCmp2, LPARAM lParam)
{
        TV_SORTCB FAR *pSortCB = (TV_SORTCB FAR *)lParam;
#ifdef DEBUG
        ++nCompares;
#endif

        return(pSortCB->lpfnCompare(sCmp1->hItem->lParam, sCmp2->hItem->lParam,
                pSortCB->lParam));
}


UINT NEAR TV_CountKids(HTREEITEM hItem)
{
    int cnt;

    for (cnt = 0, hItem = hItem->hKids; hItem; hItem = hItem->hNext)
        cnt++;

    return cnt;
}


// BUGBUG: bRecurse not implemented

BOOL PASCAL TV_SortCB(PTREE pTree, TV_SORTCB FAR *pSortCB, BOOL bRecurse,
        PFNDPACOMPARE lpfnDPACompare)
{
        HDPA dpaSort;
        HDSA dsaCmp;
        HTREEITEM hItem, hNext, hFirstMoved;
        LPTVCOMPARE psCompare, FAR *ppsCompare;
        int i, cKids;
        HTREEITEM hParent = pSortCB->hParent;

#ifdef DEBUG
        DWORD dwTime = GetTickCount();
        nCompares = 0;
#endif

        if (!hParent || hParent == TVI_ROOT)
            hParent = pTree->hRoot;

        if (!ValidateTreeItem(hParent, FALSE))
            return FALSE;               // Invalid parameter

        // Code below assumes at least one kid
        cKids = TV_CountKids(hParent);
        if (!cKids)
            return FALSE;

        // Create a DSA for all the extra info we'll need
        dsaCmp = DSA_Create(sizeof(TVCOMPARE), cKids);
        if (!dsaCmp)
            goto Error1;

        // Create a DPA containing all the tree items
        dpaSort = DPA_Create(cKids);
        if (!dpaSort)
            goto Error2;

        for (hItem = hParent->hKids; hItem; hItem = hItem->hNext)
        {
                TVCOMPARE sCompare;
                int nItem;

                // If I can't sort all of them, I don't want to sort any of them

                // We want to cache the text callback for default processing
                if (!lpfnDPACompare && hItem->lpstr==LPSTR_TEXTCALLBACK)
                {
                        TVITEMEX sItem;
                        TCHAR szTemp[MAX_PATH];

                        sItem.pszText = szTemp;
                        sItem.cchTextMax  = ARRAYSIZE(szTemp);
                        TV_GetItem(pTree, hItem, TVIF_TEXT, &sItem);

                        sCompare.lpstr = NULL;
                        sCompare.bCallBack = TRUE;
                        Str_Set(&sCompare.lpstr, sItem.pszText);
                        if (!sCompare.lpstr)
                        {
                                goto Error3;
                        }
                }
                else
                {
                        sCompare.lpstr = hItem->lpstr;
                        sCompare.bCallBack = FALSE;
                }

                // Create the pointer for this guy and add it to the DPA list
                sCompare.hItem = hItem;
                nItem = DSA_AppendItem(dsaCmp, &sCompare);
                if (nItem < 0)
                {
                        if (sCompare.bCallBack)
                        {
                                Str_Set(&sCompare.lpstr, NULL);
                        }
                        goto Error3;
                }

                if (DPA_AppendPtr(dpaSort, DSA_GetItemPtr(dsaCmp, nItem)) < 0)
                {
                        goto Error3;
                }
        }

        // Sort the DPA, then stick them back under the parent in the new order
        DPA_Sort(dpaSort, lpfnDPACompare ? (PFNDPACOMPARE)lpfnDPACompare :
                 (PFNDPACOMPARE) TV_DefCompare, (LPARAM)pSortCB);


        // Look for the first moved item, so we can invalidate a smaller area
        ppsCompare = (LPTVCOMPARE FAR *)DPA_GetPtrPtr(dpaSort);
        if (hParent->hKids != (*ppsCompare)->hItem)
        {
                hParent->hKids = (*ppsCompare)->hItem;
                hFirstMoved = hParent->hKids;
        }
        else
        {
                hFirstMoved = NULL;
        }

        // We do n-1 iterations here
        for (i = DPA_GetPtrCount(dpaSort) - 1; i > 0; --i, ++ppsCompare)
        {
                hNext = (*(ppsCompare+1))->hItem;
                if ((*ppsCompare)->hItem->hNext != hNext && !hFirstMoved)
                {
                        hFirstMoved = hNext;
                }
                (*ppsCompare)->hItem->hNext = hNext;
        }
        (*ppsCompare)->hItem->hNext = NULL;

        TV_UpdateShownIndexes(pTree, hParent);
        if ((pSortCB->hParent == TVI_ROOT) || !hParent) {
            if (pTree->cShowing < pTree->cFullVisible) {
                pTree->hTop = pTree->hRoot->hKids;
            }
        }

        if (hFirstMoved && (hParent->state & TVIS_EXPANDED))
        {
                RECT rcUpdate;

                TV_GetItemRect(pTree, hFirstMoved, &rcUpdate, FALSE);
                if (hParent->hNext)
                {
                        RECT rcTemp;

                        TV_GetItemRect(pTree, hParent->hNext, &rcTemp, FALSE);
                        rcUpdate.bottom = rcTemp.bottom;
                }
                else
                {
                        RECT rcClient;
                        GetClientRect(pTree->ci.hwnd, &rcClient);
                        // Set to maximal positive number, so the whole rest of
                        // the treeview gets invalidated
                        rcUpdate.bottom = rcClient.bottom;
                }
                if (pTree->fRedraw)
                    InvalidateRect(pTree->ci.hwnd, &rcUpdate, TRUE);
        }

Error3:
        DPA_Destroy(dpaSort);
Error2:
        for (i = DSA_GetItemCount(dsaCmp) - 1; i >= 0; --i)
        {
                psCompare = DSA_GetItemPtr(dsaCmp, i);
                if (psCompare->bCallBack)
                {
                        Str_Set(&(psCompare->lpstr), NULL);
                }
        }
        DSA_Destroy(dsaCmp);
Error1:

#ifdef DEBUG
        TraceMsg(TF_TREEVIEW, "tv.sort: %ld ms; %d cmps", GetTickCount()-dwTime, nCompares);
#endif

    {
        int wNewPos;
        // restore the scroll position
        if (GetWindowStyle(pTree->ci.hwnd) & WS_VSCROLL) {
            SCROLLINFO si;

            si.cbSize = sizeof(SCROLLINFO);
            si.fMask = SIF_POS;
            wNewPos = 0;
            if (GetScrollInfo(pTree->ci.hwnd, SB_VERT, &si)) {
                wNewPos = si.nPos;
            }

        } else {
            wNewPos = 0;
        }

        if (TV_SetTopItem(pTree, wNewPos))
            UpdateWindow(pTree->ci.hwnd);
    }

    // if the caret is the child of the thing that was sorted, make sure it's
    // visible (but if we're sorting something completely unrelated, don't bother
    if (pTree->hCaret) {
        hItem = pTree->hCaret;
        do {
            // do this first.  if hParent is hCaret, we don't want to ensure visible...
            // only if it's an eventual child
            hItem = hItem->hParent;
            if (hParent == hItem) {
                TV_EnsureVisible(pTree, pTree->hCaret);
            }
        } while(hItem && hItem != pTree->hRoot);
    }

    // The items in the view may have moved around; let apps know
    // Do this last because this call might yield
    MyNotifyWinEvent(EVENT_OBJECT_REORDER, pTree->ci.hwnd, OBJID_CLIENT, 0);

    return TRUE;
}


BOOL NEAR TV_SortChildrenCB(PTREE pTree, LPTV_SORTCB pSortCB, BOOL bRecurse)
{
        return(TV_SortCB(pTree, pSortCB, bRecurse, (PFNDPACOMPARE)TV_CompareItems));
}


BOOL NEAR TV_SortChildren(PTREE pTree, HTREEITEM hParent, BOOL bRecurse)
{
        TV_SORTCB sSortCB;

        sSortCB.hParent = hParent;
        return(TV_SortCB(pTree, &sSortCB, bRecurse, NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\unicwrap.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       unicwrap.cpp
//
//  Contents:   Wrappers for all Unicode functions used in MSHTML.
//              Any Unicode parameters/structure fields/buffers are converted
//              to ANSI, and then the corresponding ANSI version of the function
//              is called.
//
//----------------------------------------------------------------------------
#include "ctlspriv.h"

#ifdef  UNICODE
#ifndef WINNT

#include "unicwrap.h"

#undef TextOutW
#undef ExtTextOutW

int MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch = -1);
int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1);

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void CConvertStr::Free()
{
    if (_pstr != _ach && HIWORD64(_pstr) != 0)
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void CConvertStrW::Free()
{
    if (_pwstr != _awch && HIWORD64(_pwstr) != 0)
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void CStrInW::Init(LPCSTR pstr, int cch)
{
    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    ASSERT(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cwchLen = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, _awch, ARRAYSIZE(_awch));

    if (_cwchLen > 0)
    {
        if(_awch[_cwchLen-1] == 0)
            _cwchLen--;                // account for terminator
        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    cchBufReq = MultiByteToWideChar( CP_ACP, 0, pstr, cch, NULL, 0 );

    ASSERT(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    ASSERT(HIWORD64(_pwstr));
    _cwchLen = -1 + MultiByteToWideChar( 
            CP_ACP, 0, pstr, cch, _pwstr, cchBufReq );
    ASSERT(_cwchLen >= 0);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline this function or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr) : CConvertStr(CP_ACP)
{
    Init(pwstr, -1);
}

CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr) : CConvertStr(uCP)
{
    Init(pwstr, -1);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void CStrIn::Init(LPCWSTR pwstr, int cwch)
{
    int cchBufReq;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD64(pwstr) == 0)
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    if ( cwch == 0 )
    {
        *_ach = '\0';
        _pstr = _ach;
        return;
    }

    ASSERT(cwch == -1 || cwch > 0);
    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _ach, ARRAYSIZE(_ach), NULL, NULL);
    if (_cchLen > 0)
    {
        if (_ach[_cchLen-1]==0) _cchLen--;          // account for terminator
        _pstr = _ach;
        return;
    }


    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0, NULL, NULL);

    ASSERT(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _cchLen = -1 + WideCharToMultiByte(
            _uCP, 0, pwstr, cwch, _pstr, cchBufReq, NULL, NULL);

#if DBG == 1 /* { */
    if (_cchLen < 0)
    {
        errcode = GetLastError();
        ASSERT(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(LPCWSTR pwstr)
{
    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    ASSERT(HIWORD64(pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, (int)(pwstrT - pwstr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf) : CConvertStr(CP_ACP)
{
    ASSERT(cwchBuf >= 0);

    if (!cwchBuf)
        pwstr = NULL;

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        ASSERT(cwchBuf == 0);
        _pstr = NULL;
        return;
    }

    ASSERT(HIWORD64(pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAYSIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        ASSERT(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    ASSERT(HIWORD64(_pstr));
    _pstr[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertIncludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count INCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int CStrOut::ConvertIncludingNul()
{
    int cwch;

    if (!_pstr)
        return 0;

    ASSERT(_cwchBuf);

    // Preinit to null string in case of horrible catastrophe
    _pwstr[0] = TEXT('\0');

    cwch = MultiByteToWideChar(_uCP, 0, _pstr, -1, _pwstr, _cwchBuf);

    if (!cwch) {
        // Output buffer was short.  Must double-buffer (yuck)
        int cwchNeeded = MultiByteToWideChar(_uCP, 0, _pstr, -1, NULL, 0);
        if (cwchNeeded) {
            LPWSTR pwsz = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                             cwchNeeded * SIZEOF(WCHAR));
            if (pwsz) {
                cwch = MultiByteToWideChar(_uCP, 0, _pstr, -1,
                                           pwsz, cwchNeeded);
                if (cwch) {
                    StrCpyNW(_pwstr, pwsz, _cwchBuf);
                    cwch = _cwchBuf;
                }
                LocalFree(pwsz);
            }
        } else {
#if DBG == 1 /* { */
            DWORD errcode = GetLastError();
            ASSERT(0 && "MultiByteToWideChar failed in unicode wrapper.");
#endif /* } */
        }
    }

    Free();
    return cwch;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::ConvertExcludingNul
//
//  Synopsis:   Converts the buffer from MBCS to Unicode
//
//  Return:     Character count EXCLUDING the trailing '\0'
//
//----------------------------------------------------------------------------

int CStrOut::ConvertExcludingNul()
{
    int ret = ConvertIncludingNul();
    if (ret)
    {
        ret -= 1;
    }
    return ret;
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both ConvertIncludingNul() and CConvertStr::~CConvertStr will be
//              called inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
    ConvertIncludingNul();
}

//+---------------------------------------------------------------------------
//
//  Function:   MbcsFromUnicode
//
//  Synopsis:   Converts a string to MBCS from Unicode.
//
//  Arguments:  [pstr]  -- The buffer for the MBCS string.
//              [cch]   -- The size of the MBCS buffer, including space for
//                              NULL terminator.
//
//              [pwstr] -- The Unicode string to convert.
//              [cwch]  -- The number of characters in the Unicode string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pstr].
//
//----------------------------------------------------------------------------

int MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr, int cwch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    ASSERT(cch >= 0);
    if (!pstr || cch == 0)
        return 0;

    ASSERT(pwstr);
    ASSERT(cwch == -1 || cwch > 0);

    ret = WideCharToMultiByte(CP_ACP, 0, pwstr, cwch, pstr, cch, NULL, NULL);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
        ASSERT(0 && "WideCharToMultiByte failed in unicode wrapper.");
    }
#endif /* } */

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   UnicodeFromMbcs
//
//  Synopsis:   Converts a string to Unicode from MBCS.
//
//  Arguments:  [pwstr] -- The buffer for the Unicode string.
//              [cwch]  -- The size of the Unicode buffer, including space for
//                              NULL terminator.
//
//              [pstr]  -- The MBCS string to convert.
//              [cch]  -- The number of characters in the MBCS string to
//                              convert, including NULL terminator.  If this
//                              number is -1, the string is assumed to be
//                              NULL terminated.  -1 is supplied as a
//                              default argument.
//
//  Returns:    If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
//              the number of characters converted, including the terminating
//              NULL, is returned (note that converting the empty string will
//              return 1).  If the conversion fails, 0 is returned.
//
//  Modifies:   [pwstr].
//
//----------------------------------------------------------------------------

int UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch)
{
    int ret;

#if DBG == 1 /* { */
    int errcode;
#endif /* } */

    ASSERT(cwch >= 0);

    if (!pwstr || cwch == 0)
        return 0;

    ASSERT(pstr);
    ASSERT(cch == -1 || cch > 0);

    ret = MultiByteToWideChar(CP_ACP, 0, pstr, cch, pwstr, cwch);

#if DBG == 1 /* { */
    if (ret <= 0)
    {
        errcode = GetLastError();
        ASSERT(0 && "MultiByteToWideChar failed in unicode wrapper.");
    }
#endif /* } */

    return ret;
}

//+------------------------------------------------------------------------
//
//  Contents:   widechar character type function (CT_CTYPE1) and (CT_CTYPE3)
//
//  Synopsis:   We do not have wide char support for IsChar functions
//              under Win95.  The Unicode-Wrapper functions we have
//              in core\wrappers all convert to CP_ACP and then call
//              the A version, which means we will have invalid results
//              for any characters which aren't in CP_ACP.
//
//              The solution is to roll our own, which result in these
//              unfortunately large tables.  Here's how it works:
//
//              bits:   fedc ba98 7654 3210
//                      pppp pppp iiib bbbb
//
//              The 'b' bits form a 32-bit bit mask into our data.  The data
//              entrys boolean, and are thus 4-bytes long.  Of the 2^32
//              possible combinations, we in fact have only 218 distinct
//              values of data.  These are stored in adwData.
//
//              The 'p' bits represent a page.  Each page has eight
//              possible entries, represent by 'i'.  In most pages, the
//              bitfields and data are both uniform.
//
//              adwData[abIndex[abType[page]][index]] represents the data
//
//              1 << bits represents the bitmask.
//
//-------------------------------------------------------------------------

#define __BIT_SHIFT 0
#define __INDEX_SHIFT 5
#define __PAGE_SHIFT 8

#define __BIT_MASK 31
#define __INDEX_MASK 7

// straight lookup functions are inlined.

#define ISCHARFUNC(type, wch) \
    (adwData[abIndex[abType1##type[wch>>__PAGE_SHIFT]] \
                          [(wch>>__INDEX_SHIFT)&__INDEX_MASK]] \
            >> (wch&__BIT_MASK)) & 1 
    
//
// To avoid header file conflicts with IsCharAlphaW, IsCharAlphaNumericW, ... defined in
// winuser.h, the functions names end in "Wrap".  SHLWAPI.DEF exports these functions with 
// the correct name.
//

STDAPI_(BOOL) IsCharAlphaWrap(WCHAR wch);
STDAPI_(BOOL) IsCharAlphaNumericWrap(WCHAR wch);
STDAPI_(BOOL) IsCharUpperWrap(WCHAR wch);
STDAPI_(BOOL) IsCharLowerWrap(WCHAR wch);

const DWORD adwData[218] =
{
    0x00000000, 0x07fffffe, 0xff7fffff, 0xffffffff,  // 0x00-0x03
    0xfc3fffff, 0x00ffffff, 0xffff0000, 0x000001ff,  // 0x04-0x07
    0xffffd740, 0xfffffffb, 0x547f7fff, 0x000ffffd,  // 0x08-0x0b
    0xffffdffe, 0xdffeffff, 0xffff0003, 0xffff199f,  // 0x0c-0x0f
    0x033fcfff, 0xfffe0000, 0x007fffff, 0xfffffffe,  // 0x10-0x13
    0x000000ff, 0x000707ff, 0x000007fe, 0x7cffffff,  // 0x14-0x17
    0x002f7fff, 0xffffffe0, 0x03ffffff, 0xff000000,  // 0x18-0x1b
    0x00000003, 0xfff99fe0, 0x03c5fdff, 0xb0000000,  // 0x1c-0x1f
    0x00030003, 0xfff987e0, 0x036dfdff, 0x5e000000,  // 0x20-0x23
    0xfffbafe0, 0x03edfdff, 0x00000001, 0x03cdfdff,  // 0x24-0x27
    0xd63dc7e0, 0x03bfc718, 0xfffddfe0, 0x03effdff,  // 0x28-0x2b
    0x40000000, 0x03fffdff, 0x000d7fff, 0x0000003f,  // 0x2c-0x2f
    0xfef02596, 0x00006cae, 0x30000000, 0xffff003f,  // 0x30-0x33
    0x83ffffff, 0xffffff07, 0x07ffffff, 0x3f3fffff,  // 0x34-0x37
    0xaaff3f3f, 0x3fffffff, 0x1fdfffff, 0x0fcf1fdc,  // 0x38-0x3b
    0x1fdc1fff, 0xf0000000, 0x000003ff, 0x00000020,  // 0x3c-0x3f
    0x781fffff, 0x77ffffff, 0xfffe1fff, 0x00007fff,  // 0x40-0x43
    0x0000000f, 0x00003fff, 0x80f8007f, 0x5f7fffff,  // 0x44-0x47
    0xffffffdb, 0x0003ffff, 0xfff80000, 0xfffffdff,  // 0x48-0x4b
    0xfffffffd, 0xfffcffff, 0x0fff0000, 0x1fffffff,  // 0x4c-0x4f
    0xffffffc0, 0x7ffffffe, 0x1cfcfcfc, 0x00003e00,  // 0x50-0x53
    0x00000fff, 0x80000000, 0xfc00fffe, 0xf8000001,  // 0x54-0x57
    0x78000001, 0x00800000, 0x00040000, 0x7fffffff,  // 0x58-0x5b
    0x44300003, 0x000000b0, 0x0000007c, 0xfe000000,  // 0x5c-0x5f
    0x00000200, 0x00180000, 0x88001000, 0x0007f801,  // 0x60-0x63
    0x00013c00, 0xffd00000, 0x0000000e, 0x001f3fff,  // 0x64-0x67
    0x0001003c, 0xd0000000, 0x0080399f, 0x07fc000c,  // 0x68-0x6b
    0x00000004, 0x00003987, 0x001f0000, 0x00013bbf,  // 0x6c-0x6f
    0x00c0398f, 0x00010000, 0x0000000c, 0xc0000000,  // 0x70-0x73
    0x00803dc7, 0x00603ddf, 0x00803dcf, 0x87f28000,  // 0x74-0x77
    0x0c00ffc0, 0x3bff8000, 0x00003f5f, 0x08000000,  // 0x78-0x7b
    0xe0000000, 0xe000e003, 0x6000e000, 0xffff7fff,  // 0x7c-0x7f
    0x0000007f, 0xfc00fc00, 0x00007c00, 0x01ffffff,  // 0x80-0x83
    0xffff0007, 0x000007ff, 0x0000001f, 0x003fffff,  // 0x84-0x87
    0xffffdfff, 0x0000ffff, 0xfc0fffff, 0xfffff3de,  // 0x88-0x8b
    0xfffffeff, 0x7f47afff, 0xffc000fe, 0xff1fffff,  // 0x8c-0x8f
    0x7ffeffff, 0x80ffffff, 0x7e000000, 0x78000000,  // 0x90-0x93
    0x8fffffff, 0x0001ffff, 0xffff0fff, 0xf87fffff,  // 0x94-0x97
    0xffff000f, 0xfff7fe1f, 0xffd70f7f, 0x0001003e,  // 0x98-0x9b
    0x00007f7f, 0x03ff0000, 0x020c0000, 0x0000ffc0,  // 0x9c-0x9f
    0x0007ff80, 0x03f10000, 0x0000007e, 0x7f7fffff,  // 0xa0-0xa3
    0x55555555, 0xaa555555, 0x555554aa, 0x2b555555,  // 0xa4-0xa7
    0xb1dbced6, 0x11aed295, 0x4aaaadb0, 0x54165555,  // 0xa8-0xab
    0x00555555, 0xfffed740, 0x00000ffb, 0x541c0000,  // 0xac-0xaf
    0x00005555, 0x55550001, 0x5555088a, 0x01154555,  // 0xb0-0xb3
    0x00155555, 0x01555555, 0x3f00ff00, 0xff00ff00,  // 0xb4-0xb7
    0xaa003f00, 0x0000ff00, 0x1f00ff00, 0x0f001f00,  // 0xb8-0xbb
    0x1f001f00, 0xffc00000, 0xaaaaaaaa, 0x55aaaaaa,  // 0xbc-0xbf
    0xaaaaab55, 0xd4aaaaaa, 0x4e243129, 0x2651292a,  // 0xc0-0xc3
    0xb5555b60, 0xa82daaaa, 0x00aaaaaa, 0xffaffbfb,  // 0xc4-0xc7
    0x640f7ffc, 0x000001f9, 0xfffff000, 0x00637fff,  // 0xc8-0xcb
    0x000faaa8, 0xaaaa0002, 0xaaaa1114, 0x022a8aaa,  // 0xcc-0xcf
    0x07eaaaaa, 0x02aaaaaa, 0x003f00ff, 0x00ff00ff,  // 0xd0-0xd3
    0x00ff003f, 0x3fff00ff, 0x00df00ff, 0x00cf00dc,  // 0xd4-0xd7
    0x00dc00ff, 0x00f8007f
};

const BYTE abIndex[98][8] =
{
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x00
    { 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x02, 0x02 }, // 0x01
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04 }, // 0x02
    { 0x05, 0x00, 0x06, 0x03, 0x03, 0x07, 0x00, 0x00 }, // 0x03
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x09, 0x0a, 0x0b }, // 0x04
    { 0x0c, 0x03, 0x0d, 0x03, 0x0e, 0x03, 0x0f, 0x10 }, // 0x05
    { 0x00, 0x11, 0x12, 0x13, 0x14, 0x00, 0x06, 0x15 }, // 0x06
    { 0x00, 0x01, 0x16, 0x11, 0x03, 0x17, 0x18, 0x00 }, // 0x07
    { 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20 }, // 0x08
    { 0x21, 0x22, 0x23, 0x00, 0x24, 0x25, 0x00, 0x26 }, // 0x09
    { 0x1d, 0x27, 0x1f, 0x1c, 0x28, 0x29, 0x00, 0x00 }, // 0x0a
    { 0x2a, 0x2b, 0x00, 0x1c, 0x2a, 0x2b, 0x2c, 0x1c }, // 0x0b
    { 0x2a, 0x2d, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00 }, // 0x0c
    { 0x13, 0x2e, 0x2f, 0x00, 0x30, 0x31, 0x32, 0x00 }, // 0x0d
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x33, 0x12 }, // 0x0e
    { 0x03, 0x03, 0x34, 0x03, 0x03, 0x35, 0x03, 0x1a }, // 0x0f
    { 0x03, 0x03, 0x03, 0x03, 0x36, 0x03, 0x03, 0x1a }, // 0x10
    { 0x37, 0x03, 0x38, 0x39, 0x03, 0x3a, 0x3b, 0x3c }, // 0x11
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x03, 0x03, 0x3e }, // 0x12
    { 0x3f, 0x00, 0x13, 0x03, 0x40, 0x13, 0x03, 0x41 }, // 0x13
    { 0x19, 0x42, 0x03, 0x03, 0x43, 0x00, 0x00, 0x00 }, // 0x14
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03 }, // 0x15
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x2f, 0x00, 0x00 }, // 0x16
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x44, 0x00, 0x00 }, // 0x17
    { 0x03, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x18
    { 0x46, 0x47, 0x48, 0x03, 0x03, 0x49, 0x4a, 0x4b }, // 0x19
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x4c }, // 0x1a
    { 0x03, 0x39, 0x06, 0x03, 0x4d, 0x03, 0x14, 0x4e }, // 0x1b
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x03, 0x4f }, // 0x1c
    { 0x00, 0x01, 0x01, 0x50, 0x03, 0x51, 0x52, 0x00 }, // 0x1d
    { 0x53, 0x26, 0x00, 0x00, 0x00, 0x26, 0x00, 0x00 }, // 0x1e
    { 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x1f
    { 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x20
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55 }, // 0x21
    { 0x00, 0x56, 0x57, 0x58, 0x00, 0x13, 0x59, 0x59 }, // 0x22
    { 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00 }, // 0x23
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5b, 0x3e }, // 0x24
    { 0x03, 0x03, 0x2f, 0x5c, 0x5d, 0x00, 0x00, 0x00 }, // 0x25
    { 0x00, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00 }, // 0x26
    { 0x00, 0x00, 0x5f, 0x00, 0x60, 0x06, 0x44, 0x61 }, // 0x27
    { 0x62, 0x00, 0x63, 0x64, 0x00, 0x00, 0x65, 0x45 }, // 0x28
    { 0x66, 0x3d, 0x67, 0x68, 0x66, 0x69, 0x6a, 0x6b }, // 0x29
    { 0x6c, 0x69, 0x6d, 0x6e, 0x66, 0x3d, 0x6f, 0x00 }, // 0x2a
    { 0x66, 0x3d, 0x70, 0x71, 0x72, 0x73, 0x74, 0x00 }, // 0x2b
    { 0x66, 0x73, 0x75, 0x00, 0x72, 0x73, 0x75, 0x00 }, // 0x2c
    { 0x72, 0x73, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x2d
    { 0x00, 0x77, 0x78, 0x00, 0x00, 0x79, 0x7a, 0x00 }, // 0x2e
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7b }, // 0x2f
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x7d, 0x7e }, // 0x30
    { 0x03, 0x7f, 0x80, 0x81, 0x82, 0x54, 0x06, 0x1c }, // 0x31
    { 0x03, 0x83, 0x4a, 0x03, 0x84, 0x03, 0x03, 0x85 }, // 0x32
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x49 }, // 0x33
    { 0x4c, 0x03, 0x03, 0x36, 0x00, 0x00, 0x00, 0x00 }, // 0x34
    { 0x03, 0x86, 0x85, 0x03, 0x03, 0x03, 0x03, 0x85 }, // 0x35
    { 0x03, 0x03, 0x03, 0x03, 0x87, 0x88, 0x03, 0x89 }, // 0x36
    { 0x8a, 0x03, 0x03, 0x89, 0x00, 0x00, 0x00, 0x00 }, // 0x37
    { 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x00, 0x00 }, // 0x38
    { 0x13, 0x91, 0x00, 0x00, 0x92, 0x00, 0x00, 0x93 }, // 0x39
    { 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00 }, // 0x3a
    { 0x4f, 0x03, 0x44, 0x94, 0x03, 0x95, 0x96, 0x5b }, // 0x3b
    { 0x03, 0x03, 0x03, 0x97, 0x03, 0x03, 0x39, 0x5b }, // 0x3c
    { 0x2c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3d
    { 0x00, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x3e
    { 0x00, 0x98, 0x99, 0x9a, 0x03, 0x03, 0x03, 0x4f }, // 0x3f
    { 0x56, 0x57, 0x58, 0x9b, 0x73, 0x26, 0x00, 0x9c }, // 0x40
    { 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9e, 0x00, 0x00 }, // 0x41
    { 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x9d }, // 0x42
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x9f }, // 0x43
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0xa0 }, // 0x44
    { 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00 }, // 0x45
    { 0x00, 0x00, 0x9d, 0x00, 0x00, 0x00, 0x9d, 0x00 }, // 0x46
    { 0x00, 0x00, 0x00, 0xa1, 0x3e, 0x00, 0x00, 0x00 }, // 0x47
    { 0x9d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x48
    { 0x00, 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00 }, // 0x49
    { 0x9d, 0xa2, 0xa2, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4a
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa3, 0x00 }, // 0x4b
    { 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab }, // 0x4c
    { 0xac, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x4d
    { 0x00, 0x00, 0x00, 0x00, 0xad, 0xae, 0xaf, 0xb0 }, // 0x4e
    { 0x0c, 0x89, 0x00, 0xa4, 0xb1, 0xa4, 0xb2, 0xb3 }, // 0x4f
    { 0x00, 0x11, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x50
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x2f, 0x00 }, // 0x51
    { 0xa4, 0xa4, 0xa4, 0xa4, 0xb4, 0xa4, 0xa4, 0xb5 }, // 0x52
    { 0xb6, 0xb7, 0xb8, 0xb9, 0xb7, 0xba, 0xbb, 0xbc }, // 0x53
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x89, 0x00 }, // 0x54
    { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x55
    { 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x55, 0x02 }, // 0x56
    { 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5 }, // 0x57
    { 0xc6, 0x00, 0x06, 0xc7, 0xc8, 0xc9, 0x00, 0x00 }, // 0x58
    { 0x00, 0x00, 0x00, 0x00, 0x71, 0xca, 0xcb, 0xcc }, // 0x59
    { 0x00, 0x06, 0x0d, 0xbe, 0xcd, 0xbe, 0xce, 0xcf }, // 0x5a
    { 0x00, 0x00, 0x00, 0x13, 0x14, 0x00, 0x00, 0x00 }, // 0x5b
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x12 }, // 0x5c
    { 0xbe, 0xbe, 0xbe, 0xbe, 0xd0, 0xbe, 0xbe, 0xd1 }, // 0x5d
    { 0xd2, 0xd3, 0xd4, 0xd5, 0xd3, 0xd6, 0xd7, 0xd8 }, // 0x5e
    { 0x00, 0x00, 0x00, 0x00, 0x3d, 0x87, 0x06, 0x3e }, // 0x5f
    { 0xd9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // 0x60
    { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 }  // 0x61
};

const BYTE abType1Alpha[256] = // 154
{
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x00,
    0x00, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x00,
    0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x11,
    0x00, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x13, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x16,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15,
    0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x15, 0x17,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x15, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d
};

BOOL IsCharSpaceW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x1e; break;
        case 0x20: nType = 0x1f; break;
        case 0x30: nType = 0x20; break;
        case 0xfe: nType = 0x21; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >>(wch&__BIT_MASK)) & 1;
}

const BYTE abType1Punct[256] = // 32
{
    0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x00,
    0x00, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x00,
    0x2f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
    0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x39, 0x3a, 0x3b, 0x3c, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x3d, 0x00, 0x3e, 0x3f, 0x40
};

const BYTE abType1Digit[256] = // 11
{
    0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x00,
    0x00, 0x43, 0x43, 0x44, 0x43, 0x45, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48
};

BOOL IsCharDigitW(WCHAR wch) { return ISCHARFUNC(Digit, wch); }

BOOL IsCharXDigitW(WCHAR wch)
{
    int nType;

    switch(wch>>8)
    {
        case 0x00: nType = 0x49; break;
        case 0xff: nType = 0x4a; break;
        default:   nType = 0x00; break;
    }

    return (adwData[abIndex[nType][(wch>>__INDEX_SHIFT)&__INDEX_MASK]]
            >> (wch&__BIT_MASK)) & 1;
}

const BYTE abType1Upper[256] = // 12
{
    0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0x53,
    0x00, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55
};

const BYTE abType1Lower[256] = // 13
{
    0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0x5e,
    0x00, 0x00, 0x00, 0x00, 0x5f, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x61
};

BOOL IsCharPunctW(WCHAR wch) { return ISCHARFUNC(Punct, wch); }

BOOL IsCharCntrlW(WCHAR wch)
{
    return    (unsigned)(wch - 0x0000) <= (0x001f - 0x0000)
           || (unsigned)(wch - 0x007f) <= (0x009f - 0x007f);
}

// NB (cthrash) WCH_NBSP is considered blank, for compatibility.

BOOL IsCharBlankW(WCHAR wch)
{
    return    wch == 0x0009
           || wch == 0x0020
           || wch == 0x00a0
           || wch == 0x3000
           || wch == 0xfeff;
}

BOOL IsCharAlphaWrap(WCHAR wch) { return ISCHARFUNC(Alpha, wch); }
BOOL IsCharUpperWrap(WCHAR wch) { return ISCHARFUNC(Upper, wch); }
BOOL IsCharLowerWrap(WCHAR wch) { return ISCHARFUNC(Lower, wch); }

BOOL IsCharAlphaNumericWrap(WCHAR wch)
{
    return ISCHARFUNC(Alpha, wch) || ISCHARFUNC(Digit, wch);
}

static const BYTE abType3PageSub[256] = 
{
    0x00, 0x80, 0x81, 0x82, 0x00, 0x83, 0x84, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 
    0x00, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x8e, 0x8f, 0x90, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x91, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x20, 0x92, 0x00, 0x00, 0x93, 0x94, 0x00
};

static const BYTE abType3Page0[256] = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 
    0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x09, 0x09, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 
    0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 0x09, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x09, 0x09, 0x01, 0x09, 0x09, 0x01, 
    0x01, 0x01, 0x00, 0x01, 0x09, 0x01, 0x01, 0x09, 
    0x01, 0x01, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page32[256] = 
{
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
    0x11, 0x11, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x09, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static const BYTE abType3Page48[256] = 
{
    0x11, 0x11, 0x11, 0x00, 0x00, 0x20, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x11, 0x11, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
    0x01, 0x01, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
    0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 
    0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 
    0x00, 0x06, 0x06, 0x16, 0x16, 0x04, 0x04, 0x00, 
    0x00, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 0x02, 0x12, 
    0x02, 0x12, 0x02, 0x12, 0x12, 0x02, 0x12, 0x02, 
    0x12, 0x02, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 
    0x12, 0x02, 0x02, 0x12, 0x02, 0x02, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 
    0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x02, 0x12, 
    0x02, 0x02, 0x12, 0x12, 0x02, 0x02, 0x02, 0x02, 
    0x02, 0x02, 0x02, 0x13, 0x06, 0x02, 0x02, 0x00
};

static const BYTE abType3Page255[256] = 
{
    0x00, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11, 0x11, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x11, 
    0x11, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 
    0x10, 0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0e, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 
    0x00, 0x00, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x00, 
    0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

struct tagType3DualValue
{
    DWORD   adwBitfield[8];
    DWORD   adwValue[2];
}

const aType3DualValue[21] =
{
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page1
      0x00000000, 0x0000000f, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page2
      0x00000000, 0x3f000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x04000000, 0x000000b0,   // Page3
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xf8000000, 0x00000000, 0x00000200,   // Page5
      0x40000000, 0x00000009, 0x00180000, 0x00000000, 0x00000001 },
    { 0x88001000, 0x00000000, 0x00000000, 0x00003c00, 0x00000000,   // Page6
      0x00000000, 0x00100000, 0x00000200, 0x00000000, 0x00000001 },
    { 0x00000000, 0x80008000, 0x0c008040, 0x00000000, 0x00000000,   // Page14
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page31
      0xe0000000, 0xe000e003, 0x6000e000, 0x00000000, 0x00000001 },
    { 0x00800000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000,   // Page33
      0xffffffff, 0xffffffff, 0x000007ff, 0x00000000, 0x00000001 },
    { 0x40000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page34
      0x00000000, 0x00000000, 0xfffc0000, 0x00000001, 0x00000000 },
    { 0x00000002, 0x00000000, 0x00000000, 0xf8000000, 0xffffffff,   // Page35
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0xffffffe0, 0xfffff800, 0xffffffff, 0xffffffff,   // Page36
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffc00000,   // Page37
      0x00002000, 0x00000000, 0xffff8000, 0x00000001, 0x00000000 },
    { 0x03f00000, 0x00000000, 0x00000000, 0xffff0000, 0xffffffff,   // Page38
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000001, 0x00000000 },
    { 0xfffff3de, 0xfffffeff, 0x7f47afff, 0x000000fe, 0xff100000,   // Page39
      0x7ffeffff, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfffe0000, 0xffffffff, 0x0000001f, 0x00000000,   // Page49
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000010 },
    { 0x00000000, 0x00000000, 0x00000000, 0x80000000, 0x00000000,   // Page50
      0x00000000, 0x00000fff, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0xff000000, 0x0001ffff, 0x00000000,   // Page51
      0x00000000, 0x00000000, 0x7fffffff, 0x00000000, 0x00000001 },
    { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,   // Page159
      0xffffffc0, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xffffc000, 0xffffffff, 0xffffffff, 0xffffffff,   // Page250
      0xffffffff, 0xffffffff, 0xffffffff, 0x00000020, 0x00000000 },
    { 0x00000000, 0xc0000000, 0x00000000, 0x00000000, 0x00000000,   // Page253
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 },
    { 0x00000000, 0xfff90000, 0xfef7fe1f, 0x00000f77, 0x00000000,   // Page254
      0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001 }
};

//
//  CType 3 Flag Bits.
//
//  In the interest of reducing our table complexity, we've here a reduced
//  bitfield.  Only those bits currently used by IE4 are returned by
//  GetStringType3Ex().
//

// These are the flags are they are defined in winnls.h
//

// C3_NONSPACING    0x0001
// C3_DIACRITIC     0x0002
// C3_VOWELMARK     0x0004
// C3_SYMBOL        0x0008
// C3_KATAKANA      0x0010
// C3_HIRAGANA      0x0020
// C3_HALFWIDTH     0x0040
// C3_FULLWIDTH     0x0080
// C3_IDEOGRAPH     0x0100
// C3_KASHIDA       0x0200
// C3_LEXICAL       0x0400
// C3_ALPHA         0x8000

// The supported flags are encoded by shifting them to the right 3 bits.

// C3_SYMBOL       0x0001
// C3_KATAKANA     0x0002
// C3_HIRAGANA     0x0004
// C3_HALFWIDTH    0x0008
// C3_FULLWIDTH    0x0010
// C3_IDEOGRAPH    0x0020

// GetStringType3Ex returns the correct Win32 flags NOT the compressed flags.

BOOL GetStringType3ExW(
    LPCWSTR lpSrcStr,    // string arg
    int     cchSrc,      // length (or -1)
    LPWORD  lpCharType ) // output buffer
{
    LPCWSTR  lpStop = lpSrcStr + ((cchSrc == -1) ? MAXLONG : cchSrc);

    while (lpSrcStr < lpStop)
    {
        WCHAR wch = *lpSrcStr++;
        WORD wCharType;
        BYTE bPageSub;

        if (!wch && cchSrc == -1)
            break;

        switch (wch & (unsigned int)0xff00)
        {
            case 0x0000:
                wCharType = abType3Page0[wch];         // Page0: 4 values
                break;
            case 0x2000:
                wCharType = abType3Page32[wch & 0xff]; // Page32: 4 values
                break;
            case 0x3000:
                wCharType = abType3Page48[wch & 0xff];  // Page48: 10 values
                break;
            case 0xff00:
                wCharType = abType3Page255[wch & 0xff]; // Page255: 7 values
                break;
            default:
                bPageSub = abType3PageSub[wch>>8];

                if (bPageSub & 0x80)                  // 21 pages have 2 values
                {
                    const struct tagType3DualValue *p = aType3DualValue +
                        (bPageSub & 0x7f);

                    wCharType = (BYTE) p->adwValue[(p->adwBitfield[(wch>>5)&7]
                        >> (wch & 0x1f)) & 1];
                }
                else                                  // 231 pages have 1 value
                {
                    wCharType = bPageSub;
                }
                break;
        }

        *lpCharType++ = wCharType << 3;
    }
    
    return TRUE;
}

//
//  Str Functions from SHLWAPI
//
int StrCmpW(
    IN LPCWSTR pwsz1,
    IN LPCWSTR pwsz2)
{
    int iRet = -1;  // arbitrary on failure

    ASSERT(IS_VALID_STRING_PTRW(pwsz1, -1));
    ASSERT(IS_VALID_STRING_PTRW(pwsz2, -1));
    
    if (pwsz1 && pwsz2)
    {
        CStrIn psz1(pwsz1);
        CStrIn psz2(pwsz2);
        
        iRet = lstrcmpA(psz1, psz2);
    }
    return iRet;
}

int StrCmpIW(
    IN LPCWSTR pwsz1,
    IN LPCWSTR pwsz2)
{
    int iRet = -1;  // arbitrary on failure

    ASSERT(IS_VALID_STRING_PTRW(pwsz1, -1));
    ASSERT(IS_VALID_STRING_PTRW(pwsz2, -1));
    
    if (pwsz1 && pwsz2)
    {
        CStrIn psz1(pwsz1);
        CStrIn psz2(pwsz2);

        iRet = lstrcmpiA(psz1, psz2);
    }

    return iRet;
}

#if 0   // BUGBUG: We have another StrCpyW in strings.c
LPWSTR StrCpyW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    ASSERT(psz1);
    ASSERT(psz2);

    while (*psz1++ = *psz2++)
        ;

    return psz;
}
#endif


LPWSTR StrCatW(LPWSTR psz1, LPCWSTR psz2)
{
    LPWSTR psz = psz1;

    ASSERT(psz1);
    ASSERT(psz2);

    while (0 != *psz1)
        psz1++;

    while (*psz1++ = *psz2++)
        ;

    return psz;
}


//+------------------------------------------------------------------------
//
//  Implementation of the wrapped functions
//
//-------------------------------------------------------------------------

BOOL AppendMenuWrap(
        HMENU   hMenu,
        UINT    uFlags,
        UINT    uIDnewItem,
        LPCWSTR lpnewItem)
{
    ASSERT(!(uFlags & MF_BITMAP) && !(uFlags & MF_OWNERDRAW));

    CStrIn  str(lpnewItem);

    return AppendMenuA(hMenu, uFlags, uIDnewItem, str);
}

BOOL CallMsgFilterWrap(LPMSG lpMsg, int nCode)
{
    return CallMsgFilterA(lpMsg, nCode);
}

LRESULT CallWindowProcWrap(
    WNDPROC lpPrevWndFunc,
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    return CallWindowProcA(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
}

//----------------------------------------------------------------------
//
// function:    CharLowerWrap( LPWSTR pch )
//
// purpose:     Converts character to lowercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Lowercased character or string.  In the string case,
//              the lowercasing is done inplace.
//
//----------------------------------------------------------------------

LPWSTR CharLowerWrap( LPWSTR pch )
{
    if (!HIWORD64(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharLowerBuffWrap( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharLowerBuffWrap( pch, lstrlenW(pch) );
    }

    return pch;
}

//----------------------------------------------------------------------
//
// function:    CharLowerBuffWrap( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to lowercase.  String must be cch
//              characters in length.
//
// returns:     Character count (cch).  The lowercasing is done inplace.
//
//----------------------------------------------------------------------

DWORD CharLowerBuffWrap( LPWSTR pch, DWORD cchLength )
{
    DWORD cch;

    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharUpperWrap(ch))
        {
            if (ch < 0x0100)
            {
                *pch += 32;             // Get Latin-1 out of the way first
            }
            else if (ch < 0x0531)
            {
                if (ch < 0x0391)
                {
                    if (ch < 0x01cd)
                    {
                        if (ch <= 0x178)
                        {
                            if (ch < 0x0178)
                            {
                                *pch += (ch == 0x0130) ? 0 : 1;
                            }
                            else
                            {
                                *pch -= 121;
                            }
                        }
                        else
                        {
                            static const BYTE abLookup[] =
                            {  // 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
            /* 0x0179-0x17f */           1,   0,   1,   0,   1,   0,   0,
            /* 0x0180-0x187 */      0, 210,   1,   0,   1,   0, 206,   1,
            /* 0x0188-0x18f */      0, 205, 205,   1,   0,   0,  79, 202,
            /* 0x0190-0x197 */    203,   1,   0, 205, 207,   0, 211, 209,
            /* 0x0198-0x19f */      1,   0,   0,   0, 211, 213,   0, 214,
            /* 0x01a0-0x1a7 */      1,   0,   1,   0,   1,   0,   0,   1,
            /* 0x01a8-0x1af */      0, 218,   0,   0,   1,   0, 218,   1,
            /* 0x01b0-0x1b7 */      0, 217, 217,   1,   0,   1,   0, 219,
            /* 0x01b8-0x1bf */      1,   0,   0,   0,   1,   0,   0,   0,
            /* 0x01c0-0x1c7 */      0,   0,   0,   0,   2,   0,   0,   2,
            /* 0x01c8-0x1cb */      0,   0,   2,   0
                            };

                            *pch += abLookup[ch-0x0179];
                        }
                    }
                    else if (ch < 0x0386)
                    {
                        switch (ch)
                        {
                            case 0x01f1: *pch += 2; break;
                            case 0x01f2: break;
                            default: *pch += 1;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                            { 38, 0, 37, 37, 37, 0, 64, 0, 63, 63 };

                        *pch += abLookup[ch-0x0386];
                    }
                }
                else
                {
                    if (ch < 0x0410)
                    {
                        if (ch < 0x0401)
                        {
                            if (ch < 0x03e2)
                            {
                                if (!InRange(ch, 0x03d2, 0x03d4) &&
                                    !(InRange(ch, 0x3da, 0x03e0) & !(ch & 1)))
                                {
                                    *pch += 32;
                                }
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else
                        {
                            *pch += 80;
                        }
                    }
                    else
                    {
                        if (ch < 0x0460)
                        {
                            *pch += 32;
                        }
                        else
                        {
                            *pch += 1;
                        }
                    }
                }
            }
            else
            {
                if (ch < 0x2160)
                {
                    if (ch < 0x1fba)
                    {
                        if (ch < 0x1f08)
                        {
                            if (ch < 0x1e00)
                            {
                                *pch += 48;
                            }
                            else
                            {
                                *pch += 1;
                            }
                        }
                        else if (!(InRange(ch, 0x1f88, 0x1faf) && (ch & 15)>7))
                        {
                            *pch -= 8;
                        }
                    }
                    else
                    {
                        static const BYTE abLookup[] =
                        {  // 8    9    a    b    c    d    e    f
                              0,   0,  74,  74,   0,   0,   0,   0,
                             86,  86,  86,  86,   0,   0,   0,   0,
                              8,   8, 100, 100,   0,   0,   0,   0,
                              8,   8, 112, 112,   7,   0,   0,   0,
                            128, 128, 126, 126,   0,   0,   0,   0
                        };
                        int i = (ch-0x1fb0);

                        *pch -= (int)abLookup[((i>>1) & ~7) | (i & 7)];
                    }
                }
                else
                {
                    if (ch < 0xff21)
                    {
                        if (ch < 0x24b6)
                        {
                            *pch += 16;
                        }
                        else
                        {
                            *pch += 26;
                        }
                    }
                    else
                    {
                        *pch += 32;
                    }
                }
            }
        }
        else
        {
            // These are Unicode Number Forms.  They have lowercase counter-
            // parts, but are not considered uppercase.  Why, I don't know.

            if (InRange(ch, 0x2160, 0x216f))
            {
                *pch += 16;
            }
        }
    }

    return cchLength;
}

//
// BUGBUG - Do CharNextWrap and CharPrevWrap need to call the 
//          CharNextW, CharPrevW on WinNT?  Couldn't these be MACROS?
 
LPWSTR CharNextWrap(LPCWSTR lpszCurrent)
{
    if (*lpszCurrent)
    {
        return (LPWSTR) lpszCurrent + 1;
    }
    else
    {
        return (LPWSTR) lpszCurrent;
    }
}

LPWSTR CharPrevWrap(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
{
    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}

BOOL CharToOemWrap(LPCWSTR lpszSrc, LPSTR lpszDst)
{
    CStrIn  str(lpszSrc);

    return CharToOemA(str, lpszDst);
}

//----------------------------------------------------------------------
//
// function:    CharUpperWrap( LPWSTR pch )
//
// purpose:     Converts character to uppercase.  Takes either a pointer
//              to a string, or a character masquerading as a pointer.
//              In the later case, the HIWORD must be zero.  This is
//              as spec'd for Win32.
//
// returns:     Uppercased character or string.  In the string case,
//              the uppercasing is done inplace.
//
//----------------------------------------------------------------------

LPWSTR CharUpperWrap( LPWSTR pch )
{
    if (!HIWORD64(pch))
    {
        WCHAR ch = (WCHAR)(LONG_PTR)pch;

        CharUpperBuffWrap( &ch, 1 );

        pch = (LPWSTR)MAKEINTATOM(ch);
    }
    else
    {
        CharUpperBuffWrap( pch, lstrlenW(pch) );
    }

    return pch;
}

//----------------------------------------------------------------------
//
// function:    CharUpperBuffWrap( LPWSTR pch, DWORD cch )
//
// purpose:     Converts a string to uppercase.  String must be cch
//              characters in length.  Note that this function is
//              is messier that CharLowerBuffWrap, and the reason for
//              this is many Unicode characters are considered uppercase,
//              even when they don't have an uppercase counterpart.
//
// returns:     Character count (cch).  The uppercasing is done inplace.
//
//----------------------------------------------------------------------

DWORD CharUpperBuffWrap( LPWSTR pch, DWORD cchLength )
{
    DWORD cch;
    
    for ( cch = cchLength; cch-- ; pch++ )
    {
        WCHAR ch = *pch;

        if (IsCharLowerWrap(ch))
        {
            if (ch < 0x00ff)
            {
                *pch -= ((ch != 0xdf) << 5);
            }
            else if (ch < 0x03b1)
            {
                if (ch < 0x01f5)
                {
                    if (ch < 0x01ce)
                    {
                        if (ch < 0x017f)
                        {
                            if (ch < 0x0101)
                            {
                                *pch += 121;
                            }
                            else
                            {
                                *pch -= (ch != 0x0131 &&
                                         ch != 0x0138 &&
                                         ch != 0x0149);
                            }
                        }
                        else if (ch < 0x01c9)
                        {
                            static const BYTE abMask[] =
                            {                       // 6543210f edcba987
                                0xfc, 0xbf,         // 11111100 10111111
                                0xbf, 0x67,         // 10111111 01100111
                                0xff, 0xef,         // 11111111 11101111
                                0xff, 0xf7,         // 11111111 11110111
                                0xbf, 0xfd          // 10111111 11111101
                            };

                            int i = ch - 0x017f;

                            *pch -= ((abMask[i>>3] >> (i&7)) & 1) +
                                    (ch == 0x01c6);                
                        }
                        else 
                        {
                            *pch -= ((ch != 0x01cb)<<1);
                        }
                    }
                    else
                    {
                        if (ch < 0x01df)
                        {
                            if (ch < 0x01dd)
                            {
                                *pch -= 1;
                            }
                            else 
                            {
                                *pch -= 79;
                            }
                        }
                        else 
                        {
                            *pch -= 1 + (ch == 0x01f3) -
                                    InRange(ch,0x01f0,0x01f2);
                        }
                    }
                }
                else if (ch < 0x0253)
                {
                    *pch -= (ch < 0x0250);
                }
                else if (ch < 0x03ac)
                {
                    static const BYTE abLookup[] =
                    {// 0/8  1/9  2/a  3/b  4/c  5/d  6/e  7/f
    /* 0x0253-0x0257 */                210, 206,   0, 205, 205,
    /* 0x0258-0x025f */   0, 202,   0, 203,   0,   0,   0,   0,
    /* 0x0260-0x0267 */ 205,   0,   0, 207,   0,   0,   0,   0,
    /* 0x0268-0x026f */ 209, 211,   0,   0,   0,   0,   0, 211,
    /* 0x0270-0x0277 */   0,   0, 213,   0,   0, 214,   0,   0,
    /* 0x0278-0x027f */   0,   0,   0,   0,   0,   0,   0,   0,
    /* 0x0280-0x0287 */   0,   0,   0, 218,   0,   0,   0,   0,
    /* 0x0288-0x028f */ 218,   0, 217, 217,   0,   0,   0,   0,
    /* 0x0290-0x0297 */   0,   0, 219
                    };

                    if (ch <= 0x0292)
                    {
                        *pch -= abLookup[ch - 0x0253];
                    }
                }
                else 
                {
                    *pch -= (ch == 0x03b0) ? 0 : (37 + (ch == 0x03ac));
                }
            }
            else
            {
                if (ch < 0x0561)
                {
                    if (ch < 0x0451)
                    {
                        if (ch < 0x03e3)
                        {
                            if (ch < 0x03cc)
                            {
                                *pch -= (ch != 0x03c2)<<5;
                            }
                            else 
                            {
                                int i = (ch < 0x03d0);
                                *pch -= (i<<6) - i + (ch == 0x03cc);
                            }
                        }
                        else if (ch < 0x0430)
                        {
                            *pch -= (ch < 0x03f0);
                        }
                        else 
                        {
                            *pch -= 32;
                        }
                    }
                    else if (ch < 0x0461)
                    {
                        *pch -= 80;
                    }
                    else 
                    {
                        *pch -= 1;
                    }
                }
                else
                {
                    if (ch < 0x1fb0)
                    {
                        if (ch < 0x1f70)
                        {
                            if (ch < 0x1e01)
                            {
                                int i = ch != 0x0587 && ch != 0x10f6;
                                *pch -= ((i<<5)+(i<<4)); /* 48 */
                            }
                            else if (ch < 0x1f00)
                            {
                                *pch -= !InRange(ch, 0x1e96, 0x1e9a);
                            }
                            else 
                            {
                                int i = !InRange(ch, 0x1f50, 0x1f56)||(ch & 1);
                                *pch += (i<<3);
                            }
                        }
                        else 
                        {
                            static const BYTE abLookup[] =
                                { 74, 86, 86, 100, 128, 112, 126 };

                            if ( ch <= 0x1f7d )
                            {
                                *pch += abLookup[(ch-0x1f70)>>1];
                            }
                        }
                    }
                    else
                    {
                        if (ch < 0x24d0)
                        {
                            if (ch < 0x1fe5)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 8 : 0;
                            }
                            else if (ch < 0x2170)
                            {
                                *pch += (0x0023 & (1<<(ch&15))) ? 7 : 0;
                            }                
                            else 
                            {
                                *pch -= ((ch > 0x24b5)<<4);
                            }
                        }
                        else if (ch < 0xff41)
                        {   
                            int i = !InRange(ch, 0xfb00, 0xfb17);
                            *pch -= (i<<4)+(i<<3)+(i<<1); /* 26 */
                        }
                        else
                        {
                            *pch -= 32;
                        }
                    }
                }
            }
        }
        else
        {
            int i = InRange(ch, 0x2170, 0x217f);
            *pch -= (i<<4);
        }
    }

    return cchLength;
}

int CopyAcceleratorTableWrap(
        HACCEL  hAccelSrc,
        LPACCEL lpAccelDst,
        int     cAccelEntries)
{
    return CopyAcceleratorTableA(hAccelSrc, lpAccelDst, cAccelEntries);
}

HACCEL CreateAcceleratorTableWrap(LPACCEL lpAccel, int cEntries)
{
    return CreateAcceleratorTableA(lpAccel, cEntries);
}

typedef HDC (*FnCreateHDCA)(LPCSTR, LPCSTR, LPCSTR, CONST DEVMODEA *);

HDC CreateHDCWrap(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData,
        FnCreateHDCA        pfn)
{
    DEVMODEA *  pdevmode = NULL;
    CStrIn      strDriver(lpszDriver);
    CStrIn      strDevice(lpszDevice);
    CStrIn      strOutput(lpszOutput);
    HDC         hdcReturn = 0;

    if (lpInitData)
    {
        pdevmode = (DEVMODEA *) LocalAlloc( LPTR, lpInitData->dmSize + lpInitData->dmDriverExtra );

        if (pdevmode)
        {
            MbcsFromUnicode((CHAR *)pdevmode->dmDeviceName, CCHDEVICENAME, lpInitData->dmDeviceName);
            memcpy(&pdevmode->dmSpecVersion,
                    &lpInitData->dmSpecVersion,
                    FIELD_OFFSET(DEVMODEW,dmFormName) - FIELD_OFFSET(DEVMODEW,dmSpecVersion));
            MbcsFromUnicode((CHAR *)pdevmode->dmFormName, CCHFORMNAME, lpInitData->dmFormName);
            memcpy(&pdevmode->dmLogPixels,
                    &lpInitData->dmLogPixels,
                    lpInitData->dmDriverExtra + lpInitData->dmSize - FIELD_OFFSET(DEVMODEW, dmLogPixels));

            pdevmode->dmSize -= (sizeof(BCHAR) - sizeof(char)) * (CCHDEVICENAME + CCHFORMNAME);
        }
    }

    hdcReturn = (*pfn)(strDriver, strDevice, strOutput, pdevmode);

    if (pdevmode)
    {
        LocalFree(pdevmode);
    }

    return hdcReturn;
}

HDC CreateDCWrap(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
    return CreateHDCWrap(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateDCA);
}

HDC CreateICWrap(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
    return CreateHDCWrap(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateICA);
}


BOOL CreateDirectoryWrap(
        LPCWSTR                 lpPathName,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes)
{
    CStrIn  str(lpPathName);

    ASSERT(!lpSecurityAttributes);
    return CreateDirectoryA(str, lpSecurityAttributes);
}

HANDLE CreateEventWrap(
        LPSECURITY_ATTRIBUTES   lpEventAttributes,
        BOOL                    bManualReset,
        BOOL                    bInitialState,
        LPCWSTR                 lpName)
{
    return CreateEventA(lpEventAttributes, bManualReset, bInitialState, (LPCSTR) lpName);
}

HANDLE CreateFileWrap(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile)
{
    CStrIn  str(lpFileName);

    return CreateFileA(
            str,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
}

HANDLE CreateFileMappingWrap(
        HANDLE hFile,
        LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
        DWORD flProtect,
        DWORD dwMaxSizeHigh,
        DWORD dwMaxSizeLow,
        LPCWSTR lpName)
{
    CStrIn str(lpName);

    return CreateFileMappingA(
            hFile,
            lpFileMappingAttributes,
            flProtect,
            dwMaxSizeHigh,
            dwMaxSizeLow,
            str);
}

HFONT CreateFontWrap(
        int nHeight,
        int nWidth,
        int nEscapement,
        int nOrientation,
        int fnWeight,
        DWORD fdwItalic,
        DWORD fdwUnderline,
        DWORD fdwStrikeOut,
        DWORD fdwCharSet,
        DWORD fdwOutputPrecision,
        DWORD fdwClipPrecision,
        DWORD fdwQuality,
        DWORD fdwPitchAndFamily,
        LPCWSTR lpszFace)
{
    CStrIn str(lpszFace);

    return CreateFontA(
        nHeight,
        nWidth,
        nEscapement,
        nOrientation,
        fnWeight,
        fdwItalic,
        fdwUnderline,
        fdwStrikeOut,
        fdwCharSet,
        fdwOutputPrecision,
        fdwClipPrecision,
        fdwQuality,
        fdwPitchAndFamily,
        str);
}

HFONT CreateFontIndirectWrap(CONST LOGFONTW * plfw)
{
    LOGFONTA  lfa;
    HFONT     hFont;

    memcpy(&lfa, plfw, FIELD_OFFSET(LOGFONTA, lfFaceName));
    MbcsFromUnicode(lfa.lfFaceName, ARRAYSIZE(lfa.lfFaceName), plfw->lfFaceName);
    hFont = CreateFontIndirectA(&lfa);

    return hFont;
}

HWND CreateWindowExWrap(
        DWORD       dwExStyle,
        LPCWSTR     lpClassName,
        LPCWSTR     lpWindowName,
        DWORD       dwStyle,
        int         X,
        int         Y,
        int         nWidth,
        int         nHeight,
        HWND        hWndParent,
        HMENU       hMenu,
        HINSTANCE   hInstance,
        LPVOID      lpParam)
{
    CStrIn  strClass(lpClassName);
    CStrIn  strWindow(lpWindowName);

    return CreateWindowExA(
            dwExStyle,
            strClass,
            strWindow,
            dwStyle,
            X,
            Y,
            nWidth,
            nHeight,
            hWndParent,
            hMenu,
            hInstance,
            lpParam);
}

LRESULT DefWindowProcWrap(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    return DefWindowProcA(hWnd, msg, wParam, lParam);
}

BOOL DeleteFileWrap(LPCWSTR pwsz)
{
    CStrIn  str(pwsz);

    return DeleteFileA(str);
}

LRESULT DispatchMessageWrap(CONST MSG * lpMsg)
{
    return DispatchMessageA(lpMsg);
}

#ifndef FONT_LINK
int DrawTextWrap(
        HDC     hDC,
        LPCWSTR lpString,
        int     nCount,
        LPRECT  lpRect,
        UINT    uFormat)
{
    CStrIn  str(lpString, nCount);

    return DrawTextA(hDC, str, str.strlen(), lpRect, uFormat);
}

// shlwapi also have this.
int DrawTextExPrivWrap(
        HDC     hDC,
        LPWSTR  lpString,
        int     nCount,
        LPRECT  lpRect,
        UINT    uFormat,
        LPDRAWTEXTPARAMS lpDTParams)
{
    CStrIn  str(lpString, nCount);

    return DrawTextExA(hDC, str, str.strlen(), lpRect, uFormat, lpDTParams);
}
#endif

struct EFFSTAT
{
    LPARAM          lParam;
    FONTENUMPROC    lpEnumFontProc;
    BOOL            fFamilySpecified;
};

int CALLBACK EnumFontFamiliesCallbackWrap(
        ENUMLOGFONTA *  lpelf,
        NEWTEXTMETRIC * lpntm,
        DWORD           FontType,
        LPARAM          lParam)
{
    ENUMLOGFONTW    elf;

    //  Convert strings from ANSI to Unicode
    if (((EFFSTAT *)lParam)->fFamilySpecified && (FontType & TRUETYPE_FONTTYPE) )
    {
        UnicodeFromMbcs(
                        elf.elfFullName,
                        ARRAYSIZE(elf.elfFullName),
                        (LPCSTR) lpelf->elfFullName);
        UnicodeFromMbcs(
                        elf.elfStyle,
                        ARRAYSIZE(elf.elfStyle),
                        (LPCSTR) lpelf->elfStyle);
    }
    else
    {
        elf.elfStyle[0] = L'\0';
        elf.elfFullName[0] = L'\0';
    }

    UnicodeFromMbcs(
            elf.elfLogFont.lfFaceName,
            ARRAYSIZE(elf.elfLogFont.lfFaceName),
            (LPCSTR) lpelf->elfLogFont.lfFaceName);

    //  Copy the non-string data
    memcpy(
            &elf.elfLogFont,
            &lpelf->elfLogFont,
            FIELD_OFFSET(LOGFONTA, lfFaceName));

    //  Chain to the original callback function
    return (*((EFFSTAT *) lParam)->lpEnumFontProc)(
            (const LOGFONTW *) &elf,
            (const TEXTMETRICW *) lpntm,
            FontType,
            ((EFFSTAT *) lParam)->lParam);
}

int EnumFontFamiliesWrap(
        HDC          hdc,
        LPCWSTR      lpszFamily,
        FONTENUMPROC lpEnumFontProc,
        LPARAM       lParam)
{
    CStrIn  str(lpszFamily);
    EFFSTAT effstat;

    effstat.lParam = lParam;
    effstat.lpEnumFontProc = lpEnumFontProc;
    effstat.fFamilySpecified = lpszFamily != NULL;

    return EnumFontFamiliesA(
            hdc,
            str,
            (FONTENUMPROCA) EnumFontFamiliesCallbackWrap,
            (LPARAM) &effstat);
}

int EnumFontFamiliesExWrap(
        HDC          hdc,
        LPLOGFONTW   lplfw,
        FONTENUMPROC lpEnumFontProc,
        LPARAM       lParam,
        DWORD        dwFlags )
{
    LOGFONTA lfa;
    CStrIn   str(lplfw->lfFaceName);
    EFFSTAT  effstat;

    ASSERT( FIELD_OFFSET(LOGFONTW, lfFaceName) == FIELD_OFFSET(LOGFONTA, lfFaceName) );
    
    memcpy( &lfa, lplfw, sizeof(LOGFONTA) - FIELD_OFFSET(LOGFONTA, lfFaceName) );
    memcpy( lfa.lfFaceName, str, LF_FACESIZE );

    effstat.lParam = lParam;
    effstat.lpEnumFontProc = lpEnumFontProc;
    effstat.fFamilySpecified = lplfw->lfFaceName != NULL;

    return EnumFontFamiliesExA(
            hdc,
            &lfa,
            (FONTENUMPROCA) EnumFontFamiliesCallbackWrap,
            (LPARAM) &effstat,
            dwFlags );
}

BOOL EnumResourceNamesWrap(
        HINSTANCE        hModule,
        LPCWSTR          lpType,
        ENUMRESNAMEPROCW lpEnumFunc,
        LONG             lParam)
{
    ASSERT(HIWORD64(lpType) == 0);

    return EnumResourceNamesA(hModule, (LPCSTR) lpType, (ENUMRESNAMEPROCA)lpEnumFunc, lParam);
}

#ifndef FONT_LINK
//
//  There's an app that patches Win95 GDI and their ExtTextOutW handler
//  is broken.  It always dereferences the lpStr parameter, even if
//  cb is zero.  Consequently, any time we are about to pass NULL as
//  the lpStr, we have to change our mind and pass a null UNICODE string
//  instead.
//
//  The name of this app:  Lotus SmartSuite ScreenCam 97.
//
BOOL ExtTextOutWrap(HDC hdc, int x, int y, UINT fuOptions, CONST RECT *lprc, LPCWSTR lpStr, UINT cch, CONST INT *lpDx)
{
    // Force a thunk to ANSI if running Win95 + ME
    if (g_fMEEnabled && !g_bRunOnMemphis)
    {
        CStrIn str(lpStr, cch);

        return ExtTextOutA(hdc, x, y, fuOptions, lprc, str, str.strlen(), lpDx);
    }
    else
    {
        if (lpStr == NULL)              // workaround
            lpStr = TEXT("");           // for ScreenCam 97
        return ExtTextOutW(hdc, x, y, fuOptions, lprc, lpStr, cch, lpDx);
    }
}    
#endif

HANDLE FindFirstFileWrap(
        LPCWSTR             lpFileName,
        LPWIN32_FIND_DATAW  pwszFd)
{
    CStrIn              str(lpFileName);
    WIN32_FIND_DATAA    fd;
    HANDLE              ret;

    memcpy(&fd, pwszFd, sizeof(FILETIME)*3+sizeof(DWORD)*5);

    ret = FindFirstFileA(str, &fd);

    memcpy(pwszFd, &fd, sizeof(FILETIME)*3+sizeof(DWORD)*5);

    UnicodeFromMbcs(pwszFd->cFileName, ARRAYSIZE(pwszFd->cFileName), fd.cFileName);
    UnicodeFromMbcs(pwszFd->cAlternateFileName, ARRAYSIZE(pwszFd->cAlternateFileName), fd.cAlternateFileName);

    return ret;
}

//
// Although Win95 implements FindResource[Ex]W, its implementation is buggy
// if you pass a string parameter, so we must thunk to the ANSI side.
//
// The bug is that FindResource[Ex]W will accidentally
// call LocalFree(lpName) and LocalFree(lpType), so if lpName and lpType
// point to heap memory, Kernel32 secretly freed your memory and you fault
// five minutes later.
//
HRSRC FindResourceExWrap(HINSTANCE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLang)
{
    CStrIn  strType(lpType);            // rlefile.cpp passes TEXT("AVI")
    CStrIn  strName(lpName);

    return FindResourceExA(hModule, strType, strName, wLang);
}

HWND FindWindowWrap(LPCWSTR lpClassName, LPCWSTR lpWindowName)
{
    CStrIn  strClass(lpClassName);
    CStrIn  strWindow(lpWindowName);

    return FindWindowA(strClass, strWindow);
}

DWORD FormatMessageWrap(
    DWORD       dwFlags,
    LPCVOID     lpSource,
    DWORD       dwMessageId,
    DWORD       dwLanguageId,
    LPWSTR      lpBuffer,
    DWORD       nSize,
    va_list *   Arguments)
{
    //This assert is only valid on Windows 95.
    ASSERT(!(dwFlags & FORMAT_MESSAGE_ALLOCATE_BUFFER));

    CStrOut str(lpBuffer, nSize);

    FormatMessageA(
            dwFlags,
            lpSource,
            dwMessageId,
            dwLanguageId,
            str,
            str.BufSize(),
            Arguments);

    return str.ConvertExcludingNul();
}

BOOL GetClassInfoWrap(HINSTANCE hModule, LPCWSTR lpClassName, LPWNDCLASSW lpWndClassW)
{
    BOOL    ret;

    CStrIn  strClassName(lpClassName);

    ASSERT(sizeof(WNDCLASSA) == sizeof(WNDCLASSW));

    ret = GetClassInfoA(hModule, strClassName, (LPWNDCLASSA) lpWndClassW);

    lpWndClassW->lpszMenuName = NULL;
    lpWndClassW->lpszClassName = NULL;
    return ret;
}

DWORD GetClassLongWrap(HWND hWnd, int nIndex)
{
    return GetClassLongA(hWnd, nIndex);
}

int GetClassNameWrap(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
{
    CStrOut strClassName(lpClassName, nMaxCount);

    GetClassNameA(hWnd, strClassName, strClassName.BufSize());
    return strClassName.ConvertIncludingNul();
}

int GetClipboardFormatNameWrap(UINT format, LPWSTR lpFormatName, int cchFormatName)
{
    CStrOut strFormatName(lpFormatName, cchFormatName);

    GetClipboardFormatNameA(format, strFormatName, strFormatName.BufSize());
    return strFormatName.ConvertIncludingNul();
}

DWORD GetCurrentDirectoryWrap(DWORD nBufferLength, LPWSTR lpBuffer)
{
    CStrOut str(lpBuffer, nBufferLength);

    GetCurrentDirectoryA(str.BufSize(), str);
    return str.ConvertExcludingNul();
}

int GetDateFormatWrap(
        LCID Locale,
        DWORD dwFlags,
        CONST SYSTEMTIME *lpDate,
        LPCWSTR lpFormat,
        LPWSTR lpDateStr,
        int cchDate)
{
    CStrIn strFormat(lpFormat);
    CStrOut str(lpDateStr, cchDate);

    ASSERT(cchDate != 0 || lpDateStr == NULL);

    int iRc = GetDateFormatA(Locale, dwFlags, lpDate, strFormat, str, str.BufSize());

    // If app was merely querying, then return size and stop
    if (!str)
        return iRc;

    return str.ConvertIncludingNul();
}

UINT GetDlgItemTextWrap(
        HWND    hWndDlg,
        int     idControl,
        LPWSTR  lpsz,
        int     cchMax)
{
    CStrOut str(lpsz, cchMax);

    GetDlgItemTextA(hWndDlg, idControl, str, str.BufSize());
    return str.ConvertExcludingNul();
}

DWORD GetFileAttributesWrap(LPCWSTR lpFileName)
{
    CStrIn  str(lpFileName);

    return GetFileAttributesA(str);
}

int GetKeyNameTextWrap(LONG lParam, LPWSTR lpsz, int nSize)
{
    CStrOut str(lpsz, nSize);

    GetKeyNameTextA(lParam, str, str.BufSize());
    return str.ConvertExcludingNul();
}

int GetLocaleInfoWrap(LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData)
{
    CStrOut str(lpsz, cchData);

    GetLocaleInfoA(Locale, LCType, str, str.BufSize());
    return str.ConvertIncludingNul();
}

BOOL GetMenuItemInfoWrap(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPMENUITEMINFOW lpmiiW)
{
    BOOL fRet;
    
    ASSERT( sizeof(MENUITEMINFOW) == sizeof(MENUITEMINFOA) &&
            FIELD_OFFSET(MENUITEMINFOW, dwTypeData) ==
            FIELD_OFFSET(MENUITEMINFOA, dwTypeData) );

    if ( (MIIM_TYPE & lpmiiW->fMask) &&
         0 == (lpmiiW->fType & (MFT_BITMAP | MFT_SEPARATOR)))
    {
        MENUITEMINFOA miiA;
        CStrOut str(lpmiiW->dwTypeData, lpmiiW->cch);

        memcpy( &miiA, lpmiiW, sizeof(MENUITEMINFOA) );
        miiA.dwTypeData = str;
        miiA.cch = str.BufSize();
                
        fRet = GetMenuItemInfoA( hMenu, uItem, fByPosition, &miiA );

        memcpy(lpmiiW, &miiA, FIELD_OFFSET(MENUITEMINFOW, dwTypeData));
    }
    else
    {
        fRet = GetMenuItemInfoA( hMenu, uItem, fByPosition,
                                 (LPMENUITEMINFOA)lpmiiW );
    }

    return fRet;
}



int GetMenuStringWrap(
        HMENU   hMenu,
        UINT    uIDItem,
        LPWSTR  lpString,
        int     nMaxCount,
        UINT    uFlag)
{
    CStrOut str(lpString, nMaxCount);

    GetMenuStringA(hMenu, uIDItem, str, str.BufSize(), uFlag);
    return str.ConvertExcludingNul();
}

BOOL GetMessageWrap(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax)
{
    return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
}

DWORD GetModuleFileNameWrap(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize)
{
    CStrOut str(pwszFilename, nSize);

    GetModuleFileNameA(hModule, str, str.BufSize());
    return str.ConvertIncludingNul();
}


int GetNumberFormatWrap(
        LCID Locale,
        DWORD dwFlags,
        LPCWSTR lpValue,
        CONST NUMBERFMTW *lpFormat,
        LPWSTR lpNumberStr,
        int cchNumber)
{
    CStrIn strValue(lpValue);
    CStrOut str(lpNumberStr, cchNumber);

    ASSERT(cchNumber != 0);

    NUMBERFMTA nfA;
    CopyMemory(&nfA, lpFormat, sizeof(nfA));

    CStrIn strDec(lpFormat->lpDecimalSep);
    nfA.lpDecimalSep = strDec;

    CStrIn strThou(lpFormat->lpThousandSep);
    nfA.lpThousandSep = strThou;

    GetNumberFormatA(Locale, dwFlags, strValue, &nfA, str, str.BufSize());
    return str.ConvertIncludingNul();
}


UINT GetSystemDirectoryWrap(LPWSTR lpBuffer, UINT uSize)
{
    CStrOut str(lpBuffer, uSize);

    GetSystemDirectoryA(str, str.BufSize());
    return str.ConvertExcludingNul();
}

DWORD SearchPathWrap(
        LPCWSTR lpPathName,
        LPCWSTR lpFileName,
        LPCWSTR lpExtension,
        DWORD   cchReturnBuffer,
        LPWSTR  lpReturnBuffer,
        LPWSTR *  plpfilePart)
{
    CStrIn  strPath(lpPathName);
    CStrIn  strFile(lpFileName);
    CStrIn  strExtension(lpExtension);
    CStrOut strReturnBuffer(lpReturnBuffer, cchReturnBuffer);

    DWORD dwLen = SearchPathA(
            strPath,
            strFile,
            strExtension,
            strReturnBuffer.BufSize(),
            strReturnBuffer,
            (LPSTR *)plpfilePart);

    //
    // Getting the correct value for plpfilePart requires
    // a strrchr on the converted string.  If this value
    // is needed, just add the code to do it here.
    //

    *plpfilePart = NULL;

    if (cchReturnBuffer == 0)
        dwLen = 2*dwLen;
    else
        dwLen = strReturnBuffer.ConvertExcludingNul();

    return dwLen;
}

HMODULE GetModuleHandleWrap(LPCWSTR lpModuleName)
{
    CStrIn  str(lpModuleName);
    return GetModuleHandleA(str);
}

int GetObjectWrap(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
    int nRet;

    if(cbBuffer != sizeof(LOGFONTW))
    {
        nRet = GetObjectA(hgdiObj, cbBuffer, lpvObj);
    }
    else
    {
        LOGFONTA lfa;

        nRet = GetObjectA(hgdiObj, sizeof(lfa), &lfa);
        if (nRet > 0)
        {
            memcpy(lpvObj, &lfa, FIELD_OFFSET(LOGFONTW, lfFaceName));
            UnicodeFromMbcs(((LOGFONTW*)lpvObj)->lfFaceName, ARRAYSIZE(((LOGFONTW*)lpvObj)->lfFaceName),
                            lfa.lfFaceName, -1);
            nRet = sizeof(LOGFONTW);
        }
    }

    return nRet;
}

//--------------------------------------------------------------
//      GetFullPathNameWrap
//--------------------------------------------------------------

DWORD GetFullPathNameWrap( LPCWSTR lpFileName,
                     DWORD  nBufferLength,
                     LPWSTR lpBuffer,
                     LPWSTR *lpFilePart)
{
    CStrIn  strIn(lpFileName);
    CStrOut  strOut(lpBuffer,nBufferLength);
    LPSTR   pFile;
    DWORD   dwRet;

    dwRet = GetFullPathNameA(strIn, nBufferLength, strOut, &pFile);
    strOut.ConvertIncludingNul();
    *lpFilePart = lpBuffer + (pFile - strOut);
    return dwRet;
}

BOOL GetStringTypeExWrap(LCID lcid, DWORD dwInfoType, LPCTSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
{
    CStrIn  str(lpSrcStr, cchSrc);
    return GetStringTypeExA(lcid, dwInfoType, str, str.strlen(), lpCharType);
}

UINT GetPrivateProfileIntWrap(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        INT     nDefault,
        LPCWSTR lpFileName)
{
    CStrIn  strApp(lpAppName);
    CStrIn  strKey(lpKeyName);
    CStrIn  strFile(lpFileName);

    return GetPrivateProfileIntA(strApp, strKey, nDefault, strFile);
}

UINT GetProfileIntWrap(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        INT     nDefault)
{
    CStrIn  strApp(lpAppName);
    CStrIn  strKey(lpKeyName);
    
    return GetProfileIntA(strApp, strKey, nDefault);
}

DWORD GetProfileStringWrap(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpDefault, 
        LPWSTR  lpBuffer, 
        DWORD   dwBuffersize)
{
    CStrIn  strApp(lpAppName);
    CStrIn  strKey(lpKeyName);
    CStrIn  strDefault(lpDefault);
    CStrOut strBuffer(lpBuffer, dwBuffersize);
    
    GetProfileStringA(strApp, strKey, strDefault, strBuffer, dwBuffersize);
    return strBuffer.ConvertIncludingNul();
}



HANDLE GetPropWrap(HWND hWnd, LPCWSTR lpString)
{
    CStrIn  str(lpString);

    return GetPropA(hWnd, str);
}

UINT GetTempFileNameWrap(
        LPCWSTR lpPathName,
        LPCWSTR lpPrefixString,
        UINT    uUnique,
        LPWSTR  lpTempFileName)
{
    CStrIn  strPath(lpPathName);
    CStrIn  strPrefix(lpPrefixString);
    CStrOut strFileName(lpTempFileName, MAX_PATH);

    return GetTempFileNameA(strPath, strPrefix, uUnique, strFileName);
}

DWORD GetTempPathWrap(DWORD nBufferLength, LPWSTR lpBuffer)
{
    CStrOut str(lpBuffer, nBufferLength);

    GetTempPathA(str.BufSize(), str);
    return str.ConvertExcludingNul();
}

#ifndef FONT_LINK
BOOL GetTextExtentPointWrap(
        HDC     hdc,
        LPCWSTR pwsz,
        int     cb,
        LPSIZE  pSize)
{
    CStrIn str(pwsz,cb);

    return GetTextExtentPointA(hdc, str, str.strlen(), pSize);
}

BOOL GetTextExtentPoint32Wrap(
        HDC     hdc,
        LPCWSTR pwsz,
        int     cb,
        LPSIZE  pSize)
{
    CStrIn str(pwsz,cb);

    return GetTextExtentPoint32A(hdc, str, str.strlen(), pSize);
}
#endif

int GetTextFaceWrap(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName)
{
    CStrOut str(lpFaceName, cch);

    GetTextFaceA(hdc, str.BufSize(), str);
    return str.ConvertIncludingNul();
}

BOOL GetTextMetricsWrap(HDC hdc, LPTEXTMETRICW lptm)
{
   BOOL         ret;
   TEXTMETRICA  tm;

    ret = GetTextMetricsA(hdc, &tm);

    if (ret)
    {
        lptm->tmHeight              = tm.tmHeight;
        lptm->tmAscent              = tm.tmAscent;
        lptm->tmDescent             = tm.tmDescent;
        lptm->tmInternalLeading     = tm.tmInternalLeading;
        lptm->tmExternalLeading     = tm.tmExternalLeading;
        lptm->tmAveCharWidth        = tm.tmAveCharWidth;
        lptm->tmMaxCharWidth        = tm.tmMaxCharWidth;
        lptm->tmWeight              = tm.tmWeight;
        lptm->tmOverhang            = tm.tmOverhang;
        lptm->tmDigitizedAspectX    = tm.tmDigitizedAspectX;
        lptm->tmDigitizedAspectY    = tm.tmDigitizedAspectY;
        lptm->tmItalic              = tm.tmItalic;
        lptm->tmUnderlined          = tm.tmUnderlined;
        lptm->tmStruckOut           = tm.tmStruckOut;
        lptm->tmPitchAndFamily      = tm.tmPitchAndFamily;
        lptm->tmCharSet             = tm.tmCharSet;

        UnicodeFromMbcs(&lptm->tmFirstChar, 1, (LPSTR) &tm.tmFirstChar, 1);
        UnicodeFromMbcs(&lptm->tmLastChar, 1, (LPSTR) &tm.tmLastChar, 1);
        UnicodeFromMbcs(&lptm->tmDefaultChar, 1, (LPSTR) &tm.tmDefaultChar, 1);
        UnicodeFromMbcs(&lptm->tmBreakChar, 1, (LPSTR) &tm.tmBreakChar, 1);
    }

    return ret;
}

int GetTimeFormatWrap(
        LCID Locale,
        DWORD dwFlags,
        CONST SYSTEMTIME *lpTime,
        LPCWSTR lpFormat,
        LPWSTR lpTimeStr,
        int cchTime)
{
    CStrIn strFormat(lpFormat);
    CStrOut str(lpTimeStr, cchTime);

    ASSERT(cchTime != 0);

    GetTimeFormatA(Locale, dwFlags, lpTime, strFormat, str, str.BufSize());
    return str.ConvertIncludingNul();
}

LONG GetWindowLongWrap(HWND hWnd, int nIndex)
{
    return GetWindowLongA(hWnd, nIndex);
}

int GetWindowTextWrap(HWND hWnd, LPWSTR lpString, int nMaxCount)
{
    CStrOut str(lpString, nMaxCount);

    GetWindowTextA(hWnd, str, str.BufSize());
    return str.ConvertExcludingNul();
}

int GetWindowTextLengthWrap(HWND hWnd)
{
    WCHAR wstr[MAX_PATH];

    return GetWindowTextWrap(hWnd, wstr, ARRAYSIZE(wstr));
}

UINT GetWindowsDirectoryWrap(LPWSTR lpWinPath, UINT cch)
{
    CStrOut str(lpWinPath, cch);

    GetWindowsDirectoryA(str, str.BufSize());

    return str.ConvertExcludingNul();
}

ATOM GlobalAddAtomWrap(LPCWSTR lpString)
{
    CStrIn str(lpString);
 
    return GlobalAddAtomA(str);
}

BOOL GrayStringWrap(
        HDC hDC,
        HBRUSH hBrush,
        GRAYSTRINGPROC lpOutputFunc,
        LPARAM lpData,
        int nCount,
        int x,
        int y,
        int nWidth,
        int nHeight)
{
    CStrIn str((LPWSTR)lpData);
    
    return GrayStringA(hDC, hBrush, lpOutputFunc, (LPARAM)(LPCSTR)str, str.strlen(), x, y, nWidth, nHeight);    
}

LONG ImmGetCompositionStringWrap(HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen)
{
    int cb = 0;

    if ((dwIndex & GCS_COMPSTR) || (dwIndex & GCS_RESULTSTR))
    {
        if (dwBufLen)
        {
            CStrOut str((LPWSTR)lpBuf, dwBufLen/sizeof(WCHAR) + 1);

            cb = ImmGetCompositionStringA(hIMC, dwIndex, str, str.BufSize());
            *(WCHAR*)((LPSTR)str + cb) = L'\0';
            return str.ConvertExcludingNul() * sizeof(WCHAR);
        }
        else
        {
            LPWSTR lpStr;

            cb = ImmGetCompositionStringA(hIMC, dwIndex, lpBuf, dwBufLen);
            lpStr = (LPWSTR)LocalAlloc(LPTR, (cb + 1) * sizeof(WCHAR));
            if (lpStr)
            {
                CStrOut str(lpStr, cb + 1);

                cb = ImmGetCompositionStringA(hIMC, dwIndex, str, str.BufSize());
                *(WCHAR*)((LPSTR)str + cb) = L'\0';
                cb = str.ConvertExcludingNul() * sizeof(WCHAR);
                LocalFree(lpStr);
                return cb;
            }
        }
    }
    else if (dwIndex & GCS_COMPATTR)
    {
        if (dwBufLen)
        {
            LPSTR lpStr, lpAttr;
            UINT i = 0;
    
            lpStr = (LPSTR)LocalAlloc(LPTR, dwBufLen);
            if (lpStr)
            {
                lpAttr = (LPSTR)LocalAlloc(LPTR, dwBufLen);
                if (lpAttr)
                {
                    LPSTR lpNext = lpStr;

                    cb = ImmGetCompositionStringA(hIMC, GCS_COMPSTR, lpStr, dwBufLen);
                    ImmGetCompositionStringA(hIMC, GCS_COMPATTR, lpAttr, dwBufLen);

                    for (i = 0; (lpNext - lpStr < cb) && (i < dwBufLen); i++)
                    {
                        ((LPSTR)lpBuf)[i] = lpAttr[lpNext - lpStr];
                        lpNext = CharNextA(lpNext);
                    }
                    LocalFree(lpAttr);
                }
                LocalFree(lpStr);
            }
            return i;
        }
    }
    return ImmGetCompositionStringA(hIMC, dwIndex, lpBuf, dwBufLen);
}

LONG ImmSetCompositionStringWrap(HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen)
{
    if (dwIndex & SCS_SETSTR)
    {
        CStrIn str((LPWSTR)lpComp);

        ASSERT(!lpRead);

        return ImmSetCompositionStringA(hIMC, dwIndex, str, str.strlen(), lpRead, dwReadLen);
    }
    return ImmSetCompositionStringA(hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen);
}

BOOL InsertMenuWrap(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT    uIDNewItem,
        LPCWSTR lpNewItem)
{
    CStrIn  str(lpNewItem);

    return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, str);
}

BOOL IsDialogMessageWrap(HWND hWndDlg, LPMSG lpMsg)
{
    return IsDialogMessageA(hWndDlg, lpMsg);
}

HACCEL LoadAcceleratorsWrap(HINSTANCE hInstance, LPCWSTR lpTableName)
{
    CStrIn str(lpTableName);

    return LoadAcceleratorsA(hInstance, (LPCSTR) str);
}

HBITMAP LoadBitmapWrap(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
    CStrIn str(lpBitmapName);

    return LoadBitmapA(hInstance, str);
}

HCURSOR LoadCursorWrap(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
    CStrIn str(lpCursorName);

    return LoadCursorA(hInstance, (LPCSTR) str);
}

HICON LoadIconWrap(HINSTANCE hInstance, LPCWSTR lpIconName)
{
    CStrIn str(lpIconName);

    return LoadIconA(hInstance, str);
}

HANDLE LoadImageWrap(
        HINSTANCE hInstance,
        LPCWSTR lpName,
        UINT uType,
        int cxDesired,
        int cyDesired,
        UINT fuLoad)
{
    CStrIn str(lpName);

    return LoadImageA(
            hInstance,
            str,
            uType,
            cxDesired,
            cyDesired,
            fuLoad);
}

HINSTANCE LoadLibraryWrap(LPCWSTR lpLibFileName)
{
    CStrIn  str(lpLibFileName);

    return LoadLibraryA(str);
}

HINSTANCE LoadLibraryExWrap(
        LPCWSTR lpLibFileName,
        HANDLE  hFile,
        DWORD   dwFlags)
{
    CStrIn  str(lpLibFileName);

    return LoadLibraryExA(str, hFile, dwFlags);
}

HMENU LoadMenuWrap(HINSTANCE hInstance, LPCWSTR lpMenuName)
{
    ASSERT(HIWORD64(lpMenuName) == 0);

    return LoadMenuA(hInstance, (LPCSTR) lpMenuName);
}

int LoadStringWrap(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax)
{
    //
    //  Do it manually.  The old code used to call LoadStringA and then
    //  convert it up to unicode, which is bad since resources are
    //  physically already Unicode!  Just copy it out directly.
    //

    if (nBufferMax <= 0) return 0;                  // sanity check

    PWCHAR pwch;

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    HRSRC hrsrc;
    int cwch = 0;

    hrsrc = FindResourceA(hInstance, (LPSTR)(LONG_PTR)(1 + uID / 16), (LPSTR)RT_STRING);
    if (hrsrc) {
        pwch = (PWCHAR)LoadResource(hInstance, hrsrc);
        if (pwch) {
            /*
             *  Now skip over the strings in the resource until we
             *  hit the one we want.  Each entry is a counted string,
             *  just like Pascal.
             */
            for (uID %= 16; uID; uID--) {
                pwch += *pwch + 1;
            }
            cwch = min(*pwch, nBufferMax - 1);
            memcpy(lpBuffer, pwch+1, cwch * sizeof(WCHAR)); /* Copy the goo */
        }
    }
    lpBuffer[cwch] = L'\0';                 /* Terminate the string */
    return cwch;
}

UINT MapVirtualKeyWrap(UINT uCode, UINT uMapType)
{
    return MapVirtualKeyA(uCode, uMapType);
}

//----------------------------------------------------------------------
//
// function:    TransformCharNoOp1( WCHAR **ppch )
//
// purpose:     Stand-in for TransformCharWidth.  Used by the function
//              CompareStringString.
//
// returns:     Character at *ppch.  The value *ppch is incremented.
//
//----------------------------------------------------------------------

static WCHAR TransformCharNoOp1( LPCWSTR *ppch, int )
{
    WCHAR ch = **ppch;

    (*ppch)++;

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformCharWidth( WCHAR **ppch, cchRemaining )
//
// purpose:     Converts halfwidth characters to fullwidth characters.
//              Also combines voiced (dakuon) and semi-voiced (handakuon)
//              characters.  *pch is advanced by one, unless there is a
//              (semi)voiced character, in which case it is advanced by
//              two characters.
//
//              Note that unlike the full widechar version, we do not
//              combine other characters, notably the combining Hiragana
//              characters (U+3099 and U+309A.)  This is to keep the
//              tables from getting unnecessarily large.
//
//              cchRemaining is passed so as to not include the voiced
//              marks if it's passed the end of the specified buffer.
//
// returns:     Full width character. *pch is incremented.
//
//----------------------------------------------------------------------

static WCHAR TransformCharWidth( LPCWSTR *ppch, int cchRemaining )
{
    WCHAR ch = **ppch;

    (*ppch)++;

    if (ch == 0x0020)
    {
        ch = 0x3000;
    }
    else if (ch == 0x005c)
    {
        // REVERSE SOLIDUS (aka BACKSLASH) maps to itself
    }
    else if (InRange(ch, 0x0021, 0x07e))
    {
        ch += 65248;
    }
    else if (InRange(ch, 0x00a2, 0x00af))
    {
        static const WCHAR achFull[] =
        {
            0xffe0, 0xffe1, 0x00a4, 0xffe5, 0xffe4, 0x00a7, 0x00a8, // 0xa2-0xa8
            0x00a9, 0x00aa, 0x00ab, 0xffe2, 0x00ad, 0x00ae, 0xffe3  // 0xa9-0xaf
        };

        ch = achFull[ch - 0x00a2];
    }
    else if (ch == 0x20a9) // WON SIGN
    {
        ch = 0xffe6;
    }
    else if (InRange(ch, 0xff61, 0xffdc))
    {
        WCHAR chNext = (cchRemaining > 1) ? **ppch : 0;

        if (chNext == 0xff9e && InRange(ch, 0xff73, 0xff8e))
        {
            if (cchRemaining != 1)
            {
                static const WCHAR achFull[] =
                {
/* 0xff73-0xff79 */  0xb0f4, 0x30a8, 0x30aa, 0xb0ac, 0xb0ae, 0xb0b0, 0xb0b2,                  
/* 0xff7a-0xff80 */  0xb0b4, 0xb0b6, 0xb0b8, 0xb0ba, 0xb0bc, 0xb0be, 0xb0c0,                  
/* 0xff81-0xff87 */  0xb0c2, 0xb0c5, 0xb0c7, 0xb0c9, 0x30ca, 0x30cb, 0x30cc,                  
/* 0xff88-0xff8e */  0x30cd, 0x30ce, 0xb0d0, 0xb0d3, 0xb0d6, 0xb0d9, 0xb0dc                  
                };

                // HALFWIDTH KATAKANA VOICED SOUND MARK

                WCHAR chTemp = achFull[ch - 0xff73];

                // Some in the range absorb the sound mark.
                // These are indicated by the set high-bit.

                ch = chTemp & 0x7fff;

                if (chTemp & 0x8000)
                {
                    (*ppch)++;
                }
            }
        }
        else if (chNext == 0xff9f && InRange(ch, 0xff8a, 0xff8e))
        {
            // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK

            ch = 0x30d1 + (ch - 0xff8a) * 3;
            (*ppch)++;
        }
        else
        {
            static const WCHAR achMapFullFFxx[] =
            {
                0x3002, 0x300c, 0x300d, 0x3001, 0x30fb, 0x30f2, 0x30a1,  // 0xff61-0xff67
                0x30a3, 0x30a5, 0x30a7, 0x30a9, 0x30e3, 0x30e5, 0x30e7,  // 0xff68-0xff6e
                0x30c3, 0x30fc, 0x30a2, 0x30a4, 0x30a6, 0x30a8, 0x30aa,  // 0xff6f-0xff75
                0x30ab, 0x30ad, 0x30af, 0x30b1, 0x30b3, 0x30b5, 0x30b7,  // 0xff76-0xff7c
                0x30b9, 0x30bb, 0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6,  // 0xff7d-0xff83
                0x30c8, 0x30ca, 0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf,  // 0xff84-0xff8a
                0x30d2, 0x30d5, 0x30d8, 0x30db, 0x30de, 0x30df, 0x30e0,  // 0xff8b-0xff91
                0x30e1, 0x30e2, 0x30e4, 0x30e6, 0x30e8, 0x30e9, 0x30ea,  // 0xff92-0xff98
                0x30eb, 0x30ec, 0x30ed, 0x30ef, 0x30f3, 0x309b, 0x309c,  // 0xff99-0xff9f
                0x3164, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136,  // 0xffa0-0xffa6
                0x3137, 0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d,  // 0xffa7-0xffad
                0x313e, 0x313f, 0x3140, 0x3141, 0x3142, 0x3143, 0x3144,  // 0xffae-0xffb4
                0x3145, 0x3146, 0x3147, 0x3148, 0x3149, 0x314a, 0x314b,  // 0xffb5-0xffbb
                0x314c, 0x314d, 0x314e, 0xffbf, 0xffc0, 0xffc1, 0x314f,  // 0xffbc-0xffc2
                0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0xffc8, 0xffc9,  // 0xffc3-0xffc9
                0x3155, 0x3156, 0x3157, 0x3158, 0x3159, 0x315a, 0xffd0,  // 0xffca-0xffd0
                0xffd1, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f, 0x3160,  // 0xffd1-0xffd7
                0xffd8, 0xffd9, 0x3161, 0x3162, 0x3163                   // 0xffd8-0xffac
            };

            ch = achMapFullFFxx[ch - 0xff61];
        }
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharNoOp2( WCHAR ch )
//
// purpose:     Stand-in for CharLowerBuffWrap.  Used by the function
//              CompareStringString.
//
// returns:     Original character
//
//----------------------------------------------------------------------

static WCHAR TransformCharNoOp2( WCHAR ch )
{
    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharKana( WCHAR ch )
//
// purpose:     Converts Hiragana characters to Katakana characters
//
// returns:     Original character if not Hiragana,
//              Katanaka character if Hiragana
//
//----------------------------------------------------------------------

static WCHAR TransformCharKana( WCHAR ch )
{
    if (((ch & 0xff00) == 0x3000) &&
        (InRange(ch, 0x3041, 0x3094) || InRange(ch, 0x309d, 0x309e)))
    {
        ch += 0x060;
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    TransformCharNoOp3( LPWSTR pch, DWORD cch )
//
// purpose:     Stand-in for CharLowerBuffWrap.  Used by the function
//              CompareStringString.
//
// returns:     Character count (cch).
//
//----------------------------------------------------------------------

static DWORD TransformCharNoOp3( LPWSTR, DWORD cch )
{
    return cch;
}

//----------------------------------------------------------------------
//
// function:    TransformaCharFinal( WCHAR ch )
//
// purpose:     Converts "final" forms to regular forms
//
// returns:     Original character if not Hiragana,
//              Katanaka character if Hiragana
//
//----------------------------------------------------------------------

// BUGBUG (cthrash) We do not fold Presentation Forms (Alphabetic or Arabic)

static WCHAR TransformCharFinal( WCHAR ch )
{
    WCHAR chRet = ch;
    
    if (ch >= 0x3c2)                    // short-circuit ASCII +
    {
        switch (ch)
        {
            case 0x03c2:                // GREEK SMALL LETTER FINAL SIGMA
            case 0x05da:                // HEBREW LETTER FINAL KAF
            case 0x05dd:                // HEBREW LETTER FINAL MEM
            case 0x05df:                // HEBREW LETTER FINAL NUN
            case 0x05e3:                // HEBREW LETTER FINAL PE
            case 0x05e5:                // HEBREW LETTER FINAL TSADI
            case 0xfb26:                // HEBREW LETTER WIDE FINAL MEM
            case 0xfb3a:                // HEBREW LETTER FINAL KAF WITH DAGESH
            case 0xfb43:                // HEBREW LETTER FINAL PE WITH DAGESH
                chRet++;
                break;
        }
    }

    return ch;
}

//----------------------------------------------------------------------
//
// function:    CompareStringString( ... )
//
// purpose:     Helper for CompareStringWrap.
//
//              We handle the string comparsion for CompareStringWrap.
//              We can convert each character to (1) fullwidth,
//              (2) Katakana, and (3) lowercase, as necessary.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

static int CompareStringString(
    DWORD   dwFlags,
    LPCWSTR lpA,
    int     cchA,
    LPCWSTR lpB,
    int     cchB )
{
    int nRet = 0;
    WCHAR wchIgnoreNulA = cchA == -1 ? 0 : -1;
    WCHAR wchIgnoreNulB = cchB == -1 ? 0 : -1;
    WCHAR (*pfnTransformWidth)(LPCWSTR *, int);
    WCHAR (*pfnTransformKana)(WCHAR);
    DWORD (*pfnTransformLower)(LPWSTR, DWORD);
    WCHAR (*pfnTransformFinal)(WCHAR);
    

    pfnTransformWidth = (dwFlags & NORM_IGNOREWIDTH)
                        ? TransformCharWidth : TransformCharNoOp1;
    pfnTransformKana  = (dwFlags & NORM_IGNOREKANATYPE)
                        ? TransformCharKana : TransformCharNoOp2;
    pfnTransformLower = (dwFlags & NORM_IGNORECASE)
                        ? CharLowerBuffWrap : TransformCharNoOp3;
    pfnTransformFinal = (dwFlags & NORM_IGNORECASE)
                        ? TransformCharFinal : TransformCharNoOp2;

    while (   !nRet
           && cchA
           && cchB
           && (*lpA | wchIgnoreNulA)
           && (*lpB | wchIgnoreNulB) )
    {
        WCHAR chA, chB;
        LPCWSTR lpAOld = lpA;
        LPCWSTR lpBOld = lpB;

        chA = (*pfnTransformWidth)(&lpA, cchA);
        chA = (*pfnTransformKana)(chA);
        (*pfnTransformLower)(&chA, 1);
        chA = (*pfnTransformFinal)(chA);

        chB = (*pfnTransformWidth)(&lpB, cchB);
        chB = (*pfnTransformKana)(chB);
        (*pfnTransformLower)(&chB, 1);
        chB = (*pfnTransformFinal)(chB);

        nRet = (int)chA - (int)chB;
        cchA -= (int) (lpA-lpAOld);
        cchB -= (int) (lpB-lpBOld);
    }

    if (!nRet)
    {
        nRet = cchA - cchB;
    }

    if (nRet)
    {
        nRet = nRet > 0 ? 1 : -1;
    }

    return nRet + 2;
}

//----------------------------------------------------------------------
//
// function:    CompareStringWord( ... )
//
// purpose:     Helper for CompareStringWrap.
//
//              We handle the word comparsion for CompareStringWrap.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

static int CompareStringWord(
    LCID    lcid,
    DWORD   dwFlags,
    LPCWSTR lpA,
    int     cchA,
    LPCWSTR lpB,
    int     cchB )
{
    // BUGBUG (cthrash) We won't properly support word compare for the
    // time being.  Do the same old CP_ACP trick, which should cover
    // enough cases.

    // fail if either string is NULL, as it causes assert on debug windows
    if (!lpA || !lpB)
        return 0;

    CStrIn strA(lpA, cchA);
    CStrIn strB(lpB, cchB);

    cchA = strA.strlen();
    cchB = strB.strlen();

    return CompareStringA(lcid, dwFlags, strA, cchA, strB, cchB);
}

//----------------------------------------------------------------------
//
// function:    CompareStringWrap( ... )
//
// purpose:     Unicode wrapper of CompareString for Win95.
//
//              Note not all bits in dwFlags are honored; specifically,
//              since we don't do a true widechar word compare, we
//              won't properly handle NORM_IGNORENONSPACE or
//              NORM_IGNORESYMBOLS for arbitrary widechar strings.
//
// returns:     1 - string A is less in lexical value as string B
//              2 - string B is equal in lexical value as string B
//              3 - string B is greater in lexical value as string B
//
//----------------------------------------------------------------------

LWSTDAPI_(int) CompareStringAltW(
    LCID    lcid,
    DWORD   dwFlags,
    LPCWSTR lpA,
    int     cchA,
    LPCWSTR lpB,
    int     cchB )
{
    int nRet;

    if (dwFlags & SORT_STRINGSORT)
    {
        nRet = CompareStringString(dwFlags, lpA, cchA, lpB, cchB);
    }
    else
    {
        nRet = CompareStringWord(lcid, dwFlags, lpA, cchA, lpB, cchB);
    }

    return nRet;
}

int CompareStringWrap(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR lpString1,
    int      cchCount1,
    LPCWSTR lpString2,
    int      cchCount2)
{
    // fail if either string is NULL, as it causes assert on debug windows
    if (!lpString1 || !lpString2)
        return 0;
    
    CStrIn      strString1(lpString1, cchCount1);
    CStrIn      strString2(lpString2, cchCount2);

    cchCount1 = strString1.strlen();

    cchCount2 = strString2.strlen();


    return CompareStringA(Locale, dwCmpFlags,
                          strString1,cchCount1,
                          strString2,cchCount2);
}

BOOL MessageBoxIndirectWrap(MSGBOXPARAMS *pmbp)
{
    CStrIn        strText(pmbp->lpszText);
    CStrIn        strCaption(pmbp->lpszCaption);
    MSGBOXPARAMSA mbp;

    memcpy(&mbp, pmbp, sizeof(mbp));
    mbp.lpszText = strText;
    mbp.lpszCaption = strCaption;
    ASSERT(HIWORD64(mbp.lpszIcon) == 0);

    return MessageBoxIndirectA(&mbp);
}

DWORD GetCharacterPlacementWrap(
    HDC hdc,            // handle to device context
    LPCTSTR lpString,   // pointer to string
    int nCount,         // number of characters in string
    int nMaxExtent,     // maximum extent for displayed string
    LPGCP_RESULTS lpResults, // pointer to buffer for placement result
    DWORD dwFlags       // placement flags
   )
{
    CStrIn strText(lpString);
    DWORD dwRet;

    // Leave for someone else.
    ASSERT (lpResults->lpOutString == NULL);
    ASSERT (lpResults->lpClass == NULL);

    dwRet = GetCharacterPlacementA (hdc, strText, nCount, nMaxExtent,
                                    (LPGCP_RESULTSA)lpResults,
                                    dwFlags);
    return dwRet;
}

#ifndef FONT_LINK
BOOL GetCharWidthWrap (
     HDC hdc,
     UINT iFirstChar,
     UINT iLastChar,
     LPINT lpBuffer)
{
    // Note that we expect to do only one character at a time for anything but
    // ISO Latin 1.
    if (iFirstChar > 255)
    {
        UINT mbChar=0;
        WCHAR ch;

        // Convert string
        ch = (WCHAR)iFirstChar;
        WideCharToMultiByte(CP_ACP, 0, &ch, 1,
                            (char *)&mbChar, 2, NULL, NULL);
    }

    return (GetCharWidthA (hdc, iFirstChar, iLastChar, lpBuffer));
}
#endif

BOOL ModifyMenuWrap(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT    uIDNewItem,
        LPCWSTR lpNewItem)
{
    ASSERT(!(uFlags & MF_BITMAP) && !(uFlags & MF_OWNERDRAW));

    CStrIn  str(lpNewItem);

    return ModifyMenuA(hMenu, uPosition, uFlags, uIDNewItem, str);
}

BOOL CopyFileWrap(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
{
    CStrIn  strOld(lpExistingFileName);
    CStrIn  strNew(lpNewFileName);

    return CopyFileA(strOld, strNew, bFailIfExists);
}

BOOL MoveFileWrap(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
{
    CStrIn  strOld(lpExistingFileName);
    CStrIn  strNew(lpNewFileName);

    return MoveFileA(strOld, strNew);
}

BOOL OemToCharWrap(LPCSTR lpszSrc, LPWSTR lpszDst)
{
    CStrOut strDst(lpszDst, lstrlenA(lpszSrc));

    return OemToCharA(lpszSrc, strDst);
}

VOID OutputDebugStringWrap(LPCWSTR lpOutputString)
{
    CStrIn  str(lpOutputString);

    OutputDebugStringA(str);
}

BOOL PeekMessageWrap(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg)
{
    return PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

BOOL PostMessageWrap(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
    return PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL PostThreadMessageWrap(
        DWORD idThread,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam)
{
    return PostThreadMessageA(idThread, Msg, wParam, lParam);
}

LONG RegCreateKeyWrap(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
{
    CStrIn  str(lpSubKey);

    return RegCreateKeyA(hKey, str, phkResult);
}

LONG RegCreateKeyExWrap(HKEY hKey, LPCTSTR lpSubKey, DWORD Reserved, LPTSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
{
    CStrIn strSubKey(lpSubKey);
    CStrIn strClass(lpClass);

    return RegCreateKeyExA(hKey, strSubKey, Reserved, strClass, dwOptions, samDesired, lpSecurityAttributes,  phkResult, lpdwDisposition);
}

LONG RegDeleteKeyWrap(HKEY hKey, LPCWSTR pwszSubKey)
{
    CStrIn  str(pwszSubKey);

    return RegDeleteKeyA(hKey, str);
}

LONG RegEnumKeyWrap(
        HKEY    hKey,
        DWORD   dwIndex,
        LPWSTR  lpName,
        DWORD   cbName)
{
    CStrOut str(lpName, cbName);

    return RegEnumKeyA(hKey, dwIndex, str, str.BufSize());
}

LONG RegEnumKeyExWrap(
        HKEY        hKey,
        DWORD       dwIndex,
        LPWSTR      lpName,
        LPDWORD     lpcbName,
        LPDWORD     lpReserved,
        LPWSTR      lpClass,
        LPDWORD     lpcbClass,
        PFILETIME   lpftLastWriteTime)
{
    long    ret;
    DWORD   dwClass = 0;

    if (!lpcbClass)
    {
        lpcbClass = &dwClass;
    }

    CStrOut strName(lpName, *lpcbName);
    CStrOut strClass(lpClass, *lpcbClass);

    ret = RegEnumKeyExA(
            hKey,
            dwIndex,
            strName,
            lpcbName,
            lpReserved,
            strClass,
            lpcbClass,
            lpftLastWriteTime);

    *lpcbName = strName.ConvertExcludingNul();
    *lpcbClass = strClass.ConvertExcludingNul();

    return ret;
}

LONG RegOpenKeyWrap(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
    CStrIn  str(pwszSubKey);

    return RegOpenKeyA(hKey, str, phkResult);
}

LONG RegOpenKeyExWrap(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   ulOptions,
        REGSAM  samDesired,
        PHKEY   phkResult)
{
    CStrIn  str(lpSubKey);

    return RegOpenKeyExA(hKey, str, ulOptions, samDesired, phkResult);
}

LONG RegQueryInfoKeyWrap(
        HKEY hKey,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime)
{
    CStrIn  str(lpClass);

    return RegQueryInfoKeyA(
                hKey,
                str,
                lpcbClass,
                lpReserved,
                lpcSubKeys,
                lpcbMaxSubKeyLen,
                lpcbMaxClassLen,
                lpcValues,
                lpcbMaxValueNameLen,
                lpcbMaxValueLen,
                lpcbSecurityDescriptor,
                lpftLastWriteTime);
}

LONG RegQueryValueWrap(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        LPWSTR  pwszValue,
        PLONG   lpcbValue)
{
    long    ret;
    long    cb;
    CStrIn  strKey(pwszSubKey);
    CStrOut strValue(pwszValue, (*lpcbValue) / sizeof(WCHAR));

    cb = strValue.BufSize();
    ret = RegQueryValueA(hKey, strKey, strValue, &cb);
    if (ret != ERROR_SUCCESS)
        goto Cleanup;

    if (strValue)
    {
        cb = strValue.ConvertIncludingNul();
    }

    *lpcbValue = cb * sizeof(WCHAR);

Cleanup:
    return ret;
}

LONG RegQueryValueExWrap(
        HKEY    hKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData)
{
    LONG    ret;
    CStrIn  strValueName(lpValueName);
    DWORD   dwTempType;
    DWORD   cb;

    //
    // Determine the type of buffer needed
    //

    ret = RegQueryValueExA(hKey, strValueName, lpReserved, &dwTempType, NULL, &cb);
    if (ret != ERROR_SUCCESS)
        goto Cleanup;

    ASSERT(dwTempType != REG_MULTI_SZ);

    switch (dwTempType)
    {
    case REG_EXPAND_SZ:
    case REG_SZ:
        {
            CStrOut strData((LPWSTR) lpData, (*lpcbData) / sizeof(WCHAR));

            cb = strData.BufSize();
            ret = RegQueryValueExA(hKey, strValueName, lpReserved, lpType, (LPBYTE)(LPSTR)strData, &cb);
            if (ret != ERROR_SUCCESS)
                break;

            if (strData)
            {
                cb = strData.ConvertIncludingNul();
            }

            *lpcbData = cb * sizeof(WCHAR);
            break;
        }

    default:
        {
            ret = RegQueryValueExA(
                    hKey,
                    strValueName,
                    lpReserved,
                    lpType,
                    lpData,
                    lpcbData);

            break;
        }
    }

Cleanup:
    return ret;
}

LONG RegSetValueWrap(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   dwType,
        LPCWSTR lpData,
        DWORD   cbData)
{
    CStrIn  strKey(lpSubKey);
    CStrIn  strValue(lpData);

    return RegSetValueA(hKey, strKey, dwType, strValue, cbData);
}

LONG RegSetValueExWrap(
        HKEY        hKey,
        LPCWSTR     lpValueName,
        DWORD       Reserved,
        DWORD       dwType,
        CONST BYTE* lpData,
        DWORD       cbData)
{
    ASSERT(dwType != REG_MULTI_SZ);

    CStrIn      strKey(lpValueName);
    CStrIn      strSZ((dwType == REG_SZ || dwType == REG_EXPAND_SZ) ? (LPCWSTR) lpData : NULL);

    if (strSZ)
    {
        lpData = (LPBYTE) (LPSTR) strSZ;
        cbData = strSZ.strlen() + 1;
    }

    return RegSetValueExA(
            hKey,
            strKey,
            Reserved,
            dwType,
            lpData,
            cbData);
}

ATOM RegisterClassWrap(CONST WNDCLASSW * lpWndClass)
{
    WNDCLASSA   wc;
    CStrIn      strMenuName(lpWndClass->lpszMenuName);
    CStrIn      strClassName(lpWndClass->lpszClassName);

    ASSERT(sizeof(wc) == sizeof(*lpWndClass));
    memcpy(&wc, lpWndClass, sizeof(wc));

    wc.lpszMenuName = strMenuName;
    wc.lpszClassName = strClassName;

    return RegisterClassA(&wc);
}

UINT RegisterClipboardFormatWrap(LPCWSTR lpString)
{
    CStrIn  str(lpString);

    return RegisterClipboardFormatA(str);
}

UINT RegisterWindowMessageWrap(LPCWSTR lpString)
{
    CStrIn  str(lpString);

    return RegisterWindowMessageA(str);
}

HANDLE RemovePropWrap(
        HWND    hWnd,
        LPCWSTR lpString)
{
    CStrIn  str(lpString);

    return RemovePropA(hWnd, str);
}

//  NOTE (SumitC) Instead of calling SendDlgItemMessageA below, I'm forwarding to
//       SendMessageWrap so as not to have to re-do the special-case processing.
LRESULT SendDlgItemMessageWrap(
        HWND    hDlg,
        int     nIDDlgItem,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
    HWND hWnd;

    hWnd = GetDlgItem(hDlg, nIDDlgItem);

    return SendMessageWrap(hWnd, Msg, wParam, lParam);
}

// AdjustECPosition
//
// Convert mulitbyte position to unicode number of character position in EDIT control
//
// iType:   ADJUST_TO_WCHAR_POS or ADJUST_TO_CHAR_POS
//
#define ADJUST_TO_WCHAR_POS     0
#define ADJUST_TO_CHAR_POS      1

int AdjustECPosition(char *psz, int iPos, int iType)
{
    char *pstr = psz;
    int iNewPos = iPos;

    if (ADJUST_TO_WCHAR_POS == iType)
    {
        iNewPos = 0;
        while (*pstr && (pstr - psz != iPos))
        {
            pstr = CharNextA(pstr);
            iNewPos++;
        }
    }
    else if (ADJUST_TO_CHAR_POS == iType)
    {
        while (*pstr && iPos--)
            pstr = CharNextA(pstr);
        iNewPos = (int) (pstr-psz);
    }
    return iNewPos;
}

//
//  Edit controls can get really huge, so the MAX_PATH buffer in
//  SendMessageWrap just doesn't cut it when push comes to shove.
//
//  Try to use the small buffer, and switch to an allocated buffer
//  only if the small buffer doesn't work.
//
//  Use the handy CConvertStr class as our basis.
//

class CStrA : public CConvertStr
{
public:
    CStrA(int cch);
    inline int bufsize() { return _cchLen; }

protected:
    int _cchLen;
};

CStrA::CStrA(int cch) : CConvertStr(CP_ACP)
{
    _cchLen = cch;

    if (cch <= ARRAYSIZE(_ach))
    {
        // It fits in our small buffer
        _pstr = _ach;
    }
    else
    {
        // Need to allocate a big buffer
        _pstr = new char[cch];
        if (!_pstr)
        {
            // On failure, use the small buffer after all.
            _pstr = _ach;
            _cchLen = ARRAYSIZE(_ach);
        }
    }
}

LRESULT SendEditMessageWrap(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
    WORD wStart, wEnd;
    DWORD dwPos;

    //
    //  EM_SETSEL is special - We can often handle it without having to
    //  get the client text, which is good since some clients
    //  return bad data.
    //
    //  If the start and end positions are both either 0 or -1, then we
    //  don't need to do adjustment since 0 is always 0 and -1 is always -1.
    //
    if (Msg == EM_SETSEL) {
        if ((wParam == 0 || (DWORD)wParam == 0xFFFFFFFF) &&
            (lParam == 0 || (DWORD)lParam == 0xFFFFFFFF))
        return SendMessageA(hWnd, Msg, wParam, lParam);
    }

    // Get the current window text, since we will be studying it
    CStrA sz(GetWindowTextLengthA(hWnd) + 1);
    GetWindowTextA(hWnd, sz, sz.bufsize());

    switch (Msg)
    {
    case EM_GETSEL:
        {
            DWORD_PTR dwPos;
            
            dwPos = SendMessageA(hWnd, Msg, wParam, lParam);
            wStart = (WORD)AdjustECPosition(sz, GET_X_LPARAM(dwPos), ADJUST_TO_WCHAR_POS);
            wEnd = (WORD)AdjustECPosition(sz, GET_Y_LPARAM(dwPos), ADJUST_TO_WCHAR_POS);
            return MAKELONG(wStart, wEnd);
        }

    case EM_SETSEL:
        wStart = (WORD)AdjustECPosition(sz, wParam, ADJUST_TO_CHAR_POS);
        wEnd = (WORD)AdjustECPosition(sz, lParam, ADJUST_TO_CHAR_POS);
        return SendMessageA(hWnd, Msg, wStart, wEnd);

    case EM_LINEINDEX:
        dwPos = SendMessageA(hWnd, Msg, wParam, lParam);
        return AdjustECPosition(sz, dwPos, ADJUST_TO_WCHAR_POS);

    case EM_LINELENGTH:
        wStart = (WORD)AdjustECPosition(sz, wParam, ADJUST_TO_CHAR_POS);
        dwPos = SendMessageA(hWnd, Msg, wStart, lParam);
        return AdjustECPosition(sz + wStart, dwPos, ADJUST_TO_WCHAR_POS);

    case EM_LINEFROMCHAR:
    case EM_POSFROMCHAR:
        wStart = (WORD)AdjustECPosition(sz, wParam, ADJUST_TO_CHAR_POS);
        return SendMessageA(hWnd, Msg, wStart, lParam);

    default:
        AssertMsg(FALSE, TEXT("error: unknown message leaked into SendEditMessageWrap"));
        return SendMessageA(hWnd, Msg, wParam, lParam);

    }
}


#ifndef UNIX
  #define SHLWAPI_SENDMESSAGEWRAPW_ORD      136
#else
  #define SHLWAPI_SENDMESSAGEWRAPW_ORD      "SendMessageWrapW"
#endif

typedef LRESULT (* PFNSENDMESSAGEWRAPW)(HWND, UINT, WPARAM, LPARAM);

LRESULT SendMessageWrap(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam)
{
    // For XCP PlugUI:
    //     1)If shlwapi is in memory, ask it to do the work, otherwise let it
    //          fall through to original comctl32 wrap implementation.
    //     2)This implementation only apply to LB for fixing #67837
    switch (Msg)
    {
        case LB_ADDSTRING:
        case LB_FINDSTRING:
        case LB_FINDSTRINGEXACT:
        case LB_INSERTSTRING:
        case LB_GETTEXT:
        case LB_GETTEXTLEN:
        case LB_SELECTSTRING:
        {
            extern HMODULE GetShlwapiHModule();
            PFNSENDMESSAGEWRAPW pfnSndMsgWrapW = NULL;
            HMODULE hShlwapi;

            hShlwapi = GetShlwapiHModule();
            if (hShlwapi)
                pfnSndMsgWrapW = (PFNSENDMESSAGEWRAPW)GetProcAddress(hShlwapi, (LPCSTR)SHLWAPI_SENDMESSAGEWRAPW_ORD);

            if (pfnSndMsgWrapW)
                return pfnSndMsgWrapW(hWnd, Msg, wParam, lParam);
            else
                break;   // fall through the regular comctl32's wrap
        }
    }

    // original comctl32's wrap implementation
    CHAR sz[MAX_PATH];  // BUGBUG: It's big enough current comctl32 usage until now ...

    switch (Msg)
    {
    case WM_GETTEXT:
    {
        CStrOut str((LPWSTR)lParam, (int) wParam);
        SendMessageA(hWnd, Msg, (WPARAM) str.BufSize(), (LPARAM) (LPSTR) str);
        return str.ConvertExcludingNul();
    }

    // The sz[] buffer is not large enough for these guys, so use a
    // separate helper function.
    case EM_GETSEL:
    case EM_SETSEL:
    case EM_LINEINDEX:
    case EM_LINELENGTH:
    case EM_LINEFROMCHAR:
    case EM_POSFROMCHAR:
        return SendEditMessageWrap(hWnd, Msg, wParam, lParam);

    // BUGBUG raymondc - This is wrong.  EM_GETLIMITTEXT returns the number
    // of characters, not bytes.  But the only place we use it is in our
    // IME composition code, and maybe they really meant to divide by two...

    case EM_GETLIMITTEXT:
        return SendMessageA(hWnd, Msg, wParam, lParam) / sizeof(WCHAR);

    case EM_GETLINE:
    {
        LRESULT nLen;

        CStrOut str((LPWSTR) lParam, (* (SHORT *) lParam) + 1);
        * (SHORT *) (LPSTR) str = * (SHORT *) lParam;
        nLen = SendMessageA(hWnd, Msg, (WPARAM) wParam, (LPARAM) (LPSTR) str);
        if(nLen > 0)
            ((LPSTR) str)[nLen] = '\0';

        return nLen;
    }

    // BUGBUG: Always assume lParam points structure, not string buffer
    case CB_INSERTSTRING:
    {
        return SendMessageA(hWnd, Msg, wParam, (LPARAM) lParam);
    }

    case WM_SETTEXT:
    case LB_ADDSTRING:
    case CB_ADDSTRING:
    case EM_REPLACESEL:
        ASSERT(wParam == 0 && "wParam should be 0 for these messages");
        // fall through
    case CB_SELECTSTRING:
    case CB_FINDSTRINGEXACT:
    case CB_FINDSTRING:
    case LB_INSERTSTRING:
    case LB_FINDSTRINGEXACT:
    {
        CStrIn  str((LPWSTR) lParam);
        return SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str);
    }

    case LB_GETTEXTLEN:
    case CB_GETLBTEXTLEN:
        ASSERT((LB_GETTEXTLEN - LB_GETTEXT) == (CB_GETLBTEXTLEN - CB_GETLBTEXT));
        lParam = (LPARAM)sz;    // use temp buffer
        Msg -= (LB_GETTEXTLEN - LB_GETTEXT);
        // fall through ...

    case LB_GETTEXT:
    case CB_GETLBTEXT:
    {
        CStrOut str((LPWSTR)lParam, 255);
        SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) str);
        return str.ConvertExcludingNul();
    }

    case EM_SETPASSWORDCHAR:
    {
        WPARAM  wp;

        ASSERT(HIWORD64(wParam) == 0);
        MbcsFromUnicode((LPSTR) &wp, sizeof(wp), (LPWSTR) &wParam);
        ASSERT(HIWORD64(wp) == 0);

        return SendMessageA(hWnd, Msg, wp, lParam);
    }

    default:
        return SendMessageA(hWnd, Msg, wParam, lParam);
    }
}


BOOL SendNotifyMessageWrap(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    // BUGBUG: Should we use SendMessageWarp like SendDlgItemMessageWrap above?
    return SendNotifyMessageA(hWnd, Msg, wParam, lParam);
}

BOOL SetCurrentDirectoryWrap(LPCWSTR lpszCurDir)
{
    CStrIn  str(lpszCurDir);

    return SetCurrentDirectoryA(str);
}

BOOL SetDlgItemTextWrap(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
{
    CStrIn  str(lpString);

    return SetDlgItemTextA(hDlg, nIDDlgItem, str);
}

BOOL SetMenuItemInfoWrap(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFOW lpmiiW)
{
    BOOL fRet;

    ASSERT( sizeof(MENUITEMINFOW) == sizeof(MENUITEMINFOA) &&
            FIELD_OFFSET(MENUITEMINFOW, dwTypeData) ==
            FIELD_OFFSET(MENUITEMINFOA, dwTypeData) );

    if ( (MIIM_TYPE & lpmiiW->fMask) &&
         0 == (lpmiiW->fType & (MFT_BITMAP | MFT_SEPARATOR)))
    {
        MENUITEMINFOA miiA;
        CStrIn str(lpmiiW->dwTypeData, lpmiiW->cch);

        memcpy( &miiA, lpmiiW, sizeof(MENUITEMINFOA) );
        miiA.dwTypeData = str;
        miiA.cch = str.strlen();
                
        fRet = SetMenuItemInfoA( hMenu, uItem, fByPosition, &miiA );
    }
    else
    {
        fRet = SetMenuItemInfoA( hMenu, uItem, fByPosition,
                                 (LPCMENUITEMINFOA)lpmiiW );
    }

    return fRet;
}

BOOL SetPropWrap(
    HWND    hWnd,
    LPCWSTR lpString,
    HANDLE  hData)
{
    CStrIn  str(lpString);

    return SetPropA(hWnd, str, hData);
}

LONG SetWindowLongWrap(HWND hWnd, int nIndex, LONG dwNewLong)
{
    return SetWindowLongA(hWnd, nIndex, dwNewLong);
}

HHOOK SetWindowsHookExWrap(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId)
{
    return SetWindowsHookExA(idHook, lpfn, hmod, dwThreadId);
}

BOOL SetWindowTextWrap(HWND hWnd, LPCWSTR lpString)
{
    CStrIn  str(lpString);

    return SetWindowTextA(hWnd, str);
}

BOOL SystemParametersInfoWrap(
        UINT    uiAction,
        UINT    uiParam,
        PVOID   pvParam,
        UINT    fWinIni)
{
    BOOL        ret;
    char        ach[LF_FACESIZE];

    if (uiAction == SPI_SETDESKWALLPAPER)
    {
        CStrIn str((LPCWSTR) pvParam);

        ret = SystemParametersInfoA(
                        uiAction,
                        uiParam,
                        str,
                        fWinIni);
    }
    else if (uiAction == SPI_GETNONCLIENTMETRICS)
    {
        NONCLIENTMETRICSA ncmA;
        NONCLIENTMETRICS *pncm = (NONCLIENTMETRICS *)pvParam;

        ASSERT(uiParam == sizeof(NONCLIENTMETRICS) && pncm->cbSize == sizeof(NONCLIENTMETRICS));

        ncmA.cbSize = sizeof(ncmA);
        ret = SystemParametersInfoA(
                        uiAction,
                        sizeof(ncmA),
                        &ncmA,
                        fWinIni);

        pncm->iBorderWidth = ncmA.iBorderWidth;
        pncm->iScrollWidth = ncmA.iScrollWidth;
        pncm->iScrollHeight = ncmA.iScrollHeight;
        pncm->iCaptionWidth = ncmA.iCaptionWidth;
        pncm->iCaptionHeight = ncmA.iCaptionHeight;
        pncm->iSmCaptionWidth = ncmA.iSmCaptionWidth;
        pncm->iSmCaptionHeight = ncmA.iSmCaptionHeight;
        pncm->iMenuWidth = ncmA.iMenuWidth;
        pncm->iMenuHeight = ncmA.iMenuHeight;

        memcpy(&pncm->lfCaptionFont, &ncmA.lfCaptionFont, FIELD_OFFSET(LOGFONTW, lfFaceName));
        UnicodeFromMbcs(pncm->lfCaptionFont.lfFaceName, ARRAYSIZE(pncm->lfCaptionFont.lfFaceName), ncmA.lfCaptionFont.lfFaceName);

        memcpy(&pncm->lfSmCaptionFont, &ncmA.lfSmCaptionFont, FIELD_OFFSET(LOGFONTW, lfFaceName));
        UnicodeFromMbcs(pncm->lfSmCaptionFont.lfFaceName, ARRAYSIZE(pncm->lfSmCaptionFont.lfFaceName), ncmA.lfSmCaptionFont.lfFaceName);

        memcpy(&pncm->lfMenuFont, &ncmA.lfMenuFont, FIELD_OFFSET(LOGFONTW, lfFaceName));
        UnicodeFromMbcs(pncm->lfMenuFont.lfFaceName, ARRAYSIZE(pncm->lfMenuFont.lfFaceName), ncmA.lfMenuFont.lfFaceName);

        memcpy(&pncm->lfStatusFont, &ncmA.lfStatusFont, FIELD_OFFSET(LOGFONTW, lfFaceName));
        UnicodeFromMbcs(pncm->lfStatusFont.lfFaceName, ARRAYSIZE(pncm->lfStatusFont.lfFaceName), ncmA.lfStatusFont.lfFaceName);

        memcpy(&pncm->lfMessageFont, &ncmA.lfMessageFont, FIELD_OFFSET(LOGFONTW, lfFaceName));
        UnicodeFromMbcs(pncm->lfMessageFont.lfFaceName, ARRAYSIZE(pncm->lfMessageFont.lfFaceName), ncmA.lfMessageFont.lfFaceName);
    }
    else
        ret = SystemParametersInfoA(
                        uiAction,
                        uiParam,
                        pvParam,
                        fWinIni);

    if ((uiAction == SPI_GETICONTITLELOGFONT) && ret)
    {
        strcpy(ach, ((LPLOGFONTA)pvParam)->lfFaceName);
        UnicodeFromMbcs(
                ((LPLOGFONTW)pvParam)->lfFaceName,
                ARRAYSIZE(((LPLOGFONTW)pvParam)->lfFaceName),
                ach);
    }

    return ret;
}

#ifndef FONT_LINK
BOOL TextOutWrap(HDC hdc, int x, int y, LPCWSTR lpStr, int cb)
{
    if (g_fMEEnabled && !g_bRunOnMemphis)
    {
        CStrIn str(lpStr);

        return TextOutA(hdc, x, y, str, str.strlen());
    }
    else
        return TextOutW(hdc, x, y, lpStr, cb);
}    
#endif

int TranslateAcceleratorWrap(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
{
    return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);
}

BOOL UnregisterClassWrap(LPCWSTR lpClassName, HINSTANCE hInstance)
{
    CStrIn  str(lpClassName);

    return UnregisterClassA(str, hInstance);
}

SHORT VkKeyScanWrap(WCHAR ch)
{
    CStrIn str(&ch, 1);

    return VkKeyScanA(*(char *)str);
}

BOOL WinHelpWrap(HWND hwnd, LPCWSTR szFile, UINT uCmd, DWORD dwData)
{
    CStrIn  str(szFile);

    return WinHelpA(hwnd, str, uCmd, dwData);
}


#define DBCS_CHARSIZE   (2)

//  N versions of wsprintf and wvsprintf which take an output buffer size to prevent overflow
//  bugs.  Taken from the NT wsprintf source code.

//  _MBToWCS and _WCSToMB are actually macros which call ntrtl functions in the NT version.
int _MBToWCS(LPCSTR pszIn, int cchIn, LPWSTR *ppwszOut)
{
    int cch = 0;
    int cbAlloc;

    if ((0 != cchIn) && (NULL != ppwszOut))
    {
        cchIn++;
        cbAlloc = cchIn * sizeof(WCHAR);

        *ppwszOut = (LPWSTR)LocalAlloc(LMEM_FIXED, cbAlloc);

        if (NULL != *ppwszOut)
        {
            cch = MultiByteToWideChar(CP_ACP, 0, pszIn, cchIn, *ppwszOut, cchIn);

            if (!cch)
            {
                LocalFree(*ppwszOut);
                *ppwszOut = NULL;
            }
            else
            {
                cch--;  //  Just return the number of characters
            }
        }
    }

    return cch;
}

/****************************** Module Header ******************************\
* Module Name: wsprintf.c
*
* Copyright (c) 1985-91, Microsoft Corporation
*  sprintf.c
*
*  Implements Windows friendly versions of sprintf and vsprintf
*
*  History:
*   2-15-89  craigc     Initial
*  11-12-90  MikeHar    Ported from windows 3
\***************************************************************************/

/* Max number of characters. Doesn't include termination character */

#define out(c) if (cchLimit) {*lpOut++=(c); cchLimit--;} else goto errorout

/***************************************************************************\
* SP_GetFmtValueW
*
*  reads a width or precision value from the format string
*
* History:
*  11-12-90  MikeHar    Ported from windows 3
*  07-27-92  GregoryW   Created Unicode version (copied from SP_GetFmtValue)
\***************************************************************************/

LPCWSTR SP_GetFmtValueW(
    LPCWSTR lpch,
    int *lpw)
{
    int ii = 0;

    /* It might not work for some locales or digit sets */
    while (*lpch >= L'0' && *lpch <= L'9') {
        ii *= 10;
        ii += (int)(*lpch - L'0');
        lpch++;
    }

    *lpw = ii;

    /*
     * return the address of the first non-digit character
     */
    return lpch;
}

/***************************************************************************\
* SP_PutNumberW
*
* Takes an unsigned long integer and places it into a buffer, respecting
* a buffer limit, a radix, and a case select (upper or lower, for hex).
*
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   need to increment lpstr after assignment of mod
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

int SP_PutNumberW(
    LPWSTR lpstr,
    DWORD n,
    int   limit,
    DWORD radix,
    int   uppercase)
{
    DWORD mod;
    int count = 0;

    /* It might not work for some locales or digit sets */
    if(uppercase)
        uppercase =  'A'-'0'-10;
    else
        uppercase = 'a'-'0'-10;

    if (count < limit) {
        do  {
            mod =  n % radix;
            n /= radix;

            mod += '0';
            if (mod > '9')
            mod += uppercase;
            *lpstr++ = (WCHAR)mod;
            count++;
        } while((count < limit) && n);
    }

    return count;
}

/***************************************************************************\
* SP_ReverseW
*
*  reverses a string in place
*
* History:
*  11-12-90  MikeHar    Ported from windows 3 asm --> C
*  12-11-90  GregoryW   fixed boundary conditions; removed count
*  02-11-92  GregoryW   temporary version until we have C runtime support
\***************************************************************************/

void SP_ReverseW(
    LPWSTR lpFirst,
    LPWSTR lpLast)
{
    WCHAR ch;

    while(lpLast > lpFirst){
        ch = *lpFirst;
        *lpFirst++ = *lpLast;
        *lpLast-- = ch;
    }
}


/***************************************************************************\
* wvsprintfW (API)
*
* wsprintfW() calls this function.
*
* History:
*    11-Feb-1992 GregoryW copied xwvsprintf
*         Temporary hack until we have C runtime support
* 1-22-97 tnoonan       Converted to wvnsprintfW
\***************************************************************************/

int wvnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    va_list arglist)
{
    BOOL fAllocateMem = FALSE;
    WCHAR prefix, fillch;
    int left, width, prec, size, sign, radix, upper, hprefix;
    int cchLimit = --cchLimitIn, cch;
    LPWSTR lpT, lpTWC;
    LPCSTR psz;
    va_list varglist = arglist;
    union {
        long l;
        unsigned long ul;
        char sz[2];
        WCHAR wsz[2];
    } val;

    if (cchLimit < 0)
        return 0;

    while (*lpFmt != 0) {
        if (*lpFmt == L'%') {

            /*
             * read the flags.  These can be in any order
             */
            left = 0;
            prefix = 0;
            while (*++lpFmt) {
                if (*lpFmt == L'-')
                    left++;
                else if (*lpFmt == L'#')
                    prefix++;
                else
                    break;
            }

            /*
             * find fill character
             */
            if (*lpFmt == L'0') {
                fillch = L'0';
                lpFmt++;
            } else
                fillch = L' ';

            /*
             * read the width specification
             */
            lpFmt = SP_GetFmtValueW(lpFmt, &cch);
            width = cch;

            /*
             * read the precision
             */
            if (*lpFmt == L'.') {
                lpFmt = SP_GetFmtValueW(++lpFmt, &cch);
                prec = cch;
            } else
                prec = -1;

            /*
             * get the operand size
             * default size: size == 0
             * long number:  size == 1
             * wide chars:   size == 2
             * It may be a good idea to check the value of size when it
             * is tested for non-zero below (IanJa)
             */
            hprefix = 0;
            if ((*lpFmt == L'w') || (*lpFmt == L't')) {
                size = 2;
                lpFmt++;
            } else if (*lpFmt == L'l') {
                size = 1;
                lpFmt++;
            } else {
                size = 0;
                if (*lpFmt == L'h') {
                    lpFmt++;
                    hprefix = 1;
                }
            }

            upper = 0;
            sign = 0;
            radix = 10;

            switch (*lpFmt) {
            case 0:
                goto errorout;

            case L'i':
            case L'd':
                size=1;
                sign++;

                /*** FALL THROUGH to case 'u' ***/

            case L'u':
                /* turn off prefix if decimal */
                prefix = 0;
donumeric:
                /* special cases to act like MSC v5.10 */
                if (left || prec >= 0)
                    fillch = L' ';

                /*
                 * if size == 1, "%lu" was specified (good)
                 * if size == 2, "%wu" was specified (bad)
                 */
                if (size) {
                    val.l = va_arg(varglist, LONG);
                } else if (sign) {
                    val.l = va_arg(varglist, SHORT);
                } else {
                    val.ul = va_arg(varglist, unsigned);
                }

                if (sign && val.l < 0L)
                    val.l = -val.l;
                else
                    sign = 0;

                lpT = lpOut;

                /*
                 * blast the number backwards into the user buffer
                 */
                cch = SP_PutNumberW(lpOut, val.l, cchLimit, radix, upper);
                if (!(cchLimit -= cch))
                    goto errorout;

                lpOut += cch;
                width -= cch;
                prec -= cch;
                if (prec > 0)
                    width -= prec;

                /*
                 * fill to the field precision
                 */
                while (prec-- > 0)
                    out(L'0');

                if (width > 0 && !left) {
                    /*
                     * if we're filling with spaces, put sign first
                     */
                    if (fillch != L'0') {
                        if (sign) {
                            sign = 0;
                            out(L'-');
                            width--;
                        }

                        if (prefix) {
                            out(prefix);
                            out(L'0');
                            prefix = 0;
                        }
                    }

                    if (sign)
                        width--;

                    /*
                     * fill to the field width
                     */
                    while (width-- > 0)
                        out(fillch);

                    /*
                     * still have a sign?
                     */
                    if (sign)
                        out(L'-');

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * now reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);
                } else {
                    /*
                     * add the sign character
                     */
                    if (sign) {
                        out(L'-');
                        width--;
                    }

                    if (prefix) {
                        out(prefix);
                        out(L'0');
                    }

                    /*
                     * reverse the string in place
                     */
                    SP_ReverseW(lpT, lpOut - 1);

                    /*
                     * pad to the right of the string in case left aligned
                     */
                    while (width-- > 0)
                        out(fillch);
                }
                break;

            case L'X':
                upper++;

                /*** FALL THROUGH to case 'x' ***/

            case L'x':
                radix = 16;
                if (prefix)
                    if (upper)
                        prefix = L'X';
                    else
                        prefix = L'x';
                goto donumeric;

            case L'c':
            case L'C':
                if (!size && !hprefix) {
                    size = 1;           // force WCHAR
                }

                /*** FALL THROUGH to case 'C' ***/

                /*
                 * if size == 0, "%C" or "%hc" was specified (CHAR)
                 * if size == 1, "%c" or "%lc" was specified (WCHAR)
                 * if size == 2, "%wc" or "%tc" was specified (WCHAR)
                 */
                cch = 1; /* One character must be copied to the output buffer */
                if (size) {
                    val.wsz[0] = va_arg(varglist, WCHAR);
                    val.wsz[1] = 0;
                    lpT = val.wsz;
                    goto putwstring;
                } else {
                    val.sz[0] = va_arg(varglist, CHAR);
                    val.sz[1] = 0;
                    psz = val.sz;
                    goto putstring;
                }

            case L's':
            case L'S':
                if (!size && !hprefix) {
                    size = 1;           // force LPWSTR
                }

                /*** FALL THROUGH to case 'S' ***/

                /*
                 * if size == 0, "%S" or "%hs" was specified (LPSTR)
                 * if size == 1, "%s" or "%ls" was specified (LPWSTR)
                 * if size == 2, "%ws" or "%ts" was specified (LPWSTR)
                 */
                if (size) {
                    lpT = va_arg(varglist, LPWSTR);
                    cch = lstrlenW(lpT);    // Win95 supports lstrlenW!
                } else {
                    psz = va_arg(varglist, LPSTR);
                    cch = lstrlenA(psz);
putstring:
                    cch = _MBToWCS(psz, cch, &lpTWC);
                    fAllocateMem = (BOOL) cch;
                    lpT = lpTWC;
                }
putwstring:
                if (prec >= 0 && cch > prec)
                    cch = prec;
                width -= cch;

                if (left) {
                    while (cch--)
                        out(*lpT++);
                    while (width-- > 0)
                        out(fillch);
                } else {
                    while (width-- > 0)
                        out(fillch);
                    while (cch--)
                        out(*lpT++);
                }

                if (fAllocateMem) {
                     LocalFree(lpTWC);
                     fAllocateMem = FALSE;
                }

                break;

            default:
normalch:
                out((WCHAR)*lpFmt);
                break;
            }  /* END OF SWITCH(*lpFmt) */
        }  /* END OF IF(%) */ else
            goto normalch;  /* character not a '%', just do it */

        /*
         * advance to next format string character
         */
        lpFmt++;
    }  /* END OF OUTER WHILE LOOP */

errorout:
    *lpOut = 0;

    if (fAllocateMem)
    {
        LocalFree(lpTWC);
    }

    return cchLimitIn - cchLimit;
}

LWSTDAPIV_(int) wnsprintfW(
    LPWSTR lpOut,
    int cchLimitIn,
    LPCWSTR lpFmt,
    ...)
{
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvnsprintfW(lpOut, cchLimitIn, lpFmt, arglist);
    va_end(arglist);
    return ret;
}

LWSTDAPIV_(int) wsprintfW(
    LPWSTR lpOut,
    LPCWSTR lpFmt,
    ...)
{
    // unsafe printf.  arbitrary max of 0x10000 length
    va_list arglist;
    int ret;

    va_start(arglist, lpFmt);
    ret = wvnsprintfW(lpOut, 0x10000, lpFmt, arglist);
    va_end(arglist);
    return ret;
}


//+---------------------------------------------------------------------------
//      StartDoc
//----------------------------------------------------------------------------

int StartDocWrap( HDC hDC, const DOCINFO * lpdi )
{
    CStrIn  strDocName( lpdi->lpszDocName );
    CStrIn  strOutput( lpdi->lpszOutput );
    CStrIn  strDatatype( lpdi->lpszDatatype );
    DOCINFOA dia;

    dia.cbSize = sizeof(DOCINFO);
    dia.lpszDocName = strDocName;
    dia.lpszOutput = strOutput;
    dia.lpszDatatype = strDatatype;
    dia.fwType = lpdi->fwType;

    return StartDocA( hDC, &dia );
}

#endif  // !WINNT


////////////////////////////////////////////////////////////////////
//
//  Plug UI support with SHLWAPI
//

typedef HRESULT (*PFNDLLGETVERSION)(DLLVERSIONINFO * pinfo);
HMODULE GetShlwapiHModule()
{
    HMODULE hShlwapi = GetModuleHandle(TEXT("SHLWAPI"));
    if (hShlwapi)
    {
        PFNDLLGETVERSION pfnDllGetVersion = (PFNDLLGETVERSION)GetProcAddress(hShlwapi, "DllGetVersion");
        if (pfnDllGetVersion)
        {
            DLLVERSIONINFO dllinfo;

            dllinfo.cbSize = sizeof(DLLVERSIONINFO);
            if (pfnDllGetVersion(&dllinfo) == NOERROR)
            {
                if (dllinfo.dwMajorVersion < 5)
                {
                    // This guy doesn't support ML functions
                    hShlwapi = NULL;
                }
            }
        }
    }
    return hShlwapi;
}

// First, we need access to some helper functions:
//
#ifndef UNIX
#define SHLWAPIMLISMLHINSTANCE_ORD     429
#else
#define SHLWAPIMLISMLHINSTANCE_ORD     "MLIsMLHInstance"
#endif
typedef BOOL (* PFNMLISMLHINSTANCE)(HINSTANCE);
BOOL MLIsMLHInstanceWrap(HINSTANCE hInst)
{
    HMODULE hShlwapi = GetShlwapiHModule();
    if (hShlwapi)
    {
        PFNMLISMLHINSTANCE pfn;
        pfn = (PFNMLISMLHINSTANCE)GetProcAddress(hShlwapi, (LPCSTR)SHLWAPIMLISMLHINSTANCE_ORD);
        if (pfn)
            return pfn(hInst);
    }

    // BUGBUG:  What if an app told comctl32 to be PlugUI and we picked
    //          a resource that cannot be displayed on Win9x without
    //          shlwapi's font linking?  Seems like we need to foricbly
    //          load shlwapi in that case...
    //
    // No shlwapi? then this can't be an ML hinstance.
    return FALSE;
}

#ifndef UNIX
#define SHLWAPIMLSETMLHINSTANCE_ORD 430
#else
#define SHLWAPIMLSETMLHINSTANCE_ORD "MLSetMLHInstance"
#endif
typedef HRESULT (* PFNMLSETMLHINSTANCE)(HINSTANCE, LANGID);
HRESULT MLSetMLHInstanceWrap(HINSTANCE hInst, LANGID lidUI)
{
    HMODULE hShlwapi;
    PFNMLSETMLHINSTANCE pfnMLSet = NULL;

    hShlwapi = GetShlwapiHModule();
    if (hShlwapi)
    {
        pfnMLSet = (PFNMLSETMLHINSTANCE)GetProcAddress(hShlwapi, (LPCSTR)SHLWAPIMLSETMLHINSTANCE_ORD);
        if (pfnMLSet)
            return pfnMLSet(hInst, lidUI);
    }

    return E_FAIL;
}

#ifndef UNIX
#define SHLWAPIMLCLEARMLHINSTANCE_ORD 431
#else
#define SHLWAPIMLCLEARMLHINSTANCE_ORD "MLClearMLHInstance"
#endif
typedef HRESULT (* PFNMLCLEARMLHINSTANCE)(HINSTANCE);
HRESULT MLClearMLHinstanceWrap(HINSTANCE hInst)
{
    HMODULE hShlwapi;
    PFNMLCLEARMLHINSTANCE pfnMLClear = NULL;

    hShlwapi = GetShlwapiHModule();
    if (hShlwapi)
    {
        pfnMLClear = (PFNMLCLEARMLHINSTANCE)GetProcAddress(hShlwapi, (LPCSTR)SHLWAPIMLCLEARMLHINSTANCE_ORD);
        if (pfnMLClear)
            return pfnMLClear(hInst);
    }

    return E_FAIL;
}

//
// And now, when shlwapi is around we delegate to it's ML-enabled implementations:
//

//
//  Make sure we get the real USER32 versions.
//
#undef CreateDialogIndirectParamW

#ifndef UNIX
#define SHLWAPICREATEDIALOGINDIRECTPARAM_ORD     393
#else
#define SHLWAPICREATEDIALOGINDIRECTPARAM_ORD     "CreateDialogIndirectParamWrapW"
#endif
typedef HWND (* PFNCREATEDIALOGINDIRECTPARAM)(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);
HWND CreateDialogIndirectParamWrap(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATE  lpTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam)
{
    HMODULE hShlwapi;
    PFNCREATEDIALOGINDIRECTPARAM pfnCDIP = NULL;
    HWND hwndRet;

    // If shlwapi is in memory, ask it to create the dialog,
    // as then we get ML dialogs on downlevel platforms (if
    // the hInstance is from MLLoadLibrary -- otherwise it
    // thunks to the real A/W api for us).
    //
    hShlwapi = GetShlwapiHModule();
    if (hShlwapi)
    {
        pfnCDIP = (PFNCREATEDIALOGINDIRECTPARAM)GetProcAddress(hShlwapi, (LPCSTR)SHLWAPICREATEDIALOGINDIRECTPARAM_ORD);
    }

    if (!pfnCDIP)
    {
        if (g_bRunOnNT)
            pfnCDIP = CreateDialogIndirectParamW;
        else
            pfnCDIP = CreateDialogIndirectParamA;
    }

    // If this is from comctl32, assume it was loaded via the MUI-Language
    if (HINST_THISDLL == hInstance)
        MLSetMLHInstanceWrap(hInstance, GetMUILanguage());

    hwndRet = pfnCDIP(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);

    if (HINST_THISDLL == hInstance)
        MLClearMLHinstanceWrap(hInstance);

    return(hwndRet);
}

//
//  Make sure we get the real USER32 versions.
//
#undef DialogBoxIndirectParamW

#ifndef UNIX
#define SHLWAPIDIALOGBOXINDIRECTPARAM_ORD     58
#else
#define SHLWAPIDIALOGBOXINDIRECTPARAM_ORD     "DialogBoxIndirectParamWrapW"
#endif
typedef INT_PTR (* PFNDIALOGBOXINDIRECTPARAM)(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);
INT_PTR DialogBoxIndirectParamWrap(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam)
{
    HMODULE hShlwapi;
    INT_PTR iRet;
    PFNDIALOGBOXINDIRECTPARAM pfnDBIP = NULL;
   
    // If shlwapi is in memory, ask it to create the dialog,
    // as then we get ML dialogs on downlevel platforms (if
    // the hInstance is from MLLoadLibrary -- otherwise it
    // thunks to the real A/W api for us).
    //
    hShlwapi = GetShlwapiHModule();
    if (hShlwapi)
        pfnDBIP = (PFNDIALOGBOXINDIRECTPARAM)GetProcAddress(hShlwapi, (LPCSTR)SHLWAPIDIALOGBOXINDIRECTPARAM_ORD);

    if (!pfnDBIP)
    {
        if (g_bRunOnNT)
            pfnDBIP = DialogBoxIndirectParamW;
        else
            pfnDBIP = DialogBoxIndirectParamA;
    }

    // If this is from comctl32, assume it was loaded via the MUI-Language
    if (HINST_THISDLL == hInstance)
        MLSetMLHInstanceWrap(hInstance, GetMUILanguage());

    iRet = pfnDBIP(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
    
    if (HINST_THISDLL == hInstance)
        MLClearMLHinstanceWrap(hInstance);

    return iRet;
}

#endif  // UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\wrapfns.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       wrapfns.h
//
//  Contents:   The list of Unicode functions wrapped for Win95.  Each
//              wrapped function should listed in alphabetical order with
//              the following format:
//
//      STRUCT_ENTRY(FunctionName, ReturnType, (Param list with args), (Argument list))
//
//              For example:
//
//      STRUCT_ENTRY(RegisterClass, ATOM, (CONST WNDCLASSW * pwc), (pwc))
//
//      For functions which return void, use the following:
//
//      STRUCT_ENTRY_VOID(FunctionName, (Param list with args), (Argument list))
//
//----------------------------------------------------------------------------

#ifndef _WRAPFNS_H_
#define _WRAPFNS_H_

#ifdef __cplusplus
extern "C" {
#endif

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs) \
        EXTERN_C FnType WINAPI FnName##Wrap FnParamList;

#define STRUCT_ENTRY_VOID(FnName, FnParamList, FnArgs) \
        EXTERN_C void WINAPI FnName##Wrap FnParamList;


#ifdef  UNICODE
#ifndef WINNT

#define lstrcmpW        StrCmpW
#define lstrcmpiW       StrCmpIW
#define lstrcpyW        StrCpyW
#define lstrcpynW       StrCpyNW
#define lstrcatW        StrCatW


#define AppendMenuW     AppendMenuWrap
STRUCT_ENTRY(AppendMenu,
             BOOL,
             (HMENU hMenu, UINT uFlags, UINT uIDnewItem, LPCWSTR lpnewItem),
             (hMenu, uFlags, uIDnewItem, lpnewItem))

#define CallMsgFilterW  CallMsgFilterWrap
STRUCT_ENTRY(CallMsgFilter, BOOL, (LPMSG lpMsg, int nCode), (lpMsg, nCode))

#define CallWindowProcW CallWindowProcWrap
STRUCT_ENTRY(CallWindowProc,
             LRESULT,
             (WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam),
             (lpPrevWndFunc, hWnd, Msg, wParam, lParam))

#define CharLowerW      CharLowerWrap
STRUCT_ENTRY(CharLower, LPWSTR, (LPWSTR lpsz), (lpsz))

#define CharLowerBuffW  CharLowerBuffWrap
STRUCT_ENTRY(CharLowerBuff, DWORD, (LPWSTR lpsz, DWORD cch), (lpsz, cch))

#define CharNextW       CharNextWrap
STRUCT_ENTRY(CharNext, LPWSTR, (LPCWSTR lpsz), (lpsz))

#define CharPrevW       CharPrevWrap
STRUCT_ENTRY(CharPrev, LPWSTR, (LPCWSTR lpszStart, LPCWSTR lpszCurrent), (lpszStart, lpszCurrent))

#define CharToOemW      CharToOemWrap
STRUCT_ENTRY(CharToOem, BOOL, (LPCWSTR lpszSrc, LPSTR lpszDst), (lpszSrc, lpszDst))

#define CharUpperW      CharUpperWrap
STRUCT_ENTRY(CharUpper, LPWSTR, (LPWSTR lpsz), (lpsz))

#define CharUpperBuffW  CharUpperBuffWrap
STRUCT_ENTRY(CharUpperBuff, DWORD, (LPWSTR lpsz, DWORD cch), (lpsz, cch))

#define CompareStringW  CompareStringWrap
STRUCT_ENTRY(CompareString,
             int,
             (LCID  Locale, DWORD  dwCmpFlags, LPCTSTR  lpString1, int  cchCount1, LPCTSTR  lpString2, int  cchCount2),
             (Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2))

#define CopyAcceleratorTableW   CopyAcceleratorTableWrap
STRUCT_ENTRY(CopyAcceleratorTable,
            int,
            (HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries),
            (hAccelSrc, lpAccelDst, cAccelEntries))

#define CreateAcceleratorTableW CreateAcceleratorTableWrap
STRUCT_ENTRY(CreateAcceleratorTable, HACCEL, (LPACCEL pAccel, int cEntries), (pAccel, cEntries))

#define CreateDCW       CreateDCWrap
STRUCT_ENTRY(CreateDC,
             HDC,
             (LPCWSTR lpszDriver, LPCWSTR lpszDevice, LPCWSTR lpszOutput, CONST DEVMODEW* lpInitData),
             (lpszDriver, lpszDevice, lpszOutput, lpInitData))

#define CreateDirectoryW    CreateDirectoryWrap
STRUCT_ENTRY(CreateDirectory,
             BOOL,
             (LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes),
             (lpPathName, lpSecurityAttributes))

#define CreateEventW    CreateEventWrap
STRUCT_ENTRY(CreateEvent,
             HANDLE,
             (LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName),
             (lpEventAttributes, bManualReset, bInitialState, lpName))

#define CreateFileW     CreateFileWrap
STRUCT_ENTRY(CreateFile,
             HANDLE,
             (LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile),
             (lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile))

#define CreateFileMappingW  CreateFileMappingWrap
STRUCT_ENTRY(CreateFileMapping,
             HANDLE,
             (HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaxSizeHigh, DWORD dwMaxSizeLow, LPCWSTR lpName),
             (hFile, lpFileMappingAttributes, flProtect, dwMaxSizeHigh, dwMaxSizeLow, lpName))

#define CreateFontW     CreateFontWrap
STRUCT_ENTRY(CreateFont,
             HFONT,
             (int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline, DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision, DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace),
             (nHeight, nWidth, nEscapement, nOrientation, fnWeight, fdwItalic, fdwUnderline, fdwStrikeOut, fdwCharSet, fdwOutputPrecision, fdwClipPrecision, fdwQuality, fdwPitchAndFamily, lpszFace))

#define CreateFontIndirectW CreateFontIndirectWrap
STRUCT_ENTRY(CreateFontIndirect, HFONT, (CONST LOGFONTW * lpfw), (lpfw))

#define CreateICW       CreateICWrap
STRUCT_ENTRY(CreateIC,
             HDC,
             (LPCWSTR lpszDriver, LPCWSTR lpszDevice, LPCWSTR lpszOutput, CONST DEVMODEW* lpInitData),
             (lpszDriver, lpszDevice, lpszOutput, lpInitData))

#define CreateWindowExW CreateWindowExWrap
STRUCT_ENTRY(CreateWindowEx,
             HWND,
             (DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam),
             (dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam))

#define DefWindowProcW  DefWindowProcWrap
STRUCT_ENTRY(DefWindowProc,
             LRESULT,
             (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam),
             (hWnd, msg, wParam, lParam))

#define DeleteFileW     DeleteFileWrap
STRUCT_ENTRY(DeleteFile, BOOL, (LPCWSTR lpsz), (lpsz))

#define DispatchMessageW    DispatchMessageWrap
STRUCT_ENTRY(DispatchMessage, LRESULT, (CONST MSG * pMsg), (pMsg))

#define EnumFontFamiliesW   EnumFontFamiliesWrap
STRUCT_ENTRY(EnumFontFamilies,
             int,
             (HDC hdc, LPCWSTR lpszFamily, FONTENUMPROC lpEnumFontProc, LPARAM lParam),
             (hdc, lpszFamily, lpEnumFontProc, lParam))

#define EnumFontFamiliesExW EnumFontFamiliesExWrap
STRUCT_ENTRY(EnumFontFamiliesEx,
             int,
             (HDC hdc, LPLOGFONTW lpLogFont, FONTENUMPROC lpEnumFontProc, LPARAM lParam, DWORD dwFlags),
             (hdc, lpLogFont, lpEnumFontProc, lParam, dwFlags))

#define EnumResourceNamesW  EnumResourceNamesWrap
STRUCT_ENTRY(EnumResourceNames,
             BOOL,
             (HINSTANCE hModule, LPCWSTR lpType, ENUMRESNAMEPROC lpEnumFunc, LONG lParam),
             (hModule, lpType, lpEnumFunc, lParam))

#define FindFirstFileW  FindFirstFileWrap
STRUCT_ENTRY(FindFirstFile,
             HANDLE,
             (LPCWSTR lpFileName, LPWIN32_FIND_DATAW pwszFd),
             (lpFileName, pwszFd))

#define FindResourceExW   FindResourceExWrap
STRUCT_ENTRY(FindResourceEx,
             HRSRC,
             (HINSTANCE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLang),
             (hModule, lpType, lpName, wLang))

// This is not a typo.  FindResource and FindResourceEx take their parameters
// in a DIFFERENT order!
#define FindResourceW(a,b,c) FindResourceExW(a,c,b,0)

#define FindWindowW FindWindowWrap
STRUCT_ENTRY(FindWindow,
             HWND,
             (LPCWSTR lpClassName, LPCWSTR lpWindowName),
             (lpClassName, lpWindowName))

#define FormatMessageW  FormatMessageWrap
STRUCT_ENTRY(FormatMessage,
             DWORD,
             (DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments),
             (dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments))

#define GetClassInfoW   GetClassInfoWrap
STRUCT_ENTRY(GetClassInfo,
             BOOL,
             (HINSTANCE hModule, LPCWSTR lpClassName, LPWNDCLASSW lpWndClassW),
             (hModule, lpClassName, lpWndClassW))

#define GetClassLongW   GetClassLongWrap
STRUCT_ENTRY(GetClassLong, DWORD, (HWND hWnd, int nIndex), (hWnd, nIndex))

#define GetClassNameW   GetClassNameWrap
STRUCT_ENTRY(GetClassName,
             int,
             (HWND hWnd, LPWSTR lpClassName, int nMaxCount),
             (hWnd, lpClassName, nMaxCount))

#define GetClipboardFormatNameW GetClipboardFormatNameWrap
STRUCT_ENTRY(GetClipboardFormatName,
             int,
             (UINT format, LPWSTR lpFormatName, int cchFormatName),
             (format, lpFormatName, cchFormatName))

#define GetCurrentDirectoryW    GetCurrentDirectoryWrap
STRUCT_ENTRY(GetCurrentDirectory,
             DWORD,
             (DWORD nBufferLength, LPWSTR lpBuffer),
             (nBufferLength, lpBuffer))

#define GetDateFormatW GetDateFormatWrap
STRUCT_ENTRY(GetDateFormat,
             int,
             (LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate),
             (Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate))

#define GetDlgItemTextW GetDlgItemTextWrap
STRUCT_ENTRY(GetDlgItemText,
             UINT,
             (HWND hWndDlg, int idControl, LPWSTR lpsz, int cchMax),
             (hWndDlg, idControl, lpsz, cchMax))

#define GetFileAttributesW  GetFileAttributesWrap
STRUCT_ENTRY(GetFileAttributes, DWORD, (LPCWSTR lpsz), (lpsz))

#define GetFullPathNameW    GetFullPathNameWrap
STRUCT_ENTRY(GetFullPathName,
            DWORD,
            ( LPCWSTR lpFileName,
              DWORD nBufferLength,
              LPWSTR lpBuffer,
              LPWSTR *lpFilePart),
            ( lpFileName,  nBufferLength,  lpBuffer, lpFilePart))

#define GetKeyNameTextW  GetKeyNameTextWrap
STRUCT_ENTRY(GetKeyNameText, int, (LONG lParam, LPWSTR lpsz, int nSize), (lParam, lpsz, nSize))

#define GetLocaleInfoW  GetLocaleInfoWrap
STRUCT_ENTRY(GetLocaleInfo,
             int,
             (LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData),
             (Locale, LCType, lpsz, cchData))

#define GetMenuItemInfoW    GetMenuItemInfoWrap
STRUCT_ENTRY(GetMenuItemInfo,
             BOOL,
             (HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFOW lpmii),
             (hMenu, uItem, fByPosition, lpmii))

#define GetMenuStringW  GetMenuStringWrap
STRUCT_ENTRY(GetMenuString,
             int,
             (HMENU hMenu, UINT uIDItem, LPWSTR lpString, int nMaxCount, UINT uFlag),
             (hMenu, uIDItem, lpString, nMaxCount, uFlag))

#define GetMessageW     GetMessageWrap
STRUCT_ENTRY(GetMessage,
             BOOL,
             (LPMSG lpMsg, HWND hWnd , UINT wMsgFilterMin, UINT wMsgFilterMax),
             (lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax))

#define GetModuleFileNameW  GetModuleFileNameWrap
STRUCT_ENTRY(GetModuleFileName,
             DWORD,
             (HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize),
             (hModule, pwszFilename, nSize))

#define GetNumberFormatW GetNumberFormatWrap
STRUCT_ENTRY(GetNumberFormat,
             int,
             (LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber),
             (Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber))

#define GetSystemDirectoryW GetSystemDirectoryWrap
STRUCT_ENTRY(GetSystemDirectory,
             UINT,
             (LPWSTR lpBuffer, UINT uSize),
             (lpBuffer, uSize))

#define SearchPathW     SearchPathWrap
STRUCT_ENTRY(SearchPath,
             DWORD,
             (LPCWSTR lpPathName, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD cchReturnBuffer,
             LPWSTR  lpReturnBuffer, LPWSTR *  plpfilePart),
             (lpPathName, lpFileName, lpExtension, cchReturnBuffer, lpReturnBuffer, plpfilePart))

#define GetModuleHandleW    GetModuleHandleWrap
STRUCT_ENTRY(GetModuleHandle, HMODULE, (LPCWSTR lpsz), (lpsz))

#define GetObjectW      GetObjectWrap
STRUCT_ENTRY(GetObject,
             int,
             (HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj),
             (hgdiObj, cbBuffer, lpvObj))

#define GetPrivateProfileIntW   GetPrivateProfileIntWrap
STRUCT_ENTRY(GetPrivateProfileInt,
             UINT,
             (LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName),
             (lpAppName, lpKeyName, nDefault, lpFileName))

#define GetProfileIntW   GetProfileIntWrap
STRUCT_ENTRY(GetProfileInt,
             UINT,
             (LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault),
             (lpAppName, lpKeyName, nDefault))

#define GetProfileStringW   GetProfileStringWrap
STRUCT_ENTRY(GetProfileString,
             DWORD,
             (LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpBuffer, DWORD dwBuffersize),
             (lpAppName, lpKeyName, lpDefault, lpBuffer, dwBuffersize))

#define GetPropW        GetPropWrap
STRUCT_ENTRY(GetProp, HANDLE, (HWND hWnd, LPCWSTR lpString), (hWnd, lpString))

#define GetStringTypeExW    GetStringTypeExWrap
STRUCT_ENTRY(GetStringTypeEx, BOOL,
            (LCID lcid, DWORD dwInfoType, LPCTSTR lpSrcStr, int cchSrc, LPWORD lpCharType),
            (lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType))

#define GetTempFileNameW    GetTempFileNameWrap
STRUCT_ENTRY(GetTempFileName,
             UINT,
             (LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName),
             (lpPathName, lpPrefixString, uUnique, lpTempFileName))

#define GetTempPathW    GetTempPathWrap
STRUCT_ENTRY(GetTempPath, DWORD, (DWORD nBufferLength, LPWSTR lpBuffer), (nBufferLength, lpBuffer))

#define GetTextFaceW    GetTextFaceWrap
STRUCT_ENTRY(GetTextFace,
             int,
             (HDC hdc, int cch, LPWSTR lpFaceName),
             (hdc, cch, lpFaceName))

#define GetTextMetricsW GetTextMetricsWrap
STRUCT_ENTRY(GetTextMetrics, BOOL, (HDC hdc, LPTEXTMETRICW lptm), (hdc, lptm))

#define GetTimeFormatW GetTimeFormatWrap
STRUCT_ENTRY(GetTimeFormat,
             int,
             (LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime),
             (Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime))

#define GetWindowLongW  GetWindowLongWrap
STRUCT_ENTRY(GetWindowLong, LONG, (HWND hWnd, int nIndex), (hWnd, nIndex))

#define GetWindowTextW  GetWindowTextWrap
STRUCT_ENTRY(GetWindowText, int, (HWND hWnd, LPWSTR lpString, int nMaxCount), (hWnd, lpString, nMaxCount))

#define GetWindowTextLengthW    GetWindowTextLengthWrap
STRUCT_ENTRY(GetWindowTextLength, int, (HWND hWnd), (hWnd))

#define GetWindowsDirectoryW GetWindowsDirectoryWrap
STRUCT_ENTRY(GetWindowsDirectory, UINT, (LPWSTR lpWinPath, UINT cch), (lpWinPath, cch))

#define GlobalAddAtomW  GlobalAddAtomWrap
STRUCT_ENTRY(GlobalAddAtom, ATOM, (LPCWSTR lpString), (lpString))

#define GrayStringW     GrayStringWrap
STRUCT_ENTRY(GrayString,
             BOOL,
             (HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int x, int y, int nWidth, int nHeight),
             (hDC, hBrush, lpOutputFunc, lpData, nCount, x, y, nWidth, nHeight))

#define ImmGetCompositionStringW    ImmGetCompositionStringWrap
STRUCT_ENTRY(ImmGetCompositionString,
             LONG,
             (HIMC hIMC, DWORD dwIndex, LPVOID lpBuf, DWORD dwBufLen),
             (hIMC, dwIndex, lpBuf, dwBufLen))

#define ImmSetCompositionStringW    ImmSetCompositionStringWrap
STRUCT_ENTRY(ImmSetCompositionString,
             LONG,
             (HIMC hIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen),
             (hIMC, dwIndex, lpComp, dwCompLen, lpRead, dwReadLen))

#define InsertMenuW     InsertMenuWrap
STRUCT_ENTRY(InsertMenu,
             BOOL,
             (HMENU hMenu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem),
             (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem))

#define IsCharAlphaW    IsCharAlphaWrap
STRUCT_ENTRY(IsCharAlpha, BOOL, (WCHAR wch), wch);

#define IsCharAlphaNumericW IsCharAlphaNumericWrap
STRUCT_ENTRY(IsCharAlphaNumeric, BOOL, (WCHAR wch), wch);

#define IsCharUpperW    IsCharUpperWrap
STRUCT_ENTRY(IsCharUpper, BOOL, (WCHAR wch), wch);

#define IsCharLowerW    IsCharLowerWrap
STRUCT_ENTRY(IsCharLower, BOOL, (WCHAR wch), wch);

#define IsDialogMessageW    IsDialogMessageWrap
STRUCT_ENTRY(IsDialogMessage, BOOL, (HWND hWndDlg, LPMSG lpMsg), (hWndDlg, lpMsg))

#define LoadAcceleratorsW   LoadAcceleratorsWrap
STRUCT_ENTRY(LoadAccelerators, HACCEL, (HINSTANCE hInstance, LPCWSTR lpTableName), (hInstance, lpTableName))

#define LoadBitmapW     LoadBitmapWrap
STRUCT_ENTRY(LoadBitmap, HBITMAP, (HINSTANCE hInstance, LPCWSTR lpBitmapName), (hInstance, lpBitmapName))

#define LoadCursorW     LoadCursorWrap
STRUCT_ENTRY(LoadCursor, HCURSOR, (HINSTANCE hInstance, LPCWSTR lpCursorName), (hInstance, lpCursorName))

#define LoadIconW       LoadIconWrap
STRUCT_ENTRY(LoadIcon, HICON, (HINSTANCE hInstance, LPCWSTR lpIconName), (hInstance, lpIconName))

#define LoadImageW      LoadImageWrap
STRUCT_ENTRY(LoadImage, HANDLE, (HINSTANCE hInstance, LPCWSTR lpName, UINT uType, int cxDesired, int cyDesired, UINT fuLoad),
                       (hInstance, lpName, uType, cxDesired, cyDesired, fuLoad))

#define LoadLibraryW    LoadLibraryWrap
STRUCT_ENTRY(LoadLibrary, HINSTANCE, (LPCWSTR lpLibFileName), (lpLibFileName))

#define LoadLibraryExW  LoadLibraryExWrap
STRUCT_ENTRY(LoadLibraryEx,
             HINSTANCE,
             (LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags),
             (lpLibFileName, hFile, dwFlags))

#define LoadMenuW       LoadMenuWrap
STRUCT_ENTRY(LoadMenu, HMENU, (HINSTANCE hInstance, LPCWSTR lpMenuName), (hInstance, lpMenuName))

#define LoadStringW     LoadStringWrap
STRUCT_ENTRY(LoadString,
             int,
             (HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax),
             (hInstance, uID, lpBuffer, nBufferMax))

#define MapVirtualKeyW  MapVirtualKeyWrap
STRUCT_ENTRY(MapVirtualKey, UINT, (UINT uCode, UINT uMapType), (uCode, uMapType))

#define MessageBoxIndirectW MessageBoxIndirectWrap
STRUCT_ENTRY(MessageBoxIndirect,
            BOOL,
            (LPMSGBOXPARAMS lpMsgBoxParams),
            (lpMsgBoxParams))

#define ModifyMenuW     ModifyMenuWrap
STRUCT_ENTRY(ModifyMenu,
             BOOL,
             (HMENU hMenu, UINT uPosition, UINT uFlags, UINT uIDNewItem, LPCWSTR lpNewItem),
             (hMenu, uPosition, uFlags, uIDNewItem, lpNewItem))

#define GetCharacterPlacementW  GetCharacterPlacementWrap
STRUCT_ENTRY(GetCharacterPlacement, DWORD,
             (HDC hdc, LPCTSTR lpString, int nCount, int nMaxExtent,
              LPGCP_RESULTS lpResults, DWORD dwFlags),
             (hdc, lpString, nCount, nMaxExtent,
              lpResults, dwFlags))

#define CopyFileW       CopyFileWrap
STRUCT_ENTRY(CopyFile,
             BOOL,
             (LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists),
             (lpExistingFileName, lpNewFileName, bFailIfExists))

#define MoveFileW       MoveFileWrap
STRUCT_ENTRY(MoveFile,
             BOOL,
             (LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName),
             (lpExistingFileName, lpNewFileName))

#define OemToCharW      OemToCharWrap
STRUCT_ENTRY(OemToChar,
             BOOL,
             (LPCSTR lpszSrc, LPWSTR lpszDst),
             (lpszSrc, lpszDst))

#define OutputDebugStringW  OutputDebugStringWrap
STRUCT_ENTRY_VOID(OutputDebugString,
                  (LPCWSTR lpOutputString),
                  (lpOutputString))

#define PeekMessageW    PeekMessageWrap
STRUCT_ENTRY(PeekMessage,
             BOOL,
             (LPMSG lpMsg, HWND hWnd , UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg),
             (lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg))

#define PostMessageW    PostMessageWrap
STRUCT_ENTRY(PostMessage,
             BOOL,
             (HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam),
             (hWnd, Msg, wParam, lParam))

#define PostThreadMessageW  PostThreadMessageWrap
STRUCT_ENTRY(PostThreadMessage,
             BOOL,
             (DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam),
             (idThread, Msg, wParam, lParam))

#define RegCreateKeyW   RegCreateKeyWrap
STRUCT_ENTRY(RegCreateKey,
             LONG,
             (HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult),
             (hKey, lpSubKey, phkResult))

#define RegCreateKeyExW RegCreateKeyExWrap
STRUCT_ENTRY(RegCreateKeyEx,
             LONG,
             (HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition),
             (hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition))

#define RegDeleteKeyW   RegDeleteKeyWrap
STRUCT_ENTRY(RegDeleteKey, LONG, (HKEY hKey, LPCWSTR pwszSubKey), (hKey, pwszSubKey))

#define RegEnumKeyW     RegEnumKeyWrap
STRUCT_ENTRY(RegEnumKey,
             LONG,
             (HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName),
             (hKey, dwIndex, lpName, cbName))

#define RegEnumKeyExW   RegEnumKeyExWrap
STRUCT_ENTRY(RegEnumKeyEx,
             LONG,
             (HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime),
             (hKey, dwIndex, lpName, lpcbName, lpReserved, lpClass, lpcbClass, lpftLastWriteTime))

#define RegOpenKeyW     RegOpenKeyWrap
STRUCT_ENTRY(RegOpenKey, LONG, (HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult), (hKey, pwszSubKey, phkResult))

#define RegOpenKeyExW   RegOpenKeyExWrap
STRUCT_ENTRY(RegOpenKeyEx,
             LONG,
             (HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult),
             (hKey, lpSubKey, ulOptions, samDesired, phkResult))

#define RegQueryInfoKeyW    RegQueryInfoKeyWrap
STRUCT_ENTRY(RegQueryInfoKey,
            LONG,
            (HKEY hKey, LPWSTR lpClass, LPDWORD lpcbClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen,
             LPDWORD lpcbMaxClassLen,  LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen,
             LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime),
            (hKey, lpClass, lpcbClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime))

#define RegQueryValueW  RegQueryValueWrap
STRUCT_ENTRY(RegQueryValue,
             LONG,
             (HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue, PLONG lpcbValue),
             (hKey, pwszSubKey, pwszValue, lpcbValue))

#define RegQueryValueExW    RegQueryValueExWrap
STRUCT_ENTRY(RegQueryValueEx,
             LONG,
             (HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData),
             (hKey, lpValueName, lpReserved, lpType, lpData, lpcbData))

#define RegSetValueW    RegSetValueWrap
STRUCT_ENTRY(RegSetValue,
             LONG,
             (HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData),
             (hKey, lpSubKey, dwType, lpData, cbData))

#define RegSetValueExW  RegSetValueExWrap
STRUCT_ENTRY(RegSetValueEx,
             LONG,
             (HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, CONST BYTE* lpData, DWORD cbData),
             (hKey, lpValueName, Reserved, dwType, lpData, cbData))

#define RegisterClassW  RegisterClassWrap
STRUCT_ENTRY(RegisterClass, ATOM, (CONST WNDCLASSW * pwc), (pwc))

#define RegisterClipboardFormatW    RegisterClipboardFormatWrap
STRUCT_ENTRY(RegisterClipboardFormat, UINT, (LPCWSTR psz), (psz))

#define RegisterWindowMessageW  RegisterWindowMessageWrap
STRUCT_ENTRY(RegisterWindowMessage, UINT, (LPCWSTR psz), (psz))

#define RemovePropW     RemovePropWrap
STRUCT_ENTRY(RemoveProp, HANDLE, (HWND hwnd, LPCWSTR psz), (hwnd, psz))

#define SendDlgItemMessageW SendDlgItemMessageWrap
STRUCT_ENTRY(SendDlgItemMessage,
             LRESULT,
             (HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam),
             (hDlg, nIDDlgItem, Msg, wParam, lParam))

#define SendMessageW    SendMessageWrap
STRUCT_ENTRY(SendMessage,
             LRESULT,
             (HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam),
             (hWnd, Msg, wParam, lParam))

#define SendNotifyMessageW  SendNotifyMessageWrap
STRUCT_ENTRY(SendNotifyMessage,
             BOOL,
             (HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam),
             (hWnd, Msg, wParam, lParam))

#define SetCurrentDirectoryW    SetCurrentDirectoryWrap
STRUCT_ENTRY(SetCurrentDirectory, BOOL, (LPCWSTR psz), (psz))

#define SetDlgItemTextW SetDlgItemTextWrap
STRUCT_ENTRY(SetDlgItemText, BOOL, (HWND hwnd, int id, LPCWSTR psz), (hwnd, id, psz))

#define SetMenuItemInfoW    SetMenuItemInfoWrap
STRUCT_ENTRY(SetMenuItemInfo,
             BOOL,
             (HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFOW lpmii),
             (hMenu, uItem, fByPosition, lpmii))

#define SetPropW        SetPropWrap
STRUCT_ENTRY(SetProp, BOOL, (HWND hwnd, LPCWSTR psz, HANDLE hData), (hwnd, psz, hData))

#define SetWindowLongW  SetWindowLongWrap
STRUCT_ENTRY(SetWindowLong, LONG, (HWND hWnd, int nIndex, LONG dwNewLong), (hWnd, nIndex, dwNewLong))

#define SetWindowsHookExW   SetWindowsHookExWrap
STRUCT_ENTRY(SetWindowsHookEx, HHOOK, (int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId),
                (idHook, lpfn, hmod, dwThreadId))

#define SetWindowTextW  SetWindowTextWrap
STRUCT_ENTRY(SetWindowText, BOOL, (HWND hWnd, LPCWSTR lpString), (hWnd, lpString))

#define StartDocW       StartDocWrap
STRUCT_ENTRY(StartDoc, int, (HDC hDC, const DOCINFO * lpdi), (hDC, lpdi))

#define SystemParametersInfoW   SystemParametersInfoWrap
STRUCT_ENTRY(SystemParametersInfo,
             BOOL,
             (UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni),
             (uiAction, uiParam, pvParam, fWinIni))

#define TranslateAcceleratorW   TranslateAcceleratorWrap
STRUCT_ENTRY(TranslateAccelerator,
             int,
             (HWND hWnd, HACCEL hAccTable, LPMSG lpMsg),
             (hWnd, hAccTable, lpMsg))

#define UnregisterClassW    UnregisterClassWrap
STRUCT_ENTRY(UnregisterClass, BOOL, (LPCWSTR psz, HINSTANCE hinst), (psz, hinst))

#define VkKeyScanW  VkKeyScanWrap
STRUCT_ENTRY(VkKeyScan, SHORT, (WCHAR ch), (ch))

#define WinHelpW    WinHelpWrap
STRUCT_ENTRY(WinHelp, BOOL, (HWND hwnd, LPCWSTR szFile, UINT uCmd, DWORD dwData), (hwnd, szFile, uCmd, dwData))

#define wsprintfW   wsprintfWrap
STRUCT_ENTRY(wsprintf, int, (LPWSTR psz, LPCWSTR pszFormat, ...), (psz, pszFormat, ...))

#define wvsprintfW  wvsprintfWrap
STRUCT_ENTRY(wvsprintf, int, (LPWSTR psz, LPCWSTR pszFormat, va_list va), (psz, pszFormat, va))

#endif  // !WINNT

// Even on NT we want to wrap these for PlugUI on NT4

#define CreateDialogIndirectParamW  CreateDialogIndirectParamWrap
STRUCT_ENTRY(CreateDialogIndirectParam,
             HWND,
             (HINSTANCE hInstance, LPCDLGTEMPLATE lpTemplate, HWND hWndParent , DLGPROC lpDialogFunc, LPARAM dwInitParam),
             (hInstance, lpTemplate, hWndParent , lpDialogFunc, dwInitParam))

#undef CreateDialogParam
#define CreateDialogParam CreateDialogParam_WeNeedToWriteTheThunkAgain

#define DialogBoxIndirectParamW DialogBoxIndirectParamWrap
STRUCT_ENTRY(DialogBoxIndirectParam,
             INT_PTR,
             (HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam),
             (hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam))

#undef DialogBoxParam
#define DialogBoxParam DialogBoxParam_WeNeedToWriteTheThunkAgain

// And these are ML-specific

#define MLIsMLHInstance MLIsMLHInstanceWrap
BOOL MLIsMLHInstanceWrap(HINSTANCE hInst);

#define MLSetMLHInstance MLSetMLHInstanceWrap
HRESULT MLSetMLHInstanceWrap(HINSTANCE hInst, LANGID lidUI);

#define MLClearMLHinstance MLClearMLHinstanceWrap
HRESULT MLClearMLHinstanceWrap(HINSTANCE hInst);


#endif // UNICODE



#if defined(FONT_LINK) || defined(UNICODE_WIN9x)

#define DrawTextW   DrawTextWrap
STRUCT_ENTRY(DrawText,
            int,
            (HDC hDC, LPCWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat),
            (hDC, lpString, nCount, lpRect, uFormat))

// We should use the shlwapi versions.
#define DrawTextExW DrawTextExPrivWrap
STRUCT_ENTRY(DrawTextExPriv,
            int,
            (HDC hDC, LPWSTR lpString, int nCount, LPRECT lpRect, UINT uFormat, LPDRAWTEXTPARAMS lpDTParams),
            (hDC, lpString, nCount, lpRect, uFormat, lpDTParams))

#define ExtTextOutW     ExtTextOutWrap
STRUCT_ENTRY(ExtTextOut,
             BOOL,
             (HDC hdc, int xp, int yp, UINT eto, CONST RECT *lprect, LPCWSTR lpwch, UINT cLen, CONST INT *lpdxp),
             (hdc, xp, yp, eto, lprect, lpwch, cLen, lpdxp))

#define GetCharWidthW   GetCharWidthWrap
STRUCT_ENTRY(GetCharWidth,
             BOOL,
             (HDC hdc, UINT uFirstChar, UINT uLastChar, LPINT lpnWidths),
             (hdc, uFirstChar, uLastChar, lpnWidths))

#define GetTextExtentPointW     GetTextExtentPointWrap
STRUCT_ENTRY(GetTextExtentPoint,
             BOOL,
             (HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize),
             (hdc, pwsz, cb, pSize))

#define GetTextExtentPoint32W   GetTextExtentPoint32Wrap
STRUCT_ENTRY(GetTextExtentPoint32,
             BOOL,
             (HDC hdc, LPCWSTR pwsz, int cb, LPSIZE pSize),
             (hdc, pwsz, cb, pSize))

#define TextOutW        TextOutWrap
STRUCT_ENTRY(TextOut, BOOL, (HDC hdc, int xp, int yp, LPCWSTR lpwch, int cLen), (hdc, xp, yp, lpwch, cLen))

#endif  // FONT_LINK || UNICODE_WIN9x

#ifdef __cplusplus
} // extern "C"
#endif

#endif  // _WRAPFNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\unixstuff.h ===
#ifndef _COMCTL32_UNIXSTUFF_H_
#define _COMCTL32_UNIXSTUFF_H_

#define ARROW_WIDTH  4
#define ARROW_HEIGHT 4

#define CHECK_FREE( ptr ) { if(ptr) { free(ptr); ptr = NULL; } }

STDAPI_(void) UnixPaintArrow(HDC hDC, BOOL bHoriz, BOOL bDown, int nXCenter, int nYCenter, int nWidth, int nHeight);

/* We need this for the unaligned template classes to work after
 * fixing the mmsystem.h header.
 */
#if defined(MWBIG_ENDIAN)
#ifdef mmioFOURCC
#undef mmioFOURCC
#endif
#define mmioFOURCC(ch0, ch1, ch2, ch3) MAKEFOURCC(ch3, ch2, ch1, ch0)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\unixstuff.cpp ===
#include "ctlspriv.h"
#include "unixstuff.h"

EXTERN_C void UnixPaintArrow(HDC hDC, BOOL bHoriz, BOOL bDown, int nXCenter, int nYCenter,
          int nWidth, int nHeight)
{
    HPEN hOldPen;
    HBRUSH hOldBrush;
    POINT pFigure[4];
    LOGBRUSH  hBrLog  = { BS_SOLID, GetSysColor( COLOR_BTNTEXT ), 0   };

    HBRUSH hBrush = CreateBrushIndirect( &hBrLog  );
    HPEN   hPen   = CreatePen( PS_SOLID, 1, GetSysColor( COLOR_BTNTEXT ) );

    if( hPen && hBrush )
    {
        hOldPen           = (HPEN)   SelectObject(hDC, hPen);
        hOldBrush         = (HBRUSH) SelectObject(hDC, hBrush);
    }
    else
    {
        hOldPen   = (HPEN)   SelectObject(hDC, GetStockObject( BLACK_PEN ) );
        hOldBrush = (HBRUSH) SelectObject(hDC, GetStockObject( BLACK_BRUSH ) );
    }

    if(bHoriz) {
       if (bDown) {
                pFigure[0].x = nXCenter - nWidth /2;
                pFigure[0].y = nYCenter - nHeight/2;
                pFigure[1].x = nXCenter - nWidth /2;
                pFigure[1].y = nYCenter + nHeight/2;
                pFigure[2].x = nXCenter + nWidth /2;
                pFigure[2].y = nYCenter;
        } else {
                pFigure[0].x = nXCenter - nWidth /2;
                pFigure[0].y = nYCenter;
                pFigure[1].x = nXCenter + nWidth /2;
                pFigure[1].y = nYCenter + nHeight/2;
                pFigure[2].x = nXCenter + nWidth /2;
                pFigure[2].y = nYCenter - nHeight/2;
        }
    }
    else {
       if (bDown) {
                pFigure[0].x = nXCenter - nWidth /2;
                pFigure[0].y = nYCenter - nHeight/2;
                pFigure[1].x = nXCenter + nWidth /2;
                pFigure[1].y = nYCenter - nHeight/2;
                pFigure[2].x = nXCenter;
                pFigure[2].y = nYCenter + nHeight/2;
        } else {
                pFigure[0].x = nXCenter;
                pFigure[0].y = nYCenter - nHeight/2;
                pFigure[1].x = nXCenter - nWidth /2;
                pFigure[1].y = nYCenter + nHeight/2;
                pFigure[2].x = nXCenter + nWidth /2;
                pFigure[2].y = nYCenter + nHeight/2;
        }

    }

    Polygon(hDC, pFigure, 3);

    SelectObject(hDC, hOldPen);
    SelectObject(hDC, hOldBrush);

    if( hPen   ) DeleteObject(hPen  );
    if( hBrush ) DeleteObject(hBrush);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\updown.c ===
#include "ctlspriv.h"

/////////////////////////////////////////////////////////////////////////////
//
// updown.c : A micro-scrollbar control; useful for increment/decrement.
//
/////////////////////////////////////////////////////////////////////////////

#define NUM_UDACCELS 3

#define DONTCARE    0
#define SIGNED      1
#define UNSIGNED    2

#define UD_HITNOWHERE 0
#define UD_HITDOWN 1
#define UD_HITUP 2

typedef struct {
    CONTROLINFO ci;
    HWND    hwndBuddy;
    unsigned fUp        : 1;
    unsigned fDown      : 1;
    unsigned fUnsigned  : 1;    // BUGBUG: no way to turn this on
    unsigned fSharedBorder  : 1;
    unsigned fSunkenBorder  : 1;
    unsigned fUpDownDestroyed : 1;  // This tells the buddy that updown destoryed.
    BOOL     fTrackSet: 1;
    unsigned fSubclassed:1;     // did we subclass the buddy?

    UINT     nBase;
    int      nUpper;
    int      nLower;
    int      nPos;
    UINT     uClass;
    BOOL     bDown;
    DWORD    dwStart;
    UINT     nAccel;
    UDACCEL  udAccel[NUM_UDACCELS];
    UINT        uHot;
    int      cReenterSetint;    // To avoid recursion death in setint()
} UDSTATE, NEAR *PUDSTATE;


// Constants:
//
#define CLASS_UNKNOWN   0
#define CLASS_EDIT  1
#define CLASS_LISTBOX   2

#define MAX_INTLENGTH   18 // big enough for all intl stuff, too

// this is the space to the left and right of the arrow (in pixels)
#define XBORDER 0

#define BASE_DECIMAL    10
#define BASE_HEX        16

// Declarations:
//
LRESULT CALLBACK ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData);

/////////////////////////////////////////////////////////////////////////////

//
// ***** Internal workhorses *****
//


// Validates the buddy.
//
void NEAR PASCAL isgoodbuddy(PUDSTATE np)
{
    if (!np->hwndBuddy)
        return;
    if (!IsWindow(np->hwndBuddy))
    {
#if defined(DEBUG) && !defined(WIN32)
        DebugOutput(DBF_ERROR | DBF_USER,
                    TEXT("UpDown: invalid buddy handle 0x04X; ")
                    TEXT("resetting to NULL"), np->hwndBuddy);
#endif
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
    }
    if (GetParent(np->hwndBuddy) != np->ci.hwndParent)
    {
#if defined(DEBUG) && !defined(WIN32)
        DebugOutput(DBF_ERROR | DBF_USER,
                    TEXT("UpDown: buddy has different parent; ")
                    TEXT("resetting to NULL"));
#endif
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
    }
}

// Picks a good buddy.
//
void NEAR PASCAL pickbuddy(PUDSTATE np)
{
    if (np->ci.style & UDS_AUTOBUDDY)
        np->hwndBuddy = GetWindow(np->ci.hwnd, GW_HWNDPREV);
}

void NEAR PASCAL unachor(PUDSTATE np)
{
    RECT rc;
    RECT rcBuddy;
    RECT rcUD;

    if ( np->hwndBuddy && (np->ci.style & (UDS_ALIGNLEFT | UDS_ALIGNRIGHT))) {
        GetWindowRect(np->hwndBuddy, &rcBuddy);
        GetWindowRect(np->ci.hwnd, &rcUD);
        UnionRect(&rc, &rcUD, &rcBuddy);
        MapWindowRect(NULL, np->ci.hwndParent, &rc);
        MoveWindow(np->hwndBuddy, rc.left, rc.top,
                                rc.right - rc.left, rc.bottom - rc.top, FALSE);

    }
}

// Anchor this control to the buddy's edge, if appropriate.
//
void NEAR PASCAL anchor(PUDSTATE np)
{
    BOOL bAlignToBuddy;
    int nOver = 0,  nHasBorder;
    RECT rc, rcBuddy;
    int nHeight, nWidth;

    np->fSharedBorder = FALSE;

    isgoodbuddy(np);
    nHasBorder = (np->ci.style & WS_BORDER) == WS_BORDER;

    bAlignToBuddy = np->hwndBuddy && (np->ci.style & (UDS_ALIGNLEFT | UDS_ALIGNRIGHT));

    if (bAlignToBuddy)
    {
        if ((np->uClass == CLASS_EDIT) ||
                (GetWindowLong(np->hwndBuddy, GWL_EXSTYLE) & WS_EX_CLIENTEDGE))
        {
            np->fSunkenBorder = TRUE;
        }

        GetWindowRect(np->hwndBuddy, &rc);

        if ((np->uClass == CLASS_EDIT) || (GetWindowLong(np->hwndBuddy, GWL_STYLE) & WS_BORDER))
        {
            // BUGBUG for full generalization, should handle border AND clientedge

            nOver = g_cxBorder * (np->fSunkenBorder ? 2 : 1);
            np->fSharedBorder = TRUE;

            // turn off border styles...
            np->ci.style &= ~WS_BORDER;

            SetWindowLong(np->ci.hwnd, GWL_STYLE, np->ci.style);
            SetWindowLong(np->ci.hwnd, GWL_EXSTYLE, GetWindowLong(np->ci.hwnd, GWL_EXSTYLE) & ~(WS_EX_CLIENTEDGE));
        }
    }
    else
    {
        GetWindowRect(np->ci.hwnd, &rc);
    }

    nHeight = rc.bottom - rc.top;
    nWidth = rc.right - rc.left;

    //
    // If the parent is RTL mirrored, then placement of the
    // child (i.e. anchor point) should be relative to the visual 
    // right edge (near edge). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(np->ci.hwndParent))
    {
        rc.left = rc.right;
    }

    ScreenToClient(np->ci.hwndParent, (LPPOINT)&rc.left);
    rc.right = rc.left + nWidth;

    if (bAlignToBuddy)
    {
        nWidth = g_cxVScroll - g_cxBorder;
        if (nWidth > nHeight) {             // don't let the aspect ratio
            nWidth = nHeight;               // get worse than square
        }
        nWidth += nOver;
        rcBuddy = rc;

        if (np->ci.style & UDS_ALIGNLEFT)
        {
            // size buddy to right
            rcBuddy.left += nWidth - nOver;
            rc.right = rc.left + nWidth;
        }
        else
        {
            // size buddy to left
            rcBuddy.right -= nWidth - nOver;
            rc.left = rc.right - nWidth;
        }
        // size the buddy to fit the updown on the appropriate side
        MoveWindow(np->hwndBuddy, rcBuddy.left, rcBuddy.top,
                                rcBuddy.right - rcBuddy.left, nHeight, TRUE);
    }
    else if (!(np->ci.style & UDS_HORZ))
    {
        nWidth = g_cxVScroll + 2 * nHasBorder;
    }

    SetWindowPos(np->ci.hwnd, NULL, rc.left, rc.top, nWidth, nHeight,
        SWP_DRAWFRAME | SWP_NOZORDER | SWP_NOACTIVATE);
}


// Use this to make any and all comparisons involving the nPos,
// nUpper or nLower fields of the PUDSTATE. It determines
// whether to do a signed or unsigned comparison and returns
//  > 0 for (x > y)
//  < 0 for (x < y)
// == 0 for (x == y).
//
// fCompareType is SIGNED to force a signed comparison,
// fCompareType is UNSIGNED to force an unsigned comparison,
// fCompareType is DONTCARE to use the np->fUnsigned flag to decide.
//
// In comments, comparison operators are suffixed with "D", "U" or "S"
// to emphasize whether the comparison is DONTCARE, UNSIGNED, or SIGNED.
// For example "x <U y" means "x < y as UNSIGNED".

int NEAR PASCAL compare(PUDSTATE np, int x, int y, UINT fCompareType)
{
    if ((fCompareType == UNSIGNED) || ((np->fUnsigned) && !(fCompareType == SIGNED)) )
    {
        // Do unsigned comparisons
        if ((UINT)x > (UINT)y)
            return 1;
        else if ((UINT)x < (UINT)y)
            return -1;
    }
    else
    {
        // Do signed comparisons
        if (x > y)
            return 1;
        else if (x < y)
            return -1;
    }

    return 0;
}

// Use this after any pos change to make sure pos stays in range.
// Wraps as necessary.
// returns nonzero if the current value was out of range (and therefore
// got changed so it fit into range again)
//
// BUGBUG -- doesn't handle values that exceed MAXINT or MININT.

BOOL NEAR PASCAL nudge(PUDSTATE np)
{
    BOOL bOutOfRange = TRUE;
    int min = np->nUpper;
    int max = np->nLower;

    // if (max <D min) swap(min, max)
    if (compare(np,max,min, DONTCARE) < 0)
    {
        int t;
        t = min;
        min = max;
        max = t;
    }


    if (np->ci.style & UDS_WRAP)
    {
        // if (nPos <D min) nPos = max      -- wrap from below to above
        // else if (nPos >D max) nPos = min -- wrap from above to below

        if ((compare(np, np->nPos, min, DONTCARE) < 0))
            np->nPos = max;
        else if ((compare(np, np->nPos, max, DONTCARE) > 0))
            np->nPos = min;
        else bOutOfRange = FALSE;
    }
    else
    {
        // if (nPos <D min) nPos = min      -- pin at min
        // else if (nPos >D max) nPos = max -- pin at max

        if (compare(np,np->nPos,min, DONTCARE) < 0)
            np->nPos = min;
        else if (compare(np,np->nPos,max, DONTCARE) > 0)
            np->nPos = max;
        else
            bOutOfRange = FALSE;
    }

    return(bOutOfRange);
}

// Sets the state of the buttons (pushed, released).
//
void NEAR PASCAL squish(PUDSTATE np, UINT bTop, UINT bBottom)
{
    BOOL bInvalidate = FALSE;

    if (np->nUpper == np->nLower || !IsWindowEnabled(np->ci.hwnd))
    {
        bTop = FALSE;
        bBottom = FALSE;
    }
    else
    {
        bTop = !!bTop;
        bBottom = !!bBottom;
    }

    if (np->fUp != bTop)
    {
        np->fUp = bTop;
        bInvalidate = TRUE;

        MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, np->ci.hwnd, OBJID_CLIENT, 1);
    }

    if (np->fDown != bBottom)
    {
        np->fDown = bBottom;
        bInvalidate = TRUE;

        MyNotifyWinEvent(EVENT_OBJECT_STATECHANGE, np->ci.hwnd, OBJID_CLIENT, 2);
    }

    if (bInvalidate)
    {
        np->dwStart = GetTickCount();
        InvalidateRect(np->ci.hwnd, NULL, FALSE);
    }
}

// Gets the intl 1000 separator
//
void NEAR PASCAL getthousands(LPTSTR pszThousand)
{
#ifdef WIN32
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, pszThousand, 2))
    {
        pszThousand[0] = TEXT(',');
        pszThousand[1] = TEXT('\0');
    }
#else
    static DWORD uLast = 0;
    static TCHAR cThou;
    DWORD uNow;

    /* Only check the intl setting every 5 seconds.
     */
    uNow = GetTickCount();
    if (uNow - uLast > 5000)
    {
        if (!GetProfileString(TEXT("intl"), TEXT("sThousand"), pszThousand, pszThousand, 2))
        {
            pszThousand[0] = TEXT(',');
            pszThousand[1] = TEXT('\0');
        }
        cThou = pszThousand[0];
        uLast = uNow;
    }
    else
    {
        pszThousand[0] = cThou;
        pszThousand[1] = 0;
    }

#endif
}

//
//  Obtain NLS info about how numbers should be grouped.
//
//  The annoying thing is that LOCALE_SGROUPING and NUMBERFORMAT
//  have different ways of specifying number grouping.
//
//          LOCALE      NUMBERFMT      Sample   Country
//
//          3;0         3           1,234,567   United States
//          3;2;0       32          12,34,567   India
//          3           30           1234,567   ??
//
//  Not my idea.  That's the way it works.
//
//  Bonus treat - Win9x doesn't support complex number formats,
//  so we return only the first number.
//
UINT getgrouping(void)
{
    UINT grouping;
    LPTSTR psz;
    TCHAR szGrouping[32];

    // If no locale info, then assume Western style thousands
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, ARRAYSIZE(szGrouping)))
        return 3;

    grouping = 0;
    psz = szGrouping;
#ifdef WINNT
    for (;;)
    {
        if (*psz == '0') break;             // zero - stop

        else if ((UINT)(*psz - '0') < 10)   // digit - accumulate it
            grouping = grouping * 10 + (UINT)(*psz - '0');

        else if (*psz)                      // punctuation - ignore it
            { }

        else                                // end of string, no "0" found
        {
            grouping = grouping * 10;       // put zero on end (see examples)
            break;                          // and finished
        }

        psz++;
    }
#else
    // Win9x - take only the first grouping
    grouping = StrToInt(szGrouping);
#endif

    return grouping;
}

// Gets the caption of the buddy
// Returns the current position of the updown control
// and sets *pfError on error.
//
LRESULT NEAR PASCAL getint(PUDSTATE np, BOOL *pfError)
{
    TCHAR szInt[MAX_INTLENGTH]; // big enough for all intl stuff, too
    TCHAR szThousand[2];
    TCHAR cTemp;
    int nPos;
    int sign = 1;
    LPTSTR p = szInt;
    BOOL bInValid = TRUE;

    isgoodbuddy(np);
    if (np->hwndBuddy && np->ci.style & UDS_SETBUDDYINT)
    {
        if (np->uClass == CLASS_LISTBOX)
        {
            np->nPos = (int)SendMessage(np->hwndBuddy, LB_GETCURSEL, 0, 0L);
            bInValid = nudge(np);
        }
        else
        {
            GetWindowText(np->hwndBuddy, szInt, ARRAYSIZE(szInt));

            switch (np->nBase)
            {
                case BASE_HEX:
                    if ((*p == TEXT('x')) || (*p == TEXT('X')))
                        // ignore first character
                        p++;
                    else if ((*p == TEXT('0')) && ((*(p + 1) == TEXT('x')) || (*(p + 1) == TEXT('X'))))
                        // ignore first two characters (TEXT("0x") or "0X")
                        p += 2;

                    for (nPos = 0; *p; p++)
                    {
                        if ((*p >= TEXT('A')) && (*p <= TEXT('F')))
                            cTemp = (TCHAR)(*p - TEXT('A') + 10);
                        else if ((*p >= TEXT('a')) && (*p <= TEXT('f')))
                            cTemp = (TCHAR)(*p - TEXT('a') + 10);
                        else if ((*p >= TEXT('0')) && (*p <= TEXT('9')))
                            cTemp = (TCHAR)(*p - TEXT('0'));
                        else
                            goto BadValue;

                        nPos = (nPos * 16) + cTemp;
                    }
                    np->nPos = nPos;
                    break;

                case BASE_DECIMAL:
        default:
                    getthousands(szThousand);
                    if (*p == TEXT('-') && !np->fUnsigned)
                    {
                        sign = -1;
                        ++p;
                    }

                    for (nPos=0; *p; p++)
                    {
                        cTemp = *p;

                        // If there is a thousand separator, just ignore it.
                        // Do not validate that it's in the right place,
                        // because it prevents the user from editing the
                        // middle of a number.
                        if (cTemp == szThousand[0])
                        {
                            continue;
                        }

                        cTemp -= TEXT('0');
                        if ((UINT)cTemp > 9)
                        {
                            goto BadValue;
                        }
                        nPos = (nPos*10) + cTemp;
                    }

                    np->nPos = nPos*sign;
                    break;
            }
            bInValid = nudge(np);
        }
    }

BadValue:
    if (pfError)
        *pfError = bInValid;
    return np->nPos;
}

// Sets the caption of the buddy if appropriate.
//
void NEAR PASCAL setint(PUDSTATE np)
{
    TCHAR szInt[MAX_INTLENGTH];
    TCHAR szThousand[2];
    int pos = np->nPos;
    LPTSTR p = szInt;

    isgoodbuddy(np);
    if (np->hwndBuddy && np->ci.style & UDS_SETBUDDYINT)
    {
        BOOL fError;
        /*
         * If we have reentered, then maybe the app has set up a loop.
         * Check to see if the value has actually changed.  If not,
         * then there's no need to set it again.  This breaks the
         * recursion.
         */
        if (np->cReenterSetint && (LRESULT)pos==getint(np, &fError) && !fError)
        {
            return;
        }
        np->nPos = pos;

        np->cReenterSetint++;

        if (np->uClass == CLASS_LISTBOX)
        {
            SendMessage(np->hwndBuddy, LB_SETCURSEL, pos, 0L);
            FORWARD_WM_COMMAND(GetParent(np->hwndBuddy),
                                GetDlgCtrlID(np->hwndBuddy),
                np->hwndBuddy, LBN_SELCHANGE, SendMessage);
        }
        else
        {
            switch (np->nBase)
            {
                case BASE_HEX:

                    if ((np->nUpper | np->nLower) >= 0x00010000)
                        wsprintf(p, TEXT("0x%08X"), pos);
                    else
                        wsprintf(p, TEXT("0x%04X"), pos);
                    break;

                case BASE_DECIMAL:
        default:
                    if (pos < 0 && !np->fUnsigned)
                    {
                        *p++ = TEXT('-');
                        pos = -pos;
                    }

                    if (pos >= 1000 && !(np->ci.style & UDS_NOTHOUSANDS))
                    {
                        TCHAR szFmt[MAX_INTLENGTH];
                        NUMBERFMT nf;
                        nf.NumDigits = 0;   // no digits after decimal point
                        nf.LeadingZero = 0; // no leading zeros
                        nf.Grouping = getgrouping();
                        nf.lpDecimalSep = TEXT(""); // no decimal point
                        nf.lpThousandSep = szThousand;
                        nf.NegativeOrder = 0; // (not used - we always pass positive numbers)
                        getthousands(szThousand);
                        wsprintf(szFmt, TEXT("%u"), pos);
                        GetNumberFormat(LOCALE_USER_DEFAULT, 0, szFmt, &nf, p, MAX_INTLENGTH - 1);
                    }
                    else
                    {
                        wsprintf(p, TEXT("%u"), pos);
                    }
                    break;
            }

            SetWindowText(np->hwndBuddy, szInt);
        }

        np->cReenterSetint;
    }
}

// Use this to click the pos up or down by one.
//
void NEAR PASCAL bump(PUDSTATE np)
{
    BOOL bChanged = FALSE;
    UINT uElapsed, increment;
    int direction, i;

    /* So I'm not really getting seconds here; it's close enough, and
     * dividing by 1024 keeps __aFuldiv from being needed.
     */
    uElapsed = (UINT)((GetTickCount() - np->dwStart) / 1024);

    increment = np->udAccel[0].nInc;
    for (i=np->nAccel-1; i>=0; --i)
    {
        if (np->udAccel[i].nSec <= uElapsed)
        {
            increment = np->udAccel[i].nInc;
            break;
        }
    }

    if (increment == 0)
    {
        DebugMsg(DM_ERROR, TEXT("bad accelerator value"));
        return;
    }

    direction = compare(np,np->nUpper,np->nLower, DONTCARE) < 0 ? -1 : 1;
    if (np->fUp)
    {
        bChanged = TRUE;
    }
    if (np->fDown)
    {
        direction = -direction;
        bChanged = TRUE;
    }

    if (bChanged)
    {
        /* Make sure we have a multiple of the increment
         * Note that we should loop only when the increment changes
         */
        NM_UPDOWN nm;

        nm.iPos = np->nPos;
        nm.iDelta = increment*direction;
        if (CCSendNotify(&np->ci, UDN_DELTAPOS, &nm.hdr))
            return;

        np->nPos += nm.iDelta;
        for ( ; ; )
        {
            if (!((int)np->nPos % (int)increment))
            {
                break;
            }
            np->nPos += direction;
        }

        nudge(np);
        setint(np);
        if (np->ci.style & UDS_HORZ)
            FORWARD_WM_HSCROLL(np->ci.hwndParent, np->ci.hwnd, SB_THUMBPOSITION, np->nPos, SendMessage);
        else
            FORWARD_WM_VSCROLL(np->ci.hwndParent, np->ci.hwnd, SB_THUMBPOSITION, np->nPos, SendMessage);

        MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, np->ci.hwnd, OBJID_CLIENT, 0);
    }
}

//#pragma data_seg(DATASEG_READONLY)
const TCHAR c_szListbox[] = TEXT("listbox");
//#pragma data_seg()

// Sets the new buddy
//
LRESULT NEAR PASCAL setbuddy(PUDSTATE np, HWND hwndBuddy)
{
    HWND hOldBuddy;
    TCHAR szClName[10];

    hOldBuddy = np->hwndBuddy;

    if ((np->hwndBuddy = hwndBuddy) == NULL)
    {
        pickbuddy(np);
        hwndBuddy = np->hwndBuddy;
    }

    if ((hOldBuddy != hwndBuddy) && np->fSubclassed)
    {
        ASSERT(hOldBuddy);
        RemoveWindowSubclass(hOldBuddy, ArrowKeyProc, 0);
        np->fSubclassed = FALSE;
    }

    np->uClass = CLASS_UNKNOWN;
    if (hwndBuddy)
    {
        if (np->ci.style & UDS_ARROWKEYS)
        {
            np->fSubclassed = TRUE;
            SetWindowSubclass(hwndBuddy, ArrowKeyProc, 0, (ULONG_PTR)np);
        }

        GetClassName(hwndBuddy, szClName, ARRAYSIZE(szClName));
        if (!lstrcmpi(szClName, c_szEdit))
        {
            np->uClass = CLASS_EDIT;
        }
        else if (!lstrcmpi(szClName, c_szListbox))
        {
            np->uClass = CLASS_LISTBOX;
        }
    }

    anchor(np);
    return (LRESULT)hOldBuddy;
}


// Paint the whole control
//
void NEAR PASCAL PaintUpDownControl(PUDSTATE np, HDC hdc)
{
    UINT uFlags;
    PAINTSTRUCT ps;
    RECT rcBtn;
    RECT rc;

    BOOL bEnabled = (np->nUpper != np->nLower) && IsWindowEnabled(np->ci.hwnd);

    if (np->hwndBuddy)
        bEnabled = bEnabled && IsWindowEnabled(np->hwndBuddy);

    if (hdc)
        ps.hdc = hdc;
    else
        BeginPaint(np->ci.hwnd, &ps);

    GetClientRect(np->ci.hwnd, &rcBtn);

    // if we are autobuddy'd and anchored to a sunken-edge control, we draw the
    // "nonclient" area of ourselves to blend in with our buddy.
    if (np->fSharedBorder && np->fSunkenBorder)
    {
        UINT bf = BF_TOP | BF_BOTTOM | BF_ADJUST |
            (np->ci.style & UDS_ALIGNLEFT ? BF_LEFT : 0) |
            (np->ci.style & UDS_ALIGNRIGHT ? BF_RIGHT : 0);
        DrawEdge(ps.hdc, &rcBtn, EDGE_SUNKEN, bf);
    }

    // with remaining space, draw appropriate scrollbar arrow controls in
    // upper and lower halves

    rc = rcBtn;
    if (np->ci.style & UDS_HORZ)
    {

        uFlags = DFCS_SCROLLLEFT;
        if (np->fDown)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITDOWN)
                uFlags |= DFCS_HOT;
        }
        
        // Horizontal ones
        rc.right = (rcBtn.right + rcBtn.left) / 2;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL,
                         uFlags);

        uFlags = DFCS_SCROLLRIGHT;
        if (np->fUp)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITUP)
                uFlags |= DFCS_HOT;
        }

        rc.left = rcBtn.right - (rc.right - rc.left); // handles odd-x case, too
        rc.right = rcBtn.right;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, uFlags);
    }
    else
    {
        uFlags = DFCS_SCROLLUP;
        if (np->fUp)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITUP)
                uFlags |= DFCS_HOT;
        }

        rc.bottom = (rcBtn.bottom + rcBtn.top) / 2;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL, uFlags);

        uFlags = DFCS_SCROLLDOWN;
        if (np->fDown)
            uFlags |= DFCS_PUSHED;
        if (!bEnabled)
            uFlags |= DFCS_INACTIVE;
            
        if (g_bRunOnNT5 || g_bRunOnMemphis)
        {
            if (np->uHot == UD_HITDOWN)
                uFlags |= DFCS_HOT;
        }

        rc.top = rcBtn.bottom - (rc.bottom - rc.top); // handles odd-y case, too
        rc.bottom = rcBtn.bottom;
        DrawFrameControl(ps.hdc, &rc, DFC_SCROLL,
                         uFlags);
    }

    if (hdc == NULL)
        EndPaint(np->ci.hwnd, &ps);
}


LRESULT CALLBACK ArrowKeyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    PUDSTATE    np = (PUDSTATE)dwRefData;
    int         cDetants;

    switch (uMsg)
    {
    case WM_NCDESTROY:
        RemoveWindowSubclass(hWnd, ArrowKeyProc, 0);
        np->fSubclassed = FALSE;
        np->hwndBuddy = NULL;
        if (np->fUpDownDestroyed)
        {
            // The buddy was destroyed after updown so free the memory now
            // And pass off to the message to who we subclassed...
            LocalFree((HLOCAL)np);
        }
        break;

    case WM_GETDLGCODE:
        return (DefSubclassProc(hWnd, uMsg, wParam, lParam) | DLGC_WANTARROWS);

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            if (GetCapture() != np->ci.hwnd)
            {
                /* Get the value from the buddy if this is the first key down
                 */
                if (!(lParam&(1L<<30)))
                {
                    getint(np, NULL);
                }

                /* Update the visuals and bump the value
                 */
                np->bDown = (wParam == VK_DOWN);
                squish(np, !np->bDown, np->bDown);
                bump(np);
#ifdef KEYBOARDCUES
                //notify of navigation key usage
                CCNotifyNavigationKeyUsage(&(np->ci), UISF_HIDEFOCUS);
#endif
            }
            return(0L);

        default:
            break;
        }
        break;

    case WM_KEYUP:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            if (GetCapture() != np->ci.hwnd)
            {
                squish(np, FALSE, FALSE);
            }
            return(0L);

        default:
            break;
        }
        break;

        // this is dumb.
        // wm_char's aren't sent for arrow commands..
        // what you're really eating here is & and (.
#if 0
    case WM_CHAR:
        switch (wParam)
        {
        case VK_UP:
        case VK_DOWN:
            return(0L);

        default:
            break;
        }
        break;
#endif

    case WM_KILLFOCUS:
        // Reset wheel scroll amount
        gcWheelDelta = 0;
        break;

    case WM_SETFOCUS:
        ASSERT(gcWheelDelta == 0);
        break;

    default:
        if (uMsg == g_msgMSWheel && GetCapture() != np->ci.hwnd) {

            int iWheelDelta;

            if (g_bRunOnNT || g_bRunOnMemphis)
            {
                iWheelDelta = (int)(short)HIWORD(wParam);
            }
            else
            {
                iWheelDelta = (int)wParam;
            }

            // Update count of scroll amount
            gcWheelDelta -= iWheelDelta;
            cDetants = gcWheelDelta / WHEEL_DELTA;

            if (cDetants != 0) {
                gcWheelDelta %= WHEEL_DELTA;

                if (g_bRunOnNT || g_bRunOnMemphis)
                {
                    if (wParam & (MK_SHIFT | MK_CONTROL))
                        break;
                }
                else
                {
                    if (GetKeyState(VK_SHIFT) < 0 || GetKeyState(VK_CONTROL) < 0)
                        break;
                }

                getint(np, NULL);
                np->bDown = (cDetants > 0);
                cDetants = abs(cDetants);
                while (cDetants-- > 0) {
                    squish(np, !np->bDown, np->bDown);
                    bump(np);
                }
                squish(np, FALSE, FALSE);
            }

            return 1;
        }

        break;
    }

    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}

UINT NEAR PASCAL setbase(PUDSTATE np, UINT wNewBase)
{
    UINT wOldBase;

    switch (wNewBase)
    {
        case BASE_DECIMAL:
        case BASE_HEX:
            np->fUnsigned = (wNewBase != BASE_DECIMAL);
            wOldBase = np->nBase;
            np->nBase = wNewBase;
            setint(np);
            return wOldBase;
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////

HWND WINAPI CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hwndBuddy, int nUpper, int nLower, int nPos)
{
    HWND hWnd = CreateWindow(s_szUpdownClass, NULL, dwStyle, x, y, cx, cy,
                             hParent, IntToPtr_(HMENU, nID), hInst, 0L);
    if (hWnd)
    {
        SendMessage(hWnd, UDM_SETBUDDY, (WPARAM)hwndBuddy, 0L);
        SendMessage(hWnd, UDM_SETRANGE, 0, MAKELONG(nUpper, nLower));
        SendMessage(hWnd, UDM_SETPOS, 0, MAKELONG(nPos, 0));
    }
    return hWnd;
}

UINT UD_HitTest(PUDSTATE np, int x, int y)
{
    RECT rc;

    GetClientRect(np->ci.hwnd, &rc);
    if (np->ci.style & UDS_HORZ)
    {
        // Horizontal placement
        if (x < (rc.right / 2))
        {
            return UD_HITDOWN;
        }
        else if (x > (rc.right / 2))
        {
            return UD_HITUP;
        }
    }
    else
    {
        if (y > (rc.bottom / 2))
        {
            return UD_HITDOWN;
        }
        else if (y < (rc.bottom / 2))
        {
            return UD_HITUP;
        }
    }

    return UD_HITNOWHERE;
}

void UD_Invalidate(PUDSTATE np, UINT uWhich, BOOL fErase)
{
    int iMid;
    RECT rc;

    GetClientRect(np->ci.hwnd, &rc);
    if (np->ci.style & UDS_HORZ)
    {
        iMid = rc.right / 2;
        if (uWhich == UD_HITDOWN) {
            rc.right = iMid;
        } else if (uWhich == UD_HITUP) {
            rc.left = iMid;
        } else
            return;
    }
    else
    {
        iMid = rc.bottom /2;
        if (uWhich == UD_HITDOWN) {
            rc.top = iMid;
        } else if (uWhich == UD_HITUP){
            rc.bottom = iMid;
        } else
            return;
    }

    InvalidateRect(np->ci.hwnd, &rc, fErase);
}

void UD_OnMouseMove(PUDSTATE np, DWORD dwPos)
{
    if (np->ci.style & UDS_HOTTRACK) {

        UINT uHot = UD_HitTest(np, GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos));

        if (uHot != np->uHot) {
            UD_Invalidate(np, np->uHot, FALSE);
            UD_Invalidate(np, uHot, FALSE);
            np->uHot = uHot;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////

// UpDownWndProc:
//
LRESULT CALLBACK UpDownWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    int i;
    BOOL f;
    LRESULT lres;
    PUDSTATE np = GetWindowPtr(hwnd, 0);

    if (np) {
        if ((uMsg >= WM_MOUSEFIRST) && (uMsg <= WM_MOUSELAST) &&
            (np->ci.style & UDS_HOTTRACK) && !np->fTrackSet) {

            TRACKMOUSEEVENT tme;

            np->fTrackSet = TRUE;

            tme.cbSize = sizeof(tme);
            tme.hwndTrack = np->ci.hwnd;
            tme.dwFlags = TME_LEAVE;

            TrackMouseEvent(&tme);
        }
    } else if (uMsg != WM_CREATE)
        goto DoDefault;

    switch (uMsg)
    {

    case WM_MOUSEMOVE:
        UD_OnMouseMove(np, (DWORD) lParam);
        break;

    case WM_MOUSELEAVE:
        np->fTrackSet = FALSE;
        UD_Invalidate(np, np->uHot, FALSE);
        np->uHot = UD_HITNOWHERE;
        break;

    case WM_LBUTTONDOWN:
    {
        // Don't set a timer if on the middle border
        BOOL bTimeIt = TRUE;

        if (np->hwndBuddy && !IsWindowEnabled(np->hwndBuddy))
            break;

        SetCapture(hwnd);
        getint(np, NULL);

        switch (np->uClass)
        {
        case CLASS_EDIT:
        case CLASS_LISTBOX:
            SetFocus(np->hwndBuddy);
            break;
        }

        switch(UD_HitTest(np, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))) {
        case UD_HITDOWN:
            np->bDown = TRUE;
            squish(np, FALSE, TRUE);
            break;

        case UD_HITUP:
            np->bDown = FALSE;
            squish(np, TRUE, FALSE);
            break;

        case UD_HITNOWHERE:
            bTimeIt = FALSE;
            break;
        }

        if (bTimeIt)
        {
            SetTimer(hwnd, 1, GetProfileInt(TEXT("windows"), TEXT("CursorBlinkRate"), 530), NULL);
            bump(np);
        }
        break;
    }

    case WM_TIMER:
    {
        POINT pt;

        if (GetCapture() != hwnd)
        {
            goto EndScroll;
        }

        SetTimer(hwnd, 1, 100, NULL);

        GetWindowRect(hwnd, &rc);
        if (np->ci.style & UDS_HORZ) {
            i = (rc.left + rc.right) / 2;
            if (np->bDown)
            {
                rc.right = i;
            }
            else
            {
                rc.left = i;
            }
        } else {
            i = (rc.top + rc.bottom) / 2;
            if (np->bDown)
            {
                rc.top = i;
            }
            else
            {
                rc.bottom = i;
            }
        }
        InflateRect(&rc, (g_cxFrame+1)/2, (g_cyFrame+1)/2);
        GetCursorPos(&pt);
        if (PtInRect(&rc, pt))
        {
            squish(np, !np->bDown, np->bDown);
            bump(np);
        }
        else
        {
            squish(np, FALSE, FALSE);
        }
        break;
    }

    case WM_LBUTTONUP:
        if (np->hwndBuddy && !IsWindowEnabled(np->hwndBuddy))
            break;

        if (GetCapture() == hwnd)
        {
EndScroll:
            squish(np, FALSE, FALSE);
            // We cannot call CCReleaseCapture() here, because it busts a lot of apps.
            ReleaseCapture();
            KillTimer(hwnd, 1);

            if (np->uClass == CLASS_EDIT)
                Edit_SetSel(np->hwndBuddy, 0, -1);

                        if (np->ci.style & UDS_HORZ)
                            FORWARD_WM_HSCROLL(np->ci.hwndParent, np->ci.hwnd,
                                      SB_ENDSCROLL, np->nPos, SendMessage);
                        else
                            FORWARD_WM_VSCROLL(np->ci.hwndParent, np->ci.hwnd,
                                      SB_ENDSCROLL, np->nPos, SendMessage);
        }
        break;

    case WM_ENABLE:
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_WININICHANGE:
        if (np && (!wParam ||
            (wParam == SPI_SETNONCLIENTMETRICS) ||
            (wParam == SPI_SETICONTITLELOGFONT))) {
            InitGlobalMetrics(wParam);
            unachor(np);
            anchor(np);
        }
        break;

    case WM_PRINTCLIENT:
    case WM_PAINT:
        PaintUpDownControl(np, (HDC)wParam);
        break;

#ifdef KEYBOARDCUES
    case WM_UPDATEUISTATE:
        //not sure need to set bit, will probably not use it, on the other hand this
        //  is consistent with remaining of common controls and not very expensive
        CCOnUIState(&(np->ci), WM_UPDATEUISTATE, wParam, lParam);

        goto DoDefault;
#endif
    case UDM_SETRANGE:
        np->nUpper = GET_X_LPARAM(lParam);
        np->nLower = GET_Y_LPARAM(lParam);
        nudge(np);
        break;
        
    case UDM_SETRANGE32:
        np->nUpper = (int)lParam;
        np->nLower = (int)wParam;
        break;
        
    case UDM_GETRANGE32:
        if (lParam) {
            *((LPINT)lParam) = np->nUpper;
        }
        if (wParam) {
            *((LPINT)wParam) = np->nLower;
        }
        break;
        
    case UDM_GETRANGE:
        return MAKELONG(np->nUpper, np->nLower);

    case UDM_SETBASE:
        // wParam: new base
        // lParam: not used
        // return: 0 if invalid base is specified,
        //         previous base otherwise
        return (LRESULT)setbase(np, (UINT)wParam);

    case UDM_GETBASE:
        return np->nBase;

    case UDM_SETPOS:
        lParam = GET_X_LPARAM(lParam);
        // FALL THROUGH

    case UDM_SETPOS32:
    {
        int iNewPos = (int)lParam;
        if (compare(np, np->nLower, np->nUpper, DONTCARE) < 0) {

            if (compare(np, iNewPos, np->nUpper, DONTCARE) > 0) {
                iNewPos = np->nUpper;
            }

            if (compare(np, iNewPos, np->nLower, DONTCARE) < 0) {
                iNewPos = np->nLower;
            }
        } else {
            if (compare(np, iNewPos, np->nUpper, DONTCARE) < 0) {
                iNewPos = np->nUpper;
            }

            if (compare(np, iNewPos, np->nLower, DONTCARE) > 0) {
                iNewPos = np->nLower;
            }
        }

        i = np->nPos;
        np->nPos = iNewPos;
        setint(np);
        MyNotifyWinEvent(EVENT_OBJECT_VALUECHANGE, np->ci.hwnd, OBJID_CLIENT, 0);
        return (LRESULT)i;
    }

    case UDM_GETPOS:
        lres = getint(np, &f);
        return MAKELRESULT(lres, f);

    case UDM_GETPOS32:
        return getint(np, (BOOL *)lParam);

    case UDM_SETBUDDY:
        return setbuddy(np, (HWND)wParam);

    case UDM_GETBUDDY:
        return (LRESULT)np->hwndBuddy;

    case UDM_SETACCEL:
            if (wParam == 0)
                return(FALSE);
            if (wParam >= NUM_UDACCELS)
            {
                HANDLE npPrev = (HANDLE)np;
                np = (PUDSTATE)LocalReAlloc((HLOCAL)npPrev, sizeof(UDSTATE)+(wParam-NUM_UDACCELS)*sizeof(UDACCEL),
                    LMEM_MOVEABLE);
                if (!np)
                {
                    return(FALSE);
                }
                else
                {
                    SetWindowPtr(hwnd, 0, np);

                    if ((np->ci.style & UDS_ARROWKEYS) && np->hwndBuddy)
                    {
                        np->fSubclassed = TRUE;
                        SetWindowSubclass(np->hwndBuddy, ArrowKeyProc, 0,
                            (ULONG_PTR)np);
                    }
                }
            }

            np->nAccel = (UINT) wParam;
        for (i=0; i<(int)wParam; ++i)
        {
                np->udAccel[i] = ((LPUDACCEL)lParam)[i];
        }
        return(TRUE);

    case UDM_GETACCEL:
        if (wParam > np->nAccel)
        {
            wParam = np->nAccel;
        }
        for (i=0; i<(int)wParam; ++i)
        {
            ((LPUDACCEL)lParam)[i] = np->udAccel[i];
        }
        return(np->nAccel);

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&np->ci, lParam);

    case WM_CREATE:
        CCCreateWindow();
        // Allocate the instance data space.
        np = (PUDSTATE)LocalAlloc(LPTR, sizeof(UDSTATE));
        if (!np)
            return -1;

        SetWindowPtr(hwnd, 0, np);

            #define lpCreate ((CREATESTRUCT FAR *)lParam)

        CIInitialize(&np->ci, hwnd, lpCreate);

        // np->fUp =
        // np->fDown =
            // np->fUnsigned =
            // np->fSharedBorder =
            // np->fSunkenBorder =
        //  FALSE;

        if (lpCreate->style & UDS_UNSIGNED)
            np->fUnsigned = TRUE;

        if (lpCreate->dwExStyle & WS_EX_CLIENTEDGE)
            np->fSunkenBorder = TRUE;

        np->nBase = BASE_DECIMAL;
        np->nUpper = 0;
        np->nLower = 100;
        np->nPos = 0;
        np->hwndBuddy = NULL;
        np->uClass = CLASS_UNKNOWN;
        ASSERT(np->cReenterSetint == 0);

            np->nAccel = NUM_UDACCELS;
            np->udAccel[0].nSec = 0;
            np->udAccel[0].nInc = 1;
        np->udAccel[1].nSec = 2;
            np->udAccel[1].nInc = 5;
            np->udAccel[2].nSec = 5;
            np->udAccel[2].nInc = 20;

        /* This does the pickbuddy and anchor
         */
        setbuddy(np, NULL);
        setint(np);
        break;

    case WM_DESTROY:
        CCDestroyWindow();
        if (np) {
            if (np->hwndBuddy)
            {
                //  Our buddy needs to be unsubclassed, which we'll do
                //  in response to WM_NCDESTROY;  doing so now would 
                //  bust any subsequent call to the suclass proc.
                DebugMsg(DM_TRACE, TEXT("UpDown Destroyed while buddy subclassed"));
                np->fUpDownDestroyed = TRUE;
            }
            else
                LocalFree((HLOCAL)np);
            SetWindowPtr(hwnd, 0, 0);
        }
        break;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_UPDOWN;
        goto DoDefault;

    default:
    {
        LRESULT lres;
        if (CCWndProc(&np->ci, uMsg, wParam, lParam, &lres))
            return lres;
    }

DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0L;
}

/////////////////////////////////////////////////////////////////////////////

// InitUpDownClass:
// Adds our WNDCLASS to the system.
//
#pragma code_seg(CODESEG_INIT)

BOOL FAR PASCAL InitUpDownClass(HINSTANCE hInst)
{
    WNDCLASS wndclass;

        if (!GetClassInfo(hInst, s_szUpdownClass, &wndclass))
        {
#ifndef WIN32
            extern LRESULT CALLBACK _UpDownWndProc(HWND, UINT, WPARAM, LPARAM);
            wndclass.lpfnWndProc    = _UpDownWndProc;
#else
            wndclass.lpfnWndProc    = UpDownWndProc;
#endif
            wndclass.lpszClassName  = s_szUpdownClass;
            wndclass.hInstance  = hInst;
            wndclass.hCursor    = LoadCursor(NULL, IDC_ARROW);
            wndclass.hIcon      = NULL;
            wndclass.lpszMenuName   = NULL;
            wndclass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1);
            wndclass.style      = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
            wndclass.cbClsExtra = 0;
            wndclass.cbWndExtra = sizeof(PUDSTATE);

            return RegisterClass(&wndclass);
        }
        return TRUE;
}
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v5\usonly\makefile.inc ===
!include "..\makefile.inc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\blur.cpp ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"
#include <shfusion.h>

#define ARGB(a,r,g,b)          ((COLORREF)(( \
                         ((BYTE)(r))       | \
                 ((WORD) ((BYTE)(g))<< 8)) | \
                (((DWORD)((BYTE)(b))<<16)) | \
                (((DWORD)((BYTE)(a))<<24))))

#define PREMULTIPLY(c, alpha)  ((( ((c) * (alpha)) + 128) >> 8) + 1)


typedef struct tagCCBUFFER
{
    HDC hdc;
    HBITMAP hbmp;
    HBITMAP hbmpOld;
    RGBQUAD* prgb;
} CCBUFFER;

BOOL Buffer_CreateBuffer(HDC hdc, int cx, int cy, CCBUFFER* pbuf)
{
    BOOL fRet = FALSE;
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    pbuf->hdc = CreateCompatibleDC(hdc);
    if (pbuf->hdc)
    {
        pbuf->hbmp = CreateDIBSection(pbuf->hdc, &bi, DIB_RGB_COLORS, (VOID**)&pbuf->prgb, NULL, 0);
        if (!pbuf->hbmp)
        {
            DeleteDC(pbuf->hdc);
            ZeroMemory(pbuf, sizeof(CCBUFFER));
        }
        else
        {
            pbuf->hbmpOld = (HBITMAP)SelectObject(pbuf->hdc, pbuf->hbmp);
            fRet = TRUE;
        }
    }

    return fRet;
}

void Buffer_DestroyBuffer(CCBUFFER* pbuf)
{
    if (pbuf->hdc)
    {
        SelectObject(pbuf->hdc, pbuf->hbmpOld);
        DeleteDC(pbuf->hdc);
        DeleteObject(pbuf->hbmp);
    }
}
void BlurBitmapNormal(ULONG* prgb, int cx, int cy, COLORREF crFill)
{

    BYTE r = GetRValue(crFill);
    BYTE g = GetGValue(crFill);
    BYTE b = GetBValue(crFill);

    int cxMax = cx - 5;
    int cyMax = cy - 5;
    int iOffset;
    int y;
    for (y=0, iOffset = 0; y < cy; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        int Accum = ((*p)) +
                    ((*(p + 1))) +
                    ((*(p + 2))) +
                    ((*(p + 3)));

        for (int x=0; x< cxMax; x++)
        {
            Accum = Accum - ((*p)) + ((*(p + 4)));
            *p++ = (Accum >> 2);
        }
    }

    int cx2 = cx << 1;
    int cx3 = cx + cx + cx;
    int cx4 = cx << 2;

    for (iOffset = 0, y=0; y < cyMax; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        for (int x=0; x < cx; x++)
        {
            DWORD Alpha = (((*p)      ) +
                          (*(p + cx)  ) +
                          (*(p + cx2) ) +
                          (*(p + cx3) ) +
                          (*(p + cx4) )) >> 2;
            if (Alpha > 255)
                Alpha = 255;

            *p = (ULONG)ARGB(Alpha, PREMULTIPLY(r, Alpha), PREMULTIPLY(g, Alpha), PREMULTIPLY(b, Alpha));

            p++;
        }
    }
}

#ifdef _X86_

QWORD qw128 = 0x0000008000800080;
QWORD qw1   = 0x0000000100010001;

void BlurBitmapMMX(ULONG* prgb, int cx, int cy, COLORREF crFill)
{
    RGBQUAD rgbFill;                    // ColorRef is opposite of RGBQUAD
    rgbFill.rgbRed = GetRValue(crFill);
    rgbFill.rgbGreen = GetGValue(crFill);
    rgbFill.rgbBlue = GetBValue(crFill);

    int cxMax = cx - 5;
    int cyMax = cy - 5;
    int iOffset;
    int y;
    for (y=0, iOffset = 0; y < cy; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        int Accum = ((*p)) +
                    ((*(p + 1))) +
                    ((*(p + 2))) +
                    ((*(p + 3)));

        for (int x=0; x< cxMax; x++)
        {
            Accum = Accum - ((*p)) + ((*(p + 4)));
            *p++ = (Accum >> 2);
        }
    }

    int cx2 = cx << 1;
    int cx3 = cx + cx + cx;
    int cx4 = cx << 2;
    _asm
    {
        pxor mm0, mm0
        pxor mm1, mm1
        pxor mm5, mm5
        movd mm4, dword ptr [rgbFill]
        movq mm6, qw128                 // mm6 is filled with 128
        movq mm7, qw1                   // mm7 is filled with 1
    }

    for (iOffset = 0, y=0; y < cyMax; y++, iOffset += cx)
    {
        ULONG* p = &prgb[iOffset];
        for (int x=0; x < cx; x++)
        {
            DWORD Alpha = (((*p)      ) +
                          (*(p + cx)  ) +
                          (*(p + cx2) ) +
                          (*(p + cx3) ) +
                          (*(p + cx4) )) >> 2;
            if (Alpha > 255)
                Alpha = 255;

            *p = ((BYTE)Alpha);

        _asm
        {
            mov edx, dword ptr [p]
            mov ebx, dword ptr [edx]
            mov eax, ebx                    // a -> b
            or eax, eax
            jz EarlyOut
            shl ebx, 8                      // b << 8
            or eax, ebx                     // a |= b
            shl ebx, 8                      // b << 8
            or eax, ebx                     // a |= b
            shl ebx, 8                      // b << 8
                                            // Note high byte of alpha is zero.
            movd mm0, eax                   //  a -> mm0        
              movq mm1, mm4                    // Load the pixel
            punpcklbw mm0,mm5               //  mm0 -> Expands  <-   mm0 Contains the Alpha channel for this multiply

              punpcklbw mm1, mm5               // Unpack the pixel
            pmullw mm1, mm0                 // Multiply by the alpha channel <- mm1 contains c * alpha

            paddusw mm1, mm6                 // perform the (c * alpha) + 128
            psrlw mm1, 8                    // Divide by 255
            paddusw mm1, mm7                 // Add 1 to finish the divide by 255
            packuswb mm1, mm5

            movd eax, mm1
            or eax, ebx                     // Transfer alpha channel
EarlyOut:
            mov dword ptr [edx], eax
        }

            p++;
        }
    }

    _asm emms
}

void BlurBitmap(ULONG* plBitmapBits, int cx, int cy, COLORREF crFill)
{
    if (IsProcessorFeaturePresent(PF_MMX_INSTRUCTIONS_AVAILABLE))
        BlurBitmapMMX(plBitmapBits, cx, cy, crFill);
    else
        BlurBitmapNormal(plBitmapBits, cx, cy, crFill);
}

#else

void BlurBitmap(ULONG* plBitmapBits, int cx, int cy, COLORREF crFill)
{
    BlurBitmapNormal(plBitmapBits, cx, cy, crFill);
}

#endif


int DrawShadowText(HDC hdc, LPCTSTR pszText, UINT cch, RECT* prc, DWORD dwFlags, COLORREF crText, 
    COLORREF crShadow, int ixOffset, int iyOffset)
{
    int iRet = -1;
    if (dwFlags & DT_CALCRECT)
    {
        iRet = DrawText(hdc, pszText, cch, prc, dwFlags | DT_CALCRECT);
    }
    else
    {
        if (GetLayout(hdc) == LAYOUT_RTL)
        {
            COLORREF crTextSave = SetTextColor(hdc, crShadow);
            int iMode = SetBkMode(hdc, TRANSPARENT);
            RECT rc = *prc;
            OffsetRect(&rc, ixOffset, iyOffset);

            DrawText(hdc, pszText, cch, &rc, dwFlags);
            SetBkMode(hdc, iMode);
            SetTextColor(hdc, crTextSave);

        }
        else
        {
            RECT rc = *prc;
            CCBUFFER buf;

            int cx = RECTWIDTH(rc) + 10;
            int cy = RECTHEIGHT(rc) + 10;

            if (Buffer_CreateBuffer(hdc, cx, cy, &buf))
            {
                OffsetRect(&rc, 5, 5);
                RECT rcMem = {5, 5, RECTWIDTH(rc) + 5, RECTHEIGHT(rc) + 5};

                HFONT hFontOldhdc = (HFONT)SelectObject(hdc, GetStockObject(SYSTEM_FONT));
                HFONT hFontOldhdcMem = (HFONT)SelectObject(buf.hdc, hFontOldhdc);

                SetTextColor(buf.hdc, crText);
                SetBkColor(buf.hdc, crShadow);
                SetBkMode(buf.hdc, TRANSPARENT);

                DrawText(buf.hdc, pszText, cch, &rcMem, dwFlags);
                int Total = cx * cy;
                for (int z = 0; z < Total; z++)
                {
                    if (((PULONG)buf.prgb)[z] != 0)
                        ((PULONG)buf.prgb)[z] = 0x000000ff;
                }

                BlurBitmap((ULONG*)buf.prgb, cx, cy, crShadow);

                BLENDFUNCTION bf = {0};
                bf.BlendOp = AC_SRC_OVER;
                bf.SourceConstantAlpha = 255;
                bf.AlphaFormat = AC_SRC_ALPHA;
                GdiAlphaBlend(hdc, prc->left - 4 + ixOffset, prc->top - 8 + iyOffset, cx, cy, buf.hdc, 0, 0, cx, cy, bf);

                SelectObject(buf.hdc, hFontOldhdcMem);
                SelectObject(hdc, hFontOldhdc);

                Buffer_DestroyBuffer(&buf);
            }
        }

        int iMode = SetBkMode(hdc, TRANSPARENT);
        COLORREF crTextSave = SetTextColor(hdc, crText);
        iRet = DrawText(hdc, pszText, cch, prc, dwFlags);
        SetTextColor(hdc, crTextSave);
        SetBkMode(hdc, iMode);
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\bmimgctx.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  CBitmapImgCtx
//
//  Implement IImgCtx for drawing out of a bitmap
//
//  WARNING:  Incomplete implementation -- just barely enough to keep
//  listview happy.  Should not be exposed to anyone other than listview.
//
//////////////////////////////////////////////////////////////////////////


#include "ctlspriv.h"
#include <iimgctx.h>

class CBitmapImgCtx : public IImgCtx
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IImgCtx methods ***
    STDMETHODIMP Load(LPCWSTR pszUrl, DWORD dwFlags);
    STDMETHODIMP SelectChanges(ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal);
    STDMETHODIMP SetCallback(PFNIMGCTXCALLBACK pfn, void * pvPrivateData);
    STDMETHODIMP Disconnect();

    STDMETHODIMP GetUpdateRects(LPRECT prc, LPRECT prcImg, LPLONG pcrc);
    STDMETHODIMP GetStateInfo(PULONG pulState, LPSIZE psize, BOOL fClearChanges);
    STDMETHODIMP GetPalette(HPALETTE *phpal);

    STDMETHODIMP Draw(HDC hdc, LPRECT prcBounds);
    STDMETHODIMP Tile(HDC hdc, LPPOINT pptBackOrg, LPRECT prcClip, LPSIZE psize);
    STDMETHODIMP StretchBlt(HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP);

public:
    CBitmapImgCtx() : _cRef(1) { }
    BOOL Initialize(HBITMAP hbm);

protected:
    ~CBitmapImgCtx()
    {
        if (_hbr) DeleteObject(_hbr);
    }

    // Keep _cRef as first member so we can coalesce
    // with ILVRange's IUnknown implementation
    int         _cRef;

    HBRUSH      _hbr;                   // Bitmap pattern brush
    SIZE        _sizBmp;                // Size of original bitmap

    PFNIMGCTXCALLBACK _pfnCallback;
    LPVOID      _pvRefCallback;
};

STDAPI_(IImgCtx *) CBitmapImgCtx_Create(HBITMAP hbm)
{
    CBitmapImgCtx *pbic = new CBitmapImgCtx();
    if (pbic && !pbic->Initialize(hbm))
    {
        pbic->Release();
        pbic = NULL;
    }
    return pbic;
}

// CBitmapImgCtx::Initialize

BOOL CBitmapImgCtx::Initialize(HBITMAP hbm)
{
    BOOL fSuccess = FALSE;

    _hbr = CreatePatternBrush(hbm);
    if (_hbr)
    {
        BITMAP bm;
        if (GetObject(hbm, sizeof(bm), &bm))
        {
            _sizBmp.cx = bm.bmWidth;
            _sizBmp.cy = bm.bmHeight;
            fSuccess = TRUE;
        }
    }
    return fSuccess;
}

// IUnknown::QueryInterface

HRESULT CBitmapImgCtx::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_IImgCtx) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IImgCtx *);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

// IUnknown::AddRef

ULONG CBitmapImgCtx::AddRef()
{
    return ++_cRef;
}

// IUnknown::Release

ULONG CBitmapImgCtx::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

// IImgCtx::Load

HRESULT CBitmapImgCtx::Load(LPCWSTR pszUrl, DWORD dwFlags)
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}

// IImgCtx::SelectChanges

HRESULT CBitmapImgCtx::SelectChanges(ULONG ulChgOn, ULONG ulChgOff, BOOL fSignal)
{
    // Listview always calls with exactly these parameters
    ASSERT(ulChgOn == IMGCHG_COMPLETE);
    ASSERT(ulChgOff == 0);
    ASSERT(fSignal == TRUE);

    // Listview always calls after setting the callback
    ASSERT(_pfnCallback);

    _pfnCallback(this, _pvRefCallback);
    return S_OK;
}

// IImgCtx::SetCallback

HRESULT CBitmapImgCtx::SetCallback(PFNIMGCTXCALLBACK pfn, void * pvPrivateData)
{
    _pfnCallback = pfn;
    _pvRefCallback = pvPrivateData;
    return S_OK;
}

// IImgCtx::Disconnect

HRESULT CBitmapImgCtx::Disconnect()
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}

// IImgCtx::GetUpdateRects

HRESULT CBitmapImgCtx::GetUpdateRects(LPRECT prc, LPRECT prcImg, LPLONG pcrc)
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}

// IImgCtx::GetStateInfo

HRESULT CBitmapImgCtx::GetStateInfo(PULONG pulState, LPSIZE psize, BOOL fClearChanges)
{
    *pulState = IMGCHG_COMPLETE;
    *psize = _sizBmp;
    return S_OK;
}

// IImgCtx::GetPalette

HRESULT CBitmapImgCtx::GetPalette(HPALETTE *phpal)
{
    *phpal = NULL;
    return S_OK;
}

// IImgCtx::Draw
//
//  Drawing is a special case of tiling where only one tile's worth
//  gets drawn.  Listview (our only caller) is careful never to ask
//  for more than one tile's worth, so we can just forward straight
//  to IImgCtx::Tile().

HRESULT CBitmapImgCtx::Draw(HDC hdc, LPRECT prcBounds)
{
    POINT pt = { prcBounds->left, prcBounds->top };

    ASSERT(prcBounds->right - prcBounds->left <= _sizBmp.cx);
    ASSERT(prcBounds->bottom - prcBounds->top <= _sizBmp.cy);

    return Tile(hdc, &pt, prcBounds, NULL);
}

// IImgCtx::Tile

HRESULT CBitmapImgCtx::Tile(HDC hdc, LPPOINT pptBackOrg, LPRECT prcClip, LPSIZE psize)
{
    ASSERT(psize == NULL);  // Listview always passes NULL

    POINT pt;
    if (SetBrushOrgEx(hdc, pptBackOrg->x, pptBackOrg->y, &pt))
    {
        FillRect(hdc, prcClip, _hbr);
        SetBrushOrgEx(hdc, pt.x, pt.y, NULL);
    }

    // Nobody checks the return value
    return S_OK;
}

// IImgCtx::StretchBlt

HRESULT CBitmapImgCtx::StretchBlt(HDC hdc, int dstX, int dstY, int dstXE, int dstYE, int srcX, int srcY, int srcXE, int srcYE, DWORD dwROP)
{
    ASSERT(0);              // Listview should never call this
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\ccverp.h ===
//
// Version numbering for comctl32.dll
//

#ifndef FEATURE_IE40

#undef VER_PRODUCTBETA_STR
#undef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_DW

//
// NT SUR, IE 3.0
//

#define COMCTL32_BUILD_NUMBER	   1146

#ifdef WINNT
#define VER_PRODUCTVERSION          4,70,COMCTL32_BUILD_NUMBER,1
#else
#define VER_PRODUCTVERSION          4,70,0,COMCTL32_BUILD_NUMBER
#endif

#define VER_PRODUCTBETA_STR         ""
#define VER_PRODUCTVERSION_STR      "4.70"
#define VER_PRODUCTVERSION_W        (0x0446)
#define VER_PRODUCTVERSION_DW       (0x04460000 | COMCTL32_BUILD_NUMBER)

#endif  // FEATURE_IE40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\button.h ===
#if !defined(__Button_h__INCLUDED)
#define __Button_h__INCLUDED

/////////////////////////////////////////////////////////////////////////////
//
// Button Control
//
/////////////////////////////////////////////////////////////////////////////

//
// Button states
//
#define BST_CHECKMASK   0x0003
#define BST_INCLICK     0x0010
#define BST_CAPTURED    0x0020
#define BST_MOUSE       0x0040
#define BST_DONTCLICK   0x0080
#define BST_INBMCLICK   0x0100

#define PBF_PUSHABLE    0x0001
#define PBF_DEFAULT     0x0002

//
// BNDrawText codes
//
#define DBT_TEXT        0x0001
#define DBT_FOCUS       0x0002

#define BS_PUSHBOX      0x0000000AL
#define BS_TYPEMASK     0x0000000FL
#define BS_IMAGEMASK    0x000000C0L
#define BS_HORZMASK     0x00000300L
#define BS_VERTMASK     0x00000C00L
#define BS_ALIGNMASK    0x00000F00L

//
// Button macros
//
#define ISBSTEXTOROD(ulStyle)   \
            (((ulStyle & BS_BITMAP) == 0) && ((ulStyle & BS_ICON) == 0))


#define BUTTONSTATE(pbutn)      \
            (pbutn->buttonState)

//
// Instance data pointer access functions
//
#define Button_GetPtr(hwnd)    \
            (PBUTN)GetWindowPtr(hwnd, 0)

#define Button_SetPtr(hwnd, p) \
            (PBUTN)SetWindowPtr(hwnd, 0, p)

//
//  Button data structure
//
typedef struct tagBUTN 
{
    CCONTROLINFO ci;
    UINT    buttonState;    // Leave this a word for compatibility with SetWindowWord( 0L )
    HANDLE  hFont;
    HANDLE  hImage;
    UINT    fPaintKbdCuesOnly : 1;
    RECT    rcText;
    RECT    rcIcon;
    HIMAGELIST himl;
    UINT    uAlign;
    HTHEME  hTheme;         // Handle to the theme manager
    PWW     pww;            // RO pointer into the pwnd to ExStyle, Style, State, State2
} BUTN, *PBUTN;


//
// Button WndProc Prototype
//
extern LRESULT Button_WndProc(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam,
    LPARAM lParam);


#endif // __Button_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\ccver.h ===
//
//  ccver.h
//
//  App compat hack.  Apps, as always, mess up the major/minor version
//  check, so they think that 5.0 is less than 4.71 because they use
//
//    if (major < 4 && minor < 71) Fail();
//
//
//  So we artificially add 80 to our minor version, so 5.0 becomes 5.80,
//  etc.  Note that the hex version is 0x050, since 0x50 = 80 decimal.
//
//
//  The C preprocessor isn't smart enough to extract the commas out of
//  a value string, so we just do it all by hand and assert that nobody
//  has messed with <ntverp.h> or <ieverp.h> in a significant way.
//

#if _WIN32_IE == 0x0500

#define VER_FILEVERSION             5,80,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "5.80"
#define VER_FILEVERSION_W           0x0550
#define VER_FILEVERSION_DW          (0x05500000 | VER_PRODUCTBUILD)

#elif _WIN32_IE == 0x0501

#define VER_FILEVERSION             5,81,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "5.81"
#define VER_FILEVERSION_W           0x0551
#define VER_FILEVERSION_DW          (0x05510000 | VER_PRODUCTBUILD)

#elif _WIN32_IE == 0x0600

#define VER_FILEVERSION             6,0,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "6.0"
#define VER_FILEVERSION_W           0x0600
#define VER_FILEVERSION_DW          (0x06000000 | VER_PRODUCTBUILD)


#else
//
//  If this #error fires, you have to add a new version mapping.
//
#error Need to modify ccver.h for new IE/NT version.
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\animate.c ===
#include "ctlspriv.h"
#include "rlefile.h"

#define RectWid(_rc)    ((_rc).right-(_rc).left)
#define RectHgt(_rc)    ((_rc).bottom-(_rc).top)

typedef struct 
{
    HWND        hwnd;                   // my window
    int         id;                     // my id
    HWND        hwndP;                  // my owner (get notify messages)
    DWORD       style;

    BOOL        fFirstPaint;            // TRUE until first paint.
    RLEFILE     *prle;

    CRITICAL_SECTION    crit;

    RECT        rc;
    int         NumFrames;
    int         Rate;

    int         iFrame;
    int         PlayCount;
    int         PlayFrom;
    int         PlayTo;
    HANDLE      PaintThread;
    HANDLE      hStopEvent;
} ANIMATE;

#define Enter(p)    EnterCriticalSection(&p->crit)
#define Leave(p)    LeaveCriticalSection(&p->crit)

#define OPEN_WINDOW_TEXT 42

// Threading is broken with the new "Transparent" animations. If we decide to reenable
// this, we need to figure out how to get the bits without using sendmessage.
#define Ani_UseThread(p) (FALSE)

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags);
BOOL HandleStop(ANIMATE *p);
BOOL HandlePlay(ANIMATE *p, int from, int to, int count);
void HandlePaint(ANIMATE *p, HDC hdc);
int  HandleTick(ANIMATE *p);

BOOL InitAnimateClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = AnimateWndProc;
    wc.lpszClassName = ANIMATE_CLASS;
    wc.style         = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.hInstance     = hInstance;       // use DLL instance if in DLL
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszMenuName  = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, ANIMATE_CLASS, &wc))
        return FALSE;

    return TRUE;
}

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags)
{
    TCHAR ach[MAX_PATH];

    //
    // use window text as file name
    //
    if (flags == OPEN_WINDOW_TEXT)
    {
        GetWindowText(p->hwnd, ach, ARRAYSIZE(ach));
        pszName = ach;
    }

    if (hInst == NULL)
        hInst = (HINSTANCE)GetWindowLongPtr(p->hwnd, GWLP_HINSTANCE);

    HandleStop(p);              // stop a play first

    if (p->prle)
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
    }

    p->iFrame = 0;
    p->NumFrames = 0;

    if (pszName == NULL || (!IS_INTRESOURCE(pszName) && *pszName == 0))
        return FALSE;
    //
    //  now open the file/resource we got.
    //
    p->prle = RleFile_New();

    if (p->prle == NULL)
        return FALSE;

    if (!RleFile_OpenFromResource(p->prle, hInst, pszName, TEXT("AVI")) &&
        !RleFile_OpenFromFile(p->prle, pszName))
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
        return FALSE;
    }
    else
    {
        p->NumFrames = RleFile_NumFrames(p->prle);
        p->Rate = (int)RleFile_Rate(p->prle);
        SetRect(&p->rc, 0, 0, RleFile_Width(p->prle), RleFile_Height(p->prle));
    }

    //
    // handle a transparent color
    //
    if ((p->style & ACS_TRANSPARENT) && p->hwndP)
    {
        HDC hdc;
        HDC hdcM;
        HBITMAP hbm;
        COLORREF rgbS = {0};
        COLORREF rgbD = {0};

        hdc = GetDC(p->hwnd);

        //
        //  create a bitmap and draw image into it.
        //  get upper left pixel and make that transparent.
        //
        hdcM= CreateCompatibleDC(hdc);
        if (hdcM)
        {
            hbm = CreateCompatibleBitmap(hdc, 1, 1);
            if (hbm)
            {
                HBITMAP hbmO = SelectObject(hdcM, hbm);

                RleFile_Paint( p->prle, hdcM, p->iFrame, p->rc.left, p->rc.top );
                rgbS = GetPixel(hdcM, 0, 0);

                SelectObject(hdcM, hbmO);
                DeleteObject(hbm);
            }
            DeleteDC(hdcM);
        }

        SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
            GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));

        rgbD = GetBkColor(hdc);


        ReleaseDC(p->hwnd, hdc);

        //
        // now replace the color
        //
        RleFile_ChangeColor(p->prle, rgbS, rgbD);
    }

    //
    //  ok it worked, resize window.
    //
    if (p->style & ACS_CENTER)
    {
        RECT rc;
        GetClientRect(p->hwnd, &rc);
        OffsetRect(&p->rc, (rc.right-p->rc.right)/2,(rc.bottom-p->rc.bottom)/2);
    }
    else
    {
        RECT rc;
        rc = p->rc;
        AdjustWindowRectEx(&rc, GetWindowStyle(p->hwnd), FALSE, GetWindowExStyle(p->hwnd));
        SetWindowPos(p->hwnd, NULL, 0, 0, RectWid(rc), RectHgt(rc),
            SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    }

    if (p->style & ACS_AUTOPLAY)
    {
        PostMessage(p->hwnd, ACM_PLAY, (UINT_PTR)-1, MAKELONG(0, -1));
    }
    else
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
    }

    return TRUE;
}

void DoNotify(ANIMATE *p, int cmd)
{
    if (p->hwndP)
        PostMessage(p->hwndP, WM_COMMAND, GET_WM_COMMAND_MPS(p->id, p->hwnd, cmd));
}

BOOL HandleStop(ANIMATE *p)
{
    if (p == NULL || !p->PaintThread)
        return FALSE;

    if (Ani_UseThread(p)) 
    {
        // set thread up to terminate between frames
        Enter( p );
        p->PlayCount = 0;
        Leave( p );
        if (p->hStopEvent)
            SetEvent(p->hStopEvent);
        WaitForSingleObject(p->PaintThread, INFINITE);
        CloseHandle(p->PaintThread);

        // PORT QSY
        p->PaintThread = NULL;
        if (p->hStopEvent)
            CloseHandle(p->hStopEvent);
        p->hStopEvent = NULL;
    } 
    else 
    {
        KillTimer(p->hwnd, HandleToUlong(p->PaintThread)); // really was a UINT
        p->PaintThread = 0;
        DoNotify(p, ACN_STOP);
    }
    return TRUE;
}

int PlayThread(ANIMATE *p)
{
    int result;
    
    DoNotify(p, ACN_START);

    while (result = HandleTick(p))
    {
        // Sleep for a bit (4 seconds) longer if we are hidden
        //
        // Old code here slept, which can block the UI thread
        // if the app tries to stop/shutdown/change the animation
        // right near the beginning of the sleep.
        //        Sleep((result < 0 ? p->Rate+4000 : p->Rate));
        // Do a timed wait for the stop event instead
        //
        if (p->hStopEvent)
            WaitForSingleObject(p->hStopEvent, (result < 0 ? p->Rate+4000 : p->Rate));
        else
            Sleep((result < 0 ? p->Rate+4000 : p->Rate));
    }

    DoNotify(p, ACN_STOP);
    return 0;
}

BOOL HandlePlay(ANIMATE *p, int from, int to, int count)
{
    if (p == NULL || p->prle == NULL)
        return FALSE;

    HandleStop(p);

    if (from >= p->NumFrames)
        from = p->NumFrames-1;

    if (to == -1)
        to = p->NumFrames-1;

    if (to < 0)
        to = 0;

    if (to >= p->NumFrames)
        to = p->NumFrames-1;

    p->PlayCount = count;
    p->PlayTo    = to;
    if (from >= 0) 
    {
        p->iFrame = from;
        p->PlayFrom  = from;
    } 
    else
        from = p->PlayFrom;

    if ( (from == to) || !count )
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
        return TRUE;
    }

    InvalidateRect(p->hwnd, NULL, FALSE);
    UpdateWindow(p->hwnd);

    if (Ani_UseThread(p))
    {
        DWORD dw;
        p->hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        p->PaintThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PlayThread, (void*)p, 0, &dw);
    }
    else
    {
        DoNotify(p, ACN_START);
        p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
    }
    return TRUE;
}

void HandleFirstPaint(ANIMATE *p)
{
    if (p->fFirstPaint)
    {
        p->fFirstPaint = FALSE;

        if (p->NumFrames == 0 &&
            (p->style & WS_CHILD))
        {
            HandleOpen(p, NULL, NULL, OPEN_WINDOW_TEXT);
        }
    }
}

void HandlePaint(ANIMATE *p, HDC hdc)
{
    if( p && p->prle )
    {
        HDC h;
        HBRUSH hbr;
        RECT rc;
        CCDBUFFER db;

        GetClientRect(p->hwnd, &rc);
        h = CCBeginDoubleBuffer(hdc, &rc, &db);

        hbr = (HBRUSH)SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
            GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));

        FillRect(h, &rc, hbr);

        Enter( p );
        RleFile_Paint( p->prle, h, p->iFrame, p->rc.left, p->rc.top );
        Leave( p );

        CCEndDoubleBuffer(&db);
    }
}

void HandlePrint(ANIMATE *p, HDC hdc)
{
    HandleFirstPaint(p);
    HandlePaint(p, hdc);
}

int HandleTick(ANIMATE *p)
// - if something to do but we are hidden
// returns 0 if nothing left
// + if something to do
{
    int result = 0;

    if( p && p->prle )
    {
        HDC hdc;
        RECT dummy;

        Enter( p );
        hdc = GetDC( p->hwnd );

        if( GetClipBox( hdc, &dummy ) != NULLREGION )
        {
            HandlePaint( p, hdc );

            if( p->iFrame >= p->PlayTo )
            {
                if( p->PlayCount > 0 )
                    p->PlayCount--;

                if( p->PlayCount != 0 )
                    p->iFrame = p->PlayFrom;
            }
            else
                p->iFrame++;


            // Something to do? and visible, return + value
            result = ( p->PlayCount != 0 );
        }
        else
        {
            // Something to do? but hidden, so return - value
            p->iFrame = p->PlayFrom;

            result = -( p->PlayCount != 0 );
        }

        ReleaseDC( p->hwnd, hdc );
        Leave( p );
    }

    return result;
}

void Ani_OnStyleChanged(ANIMATE* p, WPARAM gwl, STYLESTRUCT *pinfo)
{
    if (gwl == GWL_STYLE) 
    {
        p->style = pinfo->styleNew;
    }
}

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ANIMATE *p = (ANIMATE *)GetWindowPtr(hwnd, 0);
    HDC hdc;
    PAINTSTRUCT ps;

    // First, the messages that can handle p == NULL.
    // All these handlers must end with a "return" or a "goto DoDefault".

    switch (msg) 
    {
    case WM_NCCREATE:

        #define lpcs ((LPCREATESTRUCT)lParam)

        p = (ANIMATE *)LocalAlloc(LPTR, sizeof(ANIMATE));

        if (!p)
            return 0;       // WM_NCCREATE failure is 0

        // note, zero init memory from above
        p->hwnd = hwnd;
        p->hwndP = lpcs->hwndParent;
        p->id = PtrToUlong(lpcs->hMenu);        // really was an int
        p->fFirstPaint = TRUE;
        p->style = lpcs->style;

        // Must do this before SetWindowBits because that will recursively
        // cause us to receive WM_STYLECHANGED and possibly even WM_SIZE
        // messages.
        InitializeCriticalSection(&p->crit);


        SetWindowPtr(hwnd, 0, p);

        //
        // UnMirror the control, if it is mirrored. We shouldn't mirror
        // a movie! [samera]
        //
        SetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);

        goto DoDefault;

    case WM_CLOSE:
        Animate_Stop(hwnd);
        goto DoDefault;

    case WM_NCHITTEST:
        return HTTRANSPARENT;

    case WM_GETOBJECT:
        if (lParam == OBJID_QUERYCLASSNAMEIDX)
            return MSAA_CLASSNAMEIDX_ANIMATE;
        goto DoDefault;
    }

    // Okay, now the messages that cannot handle p == NULL.
    // We check p == NULL once and for all.

    if (!p) 
        goto DoDefault;

    switch (msg) 
    {
    case WM_DESTROY:
        Animate_Close(hwnd);
        DeleteCriticalSection(&p->crit);
        LocalFree((HLOCAL)p);
        SetWindowPtr(hwnd, 0, 0);
        break;

    case WM_ERASEBKGND:
        return(1);

    case WM_PAINT:
        HandleFirstPaint(p);
        hdc = BeginPaint(hwnd, &ps);
        HandlePaint(p, hdc);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_PRINTCLIENT:
        HandlePrint(p, (HDC)wParam);
        return 0;

    case WM_STYLECHANGED:
        Ani_OnStyleChanged(p, wParam, (LPSTYLESTRUCT)lParam);
        return 0L;
        
    case WM_SIZE:
        if (p->style & ACS_CENTER)
        {
            OffsetRect(&p->rc, (LOWORD(lParam)-RectWid(p->rc))/2-p->rc.left,
                       (HIWORD(lParam)-RectHgt(p->rc))/2-p->rc.top);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    case WM_TIMER:
        {
            int result = HandleTick(p);
            if (!result)
            {
                HandleStop(p);
            }
            else if (result < 0)
            {
                p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate+4000, NULL);
            } 
            else
            {
                p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
            }
        }
        break;


    case ACM_OPENA:
    {
        WCHAR szFileNameW[MAX_PATH];
        LPTSTR lpFileName = szFileNameW;

        if (!IS_INTRESOURCE(lParam)) 
        {
            MultiByteToWideChar (CP_ACP, 0, (LPCSTR)lParam, -1, szFileNameW, MAX_PATH);
        } 
        else 
        {
            lpFileName = (LPTSTR) lParam;
        }
        
        return HandleOpen(p, (HINSTANCE)wParam, lpFileName, 0);
    }

    case ACM_OPEN:
        return HandleOpen(p, (HINSTANCE)wParam, (LPCTSTR)lParam, 0);

    case ACM_STOP:
        return HandleStop(p);

    case ACM_PLAY:
        return HandlePlay(p, (int)(SHORT)LOWORD(lParam), (int)(SHORT)HIWORD(lParam), (int)wParam);
    }

DoDefault:
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\ccontrol.h ===
class CControl
{
protected:
    
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPaint(HDC hdc);

    virtual ~CControl() {};
    virtual void v_OnNCPaint() {};
    virtual void v_OnPaint(HDC hdc) = 0;
    virtual LRESULT v_OnCreate() = 0;
    virtual void v_OnSize(int x, int y) = 0;
    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam);
    
    virtual BOOL v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT* plres);

    virtual LPCTSTR GetThemeClass() { return TEXT(""); }

    //Data Members
    CCONTROLINFO ci;     // common control header info
    HTHEME _hTheme;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\button.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "button.h"

//
// ButtonCalcRect codes
//
#define CBR_CLIENTRECT 0
#define CBR_CHECKBOX   1
#define CBR_CHECKTEXT  2
#define CBR_GROUPTEXT  3
#define CBR_GROUPFRAME 4
#define CBR_PUSHBUTTON 5
#define CBR_RADIOBUTTON 6


#define Button_IsThemed(pbutn)  ((pbutn)->hTheme && (pbutn)->hImage == NULL)

//---------------------------------------------------------------------------//
CONST BYTE mpStyleCbr[] = 
{
    CBR_PUSHBUTTON,     // BS_PUSHBUTTON
    CBR_PUSHBUTTON,     // BS_DEFPUSHBUTTON
    CBR_CHECKTEXT,      // BS_CHECKBOX
    CBR_CHECKTEXT,      // BS_AUTOCHECKBOX
    CBR_CHECKTEXT,      // BS_RADIOBUTTON
    CBR_CHECKTEXT,      // BS_3STATE
    CBR_CHECKTEXT,      // BS_AUTO3STATE
    CBR_GROUPTEXT,      // BS_GROUPBOX
    CBR_CLIENTRECT,     // BS_USERBUTTON
    CBR_CHECKTEXT,      // BS_AUTORADIOBUTTON
    CBR_CLIENTRECT,     // BS_PUSHBOX
    CBR_CLIENTRECT,     // BS_OWNERDRAW
};

#define IMAGE_BMMAX    IMAGE_CURSOR+1
static CONST BYTE rgbType[IMAGE_BMMAX] = 
{
    BS_BITMAP,          // IMAGE_BITMAP
    BS_ICON,            // IMAGE_CURSOR
    BS_ICON             // IMAGE_ICON
};

#define IsValidImage(imageType, realType, max)   \
    ((imageType < max) && (rgbType[imageType] == realType))

typedef struct tagBTNDATA 
{
    LPTSTR  lpsz;       // Text string
    PBUTN   pbutn;      // Button data
    WORD    wFlags;     // Alignment flags
} BTNDATA, *LPBTNDATA;

//---- to support multiple themes in a single process, move these into PBUTN ----
static SIZE sizeCheckBox = {0};
static SIZE sizeRadioBox = {0};

//---------------------------------------------------------------------------//
//
// Forwards
//
VOID    Button_DrawPush(PBUTN pbutn, HDC hdc, UINT pbfPush);
VOID    GetCheckBoxSize(HDC hdc, PBUTN pbutn, BOOL fCheckBox, LPSIZE psize);
WORD    GetAlignment(PBUTN pbutn);
VOID    Button_CalcRect(PBUTN pbutn, HDC hdc, LPRECT lprc, int iCode, UINT uFlags);
VOID    Button_MultiExtent(WORD wFlags, HDC hdc, LPRECT lprcMax, LPTSTR lpsz, int cch, PINT pcx, PINT pcy);

__inline UINT    IsPushButton(PBUTN pbutn);
__inline ULONG   GetButtonType(ULONG ulWinStyle);


//---------------------------------------------------------------------------//
//
//  InitButtonClass() - Registers the control's window class 
//
BOOL InitButtonClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = Button_WndProc;
    wc.lpszClassName = WC_BUTTON;
    wc.style         = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PBUTN);
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, WC_BUTTON, &wc))
        return FALSE;


    return TRUE;
}


//---------------------------------------------------------------------------//
//
// Button_GetThemeIds() - Gets the associated iPartId and iStateId needed for
//                        the theme manager APIs for the button control passed
//                        in pbutn. 
//
HRESULT Button_GetThemeIds(PBUTN pbutn, LPINT piPartId, LPINT piStateId)
{
    if ( piPartId )
    {
        ULONG ulStyle = GET_STYLE(pbutn);

        if (IsPushButton(pbutn))
        {
            *piPartId = BP_PUSHBUTTON;
        }
        else
        {

            switch (GetButtonType(ulStyle)) 
            {
            case BS_CHECKBOX:
            case BS_AUTOCHECKBOX:
            case BS_3STATE:
            case BS_AUTO3STATE:
                *piPartId = BP_CHECKBOX;
                break;

            case BS_RADIOBUTTON:
            case BS_AUTORADIOBUTTON:
                *piPartId = BP_RADIOBUTTON;
                break;

            case BS_GROUPBOX:
                *piPartId = BP_GROUPBOX;
                break;

            case BS_OWNERDRAW:
                //
                // don't do anything with owerdrawn buttons
                //
                return E_FAIL;

            default:
                TraceMsg(TF_STANDARD, "What kind of buttonType is this, %#.2x", GetButtonType(ulStyle));
                *piPartId = BP_PUSHBUTTON;
                break;
            }
        }

        if (piStateId)
        {
            switch (*piPartId)
            {
            case BP_PUSHBUTTON:
                if ((pbutn->buttonState & BST_PUSHED) || 
                    ((pbutn->buttonState & (BST_CHECKED|BST_HOT)) == BST_CHECKED))
                {
                    *piStateId = PBS_PRESSED;
                }
                else if (!IsWindowEnabled(pbutn->ci.hwnd))
                {
                    *piStateId = PBS_DISABLED;
                }
                else if (pbutn->buttonState & BST_HOT)
                {
                    *piStateId = PBS_HOT;
                }
                else if (ulStyle & BS_DEFPUSHBUTTON)
                {
                    *piStateId = PBS_DEFAULTED;
                }
                else
                {
                    *piStateId = PBS_NORMAL;
                }
                break;

            case BP_CHECKBOX:
            case BP_RADIOBUTTON:
                //
                // NOTE (phellyar): We're relying on the order of the RADIOBUTTONSTATES and 
                //                  CHECKBOXSTATES enums in tmdefs.h to calculate the correct 
                //                  StateId. If the ordering of those enums changes, revisit 
                //                  the logic here.
                //                  Note also that CHECKBOXSTATES is a super set of 
                //                  RADIOBUTTONSTATES which is why we're using CBS_* here.
                //
                if ( pbutn->buttonState & BST_CHECKED )
                {
                    //
                    // button is checked
                    //
                    *piStateId = CBS_CHECKEDNORMAL;
                }
                else if ( pbutn->buttonState & BST_INDETERMINATE )
                {
                    //
                    // button is intedeterminate
                    //
                    *piStateId = CBS_MIXEDNORMAL;
                }
                else
                {
                    //
                    // button is unchecked
                    //
                    *piStateId = CBS_UNCHECKEDNORMAL;
                }

                if ( pbutn->buttonState & BST_PUSHED )
                {
                    //
                    // being pressed 
                    //
                    *piStateId += 2;
                }
                else if (!IsWindowEnabled(pbutn->ci.hwnd))
                {
                    //
                    // disabled
                    //
                    *piStateId += 3;
                }
                else if (pbutn->buttonState & BST_HOT )
                {
                    //
                    // mouse over
                    //
                    *piStateId += 1;
                }

                break;

            case BP_GROUPBOX:
                if (!IsWindowEnabled(pbutn->ci.hwnd))
                {
                    *piStateId = GBS_DISABLED;
                }
                else
                {
                    *piStateId = GBS_NORMAL;
                }
                break;
            }
        }
        
    }

    return S_OK;
}


//---------------------------------------------------------------------------//
//
// Button_GetTextFlags() - Returns the DrawTextEx flags that should be used
//                         when rendering text for this control, needed by
//                         DrawThemeText.
//
DWORD Button_GetTextFlags(PBUTN pbutn)
{
    DWORD dwTextFlags = 0;
    WORD  wAlign = GetAlignment(pbutn);
    ULONG ulStyle = GET_STYLE(pbutn);

    //
    // Set up text flags
    //
      
    //
    // horizontal text alignment 
    //
    switch (wAlign & HIBYTE(BS_HORZMASK))
    {
    case HIBYTE(BS_LEFT):
        dwTextFlags |= DT_LEFT;
        break;

    case HIBYTE(BS_RIGHT):
        dwTextFlags |= DT_RIGHT;
        break;

    case HIBYTE(BS_CENTER):
        dwTextFlags |= DT_CENTER;
        break;
    }

    //
    // vertical text alignment
    //
    switch (wAlign & HIBYTE(BS_VERTMASK))
    {
    case HIBYTE(BS_TOP):
        dwTextFlags |= DT_TOP;
        break;

    case HIBYTE(BS_BOTTOM):
        dwTextFlags |= DT_BOTTOM;
        break;

    case HIBYTE(BS_VCENTER):
        dwTextFlags |= DT_VCENTER;
        break;

    }

    //
    // line break
    //
    if (ulStyle & BS_MULTILINE)
    {
        dwTextFlags |= (DT_WORDBREAK | DT_EDITCONTROL);
    }
    else
    {
        dwTextFlags |= DT_SINGLELINE;
    }


    if (ulStyle & SS_NOPREFIX)
    {
        dwTextFlags |= DT_NOPREFIX;
    }
 
    //
    // Draw the underscore for accelorators?
    //
    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN))
    {
        dwTextFlags |= DT_HIDEPREFIX;
    }

    return dwTextFlags;
}

DWORD ButtonStateToCustomDrawState(PBUTN pbutn)
{
    DWORD itemState = 0;
    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN))
    {
        itemState |= CDIS_SHOWKEYBOARDCUES;
    }

    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN))
    {
        itemState |= CDIS_SHOWKEYBOARDCUES;
    }

    if (BUTTONSTATE(pbutn) & BST_FOCUS) 
    {
        itemState |= CDIS_FOCUS;
    }

    if (BUTTONSTATE(pbutn) & BST_PUSHED) 
    {
        itemState |= CDIS_SELECTED;
    }

    if (BUTTONSTATE(pbutn) & BST_HOT) 
    {
        itemState |= CDIS_HOT;
    }

    if (!IsWindowEnabled(pbutn->ci.hwnd))
    {
        itemState |= CDIS_DISABLED;
    }

    return itemState;
}


void Button_GetImagePosition(PBUTN pbutn, RECT* prc, int* px, int* py)
{
    int cx = 0;
    int cy = 0;
    CCGetIconSize(&pbutn->ci, pbutn->himl, &cx, &cy);

    cx += pbutn->rcIcon.left + pbutn->rcIcon.right;
    cy += pbutn->rcIcon.top + pbutn->rcIcon.bottom;
    switch (pbutn->uAlign)
    {
    case BUTTON_IMAGELIST_ALIGN_RIGHT:
        *px = prc->right - cx;
        *py = prc->top + (RECTHEIGHT(*prc) - cy) / 2 + pbutn->rcIcon.top;
        prc->right -= cx;
        break;

    case BUTTON_IMAGELIST_ALIGN_CENTER:     // This means no text
        *px = prc->left + (RECTWIDTH(*prc) - cx) / 2 + pbutn->rcIcon.left;
        *py = prc->top + (RECTHEIGHT(*prc) - cy) / 2 + pbutn->rcIcon.top;
        break;

    case BUTTON_IMAGELIST_ALIGN_TOP: 
       *px = prc->left + (RECTWIDTH(*prc) - cx) / 2 + pbutn->rcIcon.left;
        *py = pbutn->rcIcon.top;
        prc->top += cy;
        break;

    case BUTTON_IMAGELIST_ALIGN_BOTTOM:
        *px = (RECTWIDTH(*prc) - cx) / 2 + pbutn->rcIcon.left;
        *py = prc->bottom - cy;
        prc->bottom -= cy;
        break;

    case BUTTON_IMAGELIST_ALIGN_LEFT:
        // Fall
    default:
        *px = prc->left + pbutn->rcIcon.left;
        *py = prc->top + (RECTHEIGHT(*prc) - cy) / 2 + pbutn->rcIcon.top;
        prc->left += cx;
        break;

    }
}


//---------------------------------------------------------------------------//
//
//  Button_DrawThemed() - Renders button control according to the current
//                        theme.
//                        pbutn    - the button control to render
//                        hdc      - the hdc to draw on
//                        iPartId  - the button part
//                        iStateId - the button state
//
HRESULT Button_DrawThemed(PBUTN pbutn, HDC hdc, int iPartId, int iStateId)
{
    HRESULT hr;
    RECT    rcClient;
    RECT    rcContent;
    RECT    rcFocus;
    RECT    rcCheck;
    DWORD   dwTextFlags;
    LPWSTR  pszText;
    int     cch;
    NMCUSTOMDRAW nmcd = {0};

    BOOL    fRadioOrCheck = (iPartId == BP_RADIOBUTTON || iPartId == BP_CHECKBOX );

    //
    // Render the button background
    //
    GetClientRect(pbutn->ci.hwnd, &rcClient);
    rcCheck = rcContent = rcClient;
    if ( fRadioOrCheck )
    {
        SIZE sizeChar; 
        SIZE sizeCheck;
        int iCode;

        //
        // Compat....
        //

        GetTextExtentPoint32(hdc, TEXT("0"), 1, &sizeChar); 

        GetCheckBoxSize(hdc, pbutn, (iPartId == BP_CHECKBOX), &sizeCheck);
        
        if (iPartId == BP_CHECKBOX)
            iCode = CBR_CHECKBOX;
        else
            iCode = CBR_RADIOBUTTON;

        Button_CalcRect(pbutn, hdc, &rcCheck, iCode, 0);

        rcCheck.bottom = rcCheck.top + sizeCheck.cx;

        if ((GET_STYLE(pbutn) & BS_RIGHTBUTTON) != 0)
        {
            rcCheck.left = rcContent.right - sizeCheck.cx;
            rcContent.right = rcCheck.left - (sizeChar.cx/2);
        }
        else
        {
            rcCheck.right = rcContent.left + sizeCheck.cx;
            rcContent.left = rcCheck.right + (sizeChar.cx/2);
        }

        //---- shrink radiobutton/checkbox button to fix client rect ----
        if (RECTWIDTH(rcClient) < RECTWIDTH(rcCheck))
        {
            rcCheck.right = rcCheck.left + RECTWIDTH(rcClient);
        }

        if (RECTHEIGHT(rcClient) < RECTHEIGHT(rcCheck))
        {
            rcCheck.bottom = rcCheck.top + RECTHEIGHT(rcClient);
        }
    }

    nmcd.hdc = hdc;
    nmcd.rc = rcClient;
    nmcd.dwItemSpec = GetWindowID(pbutn->ci.hwnd);
    nmcd.uItemState = ButtonStateToCustomDrawState(pbutn);


    pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREERASE, &nmcd);

    if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
    {
        hr = DrawThemeBackground(pbutn->hTheme, hdc, iPartId, iStateId, &rcCheck, 0);
        if (FAILED(hr))
        {
            TraceMsg(TF_STANDARD, "Failed to render theme background");
            return hr;
        }

        if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
            CICustomDrawNotify(&pbutn->ci, CDDS_POSTERASE, &nmcd);

        pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREPAINT, &nmcd);

        if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
        {
            //
            // Render the button text
            //
            GetThemeBackgroundContentRect(pbutn->hTheme, hdc, iPartId, iStateId, &rcContent, &rcContent);

            rcFocus = rcContent;

            if (pbutn->himl)
            {
                int x, y;
                int iImage = 0;
                if (ImageList_GetImageCount(pbutn->himl) > 1)
                {
                    iImage = (iStateId - PBS_NORMAL);
                }

                Button_GetImagePosition(pbutn, &rcContent, &x, &y);

                ImageList_Draw(pbutn->himl, iImage, hdc, x, y, ILD_TRANSPARENT | (CCDPIScale(pbutn->ci)?ILD_DPISCALE:0));
            }

            //
            // Get the button text
            //
            cch = GetWindowTextLength(pbutn->ci.hwnd);
            if (cch == 0)
            {
                //
                // Nothing to draw
                //
                return hr;
            }
            pszText = UserLocalAlloc(0, sizeof(WCHAR)*(cch+1));
            if (pszText == NULL) 
            {
                TraceMsg(TF_STANDARD, "Can't allocate buffer");
                return E_FAIL;
            }

            GetWindowTextW(pbutn->ci.hwnd, pszText, cch+1);

            dwTextFlags = Button_GetTextFlags(pbutn);

            if ( TESTFLAG(GET_STYLE(pbutn), BS_MULTILINE) || fRadioOrCheck )
            {
                int  cxWidth, cyHeight;
                TEXTMETRIC tm;

                if ( TESTFLAG(GET_STYLE(pbutn), BS_MULTILINE) )
                {
                    RECT rcTextExtent = rcContent;

                    cyHeight = DrawTextEx(hdc, pszText, cch, &rcTextExtent, dwTextFlags|DT_CALCRECT, NULL);
                    cxWidth  = RECTWIDTH(rcTextExtent);
                }
                else
                {
                    SIZE   size;
                    LPWSTR pszStrip = UserLocalAlloc(0, sizeof(WCHAR)*(cch+1));

                    if ( pszStrip )
                    {
                        int cchStrip = StripAccelerators(pszText, pszStrip, TRUE);
                        GetTextExtentPoint32(hdc, pszStrip, cchStrip, &size);
                        UserLocalFree(pszStrip);
                    }
                    else
                    {
                        GetTextExtentPoint32(hdc, pszText, cch, &size);
                    }

                    cyHeight = size.cy;
                    cxWidth = size.cx;
                }

                if ( fRadioOrCheck && (cyHeight < RECTHEIGHT(rcCheck)))
                {
                    // optimization for single line check/radios, align them with the top
                    // of the check no matter when the vertical alignment
                    rcContent.top = rcCheck.top;
                }
                else
                {
                    if (dwTextFlags & DT_VCENTER)
                    {
                        rcContent.top += (RECTHEIGHT(rcContent) - cyHeight) / 2;
                    }
                    else if (dwTextFlags & DT_BOTTOM)
                    {
                        rcContent.top = rcContent.bottom - cyHeight;
                    }
                }

                if ( GetTextMetrics( hdc, &tm ) && (tm.tmInternalLeading == 0) )
                {
                    // Far East fonts that have no leading. Leave space to prevent
                    // focus rect from obscuring text.
                    rcContent.top += g_cyBorder;
                }
                rcContent.bottom = rcContent.top + cyHeight;

                if (dwTextFlags & DT_CENTER)
                {
                    rcContent.left += (RECTWIDTH(rcContent) - cxWidth) / 2;
                }
                else if (dwTextFlags & DT_RIGHT)
                {
                    rcContent.left = rcContent.right - cxWidth;
                }
                rcContent.right= rcContent.left + cxWidth;
                

                if ( fRadioOrCheck )
                {
                    //
                    // Inflate the bounding rect a litte, but contrained to
                    // within the client area.
                    //
                    rcFocus.top    = max(rcClient.top,    rcContent.top-1);
                    rcFocus.bottom = min(rcClient.bottom, rcContent.bottom+1);

                    rcFocus.left   = max(rcClient.left,  rcContent.left-1);
                    rcFocus.right  = min(rcClient.right, rcContent.right+1);
                }
            }

            hr = DrawThemeText(pbutn->hTheme, hdc, iPartId, iStateId, pszText, cch, dwTextFlags, 0, &rcContent);
            if (FAILED(hr))
            {
                TraceMsg(TF_STANDARD, "Failed to render button text");
            }

            if (!TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN) && (BUTTONSTATE(pbutn) & BST_FOCUS))
            {
                DrawFocusRect(hdc, &rcFocus);
            }


            UserLocalFree(pszText);
            if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
            {
                CICustomDrawNotify(&pbutn->ci, CDDS_POSTPAINT, &nmcd);
            }
        }
    }

    return hr;
}


//---------------------------------------------------------------------------//
//
//  Button_GetTheme() - Get a handle to the theme for this button control 
//
HTHEME Button_GetTheme(PBUTN pbutn)
{
    //
    // Button's with predefined IDs can be 
    // themed differently
    //
    static LPWSTR szButtonClasses[] = 
    {
        L"Button",                  // =0
        L"Button-OK;Button",        // IDOK=1
        L"Button-CANCEL;Button",    // IDCANCEL=2
        L"Button-ABORT;Button",     // IDABORT=3
        L"Button-RETRY;Button",     // IDRETRY=4
        L"Button-IGNORE;Button",    // IDIGNORE=5
        L"Button-YES;Button",       // IDYES=6
        L"Button-NO;Button",        // IDNO=7
        L"Button-CLOSE;Button",     // IDCLOSE=8
        L"Button-HELP;Button",      // IDHELP=9
        L"Button-TRYAGAIN;Button",  // IDTRYAGAIN=10
        L"Button-CONTINUE;Button",  // IDCONTINUE=11
        L"Button-APPLY;Button",     // IDAPPLY=12 (not yet std)
    };
    int iButtonId = GetWindowID(pbutn->ci.hwnd);

    if (iButtonId < 0 || iButtonId >= ARRAYSIZE(szButtonClasses))  // outside range
    {
        iButtonId = 0;
    }

    EnableThemeDialogTexture(GetParent(pbutn->ci.hwnd), ETDT_ENABLE);

    return OpenThemeData(pbutn->ci.hwnd, szButtonClasses[iButtonId]);
}



//---------------------------------------------------------------------------//
//
VOID GetCheckBoxSize(HDC hdc, PBUTN pbutn, BOOL fCheckBox, LPSIZE psize)
{
    SIZE *psz;

    if (fCheckBox)
        psz = &sizeCheckBox;
    else
        psz = &sizeRadioBox;

    if ((! psz->cx) && (! psz->cy))         // not yet calculated
    {
        BOOL fGotSize = FALSE;

        if (pbutn->hTheme)          // get themed size
        {
            int iPartId;
            HRESULT hr;

            if (fCheckBox)
                iPartId = BP_CHECKBOX;
            else
                iPartId = BP_RADIOBUTTON;

            hr = GetThemePartSize(pbutn->hTheme, hdc, iPartId, 1, NULL, TS_DRAW, psz);
            if (FAILED(hr))
            {
                TraceMsg(TF_STANDARD, "Failed to get theme part size for checkbox/radiobutton");
            }
            else
            {
                fGotSize = TRUE;
            }
        }

        if (! fGotSize)            // get classic size (use checkbox for both)
        {
            HBITMAP hbmp = LoadBitmap(NULL, MAKEINTRESOURCE(OBM_CHECKBOXES));

            if (hbmp != NULL) 
            {
                BITMAP  bmp;

                GetObject(hbmp, sizeof(BITMAP), &bmp);

                //
                // Checkbox bitmap is arranged 4 over and three down.  Only need to get
                // the size of a single checkbox, so do the math here.
                //
                psz->cx = bmp.bmWidth / 4;
                psz->cy = bmp.bmHeight / 3;

                DeleteObject(hbmp);
            }
            else
            {
                AssertMsg(hbmp != NULL, TEXT("Unable to load checkbox bitmap"));
            }
        }
    }

    *psize = *psz;
}


//---------------------------------------------------------------------------//
//
__inline BYTE GetButtonStyle(ULONG ulWinStyle)
{
    return (BYTE) LOBYTE(ulWinStyle & BS_TYPEMASK);
}


//---------------------------------------------------------------------------//
//
__inline ULONG GetButtonType(ULONG ulWinStyle)
{
    return ulWinStyle & BS_TYPEMASK;
}


//---------------------------------------------------------------------------//
//
// IsPushButton()
//
// Returns non-zero if the window is a push button.  Returns flags that
// are interesting if it is.  These flags are
//
UINT IsPushButton(PBUTN pbutn)
{
    BYTE bStyle;
    UINT flags;

    ULONG ulStyle = GET_STYLE(pbutn);

    bStyle = GetButtonStyle(ulStyle);
    flags = 0;

    switch (bStyle) 
    {
    case LOBYTE(BS_PUSHBUTTON):
        flags |= PBF_PUSHABLE;
        break;

    case LOBYTE(BS_DEFPUSHBUTTON):
        flags |= PBF_PUSHABLE | PBF_DEFAULT;
        break;

    default:
        if (ulStyle & BS_PUSHLIKE)
        {
            flags |= PBF_PUSHABLE;
        }
    }

    return flags;
}


//---------------------------------------------------------------------------//
//
// GetAlignment()
//
// Gets default alignment of button.  If BS_HORZMASK and/or BS_VERTMASK
// is specified, uses those.  Otherwise, uses default for button.
//
// It's probably a fine time to describe what alignment flags mean for
// each type of button.  Note that the presence of a bitmap/icon affects
// the meaning of alignments.
//
// (1) Push like buttons
//      With one of {bitmap, icon, text}:
//          Just like you'd expect
//      With one of {bitmap, icon} AND text:
//          Image & text are centered as a unit; alignment means where
//          the image shows up.  E.G., left-aligned means the image
//          on the left, text on the right.
// (2) Radio/check like buttons
//      Left aligned means check/radio box is on left, then bitmap/icon
//          and text follows, left justified.
//      Right aligned means checkk/radio box is on right, preceded by
//          text and bitmap/icon, right justified.
//      Centered has no meaning.
//      With one of {bitmap, icon} AND text:
//          Top aligned means bitmap/icon above, text below
//          Bottom aligned means text above, bitmap/icon below
//      With one of {bitmap, icon, text}
//          Alignments mean what you'd expect.
// (3) Group boxes
//      Left aligned means text is left justified on left side
//      Right aligned means text is right justified on right side
//      Center aligned means text is in middle
//
WORD GetAlignment(PBUTN pbutn)
{
    BYTE bHorz;
    BYTE bVert;

    ULONG ulStyle = GET_STYLE(pbutn);

    bHorz = HIBYTE(ulStyle & BS_HORZMASK);
    bVert = HIBYTE(ulStyle & BS_VERTMASK);

    if (!bHorz || !bVert) 
    {
        if (IsPushButton(pbutn)) 
        {
            if (!bHorz)
            {
                bHorz = HIBYTE(BS_CENTER);
            }
        } 
        else 
        {
            if (!bHorz)
            {
                bHorz = HIBYTE(BS_LEFT);
            }
        }

        if (GetButtonStyle(ulStyle) == BS_GROUPBOX)
        {
            if (!bVert)
            {
                bVert = HIBYTE(BS_TOP);
            }
        }
        else
        {
            if (!bVert)
            {
                bVert = HIBYTE(BS_VCENTER);
            }
        }
    }

    return bHorz | bVert;
}


//---------------------------------------------------------------------------//
//
// Button_SetFont()
//
// Changes button font, and decides if we can use real bold font for default
// push buttons or if we have to simulate it.
//
VOID Button_SetFont(PBUTN pbutn, HFONT hFont, BOOL fRedraw)
{
    pbutn->hFont = hFont;

    if (fRedraw && IsWindowVisible(pbutn->ci.hwnd)) 
    {
        InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);
    }
}


//---------------------------------------------------------------------------//
//
HBRUSH Button_InitDC(PBUTN pbutn, HDC hdc)
{
    UINT    uMsg;
    BYTE    bStyle;
    HBRUSH  hBrush;
    ULONG   ulStyle   = GET_STYLE(pbutn);
    ULONG   ulStyleEx = GET_EXSTYLE(pbutn);

    //
    // Set BkMode before getting brush so that the app can change it to
    // transparent if it wants.
    //
    SetBkMode(hdc, OPAQUE);

    bStyle = GetButtonStyle(ulStyle);

    switch (bStyle) 
    {
    default:
        if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT) && ((ulStyle & BS_PUSHLIKE) == 0)) 
        {
            uMsg = WM_CTLCOLORSTATIC;
            break;
        }

    case LOBYTE(BS_PUSHBUTTON):
    case LOBYTE(BS_DEFPUSHBUTTON):
    case LOBYTE(BS_OWNERDRAW):
    case LOBYTE(BS_USERBUTTON):
        uMsg = WM_CTLCOLORBTN;
        break;
    }

    hBrush = (HBRUSH)SendMessage(GetParent(pbutn->ci.hwnd), uMsg, (WPARAM)hdc, (LPARAM)pbutn->ci.hwnd);

    //
    // Select in the user's font if set, and save the old font so that we can
    // restore it when we release the dc.
    //
    if (pbutn->hFont) 
    {
        SelectObject(hdc, pbutn->hFont);
    }

    //
    // Clip output to the window rect if needed.
    //
    if (bStyle != LOBYTE(BS_GROUPBOX)) 
    {
        RECT rcClient;

        GetClientRect(pbutn->ci.hwnd, &rcClient);
        IntersectClipRect(hdc, 0, 0,
            rcClient.right,
            rcClient.bottom);
    }

    if ((ulStyleEx & WS_EX_RTLREADING) != 0)
    {
        SetTextAlign(hdc, TA_RTLREADING | GetTextAlign(hdc));
    } 

    return hBrush;
}


//---------------------------------------------------------------------------//
//
HDC Button_GetDC(PBUTN pbutn, HBRUSH *phBrush)
{
    HDC hdc = NULL;

    if (IsWindowVisible(pbutn->ci.hwnd)) 
    {
        HBRUSH  hBrush;

        hdc = GetDC(pbutn->ci.hwnd);
        hBrush = Button_InitDC(pbutn, hdc);

        if ((phBrush != NULL) && hBrush)
        {
            *phBrush = hBrush;
        }
    }

    return hdc;
}


//---------------------------------------------------------------------------//
//
VOID Button_ReleaseDC(PBUTN pbutn, HDC hdc, HBRUSH *phBrush)
{
    ULONG ulStyleEx = GET_EXSTYLE(pbutn);

    if ((ulStyleEx & WS_EX_RTLREADING) != 0)
    {
        SetTextAlign(hdc, GetTextAlign(hdc) & ~TA_RTLREADING);
    }

    if (pbutn->hFont) 
    {
        SelectObject(hdc, GetStockObject(SYSTEM_FONT));
    }

    ReleaseDC(pbutn->ci.hwnd, hdc);
}


//---------------------------------------------------------------------------//
//
VOID Button_OwnerDraw(PBUTN pbutn, HDC hdc, UINT itemAction)
{
    DRAWITEMSTRUCT drawItemStruct;
    UINT itemState = 0;
    int  iButtonId = GetWindowID(pbutn->ci.hwnd);

    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN)) 
    {
        itemState |= ODS_NOFOCUSRECT;
    }

    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN)) 
    {
        itemState |= ODS_NOACCEL;
    }

    if (TESTFLAG(BUTTONSTATE(pbutn), BST_FOCUS)) 
    {
        itemState |= ODS_FOCUS;
    }

    if (TESTFLAG(BUTTONSTATE(pbutn), BST_PUSHED)) 
    {
        itemState |= ODS_SELECTED;
    }

    if (!IsWindowEnabled(pbutn->ci.hwnd))
    {
        itemState |= ODS_DISABLED;
    }

    //
    // Populate the draw item struct
    //
    drawItemStruct.CtlType    = ODT_BUTTON;
    drawItemStruct.CtlID      = iButtonId;
    drawItemStruct.itemAction = itemAction;
    drawItemStruct.itemState  = itemState;
    drawItemStruct.hwndItem   = pbutn->ci.hwnd;
    drawItemStruct.hDC        = hdc;
    GetClientRect(pbutn->ci.hwnd, &drawItemStruct.rcItem);
    drawItemStruct.itemData   = 0L;

    //
    // Send a WM_DRAWITEM message to our parent
    //
    SendMessage(GetParent(pbutn->ci.hwnd), 
                WM_DRAWITEM, 
                (WPARAM)iButtonId,
                (LPARAM)&drawItemStruct);
}


//---------------------------------------------------------------------------//
//
VOID Button_CalcRect(PBUTN pbutn, HDC hdc, LPRECT lprc, int iCode, UINT uFlags)
{
    CONST TCHAR szOneChar[] = TEXT("0");

    SIZE   sizeExtent;
    int    dy;
    LPTSTR lpName = NULL;
    WORD   wAlign;
    int    cxEdge, cyEdge;
    int    cxBorder, cyBorder;

    ULONG  ulStyle   = GET_STYLE(pbutn);
    ULONG  ulStyleEx = GET_EXSTYLE(pbutn);

    cxEdge   = GetSystemMetrics(SM_CXEDGE);
    cyEdge   = GetSystemMetrics(SM_CYEDGE);
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);

    GetClientRect(pbutn->ci.hwnd, lprc);

    wAlign = GetAlignment(pbutn);

    switch (iCode) 
    {
    case CBR_PUSHBUTTON:
        //
        // Subtract out raised edge all around
        //
        InflateRect(lprc, -cxEdge, -cyEdge);

        if (uFlags & PBF_DEFAULT)
        {
            InflateRect(lprc, -cxBorder, -cyBorder);
        }
        break;

    case CBR_CHECKBOX:
    case CBR_RADIOBUTTON:
    {
        SIZE sizeChk = {0};

        GetCheckBoxSize(hdc, pbutn, (iCode == CBR_CHECKBOX), &sizeChk);

        switch (wAlign & HIBYTE(BS_VERTMASK))
        {
        case HIBYTE(BS_VCENTER):
            lprc->top = (lprc->top + lprc->bottom - sizeChk.cy) / 2;
            break;

        case HIBYTE(BS_TOP):
        case HIBYTE(BS_BOTTOM):
            GetTextExtentPoint32(hdc, (LPTSTR)szOneChar, 1, &sizeExtent);
            dy = sizeExtent.cy + sizeExtent.cy/4;

            //
            // Save vertical extent
            //
            sizeExtent.cx = dy;

            //
            // Get centered amount
            //
            dy = (dy - sizeChk.cy) / 2;
            if ((wAlign & HIBYTE(BS_VERTMASK)) == HIBYTE(BS_TOP))
            {
                lprc->top += dy;
            }
            else
            {
                lprc->top = lprc->bottom - sizeExtent.cx + dy;
            }

            break;
        }

        if ((ulStyle & BS_RIGHTBUTTON) != 0)
        {
            lprc->left = lprc->right - sizeChk.cx;
        }
        else
        {
            lprc->right = lprc->left + sizeChk.cx;
        }

        break;
    }

    case CBR_CHECKTEXT:
    {
        SIZE sizeChk = {0};

        GetCheckBoxSize(hdc, pbutn, TRUE, &sizeChk);

        if ((ulStyle & BS_RIGHTBUTTON) != 0) 
        {
            lprc->right -= sizeChk.cx;

            //
            // More spacing for 4.0 dudes
            //
            if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT)) 
            {
                GetTextExtentPoint32(hdc, szOneChar, 1, &sizeExtent);
                lprc->right -= sizeExtent.cx  / 2;
            }

        } 
        else 
        {
            lprc->left += sizeChk.cx;

            //
            // More spacing for 4.0 dudes
            //
            if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT)) 
            {
                GetTextExtentPoint32(hdc, szOneChar, 1, &sizeExtent);
                lprc->left +=  sizeExtent.cx / 2;
            }
        }

        break;
    }

    case CBR_GROUPTEXT:
    {
        int  cch = GetWindowTextLength(pbutn->ci.hwnd);

        if (cch != 0)
        {
            //
            // Always use WCHAR for alloc because of MBCS
            //
            lpName = _alloca((cch+1)*sizeof(WCHAR));
        }

        if (cch == 0 || lpName == NULL || GetWindowText(pbutn->ci.hwnd, lpName, cch+1) == 0)
        {
            SetRectEmpty(lprc);
            break;
        }

        //
        // if not themed
        //
        if (!Button_IsThemed(pbutn))
        {
            GetTextExtentPoint32(hdc, lpName, cch, &sizeExtent);
        }
        else
        {
            DWORD dwTextFlags = Button_GetTextFlags(pbutn);
            RECT  rcExtent;
            GetThemeTextExtent(pbutn->hTheme, 
                               hdc, 
                               BP_GROUPBOX, 
                               0, 
                               lpName,
                               cch,
                               dwTextFlags,
                               lprc,
                               &rcExtent);

            sizeExtent.cx = RECTWIDTH(rcExtent);
            sizeExtent.cy = RECTHEIGHT(rcExtent);
                                
        }
        sizeExtent.cx += GetSystemMetrics(SM_CXEDGE) * 2;

        switch (wAlign & HIBYTE(BS_HORZMASK))
        {
        //
        // BFLEFT, nothing
        //
        case HIBYTE(BS_LEFT):
            lprc->left += (SYSFONT_CXCHAR - GetSystemMetrics(SM_CXBORDER));
            lprc->right = lprc->left + (int)(sizeExtent.cx);
            break;

        case HIBYTE(BS_RIGHT):
            lprc->right -= (SYSFONT_CXCHAR - GetSystemMetrics(SM_CXBORDER));
            lprc->left = lprc->right - (int)(sizeExtent.cx);
            break;

        case HIBYTE(BS_CENTER):
            lprc->left = (lprc->left + lprc->right - (int)(sizeExtent.cx)) / 2;
            lprc->right = lprc->left + (int)(sizeExtent.cx);
            break;
        }

        //
        // Center aligned.
        //
        lprc->bottom = lprc->top + sizeExtent.cy + GetSystemMetrics(SM_CYEDGE);
        break;
    }

    case CBR_GROUPFRAME:
        GetTextExtentPoint32(hdc, (LPTSTR)szOneChar, 1, &sizeExtent);
        lprc->top += sizeExtent.cy / 2;
        break;
    }
}


//---------------------------------------------------------------------------//
//
// Button_MultiExtent()
//
// Calculates button text extent, given alignment flags.
//
VOID Button_MultiExtent(WORD wFlags, HDC hdc, LPRECT lprcMax, LPTSTR lpsz, int cch, PINT pcx, PINT pcy)
{
    RECT rc;
    UINT dtFlags = DT_CALCRECT | DT_WORDBREAK | DT_EDITCONTROL;

    CopyRect(&rc, lprcMax);

    //
    // Note that since we're just calculating the maximum dimensions,
    // left-justification and top-justification are not important.
    // Also, remember to leave margins horz and vert that follow our rules
    // in DrawBtnText().
    //

    InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), -GetSystemMetrics(SM_CYBORDER));

    if ((wFlags & LOWORD(BS_HORZMASK)) == LOWORD(BS_CENTER))
    {
        dtFlags |= DT_CENTER;
    }

    if ((wFlags & LOWORD(BS_VERTMASK)) == LOWORD(BS_VCENTER))
    {
        dtFlags |= DT_VCENTER;
    }

    DrawTextEx(hdc, lpsz, cch, &rc, dtFlags, NULL);

    if (pcx)
    {
        *pcx = rc.right-rc.left;
    }

    if (pcy)
    {
        *pcy = rc.bottom-rc.top;
    }
}


//---------------------------------------------------------------------------//
//
// Button_MultiDraw()
//
// Draws multiline button text
//
BOOL Button_MultiDraw(HDC hdc, LPBTNDATA lpbd, int cch, int cx, int cy)
{
    RECT  rc;
    UINT  dtFlags = DT_WORDBREAK | DT_EDITCONTROL;
    PBUTN pbutn   = lpbd->pbutn;

    if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN)) 
    {
        dtFlags |= DT_HIDEPREFIX;
    } 
    else if (pbutn->fPaintKbdCuesOnly)
    {
        dtFlags |= DT_PREFIXONLY;
    }

    rc.left    = 0;
    rc.top     = 0;
    rc.right   = cx;
    rc.bottom  = cy;

    //
    // Horizontal alignment
    //
    UserAssert(DT_LEFT == 0);
    switch (lpbd->wFlags & LOWORD(BS_HORZMASK)) 
    {
    case LOWORD(BS_CENTER):
        dtFlags |= DT_CENTER;
        break;

    case LOWORD(BS_RIGHT):
        dtFlags |= DT_RIGHT;
        break;
    }

    //
    // Vertical alignment
    //
    UserAssert(DT_TOP == 0);
    switch (lpbd->wFlags & LOWORD(BS_VERTMASK))
    {
        case LOWORD(BS_VCENTER):
            dtFlags |= DT_VCENTER;
            break;

        case LOWORD(BS_BOTTOM):
            dtFlags |= DT_BOTTOM;
            break;
    }

    DrawTextEx(hdc, lpbd->lpsz, cch, &rc, dtFlags, NULL);

    return TRUE;
}

//---------------------------------------------------------------------------//
//
BOOL Button_SetCapture(PBUTN pbutn, UINT uCodeMouse)
{
    BUTTONSTATE(pbutn) |= uCodeMouse;

    if (!(BUTTONSTATE(pbutn) & BST_CAPTURED)) 
    {
        SetCapture(pbutn->ci.hwnd);
        BUTTONSTATE(pbutn) |= BST_CAPTURED;

        //
        // To prevent redundant CLICK messages, we set the INCLICK bit so
        // the WM_SETFOCUS code will not do a Button_NotifyParent(BN_CLICKED).
        //
        BUTTONSTATE(pbutn) |= BST_INCLICK;

        SetFocus(pbutn->ci.hwnd);

        BUTTONSTATE(pbutn) &= ~BST_INCLICK;
    }

    return BUTTONSTATE(pbutn) & BST_CAPTURED;
}


//---------------------------------------------------------------------------//
//
VOID Button_NotifyParent(PBUTN pbutn, UINT uCode)
{
    HWND hwndParent = GetParent(pbutn->ci.hwnd);
    int  iButtonId = GetWindowID(pbutn->ci.hwnd);

    if ( !hwndParent )
    {
        hwndParent = pbutn->ci.hwnd;
    }

    SendMessage(hwndParent, 
                WM_COMMAND,
                MAKELONG(iButtonId, uCode), 
                (LPARAM)pbutn->ci.hwnd);
}


//---------------------------------------------------------------------------//
//
VOID Button_ReleaseCapture(PBUTN pbutn, BOOL fCheck)
{
    UINT  uCheck;
    BOOL  fNotifyParent = FALSE;
    ULONG ulStyle = GET_STYLE(pbutn);

    if (BUTTONSTATE(pbutn) & BST_PUSHED) 
    {

        SendMessage(pbutn->ci.hwnd, BM_SETSTATE, FALSE, 0);

        if (fCheck) 
        {
            switch (GetButtonType(ulStyle)) 
            {
            case BS_AUTOCHECKBOX:
            case BS_AUTO3STATE:

                uCheck = (UINT)((BUTTONSTATE(pbutn) & BST_CHECKMASK) + 1);

                if (uCheck > (UINT)(GetButtonType(ulStyle) == BS_AUTO3STATE ? BST_INDETERMINATE : BST_CHECKED)) 
                {
                    uCheck = BST_UNCHECKED;
                }

                SendMessage(pbutn->ci.hwnd, BM_SETCHECK, uCheck, 0);

                break;

            case BS_AUTORADIOBUTTON:
                {
                    //
                    // Walk the radio buttons in the same group as us. Check ourself
                    // and uncheck everyone else. 
                    //
                    HWND hwndNext   = pbutn->ci.hwnd;
                    HWND hwndParent = GetParent(pbutn->ci.hwnd);

                    do 
                    {
                        if ((UINT)SendMessage(hwndNext, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON) 
                        {
                            SendMessage(hwndNext, BM_SETCHECK, hwndNext == pbutn->ci.hwnd, 0L);
                        }

                        hwndNext = GetNextDlgGroupItem(hwndParent, hwndNext, FALSE);
                    } 
                    //
                    // Loop until we see ourself again
                    //
                    while (hwndNext != pbutn->ci.hwnd);

                    break;
                }
            }

            fNotifyParent = TRUE;
        }
    }

    if (BUTTONSTATE(pbutn) & BST_CAPTURED) 
    {
        BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);
        ReleaseCapture();
    }

    if (fNotifyParent) 
    {
        //
        // We have to do the notification after setting the buttonstate bits.
        //
        Button_NotifyParent(pbutn, BN_CLICKED);
    }
}


//---------------------------------------------------------------------------//
//
// Button_DrawText()
//
// Draws text of button.
//
VOID Button_DrawText(PBUTN pbutn, HDC hdc, BOOL dbt, BOOL fDepress)
{

    RECT    rc;
    HBRUSH  hbr;
    LPTSTR  lpName;
    int     x = 0, y = 0;
    int     cx = 0, cy = 0;
    BYTE    bStyle;
    UINT    dsFlags;
    BTNDATA bdt;
    UINT    pbfPush;
    ULONG   ulStyle = GET_STYLE(pbutn);
    int     cch;

    bStyle = GetButtonStyle(ulStyle);

    if ((bStyle == LOBYTE(BS_GROUPBOX)) && (dbt == DBT_FOCUS))
    {
        return;
    }

    pbfPush = IsPushButton(pbutn);

    cch = GetWindowTextLength(pbutn->ci.hwnd);

    lpName = _alloca((cch + 1) * sizeof(wchar_t));
    if (lpName == NULL) 
    {
        return;
    }

    GetWindowText(pbutn->ci.hwnd, lpName, cch + 1);

    //
    // if not themed
    //
    if (!Button_IsThemed(pbutn))
    {
        if (pbfPush) 
        {
            Button_CalcRect(pbutn, hdc, &rc, CBR_PUSHBUTTON, pbfPush);
            IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

            //
            // This is because we didn't have WM_CTLCOLOR,
            // CTLCOLOR_BTN actually set up the button colors.  For
            // old apps, CTLCOLOR_BTN needs to work like CTLCOLOR_STATIC.
            //
            SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
            SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
            hbr = GetSysColorBrush(COLOR_BTNTEXT);

        } 
        else 
        {
            Button_CalcRect(pbutn, hdc, &rc, mpStyleCbr[bStyle], pbfPush);

            //
            // Skip stuff for ownerdraw buttons, since we aren't going to
            // draw text/image.
            //
            if (bStyle == LOBYTE(BS_OWNERDRAW))
            {
                goto DrawFocus;
            }
            else
            {
                hbr = GetSysColorBrush(COLOR_WINDOWTEXT);
            }
        }

        if (pbutn->himl)
        {
            int x, y;
            Button_GetImagePosition(pbutn, &rc, &x, &y);

            if (fDepress) 
            {
                x += GetSystemMetrics(SM_CXBORDER);
                y += GetSystemMetrics(SM_CYBORDER);
            }

            ImageList_Draw(pbutn->himl, 0, hdc, x, y, ILD_TRANSPARENT | (CCDPIScale(pbutn->ci)?ILD_DPISCALE:0));
        }

        //
        // Alignment
        //
        bdt.wFlags = GetAlignment(pbutn);
        bdt.pbutn = pbutn;

        //
        // Bail if we have nothing to draw
        //
        if ((ulStyle & BS_BITMAP) != 0) 
        {
            BITMAP bmp;

            //
            // Bitmap button
            //
            if (!pbutn->hImage)
            {
                return;
            }

            GetObject(pbutn->hImage, sizeof(BITMAP), &bmp);
            cx = bmp.bmWidth;
            cy = bmp.bmHeight;

            dsFlags = DST_BITMAP;
            goto UseImageForName;

        } 
        else if ((ulStyle & BS_ICON) != 0) 
        {
            SIZE sizeIcon;

            //
            // Icon button
            //
            if (!pbutn->hImage)
            {
                return;
            }

            GetIconSize(pbutn->hImage, &sizeIcon);
            cx = sizeIcon.cx;
            cy = sizeIcon.cy;

            dsFlags = DST_ICON;
    UseImageForName:
            lpName = (LPTSTR)pbutn->hImage;
            cch = TRUE;
        } 
        else 
        {
            //
            // Text button
            //
            if (cch == 0) 
            {
                return;
            }

            if ((ulStyle & BS_MULTILINE) != 0) 
            {

                bdt.lpsz = lpName;

                Button_MultiExtent(bdt.wFlags, hdc, &rc, lpName, cch, &cx, &cy);

                lpName = (LPTSTR)(LPBTNDATA)&bdt;
                dsFlags = DST_COMPLEX;

            } 
            else 
            {
                SIZE   size;
                LPWSTR lpwstr = UserLocalAlloc(0, sizeof(WCHAR)*(cch+1));

                //
                // Try to get the text extent with mnemonics stripped.
                //
                if (lpwstr != NULL)
                {
                    int iLen = StripAccelerators(lpName, lpwstr, TRUE);
                    GetTextExtentPoint32(hdc, lpwstr, iLen, &size);
                    UserLocalFree(lpwstr);
                }
                else
                {
                    GetTextExtentPoint32(hdc, lpName, cch, &size);
                }

                cx = size.cx;
                cy = size.cy;

                //
                // If the control doesn't need underlines, set DST_HIDEPREFIX and
                // also do not show the focus indicator
                //
                dsFlags = DST_PREFIXTEXT;
                if (TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIACCELHIDDEN)) 
                {
                    dsFlags |= DSS_HIDEPREFIX;
                } 
                else if (pbutn->fPaintKbdCuesOnly) 
                {
                    dsFlags |= DSS_PREFIXONLY;
                }
            }


            //
            // Add on a pixel or two of vertical space to make centering
            // happier.  That way underline won't abut focus rect unless
            // spacing is really tight.
            //
            cy++;
        }

        //
        // ALIGNMENT
        //

        //
        // Horizontal
        //
        switch (bdt.wFlags & HIBYTE(BS_HORZMASK)) 
        {
        //
        // For left & right justified, we leave a margin of CXEDGE on either
        // side for eye-pleasing space.
        //
        case HIBYTE(BS_LEFT):
            x = rc.left + GetSystemMetrics(SM_CXEDGE);
            break;

        case HIBYTE(BS_RIGHT):
            x = rc.right - cx - GetSystemMetrics(SM_CXEDGE);
            break;

        default:
            x = (rc.left + rc.right - cx) / 2;
            break;
        }

        //
        // Vertical
        //
        switch (bdt.wFlags & HIBYTE(BS_VERTMASK)) 
        {
        //
        // For top & bottom justified, we leave a margin of CYBORDER on
        // either side for more eye-pleasing space.
        //
        case HIBYTE(BS_TOP):
            y = rc.top + GetSystemMetrics(SM_CYBORDER);
            break;

        case HIBYTE(BS_BOTTOM):
            y = rc.bottom - cy - GetSystemMetrics(SM_CYBORDER);
            break;

        default:
            y = (rc.top + rc.bottom - cy) / 2;
            break;
        }

        //
        // Draw the text
        //
        if (dbt & DBT_TEXT) 
        {
            //
            // This isn't called for USER buttons.
            //
            UserAssert(bStyle != LOBYTE(BS_USERBUTTON));

            if (fDepress) 
            {
                x += GetSystemMetrics(SM_CXBORDER);
                y += GetSystemMetrics(SM_CYBORDER);
            }

            if ( !IsWindowEnabled(pbutn->ci.hwnd) ) 
            {
                UserAssert(HIBYTE(BS_ICON) == HIBYTE(BS_BITMAP));
                if (GetSystemMetrics(SM_SLOWMACHINE)  &&
                    ((ulStyle & (BS_ICON | BS_BITMAP)) != 0) &&
                    (GetBkColor(hdc) != GetSysColor(COLOR_GRAYTEXT)))
                {
                    //
                    // Perf && consistency with menus, statics
                    //
                    SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
                }
                else
                {
                    dsFlags |= DSS_DISABLED;
                }
            }

            //
            // Use transparent mode for checked push buttons since we're going to
            // fill background with dither.
            //
            if (pbfPush) 
            {
                switch (BUTTONSTATE(pbutn) & BST_CHECKMASK) 
                {
                case BST_INDETERMINATE:
                    hbr = GetSysColorBrush(COLOR_GRAYTEXT);
                    dsFlags |= DSS_MONO;
                    //
                    // FALL THRU
                    //

                case BST_CHECKED:
                    //
                    // Drawing on dithered background...
                    //
                    SetBkMode(hdc, TRANSPARENT);
                    break;
                }
            }

            //
            // Use brush and colors currently selected into hdc when we grabbed
            // color
            //
            DrawState(hdc, hbr, (DRAWSTATEPROC)Button_MultiDraw, (LPARAM)lpName,
                (WPARAM)cch, x, y, cx, cy,
                dsFlags);
        }

    }

    // Draw focus rect.
    //
    // This can get called for OWNERDRAW and USERDRAW buttons. However, only
    // OWNERDRAW buttons let the owner change the drawing of the focus button.
DrawFocus:
    if (dbt & DBT_FOCUS) 
    {
        if (bStyle == LOBYTE(BS_OWNERDRAW)) 
        {
            //
            // For ownerdraw buttons, this is only called in response to a
            // WM_SETFOCUS or WM_KILL FOCUS message.  So, we can check the
            // new state of the focus by looking at the BUTTONSTATE bits
            // which are set before this procedure is called.
            //
            Button_OwnerDraw(pbutn, hdc, ODA_FOCUS);
        } 
        else 
        {
            //
            // Don't draw the focus if underlines are not turned on
            //
            if (!TESTFLAG(GET_EXSTYLE(pbutn), WS_EXP_UIFOCUSHIDDEN)) 
            {
                //
                // Let focus rect always hug edge of push buttons.  We already
                // have the client area setup for push buttons, so we don't have
                // to do anything.
                //
                if (!pbfPush) 
                {
                    RECT rcClient;

                    GetClientRect(pbutn->ci.hwnd, &rcClient);
                    
                    if (bStyle == LOBYTE(BS_USERBUTTON))
                    {
                        CopyRect(&rc, &rcClient);
                    } 
                    else if (Button_IsThemed(pbutn))
                    {
                        //
                        // if themed
                        //
                        int iPartId = 0;
                        int iStateId = 0;

                        Button_GetThemeIds(pbutn, &iPartId, &iStateId);
                        GetThemeBackgroundContentRect(pbutn->hTheme,
                                                      hdc,
                                                      iPartId,
                                                      iStateId,
                                                      &rcClient,
                                                      &rc);

                        GetThemeTextExtent(pbutn->hTheme, 
                                           hdc, 
                                           iPartId, 
                                           iStateId, 
                                           lpName, 
                                           -1,
                                           Button_GetTextFlags(pbutn), 
                                           &rc, 
                                           &rc);

                        //
                        // Inflate the bounding rect a litte, but contrained to
                        // within the client area.
                        //
                        rc.top = max(rcClient.top, rc.top-1);
                        rc.bottom = min(rcClient.bottom, rc.bottom+1);

                        rc.left = max(rcClient.left, rc.left-1);
                        rc.right = min(rcClient.right, rc.right+1);
                    }
                    else 
                    {
                        //
                        // Try to leave a border all around text.  That causes
                        // focus to hug text.
                        //
                        rc.top = max(rcClient.top, y-GetSystemMetrics(SM_CYBORDER));
                        rc.bottom = min(rcClient.bottom, rc.top + GetSystemMetrics(SM_CYEDGE) + cy);

                        rc.left = max(rcClient.left, x-GetSystemMetrics(SM_CXBORDER));
                        rc.right = min(rcClient.right, rc.left + GetSystemMetrics(SM_CXEDGE) + cx);
                    }
                } 
                else
                {
                    InflateRect(&rc, -GetSystemMetrics(SM_CXBORDER), -GetSystemMetrics(SM_CYBORDER));
                }

                //
                // Are back & fore colors set properly?
                //
                DrawFocusRect(hdc, &rc);
            }
        }
    }
}


//---------------------------------------------------------------------------//
//
//  DrawCheck()
//
VOID Button_DrawCheck(PBUTN pbutn, HDC hdc, HBRUSH hBrush)
{
    //
    // if not themed
    //
    if (!Button_IsThemed(pbutn))       // Images don't have a mask so look ugly. Need to use old painting
    {
        RECT  rc;
        UINT  uFlags;
        BOOL  fDoubleBlt = FALSE;
        ULONG ulStyle = GET_STYLE(pbutn);
        SIZE  sizeChk = {0};

        Button_CalcRect(pbutn, hdc, &rc, CBR_CHECKBOX, 0);

        uFlags = 0;

        if ( BUTTONSTATE(pbutn) & BST_CHECKMASK )
        {
            uFlags |= DFCS_CHECKED;
        }

        if ( BUTTONSTATE(pbutn) & BST_PUSHED )
        {
            uFlags |= DFCS_PUSHED;
        }

        if ( !IsWindowEnabled(pbutn->ci.hwnd) )
        {
            uFlags |= DFCS_INACTIVE;
        }

        switch (GetButtonType(ulStyle)) 
        {
        case BS_AUTORADIOBUTTON:
        case BS_RADIOBUTTON:
            fDoubleBlt = TRUE;
            uFlags |= DFCS_BUTTONRADIO;
            break;

        case BS_3STATE:
        case BS_AUTO3STATE:
            if ((BUTTONSTATE(pbutn) & BST_CHECKMASK) == BST_INDETERMINATE) 
            {
                uFlags |= DFCS_BUTTON3STATE;
                break;
            }
            //
            // FALL THRU
            //

        default:
            uFlags |= DFCS_BUTTONCHECK;
            break;
        }

        if ((ulStyle & BS_FLAT) != 0)
        {
            uFlags |= DFCS_FLAT | DFCS_MONO;
        }

        GetCheckBoxSize(hdc, pbutn, TRUE, &sizeChk);

        rc.right = rc.left + sizeChk.cx;
        rc.bottom = rc.top + sizeChk.cy;

        FillRect(hdc, &rc, hBrush);

        DrawFrameControl(hdc, &rc, DFC_BUTTON, uFlags);
    }
    else
    {
        int iStateId = 0;
        int iPartId = 0;

        Button_GetThemeIds(pbutn, &iPartId, &iStateId);

        if ((iPartId != BP_RADIOBUTTON) && (iPartId != BP_CHECKBOX))
        {
            TraceMsg(TF_STANDARD, "Button_DrawCheck: Not a radio or check, iPartId = %d", iPartId);
            return;
        }
        

        Button_DrawThemed(pbutn, hdc, iPartId, iStateId);

    }
}


//---------------------------------------------------------------------------//
//
VOID Button_DrawNewState(PBUTN pbutn, HDC hdc, HBRUSH hbr, UINT sOld)
{
    if (sOld != (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED)) 
    {
        UINT    pbfPush;
        ULONG   ulStyle = GET_STYLE(pbutn);

        pbfPush = IsPushButton(pbutn);

        switch (GetButtonType(ulStyle)) 
        {
        case BS_GROUPBOX:
        case BS_OWNERDRAW:
            break;

        default:
            if (!pbfPush) 
            {
                Button_DrawCheck(pbutn, hdc, hbr);
                break;
            }

        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
        case BS_PUSHBOX:
            Button_DrawPush(pbutn, hdc, pbfPush);
            break;
        }
    }
}


//---------------------------------------------------------------------------//
//
// Button_DrawPush()
//
// Draws push-like button with text
//
VOID Button_DrawPush(PBUTN pbutn, HDC hdc, UINT pbfPush)
{

    //
    // if not themed
    //
    if (!Button_IsThemed(pbutn))
    {

        RECT  rc;
        UINT  uFlags = 0;
        UINT  uState = 0;
        ULONG ulStyle = GET_STYLE(pbutn);
        NMCUSTOMDRAW nmcd = {0};

        //
        // Always a push button if calling this function
        //
        uState = DFCS_BUTTONPUSH;

        GetClientRect(pbutn->ci.hwnd, &rc);
        nmcd.hdc = hdc;
        nmcd.rc = rc;
        nmcd.dwItemSpec = GetWindowID(pbutn->ci.hwnd);
        nmcd.uItemState = ButtonStateToCustomDrawState(pbutn);

        if (BUTTONSTATE(pbutn) & BST_PUSHED)
        {
            uState |= DFCS_PUSHED;
        }

        pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREERASE, &nmcd);

        if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
        {
            if (!pbutn->fPaintKbdCuesOnly) 
            {

                if (BUTTONSTATE(pbutn) & BST_CHECKMASK)
                {
                    uState |= DFCS_CHECKED;
                }

                if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT)) 
                {
                    uFlags = BF_SOFT;
                }

                if ((ulStyle & BS_FLAT) != 0)
                {
                    uFlags |= DFCS_FLAT | DFCS_MONO;
                }

                if (pbfPush & PBF_DEFAULT) 
                {
                    int cxBorder = GetSystemMetrics(SM_CXBORDER);
                    int cyBorder = GetSystemMetrics(SM_CYBORDER);

                    int clFrame = 1;

                    int x = rc.left;
                    int y = rc.top;
        
                    int cxWidth = cxBorder * clFrame;
                    int cyWidth = cyBorder * clFrame;
        
                    int cx = rc.right - x - cxWidth;
                    int cy = rc.bottom - y - cyWidth;

                    HBRUSH hbrFill = GetSysColorBrush(COLOR_WINDOWFRAME);
                    HBRUSH hbrSave = SelectObject(hdc, hbrFill);

                    PatBlt(hdc, x, y, cxWidth, cy, PATCOPY);
                    PatBlt(hdc, x + cxWidth, y, cx, cyWidth, PATCOPY);
                    PatBlt(hdc, x, y + cy, cx, cyWidth, PATCOPY);
                    PatBlt(hdc, x + cx, y + cyWidth, cxWidth, cy, PATCOPY);

                    SelectObject(hdc, hbrSave);

                    InflateRect(&rc, -cxBorder, -cyBorder);

                    if (uState & DFCS_PUSHED)
                    {
                        uFlags |= DFCS_FLAT;
                    }
                }

                DrawFrameControl(hdc, &rc, DFC_BUTTON, uState | uFlags);
            }
            if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTERASE)
                CICustomDrawNotify(&pbutn->ci, CDDS_POSTERASE, &nmcd);

            pbutn->ci.dwCustom = CICustomDrawNotify(&pbutn->ci, CDDS_PREPAINT, &nmcd);

            if (!(pbutn->ci.dwCustom & CDRF_SKIPDEFAULT))
            {
                Button_DrawText(pbutn, hdc, DBT_TEXT | (BUTTONSTATE(pbutn) &
                       BST_FOCUS ? DBT_FOCUS : 0), (uState & DFCS_PUSHED));

                if (pbutn->ci.dwCustom & CDRF_NOTIFYPOSTPAINT)
                    CICustomDrawNotify(&pbutn->ci, CDDS_POSTPAINT, &nmcd);
            }

        }
    }
    else
    {
        int iStateId = 0;
        int iPartId = 0;

        Button_GetThemeIds(pbutn, &iPartId, &iStateId);
        if (iPartId != BP_PUSHBUTTON)
        {
            TraceMsg(TF_STANDARD, "Not a Pushbutton");
            return;
        }
        Button_DrawThemed(pbutn, hdc, iPartId, iStateId);

    }
}


BOOL Button_OnSetImageList(PBUTN pbutn, BUTTON_IMAGELIST* biml)
{
    BOOL fRet = FALSE;

    if (biml)
    {
        if (biml->himl)
        {
            pbutn->rcIcon = biml->margin;
            pbutn->himl = biml->himl;
            pbutn->uAlign = biml->uAlign;

            fRet = TRUE;
        }
    }
    return fRet;
}

void ApplyMarginsToRect(RECT* prcm, RECT* prc)
{
    prc->left -= prcm->left;
    prc->top -= prcm->top;
    prc->right += prcm->right;
    prc->bottom += prcm->bottom;
}

BOOL Button_OnGetIdealSize(PBUTN pbutn, PSIZE psize)
{
    UINT   bsWnd;
    RECT   rc = {0};
    HBRUSH hBrush;
    HDC hdc;

    if (psize == NULL)
        return FALSE;

    GetWindowRect(pbutn->ci.hwnd, &rc);

    hdc = GetDC (pbutn->ci.hwnd);
    if (hdc)
    {
        ULONG  ulStyle = GET_STYLE(pbutn);

        bsWnd = GetButtonType(ulStyle);
        hBrush = Button_InitDC(pbutn, hdc);

        switch (bsWnd) 
        {
        case BS_PUSHBUTTON:
        case BS_DEFPUSHBUTTON:
            {
                PWSTR pName;
                int cch = GetWindowTextLength(pbutn->ci.hwnd);

                pName = _alloca((cch + 1) * sizeof(wchar_t));
                if (pName) 
                {
                    RECT rcText={0};
                    RECT rcIcon={0};
                    int cx = 0, cy = 0;
                    int iStateId = 0;
                    int iPartId = 0;


                    GetWindowText(pbutn->ci.hwnd, pName, cch + 1);

                    if (Button_IsThemed(pbutn))
                    {
                        Button_GetThemeIds(pbutn, &iPartId, &iStateId);

                        // First: Get the text rect
                        GetThemeTextExtent(pbutn->hTheme, hdc, iPartId, iStateId, pName, cch, 0, &rcText, &rcText);
                        ApplyMarginsToRect(&pbutn->rcText, &rcText);

                        rc = rcText;

                        // We should now have The button with text.
                    }
                    else
                    {
                        int cxWidth = 2 * GetSystemMetrics(SM_CXEDGE);
                        int cyWidth = 3 * GetSystemMetrics(SM_CYEDGE);
                        if (IsPushButton(pbutn) & PBF_DEFAULT)
                        {
                            cxWidth += 2 * GetSystemMetrics(SM_CXBORDER);
                            cyWidth += 2 * GetSystemMetrics(SM_CXBORDER);
                        }

                        DrawText(hdc, pName, cch, &rcText, DT_CALCRECT);
                        ApplyMarginsToRect(&pbutn->rcText, &rcText);

                        rcText.bottom += cyWidth + 1;   // +1 because draw text adds a single pixel to the first char, but not the last...
                        rcText.right += cxWidth + 1;
                    }

                    if (pbutn->himl)
                    {
                        rc.top = rc.left = 0;       // We turn this into a width not a position
                        CCGetIconSize(&pbutn->ci, pbutn->himl, &cx, &cy);
                        rcIcon.bottom = cy;
                        rcIcon.right = cx;
                        ApplyMarginsToRect(&pbutn->rcIcon, &rcIcon);
                        switch (pbutn->uAlign)
                        {
                        case BUTTON_IMAGELIST_ALIGN_TOP: 
                        case BUTTON_IMAGELIST_ALIGN_BOTTOM:
                            rc.bottom = RECTHEIGHT(rcIcon) + RECTHEIGHT(rcText);
                            rc.right = max(RECTWIDTH(rcIcon), RECTWIDTH(rcText));
                            break;

                        case BUTTON_IMAGELIST_ALIGN_CENTER:     // This means no text
                            rc.bottom = RECTHEIGHT(rcIcon);
                            rc.right = RECTWIDTH(rcIcon);
                            break;

                        case BUTTON_IMAGELIST_ALIGN_RIGHT:
                        case BUTTON_IMAGELIST_ALIGN_LEFT:
                            // Fall
                        default:
                            rc.right = RECTWIDTH(rcIcon) + RECTWIDTH(rcText);
                            rc.bottom = max(RECTHEIGHT(rcIcon), RECTHEIGHT(rcText));
                            break;

                        }
                    }
                    else
                    {
                        rc = rcText;
                    }

                    if (Button_IsThemed(pbutn))
                    {
                        GetThemeBackgroundExtent(pbutn->hTheme, hdc, iPartId, iStateId, &rc, &rc);
                    }

                }
            }
            break;
        }

        //
        // Release the font which may have been loaded by ButtonInitDC.
        //
        if (pbutn->hFont) 
        {
            SelectObject(hdc, GetStockObject(SYSTEM_FONT));
        }
        ReleaseDC(pbutn->ci.hwnd, hdc);
    }

    psize->cx = RECTWIDTH(rc);
    psize->cy = RECTHEIGHT(rc);

    return TRUE;
}


//---------------------------------------------------------------------------//
//
VOID Button_Paint(PBUTN pbutn, HDC hdc)
{
    RECT   rc;
    RECT   rcText;
    HBRUSH hBrush;
    HBRUSH hBrushSave = NULL;
    BOOL   fDrawBackground = TRUE;
    ULONG  ulStyle = GET_STYLE(pbutn);
    CCDBUFFER db = {0};
    UINT bsWnd = GetButtonType(ulStyle);
    UINT   pbfPush = IsPushButton(pbutn);
    BOOL fTransparent = FALSE;
    int    iPartId = 0;
    int    iStateId = 0;

    GetClientRect(pbutn->ci.hwnd, &rc);


    if (Button_IsThemed(pbutn) && 
        (bsWnd != LOBYTE(BS_GROUPBOX)) && 
        (bsWnd != LOBYTE(BS_OWNERDRAW)) && 
        !pbutn->fPaintKbdCuesOnly)
    {
        hdc = CCBeginDoubleBuffer(hdc, &rc, &db); 
        
        Button_GetThemeIds(pbutn, &iPartId, &iStateId);
        fTransparent = CCShouldAskForBits(&pbutn->ci, pbutn->hTheme, iPartId, iStateId);
        if (fTransparent)
        {
            fDrawBackground = (TRUE != CCSendPrint(&pbutn->ci, hdc));
        }
    }

    hBrush = Button_InitDC(pbutn, hdc);


    if ((!pbfPush || fTransparent) && !pbutn->fPaintKbdCuesOnly &&
        fDrawBackground)
    {
        if ((bsWnd != LOBYTE(BS_OWNERDRAW)) &&
            (bsWnd != LOBYTE(BS_GROUPBOX)))
        {
            //
            // Fill the client area with the background brush
            // before we begin painting.
            //
            FillRect(hdc, &rc, hBrush);
        }

        hBrushSave = SelectObject(hdc, hBrush);
    }

    switch (bsWnd) 
    {
    case BS_CHECKBOX:
    case BS_RADIOBUTTON:
    case BS_AUTORADIOBUTTON:
    case BS_3STATE:
    case BS_AUTOCHECKBOX:
    case BS_AUTO3STATE:
        if (!pbfPush) 
        {
            if (!Button_IsThemed(pbutn))
            {
                Button_DrawText(pbutn, hdc,
                    DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);
            }

            if (!pbutn->fPaintKbdCuesOnly || Button_IsThemed(pbutn)) 
            {
                Button_DrawCheck(pbutn, hdc, hBrush);
            }
            break;
        }
        //
        // Fall through for PUSHLIKE buttons
        //

    case BS_PUSHBUTTON:
    case BS_DEFPUSHBUTTON:
        Button_DrawPush(pbutn, hdc, pbfPush);
        break;

    case BS_PUSHBOX:
        Button_DrawText(pbutn, hdc,
            DBT_TEXT | (BUTTONSTATE(pbutn) & BST_FOCUS ? DBT_FOCUS : 0), FALSE);

        Button_DrawNewState(pbutn, hdc, hBrush, 0);
        break;

    case BS_USERBUTTON:
        // Don't support USERBUTTON in v6. This has been superceded by OWNERDRAW in win32.
        break;

    case BS_OWNERDRAW:
        Button_OwnerDraw(pbutn, hdc, ODA_DRAWENTIRE);
        break;

    case BS_GROUPBOX:
        Button_CalcRect(pbutn, hdc, &rcText, CBR_GROUPTEXT, 0);

        //----- get theme part, state for groupbox ----
        if (Button_IsThemed(pbutn))
        {
            Button_GetThemeIds(pbutn, &iPartId, &iStateId);
        }

        if (!pbutn->fPaintKbdCuesOnly) 
        {
            UINT uFlags;
            BOOL fFillMyself = TRUE;

            Button_CalcRect(pbutn, hdc, &rc, CBR_GROUPFRAME, 0);

            uFlags = ((ulStyle & BS_FLAT) != 0) ? BF_FLAT | BF_MONO : 0;
            if (!Button_IsThemed(pbutn))
            {
                DrawEdge(hdc, &rc, EDGE_ETCHED, BF_RECT | uFlags);
            }
            else
            {
                DrawThemeBackground(pbutn->hTheme, hdc, iPartId, iStateId, &rc, 0);
                fFillMyself = (FALSE == CCSendPrintRect(&pbutn->ci, hdc, &rcText));
            }

            if (fFillMyself)
            {
                FillRect(hdc, &rcText, hBrush);
            }
        }

        // FillRect(hdc, &rc, hBrush);
        if (!Button_IsThemed(pbutn))
        {
            Button_DrawText(pbutn, hdc, DBT_TEXT, FALSE);
        }
        else
        {
            DWORD    dwTextFlags;
            HRESULT  hr;
            int      cch;
            LPWSTR   lpName;

            cch = GetWindowTextLength(pbutn->ci.hwnd);
            lpName = UserLocalAlloc(0, sizeof(WCHAR)*(cch+1));
            if ( !lpName )
            {
                TraceMsg(TF_STANDARD, "Button_Paint couldn't allocate buffer");
                return;
            }
            GetWindowTextW(pbutn->ci.hwnd, lpName, cch+1);
            
            dwTextFlags = Button_GetTextFlags(pbutn);

            //
            // Button_CalcRect padded by a CXEDGE so the groupbox frame wouldn't
            // be flush with the Group text 
            //
            rcText.left += GetSystemMetrics(SM_CXEDGE);



            hr = DrawThemeText(pbutn->hTheme,
                               hdc,
                               iPartId,
                               iStateId,
                               lpName,
                               cch,
                               dwTextFlags,
                               0,
                               &rcText);

            if (FAILED(hr))
            {
                TraceMsg(TF_STANDARD, "Button_Paint failed to render groupbox text");
            }
            UserLocalFree(lpName);
        }
        break;
    }

    if (!pbfPush && hBrushSave)
    {
        SelectObject(hdc, hBrushSave);
    }

    //
    // Release the font which may have been loaded by ButtonInitDC.
    //
    if (pbutn->hFont) 
    {
        SelectObject(hdc, GetStockObject(SYSTEM_FONT));
    }

    CCEndDoubleBuffer(&db);


}


//---------------------------------------------------------------------------//
//
VOID Button_Repaint(PBUTN pbutn)
{
    HDC hdc = Button_GetDC(pbutn, NULL);

    if (hdc != NULL) 
    {
        Button_Paint(pbutn, hdc);
        Button_ReleaseDC(pbutn, hdc, NULL);
    }
}

VOID Button_SetHot(PBUTN pbutn, BOOL fHot, DWORD dwReason)
{
    NMBCHOTITEM nmhot = {0};

    // Send a notification about the hot item change
    if (fHot)
    {
        nmhot.dwFlags = HICF_ENTERING;
        pbutn->buttonState |= BST_HOT;
    }
    else
    {
        nmhot.dwFlags = HICF_LEAVING;
        pbutn->buttonState &= ~BST_HOT;
    }

    nmhot.dwFlags |= dwReason;

    CCSendNotify(&pbutn->ci, BCN_HOTITEMCHANGE, &nmhot.hdr);
}

void Button_EraseOwnerDraw(PBUTN pbutn, HDC hdc)
{
    if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_OWNERDRAW))
    {
        RECT rc;
        HBRUSH hbr;
        //
        // Handle erase background for owner draw buttons.
        //
        GetClientRect(pbutn->ci.hwnd, &rc);
        hbr = (HBRUSH)SendMessage(GetParent(pbutn->ci.hwnd), WM_CTLCOLORBTN, (WPARAM)hdc, (LPARAM)pbutn->ci.hwnd);
        FillRect(hdc, &rc, hbr);
    }
}

//---------------------------------------------------------------------------//
//
// Button_WndProc
//
// WndProc for buttons, check boxes, etc.
//
LRESULT APIENTRY Button_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    UINT        wOldState;
    RECT        rc;
    HDC         hdc;
    HBRUSH      hbr;
    PAINTSTRUCT ps;
    PBUTN       pbutn;
    LRESULT     lResult = FALSE;

    //
    // Get the instance data for this button control
    //
    pbutn = Button_GetPtr(hwnd);
    if (!pbutn && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }


    switch (uMsg) 
    {
    case WM_NCHITTEST:
        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_GROUPBOX)) 
        {
            lResult = (LONG)HTTRANSPARENT;
        } 
        else 
        {
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

            if ( lResult == HTCLIENT && Button_IsThemed(pbutn))
            {
                HRESULT hr;
                int     iPartId = 0;
                int     iStateId = 0;
                POINT   pt;
                WORD    wHitTestCode;

                hr = Button_GetThemeIds(pbutn, &iPartId, &iStateId);
                if ( SUCCEEDED(hr) )
                    GetWindowRect(pbutn->ci.hwnd, &rc);
                    pt.x = GET_X_LPARAM(lParam);
                    pt.y = GET_Y_LPARAM(lParam);
                    hr = HitTestThemeBackground(pbutn->hTheme, 
                                                NULL,
                                                iPartId, 
                                                iStateId, 
                                                0,
                                                &rc, 
                                                NULL,
                                                pt, 
                                                &wHitTestCode);
                    if ( SUCCEEDED(hr) && wHitTestCode == HTTRANSPARENT)
                    {
                        lResult = (LRESULT)HTTRANSPARENT;
                    }
            }
        }

        break;

    case WM_ERASEBKGND:
        Button_EraseOwnerDraw(pbutn, (HDC)wParam);
        //
        // Do nothing for other buttons, but don't let DefWndProc() do it
        // either.  It will be erased in Button_Paint().
        //
        lResult = (LONG)TRUE;
        break;

    case WM_PRINTCLIENT:
        Button_EraseOwnerDraw(pbutn, (HDC)wParam);
        Button_Paint(pbutn, (HDC)wParam);
        break;

    case WM_CREATE:
        pbutn->hTheme = Button_GetTheme(pbutn);
        CIInitialize(&pbutn->ci, hwnd, (LPCREATESTRUCT)lParam);

        SendMessage(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
        break;

    case WM_PAINT:
        {
            //
            // If wParam != NULL, then this is a subclassed paint.
            //
            if (wParam)
            {
                hdc = (HDC)wParam;
            }
            else
            {
                hdc = BeginPaint(hwnd, &ps);
            }

            if (IsWindowVisible(pbutn->ci.hwnd))
            {
                Button_Paint(pbutn, hdc);
            }

            if (!wParam)
            {
                EndPaint(hwnd, &ps);
            }
        }

        break;

    case WM_SETFOCUS:

        BUTTONSTATE(pbutn) |= BST_FOCUS;
        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_OWNERDRAW))
        {
            HDC hdc = Button_GetDC(pbutn, NULL);
            if (hdc)
            {
                Button_DrawText(pbutn, hdc, DBT_FOCUS, FALSE);
                Button_ReleaseDC(pbutn, hdc, NULL);
            }
        }
        else
        {
            InvalidateRect(pbutn->ci.hwnd, NULL, FALSE);
        }

        if ((GET_STYLE(pbutn)& BS_NOTIFY) != 0)
        {
            Button_NotifyParent(pbutn, BN_SETFOCUS);
        }

        if (!(BUTTONSTATE(pbutn) & BST_INCLICK)) 
        {
            switch (GetButtonType(GET_STYLE(pbutn))) 
            {
            case LOBYTE(BS_RADIOBUTTON):
            case LOBYTE(BS_AUTORADIOBUTTON):

                if (!(BUTTONSTATE(pbutn) & BST_DONTCLICK)) 
                {
                    if (!(BUTTONSTATE(pbutn) & BST_CHECKMASK)) 
                    {
                        Button_NotifyParent(pbutn, BN_CLICKED);
                    }
                }
                break;
            }
        }
        break;

    case WM_GETDLGCODE:

        lResult = DLGC_BUTTON;

        switch (GetButtonType(GET_STYLE(pbutn))) 
        {
        case LOBYTE(BS_DEFPUSHBUTTON):
            lResult |= DLGC_DEFPUSHBUTTON;
            break;

        case LOBYTE(BS_PUSHBUTTON):
        case LOBYTE(BS_PUSHBOX):
            lResult |= DLGC_UNDEFPUSHBUTTON;
            break;

        case LOBYTE(BS_AUTORADIOBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
            lResult |= DLGC_RADIOBUTTON;
            break;

        case LOBYTE(BS_GROUPBOX):
            //
            // remove DLGC_BUTTON
            //
            lResult = DLGC_STATIC;
            break;

        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):

            //
            // If this is a char that is a '=/+', or '-', we want it
            //
            if (lParam && ((LPMSG)lParam)->message == WM_CHAR) 
            {
                switch (wParam) 
                {
                case TEXT('='):
                case TEXT('+'):
                case TEXT('-'):
                    lResult |= DLGC_WANTCHARS;
                    break;

                }
            } 

            break;
        }

        break;

    case WM_CAPTURECHANGED:

        if (BUTTONSTATE(pbutn) & BST_CAPTURED) 
        {
            //
            // Unwittingly, we've been kicked out of capture,
            // so undepress etc.
            //
            if (BUTTONSTATE(pbutn) & BST_MOUSE)
            {
                SendMessage(pbutn->ci.hwnd, BM_SETSTATE, FALSE, 0);
            }
            BUTTONSTATE(pbutn) &= ~(BST_CAPTURED | BST_MOUSE);

        }
        break;

    case WM_KILLFOCUS:

        //
        // If we are losing the focus and we are in "capture mode", click
        // the button.  This allows tab and space keys to overlap for
        // fast toggle of a series of buttons.
        //
        if (BUTTONSTATE(pbutn) & BST_MOUSE) 
        {
            //
            // If for some reason we are killing the focus, and we have the
            // mouse captured, don't notify the parent we got clicked.  This
            // breaks Omnis Quartz otherwise.
            //
            SendMessage(pbutn->ci.hwnd, BM_SETSTATE, FALSE, 0);
        }

        Button_ReleaseCapture(pbutn, TRUE);

        BUTTONSTATE(pbutn) &= ~BST_FOCUS;

        if ((GET_STYLE(pbutn) & BS_NOTIFY) != 0)
        {
            Button_NotifyParent(pbutn, BN_KILLFOCUS);
        }

        //
        // Since the bold border around the defpushbutton is done by
        // someone else, we need to invalidate the rect so that the
        // focus rect is repainted properly.
        //
        InvalidateRect(hwnd, NULL, FALSE);
        break;

    case WM_LBUTTONDBLCLK:

        //
        // Double click messages are recognized for BS_RADIOBUTTON,
        // BS_USERBUTTON, and BS_OWNERDRAW styles.  For all other buttons,
        // double click is handled like a normal button down.
        //
        switch (GetButtonType(GET_STYLE(pbutn))) 
        {
        default:
            if ((GET_STYLE(pbutn) & BS_NOTIFY) == 0)
                goto btnclick;

        case LOBYTE(BS_USERBUTTON):
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_OWNERDRAW):
            Button_NotifyParent(pbutn, BN_DOUBLECLICKED);
            break;
        }

        break;

    case WM_LBUTTONUP:
        if (BUTTONSTATE(pbutn) & BST_MOUSE) 
        {
            Button_ReleaseCapture(pbutn, TRUE);
        }
        break;

    case WM_MOUSELEAVE:
        {
            //
            // We should only be requesting mouseleave messages
            // if we are themed but check anyway
            //
            if (pbutn->buttonState & BST_HOT)
            {
                Button_SetHot(pbutn, FALSE, HICF_MOUSE);
                InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);
            }
        }
        break;

    case WM_MOUSEMOVE:
        {
            //
            // If the hot bit is not already set
            //
            // 300925: Can't hottrack ownerdraw buttons for app compat reasons
            //
            if (!TESTFLAG(pbutn->buttonState, BST_HOT) &&
                GetButtonType(GET_STYLE(pbutn)) != LOBYTE(BS_OWNERDRAW))
            {
                TRACKMOUSEEVENT tme;

                //
                // Set the hot bit and request that
                // we be notified when the mouse leaves
                //
                Button_SetHot(pbutn, TRUE, HICF_MOUSE);

                tme.cbSize      = sizeof(tme);
                tme.dwFlags     = TME_LEAVE;
                tme.hwndTrack   = pbutn->ci.hwnd;
                tme.dwHoverTime = 0;

                TrackMouseEvent(&tme);
                InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);
            }

            if (!(BUTTONSTATE(pbutn) & BST_MOUSE)) 
            {
                break;
            }
        }

        //
        // FALL THRU 
        //

    case WM_LBUTTONDOWN:
btnclick:
        if (Button_SetCapture(pbutn, BST_MOUSE)) 
        {
            POINT pt;
            GetClientRect(pbutn->ci.hwnd, &rc);
            POINTSTOPOINT(pt, lParam);
            SendMessage(pbutn->ci.hwnd, BM_SETSTATE, PtInRect(&rc, pt), 0);
        }

        break;

    case WM_CHAR:
        if (BUTTONSTATE(pbutn) & BST_MOUSE)
        {
            goto CallDWP;
        }

        if (GetButtonType(GET_STYLE(pbutn)) != LOBYTE(BS_CHECKBOX) &&
            GetButtonType(GET_STYLE(pbutn)) != LOBYTE(BS_AUTOCHECKBOX))
        {
            goto CallDWP;
        }

        switch (wParam) 
        {
        case TEXT('+'):
        case TEXT('='):
            //
            // we must Set the check mark on.
            //
            wParam = 1;    

            goto SetCheck;

        case TEXT('-'):
            //
            // Set the check mark off.
            //
            wParam = 0;
SetCheck:
            //
            // Must notify only if the check status changes
            //
            if ((WORD)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (WORD)wParam)
            {
                //
                // We must check/uncheck only if it is AUTO
                //
                if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_AUTOCHECKBOX))
                {
                    if (Button_SetCapture(pbutn, 0))
                    {
                        SendMessage(pbutn->ci.hwnd, BM_SETCHECK, wParam, 0);
                        Button_ReleaseCapture(pbutn, TRUE);
                    }
                }

                Button_NotifyParent(pbutn, BN_CLICKED);
            }

            break;

        default:
            goto CallDWP;
        }

        break;

    case BCM_GETIDEALSIZE:
        return Button_OnGetIdealSize(pbutn, (PSIZE)lParam);

    case BCM_SETIMAGELIST:
        return Button_OnSetImageList(pbutn, (BUTTON_IMAGELIST*)lParam);

    case BCM_GETIMAGELIST:
        {
            BUTTON_IMAGELIST* biml = (BUTTON_IMAGELIST*)lParam;
            if (biml)
            {
                biml->himl = pbutn->himl;
                biml->uAlign = pbutn->uAlign;
                biml->margin = pbutn->rcIcon;
                return TRUE;
            }
        }
        break;

    case BCM_SETTEXTMARGIN:
        {
            RECT* prc = (RECT*)lParam;
            if (prc)
            {
                pbutn->rcText = *prc;
                return TRUE;
            }
        }
        break;

    case BCM_GETTEXTMARGIN:
        {
            RECT* prc = (RECT*)lParam;
            if (prc)
            {
                *prc = pbutn->rcText;
                return TRUE;
            }
        }
        break;

    case BM_CLICK:

        //
        // Don't recurse into this code!
        //
        if (BUTTONSTATE(pbutn) & BST_INBMCLICK)
        {
            break;
        }

        BUTTONSTATE(pbutn) |= BST_INBMCLICK;
        SendMessage(pbutn->ci.hwnd, WM_LBUTTONDOWN, 0, 0);
        SendMessage(pbutn->ci.hwnd, WM_LBUTTONUP, 0, 0);
        BUTTONSTATE(pbutn) &= ~BST_INBMCLICK;

        //
        // FALL THRU
        //

    case WM_KEYDOWN:

        if (BUTTONSTATE(pbutn) & BST_MOUSE)
        {
            break;
        }

        if (wParam == VK_SPACE) 
        {
            if (Button_SetCapture(pbutn, 0)) 
            {
                SendMessage(pbutn->ci.hwnd, BM_SETSTATE, TRUE, 0);
            }
        } 
        else 
        {
            Button_ReleaseCapture(pbutn, FALSE);
        }

        break;

    case WM_KEYUP:
    case WM_SYSKEYUP:

        if (BUTTONSTATE(pbutn) & BST_MOUSE) 
        {
            goto CallDWP;
        }

        //
        // Don't cancel the capture mode on the up of the tab in case the
        // guy is overlapping tab and space keys.
        //
        if (wParam == VK_TAB) 
        {
            goto CallDWP;
        }

        //
        // WARNING: pbutn->ci.hwnd is history after this call!
        //
        Button_ReleaseCapture(pbutn, (wParam == VK_SPACE));

        if (uMsg == WM_SYSKEYUP) 
        {
            goto CallDWP;
        }

        break;

    case BM_GETSTATE:

        lResult = (LONG)BUTTONSTATE(pbutn);
        break;

    case BM_SETSTATE:

        wOldState = (UINT)(BUTTONSTATE(pbutn) & BST_PUSHED);

        if (wParam) 
        {
            BUTTONSTATE(pbutn) |= BST_PUSHED;
        } 
        else 
        {
            BUTTONSTATE(pbutn) &= ~BST_PUSHED;
        }

        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_USERBUTTON)) 
        {
            Button_NotifyParent(pbutn, (UINT)(wParam ? BN_PUSHED : BN_UNPUSHED));
        } 

        if (wOldState != (BOOL)(BUTTONSTATE(pbutn) & BST_PUSHED))
        {
            // Only invalidate if the state changed.
            InvalidateRect(pbutn->ci.hwnd, NULL, FALSE);
            NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        }

        break;

    case BM_GETCHECK:

        lResult = (LONG)(BUTTONSTATE(pbutn) & BST_CHECKMASK);
        break;

    case BM_SETCHECK:

        switch (GetButtonType(GET_STYLE(pbutn))) 
        {
        case LOBYTE(BS_RADIOBUTTON):
        case LOBYTE(BS_AUTORADIOBUTTON):

            if (wParam) 
            {
                SetWindowState(pbutn->ci.hwnd, WS_TABSTOP);
            } 
            else 
            {
                ClearWindowState(pbutn->ci.hwnd, WS_TABSTOP);
            }

            //
            // FALL THRU
            //

        case LOBYTE(BS_CHECKBOX):
        case LOBYTE(BS_AUTOCHECKBOX):

            if (wParam) 
            {
                wParam = 1;
            }
            goto CheckIt;

        case LOBYTE(BS_3STATE):
        case LOBYTE(BS_AUTO3STATE):

            if (wParam > BST_INDETERMINATE) 
            {
                wParam = BST_INDETERMINATE;
            }

CheckIt:
            if ((UINT)(BUTTONSTATE(pbutn) & BST_CHECKMASK) != (UINT)wParam) 
            {
                BUTTONSTATE(pbutn) &= ~BST_CHECKMASK;
                BUTTONSTATE(pbutn) |= (UINT)wParam;

                if (!IsWindowVisible(pbutn->ci.hwnd))
                {
                    break;
                }

                InvalidateRect(pbutn->ci.hwnd, NULL, FALSE);

                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
            }

            break;
        }

        break;

    case BM_SETSTYLE:

        AlterWindowStyle(hwnd, BS_TYPEMASK, (DWORD)wParam);

        if (lParam) 
        {
            InvalidateRect(hwnd, NULL, TRUE);
        }

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEXID_CONTAINER);
        break;

    case WM_SETTEXT:

        //
        // In case the new group name is longer than the old name,
        // this paints over the old name before repainting the group
        // box with the new name.
        //
        if (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_GROUPBOX)) 
        {
            hdc = Button_GetDC(pbutn, &hbr);
            if (hdc != NULL) 
            {
                Button_CalcRect(pbutn, hdc, &rc, CBR_GROUPTEXT, 0);
                InvalidateRect(hwnd, &rc, TRUE);
                FillRect(hdc, &rc, hbr);
                Button_ReleaseDC(pbutn, hdc, &hbr);
            }
        }

        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

        NotifyWinEvent(EVENT_OBJECT_NAMECHANGE, hwnd, OBJID_WINDOW, INDEXID_CONTAINER);
        goto DoEnable;

    case WM_ENABLE:
        lResult = 0L;

DoEnable:
        Button_Repaint(pbutn);
        break;

    case WM_SETFONT:

        //
        // wParam - handle to the font
        // lParam - if true, redraw else don't
        //
        Button_SetFont(pbutn, (HFONT)wParam, (BOOL)(lParam != 0));
        break;

    case WM_GETFONT:
        lResult = (LRESULT)pbutn->hFont;
        break;

    case BM_GETIMAGE:
    case BM_SETIMAGE:

        if (!IsValidImage(wParam, (GET_STYLE(pbutn) & BS_IMAGEMASK) != 0, IMAGE_BMMAX)) 
        {
            TraceMsg(TF_STANDARD, "UxButton: Invalid button image type");
            SetLastError(ERROR_INVALID_PARAMETER);
        } 
        else 
        {
            HANDLE hOld = pbutn->hImage;

            if (uMsg == BM_SETIMAGE) 
            {
                pbutn->hImage = (HANDLE)lParam;
                if (IsWindowVisible(pbutn->ci.hwnd)) 
                {
                    InvalidateRect(hwnd, NULL, TRUE);
                }
            }

            lResult = (LRESULT)hOld;
        }

        break;

    case WM_NCDESTROY:

        if (pbutn->hTheme)
        {
            CloseThemeData(pbutn->hTheme);
        }
        UserLocalFree(pbutn);

        TraceMsg(TF_STANDARD, "BUTTON: Clearing button instance pointer.");
        Button_SetPtr(hwnd, NULL);

        break;

    case WM_NCCREATE:

        pbutn = (PBUTN)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(BUTN));
        if (pbutn)
        {
            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "BUTTON: Setting button instance pointer.");
            Button_SetPtr(hwnd, pbutn);
            pbutn->ci.hwnd = hwnd;
            pbutn->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

            SetRect(&pbutn->rcText, GetSystemMetrics(SM_CXEDGE) / 2, GetSystemMetrics(SM_CYEDGE) / 2,
                GetSystemMetrics(SM_CXEDGE) / 2, GetSystemMetrics(SM_CYEDGE) / 2);

            //
            // Borland's OBEX has a button with style 0x98; We didn't strip
            // these bits in win3.1 because we checked for 0x08.
            // Stripping these bits cause a GP Fault in OBEX.
            // For win3.1 guys, I use the old code to strip the style bits.
            //
            if (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN31COMPAT)) 
            {
                if ((!TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT) &&
                    (((LOBYTE(GET_STYLE(pbutn))) & (LOBYTE(~BS_LEFTTEXT))) == LOBYTE(BS_USERBUTTON))) ||
                    (TESTFLAG(GET_STATE2(pbutn), WS_S2_WIN40COMPAT) &&
                    (GetButtonType(GET_STYLE(pbutn)) == LOBYTE(BS_USERBUTTON))))
                {
                    //
                    // BS_USERBUTTON is no longer allowed for 3.1 and beyond.
                    // Just turn to normal push button.
                    //
                    AlterWindowStyle(hwnd, BS_TYPEMASK, 0);
                    TraceMsg(TF_STANDARD, "UxButton: BS_USERBUTTON no longer supported");
                }
            }

            if ((GET_EXSTYLE(pbutn) & WS_EX_RIGHT) != 0) 
            {
                AlterWindowStyle(hwnd, BS_RIGHT | BS_RIGHTBUTTON, BS_RIGHT | BS_RIGHTBUTTON);
            }

            goto CallDWP;
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "BUTTON: Unable to allocate button instance structure.");
            lResult = FALSE;
        }

        break;

    case WM_INPUTLANGCHANGEREQUEST:

        //
        // #115190
        // If the window is one of controls on top of dialogbox,
        // let the parent dialog handle it.
        //

#if 0  // Need to expose TestwndChild()
        if (TestwndChild(pbutn->ci.hwnd) && pbutn->ci.hwnd->spbutn->ci.hwndParent) 
        {
            PWND pbutn->ci.hwndParent = REBASEPWND(pbutn->ci.hwnd, spbutn->ci.hwndParent);
            if (pbutn->ci.hwndParent) 
            {
                PCLS pclsParent = REBASEALWAYS(pbutn->ci.hwndParent, pcls);

                UserAssert(pclsParent != NULL);
                if (pclsParent->atomClassName == gpsi->atomSysClass[ICLS_DIALOG]) 
                {
                    TraceMsg(TF_STANDARD, "UxButton: WM_INPUTLANGCHANGEREQUEST is sent to parent.");
                    return SendMessage(pbutn->ci.hwndParent, uMsg, wParam, lParam);
                }
            }
        }
#endif

        goto CallDWP;

    case WM_UPDATEUISTATE:

        DefWindowProc(hwnd, uMsg, wParam, lParam);
        if (ISBSTEXTOROD(GET_STYLE(pbutn))) 
        {
            pbutn->fPaintKbdCuesOnly = !IsUsingCleartype();
            Button_Repaint(pbutn);
            pbutn->fPaintKbdCuesOnly = FALSE;
        }

        break;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lResult = MSAA_CLASSNAMEIDX_BUTTON;
        }
        else
        {
            lResult = FALSE;
        }

        break;

    case WM_THEMECHANGED:
        if ( pbutn->hTheme )
        {
            CloseThemeData(pbutn->hTheme);
        }

        //---- reset cached sizes that may change with a theme change ----
        sizeCheckBox.cx = 0;
        sizeCheckBox.cy = 0;
        sizeRadioBox.cx = 0;
        sizeRadioBox.cy = 0;

        pbutn->hTheme = Button_GetTheme(pbutn);

        InvalidateRect(pbutn->ci.hwnd, NULL, TRUE);

        CCSendNotify(&pbutn->ci, NM_THEMECHANGED, NULL);

        lResult = TRUE;

        break;

    default:

        if (CCWndProc(&pbutn->ci, uMsg, wParam, lParam, &lResult))
            return lResult;

CallDWP:
        lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);

    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\combo.h ===
#if !defined(__Combo_h__INCLUDED)
#define __Combo_h__INCLUDED

//---------------------------------------------------------------------------//
//
//  Controls Controls
//
//---------------------------------------------------------------------------//

//
//  Combobox animation time in MS
//
#define CMS_QANIMATION  165

//
//  ID numbers (hMenu) for the child controls in the combo box
//
#define CBLISTBOXID     1000
#define CBEDITID        1001
#define CBBUTTONID      1002


//
//  For CBOX.c. BoxType field, we define the following combo box styles. These
//  numbers are the same as the CBS_ style codes as defined in winuser.h.
//
#define SDROPPABLE      CBS_DROPDOWN
#define SEDITABLE       CBS_SIMPLE


#define SSIMPLE         SEDITABLE
#define SDROPDOWNLIST   SDROPPABLE
#define SDROPDOWN       (SDROPPABLE | SEDITABLE)


//
//  Combobox & Listbox OwnerDraw types
//
#define OWNERDRAWFIXED  1
#define OWNERDRAWVAR    2

#define UPPERCASE       1
#define LOWERCASE       2


//
//  Special styles for static controls, edit controls & listboxes so that we
//  can do combo box specific stuff in their wnd procs.
//
#define LBS_COMBOBOX    0x8000L


//
//  The default minimun number of items that should fit in a dropdown list before
//  the list should start showing in scrollbars.
//
#define DEFAULT_MINVISIBLE  30

//
//  Combobox macros
//
#define IsComboVisible(pcbox)   \
            (!pcbox->fNoRedraw && IsWindowVisible(pcbox->hwnd))

//
//  Combine two DBCS WM_CHAR messages to
//  a single WORD value.
//
#define CrackCombinedDbcsLB(c)  \
            ((BYTE)(c))
#define CrackCombinedDbcsTB(c)  \
            ((c) >> 8)

//
// Instance data pointer access functions
//
#define ComboBox_GetPtr(hwnd)    \
            (PCBOX)GetWindowPtr(hwnd, 0)

#define ComboBox_SetPtr(hwnd, p) \
            (PCBOX)SetWindowPtr(hwnd, 0, p)


//
// Combobox WndProc Prototype
//
extern LRESULT 
ComboBox_WndProc(
    HWND   hwnd, 
    UINT   uMsg, 
    WPARAM wParam,
    LPARAM lParam);


typedef struct tagCBox 
{
    HWND   hwnd;                // Window for the combo box
    HWND   hwndParent;          // Parent of the combo box
    HTHEME hTheme;              // Handle to the theme manager
    RECT   editrc;              // Rectangle for the edit control/static text area
    RECT   buttonrc;            // Rectangle where the dropdown button is

    int    cxCombo;             // Width of sunken area
    int    cyCombo;             // Height of sunken area
    int    cxDrop;              // 0x24 Width of dropdown
    int    cyDrop;              // Height of dropdown or shebang if simple

    HWND   hwndEdit;            // Edit control window handle
    HWND   hwndList;            // List box control window handle

    UINT   CBoxStyle:2;         // Combo box style
    UINT   fFocus:1;            // Combo box has focus?
    UINT   fNoRedraw:1;         // Stop drawing?
    UINT   fMouseDown:1;        // Was the popdown button just clicked and mouse still down?
    UINT   fButtonPressed:1;    // Is the dropdown button in an inverted state?
    UINT   fLBoxVisible:1;      // Is list box visible? (dropped down?)
    UINT   OwnerDraw:2;         // Owner draw combo box if nonzero. value 
                                // specifies either fixed or varheight
    UINT   fKeyboardSelInListBox:1;     // Is the user keyboarding through the
                                        // listbox. So that we don't hide the
                                        // listbox on selchanges caused by the
                                        // user keyboard through it but we do
                                        // hide it if the mouse causes the selchange.
    UINT   fExtendedUI:1;       // Are we doing TandyT's UI changes on this combo box?
    UINT   fCase:2;

    UINT   f3DCombo:1;          // 3D or flat border?
    UINT   fNoEdit:1;           // True if editing is not allowed in the edit window.
    UINT   fButtonHotTracked:1; // Is the dropdown hot-tracked?
    UINT   fRightAlign:1;       // used primarily for MidEast right align
    UINT   fRtoLReading:1;      // used only for MidEast, text rtol reading order
    HANDLE hFont;               // Font for the combo box
    LONG   styleSave;           // Temp to save the style bits when creating
                                // window.  Needed because we strip off some
                                // bits and pass them on to the listbox or edit box.
    PWW    pww;                 // RO pointer into the pwnd to ExStyle, Style, State, State2
    int    iMinVisible;         // The minimun number of visible items before scrolls
} CBOX, *PCBOX;



//  Combobox function prototypes. 

// Defined in combo.c
BOOL    ComboBox_HideListBoxWindow(PCBOX, BOOL, BOOL);
VOID    ComboBox_ShowListBoxWindow(PCBOX, BOOL);
VOID    ComboBox_InternalUpdateEditWindow(PCBOX, HDC);



// Defined in comboini.c
LONG    ComboBox_NcCreateHandler(PCBOX, HWND);
LRESULT ComboBox_CreateHandler(PCBOX, HWND);
VOID    ComboBox_NcDestroyHandler(PWND, PCBOX);
VOID    ComboBox_SetFontHandler(PCBOX, HANDLE, BOOL);
LONG    ComboBox_SetEditItemHeight(PCBOX, int);
VOID    ComboBox_SizeHandler(PCBOX);
VOID    ComboBox_Position(PCBOX);


// Defined in combodir.c
INT     CBDir(PCBOX, UINT, LPWSTR);







#endif // __Combo_h__INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\combodir.c ===
/**************************** Module Header ********************************\
* Module Name: combodir.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Directory Combo Box Routines
*
* History:
* ??-???-???? ??????    Ported from Win 3.0 sources
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "ctlspriv.h"
#pragma hdrstop
#include "UsrCtl32.h"
#include "Combo.h"
#include "Listbox.h"

/***************************************************************************\
* CBDir
*
* Supports the CB_DIR message which adds a list of files from the
* current directory to the combo box.
*
* History:
\***************************************************************************/
int CBDir(PCBOX pcbox, UINT attrib, LPWSTR pFileName)
{
    PLBIV plb;
    int errorValue;
    
    UserAssert(pcbox->hwndList);
    
    plb = ListBox_GetPtr(pcbox->hwndList);
    
    errorValue = ListBox_DirHandler(plb, attrib, pFileName);
    
    switch (errorValue) 
    {
    case LB_ERR:
        return CB_ERR;
        break;
    case LB_ERRSPACE:
        return CB_ERRSPACE;
        break;
    default:
        return errorValue;
        break;
    }
}

//#define INCLUDE_COMBOBOX_FUNCTIONS
#ifdef  INCLUDE_COMBOBOX_FUNCTIONS

/***************************************************************************\
* DlgDirSelectComboBoxEx
*
* Retrieves the current selection from the listbox of a combobox.
* It assumes that the combo box was filled by DlgDirListComboBox()
* and that the selection is a drive letter, a file, or a directory name.
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/

int DlgDirSelectComboBoxExA(
                            HWND hwndDlg,
                            LPSTR pszOut,
                            int cchOut,
                            int idComboBox)
{
    LPWSTR lpwsz;
    BOOL fRet;
    
    lpwsz = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchOut * sizeof(WCHAR));
    if (!lpwsz) {
        return FALSE;
    }
    
    fRet = DlgDirSelectComboBoxExW(hwndDlg, lpwsz, cchOut, idComboBox);
    
    WCSToMB(lpwsz, -1, &pszOut, cchOut, FALSE);
    
    UserLocalFree(lpwsz);
    
    return fRet;
}

int DlgDirSelectComboBoxExW(
                            HWND hwndDlg,
                            LPWSTR pwszOut,
                            int cchOut,
                            int idComboBox)
{
    HWND  hwndComboBox;
    PCBOX pcbox;
    
    if (hwndDlg == NULL)
        return FALSE;
    
    hwndComboBox = GetDlgItem(hwndDlg, idComboBox);
    if (hwndComboBox == NULL) {
        TraceMsg(TF_STANDARD, "ControlId = %d not found in Dlg = %#.4x", idComboBox, hwndDlg);
        return 0;
    }
    pcbox = ComboBox_GetPtr(hwndComboBox);
    if (pcbox == NULL) {
        TraceMsg(TF_STANDARD, "ControlId = %d is not a combobox", idComboBox);
        return 0;
    }
    
    return DlgDirSelectHelper(pwszOut, cchOut, pcbox->hwndList);
}


/***************************************************************************\
* DlgDirListComboBox
*
* History:
* 12-05-90 IanJa    converted to internal version
\***************************************************************************/

int DlgDirListComboBoxA(
                        HWND hwndDlg,
                        LPSTR lpszPathSpecClient,
                        int idComboBox,
                        int idStaticPath,
                        UINT attrib)
{
    LPWSTR lpszPathSpec;
    BOOL fRet;
    
    if (hwndDlg == NULL)
        return FALSE;
    
    lpszPathSpec = NULL;
    if (lpszPathSpecClient) {
        if (!MBToWCS(lpszPathSpecClient, -1, &lpszPathSpec, -1, TRUE))
            return FALSE;
    }
    
    fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, lpszPathSpecClient,
        idComboBox, idStaticPath, attrib, FALSE);
    
    if (lpszPathSpec) {
        if (fRet) {
        /*
        * Non-zero retval means some text to copy out.  Copy out up to
        * the nul terminator (buffer will be big enough).
            */
            WCSToMB(lpszPathSpec, -1, &lpszPathSpecClient, MAXLONG, FALSE);
        }
        UserLocalFree(lpszPathSpec);
    }
    
    return fRet;
}

int DlgDirListComboBoxW(
                        HWND hwndDlg,
                        LPWSTR lpszPathSpecClient,
                        int idComboBox,
                        int idStaticPath,
                        UINT attrib)
{
    LPWSTR lpszPathSpec;
    BOOL fRet;
    
    if (hwndDlg == NULL)
        return FALSE;
    
    lpszPathSpec = lpszPathSpecClient;
    
    fRet = DlgDirListHelper(hwndDlg, lpszPathSpec, (LPBYTE)lpszPathSpecClient,
        idComboBox, idStaticPath, attrib, FALSE);
    
    return fRet;
}
#endif  // INCLUDE_COMBOBOX_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\comctl32.inc ===
#
#  Common settings for comctl32
#

# Now the NT version have FE_IME etc. defined
C_DEFINES       = $(C_DEFINES) -DFE_IME -DDBCS -DWINDOWS_ME 

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DUSE_PRIVATE_VERSION_NUMBER
!else
C_DEFINES       = $(C_DEFINES) -DUNICODE
!endif

C_DEFINES       = $(C_DEFINES) -DUXCTRL_VERSION=0x0100

# Turn structure validation ON in debug builds
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF
!endif

USE_MSVCRT      = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

MSC_WARNING_LEVEL=/W4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\comboex.c ===
#include "ctlspriv.h"

#ifdef UNIX

#define EDIT_SELECTALL( hwnd )
#define GetTextExtentPoint GetTextExtentPoint32

#else

#define EDIT_SELECTALL( hwnd )  Edit_SetSel(hwnd, 0, 0);  \
                                Edit_SetSel(hwnd, 0, -1);

#endif

const TCHAR c_szComboBox[] = TEXT("combobox");
const TCHAR c_szComboBoxEx[] = WC_COMBOBOXEX;

#ifdef DPITEST
#define ComboEx_IsDPIScaled() TRUE
#else
#define ComboEx_IsDPIScaled() (CCDPIScale(pce->ci))
#endif


#define COMBO_MARGIN        4
#define COMBO_WIDTH         g_cxSmIcon
#define COMBO_HEIGHT        g_cySmIcon
#define COMBO_BORDER        3

typedef struct {
    LPTSTR pszText;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} CEITEM, *PCEITEM;


typedef struct {
    CCONTROLINFO ci;
    HWND hwndCombo;
    HWND hwndEdit;
    DWORD dwExStyle;
    HIMAGELIST himl;
    HFONT hFont;
    int cxIndent;
    WPARAM iSel;
    CEITEM cei;
    BOOL fEditItemSet       :1;
    BOOL fEditChanged       :1;
    BOOL fFontCreated       :1;
    BOOL fInEndEdit         :1;
    BOOL fInDrop            :1;
} COMBOEX, *PCOMBOBOXEX;


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp);
HFONT ComboEx_GetFont(PCOMBOBOXEX pce);
BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem);
int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL);
int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz);
int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code);

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2);

#define ComboEx_Editable(pce) (((pce)->ci.style & CBS_DROPDOWNLIST) == CBS_DROPDOWN)

void ComboEx_OnSetFont(PCOMBOBOXEX pce, HFONT hFont, BOOL fRedraw)
{
    int iHeight;
    HFONT hfontOld = NULL;

    if (pce->fFontCreated)
        hfontOld = ComboEx_GetFont(pce);

    if (!hFont) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        hFont = CreateFontIndirect(&lf);
        pce->fFontCreated = TRUE;
    } else {
        pce->fFontCreated = FALSE;
    }
    pce->ci.uiCodePage = GetCodePageForFont(hFont);

    SendMessage(pce->hwndCombo, WM_SETFONT, (WPARAM)hFont, fRedraw);
    if (pce->hwndEdit)
    {
        SendMessage(pce->hwndEdit, WM_SETFONT, (WPARAM)hFont, fRedraw);
        SendMessage(pce->hwndEdit, EM_SETMARGINS, EC_USEFONTINFO, 0L);
    }

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, (LPARAM)iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, (LPARAM)iHeight);

    // do this last so that we don't have a nuked font as we try to create the new one
    if (hfontOld)
        DeleteObject(hfontOld);
}


void ComboEx_OnDestroy(PCOMBOBOXEX pce)
{
    // don't need do destroy hwndCombo.. it will be destroyed along with us.
    SendMessage(pce->hwndCombo, CB_RESETCONTENT, 0, 0);
    // we may still have string allocated for the item in the edit box so free it
    if (pce->cei.pszText)
        Str_Set(&(pce->cei.pszText), NULL);
    if (pce->fFontCreated) {
        DeleteObject(ComboEx_GetFont(pce));
    }

    if (pce->hwndEdit)
        RemoveWindowSubclass(pce->hwndEdit,  EditSubclassProc,  0);

    if (pce->hwndCombo)
        RemoveWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0);

    SetWindowPtr(pce->ci.hwnd, 0, 0);
    LocalFree(pce);
}

// this gets the client rect without the scrollbar part and the border
void ComboEx_GetComboClientRect(PCOMBOBOXEX pce, LPRECT lprc)
{
    GetClientRect(pce->hwndCombo, lprc);
    InflateRect(lprc, -g_cxEdge, -g_cyEdge);
    lprc->right -= g_cxScrollbar;
}

// returns the edit box (creating it if necessary) or NULL if the combo does
// not have an edit box
HWND ComboEx_GetEditBox(PCOMBOBOXEX pce)
{
    HFONT hfont;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    if (pce->hwndEdit)
        return(pce->hwndEdit);

    if (!ComboEx_Editable(pce))
        return(NULL);

    dwStyle = WS_VISIBLE | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT;

    if (pce->ci.style & CBS_AUTOHSCROLL)
        dwStyle |= ES_AUTOHSCROLL;
    if (pce->ci.style & CBS_OEMCONVERT)
        dwStyle |= ES_OEMCONVERT;
#if 0
    if (pce->ci.style & CBS_UPPERCASE)
        dwStyle |= ES_UPPERCASE;
    if (pce->ci.style & CBS_LOWERCASE)
        dwStyle |= ES_LOWERCASE;
#endif

    dwExStyle = pce->ci.dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndEdit = CreateWindowEx(dwExStyle, WC_EDIT, c_szNULL, dwStyle, 0, 0, 0, 0,
                                   pce->hwndCombo, IntToPtr_(HMENU, GetDlgCtrlID(pce->ci.hwnd)), HINST_THISDLL, 0);

    if (!pce->hwndEdit ||
        !SetWindowSubclass(pce->hwndEdit, EditSubclassProc, 0, (DWORD_PTR)pce))
    {
        return NULL;
    }

    // Override the edit's theme with combobox
    SetWindowTheme(pce->hwndEdit, L"Combobox", NULL);

    hfont = ComboEx_GetFont(pce);
    if (hfont)
        FORWARD_WM_SETFONT(pce->hwndEdit, hfont,
                           FALSE, SendMessage);

    return(pce->hwndEdit);
}

///
/// the edit box handling...
/*

 we want the edit box up on CBN_SETFOCUS and CBN_CLOSEUP
 remove it on CBN_DROPDOWN and on CBN_KILLFOCUS

 this assumes that CBN_SETFOCUS and CBN_KILLFOCUS will come before and after
 CBN_DROPDOWN and CBN_CLOSEUP respectively
 */

// Really a BOOL return value
LRESULT ComboEx_EndEdit(PCOMBOBOXEX pce, int iWhy)
{
    NMCBEENDEDIT    nm;
    LRESULT         fRet;

    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    pce->fInEndEdit = TRUE;

    GetWindowText(pce->hwndEdit, nm.szText, ARRAYSIZE(nm.szText));

    nm.fChanged = pce->fEditChanged;
    nm.iWhy = iWhy;

    nm.iNewSelection = ComboEx_OnFindStringExact(pce, ComboBox_GetCurSel(pce->hwndCombo) - 1, nm.szText);
    fRet = BOOLFROMPTR(CCSendNotify(&pce->ci, CBEN_ENDEDIT, &nm.hdr));

    pce->fInEndEdit = FALSE;

    if (!fRet) 
    {
        if (nm.iNewSelection != ComboBox_GetCurSel(pce->hwndCombo))
        {
            if (nm.iNewSelection != -1)
            {
                SendMessage(pce->ci.hwnd, CB_SETCURSEL, nm.iNewSelection, 0);
            }
            else
            {
                //if the selection is -1 and if we do a CB_SETCURSEL  on comboboxex then it nukes the text in
                //the edit window. Which is not the desired behavior. We need to update the Current Selection in the                 
                //child combobox but leave the text as it is.
                SendMessage(pce->hwndCombo, CB_SETCURSEL, nm.iNewSelection,0);
            }
        }
        pce->fEditChanged = FALSE;
    }
    InvalidateRect(pce->hwndCombo, NULL, FALSE);

    return(fRet);
}

void ComboEx_SizeEditBox(PCOMBOBOXEX pce)
{
    RECT rc;
    int cxIcon = 0, cyIcon = 0;

    ComboEx_GetComboClientRect(pce, &rc);
    InvalidateRect(pce->hwndCombo, &rc, TRUE); // erase so that the selection highlight is erased
    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        // Make room for icons.
        CCGetIconSize(&pce->ci, pce->himl, &cxIcon, &cyIcon);

        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // combobox edit field is one border in from the entire combobox client
    // rect -- thus add one border to edit control's left side
    rc.left += g_cxBorder + cxIcon;
    rc.bottom -= g_cyBorder;
    rc.top = rc.bottom - ComboEx_ComputeItemHeight(pce, TRUE) - g_cyBorder;
    SetWindowPos(pce->hwndEdit, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                 SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);

}

BOOL ComboEx_GetCurSelText(PCOMBOBOXEX pce, LPTSTR pszText, int cchText)
{

    COMBOBOXEXITEM cei;
    BOOL bRet = TRUE;

    cei.mask = CBEIF_TEXT;
    cei.pszText = pszText;
    cei.cchTextMax = cchText;
    cei.iItem = (INT)ComboBox_GetCurSel(pce->hwndCombo);
    
    if (cei.iItem == -1 ) 
    {
        pszText[0] = 0;
        bRet = FALSE;
    } 
    else 
    {
        ComboEx_OnGetItem(pce, &cei);
    }
    return bRet;
}

void ComboEx_UpdateEditText(PCOMBOBOXEX pce, BOOL fClearOnNoSel)
{
    if (!pce->fInEndEdit)
    {
        TCHAR szText[CBEMAXSTRLEN];

        HWND hwndEdit = ComboEx_Editable(pce) ? pce->hwndEdit : pce->hwndCombo;

        if (ComboEx_GetCurSelText(pce, szText, ARRAYSIZE(szText)) || fClearOnNoSel) {
            SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM)szText);
            EDIT_SELECTALL( hwndEdit );
        }
    }
}

BOOL ComboEx_BeginEdit(PCOMBOBOXEX pce)
{
    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    SetFocus(pce->hwndEdit);
    return(TRUE);
}

BOOL ComboSubclass_HandleButton(PCOMBOBOXEX pce, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
#ifndef UNIX
    POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
#else
    POINT pt;
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);
#endif

    ComboEx_GetComboClientRect(pce, &rc);
    InflateRect(&rc, g_cxEdge, g_cyEdge);

    if (PtInRect(&rc, pt)) {

        //
        //  CheckForDragBegin yields, so we must revalidate on the way back.
        //
        HWND hwndCombo = pce->hwndCombo;
        if (CheckForDragBegin(pce->hwndCombo, LOWORD(lParam), HIWORD(lParam)))
        {
            NMCBEDRAGBEGIN  nmcbebd;
            LRESULT fRet;

            nmcbebd.iItemid = -1;
            GetWindowText(pce->hwndEdit, nmcbebd.szText, ARRAYSIZE(nmcbebd.szText));

            fRet = CCSendNotify(&pce->ci, CBEN_DRAGBEGIN, &nmcbebd.hdr);
            return TRUE;
        }
        // CheckForDragBegin yields, so revalidate before continuing
        else if (IsWindow(hwndCombo)) {

            if (uMsg == WM_LBUTTONDOWN)
            {
                // Post a fake WM_LBUTTONUP message because CheckForDragBegin may have
                // removed it from the combo's message queue but the combo expects to
                // get it.
                PostMessage(hwndCombo, WM_LBUTTONUP, 0, 0);
            }

            // a click on our border should start edit mode as well
            if (ComboEx_Editable(pce)) {
                if (!ComboEx_BeginEdit(pce))
                    SetFocus(pce->hwndCombo);
                return TRUE;
            }
            return FALSE;
        }
   }
   return FALSE;
}

BOOL ComboSubclass_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);
    HWND hwnd = GET_WM_COMMAND_HWND(wParam, lParam);

    switch (uCmd)
    {
        case EN_SETFOCUS:
            if (!pce->fInDrop)
            {
                EDIT_SELECTALL( pce->hwndEdit );
                CCSendNotify(&pce->ci, CBEN_BEGINEDIT, NULL);
                pce->fEditChanged = FALSE;
            }
            break;

        case EN_KILLFOCUS:
        {
            HWND hwndFocus;
            hwndFocus = GetFocus();
            if (hwndFocus != pce->hwndCombo)
            {
                ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
                SendMessage(pce->hwndCombo, WM_KILLFOCUS, (WPARAM)hwndFocus, 0);
            }

            break;
        }

        case EN_CHANGE:
        {
            TCHAR szTextOrig[CBEMAXSTRLEN];
            TCHAR szTextNow[CBEMAXSTRLEN];
            WPARAM iItem;

            iItem = ComboBox_GetCurSel(pce->hwndCombo);

            if(iItem == -1)
            {
                if (pce->fEditItemSet && pce->cei.pszText) 
                {
                    Str_GetPtr(pce->cei.pszText, szTextOrig, ARRAYSIZE(szTextOrig));
                }
                else
                {
                    szTextOrig[0] = TEXT('\0');
                }
            }
            else 
            {
                ComboEx_GetCurSelText(pce,szTextOrig, ARRAYSIZE(szTextOrig));
            }

#ifndef UNIX
            GetWindowText(pce->hwndEdit, szTextNow, ARRAYSIZE(szTextNow));
#else
            GetWindowText(pce->hwndEdit, szTextNow, ARRAYSIZE(szTextNow)-1);
#endif
            pce->fEditChanged = (ComboEx_StrCmp(pce, szTextOrig, szTextNow) != 0);
            SendMessage(pce->ci.hwndParent, WM_COMMAND,
                    GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, CBN_EDITCHANGE));

            break;
        }
    }

    return(hwnd == pce->hwndEdit);
}

LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    if (uMsg == WM_SETFONT ||
        uMsg == WM_WININICHANGE) 
    {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    }

    switch(uMsg) 
    {
    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, EditSubclassProc, 0);
        break;

    case WM_CHAR:
        switch ((TCHAR)wParam) {
        case TEXT('\n'):
        case TEXT('\r'):
            // return... don't go to wndproc because
            // the edit control beeps on enter
            return 0;
        }
        break;

    case WM_SIZE:
        if (GetFocus() != hwnd) {
            Edit_SetSel(pce->hwndEdit, 0, 0);    // makesure everything is scrolled over first
        }
        break;

    case WM_KEYDOWN:
        switch(wParam) {
        case VK_RETURN:
            if (!ComboEx_EndEdit(pce, CBENF_RETURN))
                // we know we have an edit window, so FALSE return means
                // app returned FALSE to CBEN_ENDEDIT notification
                ComboEx_BeginEdit(pce);
            break;

        case VK_ESCAPE:
            pce->fEditChanged = FALSE;
            if (!ComboEx_EndEdit(pce, CBENF_ESCAPE)) {
                if(pce->fEditItemSet) {
                    if(pce->cei.pszText) {
                        SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
                        EDIT_SELECTALL( pce->hwndEdit );
                    }
                    RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
                }else {
                    ComboEx_BeginEdit(pce);
                }
            }
            break;

        // Pass these to the combobox itself to make it work properly...
        case VK_HOME:
        case VK_END:
            if (!pce->fInDrop)
                break;

        case VK_F4:
        case VK_UP:
        case VK_DOWN:
        case VK_PRIOR:
        case VK_NEXT:
            if (pce->hwndCombo)
                return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        if (GetFocus() != pce->hwndEdit)
        {
            SetFocus(pce->hwndEdit);
#ifndef UNIX
            // IEUNIX : since we disabled autoselection on first click in address bar,
            // we should not eat this message. This allows the dragging to begin with
            // the first click.
            return(0L); // eat this message
#endif
        }
        break;

    case WM_SYSKEYDOWN:
        switch(wParam) {
        // Pass these to the combobox itself to make it work properly...
        case VK_UP:
        case VK_DOWN:
            {
                LRESULT lR;
                if (pce->hwndCombo)
                {
                    lR=SendMessage(pce->hwndCombo, uMsg, wParam, lParam);

                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(pce->ci), UISF_HIDEFOCUS);

                    return lR;
                }
            }
        }
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT ComboEx_GetLBText(PCOMBOBOXEX pce, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COMBOBOXEXITEM cei;
    TCHAR szText[CBEMAXSTRLEN];
    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);
    cei.iItem = (INT)wParam;
    if (!ComboEx_OnGetItem(pce, &cei))
        return CB_ERR;

    if (lParam && uMsg == CB_GETLBTEXT) {
#ifdef UNICODE_WIN9x
        if (pce->ci.bUnicode) {
            lstrcpy((LPTSTR)lParam, szText);
        } else {
            WideCharToMultiByte(pce->ci.uiCodePage, 0, szText, -1, (LPSTR)lParam, CBEMAXSTRLEN, NULL,NULL);
        }
#else
        lstrcpy((LPTSTR)lParam, szText);
#endif
    }
    return lstrlen(szText);
}

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    switch (uMsg) 
    {
    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    case WM_RBUTTONDOWN:
    case WM_LBUTTONDOWN:
        if (ComboSubclass_HandleButton(pce, uMsg, wParam, lParam)) 
        {
            return 0;
        }
        break;

    case WM_PAINT:
        if (pce->hwndEdit)
        {
            RedrawWindow(pce->hwndEdit, NULL, NULL, RDW_INVALIDATE);
        }
        break;

    case WM_COMMAND:
        if (ComboSubclass_HandleCommand(pce, wParam, lParam))
        {
            return 0;
        }
        break;

    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, ComboSubclassProc, 0);
        break;

    case WM_SETCURSOR:
        if (pce) 
        {
            NMMOUSE nm = {0};
            nm.dwHitInfo = lParam;
            if (CCSendNotify(&pce->ci, NM_SETCURSOR, &nm.hdr))
            {
                return 0;
            }
        }
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

BOOL ComboEx_OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{
    PCOMBOBOXEX pce;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    pce = (PCOMBOBOXEX)LocalAlloc(LPTR, sizeof(COMBOEX));
    if (!pce)
        return FALSE;

    SetWindowPtr(hwnd, 0, pce);

    // force off borders off ourself
    lpcs->style &= ~(WS_BORDER | WS_VSCROLL | WS_HSCROLL | CBS_UPPERCASE | CBS_LOWERCASE);
    SetWindowLong(hwnd, GWL_STYLE, lpcs->style);
    CIInitialize(&pce->ci, hwnd, lpcs);

    // or in CBS_SIMPLE because we can never allow the sub combo box
    // to have just drop down.. it's either all simple or dropdownlist
    dwStyle = CBS_OWNERDRAWFIXED | CBS_SIMPLE | CBS_NOINTEGRALHEIGHT | WS_VISIBLE |WS_VSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    dwStyle |= (lpcs->style & (CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD));

    if ((lpcs->style & CBS_DROPDOWNLIST) == CBS_SIMPLE)
        dwStyle |= (lpcs->style & (CBS_AUTOHSCROLL | CBS_OEMCONVERT | CBS_UPPERCASE | CBS_LOWERCASE));

    dwExStyle = lpcs->dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndCombo = CreateWindowEx(dwExStyle, WC_COMBOBOX, lpcs->lpszName,
                                    dwStyle,
                                    0, 0, lpcs->cx, lpcs->cy,
                                    hwnd, lpcs->hMenu, lpcs->hInstance, 0);

    if (!pce->hwndCombo ||
        !SetWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0, (DWORD_PTR)pce) ||
        (!ComboEx_GetEditBox(pce) && ComboEx_Editable(pce)))
    {
        ComboEx_OnDestroy(pce);
        return FALSE;
    }

    ComboEx_OnSetFont(pce, NULL, FALSE);
    pce->cxIndent = 10;
    pce->iSel = -1;

    ComboEx_OnWindowPosChanging(pce, NULL);
    return TRUE;
}


HIMAGELIST ComboEx_OnSetImageList(PCOMBOBOXEX pce, HIMAGELIST himl)
{
    int iHeight;
    HIMAGELIST himlOld = pce->himl;

    pce->himl = himl;

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, iHeight);

    InvalidateRect(pce->hwndCombo, NULL, TRUE);

    if (pce->hwndEdit)
        ComboEx_SizeEditBox(pce);

    return himlOld;
}

void ComboEx_OnDrawItem(PCOMBOBOXEX pce, LPDRAWITEMSTRUCT pdis)
{
    HDC hdc = pdis->hDC;
    RECT rc = pdis->rcItem;
    TCHAR szText[CBEMAXSTRLEN];
    int offset = 0;
    int xString, yString, xCombo;
    int cxIcon = 0, cyIcon = 0;
    int iLen;
    BOOL fSelected = FALSE;
    SIZE sizeText;
    COMBOBOXEXITEM cei;
    BOOL fNoText = FALSE;
    BOOL fEnabled = IsWindowEnabled(pce->hwndCombo);
    BOOL fRTLReading = FALSE;
    UINT OldTextAlign;

    // Setup the dc before we use it.
    fRTLReading = GetWindowLong(pdis->hwndItem, GWL_EXSTYLE) & WS_EX_RTLREADING;
    if (fRTLReading) 
    {
        OldTextAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, OldTextAlign|TA_RTLREADING);
    }

    rc.top += g_cyBorder;

    szText[0] = 0;
    if (pdis->itemID != -1)
    {
        cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
        cei.pszText = szText;
        cei.cchTextMax = ARRAYSIZE(szText);
        cei.iItem = (INT)pdis->itemID;

        ComboEx_OnGetItem(pce, &cei);

        if (pce->iSel == (int)pdis->itemID ||
            ((pce->iSel == -1) && ((int)pdis->itemID == ComboBox_GetCurSel(pce->hwndCombo))))
            fSelected = TRUE;
    }
    else 
    {
        if (pce->fEditItemSet) 
        {
            cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
            cei.pszText = szText;
            cei.cchTextMax = ARRAYSIZE(szText);
            cei.iItem = (INT)pdis->itemID;

            ComboEx_OnGetItem(pce, &cei);
        }
    }

    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        CCGetIconSize(&pce->ci, pce->himl, &cxIcon, &cyIcon);

        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // if we're not drawing the edit box, figure out how far to indent
    // over
    if (!(pdis->itemState & ODS_COMBOBOXEDIT))
    {
        offset = (pce->cxIndent * cei.iIndent) + COMBO_BORDER;
    }
    else
    {
        if (pce->hwndEdit)
            fNoText = TRUE;

        if (pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT)
            cxIcon = 0;
    }

    xCombo = rc.left + offset;
    rc.left = xString = xCombo + cxIcon;
    iLen = lstrlen(szText);
    GetTextExtentPoint(hdc, szText, iLen, &sizeText);

    rc.right = rc.left + sizeText.cx;
    rc.left--;
    rc.right++;

    if (pdis->itemAction != ODA_FOCUS)
    {
        int yMid;
        BOOL fTextHighlight = FALSE;;

        yMid = (rc.top + rc.bottom) / 2;
        // center the string within rc
        yString = yMid - (sizeText.cy/2);

        if (pdis->itemState & ODS_SELECTED) 
        {
            if (!(pdis->itemState & ODS_COMBOBOXEDIT) ||
                !ComboEx_Editable(pce)) 
            {
                fTextHighlight = TRUE;
            }
        }

        if ( !fEnabled ) {
            SetBkColor(hdc, g_clrBtnFace);
            SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
        } else {
            SetBkColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHT : COLOR_WINDOW));
            SetTextColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
        }

        if ((pdis->itemState & ODS_COMBOBOXEDIT) &&
                (rc.right > pdis->rcItem.right))
        {
            // Need to clip as user does not!
            rc.right = pdis->rcItem.right;
        }

        if (!fNoText) {
            ExtTextOut(hdc, xString, yString, ETO_OPAQUE | ETO_CLIPPED, &rc, szText, iLen, NULL);
        }

        if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
            !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT)) &&
              (pdis->itemState & ODS_COMBOBOXEDIT))) 
        {

            DWORD dwDrawFlags = ILD_NORMAL;
        
            if ((pdis->itemState & ODS_COMBOBOXEDIT) && !fEnabled) 
            {
                dwDrawFlags = ILD_TRANSPARENT;
            }

            if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
                !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT))))
            {
                if (pdis->itemState & ODS_SELECTED)
                    dwDrawFlags |= ILD_SELECTED | ILD_FOCUS;

                if (ComboEx_IsDPIScaled())
                {
                    dwDrawFlags |= ILD_DPISCALE;
                }

                ImageList_Draw(pce->himl,
                               (fSelected) ? cei.iSelectedImage : cei.iImage,
                               hdc, xCombo, yMid - (cyIcon/2),
                               INDEXTOOVERLAYMASK(cei.iOverlay) | dwDrawFlags);
            }
        }
    }


    if ((pdis->itemAction == ODA_FOCUS ||
        (pdis->itemState & ODS_FOCUS)) && 
        !(CCGetUIState(&(pce->ci)) & UISF_HIDEFOCUS))
    {
        if (!fNoText) 
        {
            DrawFocusRect(hdc, &rc);
        }
    }

    // Restore the text align in the dc.
    if (fRTLReading) 
    {
        SetTextAlign(hdc, OldTextAlign);
    }
}

int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL fTextOnly)
{
    HDC hdc;
    HFONT hfontOld;
    int dyDriveItem;
    SIZE siz;

    hdc = GetDC(NULL);
    hfontOld = ComboEx_GetFont(pce);
    if (hfontOld)
        hfontOld = SelectObject(hdc, hfontOld);

    GetTextExtentPoint(hdc, TEXT("W"), 1, &siz);
    dyDriveItem = siz.cy;

    if (hfontOld)
        SelectObject(hdc, hfontOld);
    ReleaseDC(NULL, hdc);

    if (fTextOnly)
        return dyDriveItem;

    dyDriveItem += COMBO_BORDER;

    // now take into account the icon
    if (pce->himl) 
    {
        int cxIcon = 0, cyIcon = 0;
        CCGetIconSize(&pce->ci, pce->himl, &cxIcon, &cyIcon);

        if (dyDriveItem < cyIcon)
            dyDriveItem = cyIcon;
    }

    return dyDriveItem;
}

void ComboEx_OnMeasureItem(PCOMBOBOXEX pce, LPMEASUREITEMSTRUCT pmi)
{

    pmi->itemHeight = ComboEx_ComputeItemHeight(pce, FALSE);

}

void ComboEx_ISetItem(PCOMBOBOXEX pce, PCEITEM pcei, PCOMBOBOXEXITEM pceItem)
{
    if (pceItem->mask & CBEIF_INDENT)
        pcei->iIndent = pceItem->iIndent;
    if (pceItem->mask & CBEIF_IMAGE)
        pcei->iImage = pceItem->iImage;
    if (pceItem->mask & CBEIF_SELECTEDIMAGE)
        pcei->iSelectedImage = pceItem->iSelectedImage;
    if (pceItem->mask & CBEIF_OVERLAY)
        pcei->iOverlay = pceItem->iOverlay;

    if (pceItem->mask & CBEIF_TEXT) {
        Str_Set(&pcei->pszText, pceItem->pszText);
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pcei->lParam = pceItem->lParam;
    }

}

#define ComboEx_GetItemPtr(pce, iItem) \
        ((PCEITEM)SendMessage((pce)->hwndCombo, CB_GETITEMDATA, iItem, 0))
#define ComboEx_Count(pce) \
        ((int)SendMessage((pce)->hwndCombo, CB_GETCOUNT, 0, 0))


BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    PCEITEM pcei;
    NMCOMBOBOXEX nm;

    if(pceItem->iItem != -1) {
        pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
    }
    else {
        pcei = &(pce->cei);
    }

    if ((!pcei) || (pcei == (PCEITEM)-1))
        return FALSE;

    nm.ceItem.mask = 0;

    if (pceItem->mask & CBEIF_TEXT) {

        if (pcei->pszText == LPSTR_TEXTCALLBACK) {
            nm.ceItem.mask |= CBEIF_TEXT;
        } 
        else 
        {
            if(pceItem->iItem != -1) 
            {
                Str_GetPtr(pcei->pszText, pceItem->pszText, pceItem->cchTextMax);
            }
            else if (pce->hwndEdit) 
            {
                SendMessage(pce->hwndEdit, WM_GETTEXT, (WPARAM)pceItem->cchTextMax, (LPARAM)pceItem->pszText);
            }
        }
    }

    if (pceItem->mask & CBEIF_IMAGE) {

        if (pcei->iImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_IMAGE;
        }
        pceItem->iImage = pcei->iImage;

    }

    if (pceItem->mask & CBEIF_SELECTEDIMAGE) {

        if (pcei->iSelectedImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_SELECTEDIMAGE;
        }
        pceItem->iSelectedImage = pcei->iSelectedImage;
    }

    if (pceItem->mask & CBEIF_OVERLAY) {

        if (pcei->iOverlay == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_OVERLAY;
        }
        pceItem->iOverlay = pcei->iOverlay;
    }

    if (pceItem->mask & CBEIF_INDENT) {

        if (pcei->iIndent == I_INDENTCALLBACK) {
            nm.ceItem.mask |= CBEIF_INDENT;
            pceItem->iIndent = 0;
        } else {
            pceItem->iIndent = pcei->iIndent;
        }
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pceItem->lParam = pcei->lParam;
    }



    // is there anything to call back for?
    if (nm.ceItem.mask) {
        UINT uMask = nm.ceItem.mask;

        nm.ceItem = *pceItem;
        nm.ceItem.lParam = pcei->lParam;
        nm.ceItem.mask = uMask;

        if ((nm.ceItem.mask & CBEIF_TEXT) &&
            nm.ceItem.cchTextMax) {
            // null terminate just in case they don't respond
            *nm.ceItem.pszText = 0;
        }

        CCSendNotify(&pce->ci, CBEN_GETDISPINFO, &nm.hdr);

        if (nm.ceItem.mask & CBEIF_INDENT)
            pceItem->iIndent = nm.ceItem.iIndent;
        if (nm.ceItem.mask & CBEIF_IMAGE)
            pceItem->iImage = nm.ceItem.iImage;
        if (nm.ceItem.mask & CBEIF_SELECTEDIMAGE)
            pceItem->iSelectedImage = nm.ceItem.iSelectedImage;
        if (nm.ceItem.mask & CBEIF_OVERLAY)
            pceItem->iOverlay = nm.ceItem.iOverlay;
        if (nm.ceItem.mask & CBEIF_TEXT)
            pceItem->pszText = CCReturnDispInfoText(nm.ceItem.pszText, pceItem->pszText, pceItem->cchTextMax);

        if (nm.ceItem.mask & CBEIF_DI_SETITEM) {

            ComboEx_ISetItem(pce, pcei, &nm.ceItem);
        }
    }
    return TRUE;

}

#ifdef UNICODE
BOOL ComboEx_OnGetItemA(PCOMBOBOXEX pce, PCOMBOBOXEXITEMA pceItem)
{
    LPWSTR pwszText;
    LPSTR pszTextSave;
    BOOL fRet;

    if (!(pceItem->mask & CBEIF_TEXT)) {
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    }

    pwszText = (LPWSTR)LocalAlloc(LPTR, (pceItem->cchTextMax+1)*sizeof(WCHAR));
    if (!pwszText)
        return FALSE;
    pszTextSave = pceItem->pszText;
    ((PCOMBOBOXEXITEM)pceItem)->pszText = pwszText;
    fRet = ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    pceItem->pszText = pszTextSave;

    if (fRet) 
    {
        // WCTMB failes w/ ERROR_INSUFFICIENT_BUFFER whereas the native-A implementation truncates
        WideCharToMultiByte(CP_ACP, 0, pwszText, -1,
                            (LPSTR)pszTextSave, pceItem->cchTextMax, NULL, NULL);
    }
    LocalFree(pwszText);
    return fRet;

}
#endif

BOOL ComboEx_OnSetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    if(pceItem->iItem != -1) {
        PCEITEM pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
        UINT rdwFlags = 0;

        if (pcei == (PCEITEM)-1)
            return FALSE;

        ComboEx_ISetItem(pce, pcei, pceItem);

        if (rdwFlags & (CBEIF_INDENT | CBEIF_IMAGE |CBEIF_SELECTEDIMAGE | CBEIF_TEXT | CBEIF_OVERLAY)) {
            rdwFlags = RDW_ERASE | RDW_INVALIDATE;
        }

        if (rdwFlags) 
        {
            RedrawWindow(pce->hwndCombo, NULL, NULL, rdwFlags);
        }

        if (pceItem->iItem == (INT)ComboBox_GetCurSel(pce->hwndCombo))
            ComboEx_UpdateEditText(pce, FALSE);
        // FEATURE: notify item changed
        return TRUE;

  } else {

        pce->cei.iImage = -1;
        pce->cei.iSelectedImage = -1;

        ComboEx_ISetItem(pce, &(pce->cei), pceItem);

        pce->fEditItemSet = TRUE;

        if (!pce->hwndEdit){
            Str_Set(&pce->cei.pszText, NULL);
            pce->fEditItemSet = FALSE;
            return(CB_ERR);
        }

        if(pce->cei.pszText) {
            SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
            EDIT_SELECTALL( pce->hwndEdit );
        }
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return TRUE;

   }
}

void ComboEx_HandleDeleteItem(PCOMBOBOXEX pce, LPDELETEITEMSTRUCT pdis)
{
    PCEITEM pcei = (PCEITEM)pdis->itemData;
    if (pcei) {
        NMCOMBOBOXEX nm;

        Str_Set(&pcei->pszText, NULL);

        nm.ceItem.iItem = (INT)pdis->itemID;
        nm.ceItem.mask = CBEIF_LPARAM;
        nm.ceItem.lParam = pcei->lParam;
        CCSendNotify(&pce->ci, CBEN_DELETEITEM, &nm.hdr);

        LocalFree(pcei);
    }
}

LRESULT ComboEx_OnInsertItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    LRESULT iRet;
    PCEITEM pcei = (PCEITEM)LocalAlloc(LPTR, sizeof(CEITEM));

    if (!pcei)
        return -1;

    pcei->iImage = -1;
    pcei->iSelectedImage = -1;
    //pcei->iOverlay = 0;
    //pcei->iIndent = 0;

    ComboEx_ISetItem(pce, pcei, pceItem);

    iRet = ComboBox_InsertString(pce->hwndCombo, pceItem->iItem, pcei);
    if (iRet != -1) {
        NMCOMBOBOXEX nm;

        nm.ceItem = *pceItem;
        CCSendNotify(&pce->ci, CBEN_INSERTITEM, &nm.hdr);
    }
    return iRet;
}


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp)
{
    RECT rcWindow, rcClient;
    RECT rc;
    int  cxInner;
    int cy;

    GetWindowRect(pce->ci.hwnd, &rcWindow);

    if (pwp) {
        // check to see if our size & position aren't actually changing (rebar, for one, 
        // does lots of DeferWindowPos calls that don't actually change our size or position
        // but still generate WM_WINDOWPOSCHANGING msgs).  we avoid flicker by bailing here.
        RECT rcWp;
        SetRect(&rcWp, pwp->x, pwp->y, pwp->x + pwp->cx, pwp->y + pwp->cy);
        MapWindowRect(GetParent(pce->ci.hwnd), HWND_DESKTOP, (LPPOINT)&rcWp);
        if (EqualRect(&rcWp, &rcWindow)) {
            // this is a noop, so bail
            return;
        }
    }

    GetClientRect(pce->ci.hwnd, &rcClient);

    if (pwp)
        cxInner = pwp->cx + RECTWIDTH(rcWindow) - RECTWIDTH(rcClient);
    else
        cxInner = RECTWIDTH(rcClient);

    GetWindowRect(pce->hwndCombo, &rc);
    if (cxInner) {

        // don't size the inner combo if width is 0; otherwise, the below
        // computation will make the comboEX the height of the inner combo
        // top + inner combo dropdown instead of JUST the inner combo top
        cy = (pwp && ((pce->ci.style & CBS_DROPDOWNLIST) == CBS_SIMPLE)) ?  pwp->cy : RECTHEIGHT(rc);

        SetWindowPos(pce->hwndCombo, NULL, 0, 0, cxInner, cy,
                                          SWP_NOACTIVATE | (pce->hwndEdit ? SWP_NOREDRAW : 0));
    }

    GetWindowRect(pce->hwndCombo, &rc);

    cy = RECTHEIGHT(rc) + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

    if (pwp) 
    {
        if (cy < pwp->cy || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) 
        {
            pwp->cy = cy;
        }
    }
    else 
    {

        if (cy < RECTHEIGHT(rcWindow) || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) 
        {
            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
    }

    if (pce->hwndEdit)
    {
        ComboEx_SizeEditBox(pce);
        InvalidateRect(pce->hwndCombo, NULL, TRUE);
    }
}

LRESULT ComboEx_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    if (!pce)
        return 0;

    if (uCmd == CBN_SELCHANGE)
        // update the edit text before forwarding this notification 'cause in
        // a normal combobox, the edit control will have already been updated
        // upon receipt of this notification
        ComboEx_UpdateEditText(pce, FALSE);

    lres = SendMessage(pce->ci.hwndParent, WM_COMMAND, GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, uCmd));

    switch (uCmd) 
    {

    case CBN_DROPDOWN:
        pce->iSel = ComboBox_GetCurSel(pce->hwndCombo);
        ComboEx_EndEdit(pce, CBENF_DROPDOWN);
        if (GetFocus() == pce->hwndEdit)
            SetFocus(pce->hwndCombo);
        pce->fInDrop = TRUE;
        break;

    case CBN_KILLFOCUS:
        ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
        break;

    case CBN_CLOSEUP:
        pce->iSel = -1;
        ComboEx_BeginEdit(pce);
        pce->fInDrop = FALSE;
        break;

    case CBN_SETFOCUS:
        ComboEx_BeginEdit(pce);
        break;

    }

    return lres;
}

LRESULT ComboEx_OnGetItemData(PCOMBOBOXEX pce, WPARAM i)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) 
    {
        return CB_ERR;
    }

    return pcei->lParam;
}

LRESULT ComboEx_OnSetItemData(PCOMBOBOXEX pce, int i, LPARAM lParam)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) 
    {
        return CB_ERR;
    }
    pcei->lParam = lParam;
    return 0;
}

int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz)
{
    int i;
    int iMax = ComboEx_Count(pce);
    TCHAR szText[CBEMAXSTRLEN];
    COMBOBOXEXITEM cei;

    if (iStart < 0)
        iStart = -1;

    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);

    for (i = iStart + 1 ; i < iMax; i++)
    {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei)) 
        {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) 
            {
                return i;
            }
        }
    }

    for (i = 0; i <= iStart; i++)
    {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei))
        {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) 
            {
                return i;
            }
        }
    }

    return CB_ERR;
}

int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2)
{
    if (pce->dwExStyle & CBES_EX_CASESENSITIVE) 
    {
        return lstrcmp(psz1, psz2);
    }
    return lstrcmpi(psz1, psz2);
}

DWORD ComboEx_OnSetExStyle(PCOMBOBOXEX pce, DWORD dwExStyle, DWORD dwExMask)
{
    DWORD dwRet;
    DWORD dwChange;

    if (dwExMask)
        dwExStyle = (pce->dwExStyle & ~ dwExMask) | (dwExStyle & dwExMask);

    dwRet = pce->dwExStyle;
    dwChange = (pce->dwExStyle ^ dwExStyle);

    pce->dwExStyle = dwExStyle;
    if (dwChange & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT))
    {
        InvalidateRect(pce->ci.hwnd, NULL, TRUE);
        if (pce->hwndEdit)
        {
            ComboEx_SizeEditBox(pce);
            InvalidateRect(pce->hwndEdit, NULL, TRUE);
        }
    }

    if (dwChange & CBES_EX_PATHWORDBREAKPROC)
        SetPathWordBreakProc(pce->hwndEdit, (pce->dwExStyle & CBES_EX_PATHWORDBREAKPROC));

    return dwRet;
}

HFONT ComboEx_GetFont(PCOMBOBOXEX pce)
{
    if (pce->hwndCombo)
        return (HFONT)SendMessage(pce->hwndCombo, WM_GETFONT, 0, 0);

    return NULL;
}

LRESULT CALLBACK ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    PCOMBOBOXEX pce = (PCOMBOBOXEX)GetWindowPtr(hwnd, 0);

    if (!pce) 
    {
        if (uMsg != WM_NCCREATE &&
            uMsg != WM_CREATE)
            goto DoDefault;
    }

    switch (uMsg) 
    {
        HANDLE_MSG(pce, WM_SETFONT, ComboEx_OnSetFont);

    case WM_ENABLE:
        if (pce->hwndCombo)
            EnableWindow(pce->hwndCombo, (BOOL) wParam);
        if (pce->hwndEdit)
            EnableWindow(pce->hwndEdit, (BOOL) wParam);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        // only need to re-create this font if we created it in the first place
        // and somebody changed the font (or did a wildcard change)
        //
        // NOTE: Some people broadcast a nonclient metrics change when they
        //       change the icon title logfont, so watch for both.
        //
        if (pce && pce->fFontCreated &&
            ((wParam == 0 && lParam == 0) ||
             wParam == SPI_SETICONTITLELOGFONT ||
             wParam == SPI_SETNONCLIENTMETRICS))
        {
            ComboEx_OnSetFont(pce, NULL, TRUE);
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pce->ci, lParam);
        break;

    case WM_NCCREATE:
        // strip off the scroll bits
        SetWindowBits(hwnd, GWL_STYLE, WS_BORDER | WS_VSCROLL | WS_HSCROLL, 0);
        goto DoDefault;

    case WM_CREATE:
        if (!ComboEx_OnCreate(hwnd, (LPCREATESTRUCT)lParam))
            lres = -1; // OnCreate falied. Fail WM_CREATE
        break;

    case WM_PRINTCLIENT:
        CCSendPrint(&pce->ci, (HDC)wParam);
        break;

    case WM_DESTROY:
        ASSERT(pce);
        ComboEx_OnDestroy(pce);
        break;

    case WM_WINDOWPOSCHANGING:
        ComboEx_OnWindowPosChanging(pce, (LPWINDOWPOS)lParam);
        break;

    case WM_DRAWITEM:
        ComboEx_OnDrawItem(pce, (LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_MEASUREITEM:
        ComboEx_OnMeasureItem(pce, (LPMEASUREITEMSTRUCT)lParam);
        break;

    case WM_COMMAND:
        return ComboEx_HandleCommand(pce, wParam, lParam);

    case WM_GETFONT:
        return (LRESULT)ComboEx_GetFont(pce);

    case WM_SETFOCUS:
        if (pce->hwndCombo)
            SetFocus(pce->hwndCombo);
        break;

    case WM_DELETEITEM:
        ComboEx_HandleDeleteItem(pce, (LPDELETEITEMSTRUCT)lParam);
        return TRUE;

    case WM_UPDATEUISTATE:
        //not sure need to set bit, will probably not use it, on the other hand this
        //  is consistent with remaining of common controls and not very expensive
        CCOnUIState(&(pce->ci), WM_UPDATEUISTATE, wParam, lParam);

        goto DoDefault;

    // this is for backcompat only.
    case CBEM_SETEXSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)wParam, 0);
        
    case CBEM_SETEXTENDEDSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)lParam, (DWORD)wParam);

    case CBEM_GETEXTENDEDSTYLE:
        return pce->dwExStyle;

    case CBEM_GETCOMBOCONTROL:
        return (LRESULT)pce->hwndCombo;

    case CBEM_SETIMAGELIST:
        return (LRESULT)ComboEx_OnSetImageList(pce, (HIMAGELIST)lParam);

    case CBEM_GETIMAGELIST:
        return (LRESULT)pce->himl;

    case CBEM_GETITEMA:
        return ComboEx_OnGetItemA(pce, (PCOMBOBOXEXITEMA)lParam);

    case CBEM_GETITEM:
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)lParam);

    case CBEM_SETITEMA: 
        {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

           if ((((PCOMBOBOXEXITEM)lParam)->mask & CBEIF_TEXT) &&
               (((PCOMBOBOXEXITEM)lParam)->pszText != LPSTR_TEXTCALLBACK)) {

                uiCount = lstrlenA(lpAnsiString)+1;
                lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

                if (!lpStrings)
                    return -1;

                MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                                   lpStrings, uiCount);

                ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
                lResult = ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
                ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
                LocalFree(lpStrings);

                return lResult;
            } else {
                return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
            }
        }
    case CBEM_SETITEM:
        return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);

    case CBEM_INSERTITEMA: 
        {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

            if (!lpAnsiString || lpAnsiString == (LPSTR)LPSTR_TEXTCALLBACK)
                return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);

            uiCount = lstrlenA(lpAnsiString)+1;
            lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

            if (!lpStrings)
                return -1;

            MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                               lpStrings, uiCount);

            ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
            lResult = ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);
            ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
            LocalFree(lpStrings);

            return lResult;
        }

    case CBEM_INSERTITEM:
        return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);



    case CBEM_GETEDITCONTROL:
        return (LRESULT)pce->hwndEdit;

    case CBEM_HASEDITCHANGED:
        return pce->fEditChanged;

    case CBEM_SETWINDOWTHEME:
        if (lParam)
        {
            SetWindowTheme(hwnd, (LPWSTR)lParam, NULL);
            if (pce->hwndCombo)
                SetWindowTheme(pce->hwndCombo, (LPWSTR)lParam, NULL);
            if (pce->hwndEdit)
                SetWindowTheme(pce->hwndEdit, (LPWSTR)lParam, NULL);
        }
        break;

    case CB_GETITEMDATA:
        return ComboEx_OnGetItemData(pce, (int)wParam);

    case CB_SETITEMDATA:
        return ComboEx_OnSetItemData(pce, (int)wParam, lParam);

    case CB_LIMITTEXT:
        if (ComboEx_GetEditBox(pce))
            Edit_LimitText(pce->hwndEdit, wParam);
        break;

    case CB_FINDSTRINGEXACT:
    {
        LPCTSTR psz = (LPCTSTR)lParam;
        return ComboEx_OnFindStringExact(pce, (int)wParam, psz);
    }

    case CB_SETITEMHEIGHT:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        if (wParam == (WPARAM)-1) 
        {
            RECT rcWindow, rcClient;
            int cy;

            GetWindowRect(pce->hwndCombo, &rcWindow);
            cy = RECTHEIGHT(rcWindow);

            GetWindowRect(pce->ci.hwnd, &rcWindow);
            GetClientRect(pce->ci.hwnd, &rcClient);

            cy = cy + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
        break;

    case CB_INSERTSTRING:
    case CB_ADDSTRING:
    case CB_SETEDITSEL:
    case CB_FINDSTRING:
    case CB_DIR:
        // override to do nothing
        break;

    case CB_SETCURSEL:
    case CB_RESETCONTENT:
    case CB_DELETESTRING:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        ComboEx_UpdateEditText(pce, uMsg == CB_SETCURSEL);
        break;

    case WM_SETTEXT:
        if (!pce->hwndEdit)
            return(CB_ERR);
        
        lres = SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
        EDIT_SELECTALL( pce->hwndEdit );
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return(lres);

    case WM_CUT:
    case WM_COPY:
    case WM_PASTE:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
        if (!pce->hwndEdit)
            return 0;
        return(SendMessage(pce->hwndEdit, uMsg, wParam, lParam));

    case WM_SETREDRAW:
        if (pce->hwndEdit)
            SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
        break;

    case CB_GETEDITSEL:
        if (pce->hwndEdit)
            return SendMessage(pce->hwndEdit, EM_GETSEL, wParam, lParam);
        // else fall through

    // Handle it being in a dialog...
    // May want to handle it differently when edit control has
    // focus...
    case WM_GETDLGCODE:
    case CB_SHOWDROPDOWN:
    case CB_SETEXTENDEDUI:
    case CB_GETEXTENDEDUI:
    case CB_GETDROPPEDSTATE:
    case CB_GETDROPPEDCONTROLRECT:
    case CB_GETCURSEL:
    case CB_GETCOUNT:
    case CB_SELECTSTRING:
    case CB_GETITEMHEIGHT:
    case CB_SETDROPPEDWIDTH:
        return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);

    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    default:
        if (CCWndProc(&pce->ci, uMsg, wParam, lParam, &lres))
            return lres;

DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}


BOOL InitComboExClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ComboExWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szComboBoxEx;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(PCOMBOBOXEX);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, c_szComboBoxEx, &wc))
        return FALSE;

    return TRUE;

}

//---------------------------------------------------------------------------
// SetPathWordBreakProc does special break processing for edit controls.
//
// The word break proc is called when ctrl-(left or right) arrow is pressed in the
// edit control.  Normal processing provided by USER breaks words at spaces or tabs,
// but for us it would be nice to break words at slashes, backslashes, & periods too
// since it may be common to have paths or url's typed in.
void WINAPI SetPathWordBreakProc(HWND hwndEdit, BOOL fSet)
{
   PROC lpfnOld;
    // Don't shaft folks who set their own break proc - leave it alone.
    lpfnOld = (FARPROC)SendMessage(hwndEdit, EM_GETWORDBREAKPROC, 0, 0L);

    if (fSet) 
    {
        if (!lpfnOld)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, (LPARAM)ShellEditWordBreakProc);
    }
    else
    {
        if (lpfnOld == (FARPROC)ShellEditWordBreakProc)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, 0L);
    }
}

BOOL IsDelimiter(TCHAR ch)
{
    return (ch == TEXT(' ')  ||
            ch == TEXT('\t') ||
            ch == TEXT('.')  ||
            ch == TEXT('/')  ||
            ch == TEXT('\\'));
}

int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code)
{
    LPTSTR lpchT = lpch + ichCurrent;
    int iIndex;
    BOOL fFoundNonDelimiter = FALSE;
    static BOOL fRight = FALSE;  // hack due to bug in USER

    switch (code)
    {
        case WB_ISDELIMITER:
            fRight = TRUE;
            // Simple case - is the current character a delimiter?
            iIndex = (int)IsDelimiter(*lpchT);
            break;

        case WB_LEFT:
            // Move to the left to find the first delimiter.  If we are
            // currently at a delimiter, then skip delimiters until we
            // find the first non-delimiter, then start from there.
            //
            // Special case for fRight - if we are currently at a delimiter
            // then just return the current word!
            while ((lpchT = CharPrev(lpch, lpchT)) != lpch) 
            {
                if (IsDelimiter(*lpchT))
                {
                    if (fRight || fFoundNonDelimiter)
                        break;
                } 
                else 
                {
                    fFoundNonDelimiter = TRUE;
                    fRight = FALSE;
                }
            }
            iIndex = (int) (lpchT - lpch);

            // We are currently pointing at the delimiter, next character
            // is the beginning of the next word.
            if (iIndex > 0 && iIndex < cch)
                iIndex++;

            break;

        case WB_RIGHT:
            fRight = FALSE;

            // If we are not at a delimiter, then skip to the right until
            // we find the first delimiter.  If we started at a delimiter, or
            // we have just finished scanning to the first delimiter, then
            // skip all delimiters until we find the first non delimiter.
            //
            // Careful - the string passed in to us may not be NULL terminated!
            fFoundNonDelimiter = !IsDelimiter(*lpchT);
            if (lpchT != (lpch + cch))
            {
                while ((lpchT = FastCharNext(lpchT)) != (lpch + cch))
                {
                    if (IsDelimiter(*lpchT)) 
                    {
                        fFoundNonDelimiter = FALSE;
                    } 
                    else
                    {
                        if (!fFoundNonDelimiter)
                            break;
                    }
                }
            }
            // We are currently pointing at the next word.
            iIndex = (int) (lpchT - lpch);
            break;
    }

    return iIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\crtfree.cpp ===
#include <windows.h>

// do this so that we can override new with an allocator that zero-inits
#define CPP_FUNCTIONS
#include <crtfree.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\combo.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "combo.h"
#include "listbox.h"    // For LBIV struct


//---------------------------------------------------------------------------//
//
//  InitComboboxClass() - Registers the control's window class 
//
BOOL InitComboboxClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = ComboBox_WndProc;
    wc.lpszClassName = WC_COMBOBOX;
    wc.style         = CS_GLOBALCLASS | CS_PARENTDC | CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PCBOX);
    wc.hInstance     = hInstance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszMenuName  = NULL;

    if (!RegisterClass(&wc) && !GetClassInfo(hInstance, WC_COMBOBOX, &wc))
        return FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------//
//
//  InitComboLBoxClass() - Registers the control's dropdown window class 
//
// The dropdown list is a specially registered version
// of the listbox control called ComboLBox. We need to
// register this dummy control since apps looking for a
// combobox's listbox look for the classname ComboLBox 
//
BOOL FAR PASCAL InitComboLBoxClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ListBox_WndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_COMBOLBOX;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_GLOBALCLASS | CS_SAVEBITS | CS_DBLCLKS;
    wc.cbWndExtra      = sizeof(PLBIV);
    wc.cbClsExtra      = 0;

    if (!RegisterClass(&wc) && !GetClassInfo(hinst, WC_COMBOLBOX, &wc))
        return FALSE;

    return TRUE;

}


//---------------------------------------------------------------------------//
//
// ComboBox_PressButton()
//
// Pops combobox button back up.
//
VOID ComboBox_PressButton(PCBOX pcbox, BOOL fPress)
{
    //
    // Publisher relies on getting a WM_PAINT message after the combo list
    // pops back up.  On a WM_PAINT they change the focus, which causes
    // toolbar combos to send CBN_SELENDCANCEL notifications.  On this
    // notification they apply the font/pt size change you made to the
    // selection.
    //
    // This happened in 3.1 because the dropdown list overlapped the button
    // on the bottom or top by a pixel.  Since we'd end up painting under
    // the list SPB, when it went away USER would reinvalidate the dirty
    // area.  This would cause a paint message.
    //
    // In 4.0, this doesn't happen because the dropdown doesn't overlap.  So
    // we need to make sure Publisher gets a WM_PAINT anyway.  We do this
    // by changing where the dropdown shows up for 3.x apps
    //
    //

    if ((pcbox->fButtonPressed != 0) != (fPress != 0)) 
    {
        HWND hwnd = pcbox->hwnd;

        pcbox->fButtonPressed = (fPress != 0);
        if (pcbox->f3DCombo)
        {
            InvalidateRect(hwnd, &pcbox->buttonrc, TRUE);
        }
        else
        {
            RECT rc;

            CopyRect(&rc, &pcbox->buttonrc);
            InflateRect(&rc, 0, GetSystemMetrics(SM_CYEDGE));
            InvalidateRect(hwnd, &rc, TRUE);
        }

        UpdateWindow(hwnd);

        NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_HotTrack
//
// If we're not already hot-tracking and the mouse is over the combobox,
// turn on hot-tracking and invalidate the drop-down button.
//
VOID ComboBox_HotTrack(PCBOX pcbox, POINT pt)
{
    if (!pcbox->fButtonHotTracked && !pcbox->fMouseDown) 
    {
        TRACKMOUSEEVENT tme; 

        tme.cbSize      = sizeof(TRACKMOUSEEVENT);
        tme.dwFlags     = TME_LEAVE;
        tme.hwndTrack   = pcbox->hwnd;
        tme.dwHoverTime = 0;
        if (TrackMouseEvent(&tme)) 
        {
            if ((pcbox->CBoxStyle == SDROPDOWN &&
                 PtInRect(&pcbox->buttonrc, pt)) ||
                 pcbox->CBoxStyle == SDROPDOWNLIST) 
            {
                pcbox->fButtonHotTracked = TRUE;
                InvalidateRect(pcbox->hwnd, NULL, TRUE);
            }
            else
            {
                pcbox->fButtonHotTracked = FALSE;
            }
        }
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_DBCharHandler
//
// Double Byte character handler for ANSI ComboBox
//
LRESULT ComboBox_DBCharHandler(PCBOX pcbox, HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    WORD w;
    HWND hwndSend;

    w = DbcsCombine(hwnd, (BYTE)wParam);
    if (w == 0) 
    {
        return CB_ERR;  // Failed to assemble DBCS
    }

    UserAssert(pcbox->hwndList);
    if (pcbox->fNoEdit) 
    {
        hwndSend = pcbox->hwndList;
    } 
    else if (pcbox->hwndEdit) 
    {
        TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: WM_CHAR is posted to Combobox itself(%08x).",
                hwnd);
        hwndSend = pcbox->hwndEdit;
    } 
    else 
    {
        return CB_ERR;
    }

    TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: sending WM_CHAR %04x", w);

    if (!TestWF(hwndSend, WFANSIPROC)) 
    {
        //
        // If receiver is not ANSI WndProc (may be subclassed?),
        // send a UNICODE message.
        //
        WCHAR wChar;
        LPWSTR lpwstr = &wChar;

        if (MBToWCSEx(CP_ACP, (LPCSTR)&w, 2, &lpwstr, 1, FALSE) == 0) 
        {
            TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: cannot convert 0x%04x to UNICODE.", w);
            return CB_ERR;
        }

        return SendMessage(hwndSend, message, wChar, lParam);
    }

    //
    // Post the Trailing byte to the target
    // so that they can peek the second WM_CHAR
    // message later.
    // Note: it's safe since sender is A and receiver is A,
    // translation layer does not perform any DBCS combining and cracking.
    //PostMessageA(hwndSend, message, CrackCombinedDbcsTB(w), lParam);
    //
    return SendMessage(hwndSend, message, wParam, lParam);
}


//---------------------------------------------------------------------------//
BOOL ComboBox_MsgOKInit(UINT message, LRESULT* plRet)
{
    switch (message) 
    {
    default:
        break;
    case WM_SIZE:
    case CB_SETMINVISIBLE:
    case CB_GETMINVISIBLE:
        *plRet = 0;
        return FALSE;
    case WM_STYLECHANGED:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
    case WM_PRINT:
    case WM_COMMAND:
    case CBEC_KILLCOMBOFOCUS:
    case WM_PRINTCLIENT:
    case WM_SETFONT:
    case WM_SYSKEYDOWN:
    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
    case WM_MOUSEWHEEL:
    case WM_CAPTURECHANGED:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
    case WM_SETFOCUS:
    case WM_KILLFOCUS:
    case WM_SETREDRAW:
    case WM_ENABLE:
    case CB_SETDROPPEDWIDTH:
    case CB_DIR:
    case CB_ADDSTRING:
        //
        // Cannot handle those messages yet. Bail out.
        //
        *plRet = CB_ERR;
        return FALSE;
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// ComboBox_MessageItemHandler
//
// Handles WM_DRAWITEM,WM_MEASUREITEM,WM_DELETEITEM,WM_COMPAREITEM
// messages from the listbox.
//
LRESULT ComboBox_MessageItemHandler(PCBOX pcbox, UINT uMsg, LPVOID lpv)
{
    LRESULT lRet;

    //
    // Send the <lpv>item message back to the application after changing some
    // parameters to their combo box specific versions.
    //
    ((LPMEASUREITEMSTRUCT)lpv)->CtlType = ODT_COMBOBOX;
    ((LPMEASUREITEMSTRUCT)lpv)->CtlID = GetWindowID(pcbox->hwnd);
 
    switch (uMsg)
    {
    case WM_DRAWITEM:
        ((LPDRAWITEMSTRUCT)lpv)->hwndItem = pcbox->hwnd;
        break;

    case WM_DELETEITEM:
        ((LPDELETEITEMSTRUCT)lpv)->hwndItem = pcbox->hwnd;
        break;

    case WM_COMPAREITEM:
        ((LPCOMPAREITEMSTRUCT)lpv)->hwndItem = pcbox->hwnd;
        break;
    }

    lRet = SendMessage(pcbox->hwndParent, uMsg, (WPARAM)GetWindowID(pcbox->hwnd), (LPARAM)lpv);

    return lRet;
}


//---------------------------------------------------------------------------//
VOID ComboBox_Paint(PCBOX pcbox, HDC hdc)
{
    RECT rc;
    UINT msg;
    HBRUSH hbr;
    INT iStateId;

    CCDBUFFER ccdb;

    if (pcbox->fButtonPressed)
    {
        iStateId = CBXS_PRESSED;
    }
    else if ( !IsWindowEnabled(pcbox->hwnd))
    {
        iStateId = CBXS_DISABLED;
    }
    else if (pcbox->fButtonHotTracked)
    {
        iStateId = CBXS_HOT;
    }
    else
    {
        iStateId = CBXS_NORMAL;
    }
        
    rc.left = rc.top = 0;
    rc.right = pcbox->cxCombo;
    rc.bottom = pcbox->cyCombo;

    hdc = CCBeginDoubleBuffer(hdc, &rc, &ccdb);

    if ( !pcbox->hTheme )
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST | (!pcbox->f3DCombo ? BF_FLAT | BF_MONO : 0));
    }
    else
    {
        DrawThemeBackground(pcbox->hTheme, hdc, 0, iStateId, &rc, 0);
    }

    if ( !IsRectEmpty(&pcbox->buttonrc) )
    {
        //
        // Draw in the dropdown arrow button
        //
        if (!pcbox->hTheme)
        {
            DrawFrameControl(hdc, &pcbox->buttonrc, DFC_SCROLL,
                DFCS_SCROLLCOMBOBOX |
                (pcbox->fButtonPressed ? DFCS_PUSHED | DFCS_FLAT : 0) |
                (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) ? DFCS_INACTIVE : 0) |
                (pcbox->fButtonHotTracked ? DFCS_HOT: 0));
        }
        else
        {
            DrawThemeBackground(pcbox->hTheme, hdc, CP_DROPDOWNBUTTON, iStateId, &pcbox->buttonrc, 0);
        }

        if (pcbox->fRightAlign )
        {
            rc.left = pcbox->buttonrc.right;
        }
        else
        {
            rc.right = pcbox->buttonrc.left;
        }
    }

    //
    // Erase the background behind the edit/static item.  Since a combo
    // is an edit field/list box hybrid, we use the same coloring
    // conventions.
    //
    msg = WM_CTLCOLOREDIT;
    if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
    {
        ULONG ulStyle = pcbox->hwndEdit ? GetWindowStyle(pcbox->hwndEdit) : 0;
        if (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) ||
            (!pcbox->fNoEdit && pcbox->hwndEdit && (ulStyle & ES_READONLY)))
        {
            msg = WM_CTLCOLORSTATIC;
        }
    } 
    else
    {
        msg = WM_CTLCOLORLISTBOX;
    }

    //
    // GetControlBrush
    //
    hbr = (HBRUSH)SendMessage(GetParent(pcbox->hwnd), msg, (WPARAM)hdc, (LPARAM)pcbox->hwnd);

    if (pcbox->fNoEdit)
    {
        ComboBox_InternalUpdateEditWindow(pcbox, hdc);
    }
    else if (!pcbox->hTheme)
    {
        FillRect(hdc, &rc, hbr);
    }

    CCEndDoubleBuffer(&ccdb);
}


//---------------------------------------------------------------------------//
//
// ComboBox_NotifyParent
//
// Sends the notification code to the parent of the combo box control
//
VOID ComboBox_NotifyParent(PCBOX pcbox, short notificationCode)
{
    HWND hwndSend = (pcbox->hwndParent != 0) ? pcbox->hwndParent : pcbox->hwnd;

    //
    // wParam contains Control ID and notification code.
    // lParam contains Handle to window
    //
    SendMessage(hwndSend, WM_COMMAND,
            MAKELONG(GetWindowID(pcbox->hwnd), notificationCode),
            (LPARAM)pcbox->hwnd);
}


//---------------------------------------------------------------------------//
//
// ComboBox_UpdateListBoxWindow
//
// matches the text in the editcontrol. If fSelectionAlso is false, then we
// unselect the current listbox selection and just move the caret to the item
// which is the closest match to the text in the editcontrol.
//
VOID ComboBox_UpdateListBoxWindow(PCBOX pcbox, BOOL fSelectionAlso)
{

    if (pcbox->hwndEdit) 
    {
        INT    cchText;
        INT    sItem, sSel;
        LPWSTR pText = NULL;

        sItem = CB_ERR;

        cchText = (int)SendMessage(pcbox->hwndEdit, WM_GETTEXTLENGTH, 0, 0);
        if (cchText) 
        {
            cchText++;
            pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR));
            if (pText != NULL) 
            {
                try 
                {
                    SendMessage(pcbox->hwndEdit, WM_GETTEXT, cchText, (LPARAM)pText);
                    sItem = (int)SendMessage(pcbox->hwndList, LB_FINDSTRING,
                            (WPARAM)-1L, (LPARAM)pText);
                } 
                finally 
                {
                    UserLocalFree((HANDLE)pText);
                }
            }
        }

        if (fSelectionAlso) 
        {
            sSel = sItem;
        } 
        else 
        {
            sSel = CB_ERR;
        }

        if (sItem == CB_ERR)
        {
            sItem = 0;

            //
            // Old apps:  w/ editable combos, selected 1st item in list even if
            // it didn't match text in edit field.  This is not desirable
            // behavior for 4.0 dudes esp. with cancel allowed.  Reason:
            //      (1) User types in text that doesn't match list choices
            //      (2) User drops combo
            //      (3) User pops combo back up
            //      (4) User presses OK in dialog that does stuff w/ combo
            //          contents.
            // In 3.1, when the combo dropped, we'd select the 1st item anyway.
            // So the last CBN_SELCHANGE the owner got would be 0--which is
            // bogus because it really should be -1.  In fact if you type anything
            // into the combo afterwards it will reset itself to -1.
            //
            // 4.0 dudes won't get this bogus 0 selection.
            //
            if (fSelectionAlso && !TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
            {
                sSel = 0;
            }
        }

        SendMessage(pcbox->hwndList, LB_SETCURSEL, (DWORD)sSel, 0);
        SendMessage(pcbox->hwndList, LB_SETCARETINDEX, (DWORD)sItem, 0);
        SendMessage(pcbox->hwndList, LB_SETTOPINDEX, (DWORD)sItem, 0);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_InvertStaticWindow
//
// Inverts the static text/picture window associated with the combo
// box.  Gets its own hdc, if the one given is null.
//
VOID ComboBox_InvertStaticWindow(PCBOX pcbox, BOOL fNewSelectionState, HDC hdc)
{
    BOOL focusSave = pcbox->fFocus;

    pcbox->fFocus = (UINT)fNewSelectionState;
    ComboBox_InternalUpdateEditWindow(pcbox, hdc);

    pcbox->fFocus = (UINT)focusSave;
}


//---------------------------------------------------------------------------//
//
// ComboBox_GetFocusHandler
//
// Handles getting the focus for the combo box
//
VOID ComboBox_GetFocusHandler(PCBOX pcbox)
{
    if (pcbox->fFocus)
    {
        return;
    }

    //
    // The combo box has gotten the focus for the first time.
    //

    //
    // First turn on the listbox caret
    //

    if (pcbox->CBoxStyle == SDROPDOWNLIST)
    {
       SendMessage(pcbox->hwndList, LBCB_CARETON, 0, 0);
    }

    //
    // and select all the text in the editcontrol or static text rectangle.
    //

    if (pcbox->fNoEdit) 
    {
        //
        // Invert the static text rectangle
        //
        ComboBox_InvertStaticWindow(pcbox, TRUE, (HDC)NULL);
    } 
    else if (pcbox->hwndEdit) 
    {
        UserAssert(pcbox->hwnd);
        SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, MAXLONG);
    }

    pcbox->fFocus = TRUE;

    //
    // Notify the parent we have the focus
    //
    ComboBox_NotifyParent(pcbox, CBN_SETFOCUS);
}


//---------------------------------------------------------------------------//
//
// ComboBox_KillFocusHandler
//
// Handles losing the focus for the combo box.
//
VOID ComboBox_KillFocusHandler(PCBOX pcbox)
{
    if (!pcbox->fFocus || pcbox->hwndList == NULL)
    {
        return;
    }

    //
    // The combo box is losing the focus.  Send buttonup clicks so that
    // things release the mouse capture if they have it...  If the
    // pwndListBox is null, don't do anything.  This occurs if the combo box
    // is destroyed while it has the focus.
    //
    SendMessage(pcbox->hwnd, WM_LBUTTONUP, 0L, 0xFFFFFFFFL);
    if (!ComboBox_HideListBoxWindow(pcbox, TRUE, FALSE))
    {
        return;
    }

    //
    // Turn off the listbox caret
    //
    if (pcbox->CBoxStyle == SDROPDOWNLIST)
    {
       SendMessage(pcbox->hwndList, LBCB_CARETOFF, 0, 0);
    }

    if (pcbox->fNoEdit) 
    {
        //
        // Invert the static text rectangle
        //
        ComboBox_InvertStaticWindow(pcbox, FALSE, (HDC)NULL);
    } 
    else if (pcbox->hwndEdit) 
    {
        SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, 0);
    }

    pcbox->fFocus = FALSE;
    ComboBox_NotifyParent(pcbox, CBN_KILLFOCUS);
}


//---------------------------------------------------------------------------//
//
// ComboBox_CommandHandler
//
// Check the various notification codes from the controls and do the
// proper thing.
// always returns 0L
//
LONG ComboBox_CommandHandler(PCBOX pcbox, DWORD wParam, HWND hwndControl)
{
    //
    // Check the edit control notification codes.  Note that currently, edit
    // controls don't send EN_KILLFOCUS messages to the parent.
    //
    if (!pcbox->fNoEdit && (hwndControl == pcbox->hwndEdit)) 
    {
        //
        // Edit control notification codes
        //
        switch (HIWORD(wParam)) 
        {
        case EN_SETFOCUS:
            if (!pcbox->fFocus) 
            {
                //
                // The edit control has the focus for the first time which means
                // this is the first time the combo box has received the focus
                // and the parent must be notified that we have the focus.
                //
                ComboBox_GetFocusHandler(pcbox);
            }

            break;

        case EN_CHANGE:
            ComboBox_NotifyParent(pcbox, CBN_EDITCHANGE);
            ComboBox_UpdateListBoxWindow(pcbox, FALSE);
            break;

        case EN_UPDATE:
            ComboBox_NotifyParent(pcbox, CBN_EDITUPDATE);
            break;

        case EN_ERRSPACE:
            ComboBox_NotifyParent(pcbox, CBN_ERRSPACE);
            break;
        }
    }

    //
    // Check listbox control notification codes
    //
    if (hwndControl == pcbox->hwndList) 
    {
        //
        // Listbox control notification codes
        //
        switch ((int)HIWORD(wParam)) 
        {
        case LBN_DBLCLK:
            ComboBox_NotifyParent(pcbox, CBN_DBLCLK);
            break;

        case LBN_ERRSPACE:
            ComboBox_NotifyParent(pcbox, CBN_ERRSPACE);
            break;

        case LBN_SELCHANGE:
        case LBN_SELCANCEL:
            if (!pcbox->fKeyboardSelInListBox) 
            {
                //
                // If the selchange is caused by the user keyboarding through,
                // we don't want to hide the listbox.
                //
                if (!ComboBox_HideListBoxWindow(pcbox, TRUE, TRUE))
                {
                    return 0;
                }
            } 
            else 
            {
                pcbox->fKeyboardSelInListBox = FALSE;
            }

            ComboBox_NotifyParent(pcbox, CBN_SELCHANGE);
            ComboBox_InternalUpdateEditWindow(pcbox, NULL);

            if (pcbox->fNoEdit)
            {
                NotifyWinEvent(EVENT_OBJECT_VALUECHANGE, pcbox->hwnd, OBJID_CLIENT, INDEX_COMBOBOX);
            }

            break;
        }
    }

    return 0;
}


//---------------------------------------------------------------------------//
//
// ComboBox_CompleteEditWindow
//
//
// Completes the text in the edit box with the closest match from the
// listbox.  If a prefix match can't be found, the edit control text isn't
// updated. Assume a DROPDOWN style combo box.
//
VOID ComboBox_CompleteEditWindow(PCBOX pcbox)
{
    int cchText;
    int cchItemText;
    int itemNumber;
    LPWSTR pText;

    //
    // Firstly check the edit control.
    // 
    if (pcbox->hwndEdit == NULL) 
    {
        return;
    }

    //
    // +1 for null terminator
    //
    cchText = (int)SendMessage(pcbox->hwndEdit, WM_GETTEXTLENGTH, 0, 0);

    if (cchText) 
    {
        cchText++;
        pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR));
        if (!pText)
        {
            goto Unlock;
        }

        //
        // We want to be sure to free the above allocated memory even if
        // the client dies during callback (xxx) or some of the following
        // window revalidation fails.
        //
        try 
        {
            SendMessage(pcbox->hwndEdit, WM_GETTEXT, cchText, (LPARAM)pText);
            itemNumber = (int)SendMessage(pcbox->hwndList,
                    LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pText);

            if (itemNumber == -1)
            {
                itemNumber = (int)SendMessage(pcbox->hwndList,
                        LB_FINDSTRING, (WPARAM)-1, (LPARAM)pText);
            }
        } 
        finally 
        {
            UserLocalFree((HANDLE)pText);
        }

        if (itemNumber == -1) 
        {
            //
            // No close match.  Blow off.
            //
            goto Unlock;
        }

        cchItemText = (int)SendMessage(pcbox->hwndList, LB_GETTEXTLEN,
                itemNumber, 0);
        if (cchItemText) 
        {
            cchItemText++;
            pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchItemText*sizeof(WCHAR));
            if (!pText)
            {
                goto Unlock;
            }

            //
            // We want to be sure to free the above allocated memory even if
            // the client dies during callback (xxx) or some of the following
            // window revalidation fails.
            //
            try 
            {
                SendMessage(pcbox->hwndList, LB_GETTEXT, itemNumber, (LPARAM)pText);
                SendMessage(pcbox->hwndEdit, WM_SETTEXT, 0, (LPARAM)pText);
            } 
            finally 
            {
                UserLocalFree((HANDLE)pText);
            }

            SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, MAXLONG);
        }
    }

Unlock:
    return;
}


//---------------------------------------------------------------------------//
//
// ComboBox_HideListBoxWindow
//
// Hides the dropdown listbox window if it is a dropdown style.
//
BOOL ComboBox_HideListBoxWindow(PCBOX pcbox, BOOL fNotifyParent, BOOL fSelEndOK)
{
    HWND hwnd = pcbox->hwnd;
    HWND hwndList = pcbox->hwndList;

    //
    // For 3.1+ apps, send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
    //
    if (fNotifyParent && TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN31COMPAT) &&
        ((pcbox->CBoxStyle & SDROPPABLE) || fSelEndOK)) 
    {
        if (fSelEndOK)
        {
            ComboBox_NotifyParent(pcbox, CBN_SELENDOK);
        }
        else
        {
            ComboBox_NotifyParent(pcbox, CBN_SELENDCANCEL);
        }

        if (!IsWindow(hwnd))
        {
            return FALSE;
        }
    }

    //
    // return, we don't hide simple combo boxes.
    //
    if (!(pcbox->CBoxStyle & SDROPPABLE)) 
    {
        return TRUE;
    }

    //
    // Send a faked buttonup message to the listbox so that it can release
    // the capture and all.
    //
    SendMessage(pcbox->hwndList, LBCB_ENDTRACK, fSelEndOK, 0);

    if (pcbox->fLBoxVisible) 
    {
        WORD swpFlags = SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE;

        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN31COMPAT))
        {
            swpFlags |= SWP_FRAMECHANGED;
        }

        pcbox->fLBoxVisible = FALSE;

        //
        // Hide the listbox window
        //
        ShowWindow(hwndList, SW_HIDE);

        //
        // Invalidate the item area now since SWP() might update stuff.
        // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
        // redraw the whole thing, including the item rect.  But if it
        // isn't changing size, we still want to redraw the item anyway
        // to show focus/selection.
        //
        if (!(pcbox->CBoxStyle & SEDITABLE))
        {
            InvalidateRect(hwnd, &pcbox->editrc, TRUE);
        }

        SetWindowPos(hwnd, HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo, swpFlags);

        //
        // In case size didn't change
        //
        UpdateWindow(hwnd);

        if (pcbox->CBoxStyle & SEDITABLE) 
        {
            ComboBox_CompleteEditWindow(pcbox);
        }

        if (fNotifyParent) 
        {
            //
            // Notify parent we will be popping up the combo box.
            //
            ComboBox_NotifyParent(pcbox, CBN_CLOSEUP);

            if (!IsWindow(hwnd))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


//---------------------------------------------------------------------------//
//
// ComboBox_ShowListBoxWindow
//
// Lowers the dropdown listbox window.
//
VOID ComboBox_ShowListBoxWindow(PCBOX pcbox, BOOL fTrack)
{
    RECT        editrc;
    RECT        rcWindow;
    RECT        rcList;
    int         itemNumber;
    int         iHeight;
    int         yTop;
    DWORD       dwMult;
    int         cyItem;
    HWND        hwnd = pcbox->hwnd;
    HWND        hwndList = pcbox->hwndList;
    BOOL        fAnimPos;
    HMONITOR    hMonitor;
    MONITORINFO mi = {0};
    BOOL        bCBAnim = FALSE;

    //
    // This function is only called for droppable list comboboxes
    //
    UserAssert(pcbox->CBoxStyle & SDROPPABLE);

    //
    // Notify parent we will be dropping down the combo box.
    //
    ComboBox_NotifyParent(pcbox, CBN_DROPDOWN);

    //
    // Invalidate the button rect so that the depressed arrow is drawn.
    //
    InvalidateRect(hwnd, &pcbox->buttonrc, TRUE);

    pcbox->fLBoxVisible = TRUE;

    if (pcbox->CBoxStyle == SDROPDOWN) 
    {
        //
        // If an item in the listbox matches the text in the edit control,
        // scroll it to the top of the listbox.  Select the item only if the
        // mouse button isn't down otherwise we will select the item when the
        // mouse button goes up.
        //
        ComboBox_UpdateListBoxWindow(pcbox, !pcbox->fMouseDown);

        if (!pcbox->fMouseDown)
        {
            ComboBox_CompleteEditWindow(pcbox);
        }
    } 
    else 
    {
        //
        // Scroll the currently selected item to the top of the listbox.
        //
        itemNumber = (int)SendMessage(pcbox->hwndList, LB_GETCURSEL, 0, 0);
        if (itemNumber == -1) 
        {
            itemNumber = 0;
        }

        SendMessage(pcbox->hwndList, LB_SETTOPINDEX, itemNumber, 0);
        SendMessage(pcbox->hwndList, LBCB_CARETON, 0, 0);

        //
        // We need to invalidate the edit rect so that the focus frame/invert
        // will be turned off when the listbox is visible.  Tandy wants this for
        // his typical reasons...
        //
        InvalidateRect(hwnd, &pcbox->editrc, TRUE);
    }

    //
    // Figure out where to position the dropdown listbox.  We want it just
    // touching the edge around the edit rectangle.  Note that since the
    // listbox is a popup, we need the position in screen coordinates.
    //

    //
    // We want the dropdown to pop below or above the combo
    //

    //
    // Get screen coords
    //
    GetWindowRect(pcbox->hwnd, &rcWindow);
    editrc.left   = rcWindow.left;
    editrc.top    = rcWindow.top;
    editrc.right  = rcWindow.left + pcbox->cxCombo;
    editrc.bottom = rcWindow.top  + pcbox->cyCombo;

    //
    // List area
    //
    cyItem = (int)SendMessage(pcbox->hwndList, LB_GETITEMHEIGHT, 0, 0);

    if (cyItem == 0) 
    {
        //
        // Make sure that it's not 0
        //
        TraceMsg(TF_STANDARD, "UxCombobox: LB_GETITEMHEIGHT is returning 0" );
        cyItem = SYSFONT_CYCHAR;
    }

    //
    //  we shoulda' just been able to use cyDrop here, but thanks to VB's need
    //  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
    //  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)
    //
    GetWindowRect(pcbox->hwndList, &rcList);
    iHeight = max(pcbox->cyDrop, rcList.bottom - rcList.top);

    if (dwMult = (DWORD)SendMessage(pcbox->hwndList, LB_GETCOUNT, 0, 0)) 
    {
        dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
        dwMult += GetSystemMetrics(SM_CYEDGE);

        if (dwMult < 0x7FFF)
        {
            iHeight = min(LOWORD(dwMult), iHeight);
        }
    }

    if (!GET_STYLE(pcbox) & CBS_NOINTEGRALHEIGHT) 
    {
        UserAssert(cyItem);
        iHeight = ((iHeight - GetSystemMetrics(SM_CYEDGE)) / cyItem) * cyItem + GetSystemMetrics(SM_CYEDGE);
    }

    //
    // Other 1/2 of old app combo fix.  Make dropdown overlap combo window
    // a little.  That way we can have a chance of invalidating the overlap
    // and causing a repaint to help out Publisher 2.0's toolbar combos.
    // See comments for PressButton() above.
    //
    hMonitor = MonitorFromWindow(pcbox->hwnd, MONITOR_DEFAULTTOPRIMARY);
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hMonitor, &mi);
    if (editrc.bottom + iHeight <= mi.rcMonitor.bottom) 
    {
        yTop = editrc.bottom;
        if (!pcbox->f3DCombo)
        {
            yTop -= GetSystemMetrics(SM_CYBORDER);
        }

        fAnimPos = TRUE;
    } 
    else 
    {
        yTop = max(editrc.top - iHeight, mi.rcMonitor.top);
        if (!pcbox->f3DCombo)
        {
            yTop += GetSystemMetrics(SM_CYBORDER);
        }

        fAnimPos = FALSE;
    }

    if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
    {
        //
        // fix for Winword B#7504, Combo-ListBox text gets
        // truncated by a small width, this is do to us
        // now setting size here in SetWindowPos, rather than
        // earlier where we did this in Win3.1
        //

        GetWindowRect(pcbox->hwndList, &rcList);
        if ((rcList.right - rcList.left ) > pcbox->cxDrop)
        {
            pcbox->cxDrop = rcList.right - rcList.left;
        }
    }

    if (!TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_LAYOUTRTL))
    {
        SetWindowPos(hwndList, HWND_TOPMOST, editrc.left,
            yTop, max(pcbox->cxDrop, pcbox->cxCombo), iHeight, SWP_NOACTIVATE);
    }
    else
    {
        int cx = max(pcbox->cxDrop, pcbox->cxCombo);

        SetWindowPos(hwndList, HWND_TOPMOST, editrc.right - cx,
            yTop, cx, iHeight, SWP_NOACTIVATE);
    }

    //
    // Get any drawing in the combo box window out of the way so it doesn't
    // invalidate any of the SPB underneath the list window.
    //
    UpdateWindow(hwnd);

    SystemParametersInfo(SPI_GETCOMBOBOXANIMATION, 0, (LPVOID)&bCBAnim, 0);
    if (!bCBAnim)
    {
        ShowWindow(hwndList, SW_SHOWNA);
    } 
    else 
    {
        AnimateWindow(hwndList, CMS_QANIMATION, (fAnimPos ? AW_VER_POSITIVE :
                AW_VER_NEGATIVE) | AW_SLIDE);
    }

    //
    // Restart search buffer from first char
    //
    {
        PLBIV plb = ListBox_GetPtr(pcbox->hwndList);

        if ((plb != NULL) && (plb != (PLBIV)-1)) 
        {
            plb->iTypeSearch = 0;
        }
    }

    if (fTrack && TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
    {
        SendMessage(pcbox->hwndList, LBCB_STARTTRACK, FALSE, 0);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_InternalUpdateEditWindow
//
// Updates the editcontrol/statictext window so that it contains the text
// given by the current selection in the listbox.  If the listbox has no
// selection (ie. -1), then we erase all the text in the editcontrol.
// 
// hdcPaint is from WM_PAINT messages Begin/End Paint hdc. If null, we should
// get our own dc.
//
VOID ComboBox_InternalUpdateEditWindow(PCBOX pcbox, HDC hdcPaint)
{
    int cchText = 0;
    LPWSTR pText = NULL;
    int sItem;
    HDC hdc;
    UINT msg;
    HBRUSH hbrSave;
    HBRUSH hbrControl;
    HANDLE hOldFont;
    DRAWITEMSTRUCT dis;
    RECT rc;
    HWND hwnd = pcbox->hwnd;

    sItem = (int)SendMessage(pcbox->hwndList, LB_GETCURSEL, 0, 0);

    //
    // This 'try-finally' block ensures that the allocated 'pText' will
    // be freed no matter how this routine is exited.
    //
    try 
    {
        if (sItem != -1) 
        {
            cchText = (int)SendMessage(pcbox->hwndList, LB_GETTEXTLEN, (DWORD)sItem, 0);
            pText = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, (cchText+1) * sizeof(WCHAR));
            if (pText) 
            {
                cchText = (int)SendMessage(pcbox->hwndList, LB_GETTEXT,
                        (DWORD)sItem, (LPARAM)pText);
            }
            else
            {
                cchText = 0;
            }
        }

        if (!pcbox->fNoEdit) 
        {
            if (pcbox->hwndEdit) 
            {
                if (GET_STYLE(pcbox) & CBS_HASSTRINGS)
                {
                    SetWindowText(pcbox->hwndEdit, pText ? pText : TEXT(""));
                }

                if (pcbox->fFocus) 
                {
                    //
                    // Only hilite the text if we have the focus.
                    //
                    SendMessage(pcbox->hwndEdit, EM_SETSEL, 0, MAXLONG);
                }
            }
        } 
        else if (IsComboVisible(pcbox)) 
        {
            if (hdcPaint) 
            {
                hdc = hdcPaint;
            } 
            else 
            {
                hdc = GetDC(hwnd);
            }

            SetBkMode(hdc, OPAQUE);
            if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
            {
                if (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED))
                {
                    msg = WM_CTLCOLORSTATIC;
                }
                else
                {
                    msg = WM_CTLCOLOREDIT;
                }
            } 
            else
            {
                msg = WM_CTLCOLORLISTBOX;
            }

            hbrControl = (HBRUSH)SendMessage(GetParent(hwnd), msg, (WPARAM)hdc, (LPARAM)hwnd);
            hbrSave = SelectObject(hdc, hbrControl);

            CopyRect(&rc, &pcbox->editrc);
            InflateRect(&rc, GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER));
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left,
                rc.bottom - rc.top, PATCOPY);
            InflateRect(&rc, -GetSystemMetrics(SM_CXBORDER), -GetSystemMetrics(SM_CYBORDER));

            if (pcbox->fFocus && !pcbox->fLBoxVisible) 
            {
                //
                // Fill in the selected area
                //

                //
                // only do the FillRect if we know its not
                // ownerdraw item, otherwise we mess up people up
                // BUT: for Compat's sake we still do this for Win 3.1 guys
                //
                if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) || !pcbox->OwnerDraw)
                {
                    FillRect(hdc, &rc, GetSysColorBrush(COLOR_HIGHLIGHT));
                }

                SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
            } 
            else if (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) && !pcbox->OwnerDraw) 
            {
                if ((COLORREF)GetSysColor(COLOR_GRAYTEXT) != GetBkColor(hdc))
                {
                    SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
                }
            }

            if (pcbox->hFont != NULL)
            {
                hOldFont = SelectObject(hdc, pcbox->hFont);
            }

            if (pcbox->OwnerDraw) 
            {
                //
                // Let the app draw the stuff in the static text box.
                //
                dis.CtlType = ODT_COMBOBOX;
                dis.CtlID = GetWindowID(pcbox->hwnd);
                dis.itemID = sItem;
                dis.itemAction = ODA_DRAWENTIRE;
                dis.itemState = (UINT)
                    ((pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_SELECTED : 0) |
                    (TESTFLAG(GET_STYLE(pcbox), WS_DISABLED) ? ODS_DISABLED : 0) |
                    (pcbox->fFocus && !pcbox->fLBoxVisible ? ODS_FOCUS : 0) |
                    (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) ? ODS_COMBOBOXEDIT : 0) |
                    (TESTFLAG(GET_EXSTYLE(pcbox), WS_EXP_UIFOCUSHIDDEN) ? ODS_NOFOCUSRECT : 0) |
                    (TESTFLAG(GET_EXSTYLE(pcbox), WS_EXP_UIACCELHIDDEN) ? ODS_NOACCEL : 0));

                dis.hwndItem = hwnd;
                dis.hDC = hdc;
                CopyRect(&dis.rcItem, &rc);

                //
                // Don't let ownerdraw dudes draw outside of the combo client
                // bounds.
                //
                IntersectClipRect(hdc, rc.left, rc.top, rc.right, rc.bottom);

                dis.itemData = (ULONG_PTR)SendMessage(pcbox->hwndList,
                        LB_GETITEMDATA, (UINT)sItem, 0);

                SendMessage(pcbox->hwndParent, WM_DRAWITEM, dis.CtlID, (LPARAM)&dis);
            } 
            else 
            {
                //
                // Start the text one pixel within the rect so that we leave a
                // nice hilite border around the text.
                //

                int x;
                UINT align;

                if (pcbox->fRightAlign ) 
                {
                    align = TA_RIGHT;
                    x = rc.right - GetSystemMetrics(SM_CXBORDER);
                } 
                else 
                {
                    x = rc.left + GetSystemMetrics(SM_CXBORDER);
                    align = 0;
                }

                if (pcbox->fRtoLReading)
                {
                    align |= TA_RTLREADING;
                }

                if (align)
                {
                    SetTextAlign(hdc, GetTextAlign(hdc) | align);
                }

                //
                // Draw the text, leaving a gap on the left & top for selection.
                //
                ExtTextOut(hdc, x, rc.top + GetSystemMetrics(SM_CYBORDER), ETO_CLIPPED | ETO_OPAQUE,
                       &rc, pText ? pText : TEXT(""), cchText, NULL);
                if (pcbox->fFocus && !pcbox->fLBoxVisible) 
                {
                    if (!TESTFLAG(GET_EXSTYLE(pcbox), WS_EXP_UIFOCUSHIDDEN)) 
                    {
                        DrawFocusRect(hdc, &rc);
                    }
                }
            }

            if (pcbox->hFont && hOldFont) 
            {
                SelectObject(hdc, hOldFont);
            }

            if (hbrSave) 
            {
                SelectObject(hdc, hbrSave);
            }

            if (!hdcPaint) 
            {
                ReleaseDC(hwnd, hdc);
            }
        }

    } 
    finally 
    {
        if (pText != NULL)
        {
            UserLocalFree((HANDLE)pText);
        }
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_GetTextLengthHandler
//
// For the combo box without an edit control, returns size of current selected
// item
//
LONG ComboBox_GetTextLengthHandler(PCBOX pcbox)
{
    int item;
    int cchText;

    item = (int)SendMessage(pcbox->hwndList, LB_GETCURSEL, 0, 0);

    if (item == LB_ERR) 
    {
        //
        // No selection so no text.
        //
        cchText = 0;
    } 
    else 
    {
        cchText = (int)SendMessage(pcbox->hwndList, LB_GETTEXTLEN, item, 0);
    }

    return cchText;
}


//---------------------------------------------------------------------------//
//
// ComboBox_GetTextHandler
//
// For the combo box without an edit control, copies cbString bytes of the
// string in the static text box to the buffer given by lpszString.
//
LONG ComboBox_GetTextHandler(PCBOX pcbox, int cchString, LPWSTR lpszString)
{
    int    item;
    int    cchText;
    LPWSTR lpszBuffer;
    DWORD  dw;

    if (!cchString || !lpszString)
    {
        return 0;
    }

    //
    // Null the buffer to be nice.
    //
    *lpszString = 0;

    item = (int)SendMessage(pcbox->hwndList, LB_GETCURSEL, 0, 0);

    if (item == LB_ERR) 
    {
        //
        // No selection so no text.
        //
        return 0;
    }

    cchText = (int)SendMessage(pcbox->hwndList, LB_GETTEXTLEN, item, 0);

    cchText++;
    if ((cchText <= cchString) ||
            (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN31COMPAT) && cchString == 2)) 
    {
        //
        // Just do the copy if the given buffer size is large enough to hold
        // everything.  Or if old 3.0 app.  (Norton used to pass 2 & expect 3
        // chars including the \0 in 3.0; Bug #7018 win31: vatsanp)
        //
        dw = (int)SendMessage(pcbox->hwndList, LB_GETTEXT, item,
                (LPARAM)lpszString);
        return dw;
    }

    lpszBuffer = (LPWSTR)UserLocalAlloc(HEAP_ZERO_MEMORY, cchText*sizeof(WCHAR));
    if (!lpszBuffer) 
    {
        //
        // Bail.  Not enough memory to chop up the text.
        //
        return 0;
    }

    try 
    {
        SendMessage(pcbox->hwndList, LB_GETTEXT, item, (LPARAM)lpszBuffer);
        RtlCopyMemory((PBYTE)lpszString, (PBYTE)lpszBuffer, cchString * sizeof(WCHAR));
        lpszString[cchString - 1] = 0;
    } 
    finally 
    {
        UserLocalFree((HANDLE)lpszBuffer);
    }

    return cchString;
}


//---------------------------------------------------------------------------//
// ComboBox_GetInfo 
//
// return information about this combobox to the caller
// in the ComboBoxInfo struct
//
BOOL ComboBox_GetInfo(PCBOX pcbox, PCOMBOBOXINFO pcbi)
{
    BOOL bRet = FALSE;

    if (!pcbi || pcbi->cbSize != sizeof(COMBOBOXINFO))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        //
        // populate the structure
        //
        pcbi->hwndCombo = pcbox->hwnd;
        pcbi->hwndItem  = pcbox->hwndEdit;
        pcbi->hwndList  = pcbox->hwndList;

        pcbi->rcItem   = pcbox->editrc;
        pcbi->rcButton = pcbox->buttonrc;

        pcbi->stateButton = 0;
        if (pcbox->CBoxStyle == CBS_SIMPLE)
        {
            pcbi->stateButton |= STATE_SYSTEM_INVISIBLE;
        }
        if (pcbox->fButtonPressed)
        {
            pcbi->stateButton |= STATE_SYSTEM_PRESSED;
        }

        bRet = TRUE;
    }

    return bRet;
}


//---------------------------------------------------------------------------//
//
// ComboBox_WndProc
//
// WndProc for comboboxes.
//
LRESULT WINAPI ComboBox_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PCBOX       pcbox;
    POINT       pt;
    LPWSTR      lpwsz = NULL;
    LRESULT     lReturn = TRUE;
    static BOOL fInit = TRUE;
    INT         i;
    RECT        rcCombo;
    RECT        rcList;
    RECT        rcWindow;

    //
    // Get the instance data for this combobox control
    //
    pcbox = ComboBox_GetPtr(hwnd);
    if (!pcbox && uMsg != WM_NCCREATE)
    {
        goto CallDWP;
    }

    //
    // Protect the combobox during the initialization.
    //
    if (!pcbox || pcbox->hwndList == NULL) 
    {
        if (!ComboBox_MsgOKInit(uMsg, &lReturn)) 
        {
            TraceMsg(TF_STANDARD, "UxCombobox: ComboBoxWndProcWorker: msg=%04x is sent to hwnd=%08x in the middle of initialization.",
                    uMsg, hwnd);
            return lReturn;
        }
    }

    //
    // Dispatch the various messages we can receive
    //
    switch (uMsg) 
    {
    case CBEC_KILLCOMBOFOCUS:

        //
        // Private message coming from editcontrol informing us that the combo
        // box is losing the focus to a window which isn't in this combo box.
        //
        ComboBox_KillFocusHandler(pcbox);
        break;

    case WM_COMMAND:

        //
        // So that we can handle notification messages from the listbox and
        // edit control.
        //
        return ComboBox_CommandHandler(pcbox, (DWORD)wParam, (HWND)lParam);

    case WM_STYLECHANGED:
    {
        LONG OldStyle;
        LONG NewStyle = 0;

        UserAssert(pcbox->hwndList != NULL);

        pcbox->fRtoLReading = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RTLREADING);
        pcbox->fRightAlign  = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RIGHT);

        if (pcbox->fRtoLReading)
        {
            NewStyle |= (WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);
        }

        if (pcbox->fRightAlign)
        {
            NewStyle |= WS_EX_RIGHT;
        }

        OldStyle = GetWindowExStyle(pcbox->hwndList) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
        SetWindowLong(pcbox->hwndList, GWL_EXSTYLE, OldStyle|NewStyle);

        if (!pcbox->fNoEdit && pcbox->hwndEdit) 
        {
            OldStyle = GetWindowExStyle(pcbox->hwndEdit) & ~(WS_EX_RIGHT|WS_EX_RTLREADING|WS_EX_LEFTSCROLLBAR);
            SetWindowLong(pcbox->hwndEdit, GWL_EXSTYLE, OldStyle|NewStyle);
        }

        ComboBox_Position(pcbox);
        InvalidateRect(hwnd, NULL, FALSE);

        break;
    }
    case WM_CTLCOLORMSGBOX:
    case WM_CTLCOLOREDIT:
    case WM_CTLCOLORLISTBOX:
    case WM_CTLCOLORBTN:
    case WM_CTLCOLORDLG:
    case WM_CTLCOLORSCROLLBAR:
    case WM_CTLCOLORSTATIC:
    case WM_CTLCOLOR:
        //
        // Causes compatibility problems for 3.X apps.  Forward only
        // for 4.0
        //
        if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
        {
            LRESULT ret;

            ret = SendMessage(pcbox->hwndParent, uMsg, wParam, lParam);
            return ret;
        } 
        else
        {
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        break;

    case WM_GETTEXT:
        if (pcbox->fNoEdit) 
        {
            return ComboBox_GetTextHandler(pcbox, (int)wParam, (LPWSTR)lParam);
        }

        goto CallEditSendMessage;

        break;

    case WM_GETTEXTLENGTH:

        //
        // If the is not edit control, CBS_DROPDOWNLIST, then we have to
        // ask the list box for the size
        //

        if (pcbox->fNoEdit) 
        {
            return ComboBox_GetTextLengthHandler(pcbox);
        }

        // FALL THROUGH

    case WM_CLEAR:
    case WM_CUT:
    case WM_PASTE:
    case WM_COPY:
    case WM_SETTEXT:
        goto CallEditSendMessage;
        break;

    case WM_CREATE:

        //
        // wParam - not used
        // lParam - Points to the CREATESTRUCT data structure for the window.
        //
        return ComboBox_CreateHandler(pcbox, hwnd);

    case WM_ERASEBKGND:

        //
        // Just return 1L so that the background isn't erased
        //
        return 1L;

    case WM_GETFONT:
        return (LRESULT)pcbox->hFont;

    case WM_PRINT:
        if (!DefWindowProc(hwnd, uMsg, wParam, lParam))
            return FALSE;

        if ( (lParam & PRF_OWNED) && 
             (pcbox->CBoxStyle & SDROPPABLE) &&
             IsWindowVisible(pcbox->hwndList) ) 
        {
            INT iDC = SaveDC((HDC) wParam);

            GetWindowRect(hwnd, &rcCombo);
            GetWindowRect(pcbox->hwndList, &rcList);

            OffsetWindowOrgEx((HDC) wParam, 0, rcCombo.top - rcList.top, NULL);

            lParam &= ~PRF_CHECKVISIBLE;
            SendMessage(pcbox->hwndList, WM_PRINT, wParam, lParam);
            RestoreDC((HDC) wParam, iDC);
        }

        return TRUE;

    case WM_PRINTCLIENT:
        ComboBox_Paint(pcbox, (HDC) wParam);
        break;

    case WM_PAINT: 
    {
        HDC hdc;
        PAINTSTRUCT ps;

        //
        // wParam - perhaps a hdc
        //
        hdc = (wParam) ? (HDC) wParam : BeginPaint(hwnd, &ps);

        if (IsComboVisible(pcbox))
        {
            ComboBox_Paint(pcbox, hdc);
        }

        if (!wParam)
        {
            EndPaint(hwnd, &ps);
        }

        break;
    }

    case WM_GETDLGCODE:
    //
    // wParam - not used
    // lParam - not used
    //
    {
        LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;

        //
        // If the listbox is dropped and the ENTER key is pressed,
        // we want this message so we can close up the listbox
        //
        if ((lParam != 0) &&
            (((LPMSG)lParam)->message == WM_KEYDOWN) &&
            pcbox->fLBoxVisible &&
            ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)))
        {
            code |= DLGC_WANTMESSAGE;
        }

        return code;
    }

    case WM_SETFONT:
        ComboBox_SetFontHandler(pcbox, (HANDLE)wParam, LOWORD(lParam));
        break;

    case WM_SYSKEYDOWN:
        //
        // Check if the alt key is down
        //
        if (lParam & 0x20000000L)
        {
            //
            // Handle Combobox support.  We want alt up or down arrow to behave
            //  like F4 key which completes the combo box selection
            //
            if (lParam & 0x1000000) 
            {
                //
                // This is an extended key such as the arrow keys not on the
                // numeric keypad so just drop the combobox.
                //
                if (wParam == VK_DOWN || wParam == VK_UP)
                {
                    goto DropCombo;
                }

                goto CallDWP;
            }

            if (GetKeyState(VK_NUMLOCK) & 0x1) 
            {
                //
                // If numlock down, just send all system keys to dwp
                //
                goto CallDWP;
            } 
            else 
            {
                //
                // We just want to ignore keys on the number pad...
                //
                if (!(wParam == VK_DOWN || wParam == VK_UP))
                {
                    goto CallDWP;
                }
            }
DropCombo:
            if (!pcbox->fLBoxVisible) 
            {
                //
                // If the listbox isn't visible, just show it
                //
                ComboBox_ShowListBoxWindow(pcbox, TRUE);
            } 
            else 
            {
                //
                // Ok, the listbox is visible.  So hide the listbox window.
                //
                if (!ComboBox_HideListBoxWindow(pcbox, TRUE, TRUE))
                {
                    return 0L;
                }
            }
        }
        goto CallDWP;
        break;

    case WM_KEYDOWN:
        //
        // If the listbox is dropped and the ENTER key is pressed,
        // close up the listbox successfully.  If ESCAPE is pressed,
        // close it up like cancel.
        //
        if (pcbox->fLBoxVisible) 
        {
            if ((wParam == VK_RETURN) || (wParam == VK_ESCAPE)) 
            {
                ComboBox_HideListBoxWindow(pcbox, TRUE, (wParam != VK_ESCAPE));
                break;
            }
        }

        //
        // FALL THROUGH
        //

    case WM_CHAR:
        if (g_fDBCSEnabled && IsDBCSLeadByte((BYTE)wParam)) 
        {
            return ComboBox_DBCharHandler(pcbox, hwnd, uMsg, wParam, lParam);
        }

        if (pcbox->fNoEdit) 
        {
            goto CallListSendMessage;
        }
        else
        {
            goto CallEditSendMessage;
        }
        break;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:

        pcbox->fButtonHotTracked = FALSE;
        //
        // Set the focus to the combo box if we get a mouse click on it.
        //
        if (!pcbox->fFocus) 
        {
            SetFocus(hwnd);
            if (!pcbox->fFocus) 
            {
                //
                // Don't do anything if we still don't have the focus.
                //
                break;
            }
        }

        //
        // If user clicked in button rect and we are a combobox with edit, then
        // drop the listbox.  (The button rect is 0 if there is no button so the
        // ptinrect will return false.) If a drop down list (no edit), clicking
        // anywhere on the face causes the list to drop.
        //

        POINTSTOPOINT(pt, lParam);
        if ((pcbox->CBoxStyle == SDROPDOWN &&
                PtInRect(&pcbox->buttonrc, pt)) ||
                pcbox->CBoxStyle == SDROPDOWNLIST) 
        {
            //
            // Set the fMouseDown flag so that we can handle clicking on
            // the popdown button and dragging into the listbox (when it just
            // dropped down) to make a selection.
            //
            pcbox->fButtonPressed = TRUE;
            if (pcbox->fLBoxVisible) 
            {
                if (pcbox->fMouseDown) 
                {
                    pcbox->fMouseDown = FALSE;
                    ReleaseCapture();
                }
                ComboBox_PressButton(pcbox, FALSE);

                if (!ComboBox_HideListBoxWindow(pcbox, TRUE, TRUE))
                {
                    return 0L;
                }
            } 
            else 
            {
                ComboBox_ShowListBoxWindow(pcbox, FALSE);

                // Setting and resetting this flag must always be followed
                // imediately by SetCapture or ReleaseCapture
                //
                pcbox->fMouseDown = TRUE;
                SetCapture(hwnd);
                NotifyWinEvent(EVENT_OBJECT_STATECHANGE, hwnd, OBJID_CLIENT, INDEX_COMBOBOX_BUTTON);
            }
        }
        break;

    case WM_MOUSEWHEEL:
        //
        // Handle only scrolling.
        //
        if (wParam & (MK_CONTROL | MK_SHIFT))
        {
            goto CallDWP;
        }

        //
        // If the listbox is visible, send it the message to scroll.
        //
        if (pcbox->fLBoxVisible)
        {
            goto CallListSendMessage;
        }

        //
        // If we're in extended UI mode or the edit control isn't yet created,
        // bail.
        //
        if (pcbox->fExtendedUI || pcbox->hwndEdit == NULL)
        {
            return TRUE;
        }

        //
        // Emulate arrow up/down messages to the edit control.
        //
        i = abs(((short)HIWORD(wParam))/WHEEL_DELTA);
        wParam = ((short)HIWORD(wParam) > 0) ? VK_UP : VK_DOWN;

        while (i-- > 0) 
        {
            SendMessage(pcbox->hwndEdit, WM_KEYDOWN, wParam, 0);
        }

        return TRUE;

    case WM_CAPTURECHANGED:
        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
        {
            return 0;
        }

        if ((pcbox->fMouseDown)) 
        {
            pcbox->fMouseDown = FALSE;
            ComboBox_PressButton(pcbox, FALSE);

            //
            // Pop combo listbox back up, canceling.
            //
            if (pcbox->fLBoxVisible)
            {
                ComboBox_HideListBoxWindow(pcbox, TRUE, FALSE);
            }
        }
        break;

    case WM_LBUTTONUP:
        ComboBox_PressButton(pcbox, FALSE);

        //
        // Clear this flag so that mouse moves aren't sent to the listbox
        //
        if (pcbox->fMouseDown || ((pcbox->CBoxStyle & SDROPPABLE) && pcbox->fLBoxVisible))  
        {
            if (pcbox->fMouseDown)
            {
                pcbox->fMouseDown = FALSE;

                if (pcbox->CBoxStyle == SDROPDOWN) 
                {
                    //
                    // If an item in the listbox matches the text in the edit
                    // control, scroll it to the top of the listbox. Select the
                    // item only if the mouse button isn't down otherwise we
                    // will select the item when the mouse button goes up.
                    //
                    ComboBox_UpdateListBoxWindow(pcbox, TRUE);
                    ComboBox_CompleteEditWindow(pcbox);
                }

                ReleaseCapture();
            }

            //
            // Now, we want listbox to track mouse moves while mouse up
            // until mouse down, and select items as though they were
            // clicked on.
            //
            if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT)) 
            {
                SendMessage(pcbox->hwndList, LBCB_STARTTRACK, FALSE, 0);
            }
        }

        if (pcbox->hTheme)
        {
            POINTSTOPOINT(pt, lParam);
            ComboBox_HotTrack(pcbox, pt);
        }
        
        break;

    case WM_MOUSELEAVE:
        pcbox->fButtonHotTracked = FALSE;
        InvalidateRect(hwnd, NULL, TRUE);
        break;

    case WM_MOUSEMOVE:
        if (pcbox->fMouseDown) 
        {
            POINTSTOPOINT(pt, lParam);

            ClientToScreen(hwnd, &pt);
            GetWindowRect(pcbox->hwndList, &rcList);
            if (PtInRect(&rcList, pt)) 
            {
                //
                // This handles dropdown comboboxes/listboxes so that clicking
                // on the dropdown button and dragging into the listbox window
                // will let the user make a listbox selection.
                //
                pcbox->fMouseDown = FALSE;
                ReleaseCapture();

                if (pcbox->CBoxStyle & SEDITABLE) 
                {
                    // If an item in the listbox matches the text in the edit
                    // control, scroll it to the top of the listbox.  Select the
                    // item only if the mouse button isn't down otherwise we
                    // will select the item when the mouse button goes up.

                    //
                    // We need to select the item which matches the editcontrol
                    // so that if the user drags out of the listbox, we don't
                    // cancel back to his origonal selection
                    //
                    ComboBox_UpdateListBoxWindow(pcbox, TRUE);
                }

                //
                // Convert point to listbox coordinates and send a buttondown
                // message to the listbox window.
                //
                ScreenToClient(pcbox->hwndList, &pt);
                lParam = POINTTOPOINTS(pt);
                uMsg = WM_LBUTTONDOWN;

                goto CallListSendMessage;
            }
        }

        if (pcbox->hTheme)
        {
            POINTSTOPOINT(pt, lParam);
            ComboBox_HotTrack(pcbox, pt);
        }

        break;

    case WM_NCDESTROY:
    case WM_FINALDESTROY:
        ComboBox_NcDestroyHandler(hwnd, pcbox);

        break;

    case WM_SETFOCUS:
        if (pcbox->fNoEdit) 
        {
            //
            // There is no editcontrol so set the focus to the combo box itself.
            //
            ComboBox_GetFocusHandler(pcbox);
        } 
        else if (pcbox->hwndEdit) 
        {
            //
            // Set the focus to the edit control window if there is one
            //
            SetFocus(pcbox->hwndEdit);
        }
        break;

    case WM_KILLFOCUS:

        //
        // wParam has the new focus hwnd
        //
        if ((wParam == 0) || !IsChild(hwnd, (HWND)wParam)) 
        {
            //
            // We only give up the focus if the new window getting the focus
            // doesn't belong to the combo box.
            //
            ComboBox_KillFocusHandler(pcbox);
        }

        if ( IsWindow(hwnd) )
        {
            PLBIV plb = ListBox_GetPtr(pcbox->hwndList);

            if ((plb != NULL) && (plb != (PLBIV)-1)) 
            {
                plb->iTypeSearch = 0;
                if (plb->pszTypeSearch) 
                {
                    UserLocalFree(plb->pszTypeSearch);
                    plb->pszTypeSearch = NULL;
                }
            }
        }
        break;

    case WM_SETREDRAW:

        //
        // wParam - specifies state of the redraw flag.  nonzero = redraw
        // lParam - not used
        //

        //
        // effects: Sets the state of the redraw flag for this combo box
        // and its children.
        //
        pcbox->fNoRedraw = (UINT)!((BOOL)wParam);

        //
        // Must check pcbox->spwnEdit in case we get this message before
        // WM_CREATE - PCBOX won't be initialized yet. (Eudora does this)
        //
        if (!pcbox->fNoEdit && pcbox->hwndEdit) 
        {
            SendMessage(pcbox->hwndEdit, uMsg, wParam, lParam);
        }

        goto CallListSendMessage;
        break;

    case WM_ENABLE:

        //
        // Invalidate the rect to cause it to be drawn in grey for its
        // disabled view or ungreyed for non-disabled view.
        //
        InvalidateRect(hwnd, NULL, FALSE);
        if ((pcbox->CBoxStyle & SEDITABLE) && pcbox->hwndEdit) 
        {
            //
            // Enable/disable the edit control window
            //
            EnableWindow(pcbox->hwndEdit, !TESTFLAG(GET_STYLE(pcbox), WS_DISABLED));
        }

        //
        // Enable/disable the listbox window
        //
        UserAssert(pcbox->hwndList);
        EnableWindow(pcbox->hwndList, !TESTFLAG(GET_STYLE(pcbox), WS_DISABLED));
      break;

    case WM_SIZE:

        //
        // wParam - defines the type of resizing fullscreen, sizeiconic,
        //          sizenormal etc.
        // lParam - new width in LOWORD, new height in HIGHUINT of client area
        //
        UserAssert(pcbox->hwndList);
        if (LOWORD(lParam) == 0 || HIWORD(lParam) == 0) 
        {
            //
            // If being sized to a zero width or to a zero height or we aren't
            // fully initialized, just return.
            //
            return 0;
        }

        //
        // OPTIMIZATIONS -- first check if old and new widths are the same
        //
        GetWindowRect(hwnd, &rcWindow);
        if (pcbox->cxCombo == rcWindow.right - rcWindow.left) 
        {
            int iNewHeight = rcWindow.bottom - rcWindow.top;

            //
            // now check if new height is the dropped down height
            //
            if (pcbox->fLBoxVisible) 
            {
                //
                // Check if new height is the full size height
                //
                if (pcbox->cyDrop + pcbox->cyCombo == iNewHeight)
                {
                    return 0;
                }
            } 
            else 
            {
                //
                // Check if new height is the closed up height
                //
                if (pcbox->cyCombo == iNewHeight)
                {
                    return 0;
                }
            }
        }

        ComboBox_SizeHandler(pcbox);

        break;

    case WM_WINDOWPOSCHANGING:
        if (lParam)
        {
            ((LPWINDOWPOS)lParam)->flags |= SWP_NOCOPYBITS;
        }

        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        break;

    case CB_GETDROPPEDSTATE:

        //
        // returns 1 if combo is dropped down else 0
        // wParam - not used
        // lParam - not used
        //
        return pcbox->fLBoxVisible;

    case CB_GETDROPPEDCONTROLRECT:

        //
        // wParam - not used
        // lParam - lpRect which will get the dropped down window rect in
        //          screen coordinates.
        //
        if ( lParam )
        {
            GetWindowRect(hwnd, &rcWindow);
            ((LPRECT)lParam)->left      = rcWindow.left;
            ((LPRECT)lParam)->top       = rcWindow.top;
            ((LPRECT)lParam)->right     = rcWindow.left + max(pcbox->cxDrop, pcbox->cxCombo);
            ((LPRECT)lParam)->bottom    = rcWindow.top + pcbox->cyCombo + pcbox->cyDrop;
        }
        else
        {
            lReturn = 0;
        }

        break;

    case CB_SETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE) 
        {
            if (wParam) 
            {
                wParam = max(wParam, (UINT)pcbox->cxCombo);

                if (wParam != (UINT) pcbox->cxDrop)
                {
                    pcbox->cxDrop = (int)wParam;
                    ComboBox_Position(pcbox);
                }
            }
        }
        //
        // fall thru
        //

    case CB_GETDROPPEDWIDTH:
        if (pcbox->CBoxStyle & SDROPPABLE)
        {
            return (LRESULT)max(pcbox->cxDrop, pcbox->cxCombo);
        }
        else
        {
            return CB_ERR;
        }

        break;

    case CB_DIR:
        //
        // wParam - Dos attribute value.
        // lParam - Points to a file specification string
        //
        return lParam ? CBDir(pcbox, LOWORD(wParam), (LPWSTR)lParam) : CB_ERR;

    case CB_SETEXTENDEDUI:

        //
        // wParam - specifies state to set extendui flag to.
        // Currently only 1 is allowed.  Return CB_ERR (-1) if
        // failure else 0 if success.
        //
        if (pcbox->CBoxStyle & SDROPPABLE) 
        {
            if (!wParam) 
            {
                pcbox->fExtendedUI = 0;
                return 0;
            }

            if (wParam == 1) 
            {
                pcbox->fExtendedUI = 1;
                return 0;
            }

            TraceMsg(TF_STANDARD,
                    "UxCombobox: Invalid parameter \"wParam\" (%ld) to ComboBoxWndProcWorker",
                    wParam);

        } 
        else 
        {
            TraceMsg(TF_STANDARD,
                    "UxCombobox: Invalid message (%ld) sent to ComboBoxWndProcWorker",
                    uMsg);
        }

        return CB_ERR;

    case CB_GETEXTENDEDUI:
        if (pcbox->CBoxStyle & SDROPPABLE) 
        {
            if (pcbox->fExtendedUI)
            {
                return TRUE;
            }
        }

        return FALSE;

    case CB_GETEDITSEL:

        //
        // wParam - not used
        // lParam - not used
        // effects: Gets the selection range for the given edit control.  The
        // starting BYTE-position is in the low order word.  It contains the
        // the BYTE-position of the first nonselected character after the end
        // of the selection in the high order word.  Returns CB_ERR if no
        // editcontrol.
        //
        uMsg = EM_GETSEL;

        goto CallEditSendMessage;
        break;

    case CB_LIMITTEXT:

        //
        // wParam - max number of bytes that can be entered
        // lParam - not used
        // effects: Specifies the maximum number of bytes of text the user may
        // enter.  If maxLength is 0, we may enter MAXINT number of BYTES.
        //
        uMsg = EM_LIMITTEXT;

        goto CallEditSendMessage;
        break;

    case CB_SETEDITSEL:

        //
        // wParam - ichStart
        // lParam - ichEnd
        //
        uMsg = EM_SETSEL;

        wParam = (int)(SHORT)LOWORD(lParam);
        lParam = (int)(SHORT)HIWORD(lParam);

        goto CallEditSendMessage;
        break;

    case CB_ADDSTRING:

        //
        // wParam - not used
        // lParam - Points to null terminated string to be added to listbox
        //
        if (!pcbox->fCase)
        {
            uMsg = LB_ADDSTRING;
        }
        else
        {
            uMsg = (pcbox->fCase & UPPERCASE) ? LB_ADDSTRINGUPPER : LB_ADDSTRINGLOWER;
        }

        goto CallListSendMessage;
        break;

    case CB_DELETESTRING:

        //
        // wParam - index to string to be deleted
        // lParam - not used
        //
        uMsg = LB_DELETESTRING;

        goto CallListSendMessage;
        break;

    case CB_INITSTORAGE:
        //
        // wParamLo - number of items
        // lParam - number of bytes of string space
        //
        uMsg = LB_INITSTORAGE;

        goto CallListSendMessage;

    case CB_SETTOPINDEX:
        //
        // wParamLo - index to make top
        // lParam - not used
        //
        uMsg = LB_SETTOPINDEX;

        goto CallListSendMessage;

    case CB_GETTOPINDEX:
        //
        // wParamLo / lParam - not used
        //
        uMsg = LB_GETTOPINDEX;

        goto CallListSendMessage;

    case CB_GETCOUNT:
        //
        // wParam - not used
        // lParam - not used
        //
        uMsg = LB_GETCOUNT;

        goto CallListSendMessage;
        break;

    case CB_GETCURSEL:
        //
        // wParam - not used
        // lParam - not used
        //
        uMsg = LB_GETCURSEL;

        goto CallListSendMessage;
        break;

    case CB_GETLBTEXT:
        //
        // wParam - index of string to be copied
        // lParam - buffer that is to receive the string
        //
        uMsg = LB_GETTEXT;

        goto CallListSendMessage;
        break;

    case CB_GETLBTEXTLEN:
        //
        // wParam - index to string
        // lParam - now used for cbANSI
        //
        uMsg = LB_GETTEXTLEN;

        goto CallListSendMessage;
        break;

    case CB_INSERTSTRING:
        //
        // wParam - position to receive the string
        // lParam - points to the string
        //
        if (!pcbox->fCase)
        {
            uMsg = LB_INSERTSTRING;
        }
        else
        {
            uMsg = (pcbox->fCase & UPPERCASE) ? LB_INSERTSTRINGUPPER : LB_INSERTSTRINGLOWER;
        }

        goto CallListSendMessage;
        break;

    case CB_RESETCONTENT:
        //
        // wParam - not used
        // lParam - not used
        // If we come here before WM_CREATE has been processed,
        // pcbox->spwndList will be NULL.
        //
        UserAssert(pcbox->hwndList);
        SendMessage(pcbox->hwndList, LB_RESETCONTENT, 0, 0);
        ComboBox_InternalUpdateEditWindow(pcbox, NULL);

        break;

    case CB_GETHORIZONTALEXTENT:
        uMsg = LB_GETHORIZONTALEXTENT;

        goto CallListSendMessage;

    case CB_SETHORIZONTALEXTENT:
        uMsg = LB_SETHORIZONTALEXTENT;

        goto CallListSendMessage;

    case CB_FINDSTRING:
        //
        // wParam - index of starting point for search
        // lParam - points to prefix string
        //
        uMsg = LB_FINDSTRING;

        goto CallListSendMessage;
        break;

    case CB_FINDSTRINGEXACT:
        //
        // wParam - index of starting point for search
        // lParam - points to a exact string
        //
        uMsg = LB_FINDSTRINGEXACT;

        goto CallListSendMessage;
        break;

    case CB_SELECTSTRING:
        //
        // wParam - index of starting point for search
        // lParam - points to prefix string
        //
        UserAssert(pcbox->hwndList);
        lParam = SendMessage(pcbox->hwndList, LB_SELECTSTRING, wParam, lParam);
        ComboBox_InternalUpdateEditWindow(pcbox, NULL);

        return lParam;

    case CB_SETCURSEL:
        //
        // wParam - Contains index to be selected
        // lParam - not used
        // If we come here before WM_CREATE has been processed,
        // pcbox->spwndList will be NULL.
        //
        UserAssert(pcbox->hwndList);

        lParam = SendMessage(pcbox->hwndList, LB_SETCURSEL, wParam, lParam);
        if (lParam != -1) 
        {
            SendMessage(pcbox->hwndList, LB_SETTOPINDEX, wParam, 0);
        }
        ComboBox_InternalUpdateEditWindow(pcbox, NULL);

        return lParam;

    case CB_GETITEMDATA:
        uMsg = LB_GETITEMDATA;

        goto CallListSendMessage;
        break;

    case CB_SETITEMDATA:
        uMsg = LB_SETITEMDATA;

        goto CallListSendMessage;
        break;

    case CB_SETITEMHEIGHT:
        if (wParam == -1) 
        {
            if (HIWORD(lParam) != 0)
            {
                return CB_ERR;
            }

            return ComboBox_SetEditItemHeight(pcbox, LOWORD(lParam));
        }

        uMsg = LB_SETITEMHEIGHT;
        goto CallListSendMessage;

        break;

    case CB_GETITEMHEIGHT:
        if (wParam == -1)
        {
            return pcbox->editrc.bottom - pcbox->editrc.top;
        }

        uMsg = LB_GETITEMHEIGHT;

        goto CallListSendMessage;
        break;

    case CB_SHOWDROPDOWN:
        //
        // wParam - True then drop down the listbox if possible else hide it
        // lParam - not used
        //
        if (wParam && !pcbox->fLBoxVisible) 
        {
            ComboBox_ShowListBoxWindow(pcbox, TRUE);
        } 
        else 
        {
            if (!wParam && pcbox->fLBoxVisible) 
            {
                ComboBox_HideListBoxWindow(pcbox, TRUE, FALSE);
            }
        }

        break;

    case CB_SETLOCALE:
        //
        // wParam - locale id
        // lParam - not used
        //
        uMsg = LB_SETLOCALE;
        goto CallListSendMessage;

        break;

    case CB_GETLOCALE:
        //
        // wParam - not used
        // lParam - not used
        //
        uMsg = LB_GETLOCALE;
        goto CallListSendMessage;
        break;

    case CB_GETCOMBOBOXINFO:
        //
        // wParam - not used
        // lParam - pointer to COMBOBOXINFO struct
        //
        lReturn = ComboBox_GetInfo(pcbox, (PCOMBOBOXINFO)lParam);
        break;

    case CB_SETMINVISIBLE:
        if (wParam > 0)
        {
            PLBIV plb = ListBox_GetPtr(pcbox->hwndList);

            pcbox->iMinVisible = (int)wParam;
            if (plb && !plb->fNoIntegralHeight)
            {
                // forward through to the listbox to let him adjust
                // his size if necessary
                SendMessage(pcbox->hwndList, uMsg, wParam, 0L);
            }

            lReturn = TRUE;
        }
        else
        {
            lReturn = FALSE;
        }

        break;

    case CB_GETMINVISIBLE:

        return pcbox->iMinVisible;

    case WM_MEASUREITEM:
    case WM_DELETEITEM:
    case WM_DRAWITEM:
    case WM_COMPAREITEM:
        return ComboBox_MessageItemHandler(pcbox, uMsg, (LPVOID)lParam);

    case WM_NCCREATE:
        //
        // wParam - Contains a handle to the window being created
        // lParam - Points to the CREATESTRUCT data structure for the window.
        //

        //
        // Allocate the combobox instance stucture
        //
        pcbox = (PCBOX)UserLocalAlloc(HEAP_ZERO_MEMORY, sizeof(CBOX));
        if (pcbox)
        {
            //
            // Success... store the instance pointer.
            //
            TraceMsg(TF_STANDARD, "COMBOBOX: Setting combobox instance pointer.");
            ComboBox_SetPtr(hwnd, pcbox);

            return ComboBox_NcCreateHandler(pcbox, hwnd);
        }
        else
        {
            //
            // Failed... return FALSE.
            //
            // From a WM_NCCREATE msg, this will cause the
            // CreateWindow call to fail.
            //
            TraceMsg(TF_STANDARD, "COMBOBOX: Unable to allocate combobox instance structure.");
            lReturn = FALSE;
        }

        break;

    case WM_PARENTNOTIFY:
        if (LOWORD(wParam) == WM_DESTROY) 
        {
            if ((HWND)lParam == pcbox->hwndEdit) 
            {
                pcbox->CBoxStyle &= ~SEDITABLE;
                pcbox->fNoEdit = TRUE;
                pcbox->hwndEdit = hwnd;
            } 
            else if ((HWND)lParam == pcbox->hwndList) 
            {
                pcbox->CBoxStyle &= ~SDROPPABLE;
                pcbox->hwndList = NULL;
            }
        }
        break;

    case WM_UPDATEUISTATE:
        //
        // Propagate the change to the list control, if any
        //
        UserAssert(pcbox->hwndList);
        SendMessage(pcbox->hwndList, WM_UPDATEUISTATE, wParam, lParam);

        goto CallDWP;

    case WM_GETOBJECT:

        if(lParam == OBJID_QUERYCLASSNAMEIDX)
        {
            lReturn = MSAA_CLASSNAMEIDX_COMBOBOX;
        }
        else
        {
            lReturn = FALSE;
        }

        break;

    case WM_THEMECHANGED:

        if ( pcbox->hTheme )
        {
            CloseThemeData(pcbox->hTheme);
        }

        pcbox->hTheme = OpenThemeData(pcbox->hwnd, L"Combobox");

        ComboBox_Position(pcbox);
        InvalidateRect(pcbox->hwnd, NULL, TRUE);

        lReturn = TRUE;

        break;

    case WM_HELP:
    {
        LPHELPINFO lpHelpInfo;

        //
        // Check if this message is from a child of this combo
        //
        if ((lpHelpInfo = (LPHELPINFO)lParam) != NULL &&
            ((pcbox->hwndEdit && lpHelpInfo->iCtrlId == (SHORT)GetWindowID(pcbox->hwndEdit)) ||
             lpHelpInfo->iCtrlId == (SHORT)GetWindowID(pcbox->hwndList) )) 
        {
            //
            // Make it look like the WM_HELP is coming form this combo.
            // Then DefWindowProcWorker will pass it up to our parent,
            // who can do whatever he wants with it.
            //
            lpHelpInfo->iCtrlId = (SHORT)GetWindowID(hwnd);
            lpHelpInfo->hItemHandle = hwnd;
#if 0   // PORTPORT: GetContextHelpId
            lpHelpInfo->dwContextId = GetContextHelpId(hwnd);
#endif
        }
        //
        // Fall through to DefWindowProc
        //
    }

    default:

        if ( (GetSystemMetrics(SM_PENWINDOWS)) &&
                  (uMsg >= WM_PENWINFIRST && uMsg <= WM_PENWINLAST))
        {
            goto CallEditSendMessage;
        }
        else
        {

CallDWP:
            lReturn = DefWindowProc(hwnd, uMsg, wParam, lParam);
        }
    }

    return lReturn;

//
// The following forward messages off to the child controls.
//
CallEditSendMessage:
    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        lReturn = SendMessage(pcbox->hwndEdit, uMsg, wParam, lParam);
    }
    else 
    {
        TraceMsg(TF_STANDARD, "COMBOBOX: Invalid combobox message %#.4x", uMsg);
        lReturn = CB_ERR;
    }
    return lReturn;

CallListSendMessage:
    UserAssert(pcbox->hwndList);
    lReturn = SendMessage(pcbox->hwndList, uMsg, wParam, lParam);

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\commctrl.c ===
/***************************************************************************
 *  msctls.c
 *
 *      Utils library initialization code
 *
 ***************************************************************************/

#include "ctlspriv.h"
#include <shfusion.h>
HINSTANCE g_hinst = 0;


BOOL g_fCriticalInitialized = FALSE;

CRITICAL_SECTION g_csDll = {{0},0, 0, NULL, NULL, 0 };

ATOM g_aCC32Subclass = 0;
ATOM g_atomThemeScrollBar = 0;

UINT g_uiACP = CP_ACP;

//
// Global DCs used during mirroring an Icon.
//
HDC g_hdc=NULL, g_hdcMask=NULL;

// per process mem to store PlugUI information
LANGID g_PUILangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);
BOOL InitAnimateClass(HINSTANCE hInstance);
BOOL ListView_Init(HINSTANCE hinst);
BOOL TV_Init(HINSTANCE hinst);
BOOL InitComboExClass(HINSTANCE hinst);
BOOL Header_Init(HINSTANCE hinst);
BOOL Tab_Init(HINSTANCE hinst);
int InitIPAddr(HANDLE hInstance);
BOOL InitPager(HINSTANCE hinst);
BOOL InitNativeFontCtl(HINSTANCE hinst);
void UnregisterClasses();
void Mem_Terminate();

#define DECLARE_DELAYED_FUNC(_ret, _fn, _args, _nargs) \
_ret (__stdcall * g_pfn##_fn) _args = NULL; \
_ret __stdcall _fn _args                \
{                                       \
     if (!g_pfn##_fn) {                  \
        return 0; \
     }     \
     return g_pfn##_fn _nargs; \
}
    
#define LOAD_DELAYED_FUNC(_ret, _fn, _args) \
    (*(FARPROC*)&(g_pfn##_fn) = GetProcAddress(hinst, #_fn))


DECLARE_DELAYED_FUNC(BOOL, ImmNotifyIME, (HIMC himc, DWORD dw1, DWORD dw2, DWORD dw3), (himc, dw1, dw2, dw3));
DECLARE_DELAYED_FUNC(HIMC, ImmAssociateContext, (HWND hwnd, HIMC himc), (hwnd, himc));
DECLARE_DELAYED_FUNC(BOOL, ImmReleaseContext, (HWND hwnd, HIMC himc), (hwnd, himc));
DECLARE_DELAYED_FUNC(HIMC, ImmGetContext, (HWND hwnd), (hwnd));
DECLARE_DELAYED_FUNC(LONG, ImmGetCompositionStringA, (HIMC himc, DWORD dw1, LPVOID p1, DWORD dw2), (himc, dw1, p1, dw2) );
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionStringA, (HIMC himc, DWORD dw1, LPCVOID p1, DWORD dw2, LPCVOID p2, DWORD dw3), (himc, dw1, p1, dw2, p2, dw3));
#ifndef UNICODE_WIN9x
DECLARE_DELAYED_FUNC(LONG, ImmGetCompositionStringW, (HIMC himc, DWORD dw1, LPVOID p1, DWORD dw2), (himc, dw1, p1, dw2) );
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionStringW, (HIMC himc, DWORD dw1, LPCVOID p1, DWORD dw2, LPCVOID p2, DWORD dw3), (himc, dw1, p1, dw2, p2, dw3));
#endif
DECLARE_DELAYED_FUNC(BOOL, ImmSetCandidateWindow, (HIMC himc, LPCANDIDATEFORM pcf), (himc, pcf));
DECLARE_DELAYED_FUNC(HIMC, ImmCreateContext, (void), ());
DECLARE_DELAYED_FUNC(BOOL, ImmDestroyContext, (HIMC himc), (himc));
DECLARE_DELAYED_FUNC(BOOL, ImmIsIME, (HKL hKl), (hKl));
DECLARE_DELAYED_FUNC(BOOL, ImmUnlockIMC, (HIMC himc), (himc));
DECLARE_DELAYED_FUNC(LPINPUTCONTEXT, ImmLockIMC, (HIMC himc), (himc));
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionWindow, (HIMC himc, LPCOMPOSITIONFORM lpCompForm), (himc, lpCompForm));
DECLARE_DELAYED_FUNC(BOOL, ImmGetCompositionWindow, (HIMC himc, LPCOMPOSITIONFORM lpCompForm), (himc, lpCompForm));
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionFontW, (HIMC himc, LPLOGFONT lplf), (himc, lplf));
DECLARE_DELAYED_FUNC(LRESULT, ImmEscapeA, (HKL hKl, HIMC himc, UINT uEscape, LPVOID lpData), (hKl, himc, uEscape, lpData));
DECLARE_DELAYED_FUNC(LRESULT, ImmEscapeW, (HKL hKl, HIMC himc, UINT uEscape, LPVOID lpData), (hKl, himc, uEscape, lpData));
DECLARE_DELAYED_FUNC(BOOL, ImmSetOpenStatus, (HIMC himc, BOOL fOpen), (himc, fOpen));
DECLARE_DELAYED_FUNC(BOOL, ImmGetOpenStatus, (HIMC himc), (himc));
DECLARE_DELAYED_FUNC(BOOL, ImmGetConversionStatus, (HIMC himc, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence), (himc, lpfdwConversion, lpfdwSentence));
DECLARE_DELAYED_FUNC(BOOL, ImmSetConversionStatus, (HIMC himc, DWORD fdwConversion, DWORD fdwSentence), (himc, fdwConversion, fdwSentence));
DECLARE_DELAYED_FUNC(DWORD, ImmGetProperty, (HKL hKl, DWORD fdwIndex), (hKl, fdwIndex));
DECLARE_DELAYED_FUNC(BOOL, ImmEnumInputContext, (DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam), (idThread, lpfn, lParam));
DECLARE_DELAYED_FUNC(DWORD, ImmGetGuideLineW, (HIMC himc, DWORD dwIndex, LPTSTR lpBuf, DWORD dwBufLen), (himc, dwIndex, lpBuf, dwBufLen));

    

BOOL g_fDBCSEnabled = FALSE;
BOOL g_fMEEnabled = FALSE;
BOOL g_fDBCSInputEnabled = FALSE;
BOOL g_fIMMEnabled = FALSE;

#if defined(FE_IME) || !defined(WINNT)
void InitIme()
{
    g_fMEEnabled = GetSystemMetrics(SM_MIDEASTENABLED);
    
    g_fDBCSEnabled = g_fDBCSInputEnabled = GetSystemMetrics(SM_DBCSENABLED);
    g_fIMMEnabled = GetSystemMetrics(SM_IMMENABLED);

    if (!g_fDBCSInputEnabled)
    {
        g_fDBCSInputEnabled = g_fIMMEnabled;
    }
    
    // We load imm32.dll per process, but initialize proc pointers just once.
    // this is to solve two different problems.
    // 1) Debugging process on win95 would get our shared table trashed
    //    if we rewrite proc address each time we get loaded.
    // 2) Some lotus application rely upon us to load imm32. They do not
    //    load/link to imm yet they use imm(!)
    //
    if (g_fDBCSInputEnabled || g_fIMMEnabled) 
    {
        HANDLE hinst = LoadLibrary(TEXT("imm32.dll"));
        if (! g_pfnImmSetCandidateWindow && 
           (! hinst || 
            ! LOAD_DELAYED_FUNC(HIMC, ImmCreateContext, (void)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmDestroyContext, (HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmIsIME, (HKL)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmGetOpenStatus, (HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetOpenStatus, (HIMC, BOOL)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmGetConversionStatus, (HIMC, LPDWORD, LPDWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetConversionStatus, (HIMC, DWORD, DWORD)) ||
            ! LOAD_DELAYED_FUNC(DWORD, ImmGetProperty, (HKL, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmUnlockIMC, (HIMC)) ||
            ! LOAD_DELAYED_FUNC(LPINPUTCONTEXT, ImmLockIMC, (HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionWindow, (HIMC, LPCOMPOSITIONFORM)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmGetCompositionWindow, (HIMC, LPCOMPOSITIONFORM)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionFontW, (HIMC, LPLOGFONT)) ||
            ! LOAD_DELAYED_FUNC(LRESULT, ImmEscapeA, (HKL, HIMC, UINT, LPVOID)) ||
            ! LOAD_DELAYED_FUNC(LRESULT, ImmEscapeW, (HKL, HIMC, UINT, LPVOID)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmNotifyIME, (HIMC, DWORD, DWORD, DWORD)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmAssociateContext, (HWND, HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmReleaseContext, (HWND, HIMC)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmGetContext, (HWND)) ||
            ! LOAD_DELAYED_FUNC(LONG, ImmGetCompositionStringA, (HIMC, DWORD, LPVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionStringA, (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD)) ||
#ifndef UNICODE_WIN9x
            ! LOAD_DELAYED_FUNC(LONG, ImmGetCompositionStringW, (HIMC, DWORD, LPVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionStringW, (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD)) ||
#endif
            ! LOAD_DELAYED_FUNC(BOOL, ImmEnumInputContext, (DWORD, IMCENUMPROC, LPARAM)) ||
            ! LOAD_DELAYED_FUNC(DWORD, ImmGetGuideLineW, (HIMC, DWORD, LPTSTR, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCandidateWindow, (HIMC, LPCANDIDATEFORM)))) {

            // if we were unable to load then bail on using IME.
            g_fDBCSEnabled = FALSE;
            g_fDBCSInputEnabled = FALSE;

        }
    }
}
#else
#define InitIme() 0
#endif

#ifdef DEBUG

// Verify that the localizers didn't accidentally change
// DLG_PROPSHEET from a DIALOG to a DIALOGEX.  _RealPropertySheet
// relies on this (as well as any apps which parse the dialog template
// in their PSCB_PRECREATE handler).

BOOL IsSimpleDialog(LPCTSTR ptszDialog)
{
    HRSRC hrsrc;
    LPDLGTEMPLATE pdlg;
    BOOL fSimple = FALSE;

    if ( (hrsrc = FindResource(HINST_THISDLL, ptszDialog, RT_DIALOG)) &&
         (pdlg = LoadResource(HINST_THISDLL, hrsrc)))
    {
        fSimple = HIWORD(pdlg->style) != 0xFFFF;
    }
    return fSimple;
}

//
//  For sublanguages to work, every language in our resources must contain
//  a SUBLANG_NEUTRAL variation so that (for example) Austria gets
//  German dialog boxes instead of English ones.
//
//  The DPA is really a DSA of WORDs, but DPA's are easier to deal with.
//  We just collect all the languages into the DPA, and study them afterwards.
//
BOOL CALLBACK CheckLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    HDPA hdpa = (HDPA)lparam;
    DPA_AppendPtr(hdpa, (LPVOID)(UINT_PTR)wIdLang);
    return TRUE;
}

void CheckResourceLanguages(void)
{
    HDPA hdpa = DPA_Create(8);
    if (hdpa) {
        int i, j;
        EnumResourceLanguages(HINST_THISDLL, RT_DIALOG,
                              MAKEINTRESOURCE(DLG_PROPSHEET), CheckLangProc,
                              (LPARAM)hdpa);

        // Walk the language list.  For each language we find, make sure
        // there is a SUBLANG_NEUTRAL version of it somewhere else
        // in the list.  We use an O(n^2) algorithm because this is debug
        // only code and happens only at DLL load.

        for (i = 0; i < DPA_GetPtrCount(hdpa); i++) {
            UINT_PTR uLangI = (UINT_PTR)DPA_FastGetPtr(hdpa, i);
            BOOL fFound = FALSE;

            //
            //  It is okay to have English (American) with no
            //  English (Neutral) because Kernel32 uses English (American)
            //  as its fallback, so we fall back to the correct language
            //  after all.
            //
            if (uLangI == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
                continue;

            //
            //  If this language is already the Neutral one, then there's
            //  no point looking for it - here it is!
            //
            if (SUBLANGID(uLangI) == SUBLANG_NEUTRAL)
                continue;

            //
            //  Otherwise, this language is a dialect.  See if there is
            //  a Neutral version elsewhere in the table.
            //
            for (j = 0; j < DPA_GetPtrCount(hdpa); j++) {
                UINT_PTR uLangJ = (UINT_PTR)DPA_FastGetPtr(hdpa, j);
                if (PRIMARYLANGID(uLangI) == PRIMARYLANGID(uLangJ) &&
                    SUBLANGID(uLangJ) == SUBLANG_NEUTRAL) {
                    fFound = TRUE; break;
                }
            }

            //
            //  If this assertion fires, it means that the localization team
            //  added support for a new language but chose to specify the
            //  language as a dialect instead of the Neutral version.  E.g.,
            //  specifying Romanian (Romanian) instead of Romanian (Neutral).
            //  This means that people who live in Moldavia will see English
            //  strings, even though Romanian (Romanian) would almost
            //  certainly have been acceptable.
            //
            //  If you want to support multiple dialects of a language
            //  (e.g., Chinese), you should nominate one of the dialects
            //  as the Neutral one.  For example, we currently support
            //  both Chinese (PRC) and Chinese (Taiwan), but the Taiwanese
            //  version is marked as Chinese (Neutral), so people who live in
            //  Singapore get Chinese instead of English.  Sure, it's
            //  Taiwanese Chinese, but at least it's Chinese.
            //
            AssertMsg(fFound, TEXT("Localization bug: No SUBLANG_NEUTRAL for language %04x"), uLangI);
        }

        DPA_Destroy(hdpa);
    }
}

#endif

int _ProcessAttach(HANDLE hInstance)
{
    INITCOMMONCONTROLSEX icce;

    g_hinst = hInstance;

    g_uiACP = GetACP();
    g_atomThemeScrollBar = GlobalAddAtom(TEXT("ThemePropScrollBarCtl"));

    SHFusionInitialize(NULL);

#ifdef DEBUG
    CcshellGetDebugFlags();
#endif

    InitializeCriticalSection(&g_csDll);
    g_fCriticalInitialized = TRUE;

    InitGlobalMetrics(0);
    InitGlobalColors();
    
    InitIme();

    //
    // Initialize special language pack callouts for
    // the edit controls. Once per process.
    //
    InitEditLpk();

    // only do this for GetProcessVersion apps <= 0x40000
    // Newer apps MUST use InitCommonControlsEx.
    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_ALL_CLASSES;


    InitCommonControlsEx(&icce);

    return TRUE;
}



void _ProcessDetach(HANDLE hInstance)
{
    //
    // Cleanup cached DCs. No need to synchronize the following section of
    // code since it is only called in DLL_PROCESS_DETACH which is 
    // synchronized by the OS Loader.
    //
    if (g_hdc)
        DeleteDC(g_hdc);

    if (g_hdcMask)
        DeleteDC(g_hdcMask);

    g_hdc = g_hdcMask = NULL;

    UnregisterClasses();
    g_fCriticalInitialized = FALSE;
    DeleteCriticalSection(&g_csDll);
    SHFusionUninitialize();
}


STDAPI_(BOOL) LibMain(HANDLE hDll, DWORD dwReason, LPVOID pv)
{
    switch(dwReason) 
    {
    case DLL_PROCESS_ATTACH:
#ifdef DEBUG
        GdiSetBatchLimit(1);
#else
        DisableThreadLibraryCalls(hDll);
#endif
        return _ProcessAttach(hDll);

    case DLL_PROCESS_DETACH:
        _ProcessDetach(hDll);
        break;

    case DLL_THREAD_ATTACH:
#ifdef DEBUG
        GdiSetBatchLimit(1);
#endif
    case DLL_THREAD_DETACH:
    default:
        break;

    } // end switch()

    return TRUE;

} // end DllEntryPoint()


/* Stub function to call if all you want to do is make sure this DLL is loaded
 */
void WINAPI InitCommonControls(void)
{
}

STDAPI_(void) FixupSubclassRecordsAfterLogoff();

BOOL InitForWinlogon(HINSTANCE hInstance)
{
    //  Some people like to use comctl32 from inside winlogon, and
    //  for C2 security reasons, all global atoms are nuked from the
    //  window station when you log off.
    //
    //  So the rule is that all winlogon clients of comctl32 must
    //  call InitCommonControlsEx(ICC_WINLOGON_REINIT) immediately
    //  before doing any common control things (creating windows
    //  or property sheets/wizards) from winlogon.

    FixupSubclassRecordsAfterLogoff();

    InitGlobalMetrics(0);
    InitGlobalColors();

    return TRUE;
}

/* InitCommonControlsEx creates the classes. Only those classes requested are created!
** The process attach figures out if it's an old app and supplies ICC_WIN95_CLASSES.
*/
typedef BOOL (PASCAL *PFNINIT)(HINSTANCE);
typedef struct 
{
    PFNINIT pfnInit;
    LPCTSTR pszName;
    DWORD dw;
} INITCOMMONCONTROLSINFO;

#define MAKEICC(pfnInit, pszClass, dwFlags) { pfnInit, pszClass, dwFlags }

const INITCOMMONCONTROLSINFO icc[] =
{
     // Init function      Class name         Requested class sets which use this class
MAKEICC(InitToolbarClass,  TOOLBARCLASSNAME,  ICC_BAR_CLASSES),
MAKEICC(InitReBarClass,    REBARCLASSNAME,    ICC_COOL_CLASSES),
MAKEICC(InitToolTipsClass, TOOLTIPS_CLASS,    ICC_TREEVIEW_CLASSES|ICC_BAR_CLASSES|ICC_TAB_CLASSES),
MAKEICC(InitStatusClass,   STATUSCLASSNAME,   ICC_BAR_CLASSES),
MAKEICC(ListView_Init,     WC_LISTVIEW,       ICC_LISTVIEW_CLASSES),
MAKEICC(Header_Init,       WC_HEADER,         ICC_LISTVIEW_CLASSES),
MAKEICC(Tab_Init,          WC_TABCONTROL,     ICC_TAB_CLASSES),
MAKEICC(TV_Init,           WC_TREEVIEW,       ICC_TREEVIEW_CLASSES),
MAKEICC(InitTrackBar,      TRACKBAR_CLASS,    ICC_BAR_CLASSES),
MAKEICC(InitUpDownClass,   UPDOWN_CLASS,      ICC_UPDOWN_CLASS),
MAKEICC(InitProgressClass, PROGRESS_CLASS,    ICC_PROGRESS_CLASS),
MAKEICC(InitHotKeyClass,   HOTKEY_CLASS,      ICC_HOTKEY_CLASS),
MAKEICC(InitAnimateClass,  ANIMATE_CLASS,     ICC_ANIMATE_CLASS),
MAKEICC(InitDateClasses,   DATETIMEPICK_CLASS,ICC_DATE_CLASSES),
MAKEICC(InitComboExClass,  WC_COMBOBOXEX,     ICC_USEREX_CLASSES),
MAKEICC(InitIPAddr,        WC_IPADDRESS,      ICC_INTERNET_CLASSES),
MAKEICC(InitPager,         WC_PAGESCROLLER,   ICC_PAGESCROLLER_CLASS),
MAKEICC(InitNativeFontCtl, WC_NATIVEFONTCTL,  ICC_NATIVEFNTCTL_CLASS),
MAKEICC(InitButtonClass,   WC_BUTTON,         ICC_STANDARD_CLASSES),
MAKEICC(InitStaticClass,   WC_STATIC,         ICC_STANDARD_CLASSES),
MAKEICC(InitEditClass,     WC_EDIT,           ICC_STANDARD_CLASSES),
MAKEICC(InitListBoxClass,  WC_LISTBOX,        ICC_STANDARD_CLASSES),
MAKEICC(InitComboboxClass, WC_COMBOBOX,       ICC_STANDARD_CLASSES),
MAKEICC(InitComboLBoxClass,WC_COMBOLBOX,      ICC_STANDARD_CLASSES),
MAKEICC(InitScrollBarClass,WC_SCROLLBAR,      ICC_STANDARD_CLASSES),
MAKEICC(InitLinkClass,     WC_LINK,           ICC_LINK_CLASS),
MAKEICC(InitReaderModeClass,WC_READERMODE,    ICC_STANDARD_CLASSES),


//
//  These aren't really classes.  They're just goofy flags.
//
MAKEICC(InitForWinlogon,   NULL,              ICC_WINLOGON_REINIT),
};

BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX picce)
{
    int i;

    if (!picce ||
        (picce->dwSize != sizeof(INITCOMMONCONTROLSEX)) ||
        (picce->dwICC & ~ICC_ALL_VALID))
    {
        DebugMsg(DM_WARNING, TEXT("comctl32 - picce is bad"));
        return(FALSE);
    }

    for (i=0 ; i < ARRAYSIZE(icc) ; i++)
        if (picce->dwICC & icc[i].dw)
            if (!icc[i].pfnInit(HINST_THISDLL))
                return(FALSE);

    return(TRUE);
}
//
// InitMUILanguage / GetMUILanguage implementation
//
// we have a per process PUI language setting. For NT it's just a global
// initialized with LANG_NEUTRAL and SUBLANG_NEUTRAL
// For Win95 it's DPA slot for the current process.
// InitMUILanguage sets callers preferred language id for common control
// GetMUILangauge returns what the caller has set to us 
// 
LANGID PUIGetLangId(void)
{
    return g_PUILangId;
}

void WINAPI
InitMUILanguage(LANGID wLang)
{
    ENTERCRITICAL;
    g_PUILangId = wLang;
    LEAVECRITICAL;
}

LANGID WINAPI
GetMUILanguage(void)
{
    return g_PUILangId;
}
// end MUI functions

//
//  Unlike Win9x, WinNT does not automatically unregister classes
//  when a DLL unloads.  We have to do it manually.  Leaving the
//  class lying around means that if an app loads our DLL, then
//  unloads it, then reloads it at a different address, all our
//  leftover RegisterClass()es will point the WndProc at the wrong
//  place and we fault at the next CreateWindow().
//
//  This is not purely theoretical - NT4/FE hit this bug.
//
void UnregisterClasses()
{
    WNDCLASS wc;
    int i;

    for (i=0 ; i < ARRAYSIZE(icc) ; i++)
    {
        if (icc[i].pszName &&
            GetClassInfo(HINST_THISDLL, icc[i].pszName, &wc))
        {
            UnregisterClass(icc[i].pszName, HINST_THISDLL);
        }
    }
}

#if defined(DEBUG)
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    ASSERTNONCRITICAL;
    return SendMessageW(hWnd, Msg, wParam, lParam);
}
#endif // defined(DEBUG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\comboini.c ===
#include "ctlspriv.h"
#pragma hdrstop
#include "usrctl32.h"
#include "combo.h"


//---------------------------------------------------------------------------//
//
#define RECALC_CYDROP   -1

//---------------------------------------------------------------------------//
VOID ComboBox_CalcControlRects(PCBOX pcbox, LPRECT lprcList)
{
    CONST TCHAR szOneChar[] = TEXT("0");

    HDC hdc;
    HANDLE hOldFont = NULL;
    int dyEdit, dxEdit;
    MEASUREITEMSTRUCT mis;
    SIZE size;
    HWND hwnd = pcbox->hwnd;

    //
    // Determine height of the edit control.  We can use this info to center
    // the button with recpect to the edit/static text window.  For example
    // this will be useful if owner draw and this window is tall.
    //
    hdc = GetDC(hwnd);
    if (pcbox->hFont) 
    {
        hOldFont = SelectObject(hdc, pcbox->hFont);
    }

    //
    // Add on CYEDGE just for some extra space in the edit field/static item.
    // It's really only for static text items, but we want static & editable
    // controls to be the same height.
    //
    GetTextExtentPoint(hdc, szOneChar, 1, &size);
    dyEdit = size.cy + GetSystemMetrics(SM_CYEDGE);

    if (hOldFont) 
    {
        SelectObject(hdc, hOldFont);
    }

    ReleaseDC(hwnd, hdc);

    if (pcbox->OwnerDraw) 
    {
        //
        // This is an ownerdraw combo.  Have the owner tell us how tall this
        // item is.
        //
        int iOwnerDrawHeight;

        iOwnerDrawHeight = pcbox->editrc.bottom - pcbox->editrc.top;
        if (iOwnerDrawHeight)
        {
            dyEdit = iOwnerDrawHeight;
        } 
        else 
        {
            //
            // No height has been defined yet for the static text window.  Send
            // a measure item message to the parent
            //
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = GetWindowID(pcbox->hwnd);
            mis.itemID = (UINT)-1;
            mis.itemHeight = dyEdit;
            mis.itemData = 0;

            SendMessage(pcbox->hwndParent, WM_MEASUREITEM, mis.CtlID, (LPARAM)&mis);

            dyEdit = mis.itemHeight;
        }
    }

    //
    // Set the initial width to be the combo box rect.  Later we will shorten it
    // if there is a dropdown button.
    //
    pcbox->cyCombo = 2*GetSystemMetrics(SM_CYFIXEDFRAME) + dyEdit;
    dxEdit = pcbox->cxCombo - (2 * GetSystemMetrics(SM_CXFIXEDFRAME));

    if (pcbox->cyDrop == RECALC_CYDROP)
    {
        RECT rcWindow;

        //
        // recompute the max height of the dropdown listbox -- full window
        // size MINUS edit/static height
        //
        GetWindowRect(pcbox->hwnd, &rcWindow);
        pcbox->cyDrop = max((rcWindow.bottom - rcWindow.top) - pcbox->cyCombo, 0);

        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) && (pcbox->cyDrop == 23))
        {
            //
            // This is VC++ 2.1's debug/release dropdown that they made super
            // small -- let's make 'em a wee bit bigger so the world can
            // continue to spin -- jeffbog -- 4/19/95 -- B#10029
            //
            pcbox->cyDrop = 28;
        }
    }

    //
    // Determine the rectangles for each of the windows...  1.  Pop down button 2.
    // Edit control or generic window for static text or ownerdraw...  3.  List
    // box
    //

    //
    // Is there a button?
    //
    if (pcbox->CBoxStyle & SDROPPABLE) 
    {
        INT  cxBorder, cyBorder;

        //
        // Determine button's rectangle.
        //

        if (pcbox->hTheme && SUCCEEDED(GetThemeInt(pcbox->hTheme, 0, CBXS_NORMAL, TMT_BORDERSIZE, &cxBorder))) 
        {
            cyBorder = cxBorder;
        }
        else
        {
            cxBorder = g_cxEdge;
            cyBorder = g_cyEdge;
        }

        pcbox->buttonrc.top = cyBorder;
        pcbox->buttonrc.bottom = pcbox->cyCombo - cyBorder;

        if (pcbox->fRightAlign) 
        {
            pcbox->buttonrc.left  = cxBorder;
            pcbox->buttonrc.right = pcbox->buttonrc.left + GetSystemMetrics(SM_CXVSCROLL);
        } 
        else 
        {
            pcbox->buttonrc.right = pcbox->cxCombo - cxBorder;
            pcbox->buttonrc.left  = pcbox->buttonrc.right - GetSystemMetrics(SM_CXVSCROLL);
        }

        //
        // Reduce the width of the edittext window to make room for the button.
        //
        dxEdit = max(dxEdit - GetSystemMetrics(SM_CXVSCROLL), 0);

    } 
    else 
    {
        //
        // No button so make the rectangle 0 so that a point in rect will always
        // return false.
        //
        SetRectEmpty(&pcbox->buttonrc);
    }

    //
    // So now, the edit rect is really the item area.
    // 
    pcbox->editrc.left      = GetSystemMetrics(SM_CXFIXEDFRAME);
    pcbox->editrc.right     = pcbox->editrc.left + dxEdit;
    pcbox->editrc.top       = GetSystemMetrics(SM_CYFIXEDFRAME);
    pcbox->editrc.bottom    = pcbox->editrc.top + dyEdit;

    //
    // Is there a right-aligned button?
    //
    if ((pcbox->CBoxStyle & SDROPPABLE) && (pcbox->fRightAlign)) 
    {
        pcbox->editrc.right = pcbox->cxCombo - GetSystemMetrics(SM_CXEDGE);
        pcbox->editrc.left  = pcbox->editrc.right - dxEdit;
    }

    lprcList->left          = 0;
    lprcList->top           = pcbox->cyCombo;
    lprcList->right         = max(pcbox->cxDrop, pcbox->cxCombo);
    lprcList->bottom        = pcbox->cyCombo + pcbox->cyDrop;
}


//---------------------------------------------------------------------------//
//
// ComboBox_SetDroppedSize()
//
// Compute the drop down window's width and max height
//
VOID ComboBox_SetDroppedSize(PCBOX pcbox, LPRECT lprc)
{
    pcbox->fLBoxVisible = TRUE;
    ComboBox_HideListBoxWindow(pcbox, FALSE, FALSE);

    MoveWindow(pcbox->hwndList, lprc->left, lprc->top,
        lprc->right - lprc->left, lprc->bottom - lprc->top, FALSE);
}


//---------------------------------------------------------------------------//
//
// ComboBox_NcCreateHandler
// 
// Allocates space for the CBOX structure and sets the window to point to it.
//
LONG ComboBox_NcCreateHandler(PCBOX pcbox, HWND hwnd)
{
    ULONG ulStyle;
    ULONG ulExStyle;
    ULONG ulMask;

    pcbox->hwnd = hwnd;
    pcbox->pww = (PWW)GetWindowLongPtr(hwnd, GWLP_WOWWORDS);

    ulStyle   = GET_STYLE(pcbox);
    ulExStyle = GET_EXSTYLE(pcbox); 

    //
    // Save the style bits so that we have them when we create the client area
    // of the combo box window.
    //
    pcbox->styleSave = ulStyle & (WS_VSCROLL|WS_HSCROLL);

    if (!(ulStyle & (CBS_OWNERDRAWFIXED | CBS_OWNERDRAWVARIABLE)))
    {
        //
        // Add in CBS_HASSTRINGS if the style is implied...
        //
        SetWindowState(hwnd, CBS_HASSTRINGS);
    }

    ClearWindowState(hwnd, WS_VSCROLL|WS_HSCROLL|WS_BORDER);

    //
    // If the window is 4.0 compatible or has a CLIENTEDGE, draw the combo
    // in 3D.  Otherwise, use a flat border.
    //
    if (TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT) || TESTFLAG(ulExStyle, WS_EX_CLIENTEDGE))
    {
        pcbox->f3DCombo = TRUE;
    }

    ulMask = WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE;
    if ( (ulExStyle & ulMask) != 0 ) 
    {
        SetWindowLong(hwnd, GWL_EXSTYLE, ulExStyle & (~ ulMask));
    }

    return (LONG)TRUE;
}


//---------------------------------------------------------------------------//
//
// ComboBox_CreateHandler
//
// Creates all the child controls within the combo box
// Returns -1 if error
//
LRESULT ComboBox_CreateHandler(PCBOX pcbox, HWND hwnd)
{
    RECT rcList;
    RECT rcWindow;

    HWND hwndList;
    HWND hwndEdit;

    ULONG ulStyle;
    ULONG ulExStyle;
    ULONG ulStyleT;

    pcbox->hwndParent = GetParent(hwnd);
    pcbox->hTheme = OpenThemeData(pcbox->hwnd, L"Combobox");

    //
    // Break out the style bits so that we will be able to create the listbox
    // and editcontrol windows.
    //
    ulStyle = GET_STYLE(pcbox);
    if ((ulStyle & CBS_DROPDOWNLIST) == CBS_DROPDOWNLIST)
    {
        pcbox->CBoxStyle = SDROPDOWNLIST;
        pcbox->fNoEdit = TRUE;
    } 
    else if ((ulStyle & CBS_DROPDOWN) == CBS_DROPDOWN)
    {
        pcbox->CBoxStyle = SDROPDOWN;
    }
    else
    {
        pcbox->CBoxStyle = SSIMPLE;
    }

    pcbox->fRtoLReading = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RTLREADING);
    pcbox->fRightAlign  = TESTFLAG(GET_EXSTYLE(pcbox), WS_EX_RIGHT);

    if (ulStyle & CBS_UPPERCASE)
    {
        pcbox->fCase = UPPERCASE;
    }
    else if (ulStyle & CBS_LOWERCASE)
    {
        pcbox->fCase = LOWERCASE;
    }
    else
    {
        pcbox->fCase = 0;
    }

    //
    // Listbox item flags.
    //
    if (ulStyle & CBS_OWNERDRAWVARIABLE)
    {
        pcbox->OwnerDraw = OWNERDRAWVAR;
    }

    if (ulStyle & CBS_OWNERDRAWFIXED)
    {
        pcbox->OwnerDraw = OWNERDRAWFIXED;
    }

    //
    // Get the size of the combo box rectangle.
    //
    // Get control sizes.
    GetWindowRect(hwnd, &rcWindow);
    pcbox->cxCombo = rcWindow.right - rcWindow.left;
    pcbox->cyDrop  = RECALC_CYDROP;
    pcbox->cxDrop  = 0;
    ComboBox_CalcControlRects(pcbox, &rcList);

    //
    // We need to do this because listboxes, as of VER40, have stopped
    // reinflating themselves by CXBORDER and CYBORDER.
    //
    if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
    {
        InflateRect(&rcList, -GetSystemMetrics(SM_CXBORDER), -GetSystemMetrics(SM_CYBORDER));
    }

    //
    // Note that we have to create the listbox before the editcontrol since the
    // editcontrol code looks for and saves away the listbox pwnd and the
    // listbox pwnd will be NULL if we don't create it first.  Also, hack in
    // some special +/- values for the listbox size due to the way we create
    // listboxes with borders.
    //
    ulStyleT = pcbox->styleSave;

    ulStyleT |= WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;

    if (ulStyle & WS_DISABLED)
    {
        ulStyleT |= WS_DISABLED;
    }

    if (ulStyle & CBS_NOINTEGRALHEIGHT)
    {
        ulStyleT |= LBS_NOINTEGRALHEIGHT;
    }

    if (ulStyle & CBS_SORT)
    {
        ulStyleT |= LBS_SORT;
    }

    if (ulStyle & CBS_HASSTRINGS)
    {
        ulStyleT |= LBS_HASSTRINGS;
    }

    if (ulStyle & CBS_DISABLENOSCROLL)
    {
        ulStyleT |= LBS_DISABLENOSCROLL;
    }

    if (pcbox->OwnerDraw == OWNERDRAWVAR)
    {
        ulStyleT |= LBS_OWNERDRAWVARIABLE;
    }
    else if (pcbox->OwnerDraw == OWNERDRAWFIXED)
    {
        ulStyleT |= LBS_OWNERDRAWFIXED;
    }

    if (pcbox->CBoxStyle & SDROPPABLE)
    {
        ulStyleT |= WS_BORDER;
    }

    ulExStyle = GET_EXSTYLE(pcbox) & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    hwndList = CreateWindowEx(
                ulExStyle | ((pcbox->CBoxStyle & SDROPPABLE) ? WS_EX_TOOLWINDOW : WS_EX_CLIENTEDGE),
                WC_COMBOLBOX, 
                NULL, 
                ulStyleT,
                rcList.left, 
                rcList.top, 
                rcList.right - rcList.left,
                rcList.bottom - rcList.top,
                hwnd, 
                (HMENU)CBLISTBOXID, 
                GetWindowInstance(hwnd),
                NULL);

    pcbox->hwndList = hwndList;

    if (!pcbox->hwndList) 
    {
        return -1;
    }

    //
    // Override the listbox's theme with combobox
    //
    SetWindowTheme(pcbox->hwndList, L"Combobox", NULL);

    //
    // Create either the edit control or the static text rectangle.
    //
    if (pcbox->fNoEdit) 
    {
        //
        // No editcontrol so we will draw text directly into the combo box
        // window.
        //
        // Don't lock the combobox window: this would prevent WM_FINALDESTROY
        // being sent to it, so pwnd and pcbox wouldn't get freed (zombies)
        // until thread cleanup. (IanJa)  LATER: change name from spwnd to pwnd.
        // Lock(&(pcbox->spwndEdit), pcbox->spwnd); - caused a 'catch-22'
        //
        pcbox->hwndEdit = pcbox->hwnd;
    } 
    else 
    {
        ulStyleT = WS_CHILD | WS_VISIBLE | ES_COMBOBOX | ES_NOHIDESEL;

        if (ulStyle & WS_DISABLED)
        {
            ulStyleT |= WS_DISABLED;
        }

        if (ulStyle & CBS_AUTOHSCROLL)
        {
            ulStyleT |= ES_AUTOHSCROLL;
        }

        if (ulStyle & CBS_OEMCONVERT)
        {
            ulStyleT |= ES_OEMCONVERT;
        }

        if (pcbox->fCase)
        {
            ulStyleT |= (pcbox->fCase & UPPERCASE) ? ES_UPPERCASE : ES_LOWERCASE;
        }

        //
        // Edit control need to know whether original CreateWindow*() call
        // was ANSI or Unicode.
        //
        if (ulExStyle & WS_EX_RIGHT)
        {
            ulStyleT |= ES_RIGHT;
        }

        hwndEdit = CreateWindowEx(
                    ulExStyle,
                    WC_EDIT, 
                    NULL, 
                    ulStyleT,
                    pcbox->editrc.left, 
                    pcbox->editrc.top,
                    pcbox->editrc.right - pcbox->editrc.left, 
                    pcbox->editrc.bottom - pcbox->editrc.top, 
                    hwnd, 
                    (HMENU)CBEDITID,
                    GetWindowInstance(hwnd),
                    NULL);

        pcbox->hwndEdit = hwndEdit;

        //
        // Override the edit's theme with combobox
        //
        SetWindowTheme(pcbox->hwndEdit, L"Combobox", NULL);

    }

    if (!pcbox->hwndEdit)
    {
        return -1L;
    }

    pcbox->iMinVisible = DEFAULT_MINVISIBLE;

    if (pcbox->CBoxStyle & SDROPPABLE) 
    {
        ShowWindow(hwndList, SW_HIDE);
        SetParent(hwndList, NULL);

        //
        // We need to do this so dropped size works right
        //
        if (!TESTFLAG(GET_STATE2(pcbox), WS_S2_WIN40COMPAT))
        {
            InflateRect(&rcList, GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER));
        }

        ComboBox_SetDroppedSize(pcbox, &rcList);
    }

    //
    // return anything as long as it's not -1L (-1L == error)
    //
    return (LRESULT)hwnd;
}



//---------------------------------------------------------------------------//
//
// ComboBox_NcDestroyHandler
//
// Destroys the combobox and frees up all memory used by it
//
VOID ComboBox_NcDestroyHandler(HWND hwnd, PCBOX pcbox)
{
    //
    // If there is no pcbox, there is nothing to clean up.
    //
    if (pcbox != NULL) 
    {
        //
        // Destroy the list box here so that it'll send WM_DELETEITEM messages
        // before the combo box turns into a zombie.
        //
        if (pcbox->hwndList != NULL) 
        {
            DestroyWindow(pcbox->hwndList);
            pcbox->hwndList = NULL;
        }

        pcbox->hwnd = NULL;
        pcbox->hwndParent = NULL;

        //
        // If there is no editcontrol, spwndEdit is the combobox window which
        // isn't locked (that would have caused a 'catch-22').
        //
        if (hwnd != pcbox->hwndEdit) 
        {
            pcbox->hwndEdit = NULL;
        }

        if (pcbox->hTheme != NULL)
        {
            CloseThemeData(pcbox->hTheme);
        }

        //
        // free the combobox instance structure
        //
        UserLocalFree(pcbox);
    }

    TraceMsg(TF_STANDARD, "COMBOBOX: Clearing combobox instance pointer.");
    ComboBox_SetPtr(hwnd, NULL);
}


//---------------------------------------------------------------------------//
VOID ComboBox_SetFontHandler(PCBOX pcbox, HANDLE hFont, BOOL fRedraw)
{
    pcbox->hFont = hFont;

    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        SendMessage(pcbox->hwndEdit, WM_SETFONT, (WPARAM)hFont, FALSE);
    }

    SendMessage(pcbox->hwndList, WM_SETFONT, (WPARAM)hFont, FALSE);

    //
    // Recalculate the layout of controls.  This will hide the listbox also.
    //
    ComboBox_Position(pcbox);

    if (fRedraw) 
    {
        InvalidateRect(pcbox->hwnd, NULL, TRUE);
    }
}


//---------------------------------------------------------------------------//
//
// ComboBox_SetEditItemHeight
//
// Sets the height of the edit/static item of a combo box.
//
LONG ComboBox_SetEditItemHeight(PCBOX pcbox, int dyEdit)
{
    if (dyEdit > 255) 
    {
        TraceMsg(TF_STANDARD, "CCCombobox: CBSetEditItmeHeight: Invalid Parameter dwEdit = %d", dyEdit);
        return CB_ERR;
    }

    pcbox->editrc.bottom = pcbox->editrc.top + dyEdit;
    pcbox->cyCombo = pcbox->editrc.bottom + GetSystemMetrics(SM_CYFIXEDFRAME);

    if (pcbox->CBoxStyle & SDROPPABLE) 
    {
        int cyBorder = g_cyEdge;

        if ( pcbox->hTheme )
        {
            GetThemeInt(pcbox->hTheme, 0, CBXS_NORMAL, TMT_BORDERSIZE, &cyBorder);
        }

        pcbox->buttonrc.bottom = pcbox->cyCombo - cyBorder;
    }

    //
    // Reposition the editfield.
    // Don't let spwndEdit or List of NULL go through; if someone adjusts
    // the height on a NCCREATE; same as not having
    // HW instead of HWq but we don't go to the kernel.
    //
    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        MoveWindow(pcbox->hwndEdit, pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right-pcbox->editrc.left, dyEdit, TRUE);
    }

    //
    // Reposition the list and combobox windows.
    //
    if (pcbox->CBoxStyle == SSIMPLE) 
    {
        if (pcbox->hwndList != 0) 
        {
            RECT rcList;

            MoveWindow(pcbox->hwndList, 0, pcbox->cyCombo, pcbox->cxCombo,
                pcbox->cyDrop, FALSE);

            GetWindowRect(pcbox->hwndList, &rcList);
            SetWindowPos(pcbox->hwnd, HWND_TOP, 0, 0,
                pcbox->cxCombo, pcbox->cyCombo +
                rcList.bottom - rcList.top,
                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
    } 
    else 
    {
         RECT rcWindow;

        GetWindowRect(pcbox->hwnd, &rcWindow);
        if (pcbox->hwndList != NULL) 
        {
            MoveWindow(pcbox->hwndList, rcWindow.left,
                rcWindow.top + pcbox->cyCombo,
                max(pcbox->cxDrop, pcbox->cxCombo), pcbox->cyDrop, FALSE);
        }

        SetWindowPos(pcbox->hwnd, HWND_TOP, 0, 0,
            pcbox->cxCombo, pcbox->cyCombo,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    return CB_OKAY;
}


//---------------------------------------------------------------------------//
//
// ComboBox_SizeHandler
//
// Recalculates the sizes of the internal controls in response to a
// resizing of the combo box window.  The app must size the combo box to its
// maximum open/dropped down size.
//
VOID ComboBox_SizeHandler(PCBOX pcbox)
{
    RECT rcWindow;

    //
    // Assume listbox is visible since the app should size it to its maximum
    // visible size.
    //
    GetWindowRect(pcbox->hwnd, &rcWindow);
    pcbox->cxCombo = RECTWIDTH(rcWindow);

    if (RECTHEIGHT(rcWindow) > pcbox->cyCombo)
    {
        pcbox->cyDrop = RECALC_CYDROP;
    }

    //
    // Reposition everything.
    //
    ComboBox_Position(pcbox);
}


//---------------------------------------------------------------------------//
//
// ComboBox_Position()
//
// Repositions components of edit control.
//
VOID ComboBox_Position(PCBOX pcbox)
{
    RECT rcList;

    //
    // Calculate placement of components--button, item, list
    //
    ComboBox_CalcControlRects(pcbox, &rcList);

    if (!pcbox->fNoEdit && pcbox->hwndEdit) 
    {
        MoveWindow(pcbox->hwndEdit, pcbox->editrc.left, pcbox->editrc.top,
            pcbox->editrc.right - pcbox->editrc.left,
            pcbox->editrc.bottom - pcbox->editrc.top, TRUE);
    }

    //
    // Recalculate drop height & width
    //
    ComboBox_SetDroppedSize(pcbox, &rcList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\cstrings.c ===
#include "ctlspriv.h"

const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szTabControlClass[] = WC_TABCONTROL;
const TCHAR c_szListViewClass[] = WC_LISTVIEW;
const TCHAR c_szHeaderClass[] = WC_HEADER;
const TCHAR c_szTreeViewClass[] = WC_TREEVIEW;
const TCHAR c_szStatusClass[] = STATUSCLASSNAME;
const TCHAR c_szSToolTipsClass[] = TOOLTIPS_CLASS;
const TCHAR c_szToolbarClass[] = TOOLBARCLASSNAME;
const TCHAR c_szReBarClass[] = REBARCLASSNAME;
const TCHAR c_szEllipses[] = TEXT("...");
const TCHAR c_szShell[] = TEXT("Shell");
const TCHAR c_szEdit[] = TEXT("EDIT");
const TCHAR c_szSelect[] = TEXT("CCSelect");
const TCHAR s_szUpdownClass[] = UPDOWN_CLASS;
const TCHAR s_szHOTKEY_CLASS[] = HOTKEY_CLASS;
const TCHAR s_szSTrackBarClass[] = TRACKBAR_CLASS;
const TCHAR s_szPROGRESS_CLASS[] = PROGRESS_CLASS;
const TCHAR c_szCC32Subclass[] = TEXT("UxSubclassInfo");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\dlgcvt.h ===
#ifndef _INC_COMCTL32_DLGCVT_H
#define _INC_COMCTL32_DLGCVT_H



#ifndef _INC_WINDOWSX
#   include <windowsx.h>
#endif
#ifndef __CCSTOCK_H__
#   include <ccstock.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif 

HRESULT CvtDlgToDlgEx(LPDLGTEMPLATE pTemplate, LPDLGTEMPLATEEX *ppTemplateExOut, int iCharset);

#ifdef __cplusplus
} // extern "C"
#endif



#endif // _INC_COMCTL32_DLGCVT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\comctl32\v6\cutils.c ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"
#include "advpub.h"             // For REGINSTALL
#include <ntverp.h>
#include "ccver.h"              // App compat version hacks
#include <shfusion.h>

#ifndef SSW_EX_IGNORESETTINGS
#define SSW_EX_IGNORESETTINGS   0x00040000  // ignore system settings to turn on/off smooth scroll
#endif

// the insert mark is 6 pixels wide
#define INSERTMARKSIZE      6


//
// Globals - REVIEW_32
//

BOOL g_fAnimate;
BOOL g_fSmoothScroll;
BOOL g_fEnableBalloonTips = TRUE;

int g_cxEdge;
int g_cyEdge;
int g_cxEdgeScaled;
int g_cyEdgeScaled;
int g_cxBorder;
int g_cyBorder;
int g_cxScreen;
int g_cyScreen;
int g_cxFrame;
int g_cyFrame;
int g_cxVScroll;
int g_cyHScroll;
int g_cxIcon, g_cyIcon;
int g_cxSmIcon, g_cySmIcon;
int g_cxIconSpacing, g_cyIconSpacing;
int g_cxIconMargin, g_cyIconMargin;
int g_cyLabelSpace;
int g_cxLabelMargin;
int g_cxDoubleClk;
int g_cyDoubleClk;
int g_cxScrollbar;
int g_cyScrollbar;
int g_fDragFullWindows;
double g_dScaleX = 1.0;
double g_dScaleY = 1.0;
BOOL   g_fScale = FALSE;
int g_iDPI = 96.0;
BOOL g_fHighContrast = FALSE;
int g_cyCompensateInternalLeading;
int g_fLeftAligned = FALSE;


COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrWindowFrame;
COLORREF g_clrGrayText;
COLORREF g_clrBtnText;
COLORREF g_clrBtnFace;
COLORREF g_clrBtnShadow;
COLORREF g_clrBtnHighlight;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;
COLORREF g_clrInfoText;
COLORREF g_clrInfoBk;
COLORREF g_clr3DDkShadow;
COLORREF g_clr3DLight;
COLORREF g_clrMenuHilight;
COLORREF g_clrMenuText;

HBRUSH g_hbrGrayText;
HBRUSH g_hbrWindow;
HBRUSH g_hbrWindowText;
HBRUSH g_hbrWindowFrame;
HBRUSH g_hbrBtnFace;
HBRUSH g_hbrBtnHighlight;
HBRUSH g_hbrBtnShadow;
HBRUSH g_hbrHighlight;
HBRUSH g_hbrMenuHilight;
HBRUSH g_hbrMenuText;


DWORD  g_dwHoverSelectTimeout;

HFONT g_hfontSystem;

void InitGlobalColors()
{
    BOOL fFlatMenuMode = FALSE;
    static fMenuColorAlloc = FALSE;
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindowFrame = GetSysColor(COLOR_WINDOWFRAME);
    g_clrGrayText = GetSysColor(COLOR_GRAYTEXT);
    g_clrBtnText = GetSysColor(COLOR_BTNTEXT);
    g_clrBtnFace = GetSysColor(COLOR_BTNFACE);
    g_clrBtnShadow = GetSysColor(COLOR_BTNSHADOW);
    g_clrBtnHighlight = GetSysColor(COLOR_BTNHIGHLIGHT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrInfoText = GetSysColor(COLOR_INFOTEXT);
    g_clrInfoBk = GetSysColor(COLOR_INFOBK);
    g_clr3DDkShadow = GetSysColor(COLOR_3DDKSHADOW);
    g_clr3DLight = GetSysColor(COLOR_3DLIGHT);

    SystemParametersInfo(SPI_GETFLATMENU, 0, (PVOID)&fFlatMenuMode, 0);

    if (fFlatMenuMode)
    {
        g_clrMenuHilight = GetSysColor(COLOR_MENUHILIGHT);
        g_clrMenuText = GetSysColor(COLOR_MENUTEXT);
    }
    else
    {
        g_clrMenuHilight = GetBorderSelectColor(60, GetSysColor(COLOR_HIGHLIGHT));
        g_clrMenuText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    }

    g_hbrGrayText = GetSysColorBrush(COLOR_GRAYTEXT);
    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrWindowText = GetSysColorBrush(COLOR_WINDOWTEXT);
    g_hbrWindowFrame = GetSysColorBrush(COLOR_WINDOWFRAME);
    g_hbrBtnFace = GetSysColorBrush(COLOR_BTNFACE);
    g_hbrBtnHighlight = GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    g_hbrBtnShadow = GetSysColorBrush(COLOR_BTNSHADOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
    g_hfontSystem = GetStockObject(SYSTEM_FONT);

    if (fMenuColorAlloc)
    {
        DeleteObject(g_hbrMenuHilight);
    }

    if (fFlatMenuMode)
    {
        fMenuColorAlloc = FALSE;
        g_hbrMenuHilight = GetSysColorBrush(COLOR_MENUHILIGHT);
        g_hbrMenuText = GetSysColorBrush(COLOR_MENUTEXT);
    }
    else
    {
        fMenuColorAlloc = TRUE;
        g_hbrMenuHilight = CreateSolidBrush(g_clrMenuHilight);
        g_hbrMenuText = GetSysColorBrush(COLOR_HIGHLIGHTTEXT);
    }

}


#define CCS_ALIGN (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)

///
//
// Implement MapWindowPoints as if the hwndFrom and hwndTo aren't
// mirrored. This is used when any of the windows (hwndFrom or hwndTo)
// are mirrored. See below. [samera]
//
int TrueMapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lppt, UINT cPoints)
{
    int dx, dy;
    RECT rcFrom={0,0,0,0}, rcTo={0,0,0,0};

    if (hwndFrom) {
        GetClientRect(hwndFrom, &rcFrom);
        MapWindowPoints(hwndFrom, NULL, (LPPOINT)&rcFrom.left, 2);
    }

    if (hwndTo) {
        GetClientRect(hwndTo, &rcTo);
        MapWindowPoints(hwndTo, NULL, (LPPOINT)&rcTo.left, 2);
    }

    dx = rcFrom.left - rcTo.left;
    dy = rcFrom.top  - rcTo.top;

    /*
     * Map the points
     */
    while (cPoints--) {
        lppt->x += dx;
        lppt->y += dy;
        ++lppt;
    }
    
    return MAKELONG(dx, dy);
}


// Note that the default alignment is CCS_BOTTOM
//
void NewSize(HWND hWnd, int nThickness, LONG style, int left, int top, int width, int height)
{
    // Resize the window unless the user said not to
    //
    if (!(style & CCS_NORESIZE))
    {
        RECT rc, rcWindow, rcBorder;

        // Remember size that was passed in and don't bother calling SetWindowPos if we're not
        // actually going to change the window size
        int leftSave = left;
        int topSave = top;
        int widthSave = width;
        int heightSave = height;

        // Calculate the borders around the client area of the status bar
        GetWindowRect(hWnd, &rcWindow);
        rcWindow.right -= rcWindow.left;  // -> dx
        rcWindow.bottom -= rcWindow.top;  // -> dy

        GetClientRect(hWnd, &rc);

        //
        // If the window is mirrored, mirror the anchor point
        // since it will be passed to SWP which accepts screen
        // ccordinates. This mainly fixes the display of status bar
        // and others. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hWnd))
        {
            TrueMapWindowPoints(hWnd, NULL, (LPPOINT)&rc.left, 1);
        }
        else
        {
            ClientToScreen(hWnd, (LPPOINT)&rc);
        }

        rcBorder.left = rc.left - rcWindow.left;
        rcBorder.top  = rc.top  - rcWindow.top ;
        rcBorder.right  = rcWindow.right  - rc.right  - rcBorder.left;
        rcBorder.bottom = rcWindow.bottom - rc.bottom - rcBorder.top ;

        if (style & CCS_VERT)
            nThickness += rcBorder.left + rcBorder.right;
        else
            nThickness += rcBorder.top + rcBorder.bottom;

        // Check whether to align to the parent window
        //
        if (style & CCS_NOPARENTALIGN)
        {
            // Check out whether this bar is top aligned or bottom aligned
            //
            switch (style & CCS_ALIGN)
            {
            case CCS_TOP:
            case CCS_NOMOVEY:
                break;

            default: // CCS_BOTTOM
                if(style & CCS_VERT)
                    left = left + width - nThickness;
                else
                    top = top + height - nThickness;
            }
        }
        else
        {
            // It is assumed there is a parent by default
            //
            GetClientRect(GetParent(hWnd), &rc);

            // Don't forget to account for the borders
            //
            if(style & CCS_VERT)
            {
                top = -rcBorder.right;
                height = rc.bottom + rcBorder.top + rcBorder.bottom;
            }
            else
            {
                left = -rcBorder.left;
                width = rc.right + rcBorder.left + rcBorder.right;
            }

            if ((style & CCS_ALIGN) == CCS_TOP)
            {
                if(style & CCS_VERT)
                    left = -rcBorder.left;
                else
                    top = -rcBorder.top;
            }
            else if ((style & CCS_ALIGN) != CCS_NOMOVEY)
            {
                if (style & CCS_VERT)
                    left = rc.right - nThickness + rcBorder.right;
                else
                    top = rc.bottom - nThickness + rcBorder.bottom;
            }
        }
        if (!(style & CCS_NOMOVEY) && !(style & CCS_NODIVIDER))
        {
            if (style & CCS_VERT)
                left += g_cxEdge;
            else
                top += g_cyEdge;      // double pixel edge thing
        }

        if(style & CCS_VERT)
            width = nThickness;
        else
            height = nThickness;

        SetWindowPos(hWnd, NULL, left, top, width, height, SWP_NOZORDER);
    }
}


BOOL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int * pcx, int * pcy)
{
    BOOL fSuccess;
    SIZE size = {0,0};
    
    if (cnt == -1)
        cnt = lstrlen(lpstr);
    
    fSuccess=GetTextExtentPoint(hdc, lpstr, cnt, &size);
    if (pcx)
        *pcx=size.cx;
    if (pcy)
        *pcy=size.cy;

    return fSuccess;
}


// these are the default colors used to map the dib colors
// to the current system colors

#define RGB_BUTTONTEXT      (RGB(000,000,000))  // black
#define RGB_BUTTONSHADOW    (RGB(128,128,128))  // dark grey
#define RGB_BUTTONFACE      (RGB(192,192,192))  // bright grey
#define RGB_BUTTONHILIGHT   (RGB(255,255,255))  // white
#define RGB_BACKGROUNDSEL   (RGB(000,000,255))  // blue
#define RGB_BACKGROUND      (RGB(255,000,255))  // magenta

#ifdef UNIX
RGBQUAD CLR_TO_RGBQUAD( COLORREF clr)
{
    /* main modif for unix: keep the extra byte in the rgbReserved field
       This is used for our motif colors that are expressed in term of
       CMAPINDEX rather than real RGBs, this function is also portable
       and immune to endianness*/
    RGBQUAD rgbqResult;
    rgbqResult.rgbRed=GetRValue(clr);
    rgbqResult.rgbGreen=GetGValue(clr);
    rgbqResult.rgbBlue=GetBValue(clr);
    rgbqResult.rgbReserved=(BYTE)((clr>>24)&0xff);
    return rgbqResult;
}

COLORREF RGBQUAD_TO_CLR( RGBQUAD rgbQ )
{
    return ( ((DWORD)rgbQ.rgbRed) |  ((DWORD)(rgbQ.rgbGreen << 8)) | 
            ((DWORD)(rgbQ.rgbBlue << 16)) | ((DWORD)(rgbQ.rgbReserved << 24)) );
}

/* This is just plain wrong
   1) they definition of COLORMAP is based on COLORREFs but a
      DIB color map is RGBQUAD
   2) FlipColor as per previous definition does not flip at all
      since it goes from COLORREF to COLORREF
   so we are better doing nothing, so we dont loose our CMAP flag
   (Jose)
   */
#define FlipColor(rgb)      (rgb)
#else
#define FlipColor(rgb)      (RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)))
#endif /* UNIX */


#define MAX_COLOR_MAPS      16

void _MapBitmapColors(LPBITMAPINFOHEADER pbih, LPCOLORMAP pcmp, int iCmps, COLOR_STRUCT* pcsMask, UINT cMask, DWORD wFlags)
{
    static const COLORMAP c_acmpSys[] =
    {
        { RGB_BUTTONTEXT,    COLOR_BTNTEXT },       // black
        { RGB_BUTTONSHADOW,  COLOR_BTNSHADOW },     // dark grey
        { RGB_BUTTONFACE,    COLOR_BTNFACE },       // bright grey
        { RGB_BUTTONHILIGHT, COLOR_BTNHIGHLIGHT },  // white
        { RGB_BACKGROUNDSEL, COLOR_HIGHLIGHT },     // blue
        { RGB_BACKGROUND,    COLOR_WINDOW },        // magenta
    };

    COLORMAP acmpDef[ARRAYSIZE(c_acmpSys)];
    COLORMAP acmpDIB[MAX_COLOR_MAPS];
    COLOR_STRUCT* pcs = (COLOR_STRUCT*)(((LPBYTE)pbih) + pbih->biSize);

    int i;

    if (!pcmp)
    {
        // Get system colors for the default color map

        for (i = 0; i < ARRAYSIZE(acmpDef); i++)
        {
            acmpDef[i].from = c_acmpSys[i].from;
            acmpDef[i].to = GetSysColor((int)c_acmpSys[i].to);
        }

        pcmp = acmpDef;
        iCmps = ARRAYSIZE(acmpDef);
    }
    else
    {
        // Sanity check color map count

        if (iCmps > MAX_COLOR_MAPS)
            iCmps = MAX_COLOR_MAPS;
    }

    for (i = 0; i < iCmps; i++)
    {
        acmpDIB[i].to = FlipColor(pcmp[i].to);
        acmpDIB[i].from = FlipColor(pcmp[i].from);
    }

    // if we are creating a mask, build a color table with white
    // marking the transparent section (where it used to be background)
    // and black marking the opaque section (everything else).  this
    // table is used below to build the mask using the original DIB bits.
    if (wFlags & CMB_MASKED)
    {
        COLOR_STRUCT csBkgnd = FlipColor(RGB_BACKGROUND);

        ASSERT(cMask == MAX_COLOR_MAPS);

        for (i = 0; i < MAX_COLOR_MAPS; i++)
        {
            if (pcs[i] == csBkgnd)
                pcsMask[i] = 0xFFFFFF;       // transparent section
            else
                pcsMask[i] = 0x000000;       // opaque section
        }
    }

    for (i = 0; i < MAX_COLOR_MAPS; i++)
    {
        int j;
        for (j = 0; j < iCmps; j++)
        {
            if ((pcs[i] & 0x00FFFFFF) == acmpDIB[j].from)
            {
                pcs[i] = acmpDIB[j].to;
                break;
            }
        }
    }
}

HBITMAP _CreateMappedBitmap(LPBITMAPINFOHEADER pbih, LPBYTE lpBits, COLOR_STRUCT* pcsMask, UINT cMask, UINT wFlags)
{
    HBITMAP hbm = NULL;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        HDC hdcMem = CreateCompatibleDC(hdc);
        if (hdcMem)
        {
            int nWidth = (int)pbih->biWidth;
            int nHeight = (int)pbih->biHeight;

            if (wFlags & CMB_DIBSECTION)
            {
                // Have to edit the header slightly, since CreateDIBSection supports
                // only BI_RGB and BI_BITFIELDS.  This is the same whackery that USER
                // does in LoadImage.
                LPVOID pvDummy;
                DWORD dwCompression = pbih->biCompression;
                if (dwCompression != BI_BITFIELDS)
                    pbih->biCompression = BI_RGB;
                hbm = CreateDIBSection(hdc, (LPBITMAPINFO)pbih, DIB_RGB_COLORS,
                                       &pvDummy, NULL, 0);
                pbih->biCompression = dwCompression;
            }

            if (hbm == NULL)
            {
                // If CMB_DIBSECTION failed, then create a DDB instead.  Not perfect,
                // but better than creating nothing.  We also get here if the caller
                // didn't ask for a DIB section.

                // if creating a mask, the bitmap needs to be twice as wide.
                int nWidthBmp;
                if (wFlags & CMB_MASKED)
                    nWidthBmp = nWidth * 2;
                else
                    nWidthBmp = nWidth;

                hbm = CreateCompatibleBitmap(hdc, nWidthBmp, nHeight);
            }

            if (hbm)
            {
                HBITMAP hbmOld = SelectObject(hdcMem, hbm);

                // set the main image
                StretchDIBits(hdcMem, 0, 0, nWidth, nHeight, 0, 0, nWidth, nHeight, lpBits,
                         (LPBITMAPINFO)pbih, DIB_RGB_COLORS, SRCCOPY);

                // if building a mask, replace the DIB's color table with the
                // mask's black/white table and set the bits.  in order to
                // complete the masked effect, the actual image needs to be
                // modified so that it has the color black in all sections
                // that are to be transparent.
                if (wFlags & CMB_MASKED)
                {
                    if (cMask > 0)
                    {
                        COLOR_STRUCT* pcs = (COLOR_STRUCT*)(((LPBYTE)pbih) + pbih->biSize);
                        hmemcpy(pcs, pcsMask, cMask * sizeof(RGBQUAD));
                    }

                    StretchDIBits(hdcMem, nWidth, 0, nWidth, nHeight, 0, 0, nWidth, nHeight, lpBits,
                         (LPBITMAPINFO)pbih, DIB_RGB_COLORS, SRCCOPY);

                    BitBlt(hdcMem, 0, 0, nWidth, nHeight, hdcMem, nWidth, 0, 0x00220326);   // DSna
                }
                SelectObject(hdcMem, hbmOld);
            }

            DeleteObject(hdcMem);
        }

        ReleaseDC(NULL, hdc);
    }

    return hbm;
}

// This is almost the same as LoadImage(..., LR_MAP3DCOLORS) except that
//
//  -   The app can specify a custom color map,
//  -   The default color map maps colors beyond the 3D colors,
//  -   strange UNIX stuff happens that I'm afraid to mess with.
//
HBITMAP CreateMappedBitmap(HINSTANCE hInstance, INT_PTR idBitmap,
      UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
    HBITMAP hbm = NULL;
    BOOL bColorTable;

    HRSRC hrsrc = FindResource(hInstance, MAKEINTRESOURCE(idBitmap), RT_BITMAP);

    if (hrsrc)
    {
        HGLOBAL hglob = LoadResource(hInstance, hrsrc);

        LPBITMAPINFOHEADER pbihRes = (LPBITMAPINFOHEADER)LockResource(hglob);
        if (pbihRes)
        {
            // munge on a copy of the color table instead of the original
            // (prevent possibility of "reload" with messed table
            UINT cbOffset;
            LPBITMAPINFOHEADER pbih;
            WORD biBitCount = pbihRes->biBitCount;
            if ((biBitCount > 8) && (pbihRes->biCompression == BI_RGB))
            {
                // No bmiColors table, image bits start right after header
                cbOffset = pbihRes->biSize;
                bColorTable = FALSE;
            }
            else
            {
                // Bits start after bmiColors table
                cbOffset = pbihRes->biSize + ((1 << (pbihRes->biBitCount)) * sizeof(RGBQUAD));
                bColorTable = TRUE;
            }

            pbih = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, cbOffset);
            if (pbih)
            {
                COLOR_STRUCT acsMask[MAX_COLOR_MAPS];
                LPBYTE lpBits = (LPBYTE)(pbihRes) + cbOffset;
                UINT uColorTableLength = (bColorTable ? ARRAYSIZE(acsMask) : 0);

                memcpy(pbih, pbihRes, cbOffset);

                if (bColorTable)
                    _MapBitmapColors(pbih, lpColorMap, iNumMaps, acsMask, uColorTableLength, wFlags);

                hbm = _CreateMappedBitmap(pbih, lpBits, acsMask, uColorTableLength, wFlags);

                LocalFree(pbih);
            }

            UnlockResource(hglob);
        }

        FreeResource(hrsrc);
    }

    return hbm;
}

// moved from shelldll\dragdrop.c

// should caller pass in message that indicates termination
// (WM_LBUTTONUP, WM_RBUTTONUP)?
//
// in:
//      hwnd    to do check on
//      x, y    in client coordinates
//
// returns:
//      TRUE    the user began to drag (moved mouse outside double click rect)
//      FALSE   mouse came up inside click rect
//
// FEATURE, should support VK_ESCAPE to cancel

BOOL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rc;
    int dxClickRect = GetSystemMetrics(SM_CXDRAG);
    int dyClickRect = GetSystemMetrics(SM_CYDRAG);

    if (dxClickRect < 4)
    {
        dxClickRect = dyClickRect = 4;
    }

    // See if the user moves a certain number of pixels in any direction

    SetRect(&rc, x - dxClickRect, y - dyClickRect, x + dxClickRect, y + dyClickRect);
    MapWindowRect(hwnd, HWND_DESKTOP, &rc); // client -> screen

    //
    //  SUBTLE!  We use PeekMessage+WaitMessage instead of GetMessage,
    //  because WaitMessage will return when there is an incoming
    //  SendMessage, whereas GetMessage does not.  This is important,
    //  because the incoming message might've been WM_CAPTURECHANGED.
    //

    SetCapture(hwnd);
    do {
        MSG32 msg32;
        if (PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE))
        {
            // See if the application wants to process the message...
            if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_BEGINDRAG, TRUE) != 0)
                continue;

            switch (msg32.message) {
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                ReleaseCapture();
                return FALSE;

            case WM_MOUSEMOVE:
                if (IsWindow(hwnd) && !PtInRect(&rc, msg32.pt)) {
                    ReleaseCapture();
                    return TRUE;
                }
                break;

            default:
                TranslateMessage32(&msg32, TRUE);
                DispatchMessage32(&msg32, TRUE);
                break;
            }
        }
        else WaitMessage();

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (IsWindow(hwnd) && GetCapture() == hwnd);

    return FALSE;
}


/* Regular StrToInt; stops at first non-digit. */

int WINAPI StrToInt(LPCTSTR lpSrc)      // atoi()
{

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == TEXT('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (ISDIGIT(*lpSrc)) {
        n *= 10;
        n += *lpSrc - TEXT('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}

//
// Wrappers for StrToInt
//

int WINAPI StrToIntA(LPCSTR lpSrc)      // atoi()
{
    LPWSTR lpString;
    INT    iResult;

    lpString = ProduceWFromA (CP_ACP, lpSrc);

    if (!lpString) {
        return 0;
    }

    iResult = StrToIntW(lpString);

    FreeProducedString (lpString);

    return iResult;

}

#undef StrToLong

//
// No need to Unicode this since it is not
// exported.
//

LONG WINAPI StrToLong(LPCTSTR lpSrc)    // atoi()
{
    return StrToInt(lpSrc);
}

//
// From zmouse.h in the Magellan SDK
//

#define MSH_MOUSEWHEEL TEXT("MSWHEEL_ROLLMSG")

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  TEXT("MouseZ")           // wheel window class
#define MOUSEZ_TITLE      TEXT("Magellan MSWHEEL") // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

#define MSH_SCROLL_LINES  TEXT("MSH_SCROLL_LINES_MSG")

#define DI_GETDRAGIMAGE TEXT("ShellGetDragImage")       // Copied from Shlobj.w

UINT g_msgMSWheel;
UINT g_ucScrollLines = 3;                        /* default */
int  gcWheelDelta;
UINT g_uDragImages;

// --------------------------------------------------------------------------
//  _TrackMouseEvent() entrypoint
//
//  calls TrackMouseEvent because we run on an OS where this exists
//
// --------------------------------------------------------------------------
BOOL WINAPI _TrackMouseEvent(LPTRACKMOUSEEVENT lpTME)
{
    return TrackMouseEvent(lpTME);
}



//
// Checks the process to see if it is running under the system SID
//
BOOL IsSystemProcess()
{
    BOOL bRet = FALSE;  // assume we are not a system process
    HANDLE hProcessToken;
    
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
    {
        PSID pSIDSystem;
        static SID_IDENTIFIER_AUTHORITY sSystemSidAuthority = SECURITY_NT_AUTHORITY;

        if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                     1,
                                     SECURITY_LOCAL_SYSTEM_RID,
                                     0, 0, 0, 0, 0, 0, 0,
                                     &pSIDSystem))
        {
            CheckTokenMembership(hProcessToken, pSIDSystem, &bRet);

            FreeSid(pSIDSystem);
        }

        CloseHandle(hProcessToken);
    }

    return bRet;
}

//
// !! WARNING !! - Be very careful about opening HKCU in InitGlobalMetrics(). Basically this gets
//                 called during processattach and system process will end up loading the user hive
//                 and because advapi32 is lame we end up pinning the hive for the life of this process.
//
void InitGlobalMetrics(WPARAM wParam)
{
    static BOOL fInitMouseWheel;
    static HWND hwndMSWheel;
    static UINT msgMSWheelGetScrollLines;
    HDC hdcScreen;
    BOOL fRemoteSession = (BOOL)GetSystemMetrics( SM_REMOTESESSION );
    
    if (!fInitMouseWheel)
    {
        fInitMouseWheel = TRUE;

        g_msgMSWheel = WM_MOUSEWHEEL;
    }

    g_uDragImages = RegisterWindowMessage(DI_GETDRAGIMAGE);

    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);

    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_cySmIcon = GetSystemMetrics(SM_CYSMICON);

    g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
    g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

    hdcScreen = GetDC(NULL);
    if (hdcScreen)
    {
        g_iDPI = GetDeviceCaps(hdcScreen, LOGPIXELSX);
        g_dScaleX = GetDeviceCaps(hdcScreen, LOGPIXELSX) / 96.0;
        g_dScaleY = GetDeviceCaps(hdcScreen, LOGPIXELSY) / 96.0;
        if (g_dScaleX > 1.0 ||
            g_dScaleY > 1.0)
        {
            g_fScale = TRUE;
        }

        ReleaseDC(NULL, hdcScreen);
    }

    // Full window drag stays off if running remotely.  Sessions could become remote after
    // being started.
    if (!fRemoteSession &&
        (wParam == 0 || wParam == SPI_SETDRAGFULLWINDOWS)) 
    {
        SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, sizeof(g_fDragFullWindows), &g_fDragFullWindows, 0);
    }

    if (wParam == 0 || wParam == SPI_SETHIGHCONTRAST)
    {
        HIGHCONTRAST hc = {sizeof(hc)};
        if (SystemParametersInfo(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
        {
            g_fHighContrast = (hc.dwFlags & HCF_HIGHCONTRASTON);
        }
    }

    // Smooth scrolling stays off if running remotely
    if (!fRemoteSession)
    {
        g_fSmoothScroll = TRUE;

        //
        // (see warning at the top of this fn.)
        //
        // we want to avoid loading the users hive if we are running as a system process since advapi32 
        // will hold the hive for as long as this process exists 
        if (!IsSystemProcess())
        {
            HKEY hkey;

            if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_READ, &hkey) == ERROR_SUCCESS)
            {
                DWORD dwSize = sizeof(g_fSmoothScroll);
                RegQueryValueEx(hkey, TEXT("SmoothScroll"), 0, NULL, (LPBYTE)&g_fSmoothScroll, &dwSize);

                RegCloseKey(hkey);
            }
        }
    }

    if (fRemoteSession)
    {
        // Nobody should've turned these on
        g_fDragFullWindows = FALSE;
        g_fSmoothScroll = FALSE;
    }

    // some of these are also not members of NONCLIENTMETRICS
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
    {
        NONCLIENTMETRICS ncm;

        // REVIEW, make sure all these vars are used somewhere.
        g_cxEdgeScaled = g_cxEdge = GetSystemMetrics(SM_CXEDGE);
        g_cyEdgeScaled = g_cyEdge = GetSystemMetrics(SM_CYEDGE);

        CCDPIScaleX(&g_cxEdgeScaled);
        CCDPIScaleY(&g_cyEdgeScaled);

        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);
        g_c