Skew, sizeof(pfli->cSkew));
            pStuff += sizeof(pfli->cSkew);
	    CopyMemory(pStuff, pfli->pSkew, pfli->cSkew *
							sizeof(STARTSTOPSKEW));
            pStuff += pfli->cSkew * sizeof(STARTSTOPSKEW);

	    if (pfli->bstrURL)
                CopyMemory(pStuff, pfli->bstrURL, cb);
	    else
		*(WCHAR *)pStuff = 0;
            pStuff += cb;

            // now persist the format of the mediatype in the FILTERLOADINFO
            if (pfli->mtShare.cbFormat) {
                CopyMemory(pStuff, pfli->mtShare.pbFormat,
                                                pfli->mtShare.cbFormat);
                pStuff += pfli->mtShare.cbFormat;
            }

	    // now persist the sizeof props, and the props
	    LONG cBlob = 0;
	    BYTE *pBlob = NULL;
	    if (pfli->pSetter) {
		pfli->pSetter->SaveToBlob(&cBlob, &pBlob);
		if (cBlob) {
		    pBlob = (BYTE *)CoTaskMemAlloc(cBlob);
		    if (pBlob == NULL)
			cBlob = 0;	// OOM, can't save
		}
	    }
	    CopyMemory(pStuff, &cBlob, sizeof(cBlob));
	    pStuff += sizeof(LONG);
	    if (cBlob) {
		pfli->pSetter->SaveToBlob(&cBlob, &pBlob);
		CopyMemory(pStuff, pBlob, cBlob);
		pStuff += cBlob;
		CoTaskMemFree(pBlob);
	    }

            pfli = pfli->pNext;
        }
    }

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }
    return NOERROR;
}


// load ourself back in
//
HRESULT CBigSwitch::ReadFromStream(IStream *pStream)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::ReadFromStream")));
    CheckPointer(pStream, E_POINTER);

    Reset();	// start over

    // we don't yet know how many saved connections there are
    // all we know we have for sure is the beginning of the struct
    int savesize1 = sizeof(saveSwitch) - sizeof(CRANK2);
    saveSwitch *px = (saveSwitch *)QzTaskMemAlloc(savesize1);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }

    HRESULT hr = pStream->Read(px, savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    if (px->version != 1 && px->version != 2) {
        DbgLog((LOG_ERROR,1,TEXT("*** ERROR! Bad version file")));
        QzTaskMemFree(px);
	return S_OK;
    }

    // how much saved data was there, really?  Get the rest
    int savesize = sizeof(saveSwitch) - sizeof(CRANK2) +
			px->count * sizeof(CRANK2) + px->mt.cbFormat +
			px->InputDepth * sizeof(BOOL);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Persisted data is %d bytes"), savesize));
    px = (saveSwitch *)QzTaskMemRealloc(px, savesize);
    if (px == NULL) {
        DbgLog((LOG_ERROR,1,TEXT("*** Out of memory")));
	return E_OUTOFMEMORY;
    }
    hr = pStream->Read(&(px->crank[0]), savesize - savesize1, 0);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
        QzTaskMemFree(px);
        return hr;
    }

    SetDynamicReconnectLevel(px->nDynaFlags);
    SetInputDepth(px->InputDepth);
    SetOutputDepth(px->OutputDepth);
    SetGroupNumber(px->nGroupNumber);
    SetProjectLength(px->rtProjectLength);
    SetFrameRate(px->dFrameRate);
    SetPreviewMode(px->fPreviewMode);
    if (px->fIsCompressed)
        SetCompressed();

    // re-program our connection array
    for (int i = 0; i < px->count; i++) {
	SetX2Y(px->crank[i].rtStart, px->crank[i].iInpin, px->crank[i].iOutpin);
    }

    // remember, the format is after the array
    AM_MEDIA_TYPE mt = px->mt;
    mt.pbFormat = (BYTE *)QzTaskMemAlloc(mt.cbFormat);
    if (mt.pbFormat == NULL) {
        QzTaskMemFree(px);
        return E_OUTOFMEMORY;
    }
    CopyMemory(mt.pbFormat, &(px->crank[px->count]), mt.cbFormat);

    // finally, pick out which inputs are sources
    BOOL *pfSource = (BOOL *)((BYTE *)(&px->crank[px->count]) + mt.cbFormat);
    for (i = 0; i < m_cInputs; i++) {
	InputIsASource(i, *(pfSource + i));
    }

    // and after that, load any dynamic information if present
    if (px->version == 2) {
        DWORD   cLoadInfo;

        hr = pStream->Read(&cLoadInfo, sizeof(cLoadInfo), 0);
        if(FAILED(hr)) {
            DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
            QzTaskMemFree(px);
            return hr;
        }

        while (cLoadInfo-- > 0) {
            FILTERLOADINFO fli;

            hr = pStream->Read(&fli, sizeof(fli), 0);
            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
                QzTaskMemFree(px);
                return hr;
            }

            hr = pStream->Read(&fli.cSkew, sizeof(fli.cSkew), 0);
            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
                QzTaskMemFree(px);
                return hr;
            }
	    fli.pSkew = (STARTSTOPSKEW *)CoTaskMemAlloc(fli.cSkew *
						sizeof(STARTSTOPSKEW));
	    if (fli.pSkew == NULL) {
                DbgLog((LOG_ERROR,1,TEXT("*** Out of Memory")));
                QzTaskMemFree(px);
                return E_OUTOFMEMORY;
	    }
            hr = pStream->Read(fli.pSkew, fli.cSkew *
						sizeof(STARTSTOPSKEW), 0);
            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
                QzTaskMemFree(px);
                CoTaskMemFree(fli.pSkew);
                return hr;
            }
	
            // hack: overwrite first DWORD with string length
            int cb = (int)(INT_PTR)fli.bstrURL;
	    if (cb > sizeof(WCHAR)) {
                fli.bstrURL = SysAllocStringLen(NULL, (cb / sizeof(WCHAR)) - 1);
		if (fli.bstrURL == NULL) {
    		    FreeMediaType(mt);
                    QzTaskMemFree(px);
                    CoTaskMemFree(fli.pSkew);
		    return E_OUTOFMEMORY;
		}
	    } else {
                fli.bstrURL = NULL;
	    }

            if (fli.bstrURL) {
                hr = pStream->Read(fli.bstrURL, cb, 0);
	    } else  {
		WCHAR wch;
                hr = pStream->Read(&wch, cb, 0);
	    }

            if(FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("*** ReadFromStream FAILED")));
	        FreeMediaType(mt);
                QzTaskMemFree(px);
                CoTaskMemFree(fli.pSkew);
		if (fli.bstrURL)
		    SysFreeString(fli.bstrURL);
                return hr;
            }

            // get the FILTERLOADINFO media type format
            AM_MEDIA_TYPE *pmt = &fli.mtShare;
            if (pmt->cbFormat) {
                pmt->pbFormat = (BYTE *)QzTaskMemAlloc(pmt->cbFormat);
                if (pmt->pbFormat == NULL) {
                    FreeMediaType(mt);
                    QzTaskMemFree(px);
                    CoTaskMemFree(fli.pSkew);
                    if (fli.bstrURL)
                        SysFreeString(fli.bstrURL);
                    return E_OUTOFMEMORY;
                }
                hr = pStream->Read(pmt->pbFormat, pmt->cbFormat, 0);
            }

	    // now read the props back in
	    LONG cBlob = 0;
	    BYTE *pBlob = NULL;
	    pStream->Read(&cBlob, sizeof(LONG), 0);
	    if (cBlob) {
		pBlob = (BYTE *)CoTaskMemAlloc(cBlob);
		if (pBlob) {
		    pStream->Read(pBlob, cBlob, 0);
		    CoCreateInstance(CLSID_PropertySetter, NULL, CLSCTX_INPROC,
				IID_IPropertySetter, (void **)&fli.pSetter);
		    if (fli.pSetter) {
		        fli.pSetter->LoadFromBlob(cBlob, pBlob);
		    }
		    CoTaskMemFree(pBlob);
		}
	    }
	
            AM_MEDIA_TYPE mt;
            ZeroMemory(&mt, sizeof(AM_MEDIA_TYPE));
            hr = AddSourceToConnect(fli.bstrURL, &fli.GUID,
					fli.nStretchMode,
					fli.lStreamNumber,
					fli.dSourceFPS,
					fli.cSkew, fli.pSkew,
					fli.lInputPin, FALSE, 0, mt, 0.0,
					fli.pSetter);
            // this represents two things to connect... Audio and video shared
            if (fli.fShare) {
                hr = AddSourceToConnect(NULL, NULL,
					fli.nShareStretchMode,
					fli.lShareStreamNumber,
					0,
					fli.cSkew, fli.pSkew,
					fli.lInputPin,
                                        TRUE, fli.lShareInputPin,
                                        fli.mtShare, fli.dShareFPS,
					NULL);
            }

	    if (fli.pSetter)
		fli.pSetter->Release();
            CoTaskMemFree(fli.pSkew);
            FreeMediaType(fli.mtShare);
	    if (fli.bstrURL)
		SysFreeString(fli.bstrURL);

            if (FAILED(hr)) {
		ASSERT(FALSE);
                DbgLog((LOG_ERROR,1,TEXT("*** AddSourceToConnect FAILED")));
    	        FreeMediaType(mt);
                QzTaskMemFree(px);
                return hr;
            }
        }
    }

    SetMediaType(&mt);
    FreeMediaType(mt);
    QzTaskMemFree(px);
    SetDirty(FALSE);
    return S_OK;
}


// how big is our save data?
//
int CBigSwitch::SizeMax()
{
    int count = 0;
    int savesize;
    for (int i = 0; i < m_cInputs; i++) {
        CRANK *p = m_pInput[i]->m_pCrankHead;
        while (p) {
	    count++;
	    p = p->Next;
        }
    }

    savesize = sizeof(saveSwitch) + (count - 1) * sizeof(CRANK2) +
				m_mtAccept.cbFormat + m_cInputs * sizeof(BOOL);

    // now count the dynamic stuff to save
    //
    FILTERLOADINFO *pfli = m_pFilterLoad;
    DWORD cLoadInfo = 0;
    if (pfli) {
        savesize += sizeof(cLoadInfo); // count to load
        while (pfli) {
	    if (pfli->bstrURL)
                savesize += sizeof(FILTERLOADINFO) + sizeof(WCHAR) *
					(lstrlenW(pfli->bstrURL) + 1);
	    else
		savesize += sizeof(FILTERLOADINFO) + sizeof(WCHAR);
	    ASSERT(pfli->cSkew > 0);
	    savesize += sizeof(pfli->cSkew) + pfli->cSkew *
					sizeof(STARTSTOPSKEW);
	    savesize += pfli->mtShare.cbFormat;
	    savesize += sizeof(LONG);	// size of props
	    if (pfli->pSetter) {	// how much to save the props?
		LONG cBlob = 0;
		BYTE *pBlob = NULL;
		pfli->pSetter->SaveToBlob(&cBlob, &pBlob);
		if (cBlob) savesize += cBlob;
	    }
            ++cLoadInfo;
            pfli = pfli->pNext;
        }
    }

    return savesize;
}


#if 0
STDMETHODIMP CBigSwitch::Load(IPropertyBag * pPropBag, IErrorLog * pErrorLog)
{


}

HRESULT WriteInt(IPropertyBag *pBag, LPCOLESTR wszName, LONG lVal)
{
    VARIANT v;
    V_VT(&v) = VT_I4;
    V_I4(&v) = m_cInputs;

    return pBag->Write(wszName, &v);
}


STDMETHODIMP CBigSwitch::Save(IPropertyBag * pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Save(propbag)")));

    CheckPointer(pPropBag, E_POINTER);
    int count = 0;
    int savesize;
    CRANK *p;

    // how many queued connections to save?

    for (int i = 0; i < m_cInputs; i++) {
        p = m_pInput[i]->m_pCrankHead;
        while (p) {
	    count++;
	    p = p->Next;
        }
    }

    WriteInt(L"version", 1);
    WriteInt(L"inputs", m_cOutputs);
    WriteInt(L"outputs", m_cOutputs);


    px->version = 1;
    px->InputDepth = m_cInputs;
    px->OutputDepth = m_cOutputs;
    px->rtProjectLength = m_rtProjectLength;
    px->dFrameRate = m_dFrameRate;
    px->count = 0;
    // save all the queued connection data
    for (i = 0; i < m_cInputs; i++) {
        p = m_pInput[i]->m_pCrankHead;
        while (p) {
	    px->crank[px->count].rtStart = p->rtStart;
	    px->crank[px->count].iInpin = i;
	    px->crank[px->count].iOutpin = p->iOutpin;
            px->count++;
	    p = p->Next;
        }
    }
    px->mt = m_mtAccept;
    // Can't persist pointers
    px->mt.pbFormat = NULL;
    px->mt.pUnk = NULL;		// !!!

    // the format goes after the array
    CopyMemory(&px->crank[px->count], m_mtAccept.pbFormat, m_mtAccept.cbFormat);

    // finally, the array of which inputs are sources
    BOOL *pfSource = (BOOL *)((BYTE *)(&px->crank[px->count]) +
						m_mtAccept.cbFormat);
    for (i = 0; i < m_cInputs; i++){
	*(pfSource + i) = m_pInput[i]->m_fIsASource;
    }

    HRESULT hr = pStream->Write(px, savesize, 0);
    QzTaskMemFree(px);
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("*** WriteToStream FAILED")));
        return hr;
    }


}
#endif


//
// JoinFiltergraph
//
// OK.  It's illegal for a worker thread of a filter to take a refcount on the
// graph, but our worker thread needs to use the graph builder to do dynamic
// graph building.  So we take a non-addref'd copy of a pointer here, and just
// use it later.  We know this won't fault, because before the graph can go
// away, our filter has to be stopped, which will kill the thread that's going
// to use this pointer.
//      So never use this pointer except by the worker thread, and never let the
// filter stream when not in a graph, and you'll be OK.
//
STDMETHODIMP CBigSwitch::JoinFilterGraph(IFilterGraph *pfg, LPCWSTR lpcw)
{
    if (pfg) {
        HRESULT hr = pfg->QueryInterface(IID_IGraphBuilder, (void **)&m_pGBNoRef);
        if (FAILED(hr))
            return hr;
        m_pGBNoRef->Release();
    }

    return CBaseFilter::JoinFilterGraph(pfg, lpcw);
}


//
// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CBigSwitch::Pause()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Pause")));

    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = S_OK;

    // we can't work outside of a graph - dynamic graph building assumes it
    // (see JoinFilterGraph)
    if (m_pGraph == NULL)
        return E_UNEXPECTED;

    if (m_State == State_Stopped) {

#ifdef DEBUG
    m_nSkippedTotal = 0;
#endif

	// every time we stream, reset EOS and delivered count
        m_llFramesDelivered = 0;
	m_fEOS = FALSE;

	m_rtCurrent = m_rtLastSeek;
	m_fDiscon = FALSE;	// start over, no discon
	m_nLastInpin = -1;
        m_cStaleData = 0;

        // reset our number so we don't start off being late
        //
        m_qLastLate = 0;

        hr = IsEverythingConnectedRight();
        if (hr != S_OK) {
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*Can't stream: not connected right %x"),
								hr));
	    return hr;
        }

        if( IsDynamic( ) )
        {

            // we may need to know which switch we share sources with.  Switch
            // for group 0 may be responsible for building things for switch 1
            // too.
            // This assumes only group 0 and 1 can share!
            // find out NOW while there are still hardly any filters in the
            // graph (best perf)
            if (!m_pShareSwitch && m_nGroupNumber == 0) {
                FindShareSwitch(&m_pShareSwitch);
            }

            if (!m_pGraphConfig) {
                if (SUCCEEDED(m_pGraph->QueryInterface(IID_IGraphConfig,
						(void **) &m_pGraphConfig))) {
                    m_pGraphConfig->Release(); // don't keep refcount
                }
            }

	    // pull in the initial sources on this higher priority thread now?
	    // NO! NO!  Doing dynamic connections during Pause will deadlock
	    // DoDynamicStuff(m_rtCurrent);

            if (m_pFilterLoad) {
    	        m_hEventThread = CreateEvent(NULL, FALSE, FALSE, NULL);
    	        if (m_hEventThread == NULL) {
		    return E_OUTOFMEMORY;
	        }
                // start the background loading thread....
                if (m_worker.Create(this)) {
                    m_worker.Run();
	        }
            }
	}

        hr = m_pPoolAllocator->Commit();
        if (FAILED(hr))
	    return hr;

        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Pause  done with preparations")));
        // if there's nothing for this switch to do (like in a smart recomp
        // graph where no smart recompression can be done), then we need to send
        // EOS RIGHT NOW! or we hang.

        BOOL fEmpty = TRUE;
        for (int z = 0; z < m_cInputs; z++) {
            CRANK *p = m_pInput[z]->m_pCrankHead;
	    if (p) {
	        fEmpty = FALSE;
	    }
        }
        if (fEmpty) {
	    AllDone();
        }

	// we're never going to send anything.  Send an EOS or we'll hang!
	if (m_rtCurrent >= m_rtProjectLength) {
	    AllDone();
	}

	// pass on the NewSeg before things get started. It may not have
	// been sent yet since the last time we were seeked
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Switch:Send NewSeg=%dms"),
				(int)(m_rtLastSeek / 10000)));
        for (int i = 0; i < m_cOutputs; i++) {
	    m_pOutput[i]->DeliverNewSegment(m_rtLastSeek, m_rtStop, 1.0);
        }
    }
	
    return CBaseFilter::Pause();
}


STDMETHODIMP CBigSwitch::Stop()
{
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitch::Stop")));

    CAutoLock cObjectLock(m_pLock);

    m_pPoolAllocator->Decommit();

    // Do we need to unload the dynamic sources?  No, let's keep them around
    // so the graph can start up quickly again

    if (IsDynamic()) {
	m_worker.m_rt = -1;		// thread looks at this when woken up
        SetEvent(m_hEventThread);	// wake the thread up so it dies quickly
        m_worker.Stop();
        m_worker.Exit();
        m_worker.Close();
        if (m_hEventThread) {
	    CloseHandle(m_hEventThread);
            m_hEventThread = NULL;
        }
    }

    HRESULT hr = CBaseFilter::Stop();

    // Dexter has cyclic graphs, and the filter attached to the inpins may get
    // stopped before the filters attached to our outpins, since they are
    // equal distance from the renderer.  That will hang us, so since we
    // can't make the DXT on our outpin get stopped first, we need to flush it
    // now that we've stopped any further delivers.  This will get around the
    // problem of our filters not being stopped in the right order
    for (int z = 0; z < m_cOutputs; z++) {
        m_pOutput[z]->DeliverBeginFlush();
        m_pOutput[z]->DeliverEndFlush();
    }

    return hr;
}


HRESULT CBigSwitch::UnloadAll()
{
    FILTERLOADINFO *p = m_pFilterLoad;
    HRESULT hr = S_FALSE;
    while (p && SUCCEEDED(hr)) {
        if (p->fLoaded) {
                DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("unloading %ls"), p->bstrURL ?
					    p->bstrURL : L"<blank>"));
                hr = CallUnloadSource(p);
        }
        p = p->pNext;
    }
    m_cLoaded = 0;
    if (hr != S_FALSE) {
        // tell whoever cares that we did something
        NotifyEvent(EC_GRAPH_CHANGED,0,0);
    }
    return hr;
}


// Is it time to advance our internal clock?  Let's see what all the inputs are
// up to...
//

BOOL CBigSwitch::TimeToCrank()
{
    CAutoLock cObjectLock(&m_csCrank);

    // in the middle of a seek, cranking could send frames we're not supposed to
    if (m_fSeeking)
	return FALSE;

    int iReady = 0;
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// an unconnected pin is ready
	if (pPin->IsConnected() == FALSE) {
	    if (IsDynamic()) {
                BOOL fShouldBeConnectedNow = FALSE;
	        if (pPin->OutpinFromTime(m_rtCurrent) != -1)
		    fShouldBeConnectedNow = TRUE;
                if (fShouldBeConnectedNow) {
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d UNC, waiting for connect"), z));
                } else {
		    iReady++;
		}
	    } else {
                //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d unconnected, not needed"), z));
                iReady++;
            }
	
        // a pin at EOS is ready
        } else if (pPin->m_fEOS) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d EOS"), z));
	    iReady++;
	
        // a pin that is blocked waiting for time to pass is ready
        } else if (pPin->m_rtBlock >= 0) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d blocked"), z));
	    iReady++;
	// a pin that has already delivered at this current time is ready
	// if it isn't a source (no data is being pushed to it)
        } else if (!pPin->m_fIsASource && pPin->m_rtLastDelivered >= m_rtNext) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d done"), z));
	    iReady++;
	// since this is a source, we're waiting for more data to be pushed
        } else if (pPin->m_fIsASource && pPin->m_rtLastDelivered >= m_rtNext) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d done/wait"), z));
	// this pin is NOT ready
	// a recursive pin that is not supposed to deliver anything for a while
        } else if (!pPin->m_fIsASource && pPin->OutpinFromTime(m_rtCurrent) == -1) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d unused"), z));
	    iReady++;
	// a pin that is never needed again
	} else if (pPin->OutpinFromTime(m_rtCurrent) == -1 &&
			pPin->NextOutpinFromTime(m_rtCurrent, NULL) == -1) {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d not needed anymore"), z));
	    iReady++;
	} else {
    	    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("? %d waiting..."), z));
        }
    }
    // If all pins are ready, then we are ready!
    return (iReady == m_cInputs);
}


HRESULT CBigSwitch::Crank()
{
    CAutoLock cObjectLock(&m_csCrank);

    REFERENCE_TIME rt = CrankTime();
    return ActualCrank(rt);
}


REFERENCE_TIME CBigSwitch::CrankTime()
{
    CAutoLock cObjectLock(&m_csCrank);

    // to handle intermittent data of different types,
    // I'm going to crank to the next available time, not up a fixed amount
    REFERENCE_TIME rt = MAX_TIME, rtT;
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// some pins are blocked just to keep from wasting time, but don't go
	// anywhere
	if (pPin->m_rtBlock >= 0 && pPin->OutpinFromTime(pPin->m_rtBlock) >= 0){
	    if (pPin->m_rtBlock > m_rtCurrent && pPin->m_rtBlock < rt)
	        rt = pPin->m_rtBlock;
        // if it's at EOS, we won't get more data so waiting for any will hang
	} else if (pPin->m_fIsASource && pPin->OutpinFromTime(m_rtCurrent)== -1
			&& pPin->NextOutpinFromTime(m_rtCurrent, &rtT) >= 0 &&
                        pPin->m_fEOS == FALSE) {
	    if (rtT < rt)
		rt = rtT;
	}
    }
    return rt;
}


// when is the next time any pin has anything to do?
//
REFERENCE_TIME CBigSwitch::NextInterestingTime(REFERENCE_TIME rtNow)
{
    CAutoLock cObjectLock(&m_csCrank);

    REFERENCE_TIME rt = MAX_TIME, rtT;
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// this pin has something to do now
	if (pPin->m_fIsASource && pPin->OutpinFromTime(rtNow) >= 0) {
	    rt = rtNow;
	    break;
	// this pin will have something to do in the future
	} else if (pPin->m_fIsASource && pPin->OutpinFromTime(rtNow)== -1
			&& pPin->NextOutpinFromTime(rtNow, &rtT) >= 0) {
	    if (rtT < rt) {
	        rt = rtT;
	    }
	}
    }
    return rt;
}

// advance our internal clock
//
HRESULT CBigSwitch::ActualCrank(REFERENCE_TIME rt)
{
    CAutoLock cObjectLock(&m_csCrank);

    // are we cranking further than 1 frame ahead? That would be a discontinuity
    if (rt > m_rtCurrent + (REFERENCE_TIME)(UNITS / m_dFrameRate * 1.5)) {
	// NO! smart recompression of ASF thinks every frame is a discont, and
	// refuses to use smart recompression
	// m_fDiscon = TRUE;
    }

    m_rtCurrent = rt;
    DWORDLONG dwl = Time2Frame(m_rtCurrent, m_dFrameRate);
    m_rtNext = Frame2Time(dwl + 1, m_dFrameRate);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CRANK to %dms"), (int)(m_rtCurrent / 10000)));

    // If a pin was waiting until this time to unblock, then unblock it now
    for (int z = 0; z < m_cInputs; z++) {
        CBigSwitchInputPin *pPin = m_pInput[z];
	// the unblock time is before Next, and this pin is connected
	// to a valid output then, so unblock it!
	if (pPin->m_rtBlock >= 0 && pPin->m_rtBlock < m_rtNext &&
				pPin->OutpinFromTime(pPin->m_rtBlock) >= 0) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Unblocking %d"), z));
	    pPin->m_rtBlock = -1;
	    SetEvent(pPin->m_hEventBlock);
	}
    }

    // If all inputs are at EOS, we're all done!  Yay!
    // If all inputs are blocked or at EOS, we're in trouble! (unless we're doing
    //     dynamic reconnection - then we could still be saved)
    int iEOS = 0, iBlock = 0;
    for (z = 0; z < m_cInputs; z++) {
	if (m_pInput[z]->m_fEOS)
	    iEOS++;
	else if (m_pInput[z]->m_rtBlock >= 0)
	    iBlock++;
    }

    if (iEOS == m_cInputs) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** ALL INPUTS AT EOS!")));
	m_rtCurrent = m_rtProjectLength;
    } else if (iEOS + iBlock == m_cInputs && !m_fSeeking &&
					    m_rtCurrent < m_rtProjectLength)
    {
        if( !IsDynamic( ) )
        {
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** I AM HUNG!!!")));
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** I AM HUNG!!!")));
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** I AM HUNG!!!")));
 	    ASSERT(FALSE);
        }
    }

    // Are we completely finished yet?
    if (m_rtCurrent >= m_rtStop) {
	AllDone();
    }

    return NOERROR;
}


// All done.  Stop processing.
//
HRESULT CBigSwitch::AllDone()
{
    CAutoLock cObjectLock(&m_csCrank);

    // give the final renderer its EOS.
    if (!m_fEOS) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** ALL DONE!  Delivering EOS")));
        m_pOutput[0]->DeliverEndOfStream();
    }

    // !!! Fire all events... is this right?
    m_fEOS = TRUE;

    for (int z = 0; z < m_cInputs; z++) {
	SetEvent(m_pInput[z]->m_hEventBlock);
    }

#if 0 // infinite flush loop
    // there's no renderer to signal EC_COMPLETE (no sound card?) We better.
    if (m_pOutput[0]->m_Connected == NULL) {
        // NotifyEvent(EC_COMPLETE, S_OK, 0);   makes FG assert - not a rndrer
    }

    // Don't flush the main output?
    for (z = 0; z < m_cOutputs; z++) {
        m_pOutput[z]->DeliverBeginFlush();
        m_pOutput[z]->DeliverEndFlush();
    }
#endif
    return NOERROR;
}



HRESULT CBigSwitch::GetOutputBuffering(int *pnBuffer)
{
    CheckPointer( pnBuffer, E_POINTER );
    *pnBuffer = m_nOutputBuffering;
    return NOERROR;

}


HRESULT CBigSwitch::SetOutputBuffering(int nBuffer)
{
    // minimum 2, or we could hang.  If there's only 1, and the FRC is doing
    // a data copy to avoid giving the switch a read only buffer, the FRC has
    // a ref on the only pool buffer.   Then it goes through a DXT and another
    // switch input needs a pool buffer, because it's own buffer is still
    // addrefed by the output queue.  HANG.  If the FRC doesn't call GetBuffer
    // twice we don't have this problem
    if (nBuffer <=1)
	return E_INVALIDARG;
    m_nOutputBuffering = nBuffer;
    return NOERROR;
}

// merge some new skews into the existing ones sorted by timeline time
// !!! should signal error if skew ranges overlap in timeline time, but I know
// that won't happen (?)
// NOTE: MergeSkews operates on ONE source, by the pointer "p"
//
STDMETHODIMP CBigSwitch::MergeSkews(FILTERLOADINFO *p, int cSkew, STARTSTOPSKEW *pSkew)
{
    // calculate the total amount of skews we MIGHT need (we may merge some)
    int cTotal = p->cSkew + cSkew;

    // how many of the new skews have 0 rates in them? These are just "stop extenders" and won't
    // add another skew to our list. Shorten our cTotal by that many
    for( int i = 0 ; i < cSkew ; i++ )
    {
        if( pSkew[i].dRate == 0.0 )
        {
            cTotal--;
        }
    }

    STARTSTOPSKEW *pNew = (STARTSTOPSKEW *)CoTaskMemAlloc(cTotal *
					sizeof(STARTSTOPSKEW));
    if (pNew == NULL)
    {
	return E_OUTOFMEMORY;
    }

    int OldIndex = 0;
    int NewIndex = 0;

    int z = 0;
    while( 1 )
    {
        STARTSTOPSKEW * pOldUnit = &p->pSkew[OldIndex];
        STARTSTOPSKEW * pNewUnit = &pSkew[NewIndex];

        if( OldIndex < p->cSkew && NewIndex < cSkew )
        {
            REFERENCE_TIME OldTLStart = SkewTimelineStart( pOldUnit );
            REFERENCE_TIME NewTLStart = SkewTimelineStart( pNewUnit );

            if( OldTLStart < NewTLStart )
            {
                ASSERT( z < cTotal );
                pNew[z++] = *pOldUnit;
                OldIndex++;
            }
            else
            {
                if( pNewUnit->dRate == 0.0 )
                {
                    // adjust the rate of the old one
                    //
                    ASSERT( z > 0 );
                    pNew[z-1].rtStop = pNewUnit->rtStop;
                }
                else
                {
                    ASSERT( z < cTotal );
                    pNew[z++] = *pNewUnit;
                }
                NewIndex++;
            }
        }
        else if( OldIndex < p->cSkew )
        {
            ASSERT( z < cTotal );
            pNew[z++] = *pOldUnit;
            OldIndex++;
        }
        else if( NewIndex < cSkew )
        {
            if( pNewUnit->dRate == 0.0 )
            {
                // adjust the rate of the old one
                //
                ASSERT( z > 0 );
                pNew[z-1].rtStop = pNewUnit->rtStop;
            }
            else
            {
                ASSERT( z < cTotal );
                pNew[z++] = *pNewUnit;
            }
            NewIndex++;
        }
        else
        {
            break;
        }
    }

    // free up the old array
    if (p->cSkew)
    {
        CoTaskMemFree(p->pSkew);
    }

    p->pSkew = pNew;
    p->cSkew = cTotal;

    return S_OK;
}

STDMETHODIMP CBigSwitch::SetDynamicReconnectLevel(long Level)
{
/*
    if (m_cInputs > 0) {
	return E_UNEXPECTED;
    }
*/
    m_nDynaFlags = Level;
    return S_OK;
}


STDMETHODIMP CBigSwitch::GetDynamicReconnectLevel(long *pLevel)
{
    CheckPointer(pLevel, E_POINTER);
    *pLevel = m_nDynaFlags;
    return S_OK;
}

// this is really asking us, ARE YOUR SOURCES DYNAMIC?
// (because that's all we do right now, this is a useless function)
BOOL CBigSwitch::IsDynamic()
{
    if( m_nDynaFlags & CONNECTF_DYNAMIC_SOURCES )
        return TRUE;
    return FALSE;
}


// dynamic graph stuff. AddSourceToConnect is CURRENTLY called for each
// source (real and not) one skew at a time
//
STDMETHODIMP CBigSwitch::AddSourceToConnect(BSTR bstrURL, const GUID *pGuid,
			       int nStretchMode,
			       long lStreamNumber,
			       double SourceFPS,
                               int cSkew, STARTSTOPSKEW *pSkew,
                               long lInputPin,
                               BOOL fShare,             // sharing
                               long lShareInputPin,     //
                               AM_MEDIA_TYPE mtShare,   //
                               double dShareFPS,        //
			       IPropertySetter *pSetter)
{
    if( !IsDynamic( ) )
    {
        return E_NOTIMPL;
    }

    HRESULT hr;
    if (m_cInputs <= lInputPin)
	return E_INVALIDARG;

    CAutoLock lock(&m_csFilterLoad);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Switch:AddSourceToConnect...")));

    FILTERLOADINFO *p = m_pFilterLoad, *pNew, *pP = NULL;

    // is this source going to the same pin as a previous source?  Every
    // attribute better match, or that's illegal!  If so, we can re-use this
    // source for multiple skews that don't overlap
    //
    while (p) {
	if (p->lInputPin == lInputPin) {
            // we're being told to make 2 branches of the source at once
            if (fShare == TRUE) {
                DbgLog((LOG_TRACE,1,TEXT("SHARING: this SRC is shared with another switch")));
                // better not be sharing and re-using at the same time
                ASSERT(p->cSkew == 1);
                ASSERT(cSkew == 1);
                p->fShare = TRUE;
                p->lShareInputPin = lShareInputPin;
                CopyMediaType(&p->mtShare, &mtShare);
                p->dShareFPS = dShareFPS;
                p->nShareStretchMode = nStretchMode;
                p->lShareStreamNumber = lStreamNumber;
                // !!! I don't triple check that skew/name/etc. all matches
                return S_OK;
            } else if (p->nStretchMode == nStretchMode &&
			p->lStreamNumber == lStreamNumber &&
			p->dSourceFPS == SourceFPS) {
		if (hr = MergeSkews(p, cSkew, pSkew) != S_OK) {
    		    DbgLog((LOG_ERROR,1,TEXT("*** ERROR: Merging skews")));
		    return hr;
		}
    		SetDirty(TRUE);
    		return S_OK;
	    } else {
    		DbgLog((LOG_ERROR,1,TEXT("*** ERROR: RE-USE source doesn't match!")));
		return E_INVALIDARG;
	    }
	}
	p = p->pNext;
    }

    p = m_pFilterLoad;

    pNew = new FILTERLOADINFO;
    if (pNew == NULL)
	return E_OUTOFMEMORY;
    ZeroMemory(pNew, sizeof(FILTERLOADINFO));    // zero out sharing bits

    // !!! insert into our linked list sorted by the earliest time needed.

    // find the place to insert it
    //
    while (p && p->pSkew->rtStart + p->pSkew->rtSkew <
					pSkew->rtStart + pSkew->rtSkew)
    {
	pP = p;
	p = p->pNext;
    }

    // allocate some space for the string
    //
    pNew->bstrURL = SysAllocString(bstrURL);
    if (bstrURL && pNew->bstrURL == NULL) {
	delete pNew;
	return E_OUTOFMEMORY;
    }

    // set the props on the new struct. This struct will define
    // what sources we want to load and at what time
    //
    if (pGuid)
        pNew->GUID = *pGuid;
    else
        pNew->GUID = GUID_NULL;
    pNew->nStretchMode = nStretchMode;
    pNew->lStreamNumber = lStreamNumber;
    pNew->dSourceFPS = SourceFPS;
    pNew->cSkew = cSkew;
    pNew->pSkew = (STARTSTOPSKEW *)CoTaskMemAlloc(cSkew *
						sizeof(STARTSTOPSKEW));
    if (pNew->pSkew == NULL) {
	SysFreeString(pNew->bstrURL);
	delete pNew;
	return E_OUTOFMEMORY;
    }
    CopyMemory(pNew->pSkew, pSkew, cSkew * sizeof(STARTSTOPSKEW));
    pNew->lInputPin = lInputPin;
    pNew->fLoaded = FALSE;
    pNew->pSetter = pSetter;
    if (pSetter) pSetter->AddRef();

    // inject the new struct in the linked list
    //
    pNew->pNext = p;
    if (pP == NULL)
        m_pFilterLoad = pNew;
    else
        pP->pNext = pNew;

    // make sure we know this is a source
    //
    InputIsASource(lInputPin, TRUE);

    SetDirty(TRUE);

    return S_OK;
}


// !!! David, why is this never called?
//
STDMETHODIMP CBigSwitch::Reconfigure(PVOID pvContext, DWORD dwFlags)
{
    FILTERLOADINFO *pInfo = (FILTERLOADINFO *) pvContext;

    DbgLog((LOG_TRACE, TRACE_LOW,  TEXT("CBigSwitch::Reconfigure")));

    if (dwFlags & 1) {
        return LoadSource(pInfo);
    } else {
        return UnloadSource(pInfo);
    }
}

HRESULT CBigSwitch::CallLoadSource(FILTERLOADINFO *pInfo)
{
    if (!m_pGraphConfig) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST, TEXT("No IGraphConfig, calling immediately")));

        return LoadSource(pInfo);
    }

    DbgLog((LOG_TRACE, TRACE_LOW,  TEXT("calling LoadSource through IGraphConfig::Reconfigure")));
    return m_pGraphConfig->Reconfigure(this, pInfo, 1, m_worker.GetRequestHandle());
}

HRESULT CBigSwitch::CallUnloadSource(FILTERLOADINFO *pInfo)
{
    if (!m_pGraphConfig) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("No IGraphConfig, calling UnloadSource immediately")));
        return UnloadSource(pInfo);
    }

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("calling UnloadSource through IGraphConfig::Reconfigure")));
    return m_pGraphConfig->Reconfigure(this, pInfo, 0, m_worker.GetRequestHandle());
}

HRESULT CBigSwitch::LoadSource(FILTERLOADINFO *pInfo)
{

#ifdef DEBUG
    LONG lTime = timeGetTime();
#endif

    HRESULT hr = S_OK;

    IPin *pSwitchIn = m_pInput[pInfo->lInputPin];

    // is this a real source, or black/silence?
    BOOL fSource = TRUE;
    if ((pInfo->bstrURL == NULL || lstrlenW(pInfo->bstrURL) == 1) &&
			pInfo->GUID == GUID_NULL)
	fSource = FALSE;


    CComPtr< IPin > pOutput;
    IBaseFilter *pDangly = NULL;
    hr = BuildSourcePart(
        m_pGBNoRef,
        fSource,
        pInfo->dSourceFPS,
	&m_mtAccept,
        m_dFrameRate,
	pInfo->lStreamNumber,
        pInfo->nStretchMode,
	pInfo->cSkew,
        pInfo->pSkew,
        this,
        pInfo->bstrURL,
        &pInfo->GUID,
	NULL,
	&pOutput,
        0,
        m_pDeadGraph,
        m_bIsCompressed,
        NULL,       // medloc filter strings
        0,          // medloc flags
        NULL,       // medloc chain callback
	pInfo->pSetter,	// props for the source
        &pDangly);      // NOT ADDREF'D revived this extra chain from the cache

    if (FAILED(hr)) {
	AllDone();	 // otherwise we could hang
	return hr;
    }

    // connect newly created source chain to the Switcher
    hr = m_pGBNoRef->Connect(pOutput, pSwitchIn);
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("DYN connect to switcher returned %x"), hr));

    // we need to connect up the other switch too, that we are sharing with
    //
    IPin *pShareSwitchIn = NULL;
    if (pInfo->fShare) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Need to connect shared src to another switch"), hr));
        IPin *pSplitPin;
        pSplitPin = FindOtherSplitterPin(pOutput, pInfo->mtShare.majortype,
                        pInfo->lShareStreamNumber);

        // we are going to use the extra dangly chain we revived, so we don't
        // have to worry about killing it
        CComPtr <IPin> pDIn;
        if (pSplitPin)
            pSplitPin->ConnectedTo(&pDIn);
        if (pDIn) {
            PIN_INFO pinfo;
            pDIn->QueryPinInfo(&pinfo);
            if (pinfo.pFilter) pinfo.pFilter->Release();
            // the chain we are going to build is the extra chain that was built
            if (pinfo.pFilter == pDangly) {
                pDangly = NULL;
                DbgLog((LOG_TRACE,1,TEXT("We are using the extra chain created by BuildSourcePart")));
            }
        }

        pOutput.Release();      // re-using it below
        if (SUCCEEDED(hr)) {
            hr = BuildSourcePart(
                m_pGBNoRef,
                fSource,
                0,                          // 0 if sharing
	        &pInfo->mtShare,            // shared one?
                pInfo->dShareFPS,           // shared one?
	        pInfo->lShareStreamNumber,  // shared one?
                pInfo->nShareStretchMode,   // shared one?
	        pInfo->cSkew,
                pInfo->pSkew,
                this,
                pInfo->bstrURL,
                &pInfo->GUID,
	        pSplitPin,                  // Use this share pin
	        &pOutput,
                0,
                m_pDeadGraph,
                FALSE,
                NULL,       // medloc filter strings
                0,          // medloc flags
                NULL,       // medloc chain callback
	        NULL, NULL);// props for the source
        }

        if (FAILED(hr)) {
	    AllDone();	 // otherwise we could hang
	    return hr;
        }

        // connect other branch to the other switcher

        // what happened to the other switcher?
        if (!m_pShareSwitch) {
            ASSERT(FALSE);
	    AllDone();	 // otherwise we could hang
	    return E_UNEXPECTED;
        }
        hr= m_pShareSwitch->GetInputPin(pInfo->lShareInputPin, &pShareSwitchIn);
        if (FAILED(hr)) {
            ASSERT(FALSE);
	    AllDone();	 // otherwise we could hang
	    return hr;
        }

        hr = m_pGBNoRef->Connect(pOutput, pShareSwitchIn);
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("DYN CONNECT shared src to other switch returned %x"),
                                                                 hr));
    }

    // making the source chain revived an extra appendage for a shared source
    // that is not going to be used... kill it
    if (pDangly) {
        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Need to KILL unused revived appendage")));
	IPin *pDIn = GetInPin(pDangly, 0);
	ASSERT(pDIn);
	CComPtr <IPin> pOut;
	hr = pDIn->ConnectedTo(&pOut);
	ASSERT(pOut);
	pDIn->Disconnect();
	pOut->Disconnect();
	RemoveDownstreamFromFilter(pDangly);
    }

    // put the new filters into the same state as the rest of the graph.
    if (m_State != State_Stopped) {

        // active hasn't been called yet on this pin, so we call it.
        hr = m_pInput[pInfo->lInputPin]->Active();
        ASSERT(SUCCEEDED(hr));

        // also call active on the shared switch pin, if it exists
        if (pInfo->fShare) {
            CBigSwitchInputPin *pSIn = NULL;
            pSIn = static_cast <CBigSwitchInputPin *>(pShareSwitchIn); // !!!
            ASSERT(pSIn);
            hr = pSIn->Active();
            ASSERT(SUCCEEDED(hr));
        }

        // if we're sharing a source, make sure it gets paused LAST, after
        // both chains are paused
        //
        if (SUCCEEDED(hr)) {
            // pause chain (don't pause start filter if there are 2 chains)
            hr = StartUpstreamFromPin(pSwitchIn, FALSE, !pInfo->fShare);
            ASSERT(SUCCEEDED(hr));

            // pause 2nd chain (including start filter)
            if (pInfo->fShare) {
                hr = StartUpstreamFromPin(pShareSwitchIn, FALSE, TRUE);
                ASSERT(SUCCEEDED(hr));
            }

            if (SUCCEEDED(hr) && m_State == State_Running) {
                // run chain (don't run start filter if there are 2 chains)
                hr = StartUpstreamFromPin(pSwitchIn, TRUE, !pInfo->fShare);
                ASSERT(SUCCEEDED(hr));

                if (pInfo->fShare) {
                    // run 2nd chain (including start filter)
                    hr = StartUpstreamFromPin(pShareSwitchIn, TRUE, TRUE);
                    ASSERT(SUCCEEDED(hr));
                }
            }
        }
    }
    if (pShareSwitchIn)
        pShareSwitchIn->Release();

    pInfo->fLoaded = TRUE; // !!! only if it worked?
    m_cLoaded++;

#ifdef DEBUG
    lTime = timeGetTime() - lTime;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("LoadSource %ls returning %x   (time = %d ms)"), pInfo->bstrURL, hr, lTime));
#endif

    return hr;
}


HRESULT CBigSwitch::UnloadSource(FILTERLOADINFO *pInfo)
{
#ifdef DEBUG
    LONG lTime = timeGetTime();
#endif
    HRESULT hr = S_OK;

    // somebody might have disconnected it on us already.  Even if it fails,
    // decrement our count
    pInfo->fLoaded = FALSE;
    m_cLoaded--;

    // which input pin is connected to this source
    IPin *pSwitchIn = m_pInput[pInfo->lInputPin];

    // Get the other switch's input pin that is sharing this source, if needed
    IPin *pShareIn = NULL;
    if (pInfo->fShare && m_pShareSwitch) {
        hr = m_pShareSwitch->GetInputPin(pInfo->lShareInputPin, &pShareIn);
        ASSERT(pShareIn);
    }

    if (m_State != State_Stopped) {

        if (m_State == State_Running) {

            // pause filters upstream of this pin (don't pause the first filter
            // in the chain yet if we're sharing the source - do it last)
            hr = StopUpstreamFromPin(pSwitchIn, TRUE, !pShareIn);
            ASSERT(SUCCEEDED(hr));

            if (pShareIn) {
                hr = StopUpstreamFromPin(pShareIn, TRUE, TRUE);
                ASSERT(SUCCEEDED(hr));
            }
        }

        // stop the filters prior to removal

        if (SUCCEEDED(hr)) {

            // first stop our own pin
            hr = m_pInput[pInfo->lInputPin]->Inactive();
            ASSERT(SUCCEEDED(hr));

            // now stop the shared pin
            if (pShareIn) {
                CBigSwitchInputPin *pSIn = NULL;
                pSIn = static_cast <CBigSwitchInputPin *>(pShareIn); // !!!
                ASSERT(pSIn);
                hr = pSIn->Inactive();
            }
        }

        // stop the chain (but not the source filter if it's shared)
        hr = StopUpstreamFromPin(pSwitchIn, FALSE, !pShareIn);
        ASSERT(SUCCEEDED(hr));

        // stop the shared chain (and the source filter)
        if (pShareIn) {
            hr = StopUpstreamFromPin(pShareIn, FALSE, TRUE);
            ASSERT(SUCCEEDED(hr));
        }
    }

    // now remove the chain(s) of source filters
    //
    hr = RemoveUpstreamFromPin(pSwitchIn);
    ASSERT(SUCCEEDED(hr));
    if (pShareIn) {
        hr = RemoveUpstreamFromPin(pShareIn);
        ASSERT(SUCCEEDED(hr));
        pShareIn->Release();
    }

#ifdef DEBUG
    lTime = timeGetTime() - lTime;
    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("UnloadSource %ls returning %x   (time = %d ms)"), pInfo->bstrURL, hr, lTime));
#endif

    return hr;
}

// constants defining how long to keep things loaded
#define UNLOAD_BEFORE_TIME      (30 * UNITS)    // unload if not needed until after 30 seconds
#define UNLOAD_AFTER_TIME       (5 * UNITS)     // unload if last used 5 seconds ago
//#define LOAD_BEFORE_TIME        (10 * UNITS)    // load if needed in next 10 seconds
#define LOAD_BEFORE_TIME        (5 * UNITS)    // load if needed in next 10 seconds
#define LOAD_AFTER_TIME         (0 * UNITS)     // load if needed before now

//
// never call this when not streaming
//
HRESULT CBigSwitch::DoDynamicStuff(REFERENCE_TIME rt)
{
    HRESULT hr = S_FALSE;

    if (rt < 0)
	return S_OK;

    CAutoLock lock(&m_csFilterLoad);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("DoDynamicStuff at %dms"), (int)(rt / 10000)));

    // could just use m_rtCurrent?

    // should we have a flag, or use rt == -1, to indicate "unload all"?

    // !!! currently this is called with the filter lock held, is this bad?

    if (rt == MAX_TIME) {
        DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("DoDynamicStuff(MAX_TIME), ignoring")));
        return S_OK;
    }

    // Even though it's time rt, if nothing is happening on any pins until time
    // rt + x + LOAD_BEFORE_TIME, we need to bring in the source for that NOW,
    // because we will be cranking straight to rt + x soon, so that source
    // really is needed! So let's figure out what time it really would be after
    // cranking... (but we can't actually crank, that will mess everything up
    // and it's going to magically crank itself later anyway)
    //
    REFERENCE_TIME rtOld = rt;
    rt = NextInterestingTime(rtOld);
    if (rt != rtOld) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("WILL BE CRANKING - DoDynamicStuff at %dms"),
							(int)(rt / 10000)));
    }

    // first, look for things to unload
    FILTERLOADINFO *p = m_pFilterLoad;

    while (p && SUCCEEDED(hr)) {

	// UNLOAD a source if there are >50 sources loaded and this one isn't
	// needed.  This is done mostly because you can't open >75 ICM codec
	// instances at the same time
        if (p->fLoaded && m_cLoaded > MAX_SOURCES_LOADED) {
	    // a source must not be needed for any of its segments in order
	    // to truly not be needed
	    int yy = 0;
            REFERENCE_TIME rtTLStart, rtTLStop, rtTLDur;
	    for (int zz=0; zz<p->cSkew; zz++) {
                // !!! pre-calculate this
	        rtTLDur = p->pSkew[zz].rtStop - p->pSkew[zz].rtStart;
	        rtTLDur = (REFERENCE_TIME)(rtTLDur / p->pSkew[zz].dRate);
                rtTLStart = p->pSkew[zz].rtStart + p->pSkew[zz].rtSkew;
                rtTLStop = rtTLStart + rtTLDur;
		if ( (rtTLStart > rt + UNLOAD_BEFORE_TIME ||
            		rtTLStop <= rt - UNLOAD_AFTER_TIME)) {
		    yy++;
		} else {
		    break;
		}
	    }
            if (yy == p->cSkew) {

                // DO NOT unload a shared source, unless the shared switch is
                // also done with it!
                DbgLog((LOG_TRACE,1,TEXT("Time to UNLOAD a src that's done")));
                BOOL fUnload = TRUE;
                if (p->fShare) {
                    fUnload = FALSE;
                    DbgLog((LOG_TRACE,1,TEXT("Src is SHARED.  Make sure th other switch is done with it too")));
                    CComPtr <IBigSwitcher> pSS;
                    hr = FindShareSwitch(&pSS);
                    if (hr == S_OK) {
                        REFERENCE_TIME rtS;
                        pSS->GetCurrentPosition(&rtS);  // other switch's pos
                        yy = 0;
                        for (int zz=0; zz<p->cSkew; zz++) {
		            if (rtTLStart > rtS + UNLOAD_BEFORE_TIME
                            || rtTLStop <= rtS - UNLOAD_AFTER_TIME) {
		                yy++;
		            } else {
		                break;
		            }
	                }
                        if (yy == p->cSkew) {
                            DbgLog((LOG_TRACE,1,TEXT("The other switch IS done with it")));
                            fUnload = TRUE;
                        } else {
                            DbgLog((LOG_TRACE,1,TEXT("The other switch is NOT done with it")));
                        }
                    }
                }
                if (fUnload) {
                    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("*** unloading %ls, not needed"),
				p->bstrURL ? p->bstrURL : L"<blank>"));
                    hr = CallUnloadSource(p);
                }
            }

	// If it's time (or about to be time) for this source to be used,
	// better connect it up now!
        } else if (!p->fLoaded) {
	    for (int zz=0; zz<p->cSkew; zz++) {
	        REFERENCE_TIME rtDur = p->pSkew[zz].rtStop -
						p->pSkew[zz].rtStart;
	        rtDur = (REFERENCE_TIME)(rtDur / p->pSkew[zz].dRate);
	        // fudge 1 ms so rounding error doesn't hang the app
                if (p->pSkew[zz].rtStart + p->pSkew[zz].rtSkew + rtDur +
			10000 > rt + LOAD_AFTER_TIME &&
			p->pSkew[zz].rtStart + p->pSkew[zz].rtSkew <
			(rt + LOAD_BEFORE_TIME)) {
                    DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("loading %ls used now or about to be used")
			, p->bstrURL ? p->bstrURL : L"<blank>"));
		    // If the app uses sources that are hidden (never
		    // visible at any time on the timeline), then the switch
		    // may be programmed to never use this input and we could
		    // avoid loading it. (The GRID should never let that happen)
                    hr = CallLoadSource(p);
		    break;	// please, only load it once! :-)
                }
	    }
        }

        p = p->pNext;
    }

    if (hr != S_FALSE) {
        // tell whoever cares that we did something
        NotifyEvent(EC_GRAPH_CHANGED,0,0);
    }


    return hr;
}





STDMETHODIMP CBigSwitch::SetCompressed( )
{
    m_bIsCompressed = TRUE;
    return NOERROR;
}

STDMETHODIMP CBigSwitch::ReValidateSourceRanges( long lInputPin, long cSkews, STARTSTOPSKEW * pInSkews )
{
    HRESULT hr;

    // don't bother
    //
    if( !IsDynamic( ) )
    {
        return E_NOTIMPL;
    }

    // don't bother
    //
    if (m_cInputs <= lInputPin)
    {
	return E_INVALIDARG;
    }

    // lock us up
    //
    CAutoLock lock(&m_csFilterLoad);

    FILTERLOADINFO * p = m_pFilterLoad;
    FILTERLOADINFO * pNew = NULL;
    FILTERLOADINFO * pP = NULL;

    // run each of our filterload infos
    //
    while (p)
    {
        // if pins don't match, continue
        //
        if( p->lInputPin != lInputPin )
        {
            p = p->pNext;
            continue;
        }

        // the internal list of skews is merged, but not combined, for every
        // source that we add on the timeline. We don't need to worry about
        // two merges being combined.

        // we need to go through the set skews, strip out any that don't have
        // some portion in the passed in pSkews, and intersect those that do

        // there's only 4 ways an internal skew can coincide with any ONE of
        // the input skews. An internal skew will NOT be able to span two input
        // skews, since

        STARTSTOPSKEW * pSkews = p->pSkew;

        long NewCount = p->cSkew;

        int i;

        for( i = 0 ; i < p->cSkew ; i++ )
        {
            REFERENCE_TIME Start = pSkews[i].rtStart;
            REFERENCE_TIME Stop = pSkews[i].rtStop;
            REFERENCE_TIME Skew = pSkews[i].rtSkew;
            Start += Skew;
            Stop += Skew;

            BOOL Found = FALSE;
            for( int j = 0 ; j < cSkews ; j++ )
            {

                REFERENCE_TIME InStart = pInSkews[j].rtStart;
                REFERENCE_TIME InStop = pInSkews[j].rtStop;

                REFERENCE_TIME Lesser = max( InStart, Start );
                REFERENCE_TIME Greater = min( InStop, Stop );
                if( Lesser < Greater )
                {
                    Found = TRUE;

                    BOOL Modified = FALSE;

                    if( InStart > Start )
                    {
                        Start = InStart;
                        Modified = TRUE;
                    }
                    if( InStop < Stop )
                    {
                        Stop = InStop;
                        Modified = TRUE;
                    }

                    if( Modified )
                    {
                        pSkews[i].rtStart = Start - Skew;
                        pSkews[i].rtStop = Stop - Skew;
                    }
                }

            }

            // if we didn't find it, invalidate it
            //
            if( !Found )
            {
                pSkews[i].rtStart = 0;
                pSkews[i].rtStop = 0;
                pSkews[i].dRate = 0;
                pSkews[i].rtSkew = 0;
                NewCount--;
            }

        }

    	SetDirty(TRUE);

        // copy over the old skews to a new array
        //
        STARTSTOPSKEW * pNew = (STARTSTOPSKEW*) CoTaskMemAlloc( NewCount * sizeof(STARTSTOPSKEW) );
        if (pNew == NULL)
        {
	    return E_OUTOFMEMORY;
        }

        int j = 0;

        for( i = 0 ; i < NewCount ; i++ )
        {
            while( pSkews[j].dRate == 0  && j < p->cSkew )
            {
                j++;
            }

            pNew[i] = pSkews[j];
            j++;
        }

        CoTaskMemFree( p->pSkew );

        p->pSkew = pNew;
        p->cSkew = NewCount;

        // there shouldn't be any others in the list that match our input pin!
        //
        return NOERROR;

    } // while p

    return S_OK;
}

STDMETHODIMP CBigSwitch::SetDeadGraph( IDeadGraph * pCache )
{
    // don't hold a refcount. Render Engine will always be calling us,
    // not the other way around
    //
    m_pDeadGraph = pCache;

    return NOERROR;
}

STDMETHODIMP CBigSwitch::FlushOutput( )
{
    // !!! don't do this, too risky!
    return 0;

    DbgLog((LOG_TRACE, TRACE_MEDIUM, "Flushing the output pin!" ));
    m_pOutput[0]->DeliverBeginFlush( );
    m_pOutput[0]->DeliverEndFlush( );
    return 0;
}


// we are group 0.  Find the switch that is group 1
//
STDMETHODIMP CBigSwitch::FindShareSwitch(IBigSwitcher **ppSwitch)
{
    DbgLog((LOG_TRACE,1,TEXT("Find the other Switch we share sources with")));

    CheckPointer(ppSwitch, E_POINTER);
    if (m_pShareSwitch) {
        *ppSwitch = m_pShareSwitch;
        m_pShareSwitch->AddRef();
        return S_OK;
    }

    if (!IsDynamic())
        return E_UNEXPECTED;
    if (m_nGroupNumber != 0)
        return E_UNEXPECTED;
    if (!m_pGraph)
        return E_UNEXPECTED;

    // walk the graph for group 0
    CComPtr< IEnumFilters > pEnumFilters;
    m_pGraph->EnumFilters( &pEnumFilters );
    ULONG Fetched = 0;
    if (pEnumFilters) {
        while (1) {
            CComPtr< IBaseFilter > pFilter;
            Fetched = 0;
            pEnumFilters->Next( 1, &pFilter, &Fetched );
            if (!Fetched) {
                break;
            }
            CComQIPtr <IBigSwitcher, &IID_IBigSwitcher> pBigS(pFilter);
            if (pBigS) {
                int n = -1;
                pBigS->GetGroupNumber(&n);
                if (n == 1) {
                    *ppSwitch = pBigS;
                    (*ppSwitch)->AddRef();
                    DbgLog((LOG_TRACE,1,TEXT("Found it!")));
                    return S_OK;
                }
            }
        }
    } // if enum filters
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\switch\inpin.cpp ===
//depot/private/Lab06_DEV/MultiMedia/dshow/filterus/dexter/switch/inpin.cpp#5 - edit change 27342 (text)
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"
#include "..\util\perf_defs.h"

const int TRACE_EXTREME = 0;
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

// ================================================================
// CBigSwitchInputPin constructor
// ================================================================

CBigSwitchInputPin::CBigSwitchInputPin(TCHAR *pName,
                           CBigSwitch *pSwitch,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pSwitch, pSwitch, phr, pPinName),
    m_pSwitch(pSwitch),
    m_cbBuffer(0),
    m_cBuffers(0),
    m_pAllocator(NULL),
    m_hEventBlock(NULL),
    m_hEventSeek(NULL),
    m_rtBlock(-1),
    m_fEOS(FALSE),
    m_fInNewSegment(FALSE), // in the middle of NewSegment
    m_rtLastDelivered(0),	// last time stamp we delivered
    m_fIsASource(FALSE),	// by default, not a source
    m_fStaleData(FALSE),	// otherwise not init until connected - BAD
    m_pCrankHead(NULL),	    // our connection array
    m_fActive(false)
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("::CBigSwitchInputPin")));
    ASSERT(pSwitch);

    // !!! We have to know this already!
    if( pSwitch->IsDynamic( ) )
    {
        SetReconnectWhenActive(TRUE);
    }
}


//
// CBigSwitchInputPin destructor
//
CBigSwitchInputPin::~CBigSwitchInputPin()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("::~CBigSwitchInputPin")));

    // !!! Reset should have been called by now....
    ASSERT(!m_pCrankHead);

    ASSERT(!m_fActive);         // filter should be stopped when destroyed
}

// overridden to allow cyclic-looking graphs - we say that we aren't actually
// connected to anybody
//
STDMETHODIMP CBigSwitchInputPin::QueryInternalConnections(IPin **apPin, ULONG *nPin)
{
    DbgLog((LOG_TRACE,99,TEXT("CBigSwitchIn::QueryInteralConnections")));
    CheckPointer(nPin, E_POINTER);
    *nPin = 0;
    return S_OK;
}


// !!! what about non-format fields?
//
// CheckMediaType - only allow the type we're supposed to allow
//
HRESULT CBigSwitchInputPin::CheckMediaType(const CMediaType *pmt)
{
    DbgLog((LOG_TRACE, TRACE_LOWEST, TEXT("CBigSwitchIn[%d]::CheckMT"), m_iInpin));

    CAutoLock lock_it(m_pLock);
    CMediaType mtAccept(m_pSwitch->m_mtAccept);

    if (IsEqualGUID(*pmt->Type(), *mtAccept.Type())) {
        if (IsEqualGUID(*pmt->Subtype(), *mtAccept.Subtype())) {
	    if (*pmt->FormatType() == *mtAccept.FormatType()) {
	        if (pmt->FormatLength() >= mtAccept.FormatLength()) {

		    // !!! video formats will NOT match exactly
        	    if (IsEqualGUID(*pmt->FormatType(), FORMAT_VideoInfo)) {
			LPBITMAPINFOHEADER lpbi = HEADER((VIDEOINFOHEADER *)
							pmt->Format());
			LPBITMAPINFOHEADER lpbiAccept =HEADER((VIDEOINFOHEADER*)
							mtAccept.Format());
			if ((lpbi->biCompression == lpbiAccept->biCompression)
				&& (lpbi->biBitCount == lpbiAccept->biBitCount))
		    	    return S_OK;
			// colour converter gives 555 as bitfields!
			if (lpbi->biCompression == BI_BITFIELDS &&
				lpbiAccept->biCompression == BI_RGB &&
				lpbi->biBitCount == lpbiAccept->biBitCount &&
				*pmt->Subtype() == MEDIASUBTYPE_RGB555)
			    return S_OK;

		    // will other formats match exactly?
        	    } else {
		        LPBYTE lp1 = pmt->Format();
		        LPBYTE lp2 = mtAccept.Format();
		        if (memcmp(lp1, lp2, mtAccept.FormatLength()) == 0)
		            return S_OK;
		    }
		}
                else
                {
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchInputPin::CheckMediaType, format lengths didn't match")));
                }
	    }
        }
    }
    return VFW_E_INVALIDMEDIATYPE;

} // CheckMediaType


//
// GetMediaType - return the type we accept
//
HRESULT CBigSwitchInputPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition != 0)
        return VFW_S_NO_MORE_ITEMS;

    CopyMediaType(pMediaType, &m_pSwitch->m_mtAccept);

    return S_OK;

} // GetMediaType



//
// BreakConnect
//
HRESULT CBigSwitchInputPin::BreakConnect()
{
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::BreakConnect"), m_iInpin));

    // !!!
    // Release any allocator that we are holding
    if (m_pAllocator)
    {
        m_pAllocator->Release();
        m_pAllocator = NULL;
    }
    return CBaseInputPin::BreakConnect();
} // BreakConnect

HRESULT CBigSwitchInputPin::Disconnect()
{
    CAutoLock l(m_pLock);
    return DisconnectInternal();
}



// for efficiency, our input pins use their own allocators
//
STDMETHODIMP CBigSwitchInputPin::GetAllocator(IMemAllocator **ppAllocator)
{

    CheckPointer(ppAllocator,E_POINTER);
    ValidateReadWritePtr(ppAllocator,sizeof(IMemAllocator *));
    CAutoLock cObjectLock(m_pLock);

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: GetAllocator"), m_iInpin));

    if (m_pAllocator == NULL) {
	HRESULT hr = S_OK;

	/* Create the new allocator object */

	CBigSwitchInputAllocator *pMemObject = new CBigSwitchInputAllocator(
				NAME("Big switch input allocator"), NULL, &hr);
	if (pMemObject == NULL) {
	    return E_OUTOFMEMORY;
	}

	if (FAILED(hr)) {
	    ASSERT(pMemObject);
	    delete pMemObject;
	    return hr;
	}

        m_pAllocator = pMemObject;

        /*  We AddRef() our own allocator */
        m_pAllocator->AddRef();

	//remember pin using it
	((CBigSwitchInputAllocator *)m_pAllocator)->m_pSwitchPin = this;

        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Created a FAKE allocator")));
    }
    ASSERT(m_pAllocator != NULL);
    m_pAllocator->AddRef();
    *ppAllocator = m_pAllocator;

    return NOERROR;
}


// Make sure we use the maximum alignment and prefix required by any pin or
// we'll fault.
//
STDMETHODIMP
CBigSwitchInputPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    CheckPointer(pProps, E_POINTER);
    pProps->cbAlign = m_pSwitch->m_cbAlign;
    pProps->cbPrefix = m_pSwitch->m_cbPrefix;
    pProps->cbBuffer = m_pSwitch->m_cbBuffer;
    return S_OK;
}


//
// NotifyAllocator
//
STDMETHODIMP
CBigSwitchInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    IUnknown *p1, *p2;

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: NotifyAllocator"), m_iInpin));

    m_fOwnAllocator = FALSE;
    if (pAllocator->QueryInterface(IID_IUnknown, (void **)&p1) == S_OK) {
        if (m_pAllocator && m_pAllocator->QueryInterface(IID_IUnknown,
						(void **)&p2) == S_OK) {
	    if (p1 == p2)
		m_fOwnAllocator = TRUE;
	    p2->Release();
	}
	p1->Release();
    }

#ifdef DEBUG
    if (m_fOwnAllocator) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Using our own allocator")));
    } else {
        DbgLog((LOG_ERROR,2,TEXT("Using a FOREIGN allocator")));
    }
#endif

    HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
    if (SUCCEEDED(hr)) {
	ALLOCATOR_PROPERTIES prop;
	hr = pAllocator->GetProperties(&prop);
	if (SUCCEEDED(hr)) {
	    m_cBuffers = prop.cBuffers;
	    m_cbBuffer = prop.cbBuffer;

	    if (prop.cbAlign < m_pSwitch->m_cbAlign ||
				prop.cbPrefix < m_pSwitch->m_cbPrefix) {
		// !!! Nasty filters don't listen to our buffering requirement
		// so failing if cbBuffer is too small would prevent us from
		// connecting
                DbgLog((LOG_ERROR,1,TEXT("Allocator too small!")));
		return E_FAIL;
	    }

	    // update the maximum alignment and prefix needed
	    if (m_pSwitch->m_cbPrefix < prop.cbPrefix)
		m_pSwitch->m_cbPrefix = prop.cbPrefix;
	    if (m_pSwitch->m_cbAlign < prop.cbAlign)
		m_pSwitch->m_cbAlign = prop.cbAlign;
	    if (m_pSwitch->m_cbBuffer < prop.cbBuffer)
		m_pSwitch->m_cbBuffer = prop.cbBuffer;

            DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Allocator is using %d buffers, size %d"),
						prop.cBuffers, prop.cbBuffer));
            DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Prefix %d   Align %d"),
						prop.cbPrefix, prop.cbAlign));
	}
    }

    return hr;

} // NotifyAllocator

// If GetBuffer and Receive times don't match, we'll give a buffer from
// the WRONG ALLOCATOR and hang unless the switch is the allocator for
// downstream
// Luckily, we are the allocator
//
HRESULT CBigSwitchInputAllocator::GetBuffer(IMediaSample **ppBuffer,
                  	REFERENCE_TIME *pStartTime, REFERENCE_TIME *pEndTime,
			DWORD dwFlags)
{
    int nOutpin = -1;
    HRESULT hr;
    BOOL fSecretFlag = FALSE;

    // our Waits have to be protected, so Stop doesn't kill the event on us
    {
        CAutoLock cc(&m_pSwitchPin->m_csReceive);

        if (m_pSwitchPin->m_pSwitch->m_pOutput[0]->IsConnected() == FALSE) {
	    return VFW_E_NOT_CONNECTED;
        }

        // we're flushing... don't go blocking below!  Receive calls the base
        // class receive to catch this, but we have no equivalent
        if (m_pSwitchPin->m_bFlushing) {
	    return E_FAIL;
        }

#if 0
        // are we allowed to use our POOL buffers, even when R/O?
        if (dwFlags & SECRET_FLAG) {
            fSecretFlag = TRUE;
	    dwFlags -= SECRET_FLAG;
        }
#endif

        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::GetBuffer."),
						m_pSwitchPin->m_iInpin));

        // we're in the middle of seeking, and we're supposed to hold all input
        WaitForSingleObject(m_pSwitchPin->m_hEventSeek, INFINITE);

        // we're seeking... don't let FancyStuff we called or we'll crank and mess
        // up the flushing route
        if (m_pSwitchPin->m_pSwitch->m_fSeeking)
	    return E_FAIL;

        // this check needs to happen AFTER the wait for seek event, or a
        // surprise flush and new data will get thrown away
        if (m_pSwitchPin->m_pSwitch->m_fEOS) {
	    return E_FAIL;
        }

        // if we're dealing with compressed data, we may not get time stamps
        // in GetBuffer (we are not frame rate converting)
        BOOL fComp = (m_pSwitchPin->m_pSwitch->m_mtAccept.bTemporalCompression == TRUE);
        if (fComp || 1) {	// we are the allocator for our output pin connections.
	    goto JustGetIt; // No need to do this fancystuff
        }

#if 0
    REFERENCE_TIME rtStart, rtStop;
    ASSERT(pStartTime);
    if (pStartTime == NULL) {
	return E_INVALIDARG;
    }

    // figure out if we should block or not

    // add NewSegment offset
    rtStart = *pStartTime + m_pSwitchPin->m_tStart;
    rtStop = *pEndTime + m_pSwitchPin->m_tStart;

    // correct rounding errors (eg 1.9999 ==> 2)
    rtStart = Frame2Time(Time2Frame(rtStart, m_pSwitchPin->m_pSwitch->m_dFrameRate), m_pSwitchPin->m_pSwitch->m_dFrameRate);
    rtStop = Frame2Time(Time2Frame(rtStop, m_pSwitchPin->m_pSwitch->m_dFrameRate), m_pSwitchPin->m_pSwitch->m_dFrameRate);

    hr = m_pSwitchPin->FancyStuff(rtStart);

    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::GetBuffer blocking..."),
						m_pSwitchPin->m_iInpin));
    WaitForSingleObject(m_pSwitchPin->m_hEventBlock, INFINITE);
    ResetEvent(m_pSwitchPin->m_hEventBlock);

    // we're supposed to be all done.
    if (m_pSwitchPin->m_pSwitch->m_fEOS) {
	return E_FAIL;
    }
    // bother to check for flushing, too?

    nOutpin = m_pSwitchPin->OutpinFromTime(rtStart);
#endif

    }     // release the lock before blocking in GetBuffer, which will hang us

JustGetIt:
    if (nOutpin < 0 || m_pSwitchPin->m_pSwitch->
					m_pOutput[nOutpin]->m_fOwnAllocator) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::GetBuffer from us for pin %d"),
					m_pSwitchPin->m_iInpin, nOutpin));
	// For read only, we can't very well use random buffers from our pool
	if (m_pSwitchPin->m_bReadOnly && !fSecretFlag) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("R/O: Can't use POOL")));
             return CMemAllocator::GetBuffer(ppBuffer, pStartTime, pEndTime,
						dwFlags);
	} else {
            while (1) {
                hr = CMemAllocator::GetBuffer(ppBuffer, pStartTime, pEndTime,
						dwFlags | AM_GBF_NOWAIT);
	        if (hr == VFW_E_TIMEOUT) {
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("BUSY: Try POOL allocator")));
                    // this special allocator will timeout after 10ms
                    hr = m_pSwitchPin->m_pSwitch->m_pPoolAllocator->GetBuffer(
				    ppBuffer, pStartTime, pEndTime,
                                    dwFlags | AM_GBF_NOWAIT);
                    // give the original buffer another chance
                    if (hr == VFW_E_TIMEOUT) {
                        Sleep(10);
                        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("BUSY: Try private allocator again")));
                        continue;
                    }
                }
                break;
	    }
            return hr;
	}
    } else {
	ASSERT(FALSE);	// should never happen! we'll hang if we skipped calling
			// FancyStuff
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::GetBuffer from downstream of pin %d"),
					m_pSwitchPin->m_iInpin, nOutpin));
        return m_pSwitchPin->m_pSwitch->m_pOutput[nOutpin]->m_pAllocator->
			GetBuffer(ppBuffer, pStartTime, pEndTime, dwFlags);
    }
}


// go unstale
//
HRESULT CBigSwitchInputPin::Unstale()
{
    if (m_fStaleData) {
        m_fStaleData = FALSE;
        m_pSwitch->m_cStaleData--;

        // if nobody else is stale, then this is the last flush to come through
        // and it's FINALLY OK to let data be delivered by all our pins
        // if we do this earlier, somebody will deliver, and some other flush is
        // still coming that will screw up that data that got delivered
        if (m_pSwitch->m_cStaleData == 0) {

            // We might not have sent a NewSeg since our last seek. We were
            // waiting for the last flush for this, too
            if (!m_pSwitch->m_fNewSegSent) {
                DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Switch:Send NewSeg=%dms"),
				(int)(m_pSwitch->m_rtLastSeek / 10000)));
                for (int i = 0; i < m_pSwitch->m_cOutputs; i++) {
	            m_pSwitch->m_pOutput[i]->DeliverNewSegment(
			        m_pSwitch->m_rtLastSeek, m_pSwitch->m_rtStop, 1.0);
	        }
	        m_pSwitch->m_fNewSegSent = TRUE;
            }

	    // MUST COME AFTER NEW SEG delivered, or we'll deliver data before
	    // the new seg!  That would be bad...
            DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("NO MORE STALE DATA. Unblock")));
            for (int i = 0; i < m_pSwitch->m_cInputs; i++) {
	        SetEvent(m_pSwitch->m_pInput[i]->m_hEventSeek);
	    }

	}
    }
    return S_OK;
}


//
// BeginFlush
//
HRESULT CBigSwitchInputPin::BeginFlush()
{
    // no no no CAutoLock lock_it(m_pLock);

    // thanks, I gave at the office (a 2 input DXT sent us 2 of these)
    // !!! might hide a real bug?
    if (m_bFlushing)
	return S_OK;

    // sombody is flushing us when stopped.  BAD!  That will screw us up
    // (a dynamic source being created might do this)
    if (!m_fActive) {
        return S_OK;
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]:BeginFlush"),
								m_iInpin));

    if (!m_pSwitch->m_fSeeking && !m_fFlushAfterSeek && m_fIsASource) {
	// This flush came NOT inside a seek, and no seek has ever come before
	m_fFlushBeforeSeek = TRUE;
        DbgLog((LOG_TRACE,2,TEXT("Switch::FLUSH BEFORE SEEK!")));
    } else if (m_pSwitch->m_fSeeking) {
	// set by every seek.  The seek generated a flush, therefore, we are
	// NOT actually in the case where flushes don't come till after the seek
	m_fFlushAfterSeek = FALSE;
    }

    // first, make sure receives are failed
    HRESULT hr = CBaseInputPin::BeginFlush();

    // unblock receive
    SetEvent(m_hEventBlock);

    // only set this if we're being seeked, or we'll unblock when a bogus flush
    // comes from an audio parser pin when the video pin was seeked.  Receive
    // should never be blocked on this unless we're seeking, so this shouldn't
    // be necessary to unblock receive.
    // StaleData means we need to set this event anyway, we were blocked waiting
    // for THIS FLUSH.
    if (m_pSwitch->m_fSeeking || m_fStaleData) {
        SetEvent(m_hEventSeek);
    }

    // We need to flush ALL the outputs because we don't know which pin
    // we need to flush to unblock, (we may have cranked since then)
    // Flush the main output first to avoid hanging.

    // At least we won't flush if this isn't a source pin; that means we're
    // recursing

    if (m_fIsASource) {
	m_pSwitch->m_nLastInpin = -1;
        for (int z=0; z<m_pSwitch->m_cOutputs; z++) {
	    m_pSwitch->m_pOutput[z]->DeliverBeginFlush();
        }
    }

    // now that Receive is unblocked, and can't be entered, wait for it to
    // finish
    CAutoLock cc(&m_csReceive);

    return S_OK;
}


//
// EndFlush
//
HRESULT CBigSwitchInputPin::EndFlush()
{
    // no no no CAutoLock lock_it(m_pLock);

    // thanks, I gave at the office (a 2 input DXT sent us 2 of these)
    // !!! might hide a real bug?
    if (!m_bFlushing)
	return S_OK;

    DbgLog((LOG_TRACE,TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]:EndFlush"),m_iInpin));

    if (m_fIsASource) {
        for (int z=0; z<m_pSwitch->m_cOutputs; z++) {
	    m_pSwitch->m_pOutput[z]->DeliverEndFlush();
        }
    }

    // we're seeking, so every pin is flushing.  Until every other input is
    // flushed and ready, and we know our new current position, hold off all
    // input on this pin (or it will think new arriving data is from before
    // the seek)
    // Also, if we're stale, it's NOT OK to start delivering yet
    // Also, if this is a surprise flush, the push thread is going to start
    // delivering new data before we're ready, so hold it off!
    if (m_pSwitch->m_fSeeking || m_fStaleData || m_fFlushBeforeSeek) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Block this input until seek is done")));
	ResetEvent(m_hEventSeek);
    }

    // go unstale
    Unstale();

    ResetEvent(m_hEventBlock);

    // reset some stuff so we're ready to get data again
    m_rtBlock = -1;	// we're no longer blocked, or at EOS
    m_fEOS = FALSE;

    // bring this pin up to date to where we're going to start playing from
    if (m_pSwitch->m_fSeeking)
    	m_rtLastDelivered = m_pSwitch->m_rtSeekCurrent;//m_rtCurrent not set yet
    else
    	m_rtLastDelivered = m_pSwitch->m_rtCurrent;

    return CBaseInputPin::EndFlush();
}


//
// NewSegment - we remember the new segment we are given, but the one we
// broadcast is the timeline time we were last seeked to, because that's what
// we'll be sending next
//
HRESULT CBigSwitchInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop, double dRate)
{
    // no no no we'll hang CAutoLock lock_it(m_pLock);

#ifdef NOFLUSH
    // dont let this happen during a seek
    CAutoLock lock(&m_pSwitch->m_csNewSeg);
#endif

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]:NewSegment"), m_iInpin));

    // if this pin has last delivered, and we get a NewSegment, then
    // this is like a discontinuity.  We must notice this, because the
    // compressed switch sends a delta frame with no relation to the
    // previous frame in this situation
    if (m_pSwitch->m_nLastInpin == m_iInpin) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("NewSeg is a DISCONTINUITY")));
        m_pSwitch->m_fDiscon = TRUE;
    }

#if 0	// BAD! We get these before the seek sometime and we send the wrong # !
    // Don't recurse... don't send downstream if this isn't a SOURCE pin
    if (m_fIsASource && !m_pSwitch->m_fNewSegSent) {

        DbgLog((LOG_TRACE,TRACE_HIGHEST,TEXT("Switch:Send NewSeg=%dms"),
				(int)(m_pSwitch->m_rtLastSeek / 10000)));
        for (int i = 0; i < m_pSwitch->m_cOutputs; i++) {
	    m_pSwitch->m_pOutput[i]->DeliverNewSegment(m_pSwitch->m_rtLastSeek,
			m_pSwitch->m_rtStop, 1.0);
        }
        m_pSwitch->m_fNewSegSent = TRUE;
    }
#endif

    // remember the newsegment times we were given so we know the real time
    // of arriving data (it could be different for each input pin)
    HRESULT hr = CBaseInputPin::NewSegment(tStart, tStop, dRate);

#ifdef NOFLUSH
    m_fSawNewSeg = TRUE;  // yep, this is one

    // !!! defining NOFLUSH won't work until you fix this problem:
    // Here's the part not done yet.  Only if this is the NewSeg caused by
    // a seek that made this pin stale, do we Unstale.  We need a private msg
    // from the other switch to tell us before it passes SetPos upstream, so
    // we can take the NewSeg lock, and after, so we can release the lock and
    // go Unstale here
    // Unstale();  // go unstale
#endif

    return hr;
}

// just say yes, base class function is SLOW, and could infinite loop
//
HRESULT CBigSwitchInputPin::ReceiveCanBlock()
{
    return S_OK;
}


//
// Receive - send this sample to whoever gets it at this moment
//

// !!! IF Switch isn't using any allocator's, we need to COPY THE SAMPLE to
// !!! a buffer we get from downstream!

HRESULT CBigSwitchInputPin::Receive(IMediaSample *pSample)
{
    if (m_pSwitch->m_pOutput[0]->IsConnected() == FALSE) {
	return VFW_E_NOT_CONNECTED;
    }

    CAutoLock lock_it(&m_csReceive);

    // Check that all is well with the base class
    HRESULT hr = NOERROR;

    {

        hr = CBaseInputPin::Receive(pSample);
        if (hr != NOERROR) {
            DbgLog((LOG_ERROR,1,TEXT("CBigSwitchIn[%d]:Receive base class ERROR!"),
                                                                    m_iInpin));
            return hr;
        }

    }

    // we're in the middle of seeking, and we're supposed to hold all input
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::Receive seek block"),
								m_iInpin));
    WaitForSingleObject(m_hEventSeek, INFINITE);

    // our variables are in flux, we're seeking and this is an OLD sample
    if (m_pSwitch->m_fSeeking)
	return S_FALSE;

    // this check needs to happen AFTER the wait for seek event, or a
    // surprise flush and new data will get thrown away
    if (m_pSwitch->m_fEOS) {
        return S_FALSE;
    }

    // we were unblocked by a flush
    if (m_bFlushing) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("flushing, discard...")));
	return S_FALSE;
    }

    // add newsegment time to get the real timeline time of this sample
    REFERENCE_TIME rtStart, rtStop;
    hr = pSample->GetTime(&rtStart, &rtStop);
    if (hr != S_OK) {
	EndOfStream();
	return E_FAIL;
    }

    rtStart += m_tStart;	// add NewSegment offset
    rtStop += m_tStart;

    // correct rounding errors (eg. 1.9999==>2)
    rtStart = Frame2Time(Time2Frame(rtStart, m_pSwitch->m_dFrameRate), m_pSwitch->m_dFrameRate);
    rtStop = Frame2Time(Time2Frame(rtStop, m_pSwitch->m_dFrameRate), m_pSwitch->m_dFrameRate);

    // Fix the time stamps if our new segment is higher than the filters'.
    // EG: We're seeking to timeline time 10, but this input doesn't have
    // anything until time 15.  So our pins' new segment was 15, but the new
    // segment we passed on to the transform was 10.  Now it's finally time 15,
    // and we have a sample with time stamp 0, which if delivered downstream,
    // will be thought to belong at timestamp 10, so we need to set the time
    // stamp to 5 so that the transform will know that it belongs at time 15.
    REFERENCE_TIME a = rtStart, b = rtStop;
    a -= m_pSwitch->m_rtLastSeek;
    b -= m_pSwitch->m_rtLastSeek;
    hr = pSample->SetTime(&a, &b);
    if (hr != S_OK) {
	EndOfStream();
	return E_FAIL;
    }

    // What do we do with this sample? This will set/reset the event below
    if (FancyStuff(rtStart) == S_FALSE) {
	// we were told to swallow it
	ResetEvent(m_hEventBlock);	// make sure we'll block next time
	return NOERROR;
    }

    // Wait until it is time to deliver this thing
    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("CBigSwitchIn[%d]::Receive blocking..."),
								m_iInpin));
    WaitForSingleObject(m_hEventBlock, INFINITE);
    ResetEvent(m_hEventBlock);

    // we are apparently flushing now and NOT supposed to deliver this (or
    // that unexpected event will HANG)
    if (m_bFlushing)
	return S_FALSE;

    // oops - we finished since we blocked
    if (m_pSwitch->m_fEOS)
	return S_FALSE;

    // by the time we unblocked, we have advanced our crank past the time for
    // this frame... so we have gone from being too early for this frame to
    // being too late, and it can be discarded
    if (rtStart < m_pSwitch->m_rtCurrent) {
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("Oops. Sample no longer needed.")));
	return NOERROR;
    }

    // where should we deliver this?
    int iOutpin = OutpinFromTime(rtStart);
    DbgLog((LOG_TRACE, TRACE_MEDIUM, TEXT("CBigSwitchIn[%d]::Receive %dms, Delivering to %d"),
				m_iInpin, (int)(rtStart / 10000), iOutpin));
    if (iOutpin >= 0) {
	m_rtLastDelivered = m_pSwitch->m_rtNext;

        // remove bogus discontinuities now that we're making one stream
        pSample->SetDiscontinuity(FALSE);

	// Is this supposed to be a discontinuity? Yes, if we're dealing with
	// data that is temporally compressed and we switch input pins.  (The
	// thing coming from a new input pin is garbage when considered as a
	// delta from what the last pin sent)
	BOOL fComp = (m_pSwitch->m_mtAccept.bTemporalCompression == TRUE);
	if (iOutpin == 0 && (m_pSwitch->m_fDiscon ||
			(m_pSwitch->m_nLastInpin != -1 && fComp &&
			m_iInpin != m_pSwitch->m_nLastInpin))) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("and it was a DISCONTINUITY")));
	    pSample->SetDiscontinuity(TRUE);
	    m_pSwitch->m_fDiscon = FALSE;
	}

	// different segments will have random media times, confusing the mux
	// fix them up right, or kill them.  I'm lazy.
        pSample->SetMediaTime(NULL, NULL);

        hr = m_pSwitch->m_pOutput[iOutpin]->Deliver(pSample);

	// we just realized we're late.  The frame rate converter is probably
	// busy replicating frames.  We better tell it to stop, or trying
	// to crank ahead won't do any good
	if (m_pSwitch->m_fJustLate == TRUE) {
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("LATE:Tell the FRC to stop replicating")));
	    // The LATE variable is set to where the switch should crank to after
	    // noticing it was late.  Subtract the start time given to us by
	    // the FRC, to get the amount that the FRC is late by.  Give this
	    // number to the FRC.  The reason I do this, is that if I give a
	    // a bigger number to the FRC, and make it skip past the point that
	    // the switch skipped to, the switch will get confused and hang,
	    // so I have to be careful about how much the FRC skips

        // crank, now that we're back from Deliver (or we'll deliver 2 things
        // at once to the poor renderer!)
        m_pSwitch->ActualCrank(m_pSwitch->m_qJustLate.Late);

	    m_pSwitch->m_qJustLate.Late -= rtStart;
	    PassNotify(m_pSwitch->m_qJustLate);
	    m_pSwitch->m_fJustLate = FALSE;
	}

	// keep track of the last thing sent to the main output
	if (iOutpin == 0) {
	    m_pSwitch->m_nLastInpin = m_iInpin;	// it came from here
	    m_pSwitch->m_rtLastDelivered = m_pSwitch->m_rtCurrent;
	}
    } else {
	// nowhere to send it.
	hr = S_OK;
    }

    // Are we all done with our current time?  Is it time to advance the clock?
    if (m_pSwitch->TimeToCrank()) {
        //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("It's time to crank!")));
	// Yep!  Advance the clock!
	m_pSwitch->Crank();
    }

    return hr;

} // Receive


HRESULT CBigSwitchInputPin::Active()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: Active"), m_iInpin));
    // blocks until it's time to process input
    m_hEventBlock = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hEventBlock == NULL)
	return E_OUTOFMEMORY;
    // blocks when we're in the middle of a seek until seek is over
    m_hEventSeek = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (m_hEventSeek == NULL) {
	CloseHandle(m_hEventBlock);
        m_hEventBlock = NULL;
	return E_OUTOFMEMORY;
    }
    m_rtBlock = -1;	// we are not blocked, nor at EOS
    m_fEOS = FALSE;
    m_fStaleData = FALSE;
    m_fFlushBeforeSeek = FALSE;
    m_fFlushAfterSeek = FALSE;

    // !!! Do we need to send NewSeg ever when a dynamic input gets started up?
    // I don't think so... this can happen literally at any moment


    // We just went live.  Nobody has seeked us to the right spot yet.  Do it
    // now, for better perf, otherwise the switch will have to eat all the data
    // up to the point it wanted
    //
    // Only seek sources, that's all that's necessary.  Don't do any seeking
    // if this is the compressed switch (it will crash).
    // !!! If smart recompression ever supports seeking, we'll need to make this
    // work to get the perf benefit
    //
    if (m_pSwitch->IsDynamic() && m_fIsASource && !m_pSwitch->m_bIsCompressed) {
        IPin *pPin = GetConnected();
        ASSERT(pPin);
        CComQIPtr <IMediaSeeking, &IID_IMediaSeeking> pMS(pPin);
        if (pMS) {

            // make sure we're in MEDIA TIME format
            if (pMS->IsUsingTimeFormat(&TIME_FORMAT_MEDIA_TIME) != S_OK)
                pMS->SetTimeFormat(&TIME_FORMAT_MEDIA_TIME);

            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("Doing first DYNAMIC seek")));

            // Flushing would CONFUSE THE HELL out of us.  We'll think we're
            // in flush without seek mode.
            HRESULT hr = pMS->SetPositions(&m_pSwitch->m_rtCurrent,
                                    AM_SEEKING_AbsolutePositioning |
                                    AM_SEEKING_NoFlush, &m_pSwitch->m_rtStop,
                                    AM_SEEKING_AbsolutePositioning |
                                    AM_SEEKING_NoFlush);

            if (FAILED(hr)) {
                // oh well, guess we won't have the optimal perf
                DbgLog((LOG_ERROR,1,TEXT("Switch::SEEK FAILED!")));
                ASSERT(FALSE);
            }
        } else {
            // oh well, guess we won't have the optimal perf
            DbgLog((LOG_ERROR,1,TEXT("Switch pin CAN'T SEEK")));
            ASSERT(FALSE); // we're screwed
        }
    }

    m_fActive = true;

    return CBaseInputPin::Active();
}


HRESULT CBigSwitchInputPin::Inactive()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: Inactive"), m_iInpin));


    // pretend we're flushing. We need Receive to unblock, but not deliver
    // anything (that would screw everything up.)  We can't actually flush,
    // that delivers the flush downstream.
    // This will make Receive and GetBuffer fail from now on
    m_bFlushing = TRUE;

    // unblock Receive and GetBuffer
    SetEvent(m_hEventBlock);
    SetEvent(m_hEventSeek);

    // wait until Receive and GetBuffer are not waiting on these events
    CAutoLock lock_it(&m_csReceive);

    if (m_hEventBlock)
    {
	CloseHandle(m_hEventBlock);
        m_hEventBlock = NULL;
    }
    if (m_hEventSeek)
    {
	CloseHandle(m_hEventSeek);
        m_hEventSeek = NULL;
    }

    m_fActive = false;

    // this will turn m_bFlushing off again
    return CBaseInputPin::Inactive();
}


HRESULT CBigSwitchInputPin::EndOfStream()
{
    // Uh oh!  We've seeked and are waiting for the flush to come through. Until
    // then, cranking or setting m_fEOS or anything will hang us.
    if (m_fStaleData) {
	return S_OK;
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]: EOS"), m_iInpin));
    m_fEOS = TRUE;

    // Were we expecting more data? I certainly hope not...
    // if this pin hasn't delivered in a while, use the current time to see
    // if this pin is still needed
    // !!! add 2 ms to avoid rounding error since we don't know next crank
    REFERENCE_TIME rt = max(m_rtLastDelivered + 20000, m_pSwitch->m_rtCurrent);
    int n = OutpinFromTime(rt);
    if (n == -1)
	n = NextOutpinFromTime(rt, NULL);

    BOOL fComp = (m_pSwitch->m_mtAccept.bTemporalCompression == TRUE);

    // !!! If we are dealing with compressed data, do NOT think this is an
    // error. A smart recompression source could be any arbitrary frame rate
    // (thanks to ASF) so we don't know if we should have gotten more samples
    if ( n >= 0 && !m_pSwitch->m_fSeeking && !fComp) {

        DbgLog((LOG_ERROR,1,TEXT("*** OOPS! RAN OUT OF MOVIE TOO SOON!")));
	// !!! NEEDS TO LOG WHAT FILENAME MISBEHAVED (dynamic)
	m_pSwitch->_GenerateError(2, DEX_IDS_CLIPTOOSHORT, E_INVALIDARG);
        // !!! David didn't want to panic
	m_pSwitch->AllDone();	 // otherwise we could hang
    }

    // Eric added if( m_pSwitch->m_State != State_Stopped )
    {
        // Everytime something interesting happens, we see if it's time to advance
        // the clock
        if (m_pSwitch->TimeToCrank()) {
            //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("It's time to crank!")));
	    m_pSwitch->Crank();
        }
    }

    return CBaseInputPin::EndOfStream();
}


// We got a sample at time "rt".  What do we do with it?  Hold it off, or eat
// it, or deliver it now?
//
HRESULT CBigSwitchInputPin::FancyStuff(REFERENCE_TIME rt)
{
    CAutoLock cObjectLock(&m_pSwitch->m_csCrank);

    HRESULT hrRet;

    // we're all done.
    if (m_pSwitch->m_fEOS) {
	SetEvent(m_hEventBlock);	// don't hang!
	return NOERROR;
    }

    // This sample is later than our current clock time.  It's not time to
    // deliver it yet.  When it is time, it goes to a valid output.  Let's block
    if (rt >= m_pSwitch->m_rtNext && OutpinFromTime(rt) >= 0) {
        m_rtBlock = rt;	// when we want to wake up
        DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Next: %d - not time yet"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtNext / 10000)));
	hrRet = NOERROR;
    // this sample is earlier than we are dealing with.  I don't know where it
    // came from.  Throw it away.
    } else if (rt < m_pSwitch->m_rtCurrent) {
	// this pin will never be used again.  don't waste time... block
        if (OutpinFromTime(m_pSwitch->m_rtCurrent) < 0 &&
			NextOutpinFromTime(m_pSwitch->m_rtCurrent, NULL) < 0) {
	    m_rtBlock = MAX_TIME;
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Current: %d - NEVER NEEDED, block"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtCurrent / 10000)));
	} else {
	    m_rtBlock = -1;
	    SetEvent(m_hEventBlock);
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Current: %d - TOO EARLY, discard"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtCurrent / 10000)));
	}
	// to know if an EOS will be bad or not... it wasn't delivered but
	// we've seen something for this time, and we need to know that for
	// immediately after a seek when rtCurrent is not on a package boundary
	// !!! This can't be right!
	m_rtLastDelivered = m_pSwitch->m_rtNext;
	hrRet = S_FALSE;

    } else {
	hrRet = NOERROR;
        if (OutpinFromTime(rt) < 0) {
	    // This pin is not connected anywhere at the time of the sample.
	    // Will it ever be connected again?
	    if (NextOutpinFromTime(rt, NULL) >= 0) {
		// Yes, eventually this pin needs to deliver stuff, but not now,
		// so throw this sample away
		m_rtBlock = -1;
		SetEvent(m_hEventBlock);
        	DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  Current: %d - TOO EARLY, discard"),
					m_iInpin, (int)(rt / 10000),
					(int)(m_pSwitch->m_rtCurrent / 10000)));
		hrRet = S_FALSE;
	    } else {
		// No, this pin will never be needed again.  BLOCK it so it
		// doesn't waste anybody's time if its a source (otherwise the
		// source will keep pushing data at us eating CPU).  If its
		// not a source, blocking could hang the graph making the
		// sources that eventually feed us not crank, so we will discard
		// (it will be a timely discard, one each crank so that's OK)
		if (m_fIsASource) {
		    // It _is_ time for this sample, but it's also the end of
		    // the project!  If we don't realize this, we'll hang
		    if (rt < m_pSwitch->m_rtNext && rt >= m_pSwitch->m_rtStop) {
			m_pSwitch->AllDone();
		    } else {
	               m_rtBlock = rt;
                       DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] no longer needed - block")
						, m_iInpin));
		    }
		} else {
		    m_rtBlock = -1;
		    SetEvent(m_hEventBlock);
                    DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] no longer needed - discard"),
						m_iInpin));
		}
	    }
        } else {
            // It is time for this sample to be delivered!
            DbgLog((LOG_TRACE, TRACE_LOW, TEXT("[%d] time: %d  time to unblock"),
						m_iInpin, (int)(rt / 10000)));
	    m_rtBlock = -1;
	    // looks like our crank time is not ssynced with the incoming times
	    // (we must have just seeked to an arbitrary spot.)  MAKE THEM
	    // THE SAME, or we'll get confused processing stuff at time X and
	    // deciding whether to crank or not thinking we're at time (X-delta)
	    if (rt > m_pSwitch->m_rtCurrent) {
                ASSERT(FALSE);  // shouldn't happen, we only seek to boundaries
                DbgLog((LOG_TRACE, TRACE_LOW, TEXT("HONORARY CRANK to %dms"),
							(int)(rt / 10000)));
		m_pSwitch->ActualCrank(rt);
	    }
            SetEvent(m_hEventBlock);
	}
    }

    // OK, are we ready to advance our internal clock yet?
    if (m_pSwitch->TimeToCrank()) {
        //DbgLog((LOG_TRACE, TRACE_LOW, TEXT("It's time to crank!")));
	m_pSwitch->Crank();
    }

    return hrRet;
}

//
// Don't allow our input to connect directly to our output
//
HRESULT CBigSwitchInputPin::CompleteConnect(IPin *pReceivePin)
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]::CompleteConnect"), m_iInpin));

    PIN_INFO pinfo;
    IBigSwitcher *pBS;
    HRESULT hr = pReceivePin->QueryPinInfo(&pinfo);
    if (hr == S_OK) {
	pinfo.pFilter->Release();	// it won't go away yet
	hr = pinfo.pFilter->QueryInterface(IID_IBigSwitcher, (void **)&pBS);
	if (hr == S_OK) {
	    pBS->Release();
            DbgLog((LOG_TRACE, TRACE_HIGHEST,TEXT("CBigSwitchIn[%d]::CompleteConnect failing because it was another switch"), m_iInpin));
	    return E_FAIL;
	}
    }
    return CBaseInputPin::CompleteConnect(pReceivePin);
}


// what output is this pin connected to at this time?  check our linked list
//
int CBigSwitchInputPin::OutpinFromTime(REFERENCE_TIME rt)
{
    if (rt < 0 || rt >= m_pSwitch->m_rtProjectLength)
	return -1;

    CRANK *p = m_pCrankHead;
    while (p) {
	if (p->rtStart <= rt && p->rtStop > rt) {
	    return p->iOutpin;
	}
	p = p->Next;
    }
    return -1;
}


// after the one it's sending to now, what outpin will be next?
// !!! Assumes two of the same outpin are not in a row, but collapsed
//
int CBigSwitchInputPin::NextOutpinFromTime(REFERENCE_TIME rt,
						REFERENCE_TIME *prtNext)
{
    if (rt < 0 || rt >= m_pSwitch->m_rtProjectLength)
	return -1;

    CRANK *p = m_pCrankHead;
    while (p) {
	if (p->rtStart <= rt && p->rtStop > rt) {
	    if (p->Next == NULL)
	        return -1;
	    else {
		if (prtNext)
		    *prtNext = p->Next->rtStart;
		return p->Next->iOutpin;
	    }
	} else if (p->rtStart > rt) {
	    if (prtNext)
		*prtNext = p->rtStart;
	    return p->iOutpin;
	}
	p = p->Next;
    }
    return -1;
}

// DEBUG code to show who this pin is connected to at what times
//
#ifdef DEBUG
HRESULT CBigSwitchInputPin::DumpCrank()
{
    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("CBigSwitchIn[%d]::DumpCrank"), m_iInpin));
    CRANK *p = m_pCrankHead;
    while (p) {
        DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("Pin %d  %8d-%8d ms"), p->iOutpin,
			(int)(p->rtStart / 10000), (int)(p->rtStop / 10000)));
	p = p->Next;
    }
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\switch\setup.cpp ===
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"
#include "..\util\perf_defs.h"

// Since this filter has no property page, it is useless unless programmed.
// I have test code which will allow it to be inserted into graphedit pre-
// programmed to do something useful
//
//#define TEST

const AMOVIESETUP_FILTER sudBigSwitch =
{
    &CLSID_BigSwitch,       // CLSID of filter
    L"Big Switch",          // Filter's name
    MERIT_DO_NOT_USE,       // Filter merit
    0,                      // Number of pins
    NULL //psudPins                // Pin information
};

#ifdef FILTER_DLL
//
// Provide the ActiveMovie templates for classes supported by this DLL.
//
CFactoryTemplate g_Templates[] =
{
    {L"Big Switch", &CLSID_BigSwitch, CBigSwitch::CreateInstance, NULL, &sudBigSwitch }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CBigSwitch::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CBigSwitch(NAME("Big Switch Filter"), pUnk, phr);
}

#ifdef FILTER_DLL
//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\stdafx.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// stdafx.cpp : source file that includes just the standard includes
// Tldb.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <streams.h>
#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\setup.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"

#ifdef FILTER_DLL
#include "qedit_i.c"
#include <initguid.h>
#include "tldb.h"

// this is the only object we stick in the registry to allow people to
// create. All other creation calls go through the Timeline's methods
//
CFactoryTemplate g_Templates [] = 
{
    { 
        L"MS Timeline"
        , &CLSID_AMTimeline
        , CAMTimeline::CreateInstance
    }
};
int g_cTemplates = sizeof( g_Templates ) / sizeof( g_Templates[ 0 ] );

//
// DllRegisterServer
//
STDAPI DllRegisterServer( )
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer( )
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\switch\worker.cpp ===
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "switch.h"
#include "..\util\conv.cxx"
#include "..\util\filfuncs.h"
#include "..\render\dexhelp.h"
#include "..\util\perf_defs.h"

const int TRACE_EXTREME = 0;
const int TRACE_HIGHEST = 2;
const int TRACE_MEDIUM = 3;
const int TRACE_LOW = 4;
const int TRACE_LOWEST = 5;

const int BACKGROUND_THREAD_WAIT_TIME = 500; // ms

CBigSwitchWorker::CBigSwitchWorker()
{
}

HRESULT
CBigSwitchWorker::Create(CBigSwitch *pSwitch)
{
    m_pSwitch = pSwitch;
    m_hThread = 0;

    return CAMThread::Create();
}

HRESULT
CBigSwitchWorker::Run()
{
    return CallWorker(CMD_RUN);
}

HRESULT
CBigSwitchWorker::Stop()
{
    return CallWorker(CMD_STOP);
}

HRESULT
CBigSwitchWorker::Exit()
{
    return CallWorker(CMD_EXIT);
}

// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CBigSwitchWorker::ThreadProc()
{
    BOOL bExit = FALSE;

    m_hThread = GetCurrentThread();

#ifdef CHANGE_THREAD_PRIORITIES
    SetThreadPriority(m_hThread, THREAD_PRIORITY_BELOW_NORMAL);
#endif

    QzInitialize(NULL);


    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }

    QzUninitialize();

    return NOERROR;
}

HRESULT
CBigSwitchWorker::DoRunLoop()
{
    DWORD dw = WAIT_TIMEOUT;
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("entering worker thread")));

    while (1) {
	Command com;
	if (CheckRequest(&com)) {
	    if (com == CMD_STOP)
		break;
	}

	if (dw == WAIT_TIMEOUT) {
            m_pSwitch->DoDynamicStuff(m_pSwitch->m_rtCurrent);
	} else {
	    // we were woken up... this is the time to use (if any)
            m_pSwitch->DoDynamicStuff(m_rt);
	}

#ifdef CHANGE_THREAD_PRIORITIES
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL );
#endif

        // check every once in a while
        dw = WaitForSingleObject(m_pSwitch->m_hEventThread, BACKGROUND_THREAD_WAIT_TIME );
    }

    DbgLog((LOG_TRACE, TRACE_MEDIUM,TEXT("getting ready to leave worker thread")));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\switch\switch.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __SWITCH__
#define __SWITCH__

#include "..\errlog\cerrlog.h"

extern const AMOVIESETUP_FILTER sudBigSwitch;

// !!! don't change - frc assumes this
#define SECRET_FLAG 65536

class CBigSwitch;
class CBigSwitchOutputPin;
class CBigSwitchInputPin;
class CBigSwitchInputAllocator;

// each input pin has one of these
typedef struct _crank {
    int iOutpin;
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtStop;
    _crank *Next;
} CRANK;

struct FILTERLOADINFO {
    BSTR            bstrURL;
    GUID            GUID;
    int             nStretchMode;
    long            lStreamNumber;
    double          dSourceFPS;
    int             cSkew;
    STARTSTOPSKEW * pSkew;
    long            lInputPin;
    BOOL            fLoaded;

    BOOL            fShare;             // for source sharing
    long            lShareInputPin;     // other switch's input pin
    int             nShareStretchMode;
    long            lShareStreamNumber;
    AM_MEDIA_TYPE   mtShare;
    double          dShareFPS;

    IPropertySetter *pSetter;
    FILTERLOADINFO *pNext;
};

const int HI_PRI_TRACE = 2;
const int MED_PRI_TRACE = 3;
const int LOW_PRI_TRACE = 4;
const int EXLOW_PRI_TRACE = 5;

// class for the big switch filter's Input allocator

class CBigSwitchInputAllocator : public CMemAllocator
{
    friend class CBigSwitchInputPin;

protected:

    CBigSwitchInputPin *m_pSwitchPin;

public:

    CBigSwitchInputAllocator(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    	CMemAllocator(pName, pUnk, phr) {};
    ~CBigSwitchInputAllocator() {};

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime, DWORD dwFlags);
};


class CBigSwitchInputPin : public CBaseInputPin
{
    friend class CBigSwitchInputAllocator;
    friend class CBigSwitchOutputPin;
    friend class CBigSwitch;

public:

    // Constructor and destructor
    CBigSwitchInputPin(TCHAR *pObjName,
                 CBigSwitch *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);
    ~CBigSwitchInputPin();

    // overridden to allow cyclic-looking graphs
    STDMETHODIMP QueryInternalConnections(IPin **apPin, ULONG *nPin);

    // check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);

    // release our special allocator, if any
    HRESULT BreakConnect();

    STDMETHODIMP Disconnect();

    // get our special BigSwitch allocator
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);

    // provide a type to make connecting faster?
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // don't allow us to connect directly to a switch output pin
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    // ask the switch for the allocator requirements
    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);

    // does special processing to make sure switch knows about the biggest
    // allocator provided to it
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // pass on EOS, then see if we need to do a crank
    STDMETHODIMP EndOfStream();

    // go unstale
    STDMETHODIMP Unstale();

    // very complicated function...
    STDMETHODIMP BeginFlush();

    // very complicated function...
    STDMETHODIMP EndFlush();

    // just say yes, base class function is SLOW
    STDMETHODIMP ReceiveCanBlock();

    // deliver every input's newsegment to every output pin
    //
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

    // create and destroy synchronization events
    HRESULT Active();
    HRESULT Inactive();

protected:

#ifdef DEBUG
    // Dump switch matrix for this pin
    HRESULT DumpCrank();
#endif

    int OutpinFromTime(REFERENCE_TIME rt);
    int NextOutpinFromTime(REFERENCE_TIME rt, REFERENCE_TIME *prtNext);
    HRESULT FancyStuff(REFERENCE_TIME);	// on Receive and GetBuffer

    CBigSwitchInputAllocator *m_pAllocator; // our special allocator
    CBigSwitch *m_pSwitch;      // Main filter object
    CRANK *m_pCrankHead;        // which pins to send to, and when
    int m_iInpin;	        // which input pin are we?
    int m_cBuffers;	        // number of buffers in allocator
    int m_cbBuffer;	        // size of the allocator buffers
    BOOL m_fOwnAllocator;	//using our own?
    HANDLE m_hEventBlock;	// event blocking receive/getbuffer
    HANDLE m_hEventSeek;	// block input while seeking
    REFERENCE_TIME m_rtBlock;	// sample arrived here
    REFERENCE_TIME m_rtLastDelivered;	// end time of last thing delivered
    BOOL m_fEOS;
    BOOL m_fIsASource;		// input is connected to a source, as opposed
				// to the output of an effect
    BOOL m_fInNewSegment;	// prevent recursion

    BOOL m_fFlushBeforeSeek;	// sharing a parser, seek happens before we ask
    BOOL m_fFlushAfterSeek;	// seek happens before

    BOOL m_fStaleData;		// true if we know a seek is coming. We've sent
				// the NewSeg, so don't deliver anything until
				// the new data arrives

    CCritSec m_csReceive;
    bool m_fActive;
#ifdef NOFLUSH
    BOOL m_fSawNewSeg;
#endif
};


// Class for the big switch filter's Output pins.

class CBigSwitchOutputPin : public CBaseOutputPin, IMediaSeeking
{
    friend class CBigSwitchInputAllocator;
    friend class CBigSwitchInputPin;
    friend class CBigSwitch;

public:

    // Constructor and destructor

    CBigSwitchOutputPin(TCHAR *pObjName,
                   CBigSwitch *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName);
    ~CBigSwitchOutputPin();

    DECLARE_IUNKNOWN

    // Reveals IMediaSeeking
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // overridden to allow cyclic-looking graphs
    STDMETHODIMP QueryInternalConnections(IPin **apPin, ULONG *nPin);

    // Check that we can support an output type, checks against switch's MT
    HRESULT CheckMediaType(const CMediaType *pmt);

    // gets the switch media type
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    // Negotiation to use our input pins allocator. Weird fancy allocator stuff
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);

    // make sure the allocator has the biggest size of any of our input pins
    // and output pins
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    //HRESULT Active();
    //HRESULT Inactive();

    // Overriden to pass data to the output queues
    //HRESULT Deliver(IMediaSample *pMediaSample);
    //HRESULT DeliverEndOfStream();
    //HRESULT DeliverBeginFlush();
    //HRESULT DeliverEndFlush();
    //HRESULT DeliverNewSegment(REFERENCE_TIME tStart, REFERENCE_TIME tStop, double dRate);

    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);

    // IMediaSeeking
    STDMETHODIMP IsFormatSupported(const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat(GUID *pFormat);
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsUsingTimeFormat(const GUID * pFormat);
    STDMETHODIMP GetTimeFormat(GUID *pFormat);
    STDMETHODIMP GetDuration(LONGLONG *pDuration);
    STDMETHODIMP GetStopPosition(LONGLONG *pStop);
    STDMETHODIMP GetCurrentPosition(LONGLONG *pCurrent);
    STDMETHODIMP GetCapabilities( DWORD * pCapabilities );
    STDMETHODIMP CheckCapabilities( DWORD * pCapabilities );
    STDMETHODIMP ConvertTimeFormat(
	LONGLONG * pTarget, const GUID * pTargetFormat,
	LONGLONG    Source, const GUID * pSourceFormat );
    STDMETHODIMP SetPositions(
	LONGLONG * pCurrent,  DWORD CurrentFlags,
	LONGLONG * pStop,  DWORD StopFlags );
    STDMETHODIMP GetPositions( LONGLONG * pCurrent, LONGLONG * pStop );
    STDMETHODIMP GetAvailable( LONGLONG * pEarliest, LONGLONG * pLatest );
    STDMETHODIMP SetRate( double dRate);
    STDMETHODIMP GetRate( double * pdRate);
    STDMETHODIMP GetPreroll(LONGLONG *pPreroll);

protected:

    CBigSwitch *m_pSwitch;                  // Main filter object pointer
    BOOL m_fOwnAllocator;	            //using our own?
    int m_iOutpin;	                    // which output pin are we?
};

// worker thread object
class CBigSwitchWorker : public CAMThread
{
    friend class CBigSwitch;
    friend class CBigSwitchOutputPin;

protected:
    CBigSwitch * m_pSwitch;
    HANDLE m_hThread;
    REFERENCE_TIME m_rt;

public:
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

private:
    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    HRESULT DoRunLoop(void);

public:

    CBigSwitchWorker();

    HRESULT Create(CBigSwitch * pSwitch);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();
    HRESULT Exit();
};


// Class for the Big Switch filter

class CBigSwitch
    : public CCritSec
    , public CBaseFilter
    , public IBigSwitcher
    , public CPersistStream
    , public CAMSetErrorLog
    , public IAMOutputBuffering
    , public IGraphConfigCallback
{
    // Let the pins access our internal state
    friend class CBigSwitchInputPin;
    friend class CBigSwitchOutputPin;
    friend class CBigSwitchInputAllocator;
    friend class CBigSwitchWorker;

protected:

    IDeadGraph * m_pDeadGraph;

    STDMETHODIMP CreateInputPins(long);
    STDMETHODIMP CreateOutputPins(long);
    BOOL TimeToCrank();
    HRESULT Crank();
    HRESULT ActualCrank(REFERENCE_TIME rt);
    REFERENCE_TIME CrankTime();
    REFERENCE_TIME NextInterestingTime(REFERENCE_TIME);
    HRESULT AllDone();

    CBigSwitchInputPin **m_pInput;
    CBigSwitchOutputPin **m_pOutput;
    int m_cInputs;
    int m_cOutputs;

    REFERENCE_TIME m_rtProjectLength;
    REFERENCE_TIME m_rtStop;
    double m_dFrameRate;

    AM_MEDIA_TYPE m_mtAccept;		// all pins only connect with this

    REFERENCE_TIME m_rtCurrent;		// current timeline time
    REFERENCE_TIME m_rtNext;		// this will be next
    LONGLONG m_llFramesDelivered;	// count to avoid error propagation

    BOOL m_fEOS;	// we are all done

    REFERENCE_TIME m_rtLastSeek;	// last timeline time seeked to
    REFERENCE_TIME m_rtSeekCurrent;
    REFERENCE_TIME m_rtSeekStop;

    BOOL m_fSeeking;	// inside a seek?
    BOOL m_fNewSegSent;	// have we fwd'd the NewSeg yet?
    BOOL m_bIsCompressed;

    int m_cbPrefix, m_cbAlign;	// each pin needs its allocator to do these
    LONG m_cbBuffer;		// 

    CMemAllocator *m_pPoolAllocator;  // pool of extra buffers

    BOOL m_fPreview;

    REFERENCE_TIME m_rtLastDelivered;	// last time sent to main output
    int m_nLastInpin;			// last pin delivered to

    int  m_nOutputBuffering;	// IAMOutputBuffering

    CCritSec m_csCrank;

    long m_nDynaFlags;
    BOOL m_fDiscon;	// is there a discontinuity in what we're sending?

    BOOL m_fJustLate;		// we just got a late notification
    Quality m_qJustLate;	// (this one)
    REFERENCE_TIME m_qLastLate;


    BOOL m_cStaleData;		// how many flushes we're waiting for in the
				// seek before flush case

#ifdef NOFLUSH
    CCritSec m_csNewSeg;        // don't let NewSeg happen during Seek
#endif

    // DYNAMIC STUFF
    // DYNAMIC STUFF
    // DYNAMIC STUFF

    IGraphBuilder *m_pGBNoRef;  // see JoinFilterGraph
    int m_nGroupNumber;         // which TLDB group this switch is for
    IBigSwitcher *m_pShareSwitch; // the switch we share sources with

    // crit sec for dynamic stuff
    CCritSec m_csFilterLoad;

    // an array of FILTERLOAD infos
    FILTERLOADINFO *m_pFilterLoad;
    long m_cLoaded;		// how many are loaded?
    HRESULT UnloadAll();	// unload all the dynamic sources

    // a worker thread used to pre-set the sources
    CBigSwitchWorker m_worker;
    HANDLE m_hEventThread;

    // * to the IGraphConfig on the graph the switch is in
    IGraphConfig *   m_pGraphConfig;
    
    // called from Reconfigure, CallLoadSource
    HRESULT LoadSource(FILTERLOADINFO *pInfo);

    // called from Reconfigure, CallUnloadSource
    HRESULT UnloadSource(FILTERLOADINFO *pInfo);

    // called from DoDynamicStuff
    HRESULT CallLoadSource(FILTERLOADINFO *pInfo);

    // called from DoDynamicStuff and Stop
    HRESULT CallUnloadSource(FILTERLOADINFO *pInfo);

    // called from worker thread
    HRESULT DoDynamicStuff(REFERENCE_TIME rt);

    // flush the Q if we're late, don't bother sending data to VR
    STDMETHODIMP FlushOutput( );

    BOOL IsDynamic( );

    // find the other switch we share sources with
    STDMETHODIMP FindShareSwitch(IBigSwitcher **ppSwitch);

    STDMETHODIMP EnumPins(IEnumPins ** ppEnum);

#ifdef DEBUG
    DWORDLONG m_nSkippedTotal;
#endif

public:

    DECLARE_IUNKNOWN

    // Reveals IBigSwitcher
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    CBigSwitch(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CBigSwitch();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    STDMETHODIMP Pause();
    STDMETHODIMP Stop();
    STDMETHODIMP JoinFilterGraph(IFilterGraph *, LPCWSTR);

    // override GetState to return VFW_S_CANT_CUE when pausing
    //
    // STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);


    // IBigSwitcher
    //
    STDMETHODIMP Reset();
    STDMETHODIMP SetX2Y( REFERENCE_TIME relative, long X, long Y );
    STDMETHODIMP SetX2YArray( REFERENCE_TIME * relative, long * pX, long * pY, long ArraySize );
    STDMETHODIMP GetInputDepth( long * pDepth );
    STDMETHODIMP SetInputDepth( long Depth );
    STDMETHODIMP GetOutputDepth( long * pDepth );
    STDMETHODIMP SetOutputDepth( long Depth );
    STDMETHODIMP GetVendorString( BSTR * pVendorString );
    STDMETHODIMP GetCaps( long Index, long * pReturn );
    //		HRESULT GetReadyEvent( IMediaEvent ** ppReady );
    STDMETHODIMP IsEverythingConnectedRight( );
    STDMETHODIMP GetMediaType(AM_MEDIA_TYPE *);
    STDMETHODIMP SetMediaType(AM_MEDIA_TYPE *);
    STDMETHODIMP GetProjectLength(REFERENCE_TIME *);
    STDMETHODIMP SetProjectLength(REFERENCE_TIME);
    STDMETHODIMP GetFrameRate(double *);
    STDMETHODIMP SetFrameRate(double);
    STDMETHODIMP InputIsASource(int, BOOL);
    STDMETHODIMP IsInputASource( int, BOOL * );
    STDMETHODIMP SetPreviewMode(BOOL);
    STDMETHODIMP GetPreviewMode(BOOL *);
    STDMETHODIMP GetInputPin(int, IPin **);
    STDMETHODIMP GetOutputPin(int, IPin **);
    STDMETHODIMP SetGroupNumber(int);
    STDMETHODIMP GetGroupNumber(int *);
    STDMETHODIMP GetCurrentPosition(REFERENCE_TIME *);

    // IAMOutputBuffering
    STDMETHODIMP GetOutputBuffering(int *);
    STDMETHODIMP SetOutputBuffering(int);

    STDMETHODIMP AddSourceToConnect(BSTR bstrURL, const GUID *pGuid,
				    int nStretchMode, 
				    long lStreamNumber, 
				    double SourceFPS, 
				    int nSkew, STARTSTOPSKEW *pSkew,
                                    long lInputPin,
                                    BOOL fShare,          // for source sharing
                                    long lShareInputPin,  //
                                    AM_MEDIA_TYPE mtShare,//
                                    double dShareFPS,     //
				    IPropertySetter *pSetter);
    STDMETHODIMP ReValidateSourceRanges( long lInputPin, long cSkews, STARTSTOPSKEW * pSkew );
    STDMETHODIMP MergeSkews(FILTERLOADINFO *, int, STARTSTOPSKEW *);

    STDMETHODIMP SetDynamicReconnectLevel( long Level );
    STDMETHODIMP GetDynamicReconnectLevel( long *pLevel );
    STDMETHODIMP SetCompressed( );
    STDMETHODIMP SetDeadGraph( IDeadGraph * pCache );

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    STDMETHODIMP GetClassID(CLSID *pClsid);
    int SizeMax();

#if 0
    // IPersistPropertyBag
    STDMETHODIMP Load(IPropertyBag * pPropBag, IErrorLog * pErrorLog);
    STDMETHODIMP Save(IPropertyBag * pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties);
#endif

    // IGraphConfigCallback
    STDMETHODIMP Reconfigure(PVOID pvContext, DWORD dwFlags);
};

#endif // __SWITCH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\stdafx.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently

#if !defined(AFX_STDAFX_H__8B015554_61FD_11D2_8CAD_00A024580902__INCLUDED_)
#define AFX_STDAFX_H__8B015554_61FD_11D2_8CAD_00A024580902__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _ATL_APARTMENT_THREADED
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "qeditint.h"
#include "qedit.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8B015554_61FD_11D2_8CAD_00A024580902__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbcomp.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

const int VIRTUAL_TRACK_COMBO = 
                TIMELINE_MAJOR_TYPE_COMPOSITE | 
                TIMELINE_MAJOR_TYPE_TRACK;

//############################################################################
// Composition - either holds tracks or other compositions in a layered
// ordering. Comps can also have effects or transition on them, except for 
// the first composition, which cannot have a transition.
//############################################################################

CAMTimelineComp::CAMTimelineComp
    ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
{
    m_ClassID = CLSID_AMTimelineComp;
    m_TimelineType = TIMELINE_MAJOR_TYPE_COMPOSITE;
}

//############################################################################
// 
//############################################################################

CAMTimelineComp::~CAMTimelineComp( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::NonDelegatingQueryInterface
    (REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineEffectable )
    {
        return GetInterface( (IAMTimelineEffectable*) this, ppv );
    }
    if( riid == IID_IAMTimelineVirtualTrack )
    {
        return GetInterface( (IAMTimelineVirtualTrack*) this, ppv );
    }
    if( riid == IID_IAMTimelineTransable )
    {
        return GetInterface( (IAMTimelineTransable*) this, ppv );
    }
    if( riid == IID_IAMTimelineComp )
    {
        return GetInterface( (IAMTimelineComp*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// Insert a track before another one. A priority of -1 means "at the end". If
// there are N tracks, you cannot add a track with a Priority greater than N.
//############################################################################

STDMETHODIMP CAMTimelineComp::VTrackInsBefore
    (IAMTimelineObj * pTrackToInsert, long Priority)
{
    HRESULT hr = 0;

    // make sure incoming object isn't null
    //
    if( NULL == pTrackToInsert )
    {
        return E_INVALIDARG;
    }

    // make sure it's a track, I guess
    //
    CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > p1( pTrackToInsert );
    CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > p2( pTrackToInsert );
    CComQIPtr< IAMTimelineVirtualTrack, &IID_IAMTimelineVirtualTrack > pVirtualTrack( pTrackToInsert );
    if( !p1 && !p2 )
    {
        return E_NOINTERFACE;
    }
    if( !pVirtualTrack )
    {
        return E_NOINTERFACE;
    }

    // make sure track isn't in some other tree. If this operation failed,
    // then the tree stayed the same.
    //
    hr = pTrackToInsert->Remove( );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // ...incoming object is either a track or another comp...

    // find out how many tracks we have already
    //
    long Count = 0;
    hr = VTrackGetCount( &Count );
    // assume that worked

    // check to make sure Priority is valid
    //
    if( ( Priority < -1 ) || ( Priority > Count ) )
    {
        return E_INVALIDARG;
    }

    hr = XAddKidByPriority( VIRTUAL_TRACK_COMBO, pTrackToInsert, Priority );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // who do we dirty? We just added a track, but the whole thing 
    // is dirty. Compositions don't really have a "time", their time is set
    // by the times of all the things they contain. Compositions response
    // to asking if they are dirty is by asking their tracks, so we do
    // not dirty here.

    // make the entire track dirty, since we just inserted it. 
    //
    if( pVirtualTrack )
    {
        pVirtualTrack->SetTrackDirty( );
    }

    return NOERROR;
}

//############################################################################
// switch around a couple of the track layers in this composition. Haven't
// figured out a good use for this yet, or tested it, but it should work.
//############################################################################

STDMETHODIMP CAMTimelineComp::VTrackSwapPriorities
    ( long VirtualTrackA, long VirtualTrackB)
{
    HRESULT worked =        
        XSwapKids( VIRTUAL_TRACK_COMBO, VirtualTrackA, VirtualTrackB );
    if( FAILED( worked ) )
    {
        return worked;
    }

    return NOERROR;
}

//############################################################################
// Ask how many virtual tracks this composition is holding
//############################################################################

STDMETHODIMP CAMTimelineComp::VTrackGetCount
    (long * pVal)
{
    // base function does error checking
    return XKidsOfType( VIRTUAL_TRACK_COMBO, pVal );
}

//############################################################################
// Get the nth virtual track
//############################################################################

STDMETHODIMP CAMTimelineComp::GetVTrack
    (IAMTimelineObj ** ppVirtualTrack, long Which)
{
    HRESULT hr = 0;

    // find out how many kids we have
    //
    long count = 0;
    hr = XKidsOfType( VIRTUAL_TRACK_COMBO, &count );
    // assume that worked

    // are we in range?
    //
    if( Which < 0 || Which >= count )
    {
        return E_INVALIDARG;
    }

    // can we stuff the value?
    //
    CheckPointer( ppVirtualTrack, E_POINTER );

    // get the nth kid
    //
    hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, Which, ppVirtualTrack );

    return hr;
}

STDMETHODIMP CAMTimelineComp::GetNextVTrack(IAMTimelineObj *pVirtualTrack, IAMTimelineObj **ppNextVirtualTrack)
{
    if (!pVirtualTrack)
        return GetVTrack(ppNextVirtualTrack, 0);
    
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pVirtualTrack );

    return pNode->XGetNextOfType( VIRTUAL_TRACK_COMBO, ppNextVirtualTrack );
}


//############################################################################
// A comp's start/stop is the min/max of anything it contains
//############################################################################

STDMETHODIMP CAMTimelineComp::GetStartStop2(REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineComp::GetStartStop
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    HRESULT hr = 0;

    REFERENCE_TIME Min = 0;
    REFERENCE_TIME Max = 0;

    long VTracks = 0;
    CComPtr<IAMTimelineObj> pTrack;

    // get first track
    hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, 0, &pTrack);

    while(pTrack)
    {
//#define DEBUGDEBUG 1
#ifdef DEBUGDEBUG
        {
            CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > ptTmp;
            XGetNthKidOfType( VIRTUAL_TRACK_COMBO, VTracks, &ptTmp );
            ASSERT(ptTmp == pTrack);
        }
#endif
        
        // ask it for it's times
        //
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pTrack->GetStartStop( &Start, &Stop );
        if( Max == 0 )
        {
            Min = Start;
            Max = Stop;
        }
        if( Start < Min ) Min = Start;
        if( Stop > Max ) Max = Stop;

        IAMTimelineNode *pNodeTmp;
        pTrack->QueryInterface(IID_IAMTimelineNode, (void **)&pNodeTmp);
        pTrack.p->Release();    // bypass CComPtr for perf
        pNodeTmp->XGetNextOfType(VIRTUAL_TRACK_COMBO, &pTrack.p);
        pNodeTmp->Release();
        VTracks++;
    }


    
#ifdef DEBUG
    long VTracksTmp;
    XKidsOfType( VIRTUAL_TRACK_COMBO, &VTracksTmp );
    ASSERT(VTracks == VTracksTmp);
#endif


    *pStart = Min;
    *pStop = Max;

    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineComp::GetRecursiveLayerOfType
    (IAMTimelineObj ** ppVirtualTrack, long WhichLayer, TIMELINE_MAJOR_TYPE Type )
{
    long Dummy = WhichLayer;
    HRESULT hr = GetRecursiveLayerOfTypeI( ppVirtualTrack, &Dummy, Type );
    if( hr == S_FALSE )
    {
        ASSERT( Dummy > 0 );
        hr = E_INVALIDARG;
    }
    else if( hr == NOERROR )
    {
        ASSERT( Dummy == 0 );
    }
    return hr;
}

STDMETHODIMP CAMTimelineComp::GetRecursiveLayerOfTypeI
    (IAMTimelineObj ** ppVirtualTrack, long * pWhich, TIMELINE_MAJOR_TYPE Type )
{
    HRESULT hr = 0;

    // make sure we can stuff the value
    //
    CheckPointer( ppVirtualTrack, E_POINTER );

    *ppVirtualTrack = 0;

    CComPtr <IAMTimelineObj> pTrack;

    while (1)
    {
        if (!pTrack)
            hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, 0, &pTrack );
        else {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pTrack );
            pTrack.Release( );
            pNode->XGetNextOfType( VIRTUAL_TRACK_COMBO, &pTrack );
        }

        if (!pTrack)
            break;
        // assume that worked

        // it's either another composition or a track
        //
        CComQIPtr<IAMTimelineTrack, &IID_IAMTimelineTrack> pTrack2( pTrack );

        if( !pTrack2 )
        {   // we are a composition

            CComQIPtr<IAMTimelineComp, &IID_IAMTimelineComp> pComp( pTrack );

            hr = pComp->GetRecursiveLayerOfTypeI( ppVirtualTrack, pWhich, Type );

            if( FAILED( hr ) )
            {
                *ppVirtualTrack = NULL;
                *pWhich = 0;
                return hr;
            }

            // if they gave us the real deal, then return
            //
            if( *ppVirtualTrack != NULL )
            {
                return NOERROR;
            }

            *pWhich = *pWhich - 1;

            // they didn't find it in this composition, we should try the next one,
            // right?
        }
        else
        {   // we are a track
            TIMELINE_MAJOR_TYPE TrackType;
            hr = pTrack->GetTimelineType( &TrackType );
            // assume that worked

            // if we found a match, then decrement the found number. Note that Which will be zero coming into this
            // function if the present track is the one we want. So if we decrement Which, it will be -1.
            //
            if( Type == TrackType )
            {
                if( *pWhich == 0 )
                {
                    *ppVirtualTrack = pTrack;
                    (*ppVirtualTrack)->AddRef( );
                    return NOERROR;
                }

                *pWhich = *pWhich - 1;
            }
        }
    }

    // if Which is = 0 then we must not have any more kids
    // and have exhausted our search. Therefore we 
    //
    if( *pWhich == 0 )
    {
        *ppVirtualTrack = this;
        (*ppVirtualTrack)->AddRef( );
        return NOERROR;
    }

    // didn't find it, flag this by returning S_FALSE.
    //
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::TrackGetPriority
    (long * pPriority)
{
    CheckPointer( pPriority, E_POINTER );

    return XWhatPriorityAmI( TIMELINE_MAJOR_TYPE_TRACK | TIMELINE_MAJOR_TYPE_COMPOSITE, pPriority );
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineComp::SetTrackDirty
    ( )
{
    return E_NOTIMPL; // settrackdirty
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::GetCountOfType
    (long * pVal, long * pValWithComps, TIMELINE_MAJOR_TYPE MajorType )
{
    HRESULT hr = 0;

    long Total = 0;
    long Comps = 1; // automatically get one because it's in a group

    // make sure we can stuff the value
    //
    CheckPointer( pVal, E_POINTER );
    CheckPointer( pValWithComps, E_POINTER );

    // find out how many kids we have, so we can enum them
    //
    BOOL SetFirst = FALSE;
    CComPtr<IAMTimelineObj> pTrackObj;

    // "this" is a comp, enumerate it's effects/transitions here

    // ... are we looking for effects? Add this comp's number of effects
    //
    if( MajorType == TIMELINE_MAJOR_TYPE_EFFECT )
    {
        CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( this );
        if( pEffectable )
        {
            long Count = 0;
            pEffectable->EffectGetCount( &Count );
            Total += Count;
        }
    }

    // ... are we looking for transitions? Add this comp's number of transitions
    //
    if( MajorType == TIMELINE_MAJOR_TYPE_TRANSITION )
    {
        CComQIPtr< IAMTimelineTransable, &IID_IAMTimelineTransable > pTransable( this );
        if( pTransable )
        {
            long Count = 0;
            pTransable->TransGetCount( &Count );
            Total += Count;
        }
    }

    // ask each of the kids for the amount of whatever it is we're looking for
    for(;;)
    {
        if( !SetFirst )
        {
            // get first track
            hr = XGetNthKidOfType( VIRTUAL_TRACK_COMBO, 0, &pTrackObj);
            SetFirst = TRUE;
        }
        else
        {
            // get next track
            IAMTimelineNode *pNodeTmp;
            pTrackObj->QueryInterface(IID_IAMTimelineNode, (void **)&pNodeTmp);
            pTrackObj.p->Release(); // bypass CComPtr for perf
            pNodeTmp->XGetNextOfType(VIRTUAL_TRACK_COMBO, &pTrackObj.p);
            pNodeTmp->Release();
        }

        if(pTrackObj == 0) {
            break;
        }
        
        // it's either another composition or a track
        //
        CComQIPtr<IAMTimelineTrack, &IID_IAMTimelineTrack> pTrackTrack( pTrackObj );

        // if it's a track...
        //
        if( pTrackTrack != NULL )
        {
            // ... are we looking for effects? Add this track's number of effects
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_EFFECT )
            {
                CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( pTrackObj );
                if( pEffectable )
                {
                    long Count = 0;
                    pEffectable->EffectGetCount( &Count );
                    Total += Count;
                }
            }

            // ... are we looking for transitions? Add this track's number of transitions
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_TRANSITION )
            {
                CComQIPtr< IAMTimelineTransable, &IID_IAMTimelineTransable > pTransable( pTrackObj );
                if( pTransable )
                {
                    long Count = 0;
                    pTransable->TransGetCount( &Count );
                    Total += Count;
                }
            }

            // are we looking for tracks? If so, we're "1"
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_TRACK )
            {
                Total++;
                continue;
            }

            long SourcesCount = 0;
            hr = pTrackTrack->GetSourcesCount( &SourcesCount );
            // assume that worked

            // ... are we looking for sources? If so, count 'em up.
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_SOURCE )
            {
                Total += SourcesCount;
            }

            // ... are we looking for effects? If so, add each of our source's total
            //
            if( MajorType == TIMELINE_MAJOR_TYPE_EFFECT )
            {
                CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pTrackNode( pTrackTrack );
                CComPtr< IAMTimelineObj > pSource;
                pTrackNode->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pSource );
                while( pSource )
                {
                    CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( pSource );
                    if( pEffectable )
                    {
                        long Count = 0;
                        pEffectable->EffectGetCount( &Count );
                        Total += Count;
                    }

                    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pSource );
                    pSource.Release( );
                    pNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, &pSource );
                }
            } // if looking for EFFECT
        }
        else // it's a composition
        {
            CComQIPtr<IAMTimelineComp, &IID_IAMTimelineComp> pComp( pTrackObj );

            long SubTotal = 0;
            long SubTotalWithComps = 0;

            hr = pComp->GetCountOfType( &SubTotal, &SubTotalWithComps, MajorType );

            if( FAILED( hr ) )
            {
                *pVal = 0;
                *pValWithComps = 0;
                return hr;
            }

            Total += SubTotal;

            // since we're only counting comps here, we need to add the difference
            //
            Comps += ( SubTotalWithComps - SubTotal );
        }
    }

    // if we didn't find anything, then zero out comps so we don't
    // misadjust when doing recursive adding. If we're not counting
    // composites, that is
    //
    if( ( Total == 0 ) && ( MajorType != TIMELINE_MAJOR_TYPE_COMPOSITE ) )
    {
        Comps = 0;
    }

    *pValWithComps = Total + Comps;
    *pVal = Total;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineComp::SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}

STDMETHODIMP CAMTimelineComp::SetStartStop2(REFTIME Start, REFTIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldb.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

int function_not_done = 0;
double TIMELINE_DEFAULT_FPS = 15.0;
const int OUR_STREAM_VERSION = 0;

#include <initguid.h>

DEFINE_GUID( DefaultTransition,
0x810E402F, 0x056B, 0x11D2, 0xA4, 0x84, 0x00, 0xC0, 0x4F, 0x8E, 0xFB, 0x69 );

DEFINE_GUID( DefaultEffect,
0xF515306D, 0x0156, 0x11D2, 0x81, 0xEA, 0x00, 0x00, 0xF8, 0x75, 0x57, 0xDB );

//############################################################################
// 
//############################################################################

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    return TRUE;
}

//############################################################################
// 
//############################################################################

//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CAMTimeline::CreateInstance( LPUNKNOWN pUnk, HRESULT * phr )
{
    return new CAMTimeline( TEXT( "MS Timeline" ), pUnk, phr );
}

//############################################################################
// 
//############################################################################

CAMTimeline::CAMTimeline( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CUnknown( pName, pUnk )
    , m_nSpliceMode( 0 )
    , m_dDefaultFPS( TIMELINE_DEFAULT_FPS )
    , m_nInsertMode( TIMELINE_INSERT_MODE_OVERLAY )
    , m_nGroups( 0 )
    , m_bTransitionsEnabled( TRUE )
    , m_bEffectsEnabled( TRUE )
    , m_DefaultEffect( DefaultEffect )
    , m_DefaultTransition( DefaultTransition )
    , m_punkSite( NULL )
//    , m_DefaultEffect( GUID_NULL )
//    , m_DefaultTransition( GUID_NULL )
{
}

//############################################################################
// 
//############################################################################

CAMTimeline::~CAMTimeline( )
{
    ClearAllGroups( );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMSetErrorLog )
    {
        return GetInterface( (IAMSetErrorLog*) this, ppv );
    }
    if( riid == IID_IAMTimeline )
    {
        return GetInterface( (IAMTimeline*) this, ppv );
    }
/*
    if( riid == IID_IPersistStream )
    {
        return GetInterface( (IPersistStream*) this, ppv );
    }
*/
    if( riid == IID_IObjectWithSite )
    {            
        return GetInterface( (IObjectWithSite*) this, ppv );
    }
    if( riid == IID_IServiceProvider )
    {            
        return GetInterface( (IServiceProvider*) this, ppv );
    }
    
    return CUnknown::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::CreateEmptyNode( IAMTimelineObj ** ppObj, TIMELINE_MAJOR_TYPE TimelineType )
{
    CheckPointer( ppObj, E_POINTER );

    HRESULT hr = 0;

    switch( TimelineType )
    {
        case TIMELINE_MAJOR_TYPE_GROUP:
            {
            CAMTimelineGroup * p = new CAMTimelineGroup( NAME( "Timeline Group" ), NULL, &hr );
            *ppObj = p;
            if( p )
            {
                p->SetOutputFPS( m_dDefaultFPS );
            }
            break;
            }
        case TIMELINE_MAJOR_TYPE_COMPOSITE:
            {
            CAMTimelineComp * p = new CAMTimelineComp( NAME( "Timeline Comp" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_TRACK:
            {
            CAMTimelineTrack * p = new CAMTimelineTrack( NAME( "Timeline Track" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_SOURCE:
            {
            CAMTimelineSrc * p = new CAMTimelineSrc( NAME( "Timeline Source" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_TRANSITION:
            {
            CAMTimelineTrans * p = new CAMTimelineTrans( NAME( "Timeline Transition" ), NULL, &hr );
            *ppObj = p;
            break;
            }
    case TIMELINE_MAJOR_TYPE_EFFECT:
            {
            CAMTimelineEffect * p = new CAMTimelineEffect( NAME( "Timeline Effect" ), NULL, &hr );
            *ppObj = p;
            break;
            }
        default:
            return E_INVALIDARG;
    }

    if( NULL == *ppObj )
    {
        return E_OUTOFMEMORY;
    }

    // the major type's already set by the new call, set the mid type
    //
    (*ppObj)->AddRef( );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetInsertMode(long * pMode)
{
    CheckPointer( pMode, E_POINTER );

    *pMode = m_nInsertMode;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetInsertMode(long Mode)
{
    return E_NOTIMPL; // this is okay, for now
    m_nInsertMode = Mode;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::EnableTransitions(BOOL fEnabled)
{
    m_bTransitionsEnabled = fEnabled;
    return NOERROR;

}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::TransitionsEnabled(BOOL * pfEnabled)
{
    CheckPointer( pfEnabled, E_POINTER );
    *pfEnabled = (BOOL) m_bTransitionsEnabled;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::EnableEffects(BOOL fEnabled)
{
    m_bEffectsEnabled = fEnabled;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::EffectsEnabled(BOOL * pfEnabled)
{
    CheckPointer( pfEnabled, E_POINTER );
    *pfEnabled = (BOOL) m_bEffectsEnabled;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetInterestRange(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    // what should we do here? we have a bunch of groups and
    // a bunch of tracks and how the heck do we get rid of the commie objects?
    //
    return E_NOTIMPL; // setinterestrange, not yet working.
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDuration(REFERENCE_TIME * pDuration)
{
    CheckPointer( pDuration, E_POINTER );

    // have to go through all the groups and get the durations of each
    //
    REFERENCE_TIME MaxStop = 0; 
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        m_pGroup[i]->GetStartStop( &Start, &Stop );
        MaxStop = max( MaxStop, Stop );
    }
    *pDuration = MaxStop;

    return NOERROR;
}

STDMETHODIMP CAMTimeline::GetDuration2(double * pDuration)
{
    CheckPointer( pDuration, E_POINTER );
    *pDuration = 0;

    REFERENCE_TIME Duration = 0;
    HRESULT hr = GetDuration( &Duration );
    if( FAILED( hr ) )
    {
        return hr;
    }

    *pDuration = RTtoDouble( Duration );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultFPS(double FPS)
{
    // !!! truncate FPS to 3 decimal places?
    // m_dDefaultFPS = double( long( FPS * 1000.0 ) / 1000.0 );

    m_dDefaultFPS = FPS;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultFPS(double * pFPS)
{
    CheckPointer( pFPS, E_POINTER );

    *pFPS = m_dDefaultFPS;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::IsDirty(BOOL * pDirty)
{
    CheckPointer( pDirty, E_POINTER );

    // we are dirty if any of our groups are dirty
    //
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        REFERENCE_TIME Start, Stop;
        Start = 0;
        Stop = 0;
        m_pGroup[i]->GetDirtyRange( &Start, &Stop );
        if( Stop > 0 )
        {
            *pDirty = TRUE;
            return NOERROR;
        }
    }

    *pDirty = FALSE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDirtyRange2(REFTIME * pStart, REFTIME * pStop)
{
    return GetDirtyRange( (REFERENCE_TIME*) &pStart, (REFERENCE_TIME*) &pStop );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDirtyRange(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    // we are dirty if any of our groups are dirty
    //
    REFERENCE_TIME MaxStop = 0;
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        REFERENCE_TIME Start, Stop;
        Start = 0;
        Stop = 0;
        m_pGroup[i]->GetDirtyRange( &Start, &Stop );
        if( Stop > MaxStop )
        {
            Stop = MaxStop;
        }
    }

    *pStart = 0;
    *pStop = MaxStop;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

REFERENCE_TIME CAMTimeline::Fixup( REFERENCE_TIME Time )
{
    // bump up then down to get fixed up times
    //
    LONGLONG Frame = Time2Frame( Time, m_dDefaultFPS );
    Time = Frame2Time( Frame, m_dDefaultFPS );
    return Time;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetCountOfType
    (long Group, long * pVal, long * pValWithComps, TIMELINE_MAJOR_TYPE MajorType )
{
    CheckPointer( pVal, E_POINTER );

    if( Group < 0 )
    {
        return E_INVALIDARG;
    }
    if( Group >= m_nGroups )
    {
        return E_INVALIDARG;
    }

    CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pComp( m_pGroup[Group] );
    return pComp->GetCountOfType( pVal, pValWithComps, MajorType );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::AddGroup( IAMTimelineObj * pGroupObj )
{
    CheckPointer( pGroupObj, E_POINTER );

    // only allow so many groups
    //
    if( m_nGroups >= MAX_TIMELINE_GROUPS )
    {
        return E_INVALIDARG;
    }

    // make sure it's a group
    //
    CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pAddedGroup( pGroupObj );
    if( !pAddedGroup )
    {
        return E_NOINTERFACE;
    }

    m_pGroup[m_nGroups] = pGroupObj;
    m_nGroups++;
    pAddedGroup->SetTimeline( this );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::RemGroupFromList( IAMTimelineObj * pGroupObj )
{
    CheckPointer( pGroupObj, E_POINTER );

    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        if( m_pGroup[i] == pGroupObj )
        {
            m_pGroup[i] = m_pGroup[m_nGroups-1];
            m_pGroup[m_nGroups-1].Release( );
            m_nGroups--;
            return NOERROR;
        }
    }
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetGroup( IAMTimelineObj ** ppGroupObj, long WhichGroup )
{
    CheckPointer( ppGroupObj, E_POINTER );
    if( WhichGroup < 0 || WhichGroup >= m_nGroups )
    {
        return E_INVALIDARG;
    }
    *ppGroupObj = m_pGroup[WhichGroup];
    (*ppGroupObj)->AddRef( );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetGroupCount( long * pCount )
{
    CheckPointer( pCount, E_POINTER );
    *pCount = m_nGroups;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::ClearAllGroups( )
{
    while(m_nGroups > 0)
    {
        HRESULT hr = m_pGroup[0]->RemoveAll();
        if (FAILED(hr))
	    return hr;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

// IPersistStream
STDMETHODIMP CAMTimeline::GetClassID( GUID * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = IID_IAMTimeline;
    
    return NOERROR;
}

//############################################################################
// 
//############################################################################

// IPersistStream
STDMETHODIMP CAMTimeline::IsDirty( )
{
    // always dirty!
    return S_OK;
}

//############################################################################
// 
//############################################################################

// IPersistStream
STDMETHODIMP CAMTimeline::Load( IStream * pStream )
{
    HRESULT hr = 0;
    CheckPointer( pStream, E_POINTER );

    // !!! what if we already have a bunch of groups?
    //
    if( m_nGroups > 0 )
    {
        return E_INVALIDARG;
    }

    long x;
    long d;
    BOOL b;
    x = 0;
    pStream->Read( &x, sizeof( x ), NULL );
    pStream->Read( &x, sizeof( x ), NULL );
    m_nGroups = x;
    pStream->Read( &x, sizeof( x ), NULL );
    m_nInsertMode = x;
    pStream->Read( &x, sizeof( x ), NULL );
    m_nSpliceMode = x;
    pStream->Read( &d, sizeof( d ), NULL );
    m_dDefaultFPS = d;
    pStream->Read( &b, sizeof( b ), NULL );
    m_bTransitionsEnabled = b;
    pStream->Read( &b, sizeof( b ), NULL );
    m_bEffectsEnabled = b;

    // create a bunch of groups and serialize them in
    //
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        CComPtr< IAMTimelineObj > pObj = NULL;
        hr = CreateEmptyNode( &pObj, TIMELINE_MAJOR_TYPE_GROUP );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            // !!! bad!
        }
        else
        {
            hr = AddGroup( pObj );
            ASSERT( !FAILED( hr ) );
            CComQIPtr< IPersistStream, &IID_IPersistStream > pPersist( pObj );
            ASSERT( pPersist );
            hr = pPersist->Load( pStream );
            ASSERT( !FAILED( hr ) );
        }
    }

    return hr;
}

//############################################################################
// 
//############################################################################

// IPersistStream
STDMETHODIMP CAMTimeline::Save( IStream * pStream, BOOL fClearDirty )
{
    HRESULT hr = 0;
    CheckPointer( pStream, E_POINTER );

    long x;
    double d;
    BOOL b;
    x = OUR_STREAM_VERSION;
    pStream->Write( &x, sizeof( x ), NULL );
    x = m_nGroups;
    pStream->Write( &x, sizeof( x ), NULL );
    x = m_nInsertMode;
    pStream->Write( &x, sizeof( x ), NULL );
    x = m_nSpliceMode;
    pStream->Write( &x, sizeof( x ), NULL );
    d = m_dDefaultFPS;
    pStream->Write( &d, sizeof( d ), NULL );
    b = m_bTransitionsEnabled;
    pStream->Write( &b, sizeof( b ), NULL );
    b = m_bEffectsEnabled;
    pStream->Write( &b, sizeof( b ), NULL );

    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        CComQIPtr< IPersistStream, &IID_IPersistStream > pPersist( m_pGroup[i] );
        ASSERT( pPersist );
        if( pPersist )
        {
            hr = pPersist->Save( pStream, fClearDirty );
            // !!! error check!
        }
    }

    return hr;
}

//############################################################################
// 
//############################################################################

// IPersistStream
STDMETHODIMP CAMTimeline::GetSizeMax( ULARGE_INTEGER * pcbSize )
{
    HRESULT hr = 0;
    CheckPointer( pcbSize, E_POINTER );

    // our size is the combined size of everything beneath us, plus what we want to save ourselves
    //
    ULARGE_INTEGER OurSize;
    OurSize.LowPart = 0;
    OurSize.HighPart = 0;

    OurSize.LowPart = sizeof( long ); // version number
    OurSize.LowPart += sizeof( long ); // m_nGroups
    OurSize.LowPart += sizeof( long ); // m_nInsertMode
    OurSize.LowPart += sizeof( long ); // m_nSpliceMode
    OurSize.LowPart += sizeof( double ); // m_dDefaultFPS
    OurSize.LowPart += sizeof( BOOL ); // m_bTransitionsEnabled
    OurSize.LowPart += sizeof( BOOL ); // m_bEffectsEnabled

    ULARGE_INTEGER TheirSize;
    TheirSize.LowPart = 0;
    TheirSize.HighPart = 0;
    for( int i = 0 ; i < m_nGroups ; i++ )
    {
        CComQIPtr< IPersistStream, &IID_IPersistStream > pPersist( m_pGroup[i] );
        ASSERT( pPersist );
        ULARGE_INTEGER GroupSize;
        GroupSize.LowPart = 0;
        GroupSize.HighPart = 0;
        if( pPersist )
        {
            pPersist->GetSizeMax( &GroupSize );
            TheirSize.LowPart = TheirSize.LowPart + GroupSize.LowPart;
        }
    }

    (*pcbSize).LowPart = OurSize.LowPart + TheirSize.LowPart;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultEffect( GUID * pDummyGuid )
{
    GUID * pGuid = (GUID*) pDummyGuid;
    CheckPointer( pGuid, E_POINTER );
    m_DefaultEffect = *pGuid;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultEffect( GUID * pGuid )
{
    CheckPointer( pGuid, E_POINTER );
    *pGuid = m_DefaultEffect;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultTransition( GUID * pGuid )
{
    CheckPointer( pGuid, E_POINTER );
    m_DefaultTransition = *pGuid;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultTransition( GUID * pGuid )
{
    CheckPointer( pGuid, E_POINTER );
    *pGuid = m_DefaultTransition;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultEffectB( BSTR pGuid )
{
    HRESULT hr = CLSIDFromString( pGuid, &m_DefaultEffect );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultEffectB( BSTR * pGuid )
{
    HRESULT hr;

    WCHAR * TempVal = NULL;
    hr = StringFromCLSID( m_DefaultEffect, &TempVal );
    if( FAILED( hr ) )
    {
        return hr;
    }
    *pGuid = SysAllocString( TempVal );
    CoTaskMemFree( TempVal );
    if( !(*pGuid) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::SetDefaultTransitionB( BSTR pGuid )
{
    HRESULT hr = CLSIDFromString( pGuid, &m_DefaultTransition );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::GetDefaultTransitionB( BSTR * pGuid )
{
    HRESULT hr;

    WCHAR * TempVal = NULL;
    hr = StringFromCLSID( m_DefaultTransition, &TempVal );
    if( FAILED( hr ) )
    {
        return hr;
    }
    *pGuid = SysAllocString( TempVal );
    CoTaskMemFree( TempVal );
    if( !(*pGuid) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
// flag an error back to the app.
//############################################################################

HRESULT _GenerateError( 
                       IAMTimelineObj * pObj, 
                       long Severity, 
                       WCHAR * pErrorString, 
                       LONG ErrorCode, 
                       HRESULT hresult, 
                       VARIANT * pExtraInfo )
{
    HRESULT hr = hresult;
    if( pObj )
    {
        IAMTimeline * pTimeline = NULL;
        pObj->GetTimelineNoRef( &pTimeline );
        if( pTimeline )
        {
            CAMTimeline * pCTimeline = static_cast<CAMTimeline*>( pTimeline );
            pCTimeline->_GenerateError( Severity, pErrorString, ErrorCode, ErrorCode, pExtraInfo );
        }
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimeline::ValidateSourceNames
    ( long ValidateFlags, IMediaLocator * pOverride, LONG_PTR lNotifyEventHandle )
{
    BOOL Replace = 
        ( ( ValidateFlags & SFN_VALIDATEF_REPLACE ) == SFN_VALIDATEF_REPLACE );
    BOOL IgnoreMuted = 
        ( ( ValidateFlags & SFN_VALIDATEF_IGNOREMUTED ) == SFN_VALIDATEF_IGNOREMUTED );
    BOOL DoCheck = ( ( ValidateFlags & SFN_VALIDATEF_CHECK ) == SFN_VALIDATEF_CHECK );

    if( !Replace || !DoCheck )
    {
        return E_INVALIDARG;
    }

    HANDLE NotifyEventHandle = (HANDLE) lNotifyEventHandle;
    if( NotifyEventHandle ) ResetEvent( NotifyEventHandle );

    HRESULT hr = 0;
    CComPtr< IMediaLocator > pLoc;
    if( pOverride )
    {
        pLoc = pOverride;
    }
    else
    {
        hr = CoCreateInstance(
            CLSID_MediaLocator,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMediaLocator,
            (void**) &pLoc );
        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    // create a media locator for us to check

    for( int Group = 0 ; Group < m_nGroups ; Group++ )
    {
        // get the group
        //
        CComPtr< IAMTimelineObj > pObj = m_pGroup[Group];
        CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pObj );
        CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pComp( pObj );

        // ask timeline for how many layers and tracks we've got
        //
        long TrackCount = 0;   // tracks only
        long LayerCount = 0;       // tracks including compositions
        GetCountOfType( Group, &TrackCount, &LayerCount, TIMELINE_MAJOR_TYPE_TRACK );
        if( TrackCount < 1 )
        {
            continue;
        }

        for(  int CurrentLayer = 0 ; CurrentLayer < LayerCount ; CurrentLayer++ )
        {
            // get the layer itself
            //
            CComPtr< IAMTimelineObj > pLayer;
            hr = pComp->GetRecursiveLayerOfType( &pLayer, CurrentLayer, TIMELINE_MAJOR_TYPE_TRACK );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                continue; // audio layers
            }

            // if it's not an actual TRACK, then continue, who cares
            //
            CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > pTrack( pLayer );
            if( !pTrack )
            {
                continue; // audio layers
            }

            // run all the sources on this layer
            //
            REFERENCE_TIME InOut = 0;
            while( 1 )
            {
                CComPtr< IAMTimelineObj > pSourceObj;
                hr = pTrack->GetNextSrc( &pSourceObj, &InOut );

                // ran out of sources, so we're done
                //
                if( hr != NOERROR )
                {
                    break;
                }

                BOOL Muted = FALSE;
                pSourceObj->GetMuted( &Muted );
                if( Muted && IgnoreMuted )
                {
                    continue;
                }

                CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( pSourceObj );
                CComBSTR bszMediaName;
                hr = pSource->GetMediaName( &bszMediaName );
                if( FAILED( hr ) )
                {
                    continue; // ignore it, doesn't have to work
                }

                // can this happen?
                //
                if( bszMediaName[0] == 0 )
                {
                    continue;
                }

                HRESULT FoundHr = 0;
                CComBSTR FoundName;

                // validate the name here
                //
                FoundHr = pLoc->FindMediaFile( bszMediaName, NULL, &FoundName, ValidateFlags );

                if( FoundHr == S_FALSE )
                {
                    pSource->SetMediaName( FoundName );
                }
            } // while sources

        } // while layers

    } // while groups

    if( NotifyEventHandle ) SetEvent( NotifyEventHandle );
    return NOERROR;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::SetSite
// remember who our container is, for QueryService or other needs
STDMETHODIMP CAMTimeline::SetSite(IUnknown *pUnkSite)
{
    // note: we cannot addref our site without creating a circle
    // luckily, it won't go away without releasing us first.
    m_punkSite = pUnkSite;
    
    return S_OK;
}

//############################################################################
// 
//############################################################################
// IObjectWithSite::GetSite
// return an addrefed pointer to our containing object
STDMETHODIMP CAMTimeline::GetSite(REFIID riid, void **ppvSite)
{
    if (m_punkSite)
        return m_punkSite->QueryInterface(riid, ppvSite);
    
    return E_NOINTERFACE;
}

//############################################################################
// 
//############################################################################
// Forward QueryService calls up to the "real" host
STDMETHODIMP CAMTimeline::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
    IServiceProvider *pSP;
    
    if (!m_punkSite)
        return E_NOINTERFACE;
    
    HRESULT hr = m_punkSite->QueryInterface(IID_IServiceProvider, (void **) &pSP);
    
    if (SUCCEEDED(hr)) {
        hr = pSP->QueryService(guidService, riid, ppvObject);
        pSP->Release();
    }
    
    return hr;
}

//############################################################################
// 
//############################################################################
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbfx.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineEffect::CAMTimelineEffect( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
    , m_bRealSave( FALSE )
    , m_nSaveLength( 0 )
{
    m_ClassID = CLSID_AMTimelineEffect;
    m_TimelineType = TIMELINE_MAJOR_TYPE_EFFECT;
    XSetPriorityOverTime( );
}

//############################################################################
// 
//############################################################################

CAMTimelineEffect::~CAMTimelineEffect( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineEffect )
    {
        return GetInterface( (IAMTimelineEffect*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    if( riid == IID_IPropertyBag )
    {
        return GetInterface( (IPropertyBag*) this, ppv );
    }
    if( riid == IID_IStream )
    {
        return GetInterface( (IStream*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::EffectGetPriority(long * pVal)
{
    CheckPointer( pVal, E_POINTER );

    HRESULT hr = XWhatPriorityAmI( TIMELINE_MAJOR_TYPE_EFFECT, pVal );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::SplitAt2( REFTIME t )
{
    REFERENCE_TIME t1 = DoubleToRT( t );
    return SplitAt( t1 );
}

STDMETHODIMP CAMTimelineEffect::SplitAt( REFERENCE_TIME SplitTime )
{
    // is our split time withIN our time?
    //
    if( SplitTime <= m_rtStart || SplitTime >= m_rtStop )
    {
        return E_INVALIDARG;
    }

    // we need to be attached to something.
    //
    IAMTimelineObj * pParent;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;
    CAMTimelineEffect * pNew = new CAMTimelineEffect( NAME("Timeline Effect"), NULL, &hr );
    if( FAILED( hr ) )
    {
        return E_OUTOFMEMORY;
    }

    // we have created an object that has NO references on it. If we call ANYTHING that
    // addreffs and releases the pNewSrc, it will be deleted. So addref it NOW.

    pNew->AddRef( );

    hr = CopyDataTo( pNew, SplitTime );
    if( FAILED( hr ) )
    {
        delete pNew;
        return hr;
    }

    pNew->m_rtStart = SplitTime;
    pNew->m_rtStop = m_rtStop;
    m_rtStop = SplitTime;

    // get our priority
    //
    long Priority = 0;
    hr = EffectGetPriority( &Priority );

    // need to add the new transition to the tree
    //
    CComQIPtr< IAMTimelineEffectable, &IID_IAMTimelineEffectable > pEffectable( pParent );
    hr = pEffectable->EffectInsBefore( pNew, Priority + 1 );

    if( !FAILED( hr ) )
    {
        pNew->Release( );
    }

    return hr;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::SetSubObject(IUnknown* newVal)
{
    HRESULT hr = 0;

    hr = CAMTimelineObj::SetSubObject( newVal );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffect::GetStartStop2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1;
    REFERENCE_TIME p2;
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineEffect::GetStartStop
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    HRESULT hr = CAMTimelineObj::GetStartStop( pStart, pStop );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // make sure the times we got don't exceed our parent's
    //
    IAMTimelineObj * pParent = NULL;
    hr = XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return NOERROR;
    }
    REFERENCE_TIME ParentStart = *pStart;
    REFERENCE_TIME ParentStop = *pStop;
    hr = pParent->GetStartStop( &ParentStart, &ParentStop );
    if( FAILED( hr ) )
    {
        return NOERROR;
    }
    REFERENCE_TIME ParentDuration = ParentStop - ParentStart;
    if( *pStart < 0 )
    {
        *pStart = 0;
    }
    if( *pStart > ParentDuration )
    {
        *pStart = ParentDuration;
    }
    if( *pStop > ParentDuration )
    {
        *pStop = ParentDuration;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldb.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#define MAX_TIMELINE_GROUPS 32

#include "..\errlog\cerrlog.h"
#include "..\util\conv.cxx"

// forward reference
//
class CAMTimeline;
class CAMTimelineObj;
class CAMTimelineSrc;
class CAMTimelineVirtualTrack;
class CAMTimelineTrack;
class CAMTimelineEffect;
class CAMTimelineComp;
class CAMTimelineGroup;
class CAMTimelineTransable;

//########################################################################
//########################################################################

class CAMTimelineNode : public IAMTimelineNode
{
    friend CAMTimeline;

    CComPtr< IAMTimelineObj > m_pParent;
    CComPtr< IAMTimelineObj > m_pPrev;
    CComPtr< IAMTimelineObj > m_pNext;
    CComPtr< IAMTimelineObj > m_pKid;
    BOOL m_bPriorityOverTime;

protected:

    // helper methods
    //
    void                XAddKid( IAMTimelineObj * p );
    IAMTimelineObj *    XGetLastKidNoRef( );
    STDMETHODIMP        XRemoveOnlyMe( );
    IAMTimelineObj *    XGetFirstKidNoRef( );

    // not needed outside of the node
    //
    STDMETHODIMP XGetPrev( IAMTimelineObj ** ppResult );
    STDMETHODIMP XSetPrev( IAMTimelineObj * pVal );
    STDMETHODIMP XSetParent( IAMTimelineObj * pVal );
    STDMETHODIMP XGetNext( IAMTimelineObj ** ppResult );
    STDMETHODIMP XSetNext( IAMTimelineObj * pVal );
    STDMETHODIMP XGetPrevNoRef( IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetNextNoRef( IAMTimelineObj ** ppResult );
    STDMETHODIMP XClearAllKids( );
    STDMETHODIMP XResetFirstKid( IAMTimelineObj * p );                    // special
    STDMETHODIMP XInsertKidBeforeKid( IAMTimelineObj * pToAdd, IAMTimelineObj * pIndirectObject );
    STDMETHODIMP XInsertKidAfterKid( IAMTimelineObj * pKid, IAMTimelineObj * pIndirectObject );
    STDMETHODIMP XHavePrev( long * pVal ) { return E_NOTIMPL; }
    STDMETHODIMP XHaveNext( long * pVal ) { return E_NOTIMPL; }

    CAMTimelineNode( );

public:

    ~CAMTimelineNode( );

    // IAMTimelineNode
    //
    STDMETHODIMP XSetPriorityOverTime( ) { m_bPriorityOverTime = TRUE; return NOERROR; }
    STDMETHODIMP XGetPriorityOverTime( BOOL * pResult );
    STDMETHODIMP XGetNextOfType( long MajorType, IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetNextOfTypeNoRef( long MajorType, IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetParent( IAMTimelineObj ** ppResult );
    STDMETHODIMP XGetParentNoRef( IAMTimelineObj ** ppResult );
    STDMETHODIMP XHaveParent( long * pVal );
    // kid functions!
    STDMETHODIMP XGetNthKidOfType( long MajorType, long WhichKid, IAMTimelineObj ** ppResult );
    STDMETHODIMP XKidsOfType( long MajorType, long * pVal );
    STDMETHODIMP XAddKidByPriority( long MajorType, IAMTimelineObj * pToAdd, long Priority );
    STDMETHODIMP XAddKidByTime( long MajorType, IAMTimelineObj * pToAdd );
    STDMETHODIMP XSwapKids( long MajorType, long KidA, long KidB );
    STDMETHODIMP XRemove( );
    STDMETHODIMP XWhatPriorityAmI( long MajorType, long * pVal );

    BOOL HasPriorityOverTime( ) { return m_bPriorityOverTime; }
};

//########################################################################
//########################################################################

class CAMTimelineObj 
    : public CUnknown
    , public CAMTimelineNode
    , public IAMTimelineObj
    , public IPersistStream
{
friend class CAMTimelineObj;
friend class CAMTimelineSrc;
friend class CAMTimelineTrack;
friend class CAMTimelineEffect;
friend class CAMTimelineComp;
friend class CAMTimelineTransable;

    static long         m_nStaticGenID;

protected:

    CComPtr< IPropertySetter > m_pSetter;
    CComPtr< IUnknown > m_pSubObject;
    GUID                m_ClassID;
    TIMELINE_MAJOR_TYPE m_TimelineType;
    long                m_UserID;
    WCHAR               m_UserName[256];
    REFERENCE_TIME      m_rtStart;
    REFERENCE_TIME      m_rtStop;
    GUID                m_SubObjectGuid;
    BOOL                m_bMuted;
    REFERENCE_TIME      m_rtDirtyStart;
    REFERENCE_TIME      m_rtDirtyStop;
    BOOL                m_bLocked;
    BYTE *              m_pUserData;
    long                m_nUserDataSize;
    long                m_nGenID;

    void                _Clear( );
    void                _ClearSubObject( );
    GUID                _GetObjectGuid( IUnknown * pObject );
    void                _BumpGenID( );

    CAMTimelineObj( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineObj( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineObj
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetStartStop2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP GetSubObject(IUnknown* *pVal);
    STDMETHODIMP GetSubObjectLoaded(BOOL*pVal);
    STDMETHODIMP SetSubObject(IUnknown* newVal);
    STDMETHODIMP SetSubObjectGUID(GUID newVal);
    STDMETHODIMP GetSubObjectGUID(GUID * pVal);
    STDMETHODIMP SetSubObjectGUIDB(BSTR newVal);
    STDMETHODIMP GetSubObjectGUIDB(BSTR * pVal);
    STDMETHODIMP GetTimelineType(TIMELINE_MAJOR_TYPE * pVal);
    STDMETHODIMP SetTimelineType(TIMELINE_MAJOR_TYPE newVal);
    STDMETHODIMP GetUserID(long * pVal);
    STDMETHODIMP SetUserID(long newVal);
    STDMETHODIMP GetGenID(long * pVal);
    STDMETHODIMP GetUserName(BSTR * pVal);
    STDMETHODIMP SetUserName(BSTR newVal);
    STDMETHODIMP GetPropertySetter(IPropertySetter **pVal);
    STDMETHODIMP SetPropertySetter(IPropertySetter *pVal);
    STDMETHODIMP GetUserData(BYTE * pData, long * pSize);
    STDMETHODIMP SetUserData(BYTE * pData, long Size);
    STDMETHODIMP GetMuted(BOOL * pVal);
    STDMETHODIMP SetMuted(BOOL newVal);
    STDMETHODIMP GetLocked(BOOL * pVal);
    STDMETHODIMP SetLocked(BOOL newVal);
    STDMETHODIMP GetDirtyRange(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetDirtyRange2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetDirtyRange(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetDirtyRange2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP ClearDirty( );
    STDMETHODIMP Remove();
    STDMETHODIMP RemoveAll();
    STDMETHODIMP GetTimelineNoRef( IAMTimeline ** ppResult );
    STDMETHODIMP FixTimes( REFERENCE_TIME * pStart, REFERENCE_TIME * pStop );
    STDMETHODIMP FixTimes2( REFTIME * pStart, REFTIME * pStop );
    STDMETHODIMP GetGroupIBelongTo( IAMTimelineGroup ** ppGroup );
    STDMETHODIMP GetEmbedDepth( long * pVal );

    // IPersistStream
    STDMETHODIMP GetClassID( GUID * pVal );
    STDMETHODIMP IsDirty( );
    STDMETHODIMP Load( IStream * pStream );
    STDMETHODIMP Save( IStream * pStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER * pcbSize );

    // public helper functions
    //
    HRESULT CopyDataTo( IAMTimelineObj * pSource, REFERENCE_TIME TimelineTime );
};

//########################################################################
//########################################################################

class CAMTimelineEffectable
    : public IAMTimelineEffectable
{
    friend CAMTimeline;
    friend CAMTimelineTrack;

protected:

    CAMTimelineEffectable( );

    STDMETHODIMP Load( IStream * pStream );
    STDMETHODIMP Save( IStream * pStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER * pcbSize );

public:

    ~CAMTimelineEffectable( );

    // IAMTimelineEffectable
    STDMETHODIMP EffectInsBefore(IAMTimelineObj * pFX, long priority);
    STDMETHODIMP EffectSwapPriorities(long PriorityA, long PriorityB);
    STDMETHODIMP EffectGetCount(long * pCount);
    STDMETHODIMP GetEffect(IAMTimelineObj ** ppFx, long Which);

};

//########################################################################
//########################################################################

class CAMTimelineTransable
    : public IAMTimelineTransable
{
    bool _IsSpaceAvailable( REFERENCE_TIME Start, REFERENCE_TIME Stop );

protected:

    CAMTimelineTransable( );

public:

    ~CAMTimelineTransable( );

    // IAMTimelineTransable
    STDMETHODIMP TransAdd(IAMTimelineObj * pTrans);
    STDMETHODIMP TransGetCount(long * pCount);
    STDMETHODIMP GetNextTrans(IAMTimelineObj ** ppTrans, REFERENCE_TIME * pInOut);
    STDMETHODIMP GetNextTrans2(IAMTimelineObj ** ppTrans, REFTIME * pInOut);
    STDMETHODIMP GetTransAtTime(IAMTimelineObj ** ppObj, REFERENCE_TIME Time, long SearchDirection ); 
    STDMETHODIMP GetTransAtTime2(IAMTimelineObj ** ppObj, REFTIME Time, long SearchDirection ); 
};

//########################################################################
//########################################################################

class CAMTimelineEffect
    : public CAMTimelineObj
    , public IAMTimelineEffect
    , public IAMTimelineSplittable
{
    friend CAMTimeline;

    BOOL m_bRealSave;
    long m_nSaveLength;

    CAMTimelineEffect( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineEffect( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineEffect
    STDMETHODIMP EffectGetPriority(long * pVal);

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);

    // IAMTimelineObj overrides
    STDMETHODIMP        SetSubObject(IUnknown* newVal);
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
};

//########################################################################
//########################################################################

class CAMTimelineTrans
    : public CAMTimelineObj
    , public IAMTimelineTrans
    , public IAMTimelineSplittable
{
    friend CAMTimeline;

    REFERENCE_TIME  m_rtCut;
    BOOL            m_fSwapInputs;
    BOOL            m_bCutsOnly;

    CAMTimelineTrans( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineTrans( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineTrans
    STDMETHODIMP GetCutPoint(REFERENCE_TIME * pTLTime);
    STDMETHODIMP SetCutPoint(REFERENCE_TIME TLTime);
    STDMETHODIMP GetCutPoint2(REFTIME * pTLTime);
    STDMETHODIMP SetCutPoint2(REFTIME TLTime);
    STDMETHODIMP GetSwapInputs( BOOL * pVal );
    STDMETHODIMP SetSwapInputs( BOOL Val );
    STDMETHODIMP GetCutsOnly( BOOL * pVal );
    STDMETHODIMP SetCutsOnly( BOOL Val );

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);
};

//########################################################################
//########################################################################

class CAMTimelineSrc 
    : public CAMTimelineObj
    , public CAMTimelineTransable
    , public CAMTimelineEffectable
    , public IAMTimelineSplittable
    , public IAMTimelineSrc
    , public IAMTimelineSrcPriv
{
    friend CAMTimeline;
    friend CAMTimelineTrack;

protected:

    REFERENCE_TIME  m_rtMediaStart;
    REFERENCE_TIME  m_rtMediaStop;
    REFERENCE_TIME  m_rtMediaLength;
    long            m_nStreamNumber;
    double          m_dDefaultFPS;
    int             m_nStretchMode;
    BOOL            m_bIsRecompressable;
    BOOL            m_bToldIsRecompressable;

    // the media name is ONLY used for the programmer's convenience.
    // the user need not get/set it, and it's just a placeholder for
    // a name.
    WCHAR           m_szMediaName[_MAX_PATH];

    CAMTimelineSrc( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineSrc( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    ULONG _stdcall NonDelegatingAddRef( )
    {
        return CUnknown::NonDelegatingAddRef( );
    }
    ULONG _stdcall NonDelegatingRelease( )
    {
        return CUnknown::NonDelegatingRelease( );
    }

    // IAMTimelineSrc
    STDMETHODIMP GetMediaTimes(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetMediaTimes2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetMediaTimes(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetMediaTimes2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP GetMediaName(BSTR * pVal);
    STDMETHODIMP SetMediaName(BSTR newVal);
    STDMETHODIMP SpliceWithNext(IAMTimelineObj * pNext);
    STDMETHODIMP FixMediaTimes(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP FixMediaTimes2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP GetStreamNumber(long * pVal);
    STDMETHODIMP SetStreamNumber(long Val);
    STDMETHODIMP SetMediaLength(REFERENCE_TIME Length);
    STDMETHODIMP SetMediaLength2(REFTIME Length);
    STDMETHODIMP GetMediaLength(REFERENCE_TIME * pLength);
    STDMETHODIMP GetMediaLength2(REFTIME * pLength);
    STDMETHODIMP ModifyStopTime(REFERENCE_TIME Stop);
    STDMETHODIMP ModifyStopTime2(REFTIME Stop);
    STDMETHODIMP GetDefaultFPS(double * pFPS);
    STDMETHODIMP SetDefaultFPS(double FPS);
    STDMETHODIMP GetStretchMode(int * pnStretchMode);
    STDMETHODIMP SetStretchMode(int nStretchMode);
    STDMETHODIMP IsNormalRate( BOOL * pVal );

    // IAMTimelineObj override
    STDMETHODIMP SetStartStop( REFERENCE_TIME Start, REFERENCE_TIME Stop );

    // IAMTimelineSrcPriv
    STDMETHODIMP SetIsRecompressable( BOOL Val );
    STDMETHODIMP GetIsRecompressable( BOOL * pVal );
    STDMETHODIMP ClearAnyKnowledgeOfRecompressability( );

    // IPersistOverride
    STDMETHODIMP Load( IStream * pStream );
    STDMETHODIMP Save( IStream * pStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER * pcbSize );

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);
};

//########################################################################
//########################################################################

class CAMTimelineTrack
    : public CAMTimelineObj
    , public CAMTimelineEffectable
    , public CAMTimelineTransable
    , public IAMTimelineTrack
    , public IAMTimelineVirtualTrack
    , public IAMTimelineSplittable
{
    friend CAMTimeline;

protected:

    CAMTimelineTrack( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineTrack( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineTrack
    STDMETHODIMP SrcAdd(IAMTimelineObj * pSource);
    STDMETHODIMP GetNextSrc(IAMTimelineObj ** ppSrc, REFERENCE_TIME * pInOut);
    STDMETHODIMP GetNextSrc2(IAMTimelineObj ** ppSrc, REFTIME * pInOut);
    STDMETHODIMP MoveEverythingBy( REFERENCE_TIME Start, REFERENCE_TIME MoveBy );
    STDMETHODIMP MoveEverythingBy2( REFTIME Start, REFTIME MoveBy );
    STDMETHODIMP GetSourcesCount( long * pVal );
    STDMETHODIMP AreYouBlank( long * pVal );
    STDMETHODIMP GetSrcAtTime(IAMTimelineObj ** ppSrc, REFERENCE_TIME Time, long SearchDirection ); 
    STDMETHODIMP GetSrcAtTime2(IAMTimelineObj ** ppSrc, REFTIME Time, long SearchDirection ); 
    STDMETHODIMP InsertSpace( REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd );
    STDMETHODIMP InsertSpace2( REFTIME rtStart, REFTIME rtEnd );
    STDMETHODIMP ZeroBetween( REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd );
    STDMETHODIMP ZeroBetween2( REFTIME rtStart, REFTIME rtEnd );
    STDMETHODIMP GetNextSrcEx(IAMTimelineObj * pLast, IAMTimelineObj **ppNext);

    // IAMTimelineVirtualTrack
    STDMETHODIMP TrackGetPriority(long * pPriority);
    STDMETHODIMP SetTrackDirty( );

    // IAMTimelineSplittable
    STDMETHODIMP SplitAt(REFERENCE_TIME Time);
    STDMETHODIMP SplitAt2(REFTIME Time);

    // IAMTimelineObj
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetStartStop2(REFTIME Start, REFTIME Stop);
};

//########################################################################
//########################################################################

class CAMTimelineComp
    : public CAMTimelineObj
    , public CAMTimelineEffectable
    , public CAMTimelineTransable
    , public IAMTimelineComp
    , public IAMTimelineVirtualTrack
{
    friend CAMTimeline;
    friend CAMTimelineGroup;

protected:

    CAMTimelineComp( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineComp( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    ULONG _stdcall NonDelegatingAddRef( )
    {
        return CUnknown::NonDelegatingAddRef( );
    }
    ULONG _stdcall NonDelegatingRelease( )
    {
        return CUnknown::NonDelegatingRelease( );
    }

    // IAMTimelineComp
    STDMETHODIMP VTrackInsBefore(IAMTimelineObj * pVirtualTrack, long Priority);
    STDMETHODIMP VTrackSwapPriorities(long VirtualTrackA, long VirtualTrackB);
    STDMETHODIMP VTrackGetCount(long * pVal);
    STDMETHODIMP GetVTrack(IAMTimelineObj ** ppVirtualTrack, long Which);
    STDMETHODIMP GetCountOfType(long * pCount, long * pCountWithComps, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP GetRecursiveLayerOfTypeI(IAMTimelineObj ** ppVirtualTrack, long * pWhich, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP GetRecursiveLayerOfType(IAMTimelineObj ** ppVirtualTrack, long Which, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP GetNextVTrack(IAMTimelineObj *pVirtualTrack, IAMTimelineObj **ppNextVirtualTrack);

    // IAMTimelineVirtualTrack
    STDMETHODIMP TrackGetPriority(long * pPriority);
    STDMETHODIMP SetTrackDirty( );

    // IAMTimelineObj
    STDMETHODIMP GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetStartStop2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetStartStop2(REFTIME Start, REFTIME Stop);
};

//########################################################################
//########################################################################

class CAMTimelineGroup
    : public CAMTimelineComp
    , public IAMTimelineGroup
{
    friend CAMTimeline;

    long                    m_nPriority;
    double                  m_dFPS;
    IAMTimeline *           m_pTimeline; // no longer refcounted
    AM_MEDIA_TYPE           m_MediaType;
    WCHAR                   m_szGroupName[_MAX_PATH];
    BOOL                    m_fPreview;
    int                     m_nOutputBuffering;

    CMediaType              m_RecompressType;
    BOOL                    m_bRecompressTypeSet;
    BOOL                    m_bRecompressFormatDirty;

    CAMTimelineGroup( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );

public:

    ~CAMTimelineGroup( );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    // IAMTimelineGroup
    STDMETHODIMP GetPriority( long * pPriority );
    STDMETHODIMP GetMediaType( AM_MEDIA_TYPE * );
    STDMETHODIMP SetMediaType( AM_MEDIA_TYPE * );
    STDMETHODIMP SetOutputFPS(double FPS);
    STDMETHODIMP GetOutputFPS(double * pFPS);
    STDMETHODIMP SetTimeline( IAMTimeline * pTimeline );
    STDMETHODIMP GetTimeline( IAMTimeline ** ppTimeline );
    STDMETHODIMP SetGroupName( BSTR GroupName );
    STDMETHODIMP GetGroupName( BSTR * pGroupName );
    STDMETHODIMP SetPreviewMode( BOOL fPreview );
    STDMETHODIMP GetPreviewMode( BOOL *pfPreview );
    STDMETHODIMP SetMediaTypeForVB( long Val );
    STDMETHODIMP SetOutputBuffering( int nBuffer );
    STDMETHODIMP GetOutputBuffering( int *pnBuffer );
    STDMETHODIMP SetSmartRecompressFormat( long * pFormat );
    STDMETHODIMP GetSmartRecompressFormat( long ** ppFormat );
    STDMETHODIMP IsSmartRecompressFormatSet( BOOL * pVal );
    STDMETHODIMP IsRecompressFormatDirty( BOOL * pVal );
    STDMETHODIMP ClearRecompressFormatDirty( );
    STDMETHODIMP SetRecompFormatFromSource( IAMTimelineSrc * pSource );

    // IPersistStream overrides
    STDMETHODIMP Load( IStream * pStream );
    STDMETHODIMP Save( IStream * pStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER * pcbSize );

    // IAMTimelineObj overrides
    STDMETHODIMP Remove();
    STDMETHODIMP RemoveAll();
};

//########################################################################
//########################################################################

class CAMTimeline 
    : public CUnknown
    , public IAMTimeline
    , public CAMSetErrorLog
    , public IPersistStream
    , public IServiceProvider
    , public IObjectWithSite
{
private:

    CComPtr< IAMTimelineObj > m_pGroup[MAX_TIMELINE_GROUPS];
    CComPtr< IAMErrorLog > m_pErrorLog;
    long                m_nGroups;
    long                m_nInsertMode;
    long                m_nSpliceMode;
    double              m_dDefaultFPS;
    BOOL                m_bTransitionsEnabled;
    BOOL                m_bEffectsEnabled;
    GUID                m_DefaultTransition;
    GUID                m_DefaultEffect;

public:

    CAMTimeline( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr );
    ~CAMTimeline( );

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance( LPUNKNOWN pUnk, HRESULT *phr );

    // needed to override CBaseUnknown
    DECLARE_IUNKNOWN

    // override to return our special interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    ULONG _stdcall NonDelegatingAddRef( )
    {
        return CUnknown::NonDelegatingAddRef( );
    }
    ULONG _stdcall NonDelegatingRelease( )
    {
        return CUnknown::NonDelegatingRelease( );
    }

    // IAMTimeline
    STDMETHODIMP CreateEmptyNode( IAMTimelineObj ** ppObj, TIMELINE_MAJOR_TYPE TimelineType );
    STDMETHODIMP AddGroup( IAMTimelineObj * pGroup );
    STDMETHODIMP RemGroupFromList( IAMTimelineObj * pGroup );
    STDMETHODIMP GetGroup( IAMTimelineObj ** ppGroup, long WhichGroup );
    STDMETHODIMP GetGroupCount( long * pCount );
    STDMETHODIMP ClearAllGroups( );
    STDMETHODIMP GetInsertMode( long * pMode );
    STDMETHODIMP SetInsertMode(long Mode);
    STDMETHODIMP EnableTransitions(BOOL fEnabled);
    STDMETHODIMP EnableEffects(BOOL fEnabled);
    STDMETHODIMP TransitionsEnabled(BOOL * pfEnabled);
    STDMETHODIMP EffectsEnabled(BOOL * pfEnabled);
    STDMETHODIMP SetInterestRange(REFERENCE_TIME Start, REFERENCE_TIME Stop);
    STDMETHODIMP SetInterestRange2(REFTIME Start, REFTIME Stop);
    STDMETHODIMP GetDuration(REFERENCE_TIME * pDuration);
    STDMETHODIMP GetDuration2(REFTIME * pDuration);
    STDMETHODIMP IsDirty(BOOL * pDirty);
    STDMETHODIMP GetDirtyRange(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop);
    STDMETHODIMP GetDirtyRange2(REFTIME * pStart, REFTIME * pStop);
    STDMETHODIMP GetCountOfType(long Group, long * pCount, long * pCountWithComps, TIMELINE_MAJOR_TYPE Type);
    STDMETHODIMP SetDefaultFPS( double FPS );
    STDMETHODIMP GetDefaultFPS( double * pFPS );
    STDMETHODIMP SetDefaultTransition( GUID * pGuid );
    STDMETHODIMP GetDefaultTransition( GUID * pGuid );
    STDMETHODIMP SetDefaultEffect( GUID * pGuid );
    STDMETHODIMP GetDefaultEffect( GUID * pGuid );
    STDMETHODIMP SetDefaultTransitionB( BSTR pGuid );
    STDMETHODIMP GetDefaultTransitionB( BSTR * pGuid );
    STDMETHODIMP SetDefaultEffectB( BSTR pGuid );
    STDMETHODIMP GetDefaultEffectB( BSTR * pGuid );
    STDMETHODIMP ValidateSourceNames( long ValidateFlags, IMediaLocator * pChainer, LONG_PTR NotifyEventHandle );

    // IPersistStream
    STDMETHODIMP GetClassID( GUID * pVal );
    STDMETHODIMP IsDirty( );
    STDMETHODIMP Load( IStream * pStream );
    STDMETHODIMP Save( IStream * pStream, BOOL fClearDirty );
    STDMETHODIMP GetSizeMax( ULARGE_INTEGER * pcbSize );

    // public methods
    REFERENCE_TIME Fixup( REFERENCE_TIME Time );
    
    // --- IObjectWithSite methods
    // This interface is here so we can keep track of the context we're
    // living in.
    STDMETHODIMP    SetSite(IUnknown *pUnkSite);
    STDMETHODIMP    GetSite(REFIID riid, void **ppvSite);

    IUnknown *       m_punkSite;

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

};


extern int function_not_done;
extern double TIMELINE_DEFAULT_FPS;
extern HRESULT _GenerateError( IAMTimelineObj * pObj, long Severity, WCHAR * pErrorString, LONG ErrorCode, HRESULT hresult, VARIANT * pExtraInfo = NULL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbfxbl.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

const long OUR_STREAM_VERSION = 0;

//############################################################################
// 
//############################################################################

CAMTimelineEffectable::CAMTimelineEffectable( )
{
}

//############################################################################
// 
//############################################################################

CAMTimelineEffectable::~CAMTimelineEffectable( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::EffectInsBefore
    (IAMTimelineObj * pFX, long priority)
{
    HRESULT hr = 0;

    // make sure somebody's really inserting an effect
    //
    CComQIPtr< IAMTimelineEffect, &IID_IAMTimelineEffect > pEffect( pFX );
    if( !pEffect )
    {
        return E_NOTIMPL;
    }

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );
    hr = pThis->XAddKidByPriority( TIMELINE_MAJOR_TYPE_EFFECT, pFX, priority );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::EffectSwapPriorities
    (long PriorityA, long PriorityB)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    hr = pThis->XSwapKids( TIMELINE_MAJOR_TYPE_EFFECT, PriorityA, PriorityB );

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::EffectGetCount
    (long * pCount)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    CheckPointer( pCount, E_POINTER );

    hr = pThis->XKidsOfType( TIMELINE_MAJOR_TYPE_EFFECT, pCount );

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::GetEffect
    (IAMTimelineObj ** ppFx, long Which)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    CheckPointer( ppFx, E_POINTER );

    hr = pThis->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_EFFECT, Which, ppFx );

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::Save( IStream * pStream, BOOL fClearDirty )
{
    HRESULT hr = 0;

    // go through and write out all our effects
    //
    long Count = 0;
    hr = EffectGetCount( &Count );

    // write out a version
    //
    long Version = OUR_STREAM_VERSION;
    pStream->Write( &Version, sizeof( long ), NULL );

    // write out how many effects
    //
    pStream->Write( &Count, sizeof( Count ), NULL );

    if( !Count )
    {
        return NOERROR;
    }

    // write out each effect
    //
    for( int i = 0 ; i < Count ; i++ )
    {
        CComPtr< IAMTimelineObj > pEffect;
        hr = GetEffect( &pEffect, i );
        ASSERT( !FAILED( hr ) );
        if( !FAILED( hr ) )
        {
            CComQIPtr< IPersistStream, &IID_IPersistStream > pPersist( pEffect );
            ASSERT( pPersist );
            if( pPersist )
            {
                hr = pPersist->Save( pStream, fClearDirty );
            }
        }
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineEffectable::Load( IStream * pStream )
{
    HRESULT hr = 0;

    // we're bad if we already have some effects
    //
    long Count = 0;
    hr = EffectGetCount( &Count );
    ASSERT( !Count );
    if( Count )
    {
        return E_INVALIDARG;
    }

    // read in our version
    //
    long Version = 0;
    hr = pStream->Read( &Version, sizeof( long ), NULL );

    // read in how many effects
    //
    Count = 0;
    hr = pStream->Read( &Count, sizeof( Count ), NULL );

    if( !Count )
    {
        return NOERROR;
    }

    // get the timeline we belong to, so we can create
    // effects and add them to the tree
    //
    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pObj( this );
    ASSERT( pObj );
    IAMTimeline * pTimeline = NULL;
    hr = pObj->GetTimelineNoRef( &pTimeline );
    ASSERT( pTimeline );

    // read in each effect
    //
    for( int i = 0 ; i < Count ; i++ )
    {
        CComPtr< IAMTimelineObj > pEffect;
        hr = pTimeline->CreateEmptyNode( &pEffect, TIMELINE_MAJOR_TYPE_EFFECT );
        ASSERT( pEffect );
        CComQIPtr< IPersistStream, &IID_IPersistStream > pPersist( pEffect );
        ASSERT( pPersist );
        // !!! not done

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbhelp.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// Tldb.cpp : Defines the entry point for the DLL application.
//

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"
#ifndef _WIN64
#include <dshowasf.h>
#endif
#include "..\util\filfuncs.h"

STDMETHODIMP CAMTimeline::GenerateAutoTransitions(  )
{
    return -1;
}

HRESULT GetOverlap(
                   IAMTimelineComp * pComp,
                   long Track,
                   REFERENCE_TIME Start,
                   REFERENCE_TIME Stop,
                   REFERENCE_TIME * pOverlapStart,
                   REFERENCE_TIME * pOverlapStop,
                   BOOL * pFadeOut )
{
    return -1;
}

HRESULT StripAnyWaveformEnvelopes( IAMTimelineObj * pObject )
{
    return -1;
}

STDMETHODIMP CAMTimeline::GenerateAutoFades( )
{
    // we are going to have to run through all audio groups and find out
    // where audio overlaps. During these spots, we will insert mixers and
    // set the envelopes right
    //
    for( int Group = 0 ; Group < m_nGroups ; Group++ )
    {
        // get the group
        //
        CComPtr< IAMTimelineObj > pObj = m_pGroup[Group];

        // ask if it's audio
        //
        CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( pObj );
        CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pComp( pObj );
        AM_MEDIA_TYPE MediaType;
        pGroup->GetMediaType( &MediaType );
        if( MediaType.majortype != MEDIATYPE_Audio )
        {
            continue;
        }

        // found a group with audio

        // ask timeline for how many layers and tracks we've got
        //
        long AudioTrackCount = 0;   // tracks only
        long AudioLayers = 0;       // tracks including compositions
        GetCountOfType( Group, &AudioTrackCount, &AudioLayers, TIMELINE_MAJOR_TYPE_TRACK );
        if( AudioTrackCount < 1 )
        {
            return NOERROR;
        }

        HRESULT hr = 0;

        // add source filters for each source on the timeline
        //
        for(  int CurrentLayer = 0 ; CurrentLayer < AudioLayers ; CurrentLayer++ )
        {
            // get the layer itself
            //
            CComPtr< IAMTimelineObj > pLayer;
            hr = pComp->GetRecursiveLayerOfType( &pLayer, CurrentLayer, TIMELINE_MAJOR_TYPE_TRACK );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                continue; // audio layers
            }

            // if it's not an actual TRACK, then continue, who cares
            //
            CComQIPtr< IAMTimelineTrack, &IID_IAMTimelineTrack > pTrack( pLayer );
            if( !pTrack )
            {
                continue; // audio layers
            }

            // find this track's parent. Tracks always have parents, and they're always comps.
            // find out how many tracks total this comp has
            //
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pLayer );
            if( !pNode )
            {
                // ???
                continue;
            }
            CComPtr< IAMTimelineObj > pParentObj;
            pNode->XGetParent( &pParentObj );
            CComQIPtr< IAMTimelineComp, &IID_IAMTimelineComp > pParentComp( pParentObj );
            ASSERT( pParentComp );
            long TrackCount = 0;
            pParentComp->VTrackGetCount( &TrackCount );

            // ask me what priority I am
            //
            CComQIPtr< IAMTimelineVirtualTrack, &IID_IAMTimelineVirtualTrack > pVirtualTrack( pLayer );
            long TrackPriority = 0;
            pVirtualTrack->TrackGetPriority( &TrackPriority );

            // run all the sources on this layer
            //
            REFERENCE_TIME InOut = 0;
            while( 1 )
            {
                CComPtr< IAMTimelineObj > pSourceObj;
                hr = pTrack->GetNextSrc( &pSourceObj, &InOut );
                ASSERT( !FAILED( hr ) );
                CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( pSourceObj );

                // ran out of sources, so we're done
                //
                if( hr != NOERROR )
                {
                    break;
                }

                // ask this source for it's start/stop times
                //
                REFERENCE_TIME SourceStart = 0;
                REFERENCE_TIME SourceStop = 0;
                hr = pSourceObj->GetStartStop( &SourceStart, &SourceStop );
                ASSERT( !FAILED( hr ) );

                // align times to nearest frame boundary
                //
                hr = pSourceObj->FixTimes( &SourceStart, &SourceStop );
                ASSERT( !FAILED( hr ) );

                // see if any of the other tracks have overlapping sources
                //
                for( long OtherTrack = TrackPriority + 1 ; OtherTrack < TrackCount ; OtherTrack++ )
                {
                    BOOL FadeOut = FALSE;
                    REFERENCE_TIME OverlapStart = 0;
                    REFERENCE_TIME OverlapStop = 0;
                    hr = GetOverlap( pParentComp, OtherTrack, SourceStart, SourceStop, &OverlapStart, &OverlapStop, &FadeOut );
                     if( hr != NOERROR )
                     {
                         continue;
                     }

                     // !!! found an overlap!

                     // make sure there aren't any waveform envelopes on it already
                     //
                     hr = StripAnyWaveformEnvelopes( pSourceObj );

                     CComPtr< IAMTimelineObj > pEffectObj;
                     CreateEmptyNode( &pEffectObj, TIMELINE_MAJOR_TYPE_EFFECT );
                     // !!! error check
                     pEffectObj->SetSubObjectGUID( CLSID_AudMixer );
                     // !!! make a waveform and put it on
                }

            } // while sources

        } // while layers

    } // while group

    return NOERROR;
}

HRESULT CAMTimeline::RunProcess( LPCOLESTR ProcessCommand )
{
    USES_CONVERSION;
    char * t = W2A( (WCHAR*) ProcessCommand );
    WinExec( (const char*) t, SW_SHOW );
    return 0;
}

STDMETHODIMP CAMTimeline::WriteBitmapToDisk( char * pBuffer, long BufferSize, BSTR Filename )
{
    USES_CONVERSION;
    TCHAR * t = W2T( Filename );

    HANDLE hf = CreateFile(
        t,
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL );

    WriteFile( hf, pBuffer, BufferSize, NULL, NULL );

    CloseHandle( hf );

    return 0;
}

STDMETHODIMP CAMTimeline::WriteSampleAsBitmap( IMediaSample * pSample, BSTR Filename )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAMTimeline::SetRecompFormatFromSource( IAMTimelineGroup * pGroup, IAMTimelineSrc * pSource )
{
    CheckPointer( pGroup, E_POINTER );
    CheckPointer( pSource, E_POINTER );

    CComBSTR Filename;
    HRESULT hr = 0;
    hr = pSource->GetMediaName(&Filename);
    if( FAILED( hr ) )
    {
        return hr;
    }

    SCompFmt0 * pFmt = new SCompFmt0;
    if( !pFmt )
    {
        return E_OUTOFMEMORY;
    }
    memset( pFmt, 0, sizeof( SCompFmt0 ) );

    pFmt->nFormatId = 0;

    // create a mediadet
    //
    CComPtr< IMediaDet > pDet;
    hr = CoCreateInstance( CLSID_MediaDet,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IMediaDet,
        (void**) &pDet );
    if( FAILED( hr ) )
    {
        delete pFmt;
        return hr;
    }

    //if( m_punkSite ) // do we care here??
    {
        //
        // set the site provider on the MediaDet object to allowed keyed apps
        // to use ASF filters with dexter
        //
        CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( pDet );
        ASSERT( pOWS );
        if( pOWS )
        {
            pOWS->SetSite( (IServiceProvider *) this );
        }
    }

    hr = pDet->put_Filename( Filename );
    if( FAILED( hr ) )
    {
        delete pFmt;
        return hr;
    }

    // go through and find the video stream type
    //
    long Streams = 0;
    long VideoStream = -1;
    hr = pDet->get_OutputStreams( &Streams );
    for( int i = 0 ; i < Streams ; i++ )
    {
        pDet->put_CurrentStream( i );
        GUID Major = GUID_NULL;
        pDet->get_StreamType( &Major );
        if( Major == MEDIATYPE_Video )
        {
            VideoStream = i;
            break;
        }
    }
    if( VideoStream == -1 )
    {
        delete pFmt;
        return VFW_E_INVALIDMEDIATYPE;
    }

    hr = pDet->get_StreamMediaType( &pFmt->MediaType );

    hr = pGroup->SetSmartRecompressFormat( (long*) pFmt );

    FreeMediaType( pFmt->MediaType );

    delete pFmt;

    return hr;
}


STDMETHODIMP CAMTimeline::ConnectAviFile( IRenderEngine * pEngine, BSTR Filename )
{
    return ConnectAsfFile(pEngine, Filename, NULL, -1);
}

STDMETHODIMP CAMTimeline::ConnectAsfFile( IRenderEngine * pEngine, BSTR Filename,
                                          GUID * pguidProfile, int iProfile )
{
#ifndef _WIN64
    CheckPointer( pEngine, E_POINTER );
    if( wcslen( Filename ) == 0 )
    {
        return E_INVALIDARG;
    }

    USES_CONVERSION;
    TCHAR * tFilename = W2T( Filename );
    HANDLE h = CreateFile( tFilename, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL );
    if( h == INVALID_HANDLE_VALUE )
    {
        return GetLastError( );
    }

    CloseHandle( h );

    HRESULT hr;
    CComPtr< ICaptureGraphBuilder > pBuilder;
    hr = CoCreateInstance(
        CLSID_CaptureGraphBuilder,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_ICaptureGraphBuilder,
        (void**) &pBuilder );
    if( FAILED( hr ) )
    {
        return hr;
    }

    CComPtr< IAMTimeline > pTimeline;
    hr = pEngine->GetTimelineObject( &pTimeline );
    if( FAILED( hr ) )
    {
        return hr;
    }

    CComPtr< IGraphBuilder > pGraph;
    hr = pEngine->GetFilterGraph( &pGraph );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( !pTimeline || !pGraph )
    {
        return E_INVALIDARG;
    }

    long Groups = 0;
    pTimeline->GetGroupCount( &Groups );
    if( !Groups )
    {
        return E_INVALIDARG;
    }

    CComPtr< IBaseFilter > pMux;
    CComPtr< IFileSinkFilter > pWriter;

    hr = pBuilder->SetFiltergraph( pGraph );
    if( FAILED( hr ) )
    {
        return hr;
    }

    GUID guid = MEDIASUBTYPE_Avi;
    bool NeedToConnect = false;

    // if filename ends in ASF, use the ASF filter....
    if (lstrlenW(Filename) > 4 &&
        ((0 == lstrcmpiW(Filename + lstrlenW(Filename) - 3, L"asf")) ||
         (0 == lstrcmpiW(Filename + lstrlenW(Filename) - 3, L"wmv")) ||
         (0 == lstrcmpiW(Filename + lstrlenW(Filename) - 3, L"wma")))) {
        guid =  CLSID_WMAsfWriter;
    }

    if (lstrlenW(Filename) > 4 &&
        (0 == lstrcmpiW(Filename + lstrlenW(Filename) - 3, L"wav"))
        )
    {
        const CLSID CLSID_WavDest = {0x3C78B8E2,0x6C4D,0x11D1,{0xAD,0xE2,0x00,0x00,0xF8,0x75,0x4B,0x99}};

        hr = CoCreateInstance(
            CLSID_WavDest,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IBaseFilter,
            (void**) &pMux );
        if( SUCCEEDED( hr ) )
        {
            hr = pGraph->AddFilter( pMux, L"Wave Mux" );
        }
        if( SUCCEEDED( hr ) )
        {
            hr = CoCreateInstance(
                CLSID_FileWriter,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IFileSinkFilter,
                (void**) &pWriter );
        }
        if( SUCCEEDED( hr ) )
        {
            hr = pWriter->SetFileName( Filename, NULL );
        }
        if( SUCCEEDED( hr ) )
        {
            CComQIPtr< IBaseFilter, &IID_IBaseFilter > pWriterBase( pWriter );
            hr = pGraph->AddFilter( pWriterBase, L"Writer" );
        }

        if( SUCCEEDED( hr ) )
        {
            NeedToConnect = true;
        }

    }
    else
    {
        hr = pBuilder->SetOutputFileName(
            &guid,
            Filename,
            &pMux,
            &pWriter );
    }
    if( FAILED( hr ) )
    {
        return hr;
    }

    IConfigAsfWriter * pConfigAsfWriter;
    hr = pMux->QueryInterface(IID_IConfigAsfWriter, (void **) &pConfigAsfWriter);
    if (SUCCEEDED(hr)) {
        if (pguidProfile) {
            hr = pConfigAsfWriter->ConfigureFilterUsingProfileGuid(*pguidProfile);
        } else {
            // choose a better profile if they didn't specify one?
            if (iProfile >= 0) {
                hr = pConfigAsfWriter->ConfigureFilterUsingProfileId((DWORD) iProfile);
            }
        }

	pConfigAsfWriter->Release();
    }

    for( int g = 0 ; g < Groups ; g++ )
    {
        CComPtr< IPin > pPin;
        hr = pEngine->GetGroupOutputPin( g, &pPin );
        if( FAILED( hr ) )
        {
            // !!! clean up graph?
            //
            return hr;
        }

        // connect pin to the mux
        //
        hr = pBuilder->RenderStream( NULL, pPin, NULL, pMux );
        if( FAILED( hr ) )
        {
            // !!! clean up graph?
            //
            return hr;
        }
    }

    if( NeedToConnect )
    {
        // connect the mux to the writer
        //
        CComQIPtr< IBaseFilter, &IID_IBaseFilter > pWriterBase( pWriter );
        IPin * pMuxOut = GetOutPin( pMux, 0 );
        IPin * pWriterIn = GetInPin( pWriterBase, 0 );
        hr = pGraph->Connect( pMuxOut, pWriterIn );
        DumpGraph( pGraph, 0 );
    }

/*
    DumpGraph( pGraph, 1 );

    CComPtr< IXml2Dex > pObj;

    hr = CoCreateInstance(
        CLSID_Xml2Dex,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IXml2Dex,
        (void**) &pObj );
    pObj->WriteGrfFile( pGraph, L"c:\\smart.grf" );
*/

    return NOERROR;
#else // _WIN64
    return E_FAIL;
#endif // _WIN64
}

STDMETHODIMP CAMTimeline::GetFilterGraphFromFilter(IBaseFilter * pFilter, IFilterGraph ** ppGraph)
{
    CheckPointer( pFilter, E_POINTER );
    CheckPointer( ppGraph, E_POINTER );

    FILTER_INFO fi;
    memset( &fi, 0, sizeof( fi ) );
    HRESULT hr = pFilter->QueryFilterInfo( &fi );
    if( FAILED( hr ) )
    {
        return hr;
    }

    *ppGraph = fi.pGraph;
    return NOERROR;
}


#if 0
STDMETHODIMP CAMTimeline::GetAudMixerControl(IRenderEngine *pEngine, long ID, IAudMixerPin ** pAudMix)
{
    CheckPointer( pEngine, E_POINTER );
    CheckPointer( pAudMix, E_POINTER );

    CComPtr< IGraphBuilder > pGraph;
    HRESULT hr = pEngine->GetFilterGraph( &pGraph );
    if (FAILED(hr))
    {
        return hr;
    }

    CComPtr< IEnumFilters > pEnumFilters;
    pGraph->EnumFilters( &pEnumFilters );
    ULONG Fetched = 0;
    if (pEnumFilters == NULL) {
	return E_OUTOFMEMORY;
    }

    while( 1 )
    {
	CComPtr< IBaseFilter > pFilter;
	Fetched = 0;
	pEnumFilters->Next( 1, &pFilter, &Fetched );
	if( !Fetched )
	{
	    break;
	}
	GUID guid;
	hr = pFilter->GetClassID(&guid);
	if (FAILED(hr))
	    continue;
	if (guid != CLSID_AudMixer)
	    continue;

	CComPtr< IEnumPins > pEnumPins;
	pFilter->EnumPins( &pEnumPins );
	while( pEnumPins )
	{
	    CComPtr< IPin > pPin;
	    Fetched = 0;
	    pEnumPins->Next( 1, &pPin, &Fetched );
	    if( !Fetched )
	    {
		break;
	    }

	    CComQIPtr< IAudMixerPin, &IID_IAudMixerPin > pMix( pPin );
	    if (pMix == NULL)
		continue;
	    long tID;
	    pMix->get_UserID(&tID);
	    if (tID != ID)
		continue;
	    pMix->AddRef();
	    *pAudMix = pMix;
	    return S_OK;
	} // while pins
    } // while filters

    return E_FAIL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbgroup.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
//
//############################################################################

CAMTimelineGroup::CAMTimelineGroup
    ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineComp( pName, pUnk, phr )
    , m_nPriority( 0 )
    , m_dFPS( TIMELINE_DEFAULT_FPS )
    , m_pTimeline( NULL )
    , m_fPreview( TRUE )
    , m_nOutputBuffering( DEX_DEF_OUTPUTBUF ) // default to 30 frms of buffering
{
    m_ClassID = CLSID_AMTimelineGroup;
    m_TimelineType = TIMELINE_MAJOR_TYPE_GROUP;
    ZeroMemory( &m_MediaType, sizeof( AM_MEDIA_TYPE ) );
    m_szGroupName[0] = 0;

    m_bRecompressTypeSet = FALSE;
    m_bRecompressFormatDirty = FALSE;
}

//############################################################################
// 
//############################################################################

CAMTimelineGroup::~CAMTimelineGroup( )
{
     FreeMediaType( m_MediaType );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::NonDelegatingQueryInterface
    (REFIID riid, void **ppv)
{
    // specifically prohibit this interface, since we
    // do inherit it from the base CAMTimelineComp class,
    // but we don't support it on top-level tree nodes
    //
    if( riid == IID_IAMTimelineVirtualTrack )
    {
        return E_NOINTERFACE;
    }
    if( riid == IID_IAMTimelineGroup )
    {
        return GetInterface( (IAMTimelineGroup*) this, ppv );
    }
    return CAMTimelineComp::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetPriority( long * pPriority )
{
    CheckPointer( pPriority, E_POINTER );

    *pPriority = m_nPriority;
    return NOERROR;
}

//############################################################################
// this media type will be getting set in one of two ways. The user is setting
// the uncompressed type for the group OR the SetSmartRecompressFormat is calling
// us with a COMPRESSSED media type, and we're to glean the uncompressed info
// from it. We can assume that the user has correctly set the BIT DEPTH of the
// UNCOMPRESSED format to allow connection to the compressor. Pay attention
// to this closely - the UNCOMPRESSED media type is the type that will eventually
// be connected to the compressor. The compressed media type is what the user
// wants to compress to, but we're notified of that fact in this method so
// we can make sure the width/height/etc match
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetMediaType( AM_MEDIA_TYPE * pMediaType )
{
    CheckPointer( pMediaType, E_POINTER );

    // Make sure they are using a valid media type allowed by Dexter
    //
    if( m_MediaType.majortype == MEDIATYPE_Video &&
        		m_MediaType.subtype != GUID_NULL) {
	if (m_MediaType.formattype != FORMAT_VideoInfo) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	VIDEOINFO *pvi = (VIDEOINFO *)m_MediaType.pbFormat;
	if (HEADER(pvi)->biCompression != BI_RGB) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	if (HEADER(pvi)->biBitCount != 16 && HEADER(pvi)->biBitCount != 24 &&
					HEADER(pvi)->biBitCount != 32) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	// we can't handle top-down video... the resizer filter can't deal with
	// it
	if (HEADER(pvi)->biHeight < 0) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }
    if( m_MediaType.majortype == MEDIATYPE_Audio) {
	if (m_MediaType.formattype != FORMAT_WaveFormatEx) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
	LPWAVEFORMATEX pwfx = (LPWAVEFORMATEX)m_MediaType.pbFormat;
	if (pwfx->nChannels != 2 || pwfx->wBitsPerSample != 16) {
	    return VFW_E_INVALIDMEDIATYPE;
	}
    }

    FreeMediaType( m_MediaType );
    CopyMediaType( &m_MediaType, pMediaType );
  
    // assume that if they set the format, they've set everything else
    //
    if( m_MediaType.pbFormat )
    {
        return NOERROR;
    }

    if( m_MediaType.majortype == MEDIATYPE_Video )
    {
        // if they forgot to set the subtype, we'll set the whole thing for them
        //
        if( m_MediaType.subtype == GUID_NULL )
        {
            ZeroMemory(&m_MediaType, sizeof(AM_MEDIA_TYPE));
            m_MediaType.majortype = MEDIATYPE_Video;
            m_MediaType.subtype = MEDIASUBTYPE_RGB555;
            m_MediaType.formattype = FORMAT_VideoInfo;
            m_MediaType.bFixedSizeSamples = TRUE;
            m_MediaType.pbFormat = (BYTE *)QzTaskMemAlloc(SIZE_PREHEADER +
                            sizeof(BITMAPINFOHEADER));
            m_MediaType.cbFormat = SIZE_PREHEADER + sizeof(BITMAPINFOHEADER);
            ZeroMemory(m_MediaType.pbFormat, m_MediaType.cbFormat);
            LPBITMAPINFOHEADER lpbi = HEADER(m_MediaType.pbFormat);
            lpbi->biSize = sizeof(BITMAPINFOHEADER);
            lpbi->biCompression = BI_RGB;
            lpbi->biBitCount = 16;
            lpbi->biWidth = 320;
            lpbi->biHeight = 240;
            lpbi->biPlanes = 1;
            lpbi->biSizeImage = DIBSIZE(*lpbi);
            m_MediaType.lSampleSize = DIBSIZE(*lpbi);
        }
    }
    if( m_MediaType.majortype == MEDIATYPE_Audio )
    {
        ZeroMemory(&m_MediaType, sizeof(AM_MEDIA_TYPE));
        m_MediaType.majortype = MEDIATYPE_Audio;
        m_MediaType.subtype = MEDIASUBTYPE_PCM;
        m_MediaType.bFixedSizeSamples = TRUE;
        m_MediaType.formattype = FORMAT_WaveFormatEx;
        m_MediaType.pbFormat = (BYTE *)QzTaskMemAlloc( sizeof( WAVEFORMATEX ) );
        m_MediaType.cbFormat = sizeof( WAVEFORMATEX );
        WAVEFORMATEX * vih = (WAVEFORMATEX*) m_MediaType.pbFormat;
        ZeroMemory( vih, sizeof( WAVEFORMATEX ) );
        vih->wFormatTag = WAVE_FORMAT_PCM;
        vih->nChannels = 2;
        vih->nSamplesPerSec = 44100;
        vih->nBlockAlign = 4;
        vih->nAvgBytesPerSec = vih->nBlockAlign * vih->nSamplesPerSec;
        vih->wBitsPerSample = 16;
        m_MediaType.lSampleSize = vih->nBlockAlign;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetMediaTypeForVB( long Val )
{
    CMediaType GroupMediaType;
    if( Val == 0 )
    {
        GroupMediaType.SetType( &MEDIATYPE_Video );
    }
    else
    {
        GroupMediaType.SetType( &MEDIATYPE_Audio );
    }
    SetMediaType( &GroupMediaType );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetMediaType( AM_MEDIA_TYPE * pMediaType )
{
    CheckPointer( pMediaType, E_POINTER );
    CopyMediaType( pMediaType, &m_MediaType );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetOutputFPS( double FPS )
{
    if (FPS == 0)
    return E_INVALIDARG;
    m_dFPS = FPS;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetOutputFPS( double * pFPS )
{
    CheckPointer( pFPS, E_POINTER );
    *pFPS = m_dFPS;
    return NOERROR;
}

//############################################################################
// Set the timeline that this composition uses. This should not be called
// externally, but I can't really prevent it.
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetTimeline
    ( IAMTimeline * pTimeline )
{
    // don't allow setting it twice
    //
    if( m_pTimeline )
    {
        return E_INVALIDARG;
    }

    m_pTimeline = pTimeline;

    return NOERROR;
}

//############################################################################
// Ask the group who the timeline is. Any groups except the root
// one will return NULL. The root one knows about the timeline who's using it.
// The base object's GetTimelineNoRef will eventually call this method on the
// root group.
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetTimeline
    ( IAMTimeline ** ppTimeline )
{
    CheckPointer( ppTimeline, E_POINTER );

    *ppTimeline = m_pTimeline;

    if( *ppTimeline )
    {
        (*ppTimeline)->AddRef( );
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::Load
    ( IStream * pStream )
{
    return E_NOTIMPL;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::Save
    ( IStream * pStream, BOOL fClearDirty )
{
    return E_NOTIMPL;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetSizeMax
    ( ULARGE_INTEGER * pcbSize )
{
    return E_NOTIMPL;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetGroupName
    (BSTR newVal)
{
    lstrcpyW( m_szGroupName, newVal );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetGroupName
    (BSTR * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = SysAllocString( m_szGroupName );
    if( !(*pVal) )
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetPreviewMode
    (BOOL fPreview)
{
    m_fPreview = fPreview;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetPreviewMode
    (BOOL *pfPreview)
{
    CheckPointer( pfPreview, E_POINTER );
    *pfPreview = m_fPreview;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetOutputBuffering
    (int nBuffer)
{
    // minimum 2, or switch hangs
    if (nBuffer <=1)
    return E_INVALIDARG;
    m_nOutputBuffering = nBuffer;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::GetOutputBuffering
    (int *pnBuffer)
{
    CheckPointer( pnBuffer, E_POINTER );
    *pnBuffer = m_nOutputBuffering;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::Remove()
{
    HRESULT hr = 0;

    // all we want to do is to take this group out of the tree.
    //
    if( m_pTimeline )
    {
        hr = m_pTimeline->RemGroupFromList( this );
    }

    m_pTimeline = NULL;

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::RemoveAll()
{
    // the 'owner' of us is the timeline's list itself.
    // That's the only thing that holds a refcount on us
    // so make sure to remove us from the tree first, 
    // THEN remove us from the parent's list

    // don't call the base class RemoveAll( ) function, since it will
    // check for the presence of a timeline
    //
    XRemove( );

    IAMTimeline * pTemp = m_pTimeline;
    m_pTimeline = NULL;

    // we need to take this group out of the timeline's list
    //
    pTemp->RemGroupFromList( this );

    // at this time, the group will already have had it's
    // destructor called. Do NOT reference any member variables!

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineGroup::SetSmartRecompressFormat( long * pFormat )
{
    CheckPointer( pFormat, E_POINTER );
    long id = *pFormat;
    if( id != 0 )
    {
        return E_INVALIDARG;
    }

    SCompFmt0 * pS = (SCompFmt0*) pFormat;

    m_bRecompressTypeSet = TRUE;
    m_bRecompressFormatDirty = TRUE;
    m_RecompressType = pS->MediaType;

    // copy compressed media type's fps and size to the group's
    //
    if( m_MediaType.majortype == MEDIATYPE_Video )
    {
        VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) m_RecompressType.Format( );
        REFERENCE_TIME rt = pVIH->AvgTimePerFrame;
	// ASF files do not tell us their frame rate.  Ugh.
        // ASSERT( rt );
	// Use the smart recompresson frame rate as the output frame rate of
	// the project, so smart recompression will work.  If we don't know
	// the frame rate, just trust the rate they already programmed the
	// group with, and use that for the smart rate too, since we need
	// to pick a non-zero number or we're in trouble
        if (rt) {
            m_dFPS = 1.0 / RTtoDouble( rt );
	} else {
	    // don't let this be zero!
	    pVIH->AvgTimePerFrame = (REFERENCE_TIME)(UNITS / m_dFPS);
	}

	if (m_MediaType.formattype == FORMAT_VideoInfo) {

            VIDEOINFOHEADER * pOurVIH = (VIDEOINFOHEADER*) m_MediaType.pbFormat;
            ASSERT( pOurVIH );
            if( !pOurVIH )
            {
                return VFW_E_INVALIDMEDIATYPE;
            }

            pOurVIH->bmiHeader.biWidth = pVIH->bmiHeader.biWidth;
            pOurVIH->bmiHeader.biHeight = pVIH->bmiHeader.biHeight;
            pOurVIH->bmiHeader.biSizeImage = DIBSIZE( pOurVIH->bmiHeader );
	    m_MediaType.lSampleSize = pOurVIH->bmiHeader.biSizeImage;

            return NOERROR;
        }
    }

    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::GetSmartRecompressFormat( long ** ppFormat )
{
    CheckPointer( ppFormat, E_POINTER );

    *ppFormat = NULL;

    SCompFmt0 * pS = new SCompFmt0;
    if( !pS )
    {
        return E_OUTOFMEMORY;
    }
    pS->nFormatId = 0;
    CopyMediaType( &pS->MediaType, &m_RecompressType );
    *ppFormat = (long*) pS;

    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::IsSmartRecompressFormatSet( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = FALSE;

    // if they've set a type, then look at them both to see if SR can
    // even be done on this group
    //
    if( m_bRecompressTypeSet )
    {
        if( m_RecompressType.majortype != m_MediaType.majortype )
        {
            return NOERROR; // won't work
        }

	// !!! This means you can't do smart recompression with MPEG or
	// anything without VIDEOINFO type !!!
	//
        if( m_RecompressType.formattype != m_MediaType.formattype )
        {
            return NOERROR; // won't work
        }

        if( m_RecompressType.majortype == MEDIATYPE_Video )
        {
            VIDEOINFOHEADER * pVIH1 = (VIDEOINFOHEADER*) m_MediaType.pbFormat;
            VIDEOINFOHEADER * pVIH2 = (VIDEOINFOHEADER*) m_RecompressType.pbFormat;
            
            if( pVIH1->bmiHeader.biWidth != pVIH2->bmiHeader.biWidth )
            {
                return NOERROR;
            }
            if( pVIH1->bmiHeader.biHeight != pVIH2->bmiHeader.biHeight )
            {
                return NOERROR;
            }

	    // BIT DEPTH WILL BE DIFFERENT BETWEEN COMP AND UNCOMP TYPES

        }
        else
        {
            return NOERROR; // won't work
        }
    }

    *pVal = m_bRecompressTypeSet;

    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::IsRecompressFormatDirty( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_bRecompressFormatDirty;
    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::ClearRecompressFormatDirty( )
{
    m_bRecompressFormatDirty = FALSE;
    return NOERROR;
}

STDMETHODIMP CAMTimelineGroup::SetRecompFormatFromSource( IAMTimelineSrc * pSource )
{
    CheckPointer( pSource, E_POINTER );
    if( !m_pTimeline )
    {
        return E_NO_TIMELINE;
    }

    if( m_MediaType.majortype != MEDIATYPE_Video ) {
        return VFW_E_INVALIDMEDIATYPE;
    }

    CComBSTR Filename;
    HRESULT hr = 0;
    hr = pSource->GetMediaName(&Filename);
    if( FAILED( hr ) )
    {
        return hr;
    }

    SCompFmt0 * pFmt = new SCompFmt0;
    if( !pFmt )
    {
        return E_OUTOFMEMORY;
    }
    memset( pFmt, 0, sizeof( SCompFmt0 ) );

    // create a mediadet
    //
    CComPtr< IMediaDet > pDet;
    hr = CoCreateInstance( CLSID_MediaDet,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IMediaDet,
        (void**) &pDet );
    if( FAILED( hr ) )
    {
        delete pFmt;
        return hr;
    }

    //
    // set the site provider on the MediaDet object to allowed keyed apps
    // to use ASF filters with dexter
    //
    CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( pDet );
    CComQIPtr< IServiceProvider, &IID_IServiceProvider > pTimelineSP( m_pTimeline );
    ASSERT( pOWS );
    if( pOWS )
    {
        pOWS->SetSite( pTimelineSP );
    }

    hr = pDet->put_Filename( Filename );
    if( FAILED( hr ) )
    {
        delete pFmt;
        return hr;
    }

    // go through and find the video stream type
    //
    long Streams = 0;
    long VideoStream = -1;
    hr = pDet->get_OutputStreams( &Streams );
    for( int i = 0 ; i < Streams ; i++ )
    {
        pDet->put_CurrentStream( i );
        GUID Major = GUID_NULL;
        pDet->get_StreamType( &Major );
        if( Major == MEDIATYPE_Video )
        {
            VideoStream = i;
            break;
        }
    }
    if( VideoStream == -1 )
    {
        delete pFmt;
        return VFW_E_INVALIDMEDIATYPE;
    }

    hr = pDet->get_StreamMediaType( &pFmt->MediaType );
    if( SUCCEEDED( hr ) )
    {
        hr = SetSmartRecompressFormat( (long*) pFmt );
    }

    FreeMediaType( pFmt->MediaType );

    delete pFmt;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbsrc.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"
#include "..\..\..\filters\h\ftype.h"

const int OUR_MAX_STREAM_SIZE = 2048; // chosen at random

//############################################################################
// 
//############################################################################

CAMTimelineSrc::CAMTimelineSrc
    ( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
    , m_rtMediaStart( 0 )
    , m_rtMediaStop( 0 )
    , m_rtMediaLength( 0 )
    , m_nStreamNumber( 0 )
    , m_dDefaultFPS( 0.0 )	// ???
    , m_nStretchMode( RESIZEF_STRETCH )	// what kind of stretch to do?
{
    m_TimelineType = TIMELINE_MAJOR_TYPE_SOURCE;
    m_ClassID = CLSID_AMTimelineSrc;
    m_szMediaName[0] = 0;
    m_bIsRecompressable = FALSE;
    m_bToldIsRecompressable = FALSE;
}

//############################################################################
// 
//############################################################################

CAMTimelineSrc::~CAMTimelineSrc( )
{
    m_szMediaName[0] = 0;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::NonDelegatingQueryInterface
    (REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineSrc )
    {
        return GetInterface( (IAMTimelineSrc*) this, ppv );
    }
    if( riid == IID_IAMTimelineSrcPriv )
    {
        return GetInterface( (IAMTimelineSrcPriv*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    if( riid == IID_IAMTimelineEffectable )
    {
        return GetInterface( (IAMTimelineEffectable*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// return the media times this source runs at.
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetMediaTimes2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetMediaTimes( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::GetMediaTimes
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    *pStart = m_rtMediaStart;
    *pStop = m_rtMediaStop;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::FixMediaTimes2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = FixMediaTimes( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::FixMediaTimes
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    // first stuff 'em, like a vegetarian gourmet eggplant dish.
    //
    REFERENCE_TIME MediaStart = *pStart;
    REFERENCE_TIME MediaStop = *pStop;
    REFERENCE_TIME MediaLen = MediaStop - MediaStart;

    // If the regular start/stop times of this clip weren't on a frame boundary,
    // they are also fixed up like we did above.  But now we need to fix the
    // media times to still be in the same ratio to the start/stop times as
    // they were before either of them was fixed up, or we've changed the 
    // behaviour.  eg:  timeline time .45 to .9 is media time 0 to .45
    // The movie is 5fps.  Timeline times wil be fixed up to (.4,1) and media
    // times will be fixed up to (0,.4)  Uh oh!  They're not the same length
    // like they used to be!  So we need to make the media times .6 long like
    // the timeline times so we don't think we're stretching the video

    // We're aligning to the OUTPUT frame rate of the timeline, not
    // the source's frame rate. We could bump the media stop time beyond
    // the source's length. We should account for this

    // get the times and fix them up
    //
    REFERENCE_TIME NewStart = m_rtStart;
    REFERENCE_TIME NewStop = m_rtStop;
    GetStartStop(&NewStart, &NewStop);
    FixTimes( &NewStart, &NewStop );

        REFERENCE_TIME Len;    // len of fixed up media times
        if (m_rtStop - m_rtStart == MediaLen) 
        {
            // I don't trust FP to get this result in the else case
            Len = NewStop - NewStart;
        } 
        else 
        {
            Len = (REFERENCE_TIME)((double)(NewStop - NewStart) *
                            MediaLen / (m_rtStop - m_rtStart));
        }

    // We have to be careful when growing the media times to be in the right
    // ratio to the timeline times, because we don't want to make the start
    // get < 0, or the stop be > the movie length (which we don't know).
    // So we'll grow by moving the start back, until it hits 0, in which case
    // we'll grow the stop too, but hopefully this cannot cause a problem
    // because we're fudging by at most one output frame length, so the
    // switch should get all the frames it needs.
    if( Len > MediaLen ) // we're growing media times (dangerous)
    {   
        if ( MediaStop  - Len >= 0 ) 
        {
            *pStart = MediaStop - Len;
        } 
        else 
        {
            *pStart = 0;
            MediaStop = Len;
        }
    } 
    else 
    {
	MediaStop = MediaStart + Len;
    }

    // make sure stop doesn't go over, if there is a length.
    //
    if( m_rtMediaLength && ( MediaStop > m_rtMediaLength ) )
    {
        MediaStop = m_rtMediaLength;
    }

    *pStop = MediaStop;

    return NOERROR;

}

//############################################################################
// ask for the name that's been stored in here.
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetMediaName
    (BSTR * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = SysAllocString( m_szMediaName );
    if( !(*pVal) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
// NOTE: If a sub-COM object is being used as a media source (like within a 
// graph), changing this string will NOT change the actual clip that this
// source refers to. You're only changing a NAME, not the real clip. This
// name placeholder functionality is here for convenience purposes and if this
    // is too confusing, will be removed.
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetMediaName
    (BSTR newVal)
{
    // if they're different, then bump the genid, so something that's caching
    // us can tell we changed
    //
    if( wcscmp( m_szMediaName, newVal ) == 0 )
    {
        return NOERROR;
    }

    // blow the cache
    _BumpGenID( );

    // no recompress knowledge if we change source
    ClearAnyKnowledgeOfRecompressability( );

    wcscpy( m_szMediaName, newVal );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SpliceWithNext
    (IAMTimelineObj * pNext)
{
    HRESULT hr = 0;

    CheckPointer( pNext, E_POINTER );

    CComQIPtr<IAMTimelineSrc, &IID_IAMTimelineSrc> p( pNext );
    if( !p )
    {
        return E_NOINTERFACE;
    }

    BSTR NextName;
    p->GetMediaName( &NextName );
    if( wcscmp( NextName, m_szMediaName ) != 0 )
    {
        return E_INVALIDARG;
    }

    REFERENCE_TIME NextStart, NextStop;
    CComQIPtr<IAMTimelineObj, &IID_IAMTimelineObj> pNextBase( pNext );
    
    hr = pNextBase->GetStartStop( &NextStart, &NextStop );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( NextStart != m_rtStop )
    {
        return E_INVALIDARG;
    }

    // get the next guy's stop time
    //
    REFERENCE_TIME NextMediaStart, NextMediaStop;
    p->GetMediaTimes( &NextMediaStart, &NextMediaStop );

    // compare our rate to the next guy's rate. We need to be the same
    //
    double OurRate = double( m_rtMediaStop - m_rtMediaStart ) / double( m_rtStop - m_rtStart );
    double NextRate = double( NextMediaStop - NextMediaStart ) / double( NextStop - NextStart );
    double absv = NextRate - OurRate;
    if( absv < 0.0 )
    {
        absv *= -1.0;
    }
    // have to be close by 10 percent?
    if( absv > NextRate / 10.0 )
    {
        return E_INVALIDARG;
    }

    // set our times to the same thing
    //
    m_rtMediaStop = NextMediaStop;
    m_rtStop = NextStop;

    // we're dirty (and so's our parent)
    //
    SetDirtyRange( m_rtStart, m_rtStop );

    // remove the next guy from the tree, he's outta there! Switch around the
    // insert modes, so we don't move stuff on the remove
    //
    long OldMode = 0;
    IAMTimeline * pRoot = NULL; // okay not CComPtr2
    GetTimelineNoRef( &pRoot );
    ASSERT( pRoot );
    hr = pNextBase->RemoveAll( );

    // !!! what about 2nd clip's effects it had on it? Need to add them to the first

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetMediaTimes2
    (REFTIME Start, REFTIME Stop)
{
    REFERENCE_TIME p1 = DoubleToRT( Start );
    REFERENCE_TIME p2 = DoubleToRT( Stop );
    HRESULT hr = SetMediaTimes( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::SetMediaTimes
    (REFERENCE_TIME Start, REFERENCE_TIME Stop)
{

    if (Stop < Start)
        return E_INVALIDARG;

    // if a duration is set, make sure we don't go past it
    //
    if( m_rtMediaLength )
    {
        if( Stop > m_rtMediaLength )
        {
            Stop = m_rtMediaLength;
        }
    }

    // don't bump genid - this will ruin the cache
    // don't blow recompressability - IsNormallyRated will do

    m_rtMediaStart = Start;
    m_rtMediaStop = Stop;

    return NOERROR;
}

#include <..\render\dexhelp.h>

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetStreamNumber(long * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_nStreamNumber;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetStreamNumber(long Val)
{
    if (Val < 0)
	return E_INVALIDARG;

    // user is reponsible for making sure this is valid
    //
    m_nStreamNumber = Val;

    ClearAnyKnowledgeOfRecompressability( );

    return NOERROR;
}


//############################################################################
// 
//############################################################################

// If a source can't figure out its frames per second, this number
// will be used (eg: Dib sequences)
// AVI, MPEG, etc. will not need this
//
STDMETHODIMP CAMTimelineSrc::GetDefaultFPS(double *pFPS)
{
    CheckPointer(pFPS, E_POINTER);
    *pFPS = m_dDefaultFPS;
    return NOERROR;
}


STDMETHODIMP CAMTimelineSrc::SetDefaultFPS(double FPS)
{
    // 0.0 means do not allow dib sequences
    if (FPS < 0.0)
	return E_INVALIDARG;
    m_dDefaultFPS = FPS;
    return NOERROR;
}


//############################################################################
// 
//############################################################################

// If this source needs to be stretched, how should it be stretched?
// The choices are RESIZEF_STRETCH, RESIZEF_CROP, and
// RESIZEF_PRESERVEASPECTRATIO.
//
STDMETHODIMP CAMTimelineSrc::GetStretchMode(int *pnStretchMode)
{
    CheckPointer(pnStretchMode, E_POINTER);
    *pnStretchMode = m_nStretchMode;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetStretchMode(BOOL nStretchMode)
{
    m_nStretchMode = nStretchMode;
    return NOERROR;
}

//############################################################################
// user is reponsible for setting this right
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetMediaLength2(REFTIME Length)
{
    REFERENCE_TIME dummy = DoubleToRT( Length );
    HRESULT hr = SetMediaLength( dummy );
    return hr;
}

STDMETHODIMP CAMTimelineSrc::SetMediaLength(REFERENCE_TIME Length)
{
    m_rtMediaLength = Length;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetMediaLength2(REFTIME * pLength)
{
    CheckPointer( pLength, E_POINTER );
    *pLength = 0.0;
    if( !m_rtMediaLength )
    {
        return E_NOTDETERMINED;
    }
    *pLength = RTtoDouble( m_rtMediaLength );
    return NOERROR;
}

STDMETHODIMP CAMTimelineSrc::GetMediaLength(REFERENCE_TIME * pLength)
{
    CheckPointer( pLength, E_POINTER );
    *pLength = 0;
    if( !m_rtMediaLength )
    {
        return E_NOTDETERMINED;
    }
    *pLength = m_rtMediaLength;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::ModifyStopTime2(REFTIME Stop)
{
    REFERENCE_TIME t1 = DoubleToRT( Stop );
    return ModifyStopTime( t1 );
}

STDMETHODIMP CAMTimelineSrc::ModifyStopTime(REFERENCE_TIME Stop)
{
    return SetStartStop( m_rtStart, Stop );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SplitAt2( REFTIME t )
{
    REFERENCE_TIME t1 = DoubleToRT( t );
    return SplitAt( t1 );
}

STDMETHODIMP CAMTimelineSrc::SplitAt( REFERENCE_TIME SplitTime )
{
    // is our split time withIN our time?
    //
    if( SplitTime <= m_rtStart || SplitTime >= m_rtStop )
    {
        return E_INVALIDARG;
    }

    IAMTimelineObj * pTrack = NULL;
    XGetParentNoRef( &pTrack );
    if( !pTrack )
    {
        return E_INVALIDARG;
    }
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pTrackNode( pTrack );

    // create the shell
    //
    HRESULT hr = 0;
    CAMTimelineSrc * pNewSrc = new CAMTimelineSrc( NAME("Timeline Source"), NULL, &hr );
    if( !pNewSrc )
    {
        return E_OUTOFMEMORY;
    }

    // we have created an object that has NO references on it. If we call ANYTHING that
    // addreffs and releases the pNewSrc, it will be deleted. So addref it NOW.

    pNewSrc->AddRef( );

    hr = CopyDataTo( pNewSrc, SplitTime );
    if( FAILED( hr ) )
    {
        delete pNewSrc;
        return hr;
    }

    double dMediaRate = (double) (m_rtMediaStop - m_rtMediaStart) / (m_rtStop - m_rtStart);

    pNewSrc->m_rtStart = SplitTime;
    pNewSrc->m_rtStop = m_rtStop;
    // first clip end = new timeline time of first clip * rate
    pNewSrc->m_rtMediaStart = m_rtMediaStart + (REFERENCE_TIME)((SplitTime - m_rtStart) * dMediaRate);
    // second clip starts where first ends
    pNewSrc->m_rtMediaStop = m_rtMediaStop;

    m_rtStop = SplitTime;
    m_rtMediaStop = pNewSrc->m_rtMediaStart;

    hr = pNewSrc->SetMediaName( m_szMediaName );
    if( FAILED( hr ) )
    {
        pNewSrc->Release( );
        delete pNewSrc;
        return hr;
    }

    // get the src's parent
    //
    hr = pTrackNode->XInsertKidAfterKid( pNewSrc, this );

    // if it took or not, we can still release our local pNewSrc ref
    //
    pNewSrc->Release( );

    if( FAILED( hr ) )
    {
        delete pNewSrc;
        return hr;
    }

    // we need to adjust SplitTime so that it's relative to the start of this clip
    // before splitting effects up
    //
    SplitTime -= m_rtStart;

    // split all the effects. 
    //
    CComPtr< IAMTimelineObj > pEffect;
    long EffectCount = 0;
    hr = EffectGetCount( &EffectCount );
    for( int i = 0 ; i < EffectCount ; i++ )
    {
        CComPtr< IAMTimelineObj > p;
        HRESULT hr = GetEffect( &p, i );
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if the end time is less than our split time, it's completely
        // out of bounds, ignore it
        //
        if( e <= SplitTime )
        {
            p.Release( );
            continue;
        }

        // if it's start time is equal to or greater than our split time,
        // it's completely out of bounds, ignore it. Plus, we're done searching.
        //
        if( s >= SplitTime )
        {
            p.Release( );
            break;
        }

        CComQIPtr< IAMTimelineSplittable, &IID_IAMTimelineSplittable > pSplittable( p );
        hr = pSplittable->SplitAt( SplitTime );
        if( FAILED( hr ) )
        {
            // right in the middle of it all, it FAILED! What now?
            //
            return hr;
        }

        break; // found one to split, we're done
    }

    return hr;
}

//############################################################################
// 
//############################################################################

// !!! Persist all properties, including my new ones
STDMETHODIMP CAMTimelineSrc::Load( IStream * pStream )
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::Save( IStream * pStream, BOOL fClearDirty )
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetSizeMax( ULARGE_INTEGER * pcbSize )
{
    HRESULT hr = E_NOTIMPL;
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetIsRecompressable( BOOL Val )
{
    m_bIsRecompressable = Val;
    m_bToldIsRecompressable = TRUE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::GetIsRecompressable( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    if( !m_bToldIsRecompressable )
    {
        *pVal = FALSE;
        return S_FALSE;
    }
    *pVal = m_bIsRecompressable;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::ClearAnyKnowledgeOfRecompressability( )
{
    m_bToldIsRecompressable = FALSE;
    m_bIsRecompressable = FALSE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::IsNormalRate( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );

    REFERENCE_TIME MediaLen = m_rtMediaStop - m_rtMediaStart;
    REFERENCE_TIME TLlen = m_rtStop - m_rtStart;
    if( TLlen != MediaLen )
    {
        *pVal = FALSE;
        return NOERROR;
    }

    *pVal = TRUE;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineSrc::SetStartStop( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    // don't bump genid - this will ruin the cache
    // don't blow recompressability - IsNormallyRated will do
    return CAMTimelineObj::SetStartStop( Start, Stop );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbobj.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

const int OUR_MAX_STREAM_SIZE = 2048; // chosen at random
long CAMTimelineObj::m_nStaticGenID = 0;

//############################################################################
// 
//############################################################################

CAMTimelineObj::CAMTimelineObj( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CUnknown( pName, pUnk )
    , m_rtStart( 0 )
    , m_rtStop( 0 )
    , m_bMuted( FALSE )
    , m_bLocked( FALSE )
    , m_rtDirtyStart( -1 )
    , m_rtDirtyStop( -1 )
    , m_pUserData( NULL )
    , m_nUserDataSize( 0 )
    , m_UserID( 0 )
    , m_SubObjectGuid( GUID_NULL )
    , m_nGenID( 0 )
{
    m_UserName[0] = 0;
    m_ClassID = GUID_NULL;

    // bad logic since we don't init globals
    //
    static bool SetStatic = false;
    if( !SetStatic )
    {
        SetStatic = true;
        m_nStaticGenID = 0;
    }

    _BumpGenID( );
}

//############################################################################
// 
//############################################################################

CAMTimelineObj::~CAMTimelineObj( )
{
    _Clear( );
}

//############################################################################
// clear all the memory this object allocated for it's subobject and data
//############################################################################

void CAMTimelineObj::_Clear( )
{
    _ClearSubObject( );

    if( m_pUserData )
    {
        delete [] m_pUserData;
        m_pUserData = NULL;
    }
    m_nUserDataSize = 0;
}

//############################################################################
// clear out the subobject and anything it had in it.
//############################################################################

void CAMTimelineObj::_ClearSubObject( )
{
    m_pSubObject.Release( );
    m_SubObjectGuid = GUID_NULL;
    m_pSetter.Release( );
}

//############################################################################
// return the interfaces we support
//############################################################################

STDMETHODIMP CAMTimelineObj::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineObj )
    {
        return GetInterface( (IAMTimelineObj*) this, ppv );
    }
    if( riid == IID_IAMTimelineNode )
    {
        return GetInterface( (IAMTimelineNode*) this, ppv );
    }
/*
    if( riid == IID_IPersistStream )
    {
        return GetInterface( (IPersistStream*) this, ppv );
    }
*/
    return CUnknown::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetStartStop2(REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1;
    REFERENCE_TIME p2;
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::GetStartStop(REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    *pStart = m_rtStart;
    *pStop = m_rtStop;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetStartStop2(REFTIME Start, REFTIME Stop)
{
    if( ( Start == -1 ) && ( Stop == -1 ) )
    {
        return NOERROR;
    }

    // see how long we are
    //
    REFERENCE_TIME diff = m_rtStop - m_rtStart;

    REFERENCE_TIME p1 = DoubleToRT( Start );
    REFERENCE_TIME p2 = DoubleToRT( Stop );

    // if they didn't give the start time
    //
    if( Start == -1 )
    {
        p1 = p2 - diff;
    }

    // if they didn't give the stop time
    //
    if( Stop == -1 )
    {
        p2 = p1 + diff;
    }

    HRESULT hr = SetStartStop( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    if( ( Start == -1 ) && ( Stop == -1 ) )
    {
        return NOERROR;
    }

    CComPtr< IAMTimelineObj > pRefHolder( this );

    // is this object already in the tree? Don't add and remove it if it is NOT.
    //
    CComPtr< IAMTimelineObj > pParent;
    XGetParent( &pParent );

    REFERENCE_TIME p1 = Start;
    REFERENCE_TIME p2 = Stop;

    // if they didn't give the start time
    //
    if( Start == -1 )
    {
        p1 = m_rtStart;
    }
    else if( Start < 0 )
    {
        return E_INVALIDARG;
    }
        
    // if they didn't give the stop time
    //
    if( Stop == -1 )
    {
        p2 = m_rtStop;
    } else if( Stop < 0 )
    {
        return E_INVALIDARG;
    }

    // if stop time is less than Start
    //
    if( Start > Stop )
    {
        return E_INVALIDARG;
    }

    // if we're time based, not priority based, we need to remove this
    // object from the tree first, in case we change the start times to
    // something weird
    //
    if( !HasPriorityOverTime( ) && pParent )
    {
        XRemoveOnlyMe( );
    }

    m_rtStart = p1;
    m_rtStop = p2;

    SetDirtyRange( m_rtStart, m_rtStop );

    // if prioriity is more important, then we're done
    //
    if( HasPriorityOverTime( ) || !pParent )
    {
        return NOERROR;
    }

    HRESULT hr = 0;

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParentNode( pParent );
    hr = pParentNode->XAddKidByTime( m_TimelineType, pRefHolder );

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetSubObject(IUnknown* *ppVal)
{
    CheckPointer( ppVal, E_POINTER );

    *ppVal = m_pSubObject;
    if( *ppVal )
    {
        (*ppVal)->AddRef( );
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetSubObjectLoaded(BOOL * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = ( m_pSubObject != NULL );

    return NOERROR;
}

//############################################################################
// set the COM object that this timeline object holds. This can be used instead
// of a GUID to the COM object.
//############################################################################

// why will people be calling us to tell us what our sub object is?
// 1: we don't already have one, so we need to fill in our com
// pointer and GUID, and sub-object data. Problem is, only sometimes
// will we want sub-object data, depending on what type of node we are.
// how do we tell?
// 2: we already have a sub-object, but want to clear it out. We can call
// a clear method, then pretend it's #1 above.
//
STDMETHODIMP CAMTimelineObj::SetSubObject(IUnknown* newVal)
{
    HRESULT hr = 0;

    // if they're the same, return
    //
    if( newVal == m_pSubObject )
    {
        return NOERROR;
    }

    GUID incomingGuid = _GetObjectGuid( newVal );

    if( incomingGuid == GUID_NULL )
    {
        DbgLog((LOG_TRACE, 2, TEXT("SetSubObject: CLSID doesn't exist." )));
    }
    else
    {
        m_SubObjectGuid = incomingGuid;
    }

    // blow out the cache
    //
    _BumpGenID( );

    // dirty ourselves for our duration
    //
    SetDirtyRange( m_rtStart, m_rtStop );

    m_pSubObject = newVal;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetSubObjectGUID(GUID newVal)
{
    // if they're the same, return
    //
    if( newVal == m_SubObjectGuid )
    {
        return NOERROR;
    }

    // wipe out what used to be here, since we're setting a new object.
    //
    _ClearSubObject( );

    // blow out the cache
    //
    _BumpGenID( );

    // ??? should we wipe out user data, too?

    m_SubObjectGuid = newVal;

    SetDirtyRange( m_rtStart, m_rtStop );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetSubObjectGUID(GUID * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_SubObjectGuid;

    return NOERROR;
}

STDMETHODIMP CAMTimelineObj::SetSubObjectGUIDB(BSTR newVal)
{
    GUID NewGuid = GUID_NULL;
    HRESULT hr = CLSIDFromString( newVal, &NewGuid );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = SetSubObjectGUID( NewGuid );
    return hr;
}

STDMETHODIMP CAMTimelineObj::GetSubObjectGUIDB(BSTR * pVal)
{
    HRESULT hr;

    WCHAR * TempVal = NULL;
    hr = StringFromCLSID( m_SubObjectGuid, &TempVal );
    if( FAILED( hr ) )
    {
        return hr;
    }
    *pVal = SysAllocString( TempVal );
    CoTaskMemFree( TempVal );
    if( !(*pVal) ) return E_OUTOFMEMORY;
    return NOERROR;
}


//############################################################################
// ask what our type is.
//############################################################################

STDMETHODIMP CAMTimelineObj::GetTimelineType(TIMELINE_MAJOR_TYPE * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_TimelineType;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetTimelineType(TIMELINE_MAJOR_TYPE newVal)
{
    // don't care if they're the same
    //
    if( newVal == m_TimelineType )
    {
        return NOERROR;
    }

    // can't set the type, once it's been set
    //
    if( m_TimelineType != 0 )
    {
        DbgLog((LOG_TRACE, 2, TEXT("SetTimelineType: Timeline type already set." )));
        return E_INVALIDARG;
    }

    SetDirtyRange( m_rtStart, m_rtStop );

    m_TimelineType = newVal;

    return NOERROR;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineObj::GetUserID(long * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_UserID;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetUserID(long newVal)
{
    m_UserID = newVal;

    SetDirtyRange( m_rtStart, m_rtStop );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetUserName(BSTR * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = SysAllocString( m_UserName );
    if( !(*pVal) ) return E_OUTOFMEMORY;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetUserName(BSTR newVal)
{
    if (newVal == NULL) {
	m_UserName[0] = 0;
    } else {
        lstrcpynW( m_UserName, newVal, 256 );
    }

    SetDirtyRange( m_rtStart, m_rtStop );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetPropertySetter(IPropertySetter **ppSetter)
{
    CheckPointer(ppSetter, E_POINTER);

    *ppSetter = m_pSetter;
    if (*ppSetter)
        (*ppSetter)->AddRef();
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetPropertySetter(IPropertySetter *pSetter)
{
    m_pSetter = pSetter;
    // !!! _GiveSubObjectData(); if sub object instantiated, give it props now?
    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetUserData(BYTE * pData, long * pSize)
{
    // somebody was fooling us
    //
    if( !pData && !pSize )
    {
        return NOERROR;
    }

    CheckPointer( pSize, E_POINTER );

    *pSize = m_nUserDataSize;

    // they just want the size
    //
    if( !pData )
    {
        return NOERROR;
    }

    memcpy( pData, m_pUserData, m_nUserDataSize );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetUserData(BYTE * pData, long Size)
{
    // somebody was fooling us
    //
    if( Size == 0 )
    {
        return NOERROR;
    }

    SetDirtyRange( m_rtStart, m_rtStop );

    if( m_pUserData )
    {
        delete [] m_pUserData;
        m_pUserData = NULL;
    }

    BYTE * pNewData = new BYTE[Size];

    if( !pNewData )
    {
        DbgLog((LOG_TRACE, 2, TEXT("SetUserData: memory allocation failed." )));
        return E_OUTOFMEMORY;
    }

    m_pUserData = pNewData;
    memcpy( m_pUserData, pData, Size );
    m_nUserDataSize = Size;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetMuted(BOOL * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = FALSE;

    // if the parent is muted, so are we
    CComPtr< IAMTimelineObj > pObj;
    HRESULT hr = XGetParent(&pObj);
    if (hr == S_OK && pObj)
	pObj->GetMuted(pVal);

    if (m_bMuted)
        *pVal = TRUE;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetMuted(BOOL newVal)
{
    // drived class should override
    //
    //DbgLog((LOG_TRACE,2,TEXT("SetMuted: Derived class should implement?" )));
    m_bMuted = newVal;
    return S_OK;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetLocked(BOOL * pVal)
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_bLocked;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetLocked(BOOL newVal)
{
    // drived class should override
    //
    //DbgLog((LOG_TRACE,2,TEXT("SetLocked: Derived class should implement?" )));

    m_bLocked = newVal;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetDirtyRange2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetDirtyRange( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::GetDirtyRange
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    *pStart = m_rtDirtyStart;
    *pStop = m_rtDirtyStop;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::SetDirtyRange2
    (REFTIME Start, REFTIME Stop )
{
    REFERENCE_TIME p1 = DoubleToRT( Start );
    REFERENCE_TIME p2 = DoubleToRT( Stop );
    HRESULT hr = SetDirtyRange( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineObj::SetDirtyRange
    (REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    // need to do different things, depending on what our major type is.
    // every C++ class should need to override this.

    DbgLog((LOG_TRACE, 2, TEXT("SetDirtyRange: Derived class should implement." )));

    return E_NOTIMPL; // okay
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::ClearDirty
    ( )
{
    m_rtDirtyStart = -1;
    m_rtDirtyStop = -1;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::Remove()
{
    // if this thing isn't in the tree already, don't do anything
    //
    IAMTimelineObj * pParent = 0;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return NOERROR;
    }

    return XRemoveOnlyMe( );
}

STDMETHODIMP CAMTimelineObj::RemoveAll()
{
    // if this thing isn't in the tree already, don't do anything
    //
    IAMTimelineObj * pParent = 0;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return NOERROR;
    }

    return XRemove( );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetClassID( GUID * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = m_ClassID;
    
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::IsDirty( )
{
    // !!! always dirty!
    //
    return S_OK;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::Load( IStream * pStream )
{
    HRESULT hr = 0;
    long Value = 0;

    _Clear( );

    // read in version
    //
    hr = pStream->Read( &Value, sizeof( long ), NULL );

    // read in times
    //
    hr = pStream->Read( &m_rtStart, sizeof( REFERENCE_TIME ), NULL );
    hr = pStream->Read( &m_rtStop, sizeof( REFERENCE_TIME ), NULL );

    // read in muted
    //
    hr = pStream->Read( &Value, sizeof( long ), NULL );
    m_bMuted = (Value != 0);

    // read in locked
    //
    hr = pStream->Read( &Value, sizeof( long ), NULL );
    m_bLocked = (Value != 0);

    // read in the sub-object GUID, size of a guid is 16
    //
    hr = pStream->Read( (char*) &m_SubObjectGuid, 16, NULL );

    // do not load sub-object here, wait to instantiate it later when needed
    
    // set dirty flag
    //
    SetDirtyRange( m_rtStart, m_rtStop );

    // read in user data
    //
    hr = pStream->Read( &Value, sizeof( long ), NULL );
    m_nUserDataSize = Value;
    if( m_nUserDataSize )
    {
        m_pUserData = new BYTE[m_nUserDataSize];
        if( !m_pUserData )
        {
            _Clear( );
            DbgLog((LOG_TRACE, 2, TEXT("Load: user data memory allocation failed." )));
            return E_OUTOFMEMORY;
        }
        hr = pStream->Read( m_pUserData, m_nUserDataSize, NULL );
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::Save( IStream * pStream, BOOL fClearDirty )
{
    HRESULT hr = 0;
    long Value = 0;

    // write out version
    //
    Value = 0;
    hr = pStream->Write( &Value, sizeof( long ), NULL );

    // write out times
    //
    hr = pStream->Write( &m_rtStart, sizeof( REFERENCE_TIME ), NULL );
    hr = pStream->Write( &m_rtStop, sizeof( REFERENCE_TIME ), NULL );

    // write out muted
    //
    Value = m_bMuted;
    hr = pStream->Write( &Value, sizeof( long ), NULL );

    // write out locked
    //
    Value = m_bLocked;
    hr = pStream->Write( &Value, sizeof( long ), NULL );

    // write out the sub-object GUID, size of a guid is 16
    //
    hr = pStream->Write( (char*) &m_SubObjectGuid, 16, NULL );

    // do not persist out the sub-object here
    
    // write out user data
    //
    Value = m_nUserDataSize;
    hr = pStream->Write( &Value, sizeof( long ), NULL );
    if( m_nUserDataSize )
    {
        hr = pStream->Write( m_pUserData, m_nUserDataSize, NULL );
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetSizeMax( ULARGE_INTEGER * pcbSize )
{
    CheckPointer( pcbSize, E_POINTER );
    pcbSize->LowPart = OUR_MAX_STREAM_SIZE;
    pcbSize->HighPart = 0;
    return NOERROR;
}

//############################################################################
// complicated function. Must copy everything, including the sub-object,
//############################################################################

HRESULT CAMTimelineObj::CopyDataTo( IAMTimelineObj * pSrc, REFERENCE_TIME TimelineTime )
{
    HRESULT hr = 0;

    // these functions cannot fail
    //
    pSrc->SetStartStop( m_rtStart, m_rtStop );
    pSrc->SetTimelineType( m_TimelineType );
    pSrc->SetUserID( m_UserID );
    pSrc->SetSubObjectGUID( m_SubObjectGuid );
    pSrc->SetMuted( m_bMuted );
    pSrc->SetLocked( m_bLocked );
    pSrc->SetDirtyRange( m_rtStart, m_rtStop );

    // these functions can bomb on allocating memory
    //
    hr = pSrc->SetUserData( m_pUserData, m_nUserDataSize );
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = pSrc->SetUserName( m_UserName );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // if we have any properties in the property setter, the new object
    // needs them too.
    //
    if( !m_pSetter )
    {
        hr = pSrc->SetPropertySetter( NULL );
    }
    else
    {
        // clone our property setter and give it to the new
        // !!! these times are wrong.
        CComPtr< IPropertySetter > pNewSetter;
        hr = m_pSetter->CloneProps( &pNewSetter, TimelineTime - m_rtStart, m_rtStop - m_rtStart );
        ASSERT( !FAILED( hr ) );
        if( FAILED( hr ) )
        {
            return hr;
        }
        hr = pSrc->SetPropertySetter( pNewSetter );
    }

    if( FAILED( hr ) )
    {
        return hr;
    }

    if( m_pSubObject )
    {
        // how to create a copy of a COM object
        //
        CComPtr< IStream > pMemStream;
        CreateStreamOnHGlobal( NULL, TRUE, &pMemStream );
        if( !pMemStream )
        {
            return E_OUTOFMEMORY;
        }
        CComQIPtr< IPersistStream, &IID_IPersistStream > pPersistStream( m_pSubObject );
        if( pPersistStream )
        {
            CComPtr< IUnknown > pNewSubObject;
            hr = pPersistStream->Save( pMemStream, TRUE );
            ASSERT( !FAILED( hr ) );
            if( FAILED( hr ) )
            {
                return hr;
            }
            hr = pMemStream->Commit( 0 );
            if( FAILED( hr ) )
            {
                return hr;
            }
            LARGE_INTEGER li;
            li.QuadPart = 0;
            hr = pMemStream->Seek( li, STREAM_SEEK_SET, NULL );
            if( FAILED( hr ) )
            {
                return hr;
            }
            OleLoadFromStream( pMemStream, IID_IUnknown, (void**) &pNewSubObject );
            if( !pNewSubObject )
            {
                return E_OUTOFMEMORY;
            }
            hr = pSrc->SetSubObject( pNewSubObject );
        }
    }

    return hr;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetTimelineNoRef( IAMTimeline ** ppResult )
{
    HRESULT hr = 0;

    CheckPointer( ppResult, E_POINTER );
    *ppResult = NULL;

    CComPtr< IAMTimelineGroup > pGroup;
    hr = GetGroupIBelongTo( &pGroup );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = pGroup->GetTimeline( ppResult );

    // don't hold a reference to it
    //
    if( *ppResult )
    {
        (*ppResult)->Release( );
    }
    return hr;
}

//############################################################################
// try to find the subobject's GUID, only called by SetSubObject.
//############################################################################

GUID CAMTimelineObj::_GetObjectGuid( IUnknown * pObject )
{
    GUID guid;
    HRESULT hr = 0;

    // ask IPersist for it
    CComQIPtr< IPersist, &IID_IPersist > pPersist( pObject );
    if( pPersist )
    {
        hr = pPersist->GetClassID( &guid );
        return guid;
    }

    // ask IPersistStorage for it
    CComQIPtr< IPersistStorage, &IID_IPersistStorage > pPersistStorage( pObject );
    if( pPersistStorage )
    {
        hr = pPersistStorage->GetClassID( &guid );
        return guid;
    }

    // oh darn, ask IPersistPropertyBag?
    //
    CComQIPtr< IPersistPropertyBag, &IID_IPersistPropertyBag > pPersistPropBag( pObject );
    if( pPersistPropBag )
    {
        hr = pPersistPropBag->GetClassID( &guid );
        return guid;
    }

    // DARN!
    //
    return GUID_NULL;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineObj::GetGenID( long * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_nGenID;
    return NOERROR;
}

//############################################################################
// fix up the times to align on our group's frame rate
//############################################################################

STDMETHODIMP CAMTimelineObj::FixTimes2( REFTIME * pStart, REFTIME * pStop )
{
    REFERENCE_TIME p1 = 0;
    if( pStart )
    {
        p1 = DoubleToRT( *pStart );
    }
    REFERENCE_TIME p2 = 0;
    if( pStop )
    {
        p2 = DoubleToRT( *pStop );
    }
    HRESULT hr = FixTimes( &p1, &p2 );
    if( pStart )
    {
        *pStart = RTtoDouble( p1 );
    }
    if( pStop )
    {
        *pStop = RTtoDouble( p2 );
    }
    return hr;
}

//############################################################################
// These parameters are IN/OUT. It fixes up what was passed in.
//############################################################################

STDMETHODIMP CAMTimelineObj::FixTimes
    ( REFERENCE_TIME * pStart, REFERENCE_TIME * pStop )
{
    REFERENCE_TIME Start = 0;
    REFERENCE_TIME Stop = 0;
    if( pStart )
    {
        Start = *pStart;
    }
    if( pStop )
    {
        Stop = *pStop;
    }

    CComPtr< IAMTimelineGroup > pGroup;
    HRESULT hr = 0;
    hr = GetGroupIBelongTo( &pGroup );
    if( !pGroup )
    {
        return E_NOTINTREE;
    }

    double FPS = TIMELINE_DEFAULT_FPS;
    pGroup->GetOutputFPS( &FPS );

    LONGLONG f = Time2Frame( Start, FPS );
    REFERENCE_TIME NewStart = Frame2Time( f, FPS );
    f = Time2Frame( Stop, FPS );
    REFERENCE_TIME NewStop = Frame2Time( f, FPS );

    if( pStart )
    {
        *pStart = NewStart;
    }
    if( pStop )
    {
        *pStop = NewStop;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetGroupIBelongTo( IAMTimelineGroup ** ppGroup )
{
    CheckPointer( ppGroup, E_POINTER );

    *ppGroup = NULL;
    HRESULT hr = 0;

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = this; // okay not CComPtr

    long HaveParent;
    while( 1 )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( p );
        HaveParent = 0;
        hr = pNode->XHaveParent( &HaveParent );
        if( HaveParent == 0 )
        {
            break;
        }
        pNode->XGetParentNoRef( &p );
    }

    CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pGroup( p );
    if( !pGroup )
    {
        return E_NOINTERFACE;
    }

    *ppGroup = pGroup;
    (*ppGroup)->AddRef( );
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineObj::GetEmbedDepth( long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = 0;
    HRESULT hr = 0;

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = this; // okay not CComPtr

    long HaveParent;
    while( 1 )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( p );
        HaveParent = 0;
        hr = pNode->XHaveParent( &HaveParent );
        if( HaveParent == 0 )
        {
            break;
        }

        (*pVal)++;
        pNode->XGetParentNoRef( &p );

    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

void CAMTimelineObj::_BumpGenID( )
{
    // bump by a # to account for things who want to fiddle with secret
    // things in the graph cache. Don't change this.
    m_nStaticGenID = m_nStaticGenID + 10;
    m_nGenID = m_nStaticGenID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbnode.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineNode::CAMTimelineNode( )
: m_pParent( NULL )
, m_pNext( NULL )
, m_pPrev( NULL )
, m_pKid( NULL )
, m_bPriorityOverTime( FALSE )
{
}

//############################################################################
// 
//############################################################################

CAMTimelineNode::~CAMTimelineNode( )
{
    // the order in which release things is important. Don't do it otherwise
    m_pParent = NULL;
    m_pNext = NULL;
    m_pPrev = NULL;
    m_pKid = NULL;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetParent( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    if( m_pParent )
    {
        *ppResult = m_pParent;
        (*ppResult)->AddRef( );
    }
    return NOERROR;
}

HRESULT CAMTimelineNode::XGetParentNoRef( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    if( m_pParent )
    {
        *ppResult = m_pParent;
    }
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSetParent( IAMTimelineObj * pObj )
{
    m_pParent = pObj;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetPrev( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );

    HRESULT hr = XGetPrevNoRef( ppResult );
    if( *ppResult )
    {
        (*ppResult)->AddRef( );
    }
    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSetPrev( IAMTimelineObj * pObj )
{
    m_pPrev = pObj;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetNext( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    HRESULT hr = XGetNextNoRef( ppResult );
    if( *ppResult )
    {
        (*ppResult)->AddRef( );
    }
    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSetNext( IAMTimelineObj * pObj )
{
    m_pNext = pObj;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XKidsOfType( long MajorTypeCombo, long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    // if no kids, return 0
    //
    if( !m_pKid )
    {
        *pVal = 0;
        return NOERROR;
    }

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = m_pKid; // okay not CComPtr

    long count = 0;

    while( p )
    {
        TIMELINE_MAJOR_TYPE Type;
        p->GetTimelineType( &Type );
        if( ( Type & MajorTypeCombo ) == Type )
        {
            count++;
        }

        // get the next kid
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p2( p );
        p2->XGetNextNoRef( &p );
    }

    *pVal = count;
    return NOERROR;
}

//############################################################################
// 
//############################################################################


HRESULT CAMTimelineNode::XGetNthKidOfType
    ( long MajorTypeCombo, long Number, IAMTimelineObj ** ppResult )
{
    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * p = m_pKid; // okay not CComPtr

    while( p )
    {
        // get the type
        //
        TIMELINE_MAJOR_TYPE Type;
        p->GetTimelineType( &Type ); // assume won't fail

        // found a type that matches, decrement how many we're looking for.
        //
        if( ( Type & MajorTypeCombo ) == Type )
        {
            // if Number is 0, then we've found the Xth child, return it.
            //
            if( Number == 0 )
            {
                *ppResult = p;
                (*ppResult)->AddRef( );
                return NOERROR;
            }

            // not yet, go get the next one
            //
            Number--;
        }

        // doesn't match our type, get the next one
        //
        IAMTimelineNode *p2;    // avoid CComPtr for perf
        p->QueryInterface(IID_IAMTimelineNode, (void **)&p2);
        p2->XGetNextNoRef( &p );
        p2->Release();
    } // while p

    *ppResult = NULL;
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XSwapKids( long MajorTypeCombo, long KidA, long KidB )
{
    long KidCount = 0;
    XKidsOfType( MajorTypeCombo, &KidCount );
    if( ( KidA < 0 ) || ( KidB < 0 ) )
    {
        return E_INVALIDARG;
    }
    if( ( KidA >= KidCount ) || ( KidB >= KidCount ) )
    {
        return E_INVALIDARG;
    }

    // there are two things we can swap so far, tracks and effects, both of them
    // take priorities. 

    // make this easier on us
    //
    long min = min( KidA, KidB );
    long max = max( KidA, KidB );

    // get the objects themselves
    //
    CComPtr< IAMTimelineObj > pMinKid;
    HRESULT hr;
    hr = XGetNthKidOfType( MajorTypeCombo, min, &pMinKid );
    CComPtr< IAMTimelineObj > pMaxKid;
    hr = XGetNthKidOfType( MajorTypeCombo, max, &pMaxKid );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidNode( pMinKid );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidNode( pMaxKid );

    // don't compare for being the exact same type, we already know this works
    // because we got the "nth" kid of the right type

    // get everyone's neighboors
    //
    CComPtr< IAMTimelineObj > pMinKidPrev;
    hr = pMinKidNode->XGetPrev( &pMinKidPrev );
    CComPtr< IAMTimelineObj > pMinKidNext;
    hr = pMinKidNode->XGetNext( &pMinKidNext );
    CComPtr< IAMTimelineObj > pMaxKidPrev;
    hr = pMaxKidNode->XGetPrev( &pMaxKidPrev );
    CComPtr< IAMTimelineObj > pMaxKidNext;
    hr = pMaxKidNode->XGetNext( &pMaxKidNext );

    // what if pMinKid what the first kid?
    //
    if( pMinKid == m_pKid )
    {
        m_pKid.Release( );
        m_pKid = pMaxKid;
    }

    // do something special if we're swapping direct neighboors
    //
    if( pMinKidNext == pMaxKid )
    {
        pMaxKidNode->XSetPrev( pMinKidPrev );
        pMinKidNode->XSetNext( pMaxKidNext );
        pMaxKidNode->XSetNext( pMinKid );
        pMinKidNode->XSetPrev( pMaxKid );
        if( pMinKidPrev )
        {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidPrevNode( pMinKidPrev );
            pMinKidPrevNode->XSetNext( pMaxKid );
        }
        if( pMaxKidNext )
        {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidNextNode( pMaxKidNext );
            pMaxKidNextNode->XSetPrev( pMinKid );
        }
        return NOERROR;
    }

    pMaxKidNode->XSetPrev( pMinKidPrev );
    pMinKidNode->XSetNext( pMaxKidNext );
    pMaxKidNode->XSetNext( pMinKidNext );
    pMinKidNode->XSetPrev( pMaxKidPrev );
    if( pMinKidPrev )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidPrevNode( pMinKidPrev );
        pMinKidPrevNode->XSetNext( pMaxKid );
    }
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMinKidNextNode( pMinKidNext );
    pMinKidNextNode->XSetPrev( pMaxKid );
    if( pMaxKidNext )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidNextNode( pMaxKidNext );
        pMaxKidNextNode->XSetPrev( pMinKid );
    }
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pMaxKidPrevNode( pMaxKidPrev );
    pMaxKidPrevNode->XSetNext( pMinKid );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XHaveParent( long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = 0;

    if( m_pParent ) 
    {
        *pVal = 1;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XWhatPriorityAmI( long MajorTypeCombo, long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    IAMTimelineObj * pParent = NULL; // okay not ComPtr
    XGetParentNoRef( &pParent );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParent2( pParent );

    if( NULL == pParent )
    {
        *pVal = -1;
        return NOERROR;
    }

    long counter = 0;

    CComPtr< IAMTimelineObj > pKid; 
    pParent2->XGetNthKidOfType( MajorTypeCombo, 0, &pKid );

    while( 1 )
    {
        // no more kids, and we're still looking, so return -1
        //
        if( pKid == NULL )
        {
            return -1;
        }

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid2( pKid );

        // we addreffed it just above
        //
        pKid.Release( );

        // found it, return how many kids we looked at
        //
        if( pKid2 == (IAMTimelineNode*) this )
        {
            *pVal = counter;
            return NOERROR;
        }

        counter++;
        pKid2->XGetNextOfType( MajorTypeCombo, &pKid );
    }

    // never get here
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XGetNextOfType( long MajorTypeCombo, IAMTimelineObj ** ppResult )
{
    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * pNext = m_pNext; // okay not CComPtr

    while( pNext )
    {
        TIMELINE_MAJOR_TYPE Type;
        pNext->GetTimelineType( &Type );
        
        // if the types match, this is the next we want
        //
        if( ( Type & MajorTypeCombo ) == Type )
        {
            *ppResult = pNext;
            (*ppResult)->AddRef( );
            return NOERROR;
        }

        IAMTimelineNode *pNextNext; // no CComPtr for perf.
        pNext->QueryInterface(IID_IAMTimelineNode, (void **)&pNextNext);
        pNextNext->XGetNextNoRef( &pNext );
        pNextNext->Release();
    }

    // didn't find any next of type!
    //
    DbgLog((LOG_TRACE, 2, TEXT("XGetNextOfType: Didn't find anything of type %ld" ), MajorTypeCombo ));
    *ppResult = NULL;
    return S_FALSE;
}

//############################################################################
// release all of our references and remove ourselves from the tree.
// DO NOT REMOVE KIDS
//############################################################################

HRESULT CAMTimelineNode::XRemoveOnlyMe( )
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pPrev( m_pPrev );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNext( m_pNext );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParent( m_pParent );

    // take care of who points to us as the parent

    // if we're the first kid, the parent needs
    // to point to someone else besides us.
    //
    if( !m_pPrev )
    {
        if( !m_pParent )
        {
            // no parent is okay, as long as you are the root comp
        }
        else
        {
            // parent' first kid is not us, that's for sure!
            //
            pParent->XResetFirstKid( m_pNext );
            m_pParent.Release();
        }
    }

    CComPtr< IAMTimelineObj > pPrevTemp( m_pPrev );

    // take care of who points to us as the prev
    //
    if( m_pPrev )
    {
        m_pPrev = NULL;

        pPrev->XSetNext( m_pNext );
    }

    // take care of who points to us as the next
    //
    if( pNext )
    {
        m_pNext = NULL;

        pNext->XSetPrev( pPrevTemp );
    }

    return NOERROR;
}

//############################################################################
// release all of our references and remove ourselves from the tree.
//############################################################################

HRESULT CAMTimelineNode::XRemove( )
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pPrev( m_pPrev );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNext( m_pNext );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pParent( m_pParent );

    // take care of who points to us as the parent

    // if we're the first kid, the parent needs
    // to point to someone else besides us.
    //
    if( !m_pPrev )
    {
        if( !m_pParent )
        {
            // no parent is okay, as long as you are the root comp
        }
        else
        {
            // parent' first kid is not us, that's for sure!
            //
            pParent->XResetFirstKid( m_pNext );
            m_pParent.Release();
        }
    }

    CComPtr< IAMTimelineObj > pPrevTemp( m_pPrev );

    // take care of who points to us as the prev
    //
    if( m_pPrev )
    {
        m_pPrev = NULL;

        pPrev->XSetNext( m_pNext );
    }

    // take care of who points to us as the next
    //
    if( pNext )
    {
        m_pNext = NULL;

        pNext->XSetPrev( pPrevTemp );
    }

    // remove all of our kids
    //
    XClearAllKids( );

    // done removing kids, good.

    return NOERROR;
}

//############################################################################
// 
//############################################################################

void CAMTimelineNode::XAddKid
    ( IAMTimelineObj * pAddor )
{
    if( !m_pKid )
    {
        m_pKid = pAddor;
    }
    else
    {
        // find last kid
        //
        IAMTimelineObj * pLastKid = XGetLastKidNoRef( ); // okay not CComPtr

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pLastKid2( pLastKid );

        pLastKid2->XSetNext( pAddor );

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pAddor2( pAddor );

        pAddor2->XSetPrev( pLastKid );
    }

    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pParent( (IAMTimelineNode*) this );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid( pAddor );
    pKid->XSetParent( pParent );
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XAddKidByPriority
    ( long MajorTypeCombo, IAMTimelineObj * pThingToInsert, long Which )
{
    // -1 means add last
    //
    if( Which == -1 )
    {
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    CComPtr< IAMTimelineObj > pThingBeingAddedTo;
    XGetNthKidOfType( MajorTypeCombo, Which, &pThingBeingAddedTo );

    // we want to insert the new one just before the nth kid we just got.
    
    if( !pThingBeingAddedTo )
    {
        // we don't have the one we're looking fer, 
        // so just add it to the end of the list
        //
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    // found who we want to insert in front of.
    //
    HRESULT hr = XInsertKidBeforeKid( pThingToInsert, pThingBeingAddedTo );
    return hr;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XInsertKidBeforeKid( IAMTimelineObj * pThingToInsert, IAMTimelineObj * pThingBeingAddedTo )
{
    // we can assume pThingToInsert is a kid of ours
    
    // if pThingBeingAddedTo is NULL, then add pThingToInsert at end of list
    //
    if( pThingBeingAddedTo == NULL )
    {
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    // is pThingBeingAddedTo the very first kid?
    //
    if( pThingBeingAddedTo == m_pKid )
    {
        // yep, then insert pThingToInsert before that
        //
        CComPtr< IAMTimelineObj > pOldFirstKid = m_pKid;
        m_pKid = pThingToInsert;
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p( m_pKid );
        p->XSetNext( pOldFirstKid );
        p = pOldFirstKid;
        p->XSetPrev( m_pKid );
    }
    else
    {
        // nope, insert pThingToInsert before the kid
        //
        CComPtr< IAMTimelineObj > pPrev;
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p( pThingBeingAddedTo );
        // get the thing previous to the addor
        p->XGetPrev( &pPrev );
        p = pPrev;
        // by setting prev/next, this will temporarily drop the refcount on the old pThingBeingAddedTo,
        // so we need to addref/release around it
        pThingBeingAddedTo->AddRef( );
        p->XSetNext( pThingToInsert );
        p = pThingToInsert;
        p->XSetPrev( pPrev );
        p->XSetNext( pThingBeingAddedTo );
        p = pThingBeingAddedTo;
        p->XSetPrev( pThingToInsert );
        pThingBeingAddedTo->Release( );
    }

    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pParent( (IUnknown*) this );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid( pThingToInsert );
    pKid->XSetParent( pParent );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineNode::XInsertKidAfterKid( IAMTimelineObj * pThingToInsert, IAMTimelineObj * pThingBeingAddedTo )
{
    // we can assume pThingToInsert is a kid of ours
    
    // if pThingBeingAddedTo is NULL, then add pThingToInsert at end of list
    //
    if( pThingBeingAddedTo == NULL )
    {
        XAddKid( pThingToInsert );
        return NOERROR;
    }

    CComPtr< IAMTimelineObj > pNext;
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > p( pThingBeingAddedTo );
    // get the thing after the addor
    p->XGetNext( &pNext );
    if (pNext) 
    {
        p = pNext;
        p->XSetPrev( pThingToInsert );
    }
    p = pThingToInsert;
    p->XSetNext( pNext );
    p->XSetPrev( pThingBeingAddedTo );
    p = pThingBeingAddedTo;
    p->XSetNext( pThingToInsert );

    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pParent( (IUnknown*) this );
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid( pThingToInsert );
    pKid->XSetParent( pParent );

    return NOERROR;
}

//############################################################################
// 
//############################################################################

IAMTimelineObj * CAMTimelineNode::XGetLastKidNoRef( )
{
    // no kids = no return
    //
    if( !m_pKid )
    {
        return NULL;
    }

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * pKid = m_pKid; // okay not CComPtr

    while( 1 )
    {
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid2( pKid );
        IAMTimelineObj * pNext = NULL; // okay not CComPtr
        pKid2->XGetNextNoRef( &pNext );

        if( NULL == pNext )
        {
            return pKid;
        }

        pKid = pNext;
    }

    // never gets here.
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XClearAllKids( )
{
    // remove all of our kids
    //
    CComPtr< IAMTimelineObj > pKid;

    while( 1 )
    {
        // kick out of while loop if we've removed all of the kids from the tree
        //
        if( !m_pKid )
        {
            break;
        }

        // reset pointer, because it may have changed below
        //
        pKid = m_pKid;

        {
            CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pKid );

            // remove kid from tree, this may change our kid pointer
            //
            pNode->XRemove( );
        }

        pKid = NULL;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XGetNextOfTypeNoRef( long MajorType, IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );

    HRESULT hr = XGetNextOfType( MajorType, ppResult );
    if( *ppResult )
    {
        (*ppResult)->Release( );
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XGetNextNoRef( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    *ppResult = m_pNext; // since we are making an assignment, no addref
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XGetPrevNoRef( IAMTimelineObj ** ppResult )
{
    CheckPointer( ppResult, E_POINTER );
    *ppResult = m_pPrev;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XResetFirstKid( IAMTimelineObj * pKid )
{
    m_pKid = pKid;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineNode::XAddKidByTime( long MajorTypeCombo, IAMTimelineObj * pToAdd )
{
    HRESULT hr = 0;

    // no kids = no return
    //
    if( !m_pKid )
    {
        XAddKid( pToAdd );
        return NOERROR;
    }

    REFERENCE_TIME InStart = 0;
    REFERENCE_TIME InStop = 0;
    pToAdd->GetStartStop( &InStart, &InStop );

    // since we never use bumping of refcounts in here, don't use a CComPtr
    //
    IAMTimelineObj * pKid = m_pKid; // okay not CComPtr

    while( pKid )
    {
        // ask the kid if he's (he?) the right type
        //
        TIMELINE_MAJOR_TYPE Type;
        pKid->GetTimelineType( &Type );

        // only consider it if the types match
        //
        if( ( Type & MajorTypeCombo ) == Type )
        {
            // ask it for it's times
            //
            REFERENCE_TIME Start = 0;
            REFERENCE_TIME Stop = 0;
            pKid->GetStartStop( &Start, &Stop );

            if( InStop <= Start )
            {
                // found the one to insert into
                //
                hr = XInsertKidBeforeKid( pToAdd, pKid );
                return hr;
            }
        }

        // get the next one
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pKid2( pKid );
        pKid2->XGetNextNoRef( &pKid );
    }

    // well, didn't find anything that matched, so add it at the end
    //
    XAddKid( pToAdd );

    return NOERROR;

}

STDMETHODIMP CAMTimelineNode::XGetPriorityOverTime( BOOL * pResult )
{
    CheckPointer( pResult, E_POINTER );
    *pResult = m_bPriorityOverTime;
    return NOERROR;
}

IAMTimelineObj * CAMTimelineNode::XGetFirstKidNoRef( )
{
    return m_pKid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbtran.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

#define CUT_NOT_SET_TIME -1

#pragma warning( disable : 4800 )  // Disable warning messages

//############################################################################
// 
//############################################################################

CAMTimelineTrans::CAMTimelineTrans( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
    , m_rtCut( CUT_NOT_SET_TIME )
    , m_fSwapInputs( FALSE )
    , m_bCutsOnly( FALSE )
{
    m_ClassID = CLSID_AMTimelineTrans;
    m_TimelineType = TIMELINE_MAJOR_TYPE_TRANSITION;
}

//############################################################################
// 
//############################################################################

CAMTimelineTrans::~CAMTimelineTrans( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineTrans )
    {
        return GetInterface( (IAMTimelineTrans*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineTrans::GetCutPoint2( REFTIME * pTLTime )
{
    REFERENCE_TIME p1 = DoubleToRT( *pTLTime );
    HRESULT hr = GetCutPoint( &p1 );
    *pTLTime = RTtoDouble( p1 );
    return hr;
}

HRESULT CAMTimelineTrans::GetCutPoint( REFERENCE_TIME * pTLTime )
{
    CheckPointer( pTLTime, E_POINTER );

    // if we haven't set a cut point, then cut point is midway and we return S_FALSE
    //
    if( CUT_NOT_SET_TIME == m_rtCut )
    {
        *pTLTime = ( m_rtStop - m_rtStart ) / 2;
        return S_FALSE;
    }

    *pTLTime = m_rtCut;

    return NOERROR;
}

//############################################################################
// 
//############################################################################

HRESULT CAMTimelineTrans::SetCutPoint2( REFTIME TLTime )
{
    REFERENCE_TIME p1 = DoubleToRT( TLTime );
    HRESULT hr = SetCutPoint( p1 );
    return hr;
}

HRESULT CAMTimelineTrans::SetCutPoint( REFERENCE_TIME TLTime )
{
    // validate ranges
    //
    if( TLTime < 0 )
    {
        TLTime = 0;
    }
    if( TLTime > m_rtStop - m_rtStart )
    {
        TLTime = m_rtStop - m_rtStart;
    }

    m_rtCut = TLTime;

    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::GetSwapInputs( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );

    *pVal = (BOOL) m_fSwapInputs;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::SetSwapInputs( BOOL pVal )
{
    m_fSwapInputs = pVal;
    return NOERROR;
}


//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::SplitAt2( REFTIME t )
{
    REFERENCE_TIME t1 = DoubleToRT( t );
    return SplitAt( t1 );
}

STDMETHODIMP CAMTimelineTrans::SplitAt( REFERENCE_TIME SplitTime )
{
    DbgLog((LOG_TRACE,2,TEXT("Trans::Split")));

    // is our split time withIN our time?
    //
    if( SplitTime <= m_rtStart || SplitTime >= m_rtStop )
    {
        return E_INVALIDARG;
    }

    // we need to be attached to something.
    //
    IAMTimelineObj * pParent;
    XGetParentNoRef( &pParent );
    if( !pParent )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = 0;
    CAMTimelineTrans * pNew = new CAMTimelineTrans( NAME("Timeline Transition"), NULL, &hr );
    if( FAILED( hr ) )
    {
        return E_OUTOFMEMORY;
    }

    // we have created an object that has NO references on it. If we call ANYTHING that
    // addreffs and releases the pNewSrc, it will be deleted. So addref it NOW.

    pNew->AddRef( );

    hr = CopyDataTo( pNew, SplitTime );
    if( FAILED( hr ) )
    {
        delete pNew;
        return hr;
    }

    pNew->m_rtStart = SplitTime;
    pNew->m_rtStop = m_rtStop;
    m_rtStop = SplitTime;

    // need to add the new transition to the tree
    // !!! Will priority be right?
    //
    CComQIPtr< IAMTimelineTransable, &IID_IAMTimelineTransable > pTransable( pParent );
    hr = pTransable->TransAdd( pNew );

    if( !FAILED( hr ) )
    {
        pNew->Release( );
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::SetCutsOnly( BOOL Val )
{
    m_bCutsOnly = Val;
    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrans::GetCutsOnly( BOOL * pVal )
{
    CheckPointer( pVal, E_POINTER );
    *pVal = m_bCutsOnly;
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbtnbl.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineTransable::CAMTimelineTransable( )
{
}

//############################################################################
// 
//############################################################################

CAMTimelineTransable::~CAMTimelineTransable( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::TransAdd
    (IAMTimelineObj * pTransObj)
{
    CComQIPtr< IAMTimelineTrans, &IID_IAMTimelineTrans > pTrans( pTransObj );
    if( !pTrans )
    {
        return E_NOINTERFACE;
    }

    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );
    REFERENCE_TIME Start = 0;
    REFERENCE_TIME Stop = 0;
    pTransObj->GetStartStop( &Start, &Stop );
    bool available = _IsSpaceAvailable( Start, Stop );
    if( !available )
    {
        return E_INVALIDARG;
    }
    return pThis->XAddKidByTime( TIMELINE_MAJOR_TYPE_TRANSITION, pTransObj );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::TransGetCount
    (long * pCount)
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    CheckPointer( pCount, E_POINTER );

    return pThis->XKidsOfType( TIMELINE_MAJOR_TYPE_TRANSITION, pCount );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::GetNextTrans2
    (IAMTimelineObj ** ppTrans, REFTIME * pInOut)
{
    REFERENCE_TIME p1 = DoubleToRT( *pInOut );
    HRESULT hr = GetNextTrans( ppTrans, &p1 );
    *pInOut = RTtoDouble( p1 );
    return hr;
}

STDMETHODIMP CAMTimelineTransable::GetNextTrans
    (IAMTimelineObj ** ppTrans, REFERENCE_TIME * pInOut)
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    // since we're enumerating stuff, the times we pass out will be aligned
    // to the output FPS.

    // search through our kids until we find something that's at or just 
    // before the given time.

    // get the pointer, and immediately release it. This is almost safe,
    // since we (almost) know the thing is going to stay in the timeline throughout
    // the duration of this call. This is not technically thread-safe
    //
    IAMTimelineObj * pChild = NULL; // okay not CComPtr
    pThis->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_TRANSITION, 0, &pChild );
    if( pChild )
    {
        pChild->Release( );
    }

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME Start, Stop;
        pChild->GetStartStop( &Start, &Stop ); // assume no error

        if( Stop > * pInOut ) // careful of off-by-one!
        {
            // found it!
            //
            *ppTrans = pChild;
            (*ppTrans)->AddRef( );
            *pInOut = Stop;

            return NOERROR;
        }

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild = NULL;
        pChild2->XGetNextOfTypeNoRef( TIMELINE_MAJOR_TYPE_TRANSITION, &pChild );
    }

    *ppTrans = NULL;
    *pInOut = 0;
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

bool CAMTimelineTransable::_IsSpaceAvailable
    ( REFERENCE_TIME SearchStart, REFERENCE_TIME SearchStop )
{
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pThis( (IUnknown*) this );

    // get the pointer, and immediately release it. This is almost safe,
    // since we (almost) know the thing is going to stay in the timeline throughout
    // the duration of this call. !!! This is not technically thread-safe
    //
    IAMTimelineObj * pChild = NULL; // okay not CComPtr
    pThis->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_TRANSITION, 0, &pChild );
    if( pChild )
    {
        pChild->Release( );
    }

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME Start, Stop;
        pChild->GetStartStop( &Start, &Stop ); // assume no error

        // if we haven't found a stop time greater than our search start,
        // we can ignore it
        //
        if( Stop > SearchStart )
        {
            // if the start time is greater, then our search stop, then
            // everything's fine
            //
            if( Start >= SearchStop )
            {
                return true;
            }

            // or, it must fall in our range and we cannot return
            // true
            //
            return false;
        }

        // well, keep looking then

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild = NULL;
        pChild2->XGetNextOfTypeNoRef( TIMELINE_MAJOR_TYPE_TRANSITION, &pChild );
    }

    // huh, we must not have found anything
    //
    return true;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::GetTransAtTime2
    (IAMTimelineObj ** ppObj, REFTIME Time, long SearchDirection )
{
    REFERENCE_TIME p1 = DoubleToRT( Time );
    HRESULT hr = GetTransAtTime( ppObj, p1, SearchDirection );
    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTransable::GetTransAtTime
    (IAMTimelineObj ** ppObj, REFERENCE_TIME Time, long SearchDirection )
{
    CheckPointer( ppObj, E_POINTER );

    switch( SearchDirection )
    {
    case DEXTERF_EXACTLY_AT:
    case DEXTERF_BOUNDING:
    case DEXTERF_FORWARDS:
        break;
    default:
        return E_INVALIDARG;
    }

    // make the result invalid first
    //
    *ppObj = NULL;

    // if we don't have any sources, then nothing
    //
    CComPtr< IAMTimelineObj > pObj;
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( this );
    pNode->XGetNthKidOfType( TIMELINE_MAJOR_TYPE_TRANSITION, 0, &pObj );
    if( !pObj )
    {
        return S_FALSE;
    }

    while( pObj )
    {
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pObj->GetStartStop( &Start, &Stop );

        if( SearchDirection == DEXTERF_EXACTLY_AT )
        {
            if( Start == Time )
            {
                *ppObj = pObj;
                (*ppObj)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_FORWARDS )
        {
            if( Start >= Time )
            {
                *ppObj = pObj;
                (*ppObj)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_BOUNDING )
        {
            if( Start <= Time && Stop > Time )
            {
                *ppObj = pObj;
                (*ppObj)->AddRef( );
                return NOERROR;
            }
        }

        // get the next source
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pObj );
        pObj.Release( );
        pNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_TRANSITION, &pObj );
    }

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\tldb\tldbtrck.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include "stdafx.h"
#include "tldb.h"

//############################################################################
// 
//############################################################################

CAMTimelineTrack::CAMTimelineTrack( TCHAR *pName, LPUNKNOWN pUnk, HRESULT * phr )
    : CAMTimelineObj( pName, pUnk, phr )
{
    m_TimelineType = TIMELINE_MAJOR_TYPE_TRACK;
}

//############################################################################
// 
//############################################################################

CAMTimelineTrack::~CAMTimelineTrack( )
{
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if( riid == IID_IAMTimelineTrack )
    {
        return GetInterface( (IAMTimelineTrack*) this, ppv );
    }
    if( riid == IID_IAMTimelineSplittable )
    {
        return GetInterface( (IAMTimelineSplittable*) this, ppv );
    }
    if( riid == IID_IAMTimelineVirtualTrack )
    {
        return GetInterface( (IAMTimelineVirtualTrack*) this, ppv );
    }
    if( riid == IID_IAMTimelineEffectable )
    {
        return GetInterface( (IAMTimelineEffectable*) this, ppv );
    }
    if( riid == IID_IAMTimelineTransable )
    {
        return GetInterface( (IAMTimelineTransable*) this, ppv );
    }
    return CAMTimelineObj::NonDelegatingQueryInterface( riid, ppv );
}

//############################################################################
// we are always in overwrite mode. If application wants to do insert mode,
// it must put the space there manually.
//############################################################################

STDMETHODIMP CAMTimelineTrack::SrcAdd
    (IAMTimelineObj * pSource)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSrc( pSource );
    if( !pSrc )
    {
        return E_NOINTERFACE;
    }

    REFERENCE_TIME AddedStart, AddedStop;
    pSource->GetStartStop( &AddedStart, &AddedStop ); // assume this works

    hr = ZeroBetween( AddedStart, AddedStop );
    if( FAILED( hr ) )
    {
        return hr;
    }    
    // find who we're supposed to be in front of
    //
    CComPtr<IAMTimelineObj> pNextSrc;

    // S_FALSE means we're sure this source goes at the end
    if (hr != S_FALSE)
    {
        hr = GetSrcAtTime( &pNextSrc, AddedStart, 1 );
    }
    
    // if we found something, insert it before that source
    //
    if( pNextSrc )
    {
        hr = XInsertKidBeforeKid( pSource, pNextSrc ); // assume works
    }
    else
    {
        // didn't find somebody to put it in front of, so just add it to the end
        //
        hr = XAddKidByPriority( TIMELINE_MAJOR_TYPE_SOURCE, pSource, -1 ); // assume works
    }

    return hr;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::GetNextSrc2
    (IAMTimelineObj ** ppSrc, REFTIME * pInOut)
{
    REFERENCE_TIME p1 = DoubleToRT( *pInOut );
    HRESULT hr = GetNextSrc( ppSrc, &p1 );
    *pInOut = RTtoDouble( p1 );
    return hr;
}

STDMETHODIMP CAMTimelineTrack::GetNextSrc
    (IAMTimelineObj ** ppSrc, REFERENCE_TIME * pInOut)
{
    // since we're enumerating stuff, the times we pass out will be aligned
    // to the output FPS.

    // search through our kids until we find something that's at or just 
    // before the given time.

    CComPtr< IAMTimelineObj > pChild;
    XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pChild );

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME Start, Stop;
        pChild->GetStartStop( &Start, &Stop ); // assume no error

        if( Stop > *pInOut ) // careful of off-by-one!
        {
            // found it!
            //
            *ppSrc = pChild;
            (*ppSrc)->AddRef( );
            *pInOut = Stop;

            return NOERROR;
        }

        // get the next one
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild.Release( );
        pChild2->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, &pChild );
    }

    *ppSrc = NULL;
    *pInOut = 0;
    return S_FALSE;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::GetNextSrcEx
    (IAMTimelineObj *pSrcLast, IAMTimelineObj ** ppSrcNext)
{
    if (!pSrcLast)
        return XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, ppSrcNext );

    // otherwise get the next one
    //
    CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pSrcLastNode( pSrcLast );

    return pSrcLastNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, ppSrcNext );
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::TrackGetPriority
    (long * pPriority)
{
    CheckPointer( pPriority, E_POINTER );

    return XWhatPriorityAmI( TIMELINE_MAJOR_TYPE_TRACK | TIMELINE_MAJOR_TYPE_COMPOSITE, pPriority );
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineTrack::GetSourcesCount
    ( long * pVal )
{
    CheckPointer( pVal, E_POINTER );

    return XKidsOfType( TIMELINE_MAJOR_TYPE_SOURCE, pVal );
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineTrack::SetTrackDirty
    ( )
{
    // ASSERT( function_not_done );
    return E_NOTIMPL; // settrackdirty
}

//############################################################################
// A track's start/stop is the min/max of anything it contains
//
//############################################################################

STDMETHODIMP CAMTimelineTrack::GetStartStop2
    (REFTIME * pStart, REFTIME * pStop)
{
    REFERENCE_TIME p1 = DoubleToRT( *pStart );
    REFERENCE_TIME p2 = DoubleToRT( *pStop );
    HRESULT hr = GetStartStop( &p1, &p2 );
    *pStart = RTtoDouble( p1 );
    *pStop = RTtoDouble( p2 );
    return hr;
}

STDMETHODIMP CAMTimelineTrack::GetStartStop
    (REFERENCE_TIME * pStart, REFERENCE_TIME * pStop)
{
    CheckPointer( pStart, E_POINTER );
    CheckPointer( pStop, E_POINTER );

    HRESULT hr = 0;

    REFERENCE_TIME Min = 0;
    REFERENCE_TIME Max = 0;

    // ask each of the kids for the amount of whatever it is we're looking for
    //
    IAMTimelineObj * pTrack = NULL;
    XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pTrack );
    if( pTrack )
    {
        pTrack->Release( ); // don't keep a ref count on it
    }
    while( pTrack )
    {
        // ask it for it's times
        //
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pTrack->GetStartStop( &Start, &Stop );
        if( Max == 0 )
        {
            Min = Start;
            Max = Stop;
        }
        // if( Start < Min ) Min = Start;
        if( Stop > Max ) Max = Stop;

        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode = pTrack;
        pTrack = NULL;
        pNode->XGetNextOfTypeNoRef( TIMELINE_MAJOR_TYPE_SOURCE, &pTrack );
    }

    *pStart = 0; // track times always start at 0
    *pStop = Max;

    return NOERROR;
}

//############################################################################
// ask if there are any sources on this track
//############################################################################

STDMETHODIMP CAMTimelineTrack::AreYouBlank
    (long * pVal)
{
    CheckPointer( pVal, E_POINTER );
    *pVal = 1;

    HRESULT hr = 0;
    CComQIPtr< IAMTimelineObj, &IID_IAMTimelineObj > pSource;
    hr = XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pSource );

    if( pSource )
    {
        *pVal = 0;
    }

    // !!! what about fx and transitions?

    return hr;
}

//############################################################################
//
//############################################################################

HRESULT CAMTimelineTrack::GetSrcAtTime2
    ( IAMTimelineObj ** ppSrc, REFTIME Time, long SearchDirection )
{
    REFERENCE_TIME p1 = DoubleToRT( Time );
    HRESULT hr = GetSrcAtTime( ppSrc, p1, SearchDirection );
    return hr;
}

HRESULT CAMTimelineTrack::GetSrcAtTime
    ( IAMTimelineObj ** ppSrc, REFERENCE_TIME Time, long SearchDirection )
{
    CheckPointer( ppSrc, E_POINTER );

    switch( SearchDirection )
    {
    case DEXTERF_EXACTLY_AT:
    case DEXTERF_BOUNDING:
    case DEXTERF_FORWARDS:
        break;
    default:
        return E_INVALIDARG;
    }

    // make the result invalid first
    //
    *ppSrc = NULL;

    // if we don't have any sources, then nothing
    //
    CComPtr< IAMTimelineObj > pSource;
    XGetNthKidOfType( TIMELINE_MAJOR_TYPE_SOURCE, 0, &pSource );
    if( !pSource )
    {
        return S_FALSE;
    }

    while( pSource )
    {
        REFERENCE_TIME Start = 0;
        REFERENCE_TIME Stop = 0;
        pSource->GetStartStop( &Start, &Stop );

        if( SearchDirection == DEXTERF_EXACTLY_AT )
        {
            if( Start == Time )
            {
                *ppSrc = pSource;
                (*ppSrc)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_FORWARDS )
        {
            if( Start >= Time )
            {
                *ppSrc = pSource;
                (*ppSrc)->AddRef( );
                return NOERROR;
            }
        }
        if( SearchDirection == DEXTERF_BOUNDING )
        {
            if( Start <= Time && Stop > Time )
            {
                *ppSrc = pSource;
                (*ppSrc)->AddRef( );
                return NOERROR;
            }
        }

        // get the next source
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pNode( pSource );
        pSource.Release( );
        pNode->XGetNextOfType( TIMELINE_MAJOR_TYPE_SOURCE, &pSource );
    }

    return S_FALSE;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineTrack::InsertSpace2
    ( REFTIME rtStart, REFTIME rtEnd )
{
    REFERENCE_TIME p1 = DoubleToRT( rtStart );
    REFERENCE_TIME p2 = DoubleToRT( rtEnd );
    HRESULT hr = InsertSpace( p1, p2 );
    return hr;
}

STDMETHODIMP CAMTimelineTrack::InsertSpace( REFERENCE_TIME rtStart, REFERENCE_TIME rtEnd )
{
    HRESULT hr = 0;

    // check for errors, ding-dong!
    //
    if( ( rtStart < 0 ) || ( rtEnd < 0 ) || ( rtEnd <= rtStart ) )
    {
        return E_INVALIDARG;
    }

    // first, chop anything on this track that crosses rtStart into two sections,
    // this will make it much easier to move
    //
    hr = SplitAt( rtStart );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // now, move everything
    //
    hr = MoveEverythingBy( rtStart, rtEnd - rtStart );

    return hr;
}

//############################################################################
//
//############################################################################

STDMETHODIMP CAMTimelineTrack::ZeroBetween2( REFTIME rtStart, REFTIME rtEnd )
{
    REFERENCE_TIME p1 = DoubleToRT( rtStart );
    REFERENCE_TIME p2 = DoubleToRT( rtEnd );
    HRESULT hr = ZeroBetween( p1, p2 );
    return hr;
}

// !!! if we whack the start of a source, we should whack the whole thing?

HRESULT CAMTimelineTrack::ZeroBetween
    ( REFERENCE_TIME Start, REFERENCE_TIME Stop )
{
    HRESULT hr = 0;

    // first make sure we can zero out stuff by slicing at the
    // beginning AND at the end! This will of course take longer than
    // simply adjusting the start and stop points of things that
    // cross the split boundaries, but this is simpler.
    //
    hr = SplitAt( Start );

    // S_FALSE means we can exit early, since there were no clips,
    // effects, or transitions past time = Start
    if( hr == S_FALSE )
    {
        return hr;
    }
    
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = SplitAt( Stop );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // !!! horrible way to enumerate sources! Fix this!
    
    // whack all sources between the times
    //
    REFERENCE_TIME t = 0;
    while( 1 )
    {
        REFERENCE_TIME oldt = t;
        CComPtr< IAMTimelineObj > p;
        HRESULT hr = GetNextSrc( &p, &t );
        if( ( hr != S_OK ) || ( oldt == t ) )
        {
            // no more sources, exit
            //
            break;
        }
        
        CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( p );

        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if lesser than our bounds, continue
        //
        if( e <= Start )
        {
            p.Release( );
            continue;
        }

        // if greater than our bounds, exit
        //
        if( s >= Stop )
        {
            p.Release( );
            break;
        }

        // it's GOT to be completely within bounds. Whack it.
        //
        IAMTimeline * pRoot = NULL; // okay not CComPtr
        GetTimelineNoRef( &pRoot );
        p->RemoveAll( ); // removing this effect will change priorities of everything.
        p.Release( );

    } // all sources

    // since this track starts at time 0, we don't need to mess with
    // the start/stop times when looking for effect start/stop times

    // remove all the effects. Since we split the track above, all the effects
    // will either be completely outside of or inside of the times we're looking
    // between. This makes things simpler
    //
    CComPtr< IAMTimelineObj > pEffect;
    long EffectCount;

loopeffects:

    EffectCount = 0;
    hr = EffectGetCount( &EffectCount );
    for( int i = 0 ; i < EffectCount ; i++ )
    {
        CComPtr< IAMTimelineObj > p;
        HRESULT hr = GetEffect( &p, i );
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if lesser than our bounds, continue
        //
        if( e <= Start )
        {
            p.Release( );
            continue;
        }

        // if greater than our bounds, exit
        //
        if( s >= Stop )
        {
            p.Release( );
            break;
        }

        p->RemoveAll( ); // removing this effect will change priorities of everything.
        p.Release( );

        goto loopeffects;
    }

    // remove all the effects. Since we split the track above, all the effects
    // will either be completely outside of or inside of the times we're looking
    // between. This makes things simpler
    //
    CComPtr< IAMTimelineObj > pTransition;
    REFERENCE_TIME TransTime = 0;

looptrans:

    while( 1 )
    {
        CComPtr< IAMTimelineObj > p;
        REFERENCE_TIME t = TransTime;
        HRESULT hr = GetNextTrans( &p, &TransTime );
        if( ( hr != NOERROR ) || ( t == TransTime ) )
        {
            break;
        }
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if lesser than our bounds, continue
        //
        if( e <= Start )
        {
            p.Release( );
            continue;
        }

        // if greater than our bounds, exit
        //
        if( s >= Stop )
        {
            p.Release( );
            break;
        }

        p->RemoveAll( ); // removing this effect will change priorities of everything.
        p.Release( );

        goto looptrans;
    }

    return NOERROR;
}

//############################################################################
// called externally, and from InsertSpace
//############################################################################

HRESULT CAMTimelineTrack::MoveEverythingBy2
    ( REFTIME StartTime, REFTIME Delta )
{
    REFERENCE_TIME p1 = DoubleToRT( StartTime );
    REFERENCE_TIME p2 = DoubleToRT( Delta );
    HRESULT hr = MoveEverythingBy( p1, p2 );
    return hr;
}

HRESULT CAMTimelineTrack::MoveEverythingBy
    ( REFERENCE_TIME StartTime, REFERENCE_TIME Delta )
{
    // if we don't have any kids, then nothin to do.
    //
    if( !XGetFirstKidNoRef( ) )
    {
        return NOERROR;
    }

    // what all can a track contain? Sources, FX, and Transitions, right?
    // move EVERYTHING after a given time. 

    REFERENCE_TIME t = StartTime;
    CComPtr< IAMTimelineObj > pFirstObj = XGetFirstKidNoRef( );

    bool MovedSomething = false;

    // go look for the first object at our time
    //
    while( pFirstObj )
    {
        // ask for the time
        //
        REFERENCE_TIME nStart, nStop;
        pFirstObj->GetStartStop( &nStart, &nStop );

        // if the time is over, then move it.
        //
        if( nStart >= StartTime )
        {
            nStart += Delta;
            nStop += Delta;
		// !!! see comment below
		// this will not work for people who create their OWN IAMTimelineObj,
		// but hypothetically, they can NEVER do this because the only way for them
		// to create one is by asking the timeline to CreateEmptyNode. So we 
		// shouldn't have to worry but sometimes people get a bit too clever for
		// their britches.
            CAMTimelineObj * pObj = static_cast< CAMTimelineObj * > ( (IAMTimelineObj*) pFirstObj );
            pObj->m_rtStart = nStart;
            pObj->m_rtStop = nStop;
            // do not call this, it will fault out.
//            pFirstObj->SetStartStop( nStart, nStop );
            MovedSomething = true;
        }

        // get the next thing
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pFirstNode( pFirstObj );
        pFirstObj.Release( );
        pFirstNode->XGetNext( &pFirstObj );
    }

    if( !MovedSomething )
    {
        return S_FALSE;
    }

    return NOERROR;
}

//############################################################################
// 
//############################################################################

STDMETHODIMP CAMTimelineTrack::SplitAt2( double dSplitTime )
{
    REFERENCE_TIME p1 = DoubleToRT( dSplitTime );
    HRESULT hr = SplitAt( p1 );
    return hr;
}

#if 1
// new version: faster, also returns S_FALSE if SplitTime is past everything on the track
STDMETHODIMP CAMTimelineTrack::SplitAt( REFERENCE_TIME SplitTime )
{
    HRESULT hr = S_FALSE;

    const long SPLITAT_TYPE = TIMELINE_MAJOR_TYPE_TRANSITION |
                              TIMELINE_MAJOR_TYPE_EFFECT |
                              TIMELINE_MAJOR_TYPE_SOURCE;
                              
    CComPtr< IAMTimelineObj > pChild;
    XGetNthKidOfType( SPLITAT_TYPE, 0, &pChild );

    while( pChild )
    {
        // get the source times
        //
        REFERENCE_TIME s,e;
        pChild->GetStartStop( &s, &e );

        // if the end time is less than our split time, it's completely
        // out of bounds, ignore it
        //
        if( e > SplitTime && s < SplitTime )
        {
            CComQIPtr< IAMTimelineSplittable, &IID_IAMTimelineSplittable > pSplittable( pChild );
            hr = pSplittable->SplitAt( SplitTime );

            if (FAILED(hr))
                break;
        }

        if( e > SplitTime )
            hr = S_OK; // S_FALSE return only if nothing reaches split time

        // get the next one
        //
        CComQIPtr< IAMTimelineNode, &IID_IAMTimelineNode > pChild2( pChild );
        pChild.Release( );
        pChild2->XGetNextOfType( SPLITAT_TYPE, &pChild );
    }

    return hr;
}

#else
STDMETHODIMP CAMTimelineTrack::SplitAt( REFERENCE_TIME SplitTime )
{
    HRESULT hr = 0;

    // Just find a source that's at the
    // right time, and you're done looking. Split it and move on.

    // run all our sources and split what we need to
    //
    REFERENCE_TIME t = 0;
    while( 1 )
    {
        REFERENCE_TIME oldt = t;
        CComPtr< IAMTimelineObj > p;
        HRESULT hr = GetNextSrc( &p, &t );
        if( ( hr != S_OK ) || ( oldt == t ) )
        {
            // no more sources, exit
            //
            break;
        }
        
        CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSource( p );

        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if the end time is less than our split time, it's completely
        // out of bounds, ignore it
        //
        if( e <= SplitTime )
        {
            p.Release( );
            continue;
        }

        // if it's start time is equal to or greater than our split time,
        // it's completely out of bounds, ignore it. Plus, we're done searching.
        //
        if( s >= SplitTime )
        {
            p.Release( );
            break;
        }

        CComQIPtr< IAMTimelineSplittable, &IID_IAMTimelineSplittable > pSplittable( p );
        hr = pSplittable->SplitAt( SplitTime );

    } // split all sources which need splittin'

    // split all the effects. 
    //
    CComPtr< IAMTimelineObj > pEffect;
    long EffectCount = 0;
    hr = EffectGetCount( &EffectCount );
    for( int i = 0 ; i < EffectCount ; i++ )
    {
        CComPtr< IAMTimelineObj > p;
        HRESULT hr = GetEffect( &p, i );
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if the end time is less than our split time, it's completely
        // out of bounds, ignore it
        //
        if( e <= SplitTime )
        {
            p.Release( );
            continue;
        }

        // if it's start time is equal to or greater than our split time,
        // it's completely out of bounds, ignore it. Plus, we're done searching.
        //
        if( s >= SplitTime )
        {
            p.Release( );
            break;
        }

        CComQIPtr< IAMTimelineSplittable, &IID_IAMTimelineSplittable > pSplittable( p );
        hr = pSplittable->SplitAt( SplitTime );
        break; // found one to split, we're done
    }

    CComPtr< IAMTimelineObj > pTransition;
    REFERENCE_TIME TransTime = 0;

    while( 1 )
    {
        CComPtr< IAMTimelineObj > p;
        REFERENCE_TIME t = TransTime;
        HRESULT hr = GetNextTrans( &p, &TransTime );
        if( ( hr != NOERROR ) || ( t == TransTime ) )
        {
            break;
        }
        
        REFERENCE_TIME s,e;
        p->GetStartStop( &s, &e );

        // if the end time is less than our split time, it's completely
        // out of bounds, ignore it
        //
        if( e <= SplitTime )
        {
            p.Release( );
            continue;
        }

        // if it's start time is equal to or greater than our split time,
        // it's completely out of bounds, ignore it. Plus, we're done searching.
        //
        if( s >= SplitTime )
        {
            p.Release( );
            break;
        }

        CComQIPtr< IAMTimelineSplittable, &IID_IAMTimelineSplittable > pSplittable( p );
        hr = pSplittable->SplitAt( SplitTime );
        break; // found one to split, we're done
    }

    return hr;
}
#endif

STDMETHODIMP CAMTimelineTrack::SetStartStop(REFERENCE_TIME Start, REFERENCE_TIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}

STDMETHODIMP CAMTimelineTrack::SetStartStop2(REFTIME Start, REFTIME Stop)
{
    return E_NOTIMPL; // okay, we don't implement SetStartStop here
}

#if 0
//############################################################################
// Cut a clip that's on a timeline into two chunks. This doesn't deal with
// if you're cutting video and want to cut audio at the same point.
//############################################################################

// !!! what about fx applied to source?

STDMETHODIMP CAMTimelineTrack::SrcSplit2(
    IAMTimelineObj * pSrcToSplitObj, 
    IAMTimelineObj ** ppSrcReturned, 
    REFTIME TLTimeToSplitAt
    )
{
    REFERENCE_TIME p1 = DoubleToRT( TLTimeToSplitAt );
    HRESULT hr = SrcSplit( pSrcToSplitObj, ppSrcReturned, p1 );
    return hr;
}

STDMETHODIMP CAMTimelineTrack::SrcSplit(
    IAMTimelineObj * pSrcToSplitObj, 
    IAMTimelineObj ** ppSrcReturned, 
    REFERENCE_TIME TLTimeToSplitAt
    )
{
    // !!! if this object has a sub-object, we'll need to make a copy of it 
    // for the new one. This probably won't work for some sources(?)

    CComQIPtr< IAMTimelineSrc, &IID_IAMTimelineSrc > pSrcToSplit( pSrcToSplitObj );
    if( !pSrcToSplit )
    {
        return E_NOINTERFACE;
    }

    // create the shell
    //
    HRESULT hr = 0;
    CAMTimelineSrc * pNewSrc = new CAMTimelineSrc( NAME("Timeline Source"), NULL, &hr );
    if( !pNewSrc )
    {
        return E_OUTOFMEMORY;
    }

    // we have created an object that has NO references on it. If we call ANYTHING that
    // addreffs and releases the pNewSrc, it will be deleted. So addref it NOW.

    pNewSrc->AddRef( );

    // copy the base data from the original source
    //
    hr = ((CAMTimelineObj *) pSrcToSplitObj)->CopyDataTo( pNewSrc, TLTimeToSplitAt );
    if( FAILED( hr ) )
    {
        delete pNewSrc;
        return hr;
    }

    REFERENCE_TIME MediaStart, MediaStop;
    pSrcToSplit->GetMediaTimes( &MediaStart, &MediaStop );

    REFERENCE_TIME Start, Stop;
    pSrcToSplitObj->GetStartStop( &Start, &Stop );

    double dMediaRate = (double) (MediaStop - MediaStart) / (Stop - Start);

    pNewSrc->m_rtStart = TLTimeToSplitAt;
    pNewSrc->m_rtStop = Stop;
    // first clip end = new timeline time of first clip * rate
    pNewSrc->m_rtMediaStart = MediaStart + (REFERENCE_TIME)((TLTimeToSplitAt - Start) * dMediaRate);
    // second clip starts where first ends
    pNewSrc->m_rtMediaStop = MediaStop;

    // chop off this's stop time. Call the Src's method to do checking for us.
    //
    pSrcToSplitObj->SetStartStop( Start, pNewSrc->m_rtStart );

    // figure new media times
    //
    pSrcToSplit->SetMediaTimes( MediaStart, pNewSrc->m_rtMediaStart );

    CComBSTR Name;
    pSrcToSplit->GetMediaName( &Name );
    pNewSrc->SetMediaName( Name );

    hr = XInsertKidAfterKid( pNewSrc, pSrcToSplitObj );

    *ppSrcReturned = pNewSrc;

    return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\util\conv.cxx ===
LONGLONG inline Time2Frame( REFERENCE_TIME rt, double FPS )
{
    ASSERT( FPS );
    if (rt >= 0) {
        return LONGLONG( double( rt + 1 ) * FPS / double( UNITS ) );
    } else {
        return LONGLONG( double( rt - 1 ) * FPS / double( UNITS ) );
    }
}

REFERENCE_TIME inline Frame2Time( LONGLONG Frame, double FPS )
{
    ASSERT( FPS );
    
    double dt = (Frame * UNITS / FPS );

    // ftol rounds towards 0, and we want to round to nearest.
    if(Frame >= 0) {
        dt += 0.5;
    } else {
        dt -= 0.5;              // we do see -ve numbers for some reason
    }

    return (REFERENCE_TIME)dt;
}

LONGLONG inline RoundTime2Frame( REFERENCE_TIME rt, double FPS )
{
    ASSERT( FPS );
    double d = double( rt ) * FPS / double( UNITS ) + 0.5;
    LONGLONG l = (LONGLONG)d;
    return l;
}

LONGLONG inline RoundUpTime2Frame( REFERENCE_TIME rt, double FPS )
{
    ASSERT( FPS );
    double d;
    // rt might be rounded too high, since we're rounding up, subtract 1
    d = double(rt  - 1) * FPS / double( UNITS );
    long l = long( d );
    if( double( l ) < d )
    {
        l++;
    }
    return l;
}

REFERENCE_TIME inline DoubleToRT( double d )
{
    REFERENCE_TIME rt = REFERENCE_TIME( d * double( UNITS ) + 0.5 );
    return rt;
}

double inline RTtoDouble( REFERENCE_TIME rt )
{
    double d = double( rt ) / double( UNITS );
    return d;
}

inline REFERENCE_TIME SkewTimelineStart( STARTSTOPSKEW * pSkew )
{
    return pSkew->rtStart + pSkew->rtSkew;
}

inline REFERENCE_TIME SkewTimelineStop( STARTSTOPSKEW * pSkew )
{
    return pSkew->rtStart + pSkew->rtSkew + 
        REFERENCE_TIME( ( pSkew->rtStop - pSkew->rtStart ) / pSkew->dRate );
}

inline bool AreTimesAndRateReallyClose( 
                         REFERENCE_TIME TLStopLast,
                         REFERENCE_TIME TLStartNext,
                         REFERENCE_TIME MediaStopLast,
                         REFERENCE_TIME MediaStartNext,
                         double Rate1,
                         double Rate2,
                         double TimelineFPS )
{
    // must be REALLY close!
    //
    if( ( TLStartNext - TLStopLast > 10 ) || ( TLStopLast - TLStartNext > 10 ) )
    {
        return false;
    }

    // the media times can be off by a frame's worth, or we don't combine
    //
    ASSERT( TimelineFPS != 0.0 );
    if( TimelineFPS == 0.0 ) TimelineFPS = 15.0; // don't allow a 0, if it occurs
    REFERENCE_TIME FudgeFactor = REFERENCE_TIME( UNITS / TimelineFPS );
    if( ( MediaStartNext - MediaStopLast >= FudgeFactor ) || ( MediaStopLast - MediaStartNext >= FudgeFactor ) )
    {
        return false;
    }

    if( Rate1 == 0.0 || Rate2 == 0.0 )
    {
        return true;
    }

    // rates must match to 1/10th of a percent
    long p = abs( long( ( Rate2 - Rate1 ) * 1000 / Rate2 ) );
    if( p > 1 )
    {
        return false;
    }

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\util\perf_defs.h ===
//#define CHANGE_THREAD_PRIORITIES // comment OUT for "having the fix"
#define LATE_FIX
#define COMBINE_SAME_SOURCES
//#define SMOOTH_FADEOFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\resource.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDR_XML2DEX                     198

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\util\wmkeystuff.h ===
#pragma once

#include <..\..\..\filters\asf\wmsdk\inc\wmsdkidl.h>

typedef HRESULT STDAPICALLTYPE WMCREATEKEYPROC(BYTE *, DWORD, LPUNKNOWN *);

// note: this object is a SEMI-COM object, and can only be created statically.
class CKeyProvider : public IServiceProvider {
public:
    STDMETHODIMP_(ULONG) AddRef() { return 2; }
    STDMETHODIMP_(ULONG) Release() { return 1; }

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == IID_IServiceProvider || riid == IID_IUnknown) {
            *ppv = (void *) static_cast<IServiceProvider *>(this);
            return NOERROR;
        }    
        return E_NOINTERFACE;
    }


    STDMETHODIMP QueryService(REFIID siid, REFIID riid, void **ppv)
    {
        if (siid == __uuidof(IWMReader) && riid == IID_IUnknown) {

            IUnknown *punkCert;

            HRESULT hr = WMCreateCertificate( &punkCert );
            if (SUCCEEDED(hr)) {
                *ppv = (void *) punkCert;
            }
            return hr;
        }
        return E_NOINTERFACE;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\varyprop.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.

#define US_LCID MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT)

HRESULT VarChngTypeHelper(
    VARIANT * pvarDest, VARIANT * pvarSrc, VARTYPE vt)
{
    // our implementation doesn't handle this case and is not
    // currently used that way.
    ASSERT(pvarDest != pvarSrc);
    ASSERT(pvarDest->vt == VT_EMPTY); 
    
    // force US_LCID so that .xtl parsing is independent of different
    // numerical separators in different locales (?)
    // 
    HRESULT hr = VariantChangeTypeEx(pvarDest, pvarSrc, US_LCID, 0, vt);
    if(SUCCEEDED(hr)) {
        return hr;
    }

    // we need to parse hex strings. The NT VCTE() implementation does
    // not, but the WinME one does.
    if(vt == VT_R8 && pvarSrc->vt == VT_BSTR)
    {
        // wcstoul can be used even if not implemented on win9x
        // because we only care about NT if we got here.
        //
        WCHAR *pchLast;
        ULONG ulHexVal = wcstoul(pvarSrc->bstrVal, &pchLast, 16);
        // ulHexVal might be 0 or 0xffffffff on failure or success. We
        // can't test the global errno to determine what happened
        // because it's not thread safe. But we should have ended up
        // at the null terminator if the whole string was parsed; that
        // should catch some errors at least.

        if(*pchLast == 0 && lstrlenW(pvarSrc->bstrVal) <= 10)
        {
            pvarDest->vt = VT_R8;
            V_R8(pvarDest) = ulHexVal;
            hr = S_OK;
        }
        else
        {
            hr = DISP_E_TYPEMISMATCH;
        }
    }

    return hr;
}

// call SetProps(-1) to set static props
// call SetProps(t), t>0 to set dynamic props (won't resend the prop at time 0)
//
HRESULT CPropertySetter::SetProps(IUnknown *punkTarget, REFERENCE_TIME rtNow)
{

    HRESULT hr = S_OK;

    // there are no props
    if (m_pLastParam == NULL)
        return S_OK;

    IDispatch *pTarget;
    hr = punkTarget->QueryInterface(IID_IDispatch, (void **) &pTarget);
    if (FAILED(hr))
        return hr;
    
    QPropertyParam *pParams = &params;
    
    while (pParams) {
        QPropertyValue *pVal = &pParams->val;

	{
	    if (rtNow != -1) {
	        // if we aren't setting static props skip a single value at
		// time 0
	        if (pVal->rt == 0 && pVal->pNext == NULL)
		    goto next;

                while (pVal->pNext && pVal->pNext->rt < rtNow) {
                    pVal = pVal->pNext;
                }

	        // there are no properties yet
	        if (pVal->rt > rtNow)
		    goto next;


	    // we are being told to only set the first prop if it is time 0
	    } else {
	        if (pVal->rt > 0)
		    goto next;
	    }

            if (!pParams->dispID) {
                hr = pTarget->GetIDsOfNames(IID_IDispatch,
					&pParams->bstrPropName, 1,
                                        LOCALE_USER_DEFAULT, &pParams->dispID);
		if (FAILED(hr)) {
		    VARIANT var;
		    VariantInit(&var);
		    var.vt = VT_BSTR;
		    var.bstrVal = pParams->bstrPropName;
                    _GenerateError( 2, L"No such property exists on an object", DEX_IDS_NO_SUCH_PROPERTY, E_INVALIDARG, &var );
		    break;
		}
	    }

            VARIANT v;
            VariantInit(&v);

	    // try to make it a real, if we can.  Otherwise, leave it alone
            hr = VarChngTypeHelper(&v, &pVal->v, VT_R8);
            if( hr != S_OK)
            {
		hr = VariantCopy( &v, &pVal->v );
                ASSERT(hr == S_OK);
            }

            if (rtNow != -1 && pVal->pNext &&
				pVal->pNext->dwInterp == DEXTERF_INTERPOLATE) {
                VARIANT v2;
                VariantInit(&v2);

                hr = VarChngTypeHelper(&v2, &pVal->pNext->v, VT_R8);
		if (hr != S_OK || V_VT(&v) != VT_R8) {
                    _GenerateError( 2, L"Illegal value for a property", DEX_IDS_ILLEGAL_PROPERTY_VAL, E_INVALIDARG, NULL );
		    break;
		}
                
                double d = (double)(rtNow - pVal->rt) / (pVal->pNext->rt - pVal->rt);
		ASSERT(V_VT(&v) == VT_R8);
 		ASSERT(V_VT(&v2) == VT_R8);
                V_R8(&v) = (V_R8(&v) * (1-d) + V_R8(&v2) * d);
            }

            DbgLog((LOG_TRACE,3,TEXT("CALLING INVOKE")));
            DbgLog((LOG_TRACE,3,TEXT("time = %d ms  pval->rt = %d ms  val = %d")
                    		, (int)(rtNow / 10000), (int)(pVal->rt / 10000)
				, (int)(V_R8(&v) * 100)));
            
            DISPID dispidNamed = DISPID_PROPERTYPUT;
            DISPPARAMS disp;
            disp.cNamedArgs = 1;
            disp.cArgs = 1;
            disp.rgdispidNamedArgs = &dispidNamed;
            disp.rgvarg = &v;
            VARIANT result;
            VariantInit(&result);
            
            hr = pTarget->Invoke(pParams->dispID,
                                 IID_NULL,
                                 LOCALE_USER_DEFAULT,
                                 DISPATCH_PROPERTYPUT,
                                 &disp,
                                 &result,
                                 NULL,
                                 NULL);

            if (FAILED(hr)) {
                _GenerateError( 2, L"Illegal value for a property", DEX_IDS_ILLEGAL_PROPERTY_VAL, E_INVALIDARG, NULL );
                break;
	    }
	}

next:
        pParams = pParams->pNext;
    }

    pTarget->Release();
    
    return hr;
}


CUnknown * WINAPI CreatePropertySetterInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CPropertySetter(pUnk);
}

extern bool IsCommentElement(IXMLDOMNode *p);

HRESULT CPropertySetter::LoadOneProperty(IXMLDOMElement *p, QPropertyParam *pParam)
{
    HRESULT hr = S_OK;

    QPropertyValue *pLastValue = &pParam->val;

    CComQIPtr<IXMLDOMNode, &IID_IXMLDOMNode> pNode( p );

    IXMLDOMNodeList *pcoll;
    hr = pNode->get_childNodes(&pcoll);

    if (hr != S_OK)
	return S_FALSE; // nothing to do

    bool fLoadedProperty = false;
    
    long lChildren = 0;
    hr = pcoll->get_length(&lChildren);

    int lVal = 0;                    
    
    for (; lVal < lChildren && SUCCEEDED(hr); lVal++) {
	IXMLDOMNode *pNode;
	hr = pcoll->get_item(lVal, &pNode);

	if (SUCCEEDED(hr) && pNode) {
	    IXMLDOMElement *pelem;
	    hr = pNode->QueryInterface(__uuidof(IXMLDOMElement), (void **) &pelem);

	    if (SUCCEEDED(hr)) {
		BSTR bstrTag;
		hr = pelem->get_tagName(&bstrTag);

		if (SUCCEEDED(hr)) {
		    if (!DexCompareW(bstrTag, L"at") || !DexCompareW(bstrTag, L"linear")) { // tagg
                        BSTR bstrValue = FindAttribute(pelem, L"value"); // tagg
			REFERENCE_TIME rtTime = ReadTimeAttribute(pelem, L"time", -1); // tagg

			// times MUST be pre-sorted in the value list
			if (pLastValue->rt >= rtTime) {
			    // !!! LOG A MORE USEFUL ERROR?
			    hr = E_INVALIDARG;
			}

                        ASSERT(pLastValue);
			if (SUCCEEDED(hr)) {
                            QPropertyValue *pValue = new QPropertyValue;
                            if (!pValue) {
                                hr = E_OUTOFMEMORY;
                            } else {
                                pLastValue->pNext = pValue;
                                pLastValue = pValue;
                                fLoadedProperty = true;
                            }
			}

                        if (SUCCEEDED(hr)) {
                            pLastValue->dwInterp =
				(!DexCompareW(bstrTag, L"at")) ? DEXTERF_JUMP // tagg
				: DEXTERF_INTERPOLATE;
                            pLastValue->rt = rtTime;
                            V_VT(&pLastValue->v) = VT_BSTR;
                            V_BSTR(&pLastValue->v) = bstrValue;
                        } else {
                            // if we didn't succeed, kill the string
                            if (bstrValue) {
                                SysFreeString(bstrValue);
                            }
                        }
		    } else {
			// !!! unknown other subtag?

		    }
		    SysFreeString(bstrTag);
                    
		} // get_tagName succeded
                
		pelem->Release();
	    } else {
                if(IsCommentElement(pNode))
                {
                    // don't error on comments.
                    hr = S_OK;
                }
            }
	    pNode->Release();
	}
    }

    pcoll->Release();

    // return S_FALSE to indicate there were no properties.
    if(hr == S_OK) {
        return fLoadedProperty ? S_OK : S_FALSE;
    } else {
        return hr;
    }
}


HRESULT CPropertySetter::LoadFromXML(IXMLDOMElement *p)
{
    CheckPointer(p, E_POINTER);
    HRESULT hr = S_OK;

    IXMLDOMNodeList *pcoll;
    hr = p->get_childNodes(&pcoll);

    if (hr != S_OK)
	return S_FALSE; // nothing to do
    
    bool fLoadedProperty = false;
    
    long lChildren = 0;
    hr = pcoll->get_length(&lChildren);

    int lVal = 0;                    
    
    for (SUCCEEDED(hr); lVal < lChildren; lVal++) {
	IXMLDOMNode *pNode;
	hr = pcoll->get_item(lVal, &pNode);

	if (SUCCEEDED(hr) && pNode) {
	    IXMLDOMElement *pelem;
	    hr = pNode->QueryInterface(__uuidof(IXMLDOMElement), (void **) &pelem);

	    if (SUCCEEDED(hr)) {
		BSTR bstrTag;
		hr = pelem->get_tagName(&bstrTag);

		if (SUCCEEDED(hr)) {
		    if (!DexCompareW(bstrTag, L"param")) { // tagg
			BSTR bstrName = FindAttribute(pelem, L"name"); // tagg

			if (bstrName) {
			    BSTR bstrValue = FindAttribute(pelem, L"value"); // tagg

			    if (!bstrValue) {
				HRESULT hr2 = pelem->get_text(&bstrValue);
			    }

                            if (m_pLastParam) {
                                QPropertyParam *pParam = new QPropertyParam;
                                if (!pParam)
                                    hr = E_OUTOFMEMORY;
                                else {
                                    m_pLastParam->pNext = pParam;
                                    m_pLastParam = pParam;
                                    fLoadedProperty = true;
                                }
                            } else {
                                m_pLastParam = &params;
                                fLoadedProperty = true;
                            }

                            if (SUCCEEDED(hr)) {
                                m_pLastParam->bstrPropName = bstrName;
                            } else {
                                SysFreeString(bstrName);
                            }

                            
			    if (bstrValue) {
                                if (SUCCEEDED(hr)) {
                                    V_BSTR(&m_pLastParam->val.v) = bstrValue;
                                    V_VT(&m_pLastParam->val.v) = VT_BSTR;

                                    // now get sub-tags!
                                    hr = LoadOneProperty(pelem, m_pLastParam);
                                    // it's OK if there are none
                                    if (hr == S_FALSE)
                                        hr = S_OK;
                    
                                } else {
                                    SysFreeString(bstrValue);
                                }
			    }
			} else {
			    hr = VFW_E_INVALID_FILE_FORMAT;
			}

		    } else {
			// !!! unknown other subtag?

		    }

		    SysFreeString(bstrTag);
                    
		} // get_tagName succeeded
                
		pelem->Release();
	    } else {
                if(IsCommentElement(pNode))
                {
                    // don't error on comments.
                    hr = S_OK;
                }
            }
	    pNode->Release();
	}
    }

    pcoll->Release();
    
    // return S_FALSE to indicate there were no properties.
    if(hr == S_OK) {
        return fLoadedProperty ? S_OK : S_FALSE;
    } else {
        return hr;
    }
}


HRESULT CreatePropertySetterInstanceFromXML(IPropertySetter ** ppSetter, IXMLDOMElement *pxml)
{
    CPropertySetter *pSetter = new CPropertySetter(NULL);
    if (!pSetter)
        return E_OUTOFMEMORY;

    pSetter->AddRef();

    HRESULT hr = pSetter->LoadFromXML(pxml);

    // S_FALSE here means there weren't any properties, so throw the object away.
    if (hr != S_OK) {
        pSetter->Release();
        *ppSetter = NULL;
    } else {
        *ppSetter = pSetter;
    }

    return hr;
}


HRESULT CPropertySetter::SaveToXMLA(char *&pOut, int cchOut, int iIndent)
{
    // <param name=" " value="...">
    //          <at time="..." value="..."/>
    //          <linear time="..." value="..."/>
    QPropertyParam *pParams = &params;
    char *pEnd = pOut + cchOut;
    
    while (pParams) {
        QPropertyValue *pVal = &pParams->val;

        PrintIndentA(pOut, iIndent);

	// it may not have been programmed as a BSTR - make it one to save it
	VARIANT v2;
	VariantInit(&v2);
        HRESULT hr = VariantChangeTypeEx(&v2, &pVal->v, US_LCID, 0, VT_BSTR);
	if (FAILED(hr)) {
	    ASSERT(FALSE);	// huh?
	    return hr;
	}

	if (pEnd < (pOut + 50 + lstrlenW(pParams->bstrPropName) * sizeof(WCHAR)
                        + lstrlenW(V_BSTR(&v2)) * sizeof(WCHAR)))
	    return E_OUTOFMEMORY;
	
        pOut += wsprintfA(pOut, "<param name=\"%ls\" value=\"%ls\"", // tagg
				pParams->bstrPropName,
                        	V_BSTR(&v2));
	VariantClear(&v2);

        if (pVal->pNext) {
            pOut += wsprintfA(pOut, ">\r\n");
            
            while (pVal->pNext) {
                pVal = pVal->pNext;

                // it may not have been programmed as a BSTR
                VARIANT v2;
                VariantInit(&v2);
                hr = VariantChangeTypeEx(&v2, &pVal->v, US_LCID, 0, VT_BSTR);
                if (FAILED(hr)) {
                    ASSERT(FALSE);	// huh?
                    return hr;
                }

		if (pEnd < (pOut + 50 + lstrlenW(V_BSTR(&v2)) + sizeof(WCHAR)))
		    return E_OUTOFMEMORY;

                if (pVal->dwInterp == DEXTERF_JUMP) {
                    PrintIndentA(pOut, iIndent + 1);
                    pOut += wsprintfA(pOut, "<at time=\""); // tagg
                    PrintTimeA(pOut, pVal->rt);
                    pOut += wsprintfA(pOut, "\" value=\"%ls\"/>\r\n", V_BSTR(&v2)); // tagg
                } else if (pVal->dwInterp == DEXTERF_INTERPOLATE) {
                    PrintIndentA(pOut, iIndent + 1);
                    pOut += wsprintfA(pOut, "<linear time=\""); // tagg
                    PrintTimeA(pOut, pVal->rt);
                    pOut += wsprintfA(pOut, "\" value=\"%ls\"/>\r\n", V_BSTR(&v2)); // tagg
                }
                VariantClear(&v2);
            }

            PrintIndentA(pOut, iIndent);
            pOut += wsprintfA(pOut, "</param>\r\n"); // tagg
        } else {
            // no children, just end tag
            pOut += wsprintfA(pOut, "/>\r\n");
        }

        pParams = pParams->pNext;
    }

    return S_OK;
}


HRESULT CPropertySetter::SaveToXMLW(WCHAR *&pOut, int cchOut, int iIndent)
{
    // <param name=" " value="...">
    //          <at time="..." value="..."/>
    //          <linear time="..." value="..."/>
    QPropertyParam *pParams = &params;
    WCHAR *pEnd = pOut + cchOut;
    
    while (pParams) {
        QPropertyValue *pVal = &pParams->val;

        PrintIndentW(pOut, iIndent);

	// it may not have been programmed as a BSTR - make it one to save it
	VARIANT v2;
	VariantInit(&v2);
        HRESULT hr = VariantChangeTypeEx(&v2, &pVal->v, US_LCID, 0, VT_BSTR);
	if (FAILED(hr)) {
	    ASSERT(FALSE);	// huh?
	    return hr;
	}

	if (pEnd < (pOut + 50 + lstrlenW(pParams->bstrPropName) + lstrlenW(V_BSTR(&v2))))
	    return E_OUTOFMEMORY;
	
        pOut += wsprintfW(pOut, L"<param name=\"%ls\" value=\"%ls\"", // tagg
				pParams->bstrPropName,
                        	V_BSTR(&v2));
	VariantClear(&v2);

        if (pVal->pNext) {
            pOut += wsprintfW(pOut, L">\r\n");
            
            while (pVal->pNext) {
                pVal = pVal->pNext;

                // it may not have been programmed as a BSTR
                VARIANT v2;
                VariantInit(&v2);
                hr = VariantChangeTypeEx(&v2, &pVal->v, US_LCID, 0, VT_BSTR);
                if (FAILED(hr)) {
                    ASSERT(FALSE);	// huh?
                    return hr;
                }

		if (pEnd < (pOut + 50 + lstrlenW(V_BSTR(&v2))))
		    return E_OUTOFMEMORY;

                if (pVal->dwInterp == DEXTERF_JUMP) {
                    PrintIndentW(pOut, iIndent + 1);
                    pOut += wsprintfW(pOut, L"<at time=\""); // tagg
                    PrintTimeW(pOut, pVal->rt);
                    pOut += wsprintfW(pOut, L"\" value=\"%ls\"/>\r\n", V_BSTR(&v2)); // tagg
                } else if (pVal->dwInterp == DEXTERF_INTERPOLATE) {
                    PrintIndentW(pOut, iIndent + 1);
                    pOut += wsprintfW(pOut, L"<linear time=\""); // tagg
                    PrintTimeW(pOut, pVal->rt);
                    pOut += wsprintfW(pOut, L"\" value=\"%ls\"/>\r\n", V_BSTR(&v2)); // tagg
                }
                VariantClear(&v2);
            }

            PrintIndentW(pOut, iIndent);
            pOut += wsprintfW(pOut, L"</param>\r\n"); // tagg
        } else {
            // no children, just end tag
            pOut += wsprintfW(pOut, L"/>\r\n");
        }

        pParams = pParams->pNext;
    }

    return S_OK;
}


STDMETHODIMP CPropertySetter::LoadXML(IUnknown * pxml)
{
    return LoadFromXML((IXMLDOMElement *)pxml);
}



STDMETHODIMP CPropertySetter::PrintXML(char *pszXML, int cbXML, int *pcbPrinted, int indent)
{
    char *psz = pszXML;

    if (!psz)
	return E_POINTER;

    HRESULT hr = SaveToXMLA(psz, cbXML, indent);

    if (pcbPrinted)
	*pcbPrinted = (int)(INT_PTR)(psz - pszXML);

    return hr;
}


STDMETHODIMP CPropertySetter::PrintXMLW(WCHAR *pszXML, int cchXML, int *pcchPrinted, int indent)
{
    WCHAR *psz = pszXML;

    if (!psz)
	return E_POINTER;

    HRESULT hr = SaveToXMLW(psz, cchXML, indent);

    if (pcchPrinted)
	*pcchPrinted = (int)(INT_PTR)(psz - pszXML);

    return hr;
}


// When cloning, it only copies properties stamped between the times given.
// And the new set will be zero based.
// !!! Doesn't split PROGRESS since it isn't in here!
// !!! This could all be much simpler by just changing the times on the 
// existing properties, if static props wouldn't break by doing that
//
STDMETHODIMP CPropertySetter::CloneProps(IPropertySetter **ppSetter, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop)
{
    DbgLog((LOG_TRACE,2,TEXT("CPropSet:CloneProps - %d"),
				(int)(rtStart / 10000)));
    CheckPointer(ppSetter, E_POINTER);

    if (rtStart < 0)
	return E_INVALIDARG;

    // !!! I have to ignore the stop, or it gets complicated

    CPropertySetter *pNew = new CPropertySetter(NULL);
    if (pNew == NULL)
	return E_OUTOFMEMORY;
    pNew->AddRef();

    DEXTER_PARAM *pP;
    DEXTER_VALUE *pV;
    LONG c;
    HRESULT hr = GetProps(&c, &pP, &pV);
    if (FAILED(hr)) {
	pNew->Release();
	return hr;
    }

    LONG val=0;
    // walk through all the parameters that have (dynamic) values
    for (int z=0; z<c; z++) {
        DEXTER_VALUE *pVNew = NULL;
	int nNew = 0;

	// walk through each value
        for (int y=val; y < val+pP[z].nValues; y++) {

	    // first time through, make space for copying just the values we
	    // are interested in (plus one for the initial value)
	    if (pVNew == NULL) {
		pVNew = new DEXTER_VALUE[pP[z].nValues + 1];
		if (pVNew == NULL)
		    goto CloneError;
	    }

	    // we only copy properties that start at or after our split time
	    if (pV[y].rt >= rtStart) {
    		DbgLog((LOG_TRACE,2,TEXT("found time %d"),
						(int)(pV[y].rt / 10000)));

	        // If there isn't a property value right on the split time,
	        // construct what the initial value for this parameter should be
		if (nNew == 0 && pV[y].rt > rtStart) {
		    ASSERT(y>0);
                    VariantInit(&pVNew[nNew].v);
		    if (pV[y].dwInterp == DEXTERF_JUMP) {
			// It's just the last value before this time
			hr = VariantCopy(&pVNew[nNew].v, &pV[y-1].v);
    			DbgLog((LOG_TRACE,2,TEXT("START WITH JUMP")));
			ASSERT(SUCCEEDED(hr));
		    } else if (pV[y].dwInterp == DEXTERF_INTERPOLATE) {
			// Figure out what the value would be by doing the
			// interpolate between the last value and split time.
    			DbgLog((LOG_TRACE,2,TEXT("START WITH INTERP")));
                	VARIANT v2, v;
                	VariantInit(&v2);
                	VariantInit(&v);
                        // okay to change to float, since we're interpolating
            		hr = VariantChangeTypeEx(&v, &pV[y-1].v, US_LCID, 0, VT_R8);
			ASSERT(SUCCEEDED(hr));
                	hr = VariantChangeTypeEx(&v2, &pV[y].v, US_LCID, 0, VT_R8);
			ASSERT(SUCCEEDED(hr));
                	double d = (double)(rtStart - pV[y-1].rt) /
						(pV[y].rt - pV[y-1].rt);
                	V_R8(&v) = (V_R8(&v) * (1-d) + V_R8(&v2) * d);
    			DbgLog((LOG_TRACE,2,TEXT("interp val=%d"),
					(int)(V_R8(&v))));
			hr = VariantCopy(&pVNew[nNew].v, &v);
			ASSERT(SUCCEEDED(hr));
			VariantClear(&v);
			VariantClear(&v2);
		    } else {
			ASSERT(FALSE);
			// Ooh! Imagine how much fun spline code would be!
		    }	
		    // The first value is always a jump at time 0
		    pVNew[nNew].rt = 0;
		    pVNew[nNew].dwInterp = DEXTERF_JUMP;
		    nNew++;
		}

		// Now copy the value over to our new list of values, offset in
		// time by the split time
                VariantInit(&pVNew[nNew].v);
		hr = VariantCopy(&pVNew[nNew].v, &pV[y].v);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr)) {
	    	    for (y=0; y<nNew; y++)
			VariantClear(&pVNew[y].v);
	    	    delete [] pVNew;
		    goto CloneError;
		}
		pVNew[nNew].rt = pV[y].rt - rtStart;
		// The first value is always a jump, otherwise it stays the same
		if (nNew == 0)
		    pVNew[nNew].dwInterp = DEXTERF_JUMP;
		else
		    pVNew[nNew].dwInterp = pV[y].dwInterp;
    		DbgLog((LOG_TRACE,2,TEXT("next is now at time %d"),
					(int)(pVNew[nNew].rt / 10000)));
		
	        nNew++;
	    }
	}

	if (nNew) {
	    // Add the new values we constructed to the new property setter
            int n = pP[z].nValues;
            pP[z].nValues = nNew;  // temporarily change this, we're adding nNew
	    hr = pNew->AddProp(pP[z], pVNew);
            pP[z].nValues = n;
	    ASSERT(SUCCEEDED(hr));
	    for (y=0; y<nNew; y++)
		VariantClear(&pVNew[y].v);
	    delete [] pVNew;
	    if (FAILED(hr)) {
	        goto CloneError;
	    }

	// There are no values set after the split time.  Use the most recent
	// value before the split time as the new static value
	} else if (pP[z].nValues) {
	    y = val + pP[z].nValues - 1;
            VariantInit(&pVNew[0].v);
	    hr = VariantCopy(&pVNew[0].v, &pV[y].v);
	    ASSERT(SUCCEEDED(hr));
	    if (SUCCEEDED(hr)) {
		DbgLog((LOG_TRACE,2,TEXT("Using last value")));
	        pVNew[0].rt = 0;
	        pVNew[0].dwInterp = DEXTERF_JUMP;
                int n = pP[z].nValues;
                pP[z].nValues = 1;  // temporarily change this, we're adding 1
	        hr = pNew->AddProp(pP[z], pVNew);
                pP[z].nValues = n;
	        ASSERT(SUCCEEDED(hr));
	        VariantClear(&pVNew[0].v);
	    }
	    delete [] pVNew;
	    if (FAILED(hr)) {
	        goto CloneError;
	    }
	}
	val += pP[z].nValues;
    }

    FreeProps(c, pP, pV);
    *ppSetter = pNew;
    return S_OK;

CloneError:
    FreeProps(c, pP, pV);
    pNew->ClearProps();
    pNew->Release();
    return hr;
}


// !!! allow them to set/clear individual values of a parameter?
//
STDMETHODIMP CPropertySetter::AddProp(DEXTER_PARAM Param, DEXTER_VALUE *paValue)
{
    HRESULT hr;
    CheckPointer(paValue, E_POINTER);

    if (Param.nValues <= 0)
	return E_INVALIDARG;

    // !!! better error?
    // first value must be 0
    if (paValue[0].rt != 0)
	return E_INVALIDARG;

    // caller must provide values pre-sorted!
    if (Param.nValues > 1) {
        for (int z=1; z<Param.nValues; z++) {
	    if (paValue[z].rt <= paValue[z-1].rt)
		return E_INVALIDARG;
	}
    }

    if (m_pLastParam) {
	QPropertyParam *pParam = new QPropertyParam;
	if (!pParam)
	    return E_OUTOFMEMORY;
	else {
	    m_pLastParam->pNext = pParam;
	    m_pLastParam = pParam;
	}
    } else {
	m_pLastParam = &params;
    }

    m_pLastParam->bstrPropName = SysAllocString(Param.Name);
    if (m_pLastParam->bstrPropName == NULL)
	return E_OUTOFMEMORY;
    m_pLastParam->dispID = 0;

    VariantInit(&m_pLastParam->val.v);
    hr = VariantCopy(&m_pLastParam->val.v, &paValue->v);
    ASSERT(SUCCEEDED(hr));
    m_pLastParam->val.rt = paValue->rt;
    m_pLastParam->val.dwInterp = paValue->dwInterp;

    QPropertyValue *pLastValue = &m_pLastParam->val;
    for (int z=1; z<Param.nValues; z++) {

        QPropertyValue *pValue = new QPropertyValue;
        if (!pValue)
	    return E_OUTOFMEMORY;	// free anything now?
        else {
	    pLastValue->pNext = pValue;
	    pLastValue = pValue;
        }

        pLastValue->dwInterp = paValue[z].dwInterp;
        pLastValue->rt = paValue[z].rt;
	VariantInit(&pLastValue->v);
        hr = VariantCopy(&pLastValue->v, &paValue[z].v);
	ASSERT(SUCCEEDED(hr));
    }
    return S_OK;
}


// Caller must free the BSTR in each Param, and the BSTR in the VARIANT in
// each Value
//
STDMETHODIMP CPropertySetter::GetProps(LONG *pcParams, DEXTER_PARAM **paParam, DEXTER_VALUE **paValue)
{
    CheckPointer(pcParams, E_POINTER);
    CheckPointer(paParam, E_POINTER);
    CheckPointer(paValue, E_POINTER);

    if (m_pLastParam == NULL) {
        *pcParams = 0;
        return S_OK;
    }

    QPropertyParam *p = &params;
    QPropertyValue *v;

    // count things
    *pcParams = 0;
    LONG cVals = 0;
    while (p) {
	v = &(p->val);
	while (v) {
	    cVals++;
	    v = v->pNext;
	}
        (*pcParams)++;
	p = p->pNext;
    }
    DbgLog((LOG_TRACE,2,TEXT("CPropSet:GetProps - %d params"), (int)*pcParams));

    // allocate space
    *paParam = (DEXTER_PARAM *)CoTaskMemAlloc(*pcParams * sizeof(DEXTER_PARAM));
    if (*paParam == NULL)
	return E_OUTOFMEMORY;
    *paValue = (DEXTER_VALUE *)CoTaskMemAlloc(cVals * sizeof(DEXTER_VALUE));
    if (*paValue == NULL) {
	CoTaskMemFree(*paParam);
	return E_OUTOFMEMORY;
    }

    // do it
    p = &params;
    *pcParams = 0;
    LONG cValsTot = 0;
    while (p) {
	(*paParam)[*pcParams].Name = SysAllocString(p->bstrPropName);
	if ((*paParam)[*pcParams].Name == NULL)
	    return E_OUTOFMEMORY;	// !!! leaks
	(*paParam)[*pcParams].dispID = p->dispID;
	v = &(p->val);
        cVals = 0;
	while (v) {
	    (*paValue)[cValsTot].rt = v->rt;
	    VariantInit(&(*paValue)[cValsTot].v);
	    HRESULT hr = VariantCopy(&(*paValue)[cValsTot].v, &v->v);
	    ASSERT(SUCCEEDED(hr));
	    (*paValue)[cValsTot].dwInterp = v->dwInterp;
	    cValsTot++;
	    cVals++;
	    v = v->pNext;
	}
	(*paParam)[*pcParams].nValues = cVals;
        (*pcParams)++;
	p = p->pNext;
    }
    return S_OK;
}


// And the Lord said:  "Whosoever shall call GetProps must subsequently call
// FreeProps!!"  And it was a good idea.
//
STDMETHODIMP CPropertySetter::FreeProps(LONG cParams, DEXTER_PARAM *pParam, DEXTER_VALUE *pValue)
{
    if (cParams == 0)
	return S_OK;
    LONG v = 0;
    for (LONG zz=0; zz<cParams; zz++) {
	SysFreeString(pParam[zz].Name);
	for (LONG yy=0; yy < pParam[zz].nValues; yy++) {
	    VariantClear(&pValue[v+yy].v);
	}
	v += pParam[zz].nValues;
    }
    CoTaskMemFree(pParam);
    CoTaskMemFree(pValue);
    return S_OK;
}


// Nuke everything, start over
//
STDMETHODIMP CPropertySetter::ClearProps()
{
    if (m_pLastParam == NULL)
	return S_OK;
    QPropertyParam *p = &params, *t1;
    QPropertyValue *t2, *r;
    while (p) {
	r = &p->val;
	while (r) {
	    VariantClear(&r->v);
	    t2 = r->pNext;
	    if (r != &p->val)
	        delete r;
	    r = t2;
	}
	SysFreeString(p->bstrPropName);
	t1 = p->pNext;
	if (p != &params)
	    delete p;
	p = t1;
    }
    m_pLastParam = NULL;
    return S_OK;
}

// version of the structures with no pointers that is saveable.

typedef struct
{
    WCHAR Name[40];	// !!!
    DISPID dispID;
    LONG nValues;
} DEXTER_PARAM_BLOB;

typedef struct
{
    WCHAR wchName[40];	// !!!
    REFERENCE_TIME rt;
    DWORD dwInterp;
} DEXTER_VALUE_BLOB;


// !!! This should do versioning

STDMETHODIMP CPropertySetter::SaveToBlob(LONG *pcSize, BYTE **ppSave)
{

    CheckPointer(ppSave, E_POINTER);
    CheckPointer(pcSize, E_POINTER);

    LONG cParams = 0;
    DEXTER_PARAM *param;
    DEXTER_VALUE *value;

    // get the properties
    HRESULT hr = GetProps(&cParams, &param, &value);
    if (FAILED(hr)) {
        return hr;
    }

    DbgLog((LOG_TRACE,2,TEXT("CPropSet:SaveToBlob - %d params to save"),
						(int)cParams));

    LONG cValues = 0;
    for (LONG z=0; z<cParams; z++) {
	cValues += param[z].nValues;
        DbgLog((LOG_TRACE,2,TEXT("Param %d has %d values"), (int)z, 
						(int)param[z].nValues));
    }
    

    LONG size = sizeof(LONG) + cParams * sizeof(DEXTER_PARAM_BLOB) +
					cValues * sizeof(DEXTER_VALUE_BLOB);
    *pcSize = size;
    DbgLog((LOG_TRACE,2,TEXT("Total prop size = %d"), (int)size));

    *ppSave = (BYTE *)CoTaskMemAlloc(size);
    if (*ppSave == NULL) {
	FreeProps(cParams, param, value);
	return E_OUTOFMEMORY;
    }
    BYTE *pSave = *ppSave;

    // how many param structures for this effect?
    *((LONG *)pSave) = cParams;
    pSave += sizeof(LONG);

    // save the param structures
    DEXTER_PARAM_BLOB *pParam = (DEXTER_PARAM_BLOB *)pSave;
    for (z=0; z<cParams; z++) {
	lstrcpynW(pParam[z].Name, param[z].Name, 40); 	// !!!
	pParam[z].dispID = param[z].dispID;
	pParam[z].nValues = param[z].nValues;
    }
    pSave += cParams * sizeof(DEXTER_PARAM_BLOB);

    // save the values
    DEXTER_VALUE_BLOB *pValue = (DEXTER_VALUE_BLOB *)pSave;
    for (z=0; z<cValues; z++) {
	// always save as BSTR
	if (value[z].v.vt == VT_BSTR) {
	    lstrcpynW(pValue[z].wchName, value[z].v.bstrVal, 40);	// !!!
	} else {
	    VARIANT v;
	    VariantInit(&v);
            hr = VariantChangeTypeEx(&v, &value[z].v, US_LCID, 0, VT_BSTR);
	    ASSERT (SUCCEEDED(hr));
	    if (FAILED(hr))
		return hr;	// !!! leaks
	    lstrcpynW(pValue[z].wchName, v.bstrVal, 40);	// !!!
	    VariantClear(&v);
	}
	pValue[z].rt = value[z].rt;
	pValue[z].dwInterp = value[z].dwInterp;
    }
    //pSave += sizeof(DEXTER_VALUE_BLOB) * cValues;

    FreeProps(cParams, param, value);
    return S_OK;
}


STDMETHODIMP CPropertySetter::LoadFromBlob(LONG cSize, BYTE *pSave)
{

    LONG cParams = *(LONG *)pSave;
    DbgLog((LOG_TRACE,2,TEXT("CPropSet:LoadFromBlob - %d params"),
					    (int)cParams));
    pSave += sizeof(LONG);

    ClearProps();	// start fresh

    if (cParams) {
        DEXTER_PARAM_BLOB *pParamB = (DEXTER_PARAM_BLOB *)pSave;
        DEXTER_VALUE_BLOB *pValueB = (DEXTER_VALUE_BLOB *)(pSave + cParams
					    * sizeof(DEXTER_PARAM_BLOB));
        for (LONG z = 0; z < cParams; z++) {
	    DEXTER_PARAM param;
	    LONG nValues = pParamB->nValues;
	    DbgLog((LOG_TRACE,2,TEXT("Param %d has %d values"), (int)z,
						(int)nValues));
	    DEXTER_VALUE *pValue = (DEXTER_VALUE *)CoTaskMemAlloc(
				nValues * sizeof(DEXTER_VALUE));

	    param.Name = SysAllocString(pParamB->Name);
	    if (param.Name == NULL)
		return E_OUTOFMEMORY;	// !!! leaks?
	    param.dispID = pParamB->dispID;
	    param.nValues = pParamB->nValues;
	    for (LONG y=0; y<nValues; y++) {
		pValue[y].rt = pValueB[y].rt;
		pValue[y].dwInterp = pValueB[y].dwInterp;
		BSTR bstr = SysAllocString(pValueB[y].wchName);
		if (bstr == NULL)
		    return E_OUTOFMEMORY;	// !!! leaks?
		pValue[y].v.vt = VT_BSTR;
		pValue[y].v.bstrVal = bstr;
	    }
	
	    HRESULT hr = AddProp(param, pValue);
	    SysFreeString(param.Name);
	    for (y=0; y<nValues; y++) {
		VariantClear(&pValue[y].v);
	    }
	    CoTaskMemFree(pValue);
	    if (FAILED(hr)) {
		return hr;
	    }
	    pParamB += 1;
	    pValueB += nValues;
	}
    }
    return S_OK;
}


CUnknown * WINAPI CPropertySetter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CPropertySetter(pUnk);
}


CPropertySetter::~CPropertySetter()
{
    ClearProps();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\util\dexmisc.cpp ===
// we used to find FourCC-matching compressors first, which was bad because it was finding the Windows Media ICM compressor before
// finding the Windows Media DMO. So now we look for the FourCC compressors LAST, which of course, incurs a perf-hit.
// oh well
HRESULT FindCompressor( AM_MEDIA_TYPE * pUncompType, AM_MEDIA_TYPE * pCompType, IBaseFilter ** ppCompressor, IServiceProvider * pKeyProvider )
{
    HRESULT hr = 0;

    CheckPointer( pUncompType, E_POINTER );
    CheckPointer( pCompType, E_POINTER );
    CheckPointer( ppCompressor, E_POINTER );

    // preset it to nothing
    //
    *ppCompressor = NULL;

    // !!! can we assume we'll always get a video compressor for now?
    //
    if( pUncompType->majortype != MEDIATYPE_Video )
    {
        return E_INVALIDARG;
    }

    // get the FourCC out of the media type
    //
    VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) pCompType->pbFormat;

    DWORD WantedFourCC = FourCCtoUpper( pVIH->bmiHeader.biCompression );

    // enumerate all compressors and find one that matches
    //
    CComPtr< ICreateDevEnum > pCreateDevEnum;
    hr = CoCreateInstance(
        CLSID_SystemDeviceEnum, 
        NULL, 
        CLSCTX_INPROC_SERVER,
        IID_ICreateDevEnum, 
        (void**) &pCreateDevEnum );
    if( FAILED( hr ) )
    {
        return hr;
    }

    CComPtr< IEnumMoniker > pEm;
    hr = pCreateDevEnum->CreateClassEnumerator( CLSID_VideoCompressorCategory, &pEm, 0 );
     if( !pEm )
    {
        if( hr == S_FALSE )
        {
            return VFW_E_NO_ACCEPTABLE_TYPES;
        }
        return hr;
    }

    // --- first, we'll go through and enumerate friendly filters which provide FourCC's
    // --- first, we'll go through and enumerate friendly filters which provide FourCC's
    // --- first, we'll go through and enumerate friendly filters which provide FourCC's
    // --- first, we'll go through and enumerate friendly filters which provide FourCC's

    ULONG cFetched;
    CComPtr< IMoniker > pM;

    // --- Put each compressor in a graph and test it
    // --- Put each compressor in a graph and test it
    // --- Put each compressor in a graph and test it
    // --- Put each compressor in a graph and test it

    // create a graph
    //
    CComPtr< IGraphBuilder > pGraph;
    hr = CoCreateInstance(
        CLSID_FilterGraph,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGraphBuilder,
        (void**) &pGraph );
    if( FAILED( hr ) )
    {
        return hr;
    }

    if( pKeyProvider )
    {
        // unlock the graph
        CComQIPtr< IObjectWithSite, &IID_IObjectWithSite > pOWS( pGraph );
        ASSERT( pOWS );
        if( pOWS )
        {
            pOWS->SetSite( pKeyProvider );
        }
    }

    // create a black source to hook up
    //
    CComPtr< IBaseFilter > pSource;
    hr = CoCreateInstance(
        CLSID_GenBlkVid,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IBaseFilter,
        (void**) &pSource );
    if( FAILED( hr ) )
    {
        return hr;
    }
    hr = pGraph->AddFilter( pSource, NULL );
    if( FAILED( hr ) )
    {
        return hr;
    }
    IPin * pSourcePin = GetOutPin( pSource, 0 );
    if( !pSourcePin )
    {
        return E_FAIL;
    }

    CComQIPtr< IDexterSequencer, &IID_IDexterSequencer > pDexSeq( pSourcePin );
    hr = pDexSeq->put_MediaType( pUncompType );
    if( FAILED( hr ) )
    {
        return hr;
    }

    pEm->Reset();
    while( 1 )
    {
        pM.Release( );
        hr = pEm->Next( 1, &pM, &cFetched );
        if( hr != S_OK ) break;

        DWORD MatchFourCC = 0;

        CComPtr< IPropertyBag > pBag;
	hr = pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pBag);
        if( FAILED( hr ) )
        {
            continue;
        }

	VARIANT var;
        VariantInit( &var );
	var.vt = VT_BSTR;
	hr = pBag->Read(L"FriendlyName", &var, NULL);
        if( FAILED( hr ) )
        {
            continue;
        }
        VariantClear( &var );

        // found a compressor, see if it's the right type
        //
        VARIANT var2;
        VariantInit( &var2 );
        var2.vt = VT_BSTR;
        HRESULT hrHandler = pBag->Read( L"FccHandler", &var2, NULL );
        if( hrHandler == NOERROR )
        {
            // hey! found a FourCC! Look at that instead!

            // convert the bstr to a TCHAR
            //
            USES_CONVERSION;
            TCHAR * pTCC = W2T( var2.bstrVal );
            MatchFourCC = FourCCtoUpper( *((DWORD*)pTCC) ); // YUCK!
            VariantClear( &var2 );

            if( MatchFourCC == WantedFourCC )
            {
                // found it.
                //
                hr = pM->BindToObject(0, 0, IID_IBaseFilter,
							(void**)ppCompressor );
                if( !FAILED( hr ) )
                {
                    // nothing left to free up, we can return now.
                    //
                    pGraph->RemoveFilter( pSource );
                    return hr;
                }
	    }

            // we don't care, we already looked here
            //
            continue;
        }

        // didn't find a FourCC handler, oh well
        
        CComPtr< IBaseFilter > pFilter;
        hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**) &pFilter );
        if( FAILED( hr ) )
        {
            continue;
        }

        // put the filter in the graph and connect up it's input pin
        //
        hr = pGraph->AddFilter( pFilter, NULL );
        if( FAILED( hr ) )
        {
            continue;
        }

        IPin * pInPin = GetInPin( pFilter, 0 );
        if( !pInPin )
        {
            continue;
        }

        IPin * pOutPin = GetOutPin( pFilter, 0 );
        if( !pOutPin )
        {
            continue;
        }

        hr = pGraph->Connect( pSourcePin, pInPin );
        if( FAILED( hr ) )
        {
            pGraph->RemoveFilter( pFilter );
            continue;
        }

        CComPtr< IEnumMediaTypes > pEnum;
        pOutPin->EnumMediaTypes( &pEnum );
        if( pEnum )
        {
            DWORD Fetched = 0;
            while( 1 )
            {
                AM_MEDIA_TYPE * pOutPinMediaType = NULL;
                Fetched = 0;
                pEnum->Next( 1, &pOutPinMediaType, &Fetched );
                if( ( Fetched == 0 ) || ( pOutPinMediaType == NULL ) )
                {
                    break;
                }

                if( pOutPinMediaType->majortype == pCompType->majortype )
                if( pOutPinMediaType->subtype   == pCompType->subtype )
                if( pOutPinMediaType->formattype == pCompType->formattype )
                {
                    // !!! if we change the rules for SetSmartRecompressFormat on the group,
                    // this may not be a VIDEOINFOHEADER at all!
                    //
                    VIDEOINFOHEADER * pVIH = (VIDEOINFOHEADER*) pOutPinMediaType->pbFormat;
                    MatchFourCC = FourCCtoUpper( pVIH->bmiHeader.biCompression );

                } // if formats match

                DeleteMediaType( pOutPinMediaType );

                if( MatchFourCC )
                {
                    break;
                }

            } // while 1

        } // if pEnum

	// connect may have put intermediate filters in.  Destroy them all
        RemoveChain(pSourcePin, pInPin);
	// remove the codec that didn't work
        pGraph->RemoveFilter( pFilter );

        if( MatchFourCC && MatchFourCC == WantedFourCC )
        {
            // found it.
            //
            hr = pM->BindToObject(0, 0, IID_IBaseFilter, (void**) ppCompressor );
            if( !FAILED( hr ) )
            {
                break;
            }
        }

    } // while trying to insert filters into a graph and look at their FourCC

    // remove the black source now
    //
    pGraph->RemoveFilter( pSource );

    // return now if we found one
    //
    if( *ppCompressor )
    {
        return NOERROR;
    }

    // no compressor. Darn.
    return E_FAIL; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\varyprop.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include "..\errlog\cerrlog.h"

CUnknown * WINAPI CreatePropertySetterInstance(LPUNKNOWN pUnk, HRESULT *phr);

class CPropertySetter;

HRESULT CreatePropertySetterInstanceFromXML(IPropertySetter ** ppSetter, IXMLDOMElement *pxml);
HRESULT PrintProperties(IPropertySetter *pSetter, char *&pOut, int iIndent);

class QPropertyValue {
public:
    DWORD dwInterp; // DEXTERF_JUMP or DEXTERF_INTERPOLATE
    REFERENCE_TIME rt;
    VARIANT v;
    QPropertyValue *pNext;

    QPropertyValue() { pNext = NULL; dwInterp = 0; rt = 0; VariantInit(&v); }
};

class QPropertyParam {
public:
    BSTR bstrPropName;
    DISPID dispID;
    QPropertyValue val;
    QPropertyParam *pNext;

    QPropertyParam() { dispID = 0; pNext = NULL; bstrPropName = NULL; }
};

class CPropertySetter 
    : public CUnknown
    , public IPropertySetter
    , public CAMSetErrorLog
{
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IPropertySetter) 
        {
	    return GetInterface((IPropertySetter *) this, ppv);
	} 
        if (riid == IID_IAMSetErrorLog)
        {
	    return GetInterface((IAMSetErrorLog*) this, ppv);
	}
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    };


    QPropertyParam params;
    QPropertyParam *m_pLastParam;
    
public:
    DECLARE_IUNKNOWN

    CPropertySetter(LPUNKNOWN punk) :
            CUnknown(NAME("Varying property holder"), punk),
            m_pLastParam(NULL) {};

    ~CPropertySetter();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    HRESULT LoadOneProperty(IXMLDOMElement *pxml, QPropertyParam *pParam);
    HRESULT LoadFromXML(IXMLDOMElement *pxml);
    HRESULT SaveToXMLA(char *&pOut, int cbOut, int iIndent);
    HRESULT SaveToXMLW(WCHAR *&pOut, int cchOut, int iIndent);

    // IPropertySetter
    STDMETHODIMP SetProps(IUnknown *pTarget, REFERENCE_TIME rtNow);
    STDMETHODIMP CloneProps(IPropertySetter **pSetter, REFERENCE_TIME rtStart,
					REFERENCE_TIME rtStop);
    STDMETHODIMP AddProp(DEXTER_PARAM Param, DEXTER_VALUE *paValue);
    STDMETHODIMP GetProps(LONG *pcParams, DEXTER_PARAM **paParam,
			DEXTER_VALUE **paValue);
    STDMETHODIMP FreeProps(LONG cParams, DEXTER_PARAM *pParam,
			DEXTER_VALUE *pValue);
    STDMETHODIMP ClearProps();
    STDMETHODIMP LoadXML(IUnknown * pxml);
    STDMETHODIMP PrintXML(char *pszXML, int cbXML, int *pcbPrinted, int indent);
    STDMETHODIMP PrintXMLW(WCHAR *pszXML, int cbXML, int *pcbPrinted, int indent);
    STDMETHODIMP SaveToBlob(LONG *pcSize, BYTE **ppb);
    STDMETHODIMP LoadFromBlob(LONG cSize, BYTE *pb);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\util\filfuncs.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <initguid.h>

DEFINE_GUID( CLSID_Indeo5, 0x1F73E9B1, 0x8C3A, 0x11d0, 0xA3, 0xBE, 0x00, 0xa0, 0xc9, 0x24, 0x44, 0x36 );

IPin * GetInPin( IBaseFilter * pFilter, int PinNum )
{
    IEnumPins * pEnum = 0;
    HRESULT hr = pFilter->EnumPins( &pEnum );
    pEnum->Reset( );
    ULONG Fetched;
    do
    {
        Fetched = 0;
        IPin * pPin = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( Fetched )
        {
            PIN_DIRECTION pd;
            pPin->QueryDirection( &pd);
            pPin->Release( );
            if( pd == PINDIR_INPUT )
            {
                if( PinNum == 0 )
                {
                    pEnum->Release( );
                    return pPin;
                }
                PinNum--;
            }
        }
    }
    while( Fetched );
    pEnum->Release( );
    return NULL;
}

IPin * GetOutPin( IBaseFilter * pFilter, int PinNum )
{
    IEnumPins * pEnum = 0;
    HRESULT hr = pFilter->EnumPins( &pEnum );
    pEnum->Reset( );
    ULONG Fetched;
    do
    {
        Fetched = 0;
        IPin * pPin = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( Fetched )
        {
            PIN_DIRECTION pd;
            pPin->QueryDirection( &pd);
            pPin->Release( );
            if( pd == PINDIR_OUTPUT )
            {
                if( PinNum == 0 )
                {
                    pEnum->Release( );
                    return pPin;
                }
                PinNum--;
            }
        }
    }
    while( Fetched );
    pEnum->Release( );
    return NULL;
}

// I only want output pins NOT of this major type
//
IPin * GetOutPinNotOfType( IBaseFilter * pFilter, int PinNum, GUID * type )
{
    IEnumPins * pEnum = 0;
    HRESULT hr = pFilter->EnumPins( &pEnum );
    pEnum->Reset( );
    ULONG Fetched;
    do
    {
        Fetched = 0;
        IPin * pPin = 0;
        pEnum->Next( 1, &pPin, &Fetched );
        if( Fetched )
        {
            pPin->Release( );
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir == PINDIR_OUTPUT )
            {
                CComPtr <IEnumMediaTypes> pMediaEnum;
	        AM_MEDIA_TYPE *pMediaType;
                pPin->EnumMediaTypes(&pMediaEnum);
                if (!pMediaEnum ) continue;
                ULONG tFetched = 0;
                pMediaEnum->Next(1, &pMediaType, &tFetched);
                if (!tFetched) continue;
                if (pMediaType->majortype == *type)  {
                    DeleteMediaType(pMediaType);
                    continue;	// NOT YOU!
                }
                DeleteMediaType(pMediaType);                
                if (PinNum == 0)
                {
                    pEnum->Release( );
                    return pPin;
                }
                PinNum--;
            }
        }
    }
    while( Fetched );
    pEnum->Release( );
    return NULL;
}

// this will remove everything from the graph, NOT including
// the filters of pPin1 and pPin2
//
void RemoveChain( IPin * pPin1, IPin * pPin2 )
{
    HRESULT hr = 0;

    // find the pin that our output is connected to, this
    // will be on the "next" filter
    //
    CComPtr< IPin > pDownstreamInPin;
    pPin1->ConnectedTo( &pDownstreamInPin );
    if( !pDownstreamInPin )
    {
        return;
    }

    // if the connected to is the same as the pPin2, then we
    // have reached the LAST two connected pins, so just
    // disconnect them
    //
    if( pDownstreamInPin == pPin2 )
    {
        pPin1->Disconnect( );
        pPin2->Disconnect( );

        return;
    }
    
    // ask that pin for it's info, so we know what filter
    // it's on
    //
    PIN_INFO PinInfo;
    ZeroMemory( &PinInfo, sizeof( PinInfo ) );
    pDownstreamInPin->QueryPinInfo( &PinInfo );
    if( !PinInfo.pFilter )
    {
        return;
    }

    // find a pin enumerator on the downstream filter, so we
    // can find IT'S connected output pin
    //
    CComPtr< IEnumPins > pPinEnum;
    PinInfo.pFilter->EnumPins( &pPinEnum );
    PinInfo.pFilter->Release( );
    if( !pPinEnum )
    {
        // error condition, but we'll continue anyhow. This should never happen
        //
        ASSERT( pPinEnum );
        return;
    }

    // go look for the first connected output pin
    //
    while( 1 )
    {
        CComPtr< IPin > pPin;
        ULONG Fetched = 0;
        hr = pPinEnum->Next( 1, &pPin, &Fetched );
        if( hr != 0 )
        {
            ASSERT( hr != 0 );
            break;
        }

        PIN_INFO PinInfo2;
        ZeroMemory( &PinInfo2, sizeof( PinInfo2 ) );
        pPin->QueryPinInfo( &PinInfo2 );
        if( !PinInfo2.pFilter )
        {
            // error condition, but we'll continue anyhow. This should never happen
            //
            ASSERT( PinInfo2.pFilter );
            continue;
        }

        if( PinInfo2.dir == PINDIR_OUTPUT )
        {
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );
            if( !pConnected )
            {
                continue;
            }

            // we found a connected output pin, so
            // recursively call Remove( ) on those two...
            //
            RemoveChain( pPin, pPin2 );

            // then disconnect the upper two...
            //
            pPin1->Disconnect( );
            pDownstreamInPin->Disconnect( );

            // then remove the filter from the graph..
            //
            FILTER_INFO FilterInfo;
            PinInfo2.pFilter->QueryFilterInfo( &FilterInfo );
            hr  = FilterInfo.pGraph->RemoveFilter( PinInfo2.pFilter );
            FilterInfo.pGraph->Release( );

            // and release our refcount! The filter should go away now
            //
            PinInfo2.pFilter->Release( );

            return;
        }

        PinInfo2.pFilter->Release( );
    }

    // nothing to do here. It should in fact, never get here
    //
    ASSERT( 0 );
}

// Pause or Run (fRun) each filter walking upstream from pPinIn (taking all
//      upstream branches)
// Optionally change the state of the filter at the head of the chains (filters
//      without input pins)
//
HRESULT StartUpstreamFromPin(IPin *pPinIn, BOOL fRun, BOOL fHeadToo)
{
    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);
    if (FAILED(hr))
        return hr;

    FILTER_STATE State;

    hr = pinfo.pFilter->GetState(0, &State);

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "pFilter->GetState returned %x, I'm confused", hr));
        pinfo.pFilter->Release();
        return E_FAIL;
    }

    hr = StartUpstreamFromFilter(pinfo.pFilter, fRun, fHeadToo);

    pinfo.pFilter->Release();

    return hr;
}

// Run or Pause (fRun) this filter, unless it has no input pins and we don't
//     want to change the state of the head filter (fHeadToo)
// Continue upstream of all input pins
//
HRESULT StartUpstreamFromFilter(IBaseFilter *pf, BOOL fRun, BOOL fHeadToo, REFERENCE_TIME RunTime )
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 2, "  StartUpstreamFromFilter(%x, %d)", pf, fRun));

    // has this filter been started yet? Don't start it now, we don't know yet
    // if we're supposed to
    BOOL fStarted = FALSE;

    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        for (;;) {

            ULONG ulActual;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }
            
            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            if (hr == S_OK && pd == PINDIR_INPUT) {

                // start this filter if it hasn't been yet.  It's not the head
                // filter, it has input pins
                //
                if (fStarted == FALSE) {
                    fStarted = TRUE;
                    if (fRun) {
                        hr = pf->Run(RunTime);
                    } else {
                        hr = pf->Pause();
                    }
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR, 1, "Filter %x failed %hs, hr = %x", pf, fRun ? "run" : "pause", hr));
                    }
                }

                // recurse upstream of each input pin
                if (SUCCEEDED(hr)) {
                    hr = StartUpstreamFromPin(aPin, fRun, fHeadToo);
                }
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE, 2, "  Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;

            // start this filter (if the head filter of the chain is 
            // supposed to be started) If it isn't started yet, it has no inputs
            if (fHeadToo && fStarted == FALSE) {
                fStarted = TRUE;
                if (fRun) {
                    hr = pf->Run(RunTime);
                } else {
                    hr = pf->Pause();
                }
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR, 1, "Filter %x failed %hs, hr = %x", pf, fRun ? "run" : "pause", hr));
                }
            }
        }
    }

    DbgLog((LOG_TRACE, 2, "  StartUpstreamFromFilter(%x, %d) returning %x", pf, fRun, hr));
    
    return hr;
}


// Pause or Stop (fPause) each filter walking upstream from pPinIn (taking all
//      upstream branches)
// Optionally change the state of the filter at the head of the chains (filters
//      without input pins)
//
HRESULT StopUpstreamFromPin(IPin *pPinIn, BOOL fPause, BOOL fHeadToo)
{
    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);
    if (FAILED(hr))
        return hr;

    hr = StopUpstreamFromFilter(pinfo.pFilter, fPause, fHeadToo);

    pinfo.pFilter->Release();
    
    return hr;
}

// Pause or Stop (fPause) this filter, unless it has no input pins and we don't
//     want to change the state of the head filter (fHeadToo)
// Continue upstream of all input pins
//
HRESULT StopUpstreamFromFilter(IBaseFilter *pf, BOOL fPause, BOOL fHeadToo)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 2, "  StopUpstreamFromFilter(%x)", pf));

    // has this filter been stopped yet?  Don't stop it now, we don't yet know
    // if we're supposed to
    BOOL fStopped = FALSE;
    
    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,"Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        for (;;) {

            ULONG       ulActual;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }

            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            if (hr == S_OK && pd == PINDIR_INPUT) {

                // There is an input pin.  this is not the head of the chain
                // so we can stop this filter now, if it hasn't been yet
                if (!fStopped) {
                    DbgLog((LOG_TRACE, 3, "about to %hs Filter %x",
                                    fPause ? "pause" : "stop", pf));
                    fStopped = TRUE;
                    if (fPause) {
                        hr = pf->Pause();
                    } else {
                        hr = pf->Stop();
                    }
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR,1,"Filter %x failed %hs, hr = %x", pf,
                                        fPause ? "pause" : "stop", hr));
                    }
                }

                hr = StopUpstreamFromPin(aPin, fPause, fHeadToo);
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE,5,"Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;

            // start this filter (if the head filter is supposed to be
            // started) If it isn't started yet, it has no inputs
            if (!fStopped && fHeadToo) {
                DbgLog((LOG_TRACE,3,"about to %hs Filter %x",
                                    fPause ? "pause" : "stop", pf));
                fStopped = TRUE;
                if (fPause) {
                    hr = pf->Pause();
                } else {
                    hr = pf->Stop();
                }
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,1,"Filter %x failed %hs, hr = %x", pf,
                                     fPause ? "pause" : "stop", hr));
                }
            }
        }
    }

    DbgLog((LOG_TRACE, 2, "  StopUpstreamFromFilter(%x) returning %x", pf, hr));
    
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is upstream of this pin from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveUpstreamFromPin(IPin *pPinIn)
{
    DbgLog((LOG_TRACE, 2, "  RemoveUpstreamFromPin(%x)", pPinIn));

    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);

    if (FAILED(hr))
        return hr;

// I'm counting on the whole chain really going away!
#if 0
    CComPtr< IAMStreamControl > pSC;
    HRESULT hrQI = pPin->QueryInterface(IID_IAMStreamControl, (void **) &pSC);
    if (FAILED(hrQI)) {
        // throw away return code and continue upstream
        hr = RemoveUpstreamFromFilter(pinfo.pFilter);
    } else {
        // if the next filter has streamcontrol, by definition it's not part of
        // this chain so we don't do anything!
    }
#else
    hr = RemoveUpstreamFromFilter(pinfo.pFilter);
#endif
    
    pinfo.pFilter->Release();
        
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is downstream of this pin from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveDownstreamFromPin(IPin *pPinIn)
{
    DbgLog((LOG_TRACE, 2, "  RemoveDownstreamFromPin(%x)", pPinIn));

    CComPtr< IPin > pPin;
    HRESULT hr = pPinIn->ConnectedTo(&pPin);

    if (pPin == NULL) {
        // not connected, we don't need to follow further
        return S_OK;
    }
    
    PIN_INFO pinfo;
    
    hr = pPin->QueryPinInfo(&pinfo);

    if (FAILED(hr))
        return hr;

// I'm counting on the whole chain really going away!
#if 0
    CComPtr< IAMStreamControl > pSC;
    HRESULT hrQI = pPin->QueryInterface(IID_IAMStreamControl, (void **) &pSC);
    if (FAILED(hrQI)) {
        // throw away return code and continue upstream
        hr = RemoveDownstreamFromFilter(pinfo.pFilter);
    } else {
        // if the next filter has streamcontrol, by definition it's not part of
        // this chain so we don't do anything!
    }
#else
    hr = RemoveDownstreamFromFilter(pinfo.pFilter);
#endif
    
    pinfo.pFilter->Release();
        
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is upstream of this filter from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveUpstreamFromFilter(IBaseFilter *pf)
{
    DbgLog((LOG_TRACE, 2, "  RemoveUpstreamFromFilter(%x)", pf));

    HRESULT hr;

    // do this function on all pins on this filter
    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        // for each pin on this filter
        for (;;) {

            ULONG ulActual = 0;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }

            // ask for the pin direction
            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            // if it's an input pin, then remove anything upstream of it
            if (hr == S_OK && pd == PINDIR_INPUT) {
                hr = RemoveUpstreamFromPin(aPin);
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE, 2, "Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;
        }
    }

    // removed all upstream pins of this filter, now remove this filter from
    // the graph as well
    if (SUCCEEDED(hr)) {
        FILTER_INFO fi;
        pf->QueryFilterInfo( &fi );
        if( fi.pGraph )
        {
            hr = fi.pGraph->RemoveFilter( pf );
            fi.pGraph->Release( );
        }

        ASSERT(SUCCEEDED(hr));

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, "error removing Filter %x, hr = %x", pf, hr));
        }
    }
    
    DbgLog((LOG_TRACE, 2, "  RemoveUpstreamFromFilter(%x) returning %x", pf, hr));
    
    return hr;
}


//----------------------------------------------------------------------------
// Remove anything that is downstream of this filter from the graph.
//----------------------------------------------------------------------------

HRESULT RemoveDownstreamFromFilter(IBaseFilter *pf)
{
    DbgLog((LOG_TRACE, 2, "  RemoveDownstreamFromFilter(%x)", pf));

    HRESULT hr;

    // do this function on all pins on this filter
    CComPtr< IEnumPins > pEnum;
    hr = pf->EnumPins(&pEnum);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1, "Filter %x failed EnumPins, hr = %x", pf, hr));
    } else {

        // for each pin on this filter
        for (;;) {

            ULONG ulActual = 0;
            CComPtr< IPin > aPin;

            hr = pEnum->Next(1, &aPin, &ulActual);
            if (hr != S_OK) {       // no more pins
                hr = S_FALSE;
                break;
            }

            // ask for the pin direction
            PIN_DIRECTION pd;
            hr = aPin->QueryDirection(&pd);

            // if it's an input pin, then remove anything upstream of it
            if (hr == S_OK && pd == PINDIR_OUTPUT) {
                hr = RemoveDownstreamFromPin(aPin);
            }

            if (FAILED(hr))
                break;
        }

        if (hr == S_FALSE) {
            DbgLog((LOG_TRACE, 2, "Successfully dealt with all pins of filter %x", pf));
            hr = S_OK;
        }
    }

    // removed all downstream pins of this filter, now remove this filter from
    // the graph as well
    if (SUCCEEDED(hr)) {
        FILTER_INFO fi;
        pf->QueryFilterInfo( &fi );
        if( fi.pGraph )
        {
            hr = fi.pGraph->RemoveFilter( pf );
            fi.pGraph->Release( );
        }

        ASSERT(SUCCEEDED(hr));

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, "error removing Filter %x, hr = %x", pf, hr));
        }
    }
    
    DbgLog((LOG_TRACE, 2, "  RemoveDownstreamFromFilter(%x) returning %x", pf, hr));
    
    return hr;
}


#if 0
HRESULT HideVideoWindows( IGraphBuilder * pGraph )
{
    USES_CONVERSION;

    if( pGraph )
    {
        CComPtr< IEnumFilters > pEnumFilters;
        pGraph->EnumFilters( &pEnumFilters );
        if( pEnumFilters )
        {
            while( 1 )
            {
                CComPtr< IBaseFilter > pFilter;
                ULONG Fetched = 0;
                pEnumFilters->Next( 1, &pFilter, &Fetched );
                if( !Fetched )
                {
                    break;
                }

                // check all the pins for this filter
                //
                CComPtr< IVideoWindow > pVW;
                pFilter->QueryInterface(IID_IVideoWindow, (void **)&pVW);
                if (pVW) {
                    pVW->put_Visible(OAFALSE);
                }
            } // while filters
        } // if enum filters
    } // if pGraph

    return NOERROR;
}
#endif


HRESULT WipeOutGraph( IGraphBuilder * pGraph )
{
    USES_CONVERSION;

    if( pGraph )
    {
        CComPtr< IEnumFilters > pEnumFilters;
        pGraph->EnumFilters( &pEnumFilters );
        ULONG Fetched = 0;
        if( pEnumFilters )
        {
            // remove all filters from the graph
            //
            ULONG Fetched = 0;
            while( 1 )
            {
                CComPtr< IBaseFilter > pFilter;
                Fetched = 0;
                pEnumFilters->Next( 1, &pFilter, &Fetched );
                if( !Fetched )
                {
                    break;
                }

#ifdef DEBUG
                FILTER_INFO fi;
                pFilter->QueryFilterInfo( &fi );
                if( fi.pGraph ) fi.pGraph->Release( );
                TCHAR * t = W2T( fi.achName );
                DbgLog( ( LOG_TRACE, 2, "WipeOutGraph removing filter %s", t ) );
#endif
                pGraph->RemoveFilter( pFilter );
                pEnumFilters->Reset( );
            } // while filters

        } // if enum filters

    } // if pGraph

    return NOERROR;
}

//############################################################################
// This function takes a source filter with an output pin connected already,
// and reconnects a different output pin to the downstream connected filter
// instead. This is because we can't easily pull in a parser for a given
// source filter. It's easier just to connect the first one and diconnect it.
//############################################################################

HRESULT ReconnectToDifferentSourcePin(IGraphBuilder *pGraph, 
                                      IBaseFilter *pUnkFilter, 
                                      long StreamNumber, 
                                      const GUID *pGuid)
{
    HRESULT hr = E_FAIL;

    CComPtr< IBaseFilter > pBaseFilter = pUnkFilter;

    // !!! We assume there will only be one connected pin on each filter (of
    // the mediatype we're interested in) on our search downstream
    
    // look at each downstream filter
    //    
    while( pBaseFilter )
    {
        CComPtr< IEnumPins > pEnumPins;
        pBaseFilter->EnumPins( &pEnumPins );
        if( !pEnumPins )
        {
            break;
        }

        // Walk downstream using the first connected pin of any kind.
	// But if there is a connected pin of type pGuid, stop walking
	// downstream, and see if we need to reconnect what's downstream of
	// that to a different pin of type pGuid
        //
        CComPtr< IBaseFilter > pNextFilter;
        CComPtr< IPin > pConnectedOutPin;
        while( 1 )
        {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue;
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );
            if( !pConnected ) continue;

	    // this is the filter we'll walk downstream to, if we do
            pConnected->QueryPinInfo( &pi );
            pNextFilter = pi.pFilter;
            if( pi.pFilter ) pi.pFilter->Release( );
	    
            CComPtr< IEnumMediaTypes > pMediaEnum;
	    pPin->EnumMediaTypes(&pMediaEnum);
	    if (!pMediaEnum) continue;
	    Fetched = 0;
	    AM_MEDIA_TYPE *pMediaType;
	    pMediaEnum->Next(1, &pMediaType, &Fetched);
	    if (!Fetched) continue;
	    // this is the wrong pin - (wrong mediatype)
	    if (pMediaType->majortype != *pGuid) {
		DeleteMediaType(pMediaType);
		continue;
	    }
	    DeleteMediaType( pMediaType );
            pConnectedOutPin = pPin;
            break; // found it
        }
        pEnumPins->Reset( );

        // we found the first connected output pin, now go through
        // the pins again and count up output types that match the media
        // type we're looking for

        long FoundPins = -1;
	// if we didn't find an outpin of the right type, don't waste time here
        while (pConnectedOutPin) {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;   // out of pins, done
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue; // not output pin, continue
            AM_MEDIA_TYPE * pMediaType = NULL;
            CComPtr< IEnumMediaTypes > pMediaEnum;
            pPin->EnumMediaTypes( &pMediaEnum );
            ASSERT( pMediaEnum );
            if( !pMediaEnum ) continue; // no media types on this pin, continue
            Fetched = 0;
            pMediaEnum->Next( 1, &pMediaType, &Fetched );
            if( !Fetched ) continue; // no media types on this pin, continue
            GUID MajorType = pMediaType->majortype;
            DeleteMediaType( pMediaType );
            if( MajorType == *pGuid )
            {
                FoundPins++;
                if( FoundPins == StreamNumber )
                {
                    // found it!
                    
                    // if they're the same pin, we're done
                    //
                    if( pConnectedOutPin == pPin )
                    {
                        return 0;
                    }

                    // disconnect the connected output pin and
                    // reconnect the right output pin
                    //
                    CComPtr< IPin > pDestPin;
                    pConnectedOutPin->ConnectedTo( &pDestPin );
                    RemoveChain( pConnectedOutPin, pDestPin );
                    pConnectedOutPin->Disconnect( );
                    pDestPin->Disconnect( );

                    hr = pGraph->Connect( pPin, pDestPin );

                    return hr;
                } // if we found the pin
            } // if the media type matches
        } // for every pin

        pBaseFilter = pNextFilter;

    } // for each filter

    return VFW_E_UNSUPPORTED_STREAM;
}

IBaseFilter * GetStartFilterOfChain( IPin * pPin )
{
    PIN_INFO ThisPinInfo;
    pPin->QueryPinInfo( &ThisPinInfo );
    if( ThisPinInfo.pFilter ) ThisPinInfo.pFilter->Release( );

    CComPtr< IEnumPins > pEnumPins;
    ThisPinInfo.pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        ASSERT( !pPin ); // is it out of scope?
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }

        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an input pin...
        //
        if( pi.dir == PINDIR_INPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // go return IT'S filter!
            //
            if( pConnected )
            {
                return GetStartFilterOfChain( pConnected );
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    // hey! didn't find any connected input pins, it must be us!
    //
    return ThisPinInfo.pFilter;
}

IBaseFilter * GetStopFilterOfChain( IPin * pPin )
{
    PIN_INFO ThisPinInfo;
    pPin->QueryPinInfo( &ThisPinInfo );
    if( ThisPinInfo.pFilter ) ThisPinInfo.pFilter->Release( );

    CComPtr< IEnumPins > pEnumPins;
    ThisPinInfo.pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        pPin.Release( );
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }
        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an output pin...
        //
        if( pi.dir == PINDIR_OUTPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // go return IT'S filter!
            //
            if( pConnected )
            {
                return GetStopFilterOfChain( pConnected );
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    // hey! didn't find any connected input pins, it must be us!
    //
    return ThisPinInfo.pFilter;
}

IBaseFilter * GetNextDownstreamFilter( IBaseFilter * pFilter )
{
    CComPtr< IEnumPins > pEnumPins;
    pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        pPin.Release( );
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }
        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an output pin...
        //
        if( pi.dir == PINDIR_OUTPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // return that pin's filter
            //
            if( pConnected )
            {
                pConnected->QueryPinInfo( &pi );
                pi.pFilter->Release( );
                return pi.pFilter;
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    return NULL;
}

IBaseFilter * GetNextUpstreamFilter( IBaseFilter * pFilter )
{
    CComPtr< IEnumPins > pEnumPins;
    pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return NULL;
    }

    // look at every pin on the current filter...
    //
    ULONG Fetched = 0;
    do
    {
        CComPtr< IPin > pPin;
        Fetched = 0;
        pPin.Release( );
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            break;
        }
        PIN_INFO pi;
        pPin->QueryPinInfo( &pi );
        if( pi.pFilter ) pi.pFilter->Release( );

        // if it's an output pin...
        //
        if( pi.dir == PINDIR_INPUT )
        {
            // see if it's connected, and if it is...
            //
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );

            // return that pin's filter
            //
            if( pConnected )
            {
                pConnected->QueryPinInfo( &pi );
                pi.pFilter->Release( );
                return pi.pFilter;
            }
        }

        // go try the next pin
        
    } while( Fetched > 0 );

    return NULL;
}

IFilterGraph * GetFilterGraphFromPin( IPin * pPin )
{
    PIN_INFO pi;
    pPin->QueryPinInfo( &pi );
    if( !pi.pFilter )
    {
        return NULL;
    }

    FILTER_INFO fi;
    pi.pFilter->QueryFilterInfo( &fi );
    pi.pFilter->Release( );
    fi.pGraph->Release( );
    return fi.pGraph;
}

IFilterGraph * GetFilterGraphFromFilter( IBaseFilter * pFilter )
{
    FILTER_INFO fi;
    pFilter->QueryFilterInfo( &fi );
    if( !fi.pGraph ) return NULL;
    fi.pGraph->Release( );
    return fi.pGraph;
}

BOOL IsInputPin( IPin * pPin )
{
    PIN_INFO pi;
    pPin->QueryPinInfo( &pi );
    if( pi.pFilter ) pi.pFilter->Release( );
    return ( pi.dir == PINDIR_INPUT );
}

long GetFilterGenID( IBaseFilter * pFilter )
{
    FILTER_INFO fi;
    pFilter->QueryFilterInfo( &fi );
    if( fi.pGraph ) fi.pGraph->Release( );
    // for it to be a "special" dexter filter in the graph,
    // it's name must conform to a special structure.
    if( wcsncmp( fi.achName, L"DEXFILT", 7 ) != 0 )
    {
        return 0;
    }

    // the last 8 digits represent the ID in hex
    //
    long ID = 0;
    for( int i = 0 ; i < 8 ; i++ )
    {
        WCHAR w = fi.achName[7+i];
        int x = w;
        if( x > '9' )
        {
            x -= 7;
        }
        x -= '0';

        ID = ( ID * 16 ) + x;
    }

    return ID;
}

void GetFilterName( long UniqueID, WCHAR * pSuffix, WCHAR * pNameToWriteTo, long SizeOfString )
{
    wcscpy( pNameToWriteTo, L"DEXFILT" );
    wcscat( pNameToWriteTo, L"00000000: " );
    pNameToWriteTo[15] = 0;
    pNameToWriteTo[16] = 0;
    if( pSuffix )
    {
        if( wcslen( pSuffix ) + 16 < unsigned long( SizeOfString ) )
        {
            wcscat( pNameToWriteTo, pSuffix );
        }
    }
    long ID = UniqueID;
    for( int i = 0 ; i < 8 ; i++ )
    {
        long r = ID & 15;
        ID /= 16;
        r += '0';
        if( r > '9' )
        {
            r += 7;
        }
        WCHAR w = WCHAR( r );
        pNameToWriteTo[14-i] = w;
    }
}

IBaseFilter * FindFilterWithInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface )
{
    while( pFilter )
    {
        IUnknown * pInt = NULL;
        HRESULT hr = pFilter->QueryInterface( *pInterface, (void**) &pInt );
        if( pInt )
        {
            pInt->Release( );
            return pFilter;
        }
        pFilter = GetNextUpstreamFilter( pFilter );
    }
    return NULL;
}

void * FindInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface )
{
    while( pFilter )
    {
        IUnknown * pInt = NULL;
        HRESULT hr = pFilter->QueryInterface( *pInterface, (void**) &pInt );
        if( pInt )
        {
            return (void**) pInt;
        }
        pFilter = GetNextUpstreamFilter( pFilter );
    }
    return NULL;
}

IUnknown * FindPinInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface )
{
    return NULL;
}

IBaseFilter * GetFilterFromPin( IPin * pPin )
{
    if( !pPin ) return NULL;
    PIN_INFO pi;
    pPin->QueryPinInfo( &pi );
    pi.pFilter->Release( );
    return pi.pFilter;
}

HRESULT DisconnectFilters( IBaseFilter * p1, IBaseFilter * p2 )
{
    CheckPointer( p1, E_POINTER );
    CheckPointer( p2, E_POINTER );

    // enumerate all pins on p1 and if they're connected to p2,
    // disconnect both

    CComPtr< IEnumPins > pEnum;
    p1->EnumPins( &pEnum );
    if( !pEnum )
    {
        return E_NOINTERFACE;
    }

    while( 1 )
    {
        ULONG Fetched = 0;
        CComPtr< IPin > pOutPin;
        pEnum->Next( 1, &pOutPin, &Fetched );
        if( !pOutPin )
        {
            break;
        }
        PIN_INFO OutInfo;
        pOutPin->QueryPinInfo( &OutInfo );
        if( OutInfo.pFilter ) OutInfo.pFilter->Release( );
        if( OutInfo.dir != PINDIR_OUTPUT )
        {
            continue;
        }

        CComPtr< IPin > pInPin;
        pOutPin->ConnectedTo( &pInPin );
        if( pInPin )
        {
            PIN_INFO InInfo;
            pInPin->QueryPinInfo( &InInfo );
            if( InInfo.pFilter ) InInfo.pFilter->Release( );
            if( InInfo.pFilter == p2 )
            {
                pOutPin->Disconnect( );
                pInPin->Disconnect( );
            }
        }
    }
    return NOERROR;
}

HRESULT DisconnectFilter( IBaseFilter * p1 )
{
    CheckPointer( p1, E_POINTER );

    // enumerate all pins on p1 and if they're connected to p2,
    // disconnect both

    CComPtr< IEnumPins > pEnum;
    p1->EnumPins( &pEnum );
    if( !pEnum )
    {
        return E_NOINTERFACE;
    }

    while( 1 )
    {
        ULONG Fetched = 0;
        CComPtr< IPin > pPin;
        pEnum->Next( 1, &pPin, &Fetched );
        if( !pPin )
        {
            break;
        }
        PIN_INFO OutInfo;
        pPin->QueryPinInfo( &OutInfo );
        if( OutInfo.pFilter ) OutInfo.pFilter->Release( );

        CComPtr< IPin > pOtherPin;
        pPin->ConnectedTo( &pOtherPin );
        if( pOtherPin )
        {
            pPin->Disconnect( );
            pOtherPin->Disconnect( );
        }
    }
    return NOERROR;
}

// this function looks for the major type defined in the
// findmediatype until it finds the nth stream which matches
// the media type, then copies the entire media type into the
// passed in struct.
//
HRESULT FindMediaTypeInChain( 
                             IBaseFilter * pSource, 
                             AM_MEDIA_TYPE * pFindMediaType, 
                             long StreamNumber )
{
    HRESULT hr = E_FAIL;

    CComPtr< IBaseFilter > pBaseFilter = pSource;

    // !!! We assume there
    // will only be one connected pin on each filter as it gets
    // to our destination pin
    
    // look at each downstream filter
    //    
    while( 1 )
    {
        CComPtr< IEnumPins > pEnumPins;
        pBaseFilter->EnumPins( &pEnumPins );
        if( !pEnumPins )
        {
            break;
        }

        // find the first connected output pin and the downstream filter
        // it's connected to
        //
        CComPtr< IBaseFilter > pNextFilter;
        CComPtr< IPin > pConnectedOutPin;
        while( 1 )
        {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue;
            CComPtr< IPin > pConnected;
            pPin->ConnectedTo( &pConnected );
            if( !pConnected ) continue;
            pConnected->QueryPinInfo( &pi );
            pNextFilter = pi.pFilter;
            if( pi.pFilter ) pi.pFilter->Release( );
            pConnectedOutPin = pPin;
            break; // found it
        }
        pEnumPins->Reset( );

        // we found the first connected output pin, now go through
        // the pins again and count up output types that match the media
        // type we're looking for

        long FoundPins = -1;
        while( 1 )
        {
            ULONG Fetched = 0;
            CComPtr< IPin > pPin;
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched ) break;   // out of pins, done
            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );
            if( pi.dir != PINDIR_OUTPUT ) continue; // not output pin, continue
            AM_MEDIA_TYPE * pMediaType = NULL;
            CComPtr< IEnumMediaTypes > pMediaEnum;
            pPin->EnumMediaTypes( &pMediaEnum );
            ASSERT( pMediaEnum );
            if( !pMediaEnum ) continue; // no media types on this pin, continue
            Fetched = 0;
            pMediaEnum->Next( 1, &pMediaType, &Fetched );
            if( !Fetched ) continue; // no media types on this pin, continue
            GUID MajorType = pMediaType->majortype;
            if( MajorType == pFindMediaType->majortype )
            {
                FoundPins++;
                if( FoundPins == StreamNumber )
                {
                    // found it! Copy the media type to the
                    // one we passed in

                    CopyMediaType( pFindMediaType, pMediaType );

                    DeleteMediaType( pMediaType );

                    return NOERROR;
                    
                } // if we found the pin

            } // if the media type matches

            DeleteMediaType( pMediaType );

        } // for every pin

        pBaseFilter.Release( );
        pBaseFilter = pNextFilter;

    } // for each filter

    return S_FALSE;
}

DWORD FourCCtoUpper( DWORD u )
{
    DWORD t = 0;
    for( int i = 0 ; i < 4 ; i++ )
    {
        int j = ( u & 0xff000000 ) >> 24;
        if( j >= 'a' && j <= 'z' )
        {
            j -= ( 'a' - 'A' );
        }
        t = t * 256 + j;
        u <<= 8;
    }
    return t;
}

// Is the first type acceptable for not needing to be uncompressed, given that
// pTypeNeeded is the format of the project
//
BOOL AreMediaTypesCompatible( AM_MEDIA_TYPE * pType1, AM_MEDIA_TYPE * pTypeNeeded )
{
    if( !pType1 ) return FALSE;
    if( !pTypeNeeded ) return FALSE;

    if( pType1->majortype != pTypeNeeded->majortype )
    {
        return FALSE;
    }

    if( pType1->subtype != pTypeNeeded->subtype )
    {
        return FALSE;
    }

    // how do we compare formattypes? will they always be the same?
    //
    if( pType1->formattype != pTypeNeeded->formattype )
    {
        return FALSE;
    }

    // okay, the formats are the same. NOW what? I guess we'll have to
    // do a switch on the formattype to see if the formats are the same
    //
    if( pType1->formattype == FORMAT_None )
    {
        return TRUE;
    }
    else if( pType1->formattype == FORMAT_VideoInfo )
    {
        VIDEOINFOHEADER * pVIH1 = (VIDEOINFOHEADER*) pType1->pbFormat;
        VIDEOINFOHEADER * pVIH2 = (VIDEOINFOHEADER*) pTypeNeeded->pbFormat;

        if( pVIH1->bmiHeader.biWidth != pVIH2->bmiHeader.biWidth )
        {
            return FALSE;
        }
        if( pVIH1->bmiHeader.biHeight != pVIH2->bmiHeader.biHeight )
        {
            return FALSE;
        }
        if( pVIH1->bmiHeader.biBitCount != pVIH2->bmiHeader.biBitCount )
        {
            return FALSE;
        }
        // !!! do a non-case-sensitive compare
        //
        if( pVIH1->bmiHeader.biCompression != pVIH2->bmiHeader.biCompression )
        {
            return FALSE;
        }
        
        // compare frame rates
        //
        if( pVIH1->AvgTimePerFrame == 0 )
        {
            if( pVIH2->AvgTimePerFrame != 0 )
            {
		// !!! This assumes any file that doesn't know its frame rate
		// is acceptable without recompressing!
		// MediaPad can't do smart recompression with ASF sources
		// without this - WM files don't know their frame rate.
		// But using ASF sources to write an AVI file with Smart
		// recompression will make an out of sync file because I'm
		// not returning FALSE!
                return TRUE;
            }
        }
        // !!! accept frame rate <1% different?
        else
        {
            REFERENCE_TIME Percent = ( pVIH1->AvgTimePerFrame - pVIH2->AvgTimePerFrame ) * 100 / ( pVIH1->AvgTimePerFrame );
            if( Percent > 1 || Percent < -1)
            {
                return FALSE;
            }
        }

        // compare bit rates - !!! if they didn't give us a bit rate to insist upon, don't reject any source
        //
        if( pVIH2->dwBitRate == 0 )
        {
            // do nothing la la la
        }
        // !!! accept data rate <5% too high?
        else
        {
            int Percent = (int)(((LONGLONG)pVIH1->dwBitRate - pVIH2->dwBitRate)
					* 100 / pVIH2->dwBitRate);
            if( Percent > 5 )
            {
                return FALSE;
            }
        }
    }
    else if( pType1->formattype == FORMAT_WaveFormatEx )
    {
        WAVEFORMATEX * pFormat1 = (WAVEFORMATEX*) pType1->pbFormat;
        WAVEFORMATEX * pFormat2 = (WAVEFORMATEX*) pTypeNeeded->pbFormat;

        if( pFormat1->wFormatTag != pFormat2->wFormatTag )
        {
            return FALSE;
        }
        if( pFormat1->nChannels != pFormat2->nChannels )
        {
            return FALSE;
        }
        if( pFormat1->nSamplesPerSec != pFormat2->nSamplesPerSec )
        {
            return FALSE;
        }
        if( pFormat1->nAvgBytesPerSec != pFormat2->nAvgBytesPerSec )
        {
            return FALSE;
        }
        if( pFormat1->wBitsPerSample != pFormat2->wBitsPerSample )
        {
            return FALSE;
        }
        if( pFormat1->cbSize != pFormat2->cbSize )
        {
            return FALSE;
        }

        // if there's a size, then compare the compression blocks
        //
        if( pFormat1->cbSize )
        {
            char * pExtra1 = ((char*) pFormat1) + pFormat1->cbSize;
            char * pExtra2 = ((char*) pFormat2) + pFormat2->cbSize;
            if( memcmp( pExtra1, pExtra2, pFormat1->cbSize ) != 0 )
            {
                return FALSE;
            }
        }
    }
    else
    {
        return FALSE;
    }

    return TRUE;
}

long GetPinCount( IBaseFilter * pFilter, PIN_DIRECTION pindir )
{
    CheckPointer( pFilter, E_POINTER );

    CComPtr< IEnumPins > pEnumPins;
    pFilter->EnumPins( &pEnumPins );
    if( !pEnumPins )
    {
        return 0;
    }

    long Count = 0;

    while( 1 )
    {
        ULONG Fetched = 0;
        CComPtr< IPin > pPin;
        pEnumPins->Next( 1, &pPin, &Fetched );
        if( !Fetched )
        {
            return Count;
        }
        PIN_INFO PinInfo;
        memset( &PinInfo, 0, sizeof( PinInfo ) );
        pPin->QueryPinInfo( &PinInfo );
        if( PinInfo.pFilter ) PinInfo.pFilter->Release( );
        if( PinInfo.dir == pindir )
        {
            Count++;
        }
    }
}

BOOL DoesPinHaveMajorType( IPin * pPin, GUID MajorType )
{
    if( !pPin ) return FALSE;

    HRESULT hr;

    AM_MEDIA_TYPE MediaType;
    memset( &MediaType, 0, sizeof( MediaType ) );
    hr = pPin->ConnectionMediaType( &MediaType );
    GUID FoundType = MediaType.majortype;
    FreeMediaType( MediaType );
    if( FoundType == MajorType ) return TRUE;
    return FALSE;
}

// the passed in pin should be an input pin for a filter, not an output pin
//
HRESULT FindFirstPinWithMediaType( IPin ** ppPin, IPin * pEndPin, GUID MajorType )
{
    CheckPointer( ppPin, E_POINTER );
    CheckPointer( pEndPin, E_POINTER );

    *ppPin = NULL;

    HRESULT hr;

    // find the pin the end pin is connected to
    //
    CComPtr< IPin > pOutPin;
    hr = pEndPin->ConnectedTo( &pOutPin );
    if( FAILED( hr ) )
    {
        return hr;
    }

    // travel upstream until we come to a filter whose input pin is not the
    // same type as the output pin. When this happens, we will have found
    // a splitter or a source filter which provides the media type we're looking
    // for. We'll return that pin
    //
    while( 1 )
    {
        IBaseFilter * pFilter = GetFilterFromPin( pOutPin );
        IPin * pInPin = GetInPin( pFilter, 0 );

        // if the filter doesn't have an input pin, it must be the
        // source filter
        //
        if( !pInPin )
        {
            // the output pin should already match the media type
            // we're looking for, since we traveled upstream to get
            // it
            //
            *ppPin = pOutPin;
            (*ppPin)->AddRef( );
            return NOERROR;
        }

        // does the input pin's type match? If not, we're done
        //
        if( !DoesPinHaveMajorType( pInPin, MajorType ) )
        {
            *ppPin = pOutPin;
            (*ppPin)->AddRef( );
            return NOERROR;
        }

        // they both match, travel upstream to find the next one
        //
        pOutPin.Release( );
        pInPin->ConnectedTo( &pOutPin );
        if( !pOutPin )
        {
            return NOERROR;
        }
    }

    // never gets here
}

HRESULT CheckGraph( IGraphBuilder * pGraph )
{
    USES_CONVERSION;

    if( pGraph )
    {
        CComPtr< IEnumFilters > pEnumFilters;
        pGraph->EnumFilters( &pEnumFilters );
        if( pEnumFilters )
        {
            while( 1 )
            {
                CComPtr< IBaseFilter > pFilter;
                ULONG Fetched = 0;
                pEnumFilters->Next( 1, &pFilter, &Fetched );
                if( !Fetched )
                {
                    break;
                }

                FILTER_INFO fi;
                pFilter->QueryFilterInfo( &fi );
                if( fi.pGraph ) fi.pGraph->Release( );

                TCHAR * t = W2T( fi.achName );
                DbgLog( ( LOG_TRACE, 2, "Checking filter %s", t ) );

                if( fi.pGraph != pGraph )
                {
                    DbgLog( ( LOG_TRACE, 2, "CheckGraph has BAD filter %s", t ) );
                    ASSERT( 0 );
                }

                // check all the pins for this filter
                //
                CComPtr< IEnumPins > pEnumPins;
                pFilter->EnumPins( &pEnumPins );
                while( 1 )
                {
                    CComPtr< IPin > pPin;
                    Fetched = 0;
                    pEnumPins->Next( 1, &pPin, &Fetched );
                    if( !Fetched )
                    {
                        break;
                    }

                    PIN_INFO pi;
                    pPin->QueryPinInfo( &pi );
                    if( pi.pFilter ) pi.pFilter->Release( );

                    CComPtr< IPin > pConnected;
                    pPin->ConnectedTo( &pConnected );
                    if( pConnected )
                    {
                        PIN_INFO pi2;
                        pConnected->QueryPinInfo( &pi2 );
                        if( pi2.pFilter ) pi2.pFilter->Release( );

                        IBaseFilter * s = pi2.pFilter;
                        while( s )
                        {
                            s->QueryFilterInfo( &fi );
                            if( fi.pGraph ) fi.pGraph->Release( );

                            TCHAR * t = W2T( fi.achName );
//                            DbgLog( ( LOG_TRACE, 2, "Checking linked filter %s", t ) );

                            if( fi.pGraph != pGraph )
                            {
                                DbgLog( ( LOG_TRACE, 2, "CheckGraph has BAD filter %s", t ) );
                                ASSERT( 0 );
                            }

                            if( pi2.dir == PINDIR_OUTPUT )
                            {
                                s = GetNextUpstreamFilter( s );
                            }
                            else
                            {
                                s = GetNextDownstreamFilter( s );
                            }
                        }
                    }
                }
            } // while filters
        } // if enum filters
    } // if pGraph

    return NOERROR;
}


// Disconnect the pin that is still attached to the switch.  Downstream of
// pSource will be a splitter with both branches connected, only one of which
// is still attached to a switch (the one of media type pmt).  Disconnect that
// one.
//
HRESULT DisconnectExtraAppendage(IBaseFilter *pSource, GUID *pmt, IBaseFilter *pSwitch, IBaseFilter **ppDanglyBit)
{
    CheckPointer(pSource, E_POINTER);
    CheckPointer(pmt, E_POINTER);
    CheckPointer(pSwitch, E_POINTER);
    CheckPointer(ppDanglyBit, E_POINTER);
    *ppDanglyBit = NULL;

    CComPtr<IPin> pSwitchIn;
    CComPtr<IPin> pCon;

    while (pSource && pSource != pSwitch) {

        CComPtr <IEnumPins> pEnumPins;
        pSource->EnumPins(&pEnumPins);
        if (!pEnumPins) {
            return E_FAIL;
        }
	pSource = NULL;

        // look at every pin on the current filter...
        //
        ULONG Fetched = 0;
        while (1) {
            CComPtr <IPin> pPin;
    	    CComPtr<IPin> pPinIn;
            Fetched = 0;
            pEnumPins->Next(1, &pPin, &Fetched);
            if (!Fetched) {
                break;
            }
	    PIN_INFO pi;
	    pPin->QueryPinInfo(&pi);
	    if (pi.pFilter) pi.pFilter->Release();
            if( pi.dir == PINDIR_INPUT )
            {
                continue;
            } else {
                pPin->ConnectedTo(&pPinIn);
		if (pPinIn) {
                    PIN_INFO pi;
                    pPinIn->QueryPinInfo(&pi);
                    if (pi.pFilter) pi.pFilter->Release();
                    pSource = pi.pFilter;	// we'll continue down from here
						// unless it's the wrong split
						// pin
		    if (pSource == pSwitch) {
			pSwitchIn = pPinIn;
			pCon = pPin;
		        break;
                    }
		}
                CComPtr<IEnumMediaTypes> pMediaEnum;
                pPin->EnumMediaTypes(&pMediaEnum);
                if (pMediaEnum && pPinIn) {
                    Fetched = 0;
                    AM_MEDIA_TYPE *pMediaType;
                    pMediaEnum->Next(1, &pMediaType, &Fetched);
                    if (Fetched) {
                        if (pMediaType->majortype == *pmt) {
                            DeleteMediaType(pMediaType);
			    // return the head of the dangly chain
			    *ppDanglyBit = GetFilterFromPin(pPinIn);
                            //pSplitPin = pPin;
			    // This is where to continue downstream from
			    break;
			}
                        DeleteMediaType(pMediaType);
		    }
		}
	    }
	}

	// continue downstream
    }

    // we never did find an appropriate splitter pin and switch input pin
    if (pCon == NULL || pSwitchIn == NULL) {
	return S_OK;
    }

    //
    // now disconnect
    //
    HRESULT hr = pSwitchIn->Disconnect();
    hr = pCon->Disconnect();
    return hr;
}


// Look upstream from pPinIn for a splitter with an output pin that supports
// type "guid".  Return that pin, non-addrefed.  It may already be connected,
// that's OK. AND GET THE RIGHT STREAM #!  If we don't get the correct split
// pin for the stream # desired right now, our caching dangly bit logic
// won't work!
//
IPin * FindOtherSplitterPin(IPin *pPinIn, GUID guid, int nStream)
{
    DbgLog((LOG_TRACE,1,TEXT("FindOtherSplitterPin")));

    CComPtr< IPin > pPinOut;
    pPinOut = pPinIn;

    while (pPinOut) {
        PIN_INFO ThisPinInfo;
        pPinOut->QueryPinInfo( &ThisPinInfo );
        if( ThisPinInfo.pFilter ) ThisPinInfo.pFilter->Release( );

	pPinOut = NULL;
        CComPtr< IEnumPins > pEnumPins;
        ThisPinInfo.pFilter->EnumPins( &pEnumPins );
        if( !pEnumPins )
        {
            return NULL;
        }

        // look at every pin on the current filter...
        //
        ULONG Fetched = 0;
        while (1) {
            CComPtr< IPin > pPin;
            Fetched = 0;
            ASSERT( !pPin ); // is it out of scope?
            pEnumPins->Next( 1, &pPin, &Fetched );
            if( !Fetched )
            {
                break;
            }

            PIN_INFO pi;
            pPin->QueryPinInfo( &pi );
            if( pi.pFilter ) pi.pFilter->Release( );

            // if it's an input pin...
            //
            if( pi.dir == PINDIR_INPUT )
            {
                // continue searching upstream from this pin
                //
                pPin->ConnectedTo(&pPinOut);

	    // a pin that supports the required media type is the
	    // splitter pin we are looking for!  We are done
	    //
            } else {
            	    CComPtr< IEnumMediaTypes > pMediaEnum;
            	    pPin->EnumMediaTypes(&pMediaEnum);
            	    if (pMediaEnum) {
            		Fetched = 0;
			AM_MEDIA_TYPE *pMediaType;
            		pMediaEnum->Next(1, &pMediaType, &Fetched);
            		if (Fetched) {
			    if (pMediaType->majortype == guid) {
				if (nStream-- == 0) {
            			    DeleteMediaType(pMediaType);
    		    		    DbgLog((LOG_TRACE,1,TEXT("Found SPLIT pin")));
		    		    return pPin;
				}
			    }
            		    DeleteMediaType( pMediaType );
			}
		    }
	    }

            // go try the next pin
            
        } // while
    }
    // file doesn't contain any video/audio that is wanted ASSERT(FALSE);
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\util\filfuncs.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>

// NONE of these functions will addref the returned pointers! ! ! !
IPin * GetInPin( IBaseFilter * pFilter, int PinNum );
IPin * GetOutPin( IBaseFilter * pFilter, int PinNum );
IPin * GetOutPinNotOfType( IBaseFilter * pFilter, int PinNum, GUID* );
long GetPinCount( IBaseFilter * pFilter, PIN_DIRECTION pindir );
void RemoveChain( IPin * pPin1, IPin * pPin2 );
IBaseFilter * GetStartFilterOfChain( IPin * pPin );
IBaseFilter * GetStopFilterOfChain( IPin * pPin );
IBaseFilter * GetNextDownstreamFilter( IBaseFilter * pFilter );
IBaseFilter * GetNextUpstreamFilter( IBaseFilter * pFilter );
BOOL IsInputPin( IPin * pPin );
HRESULT StartUpstreamFromPin(IPin *pPinIn, BOOL fRun, BOOL fHeadToo);
HRESULT StartUpstreamFromFilter(IBaseFilter *pf, BOOL fRun, BOOL fHeadToo, REFERENCE_TIME RunTime = 0 );
HRESULT StopUpstreamFromPin(IPin *pPinIn, BOOL fPause, BOOL fHeadToo);
HRESULT StopUpstreamFromFilter(IBaseFilter *pf, BOOL fPause, BOOL fHeadToo);
HRESULT RemoveUpstreamFromPin(IPin *pPinIn);
HRESULT RemoveDownstreamFromPin(IPin *pPinIn);
HRESULT RemoveUpstreamFromFilter(IBaseFilter *pf);
HRESULT RemoveDownstreamFromFilter(IBaseFilter *pf);
HRESULT WipeOutGraph( IGraphBuilder * pGraph );
HRESULT CheckGraph( IGraphBuilder * pGraph );
HRESULT ReconnectToDifferentSourcePin(IGraphBuilder *pGraph,
                                      IBaseFilter *pUnkFilter, 
                                      long StreamNumber, 
                                      const GUID *pGuid );
long    GetFilterGenID( IBaseFilter * pFilter );
void GetFilterName( long UniqueID, WCHAR * pSuffix, WCHAR * pNameToWriteTo, long SizeOfString );
IBaseFilter * FindFilterWithInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface );
IUnknown * FindPinInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface );
HRESULT DisconnectFilters( IBaseFilter * p1, IBaseFilter * p2 );
HRESULT DisconnectFilter( IBaseFilter * p1 );
void * FindInterfaceUpstream( IBaseFilter * pFilter, const GUID * pInterface );
IBaseFilter * GetFilterFromPin( IPin * pPin );
IFilterGraph * GetFilterGraphFromPin( IPin * pPin );
IFilterGraph * GetFilterGraphFromFilter( IBaseFilter * );
HRESULT FindMediaTypeInChain( 
                             IBaseFilter * pSource, 
                             AM_MEDIA_TYPE * pFindMediaType, 
                             long StreamNumber );

BOOL AreMediaTypesCompatible( AM_MEDIA_TYPE * pType1, AM_MEDIA_TYPE * pType2 );

HRESULT FindFirstPinWithMediaType( IPin ** ppPin, IPin * pEndPin, GUID MajorType );

BOOL DoesPinHaveMajorType( IPin * pPin, GUID MajorType );
HRESULT FindCompressor( AM_MEDIA_TYPE * pType, 
                        AM_MEDIA_TYPE * pCompType, 
                        IBaseFilter ** ppCompressor, 
                        IServiceProvider * pKeyProvider = NULL );
HRESULT DisconnectExtraAppendage(IBaseFilter *, GUID *, IBaseFilter *, IBaseFilter **);
IPin * FindOtherSplitterPin(IPin *pPinIn, GUID guid, int StreamNumber );

class DbgTimer
{
#ifdef DEBUG
    char m_Text[256];
    long m_Level;
    long m_StartTime;
#endif
    
public:

    DbgTimer( char * pText, long Level = 1 )
    {
#ifdef DEBUG
        strcpy( m_Text, "DEXTIME:" );
        strcat( m_Text, pText );
        strcat( m_Text, " = %ld ms" );
        m_Level = Level;
        m_StartTime = timeGetTime( );
#endif
    };
    ~DbgTimer( )
    {
#ifdef DEBUG
        DbgLog( ( LOG_TIMING, m_Level, m_Text, timeGetTime( ) - m_StartTime ) );
//#else
//        char temp[256];
//        wsprintf(temp, m_Text, timeGetTime( ) - m_StartTime);
//       strcat(temp, "\r\n");
//        OutputDebugString(temp);
#endif
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\xml2dex.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// Xml2Dex.cpp : Implementation of CXml2Dex
#include <streams.h>
#include <qeditint.h>
#include <qedit.h>
#include "xmltl.h"
#include "Xml2Dex.h"

#ifdef FILTER_DLL
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Xml2Dex, CXml2Dex)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XMLPRSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}

int g_cTemplates = 0;
CFactoryTemplate g_Templates[1];
#endif

/////////////////////////////////////////////////////////////////////////////
// CXml2Dex


#if 0
STDMETHODIMP CXml2Dex::CreateTimeline(IUnknown **ppTimelineUnk)
{
    HRESULT hr = 0;

    // create the timeline
    //
    CComPtr< IAMTimeline > pTimeline;
    hr = CoCreateInstance(
        __uuidof(AMTimeline),
        NULL,
        CLSCTX_INPROC_SERVER,
        __uuidof(IAMTimeline),
        (void**) &pTimeline
    );

    if (FAILED(hr))
    {
        return hr;
    }

    // create the first composite node for the timeline
    //
    CComPtr< IAMTimelineObj > pRootComp;
    hr = pTimeline->CreateEmptyNode(&pRootComp, TIMELINE_MID_TYPE_GROUP);
            CComQIPtr< IAMTimelineGroup, &IID_IAMTimelineGroup > pRootGroup( pRootComp );
            CMediaType GroupMediaType;
            GroupMediaType.SetType( &MEDIATYPE_Video );
            pRootGroup->SetMediaType( &GroupMediaType );

    // tell the timeline who it's composite node is
    //
    hr = pTimeline->AddGroup(pRootComp);
    pRootComp.Release( );

    *ppTimelineUnk = pTimeline;
    (*ppTimelineUnk)->AddRef( );

    return S_OK;
}
#endif

STDMETHODIMP CXml2Dex::ReadXMLFile(IUnknown * pTimelineUnk, BSTR Filename)
{
    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(Filename, E_POINTER);

    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    HRESULT hr = BuildFromXMLFile( pTimeline, Filename );

    return hr;
}

STDMETHODIMP CXml2Dex::ReadXML(IUnknown * pTimelineUnk, IUnknown *pxmlunk)
{
    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(pxmlunk, E_POINTER);

    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );
    CComQIPtr< IXMLDOMElement, &_uuidof(IXMLDOMElement) > pxml( pxmlunk );

    HRESULT hr = BuildFromXML( pTimeline, pxml );

    return hr;
}

STDMETHODIMP CXml2Dex::Delete(IUnknown *pTimelineUnk, double Start, double End)
{
    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    HRESULT hr = InsertDeleteTLSection(pTimeline,
                                       (REFERENCE_TIME) (Start * UNITS),
                                       (REFERENCE_TIME) (End * UNITS),
                                       TRUE); // delete

    return hr;
}

STDMETHODIMP CXml2Dex::CreateGraphFromFile(IUnknown **ppGraph, IUnknown * pTimelineUnk, BSTR Filename)
{
    HRESULT hr = 0;

    CComQIPtr< IAMTimeline, &_uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    hr = BuildFromXMLFile( pTimeline, Filename );

    // create a render engine
    //
    hr = CoCreateInstance(
        __uuidof(RenderEngine),
        NULL,
        CLSCTX_INPROC_SERVER,
        __uuidof(IRenderEngine),
        (void**) &m_pRenderEngine
    );

    if (FAILED(hr))
    {
        return hr;
    }

    hr = m_pRenderEngine->SetTimelineObject( pTimeline );

    hr = m_pRenderEngine->ConnectFrontEnd( );
    hr |= m_pRenderEngine->RenderOutputPins( );


    CComPtr< IGraphBuilder > pGraphTemp;
    hr = m_pRenderEngine->GetFilterGraph( &pGraphTemp );
    *ppGraph = (IUnknown*) pGraphTemp;
    (*ppGraph)->AddRef( );

    return S_OK;
}

#if 0
STDMETHODIMP CXml2Dex::DiscardTimeline(IUnknown *pTimelineUnk)
{
}
#endif

EXTERN_GUID(IID_IXMLGraphBuilder,
0x1bb05960, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

interface IXMLGraphBuilder : IUnknown
{
    STDMETHOD(BuildFromXML) (IGraphBuilder *pGraph, IXMLDOMElement *pxml) = 0;
    STDMETHOD(SaveToXML) (IGraphBuilder *pGraph, BSTR *pbstrxml) = 0;
    STDMETHOD(BuildFromXMLFile) (IGraphBuilder *pGraph, WCHAR *wszFileName, WCHAR *wszBaseURL) = 0;
};

// CLSID_XMLGraphBuilder
// {1BB05961-5FBF-11d2-A521-44DF07C10000}
EXTERN_GUID(CLSID_XMLGraphBuilder,
0x1bb05961, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);


STDMETHODIMP CXml2Dex::WriteGrfFile(IUnknown *pGraphUnk, BSTR FileName)
{
    CheckPointer(pGraphUnk, E_POINTER);
    CheckPointer(FileName, E_POINTER);

    HRESULT hr = E_INVALIDARG;

    CComQIPtr< IGraphBuilder, &_uuidof(IGraphBuilder) > pGraph( pGraphUnk );
    if (pGraph == NULL)
        return E_INVALIDARG;

    if (!DexCompareW(FileName + lstrlenW(FileName) - 3, L"grf")) {
        CComPtr< IStorage > pStg;
        hr = StgCreateDocfile
        (
            FileName,
            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
            0, // reserved
            &pStg
        );

        if (SUCCEEDED(hr)) {
            CComPtr< IStream > pStream;
            hr = pStg->CreateStream
            (
                L"ActiveMovieGraph",
                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                NULL,
                NULL,
                &pStream
            );
            if (SUCCEEDED(hr)) {
                CComQIPtr< IPersistStream, &IID_IPersistStream > pPersist( pGraph );
                if (pPersist) {
                    hr = pPersist->Save( pStream, FALSE );
                } else {
                    hr = E_INVALIDARG;
                }

                if (SUCCEEDED(hr)) {
                    hr = pStg->Commit( STGC_DEFAULT );
                }
            }
        }
    } else if (!DexCompareW(FileName + lstrlenW(FileName) - 3, L"xgr")) {
        USES_CONVERSION;

        TCHAR * tFileName = W2T( FileName );
        HANDLE hFile = CreateFile(tFileName, GENERIC_WRITE, FILE_SHARE_READ,
                                NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (hFile != INVALID_HANDLE_VALUE) {
            IXMLGraphBuilder *pxmlgb;
            HRESULT hr = CoCreateInstance(CLSID_XMLGraphBuilder, NULL, CLSCTX_INPROC_SERVER,
                                          IID_IXMLGraphBuilder, (void**)&pxmlgb);

            if (SUCCEEDED(hr)) {
                BSTR bstrXML;
                hr = pxmlgb->SaveToXML(pGraph, &bstrXML);

                if (SUCCEEDED(hr)) {
                    DWORD cbToWrite = SysStringLen(bstrXML) * 2 + 1;
                    char *pszXML = new char[cbToWrite];

                    if (pszXML) {
                        WideCharToMultiByte(CP_ACP, 0,
                                            bstrXML, -1,
                                            pszXML, cbToWrite,
                                            NULL, NULL);
                        cbToWrite = lstrlenA(pszXML);

                        DWORD cbWritten;
                        if (!WriteFile(hFile, pszXML, cbToWrite, &cbWritten, NULL) ||
                            (cbWritten != cbToWrite)) {

                            hr = E_FAIL;
                        }

                        delete[] pszXML;
                    }

                    SysFreeString(bstrXML);
                }
                pxmlgb->Release();
            }
            CloseHandle(hFile);
        }
    } else {
        // !!!
        ASSERT(!"filename should have ended in .xgr or .grf!");
    }

    return hr;
}

STDMETHODIMP CXml2Dex::WriteXMLFile(IUnknown * pTimelineUnk, BSTR FileName)
{
    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(FileName, E_POINTER);

    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    return SaveTimelineToXMLFile(pTimeline, FileName);
}


STDMETHODIMP CXml2Dex::WriteXMLPart(IUnknown * pTimelineUnk, double dStart, double dEnd, BSTR FileName)
{
    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    return SavePartialToXMLFile(pTimeline,
                                (REFERENCE_TIME) (dStart * UNITS),
                                (REFERENCE_TIME) (dEnd * UNITS),
                                FileName);
}

STDMETHODIMP CXml2Dex::PasteXMLFile(IUnknown * pTimelineUnk, double dStart, BSTR FileName)
{
    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    return PasteFromXMLFile(pTimeline,
                            (REFERENCE_TIME) (dStart * UNITS),
                            FileName);
}

STDMETHODIMP CXml2Dex::CopyXML(IUnknown * pTimelineUnk, double dStart, double dEnd)
{
    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    HGLOBAL h;
    HRESULT hr = SavePartialToXMLString(pTimeline,
                                        (REFERENCE_TIME) (dStart * UNITS),
                                        (REFERENCE_TIME) (dEnd * UNITS),
                                        &h);

    if (SUCCEEDED(hr)) {
        if (OpenClipboard(NULL)) {
            SetClipboardData(CF_TEXT, h);
            CloseClipboard();
        } else
            hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CXml2Dex::PasteXML(IUnknown * pTimelineUnk, double dStart)
{
    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    if (!OpenClipboard(NULL))
        return E_FAIL;

    HGLOBAL h = GetClipboardData(CF_TEXT);

    if (!h) {
        CloseClipboard();
        return E_FAIL;
    }
#if 0
    char *p1 = (char *) GlobalLock(h);

    // !!! we shouldn't need to do this, but the handle I get
    // back from the clipboard is funny somehow.
    // also, this lets us close the clipboard before
    // actually doing the work, which is perhaps a good thing.
    DWORD cbSize = lstrlenA(p1);
    HGLOBAL h2 = GlobalAlloc(GHND, cbSize);
    char *p2 = (char *) GlobalLock(h2);
    memcpy(p2, p1, cbSize);

    CloseClipboard();
    HRESULT hr = PasteFromXML(pTimeline,
                             (REFERENCE_TIME) (dStart * UNITS),
                             h2);
#else
    HRESULT hr = PasteFromXML(pTimeline,
                             (REFERENCE_TIME) (dStart * UNITS),
                             h);
    CloseClipboard();
#endif

    return hr;
}

STDMETHODIMP CXml2Dex::Reset( )
{
    HRESULT hr = 0;

    if( !m_pRenderEngine )
    {
        return NOERROR;
    }

    m_pRenderEngine->ScrapIt( );
    m_pRenderEngine.Release( );
    m_pRenderEngine = NULL;

    return NOERROR;
}

STDMETHODIMP CXml2Dex::WriteXML(IUnknown * pTimelineUnk, BSTR *pbstrXML)
{
    CheckPointer(pTimelineUnk, E_POINTER);
    CheckPointer(pbstrXML, E_POINTER);

    CComQIPtr< IAMTimeline, &__uuidof(IAMTimeline) > pTimeline( pTimelineUnk );

    return SaveTimelineToXMLString(pTimeline, pbstrXML);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\xtlload.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// CLSID_XTLLoader
// {1BB05981-5FBF-11d2-A521-44DF07C10000}
EXTERN_GUID(CLSID_XTLLoader, 
0x1bb05981, 0x5fbf, 0x11d2, 0xa5, 0x21, 0x44, 0xdf, 0x7, 0xc1, 0x0, 0x0);

extern const AMOVIESETUP_FILTER sudXTLLoader;

CUnknown *CreateXTLLoaderInstance(LPUNKNOWN, HRESULT *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\xmltl.cpp ===
// different tag names, a bit like listing the verbs in Zork!
//
// at
// atrack
// bitdepth
// buffering
// clip
// clsid
// composite
// cutpoint
// cutsonly
// daclip
// defaultfx
// defaulttrans
// duration
// effect
// enabletrans
// enablefx
// framerate
// group
// height
// linear
// lock
// mlength
// mstart
// mstop
// mute
// name
// param
// previewmode
// samplingrate
// src
// start
// stop
// stream
// stretchmode
// swapinputs
// time
// timeline
// tlstart
// tlstop
// track
// transition
// type
// userdata
// userid
// username
// value
// vtrack
// width
//

// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// !!! I could be nice and log a detailed error about syntax errors in the XML

//      output="foo.avi" (default is preview) (not yet implemented)
//
// <group>
//      name="Project X" (Switch will get this name)
//      framerate="15.0"         !!! anything with more than seven decimal
//				 digits won't work! (overflow)
//      previewmode="1"	allow drop frames
//      buffering="30"	for video groups, # of frames
//      type="Video"
//              width="320"
//              height="320"
//              bitdepth="16" (or 24 or 32)
//      type="Audio"
//              samplingrate="44100"
//
// (any of the below objects can have:
//	start="0", in seconds
//	stop="5", in seconds
//	clsid="{xxxx-..}"
//	mute="0" (FALSE)
//	lock="0" (FALSE)
//	userid="0"
//	username="Blah"
//      userdata="xxxxxxxxxxx" (hex encoded binary)
//
//
// <composite>
// <track>
//
// <clip>
//      src="file" (given to the source filter)
//      stream="0"	stream number of that type, 0 based
//      mstart= "time"
//      mstop= "time" (optional)
//      framerate= "0" (used only for dib sequences... what is its fps? The
//		        default, 0, means to disable dib seq (use only that 1
//		 	file), so to enable dib sequences, you must set this
//			parameter)
//      !!! anything more than seven decimal digits won't work! (overflow)
//      stretchmode= "Stretch" (Stretch, Crop, PreserveAspectRatio or PreserveAspectRatioNoLetterbox)
//      clsid= "clsid" (optional specific src filter to use - not used if
//                       "category" or "instance" are specified)
//      category = "clsid" (optional - default is "DShow Filters" category)
//      instance = "friendly name" (optional - looks in "category" for it)
//
// <effect>
//      clsid=""
//
// <transition>
//      clsid=""
//      swapinputs="0"
//      cutpoint="time"
//      cutsonly="0"
//
//  Effects and transitions can have a <param> sub tag, to specify parameters
//  you can set on that DirectXTransform.  Most transitions support "progress",
//  to specify how much of A vs. B you want to see.  Most other possible
//  parameters are transform specific.
//
//
//  Our SMPTE wipe DXT that is part of Dexter supports the following parameters:
//  (more information needs to be written about this)
//
//  "MaskName" - if not NULL, use this JPEG as the wipe instead of a standard
//               SMPTE wipe
//  "MaskNum" - which SMPTE wipe # to use (see TedWi for chart of wipes)
//  "ScaleX" - stretch the shape of the wipe
//   "ScaleY" - stretch the shape of the wipe
//  "OffsetX" - have the transform start off centre
//  "OffsetY" - have the transform start off centre
//  "ReplicateX" - duplicate the shape this many times horizontally
//  "ReplicateY" - duplicate the shape this many times vertically
//  "BorderColor" - colour of border between A and B
//  "BorderWidth" - width of border between A and B
//  "BorderSoftness" - additional width to be blurry
//
//  The value of the parameter can change over time, jumping to a new value at
//  a new time, or interpolating from the last point to a new value at a new
//  point.  Here's a wacky example of a wipe effect that flies around wildly
//  instead of going linearly from left to right as it would have done by
//  default:
//  NOTE: All parameter times are relative to the start of the effect
//  or transition, and are zero based!
//
//<transition clsid="{AF279B30-86EB-11D1-81BF-0000F87557DB}" start="2" stop="9">
//                <param name="progress" value="0.0">
//                       <at time="1" value="0.5"/>
//                        <at time="2" value="1.0"/>
//                        <linear time="5" value="0.0"/>
//                        <linear time="6" value="1.0"/>
//                        <linear time="6.5" value="0.0"/>
//                        <linear time="7.0" value="1.0"/>
//                </param>
//</transition>
//
//  This example runs the progress backwards... eg.  a left to right wipe
//  becomes a right to left wipe, starting with all new video and wiping back
//  to old video:
//
//<transition clsid="{AF279B30-86EB-11D1-81BF-0000F87557DB}" start="2" stop="8">
//                <param name="progress" value="1.0">
//                       <linear time="6" value="0"/>
//                </param>
//</transition>
//
//  The first value on the same line as the parameter name is the value at time
//  0, and will always be the value unless other values are specified as
//  sub tags underneath it.  "Progress" is a parameter that you will likely
//  want to vary over time.  The SMPTE DXT parameters are not...
//  you would simply say:
//
//<transition clsid="{dE75D012-7A65-11D2-8CEA-00A0C9441E20}" start="2" stop="4">
//            <param name="MaskNum" value="107"/>
//             <param name="BorderWidth" value="3"/>
//</transition>
//
//  The above example uses the clsid of the SMPTE DXT.  By default is does a
//  left to right wipe with no border.
//
//  Here's a fun example:  A 2x3 matrix of tall skinny hearts with the border
//  colour changing dynamically!!!
//
//<transition clsid="{dE75D012-7A65-11D2-8CEA-00A0C9441E20}" start="2" stop="4">
//    	    <param name="MaskNum" value="130"/>
//    	    <param name="ScaleY" value="3"/>
//    	    <param name="ReplicateX" value="2"/>
//    	    <param name="ReplicateY" value="3"/>
//    	    <param name="BorderColor" value="65280">
//		<at time=".5" value="16711680"/>
//		<at time="1" value="255"/>
//		<at time="1.5" value="65535"/>
//	    </param>
//    	    <param name="BorderWidth" value="5"/>
//    	    <param name="BorderSoftness" value="5"/>
//</transition>
//
//
//  Using parameters with the audio mixer filter is how you change the volume
//  of an audio clip, track, composite, or group.  Use the clsid of the
//  Audio Mixer filter (CLSID_AudMixer) and use the parameter name "vol".
//  BE CAREFUL using values > 1 to increase the volume, you will probably clip
//  the audio and distort the sound.  Only decreasing the volume is recommended.
//
//  This example sets the volume of an object to 1/2 volume
//
//  <!-- this effect can be on a clip, track, composite or group-->
//  <effect clsid="{036A9790-C153-11d2-9EF7-006008039E37}" start="0" stop="5">
//    	    <param name="vol" value=".5"/>
//  </effect>
//
//  This example fades the volume out
//
//  <effect clsid="{036A9790-C153-11d2-9EF7-006008039E37}" start="0" stop="5">
//    	    <param name="vol" value="1.0">
//    	        <at time="5" value="0"/>
//	    </param>
//  </effect>
//

#include <streams.h>
#include <atlbase.h>
#include <atlconv.h>
#include <msxml.h>
#include "xmldom.h"

#include "qeditint.h"
#include "qedit.h"

#include "xmltl.h"

// !!! Timeline hopefully thinks these are the defaults
DEFINE_GUID( DefaultTransition,
0x810E402F, 0x056B, 0x11D2, 0xA4, 0x84, 0x00, 0xC0, 0x4F, 0x8E, 0xFB, 0x69);
DEFINE_GUID( DefaultEffect,
0xF515306D, 0x0156, 0x11D2, 0x81, 0xEA, 0x00, 0x00, 0xF8, 0x75, 0x57, 0xDB);

#define DEF_BITDEPTH	16
#define DEF_WIDTH	320
#define DEF_HEIGHT	240
#define DEF_SAMPLERATE	44100

HRESULT _GenerateError(IAMTimeline * pTimeline,
                       long Severity,
                       LONG ErrorCode,
                       HRESULT hresult,
                       VARIANT * pExtraInfo = NULL)
{
    HRESULT hr = hresult;
    if( pTimeline )
    {
            CComQIPtr< IAMSetErrorLog, &IID_IAMSetErrorLog > pTimelineLog( pTimeline );
            if( pTimelineLog )
            {
                CComPtr< IAMErrorLog > pErrorLog;
                pTimelineLog->get_ErrorLog( &pErrorLog );
                if( pErrorLog )
                {
        	    TCHAR tBuffer[256];
        	    tBuffer[0] = 0;
        	    LoadString( g_hInst, ErrorCode, tBuffer, 256 );
        	    USES_CONVERSION;
        	    WCHAR * w = T2W( tBuffer );
		    if (hresult == E_OUTOFMEMORY)
                        hr = pErrorLog->LogError( Severity, L"Out of memory",
				DEX_IDS_OUTOFMEMORY, hresult, pExtraInfo);
		    else
                        hr = pErrorLog->LogError( Severity, w, ErrorCode,
							hresult, pExtraInfo);
                }
            }
    }

    return hr;
}

HRESULT BuildOneElement(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *p, REFERENCE_TIME rtOffset);

bool IsCommentElement(IXMLDOMNode *p);

HRESULT BuildChildren(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *pxml, REFERENCE_TIME rtOffset)
{
    HRESULT hr = S_OK;

    IXMLDOMNodeList *pcoll;

    CComQIPtr<IXMLDOMNode, &IID_IXMLDOMNode> pNode( pxml );

    hr = pNode->get_childNodes(&pcoll);
    ASSERT(hr == S_OK);

    if (hr != S_OK)
	return S_OK; // nothing to do, is this an error?

    long lChildren = 0;
    hr = pcoll->get_length(&lChildren);
    ASSERT(hr == S_OK);

    int lVal = 0;

    for (; SUCCEEDED(hr) && lVal < lChildren; lVal++) {
	IXMLDOMNode *pNode;
	hr = pcoll->get_item(lVal, &pNode);
	ASSERT(hr == S_OK);

	if (SUCCEEDED(hr) && pNode) {
	    IXMLDOMElement *pelem;
	    hr = pNode->QueryInterface(__uuidof(IXMLDOMElement), (void **) &pelem);
	    if (SUCCEEDED(hr)) {
		hr = BuildOneElement(pTL, pParent, pelem, rtOffset);

		pelem->Release();
	    } else {
                // just skip over comments.
                if(IsCommentElement(pNode)) {
                    hr = S_OK;
                }
            }
	    pNode->Release();
	}
    }

    pcoll->Release();

    return hr;
}	

HRESULT ReadObjStuff(IXMLDOMElement *p, IAMTimelineObj *pObj)
{
    HRESULT hr;

    REFERENCE_TIME rtStart = ReadTimeAttribute(p, L"start", -1); // tagg
    REFERENCE_TIME rtStop = ReadTimeAttribute(p, L"stop", -1); // tagg
    // caller will handle it if stop is missing
    if (rtStop != -1) {
        hr = pObj->SetStartStop(rtStart, rtStop);
	// group/comp/track will fail this
    }
    // backwards compatability
    if (rtStart == -1) {
        REFERENCE_TIME rtTLStart = ReadTimeAttribute(p, L"tlstart", -1); // tagg
        REFERENCE_TIME rtTLStop = ReadTimeAttribute(p, L"tlstop", -1); // tagg
        // caller will handle it if stop is missing
        if (rtTLStop != -1) {
            hr = pObj->SetStartStop(rtTLStart, rtTLStop);
	    ASSERT(SUCCEEDED(hr));
        }
    }

    BOOL fMute = ReadBoolAttribute(p, L"mute", FALSE); // tagg
    pObj->SetMuted(fMute);

    BOOL fLock = ReadBoolAttribute(p, L"lock", FALSE); // tagg
    pObj->SetLocked(fLock);

    long nUserID = ReadNumAttribute(p, L"userid", 0); // tagg
    pObj->SetUserID(nUserID);

    BSTR bstrName = FindAttribute(p, L"username"); // tagg
    pObj->SetUserName(bstrName);
    if (bstrName)
        SysFreeString(bstrName);

    BSTR bstrData = FindAttribute(p, L"userdata"); // tagg
    UINT size = 0;
    if (bstrData) {
	size = lstrlenW(bstrData);
    }
    if (size > 0) {
	BYTE *pData = (BYTE *)QzTaskMemAlloc(size / 2);
	if (pData == NULL) {
	    SysFreeString(bstrData);
	    return E_OUTOFMEMORY;
	}
	ZeroMemory(pData, size / 2);
	ASSERT((size % 2) == 0);
        for (UINT i = 0; i < size / 2; i++) {
	    WCHAR wch = bstrData[i * 2];
	    if (wch >= L'0' && wch <= L'9')
		pData[i] = (BYTE) (wch - L'0') * 16;
	    else if (wch >= L'A' && wch <= L'F')
		pData[i] = (BYTE) (wch - L'A' + 10) * 16;

	    wch = bstrData[i * 2 + 1];
	    if (wch >= L'0' && wch <= L'9')
		pData[i] += (BYTE) (wch - L'0');
	    else if (wch >= L'A' && wch <= L'F')
		pData[i] += (BYTE) (wch - L'A' + 10);
	}
        pObj->SetUserData(pData, size / 2);
	QzTaskMemFree(pData);
    }
    if (bstrData) {
	SysFreeString(bstrData);
    }

    CLSID guid;
    BSTR bstrCLSID = FindAttribute(p, L"clsid"); // tagg
    if (bstrCLSID) {
        hr = CLSIDFromString(bstrCLSID, &guid);
        hr = pObj->SetSubObjectGUID(guid);
        SysFreeString(bstrCLSID);
    }

    // !!! can't do SubObject
    // !!! category/instance will only save clsid

    return S_OK;
}


HRESULT BuildTrackOrComp(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *p,
                        TIMELINE_MAJOR_TYPE maj, REFERENCE_TIME rtOffset)
{
    HRESULT hr = S_OK;

    //ASSERT(pParent && "<track> must be in a <group> tag now!");
    if (!pParent) {
        DbgLog((LOG_ERROR,0,"ERROR: track must be in a GROUP tag"));
        return VFW_E_INVALID_FILE_FORMAT;
    }

    IAMTimelineComp *pParentComp;
    hr = pParent->QueryInterface(__uuidof(IAMTimelineComp), (void **) &pParentComp);
    if (SUCCEEDED(hr)) {
        IAMTimelineObj *pCompOrTrack = NULL;

        {
            hr = pTL->CreateEmptyNode(&pCompOrTrack, maj);
            if (SUCCEEDED(hr)) {
		hr = ReadObjStuff(p, pCompOrTrack);
                hr = pParentComp->VTrackInsBefore( pCompOrTrack, -1 );
            } else {
                DbgLog((LOG_ERROR,0,TEXT("ERROR:Failed to create empty track node")));
            }
	}

        if (SUCCEEDED(hr)) {
            hr = BuildChildren(pTL, pCompOrTrack, p, rtOffset);
        }

        if (pCompOrTrack)
            pCompOrTrack->Release();

        pParentComp->Release();
    } else {
        DbgLog((LOG_ERROR, 0, "ERROR: Track/composition can only be a child of a composition"));
    }

    return hr;
}

#include "varyprop.h"
HRESULT BuildElementProperties(IAMTimelineObj *pElem, IXMLDOMElement *p)
{
    IPropertySetter *pSetter;

    HRESULT hr = CreatePropertySetterInstanceFromXML(&pSetter, p);

    if (FAILED(hr))
        return hr;

    if (pSetter) {
        pElem->SetPropertySetter(pSetter);
        pSetter->Release();
    }

    return S_OK;
}

bool IsCommentElement(IXMLDOMNode *p)
{
    DOMNodeType Type;
    if(p->get_nodeType(&Type) == S_OK && Type == NODE_COMMENT) {
        return true;
    }

    // there was an error or it's not a comment
    return false;
}


HRESULT BuildOneElement(IAMTimeline *pTL, IAMTimelineObj *pParent, IXMLDOMElement *p, REFERENCE_TIME rtOffset)
{
    HRESULT hr = S_OK;

    BSTR bstrName;
    hr = p->get_tagName(&bstrName);

    if (FAILED(hr))
    {
        return hr;
    }

    // do the appropriate thing based on the current tag
 
    if (!DexCompareW(bstrName, L"group")) { // tagg

        if (pParent) {
            // group shouldn't have parent
	    SysFreeString(bstrName);
            return VFW_E_INVALID_FILE_FORMAT;
        }

        IAMTimelineObj *pGroupObj = NULL;

        BSTR bstrGName = FindAttribute(p, L"name"); // tagg
        if (bstrGName) {
            long cGroups;
            hr = pTL->GetGroupCount(&cGroups);
            if (SUCCEEDED(hr)) {
                for (long lGroup = 0; lGroup < cGroups; lGroup++) {
                    IAMTimelineObj *pExistingGroupObj;
                    hr = pTL->GetGroup(&pExistingGroupObj, lGroup);
                    if (FAILED(hr))
                        break;

                    IAMTimelineGroup *pGroup;
                    hr = pExistingGroupObj->QueryInterface(__uuidof(IAMTimelineGroup), (void **) &pGroup);

                    if (SUCCEEDED(hr)) {
                        BSTR wName;
                        hr = pGroup->GetGroupName(&wName);
                        pGroup->Release( );

                        if( FAILED( hr ) )
                            break;

                        long iiiii = DexCompareW(wName, bstrGName);
                        SysFreeString( wName );

                        if (iiiii == 0 ) {
                            pGroupObj = pExistingGroupObj;
                            break;
                        }
                    }
                    pExistingGroupObj->Release();
                }
            }
        }

        if (!pGroupObj) {
            hr = pTL->CreateEmptyNode(&pGroupObj, TIMELINE_MAJOR_TYPE_GROUP);
            if (FAILED(hr)) {
                SysFreeString(bstrName);
                return hr;
            }

            hr = ReadObjStuff(p, pGroupObj);

            BSTR bstrType = FindAttribute(p, L"type"); // tagg
            {

                // !!! can be confused by colons - only decimal supported
                REFERENCE_TIME llfps = ReadTimeAttribute(p, L"framerate", // tagg
                                                                15*UNITS);
                double fps = (double)llfps / UNITS;

                BOOL fPreviewMode = ReadBoolAttribute(p, L"previewmode", TRUE); // tagg
                long nBuffering = ReadNumAttribute(p, L"buffering", 30); // tagg

                CMediaType GroupMediaType;
                // !!! fill in more of the MediaType later
                if (bstrType && 
                        !DexCompareW(bstrType, L"audio")) {
                    long sr = ReadNumAttribute(p, L"samplingrate", // tagg
                                                        DEF_SAMPLERATE);
                    GroupMediaType.majortype = MEDIATYPE_Audio;
                    GroupMediaType.subtype = MEDIASUBTYPE_PCM;
                    GroupMediaType.formattype = FORMAT_WaveFormatEx;
                    GroupMediaType.AllocFormatBuffer(sizeof(WAVEFORMATEX));
                    GroupMediaType.SetSampleSize(4);
                    WAVEFORMATEX * vih = (WAVEFORMATEX*)GroupMediaType.Format();
                    ZeroMemory( vih, sizeof( WAVEFORMATEX ) );
                    vih->wFormatTag = WAVE_FORMAT_PCM;
                    vih->nChannels = 2;
                    vih->nSamplesPerSec = sr;
                    vih->nBlockAlign = 4;
                    vih->nAvgBytesPerSec = vih->nBlockAlign * sr;
                    vih->wBitsPerSample = 16;
                } else if (bstrType && 
                        !DexCompareW(bstrType, L"video")) {
                    long w = ReadNumAttribute(p, L"width", DEF_WIDTH); // tagg
                    long h = ReadNumAttribute(p, L"height", DEF_HEIGHT); // tagg 
                    long b = ReadNumAttribute(p, L"bitdepth", DEF_BITDEPTH); // tagg
                    GroupMediaType.majortype = MEDIATYPE_Video;
                    if (b == 16)
                        GroupMediaType.subtype = MEDIASUBTYPE_RGB555;
                    else if (b == 24)
                        GroupMediaType.subtype = MEDIASUBTYPE_RGB24;
                    else if (b == 32)
                        GroupMediaType.subtype = MEDIASUBTYPE_ARGB32;
                    GroupMediaType.formattype = FORMAT_VideoInfo;
                    GroupMediaType.AllocFormatBuffer(sizeof(VIDEOINFOHEADER));
                    VIDEOINFOHEADER * vih = (VIDEOINFOHEADER*)
                                                GroupMediaType.Format();
                    ZeroMemory(vih, sizeof(VIDEOINFOHEADER));
                    vih->bmiHeader.biBitCount = (WORD)b;
                    vih->bmiHeader.biWidth = w;
                    vih->bmiHeader.biHeight = h;
                    vih->bmiHeader.biPlanes = 1;
                    vih->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                    vih->bmiHeader.biSizeImage = DIBSIZE(vih->bmiHeader);
                    GroupMediaType.SetSampleSize(DIBSIZE(vih->bmiHeader));
                } else {
                    pGroupObj->Release();
                    return E_INVALIDARG;
                }
                IAMTimelineGroup *pGroup;
                hr = pGroupObj->QueryInterface(__uuidof(IAMTimelineGroup), (void **) &pGroup);
                if (SUCCEEDED(hr)) {
                    if (bstrGName) {
                        pGroup->SetGroupName(bstrGName);
                    }
                    hr = pGroup->SetMediaType( &GroupMediaType );
                    if (FAILED(hr)) {
                        // !!! be nice and tell them the group #?
                        _GenerateError(pTL, 2, DEX_IDS_BAD_MEDIATYPE, hr);
                    }
                    // you're on your own if fps is <=0, you should know better
                    pGroup->SetOutputFPS( fps );
                    pGroup->SetPreviewMode( fPreviewMode );
                    pGroup->SetOutputBuffering( nBuffering );
                    pGroup->Release();
                }
                if (bstrType)
                    SysFreeString(bstrType);
            }

            if (SUCCEEDED(hr))
                 hr = pTL->AddGroup(pGroupObj);
        }

        if (SUCCEEDED(hr))
            hr = BuildChildren(pTL, pGroupObj, p, rtOffset);

        if (pGroupObj)
            pGroupObj->Release();

        if (bstrGName) {
            SysFreeString(bstrGName);
        }
    } else if (!DexCompareW(bstrName, L"composite") || // tagg
    !DexCompareW(bstrName, L"timeline")) { // tagg
        hr = BuildTrackOrComp(pTL, pParent, p, TIMELINE_MAJOR_TYPE_COMPOSITE,
                              rtOffset );
    } else if (!DexCompareW(bstrName, L"track") || // tagg
    !DexCompareW(bstrName, L"vtrack") || // tagg
    !DexCompareW(bstrName, L"atrack")) { // tagg
	// create track
        hr = BuildTrackOrComp(pTL, pParent, p, TIMELINE_MAJOR_TYPE_TRACK,
                              rtOffset );
    } else if (!DexCompareW(bstrName, L"clip") || // tagg
    !DexCompareW(bstrName, L"daclip")) { // tagg

	// create the timeline source
	//
	IAMTimelineObj *pSourceObj;
	hr = pTL->CreateEmptyNode(&pSourceObj, TIMELINE_MAJOR_TYPE_SOURCE);

	if (FAILED(hr)) {
	    goto ClipError;
	}

      {
	// every object has this
	hr = ReadObjStuff(p, pSourceObj);

	// clip objects also support...

	BSTR bstrSrc = FindAttribute(p, L"src"); // tagg
	BSTR bstrStretchMode = FindAttribute(p, L"stretchmode"); // tagg
	REFERENCE_TIME rtMStart = ReadTimeAttribute(p, L"mstart", -1); // tagg
	REFERENCE_TIME rtMStop = ReadTimeAttribute(p, L"mstop", -1); // tagg
	REFERENCE_TIME rtMLen = ReadTimeAttribute(p, L"mlength", 0); // tagg
        long StreamNum = ReadNumAttribute(p, L"stream", 0); // tagg

	// do these 2 again so we can do a default stop
	REFERENCE_TIME rtStart = ReadTimeAttribute(p, L"start", -1); // tagg
	REFERENCE_TIME rtStop = ReadTimeAttribute(p, L"stop", -1); // tagg
	// backwards compat
	if (rtStart == -1) {
	    rtStart = ReadTimeAttribute(p, L"tlstart", -1); // tagg
	    rtStop = ReadTimeAttribute(p, L"tlstop", -1); // tagg
	}

        // default to something reasonable
        if (rtStart == -1 && rtStop == -1)
            rtStart = 0;

	// !!! can be confused by colons - only decimal supported
	REFERENCE_TIME llfps = ReadTimeAttribute(p, L"framerate", 0); // tagg
	double fps = (double)llfps / UNITS;

        if (rtStop == -1 && rtMStop != -1) {
	    // default tstop
            rtStop = rtStart + (rtMStop - rtMStart);
	    pSourceObj->SetStartStop(rtStart, rtStop);
        }
        if (rtMStop == -1 && rtMStart != -1 && rtStop != -1) {
            // default mstop
            rtMStop = rtMStart + (rtStop - rtStart);
        }

	int StretchMode = RESIZEF_STRETCH;
	if (bstrStretchMode && 
              !DexCompareW(bstrStretchMode, L"crop"))
	    StretchMode = RESIZEF_CROP;
	else if (bstrStretchMode && 
    !DexCompareW(bstrStretchMode, L"PreserveAspectRatio"))
	    StretchMode = RESIZEF_PRESERVEASPECTRATIO;
	else if (bstrStretchMode &&
    !DexCompareW(bstrStretchMode, L"PreserveAspectRatioNoLetterbox"))
	    StretchMode = RESIZEF_PRESERVEASPECTRATIO_NOLETTERBOX;
	
        // support "daclip" hack
        CLSID clsidSrc = GUID_NULL;
        if (!DexCompareW(bstrName, L"daclip")) { // tagg
            clsidSrc = __uuidof(DAScriptParser);
            hr = pSourceObj->SetSubObjectGUID(clsidSrc);
            ASSERT(hr == S_OK);
        }

	IAMTimelineSrc *pSourceSrc;

        hr = pSourceObj->QueryInterface(__uuidof(IAMTimelineSrc), (void **) &pSourceSrc);
	    ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) {
		hr = S_OK;
		if (rtMStart != -1 && rtMStop != -1)
                    hr = pSourceSrc->SetMediaTimes(rtMStart, rtMStop);
		ASSERT(hr == S_OK);
                if (bstrSrc) {
                    hr = pSourceSrc->SetMediaName(bstrSrc);
                    ASSERT(hr == S_OK);
                }
                pSourceSrc->SetMediaLength(rtMLen);
		pSourceSrc->SetDefaultFPS(fps);
		pSourceSrc->SetStretchMode(StretchMode);
                pSourceSrc->SetStreamNumber( StreamNum );
                pSourceSrc->Release();
            }

	    if (SUCCEEDED(hr)) {
                IAMTimelineTrack *pRealTrack;
                hr = pParent->QueryInterface(__uuidof(IAMTimelineTrack),
							(void **) &pRealTrack);
                if (SUCCEEDED(hr)) {
                    hr = pRealTrack->SrcAdd(pSourceObj);
		    ASSERT(hr == S_OK);
                    pRealTrack->Release();
                } else {
	            DbgLog((LOG_ERROR, 0, "ERROR: Clip must be a child of a track"));
	        }
	    }

            if (SUCCEEDED(hr)) {
                // any effects on this source
                hr = BuildChildren(pTL, pSourceObj, p, rtOffset);
            }

            if (SUCCEEDED(hr)) {
                // any parameters on this source?
                // !!! should/must this be combined with the BuildChildren above which
                // !!! also enumerates any subtags?
                hr = BuildElementProperties(pSourceObj, p);
            }

            pSourceObj->Release();


	if (bstrSrc)
	    SysFreeString(bstrSrc);

        if (bstrStretchMode)
            SysFreeString(bstrStretchMode);
      }
ClipError:;

    } else if (!DexCompareW(bstrName, L"effect")) { // tagg
	// <effect

        IAMTimelineObj *pTimelineObj;
    	// create the timeline effect
        //
        hr = pTL->CreateEmptyNode(&pTimelineObj,TIMELINE_MAJOR_TYPE_EFFECT);
	ASSERT(hr == S_OK);
	if (FAILED(hr)) {
	    SysFreeString(bstrName);
	    return hr;
	}

	hr = ReadObjStuff(p, pTimelineObj);

	IAMTimelineEffectable *pEffectable;
	hr = pParent->QueryInterface(__uuidof(IAMTimelineEffectable), (void **) &pEffectable);

	if (SUCCEEDED(hr)) {
	    hr = pEffectable->EffectInsBefore( pTimelineObj, -1 );
	    ASSERT(hr == S_OK);

	    pEffectable->Release();
	} else {
	    DbgLog((LOG_ERROR, 0, "ERROR: Effect cannot be a child of this object"));
	}

	if (SUCCEEDED(hr)) {
	    hr = BuildElementProperties(pTimelineObj, p);
	}

	pTimelineObj->Release();

    } else if (!DexCompareW(bstrName, L"transition")) { // tagg
	// <transition

        IAMTimelineObj *pTimelineObj;
    	// create the timeline effect
        //
        hr = pTL->CreateEmptyNode(&pTimelineObj,TIMELINE_MAJOR_TYPE_TRANSITION);
	ASSERT(hr == S_OK);
	if (FAILED(hr)) {
	    SysFreeString(bstrName);
	    return hr;
	}

	hr = ReadObjStuff(p, pTimelineObj);

	REFERENCE_TIME rtCut = ReadTimeAttribute(p, L"cutpoint", -1); // tagg
	BOOL fSwapInputs = ReadBoolAttribute(p, L"swapinputs", FALSE); // tagg
	BOOL fCutsOnly = ReadBoolAttribute(p, L"cutsonly", FALSE); // tagg

            // set up filter right
            if (rtCut >= 0 || fSwapInputs || fCutsOnly) {
                IAMTimelineTrans *pTimeTrans;
                hr = pTimelineObj->QueryInterface(__uuidof(IAMTimelineTrans), (void **) &pTimeTrans);
		ASSERT(SUCCEEDED(hr));

                if (SUCCEEDED(hr)) {
		    if (rtCut >= 0) {
                        hr = pTimeTrans->SetCutPoint(rtCut);
	    	        ASSERT(hr == S_OK);
		    }
                    hr = pTimeTrans->SetSwapInputs(fSwapInputs);
	    	    ASSERT(hr == S_OK);
                    hr = pTimeTrans->SetCutsOnly(fCutsOnly);
	    	    ASSERT(hr == S_OK);
                    pTimelineObj->Release();
		}
            }

            IAMTimelineTransable *pTransable;
            hr = pParent->QueryInterface(__uuidof(IAMTimelineTransable), (void **) &pTransable);

            if (SUCCEEDED(hr)) {
                hr = pTransable->TransAdd( pTimelineObj );

                pTransable->Release();
	    } else {
	        DbgLog((LOG_ERROR, 0, "ERROR: Transition cannot be a child of this object"));
	    }

            if (SUCCEEDED(hr)) {
                hr = BuildElementProperties(pTimelineObj, p);
            }

            pTimelineObj->Release();

    } else {
	// !!! ignore unknown tags?
	DbgLog((LOG_ERROR, 0, "ERROR: Ignoring unknown tag '%ls'", bstrName));
    }

    SysFreeString(bstrName);

    return hr;
}


HRESULT BuildFromXML(IAMTimeline *pTL, IXMLDOMElement *pxml)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pxml, E_POINTER);

    HRESULT hr = S_OK;

    BSTR bstrName;
    hr = pxml->get_tagName(&bstrName);

    if (FAILED(hr))
	return hr;

    int i = DexCompareW(bstrName, L"timeline"); // tagg
    SysFreeString(bstrName);

    if (i != 0)
	return VFW_E_INVALID_FILE_FORMAT;

    CLSID DefTrans, DefFX;
    BOOL fEnableTrans = ReadBoolAttribute(pxml, L"enabletrans", 1); // tagg
    hr = pTL->EnableTransitions(fEnableTrans);

    BOOL fEnableFX = ReadBoolAttribute(pxml, L"enablefx", 1); // tagg
    hr = pTL->EnableEffects(fEnableFX);

    BSTR bstrDefTrans = FindAttribute(pxml, L"defaulttrans"); // tagg
    if (bstrDefTrans) {
        hr = CLSIDFromString(bstrDefTrans, &DefTrans);
	hr = pTL->SetDefaultTransition(&DefTrans);
    }
    BSTR bstrDefFX = FindAttribute(pxml, L"defaultfx"); // tagg
    if (bstrDefFX) {
        hr = CLSIDFromString(bstrDefFX, &DefFX);
	hr = pTL->SetDefaultEffect(&DefFX);
    }

    REFERENCE_TIME llfps = ReadTimeAttribute(pxml, L"framerate", 15*UNITS); // tagg
    double fps = (double)llfps / UNITS;
    hr = pTL->SetDefaultFPS(fps);

    hr = BuildChildren(pTL, NULL, pxml, 0);

    return hr;
}	

HRESULT BuildFromXMLDoc(IAMTimeline *pTL, IXMLDOMDocument *pxml)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pxml, E_POINTER);

    HRESULT hr = S_OK;

    IXMLDOMElement *proot;

    hr = pxml->get_documentElement(&proot);

    if (hr == S_FALSE)          // can't read the file - no root
        hr = E_INVALIDARG;

    if (FAILED(hr))
	return hr;

    hr = BuildFromXML(pTL, proot);

    proot->Release();

    return hr;
}


HRESULT BuildFromXMLFile(IAMTimeline *pTL, WCHAR *wszXMLFile)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(wszXMLFile, E_POINTER);

    // convert to absolute path because relative paths don't work with
    // XMLDocument on Win98 (IE4?)
    USES_CONVERSION;
    TCHAR *szXMLFile = W2T(wszXMLFile);
    TCHAR szFullPath[MAX_PATH];
    TCHAR *pName;
    if(GetFullPathName(szXMLFile, NUMELMS(szFullPath), szFullPath, &pName) == 0) {
        return AmGetLastErrorToHResult();
    }
    WCHAR *wszFullPath = T2W(szFullPath);
    
    CComQIPtr<IAMSetErrorLog, &IID_IAMSetErrorLog> pSet( pTL );
    CComPtr<IAMErrorLog> pLog;
    if (pSet) {
	pSet->get_ErrorLog(&pLog);
    }



    IXMLDOMDocument *pxml;
    HRESULT hr = CoCreateInstance(CLSID_DOMDocument, NULL,
				CLSCTX_INPROC_SERVER,
				IID_IXMLDOMDocument, (void**)&pxml);
    if (SUCCEEDED(hr)) {

        VARIANT var;
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = W2BSTR(wszFullPath);

        VARIANT_BOOL b;
	hr = pxml->load(var, &b);
        if (hr == S_FALSE)
            hr = E_INVALIDARG;

        VariantClear(&var);

	// !!! async?

	if (SUCCEEDED(hr)) {
	    hr = BuildFromXMLDoc(pTL, pxml);
	}

	if (FAILED(hr)) {
            // Print error information !

            IXMLDOMParseError *pXMLError = NULL;
            HRESULT hr2 = pxml->get_parseError(&pXMLError);
            if (SUCCEEDED(hr2)) {
                long nLine;
                hr2 = pXMLError->get_line(&nLine);
                pXMLError->Release();
                if (SUCCEEDED(hr2)) {
                    DbgLog((LOG_ERROR, 0, TEXT(" Error on line %d"), (int)nLine));
	    	    VARIANT var;
	    	    VariantInit(&var);
	    	    var.vt = VT_I4;
	    	    V_I4(&var) = nLine;
	    	    _GenerateError(pTL, 1, DEX_IDS_INVALID_XML, hr, &var);
                } else {
	    	    _GenerateError(pTL, 1, DEX_IDS_INVALID_XML, hr);
		}
            } else {
	    	_GenerateError(pTL, 1, DEX_IDS_INVALID_XML, hr);
	    }
        }

	pxml->Release();
    } else {
	_GenerateError(pTL, 1, DEX_IDS_INSTALL_PROBLEM, hr);
    }
    return hr;
}




const int SUPPORTED_TYPES =  TIMELINE_MAJOR_TYPE_TRACK |
                             TIMELINE_MAJOR_TYPE_SOURCE |
                             TIMELINE_MAJOR_TYPE_GROUP |
                             TIMELINE_MAJOR_TYPE_COMPOSITE |
                             TIMELINE_MAJOR_TYPE_TRANSITION |
                             TIMELINE_MAJOR_TYPE_EFFECT;


HRESULT InsertDeleteTLObjSection(IAMTimelineObj *p, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, BOOL fDelete)
{
    TIMELINE_MAJOR_TYPE lType;
    HRESULT hr = p->GetTimelineType(&lType);

    switch (lType) {
        case TIMELINE_MAJOR_TYPE_TRACK:
        {
            IAMTimelineTrack *pTrack;
            if (SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineTrack), (void **) &pTrack))) {
                if (fDelete)
                {
                    hr = pTrack->ZeroBetween(rtStart, rtStop);
                    hr = pTrack->MoveEverythingBy( rtStop, rtStart - rtStop );
                }
                else
                    hr = pTrack->InsertSpace(rtStart, rtStop);
                pTrack->Release();
            }
        }
        break;

        case TIMELINE_MAJOR_TYPE_GROUP:
        case TIMELINE_MAJOR_TYPE_COMPOSITE:
        {
            IAMTimelineNode *pNode;
            HRESULT hr = p->QueryInterface(__uuidof(IAMTimelineNode), (void **) &pNode);
            if (SUCCEEDED(hr)) {
                long count;
                hr = pNode->XKidsOfType( TIMELINE_MAJOR_TYPE_TRACK |
                                         TIMELINE_MAJOR_TYPE_COMPOSITE,
                                         &count );

                if (SUCCEEDED(hr) && count > 0) {
                    for (int i = 0; i < count; i++) {
                        IAMTimelineObj *pChild;
                        hr = pNode->XGetNthKidOfType(SUPPORTED_TYPES, i, &pChild);

                        if (SUCCEEDED(hr)) {
                            // recurse!
                            hr = InsertDeleteTLObjSection(pChild, rtStart, rtStop, fDelete);
                        }

                        pChild->Release();
                    }
                }
                pNode->Release();
            }

            break;
        }

        default:
            break;
    }

    return hr;
}


HRESULT InsertDeleteTLSection(IAMTimeline *pTL, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, BOOL fDelete)
{
    long cGroups;
    HRESULT hr = pTL->GetGroupCount(&cGroups);
    if (FAILED(hr))
        return hr;

    for (long lGroup = 0; lGroup < cGroups; lGroup++) {
        IAMTimelineObj * pGroupObj;
        hr = pTL->GetGroup(&pGroupObj, lGroup);
        if (FAILED(hr))
            break;

        hr = InsertDeleteTLObjSection(pGroupObj, rtStart, rtStop, fDelete);
        pGroupObj->Release();
        if (FAILED(hr))
            break;
    }

    return hr;
}


// !!! OLD CODE MISSING MANY THINGS
//
HRESULT SavePartialToXMLString(IAMTimeline *pTL, REFERENCE_TIME clipStart, REFERENCE_TIME clipEnd, HGLOBAL *ph)
{
    return E_FAIL;
#if 0

    long cGroups;
    HRESULT hr = pTL->GetGroupCount(&cGroups);
    if (FAILED(hr))
        return hr;

    HGLOBAL h = GlobalAlloc(GHND, 10000);
    if (!h)
        return E_OUTOFMEMORY;

    char *p = (char *) GlobalLock(h);

    REFERENCE_TIME rtDuration;
    hr = pTL->GetDuration(&rtDuration);

    if (clipEnd == 0)
        clipEnd = rtDuration;

    p += wsprintfA(p, "<timeline duration=\""); // tagg
    PrintTime(p, clipEnd - clipStart);
    p += wsprintfA(p, "\"");

    p += wsprintfA(p, ">\r\n");
    for (long lGroup = 0; lGroup < cGroups; lGroup++) {
        IAMTimelineObj * pGroupObj;
        hr = pTL->GetGroup(&pGroupObj, lGroup);
        if (FAILED(hr))
            break;

        hr = SavePartialToXML(pGroupObj, clipStart, clipEnd, p, 1);
        pGroupObj->Release();
        if (FAILED(hr))
            break;
    }
    p += wsprintfA(p, "</timeline>\r\n"); // tagg

    if (FAILED(hr))
        GlobalFree(h);
    else
        *ph = h;

    return hr;
#endif
}

// !!! OLD CODE MISSING MANY THINGS
//
HRESULT SavePartialToXMLFile(IAMTimeline *pTL, REFERENCE_TIME clipStart, REFERENCE_TIME clipEnd, WCHAR *pwszXML)
{
    HANDLE h;

    HRESULT hr = SavePartialToXMLString(pTL, clipStart, clipEnd, &h);

    if (FAILED(hr))
        return hr;

    char *p = (char *) GlobalLock(h);

    USES_CONVERSION;
    TCHAR * tpwszXML = W2T( pwszXML );
    HANDLE hFile = CreateFile( tpwszXML,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

    if (hFile) {
        DWORD cb = lstrlenA(p);

        WriteFile(hFile, p, cb, &cb, NULL);



        CloseHandle(hFile);
    }

    return hr;
}


HRESULT PasteInXMLDoc(IAMTimeline *pTL, REFERENCE_TIME rtStart, IXMLDocument *pxmldoc)
{
    return E_NOTIMPL;
}	

HRESULT PasteFromXMLFile(IAMTimeline *pTL, REFERENCE_TIME rtStart, WCHAR *wszXMLFile)
{
    return E_NOTIMPL;
}

HRESULT PasteFromXML(IAMTimeline *pTL, REFERENCE_TIME rtStart, HGLOBAL hXML)
{
    return E_NOTIMPL;
}


static void PrintIndentA(char * &pOut, int indent)
{
    while (indent--) {
        pOut += wsprintfA(pOut, "    ");
    }
}

static void PrintIndentW(WCHAR * &pOut, int indent)
{
    while (indent--) {
        pOut += wsprintfW(pOut, L"    ");
    }
}

static void PrintTimeA(char * &pOut, REFERENCE_TIME rt)
{
    int secs = (int) (rt / UNITS);

    double dsecs = rt - (double)(secs * UNITS);
    int isecs = (int)dsecs;

    if (isecs) {
        pOut += wsprintfA(pOut, "%d.%07d", secs, isecs);
    } else {
        pOut += wsprintfA(pOut, "%d", secs);
    }
}

static void PrintTimeW(WCHAR * &pOut, REFERENCE_TIME rt)
{
    int secs = (int) (rt / UNITS);

    double dsecs = rt - (double)(secs * UNITS);
    int isecs = (int)dsecs;

    if (isecs) {
        pOut += wsprintfW(pOut, L"%d.%07d", secs, isecs);
    } else {
        pOut += wsprintfW(pOut, L"%d", secs);
    }
}


#include "varyprop.cpp"		// can't include qxmlhelp.h twice




class CXTLPrinter {
    WCHAR *m_pOut;
    DWORD m_dwAlloc;    // count of characters
    DWORD m_dwCurrent;    // count of characters
    int   m_indent;

    REFERENCE_TIME clipStart, clipEnd;

    void Print(const WCHAR *pFormat, ...);
    void PrintTime(REFERENCE_TIME rt);
    void PrintIndent();

    HRESULT EnsureSpace(DWORD dw);

    HRESULT PrintObjStuff(IAMTimelineObj *pObj, BOOL fTimesToo);

    HRESULT PrintProperties(IPropertySetter *pSetter);

    HRESULT PrintPartial(IAMTimelineObj *p);

    HRESULT PrintPartialChildren(IAMTimelineObj *p);

public:
    CXTLPrinter();
    ~CXTLPrinter();

    HRESULT PrintTimeline(IAMTimeline *pTL);
    WCHAR *GetOutput() { return m_pOut; }
};

CXTLPrinter::CXTLPrinter()
{
    m_pOut = NULL;
}

CXTLPrinter::~CXTLPrinter()
{
    delete[] m_pOut;
}

void CXTLPrinter::Print(const WCHAR *pFormat, ...)
{
    va_list va;
    va_start(va, pFormat);

    m_dwCurrent += wvsprintfW(m_pOut + m_dwCurrent, pFormat, va);

    ASSERT(m_dwCurrent < m_dwAlloc);
}

void CXTLPrinter::PrintIndent()
{
    int indent = m_indent;
    while (indent--) {
        Print(L"    ");
    }
}

void CXTLPrinter::PrintTime(REFERENCE_TIME rt)
{
    int secs = (int) (rt / UNITS);

    double dsecs = rt - (double)(secs * UNITS);
    int isecs = (int)dsecs;

    if (isecs) {
        Print(L"%d.%07d", secs, isecs);
    } else {
        Print(L"%d", secs);
    }
}

HRESULT CXTLPrinter::PrintProperties(IPropertySetter *pSetter)
{
    int cchPrinted;
    HRESULT hr = pSetter->PrintXMLW(m_pOut+m_dwCurrent, 
            m_dwAlloc - m_dwCurrent, &cchPrinted, m_indent);
    m_dwCurrent += cchPrinted;

    return hr;
}


HRESULT CXTLPrinter::EnsureSpace(DWORD dw)
{
    if (m_dwCurrent + dw < m_dwAlloc)
        return S_OK;

    DWORD dwAlloc = max(m_dwCurrent + dw, m_dwCurrent * 2);

    WCHAR *pNew = new WCHAR[dwAlloc];
    if (!pNew)
        return E_OUTOFMEMORY;

    CopyMemory(pNew, m_pOut, m_dwCurrent * sizeof(WCHAR));
    delete[] m_pOut;

    m_pOut = pNew;
    m_dwAlloc = dwAlloc;

    return S_OK;
}

HRESULT CXTLPrinter::PrintObjStuff(IAMTimelineObj *pObj, BOOL fTimesToo)
{
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtStop;
    HRESULT hr = pObj->GetStartStop(&rtStart, &rtStop);
    if (fTimesToo && SUCCEEDED(hr) && rtStop > 0) {
        Print(L" start=\""); // tagg
        PrintTime(rtStart);
        Print(L"\" stop=\""); // tagg
        PrintTime(rtStop);
        Print(L"\"");
    }

    CLSID clsidObj;
    hr = pObj->GetSubObjectGUID(&clsidObj);
    WCHAR wszClsid[50];
    if (SUCCEEDED(hr) && clsidObj != GUID_NULL) {
        StringFromGUID2(clsidObj, wszClsid, 50);
        Print(L" clsid=\"%ls\"", wszClsid); // tagg
    }

    // !!! BROKEN - Child is muted if parent is.  Save. Load.  Unmute parent.
    // Child will still be muted
    BOOL Mute;
    pObj->GetMuted(&Mute);
    if (Mute)
        Print(L" mute=\"%d\"", Mute); // tagg

    BOOL Lock;
    pObj->GetLocked(&Lock);
    if (Lock)
        Print(L" lock=\"%d\"", Lock); // tagg

    long UserID;
    pObj->GetUserID(&UserID);
    if (UserID != 0)
        Print(L" userid=\"%d\"", (int)UserID);// !!! trunc? // tagg

    BSTR bstr;
    hr = pObj->GetUserName(&bstr);
    if (bstr) {
	if (lstrlenW(bstr) > 0) {
            Print(L" username=\"%ls\"", bstr); // tagg
	}
	SysFreeString(bstr);
    }

    LONG size;
    hr = pObj->GetUserData(NULL, &size);
    if (size > 0) {
        BYTE *pData = (BYTE *)QzTaskMemAlloc(size);
        if (pData == NULL) {
	    return E_OUTOFMEMORY;
	}
        WCHAR *pHex = (WCHAR *)QzTaskMemAlloc(2 * size * sizeof(WCHAR));
        if (pHex == NULL) {
	    QzTaskMemFree(pData);
	    return E_OUTOFMEMORY;
	}
        hr = pObj->GetUserData(pData, &size);
        WCHAR *pwch = pHex;
        for (int zz=0; zz<size; zz++) {
	    wsprintfW(pwch, L"%02X", pData[zz]);
	    pwch += 2;
        }
        Print(L" userdata=\"%ls\"", pHex); // tagg
	QzTaskMemFree(pHex);
	QzTaskMemFree(pData);
    }

    return S_OK;
}



HRESULT CXTLPrinter::PrintTimeline(IAMTimeline *pTL)
{
    m_pOut = new WCHAR[10000];
    if (!m_pOut)
        return E_OUTOFMEMORY;
    m_dwAlloc = 10000;  // in characters, not bytes
    m_indent = 1;
    
    // unicode strings need to be prefixed by FFFE, apparently
    *(LPBYTE)m_pOut = 0xff;
    *(((LPBYTE)m_pOut) + 1) = 0xfe;
    m_dwCurrent = 1;

    REFERENCE_TIME rtDuration;
    HRESULT hr = pTL->GetDuration(&rtDuration);
    if (FAILED(hr))
        return hr;

    clipStart = 0; clipEnd = rtDuration;

    long cGroups;
    hr = pTL->GetGroupCount(&cGroups);
    if (FAILED(hr))
        return hr;

    Print(L"<timeline"); // tagg

    BOOL fEnableTrans;
    pTL->TransitionsEnabled(&fEnableTrans);
    if (!fEnableTrans)
        Print(L" enabletrans=\"%d\"", fEnableTrans); // tagg

    BOOL fEnableFX;
    hr = pTL->EffectsEnabled(&fEnableFX);
    if (!fEnableFX)
        Print(L" enablefx=\"%d\"", fEnableFX); // tagg

    CLSID DefTrans, DefFX;
    WCHAR wszClsid[50];
    hr = pTL->GetDefaultTransition(&DefTrans);
    if (SUCCEEDED(hr) && DefTrans != GUID_NULL && !IsEqualGUID(DefTrans,
						DefaultTransition)) {
        StringFromGUID2(DefTrans, wszClsid, 50);
        Print(L" defaulttrans=\"%ls\"", wszClsid); // tagg
    }
    hr = pTL->GetDefaultEffect(&DefFX);
    if (SUCCEEDED(hr) && DefFX != GUID_NULL && !IsEqualGUID(DefFX,
						DefaultEffect)) {
        StringFromGUID2(DefFX, wszClsid, 50);
        Print(L" defaultfx=\"%ls\"", wszClsid); // tagg
    }

    double frc;
    hr = pTL->GetDefaultFPS(&frc);
    if (frc != 15.0) {
        LONG lfrc = (LONG)frc;
        double ffrc = (frc - (double)lfrc) * UNITS;
        Print(L" framerate=\"%d.%07d\"", (int)frc, (int)ffrc); // tagg
    }

    Print(L">\r\n");

    for (long lGroup = 0; lGroup < cGroups; lGroup++) {
        IAMTimelineObj * pGroupObj;
        hr = pTL->GetGroup(&pGroupObj, lGroup);
        if (FAILED(hr))
            break;

        hr = PrintPartial(pGroupObj);

        pGroupObj->Release();
        if (FAILED(hr))
            break;
    }
    Print(L"</timeline>\r\n"); // tagg

    return hr;
}

HRESULT CXTLPrinter::PrintPartialChildren(IAMTimelineObj *p)
{
    IAMTimelineNode *pNode;
    HRESULT hr = p->QueryInterface(__uuidof(IAMTimelineNode), (void **) &pNode);
    if (SUCCEEDED(hr)) {
        long count;
        hr = pNode->XKidsOfType( SUPPORTED_TYPES, &count );

        if (SUCCEEDED(hr) && count > 0) {

            Print(L">\r\n");

            for (int i = 0; i < count; i++) {
                IAMTimelineObj *pChild;
                hr = pNode->XGetNthKidOfType(SUPPORTED_TYPES, i, &pChild);

                if (SUCCEEDED(hr)) {
                    // recurse!
                    ++m_indent;
                    hr = PrintPartial(pChild);
		    if (FAILED(hr)) {
			break;
		    }
                    --m_indent;
                }

                pChild->Release();
            }
        }
        pNode->Release();

        if (SUCCEEDED(hr) && count == 0)
            hr = S_FALSE;
    }

    return hr;
}

HRESULT CXTLPrinter::PrintPartial(IAMTimelineObj *p)
{
    HRESULT hr = S_OK;

    hr = EnsureSpace(5000);
    if (FAILED(hr))
        return hr;

    TIMELINE_MAJOR_TYPE lType;
    hr = p->GetTimelineType(&lType);

    switch (lType) {
        case TIMELINE_MAJOR_TYPE_TRACK:
        {
            IAMTimelineVirtualTrack *pTrack;
            if (SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineVirtualTrack), (void **) &pTrack))) {

                PrintIndent();

    		Print(L"<track"); // tagg

		hr = PrintObjStuff(p, FALSE);
		if (FAILED(hr))
		    break;

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</track>\r\n"); // tagg
                }
                pTrack->Release();
            }
        }
        break;

        case TIMELINE_MAJOR_TYPE_SOURCE:
        {
#if 0
            if (clipEnd <= rtStart || clipStart >= rtStop) {
		ASSERT(FALSE);	// why would this happen?
                break;
	    }
#endif

            IAMTimelineSrc *pSrc;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineSrc),
							(void **) &pSrc)) {

                REFERENCE_TIME rtMStart;
                REFERENCE_TIME rtMStop;
                hr = pSrc->GetMediaTimes(&rtMStart, &rtMStop);

                BSTR bstrSrc;
                hr = pSrc->GetMediaName(&bstrSrc);

#if 0	// this strikes me as very unecessary
                double dMediaRate = (double)(rtMStop - rtMStart) /
						(rtStop - rtStart);

                if (clipEnd < rtStop) {
                    rtMStop = rtMStart + (REFERENCE_TIME) ((clipEnd - rtStart)
								 * dMediaRate);
                    rtStop = clipEnd;
                }
                if (clipStart > rtStart) {
                    rtMStart = rtMStart + (REFERENCE_TIME)((clipStart - rtStart)
								 * dMediaRate);
                    rtStart = clipStart;
                }

                rtStart -= clipStart;
                rtStop -= clipStart;
#endif

                PrintIndent();
                Print(L"<clip"); // tagg

		hr = PrintObjStuff(p, TRUE);

		if (bstrSrc && lstrlenW(bstrSrc) > 0)
                {
                    Print(L" src=\"%ls\"", bstrSrc); // tagg
                }

		if (rtMStop > 0) {
                    Print(L" mstart=\""); // tagg
                    PrintTime(rtMStart);

                    // only print out MStop if it's not the default....
                    REFERENCE_TIME rtStart;
                    REFERENCE_TIME rtStop;
                    hr = p->GetStartStop(&rtStart, &rtStop);
                    if (rtMStop != (rtMStart + (rtStop - rtStart))) {
                        Print(L"\" mstop=\""); // tagg
                        PrintTime(rtMStop);
                    }
                    Print(L"\"");
		}

		REFERENCE_TIME rtLen;
                hr = pSrc->GetMediaLength(&rtLen);
		if (rtLen > 0) {
                    Print(L" mlength=\""); // tagg
                    PrintTime(rtLen);
                    Print(L"\"");
		}

		int StretchMode;
		pSrc->GetStretchMode(&StretchMode);
		if (StretchMode == RESIZEF_PRESERVEASPECTRATIO)
                    Print(L" stretchmode=\"PreserveAspectRatio\""); // tagg
		else if (StretchMode == RESIZEF_CROP)
                    Print(L" stretchmode=\"Crop\""); // tagg
		else if (StretchMode == RESIZEF_PRESERVEASPECTRATIO_NOLETTERBOX)
		    Print(L" stretchmode=\"PreserveAspectRatioNoLetterbox\""); // tagg
		else
                    ; // !!! Is Stretch really the default?

		double fps; LONG lfps;
		pSrc->GetDefaultFPS(&fps);
		lfps = (LONG)fps;
		if (fps != 0.0)	// !!! Is 0 really the default?
                    Print(L" framerate=\"%d.%07d\"", (int)fps, // tagg
					(int)((fps - (double)lfps) * UNITS));

		long stream;
		pSrc->GetStreamNumber(&stream);
		if (stream > 0)
                    Print(L" stream=\"%d\"", (int)stream); // tagg

		if (bstrSrc)
                    SysFreeString(bstrSrc);

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                IPropertySetter *pSetter = NULL;
                HRESULT hr2 = p->GetPropertySetter(&pSetter);

                // save properties!
                if (hr2 == S_OK && pSetter) {
                    if (hr == S_FALSE) {
                        Print(L">\r\n");
                        hr = S_OK;
                    }

                    PrintProperties(pSetter);

                    pSetter->Release();
                }

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</clip>\r\n"); // tagg
                }

                pSrc->Release();
            }
        }
            break;

        case TIMELINE_MAJOR_TYPE_EFFECT:
        {
#if 0
            if (clipEnd <= rtStart || clipStart >= rtStop)
                break;

            if (clipEnd < rtStop) {
                rtStop = clipEnd - clipStart;
            } else {
                rtStop -= clipStart;
            }
            if (clipStart > rtStart) {
                rtStart = 0;
            } else {
                rtStart -= clipStart;
            }
#endif

            IAMTimelineEffect *pEffect;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineEffect), (void **) &pEffect)) {

                PrintIndent();
                Print(L"<effect"); // tagg

		hr = PrintObjStuff(p, TRUE);
		if (FAILED(hr))
		    break;

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                {
                    IPropertySetter *pSetter = NULL;
                    HRESULT hr2 = p->GetPropertySetter(&pSetter);

                    // save properties!
                    if (hr2 == S_OK && pSetter) {
                        if (hr == S_FALSE) {
                            Print(L">\r\n");
                            hr = S_OK;
                        }

                        PrintProperties(pSetter);

                        pSetter->Release();
                    }
                }

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</effect>\r\n"); // tagg
                }

                pEffect->Release();
            }
        }
            break;

        case TIMELINE_MAJOR_TYPE_TRANSITION:
        {
#if 0
            if (clipEnd <= rtStart || clipStart >= rtStop)
                break;

            if (clipEnd < rtStop) {
                rtStop = clipEnd - clipStart;
            } else {
                rtStop -= clipStart;
            }
            if (clipStart > rtStart) {
                rtStart = 0;
            } else {
                rtStart -= clipStart;
            }
#endif

            IAMTimelineTrans *pTrans;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineTrans), (void **) &pTrans)) {
                PrintIndent();
                Print(L"<transition"); // tagg

		hr = PrintObjStuff(p, TRUE);

		BOOL fSwapInputs;
		pTrans->GetSwapInputs(&fSwapInputs);
		if (fSwapInputs)
                    Print(L" swapinputs=\"%d\"", fSwapInputs); // tagg

		BOOL fCutsOnly;
		pTrans->GetCutsOnly(&fCutsOnly);
		if (fCutsOnly)
                    Print(L" cutsonly=\"%d\"", fCutsOnly); // tagg

		REFERENCE_TIME rtCutPoint;
		hr = pTrans->GetCutPoint(&rtCutPoint);
		if (hr == S_OK) { // !!! S_FALSE means not set, using default
                    Print(L" cutpoint=\""); // tagg
		    PrintTime(rtCutPoint);
                    Print(L"\"");
		}

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                // save properties!
                {
                    IPropertySetter *pSetter = NULL;
                    HRESULT hr2 = p->GetPropertySetter(&pSetter);

                    if (hr2 == S_OK && pSetter) {
                        if (hr == S_FALSE) {
                            Print(L">\r\n");
                            hr = S_OK;
                        }

                        PrintProperties(pSetter);

                        pSetter->Release();
                    }
                }

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</transition>\r\n"); // tagg
                }

                pTrans->Release();
            }
        }
            break;

        case TIMELINE_MAJOR_TYPE_COMPOSITE:
        {
            IAMTimelineVirtualTrack *pTrack;
            if (SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineVirtualTrack), (void **) &pTrack))) {
                PrintIndent();
                Print(L"<composite"); // tagg

		hr = PrintObjStuff(p, FALSE);
		if (FAILED(hr))
		    break;

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</composite>\r\n"); // tagg
                }
		pTrack->Release();
            }
            break;
        }

        case TIMELINE_MAJOR_TYPE_GROUP:
        {
            PrintIndent();

            IAMTimelineGroup *pGroup;
            if SUCCEEDED(p->QueryInterface(__uuidof(IAMTimelineGroup), (void **) &pGroup)) {
                Print(L"<group"); // tagg

		hr = PrintObjStuff(p, FALSE);

		CMediaType mt;
                pGroup->GetMediaType(&mt);
		if (*mt.Type() == MEDIATYPE_Video) {
		    LPBITMAPINFOHEADER lpbi = HEADER(mt.Format());
		    int bitdepth = lpbi->biBitCount;
		    int width = lpbi->biWidth;
		    int height = lpbi->biHeight;
		    USES_CONVERSION;
                    Print(L" type=\"video\""); // tagg
		    if (bitdepth != DEF_BITDEPTH)
                        Print(L" bitdepth=\"%d\"", bitdepth); // tagg
		    if (width != DEF_WIDTH)
                        Print(L" width=\"%d\"", width); // tagg
		    if (height != DEF_HEIGHT)
                        Print(L" height=\"%d\"", height); // tagg
		} else if (*mt.Type() == MEDIATYPE_Audio) {
		    WAVEFORMATEX *pwfx = (WAVEFORMATEX *)mt.Format();
		    int samplingrate = pwfx->nSamplesPerSec;
                    Print(L" type=\"audio\""); // tagg
		    if (samplingrate != DEF_SAMPLERATE)
                        Print(L" samplingrate=\"%d\"", // tagg
							samplingrate);
		}

		double frc, ffrc; LONG lfrc;
		int nPreviewMode, nBuffering;
                BSTR wName;
		pGroup->GetOutputFPS(&frc);
		pGroup->GetPreviewMode(&nPreviewMode);
		pGroup->GetOutputBuffering(&nBuffering);
		hr = pGroup->GetGroupName(&wName);
		lfrc = (LONG)frc;
		ffrc = (frc - (double)lfrc) * UNITS;
		if (frc != 15.0)  // !!! Is 15 really the default?
                    Print(L" framerate=\"%d.%07d\"", // tagg
						(int)frc, (int)ffrc);
		if (nPreviewMode == 0)	// Is ON really the default?
                    Print(L" previewmode=\"%d\"",nPreviewMode); // tagg
		if (nBuffering != DEX_DEF_OUTPUTBUF)
                    Print(L" buffering=\"%d\"", nBuffering); // tagg
		if (lstrlenW(wName) > 0)
                    Print(L" name=\"%ls\"", wName); // tagg
                SysFreeString( wName );

                hr = PrintPartialChildren(p);
		if (FAILED(hr))
		    break;

                if (hr == S_FALSE) {
                    Print(L"/>\r\n");
                    hr = S_OK;
                } else {
                    PrintIndent();
                    Print(L"</group>\r\n"); // tagg
                }

                pGroup->Release();
            }
            break;
        }

        default:
        {
            hr = PrintPartialChildren(p);
            break;
        }
    }

    return hr;
}



// !!! I need to get the OFFICIAL defaults, and not print out a value if it's
// the REAL default.  If the defaults change, I am in trouble!
//
HRESULT SaveTimelineToXMLFile(IAMTimeline *pTL, WCHAR *pwszXML)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pwszXML, E_POINTER);

    CXTLPrinter print;

    HRESULT hr = print.PrintTimeline(pTL);

    if (SUCCEEDED(hr)) {
        USES_CONVERSION;
        TCHAR * tpwszXML = W2T( pwszXML );
        HANDLE hFile = CreateFile( tpwszXML,
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);

        if (hFile && hFile != (HANDLE)-1) {
            DWORD cb = lstrlenW(print.GetOutput()) * sizeof(WCHAR);

            BOOL fOK =  WriteFile(hFile, print.GetOutput(), cb, &cb, NULL);
            if (fOK == FALSE) {
                _GenerateError(pTL, 1, DEX_IDS_DISK_WRITE_ERROR, hr);
                hr = E_INVALIDARG;
            }

            CloseHandle(hFile);
        } else {
            hr = E_INVALIDARG;
            _GenerateError(pTL, 1, DEX_IDS_DISK_WRITE_ERROR, hr);
        }
    }

    return hr;
}

HRESULT SaveTimelineToXMLString(IAMTimeline *pTL, BSTR *pbstrXML)
{
    CheckPointer(pTL, E_POINTER);
    CheckPointer(pbstrXML, E_POINTER);

    CXTLPrinter print;

    HRESULT hr = print.PrintTimeline(pTL);

    if (SUCCEEDED(hr)) {
        *pbstrXML = W2BSTR(print.GetOutput());

        if (!*pbstrXML)
            hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\xml2dex.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// Xml2Dex.h : Declaration of the CXml2Dex

#ifndef __XML2DEX_H_
#define __XML2DEX_H_

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "resource.h"       // main symbols
#include <qedit.h>

/////////////////////////////////////////////////////////////////////////////
// CXml2Dex
class ATL_NO_VTABLE CXml2Dex : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CXml2Dex, &CLSID_Xml2Dex>,
	public IDispatchImpl<IXml2Dex, &IID_IXml2Dex, &LIBID_DexterLib>
{
            CComPtr< IRenderEngine > m_pRenderEngine;
public:
	CXml2Dex()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_XML2DEX)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CXml2Dex)
	COM_INTERFACE_ENTRY(IXml2Dex)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IXml2Dex
public:
	STDMETHOD(WriteXMLFile)(IUnknown *pTL, BSTR FileName);
	STDMETHOD(WriteGrfFile)(IUnknown *pGraph, BSTR FileName);
	//STDMETHOD(DiscardTimeline)(IUnknown * pTimeline);
	STDMETHOD(CreateGraphFromFile)(IUnknown ** ppGraph, IUnknown * pTimeline, BSTR Filename);
	//STDMETHOD(CreateTimeline)(IUnknown ** ppTimelineUnk);
        STDMETHOD(ReadXMLFile)(IUnknown * pTimelineUnk, BSTR Filename);
        STDMETHOD(Delete)(IUnknown * pTimelineUnk, double dStart, double dEnd);
	STDMETHOD(WriteXMLPart)(IUnknown *pTL, double dStart, double dEnd, BSTR FileName);
	STDMETHOD(PasteXMLFile)(IUnknown *pTL, double dStart, BSTR FileName);
	STDMETHOD(CopyXML)(IUnknown *pTL, double dStart, double dEnd);
	STDMETHOD(PasteXML)(IUnknown *pTL, double dStart);
	STDMETHOD(Reset)();
        STDMETHOD(ReadXML)(IUnknown * pTimelineUnk, IUnknown *pxmlunk);
	STDMETHOD(WriteXML)(IUnknown *pTL, BSTR *pbstrXML);
};

#endif //__XML2DEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\xtlload.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <qedit.h>
#include "xmltl.h"
#include "xtlload.h"

class CXTLLoader : public CBaseFilter, public IFileSourceFilter {
    public:
	CXTLLoader(LPUNKNOWN punk, HRESULT *phr);
	~CXTLLoader();
	
	int GetPinCount() { return 0; }

	CBasePin * GetPin(int n) { return NULL; }

	DECLARE_IUNKNOWN

	// override this to say what interfaces we support where
	STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

	// -- IFileSourceFilter methods ---

	STDMETHODIMP Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt);
	STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt);

    private:
	WCHAR *m_pFileName;

	CCritSec m_csLock;
};

CXTLLoader::CXTLLoader(LPUNKNOWN punk, HRESULT *phr) :
		       CBaseFilter(NAME("XTL Loader"), punk, &m_csLock, CLSID_XTLLoader),
                       m_pFileName(NULL)
{
}

CXTLLoader::~CXTLLoader()
{
    delete[] m_pFileName;
}

STDMETHODIMP
CXTLLoader::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IFileSourceFilter) {
	return GetInterface((IFileSourceFilter*) this, ppv);
    } else {
	return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

HRESULT
CXTLLoader::Load(LPCOLESTR lpwszFileName, const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(lpwszFileName, E_POINTER);

    m_pFileName = new WCHAR[lstrlenW(lpwszFileName) + 1];
    if (m_pFileName!=NULL) {
	lstrcpyW(m_pFileName, lpwszFileName);
    } else
	return E_OUTOFMEMORY;

    HRESULT hr;
    
    if (m_pGraph) {
        IGraphBuilder *pGB;
	hr = m_pGraph->QueryInterface(IID_IGraphBuilder, (void **) &pGB);
	if (FAILED(hr))
	    return hr;

        IAMTimeline *pTL;
        hr = CoCreateInstance(__uuidof(AMTimeline), NULL, CLSCTX_INPROC_SERVER, 
                              __uuidof(IAMTimeline), (void**) &pTL);
        if (SUCCEEDED(hr)) {
            hr = BuildFromXMLFile(pTL, (WCHAR *) lpwszFileName);

            if (SUCCEEDED(hr)) {
                // create a render engine
                //
                IRenderEngine *pRender;
                hr = CoCreateInstance(__uuidof(RenderEngine), NULL, CLSCTX_INPROC_SERVER,
                                      __uuidof(IRenderEngine), (void**) &pRender);

                if (SUCCEEDED(hr)) {
                    hr = pRender->SetTimelineObject(pTL);

                    hr = pRender->SetFilterGraph(pGB);

                    hr = pRender->ConnectFrontEnd();
                    hr |= pRender->RenderOutputPins( );

                    pRender->Release();
                }
            }

            pTL->Release();
        }

        pGB->Release();
    } else {
	// m_fLoadLater = TRUE;
    }

    return hr;
}

// Modelled on IPersistFile::Load
// Caller needs to CoTaskMemFree or equivalent.

STDMETHODIMP
CXTLLoader::GetCurFile(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt)
{
    return E_NOTIMPL;
}

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter
CUnknown *CreateXTLLoaderInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CXTLLoader(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}

const AMOVIESETUP_FILTER
sudXTLLoader = { &CLSID_XTLLoader     // clsID
               , L"XTL Loader"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 0                     // nPins
               , NULL };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"XTL Loader"
    , &CLSID_XTLLoader
    , CreateXTLLoaderInstance
    , NULL
    , &sudXTLLoader }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\editlist\editlist.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <initguid.h>
#include "EditList.h"

// current limitations (partial list)
//	Doesn't implement IMediaSeeking or IMediaPosition, so you can't seek
//		the patched-together stream
//	(related to above) doesn't seek back to zero again properly if played
//		more than once
//	Not very smart about handling the same file occuring more than once
//		in the edit list
//	No built-in way to do transition effects between files
//	Does background thread need to run at lower priority?
//	Quality management probably isn't quite right.
//	Internal graphs should probably not be immediately Run, but instead
//		should just be Paused and then Run when they actually should
//		start playing.
//	Right now RenderFile is used to connect the source files to the internal
//		pins, which isn't very good as it can cause other renderers to
//		be instantiated if the file doesn't have the types we expect.
//		Fixing this requires code to find the proper source filter and parser
//		to either be added to the filter graph or explicitly put into
//		this filter.
//


CFactoryTemplate g_Templates[]= {
  {L"", &CLSID_EditList, CEditList::CreateInstance}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

static const char rgbEditListHeader[] = "EDITLIST\r\n";
static const char rgbNoDecompress[] = "NODECOMPRESS";

CUnknown *
CEditList::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
  return new CEditList(pUnk, phr);
}

CEditList::CEditList(LPUNKNOWN pUnk,
		     HRESULT * phr) :
	   CBaseFilter(NAME("Edit list filter"), pUnk,
		       &m_InterfaceLock, CLSID_EditList),
	   m_apStreams(NULL),
	   m_nStreams(0),
	   m_pList(NULL),
	   m_pNextToLoad(NULL),
	   m_pCurrent(NULL),
	   m_pNextToUnload(NULL),
	   m_fNoDecompress(FALSE),
	   m_pFileName(NULL)
{

}

CEditList::~CEditList()
{
    for (int i=0; i < m_nStreams; i++) {
	delete m_apStreams[i];
    }
    delete[] m_apStreams;

    delete[] m_pFileName;

    while (m_pList) {
	CEditListEntry *pEntry = m_pList;
	m_pList = pEntry->m_pNext;
	delete pEntry;
    }
}


// override this to say what interfaces we support where
STDMETHODIMP
CEditList::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{

    /* See if we have the interface */
    /* try each of our interface supporting objects in turn */

    if (riid == IID_IFileSourceFilter) {
        return GetInterface((IFileSourceFilter *)this, ppv);
    }

    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


STDMETHODIMP
CEditList::Load(
    LPCOLESTR pszFileName,
    const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = S_OK;

    //
    // Record the file name for GetCurFile
    //
    m_pFileName = new WCHAR[1+lstrlenW(pszFileName)];
    if (m_pFileName!=NULL) {
        lstrcpyW(m_pFileName, pszFileName);
    }


    // open the file (a text file with a list of filenames, for now)
#ifndef UNICODE
    CHAR szFile[MAX_PATH];
	
    WideCharToMultiByte(CP_ACP, 0, pszFileName, -1,
			szFile, sizeof(szFile), NULL, NULL);
	
    /*  Check we can open the file */
    HANDLE hFile = CreateFile(szFile,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
#else
    /*  Check we can open the file */
    HANDLE hFile = CreateFile(m_pFileName,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
#endif

    // we read the entire file into memory for easier handling.
    // could use a memory-mapped file here....
    DWORD dwSize = GetFileSize(hFile, NULL);
    char *pbFile = new char[dwSize + 1];
    pbFile[dwSize] = '\0'; // sentinel

    // !!! handle UNICODE edit-list file????

    DWORD cbRead;
    if (!ReadFile(hFile, pbFile, dwSize, &cbRead, NULL) ||
	    dwSize != cbRead) {
	hr = E_FAIL;
    } else if (memcmp(pbFile, rgbEditListHeader, sizeof(rgbEditListHeader) - 1)) {
	DbgLog((LOG_ERROR, 1, TEXT("Bad edit list header!")));
	hr = E_FAIL;
    } else {
	char * pb = pbFile;

	LONG lStartMS = 0;
	LONG lEndMS = 0;

	while (1) {
	    // skip to eol
	    while (*pb && *pb != '\r' && *pb != '\n')
		pb++;

	    // skip eol
	    while (*pb && (*pb == '\r' || *pb == '\n'))
		pb++;

	    // at eof?
	    if (*pb == 0)
		break;

	    // lines starting with ; are comments
	    if (*pb == ';')
		continue;

	    // !!! allow options here, whether to decompress all streams or not?
	    if (*pb == '/') {
		if (memcmp(pb+1, rgbNoDecompress, sizeof(rgbNoDecompress) - 1) == 0) {
		    m_fNoDecompress = TRUE;
		} else {
		    DbgLog((LOG_TRACE, 2, TEXT("Unknown option: %hs"), pb+1));
		}

		continue;
	    }

	    // lines starting with '+' define the output stream formats
	    if (*pb == '+') {

		if (m_nStreams != 0) {
		    DbgLog((LOG_TRACE, 1, TEXT("More than one set of format specifiers!")));
		
		    hr = E_FAIL;
		    break;
		}
		
		m_nStreams = atol(pb+1);

		int i = 0;
		
		m_apStreams = new CELStream * [m_nStreams];
		if (m_apStreams == NULL) {
		    hr = E_OUTOFMEMORY;
		    break;
		}

		while (*pb != ',')
		    pb++;

		
		while ((*pb++) == ',') {
		    if (i >= m_nStreams) {
			DbgLog((LOG_ERROR, 1, TEXT("Too many stream descriptors")));
			hr = E_FAIL;
			break;
		    }
		
		    m_apStreams[i] = new CELStream(NAME("EditList output"),
						   &hr,
						   this,
						   L"Out"); // !!! pin names?

		    if (m_apStreams[i] == NULL)
			hr = E_OUTOFMEMORY;

		    if (FAILED(hr)) {
			DbgLog((LOG_ERROR, 1, TEXT("Create output pin failed")));

			// !!! delete things?

			break;
		    }

		    DbgLog((LOG_TRACE, 2, TEXT("Created output pin[%d] %x"),
			    i, m_apStreams[i]));

		    if (*pb == 'V' || *pb == 'v') {
			//
			// Parse video information, can look like
			//	'cvid'320x240x8
			//	352x240x24
			//
			DWORD biCompression = BI_RGB;
			if (*(pb+1) == '\'') {
			    biCompression = *((UNALIGNED DWORD *) (pb+2));

			    if (*(pb+6) != '\'') {
				hr = E_FAIL;
				break;
			    }

			    pb += 6;
			}
			
			int width = atol(pb+1);
			while (*pb != 'x' && *pb != '\r')
			    pb++;

			int height = atol(pb+1);

			pb++;
			while (*pb != 'x' && *pb != '\r')
			    pb++;

			int depth = atol(pb+1);

			if (depth < 8)
			    depth = 24;

			m_apStreams[i]->m_mtOut.SetType(&MEDIATYPE_Video);
			m_apStreams[i]->m_mtOut.SetFormatType(&FORMAT_VideoInfo);

			// !!!!
			// Can't error, can only be smaller
			m_apStreams[i]->m_mtOut.ReallocFormatBuffer(SIZE_VIDEOHEADER);

			ZeroMemory(m_apStreams[i]->m_mtOut.Format(), SIZE_VIDEOHEADER);

			LPBITMAPINFOHEADER lpbi = HEADER(m_apStreams[i]->m_mtOut.Format());
			lpbi->biSize = sizeof(BITMAPINFOHEADER);
			lpbi->biWidth = width; // !!!
			lpbi->biHeight = height; // !!!
			lpbi->biCompression = biCompression;
			lpbi->biBitCount = depth;
			lpbi->biPlanes = 1;
			lpbi->biClrUsed = 0;
			lpbi->biClrImportant = 0;
			lpbi->biSizeImage = DIBSIZE(*lpbi);

			m_apStreams[i]->m_mtOut.SetSampleSize(lpbi->biSizeImage);
			m_apStreams[i]->m_mtOut.SetSubtype(&GetBitmapSubtype(lpbi));
			m_apStreams[i]->m_mtOut.SetTemporalCompression(FALSE);
			
		    } else if (*pb == 'A' || *pb == 'a') {
			//
			// Parse audio information, can look like
			//	22050
			//	11025x16
			//
			// no way to indicate a stereo stream yet.
			
			long rate = atol(pb+1);

			if (rate < 1000)
			    rate = 11025;

			int bits;
			while (*pb != 'x' && *pb !=',' && *pb != '\r')
			    pb++;

			bits = atol(pb+1);

			if (bits < 8)
			    bits = 8;

			m_apStreams[i]->m_mtOut.SetType(&MEDIATYPE_Audio);
			// m_apStreams[i]->m_mtOut.SetSubtype(&FOURCCMap((DWORD) 0));
			m_apStreams[i]->m_mtOut.SetSubtype(&MEDIASUBTYPE_NULL);

			// !!!!
			m_apStreams[i]->m_mtOut.SetFormatType(&FORMAT_WaveFormatEx);

			// generate a wave format!!!
			WAVEFORMATEX wfx;

			wfx.wFormatTag      = WAVE_FORMAT_PCM;
			wfx.nSamplesPerSec  = rate;
			wfx.nChannels       = 1;
			wfx.wBitsPerSample  = bits;
			wfx.nBlockAlign     = wfx.nChannels * ((wfx.wBitsPerSample + 7) / 8);
			wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
			wfx.cbSize	  = 0;

			m_apStreams[i]->m_mtOut.SetFormat((LPBYTE) &wfx, sizeof(wfx));

			m_apStreams[i]->m_mtOut.SetSampleSize(wfx.nBlockAlign);

			m_apStreams[i]->m_mtOut.SetTemporalCompression(FALSE);
		    } else {
			DbgLog((LOG_ERROR, 1, TEXT("Bad stream descriptor %hs"), pb));
			hr = E_FAIL;
		    }

		    while (*pb != ',' && *pb != '\r' && *pb != '\n')
			pb++;

		    i++;
		}

		if (FAILED(hr))
		    break;
		
		continue;
	    } else if (*pb == '[') {
		// [0, 5000] segment of the next file to play in milliseconds

		lStartMS = atol(pb+1);
		while (*pb != ',' && *pb != '\r')
		    pb++;

		if (*pb == ',') {
		    pb++;	// skip comma
		
		    lEndMS = atol(pb);
		}
		
		continue;
	    }

	    // otherwise, it's a filename.
	
	    DWORD dw = 0;

	    // figure length of this filename
	    while (pb[dw] && pb[dw] != '\r' && pb[dw] != '\n')
		dw++;

	    if (dw > MAX_PATH - 1)
		dw = MAX_PATH - 1;
	
	    WCHAR wszFile[MAX_PATH];
	
	    MultiByteToWideChar(CP_ACP, 0, pb, dw, wszFile, MAX_PATH);

	    // be sure it's null-terminated.
	    wszFile[dw] = L'\0';

	    DbgLog((LOG_TRACE, 2, TEXT("Next file in list: %ls"), wszFile));

	    CEditListEntry *pEntry = new CEditListEntry(wszFile,
							&hr,
							this);

	    if (pEntry == NULL)
		hr = E_OUTOFMEMORY;
	
	    if (FAILED(hr)) {
		delete pEntry;
		DbgLog((LOG_ERROR, 1, TEXT("Create edit list entry failed")));
		break;
	    }

	    pEntry->m_rtLocalStart = CRefTime(lStartMS);
	    pEntry->m_rtLocalStop = CRefTime(lEndMS);

#ifdef SEEKING_LATER
	    for (int i = 0; i < m_nStreams; i++) {
		m_apStreams[i]->m_Duration += (pEntry->m_rtLocalStop - pEntry->m_rtLocalStart);
	    }
#endif
	    lStartMS = 0;
	    lEndMS = 0;
	
	    if (m_pList) {
		m_pCurrent->m_pNext = pEntry;
	    } else {
		m_pList = pEntry;
		m_pNextToLoad = pEntry;
		m_pNextToUnload = pEntry;
	    }
	    m_pCurrent = pEntry;
	}
    }

#ifdef SEEKING_LATER
    // Set up our CSourcePosition variables
    for (int i = 0; i < m_nStreams; i++) {
	    m_apStreams[i]->m_Start = 0;
	    m_apStreams[i]->m_Stop = m_Duration;
    }

    DbgLog((LOG_TRACE, 1, TEXT("Guess at total duration: [%s, %s]"),
	    (LPCTSTR) CDisp(m_apStreams[0]->m_Start),
	    (LPCTSTR) CDisp(m_apStreams[0]->m_Stop)));

#endif

    // whether successful or not, we're done with the file now.
    delete[] pbFile;
    CloseHandle(hFile);

    if (m_nStreams == 0) {
	DbgLog((LOG_TRACE, 1, TEXT("Never got a format specifier!")));

	return E_FAIL;
    }

    if (m_pList == NULL) {
	DbgLog((LOG_ERROR, 1, TEXT("No entries in edit list")));
	return E_FAIL;
    }

    // !!! load the first file in the edit list to find out how many streams it should
    // have....
    // !!! do I need to do this anymore???
    if (SUCCEEDED(hr))
	hr = m_pList->LoadFilter(FALSE);

    if (FAILED(hr)) {
	DbgLog((LOG_ERROR, 1, TEXT("Failed to load first file in list")));
	return hr;
    }

    hr = m_pList->UnloadFilter();

    return hr;
}


STDMETHODIMP
CEditList::GetCurFile(
		LPOLESTR * ppszFileName,
                AM_MEDIA_TYPE *pmt)
{
    // return the current file name from avifile

    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName!=NULL) {
        *ppszFileName = (LPOLESTR) QzTaskMemAlloc( sizeof(WCHAR)
                                                 * (1+lstrlenW(m_pFileName)));
        if (*ppszFileName!=NULL) {
            lstrcpyW(*ppszFileName, m_pFileName);
        }
    }

    if (pmt) {
	pmt->majortype = GUID_NULL;   // Not meaningful
    }

    return NOERROR;
}


CELStream::CELStream(TCHAR *pObjectName,
		     HRESULT *phr,
		     CEditList *pDoc,
		     LPCWSTR pPinName) :
	   CBaseOutputPin(pObjectName, pDoc, &pDoc->m_InterfaceLock,
			  phr, pPinName),
           CSourcePosition(NAME("Source position object"),
                           NULL, phr, &pDoc->m_InterfaceLock),
	   m_pEditList(pDoc),
	   m_pCurrentInternalPin(NULL)
{

}

CELStream::~CELStream()
{
}

// override this to say what interfaces we support where
STDMETHODIMP
CELStream::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    // !!! need IMediaSeeking, IMediaPosition....

    return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
}


// Pass the quality mesage on upstream.

STDMETHODIMP
CELStream::Notify(IBaseFilter * pSender, Quality q)
{
    CheckPointer(pSender,E_POINTER);
    ValidateReadPtr(pSender,sizeof(IBaseFilter));

    // S_FALSE means we pass the message on.
    // Find the quality sink for our input pin and send it there

//    CAutoLock lck(&m_pEditList....)
    if (m_pCurrentInternalPin == NULL) {
        return E_FAIL;
    }

    return m_pCurrentInternalPin->PassNotify(q);

} // Notify



CEditListEntry::CEditListEntry(LPOLESTR lpFilename, HRESULT *phr,
			       CEditList *pEL) : CBaseObject(NAME("Edit list entry")),
    m_pNext(NULL),
    m_bKnowStart(FALSE),
    m_rtStart(),
    m_pEditList(pEL),
    m_pFilter(NULL),
    m_pGraphBuilder(NULL),
    m_pMediaControl(NULL),
    m_bReadyToUnload(FALSE)
{
    lstrcpyW(m_szFilename, lpFilename);
}


CELWorker::CELWorker()
{

}

HRESULT
CELWorker::Create(CEditList *pFilter)
{
    m_pFilter = pFilter;

    return CAMThread::Create();
}

// called on the worker thread to do all the work. Thread exits when this
// function returns.
DWORD
CELWorker::ThreadProc()
{
    BOOL bExit = FALSE;

    QzInitialize(NULL);

    while (!bExit) {

	Command cmd = GetRequest();

	switch (cmd) {

	case CMD_EXIT:
	    bExit = TRUE;
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
	    DoRunLoop();
	    break;

	case CMD_STOP:
	    Reply(NOERROR);
	    break;

	default:
	    Reply(E_NOTIMPL);
	    break;
	}
    }

    QzUninitialize();

    return NOERROR;
}

HRESULT
CELWorker::DoRunLoop()
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 2, TEXT("entering worker thread")));

    // re-set to first filter
    // !!! change when we support seeking....
    m_pFilter->m_pNextToLoad = m_pFilter->m_pList;
    m_pFilter->m_pNextToUnload = m_pFilter->m_pList;

    for (int i = 0; i < m_pFilter->m_nStreams; i++) {
	m_pFilter->m_apStreams[i]->m_pCurrentInternalPin = NULL;
    }

    while (1) {
	Command com;
	if (CheckRequest(&com)) {
	    if (com == CMD_STOP)
		break;
	}

	if (m_pFilter->m_pNextToLoad) {
	    DbgLog((LOG_TRACE, 4, TEXT("rtLastSent = %s, nextStart = %s"),
		    (LPCTSTR) CDisp(m_pFilter->m_rtLastSent),
		    (LPCTSTR) CDisp(m_pFilter->m_pNextToLoad->m_rtStart)));

	    if (((m_pFilter->m_rtLastSent + CRefTime(PRELOAD_TIME)) >
		 (m_pFilter->m_pNextToLoad->m_rtStart))) {
		hr = m_pFilter->m_pNextToLoad->LoadFilter(TRUE);

		if (FAILED(hr)) {
		    DbgLog((LOG_ERROR, 1, TEXT("Failed to load a file in our list!")));

		    m_pFilter->NotifyEvent(EC_ERRORABORT,hr,0);
		    // !!! how can we recover here?
		}


		m_pFilter->m_pNextToLoad = m_pFilter->m_pNextToLoad->m_pNext;

		// anything else?
	    }
	}

	if (m_pFilter->m_pNextToUnload &&
	    m_pFilter->m_pNextToUnload->m_bReadyToUnload) {
	    hr = m_pFilter->m_pNextToUnload->UnloadFilter();

	    if (FAILED(hr)) {
		ASSERT(0); // !!! can we just ignore this?

	    } else {
		m_pFilter->m_pNextToUnload =
			    m_pFilter->m_pNextToUnload->m_pNext;

		// anything else?
	    }
	}
	// !!! should sleep for a while here; really we want a
	// CheckRequest with a timeout....
	Sleep(50);
    }

    DbgLog((LOG_TRACE, 2, TEXT("getting ready to leave worker thread")));

    while (m_pFilter->m_pNextToUnload) {
	DbgLog((LOG_TRACE, 2, TEXT("Unloading an internal filter")));
	
	hr = m_pFilter->m_pNextToUnload->UnloadFilter();

	if (FAILED(hr)) {
	    ASSERT(0); // !!!
	}

	m_pFilter->m_pNextToUnload = m_pFilter->m_pNextToUnload->m_pNext;

    }

    return hr;
}



// !!!
// Seeking stuff, CSourcePosition is broken so we may not be able to base off of it
// Lots of work needed here.
//

HRESULT
CELStream::ChangeStart()
{
//    CAutoLock lock(this);

    DbgLog((LOG_TRACE, 1, TEXT("Start position changed")));


    // !!!!

    return S_OK;
}

HRESULT
CELStream::ChangeRate()
{
    // changing the rate means flushing and re-starting from current position
    return ChangeStart();
}

HRESULT
CELStream::ChangeStop()
{
    // if stop has changed when running, simplest is to
    // flush data in case we have gone past the new stop pos. Perhaps more
    // complex strategy later. Stopping and restarting the worker thread
    // like this should not cause a change in current position if
    // we have not changed start pos.
    return ChangeStart();
}


HRESULT
CELStream::Inactive()
{
    return S_OK;
}


HRESULT
CELStream::Active()
{
    return S_OK;
}


// !!! we need to force our allocator
HRESULT
CELStream::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    // the derived class may modify this in DecideBufferSize, but
    // we assume that he will consistently modify it the same way,
    // so we only get it once
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    /* Don't try the allocator provided by the input pin */

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}


HRESULT
CELStream::DecideBufferSize(IMemAllocator *pAllocator,
			       ALLOCATOR_PROPERTIES *pProperties)
{
    // !!!!

    ASSERT(pAllocator);
    ASSERT(pProperties);

    // !!! how do we decide how many to get ?

    // TOTAL HACK HERE !!!!
    if (*m_mtOut.Type() == MEDIATYPE_Video) {
	pProperties->cBuffers = 1;
	pProperties->cbBuffer = m_mtOut.GetSampleSize();

	if (pProperties->cbBuffer < 1024)
	    pProperties->cbBuffer = 65536;
    } else {
	pProperties->cBuffers = 4;

	pProperties->cbBuffer = 20000;  // !!!
    }

    // ask the allocator for these buffers
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    return NOERROR;
}

HRESULT
CELStream::GetMediaType(int iPos, CMediaType *pmt)
{
    if (iPos != 0)
	return S_FALSE;

    *pmt = m_mtOut;

    // !!! need to force a single media type, but which one?
    // !!! get from file?
    return S_OK;
}


BOOL AreEqualVideoTypes( const CMediaType *pmt1, const CMediaType *pmt2 )
{
    // The standard implementation is too strict - it demands an exact match
    // We just want to know is they are the same format and have the same
    // width / height

    ASSERT( IsEqualGUID( *pmt1->Type(), MEDIATYPE_Video ) );
    ASSERT( IsEqualGUID( *pmt2->Type(), MEDIATYPE_Video ) );
    ASSERT( *pmt1->FormatType() == FORMAT_VideoInfo );
    ASSERT( *pmt2->FormatType() == FORMAT_VideoInfo );

    VIDEOINFOHEADER *pvi1 = (VIDEOINFOHEADER *) pmt1->Format();
    VIDEOINFOHEADER *pvi2 = (VIDEOINFOHEADER *) pmt2->Format();

    return    IsEqualGUID( *pmt1->Subtype(), *pmt2->Subtype() )
           && pvi1->bmiHeader.biBitCount  == pvi2->bmiHeader.biBitCount
           && pvi1->bmiHeader.biWidth  == pvi2->bmiHeader.biWidth
           && pvi2->bmiHeader.biHeight == pvi2->bmiHeader.biHeight;
}


BOOL AreMediaTypesCloseEnough(const CMediaType *pmt1, const CMediaType *pmt2)
{
    if (*pmt1->Type() != *pmt2->Type())
	return FALSE;

    if (*pmt1->Type() == MEDIATYPE_Video) {
	if (*pmt1->FormatType() != FORMAT_VideoInfo)
	    return FALSE;
	
	return AreEqualVideoTypes(pmt1, pmt2);
    } else if (*pmt1->Type() == MEDIATYPE_Audio) {
	// don't compare subtypes for audio....
	return (pmt1->formattype == pmt2->formattype) && (pmt1->cbFormat == pmt2->cbFormat) &&
		  (memcmp(pmt1->pbFormat, pmt2->pbFormat, pmt1->cbFormat) == 0);
    }

    return (*pmt1 == *pmt2);
}


// verify that the type matches
HRESULT CELStream::CheckMediaType(CMediaType const *pmt)
{
    if (AreMediaTypesCloseEnough(pmt, &m_mtOut)) {
	DbgLog((LOG_TRACE, 4, TEXT("Succeeded")));

	return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP
CEditList::Pause()
{
    if (m_State == State_Stopped) {
	m_Worker.Create(this);
	m_Worker.CallWorker(CELWorker::CMD_RUN);
    }

    return CBaseFilter::Pause();
}

STDMETHODIMP
CEditList::Stop()
{
    if (m_State != State_Stopped) {
	// kill the worker thread
	m_Worker.CallWorker(CELWorker::CMD_STOP);
	m_Worker.CallWorker(CELWorker::CMD_EXIT);
    }

    return CBaseFilter::Stop();
}

// Called when we think it's time to load another file....
HRESULT
CEditListEntry::LoadFilter(BOOL fRunNow)
{
    HRESULT hr = QzCreateFilterObject(CLSID_FilterGraph, NULL,
				      CLSCTX_INPROC_SERVER,
				      IID_IGraphBuilder,
				      (void **) &m_pGraphBuilder);

    if (FAILED(hr)) {
	DbgLog((LOG_ERROR, 1, TEXT("Create Filter Graph failed")));
	
	return hr;
    }

    // somehow figure out how many internal pins we'll need,
    // and then call RenderFile or somesuch to render the source
    // file onto our internal streams.

    // make the internal filter object
    m_pFilter = new CInternalFilter(
	NAME("Internal Filter"),  // !!! make better name w/filename?
	m_pEditList,
	this,
	&hr);

    if (m_pFilter == NULL)
	hr = E_OUTOFMEMORY;

    if (FAILED(hr)) {
	delete m_pFilter;
	m_pFilter = NULL;

	DbgLog((LOG_ERROR, 1, TEXT("Create internal filter failed")));
	return hr;
    }

    IBaseFilter *pFilter;

    hr = m_pFilter->QueryInterface(IID_IBaseFilter, (void **) &pFilter);
    hr = m_pGraphBuilder->AddFilter(pFilter, NULL);

    pFilter->Release();  // graphbuilder keeps refcount

    DbgLog((LOG_TRACE, 2, TEXT("Loading filter for %ls..."),
	   m_szFilename));

    if (SUCCEEDED(hr)) {
#if 1
	// !!! quite possibly should use Connect instead of RenderFile here!
	// !!! this can create extra random renderers!
	
	hr = m_pGraphBuilder->RenderFile(m_szFilename, NULL);
#else
	IBaseFilter pFilter = NULL;
	hr = m_pGraphBuilder->AddSourceFilter(m_szFilename, NULL, &pFilter);

	if (FAILED(hr) || pFilter == NULL) {
	    DbgLog((LOG_ERROR, 1, TEXT("Failed to load %ls..."), m_szFilename));

	    return hr; // !!!
	}

	// !!! if we need a parser, get it now....
	// !!! this doesn't work any more now that we have parsers....


	if (FAILED(hr))
	    return hr;
	
	// now enumerate pins, connect them appropriately....

	IEnumPins *pEnum;
	hr = pFilter->EnumPins(&pEnum);

	if (SUCCEEDED(hr)) {
	    for (int i = 0; i < m_pEditList->m_nStreams; i++) {
		ULONG	ulActual;
		IPin	*aPin[1];

		hr = pEnum->Next(1, aPin, &ulActual);
		if (SUCCEEDED(hr) && (ulActual == 0) ) {	// no more pins
		    ASSERT(0);
		    break;
		} else if (FAILED(hr) || (ulActual != 1) ) {	// some unexpected problem occured
		    ASSERT(!"Pin enumerator broken");
		    break;
		}

		// !!! choose which pin to connect to based on media type of
		// this source pin, so we don't have to assume the streams are
		// in the same order for all source files....
			
		hr = m_pGraphBuilder->Connect(aPin[0], m_pFilter->GetPin(i));
		aPin[0]->Release();

		if (FAILED(hr)) {
		    DbgLog((LOG_ERROR, 1, TEXT("Failed to connect %ls output #%d to internal pin!"),
			    m_szFilename, i));
		}	
	    }
	    pEnum->Release();
	}

#endif
    }

    if (SUCCEEDED(hr)) {
	// !!! need to get length of this file so we'll know when to load
	// the one after....

	// note that we can't just use IMediaSeeking on the filter graph,
	// as our internal filters don't support it.

	// loop through internal pins calling get_Duration, use maximum
	// to know when to load next filter....
	CRefTime rtMax; // = 0;
	int i;
	for (i = 0; i < m_pEditList->m_nStreams; i++) {
	    IMediaSeeking * pMP;

	    ASSERT(m_pFilter->m_apInputs[i]->GetConnected());

	    if (m_pFilter->m_apInputs[i]->GetConnected()) {
		hr = m_pFilter->m_apInputs[i]->GetConnected()
				 ->QueryInterface(IID_IMediaSeeking,
							  (void **) &pMP);

		if (SUCCEEDED(hr)) {
		    CRefTime rt;

		    hr = pMP->GetDuration((REFERENCE_TIME *) &rt);

		    if (SUCCEEDED(hr)) {
			DbgLog((LOG_TRACE, 1, TEXT("Got duration of %s..."),
				(LPCTSTR) CDisp(rt)));
			if (rt > rtMax)
			    rtMax = rt;
		    } else {
			DbgLog((LOG_TRACE, 1, TEXT("Didn't get a duration")));
		    }

		    // if stop position wasn't set, do so now.
		    if (m_rtLocalStop == 0)
			m_rtLocalStop = rtMax;

		    pMP->SetPositions((REFERENCE_TIME *) &m_rtLocalStart,
				      AM_SEEKING_AbsolutePositioning,
				      (REFERENCE_TIME *) &m_rtLocalStop,
				      AM_SEEKING_AbsolutePositioning);

		    pMP->Release();

		} else {
		    DbgLog((LOG_TRACE, 1, TEXT("Didn't get IMediaSeeking")));
		}
	    }
	}

	if (SUCCEEDED(hr)) {
	    // don't use a clock for the internal graph, rely on blocking
	    // to make things work....
	    IMediaFilter *pMF;

	    hr = m_pGraphBuilder->QueryInterface(IID_IMediaFilter, (void **) &pMF);

	    // !!! it appears that doing this turns of QM entirely, which is not what
	    // we want.
	    // !!!
	    if (SUCCEEDED(hr)) {
#if 0
		hr = pMF->SetSyncSource(NULL);
#endif
		pMF->Release();
	    }
	    hr = m_pGraphBuilder->QueryInterface(IID_IMediaControl,
					    (void **) &m_pMediaControl);
	
	    if (FAILED(hr)) {
		DbgLog((LOG_ERROR, 1, TEXT("Error getting IMediaControl!")));
	    }
	
	    if (fRunNow) {
		// !!! Is this supposed to pause the filter?
		// probably, so it will be ready....

		hr = m_pMediaControl->Pause();

		// !!! really, we shouldn't run now, but should instead
		// run later when it's time for this segment to start
		// otherwise, we'll think we're behind and skip frames!
		hr = m_pMediaControl->Run();
	    }
	
	    // release all refcounts on our internal pins, so that
	    // one release() will kill the whole thing....

            m_pFilter->m_streamsDone = 0;
	} else {
	    DbgLog((LOG_ERROR, 1, TEXT("Error %lx from RenderFile")));
	}
    }

    DbgLog((LOG_TRACE, 1, TEXT("%ls: playing [%s, %s]"),
	    m_szFilename,
	    (LPCTSTR) CDisp(m_rtLocalStart),
	    (LPCTSTR) CDisp(m_rtLocalStop)));

    if (m_pNext) {
	m_pNext->m_rtStart = m_rtStart + (m_rtLocalStop - m_rtLocalStart);
	m_pNext->m_bKnowStart = TRUE;
	DbgLog((LOG_TRACE, 1, TEXT("Start of next file at %s..."),
		(LPCTSTR) CDisp(m_pNext->m_rtStart)));
    }

    return hr;
}

// Called when we think it's time to unload this file....
HRESULT
CEditListEntry::UnloadFilter()
{
    HRESULT hr = NOERROR;

    if (!m_pFilter)	// never loaded in the first place....
	return S_OK;

    DbgLog((LOG_TRACE, 2, TEXT("Unloading filter for %ls..."),
	   m_szFilename));

    // wake up all of our streams if they're blocked....
    for (int i = 0; i < m_pEditList->m_nStreams; i++) {
	m_pFilter->m_apInputs[i]->m_event.Set();
    }

    m_pMediaControl->Stop();
    m_pMediaControl->Release();
    m_pMediaControl = NULL;

    // this is about to become invalid....
    m_pFilter = NULL;

    // what do we have to release?
    m_pGraphBuilder->Release();

    // !!! some kind of assert that filgraph really went away?

    m_pGraphBuilder = NULL;

    return hr;
}



CInternalFilter::CInternalFilter(TCHAR *pName,
				 CEditList *pEditList,
				 CEditListEntry *pEntry,
				 HRESULT *phr) :
	   CBaseFilter(pName, NULL, &m_InterfaceLock, CLSID_NULL),
	   m_pEntry(pEntry),
	   m_pEditList(pEditList),
	   m_pImplPosition(NULL),
	   m_apInputs(NULL)
{
    ASSERT(m_pEditList->m_nStreams != 0);

    m_apInputs = new CInternalPin * [m_pEditList->m_nStreams];
    if (m_apInputs == NULL) {
	*phr = E_OUTOFMEMORY;
    } else {
	int i;
	for (i = 0; i < m_pEditList->m_nStreams; i++) {
	    m_apInputs[i] = new CInternalPin(m_pEditList->m_apStreams[i],
					     i,
					     this,
					     phr);

	
	    if (FAILED(phr)) {
		DbgLog((LOG_ERROR, 1, TEXT("Create internal pin failed")));
	    }

	    DbgLog((LOG_TRACE, 2, TEXT("Created internal pin[%d] %x"), i, m_apInputs[i]));
	
	    if (pEditList->m_apStreams[i]->m_pCurrentInternalPin == NULL) {
		DbgLog((LOG_TRACE, 2, TEXT("Setting currentinternal[%d] to %x"),
			i, m_apInputs[i]));
		pEditList->m_apStreams[i]->m_pCurrentInternalPin = m_apInputs[i];
	    }
	}
    }
}


CInternalFilter::~CInternalFilter()
{
    if (m_apInputs) {
	int i;
	for (i = 0; i < m_pEditList->m_nStreams; i++) {
	    delete m_apInputs[i];
	}
    }

    delete[] m_apInputs;
}

CInternalPin::CInternalPin(CELStream *pOutputPin,
			   int iPin,
			   CInternalFilter *pInternalFilter,
			   HRESULT *phr) :
    CBaseInputPin(NAME("Internal pin"),
		  pInternalFilter,
		  &pInternalFilter->m_InterfaceLock,
		  phr,
		  L"In"),   // !!! need different pin names?
    m_iPin(iPin),
    m_pOutputPin(pOutputPin),
    m_pInternalFilter(pInternalFilter),
    m_bWaitingForOurTurn(FALSE),
    m_bFlushing(FALSE)
{

}


HRESULT CInternalPin::CheckMediaType(const CMediaType *pmt)
 {
    DisplayType("Internal CheckMediaType", pmt);

    if (AreMediaTypesCloseEnough(pmt, &m_pOutputPin->m_mtOut)) {
	DbgLog((LOG_TRACE, 2, TEXT("Succeeded")));

	// !!! do this so we'll get the right palette....
	CopyMediaType(&m_pOutputPin->m_mtOut, pmt);
	return S_OK;
    }

    return S_FALSE;
}

HRESULT CInternalPin::Receive(IMediaSample *pSample)
{
    if (m_pOutputPin->m_pCurrentInternalPin != this) {
	// we are not the currently active editlist element,
	// and thus must block.

	// if this doesn't terminate, we'll feel bad. !!!
	// !!! be sure to set this event when stopping....
	DbgLog((LOG_TRACE, 2, TEXT("Waiting for our turn  us(%x) active(%x)...."),
	       this, m_pOutputPin->m_pCurrentInternalPin));

	m_bWaitingForOurTurn = TRUE;
	m_event.Wait();

	m_bWaitingForOurTurn = FALSE;
	
	if (m_bFlushing)
	    return S_FALSE;
	
	DbgLog((LOG_TRACE, 2, TEXT("Seems to be our turn....")));

	// !!! since this must be the first sample in our piece, set
	// the discontinuity flag?
	pSample->SetDiscontinuity(TRUE);
    }

    // adjust time stamps by start time of this piece....
    CRefTime rtStart, rtEnd;
    pSample->GetTime((REFERENCE_TIME *) &rtStart,
		     (REFERENCE_TIME *) &rtEnd);

    rtStart += m_pInternalFilter->m_pEntry->m_rtStart;
    rtEnd += m_pInternalFilter->m_pEntry->m_rtStart;

    if (rtEnd > m_pOutputPin->m_pEditList->m_rtLastSent)
	m_pOutputPin->m_pEditList->m_rtLastSent = rtEnd;

    DbgLog((LOG_TRACE, 4, TEXT("rtLastSent = %s, rtEnd = %s"),
	    (LPCTSTR) CDisp(m_pOutputPin->m_pEditList->m_rtLastSent),
	    (LPCTSTR) CDisp(rtEnd)));


    // !!! also need to adjust based on overall IMediaPosition settings,
    // which aren't done yet....

    pSample->SetTime((REFERENCE_TIME *) &rtStart,
		     (REFERENCE_TIME *) &rtEnd);


    // just pass it along via the appropriate output pin
    return m_pOutputPin->Deliver(pSample);
}



// Pass on the Quality notification q to our upstream filter
HRESULT CInternalPin::PassNotify(Quality q)
{
    // no sink set, so pass it upstream
    HRESULT hr;
    IQualityControl * pIQC;

    hr = VFW_E_NOT_FOUND;                   // default
    if (m_Connected) {
	m_Connected->QueryInterface(IID_IQualityControl, (void**)&pIQC);

	if (pIQC!=NULL) {
	    DbgLog((LOG_TRACE,3,TEXT("Passing Quality notification through transform")));
	    hr = pIQC->Notify(m_pInternalFilter, q);
	    pIQC->Release();
	}
    }
    return hr;
} // PassNotify



// keep track of the EOS's received by the various pins,
// and keep track of when it's okay to unload the file
// this filter owns.
HRESULT CInternalFilter::HandleEndOfStream(CELStream * pOutputPin)
{
    HRESULT hr = S_OK;

    if (++m_streamsDone < m_pEditList->m_nStreams)
        return S_OK;

    m_pEntry->m_bReadyToUnload = TRUE;

    // !!! wake the unloading thread?  set a semaphore?
    // not for now, it wakes up from time to time anyway.

    return hr;
}

// Called when the input pin receives an EndOfStream notification. If we have
// another stream to play, start it now, otherwise send the EOS on to the
// output pin.

HRESULT CInternalPin::EndOfStream()
{
    HRESULT hr;
    // Ignore these calls if we are stopped

    // CAutoLock !!!

    if (m_pInternalFilter->m_State == State_Stopped) {
        return NOERROR;
    }

    // was this the last file?
    if (m_pInternalFilter->m_pEntry->m_pNext == NULL) {
	DbgLog((LOG_TRACE, 2, TEXT("Last stream finished, sending EOS...")));
	hr = m_pOutputPin->DeliverEndOfStream();
    } else {
	// go to next file....

	DbgLog((LOG_TRACE, 2, TEXT("Stream finished, waking next stream...")));

	// it had better have been loaded already....
	ASSERT(m_pInternalFilter->m_pEntry->m_pNext->m_pFilter != NULL);

	// set the next filter to be active in Receive....
	m_pOutputPin->m_pCurrentInternalPin = m_pInternalFilter->m_pEntry->m_pNext->
						      m_pFilter->m_apInputs[m_iPin];
	// and wake it up....
	m_pInternalFilter->m_pEntry->m_pNext->m_pFilter->
			    m_apInputs[m_iPin]->m_event.Set();
    }


    // signal main filter that this stream is done so it can unload as needed
    return m_pInternalFilter->HandleEndOfStream(m_pOutputPin);
}


HRESULT CInternalPin::BeginFlush()
{
    // !!! CAutoLock

    // !!! what needs to be done here?  Will this ever happen,
    // given that we shouldn't generally be seeking the upstream
    // filters?

    m_bFlushing = TRUE;

    if (m_bWaitingForOurTurn) {
	m_event.Set();

    }
    return NOERROR;
}




HRESULT CInternalPin::EndFlush()
{
    // CAutoLock???

    m_bFlushing = FALSE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\xmltl.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
HRESULT BuildFromXMLFile(IAMTimeline *pTL, WCHAR *wszXMLFile);
HRESULT BuildFromXML(IAMTimeline *pTL, IXMLDOMElement *pxml);
HRESULT SaveTimelineToXMLFile(IAMTimeline *pTL, WCHAR *pwszXML);
HRESULT SaveTimelineToAVIFile(IAMTimeline *pTL, WCHAR *pwszAVI);
HRESULT InsertDeleteTLSection(IAMTimeline *pTL, REFERENCE_TIME rtStart, REFERENCE_TIME rtStop, BOOL fDelete);
HRESULT SavePartialToXMLFile(IAMTimeline *pTL, REFERENCE_TIME clipStart, REFERENCE_TIME clipEnd, WCHAR *pwszXML);
HRESULT PasteFromXMLFile(IAMTimeline *pTL, REFERENCE_TIME rtStart, WCHAR *wszXMLFile);
HRESULT SavePartialToXMLString(IAMTimeline *pTL, REFERENCE_TIME clipStart, REFERENCE_TIME clipEnd, HGLOBAL *ph);
HRESULT PasteFromXML(IAMTimeline *pTL, REFERENCE_TIME rtStart, HGLOBAL hXML);
HRESULT SaveTimelineToXMLString(IAMTimeline *pTL, BSTR *pbstrXML);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\dexter\xmltl\xmldom.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.

BSTR FindAttribute(IXMLDOMElement *p, LPWSTR name);
DWORD ParseNum(LPWSTR p);
LONG ReadNumAttribute(IXMLDOMElement *p, LPWSTR attrName, LONG lDefault = 0);
LONGLONG ParseTime(LPWSTR p);
LONGLONG ReadTimeAttribute(IXMLDOMElement *p, LPWSTR attrName, LONGLONG llDefault = 0);
BOOL ReadBoolAttribute(IXMLDOMElement *p, LPWSTR attrName, BOOL bDefault);

BSTR FindAttribute(IXMLDOMElement *p, LPWSTR name)
{
    VARIANT v;

    VariantInit(&v);
    
    HRESULT hr = p->getAttribute(name, &v);
    if( hr != NOERROR )
    {
        return NULL;
    }

    return V_BSTR(&v);
}

DWORD ParseNum(LPWSTR p)
{
    DWORD dwRet = 0;

    WCHAR c;
    while (((c = *p++) >= L'0') && (c <= L'9') )
	dwRet = (dwRet * 10) + (c - L'0');

    return dwRet;
}

LONG ReadNumAttribute(IXMLDOMElement *p, LPWSTR attrName, LONG lDefault /* = 0 */)
{
    BSTR val = FindAttribute(p, attrName);

    LONG lRet = lDefault;

    if (val) {
	lRet = ParseNum(val);

	SysFreeString(val);
    }

    return lRet;
}


LONGLONG ParseTime(LPWSTR p)
{
    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: parsing '%hs'"), p));
    
    WCHAR c = *p++;

    // !!! could handle SMPTE frames here?
    DWORD	dwSec = 0;
    DWORD	dwMin = 0;
    DWORD	dwFrac = 0;
    int		iFracPlaces = -1;
    while (c != L'\0') {
	if (c >= L'0' && c <= L'9') {
	    if (iFracPlaces >= 0) {
		++iFracPlaces;
		dwFrac = dwFrac * 10 + (c - L'0');
	    } else {
		dwSec = dwSec * 10 + (c - L'0');
            }
	} else if (iFracPlaces >= 0) {
            break;
        } else if (c == L':') {
	    dwMin = dwMin * 60 + dwSec;
	    dwSec = 0;
	} else if (c == L'.') {
	    iFracPlaces = 0;
	} else
	    break;	// !!! allow for skipping whitespace?

	c = *p++;
    }

    LONGLONG llRet = (LONGLONG) dwFrac * UNITS;
    while (iFracPlaces-- > 0) {
	llRet /= 10;
    }

    llRet += (LONGLONG) dwMin * 60 * UNITS + (LONGLONG) dwSec * UNITS;

    DbgLog((LOG_TRACE, 4, TEXT("ParseTime: returning %d ms"), (DWORD) (llRet / 10000)));
    
    return llRet;
}

LONGLONG ReadTimeAttribute(IXMLDOMElement *p, LPWSTR attrName, LONGLONG llDefault /* = 0 */)
{
    BSTR val = FindAttribute(p, attrName);

    LONGLONG llRet = llDefault;

    if (val) {
	llRet = ParseTime(val);

	SysFreeString(val);
    }

    return llRet;
}

BOOL ReadBoolAttribute(IXMLDOMElement *p, LPWSTR attrName, BOOL bDefault)
{
    BSTR val = FindAttribute(p, attrName);

    if (val) {
	WCHAR c = *val;
	if (c == L'y' || c == L'Y' || c == L't' || c == L'T' || c == L'1')
	    bDefault = TRUE;
	else if (c == L'n' || c == L'N' || c == L'f' || c == L'F' || c == L'0')
	    bDefault = FALSE;
	else {
	    DbgLog((LOG_ERROR, 1, TEXT("Looking for yes/no value, found '%ls'"), val));
	}

	SysFreeString(val);
    }

    return bDefault;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\editlist\editlist.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
// The classes
//	CEditList: The main filter -- loads .ELS files
//	CELStream: one output stream of the main filter
//	CEditListEntry: not a "quartz" object, represents one file in the edit list
//		if file is loaded, holds pointer to internal filter graph
//	CELWorker: background thread which waits for the proper time to load and
//		unload individual files and their corresponding internal graphs.
//	CInternalFilter: rendering filter of the internal graph
//	CInternalPin: input pins of internal rendering filter
//
//
// The general idea:
//	Since all of the files are not loaded at the same time, each file is kept
//	in a separate filter graph so that it can be unloaded while other things are
//	playing.  At any one time, one of the internal graphs is connected through to
//	the external output pin, while the other ones are blocked waiting for
//	their turn.
//
//	A background thread loads and unloads files when appropriate, so that you
//	could potentially have a very long sequence of files (hundreds or thousands)
//	without needing all of them open at once.
//
//
//
// The file format:
//	Eventually, this should probably be a component that an app would use
//	via some kind of ICutList interface, but for now it was easier to just
//	read the edit list information out of a text file.  See "samp.els" for
//	what the file looks like.
//

//
// See editlist.cpp for to-do list.
//



// forward declarations

class CELStream;	// owns a particular output stream
class CEditList;	// main filter
class CEditListEntry;	// represents one file in our list
class CInternalFilter;
class CInternalPin;

#define PRELOAD_TIME ((LONG) 10000)    // load filter 10 seconds before needed

// {0CB8B38C-6D62-11cf-BBEB-00AA00B944D8}
DEFINE_GUID(CLSID_EditList,
0xcb8b38c, 0x6d62, 0x11cf, 0xbb, 0xeb, 0x0, 0xaa, 0x0, 0xb9, 0x44, 0xd8);

// worker thread object
class CELWorker : public CAMThread
{

    CEditList * m_pFilter;

public:
    enum Command { CMD_RUN, CMD_STOP, CMD_EXIT };

private:
    // type-corrected overrides of communication funcs
    Command GetRequest() {
	return (Command) CAMThread::GetRequest();
    };

    BOOL CheckRequest(Command * pCom) {
	return CAMThread::CheckRequest( (DWORD *) pCom);
    };

    HRESULT DoRunLoop(void);

public:
    CELWorker();

    HRESULT Create(CEditList * pFilter);

    DWORD ThreadProc();

    // commands we can give the thread
    HRESULT Run();
    HRESULT Stop();

    HRESULT Exit();
};


// CELStream
// represents one stream of data within the file
// responsible for delivering data to connected components
//
// supports IPin
//
// never created by COM, so no CreateInstance or entry in global
// FactoryTemplate table. Only ever created by a CEditList object and
// returned via the EnumPins interface.
//

class CELStream : public CBaseOutputPin, CSourcePosition
{

public:

    CELStream(
	TCHAR *pObjectName,
	HRESULT * phr,
	CEditList * pDoc,
	LPCWSTR pPinName);

    ~CELStream();

    // expose IMediaPosition via CImplPosition, rest via CBaseOutputPin
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

    // IPin

    HRESULT GetMediaType(int iPosition, CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType*);

    // force our allocator to be used
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
	
    // say how big our buffers should be and how many we want
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Override to start & stop thread
    HRESULT Active();
    HRESULT Inactive();

    // override to receive Notification messages
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    CEditList * m_pEditList;

private:

    // below stuff is for IMediaPosition support,
    // which isn't really a priority....

    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();
    double Rate() {
	return m_Rate;
    };
    CRefTime Start() {
	return m_Start;
    };
    CRefTime Stop() {
	return m_Stop;
    };

public:
    CMediaType	    m_mtOut;	// media type this stream will output

    CInternalPin *  m_pCurrentInternalPin;
};


//
// CEditList
//
// responsible for
// -- finding .ELS file and parsing it
//
//
// supports (via nested implementations)
//  -- IBaseFilter
//  -- IFileSourceFilter
//

class CEditList : public CBaseFilter, public IFileSourceFilter
{

public:

    // constructors etc
    CEditList(LPUNKNOWN, HRESULT *);
    ~CEditList();

    DECLARE_IUNKNOWN
	
    // create a new instance of this class
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // override this to say what interfaces we support where
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // pin enumerator calls this
    int GetPinCount() {
	return m_nStreams;
    };

    CBasePin * GetPin(int n) {
	return m_apStreams[n];
    };

    LPOLESTR      m_pFileName;  // set by Load, used by GetCurFile
    BOOL	  m_fNoDecompress;

public:

    STDMETHODIMP Load(
		    LPCOLESTR pszFileName,
		    const AM_MEDIA_TYPE *pmt);

    STDMETHODIMP GetCurFile(
		    LPOLESTR * ppszFileName,
		    AM_MEDIA_TYPE *pmt);


    // override to control our worker thread
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

// implementation details

    friend class CELStream;
    friend class CELWorker;

    CELStream ** m_apStreams;
    int m_nStreams;

    CELWorker		m_Worker;	// worker thread object

    CEditListEntry *	m_pList;	// pointer to the whole list
    CEditListEntry *	m_pNextToLoad;	// next file which hasn't been loaded
    CEditListEntry *	m_pCurrent;	// pointer to currently playing file
    CEditListEntry *	m_pNextToUnload;// next file which is done, but hasn't
					// been unloaded.

    CRefTime		m_rtLastSent;

    CCritSec m_InterfaceLock;           // Critical section for interfaces
};


class CEditListEntry : CBaseObject {
public:
    CEditListEntry(LPOLESTR lpFilename, HRESULT *phr, CEditList *pEL);

    BOOL		    m_bKnowStart;
    CRefTime		    m_rtStart;

    CCritSec m_InterfaceLock;           // Critical section for interfaces

    CEditList *		    m_pEditList;

    // our internal sink filter
    CInternalFilter *	    m_pFilter;


    CRefTime		    m_rtLocalStart;
    CRefTime		    m_rtLocalStop;

    // graph builder used to make our internal graph
    IGraphBuilder *	    m_pGraphBuilder;

    IMediaControl *	    m_pMediaControl;

    // pointer to next file in edit list
    CEditListEntry *	    m_pNext;

    // are we finished playing?
    BOOL		    m_bReadyToUnload;

    // the file this entry represents
    OLECHAR		    m_szFilename[256];

    // private routines to actually load and unload the file
    HRESULT		    LoadFilter(BOOL fRunNow);
    HRESULT		    UnloadFilter();
};


class CInternalPin : public CBaseInputPin
{
protected:

    CELStream *m_pOutputPin;	    // output pin we deliver to
    CInternalFilter *m_pInternalFilter;

public:

    CInternalPin(CELStream *pOutputPin,
		 int iPin,
		 CInternalFilter *pInternalFilter,
		 HRESULT *phr);

    // Overriden from the base pin classes
    // HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT CheckMediaType(const CMediaType *pmt);
    // HRESULT Active();
    // HRESULT Inactive();


    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample *pMediaSample);


    // Pass a Quality notification on to the appropriate sink
    HRESULT PassNotify(Quality q);


    BOOL		    m_bWaitingForOurTurn;
    BOOL		    m_bFlushing;

    // this is the event we wait on while it's not our turn
    CAMEvent		    m_event;
    const int		    m_iPin;
};


class CInternalFilter : public CBaseFilter
{
protected:

    friend class CInternalPin;
    friend class CEditListEntry;

    CEditListEntry *m_pEntry;	    // currently playing file
    CEditList *m_pEditList;	    // owning edit list filter

    CPosPassThru *m_pImplPosition;      // IMediaPosition helper

    CInternalPin **m_apInputs;      // Our input pin object
    CCritSec m_InterfaceLock;           // Critical section for interfaces
    // CCritSec m_RendererLock;            // Controls access to internals

    int         m_streamsDone;

public:
    CInternalFilter(TCHAR *pName,         // Debug ONLY description
		    CEditList *pEditList,
		    CEditListEntry *pEntry,
		    HRESULT *phr);        // General OLE return code

    ~CInternalFilter();

    int GetPinCount() { return m_pEditList->GetPinCount(); };
    CBasePin *GetPin(int n) { return m_apInputs[n]; };

    HRESULT HandleEndOfStream(CELStream *pOutputPin);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\dmusic\dmlink.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.

  #ifndef _DMFilter_
  #define _DMFilter_

  #ifdef FILTER_DLL

  DEFINE_GUID(CLSID_DMFilter,
  0x119d0161, 0xb56a, 0x11d2, 0x95, 0x36, 0x0, 0x60, 0x8, 0x18, 0x40, 0xbc);

  #endif

  class CDMLink;
  class CDMFilter;
  class CDMFilterInputPin;
  class CDMFilterOutputPin;

  class CDMLink : public CUnknown, public IDirectMusicSynthSink, public IReferenceClock, public CCritSec

    { // CDMLink

      friend class CDMFilter;
      friend class CDMFilterOutputPin;

      private:

        CCritSec m_pLock;

        BOOL m_InitializedDM;

        IDirectMusic              *m_pDMusic;
        IDirectMusicPort          *m_pDMPort;
        IDirectMusicPerformance   *m_pDMPerf;
        IDirectMusicLoader        *m_pDMLoad;
        IDirectMusicSegment       *m_pDMSeg;
        IDirectMusicSegmentState  *m_pSegState;
        IKsControl                *m_pKSControl;
        IDirectSound              *m_piDS;

        IReferenceClock           *m_pirc;
        IDirectMusicSynth         *m_pidms;

        CDMFilterOutputPin *m_pOutput;
        CDMFilter *m_pFilter;

        LONGLONG m_llAbsWrite;

        REFERENCE_TIME m_rtMasterStamp;

        CAMEvent m_evEndSeg;

        DMUS_PORTPARAMS m_dmpp;

      public:

        CDMLink(CDMFilter *, CDMFilterOutputPin *);
        ~CDMLink();

        DECLARE_IUNKNOWN

        // Expose our custom interfaces
        STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

        HRESULT LoadDirectMusic();
        HRESULT InitDirectMusicPort();
        HRESULT HookDirectMusic();
        HRESULT InitSegmentNotification();
        HRESULT ExitDirectMusicBaggage();

        // IDirectMusicSynthSink
        STDMETHODIMP Init(IDirectMusicSynth *pSynth) { m_pidms = pSynth; return NOERROR; }
        STDMETHODIMP CDMLink::SetMasterClock(IReferenceClock *);
        STDMETHODIMP GetLatencyClock(IReferenceClock **);
        STDMETHODIMP SampleToRefTime(LONGLONG, REFERENCE_TIME *);
        STDMETHODIMP RefTimeToSample(REFERENCE_TIME, LONGLONG *);
        STDMETHODIMP Activate(BOOL) { return NOERROR; }
        STDMETHODIMP SetDirectSound(LPDIRECTSOUND, LPDIRECTSOUNDBUFFER) { return E_NOTIMPL; }
        STDMETHODIMP GetDesiredBufferSize(LPDWORD) { return E_NOTIMPL; }

        // IReferenceClock
        STDMETHODIMP GetTime(REFERENCE_TIME *);
        STDMETHODIMP AdviseTime(REFERENCE_TIME, REFERENCE_TIME, HEVENT, DWORD *) { return E_NOTIMPL; }
        STDMETHODIMP AdvisePeriodic(REFERENCE_TIME, REFERENCE_TIME, HSEMAPHORE, DWORD *)  { return E_NOTIMPL; }
        STDMETHODIMP Unadvise(DWORD)  { return E_NOTIMPL; }

    };

  class CDMFilterInputPin : public CBaseInputPin

    { // CDMFilterInputPin

      friend class CDMLink;

      private:

        CMediaType mtFormat[2];

        IAsyncReader *m_piAsyncRead;

        BYTE *m_pbMem;

        LONGLONG m_llMemLength;

      public:

        CDMFilterInputPin(TCHAR *, CDMFilter *, HRESULT *, LPCWSTR);

        ~CDMFilterInputPin();

        HRESULT GetMediaType(int, CMediaType *);
        HRESULT CheckMediaType(const CMediaType *);
        HRESULT CheckConnect(IPin *);
        HRESULT Inactive();

    };

  class CDMFilterOutputPin : public CBaseOutputPin, public CAMThread

    { // CDMFilterOutputPin

      friend class CDMLink;

      private:

        CMediaType mtFormat;

        BOOL m_bEndSegFound;

      public:

        // CBaseOutputPin
        CDMFilterOutputPin(TCHAR *, CDMFilter *, HRESULT *, LPCWSTR);

        HRESULT CheckMediaType(const CMediaType *) { return NOERROR; }
        HRESULT GetMediaType(int, CMediaType *);
        HRESULT DecideBufferSize(IMemAllocator *, ALLOCATOR_PROPERTIES *);
        HRESULT Active();
        HRESULT Inactive();

        // CAMThread
        DWORD ThreadProc();

    };

  class CDMFilter : public CBaseFilter, public CCritSec

    { // CDMFilter

      private:

        friend class CDMLink;
        friend class CDMFilterOutputPin;

        CDMFilterInputPin *m_pInput;
        CDMFilterOutputPin *m_pOutput;

        CDMLink *m_pLink;

      public:

        // CBaseFilter
        CDMFilter(TCHAR *, LPUNKNOWN, HRESULT *);

        ~CDMFilter();

        DECLARE_IUNKNOWN

        static CUnknown * WINAPI CreateInstance(LPUNKNOWN, HRESULT *);

        // CBaseFilter

        int GetPinCount(void) { return 2; }

        CBasePin *GetPin(int);

    };

  #ifdef FILTER_DLL

  const AMOVIESETUP_MEDIATYPE sudPinInputTypes =

    {
      &MEDIATYPE_Stream,
      &MEDIATYPE_NULL
    };

  const AMOVIESETUP_MEDIATYPE sudPinOutputTypes =

    {
      &MEDIATYPE_Stream,
      &MEDIATYPE_NULL
    };

  const AMOVIESETUP_PIN psudPins[] =

    {
      {
        L"Synthesized",
        FALSE,
        FALSE,
        FALSE,
        FALSE,
        &CLSID_NULL,
        L"Input",
        1,
        &sudPinOutputTypes
      }
    };

  const AMOVIESETUP_FILTER sudDMFilter =

    {
      &CLSID_DMFilter,
      L"Direct Music",
      MERIT_PREFERRED,//MERIT_DO_NOT_USE,
      1,
      psudPins
    };

  CFactoryTemplate g_Templates[1] =

    {
      {
        L"Direct Music",
        &CLSID_DMFilter,
        CDMFilter::CreateInstance,
        NULL,
        &sudDMFilter
      }
    };

  int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

  STDAPI DllRegisterServer()

    { // DllRegisterServer //

      return AMovieDllRegisterServer2(TRUE);

    } // DllRegisterServer //

  STDAPI DllUnregisterServer()

    { // DllUnregisterServer //

      return AMovieDllRegisterServer2(FALSE);

    } // DllUnregisterServer //

  #endif
  #endif

  // --- Key numerics ---

  const int OUTPUT_NUMBUFFERS=5;
  const int OUTPUT_FREQ=22050;
  const int OUTPUT_CHANNELS=2;
  const int OUTPUT_BITSPERSAMPLE=16;
  const int OUTPUT_BUFFER_TIMESLICE=100/*MS*/;
  const int OUTPUT_BUFFERSIZE=(((OUTPUT_FREQ*(OUTPUT_BITSPERSAMPLE*OUTPUT_CHANNELS))>>3)*OUTPUT_BUFFER_TIMESLICE)/1000;

  #define MILS_TO_REF	10000

  // Helpers
  LONGLONG SampleToByte(LONGLONG llSamples) {return llSamples << OUTPUT_CHANNELS;}
  DWORD SampleToByte(DWORD dwSamples) {return dwSamples << OUTPUT_CHANNELS;}
  LONGLONG ByteToSample(LONGLONG llBytes)   {return llBytes >> OUTPUT_CHANNELS;}
  DWORD ByteToSample(DWORD dwBytes)   {return dwBytes >> OUTPUT_CHANNELS;}
  LONGLONG SampleAlign(LONGLONG llBytes)    {return SampleToByte(ByteToSample(llBytes));}
  DWORD SampleAlign(DWORD dwBytes)    {return SampleToByte(ByteToSample(dwBytes));}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\metronom\metronom.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

/******************************************************************************
// This clock filter will listen to the sound card's input port, and listen
// for ticks.  The faster the ticks, the faster the clock will run.  So you can
// clap your hands into a microphone and control how fast a movie plays.
//
// NOTE: THIS FILTER DOES NOT WORK FOR AUDIO!!!
//      The default DSound renderer only allows ~2% variance in clocks.
//      This sample filter is intended to serve as a clock for a VIDEO clip.
//
// To use the filter:
//      - Build a filter graph with a video component (or audio and video)
//      - Delete the "Default DSound Renderer" from the graph (which removes
//          the reference clock from the graph)
//      - Select Graph->Insert Filters in GraphEdit
//      - Expand the DirectShow Filters node and insert the "Metronome" filter.
//      - Play the graph
//      - The video will begin playing at normal speed.  To modify the speed,
//          clap your hands or use a metronome to set a new speed.  For best
//          results, start clapping at the same rate that you were clapping
//          when you set the clock rate.
//
//  Please refer to this sample's README.TXT file for more instructions.
//
****************************************************************************** 
//
//  Release Notes
//  =============
//
//  0.  This filter opens the waveIn device whenever it is around, so you can't
//  have any other app that is recording audio running at the same time. Sorry.
//
//  1.  This filter works for VIDEO ONLY.  Our audio renderer is not capable 
//  of slaving  to radically different clock rates.   Make a graph in graphedit 
//  of some video file, and then Insert the "metronome" filter into the graph.  
//  If the clip contains an audio component, then remove the "Default DSound 
//  Renderer" from the filter graph.  Play the graph.
//
//  2.  Clap into your microphone.  If you clap 92 times per minute (once every 
//  ~652 ms) the movie will play at the normal rate.  You can change this default 
//  near the top of the .cpp file.  Clap faster or slower, and the playback rate 
//  of the video will change accordingly.  
//
//  3.  Or, hook up an electronic metronome by a cable to your sound card, and 
//  turn the dial and watch the video playback speed change.
//
//  4.  If you don't clap for any length of time, it keeps on at the old rate, 
//  so you can give your hands a rest.  But when you start clapping again, you must 
//  start clapping at about the same speed you left off at, and then slow down 
//  or speed up, or it will ignore you.  To be precise:  Don't suddenly start 
//  clapping more than TWICE as slow as you were before you stopped, or you'll 
//  be ignored.
//
//  5.  DShow can't play infinitely fast.  The limit depends on your CPU speed.  
//  If you try and go much faster than is possible for any length of time, it will 
//  get confused, will stop working, and you won't be able to slow it down.  
//  Press STOP and PLAY again.
//
//
//  The only important rule for writing a clock is this:  
//      Your clock can NEVER GO BACKWARDS!
//
//   When you are asked what time it is, never give a time before the last 
//   reported time.
//
******************************************************************************/


#include <streams.h>
#include <initguid.h>
#include <limits.h>
#include <olectl.h>

#include "metronom.h"

#pragma warning(disable:4355)

//
//  Beats per minute - this value will be considered to be "standard" speed.
//  (MIDI applications often use 120 BPM to be the standard.)
//
#define BPM 92      // normal clock speed - when the metronome ticks at
            // this rate, we'll provide normal wall clock time
            // (NOTE: You can set this to any value, depending on what kind
            // of metronome you're using.)

//
//  Sound threshold that must be reached in order to achieve a valid "beat".
//  If your sound card volume is set too high, then all sounds (including
//  background noise) may be registered as being above this threshold.
//
#define THRESHOLD 150   // 8 bit samples above this value are HIGH (remember,
            // 128 is silence), else they are LOW
            // (leaving 128-255 values as valid)

#define BUFSIZE 3072    // size per wave buffer


//
//  Filter registration
//
CFactoryTemplate g_Templates[] =
{
    {L"Metronome Filter", &CLSID_MetronomeFilter, CMetronomeFilter::CreateInstance},
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
AMOVIESETUP_FILTER sudMetronomeFilter = { &CLSID_MetronomeFilter, L"Metronome Filter", 0x20, 0, 0 };


CMetronomeFilter::CMetronomeFilter(LPUNKNOWN pUnk, HRESULT *phr)
: CBaseFilter(NAME("Metronome Filter"), pUnk, &m_Lock, CLSID_NULL)
, m_Clock(static_cast<IBaseFilter*>(this), phr)
{
    // Set the protected variable in CBaseFilter so that
    // CBaseFilter::GetClassID reports the correct ClassID!
    m_clsid = CLSID_MetronomeFilter;
}

//
// CreateInstance
//
CUnknown *CMetronomeFilter::CreateInstance(LPUNKNOWN punk, HRESULT *phr)
{
    CMetronomeFilter *pNewObject = new CMetronomeFilter(punk, phr);
    if(pNewObject == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }

    return pNewObject;
}

STDMETHODIMP CMetronomeFilter::NonDelegatingQueryInterface( REFIID riid, void ** ppv )
{
    CheckPointer(ppv, E_POINTER);

    if(riid == IID_IReferenceClock)
    {
        return GetInterface(static_cast<IReferenceClock*>(&m_Clock), ppv);
    }
    else
    {
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


//  Pin enumeration
int CMetronomeFilter::GetPinCount()
{
    return 0;
}

CBasePin *CMetronomeFilter::GetPin(int i)
{
    UNREFERENCED_PARAMETER(i);
    return NULL;
}

STDMETHODIMP CMetronomeFilter::JoinFilterGraph( IFilterGraph * pGraph, LPCWSTR pName )
{
    m_Clock.JoinFilterGraph(pGraph);
    return CBaseFilter::JoinFilterGraph(pGraph, pName);
}

STDMETHODIMP CMetronomeFilter::SetSyncSource(IReferenceClock * pClock)
{
    m_Clock.SetSyncSource(pClock);
    return CBaseFilter::SetSyncSource(pClock);
}

//
// Exported entry points for registration and unregistration 
// (in this case they only call through to default implmentations).
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
}

//
// GetSetupData
//
LPAMOVIESETUP_FILTER CMetronomeFilter::GetSetupData()
{
    return &sudMetronomeFilter;
}


//
// CMetronome methods
//
CMetronome::CMetronome(LPUNKNOWN pUnk, HRESULT *phr)
: CBaseReferenceClock(NAME("Metronome Filter Clock"), pUnk, phr)
, m_pCurrentRefClock(0), m_pPrevRefClock(0)
, m_pFilterGraph(0)
{
    // !!! failure?
    OpenWaveDevice();
    // last time we reported
    m_dwLastMet = 0;
    // similar to m_LastMet, but used to help switch between clocks somehow
    m_dwPrevSystemTime = timeGetTime();
    // what timeGetTime said last time we heard a tick
    m_LastTickTGT = m_dwPrevSystemTime;
    // the number we reported last time we heard a tick
    m_LastTickTime = m_LastTickTGT;
    // the last time we reported (in 100ns units)
    m_rtPrivateTime = (UNITS / MILLISECONDS) * m_dwPrevSystemTime;
    // what timeGetTime said the last time we were asked what time it was
    m_dwLastTGT = m_dwPrevSystemTime;

    // We start off assuming the clock is running at normal speed
    m_msPerTick = 60000 / BPM;

    DbgLog((LOG_TRACE,1,TEXT("Creating clock at ref tgt=%d"), m_LastTickTime));
}


CMetronome::~CMetronome(void)
{
    CloseWaveDevice();
}

STDMETHODIMP CMetronomeFilter::Pause()
{
    if(m_State == State_Stopped)
    {
        m_Clock.StartWaveDevice();
    }
    return CBaseFilter::Pause();
}


STDMETHODIMP CMetronomeFilter::Stop()
{
    m_Clock.StopWaveDevice();
    return CBaseFilter::Stop();
}


REFERENCE_TIME CMetronome::GetPrivateTime()
{
    CAutoLock cObjectLock(this);

    /* If the clock has wrapped then the current time will be less than
    * the last time we were notified so add on the extra milliseconds
    *
    * The time period is long enough so that the likelihood of
    * successive calls spanning the clock cycle is not considered.
    */

    // This returns the current time in ms according to our special clock.  If
    // we used timeGetTime() here, our clock would run normally.
    DWORD dwTime = MetGetTime();
    {
        REFERENCE_TIME delta = REFERENCE_TIME(dwTime) - REFERENCE_TIME(m_dwPrevSystemTime);
        if(dwTime < m_dwPrevSystemTime) delta +=  REFERENCE_TIME(UINT_MAX) + 1;
        m_dwPrevSystemTime = dwTime;

        delta *= (UNITS / MILLISECONDS);
        m_rtPrivateTime += delta;
        //DbgLog((LOG_TRACE,3,TEXT("MetTGT=%d, reporting ref %d"), dwTime, (DWORD)(m_rtPrivateTime * MILLISECONDS / UNITS)));
    }

    return m_rtPrivateTime;
}

void CMetronome::JoinFilterGraph( IFilterGraph * pGraph )
{
    if(pGraph) 
        EXECUTE_ASSERT(SUCCEEDED(pGraph->QueryInterface(IID_IMediaFilter, reinterpret_cast<void**>(&m_pFilterGraph))));
    else
    {
        ASSERT(m_pFilterGraph);
        m_pFilterGraph->Release();
    }
}

void CMetronome::SetSyncSource(IReferenceClock * pClock)
{
    m_pPrevRefClock = m_pCurrentRefClock;
    if(pClock)
    {
        m_dwPrevSystemTime = timeGetTime();
        if(IsEqualObject(pClock, pUnk()))
        {
            // Sync this clock up to the old one - just to be nice - for now
            m_LastTickTGT = m_dwPrevSystemTime;
            m_LastTickTime = m_LastTickTGT;
            m_rtPrivateTime = (UNITS / MILLISECONDS) * m_dwPrevSystemTime;
            if(m_pPrevRefClock)
            {
                if(SUCCEEDED(m_pPrevRefClock->GetTime(&m_rtPrivateTime)))
                {
                    // !!!
                    m_dwPrevSystemTime += timeGetTime();
                    m_dwPrevSystemTime /= 2;
                }
                else ASSERT(FALSE);
            }

            DbgLog((LOG_TRACE,1,TEXT("*** USING OUR CLOCK : reference is %d at tgt %d"), (DWORD)(MILLISECONDS * m_rtPrivateTime / UNITS), m_LastTickTime));

        }
        else
        {
            // Sync our clock up to the new one
            m_LastTickTGT = m_dwPrevSystemTime;
            m_LastTickTime = m_LastTickTGT;
            EXECUTE_ASSERT(SUCCEEDED(pClock->GetTime(&m_rtPrivateTime)));

            // !!!
            m_dwPrevSystemTime += timeGetTime();
            m_dwPrevSystemTime /= 2;

            DbgLog((LOG_TRACE,1,TEXT("*** USING SOMEONE ELSE'S CLOCK : reference is %d at tgt %d"), (DWORD)(MILLISECONDS * m_rtPrivateTime / UNITS), m_LastTickTime));
        }
    }
    m_pCurrentRefClock = pClock;
}

// The last time the metronome ticked we reported m_LastTickTime
// and timeGetTime() reported m_LastTimeTGT.
// It is currently ticking at a rate of m_msPerTick ms per tick
// When it ticks at 60000/BPM ms per tick, that's normal clock time
// The last time somebody called us, we returned m_dwLastMet
//
DWORD CMetronome::MetGetTime(void)
{
    // Don't let anybody change our time variables on us while we're using them
    m_csClock.Lock();
    LONGLONG lfudge;    // mmm... fudge

    // how many ms have elapsed since last time we were asked?
    DWORD tgt = timeGetTime();
    LONGLONG lms = tgt - m_LastTickTGT;

    // How many ms do we want to pretend elapsed?
    if(m_msPerTick)
        lfudge = lms * (60000 / BPM) / (LONGLONG)m_msPerTick;
    else
        lfudge = 0; // !!!

    // that's the new time to report
    DWORD dw = m_LastTickTime + (DWORD)lfudge;
    m_csClock.Unlock();

    // Under no circumstances let the clock run backwards.  Just stall it.
    if(dw < m_dwLastMet)
    {
        dw = m_dwLastMet;
        DbgLog((LOG_TRACE,1,TEXT("*** ACK! Tried to go backwards!")));
    }

    DbgLog((LOG_TRACE,3,TEXT("MetTGT: %dms elapsed. Adjusted to %dms"),
        (int)lms, (int)lfudge));
    DbgLog((LOG_TRACE,3,TEXT("        returning %d TGT=%d"), (int)dw,
                                                (int)timeGetTime()));
        
    m_dwLastMet = dw;
    m_dwLastTGT = tgt;
    return dw;
}

STDMETHODIMP CMetronome::OpenWaveDevice(void)
{
    WAVEFORMATEX wfx;

    // who cares about quality, do what's quickest - 8 bit MONO 11kHz
    wfx.wFormatTag      = WAVE_FORMAT_PCM;
    wfx.nSamplesPerSec  = 11025;
    wfx.nChannels       = 1;
    wfx.wBitsPerSample  = 8;
    wfx.nBlockAlign     = wfx.nChannels * ((wfx.wBitsPerSample + 7) / 8);
    wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
    wfx.cbSize    = 0;

    DbgLog((LOG_TRACE,1,TEXT("*** Opening wave device....")));
    UINT err = waveInOpen(&m_hwi,
        WAVE_MAPPER,
        &wfx,
        (DWORD) &CMetronome::Callback,
        (DWORD) this,
        CALLBACK_FUNCTION);

    if(err != 0)
    {
        DbgLog((LOG_ERROR,1,TEXT("Error opening wave device: %u"), err));
        return E_FAIL;
    }
    waveInStop(m_hwi);

    // 4 buffers should be good enough
    DbgLog((LOG_TRACE,1,TEXT("allocating wave buffers")));
    m_pwh1 = (LPWAVEHDR)QzTaskMemAlloc(sizeof(WAVEHDR) + BUFSIZE);
    m_pwh2 = (LPWAVEHDR)QzTaskMemAlloc(sizeof(WAVEHDR) + BUFSIZE);
    m_pwh3 = (LPWAVEHDR)QzTaskMemAlloc(sizeof(WAVEHDR) + BUFSIZE);
    m_pwh4 = (LPWAVEHDR)QzTaskMemAlloc(sizeof(WAVEHDR) + BUFSIZE);

    if(!m_pwh1 || !m_pwh2 || !m_pwh3 || !m_pwh4)
    {
        if(m_pwh1) QzTaskMemFree(m_pwh1);
        if(m_pwh2) QzTaskMemFree(m_pwh2);
        if(m_pwh3) QzTaskMemFree(m_pwh3);
        if(m_pwh4) QzTaskMemFree(m_pwh4);
        DbgLog((LOG_ERROR,1,TEXT("ERROR allocating wave buffers")));
        waveInClose(m_hwi);
        return E_FAIL;
    }

    _fmemset(m_pwh1, 0, sizeof(WAVEHDR));
    _fmemset(m_pwh2, 0, sizeof(WAVEHDR));
    _fmemset(m_pwh3, 0, sizeof(WAVEHDR));
    _fmemset(m_pwh4, 0, sizeof(WAVEHDR));

    m_pwh1->lpData = (LPSTR)m_pwh1 + sizeof(WAVEHDR);
    m_pwh1->dwBufferLength = BUFSIZE;
    m_pwh1->dwBytesRecorded = 0;
    m_pwh2->lpData = (LPSTR)m_pwh2 + sizeof(WAVEHDR);
    m_pwh2->dwBufferLength = BUFSIZE;
    m_pwh2->dwBytesRecorded = 0;
    m_pwh3->lpData = (LPSTR)m_pwh3 + sizeof(WAVEHDR);
    m_pwh3->dwBufferLength = BUFSIZE;
    m_pwh3->dwBytesRecorded = 0;
    m_pwh4->lpData = (LPSTR)m_pwh4 + sizeof(WAVEHDR);
    m_pwh4->dwBufferLength = BUFSIZE;
    m_pwh4->dwBytesRecorded = 0;

    DbgLog((LOG_TRACE,1,TEXT("preparing headers")));
    DWORD dw1 = waveInPrepareHeader(m_hwi, m_pwh1, sizeof(WAVEHDR));
    DWORD dw2 = waveInPrepareHeader(m_hwi, m_pwh2, sizeof(WAVEHDR));
    DWORD dw3 = waveInPrepareHeader(m_hwi, m_pwh3, sizeof(WAVEHDR));
    DWORD dw4 = waveInPrepareHeader(m_hwi, m_pwh4, sizeof(WAVEHDR));
    if(dw1 || dw2 || dw3 || dw4)
    {
        DbgLog((LOG_ERROR,1,TEXT("error %d preparing headers"), dw1));
    }


    return NOERROR;
}


STDMETHODIMP CMetronome::StartWaveDevice(void)
{
    DbgLog((LOG_TRACE,1,TEXT("*** Starting the wave device")));

    DbgLog((LOG_TRACE,1,TEXT("adding buffers")));
    DWORD dw1 = waveInAddBuffer(m_hwi, m_pwh1, sizeof(WAVEHDR));
    DWORD dw2 = waveInAddBuffer(m_hwi, m_pwh2, sizeof(WAVEHDR));
    DWORD dw3 = waveInAddBuffer(m_hwi, m_pwh3, sizeof(WAVEHDR));
    DWORD dw4 = waveInAddBuffer(m_hwi, m_pwh4, sizeof(WAVEHDR));
    if(dw1 || dw2 || dw3 || dw4)
    {
        DbgLog((LOG_ERROR,1,TEXT("error %d adding the buffers"), dw1));
    }

    m_fWaveRunning = TRUE;

    m_SamplesSinceTick = 0;
    m_SamplesSinceSpike = 0;
    m_fSpikeAtStart = FALSE;

    dw1 = waveInStart(m_hwi);
    if(dw1)
    {
        DbgLog((LOG_ERROR,1,TEXT("error %d starting the wave device"), dw1));
    }

    return NOERROR;
}



STDMETHODIMP CMetronome::StopWaveDevice(void)
{
    DbgLog((LOG_TRACE,1,TEXT("*** Stopping the wave device")));
    m_fWaveRunning = FALSE;

    if(m_hwi)
    {
        waveInStop(m_hwi);
        waveInReset(m_hwi);
    }
    return NOERROR;
}


STDMETHODIMP CMetronome::CloseWaveDevice(void)
{
    DbgLog((LOG_TRACE,1,TEXT("*** Closing down the wave device")));

    if(m_hwi)
    {
        waveInUnprepareHeader(m_hwi, m_pwh1, sizeof(WAVEHDR));
        waveInUnprepareHeader(m_hwi, m_pwh2, sizeof(WAVEHDR));
        waveInUnprepareHeader(m_hwi, m_pwh3, sizeof(WAVEHDR));
        waveInUnprepareHeader(m_hwi, m_pwh4, sizeof(WAVEHDR));
        waveInClose(m_hwi);
    }
    return NOERROR;
}


// This function is given a bunch of input wave data and finds a tick or spike
// in the sound.  It returns how many bytes into the data the spike begins.
// Once it finds a tick, it sets m_fSpikeAtStart, which means there is a spike
// at the beginning of the data that is left that we need to skip past before
// we start looking for another spike
// returning -1 means there is no spike
int CMetronome::FindSpike(LPBYTE lp, int len)
{
    int lenOrig = len;

TryAgain:
    // too small to deal with
    if(len < 2)
        return -1;

    // we are supposed to skip any spike at the beginning of this buffer
    // we wait until we see 2 samples in a row under the threshold.
    if(m_fSpikeAtStart)
    {
        while(len >=2 && (*lp > THRESHOLD || *(lp+1) > THRESHOLD))
        {
            lp++;
            len--;
            m_SamplesSinceSpike++;
        }
        if(len < 2)
            return -1;
    }
    m_fSpikeAtStart = FALSE;

    // look for spike - at least 2 consecutive samples above the threshold
    while(len >=2 && (*lp <= THRESHOLD || *(lp+1) <= THRESHOLD))
    {
        lp++;
        len--;
        m_SamplesSinceSpike ++;
    }
    if(len < 2)
        return -1;

    m_fSpikeAtStart = TRUE;

    // too close together, don't count it - so random music or frequncies above
    // 100 Hz or so will be seen as silence with no ticks.  This way if you are
    // using a digital metronome and set it to generate A440 it won't make the
    // clock go wild.
    if(m_SamplesSinceSpike < 1000)
    {
        m_SamplesSinceSpike = 0;
        goto TryAgain;
    }

    m_SamplesSinceSpike = 0;
    return lenOrig - len;
}


void CALLBACK CMetronome::Callback(HDRVR hdrvr, UINT uMsg, DWORD dwUser,
                                   DWORD dw1, DWORD dw2)
{
    CMetronome *pFilter = (CMetronome *) dwUser;

    switch(uMsg)
    {
        case WIM_DATA:
        {
            // really need a second worker thread here, because
            // one shouldn't do this much in a wave callback.

            LPWAVEHDR lpwh = (LPWAVEHDR) dw1; // !!! verify?

            DbgLog((LOG_TRACE,4,TEXT("WAVEIN Callback: %d bytes recorded"),
                lpwh->dwBytesRecorded));

            LPBYTE lp = (LPBYTE)(lpwh->lpData);
            int len = lpwh->dwBytesRecorded;
            int spike;

            // look for a spike in this buffer we just recorded
            while((spike = pFilter->FindSpike(lp, len)) != -1)
            {

                // don't let anybody else mess with our timing variables
                pFilter->m_csClock.Lock();
                lp += spike;
                len -= spike;

                // How long has it been since we saw a tick?
                pFilter->m_SamplesSinceTick += spike;
                DWORD msPerTickPrev = pFilter->m_msPerTick;

                // Even though we just got the callback now, this stuff was
                // recorded who knows how long ago, so what we're doing is not
                // entirely correct... we're assuming that since we just noticed
                // the tick means that it happened right now.  As long as our
                // buffers are really small, and the system is very responsive,
                // this won't be too bad.
                DWORD dwTGT = timeGetTime();

                // deal with clock stopping altogether for a while - pretend
                // it kept ticking at its old rate or else we will think we're
                // way ahead and the clock will freeze for the length of time
                // the clock was stopped
                // So if it's been a while since the last tick, don't use that
                // long interval as a new tempo.  This way you can stop clapping
                // and the movie will keep the current tempo until you start
                // clapping a new tempo.
                // (If it's been > 1.5s since the last tick, this is probably
                //  the start of a new tempo).
                if(pFilter->m_SamplesSinceTick * 1000 / 11025 > 1500)
                {
                    DbgLog((LOG_TRACE,2,TEXT("Ignoring 1st TICK after long gap")));
                }
                else
                {
                    // running our clock at the old rate, we'd be here right now
                    pFilter->m_LastTickTime = pFilter->m_dwLastMet +
                        (dwTGT - pFilter->m_dwLastTGT) *
                        (60000 / BPM) / pFilter->m_msPerTick;
                    pFilter->m_msPerTick = (DWORD)((LONGLONG)
                        pFilter->m_SamplesSinceTick * 1000 / 11025);
                    pFilter->m_LastTickTGT = dwTGT;
                    DbgLog((LOG_TRACE,2,TEXT("TICK! after %dms, reporting %d tgt=%d"), pFilter->m_msPerTick, pFilter->m_LastTickTime, pFilter->m_LastTickTGT));
                }

                pFilter->m_SamplesSinceTick = 0;
                pFilter->m_csClock.Unlock();
            }

            // we went the whole buffer without seeing a tick.
            pFilter->m_SamplesSinceTick += len;

            if(pFilter->m_fWaveRunning)
            {
                    DbgLog((LOG_TRACE,4,TEXT("Sending the buffer back")));
                    waveInAddBuffer(pFilter->m_hwi, lpwh, sizeof(WAVEHDR));
            }

        }
        break;

        case WIM_OPEN:
        case WIM_CLOSE:
            break;

        default:
            DbgLog((LOG_TRACE,2,TEXT("Unexpected wave callback message %d"), uMsg));
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\metronom\metronom.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

class CMetronomeFilter;

class CMetronome : public CBaseReferenceClock
{
    friend class CMetronomeFilter;
public:
    ~CMetronome();
    CMetronome(LPUNKNOWN pUnk, HRESULT *phr);

    REFERENCE_TIME GetPrivateTime();

    void SetSyncSource( IReferenceClock *pClock );
    void JoinFilterGraph( IFilterGraph * pGraph );

    IUnknown * pUnk() 
    { return static_cast<IUnknown*>(static_cast<IReferenceClock*>(this)); }

private:

    DWORD MetGetTime(void);
    static void Callback(HDRVR hdrvr, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2);
    STDMETHODIMP OpenWaveDevice(void);
    STDMETHODIMP CloseWaveDevice(void);
    STDMETHODIMP StartWaveDevice(void);
    STDMETHODIMP StopWaveDevice(void);
    int FindSpike(LPBYTE lp, int len);

    REFERENCE_TIME    m_rtPrivateTime;
    DWORD   m_dwPrevSystemTime;

    DWORD	m_msPerTick;
    DWORD	m_LastTickTime;
    DWORD	m_LastTickTGT;
    HWAVEIN	m_hwi;
    LPWAVEHDR	m_pwh1, m_pwh2, m_pwh3, m_pwh4;
    BOOL	m_fWaveRunning;
    DWORD	m_SamplesSinceTick;
    DWORD	m_SamplesSinceSpike;
    BOOL	m_fSpikeAtStart;
    DWORD	m_dwLastMet;
    DWORD	m_dwLastTGT;
    CCritSec    m_csClock;

    IReferenceClock * m_pCurrentRefClock;
    IReferenceClock * m_pPrevRefClock;

    // This is the IMediaFilter interface of the filter garph!
    IMediaFilter    * m_pFilterGraph;
};

class CMetronomeFilter : public CBaseFilter
{
public:

    //  Make one of these
    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

    //  Constructor
    CMetronomeFilter(LPUNKNOWN pUnk, HRESULT *phr);

    DECLARE_IUNKNOWN

    // New NDQI
    STDMETHODIMP NonDelegatingQueryInterface( REFIID riid, void ** ppv);
    // Self-registration stuff
    LPAMOVIESETUP_FILTER GetSetupData();

    //  CBaseFilter methods
    int CMetronomeFilter::GetPinCount();
    CBasePin *CMetronomeFilter::GetPin(int iPin);
    STDMETHODIMP JoinFilterGraph( IFilterGraph * pGraph, LPCWSTR pName);

    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);

protected:
    ~CMetronomeFilter()
    {}

private:
    CMetronome              m_Clock;
    //  Locking
    CCritSec                m_Lock;

};

// Our class id
// Metronome filter object
DEFINE_GUID(CLSID_MetronomeFilter,
0x08d5ec80, 0xb00b, 0x11cf, 0xb3, 0xf0, 0x0, 0xaa, 0x0, 0x37, 0x61, 0xc5);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\dmusic\dmlink.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.

  #include <streams.h>
  #include <initguid.h>

  #pragma warning(disable:4355 4201 4244)

  #include "dmusicc.h"
  #include "dmusici.h"
  #include "dmusics.h"
  #include "dmksctrl.h"
  #include "dmlink.h"

  /// !!!! I N P U T   P I N !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  CDMFilterInputPin::CDMFilterInputPin(TCHAR *pName, CDMFilter *pParent, HRESULT *phr, LPCWSTR pPinName) : CBaseInputPin(pName, pParent, pParent, phr, pPinName), m_piAsyncRead(NULL)

    { // Constructor //

      mtFormat[0].majortype = MEDIATYPE_Stream;
      mtFormat[0].subtype = MEDIATYPE_Midi;
      mtFormat[0].bFixedSizeSamples = 1;
      mtFormat[0].bTemporalCompression = 0;
      mtFormat[0].lSampleSize = 1;
      mtFormat[0].formattype = GUID_NULL;
      mtFormat[0].pUnk = NULL;
      mtFormat[0].cbFormat = 0;
      mtFormat[0].pbFormat = NULL;

      mtFormat[1].majortype = MEDIATYPE_Midi;
      mtFormat[1].subtype = MEDIATYPE_NULL;
      mtFormat[1].bFixedSizeSamples = 1;
      mtFormat[1].bTemporalCompression = 0;
      mtFormat[1].lSampleSize = 1;
      mtFormat[1].formattype = GUID_NULL;
      mtFormat[1].pUnk = NULL;
      mtFormat[1].cbFormat = 0;
      mtFormat[1].pbFormat = NULL;

    } // Constructor //

  CDMFilterInputPin::~CDMFilterInputPin()

    { // Destructor //

      if (m_piAsyncRead)
        m_piAsyncRead->Release();

      m_piAsyncRead = NULL;

    } // Destructor //

  HRESULT CDMFilterInputPin::GetMediaType(int iPosition, CMediaType *pmt)

    { // GetMediaType //

      if (0 > iPosition)
        return E_INVALIDARG;

      if (iPosition > 0)
        return VFW_S_NO_MORE_ITEMS;

      *pmt = mtFormat[iPosition];

      return NOERROR;

    } // GetMediaType //

  HRESULT CDMFilterInputPin::CheckMediaType(const CMediaType *pmt)

    { // CheckMediaType //

      if ((mtFormat[0] != *pmt) && (mtFormat[1] != *pmt))
        return E_INVALIDARG;

      return NOERROR;

    } // CheckMediaType //

  HRESULT CDMFilterInputPin::CheckConnect(IPin *pin)

    { // CheckConnect //

      HRESULT hr = NOERROR;

      LONGLONG llTotal;

      pin->QueryInterface(IID_IAsyncReader, (void **)&m_piAsyncRead);

      for (;;)

        { // Data available?

          hr = m_piAsyncRead->Length(&llTotal, &m_llMemLength);

          if (FAILED(hr))
            return hr;

          if (VFW_S_ESTIMATED != hr)
            break;

          Sleep(15);

        } // Data available?

      m_pbMem = new BYTE[m_llMemLength];

      ASSERT(m_pbMem != NULL);

      hr = m_piAsyncRead->SyncRead(0, m_llMemLength, m_pbMem);

      ASSERT(SUCCEEDED(hr));

      return NOERROR;

    } // CheckConnect //

  HRESULT CDMFilterInputPin::Inactive()

    { // Inactive //

      m_bRunTimeError = FALSE;

      m_bFlushing = FALSE;

      return NOERROR;

    } // Inactive //

  /// !!!! O U T P U T   P I N !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  CDMFilterOutputPin::CDMFilterOutputPin(TCHAR *pName, CDMFilter *pParent, HRESULT *phr, LPCWSTR pPinName) : CBaseOutputPin(pName, pParent, pParent, phr, pPinName), m_bEndSegFound(FALSE)

    { // Constructor //

      WAVEFORMATEX wfex;

      wfex.wFormatTag = WAVE_FORMAT_PCM;
      wfex.nSamplesPerSec = OUTPUT_FREQ;
      wfex.wBitsPerSample = OUTPUT_BITSPERSAMPLE;
      wfex.nChannels = OUTPUT_CHANNELS;
      wfex.nBlockAlign = (wfex.wBitsPerSample*wfex.nChannels)/8;
      wfex.nAvgBytesPerSec = wfex.nSamplesPerSec*wfex.nBlockAlign;
      wfex.cbSize = 0;

      CreateAudioMediaType(&wfex, &mtFormat, TRUE);

    } // Constructor //

  HRESULT CDMFilterOutputPin::GetMediaType(int iPosition, CMediaType *pmt)

    { // GetMediaType //

      if (0 > iPosition)
        return E_INVALIDARG;

      if (iPosition > 0)
        return VFW_S_NO_MORE_ITEMS;

      *pmt = mtFormat;

      return NOERROR;

    } // GetMediaType //

  HRESULT CDMFilterOutputPin::DecideBufferSize(IMemAllocator *param1, ALLOCATOR_PROPERTIES *param2)

    { // DecideBufferSize //

      if (param2->cBuffers < OUTPUT_NUMBUFFERS)
        param2->cBuffers = OUTPUT_NUMBUFFERS;

      if (param2->cbBuffer < OUTPUT_BUFFERSIZE)
        param2->cbBuffer = OUTPUT_BUFFERSIZE;

      if (param2->cbAlign == 0)
        param2->cbAlign = 1;

      ALLOCATOR_PROPERTIES Actual;

      param1->SetProperties(param2,&Actual);

      if (Actual.cbBuffer < param2->cbBuffer)
        return E_FAIL;

      if (Actual.cBuffers != OUTPUT_NUMBUFFERS)
        return E_FAIL;

      return NOERROR;

    } // DecideBufferSize //

  HRESULT CDMFilterOutputPin::Active()

    { // Active //

      HRESULT hr = NOERROR;

      hr = ((CDMFilter *)m_pFilter)->m_pLink->LoadDirectMusic();
      hr = ((CDMFilter *)m_pFilter)->m_pLink->InitDirectMusicPort();
      hr = ((CDMFilter *)m_pFilter)->m_pLink->HookDirectMusic();
      hr = ((CDMFilter *)m_pFilter)->m_pLink->InitSegmentNotification();

      m_pAllocator->Commit();

      Create();

      hr = ((CDMFilter *)m_pFilter)->m_pLink->m_pDMPerf->PlaySegment(((CDMFilter *)m_pFilter)->m_pLink->m_pDMSeg, DMUS_SEGF_DEFAULT, 0, NULL);

      return NOERROR;

    } // Active //

  HRESULT CDMFilterOutputPin::Inactive()

    { // Inactive //

      HRESULT hr = NOERROR;

      Close();

      hr = ((CDMFilter *)m_pFilter)->m_pLink->ExitDirectMusicBaggage();

      return CBaseOutputPin::Inactive();

    } // Inactive //

  DWORD CDMFilterOutputPin::ThreadProc()

    { // ThreadProc //

      HRESULT hr = NOERROR;

      IMediaSample *pims = NULL;

      BYTE *pbSynthesized = NULL;

      DWORD dwActualBufSize;
      DWORD cNumBytes;

      DMUS_NOTIFICATION_PMSG *pMsg;

      REFERENCE_TIME rtStart = 0;
      REFERENCE_TIME rtEnd = 0;

      while (SUCCEEDED(hr))

        { // Delivery

          dwActualBufSize = 0;
          pims = NULL;
          pbSynthesized = NULL;

          hr = GetDeliveryBuffer(&pims, NULL, NULL, 0);

          if (FAILED(hr))
            break;

          hr |= pims->GetPointer(&pbSynthesized);

          ZeroMemory(pbSynthesized, cNumBytes = pims->GetSize());
          ASSERT(cNumBytes);

          dwActualBufSize = cNumBytes/((OUTPUT_BITSPERSAMPLE*OUTPUT_CHANNELS)>>3);

          DbgLog((LOG_TRACE, 2, TEXT("[ThreadProc]Buffersize = %u, samples: %u"), cNumBytes, dwActualBufSize));

          hr |= ((CDMFilter *)m_pFilter)->m_pLink->m_pidms->Render((short *)pbSynthesized, dwActualBufSize, ((CDMFilter *)m_pFilter)->m_pLink->m_llAbsWrite);
          ASSERT(SUCCEEDED(hr));

          hr |= pims->SetActualDataLength(dwActualBufSize*((OUTPUT_BITSPERSAMPLE*OUTPUT_CHANNELS)>>3));

          rtEnd = dwActualBufSize*OUTPUT_FREQ;
          rtEnd /= 88200;
          rtEnd += rtStart;

          DbgLog((LOG_TRACE, 2, TEXT("Timestamped: rtStart = %u"), rtStart));
          DbgLog((LOG_TRACE, 2, TEXT("Timestamped: rtEnd = %u"), rtEnd));

          hr |= pims->SetTime(&rtStart, &rtEnd);

          hr |= Deliver(pims);

          ((CDMFilter *)m_pFilter)->m_pLink->m_llAbsWrite += dwActualBufSize;

          rtStart = rtEnd;

          WaitForSingleObject(((CDMFilter *)m_pFilter)->m_pLink->m_evEndSeg, 0);

          while (S_OK == ((CDMFilter *)m_pFilter)->m_pLink->m_pDMPerf->GetNotificationPMsg(&pMsg))

            { // End-of-segment signaled?

              m_bEndSegFound = (DMUS_NOTIFICATION_SEGEND == pMsg->dwNotificationOption);

              ((CDMFilter *)m_pFilter)->m_pLink->m_pDMPerf->FreePMsg((DMUS_PMSG*)pMsg);

            }

          pims->Release();

          if (m_bEndSegFound)
            break;

        } // Spining delivery

      DbgLog((LOG_TRACE, 2, TEXT("Deliverying end-of-stream!!!")));

      return DeliverEndOfStream();

    } // ThreadProc //

  /// !!!! F I L T E R !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  CUnknown * WINAPI CDMFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)

    { // CreateInstance //

      return new CDMFilter(NAME("Direct Music"), pUnk, phr);

    } // CreateInstance //

  CDMFilter::CDMFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) : CBaseFilter(NAME("Direct Music"), pUnk, this, CLSID_DMFilter)

    { // Construct //

      m_pInput = new CDMFilterInputPin("In", this, phr, L"In");
      ASSERT(m_pInput != NULL);

      m_pOutput = new CDMFilterOutputPin("Synthesized", this, phr, L"Synthesized");
      ASSERT(m_pOutput != NULL);

      m_pLink = new CDMLink(this, m_pOutput);
      ASSERT(m_pLink != NULL);

    } // Construct //

  CDMFilter::~CDMFilter()

    { // Destruct //

      m_pLink ? delete m_pLink : NULL;
      m_pInput ? delete m_pInput : NULL;
      m_pOutput ? delete m_pOutput : NULL;

    } // Destruct //

  CBasePin* CDMFilter::GetPin(int x)

    { // GetPin //

      if (m_pInput && (0 == x))
        return m_pInput;

      if (m_pOutput && (1 == x))
        return m_pOutput;

      return NULL;

    } // GetPin //

  /// !!!! C D M L I N K !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  CDMLink::CDMLink(CDMFilter *parent, CDMFilterOutputPin *outpin) : CUnknown("CDMLink", NULL)

    { // Sink construction //

      m_pFilter = parent;
      m_pOutput = outpin;

      m_pDMusic = NULL;
      m_pDMPort = NULL;
      m_pDMPerf = NULL;
      m_pDMLoad = NULL;
      m_pDMSeg = NULL;
      m_pSegState = NULL;
      m_pKSControl = NULL;
      m_piDS = NULL;

      m_pirc = NULL;
      m_pidms = NULL;

      m_InitializedDM = FALSE;

      m_llAbsWrite = 0;

      m_rtMasterStamp = 0;

    } // Sink construction //

  CDMLink::~CDMLink()

    { // Sink deconstruction //

      m_pirc ? m_pirc->Release() : NULL;

      m_pidms ? m_pidms->Release() : NULL;

    } // Sink deconstruction //

  STDMETHODIMP CDMLink::NonDelegatingQueryInterface(REFIID riid, void **ppv)

    { // NonDelegatingQueryInterface //

      DbgLog((LOG_TRACE, 2, TEXT("CDMLink::NonDelegatingQueryInterface")));

      *ppv = NULL;

      // IDirectMusicSynthSink
      if (IsEqualIID(IID_IDirectMusicSynthSink, riid))
        return GetInterface((IDirectMusicSynthSink *)this, ppv);

      // IReferenceClock
      if (IsEqualIID(IID_IReferenceClock, riid))
        return GetInterface((IReferenceClock *)this, ppv);

      return E_NOINTERFACE;

    } // NonDelegatingQueryInterface //

  HRESULT CDMLink::LoadDirectMusic()

    { // LoadDirectMusic //

      HRESULT hr = NOERROR;

      hr |= CoCreateInstance(
              CLSID_DirectMusic,
              0,
              CLSCTX_INPROC_SERVER,
              IID_IDirectMusic,
              (void **)&m_pDMusic);

      hr |= CoCreateInstance(
              CLSID_DirectMusicPerformance,
              0,
              CLSCTX_INPROC_SERVER,
              IID_IDirectMusicPerformance,
              (void **)&m_pDMPerf);

      hr |= CoCreateInstance(
              CLSID_DirectMusicLoader,
              0,
              CLSCTX_INPROC_SERVER,
              IID_IDirectMusicLoader,
              (void **)&m_pDMLoad);

      if (SUCCEEDED(hr))
        return NOERROR;

      m_pDMusic ? m_pDMusic->Release() : NULL;
      m_pDMPerf ? m_pDMPerf->Release() : NULL;
      m_pDMLoad ? m_pDMLoad->Release() : NULL;

      return VFW_E_RUNTIME_ERROR;

    } // LoadDirectMusic //

  HRESULT CDMLink::InitDirectMusicPort()

    { // InitDirectMusicPort //

      HRESULT hr = NOERROR;

      hr |= m_pDMusic->SetDirectSound(NULL, NULL);

      memset(&m_dmpp, 0, sizeof DMUS_PORTPARAMS);

      m_dmpp.dwSize = sizeof DMUS_PORTPARAMS;

      hr |= m_pDMusic->CreatePort(GUID_NULL, &m_dmpp, &m_pDMPort, NULL);

      if (FAILED(hr))
        return E_FAIL;

      return NOERROR;

    } // InitDirectMusicPort //

  HRESULT CDMLink::HookDirectMusic()

    { // HookDirectMusic //

      HRESULT hr = NOERROR;

      KSPROPERTY kp;

      ULONG ulong = 0;

      LPUNKNOWN lpunk = NULL;

      NonDelegatingQueryInterface(IID_IReferenceClock, (void **)&lpunk);

      ZeroMemory(&kp, sizeof(kp));

      kp.Set = GUID_DMUS_PROP_SetSynthSink;

      kp.Flags  = KSPROPERTY_TYPE_SET;

      hr = m_pDMPort->QueryInterface(IID_IKsControl, (void **)&m_pKSControl);

      ASSERT(NOERROR == hr);

      hr = m_pKSControl->KsProperty(&kp, sizeof(kp), &lpunk, sizeof(lpunk), &ulong);

      ASSERT(NOERROR == hr);

      m_pKSControl->Release();

      BOOL fAutoDownload = TRUE;

      hr = m_pDMPerf->SetGlobalParam(GUID_PerfAutoDownload, &fAutoDownload, sizeof(BOOL));
      ASSERT(NOERROR == hr);

      hr = m_pDMPerf->SetBumperLength(OUTPUT_BUFFER_TIMESLICE);
      ASSERT(NOERROR == hr);

      hr = m_pDMPerf->Init(&m_pDMusic, NULL, NULL);
      ASSERT(NOERROR == hr);

      hr = m_pDMPerf->AddPort(m_pDMPort);
      ASSERT(NOERROR == hr);

      for (int u = 0; u < 2000; ++u)
        hr = m_pDMPerf->AssignPChannelBlock(u, m_pDMPort, u+1);

      return NOERROR;

    } // HookDirectMusic //

  HRESULT CDMLink::InitSegmentNotification()

    { // InitSegmentNotification //

      HRESULT hr = NOERROR;

      DMUS_OBJECTDESC ObjDesc;

      ObjDesc.guidClass = CLSID_DirectMusicSegment;
      ObjDesc.dwSize = sizeof(DMUS_OBJECTDESC);

      ObjDesc.pbMemData = m_pFilter->m_pInput->m_pbMem;
      ObjDesc.llMemLength = m_pFilter->m_pInput->m_llMemLength;
      ObjDesc.dwValidData = DMUS_OBJ_CLASS|DMUS_OBJ_MEMORY;

      hr = m_pDMLoad->GetObject(&ObjDesc, IID_IDirectMusicSegment, (void**)&m_pDMSeg);
      ASSERT(NOERROR == hr);

      hr = m_pDMSeg->SetParam(GUID_Download, -1 ,0, 0, (void*)m_pDMPerf);
      ASSERT(NOERROR == hr);

      hr = m_pDMusic->Activate(TRUE);
      ASSERT(NOERROR == hr);

      m_InitializedDM = TRUE;

      hr = m_pDMPerf->SetNotificationHandle(m_evEndSeg, 0);
      hr = m_pDMPerf->AddNotificationType(GUID_NOTIFICATION_SEGMENT);

      return NOERROR;

    } // InitSegmentNotification //

  HRESULT CDMLink::ExitDirectMusicBaggage()

    { // ExitDirectMusicBaggage //

      HRESULT hr = NOERROR;

      DbgLog((LOG_TRACE, 2, TEXT("CDMLink::ExitDirectMusicBaggage")));

      m_InitializedDM = FALSE;

      hr = m_pDMPerf->Stop(NULL, NULL, 0, 0);
      ASSERT(NOERROR == hr);

      hr = m_pDMPerf->CloseDown();
      ASSERT(NOERROR == hr);

      hr = m_pDMSeg->SetParam(GUID_Unload, -1, 0, 0, (void*)m_pDMPerf);
      ASSERT(NOERROR == hr);

      hr = m_pDMPerf->Release();
      ASSERT(NOERROR == hr);

      hr = m_pDMLoad->Release();
      ASSERT(NOERROR == hr);

      hr = m_pDMusic->Release();
      ASSERT(NOERROR == hr);

      return NOERROR;

    } // ExitDirectMusicBaggage //

  // IDirectMusicSynthSink

  STDMETHODIMP CDMLink::SetMasterClock(IReferenceClock *pClock)

    { // SetMasterClock //

      DbgLog((LOG_TRACE, 2, TEXT("CDMLink::SetMasterClock")));

      m_pirc = pClock;

      return NOERROR;

    } // SetMasterClock //

  STDMETHODIMP CDMLink::GetLatencyClock(IReferenceClock **ppClock)

    { // GetLatencyClock //

      HRESULT hr = NOERROR;

      DbgLog((LOG_TRACE, 2, TEXT("CDMLink::GetLatencyClock")));

      IReferenceClock *pirc = NULL;

      NonDelegatingQueryInterface(IID_IReferenceClock, (void **)&pirc);

      *ppClock = pirc;

      hr = m_pirc->GetTime(&m_rtMasterStamp);

      ASSERT(NOERROR == hr);

      return NOERROR;

    } // GetLatencyClock //

  STDMETHODIMP CDMLink::SampleToRefTime(LONGLONG llSampleTime, REFERENCE_TIME *prfTime)

    { // SampleToRefTime //

      DbgLog((LOG_TRACE, 2, TEXT("CDMLink::SampleToRefTime")));

      llSampleTime *= MILS_TO_REF;
      llSampleTime /= OUTPUT_FREQ;
      llSampleTime *= 1000;

      llSampleTime += m_rtMasterStamp;

      *prfTime = llSampleTime;

      return NOERROR;

    } // SampleToRefTime //

  STDMETHODIMP CDMLink::RefTimeToSample(REFERENCE_TIME rfTime, LONGLONG *pllSampleTime)

    { // RefTimeToSample //

      DbgLog((LOG_TRACE, 2, TEXT("CDMLink::RefTimeToSample")));

      rfTime -= m_rtMasterStamp;

      rfTime /= 1000;
      rfTime *= OUTPUT_FREQ;
      rfTime /= MILS_TO_REF;

      *pllSampleTime = rfTime;

      return NOERROR;

    } // RefTimeToSample //

  STDMETHODIMP CDMLink::GetTime(REFERENCE_TIME *pTime)

    { // GetTime //

      DbgLog((LOG_TRACE, 2, TEXT("CDMLink::GetTime")));

      REFERENCE_TIME rtCompare;

      m_pirc->GetTime(&rtCompare);

      { // Lock&scope

        CAutoLock m_lock(&m_pLock);

        SampleToRefTime(ByteToSample(m_llAbsWrite), pTime);

      } // Lock&scope

      DbgLog((LOG_TRACE, 2, TEXT("[GetTime]*pTime = %016X, rtCompare = %016X"), (DWORD)(*pTime/10000), (DWORD)(rtCompare/10000)));

      if (*pTime < rtCompare)
        *pTime = rtCompare;

      if (*pTime > (rtCompare + (10000 * 1000)))
        *pTime = rtCompare + (10000 * 1000);

      return NOERROR;

    } // GetTime //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midiin\midiin.cpp ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
// MIDI input filter

#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include "midiin.h"

// The MIDI format consists of the time division of the file.  This is found
// in the header of an smf file.  It doesn't change and needs to be sent to
// MMSYSTEM before we play the file.
typedef struct _MIDIFORMAT {
    DWORD               dwDivision;
    DWORD               dwReserved[7];
} MIDIFORMAT, FAR * LPMIDIFORMAT;

#ifdef FILTER_DLL
/* List of class IDs and creator functions for class factory */

CFactoryTemplate g_Templates[] = {
    {L"", &CLSID_MIDIRecord, CMIDIInFilter::CreateInstance}
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);
#endif

CUnknown *CMIDIInFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CMIDIInFilter(pUnk, phr);  // need cast here?
}

#pragma warning(disable:4355)
/* Constructor - initialise the base class */

CMIDIInFilter::CMIDIInFilter(
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CBaseFilter(NAME("MIDIInFilter"), pUnk, &m_csFilter, CLSID_MIDIRecord, phr)
    , m_fStopping(FALSE)
    , m_hmi(NULL)
    , m_iDevice(0)
{
    /* Create the single input pin */

    m_pOutputPin = new CMIDIInOutputPin(this,        // Owning filter
                                    phr,              // Result code
                                    L"MIDI Output"); // Pin name
    ASSERT(m_pOutputPin);

    /* Initialise ... */


#ifdef DEBUG
    {
	int i, iMax;
	GetInstanceCount(&iMax);
	for (i = 0; i < iMax; i++) {
	    BSTR name;
	    GetInstanceName(i, &name);

	    DbgLog((LOG_TRACE, 1, TEXT("Device #%d: '%ls'"), i, name));

	    SysFreeString(name);
	}

	// !!!!!!!!!!!!!!!!!!!!!!
	// !!!!!!! temp for testing
	if (iMax > 3)
	    m_iDevice = 3;  // midi router on \\davidmay !!!
    }

#endif
}

#pragma warning(default:4355)

/* Destructor */

CMIDIInFilter::~CMIDIInFilter()
{
    ASSERT(m_hmi == NULL);

    ASSERT(m_pOutputPin);

    delete m_pOutputPin;
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP CMIDIInFilter::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IFilterFactory) {
        return GetInterface((IFilterFactory *) this, ppv);
    }

    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


// IFilter stuff

/* Return our single input pin - not addrefed */

CBasePin *CMIDIInFilter::GetPin(int n)
{
    /* We only support one input pin and it is numbered zero */

    ASSERT(n == 0);
    if (n != 0) {
        return NULL;
    }

    return m_pOutputPin;
}


// switch the filter into stopped mode.
STDMETHODIMP CMIDIInFilter::Stop()
{
    HRESULT hr = NOERROR;
    CAutoLock lock(&m_csFilter);

    if (m_State != State_Stopped) {

        // pause the device if we were running
        if (m_State == State_Running) {
	    hr = Pause();
	    if (FAILED(hr)) {
		return hr;
	    }
        }

        DbgLog((LOG_TRACE,1,TEXT("Stopping....")));
        
        // base class changes state and tells pin to go to inactive
        // the pin Inactive method will decommit our allocator, which we
        // need to do before closing the device.

        // do the state change
        HRESULT hr =  CBaseFilter::Stop();
        if (FAILED(hr)) {
            return hr;
        }
	
	// close the MIDI device.
	if (m_hmi) {
	    midiInReset(m_hmi);
	    midiInClose(m_hmi);
	    m_hmi = 0;
	}
    }
    return hr;
}


STDMETHODIMP CMIDIInFilter::Pause()
{
    CAutoLock lock(&m_csFilter);

    HRESULT hr = NOERROR;

    /* Check we can PAUSE given our current state */

    if (m_State == State_Running) {
        ASSERT(m_hmi);

        DbgLog((LOG_TRACE,1,TEXT("MidiIn: Running->Paused")));

        midiInStop(m_hmi);
    } else {
        if (m_State == State_Stopped) {
            DbgLog((LOG_TRACE,1,TEXT("MidiIn: Inactive->Paused")));

            // open the MIDI device.
            hr = OpenMIDIDevice();
            if (FAILED(hr)) {
                return hr;
            }
        }
    }

    // tell the pin to go active and change state
    return CBaseFilter::Pause();

}


STDMETHODIMP CMIDIInFilter::Run(REFERENCE_TIME tStart)
{
    CAutoLock lock(&m_csFilter);

    HRESULT hr = NOERROR;

    FILTER_STATE fsOld = m_State;

    // this will call Pause if currently stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    if (fsOld != State_Running) {
        DbgLog((LOG_TRACE,1,TEXT("Paused->Running")));

        //!!! correct timing needed here
        // we should postpone this restart until the correct
        // start time. That means knowing the stream at which we paused
        // and having an advise for (just before) that time.

        midiInStart(m_hmi);

	rtLast = 0;
    }

    return NOERROR;
}


/* Override this if your state changes are not done synchronously */
STDMETHODIMP
CMIDIInFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));

    *State = m_State;

    if (m_State == State_Paused)
	return VFW_S_CANT_CUE;
    
    return S_OK;
}



// open the MIDI device if not already open
// called by the MIDI allocator at Commit time
STDMETHODIMP
CMIDIInFilter::OpenMIDIDevice(void)
{
    MIDIFORMAT *pmf = (MIDIFORMAT *) m_pOutputPin->m_mt.Format();

    DbgLog((LOG_TRACE,3,TEXT("Opening MIDI device....")));
    // !!! adjust based on speed?
    UINT err = midiInOpen(&m_hmi,
                           (UINT) (m_iDevice - 1),
                           (DWORD) &CMIDIInFilter::MIDIInCallback,
                           (DWORD) this,
                           CALLBACK_FUNCTION);

    if (err != 0) {
        DbgLog((LOG_TRACE,1,TEXT("Error opening MIDI device: %u"), err));
        return E_FAIL; // !!!!
    }

    midiInStop(m_hmi);

    return NOERROR;
}


typedef struct
{
    DWORD       dwDeltaTime;          /* Ticks since last event */
    DWORD       dwStreamID;           /* Reserved; must be zero */
    DWORD       dwEvent;              /* Event type and parameters */
} MIDISHORTEVENT;


void CALLBACK CMIDIInFilter::MIDIInCallback(HDRVR hdrvr, UINT uMsg, DWORD dwUser,
                                            DWORD dw1, DWORD dw2)
{
    CMIDIInFilter *pFilter = (CMIDIInFilter *) dwUser;

    switch (uMsg) {
	// !!! we're ignoring SYSEX data!
	
        case MIM_DATA:
        {
            // really need a  worker thread here, because
            // one shouldn't do this much in a MIDI callback.
            HRESULT hr;
            REFERENCE_TIME rt;

	    // throw data away if not running.... hope nobody wants to queue
	    // anything.....
	    if (pFilter->m_State != State_Running)
		break;
	    
            pFilter->m_pClock->GetTime(&rt);

            rt -= pFilter->m_tStart;

            if (pFilter->m_pOutputPin->m_piip) {
                hr = pFilter->m_pOutputPin->m_piip->ReceiveImmediate(rt, dw1);
            } else {
		IMediaSample *pSample;
                DbgLog((LOG_TRACE,3,TEXT("Calling GetBuffer")));
                hr = pFilter->m_pOutputPin->m_pAllocator->GetBuffer(&pSample,NULL,NULL,FALSE);
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR,3,TEXT("GetBuffer failed, hr = %X"), hr));
                    break;
                }
                DbgLog((LOG_TRACE,3,TEXT("GetBuffer returned sample %X"), pSample));

		DWORD dwBytes = sizeof(MIDIHDR) * 2 + sizeof(MIDISHORTEVENT);

		BYTE *pData;
		pSample->GetPointer(&pData);
		
		LPMIDIHDR pmh = (LPMIDIHDR) pData;

		pmh->dwBufferLength = 0;
		(pmh+1)->dwBufferLength = sizeof(MIDISHORTEVENT);
		MIDISHORTEVENT *pme = (MIDISHORTEVENT *) (pmh+2);

		// !!! delta in milliseconds???
		pme->dwDeltaTime = (DWORD) ((rt - pFilter->rtLast) / 10000);  
		pme->dwStreamID = 0;
		pme->dwEvent = dw1;
		
                hr = pSample->SetActualDataLength(dwBytes);
                ASSERT(SUCCEEDED(hr));

		if (rt <= pFilter->rtLast) {
		    DbgLog((LOG_TRACE,3,TEXT("Adjusting stop time to be start+1")));
		    rt = pFilter->rtLast + 1;
		}
		
                pSample->SetTime(&pFilter->rtLast, &rt);

		pFilter->rtLast = rt;
		
                pFilter->m_pOutputPin->Deliver(pSample);

		pSample->Release();
            }
            
        }
            break;

	case MIM_LONGDATA:
	    DbgLog((LOG_TRACE,1,TEXT("Got a LONGDATA message?!?")));
	    break;

        case MIM_OPEN:
	    break;
	    
        case MIM_CLOSE:
            break;

        default:
            DbgLog((LOG_ERROR,2,TEXT("Unexpected MIDI callback message %d"), uMsg));
            break;
    }
}


HRESULT CMIDIInFilter::GetInstanceCount(int *pn)
{
    *pn = midiInGetNumDevs() + 1;
    
    return S_OK;
}


HRESULT CMIDIInFilter::GetInstanceName(int n, BSTR *pstrName)
{
    // can't do unicode on Win95, so make do.
    
    MIDIINCAPSA	mc;

    mc.szPname[0] = '\0';
    
    HRESULT hr = midiInGetDevCapsA(n - 1, &mc, sizeof(mc)) ? E_FAIL : S_OK;

    WCHAR wName[sizeof(mc.szPname)];
    MultiByteToWideChar(CP_ACP, 0, mc.szPname, -1, wName, sizeof(mc.szPname));
    if (FAILED(hr)) {
	*pstrName = NULL;
	return hr;
    }

    return WriteBSTR(pstrName, wName);
}

HRESULT CMIDIInFilter::SetInstance(int n)
{
    if (m_hmi) {
	return E_FAIL; // !!! E_NOTALLOWEDWHENRUNNING?

	// or just close and open new device here, why not?
    }

    m_iDevice = n;

    return S_OK;
}

/* Constructor */

CMIDIInOutputPin::CMIDIInOutputPin(
    CMIDIInFilter *pFilter,
    HRESULT *phr,
    LPCWSTR pPinName)
    : CBaseOutputPin(NAME("MIDIIn Output Pin"),
		     pFilter, &pFilter->m_csFilter,
		     phr, pPinName)
{
    m_pFilter = pFilter;
    m_piip = NULL;
}

CMIDIInOutputPin::~CMIDIInOutputPin()
{
}


/* This is called when a connection or an attempted connection is terminated
   and allows us to reset the connection media type to be invalid so that
   we can always use that to determine whether we are connected or not. We
   leave the format block alone as it will be reallocated if we get another
   connection or alternatively be deleted if the filter is finally released */

HRESULT CMIDIInOutputPin::BreakConnect()
{
    // !!! Should we check that all buffers have been freed?
    // --- should be done in the Decommit ?

    if (m_piip) {
        // release IImmediateInputPin, if using
        m_piip->Release();
        m_piip = NULL;
    }
    
    return CBaseOutputPin::BreakConnect();
}


HRESULT
CMIDIInOutputPin::CompleteConnect(IPin *pReceivePin)
{
    ASSERT(m_piip == NULL);
    pReceivePin->QueryInterface(IID_IImmediateInputPin, (void **) &m_piip);

    if (m_piip != NULL) {
	DbgLog((LOG_TRACE,1,TEXT("Receiving pin has IImmediateInputPin, oh, boy!")));

	// !!! could return here, since in this case we don't really need an allocator.
	// if we do this, need to override ::Active, ::Inactive to not touch allocators.
    }

    // non-immediate case, get allocator.
    return CBaseOutputPin::CompleteConnect(pReceivePin);
}


// !!! need code here to enumerate possible allowed types....

// return default media type & format
HRESULT
CMIDIInOutputPin::GetMediaType(int iPosition, CMediaType* pt)
{
    // check it is the single type they want
    if (iPosition<0) {
        return E_INVALIDARG;
    }
    if (iPosition>0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    pt->SetType(&MEDIATYPE_Midi);
    pt->SetFormatType(&MEDIATYPE_Midi);

    // !!! more subtypes?

    MIDIFORMAT mf;

    memset(&mf, 0, sizeof(mf));

    mf.dwDivision = 1000; // !!!!! fixed beats/second?

    if (!(pt->SetFormat((LPBYTE) &mf, sizeof(mf)))) {
        //SetFormat failed...
        return E_OUTOFMEMORY;
    }

    pt->SetVariableSize();

    pt->SetTemporalCompression(FALSE);

    return NOERROR;
}


// check if the pin can support this specific proposed type&format
HRESULT
CMIDIInOutputPin::CheckMediaType(const CMediaType* pmt)
{
    // !!! Just like the output filter--combine?
    MIDIFORMAT *pmf = (MIDIFORMAT *) pmt->Format();

    DisplayType("MIDI format in CMidiIn::CheckMediaType", pmt);

    // reject non-Audio type
    if (pmt->majortype != MEDIATYPE_Midi) {
        return E_INVALIDARG;
    }

    return NOERROR;
}


HRESULT
CMIDIInOutputPin::DecideBufferSize(IMemAllocator * pAlloc,
                                   ALLOCATOR_PROPERTIES *pProperties)
{
    // enough space for one short message
    pProperties->cbBuffer = sizeof(MIDIHDR) * 2 + sizeof(MIDISHORTEVENT);
    pProperties->cBuffers = 50;

    ALLOCATOR_PROPERTIES Actual;
    return pAlloc->SetProperties(pProperties,&Actual);
}

#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\debug.h ===
//==========================================================================;
//
//      Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//      You have a royalty-free right to use, modify, reproduce and 
//      distribute the Sample Files (and/or any modified version) in 
//      any way you find useful, provided that you agree that 
//      Microsoft has no warranty obligations or liability for any 
//      Sample Application Files which are modified. 
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//  Notes:
//
//      To use this library at interrupt time under Win16, you must do
//      the following:
//
//      1. Defined ISRDEBUG when compiling debug.c
//  
//      2. Add a line in the SEGMENTS section of your .DEF file to
//         define the DEBUG_TEXT segment:
//
//
//      SEGMENTS
//          DEBUG_TEXT FIXED PRELOAD
//
//
//      These routines are callable at interrupt time under Win32 by
//      default.
//
//  win.ini
//  [debug]
//  SMF=0|1|2|3|4
//
//  History:
//      11/23/92    cjp     [curtisp] 
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif

//
//  
//
//
//
#define  ISRDEBUG             1
#define  DEBUG_SECTION        "debug"        // section name for 
#define  DEBUG_MODULE_NAME    "smf"          // key name and prefix for output
#define  DEBUG_MAX_LINE_LEN   255            // max line length (bytes)
                                             
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG
    VOID WINAPI WinAssert(LPSTR lpstrExp, LPSTR lpstrFile, DWORD dwLine);
    BOOL WINAPI DbgEnable(BOOL fEnable);
    UINT WINAPI DbgSetLevel(UINT uLevel);
    UINT WINAPI DbgInitialize(BOOL fEnable);

    void FAR CDECL dprintf(UINT uDbgLevel, LPSTR szFmt, ...);

    #define assert(exp) \
        ( (exp) ? (void) 0 : WinAssert(#exp, __FILE__, __LINE__) )

    #define DPF                  dprintf

    #define D1(sz)               dprintf(1,sz) 
    #define D2(sz)               dprintf(2,sz) 
    #define D3(sz)               dprintf(3,sz) 
    #define D4(sz)               dprintf(4,sz) 
#else
    #define assert(exp)          ((void)0)
    
    #define DbgEnable(x)         FALSE
    #define DbgSetLevel(x)       0
    #define DbgInitialize(x)     0

    #define DPF                  1 ? (void)0 : (void)

    #define D1(sz)
    #define D2(sz)
    #define D3(sz)
    #define D4(sz)
#endif


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\global.h ===
/*****************************************************************************
*
*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR
*  A PARTICULAR PURPOSE.
*
*  Copyright (c) 1996 - 1996  Microsoft Corporation.  All Rights Reserved.
*
******************************************************************************
*
* Global.H
*
* #define's everybody needs
*
*****************************************************************************/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifndef _WIN32
#define  BCODE                  __based(__segname("_CODE"))
#define  BSTACK                 __based(__segname("_STACK"))
#define  BSEG(x)                __based(__segname(x))
#define  HUGE                   __huge
#else
#define  BCODE
#define  BSTACK
#define  BSEG(x)
#define  HUGE
#endif

/* Allow visibility of static functions for debug
*/ 
#ifdef DEBUG
#define  PUBLIC
#define  PRIVATE
#else
#define  PUBLIC                 
#define  PRIVATE                static
#endif

#define  FNLOCAL                NEAR PASCAL
#define  FNGLOBAL               FAR PASCAL
#define  FNEXPORT               FAR PASCAL __export __loadds

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\midif.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// The MIDI format consists of the time division of the file.  This is found
// in the header of an smf file.  It doesn't change and needs to be sent to
// MMSYSTEM before we play the file.
typedef struct _MIDIFORMAT {
    DWORD		dwDivision;
    DWORD		dwReserved[7];
} MIDIFORMAT, FAR * LPMIDIFORMAT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\muldiv32.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  muldiv32.h
//
//  Description:
//      math routines for 32 bit signed and unsiged numbers.
//
//      MulDiv32(a,b,c) = (a * b) / c         (round down, signed)
//
//      MulDivRD(a,b,c) = (a * b) / c         (round down, unsigned)
//      MulDivRN(a,b,c) = (a * b + c/2) / c   (round nearest, unsigned)
//      MulDivRU(a,b,c) = (a * b + c-1) / c   (round up, unsigned)
//
//==========================================================================;

#ifndef _INC_MULDIV32
#define _INC_MULDIV32


#ifndef INLINE
#define INLINE __inline
#endif


#ifdef _X86_

    //
    //  Use 32-bit x86 assembly.
    //

    #pragma warning(disable:4035 4704)

    INLINE LONG MulDiv32(LONG a,LONG b,LONG c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     imul    ebx              //  imul ebx
        _asm     idiv    ecx              //  idiv ecx
        _asm	 shld	 edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRN(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     shr     ebx,1            //  sar  ebx,1
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDiv32()

    INLINE DWORD MulDivRU(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     mov     ebx,ecx          //  mov  ebx,ecx
        _asm     dec     ebx              //  dec  ebx
        _asm     add     eax,ebx          //  add  eax,ebx
        _asm     adc     edx,0            //  adc  edx,0
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRU32()

    INLINE DWORD MulDivRD(DWORD a,DWORD b,DWORD c)
    {
        _asm     mov     eax,dword ptr a  //  mov  eax, a
        _asm     mov     ebx,dword ptr b  //  mov  ebx, b
        _asm     mov     ecx,dword ptr c  //  mov  ecx, c
        _asm     mul     ebx              //  mul  ebx
        _asm     div     ecx              //  div  ecx
        _asm     shld    edx, eax, 16     //  shld edx, eax, 16

    } // MulDivRD32()

    #pragma warning(default:4035 4704)


#else

    //
    //  Use C9 __int64 support for Daytona RISC platforms.
    //

    INLINE LONG MulDiv32( LONG a, LONG b, LONG c )
    {
        return (LONG)( Int32x32To64(a,b) / c );
    }


    INLINE DWORD MulDivRD( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( UInt32x32To64(a,b) / c );
    }


    INLINE DWORD MulDivRN( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (UInt32x32To64(a,b)+c/2) / c );
    }


    INLINE DWORD MulDivRU( DWORD a, DWORD b, DWORD c )
    {
        return (DWORD)( (UInt32x32To64(a,b)+c-1) / c );
    }

#endif


//
//  some code references these by other names.
//
#define muldiv32    MulDivRN
#define muldivrd32  MulDivRD
#define muldivru32  MulDivRU

#endif  // _INC_MULDIV32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\avimidi.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

/* AVI MIDI stream renderer	*/
/*     CMIDIFilter class	*/
/*       Danny Miller		*/
/*        July 1995		*/

#include <streams.h>
#include <mmsystem.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include <vfw.h>
#include "midif.h"  // the avi file's MIDI format definition
#include "avimidi.h"
#include "handler.h"

// ------------------------------------------------------------------------
// setup data


// input pin
const AMOVIESETUP_MEDIATYPE
sudMIDIPinTypes =
{
  &MEDIATYPE_Midi,            // MajorType
  &MEDIASUBTYPE_NULL         // MinorType
};

const AMOVIESETUP_PIN
sudMIDIPin =
{
  L"Input",                     // strName
  TRUE,                         // bRenderered
  FALSE,                        // bOutput
  FALSE,                        // bZero
  FALSE,                        // bMany
  &CLSID_NULL,		        // connects to filter // !!!
  NULL,                         // connects to pin
  1,                            // nMediaTypes
  &sudMIDIPinTypes              // lpMediaType
};

const AMOVIESETUP_FILTER
sudMIDIRender =
{
  &CLSID_AVIMIDIRender,         // clsID
  L"MIDI Renderer",             // strName
  MERIT_PREFERRED,              // dwMerit
  1,                            // nPins
  &sudMIDIPin                   // lpPin
};


#ifdef FILTER_DLL
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}

CFactoryTemplate g_Templates[] = {
    { L"MIDI Renderer"
    , &CLSID_AVIMIDIRender
    , CMIDIFilter::CreateInstance
    , NULL
    , &sudMIDIRender }
  ,
    { L"AVIFile MIDI Reader"
    , &CLSID_MIDIFileReader
    , CMIDIFile::CreateInstance }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#endif

/* This goes in the factory template table to create new instances */

CUnknown *CMIDIFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CMIDIFilter *pFilter = new CMIDIFilter(pUnk, phr);
    if (!pFilter)
	*phr = E_OUTOFMEMORY;
    else if (FAILED(*phr)) {
	delete pFilter;
	pFilter = NULL;
    }
    return pFilter;
}

//
// IBaseFilter stuff
//

//
// Return the number of input pins we support */
//
int CMIDIFilter::GetPinCount()
{
    DbgLog((LOG_TRACE,3,TEXT("GetPinCount: We have 1 pin")));
    return 1;
}

//
// Return our single input pin - addrefed by caller if needed
//
//
CBasePin *CMIDIFilter::GetPin(int n)
{
    DbgLog((LOG_TRACE,3,TEXT("GetPin: %d"), n));

    // We only support one input pin and it is number zero
    if (n != 0) {
        return NULL;
    }

    // Made in our constructor, so we know it's around
    return m_pInputPin;
}


//
// The filter has been told to stop playing
//
STDMETHODIMP CMIDIFilter::Stop()
{
    FILTER_STATE m_OldState = m_State;

    DbgLog((LOG_TRACE,1,TEXT("Stop:")));

    // before we take the CritSect
    m_fWaitingForData = FALSE;

    // This code is part of our critical section
    CAutoLock lock(this);

    HRESULT   hr;

    // If we are not stopped,
    // CBaseFilter::Stop changes the state, and then calls
    // CMIDIInputPin::Inactive which calls CAllocator::Decommit which
    // calls CAllocator::Free and thus everything shuts down.

    // stop first, before doing our stuff, so that the rest of the code knows
    // we're stopped and shutting MIDI down
    hr =  CBaseFilter::Stop();

    if (m_OldState != State_Stopped) {

	// We're stopping, no need to worry about EOS anymore. Reset
	m_fEOSReceived = FALSE;
	m_fEOSDelivered = FALSE;

	if (m_hmidi) {
	    DbgLog((LOG_TRACE,1,TEXT("calling midiOutReset")));
	    midiOutReset((HMIDIOUT)m_hmidi);

            // !!! What if a receive is happening right now? It might go through
	    // now and give MMYSTEM a buffer which will never come back, and
	    // we'll hang.

	    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamClose")));
	    midiStreamClose(m_hmidi);
	    m_hmidi = NULL;
	}

	// now force the buffer count back to the normal
	// at this point, we are sure there are no more buffers coming in
	// and no more buffers waiting for callbacks.
	m_lBuffers = 0;

    }

    if (FAILED(hr)) {
        return hr;
    }

    return NOERROR;
}

//
// The filter has been told to pause playback
//
STDMETHODIMP CMIDIFilter::Pause()
{
    DbgLog((LOG_TRACE,1,TEXT("Midi filter pausing:")));

    // This code is part of our critical section
    CAutoLock lock(this);

    HRESULT hr = NOERROR;

    if (m_State == State_Running) {
	DbgLog((LOG_TRACE,1,TEXT("Pause: when running")));

	// Next time we're run, send another EC_COMPLETE if we're at EOS
	m_fEOSDelivered = FALSE;

	if (m_hmidi) {
	    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamPause")));
	    midiStreamPause(m_hmidi);
	}
    } else if (m_State == State_Stopped) {
	DbgLog((LOG_TRACE,1,TEXT("Pause: when stopped")));

	// Start things off by opening the device.  You may think this belongs
	// in the allocator stuff, since that does everything else, like
	// preparing headers, writing to the the device, etc., but the filter
	// needs to know the midi device handle too, for starting and stopping
	// it, and the allocator doesn't know what filter this is to give it
	// that information, but we know what allocator our pin is using.  So
	// we will open the device here, give the hmidi to the allocator, and
	// the allocator will do everything else.
	if (m_pInputPin->IsConnected()) {	// otherwise we'll blow up
	    HRESULT hr = OpenMIDIDevice();
	    if (FAILED(hr)) {
		// We will fail silently
	        // This will trigger Receive to fail and Run to send EC_COMPLETE
	        m_fEOSReceived = TRUE;
	    } else {
		// we aren't done the pause until we get some data
	        m_fWaitingForData = TRUE;
		DbgLog((LOG_TRACE, 2, "Midi - waiting now TRUE (from PAUSE)"));
	        hr = CBaseFilter::Pause();
	        if (hr == NOERROR)
		    return S_FALSE;
	        else
		    return hr;
	    }
	}
    } else {
	DbgLog((LOG_TRACE,2,TEXT("Midi must have been paused already")));
    }

    // If we are in stopped state,
    // CBaseFilter::Pause changes the state, and then calls
    // CMIDIInputPin::Active which calls CAllocator::Commit which
    // calls CAllocator::Alloc and thus everything gets set up.
    return CBaseFilter::Pause();

}

//
// The filter has been told to start playback at a particular time
//
STDMETHODIMP CMIDIFilter::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE,1,TEXT("Run:")));

    // This code is part of our critical section
    CAutoLock lock(this);

    // We're not finished pausing yet
    while (m_fWaitingForData) {
	// !!! this might happen after EndFlush and before we get new data
	Sleep(1);
    }

    HRESULT hr = NOERROR;

    FILTER_STATE fsOld = m_State;

    // !!! I'm ignoring the start time!
    // We should postpone this restart until the correct
    // start time. That means knowing the stream at which we paused
    // and having an advise for (just before) that time. ???

    // this will call ::Pause if currently Stopped
    hr = CBaseFilter::Run(tStart);
    if (FAILED(hr)) {
        return hr;
    }

    // We have seen EOS, so running is pointless. Send EC_COMPLETE if we
    // haven't done so yet
    if (m_fEOSReceived) {
	m_csEOS.Lock();
	if (!m_fEOSDelivered) {
            DbgLog((LOG_TRACE,1,TEXT("::Run signals EC_COMPLETE")));
            NotifyEvent(EC_COMPLETE, S_OK, 0);
	}
	m_fEOSDelivered = TRUE;
	m_csEOS.Unlock();
    } else if (fsOld != State_Running) {
	if (m_hmidi) {
	    // Tell MIDI to start playing
	    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamRestart")));
	    midiStreamRestart(m_hmidi);
	}
    }

    return NOERROR;
}

//
// Open the MIDI device, and set the tempo from the format
// Called by the allocator at Commit time
//
STDMETHODIMP CMIDIFilter::OpenMIDIDevice(void)
{
    // the format was set during connection negotiation by the base class
    MIDIFORMAT *pmf = (MIDIFORMAT *) m_pInputPin->m_mt.Format();
    MIDIPROPTIMEDIV mptd;
    UINT	    uDeviceID = (UINT)-1;

    // Sends callbacks to our function when buffers are done
    DbgLog((LOG_TRACE,1,TEXT("calling midiStreamOpen")));
    UINT err = midiStreamOpen(&m_hmidi,
                           &uDeviceID,
                           1,
                           (DWORD) &CMIDIFilter::MIDICallback,
                           (DWORD) this,
                           CALLBACK_FUNCTION);

    if (err != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error %u in midiStreamOpen"), err));
	m_hmidi = NULL;
        return E_FAIL;
    }

    // The format of a MIDI stream is just the time division (the tempo).
    // Set the proper tempo.
    mptd.cbStruct  = sizeof(mptd);
    mptd.dwTimeDiv = pmf->dwDivision;
    DbgLog((LOG_TRACE,1,TEXT("Setting time division to %ld"),mptd.dwTimeDiv));
    if (midiStreamProperty(m_hmidi, (LPBYTE)&mptd,
			MIDIPROP_SET|MIDIPROP_TIMEDIV) != MMSYSERR_NOERROR) {
        DbgLog((LOG_ERROR,1,TEXT("Error setting time division, closing device")));
	midiStreamClose(m_hmidi);
	m_hmidi = NULL;
	return E_FAIL;
    }

    return NOERROR;
}

/* PUBLIC Member functions */


#pragma warning(disable:4355)

//
// Constructor
//
CMIDIFilter::CMIDIFilter(LPUNKNOWN pUnk, HRESULT *phr)
    : CBaseFilter(NAME("AVI MIDI Filter"), pUnk, (CCritSec *) this, CLSID_AVIMIDIRender),
      m_pImplPosition(NULL),
      m_lBuffers(0),
      m_fEOSReceived(FALSE),
      m_fEOSDelivered(FALSE),
      m_fWaitingForData(FALSE)

{

    DbgLog((LOG_TRACE,1,TEXT("CMIDIFilter constructor")));

    m_hmidi = NULL;

    // Create the single input pin
    m_pInputPin = new CMIDIInputPin(
                            this,                   // Owning filter
                            phr,                    // Result code
                            L"AVI MIDI Input pin"); // Pin name

    if (!m_pInputPin) {
	DbgLog((LOG_ERROR,1,TEXT("new CMIDIInput pin failed!")));
	// OLE will not have returned an error code in this case.
	*phr = E_OUTOFMEMORY;
    }

    // Just call me paranoid.
    if (m_pInputPin && FAILED(*phr)) {
	DbgLog((LOG_ERROR,1,TEXT("new CMIDIINput pin failed!")));
	delete m_pInputPin;
	m_pInputPin = NULL;
    }
}

//
// Destructor
//
CMIDIFilter::~CMIDIFilter()
{

    DbgLog((LOG_TRACE,1,TEXT("CMIDIFilter destructor")));

    ASSERT(m_hmidi == NULL);

    /* Delete the contained interfaces */

    if (m_pInputPin) {
        delete m_pInputPin;
    }

    if (m_pImplPosition) {
	delete m_pImplPosition;
    }
}

//
// Override this to say what interfaces we support and where
//
STDMETHODIMP CMIDIFilter::NonDelegatingQueryInterface(REFIID riid,
                                                        void ** ppv)
{
    if (riid == IID_IPersist) {
	DbgLog((LOG_TRACE,4,TEXT("CMIDIFilter QI for IPersist")));
        return GetInterface((IPersist *) this, ppv);
    } else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
	DbgLog((LOG_TRACE,4,TEXT("CMIDIFilter QI for position")));
	if (!m_pImplPosition) {
            HRESULT hr = S_OK;
	    // This helper class does ALL THE WORK of passing position
	    // requests back to the source filter which is the one who
	    // really cares about such stuff.
            m_pImplPosition = new CPosPassThru(
                                    NAME("MIDI CPosPassThru"),
                                    GetOwner(),
                                    &hr,
                                    (IPin *)m_pInputPin);
	    if (!m_pImplPosition) {
		DbgLog((LOG_ERROR,1,TEXT("new CPosPassThru failed!")));
		// OLE will not have returned an error code in this case.
		return E_OUTOFMEMORY;
	    }
	    // That's me, Mr. Paranoid
            if (FAILED(hr)) {
		DbgLog((LOG_ERROR,1,TEXT("new CPosPassThru failed!")));
                delete m_pImplPosition;
                m_pImplPosition = NULL;
                return hr;
            }
	}
	return m_pImplPosition->NonDelegatingQueryInterface(riid, ppv);
    } else {
	DbgLog((LOG_TRACE,4,TEXT("CMIDIFilter QI for ???")));
        return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

//
// Override this if your state changes are not done synchronously
//
STDMETHODIMP CMIDIFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    DbgLog((LOG_TRACE,4,TEXT("::GetState wait for %ldms"), dwMSecs));
    CheckPointer( State, E_POINTER );

    // We are in an intermediate state.  Give ourselves dwMSecs ms to steady
    while (m_fWaitingForData && dwMSecs > 10) {
	Sleep(10);
	dwMSecs -= 10;
    }
    DbgLog((LOG_TRACE,4,TEXT("::GetState done waiting")));

    *State = m_State;
    if (m_fWaitingForData) {
	// guess we didn't steady in time
	DbgLog((LOG_TRACE, 2, "Midi getstate returning INTERMEDIATE"));
        return VFW_S_STATE_INTERMEDIATE;
    } else {
        return S_OK;
    }
}

// Pin stuff

//
// Constructor: Remember what filter we're attached to.
//
CMIDIInputPin::CMIDIInputPin(CMIDIFilter *pFilter, HRESULT *phr,
							LPCWSTR pPinName)
    : CBaseInputPin(NAME("AVI MIDI Pin"), pFilter, pFilter, phr, pPinName)
{
    DbgLog((LOG_TRACE,2,TEXT("CMIDIInputPin constructor")));
    m_pFilter = pFilter;
    m_fFlushing = FALSE;
}

//
// Destructor
//
CMIDIInputPin::~CMIDIInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("CMIDIInputPin destructor")));
    // Release our allocator if we made one
}

//
// return the allocator interface that this input pin
// would like the output pin to use, or, if we've already been
// assigned an allocator, just return that one.
//
STDMETHODIMP CMIDIInputPin::GetAllocator(IMemAllocator ** ppAllocator)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE,3,TEXT("CMIDIInputPin::GetAllocator")));

    // We shouldn't be asked this question before getting connected to
    // somebody.
    if (!IsConnected()) {
	DbgLog((LOG_TRACE,3,TEXT("Sorry, not connected yet")));
	return E_FAIL;
    }

    // Well, we don't have a preference; we don't have an allocator
    *ppAllocator = NULL;
    return E_NOINTERFACE;
}

//
// We are being told to use this allocator
//
STDMETHODIMP CMIDIInputPin::NotifyAllocator(
    IMemAllocator *pAllocator)
{
    HRESULT hr;             // General OLE return code

    DbgLog((LOG_TRACE,3,TEXT("NotifyAllocator:")));

    // The base class will remember this allocator, and free the old one
    // Should we always signal that the samples are to be read only?
    hr = CBaseInputPin::NotifyAllocator(pAllocator,TRUE);
    if (FAILED(hr)) {
        return hr;
    }

    // Actually, we don't care.
    return NOERROR;
}


//
// This is called when a connection or an attempted connection is terminated
// and allows us to do anything we want besides releasing the allocator and
// connected pin.
// We will reset our media type to NULL, so we can use that as an indicator
// as to whether we're connected or not.
// !!! So what!  Is this necessary? Probably not
// !!! We leave the format block alone as it will be reallocated if we get
// another connection or alternatively be deleted if the filter is finally
// released - look at CMediaType
//
HRESULT CMIDIInputPin::BreakConnect()
{
    DbgLog((LOG_TRACE,2,TEXT("BreakConnect:")));

    // This just checks to see if the major type is already GUID_NULL
    if (m_mt.IsValid() == FALSE) {
        return E_FAIL;
    }

    // !!! Should we check that all buffers have been freed?

    // Set the CLSIDs of the connected media type to nothing
    m_mt.SetType(&GUID_NULL);
    m_mt.SetSubtype(&GUID_NULL);

    // This will do absolutely nothing
    return CBaseInputPin::BreakConnect();
}

//
// Check that we can support a given proposed media type
//
HRESULT CMIDIInputPin::CheckMediaType(const CMediaType *pmt)
{

    MIDIFORMAT *pmf = (MIDIFORMAT *) pmt->Format();
    DbgLog((LOG_TRACE,2,TEXT("CheckMediaType:")));
    DbgLog((LOG_TRACE,2,TEXT("Format length %d"),pmt->FormatLength()));

    #ifdef DEBUG

    /* Dump the GUID types */

    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));

    /* Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->FormatLength()));

    #endif

    // Verify that majortype is MIDI
    if (pmt->majortype != MEDIATYPE_Midi) {
	return E_INVALIDARG;
    }

    // Verify that the format is the right length
    if (pmt->FormatLength() < sizeof(MIDIFORMAT))
	return E_INVALIDARG;

    #ifdef DEBUG

    /* Dump the contents of the MIDIFORMAT type-specific format structure */

    DbgLog((LOG_TRACE,2,TEXT("Format dwDivision=%ld"), pmf->dwDivision));

    #endif

    // Just assume that we can accept whatever the format is

    DbgLog((LOG_TRACE,2,TEXT("Accepting the media type")));

    return NOERROR;
}


// Implements the remaining IMemInputPin virtual methods

//
// Here's the next block of data from the stream
// We need to AddRef it since we're not blocking until we're done with it.
// We will release it in the MIDI callback when MMSYSTEM is done with it.
//
HRESULT CMIDIInputPin::Receive(IMediaSample * pSample)
{
    DbgLog((LOG_TRACE,3,TEXT("Receive:")));

    // we're flushing and don't want any receives
    if (m_fFlushing) {
        DbgLog((LOG_TRACE,2,TEXT("can't receive, flushing")));
	return VFW_E_WRONG_STATE;
    }

    // what are we doing receiving data after we were promised no more would be
    // sent?
    if (m_pFilter->m_fEOSReceived) {
        DbgLog((LOG_TRACE,2,TEXT("can't receive, already seen EOS")));
	return E_UNEXPECTED;
    }

    // if we're stopped, then reject this call
    // (the filter graph may be in mid-change)
    if (m_pFilter->m_State == State_Stopped) {
	DbgLog((LOG_TRACE,2,TEXT("can't receive, stopped")));
        return E_FAIL;
    }

    // If this was a "play from 10 to 10" the video wants to draw it, but
    // we don't want to play any MIDI data.
    CRefTime tStart, tStop;
    pSample->GetTime((REFERENCE_TIME *) &tStart,
                     (REFERENCE_TIME *) &tStop);
    if (tStop <= tStart) {
	return S_OK;
    }

    HRESULT hr = NOERROR;

    // This will verify that we are receiving valid MIDI data
    hr = CBaseInputPin::Receive(pSample);
    // S_FALSE or an error code both mean we aren't receiving samples.
    if (hr != S_OK) {
	DbgLog((LOG_ERROR,1, TEXT("can't receive, base class unhappy")));
        return hr;
    }

    // !!! We're ignoring pre-roll!

    // The sample we get contains a MIDIHDR, the keyframe data, a MIDIHDR, and
    // this frame's data.  Typically, we only need to send the second buffer.
    // Before we send it, we'll have to patch the header with the proper
    // lpData and dwBufferSize. We also have to Prepare it now, because
    // we didn't know until now what part of the buffer we'd need to send.
    // Remember to set dwUser to pSample to retrieve it later.
    BYTE *pData;
    pSample->GetPointer(&pData);
    ASSERT(pData != NULL);

    // Each sample that comes to us is actually 2 headers and buffers
    // in a row.  The first is key frame data, which we only need if
    // we play non-contiguously.  The second one is the one we want.
    // Then adjust the actual bytes written
    LPMIDIHDR pmh = (LPMIDIHDR)pData;

    // This is not simply the next sample in a contiguous group.  So we need
    // to throw out keyframe data to the MIDI device.  This frame is a keyframe,
    // that much is guaranteed by Quartz, but we keep the keyframe data
    // separate and have to know that we need to use it.
    if (pSample->IsDiscontinuity() == S_OK && pmh->dwBufferLength) {

        DbgLog((LOG_TRACE,1, TEXT("Not continuous.  Sending a KEYFRAME")));

        // we have to set the USER word so we know which sample this came from
        pmh->dwUser = (DWORD)pSample;

	hr = SendBuffer(pmh);

	if (FAILED(hr)) {
	    return hr;
	}
    }

    // Now skip to the second buffer in the sample, the actual data (the first
    // buffer is the keyframe data).
    pmh = (LPMIDIHDR)((LPBYTE)(pmh + 1) + pmh->dwBufferLength);

    // we have to set the USER word so we know which sample this came from
    pmh->dwUser = (DWORD)pSample;

    hr = SendBuffer(pmh);

    m_pFilter->m_fWaitingForData = FALSE;

    /* Return the status code */
    return hr;
}

// No more data is coming. If we have samples queued, then store this for
// action in the last MIDI callback. If there are no samples, then action
// it now by notifying the filtergraph.
//
// Once we run out of buffers, we can signal EC_COMPLETE if we've seen EOS
STDMETHODIMP CMIDIInputPin::EndOfStream(void)
{
    // we're flushing and don't want any receives
    if (m_fFlushing) {
        DbgLog((LOG_TRACE,2,TEXT("don't care about EOS, flushing")));
	return VFW_E_WRONG_STATE;
    }

    // not supposed to do anything if we're stopped
    if (m_pFilter->m_State == State_Stopped)
	return NOERROR;

    DbgLog((LOG_TRACE,1,TEXT("EndOfStream received")));

    // do this before taking the CritSect
    m_pFilter->m_fWaitingForData = FALSE;

    m_pFilter->m_fEOSReceived = TRUE;

    // no outstanding buffers, OK to deliver EC_COMPLETE if running
    m_pFilter->m_csEOS.Lock();
    if (m_pFilter->m_lBuffers == 0 && m_pFilter->m_fEOSDelivered == FALSE &&
	    			m_pFilter->m_State == State_Running) {

        DbgLog((LOG_TRACE,1,TEXT("EndOfStream signals EC_COMPLETE")));
        m_pFilter->NotifyEvent(EC_COMPLETE, S_OK, 0);

	m_pFilter->m_fEOSDelivered = TRUE;
    }
    m_pFilter->m_csEOS.Unlock();

    // else there are some buffers outstanding, and on release of the
    // last buffer the MIDI callback will signal.

    return S_OK;
}

// enter flush state - block receives and free queued data
STDMETHODIMP CMIDIInputPin::BeginFlush(void)
{
    DbgLog((LOG_TRACE,1,TEXT("BeginFlush received")));

    // do this before taking the CritSect
    m_pFilter->m_fWaitingForData = FALSE;

    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive

    CAutoLock lock(m_pFilter);

    // don't allow any more receives
    m_fFlushing = TRUE;

    HRESULT hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr)) {
	return hr;
    }

    // discard queued data

    // force end-of-stream clear
    m_pFilter->m_fEOSReceived = FALSE;
    m_pFilter->m_fEOSDelivered = FALSE;

    // release all buffers from the driver
    if (m_pFilter->m_hmidi) {
	DbgLog((LOG_TRACE,1,TEXT("calling midiOutReset")));
	midiOutReset((HMIDIOUT)m_pFilter->m_hmidi);

        // !!! What if a receive is happening right now? It might go through
	// now and MMSYSTEM will never give the buffer back, and we'll hang

	// Now that we've called Reset, we'll never be able to Restart the MIDI
	// stream without closing and re-opening it (MMSYSTEM bug)
	DbgLog((LOG_TRACE,1,TEXT("calling midiStreamClose (begin flush)")));
	midiStreamClose(m_pFilter->m_hmidi);
	m_pFilter->m_hmidi = NULL;
    }

    // now force the buffer count back to normal
    // at this point, we are sure there are no more buffers coming in
    // and no more buffers waiting for callbacks.
    m_pFilter->m_lBuffers = 0;

    // free anyone blocked on receive - not possible in this filter

    // call downstream -- no downstream pins
    return S_OK;
}

// leave flush state - ok to re-enable receives
STDMETHODIMP CMIDIInputPin::EndFlush(void)
{
    HRESULT hr = NOERROR, hr2;

    DbgLog((LOG_TRACE,1,TEXT("EndFlush received")));

    // lock this with the filter-wide lock
    // ok since this filter cannot block in Receive
    CAutoLock lock(m_pFilter);

    // sync with pushing thread -- we have no worker thread

    // ensure no more data to go downstream
    // --- we did this in BeginFlush()

    // call EndFlush on downstream pins -- no downstream pins

    // We're ready to Receive data again.  If we're not stopped, we need
    // to re-open the MIDI device.  If we are stopped, pausing will open it
    // for us.
    if (m_pFilter->m_State != State_Stopped) {
	hr = m_pFilter->OpenMIDIDevice();
	if (FAILED(hr)) {
	    // something wrong? Make sure Receive's fail, and EC_COMPLETE is
	    // sent if we try and run, but otherwise pretend it's OK
	    m_pFilter->m_fEOSReceived = TRUE;
	    hr = NOERROR;
	} else {
	    ASSERT(m_pFilter->m_State == State_Paused);
	    // can't run until we get some data
	    // !!! The filtergraph won't hold off the run until we're ready
	    m_pFilter->m_fWaitingForData = TRUE;
	}
    }

    m_fFlushing = FALSE;

    // unblock Receives
    hr2 = CBaseInputPin::EndFlush();

    if (FAILED(hr)) {
	return hr;
    } else {
	return hr2;
    }
}

//
// Our pin has become active.  Nothing needs to happen here.  The output pin
// is the one who will allocate all the buffers.
//
HRESULT CMIDIInputPin::Active(void)
{
    DbgLog((LOG_TRACE,3,TEXT("Active: nothing to do")));

    // this doesn't do a darn thing
    return CBaseInputPin::Active();
}

//
// Our pin has become inactive.  Nothing needs to happen here either. The
// output pin is the one who will free all the buffers
//
HRESULT CMIDIInputPin::Inactive(void)
{
    DbgLog((LOG_TRACE,3,TEXT("Inactive: nothing to do")));

    // this won't do a darn thing
    return CBaseInputPin::Inactive();
}

HRESULT CMIDIInputPin::SendBuffer(LPMIDIHDR pmh)
{
    // Back when we set up these headers we didn't know the buffer size
    // yet, so set it now.
    pmh->lpData = (LPSTR)(pmh + 1);

    DbgLog((LOG_TRACE,3, TEXT("This buffer has length %ld"), pmh->dwBufferLength));
	
    // There's nothing to send
    if (pmh->dwBufferLength == 0)
	return NOERROR;

    DbgLog((LOG_TRACE,3, TEXT("Preparing header")));
    UINT err = midiOutPrepareHeader((HMIDIOUT)m_pFilter->m_hmidi, pmh,
							sizeof(MIDIHDR));
    if (err != MMSYSERR_NOERROR) {
	DbgLog((LOG_ERROR,1,TEXT("Error %d from midiOutPrepareHeader"),err));
	return E_FAIL;
    }

    // note that we have added another buffer
    InterlockedIncrement(&m_pFilter->m_lBuffers);

    DbgLog((LOG_TRACE,3, TEXT("midiStreamOut: sample %x  %d bytes"),
					pmh->dwUser, pmh->dwBufferLength));
    // addref the sample BEFORE USING IT so we keep it until MMSYSTEM is done
    ((IMediaSample *)(pmh->dwUser))->AddRef();
    err = midiStreamOut(m_pFilter->m_hmidi, pmh, sizeof(MIDIHDR));
    if (err != MMSYSERR_NOERROR) {
	// device error: PCMCIA card removed?
	DbgLog((LOG_ERROR,1,TEXT("Error %d from midiStreamOut"), err));
	((IMediaSample *)(pmh->dwUser))->Release();
	return E_FAIL;
    } else {
	return NOERROR;
    }
}

//
// MMSYSTEM will callback to this function whenever it's done with a buffer.
// dwUser parameter is the CMIDIFilter pointer
//
void CALLBACK CMIDIFilter::MIDICallback(HDRVR hdrvr, UINT uMsg,
				DWORD dwUser, DWORD dw1, DWORD dw2)
{
    switch (uMsg) {
	case MOM_DONE:
	{
	    LPMIDIHDR lpmh = (LPMIDIHDR) dw1;

	    IMediaSample * pSample = (IMediaSample *) lpmh->dwUser;

	    DbgLog((LOG_TRACE,3,TEXT("MIDIOutCallback: sample %x  %ld bytes"),
						pSample, lpmh->dwBufferLength));

            CMIDIFilter* pFilter = (CMIDIFilter *)dwUser;
            ASSERT(pFilter);

	    // if we are getting callbacks because of a midiOutReset, then
	    // we already have the critical section, so we better not try
	    // and take it now!
	
	    // First, unprepare this buffer
	    UINT err = midiOutUnprepareHeader((HMIDIOUT)pFilter->m_hmidi, lpmh,
							sizeof(*lpmh));
	    if (err != MMSYSERR_NOERROR) {
		// Ok, now what? - don't worry, won't happen
	    }

            // is this the end of stream and are we out of buffers?
	    // If so, we're supposed to signal EC_COMPLETE
	    pFilter->m_csEOS.Lock();
	    if (InterlockedDecrement(&pFilter->m_lBuffers) == 0 &&
			pFilter->m_fEOSReceived && !pFilter->m_fEOSDelivered) {
        	DbgLog((LOG_TRACE,1,TEXT("Callback signals EC_COMPLETE")));
                pFilter->NotifyEvent(EC_COMPLETE, S_OK, 0);
		pFilter->m_fEOSDelivered = TRUE;
            }
	    pFilter->m_csEOS.Unlock();

	    // This will call CMemAllocator::PutOnFreeList
	    if (pSample)	// necessary to avoid a TurtleBeach bug
	        pSample->Release();
	    else
        	DbgLog((LOG_ERROR,1,TEXT("NOT RELEASING SAMPLE! Turtle beach bug?")));

	}
	    break;

	case WOM_OPEN:
	case WOM_CLOSE:
	    break;

	default:
	    break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\debug.c ===
//==========================================================================;
//
//      Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//      You have a royalty-free right to use, modify, reproduce and
//      distribute the Sample Files (and/or any modified version) in
//      any way you find useful, provided that you agree that
//      Microsoft has no warranty obligations or liability for any
//      Sample Application Files which are modified.
//
//--------------------------------------------------------------------------;
//
//  debug.c
//
//  Description:
//      This file contains code yanked from several places to provide debug
//      support that works in win 16 and win 32.
//
//  History:
//      11/23/92    cjp     [curtisp]
//
//==========================================================================;

#ifdef   DEBUG

#include <windows.h>
#include <mmsystem.h>
#include <stdarg.h>
#include "debug.h"

#ifdef WIN32
   #define  BCODE
#else
   #define  BCODE                   __based(__segname("_CODE"))
#endif


#define WSPRINTF_LIMIT 1024

//
//
//
BOOL    __gfDbgEnabled  = TRUE;     // master enable
UINT    __guDbgLevel    = 0;        // current debug level

WORD    wDebugLevel     = 0;

//************************************************************************
//**
//**  WinAssert();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR lpstrExp
//**     LPSTR lpstrFile
//**     DWORD dwLine
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**
//************************************************************************
VOID WINAPI WinAssert(
    LPSTR           lpstrExp,
    LPSTR           lpstrFile,
    DWORD           dwLine)
{
    static char szWork[256];
    static char BCODE szFormat[] =
        "!Assert: %s#%lu [%s]";

    dprintf(0, (LPSTR)szFormat, (LPSTR)lpstrFile, dwLine, (LPSTR)lpstrExp);
}

//************************************************************************
//**
//**  DbgVPrintF();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     LPSTR szFmt
//**     LPSTR va
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**
//************************************************************************

void FAR CDECL DbgVPrintF(
   LPSTR szFmt,
   va_list va)
{
    char    ach[DEBUG_MAX_LINE_LEN];
    BOOL    fDebugBreak = FALSE;
    BOOL    fPrefix     = TRUE;
    BOOL    fCRLF       = TRUE;

    ach[0] = '\0';

    for (;;)
    {
        switch(*szFmt)
        {
            case '!':
                fDebugBreak = TRUE;
                szFmt++;
                continue;

            case '`':
                fPrefix = FALSE;
                szFmt++;
                continue;

            case '~':
                fCRLF = FALSE;
                szFmt++;
                continue;
        }

        break;
    }

    if (fDebugBreak)
    {
        ach[0] = '\007';
        ach[1] = '\0';
    }

    if (fPrefix)
        lstrcatA(ach, DEBUG_MODULE_NAME ": ");

    wvsprintfA(ach + lstrlenA(ach), szFmt, va);

    if (fCRLF)
        lstrcatA(ach, "\r\n");

    OutputDebugStringA(ach);

    if (fDebugBreak)
        DebugBreak();
} //** DbgVPrintF()


//************************************************************************
//**
//**  dprintf();
//**
//**  DESCRIPTION:
//**     dprintf() is called by the DPF macro if DEBUG is defined at compile
//**     time.
//**
//**     The messages will be send to COM1: like any debug message. To
//**     enable debug output, add the following to WIN.INI :
//**
//**     [debug]
//**     smf=1
//**
//**
//**  ARGUMENTS:
//**     UINT     uDbgLevel
//**     LPCSTR   szFmt
//**     ...
//**
//**  RETURNS:
//**     void
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

void FAR CDECL dprintf(
   UINT     uDbgLevel,
   LPSTR   szFmt,
   ...)
{
    va_list va;

    if (!__gfDbgEnabled || (__guDbgLevel < uDbgLevel))
        return;

    va_start(va, szFmt);
    DbgVPrintF(szFmt, va);
    va_end(va);
} //** dprintf()


//************************************************************************
//**
//**  DbgEnable();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     BOOL fEnable
//**
//**  RETURNS:
//**     BOOL
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

BOOL WINAPI DbgEnable(
   BOOL fEnable)
{
    BOOL    fOldState;

    fOldState      = __gfDbgEnabled;
    __gfDbgEnabled = fEnable;

    return (fOldState);
} //** DbgEnable()



//************************************************************************
//**
//**  DbgSetLevel();
//**
//**  DESCRIPTION:
//**
//**
//**  ARGUMENTS:
//**     UINT uLevel
//**
//**  RETURNS:
//**     UINT
//**
//**  HISTORY:
//**     06/12/93       [t-kyleb]
//**
//************************************************************************

UINT WINAPI DbgSetLevel(
   UINT uLevel)
{
    UINT    uOldLevel;

    uOldLevel    = __guDbgLevel;
    __guDbgLevel = uLevel;
	wDebugLevel = (WORD) uLevel;

    return (uOldLevel);
} //** DbgSetLevel()


//--------------------------------------------------------------------------;
//
//  UINT DbgInitialize(void)
//
//  Description:
//
//
//  Arguments:
//
//  Return (UINT):
//
//
//  History:
//      11/24/92    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

UINT WINAPI DbgInitialize(BOOL fEnable)
{
    DbgSetLevel(GetProfileIntA(DEBUG_SECTION, DEBUG_MODULE_NAME, 0));
    DbgEnable(fEnable);

    return (__guDbgLevel);
} // DbgInitialize()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midiin\midiin.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

/*  Implements a MIDI input filter	  */
/*            David Maymudes          */
/*              April 1996            */


class CMIDIInFilter;

// e30629d3-27e5-11ce-875d-00608cb78066           MIDI recorder
DEFINE_GUID(CLSID_MIDIRecord,
0xe30629d3, 0x27e5, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66);

#define IID_IImmediateInputPin		MEDIATYPE_Midi		// !!!! big hack
interface IImmediateInputPin : IUnknown
{
	virtual HRESULT ReceiveImmediate(REFERENCE_TIME rtData,	// do we need an rtEnd
			     LONG lData);

    // See if Receive might block
    // Returns S_OK if it can block, S_FALSE if it can't or some
    // failure code (assume it can in this case)
    virtual HRESULT ReceiveImmediateCanBlock();
};

// !!! temporary guid
// {09B4F480-9575-11cf-A520-0080C77EF58A}
DEFINE_GUID(IID_IFilterFactory, 
0x9b4f480, 0x9575, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

interface IFilterFactory : IUnknown
{
	virtual HRESULT GetInstanceCount(int *pn) = 0;
//	virtual HRESULT GetDefaultInstance(int *pnDefault);	// or always 0?
	virtual HRESULT GetInstanceName(int n, BSTR *pName) = 0;

	virtual HRESULT SetInstance(int n) = 0;		// choose one....
};


/* Class supporting the renderer input pin */

class CMIDIInOutputPin : public CBaseOutputPin
{
    friend class CMIDIInFilter;

private:

    CMIDIInFilter *m_pFilter;         // The renderer that owns us

public:

    CMIDIInOutputPin(CMIDIInFilter *pMIDIInFilter,
					 HRESULT *phr,
					 LPCWSTR pPinName);

    ~CMIDIInOutputPin();

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

    // enumerate supported input types
    HRESULT GetMediaType(int iPosition,CMediaType* pt);

    // check if the pin can support this specific proposed type&format
    HRESULT CheckMediaType(const CMediaType *pmt);

    // override this to set the buffer size and count. Return an error
    // if the size/count is not to your liking
    HRESULT DecideBufferSize(IMemAllocator * pAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);


    HRESULT CompleteConnect(IPin *pReceivePin);
	
    IImmediateInputPin *m_piip;
};


class CMIDIInFilter : public CBaseFilter, public IFilterFactory
{
public:
    // Implements the IFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN
	
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);

public:

    CMIDIInFilter(
        LPUNKNOWN pUnk,
        HRESULT *phr);

    virtual ~CMIDIInFilter();

    /* Return the pins that we support */

    int GetPinCount() {return 1;};
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    // override GetState to return VFW_S_CANT_CUE
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

    // open the device if not already open
    STDMETHODIMP OpenMIDIDevice(void);

    // close the MIDI device
    STDMETHODIMP CloseMIDIDevice(void);

    // IFilterFactory methods
    HRESULT GetInstanceCount(int *pn);
    HRESULT GetInstanceName(int n, BSTR *pName);
	
    HRESULT SetInstance(int n);		// choose one....
	
private:

    /* The pin may access our private state */

    friend class CMIDIInOutputPin;

    /* Member variables */
    CMIDIInOutputPin *m_pOutputPin;      /* IPin interface */

    BOOL	m_fStopping;

    int		m_iDevice;
	
    HMIDIIN	m_hmi;

    REFERENCE_TIME rtLast;
    
    CCritSec m_csFilter;

    static void MIDIInCallback(HDRVR hdrvr, UINT uMsg, DWORD dwUser,
			       DWORD dw1, DWORD dw2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\avimidi.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

/* This is a renderer that can play MIDI data as found in AVI files */
/* (not quite what you'd find in a .MID file)			    */

/*            Danny Miller            	*/
/*              July 1995             	*/

extern const AMOVIESETUP_FILTER sudMIDIRender;

/* 07b65360-c445-11ce-afde-00aa006c14f4 */

DEFINE_GUID(CLSID_AVIMIDIRender,
0x07b65360, 0xc445, 0x11ce, 0xaf, 0xde, 0x00, 0xaa, 0x00, 0x6c, 0x14, 0xf4);

class CMIDIFilter;

/* Class supporting the renderer input pin */

//
// This pin is still a separate object in case it wants to have a distinct
// IDispatch....
//
class CMIDIInputPin : public CBaseInputPin
{
    friend class CMIDIFilter;

private:

    CMIDIFilter *m_pFilter;         // The renderer that owns us

public:

    CMIDIInputPin(CMIDIFilter *pMIDIFilter, HRESULT *phr, LPCWSTR pPinName);

    ~CMIDIInputPin();

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(IMemAllocator * pAllocator);

    /* Lets us know where a connection ends */
    HRESULT BreakConnect();

    /* Check that we can support this output type */
    HRESULT CheckMediaType(const CMediaType *pmt);

    /* Send a MIDI buffer to MMSYSTEM */
    HRESULT SendBuffer(LPMIDIHDR pmh);

    /* IMemInputPin virtual methods */

    /* Here's the next block of data from the stream.
       AddRef it if you are going to hold onto it. */
    STDMETHODIMP Receive(IMediaSample *pSample);

    // override so we can decommit and commit our own allocator
    HRESULT Active(void);
    HRESULT Inactive(void);

    // no more data is coming
    STDMETHODIMP EndOfStream(void);

    // flush our queued data
    STDMETHODIMP BeginFlush(void);
    STDMETHODIMP EndFlush(void);

    // flushing, ignore all receives
    BOOL	m_fFlushing;
};

/* This is the COM object that represents a simple rendering filter. It
   supports IBaseFilter and IMediaFilter and has a single input stream (pin)

   It will also (soon ??? !!!) support IDispatch to allow it to expose some
   simple properties....

*/

class CMIDIFilter : public CBaseFilter, public CCritSec
{

public:
    // Implements the IBaseFilter and IMediaFilter interfaces

    DECLARE_IUNKNOWN
	

    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State);

public:

    CMIDIFilter(LPUNKNOWN pUnk, HRESULT *phr);
    virtual ~CMIDIFilter();

    // open the MIDI device - called when our filter becomes active
    STDMETHODIMP OpenMIDIDevice(void);

    /* Return the pins that we support */

    int GetPinCount();
    CBasePin *GetPin(int n);

    /* Override this to say what interfaces we support and where */

    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    /* This goes in the factory template table to create new instances */

    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

private:

    /* The nested classes may access our private state */

    friend class CMIDIInputPin;

    /* Member variables */
    CMIDIInputPin *m_pInputPin;         /* IPin and IMemInputPin interfaces */

    HMIDISTRM m_hmidi;

    // handles IMediaPosition by passing upstream
    CPosPassThru * m_pImplPosition;

    static void MIDICallback(HDRVR hdrvr, UINT uMsg, DWORD dwUser,
					DWORD dw1, DWORD dw2);

    // we have a long that counts the number of queued buffers, which we
    // access with InterlockedIncrement. It is initialised to 0,
    // incremented whenever a buffer is added, and then decremented whenever
    // a buffer is completed.
    LONG        m_lBuffers;

    // End of stream goop.
    BOOL	m_fEOSReceived;
    BOOL	m_fEOSDelivered;

    // need some data to complete the ::Pause
    volatile BOOL m_fWaitingForData;

    CCritSec	m_csEOS;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\midirdr.h ===
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved

extern const AMOVIESETUP_FILTER sudMIDIParse;

// CLSID_MIDIParser,
// {D51BD5A2-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_MIDIParser,
0xd51bd5a2, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

#include "simpread.h"
#include <qnetwork.h> // IAMMediaContent

extern "C" {
    #include "smf.h"
};

class CMIDIStream;       // manages the output stream & pin

//
// CMIDIParse
//
class CMIDIParse : 
    public CSimpleReader, 
    IAMMediaContent 
{
    friend class CMIDIStream;
public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);    

    // During construction we create the single CMIDIStream object that provides the
    // output pin.
    CMIDIParse(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMIDIParse();

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    LONG StartFrom(LONG sStart) { return sStart; };
    HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t);
    CRefTime SampleToRefTime(LONG s);
    ULONG GetMaxSampleSize();

    // IAMMediaContent

    STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetTypeInfo(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

    STDMETHODIMP GetIDsOfNames(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) { return E_NOTIMPL; }

    STDMETHODIMP Invoke(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) { return E_NOTIMPL; }

    STDMETHODIMP get_Copyright(BSTR FAR* pbstrCopyright);
    STDMETHODIMP get_AuthorName(BSTR FAR* pbstrAuthorName) { return E_NOTIMPL; } ;
    STDMETHODIMP get_Title(BSTR FAR* pbstrTitle) { return E_NOTIMPL; };
    STDMETHODIMP get_Rating(BSTR FAR* pbstrRating) { return E_NOTIMPL; }
    STDMETHODIMP get_Description(BSTR FAR* pbstrDescription) { return E_NOTIMPL; };
    STDMETHODIMP get_BaseURL(BSTR FAR* pbstrBaseURL) { return E_NOTIMPL; }
    STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL) { return E_NOTIMPL; }
    STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL) { return E_NOTIMPL; }
    STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
    STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }
    

    BYTE *      m_lpFile;		// whole file, kept in memory
    HSMF	m_hsmf;			// handle for contigous reader
    HSMF	m_hsmfK;		// handle for keyframe reader
    DWORD	m_dwTimeDivision;	// used for the format

    DWORD	m_dwLastSampleRead;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\smf.c ===
// !!!
// This version differs slightly from the code in MCISEQ to make the API
// compatible with AVIMIDI.  Look for !!!
// !!!

/**********************************************************************
 
    Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.

    smf.c

    DESCRIPTION:
      Routines for reading and writing Standard MIDI Files.

*********************************************************************/

// !!! #define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include "muldiv32.h" 
#include "smf.h"
#include "smfi.h"
#include "debug.h"

void * __stdcall memmoveInternal(void *, const void *, size_t);
#undef hmemcpy
#define hmemcpy memmoveInternal

PRIVATE SMFRESULT FNLOCAL smfInsertParmData(
    PSMF                psmf,
    TICKS               tkDelta,                                            
    LPMIDIHDR           lpmh);


// For memory mapped riff file io:

typedef struct RIFF {  
    DWORD ckid;
    DWORD cksize;
} RIFF;

typedef struct RIFFLIST {
    DWORD ckid;
    DWORD cksize;
    DWORD fccType;
} RIFFLIST;

 #ifndef FCC
  #define FCC(dw) (((dw & 0xFF) << 24) | ((dw & 0xFF00) << 8) | ((dw & 0xFF0000) >> 8) | ((dw & 0xFF000000) >> 24))
 #endif


/*****************************************************************************
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfOpenFile | This function opens a MIDI file for access. No
 *  I/O can actually be performed until an HTRACK handle is obtained from
 *  <f smfOpenTrack>.
 *
 * @parm <t PSMFOPENFILESTRUCT> | psofs | Specifies the file to open and
 *  associated parameters. Contains a valid HSMF handle on success.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The specified file was opened.
 *  @flag SMF_OPEN_FAILED | The specified file could not be opened because it
 *   did not exist or could not be created on the disk.
 *  @flag SMF_INVALID_FILE | The specified file was corrupt or not a MIDI file.
 *  @flag SMF_NO_MEMORY | There was insufficient memory to open the file.
 *  @flag SMF_INVALID_PARM | The given flags or time division in the
 *   <t SMFOPENFILESTRUCT> were invalid.
 * 
 * @xref <t SMFOPENFILESTRUCT>, <f smfCloseFile>, <f smfOpenTrack>
 *****************************************************************************/
SMFRESULT FNLOCAL smfOpenFile(
    LPBYTE		lp,
    DWORD		cb,
    HSMF	       *phsmf)
{
    PSMF                psmf;
    SMFRESULT           smfrc = SMF_SUCCESS;
    RIFFLIST *riffptr = (RIFFLIST *) lp;

    // !!! as good a place as any?
    DbgInitialize(TRUE);

    // Now see if we can create the handle structure
    //
    psmf = (PSMF)LocalAlloc(LPTR, sizeof(SMF));
    if (NULL == psmf)
    {
        DPF(1, "smfOpenFile: LocalAlloc failed!");
        smfrc = SMF_NO_MEMORY;
        goto smf_Open_File_Cleanup;
    }

    psmf->fdwSMF = 0;
    psmf->pTempoMap = NULL;
    psmf->pbTrackName = NULL;
    psmf->pbCopyright = NULL;
    psmf->wChannelMask = 0xFFFF;

    if (riffptr->ckid == FCC('RIFF') && riffptr->fccType == FCC('RMID'))
    {
	DWORD offset = sizeof(RIFFLIST);
	RIFF * dataptr;
	
	while (offset < cb - 8) {
	    dataptr = (RIFF *) ((BYTE *) lp + offset);

	    if (dataptr->ckid == FCC('data'))
		break;

	    offset += sizeof(RIFF) + dataptr->cksize;
	}

	if (offset >= cb - 8) {
	    smfrc = SMF_INVALID_FILE;
	    goto smf_Open_File_Cleanup;
	}

        if(riffptr->cksize > cb) {
	    smfrc = SMF_INVALID_FILE;
	    goto smf_Open_File_Cleanup;
        }
        
	psmf->cbImage = riffptr->cksize;
	psmf->hpbImage = (BYTE *) (dataptr + 1);
    }
    else
    {
        psmf->cbImage = cb;
	psmf->hpbImage = lp;
    }
    
    //
    // If the file exists, parse it just enough to pull out the header and
    // build a track index.
    //
    smfrc = smfBuildFileIndex((PSMF BSTACK *)&psmf);
    if (MMSYSERR_NOERROR != smfrc)
    {
        DPF(1, "smfOpenFile: smfBuildFileIndex failed! [%lu]", (DWORD)smfrc);
    }
    else {
	// this code was in MCISeq, which did this after SMFOpen....
	// moved here, DavidMay, 11/11/96

	
	// Channel masks for getting events
	#define CHANMASK_GENERAL            0xFFFF      // 1-16
	#define CHANMASK_EXTENDED           0x03FF      // 1-10
	#define CHANMASK_BASE               0xFC00      // 11-16

	smfSetChannelMask((HSMF) psmf, CHANMASK_GENERAL);
	smfSetRemapDrum((HSMF) psmf, FALSE);
	if (psmf->fdwSMF & SMF_F_MSMIDI)
	{
	    if (psmf->wChanInUse & CHANMASK_EXTENDED)
		smfSetChannelMask((HSMF) psmf, CHANMASK_EXTENDED);
	    else
	    {
		smfSetChannelMask((HSMF) psmf, CHANMASK_BASE);
		smfSetRemapDrum((HSMF) psmf, TRUE);
	    }
	}
    }
        

smf_Open_File_Cleanup:

    if (SMF_SUCCESS != smfrc)
    {
        if (NULL != psmf)
        {
            LocalFree((HLOCAL)psmf);
        }
    }
    else
    {
        *phsmf = (HSMF)psmf;
    }
    
    return smfrc;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfCloseFile | This function closes an open MIDI file.
 *  Any open tracks are closed. All data is flushed and the MIDI file is
 *  remerged with any new track data. 
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @comm 
 *  Any track handles opened from this file handle are invalid after this
 *  call.
 *        
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The specified file was closed.
 *  @flag SMF_INVALID_PARM | The given handle was not valid.
 *
 * @xref <f smfOpenFile>
 *****************************************************************************/
SMFRESULT FNLOCAL smfCloseFile(
    HSMF                hsmf)
{
    PSMF                psmf        = (PSMF)hsmf;
    
    assert(psmf != NULL);
    
    //
    // Free up handle memory 
    //
    if (NULL != psmf->pbTrackName)
        LocalFree((HLOCAL)psmf->pbTrackName);
    
    if (NULL != psmf->pbCopyright)
        LocalFree((HLOCAL)psmf->pbCopyright);
    
    if (NULL != psmf->hTempoMap)
    {
        LocalUnlock(psmf->hTempoMap);
        LocalFree(psmf->hTempoMap);
    }
    
    LocalFree((HLOCAL)psmf);
    
    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfGetFileInfo | This function gets information about
 *  the MIDI file.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to inquire about.
 *
 * @parm PSMFFILEINFO | psfi | A structure which will be filled in with
 *  information about the file.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | Information was gotten about the file.
 *  @flag SMF_INVALID_PARM | The given handle was invalid.
 *
 * @xref <t SMFFILEINFO>
 *****************************************************************************/
SMFRESULT FNLOCAL smfGetFileInfo(
    HSMF                hsmf,
    PSMFFILEINFO        psfi)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);
    assert(psfi != NULL);

    // 
    // Just fill in the structure with useful information.
    //
    psfi->dwTracks      = psmf->dwTracks;
    psfi->dwFormat      = psmf->dwFormat;
    psfi->dwTimeDivision= psmf->dwTimeDivision;
    psfi->tkLength      = psmf->tkLength;
    psfi->fMSMidi       = (psmf->fdwSMF & SMF_F_MSMIDI) ? TRUE : FALSE;
    psfi->pbTrackName   = (LPBYTE)psmf->pbTrackName;
    psfi->pbCopyright   = (LPBYTE)psmf->pbCopyright;
    psfi->wChanInUse    = psmf->wChanInUse;
    
    return SMF_SUCCESS;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api void | smfSetChannelMask | This function sets the channel mask that
 *  SMF will use in all future read operations. The low bit corresponds to
 *  channel 0; the high bit to channel 15. Only 454-0055 events which are on
 *  channels with the corresponding bit set in the channel mask will be read.
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @parm WORD | wChannelMask | The new channel mask.
 *
 * @comm
 *  Don't change this in the middle of the file unless you want to have 
 *  missing note off's for note on's that already happened. 
 *        
 *****************************************************************************/
void FNLOCAL smfSetChannelMask(
    HSMF                hsmf,
    WORD                wChannelMask)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);

    DPF(1, "smfSetChannelMask(%04X)", wChannelMask);

    psmf->wChannelMask = wChannelMask;
}

/*****************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api void | smfRemapDrum | This function sets the remap drum flag. If
 *  this flag is set, SMF will convert all events on channel 16 to channel
 *  10.
 *
 * @parm HSMF | hsmf | The handle of the open file to close.
 *
 * @parm BOOL | fRemapDrum | The value to set the remap flag to
 *
 *****************************************************************************/
void FNLOCAL smfSetRemapDrum(
    HSMF                hsmf,
    BOOL                fRemapDrum)
{
    PSMF                psmf = (PSMF)hsmf;

    assert(psmf != NULL);

    DPF(2, "smfSetRemapDrum(%04X)", fRemapDrum);

    if (fRemapDrum)
        psmf->fdwSMF |= SMF_F_REMAPDRUM;
    else
        psmf->fdwSMF &=~SMF_F_REMAPDRUM;
}


/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api DWORD | smfTicksToMillisecs | This function returns the millisecond
 *  offset into the file given the tick offset.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to perform the conversion
 *  on.
 *
 * @parm TICKS | tkOffset | Specifies the tick offset into the stream to convert.
 *
 * @comm
 *  The conversion is performed taking into account the file's time division and
 *  tempo map from the first track. Note that the same millisecond value
 *  might not be valid at a later time if the tempo track is rewritten.
 *
 * @rdesc Returns the number of milliseconds from the start of the stream.
 *
 * @xref <f smfMillisecsToTicks>
 *****************************************************************************/
DWORD FNLOCAL smfTicksToMillisecs(
    HSMF                hsmf,
    TICKS               tkOffset)
{
    PSMF                psmf            = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    UINT                uSMPTE;
    DWORD               dwTicksPerSec;

    assert(psmf != NULL);

    // SMPTE time is easy -- no tempo map, just linear conversion
    // Note that 30-Drop means nothing to us here since we're not
    // converting to a colonized format, which is where dropping
    // happens.
    //
    if (psmf->dwTimeDivision & 0x8000)
    {
        uSMPTE = -(int)(char)((psmf->dwTimeDivision >> 8)&0xFF);
        if (29 == uSMPTE)
            uSMPTE = 30;
        
        dwTicksPerSec = (DWORD)uSMPTE *
                        (DWORD)(BYTE)(psmf->dwTimeDivision & 0xFF);
        
        return (DWORD)muldiv32(tkOffset, 1000L, dwTicksPerSec);
    }
       
    // Walk the tempo map and find the nearest tick position. Linearly
    // calculate the rest (using MATH.ASM)
    //

    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (tkOffset < pTempo->tkTempo)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //

    return pTempo->msBase + muldiv32(tkOffset-pTempo->tkTempo,
                                     pTempo->dwTempo,
                                     1000L*psmf->dwTimeDivision);
}


/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api DWORD | smfMillisecsToTicks | This function returns the nearest tick
 *  offset into the file given the millisecond offset.
 *
 * @parm HSMF | hsmf | Specifies the open MIDI file to perform the conversion
 *  on.
 *
 * @parm DWORD | msOffset | Specifies the millisecond offset into the stream
 *  to convert.
 *
 * @comm
 *  The conversion is performed taking into account the file's time division and
 *  tempo map from the first track. Note that the same tick value
 *  might not be valid at a later time if the tempo track is rewritten.
 *  If the millisecond value does not exactly map to a tick value, then
 *  the tick value will be rounded down.
 *
 * @rdesc Returns the number of ticks from the start of the stream.
 *
 * @xref <f smfTicksToMillisecs>
 *****************************************************************************/
DWORD FNLOCAL smfMillisecsToTicks(
    HSMF                hsmf,
    DWORD               msOffset)
{
    PSMF                psmf            = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    UINT                uSMPTE;
    DWORD               dwTicksPerSec;

    DPF(2, "smfMillisecsToTicks");
    assert(psmf != NULL);
    
    // SMPTE time is easy -- no tempo map, just linear conversion
    // Note that 30-Drop means nothing to us here since we're not
    // converting to a colonized format, which is where dropping
    // happens.
    //
    if (psmf->dwTimeDivision & 0x8000)
    {
        uSMPTE = -(int)(char)((psmf->dwTimeDivision >> 8)&0xFF);
        if (29 == uSMPTE)
            uSMPTE = 30;
        
        dwTicksPerSec = (DWORD)uSMPTE *
                        (DWORD)(BYTE)(psmf->dwTimeDivision & 0xFF);

        DPF(2, "SMPTE: dwTicksPerSec %ld", dwTicksPerSec);
        
        return (DWORD)muldiv32(msOffset, dwTicksPerSec, 1000L);
    }
    
    // Walk the tempo map and find the nearest millisecond position. Linearly
    // calculate the rest (using MATH.ASM)
    //
    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (msOffset < pTempo->msBase)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //
    DPF(2, "pTempo->tkTempo %lu msBase %lu dwTempo %lu", (DWORD)pTempo->tkTempo, (DWORD)pTempo->msBase, pTempo->dwTempo);
    return pTempo->tkTempo + muldiv32(msOffset-pTempo->msBase,
                                     1000L*psmf->dwTimeDivision,
                                     pTempo->dwTempo);
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfReadEvents | This function reads events from a track.
 *
 * @parm HSMF | hsmf | Specifies the file to read data from.
 *
 * @parm LPMIDIHDR | lpmh | Contains information about the buffer to fill.
 *
 * @parm DWORD | fdwRead | Contains flags specifying how to do the read.
 *  @flag SMF_REF_NOMETA | Meta events will not be put into the buffer.         
 *
 * @comm
 *  This function may only be called on a file opened for read access.
 * 
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_TRACK | There are no more events to read in this track.
 *  @flag SMF_INVALID_PARM | The given handle, buffer, or flags were invalid.
 *  @flag SMF_INVALID_FILE | A disk error occured on the file.
 * 
 * @xref <f smfWriteEvents>
 *****************************************************************************/
SMFRESULT FNLOCAL smfReadEvents(
    HSMF                hsmf,
    LPMIDIHDR           lpmh,
    DWORD               fdwRead,
    TICKS               tkMax,
    BOOL                fDiscardTempoEvents)
{
    PSMF                psmf = (PSMF)hsmf;
    SMFRESULT           smfrc;
    EVENT               event;
    LPDWORD             lpdw;
    DWORD               dwTempo;

    assert(psmf != NULL);
    assert(lpmh != NULL);

    // 
    // Read events from the track and pack them into the buffer in polymsg
    // format.
    // 
    // If a SysEx or meta would go over a buffer boundry, split it.
    // 
    lpmh->dwBytesRecorded = 0;
    if (psmf->dwPendingUserEvent)
    {
        DPF(1, "smfReadEvents: Inserting pending event...");
        
        smfrc = smfInsertParmData(psmf, (TICKS)0, lpmh);
        if (SMF_SUCCESS != smfrc)
        {
            DPF(1, "smfInsertParmData() -> %u", (UINT)smfrc);
            return smfrc;
        }
    }
    
    lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);

    if (psmf->fdwSMF & SMF_F_EOF)
    {
        DPF(1, "smfReadEvents: SMF_F_EOF set; instant out");
        return SMF_END_OF_FILE;
    }

    while(TRUE)
    {
        assert(lpmh->dwBytesRecorded <= lpmh->dwBufferLength);
        
        // If we know ahead of time we won't have room for the
        // event, just break out now. We need at least 3 DWORD's
        // for any event we might store - this will allow us a full
        // short event or the delta time and stub for a long
        // event to be split.
        //
        if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
        {
            break;
        }

        smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkMax);
        if (SMF_SUCCESS != smfrc)
        {
            // smfGetNextEvent doesn't set this because smfSeek uses it
            // as well and needs to distinguish between reaching the
            // seek point and reaching end-of-file.
            //
            // To the user, however, we present the selection between
            // their given tkBase and tkEnd as the entire file, therefore
            // we want to translate this into EOF.
            //
            if (SMF_REACHED_TKMAX == smfrc)
            {
	 	// !!! poor API!!! This prevents Read(100), Read(200) from
		// working, because the Read(200) will fail just because the
		// Read(100) succeeded and says that the EOF is reached!
                // pSmf->fdwSMF |= SMF_F_EOF;
            }
            
            DPF(2, "smfReadEvents: smfGetNextEvent() -> %u", (UINT)smfrc);
            break;
        }

        
        if (MIDI_SYSEX > EVENT_TYPE(event))
        {
            BYTE b = EVENT_TYPE(event);

            // If we're remapping drum events, and this event is on
            // channel 16, move it to channel 10 (or, 0-based, 15 to 9)
            //
            if (psmf->fdwSMF & SMF_F_REMAPDRUM &&
                ((b & 0x0F) == 0x0F))
            {
               b = (b & 0xF0) | 0x09;
            }
            
            *lpdw++ = (DWORD)(psmf->tkDiscardedEvents + event.tkDelta);
            psmf->tkDiscardedEvents = 0;
            
            *lpdw++ = 0;
            *lpdw++ = (((DWORD)MEVT_SHORTMSG)<<24) |
                      ((DWORD)b)|
                      (((DWORD)EVENT_CH_B1(event)) << 8) |
                      (((DWORD)EVENT_CH_B2(event)) << 16);
            
            lpmh->dwBytesRecorded += 3*sizeof(DWORD);
        }
        else if (MIDI_META == EVENT_TYPE(event) &&
                 MIDI_META_EOT == EVENT_META_TYPE(event))
        {
            // These are ignoreable since smfReadNextEvent()
            // takes care of track merging
            //
            DPF(1, "smfReadEvents: Hit META_EOT");
        }
        else if (MIDI_META == EVENT_TYPE(event) &&
                 MIDI_META_TEMPO == EVENT_META_TYPE(event))
        {
            if (event.cbParm != 3)
            {
                DPF(1, "smfReadEvents: Corrupt tempo event");
                return SMF_INVALID_FILE;
            }

            if( !fDiscardTempoEvents ) {
                dwTempo = (((DWORD)MEVT_TEMPO)<<24)|
                        (((DWORD)event.hpbParm[0])<<16)|
                        (((DWORD)event.hpbParm[1])<<8)|
                        ((DWORD)event.hpbParm[2]);

                *lpdw++ = (DWORD)(psmf->tkDiscardedEvents + event.tkDelta);
                psmf->tkDiscardedEvents = 0;

                // Tempo should be honored by everyone
                //
                *lpdw++ = (DWORD)-1L;
                *lpdw++ = dwTempo;

                lpmh->dwBytesRecorded += 3*sizeof(DWORD);
            }
        }
        else if (MIDI_META != EVENT_TYPE(event))
        {
            // Must be F0 or F7 system exclusive or FF meta
            // that we didn't recognize
            //
            psmf->cbPendingUserEvent = event.cbParm;
            psmf->hpbPendingUserEvent = event.hpbParm;
            psmf->fdwSMF &= ~SMF_F_INSERTSYSEX;

            switch(EVENT_TYPE(event))
            {
//                case MIDI_META:
//                    psmf->dwPendingUserEvent = ((DWORD)MEVT_META) << 24;
//                    break;

                case MIDI_SYSEX:
                    psmf->fdwSMF |= SMF_F_INSERTSYSEX;
            
                    ++psmf->cbPendingUserEvent;

                    // Falling through...
                    //

                case MIDI_SYSEXEND:
                    psmf->dwPendingUserEvent = ((DWORD)MEVT_LONGMSG) << 24;
                    break;
            }

            smfrc = smfInsertParmData(psmf,
                                      psmf->tkDiscardedEvents + event.tkDelta,
                                      lpmh);
            psmf->tkDiscardedEvents = 0;
            
            if (SMF_SUCCESS != smfrc)
            {
                DPF(1, "smfInsertParmData[2] %u", (UINT)smfrc);
                return smfrc;
            }

            lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);
        }
        else
        {
            // Take into account the delta-time of any events
            // we don't actually put into the buffer
            //
            psmf->tkDiscardedEvents += event.tkDelta;
        }        
    }

    if( 0 == lpmh->dwBytesRecorded ) {
	// !!! poor API!!! This prevents Read(100), Read(200) from
	// working, because the Read(200) will fail just because the
	// Read(100) succeeded and says that the EOF is reached!
        // psmf->fdwSMF |= SMF_F_EOF;
    }

    return (psmf->fdwSMF & SMF_F_EOF) ? SMF_END_OF_FILE : SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @api SMFRESULT | smfInsertParmData | Inserts pending long data from
 *  a track into the given buffer.
 *
 * @parm PSMF | psmf | Specifies the file to read data from.
 *
 * @parm LPMIDIHDR | lpmh | Contains information about the buffer to fill.
 *
 * @comm
 *  Fills as much data as will fit while leaving room for the buffer
 *  terminator.
 *
 *  If the long data is depleted, resets <p psmf!dwPendingUserEvent> so
 *  that the next event may be read.
 * 
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_TRACK | There are no more events to read in this track.
 *  @flag SMF_INVALID_FILE | A disk error occured on the file.
 * 
 * @xref <f smfReadEvents>
 *****************************************************************************/
PRIVATE SMFRESULT FNLOCAL smfInsertParmData(
    PSMF                psmf,
    TICKS               tkDelta,                                            
    LPMIDIHDR           lpmh)
{
    DWORD               dwLength;
    DWORD               dwRounded;
    LPDWORD             lpdw;

    assert(psmf != NULL);
    assert(lpmh != NULL);
    
    // Can't fit 4 DWORD's? (tkDelta + stream-id + event + some data) Can't do anything.
    //
    assert(lpmh->dwBufferLength >= lpmh->dwBytesRecorded);
    
    if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 4*sizeof(DWORD))
    {
        if (0 == tkDelta)
            return SMF_SUCCESS;

        // If we got here with a real delta, that means smfReadEvents screwed
        // up calculating left space and we should flag it somehow.
        //
        return SMF_INVALID_FILE;
    }

    lpdw = (LPDWORD)(lpmh->lpData + lpmh->dwBytesRecorded);

    dwLength = lpmh->dwBufferLength - lpmh->dwBytesRecorded - 3*sizeof(DWORD);
    dwLength = min(dwLength, psmf->cbPendingUserEvent);

    *lpdw++ = (DWORD)tkDelta;

    // Stream ID -- SysEx is broadcast
    //
    *lpdw++ = (DWORD)-1L;
    *lpdw++ = (psmf->dwPendingUserEvent & 0xFF000000L) | (dwLength & 0x00FFFFFFL);

    dwRounded = (dwLength + 3) & (~3L);
    
    if (psmf->fdwSMF & SMF_F_INSERTSYSEX)
    {
        *((LPBYTE)lpdw)++ = MIDI_SYSEX;
        psmf->fdwSMF &= ~SMF_F_INSERTSYSEX;
        --dwLength;
        --psmf->cbPendingUserEvent;
    }    

    hmemcpy(lpdw, psmf->hpbPendingUserEvent, dwLength);
    if (0 == (psmf->cbPendingUserEvent -= dwLength))
        psmf->dwPendingUserEvent = 0;

    lpmh->dwBytesRecorded += 3*sizeof(DWORD) + dwRounded;

    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfSeek | This function moves the file pointer within a track
 *  and gets the state of the track at the new position. It returns a buffer of
 *  state information which can be used to set up to play from the new position.
 *
 * @parm HTRACK | htrack | The track to seek and get state information from.
 *
 * @parm TICKS | tkPosition | The position to seek to in the track.
 *         
 * @parm LPMIDIHDR | lpmh | A buffer to contain the state information.
 *  If this pointer is NULL, then no state information will be returned.
 *
 * @comm
 *  The state information in the buffer includes patch changes, tempo changes,
 *  time signature, key signature, 
 *  and controller information. Only the most recent of these paramters before
 *  the current position will be stored. The state buffer will be returned
 *  in polymsg format so that it may be directly transmitted over the MIDI
 *  bus to bring the state up to date.
 *
 *  The buffer is mean to be sent as a streaming buffer; i.e. immediately
 *  followed by the first data buffer. If the requested tick position
 *  does not exist in the file, the last event in the buffer
 *  will be a MEVT_NOP with a delta time calculated to make sure that
 *  the next stream event plays at the proper time.
 *
 *  The meta events (tempo, time signature, key signature) will be the
 *  first events in the buffer if they exist.
 * 
 *  This function may only be called on a file opened for read access.
 *
 *  Use <f smfGetStateMaxSize> to determine the maximum size of the state
 *  information buffer. State information that will not fit into the given
 *  buffer will be lost.
 *
 *  On return, the <t dwBytesRecorded> field of <p lpmh> will contain the
 *  actual number of bytes stored in the buffer.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The state was successfully read.
 *  @flag SMF_END_OF_TRACK | The pointer was moved to end of track and no state
 *   information was returned.
 *  @flag SMF_INVALID_PARM | The given handle or buffer was invalid.
 *  @flag SMF_NO_MEMORY | There was insufficient memory in the given buffer to
 *   contain all of the state data.
 *
 * @xref <f smfGetStateMaxSize>
 *****************************************************************************/

PRIVATE SMFRESULT FNLOCAL smfFillBufferFromKeyframe(HSMF hsmf, LPMIDIHDR lpmh);

SMFRESULT FNLOCAL smfSeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh)
{
    PSMF                psmf    = (PSMF)hsmf;
    PTRACK              ptrk;
    DWORD               idxTrack;
    SMFRESULT           smfrc;
    EVENT               event;
    BYTE                bEvent;
    
// !!! KEYFRAME is now part of SMF

    assert( tkPosition <= psmf->tkLength );  // Caller should guarantee this!

    _fmemset(&psmf->kf, 0xFF, sizeof(KEYFRAME));
    
    psmf->tkPosition = 0;
    psmf->tkDiscardedEvents = 0;
    psmf->fdwSMF &= ~(SMF_F_EOF|SMF_F_MSMIDI);
    
    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
    {
        ptrk->psmf              = psmf;
        ptrk->tkPosition        = 0;
        ptrk->cbLeft            = ptrk->smti.cbLength;
        ptrk->hpbImage          = psmf->hpbImage + ptrk->idxTrack;
        ptrk->bRunningStatus    = 0;
        ptrk->fdwTrack          = 0;
    }

    // If we're starting at zero, let events get sent in normal buffer.
    // Else seek through tkPosition-1 to get everything before where we're
    // going to start playing. This avoids the problem of discardind
    // the non-keyframe events (such as note on's) at the tick tkPosition.
    //
    smfrc = SMF_REACHED_TKMAX;
    
    if (tkPosition)
    {
        --tkPosition;
        while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkPosition)))
        {
            if (MIDI_META == (bEvent = EVENT_TYPE(event)))
            {
                if (EVENT_META_TYPE(event) == MIDI_META_TEMPO)
                {
                    if (event.cbParm != sizeof(psmf->kf.rbTempo))
                        return SMF_INVALID_FILE;

                    hmemcpy((HPBYTE)psmf->kf.rbTempo, event.hpbParm, event.cbParm);
                }
            }
            else switch(bEvent & 0xF0)
            {
 case MIDI_PROGRAMCHANGE:
     psmf->kf.rbProgram[bEvent & 0x0F] = EVENT_CH_B1(event);
     break;

 case MIDI_CONTROLCHANGE:
     psmf->kf.rbControl[(((WORD)bEvent & 0x0F)*120) + EVENT_CH_B1(event)] =
         EVENT_CH_B2(event);
     break;
            }
        }
    }

    //
    //  If we hit EOF, then we must have been seeking for the end.
    //
    if( ( SMF_REACHED_TKMAX != smfrc )  &&
        ( SMF_END_OF_FILE   != smfrc ) )
    {
        return smfrc;
    }

#ifdef DEBUG
    if( (SMF_END_OF_FILE==smfrc) && (tkPosition!=psmf->tkLength) ) {
        DPF(1,"smfSeek: hit EOF, yet we weren't seeking to the end (tkPosition=%lu, tkLength=%lu).",tkPosition,psmf->tkLength);
    }
#endif

    // Now fill the buffer from our keyframe data
    // !!! This part has been pulled out into a separate function
    smfrc = smfFillBufferFromKeyframe(hsmf, lpmh);

    // Force all tracks to be at tkPosition. We are guaranteed that
    // all tracks will be past the event immediately preceding tkPosition;
    // this will force correct delta-ticks to be generated so that events
    // on all tracks will line up properly on a seek into the middle of the
    // file.
    //
// !!! I think this is commented out because of the --tkPosition added above
//    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
//    {
//        ptrk->tkPosition        = tkPosition;
//    }

    return smfrc;
    
}
    

// !!! Danny's new function to seek forward a bit and keep the old keyframe
// info around, only adding to it, to avoid every seek seeking from the
// beginning of the file.  You would use it like:
//
// smfSeek(10);
// smfDannySeek(20);
// smfDannySeek(30);
//
// which will work as long as you make no other calls on this handle in between.
// The subsequent seeks will NOT re-seek from the beginning, but remember where
// they left off.
//
SMFRESULT FNLOCAL smfDannySeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh)
{
    PSMF                psmf    = (PSMF)hsmf;
    SMFRESULT           smfrc;
    EVENT               event;
    BYTE                bEvent;
    
    assert( tkPosition <= psmf->tkLength );  // Caller should guarantee this!

    if (tkPosition < psmf->tkPosition) {
        DPF(1,"smfDannySeek: not seeking forward... doing a REAL seek");
	return smfSeek(hsmf, tkPosition, lpmh);
    }

    // If we're starting at zero, let events get sent in normal buffer.
    // Else seek through tkPosition-1 to get everything before where we're
    // going to start playing. This avoids the problem of discardind
    // the non-keyframe events (such as note on's) at the tick tkPosition.
    //
    smfrc = SMF_REACHED_TKMAX;
    
    if (tkPosition)
    {
        --tkPosition;
        while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (SPEVENT)&event, tkPosition)))
        {
            if (MIDI_META == (bEvent = EVENT_TYPE(event)))
            {
                if (EVENT_META_TYPE(event) == MIDI_META_TEMPO)
                {
                    if (event.cbParm != sizeof(psmf->kf.rbTempo))
                        return SMF_INVALID_FILE;

                    hmemcpy((HPBYTE)psmf->kf.rbTempo, event.hpbParm, event.cbParm);
                }
            }
            else switch(bEvent & 0xF0)
            {
 case MIDI_PROGRAMCHANGE:
     psmf->kf.rbProgram[bEvent & 0x0F] = EVENT_CH_B1(event);
     break;

 case MIDI_CONTROLCHANGE:
     psmf->kf.rbControl[(((WORD)bEvent & 0x0F)*120) + EVENT_CH_B1(event)] =
         EVENT_CH_B2(event);
     break;
            }
        }
    }

    //
    //  If we hit EOF, then we must have been seeking for the end.
    //
    if( ( SMF_REACHED_TKMAX != smfrc )  &&
        ( SMF_END_OF_FILE   != smfrc ) )
    {
        return smfrc;
    }

#ifdef DEBUG
    if( (SMF_END_OF_FILE==smfrc) && (tkPosition!=psmf->tkLength) ) {
        DPF(1,"smfSeek: hit EOF, yet we weren't seeking to the end (tkPosition=%lu, tkLength=%lu).",tkPosition,psmf->tkLength);
    }
#endif

    // Now fill the buffer from our keyframe data
    return smfFillBufferFromKeyframe(hsmf, lpmh);
}


// !!! new function
SMFRESULT FNLOCAL smfFillBufferFromKeyframe(HSMF hsmf, LPMIDIHDR lpmh)
{
    UINT                idx;
    UINT                idxChannel;
    UINT                idxController;
    LPDWORD             lpdw;
    PSMF                psmf    = (PSMF)hsmf;

    // Build lpmh from keyframe
    //
    lpmh->dwBytesRecorded = 0;
    lpdw = (LPDWORD)lpmh->lpData;

    // Tempo change event?
    //
    if (KF_EMPTY != psmf->kf.rbTempo[0] ||
        KF_EMPTY != psmf->kf.rbTempo[1] ||
        KF_EMPTY != psmf->kf.rbTempo[2])
    {
        if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
            return SMF_NO_MEMORY;

        *lpdw++ = 0;
        *lpdw++ = 0;
        *lpdw++ = (((DWORD)psmf->kf.rbTempo[0])<<16)|
                  (((DWORD)psmf->kf.rbTempo[1])<<8)|
                  ((DWORD)psmf->kf.rbTempo[2])|
                  (((DWORD)MEVT_TEMPO) << 24);

        lpmh->dwBytesRecorded += 3*sizeof(DWORD);
    }

    // Program change events?
    //
    for (idx = 0; idx < 16; idx++)
    {
        if (KF_EMPTY != psmf->kf.rbProgram[idx])
        {
            if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
                return SMF_NO_MEMORY;

            *lpdw++ = 0;
            *lpdw++ = 0;
            *lpdw++ = (((DWORD)MEVT_SHORTMSG) << 24)      |
                      ((DWORD)MIDI_PROGRAMCHANGE)         |
                      ((DWORD)idx)                        |
                      (((DWORD)psmf->kf.rbProgram[idx]) << 8);

            lpmh->dwBytesRecorded += 3*sizeof(DWORD);
        }
    }

    // Controller events?
    //
    idx = 0;
    for (idxChannel = 0; idxChannel < 16; idxChannel++)
    {
        for (idxController = 0; idxController < 120; idxController++)
        {
            if (KF_EMPTY != psmf->kf.rbControl[idx])
            {
                if (lpmh->dwBufferLength - lpmh->dwBytesRecorded < 3*sizeof(DWORD))
                    return SMF_NO_MEMORY;

                *lpdw++ = 0;
                *lpdw++ = 0;
                *lpdw++ = (((DWORD)MEVT_SHORTMSG << 24)     |
                          ((DWORD)MIDI_CONTROLCHANGE)       |
                          ((DWORD)idxChannel)               |
                          (((DWORD)idxController) << 8)     |
                          (((DWORD)psmf->kf.rbControl[idx]) << 16));

                lpmh->dwBytesRecorded += 3*sizeof(DWORD);
            }

            idx++;
        }
    }

    return SMF_SUCCESS;
}

DWORD FNLOCAL smfGetTempo(
    HSMF                hsmf,
    TICKS               tkPosition)
{
    PSMF                psmf     = (PSMF)hsmf;
    PTEMPOMAPENTRY      pTempo;
    UINT                idx;
    
    // Walk the tempo map and find the nearest tick position. Linearly
    // calculate the rest (using MATH.ASM)
    //

    pTempo = psmf->pTempoMap;
    assert(pTempo != NULL);
    
    for (idx = 0; idx < psmf->cTempoMap; idx++, pTempo++)
        if (tkPosition < pTempo->tkTempo)
            break;

    pTempo--;       // Want the one just BEFORE

    // pTempo is the tempo map entry preceding the requested tick offset.
    //
    return pTempo->dwTempo;
}
                          

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api SMFRESULT | smfGetStateMaxSize | This function returns the maximum size
 *  of buffer that is needed to hold the state information returned by
 *  <f smfSeek>.
 *
 * @parm PDWORD | pdwSize | Gets the size in bytes that should be allocated
 *  for the state buffer.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The state was successfully read.
 *
 * @xref <f smfSeek>
 *****************************************************************************/
DWORD FNLOCAL smfGetStateMaxSize(
    void)
{
    return  3*sizeof(DWORD) +           // Tempo
            3*16*sizeof(DWORD) +        // Patch changes
            3*16*120*sizeof(DWORD) +    // Controller changes
            3*sizeof(DWORD);            // Time alignment NOP
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api LPWORD | smfGetPatchCache | This function returns the patch cache
 *  array for the given MIDI file. This information was compiled at file open
 *  time. The returned pointer points to an array suitable for
 *  midiOutCachePatches.
 *
 * @parm HSMF | hsmf | The handle of the open file to get patch information from.
 *
 * @xref <f smfGetKeyCache>
 *****************************************************************************/
LPWORD FNGLOBAL smfGetPatchCache(
    HSMF            hsmf)
{
    PSMF            psmf    = (PSMF)hsmf;

    assert(psmf != NULL);

    return (LPWORD)psmf->awPatchCache;
}

/******************************************************************************
 *
 * @doc SMF EXTERNAL
 *
 * @api LPWORD | smfGetKeyCache | This function returns the key cache
 *  array for the given MIDI file. This information was compiled at file open
 *  time. The returned pointer points to an array suitable for
 *  midiOutCacheDrumPatches.
 *
 * @parm HSMF | hsmf | The handle of the open file to get key information from.
 *
 * @xref <f smfGetPatchCache>
 *****************************************************************************/
LPWORD FNGLOBAL smfGetKeyCache(
    HSMF            hsmf)
{
    PSMF            psmf    = (PSMF)hsmf;

    assert(psmf != NULL);

    return (LPWORD)psmf->awKeyCache;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\smf.h ===
/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    smf.h

    DESCRIPTION:
      Public include file for Standard MIDI File access routines.

*********************************************************************/

#ifndef _SMF_
#define _SMF_

#include "global.h"             // #define's we need
//-----------------------------------------------------------------------------
//
// Debug from test app - remove later
//
extern void NEAR SeqDebug(LPSTR lpstrDebugText, ...);
//-----------------------------------------------------------------------------


typedef DWORD SMFRESULT;
typedef DWORD TICKS;
typedef TICKS FAR *PTICKS;
typedef BYTE HUGE *HPBYTE;
// !!! typedef BYTE __huge *HPBYTE;

#define MAX_TICKS           ((TICKS)0xFFFFFFFFL)

#define SMF_SUCCESS         (0L)
#define SMF_INVALID_FILE    (1L)
#define SMF_NO_MEMORY       (2L)
#define SMF_OPEN_FAILED     (3L)
#define SMF_INVALID_TRACK   (4L)
#define SMF_META_PENDING    (5L)
#define SMF_ALREADY_OPEN    (6L)
#define SMF_END_OF_TRACK    (7L)
#define SMF_NO_META         (8L)
#define SMF_INVALID_PARM    (9L)
#define SMF_INVALID_BUFFER  (10L)
#define SMF_END_OF_FILE     (11L)
#define SMF_REACHED_TKMAX   (12L)

DECLARE_HANDLE(HSMF);
DECLARE_HANDLE(HTRACK);

//-----------------------------------------------------------------------------

extern SMFRESULT FNLOCAL smfOpenFile(
    LPBYTE		lp,
    DWORD		cb,
    HSMF	       *phsmf);

extern SMFRESULT FNLOCAL smfCloseFile(
    HSMF                hsmf);

typedef struct tag_smffileinfo
{
    DWORD               dwTracks;
    DWORD               dwFormat;
    DWORD               dwTimeDivision;
    TICKS               tkLength;
    BOOL                fMSMidi; 
    LPBYTE              pbTrackName;
    LPBYTE              pbCopyright;
    WORD                wChanInUse;
}   SMFFILEINFO,
    FAR *PSMFFILEINFO;

extern SMFRESULT FNLOCAL smfGetFileInfo(
    HSMF                hsmf,
    PSMFFILEINFO        psfi);

extern void FNLOCAL smfSetChannelMask(
    HSMF                hsmf,
    WORD                wChannelMask);

extern void FNLOCAL smfSetRemapDrum(
    HSMF                hsmf,
    BOOL                fRemapDrum);                                    

//-----------------------------------------------------------------------------

extern DWORD FNLOCAL smfTicksToMillisecs(
    HSMF                hsmf,
    TICKS               tkOffset);

extern DWORD FNLOCAL smfMillisecsToTicks(
    HSMF                hsmf,
    DWORD               msOffset);

//-----------------------------------------------------------------------------

#define SMF_REF_NOMETA      0x00000001L

extern SMFRESULT FNLOCAL smfReadEvents(
    HSMF                hsmf,
    LPMIDIHDR           lpmh,
    DWORD               fdwRead,
    TICKS               tkMax,
    BOOL                fDiscardTempoEvents);

extern SMFRESULT FNLOCAL smfSeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh);

// !!! new
extern SMFRESULT FNLOCAL smfDannySeek(
    HSMF                hsmf,
    TICKS               tkPosition,
    LPMIDIHDR           lpmh);

extern DWORD FNLOCAL smfGetTempo(
    HSMF                hsmf,
    TICKS               tkPosition);

extern DWORD FNLOCAL smfGetStateMaxSize(
    void);

extern LPWORD FNGLOBAL smfGetPatchCache(
    HSMF            hsmf);

extern LPWORD FNGLOBAL smfGetKeyCache(
    HSMF            hsmf);


//-----------------------------------------------------------------------------

//
// Buffer described by LPMIDIHDR is in polymsg format, except that it
// can contain meta-events (which will be ignored during playback by
// the current system). This means we can use the pack functions, etc.
//
#define PMSG_META       ((BYTE)0xC0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\midirdr.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
//  WAV file parser
//

// Caveats
//

#include <streams.h>
#include <windowsx.h>
#include "midif.h"

#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include <mmsystem.h>

#include "midirdr.h"
// We break MIDI data up into samples of 1s each - constant time, variable
// size.
#define MSPERSAMPLE	1000L	// smaller buffers break up too often

//
// setup data
//

// !!!! is this a good idea???
#define MEDIASUBTYPE_Midi	MEDIATYPE_Midi

const AMOVIESETUP_MEDIATYPE
psudMIDIParseType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &MEDIASUBTYPE_Midi } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudMIDIParseOutType = { &MEDIATYPE_Midi       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudMIDIParsePins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudMIDIParseType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudMIDIParseOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudMIDIParse = { &CLSID_MIDIParser     // clsID
               , L"MIDI Parser"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudMIDIParsePins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"MIDI Parser"
    , &CLSID_MIDIParser
    , CMIDIParse::CreateInstance
    , NULL
    , &sudMIDIParse }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CMIDIParse::Constructor
//
CMIDIParse::CMIDIParse(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
    : CSimpleReader(pName, lpunk, CLSID_MIDIParser, &m_cStateLock, phr),
	m_hsmf(NULL),
	m_hsmfK(NULL),
	m_dwTimeDivision(0),
	m_lpFile(NULL)
{

    CAutoLock l(&m_cStateLock);

    DbgLog((LOG_TRACE, 1, TEXT("CMIDIParse created")));
}


//
// CMIDIParse::Destructor
//
CMIDIParse::~CMIDIParse(void) {
    if (m_hsmf)
	smfCloseFile(m_hsmf);
    if (m_hsmfK)
	smfCloseFile(m_hsmfK);

    delete[] m_lpFile;
    
    DbgLog((LOG_TRACE, 1, TEXT("CMIDIParse destroyed")) );
}


//
// CreateInstance
//
// Called by CoCreateInstance to create a QuicktimeReader filter.
CUnknown *CMIDIParse::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CMIDIParse(NAME("MIDI parsing filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}

STDMETHODIMP
CMIDIParse::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IAMMediaContent)
    {
        return GetInterface((IAMMediaContent  *)this, ppv);
    }
    else
    {
        return CSimpleReader::NonDelegatingQueryInterface(riid, ppv);
    }
}


HRESULT CMIDIParse::ParseNewFile()
{
    HRESULT         hr = NOERROR;

    LONGLONG llTotal, llAvailable;

    for (;;) {
	hr = m_pAsyncReader->Length(&llTotal, &llAvailable);
	if (FAILED(hr))
	    return hr;

	if (hr != VFW_S_ESTIMATED)
	    break;	// success....

        MSG Message;
        while (PeekMessage(&Message, NULL, 0, 0, TRUE))
        {
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
        
	Sleep(10);	// wait until file has finished reading....
    }

	
    DWORD cbFile = (DWORD) llTotal;

    //
    // Something bogus to force a seek on first read
    //
    m_dwLastSampleRead = (DWORD) -64;
    
    m_lpFile = new BYTE[cbFile];

    if (!m_lpFile)
	goto memerror;
    
    /* Try to read whole file */
    hr = m_pAsyncReader->SyncRead(0, cbFile, m_lpFile);

    if (hr != S_OK)
        goto readerror;

    
    {
	// call smfOpenFile to set up the MIDI parser....

	SMFRESULT f = smfOpenFile(m_lpFile, cbFile, &m_hsmf);
	if (f != SMF_SUCCESS) {
	    DbgLog((LOG_ERROR,1,TEXT("*Error %d opening MIDI file"), (int)f));
	    goto formaterror;
	}

	f = smfOpenFile(m_lpFile, cbFile, &m_hsmfK);
	if (f != SMF_SUCCESS) {
	    DbgLog((LOG_ERROR,1,TEXT("*Error %d opening MIDI file"), (int)f));
	    goto formaterror;
	}

	// Get the length (in samples)
	SMFFILEINFO	sfi;
	f = smfGetFileInfo(m_hsmf, &sfi);
	if (f != SMF_SUCCESS) {
	    DbgLog((LOG_ERROR,1,TEXT("*Error %d from smfGetFileInfo"), f));
	    // !!! Now what?
	}
	m_dwTimeDivision = sfi.dwTimeDivision;	// save for the format
	// Get the length of the file in ms and convert to samples
	DWORD dwLength = smfTicksToMillisecs(m_hsmf, sfi.tkLength);
	m_sLength = (dwLength + MSPERSAMPLE - 1) / MSPERSAMPLE;
    }

    {
	CMediaType mtMIDI;

	if (mtMIDI.AllocFormatBuffer(sizeof(MIDIFORMAT)) == NULL)
	    goto memerror;

	ZeroMemory((BYTE *) mtMIDI.Format(), sizeof(MIDIFORMAT));

	// !!! get format
	((MIDIFORMAT *) (mtMIDI.Format()))->dwDivision = m_dwTimeDivision;


	mtMIDI.SetType(&MEDIATYPE_Midi);
	mtMIDI.SetFormatType(&GUID_NULL);
	mtMIDI.SetVariableSize();
	mtMIDI.SetTemporalCompression(FALSE);
	// !!! anything else?

	SetOutputMediaType(&mtMIDI);
    }
    
    return hr;

memerror:
    hr = E_OUTOFMEMORY;
    goto error;

formaterror:
    hr = VFW_E_INVALID_FILE_FORMAT;
    goto error;

readerror:
    hr = VFW_E_INVALID_FILE_FORMAT;

error:
    return hr;
}


ULONG CMIDIParse::GetMaxSampleSize()
{
    DWORD dwSize = 2 * sizeof(MIDIHDR) + smfGetStateMaxSize() +
	MulDiv(1 /*lSamples*/ * MSPERSAMPLE, 31250 * 4, 1000);	// !!!

    // midi stream buffers can't be bigger than this....
    if (dwSize > 30000)
	dwSize = 30000;
    
    return dwSize;
}


// !!! rounding
// returns the sample number showing at time t
LONG
CMIDIParse::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * MILLISECONDS / MSPERSAMPLE) / UNITS);
    return s;
}

CRefTime
CMIDIParse::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, MSPERSAMPLE * UNITS, MILLISECONDS, MILLISECONDS-1 );
}


HRESULT
CMIDIParse::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != MEDIASUBTYPE_Midi)
        return E_INVALIDARG;

    return S_OK;
}


HRESULT CMIDIParse::FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pdwSamples)
{
    PBYTE pbuf;
    const DWORD lSamples = 1;

    DWORD dwSize = pSample->GetSize();
    
    HRESULT hr = pSample->GetPointer(&pbuf);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	pSample->Release();
	return E_OUTOFMEMORY;
    }

    // Seek to the spot we'll begin reading from, and get keyframe info to
    // write our keyframe. Since this disturbs reading the file contiguously,
    // we have our own file handle for this.

    TICKS tk = smfMillisecsToTicks(m_hsmfK, dwStart * MSPERSAMPLE);
    LPMIDIHDR lpmh = (LPMIDIHDR)pbuf;
    lpmh->lpData = (LPSTR)lpmh + sizeof(MIDIHDR);
    lpmh->dwBufferLength    = dwSize - sizeof(MIDIHDR);
    lpmh->dwBytesRecorded   = 0;
    lpmh->dwFlags           = 0;

    // the API smfSeek() starts looking from the beginning, and takes forever
    // if you are seeking way into the file.  We can't do that while streaming
    // playback, there is no time.  So if we are just being asked for the next
    // portion of MIDI after the last one we just gave, we will do a special
    // seek I wrote that remembers the keyframe last time and adds just the
    // new bits for this next section.

    SMFRESULT smfrc;
    
    if (m_dwLastSampleRead != dwStart - 1) {
        DbgLog((LOG_TRACE,4,TEXT("Doing a REAL seek from the beginning for keyframe info")));
        if ((smfrc = smfSeek(m_hsmfK, tk, lpmh)) != SMF_SUCCESS) {
	    return E_FAIL;
        }
    } else {
        DbgLog((LOG_TRACE,4,TEXT("Doing a small forward seek for keyframe info")));
        if ((smfrc = smfDannySeek(m_hsmfK, tk, lpmh)) != SMF_SUCCESS) {
	    return E_FAIL;
        }
    }

    lpmh->dwBufferLength = (lpmh->dwBytesRecorded + 3) & ~3;
    DbgLog((LOG_TRACE,3,TEXT("Key frame is %ld bytes"), lpmh->dwBytesRecorded));

    // Now prepare to read the actual data for these samples.
    // !!! I'll bet this blows up when dwSize > 64K even if data read < 64K
    // because we're already offset in the pointer!
    lpmh = (LPMIDIHDR)((LPBYTE)lpmh + sizeof(MIDIHDR) + lpmh->dwBufferLength);
    lpmh->lpData = (LPSTR)lpmh + sizeof(MIDIHDR);
    lpmh->dwBufferLength    = dwSize - (DWORD)((LPBYTE)lpmh - pbuf) - sizeof(MIDIHDR);
    lpmh->dwBytesRecorded   = 0;
    lpmh->dwFlags           = 0;

    // We are NOT reading contiguously, so we'll have to do a seek to get to
    // the right spot.
    if (m_dwLastSampleRead != dwStart - 1) {
        DbgLog((LOG_TRACE,1,TEXT("Discontiguous Read:  Seeking from %ld to %ld")
					, m_dwLastSampleRead, dwStart));
	tk = smfMillisecsToTicks(m_hsmf, dwStart * MSPERSAMPLE);
	if ((smfrc = smfSeek(m_hsmf, tk, lpmh)) != SMF_SUCCESS) {
	    return E_FAIL;
	}
    }

    // We are reading contiguously, simply continue where we left off, with
    // a new high limit

    tk = smfMillisecsToTicks(m_hsmf, (dwStart + lSamples) * MSPERSAMPLE);
    smfrc = smfReadEvents(m_hsmf, lpmh, 0, tk, FALSE);
    if (smfrc != SMF_SUCCESS && smfrc != SMF_END_OF_FILE)
	return E_FAIL;
    
    lpmh->dwBufferLength = (lpmh->dwBytesRecorded + 3) & ~3;
    DWORD dwReadSize = lpmh->dwBufferLength + sizeof(MIDIHDR) + (DWORD)((LPBYTE)lpmh - pbuf);
    DbgLog((LOG_TRACE,3,TEXT("Data is %ld bytes"), lpmh->dwBytesRecorded));

    // Looks like we're actually going to return success; update the last sample
    // we returned to them.
    m_dwLastSampleRead = dwStart;
    
    hr = pSample->SetActualDataLength(dwReadSize);
    ASSERT(SUCCEEDED(hr));

    // mark as a sync point if it should be....
    pSample->SetSyncPoint(TRUE);  // !!!
	
    *pdwSamples = 1;

    return S_OK;
}

HRESULT CMIDIParse::get_Copyright(BSTR FAR* pbstrCopyright)
{
    //
    // If the file has a Copyright meta-event, use that
    //
    HRESULT hr = VFW_E_NOT_FOUND;

    if( m_hsmf )
    {    
        SMFFILEINFO sfi;
        SMFRESULT f = smfGetFileInfo(m_hsmf, &sfi);
        if (f == SMF_SUCCESS) 
        {
            if( sfi.pbCopyright )
            {
                DWORD dwcch = strlen( (char *)sfi.pbCopyright );
                *pbstrCopyright = SysAllocStringLen( 0, dwcch + 1 );
                if(*pbstrCopyright)
                {
                    MultiByteToWideChar(CP_ACP, 0, (char *)sfi.pbCopyright, -1, *pbstrCopyright, dwcch + 1);
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }                    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\smfread.c ===
// !!!
// This version differs slightly from the code in MCISEQ to make the API
// compatible with AVIMIDI.  Look for !!!
// !!!

/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    read.c

    DESCRIPTION:
      Routines for reading Standard MIDI Files.

*********************************************************************/

// !!! #define STRICT
#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <memory.h>
#include "muldiv32.h" 
#include "smf.h"
#include "smfi.h"
#include "debug.h"

void * __stdcall memmoveInternal(void *, const void *, size_t);
#undef hmemcpy
#define hmemcpy memmoveInternal

UINT rbChanMsgLen[] =
{ 
    0,                      // 0x   not a status byte
    0,                      // 1x   not a status byte
    0,                      // 2x   not a status byte
    0,                      // 3x   not a status byte
    0,                      // 4x   not a status byte
    0,                      // 5x   not a status byte
    0,                      // 6x   not a status byte
    0,                      // 7x   not a status byte
    3,                      // 8x   Note off
    3,                      // 9x   Note on
    3,                      // Ax   Poly pressure
    3,                      // Bx   Control change
    2,                      // Cx   Program change
    2,                      // Dx   Chan pressure
    3,                      // Ex   Pitch bend change
    0,                      // Fx   SysEx (see below)                  
} ;

PRIVATE SMFRESULT FNLOCAL smfAddTempoMapEntry(
    PSMF                    psmf,                                       
    EVENT BSTACK            *pevent);

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfBuildFileIndex | Preliminary parsing of a MIDI file.
 *
 * @parm PSMF BSTACK * | ppsmf | Pointer to a returned SMF structure if the
 *  file is successfully parsed.
 *
 * @comm
 *  This function validates the format of and existing MIDI or RMI file
 *  and builds the handle structure which will refer to it for the
 *  lifetime of the instance.
 *  
 *  The file header information will be read and verified, and
 *  <f smfBuildTrackIndices> will be called on every existing track
 *  to build keyframes and validate the track format.
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_NO_MEMORY | Out of memory to build key frames.
 *  @flag SMF_INVALID_FILE | A disk or parse error occured on the file.
 * 
 * @xref <f smfTrackIndices>
 *****************************************************************************/

SMFRESULT FNLOCAL smfBuildFileIndex(
    PSMF BSTACK         *ppsmf)
{
    SMFRESULT           smfrc;
    CHUNKHDR UNALIGNED FAR *      pch;
    FILEHDR UNALIGNED FAR *       pfh;
    DWORD               i;
    PSMF                psmf,
                        psmfTemp;
    PTRACK              ptrk;
    WORD                wMemory;
    DWORD               dwLeft;
    HPBYTE              hpbImage;
    
    DWORD               idxTrack;
    EVENT               event;
    DWORD               dwLength;
    WORD                wChanInUse;
    WORD                wFirstNote;
    const WORD          WORD_MAX = ~0;
    const DWORD         MAX_NUMBER_OF_TRACKS = (WORD_MAX - sizeof(SMF)) / sizeof(TRACK);

    assert(ppsmf != NULL);

    psmf = *ppsmf;

    assert(psmf != NULL);

    // MIDI data image is already in hpbImage (already extracted from
    // RIFF header if necessary).
    //

    // Validate MIDI header
    //
    dwLeft   = psmf->cbImage;
    hpbImage = psmf->hpbImage;
    
    if (dwLeft < sizeof(CHUNKHDR))
        return SMF_INVALID_FILE;

    pch = (CHUNKHDR UNALIGNED FAR *)hpbImage;

    dwLeft   -= sizeof(CHUNKHDR);
    hpbImage += sizeof(CHUNKHDR);
    
    if (pch->fourccType != FOURCC_MThd)
        return SMF_INVALID_FILE;

    dwLength = DWORDSWAP(pch->dwLength);
    if (dwLength < sizeof(FILEHDR) || dwLength > dwLeft)
        return SMF_INVALID_FILE;

    pfh = (FILEHDR UNALIGNED FAR *)hpbImage;

    dwLeft   -= dwLength;
    hpbImage += dwLength;
    
    psmf->dwFormat       = (DWORD)(WORDSWAP(pfh->wFormat));
    DPF(1, "*This MIDI file is format %ld", psmf->dwFormat);	// !!!
    psmf->dwTracks       = (DWORD)(WORDSWAP(pfh->wTracks));
    DPF(1, "*This MIDI file has %ld tracks", psmf->dwTracks);	// !!!
    psmf->dwTimeDivision = (DWORD)(WORDSWAP(pfh->wDivision));

    //
    // We've successfully parsed the header. Now try to build the track
    // index.
    // 
    // We only check out the track header chunk here; the track will be
    // preparsed after we do a quick integretiy check.
    //

    if( psmf->dwTracks > MAX_NUMBER_OF_TRACKS ) {
        return SMF_INVALID_FILE;
    }

    wMemory = sizeof(SMF) + (WORD)(psmf->dwTracks*sizeof(TRACK)); 
    psmfTemp = (PSMF)LocalReAlloc((HLOCAL)psmf, wMemory, LMEM_MOVEABLE|LMEM_ZEROINIT);

    if (NULL == psmfTemp)
    {
        DPF(1, "No memory for extended psmf");
        return SMF_NO_MEMORY;
    }

    psmf = *ppsmf = psmfTemp;
    ptrk = psmf->rTracks;
    
    for (i=0; i<psmf->dwTracks; i++)
    {
        if (dwLeft < sizeof(CHUNKHDR))
            return SMF_INVALID_FILE;

        pch = (CHUNKHDR UNALIGNED FAR *)hpbImage;

        dwLeft   -= sizeof(CHUNKHDR);
        hpbImage += sizeof(CHUNKHDR);

        if (pch->fourccType != FOURCC_MTrk)
            return SMF_INVALID_FILE;
        
        ptrk->idxTrack      = (DWORD)(hpbImage - psmf->hpbImage);
        ptrk->smti.cbLength = DWORDSWAP(pch->dwLength);

        if (ptrk->smti.cbLength > dwLeft)
        {
            DPF(1, "Track longer than file!");
            return SMF_INVALID_FILE;
        }

        dwLeft   -= ptrk->smti.cbLength;
        hpbImage += ptrk->smti.cbLength;

        ptrk++;
    }

    // File looks OK. Now preparse, doing the following:
    // (1) Build tempo map so we can convert to/from ticks quickly
    // (2) Determine actual tick length of file
    // (3) Validate all events in all tracks
    // 
    psmf->tkPosition = 0;
    psmf->tkDiscardedEvents = 0;
    psmf->fdwSMF &= ~(SMF_F_EOF|SMF_F_MSMIDI);
    
    for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
    {
        ptrk->psmf              = psmf;
        ptrk->tkPosition        = 0;
        ptrk->cbLeft            = ptrk->smti.cbLength;
        ptrk->hpbImage          = psmf->hpbImage + ptrk->idxTrack;
        ptrk->bRunningStatus    = 0;
        ptrk->fdwTrack          = 0;
    }

//    for (idxTrack=0,ptrk=psmf->rTracks; idxTrack < psmf->dwTracks; idxTrack++,ptrk++)
//    {
//        DPF(1, "Track %lu ptrk %04X ptrk->hpbImage %08lX", (DWORD)idxTrack, (WORD)ptrk, (DWORD)ptrk->hpbImage);
//    }

    psmf->awPatchCache[0] = 0xFDFF; // assume default patch on all but channel 10
    wFirstNote = wChanInUse = 0;
    while (SMF_SUCCESS == (smfrc = smfGetNextEvent(psmf, (EVENT BSTACK *)&event, MAX_TICKS)))
    {
        // track whether a channel is used, and whether we have seen
        // the first note-on event yet
        //
        if (0xF0 != (EVENT_TYPE(event)))
        {
            WORD wChan = (1 << (EVENT_TYPE(event) & 0x0F));
            wChanInUse |= wChan;
            if ((EVENT_TYPE(event) & 0xF0) == 0x80) // if note on
                wFirstNote |= wChan;
        }
            
        if (MIDI_META == EVENT_TYPE(event))
        {
            switch(EVENT_META_TYPE(event))
            {
                case MIDI_META_TEMPO:
                    if (SMF_SUCCESS != (smfrc = smfAddTempoMapEntry(psmf, (EVENT BSTACK *)&event)))
                    {
                        return smfrc;
                    }
                    break;

                case MIDI_META_SEQSPECIFIC:
                    if (3 == event.cbParm &&
                        event.hpbParm[0] == 0x00 &&
                        event.hpbParm[1] == 0x00 &&
                        event.hpbParm[2] == 0x41)
                    {
                        DPF(1, "This file is MSMIDI");
                        psmf->fdwSMF |= SMF_F_MSMIDI;
                    }
                    break;

                case MIDI_META_TRACKNAME:
                    if (psmf->pbTrackName)
                        LocalFree((HLOCAL)psmf->pbTrackName);

                    psmf->pbTrackName = (PBYTE)LocalAlloc(LPTR, 1+(UINT)event.cbParm);
                    if (NULL != psmf->pbTrackName)
                    {
                        hmemcpy((HPBYTE)psmf->pbTrackName, event.hpbParm, (UINT)event.cbParm);
                        psmf->pbTrackName[(UINT)event.cbParm] = '\0';
                    }
                    break;
                    
                case MIDI_META_COPYRIGHT:
                    if (psmf->pbCopyright)
                        LocalFree((HLOCAL)psmf->pbCopyright);

                    psmf->pbCopyright = (PBYTE)LocalAlloc(LPTR, 1+(UINT)event.cbParm);
                    if (NULL != psmf->pbCopyright)
                    {
                        hmemcpy((HPBYTE)psmf->pbCopyright, event.hpbParm, (UINT)event.cbParm);
                        psmf->pbCopyright[(UINT)event.cbParm] = '\0';
                    }
                    break;
            }
        }
        else if (MIDI_PROGRAMCHANGE == (EVENT_TYPE(event)&0xF0))
        {
            WORD wChan = (1 << (EVENT_TYPE(event) & 0x0F));
            //
            // if this channel has a patch change, and it is
            // before the first keydown event on the channel
            // clear the 'default' patch and set the bit
            // for the requested patch
            //
            if (!(wFirstNote & wChan))
               psmf->awPatchCache[0] &= ~wChan;
            psmf->awPatchCache[EVENT_CH_B1(event)] |= wChan;
        }
        else if (EV_DRUM_BASE == EVENT_TYPE(event) ||
                 EV_DRUM_EXT  == EVENT_TYPE(event))
        {
            psmf->awKeyCache[EVENT_CH_B1(event)]
                |= (1 << (EVENT_TYPE(event)&0x0F));
        }
    }

    psmf->wChanInUse = wChanInUse;
    
    if (SMF_END_OF_FILE == smfrc || SMF_SUCCESS == smfrc)
    {
	// !!! Will format 2 work?
        // NOTE: This is wrong for format 2, where the tracks are end-to-end
        //
        psmf->tkLength = psmf->tkPosition;
        smfrc = SMF_SUCCESS;
    }

    // Do something reasonable if we don't have a tempo entry in the file
    //
    if (SMF_SUCCESS == smfrc && 0 == psmf->cTempoMap)
    {
        if (NULL == (psmf->hTempoMap = LocalAlloc(LHND, sizeof(TEMPOMAPENTRY))))
            return SMF_NO_MEMORY;

        psmf->pTempoMap = (PTEMPOMAPENTRY)LocalLock(psmf->hTempoMap);

        psmf->cTempoMap = 1;
        psmf->cTempoMapAlloc = 1;

        psmf->pTempoMap->tkTempo = 0;
        psmf->pTempoMap->msBase = 0;
        psmf->pTempoMap->dwTempo = MIDI_DEFAULT_TEMPO;
    }
        
    return smfrc;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfAddTempoMapEntry | Adds a tempo map entry.
 *
 * @parm PSMF | psmf | Pointer to the owning SMF structure.
 *
 * @parm PEVENT BSTACK * | pevent | Pointer to the tempo event.
 *
 * @comm
 *  Add the event to the map.
 *  
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_NO_MEMORY | Out of memory in the local heap for the map.
 * 
 * @xref <f smfBuildTrackIndex>
 *****************************************************************************/
PRIVATE SMFRESULT FNLOCAL smfAddTempoMapEntry(
    PSMF                    psmf,                                       
    EVENT BSTACK            *pevent)
{
    BOOL                    fFirst;
    HLOCAL                  hlocal;
    PTEMPOMAPENTRY          pTempo;
    DWORD                   dwTempo;
    
    if (3 != pevent->cbParm)
    {
        return SMF_INVALID_FILE;
    }

    dwTempo = (((DWORD)pevent->hpbParm[0])<<16)|
              (((DWORD)pevent->hpbParm[1])<<8)|
              ((DWORD)pevent->hpbParm[2]);

    // Some MIDI files have tempo changes strewn through them at regular
    // intervals even tho the tempo never changes -- or they have the same
    // tempo change across all tracks to the same value. In either case, most
    // of the changes are redundant -- don't waste memory storing them.
    //
    if (psmf->cTempoMap)
        if (psmf->pTempoMap[psmf->cTempoMap-1].dwTempo == dwTempo)
            return SMF_SUCCESS;

    fFirst = FALSE;
    if (psmf->cTempoMap == psmf->cTempoMapAlloc)
    {
        if (NULL != psmf->hTempoMap)
        {
            LocalUnlock(psmf->hTempoMap);
        }

        psmf->cTempoMapAlloc += C_TEMPO_MAP_CHK;
        fFirst = FALSE;
        if (0 == psmf->cTempoMap)
        {
            hlocal = LocalAlloc(LHND, (UINT)(psmf->cTempoMapAlloc*sizeof(TEMPOMAPENTRY)));
            fFirst = TRUE;
        }
        else
        {
            hlocal = LocalReAlloc(psmf->hTempoMap, (UINT)(psmf->cTempoMapAlloc*sizeof(TEMPOMAPENTRY)), LHND);
        }

        if (NULL == hlocal)
        {
            return SMF_NO_MEMORY;
        }

        psmf->pTempoMap = (PTEMPOMAPENTRY)LocalLock(psmf->hTempoMap = hlocal);
    }

    if (fFirst && psmf->tkPosition != 0)
    {
        // Inserting first event and the absolute time is zero.
        // This is not good since we have no idea what the tempo
        // should be; assume the standard 500,000 uSec/QN (120 BPM
        // at 4/4 time).
        //

        pTempo = &psmf->pTempoMap[psmf->cTempoMap++];

        pTempo->tkTempo = 0;
        pTempo->msBase  = 0;
        pTempo->dwTempo = MIDI_DEFAULT_TEMPO;

        fFirst = FALSE;
    }

    pTempo = &psmf->pTempoMap[psmf->cTempoMap++];

    pTempo->tkTempo = psmf->tkPosition;
    if (fFirst)
    {
        pTempo->msBase = 0;
    }
    else
    {
        // NOTE: Better not be here unless we're q/n format!
        //
        pTempo->msBase = (pTempo-1)->msBase +
                         muldiv32(pTempo->tkTempo-((pTempo-1)->tkTempo),
                                  (pTempo-1)->dwTempo,
                                  1000L*psmf->dwTimeDivision);
    }
    
    pTempo->dwTempo = dwTempo;

    return SMF_SUCCESS;
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func SMFRESULT | smfGetNextEvent | Read the next event from the given
 *  file.
 *
 * @parm PSMF | psmf | File to read the event from.
 *
 * @parm SPEVENT | pevent | Pointer to an event structure which will receive
 *  basic information about the event.
 *
 * @parm TICKS | tkMax | Tick destination. An attempt to read past this
 *  position in the file will fail.
 *
 * @comm
 *  This is the lowest level of parsing for a raw MIDI stream. The basic
 *  information about one event in the file will be returned in <p pevent>.
 *
 *  Merging data from all tracks into one stream is performed here.
 * 
 *  <p pevent!tkDelta> will contain the tick delta for the event.
 *
 *  <p pevent!abEvent> will contain a description of the event.
 *   <p pevent!abEvent[0]> will contain
 *    F0 or F7 for a System Exclusive message.
 *    FF for a MIDI file meta event.
 *    The status byte of any other MIDI message. (Running status will
 *    be tracked and expanded).
 *
 *  <p pevent!cbParm> will contain the number of bytes of paramter data
 *   which is still in the file behind the event header already read.
 *   This data may be read with <f smfGetTrackEventData>. Any unread
 *   data will be skipped on the next call to <f smfGetNextTrackEvent>.
 *
 *  Channel messages (0x8? - 0xE?) will always be returned fully in
 *   <p pevent!abEvent>.
 *
 *  Meta events will contain the meta type in <p pevent!abEvent[1]>.
 *
 *  System exclusive events will contain only an 0xF0 or 0xF7 in
 *   <p pevent!abEvent[0]>.
 *
 *  The following fields in <p ptrk> are used to maintain state and must
 *  be updated if a seek-in-track is performed:
 *
 *  <f bRunningStatus> contains the last running status message or 0 if
 *   there is no valid running status.
 *
 *  <f hpbImage> is a pointer into the file image of the first byte of
 *   the event to follow the event just read.
 *
 *  <f dwLeft> contains the number of bytes from hpbImage to the end
 *   of the track.
 *
 *
 * Get the next due event from all (in-use?) tracks
 *
 * For all tracks
 *  If not end-of-track
 *   decode event delta time without advancing through buffer
 *   event_absolute_time = track_tick_time + track_event_delta_time
 *   relative_time = event_absolute_time - last_stream_time
 *   if relative_time is lowest so far
 *    save this track as the next to pull from, along with times
 *
 * If we found a track with a due event
 *  Advance track pointer past event, saving ptr to parm data if needed
 *  track_tick_time += track_event_delta_time
 *  last_stream_time = track_tick_time
 * Else
 *  Mark and return end_of_file
 *
 * @rdesc Contains the result of the operation.
 *  @flag SMF_SUCCESS | The events were successfully read.
 *  @flag SMF_END_OF_FILE | There are no more events to read in this track.
 *  @flag SMF_REACHED_TKMAX | No event was read because <p tkMax> was reached.
 *  @flag SMF_INVALID_FILE | A disk or parse error occured on the file.
 * 
 * @xref <f smfGetTrackEventData>
 *****************************************************************************/

SMFRESULT FNLOCAL smfGetNextEvent(
    PSMF                psmf,
    EVENT BSTACK *      pevent,
    TICKS               tkMax)
{
    PTRACK              ptrk;
    PTRACK              ptrkFound;
    DWORD               idxTrack;
    TICKS               tkEventDelta;
    TICKS               tkRelTime;
    TICKS               tkMinRelTime;
    BYTE                bEvent;
    DWORD               dwGotTotal;
    DWORD               dwGot;
    DWORD               cbEvent;
    WORD                wChannelMask;

    assert(psmf != NULL);
    assert(pevent != NULL);

    if (psmf->fdwSMF & SMF_F_EOF)
    {
        return SMF_END_OF_FILE;
    }

    pevent->tkDelta = 0;

    for(;;)
    {
        ptrkFound       = NULL;
        tkMinRelTime    = MAX_TICKS;

        for (ptrk = psmf->rTracks, idxTrack = psmf->dwTracks; idxTrack--; ptrk++)
        {
            if (ptrk->fdwTrack & SMF_TF_EOT)
                continue;

            //        DPF(1, "ptrk %04X ptrk->hpbImage %08lX", (WORD)ptrk, (DWORD)ptrk->hpbImage);

            if (!smfGetVDword(ptrk->hpbImage, ptrk->cbLeft, (DWORD BSTACK *)&tkEventDelta))
            {
                DPF(1, "Hit end of track w/o end marker!");
                return SMF_INVALID_FILE;
            }

            tkRelTime = ptrk->tkPosition + tkEventDelta - psmf->tkPosition;

            if (tkRelTime < tkMinRelTime)
            {
                tkMinRelTime = tkRelTime;
                ptrkFound = ptrk;
            }
        }

        if (!ptrkFound)
        {
            DPF(2, "END_OF_FILE!");

	    // !!! poor API!!! This prevents Read(100), Read(200) from
	    // working, because the Read(200) will fail just because the
	    // Read(100) succeeded and says that the EOF is reached!
            // pSmf->fdwSMF |= SMF_F_EOF;
            return SMF_END_OF_FILE;
        }

        ptrk = ptrkFound;

        if (psmf->tkPosition + tkMinRelTime > tkMax)
        {
            return SMF_REACHED_TKMAX;
        }


        ptrk->hpbImage += (dwGot = smfGetVDword(ptrk->hpbImage, ptrk->cbLeft, (DWORD BSTACK *)&tkEventDelta));
        ptrk->cbLeft   -= dwGot;

        // We MUST have at least three bytes here (cause we haven't hit
        // the end-of-track meta yet, which is three bytes long). Checking
        // against three means we don't have to check how much is left
        // in the track again for any short event, which is most cases.
        //
        if (ptrk->cbLeft < 3)
        {
            return SMF_INVALID_FILE;
        }

        ptrk->tkPosition += tkEventDelta;
        pevent->tkDelta += ptrk->tkPosition - psmf->tkPosition;

        bEvent = *ptrk->hpbImage++;

        if (MIDI_MSG > bEvent)
        {
            if (0 == ptrk->bRunningStatus)
            {
                DPF(1, "Need running status; it's zero");
                return SMF_INVALID_FILE;
            }

            dwGotTotal = 1;
            pevent->abEvent[0] = ptrk->bRunningStatus;
            pevent->abEvent[1] = bEvent;
            if (3 == rbChanMsgLen[(ptrk->bRunningStatus >> 4) & 0x0F])
            {
                pevent->abEvent[2] = *ptrk->hpbImage++;
                dwGotTotal++;
            }
        }
        else if (MIDI_SYSEX > bEvent)
        {
            ptrk->bRunningStatus = bEvent;
            
            dwGotTotal = 2;
            pevent->abEvent[0] = bEvent;
            pevent->abEvent[1] = *ptrk->hpbImage++;
            if (3 == rbChanMsgLen[(bEvent >> 4) & 0x0F])
            {
                pevent->abEvent[2] = *ptrk->hpbImage++;
                dwGotTotal++;
            }
        }
        else
        {
            // Even though the SMF spec says that meta and SysEx clear
            // running status, there are files out there that make the
            // assumption that you can span running status across these
            // events (Knowledge Adventure's Aviation Adventure). So we
            // do NOT clear running status here
            //
            if (MIDI_META == bEvent)
            {
                pevent->abEvent[0] = MIDI_META;
                if (MIDI_META_EOT == (pevent->abEvent[1] = *ptrk->hpbImage++))
                {
                    ptrk->fdwTrack |= SMF_TF_EOT;
                }

                dwGotTotal = 2;
            }
            else if (MIDI_SYSEX == bEvent || MIDI_SYSEXEND == bEvent)
            {
                pevent->abEvent[0] = bEvent;
                dwGotTotal = 1;
            }
            else
            {
                return SMF_INVALID_FILE;
            }

            if (0 == (dwGot = smfGetVDword(ptrk->hpbImage, ptrk->cbLeft - 2, (DWORD BSTACK *)&cbEvent)))
            {
                return SMF_INVALID_FILE;
            }

            ptrk->hpbImage  += dwGot;
            dwGotTotal      += dwGot;

            if (dwGotTotal + cbEvent > ptrk->cbLeft)
            {
                return SMF_INVALID_FILE;
            }

            pevent->cbParm  = cbEvent;
            pevent->hpbParm = ptrk->hpbImage;

            ptrk->hpbImage += cbEvent;
            dwGotTotal     += cbEvent;
        }

        // DON'T update total file time based including end-of-track
        // deltas -- these are sometimes way off
        //
        if (!(ptrk->fdwTrack & SMF_TF_EOT))
            psmf->tkPosition = ptrk->tkPosition;
        
        assert(ptrk->cbLeft >= dwGotTotal);

        ptrk->cbLeft -= dwGotTotal;

        if (MIDI_SYSEX > pevent->abEvent[0])
        {
            wChannelMask = 1 << (pevent->abEvent[0] & 0x0F);
            if (!(wChannelMask & psmf->wChannelMask))
            {
//                DPF(3, "Skip event mask=%04X", wChannelMask);
                continue;
            }
        }

        return SMF_SUCCESS;
    }
}

/******************************************************************************
 *
 * @doc SMF INTERNAL
 *
 * @func BOOL | smfGetVDword | Reads a variable length DWORD from
 *  the given file.
 *
 * @parm HPBYTE | hpbImage | Pointer to the first byte of the VDWORD.
 *
 * @parm DWORD | dwLeft | Bytes left in image
 *
 *
 * @parm DWORD BSTACK * | pdw | Pointer to a DWORD to store the result in.
 *  track.
 *
 * @comm
 *  A variable length DWORD stored in a MIDI file contains one or more
 *  bytes. Each byte except the last has the high bit set; only the
 *  low 7 bits are significant.
 *  
 * @rdesc # of bytes consumed on success; else 0.
 * 
 *****************************************************************************/

DWORD FNLOCAL smfGetVDword(
    HPBYTE              hpbImage,                                
    DWORD               dwLeft,                               
    DWORD BSTACK *      pdw)
{
    BYTE                b;
    DWORD               dwUsed  = 0;

    assert(hpbImage != NULL);
    assert(pdw != NULL);
    
    *pdw = 0;

    do
    {
        if (!dwLeft)
        {
            return 0;
        }

        b = *hpbImage++;
        dwLeft--;
        dwUsed++;
        
        *pdw = (*pdw << 7) | (b & 0x7F);
    } while (b&0x80);

    return dwUsed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\midi\midirdr\smfi.h ===
/**********************************************************************

    Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.

    smfi.h

    DESCRIPTION:
      Private include file for Standard MIDI File access routines.

*********************************************************************/

#ifndef _SMFI_
#define _SMFI_

#define CH_DRUM_BASE        15
#define CH_DRUM_EXT         9

#define EV_DRUM_BASE        (MIDI_NOTEON | CH_DRUM_BASE)
#define EV_DRUM_EXT         (MIDI_NOTEON | CH_DRUM_EXT)

// 
// Handle structure for HSMF
// 

#define SMF_TF_EOT          0x00000001L
#define SMF_TF_INVALID      0x00000002L

typedef struct tag_tempomapentry
{
    TICKS           tkTempo;            // Where this change takes effect
    DWORD           msBase;             // Milliseconds already passed at this point
    DWORD           dwTempo;            // New tempo value in microseconds per quarter note
}   TEMPOMAPENTRY,
    *PTEMPOMAPENTRY;

typedef struct tag_smf *PSMF;

typedef struct tag_keyframe
{
    //
    // Meta events. All FF's indicates never seen.
    //
    BYTE        rbTempo[3];

    //
    // MIDI channel messages. FF indicates never seen.
    //
    BYTE        rbProgram[16];
    BYTE        rbControl[16*120];
}   KEYFRAME,
    FAR *PKEYFRAME;

#define KF_EMPTY ((BYTE)0xFF)

typedef struct tag_track
{
    PSMF            psmf;

    DWORD           idxTrack;           // Start of track rel to psmf->hpbImage
    
    TICKS           tkPosition;         // Tick position of last event played
    DWORD           cbLeft;             // Bytes left in track past hpbImage
    HPBYTE          hpbImage;           // Pointer to current position in track
    
    DWORD           fdwTrack;           // Flags about current state

    struct
    {
        TICKS       tkLength;
        DWORD       cbLength;
    }
    smti;                               // Returnable track information
    BYTE            bRunningStatus;     // Running status for this track

}   TRACK,
    *PTRACK;

#define SMF_F_EOF               0x00000001L
#define SMF_F_MSMIDI            0x00000002L
#define SMF_F_INSERTSYSEX       0x00000004L
#define SMF_F_REMAPDRUM         0x00000008L

#define C_TEMPO_MAP_CHK     16
typedef struct tag_smf
{
    HPBYTE          hpbImage;
    DWORD           cbImage;

    TICKS           tkPosition;
    TICKS           tkLength;
    TICKS           tkDiscardedEvents;
    DWORD           dwFormat;
    DWORD           dwTracks;
    DWORD           dwTimeDivision;
    DWORD           fdwSMF;
    WORD            wChanInUse;
    WORD            wChannelMask;

    DWORD           cTempoMap;
    DWORD           cTempoMapAlloc;
    HLOCAL          hTempoMap;
    PTEMPOMAPENTRY  pTempoMap;

    DWORD           dwPendingUserEvent;
    DWORD           cbPendingUserEvent;
    HPBYTE          hpbPendingUserEvent;

    PBYTE           pbTrackName;
    PBYTE           pbCopyright;

    WORD            awPatchCache[128];
    WORD            awKeyCache[128];
    
    // !!! new
    KEYFRAME	    kf;

    TRACK           rTracks[];
}   SMF;

typedef struct tagEVENT
{
    TICKS           tkDelta;            // Delta tick count for event
    DWORD           cbParm;             // Length of parameters if any
    HPBYTE          hpbParm;            // -> into image at paramters
    BYTE            abEvent[3];         // abEvent[0] == F0 or F7 for SysEx
                                        //            == FF for meta
                                        // Otherwise channel message (running
                                        // status expanded)
}   EVENT,
    BSTACK *SPEVENT;

#define EVENT_TYPE(event)       ((event).abEvent[0])
#define EVENT_CH_B1(event)      ((event).abEvent[1])
#define EVENT_CH_B2(event)      ((event).abEvent[2])

#define EVENT_META_TYPE(event)  ((event).abEvent[1])

//----------------------------------------------------------------------------
//
// Globals
//
extern UINT rbChanMsgLen[];


//----------------------------------------------------------------------------
// 
// Internal prototypes
//
// read.c
extern SMFRESULT FNLOCAL smfBuildFileIndex(
    PSMF BSTACK *       ppsmf);

extern DWORD FNLOCAL smfGetVDword(
    HPBYTE              hpbImage,
    DWORD               dwLeft,                                
    DWORD BSTACK *      pdw);

extern SMFRESULT FNLOCAL smfGetNextEvent(
    PSMF                psmf,
    SPEVENT             pevent,
    TICKS               tkMax);

//----------------------------------------------------------------------------
// 
// Stuff from MIDI specs
//

//
// Useful macros when dealing with hi-lo format integers
//
#define DWORDSWAP(dw) \
    ((((dw)>>24)&0x000000FFL)|\
    (((dw)>>8)&0x0000FF00L)|\
    (((dw)<<8)&0x00FF0000L)|\
    (((dw)<<24)&0xFF000000L))

#define WORDSWAP(w) \
    ((((w)>>8)&0x00FF)|\
    (((w)<<8)&0xFF00))

#define FOURCC_RMID     mmioFOURCC('R','M','I','D')
#define FOURCC_data     mmioFOURCC('d','a','t','a')
#define FOURCC_MThd     mmioFOURCC('M','T','h','d')
#define FOURCC_MTrk     mmioFOURCC('M','T','r','k')

typedef struct tag_chunkhdr
{
    FOURCC  fourccType;
    DWORD   dwLength;
}   CHUNKHDR,
    *PCHUNKHDR;

typedef struct tag_filehdr
{
    WORD    wFormat;
    WORD    wTracks;
    WORD    wDivision;
}   FILEHDR,
    *PFILEHDR;

// NOTE: This is arbitrary and only used if there is a tempo map but no
// entry at tick 0.
//
#define MIDI_DEFAULT_TEMPO      (500000L)

#define MIDI_MSG                ((BYTE)0x80)
#define MIDI_NOTEOFF            ((BYTE)0x80)
#define MIDI_NOTEON             ((BYTE)0x90)
#define MIDI_POLYPRESSURE       ((BYTE)0xA0)
#define MIDI_CONTROLCHANGE      ((BYTE)0xB0)
#define MIDI_PROGRAMCHANGE      ((BYTE)0xC0)
#define MIDI_CHANPRESSURE       ((BYTE)0xD0)
#define MIDI_PITCHBEND          ((BYTE)0xE0)
#define MIDI_META               ((BYTE)0xFF)
#define MIDI_SYSEX              ((BYTE)0xF0)
#define MIDI_SYSEXEND           ((BYTE)0xF7)

#define MIDI_META_COPYRIGHT     ((BYTE)0x02)
#define MIDI_META_TRACKNAME     ((BYTE)0x03)
#define MIDI_META_EOT           ((BYTE)0x2F)
#define MIDI_META_TEMPO         ((BYTE)0x51)
#define MIDI_META_TIMESIG       ((BYTE)0x58)
#define MIDI_META_KEYSIG        ((BYTE)0x59)
#define MIDI_META_SEQSPECIFIC   ((BYTE)0x7F)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\acmp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "acmp.h"
#include <vfw.h>
#include "util.h"

static const TCHAR g_szDriverClsid[] = TEXT("CLSID");
const TCHAR g_szAcmDriverIndex[] = TEXT("AcmId");
static const WCHAR g_wszDriverIndex[] = L"AcmId";

CAcmClassManager::CAcmClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_lDev(NAME("acm dev list"), 10)
{
    m_hmod = LoadLibrary(TEXT("msacm32.dll"));
    if(m_hmod)
    {
        m_pacmFormatTagEnum = (PacmFormatTagEnum)GetProcAddress(m_hmod,
#ifdef UNICODE
                                             "acmFormatTagEnumW"
#else
                                             "acmFormatTagEnumA"
#endif
                                             );
    }
}

CAcmClassManager::~CAcmClassManager()
{
    LegacyAcm *plamCurrent;
    for(; plamCurrent = m_lDev.RemoveHead(); )
        delete plamCurrent;

    if(m_hmod != 0)
        FreeLibrary(m_hmod);
}

HRESULT CAcmClassManager::ReadLegacyDevNames()
{
    LegacyAcm *plamCurrent;
    for(; plamCurrent = m_lDev.RemoveHead(); )
        delete plamCurrent;

    
    ACMFORMATTAGDETAILS aftd;

    ZeroMemory(&aftd, sizeof(aftd));

    /* Enumerate the format tags */
    aftd.cbStruct = sizeof(aftd);

    if(m_pacmFormatTagEnum)
    {

        MMRESULT mmr = m_pacmFormatTagEnum(
            NULL,
            &aftd,
            FormatTagsCallbackSimple,
            (DWORD_PTR)this,
            0L);
    
        if(MMSYSERR_NOERROR != mmr)
        {
        }
    }
    
    m_cNotMatched = m_lDev.GetCount();
    return S_OK;
}


BOOL CALLBACK CAcmClassManager::FormatTagsCallbackSimple
(
    HACMDRIVERID            hadid,
    LPACMFORMATTAGDETAILS   paftd,
    DWORD_PTR               dwInstance,
    DWORD                   fdwSupport
)
{
    MMRESULT            mmr;
    int                 n;
    LPWAVEFORMATEX	pwfxSave;
    DWORD		cbwfxSave;
    BOOL                f;
    DWORD               dw;

    //
    //
    //
    CAcmClassManager *pThis = (CAcmClassManager *)dwInstance;

    LegacyAcm *plamCurrent = new LegacyAcm;
    if(plamCurrent)
    {
        lstrcpy(plamCurrent->szLongName, paftd->szFormatTag);
        plamCurrent->dwFormatTag = paftd->dwFormatTag;
        pThis->m_lDev.AddTail(plamCurrent);

        DbgLog((LOG_TRACE, 10, TEXT("CAcmClassManager: adding %d %s"),
                paftd->dwFormatTag, paftd->szFormatTag));

        return TRUE;
    }

    return (FALSE);
} // FormatTagsCallbackSimple()

BOOL CAcmClassManager::MatchString(const TCHAR *szDevName)
{
    
    for(POSITION pos = m_lDev.GetHeadPositionI();
        pos;
        pos = m_lDev.Next(pos))
    {
        LegacyAcm *plamCurrent = m_lDev.Get(pos);
        if(lstrcmp(plamCurrent->szLongName, szDevName) == 0)
        {
            DbgLog((LOG_TRACE, 5, TEXT("CAcmClassManager: matched %s"),
                    szDevName));
            return TRUE;
        }
    }
        
    return FALSE;
}

HRESULT CAcmClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    USES_CONVERSION;
    HRESULT hr = S_OK;

    ResetClassManagerKey(CLSID_AudioCompressorCategory);
    ReadLegacyDevNames();
    
    for(POSITION pos = m_lDev.GetHeadPositionI();
        pos;
        pos = m_lDev.Next(pos))
    {
        LegacyAcm *plamCurrent = m_lDev.Get(pos);
        const WCHAR *wszFriendlyName = T2CW(plamCurrent->szLongName);
        TCHAR szUniq[ACMFORMATTAGDETAILS_FORMATTAG_CHARS + 100];
        wsprintf(szUniq, TEXT("%d%s"), plamCurrent->dwFormatTag, plamCurrent->szLongName);

        // we could probably specify that the input pins accept PCM
        // only, but a wildcard should be fine.
        static const AMOVIESETUP_MEDIATYPE sudInPinTypes =
        {
            &MEDIATYPE_Audio,   // clsMajorType
            &MEDIASUBTYPE_NULL  // clsMinorType
        }; 

        const FOURCCMap fccSubtype(plamCurrent->dwFormatTag);
        const AMOVIESETUP_MEDIATYPE sudOutPinTypes =
        {
            &MEDIATYPE_Audio,   // clsMajorType
            &fccSubtype         // clsMinorType
        }; 

        const AMOVIESETUP_PIN sudpPins [] =
        {
            { L"Input"             // strName
              , FALSE              // bRendered
              , FALSE              // bOutput
              , FALSE              // bZero
              , FALSE              // bMany
              , &CLSID_NULL        // clsConnectsToFilter
              , NULL               // strConnectsToPin
              , 1                  // nTypes
              , &sudInPinTypes     // lpTypes
            },
            { L"Output"            // strName
              , FALSE              // bRendered
              , TRUE               // bOutput
              , FALSE              // bZero
              , FALSE              // bMany
              , &CLSID_NULL        // clsConnectsToFilter
              , NULL               // strConnectsToPin
              , 1                  // nTypes
              , &sudOutPinTypes    // lpTypes
            }
        };

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = NUMELMS(sudpPins);
        rf2.rgPins = sudpPins;
            
        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_ACMWrapper,
            wszFriendlyName,
            &pMoniker,
            &CLSID_AudioCompressorCategory,
            T2CW(szUniq),
            &rf2);
        
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = plamCurrent->dwFormatTag;
                hr = pPropBag->Write(g_wszDriverIndex, &var);

                pPropBag->Release();
            }
            pMoniker->Release();
        }              
    }

            

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\acmp.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

#include <mmreg.h>
#include <msacm.h>

class CAcmClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CAcmClassManager,&CLSID_CAcmCoClassManager>
{
    struct LegacyAcm
    {
        TCHAR szLongName[ACMFORMATTAGDETAILS_FORMATTAG_CHARS];
        DWORD dwFormatTag;
    };

    CGenericList<LegacyAcm> m_lDev;

//     static BOOL CALLBACK AcmDriverEnumCallback(
//         HACMDRIVERID hadid,
//         DWORD dwInstance,
//         DWORD fdwSupport);

    static BOOL CALLBACK FormatTagsCallbackSimple(
        HACMDRIVERID            hadid,
        LPACMFORMATTAGDETAILS   paftd,
        DWORD_PTR               dwInstance,
        DWORD                   fdwSupport);

    // dynlink stuff. dynlink.h doesn't help us much. and enumerating
    // this category loads every single driver anyway.

    HMODULE m_hmod;

    typedef MMRESULT (/* ACMAPI */ *PacmFormatTagEnumA) (
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSA  paftd,
        ACMFORMATTAGENUMCBA     fnCallback,
        DWORD_PTR               dwInstance, 
        DWORD                   fdwEnum
    );

    typedef MMRESULT (/* ACMAPI */ *PacmFormatTagEnumW)(
        HACMDRIVER              had,
        LPACMFORMATTAGDETAILSW  paftd,
        ACMFORMATTAGENUMCBW     fnCallback,
        DWORD_PTR               dwInstance, 
        DWORD                   fdwEnum
        );

#ifdef UNICODE
    typedef PacmFormatTagEnumW PacmFormatTagEnum;
#else
    typedef PacmFormatTagEnumA PacmFormatTagEnum;
#endif

    PacmFormatTagEnum m_pacmFormatTagEnum;
    

public:

    CAcmClassManager();
    ~CAcmClassManager();

    BEGIN_COM_MAP(CAcmClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CAcmClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\cenumpnp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "cenumpnp.h"

// declare statics
CEnumPnp *CEnumInterfaceClass::m_pEnumPnp = 0;
struct CEnumInterfaceClass::SetupApiFns CEnumInterfaceClass::m_setupFns;

// dyn-load setupapi
CEnumInterfaceClass::CEnumInterfaceClass() :
        m_fLoaded(false)
{
    PNP_PERF(m_msrPerf = MSR_REGISTER("CEnumInterfaceClass"));
    PNP_PERF(MSR_INTEGER(m_msrPerf, 1));
    
    // NT4 has setupapi without the new apis. loading it on slow
    // machines takes 120-600 ms
    extern OSVERSIONINFO g_osvi;
    if(g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
       g_osvi.dwMajorVersion <= 4)
    {
        m_hmodSetupapi = 0;
        DbgLog((LOG_TRACE, 5, TEXT("nt4 - not loading setupapi")));
    }
    else if(g_osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS &&
            g_osvi.dwMajorVersion == 4 &&
            g_osvi.dwMinorVersion < 10)
    {
        m_hmodSetupapi = 0;
        DbgLog((LOG_TRACE, 5, TEXT("win95 non memphis - not loading setupapi")));
    }
    else
    {
        m_hmodSetupapi = LoadLibrary(TEXT("setupapi.dll"));
    }
    //PNP_PERF(static int msrSetupapi = MSR_REGISTER("mkenum: setupapi"));
    //PNP_PERF(MSR_NOTE(msrSetupapi));

    if(m_hmodSetupapi != 0)
    {
        m_fLoaded = LoadSetupApiProcAdds();
    }
    else
    {
        DbgLog((LOG_TRACE, 5, TEXT("devenum: didn't load setupapi")));
    }
    PNP_PERF(MSR_INTEGER(m_msrPerf, 2));
}

// load proc addresses for SetupApi
bool CEnumInterfaceClass::LoadSetupApiProcAdds( )
{
    bool fLoaded = FALSE;
    
#ifdef UNICODE
    static const char szSetupDiGetClassDevs[] = "SetupDiGetClassDevsW";
    static const char szSetupDiGetDeviceInterfaceDetail[] = "SetupDiGetDeviceInterfaceDetailW";
    static const char szSetupDiCreateDeviceInterfaceRegKey[] = "SetupDiCreateDeviceInterfaceRegKeyW";
    static const char szSetupDiOpenDeviceInterface[] = "SetupDiOpenDeviceInterfaceW";
#else
    static const char szSetupDiGetClassDevs[] = "SetupDiGetClassDevsA";
    static const char szSetupDiGetDeviceInterfaceDetail[] = "SetupDiGetDeviceInterfaceDetailA";
    static const char szSetupDiCreateDeviceInterfaceRegKey[] = "SetupDiCreateDeviceInterfaceRegKeyA";
    static const char szSetupDiOpenDeviceInterface[] = "SetupDiOpenDeviceInterfaceA";
#endif

    ASSERT(m_hmodSetupapi != 0);

    if((m_setupFns.pSetupDiGetClassDevs =
        (PSetupDiGetClassDevs)GetProcAddress(
            m_hmodSetupapi, szSetupDiGetClassDevs)) &&

       (m_setupFns.pSetupDiDestroyDeviceInfoList =
        (PSetupDiDestroyDeviceInfoList)GetProcAddress(
            m_hmodSetupapi, "SetupDiDestroyDeviceInfoList")) &&

       (m_setupFns.pSetupDiEnumDeviceInterfaces =
        (PSetupDiEnumDeviceInterfaces)GetProcAddress(
            m_hmodSetupapi, "SetupDiEnumDeviceInterfaces")) &&

       (m_setupFns.pSetupDiOpenDeviceInterfaceRegKey =
        (PSetupDiOpenDeviceInterfaceRegKey)GetProcAddress(
            m_hmodSetupapi, "SetupDiOpenDeviceInterfaceRegKey")) &&

       (m_setupFns.pSetupDiCreateDeviceInterfaceRegKey =
        (PSetupDiCreateDeviceInterfaceRegKey)GetProcAddress(
            m_hmodSetupapi, szSetupDiCreateDeviceInterfaceRegKey)) &&

//        (m_setupFns.pSetupDiOpenDevRegKey =
//         (PSetupDiOpenDevRegKey)GetProcAddress(
//             m_hmodSetupapi, "SetupDiOpenDevRegKey")) &&
       
       (m_setupFns.pSetupDiGetDeviceInterfaceDetail =
        (PSetupDiGetDeviceInterfaceDetail)GetProcAddress(
            m_hmodSetupapi, szSetupDiGetDeviceInterfaceDetail)) &&
       
       (m_setupFns.pSetupDiCreateDeviceInfoList =
        (PSetupDiCreateDeviceInfoList)GetProcAddress(
            m_hmodSetupapi, "SetupDiCreateDeviceInfoList")) &&

       (m_setupFns.pSetupDiOpenDeviceInterface =
        (PSetupDiOpenDeviceInterface)GetProcAddress(
            m_hmodSetupapi, szSetupDiOpenDeviceInterface)) &&

       (m_setupFns.pSetupDiGetDeviceInterfaceAlias =
        (PSetupDiGetDeviceInterfaceAlias)GetProcAddress(
            m_hmodSetupapi, "SetupDiGetDeviceInterfaceAlias"))
       )
    {
        fLoaded = true;
    }
    else
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("devenum: couldn't get setupapi entry points.")));
    }
    return fLoaded;
}


// use the persistent DEVICEPATH to create DeviceList with just the
// one device so we can call the OpenRegKey API. We can't always the
// DeviceInterfaceData saved off from the enumeration, but that might
// be an optimization if this is too slow.

HRESULT CEnumInterfaceClass::OpenDevRegKey(
    HKEY *phk, WCHAR *wszDevicePath,
    BOOL fReadOnly)
{
    *phk = 0;
    HRESULT hr = S_OK;
    if(!m_fLoaded)
    {
        DbgBreak("CEnumInterfaceClass: caller lost earlier error");
        return E_UNEXPECTED;
    }

    HDEVINFO hDevInfoTmp = m_setupFns.pSetupDiCreateDeviceInfoList(0, 0);
    if(hDevInfoTmp != INVALID_HANDLE_VALUE)
    {
        USES_CONVERSION;
        SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
        DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        SP_DEVINFO_DATA DevInfoData;
        BOOL f = m_setupFns.pSetupDiOpenDeviceInterface(
            hDevInfoTmp,
            W2T(wszDevicePath),
            0,
            &DeviceInterfaceData);
        if(f)
        {
            HKEY hkDev;
            if(fReadOnly)
            {
                hkDev = m_setupFns.pSetupDiOpenDeviceInterfaceRegKey(
                    hDevInfoTmp, 
                    &DeviceInterfaceData,
                    0,              // RESERVED
                    KEY_READ
                    );
            }
            else
            {
                hkDev = m_setupFns.pSetupDiCreateDeviceInterfaceRegKey(
                    hDevInfoTmp, 
                    &DeviceInterfaceData, 
                    0,                  // Reserved
                    KEY_READ | KEY_SET_VALUE,
                    0,                  // InfHandler
                    0                   // InfSectionName
                    );
                    
            }
            if(hkDev != INVALID_HANDLE_VALUE)
            {
                // Note that SetupDi returns INVALID_HANDLE_VALUE
                // rather than null for a bogus reg key.
                *phk = hkDev;
                hr = S_OK;
            }
            else
            {
                // we can expect this to fail.
                DWORD dwLastError = GetLastError();
                DbgLog((LOG_ERROR, 1, TEXT("SetupDi{Create,Open}DeviceInterfaceRegKey failed: %d"),
                        dwLastError));
                hr = HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else
        {
            DWORD dwLastError = GetLastError();
            DbgLog((LOG_ERROR, 0, TEXT("SetupDiOpenDeviceInterface failed: %d"),
                    dwLastError));
            hr = HRESULT_FROM_WIN32(dwLastError);
        }
            
        
        m_setupFns.pSetupDiDestroyDeviceInfoList(hDevInfoTmp);
    }
    else
    {
        DWORD dwLastError = GetLastError();
        DbgLog((LOG_ERROR, 0, TEXT("SetupDiCreateDeviceInfoList failed: %d"),
                dwLastError));
        hr = HRESULT_FROM_WIN32(dwLastError);
    }

    return hr;
}

bool CEnumInterfaceClass::IsActive(WCHAR *wszDevicePath)
{
    bool fRet = false;
    
    HDEVINFO hDevInfoTmp = m_setupFns.pSetupDiCreateDeviceInfoList(0, 0);
    if(hDevInfoTmp != INVALID_HANDLE_VALUE)
    {
        USES_CONVERSION;
        SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
        DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        SP_DEVINFO_DATA DevInfoData;
        BOOL f = m_setupFns.pSetupDiOpenDeviceInterface(
            hDevInfoTmp,
            W2T(wszDevicePath),
            0,
            &DeviceInterfaceData);
        if(f)
        {
            if(DeviceInterfaceData.Flags & SPINT_ACTIVE)
            {
                fRet = true;
            }
        }
        m_setupFns.pSetupDiDestroyDeviceInfoList(hDevInfoTmp);
    
    }

    return fRet;
}

//
// enumerator using cursor. returns the device path for the next
// device with aliases in all categories in rgpclsidKsCat
// 

HRESULT
CEnumInterfaceClass::GetDevicePath(
    WCHAR **pwszDevicePath,
    const CLSID **rgpclsidKsCat,
    CEnumInternalState *pCursor)
{
    HRESULT hr = S_OK;
    if(!m_fLoaded)
    {
        // ??? wrong error?
        return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);;
    }


    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    DeviceInterfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceDataAlias;
    DeviceInterfaceDataAlias.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    // use this one unless we find an InterfaceLink alias
    SP_DEVICE_INTERFACE_DATA *pdidSelected = &DeviceInterfaceData;

    GUID guidTmp0 = *rgpclsidKsCat[0];
            
    if(pCursor->hdev == INVALID_HANDLE_VALUE)
    {
        // workaround around for rogue dlls that might unload setupapi out from under us
        // (codec download in IE process, for example)
        HMODULE hMod = GetModuleHandle( TEXT("setupapi.dll"));
        if( NULL == hMod )
        {
            DbgLog(( LOG_TRACE, 1,
                TEXT("ERROR CEnumInterfaceClass::GetDevicePath - setupapi was unloaded!! Attempting reload... ")));
             
            m_hmodSetupapi = LoadLibrary(TEXT("setupapi.dll"));
            if( !m_hmodSetupapi )
            {        
                DbgLog(( LOG_TRACE, 1,
                    TEXT("ERROR CEnumInterfaceClass::GetDevicePath - LoadLibrary on setupapi FAILED!!. ")));
                                    
                return AmGetLastErrorToHResult();
            }
            else
            {
                // always the possibility that addresses have changed
                m_fLoaded = LoadSetupApiProcAdds();
                if( !m_fLoaded )
                {            
                    DbgLog(( LOG_TRACE, 1,
                        TEXT("ERROR CEnumInterfaceClass::GetDevicePath - failed to reload setupapi proc addresses. Aborting... ")));
                    return E_FAIL;
                }                
            }            
        }            
        pCursor->hdev = m_setupFns.pSetupDiGetClassDevs(
            &guidTmp0,              // guid
            0,                      // enumerator
            0,                      // hwnd
            DIGCF_DEVICEINTERFACE | DIGCF_PRESENT);
        if(pCursor->hdev == INVALID_HANDLE_VALUE)
        {
            DbgLog((LOG_ERROR, 0, TEXT("SetupDiGetClassDevs failed.")));
            return AmGetLastErrorToHResult();
        }
    }

    HDEVINFO &hdev = pCursor->hdev;

    // get next device in first category that is also in all the other
    // required categories.
    
    while(m_setupFns.pSetupDiEnumDeviceInterfaces(
        hdev, NULL, &guidTmp0, pCursor->iDev++, &DeviceInterfaceData))
    {
        UINT iCatInstersect = 1;
        while(rgpclsidKsCat[iCatInstersect])
        {
            GUID guidTmp1 = *rgpclsidKsCat[iCatInstersect];
            if(!m_setupFns.pSetupDiGetDeviceInterfaceAlias(
                hdev,
                &DeviceInterfaceData,
                &guidTmp1,
                &DeviceInterfaceDataAlias))
            {
                DbgLog((LOG_TRACE, 5, TEXT("devenum: didn't match %d in %08x"),
                        pCursor->iDev - 1,
                        rgpclsidKsCat[iCatInstersect]->Data1));

                break;
            }

            iCatInstersect++;
        }

        if(rgpclsidKsCat[iCatInstersect]) {
            // must not have matched a category
            continue;
        }
        else
        {
            DbgLog((LOG_TRACE, 15, TEXT("devenum: %d matched %d categories"),
                    pCursor->iDev - 1, iCatInstersect));
        }

        // Read the InterfaceLink value and use that alias
        HKEY hkDeviceInterface =
            m_setupFns.pSetupDiOpenDeviceInterfaceRegKey(
                hdev, 
                &DeviceInterfaceData,
                0,              // RESERVED
                KEY_READ
                );
        if(hkDeviceInterface != INVALID_HANDLE_VALUE)
        {
            CLSID clsIfLink;
            DWORD dwcb = sizeof(clsIfLink);
            DWORD dwType;
            LONG lResult = RegQueryValueEx(
                hkDeviceInterface,
                TEXT("InterfaceLink"),
                0,
                &dwType,
                (BYTE *)&clsIfLink,
                &dwcb);

            EXECUTE_ASSERT(RegCloseKey(hkDeviceInterface) ==
                           ERROR_SUCCESS);
            
            if(lResult == ERROR_SUCCESS)
            {
                ASSERT(dwType == REG_BINARY && dwcb == sizeof(clsIfLink));
            
                ASSERT(DeviceInterfaceDataAlias.cbSize ==
                       sizeof(SP_DEVICE_INTERFACE_DATA));
                
                if(m_setupFns.pSetupDiGetDeviceInterfaceAlias(
                    hdev,
                    &DeviceInterfaceData,
                    &clsIfLink,
                    &DeviceInterfaceDataAlias))
                {
                    // use this base interface instead
                    pdidSelected = &DeviceInterfaceDataAlias;
                }
                else
                {
                    DbgBreak("registry error: InterfaceLink invalid");
                }

            } // read InterfaceLink
           
        } // SetupDiOpenDeviceInterfaceRegKey
        

        //
        // get the device path.
        // 

        SP_DEVINFO_DATA DevInfoData;
        DevInfoData.cbSize = sizeof(DevInfoData);

        BYTE *rgbDeviceInterfaceDetailData = 0;
        PSP_DEVICE_INTERFACE_DETAIL_DATA &rpDeviceInterfaceDetailData =
            (PSP_DEVICE_INTERFACE_DETAIL_DATA &)rgbDeviceInterfaceDetailData;

        // start with 1k buffer to hopefully avoid calling this
        // expensive api twice.
        DWORD dwcbAllocated = 1024;
        for(;;)
        {
            rgbDeviceInterfaceDetailData = new BYTE[dwcbAllocated];
            if(rgbDeviceInterfaceDetailData)
            {
                rpDeviceInterfaceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

                // reported size. shouldn't reuse dwcbAllocated for out param.
                DWORD dwcbRequired; 
                
                BOOL f = m_setupFns.pSetupDiGetDeviceInterfaceDetail(
                    hdev,
                    pdidSelected,
                    rpDeviceInterfaceDetailData,
                    dwcbAllocated,
                    &dwcbRequired,
                    &DevInfoData);

                if(f)
                {
                    hr = S_OK;
                }
                else
                {
                    DWORD dwLastError = GetLastError();
                    if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
                    {
                        // try again with a properly sized buffer
                        delete[] rgbDeviceInterfaceDetailData;
                        dwcbAllocated = dwcbRequired;
                        continue;
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(dwLastError);
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            break;
        } // for

        if(SUCCEEDED(hr))
        {
            UINT cch = lstrlen(rpDeviceInterfaceDetailData->DevicePath) + 1;
            *pwszDevicePath = new WCHAR[cch];
            if(*pwszDevicePath)
            {
                USES_CONVERSION;
                lstrcpyW(*pwszDevicePath, T2CW(rpDeviceInterfaceDetailData->DevicePath));
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        
        // always safe to delete it
        delete[] rgbDeviceInterfaceDetailData;
        return hr;
    }

    // exit while loop only on error from SetupDiEnumDeviceInterfaces
    DWORD dwLastError = GetLastError();

    ASSERT(dwLastError);
    hr = HRESULT_FROM_WIN32(dwLastError);
    return hr;
}

extern CRITICAL_SECTION g_devenum_cs;
CEnumPnp *CEnumInterfaceClass::CreateEnumPnp()
{
    // cs initialized in dll entry point
    EnterCriticalSection(&g_devenum_cs);
    if(m_pEnumPnp == 0)
    {
        // created only once; released when dll unloaded
        m_pEnumPnp = new CEnumPnp;
    }
    LeaveCriticalSection(&g_devenum_cs);

    return m_pEnumPnp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\cenumpnp.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _CENUM_H
#define _CENUM_H

// class to cache setupapi.dll (dynamically loaded) and call the
// various SetupDi apis

#include <setupapi.h>

struct CEnumInternalState;

class CEnumInterfaceClass 
{
public:

    CEnumInterfaceClass();

    //HRESULT OpenDevRegKey(HKEY *phk, REFCLSID clsidCategory, UINT iDev);
    HRESULT OpenDevRegKey(HKEY *phk, WCHAR *wszDevicePath, BOOL fReadOnly);

    bool IsActive(WCHAR *wszDevicePath);
    bool LoadSetupApiProcAdds(void);

    // used to enumerate. ERROR_NO_MORE_ITEMS returned at the
    // end. caller must zero pCursor the first time.
    HRESULT GetDevicePath(
        WCHAR **pwszDevicePath,
        const CLSID **rgpclsidKsCat,
        CEnumInternalState *pCursor);
    
    // the user must be in devenum.dll since we don't increment the
    // refcount on devenum.dll
    static CEnumInterfaceClass *m_pEnumPnp;

    // return an CEnumPnp or NULL. 
    static CEnumInterfaceClass *CreateEnumPnp();
    
private:

    bool m_fLoaded;
    HMODULE m_hmodSetupapi;

    typedef HDEVINFO (/* WINSETUPAPI */ WINAPI *PSetupDiGetClassDevsW)(
        IN LPGUID ClassGuid,  OPTIONAL
        IN PCWSTR Enumerator, OPTIONAL
        IN HWND   hwndParent, OPTIONAL
        IN DWORD  Flags
        );

    typedef HDEVINFO (/* WINSETUPAPI */ WINAPI *PSetupDiGetClassDevsA)(
        IN LPGUID ClassGuid,  OPTIONAL
        IN PCSTR  Enumerator, OPTIONAL
        IN HWND   hwndParent, OPTIONAL
        IN DWORD  Flags
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiDestroyDeviceInfoList)(
        IN HDEVINFO DeviceInfoSet
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiEnumDeviceInterfaces)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
        IN  LPGUID                    InterfaceClassGuid,
        IN  DWORD                     MemberIndex,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDeviceInterfaceRegKey)(
        IN HDEVINFO                  DeviceInfoSet,
        IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDevRegKey)(
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData,
        IN DWORD            Scope,
        IN DWORD            HwProfile,
        IN DWORD            KeyType,
        IN REGSAM           samDesired
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiGetDeviceInterfaceDetailA)(
        IN  HDEVINFO                           DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
        OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,
        IN  DWORD                              DeviceInterfaceDetailDataSize,
        OUT PDWORD                             RequiredSize,
        OUT PSP_DEVINFO_DATA                   DeviceInfoData
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiGetDeviceInterfaceDetailW)(
        IN  HDEVINFO                           DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
        OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_W DeviceInterfaceDetailData,
        IN  DWORD                              DeviceInterfaceDetailDataSize,
        OUT PDWORD                             RequiredSize,
        OUT PSP_DEVINFO_DATA                   DeviceInfoData
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiCreateDeviceInterfaceRegKeyA)(
        IN HDEVINFO                  DeviceInfoSet,
        IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired,
        IN HINF                      InfHandle,
        IN PCSTR                     InfSectionName
        );

    typedef HKEY (/* WINSETUPAPI */ WINAPI *PSetupDiCreateDeviceInterfaceRegKeyW)(
        IN HDEVINFO                  DeviceInfoSet,
        IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired,
        IN HINF                      InfHandle,           OPTIONAL
        IN PCWSTR                    InfSectionName       OPTIONAL
        );

    typedef HDEVINFO (/* WINSETUPAPI */ WINAPI *PSetupDiCreateDeviceInfoList)(
        IN LPGUID ClassGuid, OPTIONAL
        IN HWND   hwndParent OPTIONAL
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDeviceInterfaceA)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PCSTR                     DevicePath,
        IN  DWORD                     OpenFlags,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiOpenDeviceInterfaceW)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PCWSTR                    DevicePath,
        IN  DWORD                     OpenFlags,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
        );

    typedef BOOL (/* WINSETUPAPI */ WINAPI *PSetupDiGetDeviceInterfaceAlias)(
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
        IN  LPGUID                    AliasInterfaceClassGuid,
        OUT PSP_DEVICE_INTERFACE_DATA AliasDeviceInterfaceData
        );
        

#ifdef UNICODE
    typedef PSetupDiGetClassDevsW PSetupDiGetClassDevs;
    typedef PSetupDiGetDeviceInterfaceDetailW PSetupDiGetDeviceInterfaceDetail;
    typedef PSetupDiCreateDeviceInterfaceRegKeyW PSetupDiCreateDeviceInterfaceRegKey;
    typedef PSetupDiOpenDeviceInterfaceW PSetupDiOpenDeviceInterface;
#else
    typedef PSetupDiGetClassDevsA PSetupDiGetClassDevs;
    typedef PSetupDiGetDeviceInterfaceDetailA PSetupDiGetDeviceInterfaceDetail;
    typedef PSetupDiCreateDeviceInterfaceRegKeyA PSetupDiCreateDeviceInterfaceRegKey;
    typedef PSetupDiOpenDeviceInterfaceA PSetupDiOpenDeviceInterface;
#endif

    static struct SetupApiFns
    {
        PSetupDiGetClassDevs pSetupDiGetClassDevs;
        PSetupDiDestroyDeviceInfoList pSetupDiDestroyDeviceInfoList;
        PSetupDiEnumDeviceInterfaces pSetupDiEnumDeviceInterfaces;
        PSetupDiOpenDeviceInterfaceRegKey pSetupDiOpenDeviceInterfaceRegKey;
//         PSetupDiOpenDevRegKey pSetupDiOpenDevRegKey;
        PSetupDiGetDeviceInterfaceDetail pSetupDiGetDeviceInterfaceDetail;
        PSetupDiCreateDeviceInterfaceRegKey pSetupDiCreateDeviceInterfaceRegKey;
        PSetupDiCreateDeviceInfoList pSetupDiCreateDeviceInfoList;
        PSetupDiOpenDeviceInterface pSetupDiOpenDeviceInterface;
        PSetupDiGetDeviceInterfaceAlias pSetupDiGetDeviceInterfaceAlias;
    } m_setupFns;

    friend struct CEnumInternalState;

#ifdef PNP_PERF
    int m_msrPerf;
#endif
};

// used to remember the last device returned when caller asks for the
// next.
struct CEnumInternalState
{
    CEnumInternalState() { hdev = INVALID_HANDLE_VALUE; iDev = 0; }
    ~CEnumInternalState() { if(hdev != INVALID_HANDLE_VALUE) {
        EXECUTE_ASSERT(CEnumInterfaceClass::m_setupFns.pSetupDiDestroyDeviceInfoList(hdev));}
    }
    UINT iDev;
    HDEVINFO hdev;
};



// typedef CComObject<CEnumInterfaceClass> CEnumPnp;
typedef CEnumInterfaceClass CEnumPnp;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\cmgrbase.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "util.h"
#include "cmgrbase.h"
#include "mkenum.h"

CClassManagerBase::CClassManagerBase(const TCHAR *szUniqueName) :
        m_szUniqueName(szUniqueName),
        m_fDoAllDevices(true)
{
}

//
// Routine
//
//     Updates the registry to match installed devices if necessary
//     and create an enumerator for this category
//
// Arguments
//
//     clsidDeviceClass - category we're enumerating
//
//     ppEnumDevMoniker - enumerator returned here. null returned if
//     anything other than S_OK is returned
//
//     dwFlags - non used yet
//
// Returns
//
//     S_FALSE (and null) if the category is empty
//
STDMETHODIMP CClassManagerBase::CreateClassEnumerator(
    REFCLSID clsidDeviceClass,
    IEnumMoniker ** ppEnumDevMoniker,
    DWORD dwFlags)
{
    PNP_PERF(static int msrCmgr = MSR_REGISTER("cmgrBase: Create"));
    PNP_PERF(static int msrCmgrRead = MSR_REGISTER("cmgr: ReadLegacyDevNames"));
    PNP_PERF(static int msrCmgrVrfy = MSR_REGISTER("cmgr: VerifyRegistryInSync"));
    PNP_PERF(MSR_INTEGER(msrCmgr, clsidDeviceClass.Data1));

    DbgLog((LOG_TRACE, 2, TEXT("CreateClassEnumerator enter")));

    HRESULT hr = S_OK;

    // the m_fDoAllDevices performance hack is more noticeably broken
    // for the AM filter category, so don't do it there. what happens
    // is that an AM 1.0 filter is not found for playback because the
    // cache of AM 1.0 filters is not rebuilt. !!!
    
    //  Save the flags
    m_fDoAllDevices = (0 == (dwFlags & CDEF_MERIT_ABOVE_DO_NOT_USE) ||
                       clsidDeviceClass == CLSID_LegacyAmFilterCategory);

    // serialize registry verification and editing with global mutex 
    CCreateSwEnum * pSysCreateEnum;
    hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL,
                          CLSCTX_INPROC_SERVER, CLSID_SystemDeviceEnum,
                          (void **)&pSysCreateEnum);
    if (SUCCEEDED(hr))
    {
        extern HANDLE g_devenum_mutex;
        // because CCreateSwEnum ctor must have been called
        ASSERT(g_devenum_mutex);
        
        EXECUTE_ASSERT(WaitForSingleObject(g_devenum_mutex, INFINITE) ==
                       WAIT_OBJECT_0);

        CComPtr<IEnumMoniker> pEnumClassMgrMonikers;
        CComPtr<IEnumMoniker> pSysEnumClass;
        hr = pSysCreateEnum->CreateClassEnumerator(
            clsidDeviceClass, &pSysEnumClass,
            dwFlags | CDEF_BYPASS_CLASS_MANAGER,
            &pEnumClassMgrMonikers);
        if(SUCCEEDED(hr))
        {
            // S_FALSE means category is empty and no enumerator
            // is returned. pEnumClassMgrMonikers need not be null
            // even if there are no class-managed devices.
            ASSERT((hr == S_OK && pSysEnumClass) ||
                   (hr == S_FALSE && !pEnumClassMgrMonikers && !pSysEnumClass));

            PNP_PERF(MSR_START(msrCmgrRead));
            DbgLog((LOG_TRACE, 2, TEXT("ReadLegacyDeviceNames start")));
            hr = ReadLegacyDevNames();
            DbgLog((LOG_TRACE, 2, TEXT("ReadLegacyDeviceNames end")));
            PNP_PERF(MSR_STOP(msrCmgrRead));

            if(SUCCEEDED(hr))
            {
                PNP_PERF(MSR_START(msrCmgrVrfy));
                DbgLog((LOG_TRACE, 2, TEXT("Verify registry in sync start")));
                BOOL fVrfy = VerifyRegistryInSync(pEnumClassMgrMonikers);
                DbgLog((LOG_TRACE, 2, TEXT("Verify registry in sync end")));
                PNP_PERF(MSR_STOP(msrCmgrVrfy));
                if (fVrfy)
                {
                    // registry was in sync. just return our
                    // enumerator.
                    *ppEnumDevMoniker = pSysEnumClass;
                    if (*ppEnumDevMoniker)
                    {
                        (*ppEnumDevMoniker)->AddRef();
                        hr = S_OK;
                    }
                    else
                    {
                        hr = S_FALSE;
                    }
                }
                else
                {
                    // Recreate now that the registry is in sync
#ifdef DEBUG
                    // auto relase with check for null (may be
                    // null in S_FALSE case)
                    pEnumClassMgrMonikers = 0;
#endif
                    DbgLog((LOG_TRACE, 2, TEXT("Bypass class manager")));
                    hr = pSysCreateEnum->CreateClassEnumerator(
                        clsidDeviceClass,
                        ppEnumDevMoniker,
                        dwFlags | CDEF_BYPASS_CLASS_MANAGER,
#ifdef DEBUG
                        &pEnumClassMgrMonikers
#else
                        0   // don't check again in retail builds
#endif
                        );
#ifdef DEBUG
                    // check again in debug builds
                    if(pEnumClassMgrMonikers)
                    {
                        ASSERT(VerifyRegistryInSync(pEnumClassMgrMonikers));
                    }
#endif // DEBUG
                } // registry was out of sync

            } // ReadLegacyDevNames succeeded

        } // CreateClassEnumerator succeeded

        pSysCreateEnum->Release();

        EXECUTE_ASSERT(ReleaseMutex(g_devenum_mutex));

    } // CoCreate succeeded

    PNP_PERF(MSR_INTEGER(msrCmgr, 7));


    DbgLog((LOG_TRACE, 2, TEXT("CreateClassEnumerator leave")));
    return hr;
}

//
// Routine
//
//     checks that the registry matches what the derived class thinks
//     is installed. updates the registry if not in sync. and returns
//     FALSE.
//
// Arguments
//
//     pEnum - enumerator containing the class-managed devices to
//     check.
//
BOOL CClassManagerBase::VerifyRegistryInSync(IEnumMoniker *pEnum)
{
    IMoniker *pDevMoniker;
    ULONG cFetched;
    if(pEnum)
    {
        while (m_cNotMatched > -1 &&
               pEnum->Next(1, &pDevMoniker, &cFetched) == S_OK)
        {
            // if we don't need to enumerate all devices and we've already
            // written something to this key then we assume that either this
            // category has already been fully enumerated (in which case we 
            // don't want to delete the reg cache) or the higher merit filters
            // have already been enumerated (so we don't need to do it again).
            if( !m_fDoAllDevices )
            {
                pDevMoniker->Release();
                return TRUE;
            }                
                            
            IPropertyBag *pPropBag;
            HRESULT hr = pDevMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                if(MatchString(pPropBag))
                {
                    m_cNotMatched--;
                }
                else
                {
                    hr = S_FALSE;
                }

                pPropBag->Release();
            }
            pDevMoniker->Release();

            if(hr != S_OK)
            {
                m_cNotMatched = -1;
                break;
            }
        }
        if (m_cNotMatched == 0)
        {
            return TRUE;
        }
    }
    else if(m_cNotMatched == 0)
    {
        return TRUE;
    }

    IFilterMapper2 *pFm2;
    HRESULT hr = CoCreateInstance(
        CLSID_FilterMapper2, NULL, CLSCTX_INPROC_SERVER,
        IID_IFilterMapper2, (void **)&pFm2);
    if(SUCCEEDED(hr))
    {
        CreateRegKeys(pFm2);
        pFm2->Release();
    }

    return FALSE;
}

//
// Routine
//
//     Deletes everything in the class manager key (in HKCU) or
//     creates the key if it's missing
//
HRESULT ResetClassManagerKey(
    REFCLSID clsidCat)
{
    HRESULT hr = S_OK;
    CRegKey rkClassMgr;

    TCHAR szcmgrPath[100];
    WCHAR wszClsidCat[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(clsidCat, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    LONG lResult = rkClassMgr.Open(
        g_hkCmReg,
        g_szCmRegPath,
        KEY_WRITE);
    if(lResult == ERROR_SUCCESS)
    {
        USES_CONVERSION;
        TCHAR *szClsidCat = W2T(wszClsidCat);
        rkClassMgr.RecurseDeleteKey(szClsidCat);

        lResult = rkClassMgr.Create(
            rkClassMgr,
            szClsidCat);
    }

    return HRESULT_FROM_WIN32(lResult);
}

//
// Routine
//
//     Determine if one entry in the registry is matched in the
//     derived class. read m_szUniqueName and give it to the derived
//     class.
//
BOOL CClassManagerBase::MatchString(
    IPropertyBag *pPropBag)
{
    BOOL fReturn = FALSE;

    VARIANT var;
    var.vt = VT_EMPTY;
    USES_CONVERSION;
    HRESULT hr = pPropBag->Read(T2COLE(m_szUniqueName), &var, 0);
    if(SUCCEEDED(hr))
    {
        fReturn = MatchString(OLE2CT(var.bstrVal));

        if(!fReturn) {
            DbgLog((LOG_TRACE, 5, TEXT("devenum: failed to match %S"), var.bstrVal));
        }

        SysFreeString(var.bstrVal);
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("devenum: couldn't read %s"), m_szUniqueName));
    }

    return fReturn;
}

BOOL CClassManagerBase::MatchString(
    const TCHAR *szDevName)
{
    DbgBreak("MatchString should be overridden");
    return FALSE;
}

// register the filter through IFilterMapper2 and return the
// moniker. requires building a moniker by hand since the
// RegisterFilter method puts it somewhere the ClassManager cannot
// write.
HRESULT RegisterClassManagerFilter(
    IFilterMapper2 *pfm2,
    REFCLSID clsidFilter,
    LPCWSTR szName,
    IMoniker **ppMonikerOut,
    const CLSID *pclsidCategory,
    LPCWSTR szInstance,
    REGFILTER2 *prf2)
{
    USES_CONVERSION;
    TCHAR szDisplayName[MAX_PATH]; // we limit cm display names to 100 chars
    WCHAR wszCategory[CHARS_IN_GUID], wszFilterClsid[CHARS_IN_GUID];

    EXECUTE_ASSERT(StringFromGUID2(*pclsidCategory, wszCategory, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    EXECUTE_ASSERT(StringFromGUID2(clsidFilter, wszFilterClsid, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    // truncate instance name at 100 characters.
    wsprintf(szDisplayName, TEXT("@device:cm:%s\\%.100s"),
             W2CT(wszCategory),
             W2CT((szInstance == 0 ? wszFilterClsid : szInstance)));

    IBindCtx *lpBC;
    HRESULT hr = CreateBindCtx(0, &lpBC);
    if(SUCCEEDED(hr))
    {
        IParseDisplayName *ppdn;
        hr = CoCreateInstance(
            CLSID_CDeviceMoniker,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IParseDisplayName,
            (void **)&ppdn);
        if(SUCCEEDED(hr))
        {
            IMoniker *pMoniker = 0;
            ULONG cchEaten;
            hr = ppdn->ParseDisplayName(
                lpBC, T2OLE(szDisplayName), &cchEaten, &pMoniker);

            if(SUCCEEDED(hr))
            {
                IMoniker *pMonikerTmp = pMoniker;
                hr = pfm2->RegisterFilter(
                    clsidFilter,
                    szName,
                    &pMonikerTmp,
                    0,
                    0,
                    prf2);

                if(SUCCEEDED(hr))
                {
                    if(ppMonikerOut)
                    {
                        hr = pMoniker->QueryInterface(
                            IID_IMoniker,
                            (void **)ppMonikerOut);
                    }
                }

                pMoniker->Release();
            }

            ppdn->Release();
        }

        lpBC->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\dlldata.c ===
/* Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved. */
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( devenum )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( devenum ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\devmon.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "devmon.h"
#include "util.h"
#include "cenumpnp.h"

// compiler bug prevents making these static class members
PDMOGetTypes g_pDMOGetTypes;
PDMOGetName g_pDMOGetName;

static BOOL CompareSubstr(const WCHAR *wsz1, const WCHAR *wszSubstr)
{
    while(*wszSubstr != 0)
    {
        if(*wszSubstr++ != *wsz1++)
            return FALSE;
    }

    return TRUE;
}
static BOOL CopySubstr(WCHAR *wszDest, const WCHAR *wszSrc, UINT cchDest)
{
    while(*wszSrc != 0 && cchDest > 1)
    {
        *wszDest++ = *wszSrc++;
        cchDest--;
    }

    *wszDest = 0;
    return cchDest == 1;
}

CDeviceMoniker::CDeviceMoniker() :
    m_szPersistName(0),
    m_type(Invalid),
    m_clsidDeviceClass(GUID_NULL)
{

}

//
// Routine
//
//     initialize moniker. can be called more than once.
//
// Arguments
//
//     pszPersistName - the display name:
//
//          @device:sw:{category}\{Unique-id}
//          @device:cm:{category}\{Unique-id}
//          @device:pnp:{device-path}
//

HRESULT CDeviceMoniker::Init(
    LPCWSTR pszPersistName)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE, 0x50, TEXT("CDeviceMoniker::Init called with %ws"),
            pszPersistName));

    m_clsidDeviceClass = GUID_NULL;

    delete[] m_szPersistName;
    m_szPersistName = new WCHAR[(lstrlenW(pszPersistName) + 1) * sizeof(WCHAR)];
    if(m_szPersistName == 0)
    {
        return E_OUTOFMEMORY;
    }

    lstrcpyW(m_szPersistName, pszPersistName);

    WCHAR *pwch = m_szPersistName;
    UINT cColons = 0;

    for(;*pwch != 0 && cColons < 2; pwch++)
        if(*pwch == L':')
            cColons++;

    if(cColons == 2)
    {
        if(pwch - m_szPersistName > 4 &&
           CompareSubstr(pwch - 4, L":sw:"))
        {
            m_sz = pwch;
            m_type = Software;
        }
        else if(pwch - m_szPersistName > 4 &&
           CompareSubstr(pwch - 4, L":cm:"))
        {
            m_sz = pwch;
            m_type = ClassMgr;
        }
        else if(pwch - m_szPersistName > 5 &&
                CompareSubstr(pwch - 5, L":pnp:"))
        {
            m_sz = pwch;
            m_type = PnP;
        }
        else if(pwch - m_szPersistName > 5 &&
                CompareSubstr(pwch - 5, L":dmo:"))
        {
            if (lstrlenW(pwch) != 2 * (CHARS_IN_GUID - 1)) {
                hr = MK_E_SYNTAX;
            } else {
                m_sz = pwch;
                m_type = Dmo;
            }
        }
        else
        {
            hr = MK_E_SYNTAX;
        }
    }
    else
    {
        hr = MK_E_SYNTAX;
    }

    return hr;
}

CDeviceMoniker::~CDeviceMoniker()
{
    delete[] m_szPersistName;
}

STDMETHODIMP CDeviceMoniker::GetClassID(
    CLSID *pClassID)
{
    HRESULT hr;

    __try
        {
            *pClassID = CLSID_CDeviceMoniker;
            hr = S_OK;
        }
    __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_INVALIDARG;
        }

    return hr;
}


STDMETHODIMP CDeviceMoniker::IsDirty()
{
    return S_FALSE;
}

STDMETHODIMP CDeviceMoniker::Load(
    IStream *pStream)
{
    HRESULT hr;

    DWORD dwcb;
    ULONG cbRead;
    hr = pStream->Read(&dwcb, sizeof(DWORD), &cbRead);
    if(SUCCEEDED(hr))
    {
        WCHAR *wszDisplayName = (WCHAR *)new BYTE[dwcb];
        if(wszDisplayName)
        {
            hr = pStream->Read(wszDisplayName, dwcb, &cbRead);

            if(SUCCEEDED(hr))
            {
                // force null terminator
                wszDisplayName[dwcb / sizeof(WCHAR) - 1] = 0;

                hr = Init(wszDisplayName);
            }

            delete[] wszDisplayName;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }

    return hr;
}

// ------------------------------------------------------------------------
// format in stream is DWORD containing size (incl. null) in bytes of
// display name + display name

STDMETHODIMP CDeviceMoniker::Save(
    IStream *pStream,
    BOOL     fClearDirty)
{
    CheckPointer(m_szPersistName, E_UNEXPECTED);

    DWORD dwcb = (lstrlenW(m_szPersistName) + 1) * sizeof(WCHAR);
    HRESULT hr = pStream->Write(&dwcb, sizeof(dwcb), 0);
    if(SUCCEEDED(hr))
    {
        hr = pStream->Write(m_szPersistName, dwcb, 0);
    }

    return  hr;
}


STDMETHODIMP CDeviceMoniker::GetSizeMax(
    ULARGE_INTEGER * pcbSize)
{
    CheckPointer(pcbSize, E_POINTER);
    CheckPointer(m_szPersistName, E_UNEXPECTED);


    // size in bytes incl null + DWORD for length up front
    DWORD dwcb = (lstrlenW(m_szPersistName) + 1) * sizeof(WCHAR) + sizeof(DWORD);
    pcbSize->QuadPart = dwcb;
    return S_OK;
}

// helper to get the class manager to update the registry so that
// BindToObject() can read the device's values. this function creates
// the class manager enumerator rather than calling the class manager
// function directly.
//
// returns S_OK on success; S_FALSE or failure on failure.
// 
HRESULT PopulateRegistry(WCHAR *wszMoniker)
{
    WCHAR wszClsid[CHARS_IN_GUID];
    lstrcpynW(wszClsid, wszMoniker, CHARS_IN_GUID);
    CLSID clsidCat;
    HRESULT hr = CLSIDFromString( wszClsid, &clsidCat);
    if(SUCCEEDED(hr))
    {
        ICreateDevEnum *pcde;
        HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                      IID_ICreateDevEnum, (void **)&pcde);
        if(SUCCEEDED(hr))
        {
            IEnumMoniker *pEnum;
            hr = pcde->CreateClassEnumerator(clsidCat, &pEnum, CDEF_DEVMON_CMGR_DEVICE);
            if(hr == S_OK)      // S_FALSE means no items
            {
                pEnum->Release();
            }

            pcde->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDeviceMoniker::BindToObject (
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    iidResult,
    void **   ppvResult)
{
    CheckPointer(ppvResult, E_POINTER);

    HRESULT    hr = S_OK;

    *ppvResult = NULL;

    if(m_type == Dmo)
    {
        IDMOWrapperFilter *pFilter;
        hr = CoCreateInstance(
            CLSID_DMOWrapperFilter, NULL, CLSCTX_INPROC_SERVER,
            IID_IDMOWrapperFilter, (void **)&pFilter);
        if(SUCCEEDED(hr))
        {
            CLSID clsid;
            GUID guidCategory;
            WCHAR szTemp[CHARS_IN_GUID];

            //  Extract the 2 GUIDs - clsid categoryid
            szTemp[CHARS_IN_GUID - 1] = 0;
            CopyMemory(szTemp, m_sz, sizeof(szTemp) - sizeof(WCHAR));
            hr = CLSIDFromString(szTemp, &clsid);
            if (SUCCEEDED(hr)) {
                hr = CLSIDFromString(m_sz + CHARS_IN_GUID - 1, &guidCategory);
            }
            if(SUCCEEDED(hr))
            {
                hr = pFilter->Init(clsid, guidCategory);
            }
            if(SUCCEEDED(hr))
            {
                hr = pFilter->QueryInterface(iidResult, ppvResult);
            }
            pFilter->Release();
        }

        return hr;
    }

    for(int i = 0; i < 2; i++)
    {
        if(m_clsidDeviceClass == GUID_NULL)
        {
            VARIANT var;
            var.vt = VT_BSTR;
            hr = Read(L"CLSID", &var, 0);

            if(SUCCEEDED(hr))
            {
                hr = CLSIDFromString(var.bstrVal, &m_clsidDeviceClass);
                SysFreeString(var.bstrVal);
            }
        }

        if(i == 0 && hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &&
           PopulateRegistry(m_sz) == S_OK)
        {
            continue;
        }

        break;
    }
    

    if(SUCCEEDED(hr))
    {
        IUnknown *pUnk;

        // don't fault in server from DS in ZAW. can't always specify
        // NO_DOWNLOAD flag because is not supported on win98. ole
        // team of all groups (debim) says use the operating system
        // version info since they provide no way to discover what
        // flags are supported

#ifdef CLSCTX_NO_CODE_DOWNLOAD
# if CLSCTX_NO_CODE_DOWNLOAD != 0x400
#  error fix CLSCTX_NO_CODE_DOWNLOAD value
# endif
#else
# define CLSCTX_NO_CODE_DOWNLOAD 0x400
#endif

        extern OSVERSIONINFO g_osvi;
        DWORD dwFlags = CLSCTX_INPROC_SERVER;
        if(g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
           g_osvi.dwMajorVersion >= 5)
        {
            dwFlags |= CLSCTX_NO_CODE_DOWNLOAD;
        }
        else
        {
            // because we would specify the flag if it was supported
            ASSERT(CoCreateInstance(
                m_clsidDeviceClass, NULL, dwFlags | CLSCTX_NO_CODE_DOWNLOAD,
                IID_IUnknown, (void **)&pUnk) == E_INVALIDARG);
            // failed, so nothing to release.
        }

        DbgLog((LOG_TRACE, 15, TEXT("BindToObject CoCreateInstance flags: %08x"), dwFlags));

        hr = CoCreateInstance(
            m_clsidDeviceClass, NULL, dwFlags,
            IID_IUnknown, (void **)&pUnk);
        if(SUCCEEDED(hr))
        {
            IPersistPropertyBag *pDevice;
            hr = pUnk->QueryInterface(IID_IPersistPropertyBag, (void **)&pDevice);
            if(SUCCEEDED(hr))
            {
                IPropertyBag *pPropBag;
                hr = BindToStorage(0, 0, IID_IPropertyBag, (void**)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    hr = pDevice->Load(pPropBag, 0);
                    if(SUCCEEDED(hr))
                    {
                        hr = pDevice->QueryInterface(iidResult, ppvResult);
                    }
                    pPropBag->Release();
                }

                pDevice->Release();
            }
            else
            {
                hr = pUnk->QueryInterface(iidResult, ppvResult);
            }

            pUnk->Release();
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::BindToStorage
//
//  Synopsis:   Bind to the storage for the object named by the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::BindToStorage(
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    CheckPointer(ppv, E_POINTER);

    HRESULT hr = S_OK;

    if(riid == IID_IPropertyBag)
    {
        *ppv = (IPropertyBag *)this;
        GetControllingUnknown()->AddRef();
    }
    else
    {
      hr = E_NOINTERFACE;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Reduce
//
//  Synopsis:   Reduce the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Reduce(
    IBindCtx *  pbc,
    DWORD       dwReduceHowFar,
    IMoniker ** ppmkToLeft,
    IMoniker ** ppmkReduced)
{
    HRESULT hr;

    __try
    {
        //Validate parameters.
        *ppmkReduced = NULL;

        GetControllingUnknown()->AddRef();
        *ppmkReduced = (IMoniker *) this;
        hr = MK_S_REDUCED_TO_SELF;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::ComposeWith
//
//  Synopsis:   Compose another moniker onto the end of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::ComposeWith(
    IMoniker * pmkRight,
    BOOL       fOnlyIfNotGeneric,
    IMoniker **ppmkComposite)
{
    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Enum
//
//  Synopsis:   Enumerate the components of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Enum(
    BOOL            fForward,
    IEnumMoniker ** ppenumMoniker)
{
    HRESULT hr;

    __try
    {
        *ppenumMoniker = NULL;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::IsEqual
//
//  Synopsis:   Compares with another moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::IsEqual(
    IMoniker *pmkOther)
{
    HRESULT        hr;
    CDeviceMoniker *pDeviceMoniker;

    __try
    {
        hr = pmkOther->QueryInterface(CLSID_CDeviceMoniker,
                                      (void **) &pDeviceMoniker);

        if(SUCCEEDED(hr))
        {

            if(m_szPersistName && pDeviceMoniker->m_szPersistName &&
               lstrcmpW(m_szPersistName, pDeviceMoniker->m_szPersistName) == 0)
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }

            pDeviceMoniker->GetControllingUnknown()->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Hash
//
//  Synopsis:   Compute a hash value
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Hash(
    DWORD * pdwHash)
{
    HRESULT hr;

    __try
    {
        *pdwHash = m_clsidDeviceClass.Data1;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CDeviceMoniker::IsRunning(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    IMoniker * pmkNewlyRunning)
{
    return E_NOTIMPL;
}


STDMETHODIMP CDeviceMoniker::GetTimeOfLastChange        (
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    FILETIME * pFileTime)
{
    return MK_E_UNAVAILABLE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::Inverse
//
//  Synopsis:  Returns the inverse of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::Inverse(
    IMoniker ** ppmk)
{
    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::CommonPrefixWith
//
//  Synopsis:  Returns the common prefix shared by this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::CommonPrefixWith(
    IMoniker *  pmkOther,
    IMoniker ** ppmkPrefix)
{
    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::RelativePathTo
//
//  Synopsis:  Returns the relative path between this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::RelativePathTo(
    IMoniker *  pmkOther,
    IMoniker ** ppmkRelPath)
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::GetDisplayName
//
//  Synopsis:   Get the display name of this moniker. looks like
//  device:{device_clsid}sw:{class_manager_clsid}\Instance\Instance_name
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = E_FAIL;
    LPWSTR pszDisplayName;

    __try
        {

            //Validate parameters.
            *lplpszDisplayName = NULL;


            pszDisplayName = (LPWSTR) CoTaskMemAlloc((lstrlenW(m_szPersistName) + 1) * sizeof(wchar_t));
            if(pszDisplayName != NULL)
            {
                lstrcpyW(pszDisplayName, m_szPersistName);
                *lplpszDisplayName = pszDisplayName;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

    __except(EXCEPTION_EXECUTE_HANDLER)
        {
            hr = E_INVALIDARG;
        }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     GetDefaultMoniker
//
//  Synopsis:   Return the default device for a category.
//
//  Algorithm:  Enumerate category clsidCategory and return first moniker
//
//----------------------------------------------------------------------------

HRESULT GetDefaultMoniker(CLSID& clsidCategory, IMoniker **ppMon)
{
    ICreateDevEnum *pcde;
    HRESULT hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,
                                  IID_ICreateDevEnum, (void **)&pcde);
    if(SUCCEEDED(hr))
    {
        IEnumMoniker *pEnum;
        hr = pcde->CreateClassEnumerator(clsidCategory, &pEnum, 0);
        if(hr == S_OK)          // S_FALSE means no items
        {
            ULONG cFetched;
            IMoniker *pMon;
            hr = pEnum->Next(1, &pMon, &cFetched);
            if(hr == S_OK)      // S_FALSE means no items
            {
                *ppMon = pMon;  // transfer refcount
            }

            pEnum->Release();
        }

        pcde->Release();
    }
    if (hr == S_FALSE)
    {
        hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::ParseDisplayName
//
//  Synopsis:   Parse the display name.
//
//  Algorithm:  Call BindToObject to get an IParseDisplayName on the class
//              object.  Call IParseDisplayName::ParseDisplayName on the
//              class object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    IMoniker *  pmkToLeft,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    CheckPointer(ppmkOut, E_POINTER);
    CheckPointer(pchEaten, E_POINTER);
    *ppmkOut = 0;
    *pchEaten = 0;

    bool fInited = false;

    HRESULT hr = S_OK;

    {
        static const WCHAR wsz[] = L"@device:";
        WCHAR *wszDispNameIn = lpszDisplayName;
        
        bool fAtPrefix = (wszDispNameIn[0] == L'@');
        if(!CompareSubstr(wszDispNameIn, fAtPrefix ? wsz : (wsz + 1)))
        {
            return MK_E_SYNTAX;
        }

        // find type and check for "default" moniker
        wszDispNameIn += (NUMELMS(wsz) - (fAtPrefix ? 1 : 2));
        if(*wszDispNameIn++ == L'*' &&
           *wszDispNameIn++ == L':')
        {
            CLSID clsCategory;
            hr = CLSIDFromString(wszDispNameIn, &clsCategory);
            if(SUCCEEDED(hr))
            {
                IMoniker *pMonDefault;
                hr = GetDefaultMoniker(clsCategory, &pMonDefault);
                if(SUCCEEDED(hr))
                {
                    WCHAR *wszDisplayName;
                    hr = pMonDefault->GetDisplayName(0, 0, &wszDisplayName);
                    if(SUCCEEDED(hr))
                    {
                        hr = Init(wszDisplayName);
                        fInited = SUCCEEDED(hr);
                        CoTaskMemFree(wszDisplayName);
                    }
                    pMonDefault->Release();
                }
            }
        } // default moniker
    }

    if(!fInited && SUCCEEDED(hr)) {
        hr =  Init(lpszDisplayName);
    }
    if(SUCCEEDED(hr))
    {
        *ppmkOut = this;
        (*ppmkOut)->AddRef();
        *pchEaten = lstrlenW(lpszDisplayName);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDeviceMoniker::IsSystemMoniker
//
//  Synopsis:   Determines if this is one of the system supplied monikers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CDeviceMoniker::IsSystemMoniker(
    DWORD * pdwType)
{
    HRESULT hr;

    __try
    {
        *pdwType = MKSYS_NONE;
        hr = S_FALSE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CDeviceMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    return ParseDisplayName(pbc, 0, lpszDisplayName, pchEaten, ppmkOut);
}

STDMETHODIMP CDeviceMoniker::Read(
    LPCOLESTR pszPropName, LPVARIANT pVar,
    LPERRORLOG pErrorLog)
{
    CheckPointer(pszPropName, E_POINTER);
    CheckPointer(pVar, E_POINTER);

    HRESULT hr = S_OK;

    if(m_type == Software || m_type == ClassMgr)
    {

        LONG lResult = ERROR_SUCCESS;
        CRegKey rkDevKey;
        HKEY hkRoot;
        TCHAR szPath[MAX_PATH];
        ConstructKeyPath(szPath, &hkRoot);

        USES_CONVERSION;
        lResult = rkDevKey.Open(hkRoot, szPath, KEY_READ) ;
        DbgLog((LOG_TRACE, 5, TEXT("CDeviceMoniker::OpenKey opening %s %d"),
                W2CT(m_sz), lResult));

        if(lResult == ERROR_SUCCESS)
        {
            USES_CONVERSION;
            const TCHAR *szProp = OLE2CT(pszPropName);

            hr = RegConvertToVariant(pVar, rkDevKey, szProp);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lResult);
        }
    }
    else if(m_type == PnP)
    {
        hr = S_OK;

        if(lstrcmpW(pszPropName, L"DevicePath") == 0)
        {
            if(pVar->vt == VT_EMPTY || pVar->vt == VT_BSTR)
            {
                pVar->vt = VT_BSTR;
                pVar->bstrVal = SysAllocString(m_sz);

                hr = pVar->bstrVal ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        else
        {
            // unknown things and things like FriendlyName
            // and CLSID come out of the InterfaceDevice
            // registry key

            CRegKey rkDevKey;
            CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
            if(pEnumPnp)
            {
                hr = pEnumPnp->OpenDevRegKey(&rkDevKey.m_hKey, m_sz, TRUE);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            if(SUCCEEDED(hr))
            {
                USES_CONVERSION;
                hr = RegConvertToVariant(
                    pVar, rkDevKey, OLE2CT(pszPropName));
            }
        }
    }
    else if(m_type == Dmo)
    {
        hr = DmoRead(pszPropName, pVar);
    }
    else
    {
        hr = MK_E_SYNTAX;
    }

    return hr;
}

HRESULT VariantArrayHelper(VARIANT *pVar, BYTE *pbSrc, ULONG cbSrc)
{
    HRESULT hr = S_OK;
    pVar->vt = VT_UI1 | VT_ARRAY;

    SAFEARRAY * psa;
    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbSrc;
    psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

    if(psa)
    {
        BYTE *pbData;
        EXECUTE_ASSERT(SafeArrayAccessData(psa, (void **)&pbData) == S_OK);
        CopyMemory(pbData, pbSrc, cbSrc);
        EXECUTE_ASSERT(SafeArrayUnaccessData(psa) == S_OK);
        pVar->parray = psa;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT CDeviceMoniker::RegConvertToVariant(
    VARIANT *pVar, HKEY hk, const TCHAR *szProp)
{
    HRESULT hr = E_FAIL;

    DWORD dwType;
    DWORDLONG rgdwl[32];         // 256 bytes, 64bit aligned
    DWORD dwcb = sizeof(rgdwl);

    // pbRegValue points to allocated memory if these are not
    // equal. memory on the stack otherwise
    BYTE *pbRegValue = (BYTE *)rgdwl;

    // try reading the registry with a few bytes on the
    // stack. allocate from the heap if that's not enough
    LONG lResult = RegQueryValueEx(
        hk,
        szProp,
        0,
        &dwType,
        pbRegValue,
        &dwcb);
    if(lResult == ERROR_MORE_DATA)
    {
        pbRegValue = new BYTE[dwcb];
        if(pbRegValue == 0) {
            lResult = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            lResult = RegQueryValueEx(
                hk,
                szProp,
                0,
                &dwType,
                pbRegValue,
                &dwcb);
        }
    }

    if(lResult == ERROR_SUCCESS)
    {
        if(dwType == REG_SZ &&
           (pVar->vt == VT_EMPTY || pVar->vt == VT_BSTR))
        {
            USES_CONVERSION;
            pVar->vt = VT_BSTR;
            pVar->bstrVal = SysAllocString(T2COLE((TCHAR *)pbRegValue));
            if(pVar->bstrVal)
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        // 16 bit INFs cannot write out DWORDs. so accept binary data
        // if the caller wanted a DWORD
        else if((dwType == REG_DWORD && (pVar->vt == VT_EMPTY || pVar->vt == VT_I4)) ||
                (dwType == REG_BINARY && dwcb == sizeof(DWORD) && pVar->vt == VT_I4))
        {
            pVar->vt = VT_I4;
            pVar->lVal = *(DWORD *)pbRegValue;
            hr = S_OK;
        }
        else if(dwType == REG_QWORD && (pVar->vt == VT_EMPTY || pVar->vt == VT_I8))
        {
            pVar->vt = VT_I8;
            pVar->llVal = *(LONGLONG *)pbRegValue;
            hr = S_OK;
        }
        else if(dwType == REG_BINARY &&
                (pVar->vt == VT_EMPTY || pVar->vt == (VT_UI1 | VT_ARRAY)))
        {
            hr = VariantArrayHelper(pVar, pbRegValue, dwcb);
        }
        else
        {
            hr = E_INVALIDARG;
        }

    }
    else
    {
        hr = HRESULT_FROM_WIN32(lResult);
    }

    // pbRegValue not on the stack but allocated, so free it
    if(pbRegValue != (BYTE *)rgdwl) {
        delete[] pbRegValue;
    }

    return hr;
}

STDMETHODIMP CDeviceMoniker::Write(
    LPCOLESTR pszPropName,
    LPVARIANT pVar)
{
    CheckPointer(pszPropName, E_POINTER);
    CheckPointer(pVar, E_POINTER);
    USES_CONVERSION;

    HRESULT hr = S_OK;

    CRegKey rkDevKey;

    // open the key with Write access each time.
    if(m_type == PnP)
    {
        CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
        if(pEnumPnp)
        {
            hr = pEnumPnp->OpenDevRegKey(&rkDevKey.m_hKey, m_sz, FALSE);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if(m_type == Dmo)
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
    }
    else
    {
        HKEY hkRoot;
        TCHAR szPath[MAX_PATH];
        ConstructKeyPath(szPath, &hkRoot);

        ASSERT(m_type == Software || m_type == ClassMgr);
        USES_CONVERSION;
        LONG lResult = rkDevKey.Create(
            hkRoot,
            szPath,
            NULL,               // class
            0,                  // flags
            KEY_READ | KEY_SET_VALUE
            );
        if(lResult != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(lResult);

        DbgLog((LOG_TRACE, 5, TEXT("CDeviceMoniker: creating %s: %d"),
                szPath, lResult));
    }

    // write the value
    if(SUCCEEDED(hr))
    {
        const TCHAR *szPropName = OLE2CT(pszPropName);
        LONG lResult = ERROR_SUCCESS;
        switch(pVar->vt)
        {
          case VT_I4:
              lResult = rkDevKey.SetValue(pVar->lVal, szPropName);
              break;

          case VT_I8:
              lResult = RegSetValueEx(
                  rkDevKey,
                  szPropName,
                  0,            // dwReserved
                  REG_QWORD,
                  (BYTE *)&pVar->llVal,
                  sizeof(pVar->llVal));
              break;

          case VT_BSTR:
              lResult = rkDevKey.SetValue(OLE2CT(pVar->bstrVal), szPropName);
              break;

          case VT_UI1 | VT_ARRAY:
              BYTE *pbData;
              EXECUTE_ASSERT(SafeArrayAccessData(
                  pVar->parray, (void **)&pbData) == S_OK);

              lResult = RegSetValueEx(
                  rkDevKey,
                  szPropName,
                  0,            // dwReserved
                  REG_BINARY,
                  pbData,
                  pVar->parray->rgsabound[0].cElements);

              EXECUTE_ASSERT(SafeArrayUnaccessData(
                  pVar->parray) == S_OK);

              break;

          default:
              lResult = ERROR_INVALID_PARAMETER;

        }
        if(lResult != ERROR_SUCCESS)
            hr = HRESULT_FROM_WIN32(lResult);
    }

    return hr;
}

//
// returns what key to open from the DisplayName. HKCU\...\devenum or
// HKCR\...\Instance
//
// szPath is MAX_PATH characters long
//
void CDeviceMoniker::ConstructKeyPath(
    TCHAR szPath[MAX_PATH],
    HKEY *phk)
{
    ASSERT(m_type == Software || m_type == ClassMgr);
    USES_CONVERSION;

    TCHAR *szPathStart = szPath;
    const TCHAR *sz = W2CT(m_sz);

    if(m_type == Software)
    {
        static const TCHAR szClsid[] = TEXT("CLSID\\");
        lstrcpy(szPath, szClsid);
        szPath += NUMELMS(szClsid) - 1;

        lstrcpyn(szPath, sz, CHARS_IN_GUID);
        szPath += CHARS_IN_GUID - 1;

        static const TCHAR szInstace[] = TEXT("\\Instance\\");
        lstrcpy(szPath, szInstace);
        szPath += NUMELMS(szInstace) - 1;

        *phk = HKEY_CLASSES_ROOT;
    }
    else
    {
        lstrcpy(szPath, g_szCmRegPath);
        szPath += NUMELMS(g_szCmRegPath) - 1;

        *szPath++ = TEXT('\\');

        lstrcpyn(szPath, sz, CHARS_IN_GUID);
        szPath += CHARS_IN_GUID - 1;

        *szPath++ = TEXT('\\');

        *phk = g_hkCmReg;
    }

    if(lstrlen(sz) > CHARS_IN_GUID) {
        lstrcpyn(szPath, sz + CHARS_IN_GUID, MAX_PATH - (LONG)(szPath - szPathStart));
    }

}

#include "fil_data.h"
#include "fil_data_i.c"

HRESULT CDeviceMoniker::DmoRead(
    LPCOLESTR pszPropName, LPVARIANT pVar)
{
    bool  InitDmo();
    if(!InitDmo()) {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    if(lstrcmpiW(pszPropName, L"FriendlyName") == 0 &&
       (pVar->vt == VT_EMPTY || pVar->vt == VT_BSTR))
    {
        WCHAR szName[80];       // !!!
        CLSID clsid;
        WCHAR szTemp[CHARS_IN_GUID];
        szTemp[CHARS_IN_GUID - 1] = 0;
        CopyMemory(szTemp, m_sz, sizeof(szTemp) - sizeof(WCHAR));
        hr = CLSIDFromString(szTemp, &clsid);
        if(SUCCEEDED(hr))
        {
            hr = g_pDMOGetName(clsid, szName);
        }
        if(SUCCEEDED(hr))
        {
            pVar->bstrVal = SysAllocString(szName);
            pVar->vt = VT_BSTR;

            if(pVar->bstrVal == 0) {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else if(lstrcmpiW(pszPropName, L"FilterData") == 0 &&
            (pVar->vt == VT_EMPTY || pVar->vt == (VT_UI1 | VT_ARRAY)))
    {
        USES_CONVERSION;
        CLSID clsid;
        WCHAR szTemp[CHARS_IN_GUID];
        szTemp[CHARS_IN_GUID - 1] = 0;
        CopyMemory(szTemp, m_sz, sizeof(szTemp) - sizeof(WCHAR));
        hr = CLSIDFromString(szTemp, &clsid);
        ULONG ulIn, ulOut;
        DMO_PARTIAL_MEDIATYPE dmoMtIn[10], dmoMtOut[10];
        if(SUCCEEDED(hr))
        {
            hr = g_pDMOGetTypes(clsid, 10, &ulIn, dmoMtIn, 10, &ulOut, dmoMtOut);
        }

        //  Try to get the merit from the CLSID key
        DWORD dwMerit = MERIT_NORMAL + 0x800;
        CRegKey rkCLSID;
        TCHAR szClsidPath[MAX_PATH];
        lstrcpy(szClsidPath, TEXT("clsid\\"));
        lstrcat(szClsidPath, W2T(szTemp));
        LONG lRc = rkCLSID.Open(HKEY_CLASSES_ROOT, szClsidPath, KEY_READ);
        if (ERROR_SUCCESS == lRc) {
            rkCLSID.QueryValue(dwMerit, TEXT("Merit"));
        }
        if(SUCCEEDED(hr))
        {
            IAMFilterData *pfd;
            hr = CoCreateInstance(
                CLSID_FilterMapper,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IAMFilterData,
                (void **)&pfd);

            if(SUCCEEDED(hr))
            {
                REGPINTYPES *rgrptIn = (REGPINTYPES *)_alloca(ulIn * sizeof(REGPINTYPES));
                for(UINT i = 0; i < ulIn; i++)
                {
                    rgrptIn[i].clsMajorType = &dmoMtIn[i].type;
                    rgrptIn[i].clsMinorType = &dmoMtIn[i].subtype;
                }

                REGPINTYPES *rgrptOut = (REGPINTYPES *)_alloca(ulOut * sizeof(REGPINTYPES));
                for(i = 0; i < ulOut; i++)
                {
                    rgrptOut[i].clsMajorType = &dmoMtOut[i].type;
                    rgrptOut[i].clsMinorType = &dmoMtOut[i].subtype;
                }

                REGFILTERPINS2 rfpIn, rfpOut;
                ZeroMemory(&rfpIn, sizeof(rfpIn));
                ZeroMemory(&rfpOut, sizeof(rfpOut));

                rfpIn.dwFlags = 0;
                rfpIn.nMediaTypes = ulIn;
                rfpIn.lpMediaType = rgrptIn;

                rfpOut.dwFlags = REG_PINFLAG_B_OUTPUT;
                rfpOut.nMediaTypes = ulOut;
                rfpOut.lpMediaType = rgrptOut;

                REGFILTERPINS2 rgrfp2[2];
                rgrfp2[0] = rfpIn;
                rgrfp2[1] = rfpOut;

                REGFILTER2 rf2;
                rf2.dwVersion = 2;
                rf2.dwMerit = dwMerit;

                // no correspondence between pins and types, so just
                // make two pins to represent input & output types.
                rf2.cPins = 2;
                rf2.rgPins2 = rgrfp2;

                ULONG cbData;
                BYTE *pbData = 0;
                hr = pfd->CreateFilterData(&rf2, &pbData, &cbData);

                if(SUCCEEDED(hr))
                {
                    hr = VariantArrayHelper(pVar, pbData, cbData);
                }

                pfd->Release();
                if(pbData) {
                    CoTaskMemFree(pbData);
                }
            }
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}

bool CDeviceMoniker::IsActive()
{
    bool fRet = false;
    if(m_type == PnP)
    {
        CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
        if(pEnumPnp)
        {
            fRet = pEnumPnp->IsActive(m_sz);
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\cmgrbase.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _ClassManagerBase_H
#define _ClassManagerBase_H

#include "resource.h"

class CClassManagerBase :
    public ICreateDevEnum
// public ISupportErrorInfo
{
public:
    CClassManagerBase(const TCHAR *szUniqueName);
    ~CClassManagerBase() {}

protected:
    virtual HRESULT ReadLegacyDevNames() = 0;
    BOOL VerifyRegistryInSync(IEnumMoniker *pEnum);

    // override one of the two. the first one lets you read whatever
    // you need from the propertybag. the second one reads
    // m_szUniqueName for you.
    virtual BOOL MatchString(IPropertyBag *pPropBag);
    virtual BOOL MatchString(const TCHAR *szDevName);

    virtual HRESULT CreateRegKeys(IFilterMapper2 *pFm2) = 0;

    virtual BOOL CheckForOmittedEntries() { return FALSE; }

    LONG m_cNotMatched;
    const TCHAR *m_szUniqueName;
    bool m_fDoAllDevices;  // Set by CreateClassEnumerator

private:
    STDMETHODIMP CreateClassEnumerator(
        REFCLSID clsidDeviceClass,
        IEnumMoniker ** ppEnumMoniker,
        DWORD dwFlags);

//     // ISupportsErrorInfo
//     STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
};


// remove all class manager entries and create the key if it wasn't
// there.
HRESULT ResetClassManagerKey(
    REFCLSID clsidCat);

// register the filter through IFilterMapper2 and return the moniker
HRESULT RegisterClassManagerFilter(
    IFilterMapper2 *pfm2,
    REFCLSID clsidFilter,
    LPCWSTR szName,
    IMoniker **ppMonikerOut,
    const CLSID *clsidCategory,
    LPCWSTR szInstance,
    REGFILTER2 *prf2);

#endif // _ClassManagerBase_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\devmon.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef _DEVMON_H
#define _DEVMON_H

#include "resource.h"       // main symbols
#include "mkenum.h"
#include "cenumpnp.h"
#include "isactive.h"

#include <dmodshow.h>
#include <dmoreg.h>

typedef HRESULT (STDAPICALLTYPE *PDMOEnum)(
   REFGUID guidCategory,
   DWORD dwFlags,
   DWORD cInTypes,
   const DMO_PARTIAL_MEDIATYPE *pInTypes, 
   DWORD cOutTypes,
   const DMO_PARTIAL_MEDIATYPE *pOutTypes,
   IEnumDMO **ppEnum);

typedef HRESULT (STDAPICALLTYPE *PDMOGetName)(
   REFCLSID clsidDMO,
   WCHAR szName[80]
);

typedef HRESULT (STDAPICALLTYPE *PDMOGetTypes)(
   REFCLSID clsidDMO,
   unsigned long ulInputTypesRequested,
   unsigned long *pulInputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pInputTypes,
   unsigned long ulOutputTypesRequested,
   unsigned long *pulOutputTypesSupplied,
   DMO_PARTIAL_MEDIATYPE *pOutputTypes
);

class CDeviceMoniker :
  public IMoniker,
  public IPropertyBag,
  public IParseDisplayName,
  public CIsActive,
  public CComObjectRootEx<CComMultiThreadModelNoCS>,
  public CComCoClass<CDeviceMoniker,&CLSID_CDeviceMoniker>
{
    // cached thing on which we call CoCreateInstance
    CLSID m_clsidDeviceClass;

    WCHAR *m_szPersistName;

    enum DevType {
        Software,               // registered directly
        ClassMgr,               // through class manager
        PnP,                    // through SetupApi
        Dmo,                    // through DMO enumeration
        Invalid
    };
    DevType m_type;

    // pointer to m_szPersistName that contains the useful part
    WCHAR *m_sz;

    HRESULT RegConvertToVariant(VARIANT *pvar, HKEY hk, const TCHAR *szProp);

    HRESULT GetPnpEnum();

    void ConstructKeyPath(TCHAR szPath[MAX_PATH], HKEY *phk);
    HRESULT DmoRead(LPCOLESTR pszPropName, LPVARIANT pVar);

public:
    CDeviceMoniker();

    HRESULT Init(LPCWSTR pszPersistName);
    ~CDeviceMoniker();

    BEGIN_COM_MAP(CDeviceMoniker)
        COM_INTERFACE_ENTRY(IMoniker)
        COM_INTERFACE_ENTRY(IPersist)
        COM_INTERFACE_ENTRY(IPersistStream)
        COM_INTERFACE_ENTRY(IPropertyBag)
        COM_INTERFACE_ENTRY(IParseDisplayName)
        COM_INTERFACE_ENTRY_IID(CLSID_CDeviceMoniker, CDeviceMoniker)
        COM_INTERFACE_ENTRY_IID(CLSID_CIsActive, CIsActive)
    END_COM_MAP()
    DECLARE_NOT_AGGREGATABLE(CDeviceMoniker) //!!!
//    bug in ATL 2.1 requires admin priv. on NT for this to work
//    DECLARE_REGISTRY(CCreateSwEnum, _T("device.1"), _T("device"), IDS_DEVICEMONIKER_DESC, THREADFLAGS_BOTH)
    // x86 specific entries done here.
#ifdef WIN64
    DECLARE_NO_REGISTRY();
#else
    DECLARE_REGISTRY_RESOURCEID(IDR_REGISTRY_X86)
#endif
    DECLARE_GET_CONTROLLING_UNKNOWN();

    // *** IPersist methods ***
    STDMETHOD(GetClassID)(
        CLSID * pClassID);

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) ();

    STDMETHOD(Load)(
        IStream * pStream);

    STDMETHOD(Save) (
        IStream * pStream,
        BOOL      fClearDirty);

    STDMETHOD(GetSizeMax)(
        ULARGE_INTEGER * pcbSize);

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID    iidResult,
        void **   ppvResult);

    STDMETHOD(BindToStorage) (
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID    riid,
        void **   ppv);

    STDMETHOD(Reduce) (
        IBindCtx *  pbc,
        DWORD       dwReduceHowFar,
        IMoniker ** ppmkToLeft,
        IMoniker ** ppmkReduced);

    STDMETHOD(ComposeWith) (
        IMoniker * pmkRight,
        BOOL       fOnlyIfNotGeneric,
        IMoniker **ppmkComposite);

    STDMETHOD(Enum)(
        BOOL            fForward,
        IEnumMoniker ** ppenumMoniker);

    STDMETHOD(IsEqual)(
        IMoniker *pmkOther);

    STDMETHOD(Hash)(
        DWORD * pdwHash);

    STDMETHOD(IsRunning) (
        IBindCtx * pbc,
        IMoniker * pmkToLeft,
        IMoniker * pmkNewlyRunning);

    STDMETHOD(GetTimeOfLastChange) (
        IBindCtx * pbc,
        IMoniker * pmkToLeft,
        FILETIME * pFileTime);

    STDMETHOD(Inverse)(
        IMoniker ** ppmk);

    STDMETHOD(CommonPrefixWith) (
        IMoniker *  pmkOther,
        IMoniker ** ppmkPrefix);

    STDMETHOD(RelativePathTo) (
        IMoniker *  pmkOther,
        IMoniker ** ppmkRelPath);

    STDMETHOD(GetDisplayName) (
        IBindCtx * pbc,
        IMoniker * pmkToLeft,
        LPWSTR   * lplpszDisplayName);

    STDMETHOD(ParseDisplayName) (
        IBindCtx *  pbc,
        IMoniker *  pmkToLeft,
        LPWSTR      lpszDisplayName,
        ULONG    *  pchEaten,
        IMoniker ** ppmkOut);

    STDMETHOD(IsSystemMoniker)(
        DWORD * pdwType);

    // IParseDisplayName
    STDMETHOD(ParseDisplayName) (
        IBindCtx *  pbc,
        LPWSTR      lpszDisplayName,
        ULONG    *  pchEaten,
        IMoniker ** ppmkOut);


    //   // *** IROTData Methods ***
    //     STDMETHOD(GetComparisonData)(
    //         byte * pbData,
    //         ULONG  cbMax,
    //         ULONG *pcbData);

    // IPropertyBag methods
    STDMETHOD(Read)(THIS_ LPCOLESTR pszPropName, LPVARIANT pVar,
                    LPERRORLOG pErrorLog);
    STDMETHOD(Write)(THIS_ LPCOLESTR pszPropName, LPVARIANT pVar);

    bool IsActive();
};

typedef CComObject<CDeviceMoniker> DevMon;

#endif // _DEVMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\icmco.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "icmco.h"
#include <vfw.h>
#include "util.h"

static const TCHAR g_szDriverClsid[] = TEXT("CLSID");
const TCHAR g_szIcmDriverIndex[] = TEXT("FccHandler");


#ifdef _WIN64
#error build error -- this is x86 only
#endif

CIcmCoClassManager::CIcmCoClassManager() :
        CClassManagerBase(g_szIcmDriverIndex),
        m_hmodMsvideo(0),
        m_rgIcmCo(0)
{
}

CIcmCoClassManager::~CIcmCoClassManager()
{
    delete[] m_rgIcmCo;

    if(m_hmodMsvideo)
    {
        FreeLibrary(m_hmodMsvideo);
    }
}

HRESULT CIcmCoClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;

    HRESULT hr = DynLoad();
    if(FAILED(hr))
        return hr;
    
    // count
    for (m_cCompressors = 0;; m_cCompressors++)
    {
        ICINFO icinfo;
        // docs wrong about return code
        if(m_pICInfo(ICTYPE_VIDEO, m_cCompressors, &icinfo) == ICERR_OK)
            break;
    }

    if(m_cCompressors == 0)
        return S_FALSE;

    delete[] m_rgIcmCo;
    m_rgIcmCo = new LegacyCo[m_cCompressors];
    if(m_rgIcmCo == 0)
        return E_OUTOFMEMORY;

    // save names
    for(UINT i = 0; i < m_cCompressors; i++)
    {
        ICINFO icinfo;
        if(m_pICInfo(ICTYPE_VIDEO, i, &icinfo) != ICERR_OK)
        {
            m_rgIcmCo[i].fccHandler = icinfo.fccHandler;
        }
        else
        {
        }
    }

    m_cNotMatched = m_cCompressors;
    return S_OK;
}

BOOL CIcmCoClassManager::MatchString(const TCHAR *szDevName)
{
    for (UINT i = 0; i < m_cCompressors; i++)
    {
	USES_CONVERSION;
        DWORD dwFccHandler = *(DWORD UNALIGNED*)(T2CA(szDevName)); 
        if (dwFccHandler == m_rgIcmCo[i].fccHandler)
        {
            return TRUE;
        }

    }
    return FALSE;
}

HRESULT CIcmCoClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_VideoCompressorCategory);
    USES_CONVERSION;

    HRESULT hr =  ReadLegacyDevNames();
    if( FAILED( hr )) {
        // m_pICOpen could be null if ignored 
        return hr;
    }

    for (UINT i = 0; i < m_cCompressors; i++)
    {
        // is fccHandler unique?
        char szFccHandler[sizeof(DWORD) + 1];
        *(DWORD UNALIGNED *)szFccHandler = m_rgIcmCo[i].fccHandler;
        szFccHandler[sizeof(DWORD)] = 0;
        const WCHAR *wszUniq = A2CW(szFccHandler);
        WCHAR wszFriendlyName[MAX_PATH];
        *wszFriendlyName = 0;

        // assume codec is broken for some reason
        DWORD dwFlags = CLASS_MGR_OMIT;

        HIC hic = m_pICOpen(ICTYPE_VIDEO, m_rgIcmCo[i].fccHandler, ICMODE_QUERY);
        if(hic)
        {
            ICINFO icinfo;
            if(m_pICGetInfo(hic, &icinfo, sizeof(icinfo)) != 0)
            {
                lstrcpyW(wszFriendlyName, icinfo.szDescription);


                // mark codecs that can't compress
                HIC hicCompress = m_pICOpen(
                    ICTYPE_VIDEO,  m_rgIcmCo[i].fccHandler, ICMODE_COMPRESS);
                if(hicCompress)
                {
                    dwFlags = 0; // codec isn't broken after all
                    m_pICClose(hicCompress);
                }
                else
                {
                }

            }
                
            m_pICClose(hic);
        }

        const FOURCCMap fccSubtype(m_rgIcmCo[i].fccHandler);
        const AMOVIESETUP_MEDIATYPE sudAVICoTypeOut =  {
            &MEDIATYPE_Video,
            &fccSubtype };

        static const AMOVIESETUP_MEDIATYPE sudAVICoTypeIn =  {
            &MEDIATYPE_Video,
            &GUID_NULL };

        const AMOVIESETUP_PIN psudAVICoPins[] =
        {
            {
                L"Input"        // strName
                , FALSE         // bRendered
                , FALSE         // bOutput
                , FALSE         // bZero
                , FALSE         // bMany
                , &CLSID_NULL   // clsConnectsToFilter
                , 0             // strConnectsToPin
                , 1             // nTypes
                , &sudAVICoTypeIn } // lpTypes
            , { L"Output"       // strName
                , FALSE         // bRendered
                , TRUE          // bOutput
                , FALSE         // bZero
                , FALSE         // bMany
                , &CLSID_NULL   // clsConnectsToFilter
                , 0             // strConnectsToPin
                , 1             // nTypes
                , &sudAVICoTypeOut
            }
        };   // lpTypes

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = NUMELMS(psudAVICoPins);
        rf2.rgPins = psudAVICoPins;
        

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AVICo,
            wszFriendlyName,
            &pMoniker,
            &CLSID_VideoCompressorCategory,
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(wszUniq);
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(T2CW(g_szIcmDriverIndex), &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if(SUCCEEDED(hr))
                {
                    VARIANT var;
                    var.vt = VT_I4;
                    var.lVal = dwFlags;
                    hr = pPropBag->Write(g_wszClassManagerFlags, &var);
                }

                    

                pPropBag->Release();
            }
            pMoniker->Release();                
        }
    }
    

    return S_OK;
}


HRESULT CIcmCoClassManager::DynLoad()
{
    if(m_hmodMsvideo)
        return S_OK;
    
    m_hmodMsvideo = LoadLibrary(TEXT("msvfw32.dll"));
    if(m_hmodMsvideo == 0)
    {
        DWORD dwLastError = GetLastError();
        return HRESULT_FROM_WIN32(dwLastError);
    }

    if(
        (m_pICInfo = (PICInfo)GetProcAddress(m_hmodMsvideo, "ICInfo")) &&
        (m_pICOpen = (PICOpen)GetProcAddress(m_hmodMsvideo, "ICOpen")) &&
        (m_pICGetInfo = (PICGetInfo)GetProcAddress(m_hmodMsvideo, "ICGetInfo")) &&
        (m_pICClose = (PICClose)GetProcAddress(m_hmodMsvideo, "ICClose"))
        )
    {
        return S_OK;
    }
    else
    {
        DWORD dwLastError = GetLastError();
        FreeLibrary(m_hmodMsvideo);
        m_hmodMsvideo = 0;
        return HRESULT_FROM_WIN32(dwLastError);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\devenum.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// devenum.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//              To build a separate proxy/stub DLL, 
//              run nmake -f devenumps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "mkenum.h"
#include "devmon.h"
#include "vidcap.h"
#include "qzfilter.h"
#include "icmco.h"
#include "waveinp.h"
#include "cenumpnp.h"
#include "acmp.h"
#include "waveoutp.h"
#include "midioutp.h"

CComModule _Module;
extern OSVERSIONINFO g_osvi;
OSVERSIONINFO g_osvi;

// critical section used to reference count dlls, cached objects, etc.
CRITICAL_SECTION g_devenum_cs;

// mutex used for cross process registry synchronization for HKCU
HANDLE g_devenum_mutex = 0;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_SystemDeviceEnum, CCreateSwEnum)
  OBJECT_ENTRY(CLSID_CDeviceMoniker, CDeviceMoniker)
  OBJECT_ENTRY(CLSID_CQzFilterClassManager, CQzFilterClassManager)
#ifndef _WIN64
  OBJECT_ENTRY(CLSID_CIcmCoClassManager, CIcmCoClassManager)
  OBJECT_ENTRY(CLSID_CVidCapClassManager, CVidCapClassManager)
#endif
  OBJECT_ENTRY(CLSID_CWaveinClassManager, CWaveInClassManager)
  OBJECT_ENTRY(CLSID_CWaveOutClassManager, CWaveOutClassManager)
  OBJECT_ENTRY(CLSID_CMidiOutClassManager, CMidiOutClassManager)
  OBJECT_ENTRY(CLSID_CAcmCoClassManager, CAcmClassManager)
END_OBJECT_MAP()



/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);

            _ASSERTE(g_devenum_mutex == 0);

	    DbgInitialise(hInstance);
	    InitializeCriticalSection(&g_devenum_cs);

            g_osvi.dwOSVersionInfoSize = sizeof(g_osvi);
            BOOL f = GetVersionEx(&g_osvi);
            ASSERT(f);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
	    // We hit this ASSERT in NT setup
#ifdef DEBUG
	    if (_Module.GetLockCount() != 0) {
                DbgLog((LOG_ERROR, 0, TEXT("devenum object leak")));
            }
#endif
            if(g_devenum_mutex != 0)
            {
                BOOL f = CloseHandle(g_devenum_mutex);
                _ASSERTE(f);
            }
            delete CEnumInterfaceClass::m_pEnumPnp;
	    DeleteCriticalSection(&g_devenum_cs);
	    _Module.Term();
	    DbgTerminate();

	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

// remove dynamically generated filter registration info from a
// previous release when the dynamically discovered filters went in
// the same key as the statically registered ones. find and remove
// only the dynamically registered ones.
// 
void SelectiveDeleteCmgrKeys(const CLSID *pclsid, const TCHAR *szcmgrid)
{
    WCHAR wszClsid[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(*pclsid, wszClsid, CHARS_IN_GUID) == CHARS_IN_GUID);

    TCHAR szInstancePath[100];
    wsprintf(szInstancePath, TEXT("%s\\%ls\\%s"), TEXT("CLSID"), wszClsid, TEXT("Instance"));

    // must not use KEY_ALL_ACCESS (CRegKey's default) because on NT,
    // permissions are set so that KEY_ALL_ACCESS fails unless you are
    // administrator.
    CRegKey rkInstance;
    LONG lResult = rkInstance.Open(HKEY_CLASSES_ROOT, szInstancePath, MAXIMUM_ALLOWED);

    //if(lResult == ERROR_SUCCESS) {
    for(LONG iReg = 0; lResult == ERROR_SUCCESS; iReg++)
    {
	TCHAR szSubKey[MAX_PATH];
	DWORD dwcchszSubkey = NUMELMS(szSubKey);
	    
	lResult = RegEnumKeyEx(
	    rkInstance,
	    iReg,
	    szSubKey,
	    &dwcchszSubkey,
	    0,              // reserved
	    0,              // class string
	    0,              // class string size
	    0);             // lpftLastWriteTime
	if(lResult == ERROR_SUCCESS)
	{
	    CRegKey rkDev;
	    lResult = rkDev.Open(rkInstance, szSubKey, MAXIMUM_ALLOWED);
	    if(lResult == ERROR_SUCCESS)
	    {
		if(RegQueryValueEx(
		    rkDev,
		    szcmgrid,
		    0,          // reserved
		    0,          // type
		    0,          // lpData
		    0)          // cbData
		   == ERROR_SUCCESS)
		{
		    lResult = rkDev.Close();
		    ASSERT(lResult == ERROR_SUCCESS);

		    lResult = rkInstance.RecurseDeleteKey(szSubKey);

		    // delete could fail if permissions set funny, but
		    // we'll still break out of the loop
		    ASSERT(lResult == ERROR_SUCCESS);

		    // keys are now renumbered, so enumeration must
		    // restart. probably could just subtract 1
		    iReg = -1;
		}
	    }
	}
    } // for
}

// remove dynamically generated filter registration info from a
// previous release when the dynamically discovered filters went in
// the InstanceCm key under HKCR
//
// not strictly necessary since we no longer look here.
// 
void RemoveInstanceCmKeys(const CLSID *pclsid)
{
    HRESULT hr = S_OK;
    CRegKey rkClassMgr;

    TCHAR szcmgrPath[100];
    WCHAR wszClsidCat[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(*pclsid, wszClsidCat, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);
    wsprintf(szcmgrPath, TEXT("CLSID\\%ls"), wszClsidCat);
    
    LONG lResult = rkClassMgr.Open(
        HKEY_CLASSES_ROOT,
        szcmgrPath,
        KEY_WRITE);
    if(lResult == ERROR_SUCCESS)
    {
        rkClassMgr.RecurseDeleteKey(TEXT("InstanceCm"));
    }

    return;;
}
 

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, no typelib
    HRESULT hr = _Module.RegisterServer(FALSE);

    // we cannot use the .rgs file to write a version number because
    // we don't want to remove it on unregister, and there is no way
    // to tell the registrar to do that.
    //
    // note that we no longer look at the version number; we're just
    // more careful about which keys we delete (which is the only
    // thing that looks at the version # for now
    //
    // if we do remove it then uninstall, we register an old version
    // of devenum that may blow away 3rd party filters
    // 
    if(SUCCEEDED(hr))
    {
	CRegKey rkSysDevEnum;
	
	LONG lResult = rkSysDevEnum.Open(
            HKEY_CLASSES_ROOT, G_SZ_DEVENUM_PATH, MAXIMUM_ALLOWED);
	if(lResult == ERROR_SUCCESS)
	{
	    lResult = rkSysDevEnum.SetValue(DEVENUM_VERSION, TEXT("Version"));
        }

	if(lResult != ERROR_SUCCESS)
	{
	    hr = HRESULT_FROM_WIN32(lResult);
	}
    }

    if(SUCCEEDED(hr))
    {
	// if it was an IE4 install (v=0) then delete all of its class
	// manager keys. Class Manager now writes to a different
	// location and we don't want the ie4 entries to be
	// duplicates. ** actually we now just always delete what look
	// like class manager keys from the old location.


	static const struct {const CLSID *pclsid; const TCHAR *sz;} rgIE4KeysToPurge[] =
	{
#ifndef _WIN64
	    { &CLSID_VideoCompressorCategory,  g_szIcmDriverIndex },
	    { &CLSID_VideoInputDeviceCategory, g_szVidcapDriverIndex }, 
#endif
	    { &CLSID_LegacyAmFilterCategory,   g_szQzfDriverIndex },
	    { &CLSID_AudioCompressorCategory,  g_szAcmDriverIndex },
	    /* two in the Audio Renderer category */
	    { &CLSID_AudioRendererCategory,    g_szWaveoutDriverIndex },
	    { &CLSID_AudioRendererCategory,    g_szDsoundDriverIndex },
	    { &CLSID_AudioInputDeviceCategory, g_szWaveinDriverIndex },
	    { &CLSID_MidiRendererCategory,     g_szMidiOutDriverIndex }
	};

	for(int i = 0; i < NUMELMS(rgIE4KeysToPurge); i++)
	{
	    SelectiveDeleteCmgrKeys(
		rgIE4KeysToPurge[i].pclsid,
		rgIE4KeysToPurge[i].sz);

            RemoveInstanceCmKeys(rgIE4KeysToPurge[i].pclsid);

            // remove the current class manager key too, but that'll
            // be handled by the versioning.
            // ResetClassManagerKey(*rgIE4KeysToPurge[i].pclsid);
	}
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\icmco.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

#include <vfw.h>

static const cchIcDriverName = 16;

class CIcmCoClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CIcmCoClassManager,&CLSID_CIcmCoClassManager>
{
    struct LegacyCo
    {
        DWORD fccHandler;
    } *m_rgIcmCo;

    ULONG m_cCompressors;

    typedef BOOL(VFWAPI *PICInfo)(
        DWORD fccType, DWORD fccHandler, ICINFO FAR * lpicinfo);
    typedef HIC(VFWAPI *PICOpen)(
        DWORD fccType, DWORD fccHandler, UINT wMode);
    typedef LRESULT (VFWAPI *PICGetInfo)(
        HIC hic, ICINFO FAR *picinfo, DWORD cb);
    typedef LRESULT(VFWAPI *PICClose)(HIC hic);

    PICInfo m_pICInfo;
    PICOpen m_pICOpen;
    PICGetInfo m_pICGetInfo;
    PICClose m_pICClose;
    HMODULE m_hmodMsvideo;
    HRESULT DynLoad();

public:

    CIcmCoClassManager();
    ~CIcmCoClassManager();

    BEGIN_COM_MAP(CIcmCoClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CIcmCoClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
    BOOL CheckForOmittedEntries() { return TRUE; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\ksaudio.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef _KSAUDIO_H
#define _KSAUDIO_H

#define KSAUD_F_ENUM_WAVE_CAPTURE 0x0001
#define KSAUD_F_ENUM_WAVE_RENDER  0x0002

#include "cenumpnp.h"
#include "devmon.h"

// Pnp audio devices
struct KsProxyAudioDev
{
    GUID clsid;
    TCHAR *szName;
    LPTSTR lpstrDevicePath;
    DWORD dwMerit;
    IPropertyBag * pPropBag;
};


HRESULT BuildPnpAudDeviceList
(
    const CLSID **rgpclsidKsCat, 
    CGenericList<KsProxyAudioDev> &lstDev,
    DWORD dwFlags = 0
);

BOOL IsFilterWanted( DevMon * pDevMon, DWORD dwFlags );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\makefile.inc ===
$(O)\devenum.res: devenum.rgs dev_x86.rgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\isactive.h ===
// note this is not really a COM interface -- its methods are not
// stdcall.

struct CIsActive : public IUnknown {
    virtual bool IsActive() = 0;
};

static CLSID CLSID_CIsActive = { /* f6c8e5a4-86fc-43f4-a058-242b420af6b5 */
    0xf6c8e5a4,
    0x86fc,
    0x43f4,
    {0xa0, 0x58, 0x24, 0x2b, 0x42, 0x0a, 0xf6, 0xb5}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\ksaudio.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "ksaudio.h"

//--------------------------------------------------------------------------;
//
// BuildPnpAudDeviceList
//
// Add the correct ksproxy audio filters to the passed in DirectShow category.
//
//--------------------------------------------------------------------------;
HRESULT BuildPnpAudDeviceList
(
    const CLSID **rgpclsidKsCat, 
    CGenericList<KsProxyAudioDev> &lstDev,
    DWORD dwFlags
)
{
    HRESULT hr = S_OK;
    CEnumInternalState cenumState;
    for(;;)
    {
        WCHAR *wszDevicePath = 0;
        CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
        if(pEnumPnp)
        {
            hr = pEnumPnp->GetDevicePath(&wszDevicePath, rgpclsidKsCat, &cenumState);
            if( S_OK == hr )
            {
                IBaseFilter * pFilter = NULL;
                DevMon *pDevMon = new DevMon;
                if( pDevMon )
                {
                    // addref the moniker
                    pDevMon->AddRef();
                    
                    USES_CONVERSION;
                         
                    BOOL bUseFilter = FALSE;   
                    UINT cchDevicePath = lstrlenW(wszDevicePath) + sizeof("@device:pnp:");
                    WCHAR *wszPersistName = new WCHAR[cchDevicePath];
                    if(wszPersistName)
                    {
                        lstrcpyW(wszPersistName, L"@device:pnp:");
                        lstrcatW(wszPersistName, wszDevicePath);

                        ASSERT((UINT)lstrlenW(wszPersistName) == cchDevicePath - 1);

                        hr = pDevMon->Init(wszPersistName);
                        if( SUCCEEDED( hr ) )
                        {
                            bUseFilter = IsFilterWanted( pDevMon, dwFlags );
                            if( bUseFilter )
                            {                            
                                IPropertyBag * pPropBag;
                                hr = pDevMon->BindToStorage( 0, 0, IID_IPropertyBag, (void **)&pPropBag );
                                if (FAILED (hr))
                                {
                                    DbgLog((LOG_TRACE, 1, TEXT("ERROR: IMoniker::BindToStorage failed [0x%08lx]"), hr));
                                }
                                else
                                {
                                    KsProxyAudioDev *pksp = new KsProxyAudioDev;
                                    ZeroMemory( pksp, sizeof( KsProxyAudioDev ) );
                                    if( pksp )
                                    {
                                        VARIANT varFriendly, varDevPath;
                                        varFriendly.vt = VT_EMPTY;
                                        varDevPath.vt = VT_EMPTY;
                                        USES_CONVERSION;
                                    
                                        hr = pPropBag->Read( L"FriendlyName", &varFriendly, 0 );
                                        if( SUCCEEDED( hr ) )
                                        {   
                                            TCHAR szKsProxyFmt[100];
                                            int ret = LoadString(
                                            _Module.GetResourceInstance(), IDS_KSPREFIX,
                                            szKsProxyFmt, 100);
                                            ASSERT(ret);
                                            
                                            pksp->szName = new TCHAR[lstrlen( szKsProxyFmt ) + 
                                                                     lstrlen( W2T( varFriendly.bstrVal ) ) +
                                                                     1];
                                            if( pksp->szName )
                                            {    
                                                wsprintf( pksp->szName, szKsProxyFmt, W2T( varFriendly.bstrVal ) );
                                        
                                                hr = pPropBag->Read( L"DevicePath", &varDevPath, 0 ); 
                                                if( SUCCEEDED( hr ) )
                                                {    
                                                    UINT cch = lstrlen( W2T( varDevPath.bstrVal ) ) + 1;
                                                    pksp->lpstrDevicePath = new TCHAR[cch];
                                                    pksp->pPropBag = pPropBag;
                                                    pksp->dwMerit = MERIT_DO_NOT_USE;
                                                    pksp->clsid = CLSID_Proxy; // ksproxy clsid
                                                    lstrcpy(pksp->lpstrDevicePath, W2T( varDevPath.bstrVal ) );
                                                    SysFreeString( varDevPath.bstrVal );
                                            
                                                    if(!lstDev.AddTail(pksp)) {
                                                        hr = E_OUTOFMEMORY;
                                                    }
                                                }
                                            }                            
                                            else
                                            {
                                                hr = E_OUTOFMEMORY;
                                            }
                                            SysFreeString( varFriendly.bstrVal );
                                        }
                                        
                                        if( FAILED( hr ) )
                                        {
                                            pPropBag->Release();
                                            delete pksp;
                                        }                                            
                                    }                                        
                                }
                            }
                        }                            
                        delete[] wszPersistName;
                    }
                    pDevMon->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                delete[] wszDevicePath;
            }
            else
            {
                if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
                {
					hr = S_OK;
                } 
                // else error                        
				
                break;
            }

        }
        else
			hr = E_OUTOFMEMORY;
    }
         
    return hr;
}

//--------------------------------------------------------------------------;
//
// IsFilterWanted
//
// Query the ks filter to tell if it's of the desired type 
//
//--------------------------------------------------------------------------;
BOOL IsFilterWanted( DevMon * pDevMon, DWORD dwFlags )
{
    ASSERT( pDevMon );
    
    BOOL bWanted = FALSE;
    
    if( 0 == dwFlags ) // take anything
        bWanted =  TRUE;
    
    IBaseFilter * pFilter;
        
    HRESULT hr = pDevMon->BindToObject(0, 0, IID_IBaseFilter, (void**)&pFilter );
    if (SUCCEEDED(hr))
    {
        IEnumPins * pEnum;
        if( KSAUD_F_ENUM_WAVE_CAPTURE & dwFlags )
        {    
            //
            // for capture filters: 
            //      first look for an output capture pin, next
            //      look for wave audio as a supported type
            //
            HRESULT hr = pFilter->EnumPins( &pEnum );
            if( SUCCEEDED( hr ) )
            {
                for( ; !bWanted ; )
                {
                    IPin * pPin;
                    ULONG  ul;
            
                    hr = pEnum->Next(1,  &pPin, &ul );
                    if( S_OK != hr )
                    {
                        break;
                    }                        
                    else
                    {
                        DbgLog( ( LOG_TRACE
                                , 7
                                , TEXT( "CreateRegKeys(waveinp): checking ksaud filter for capture support..." ) ) );
                        PIN_DIRECTION dir;
                        hr = pPin->QueryDirection( &dir );
                        if( SUCCEEDED( hr ) && PINDIR_OUTPUT == dir)
                        {
                            IKsPropertySet * pKs;
                            GUID clsidPinCategory;
                            ULONG ulBytesReturned;
                            if (pPin->QueryInterface( IID_IKsPropertySet
                                                    , (void **)&pKs) == S_OK) 
                            {
                                hr = pKs->Get( AMPROPSETID_Pin
                                             , AMPROPERTY_PIN_CATEGORY
                                             , NULL
                                             , 0
                                             , &clsidPinCategory
                                             , sizeof( clsidPinCategory )
                                             , &ulBytesReturned );
                                if( SUCCEEDED( hr ) && 
                                    ( clsidPinCategory == PINNAME_CAPTURE ) )
                                {
                                    IEnumMediaTypes * pEnumMT;
                                    hr = pPin->EnumMediaTypes( &pEnumMT );
                                    if( SUCCEEDED( hr ) )
                                    {
                                        // 
                                        // if this pin enumerates Wave Audio then
                                        // it's the one we want
                                        //
                                        for( ; ; )
                                        {
                                            AM_MEDIA_TYPE *pMediaType = NULL;
                                            ULONG ulCount;
                        
                                            hr = pEnumMT->Next( 1, &pMediaType, &ulCount );  
                                            if( S_OK != hr )
                                            {
                                                break;
                                            }                                        
                                            else if( ( MEDIATYPE_Audio == pMediaType->majortype ) &&
                                                     ( FORMAT_WaveFormatEx == pMediaType->formattype ) )
                                            {
                                                DbgLog( ( LOG_TRACE
                                                    , 5
                                                    , TEXT( "CreateRegKeys(waveinp): found ks wave audio capture filter" ) ) );
                                                DeleteMediaType( pMediaType );
                                                bWanted = TRUE;
                                                break;
                                            }
                                            DeleteMediaType( pMediaType );
                                        }
                                        pEnumMT->Release();                                                                       
                                    }          
                                }
                                pKs->Release();
                            }            
                        }
                        pPin->Release();
                    }                    
                }                    
                pEnum->Release();
            }
        }
        pFilter->Release();            
    }
    else
        DbgLog((LOG_TRACE, 1, TEXT("ERROR: CreateRegKeys - BindToObject failed [0x%08lx]"), hr));
    
    return bWanted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\midioutp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "midioutp.h"
#include <vfw.h>
#include "util.h"

static const WCHAR g_wszDriverIndex[] = L"MidiOutId";
const TCHAR g_szMidiOutDriverIndex[] = TEXT("MidiOutId");

const AMOVIESETUP_MEDIATYPE
midiOpPinTypes = { &MEDIATYPE_Midi, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_PIN
midiOutOpPin = { L"Input"
               , TRUE    	   	// bRendered
               , FALSE		   // bOutput
               , FALSE		   // bZero
               , FALSE		   // bMany
               , &CLSID_NULL	   // clsConnectToFilter
               , NULL	           // strConnectsToPin
               , 1	           	// nMediaTypes
               , &midiOpPinTypes }; // lpMediaTypes

CMidiOutClassManager::CMidiOutClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_rgMidiOut(0)
{
}

CMidiOutClassManager::~CMidiOutClassManager()
{
    delete[] m_rgMidiOut;

}

HRESULT CMidiOutClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;

    HRESULT hr = S_OK;
    if (m_fDoAllDevices) {
        m_cMidiOut = midiOutGetNumDevs() + 1;	// leave room for "midiOut mapper"
    } else {
        m_cMidiOut = 1;
    }

    ASSERT(m_cMidiOut > 0);
    
    delete[] m_rgMidiOut;
    m_rgMidiOut = new LegacyMidiOut[m_cMidiOut];
    if(m_rgMidiOut == 0)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // save names
        const UINT cMidiOutPhysical = m_cMidiOut - 1;
        for(UINT i = 0; i < cMidiOutPhysical; i++)
        {
            MIDIOUTCAPS moCaps;

            if(midiOutGetDevCaps(i, &moCaps, sizeof(moCaps)) == MMSYSERR_NOERROR)
            {
                lstrcpy(m_rgMidiOut[i].szName, moCaps.szPname);
                m_rgMidiOut[i].dwMidiId = i;
                m_rgMidiOut[i].dwMerit = MERIT_DO_NOT_USE;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("midiOutGetDevCaps failed")));
                // leave room for the default one
                m_cMidiOut = i + 1;
                break;
            }
        }

        int ret = LoadString(
            _Module.GetResourceInstance(), IDS_MIDIOUTMAPPER,
            m_rgMidiOut[i].szName, MAXPNAMELEN);

        ASSERT(ret);

        m_rgMidiOut[i].dwMidiId = MIDI_MAPPER;
        m_rgMidiOut[i].dwMerit = MERIT_PREFERRED;
    }
    

    m_cNotMatched = m_cMidiOut;
    return hr;
}

BOOL CMidiOutClassManager::MatchString(const TCHAR *szDevName)
{
    for (UINT i = 0; i < m_cMidiOut; i++)
    {
	USES_CONVERSION;
        if (lstrcmp(m_rgMidiOut[i].szName, szDevName) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CMidiOutClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_MidiRendererCategory);

    USES_CONVERSION;

    ReadLegacyDevNames();
    for (DWORD i = 0; i < m_cMidiOut; i++)
    {
        const WCHAR *wszUniq = T2COLE(m_rgMidiOut[i].szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = m_rgMidiOut[i].dwMerit;
        rf2.cPins = 1;
        rf2.rgPins = &midiOutOpPin;

        IMoniker *pMoniker = 0;
        HRESULT hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AVIMIDIRender,
            wszUniq,
            &pMoniker,
            &CLSID_MidiRendererCategory,
            wszUniq,
            &rf2);

        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = m_rgMidiOut[i].dwMidiId;
                hr = pPropBag->Write(g_wszDriverIndex, &var);

                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    } // for

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\midioutp.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

class CMidiOutClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CMidiOutClassManager,&CLSID_CMidiOutClassManager>
{
    struct LegacyMidiOut
    {

	TCHAR szName[MAXPNAMELEN];
	DWORD dwMidiId;
	DWORD dwMerit;

    } *m_rgMidiOut;

    ULONG m_cMidiOut;

public:

    CMidiOutClassManager();
    ~CMidiOutClassManager();

    BEGIN_COM_MAP(CMidiOutClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CMidiOutClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\resource.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by devenum.rc
//
#define IDS_DEVICEMONIKER_DESC          6
#define IDS_DSOUNDDEFAULTDEVICE         7
#define IDS_DSOUNDPREFIX                8
#define IDS_WAVEOUTMAPPER               9
#define IDS_MIDIOUTMAPPER               10
#define IDS_KSMAPPER                    11
#define IDS_KSPREFIX                    12
#define IDR_REGISTRY                    202
#define IDR_REGISTRY_X86                203
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\mkenum.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// CreateSwEnum.h : Declaration of the CCreateSwEnum

#ifndef _MKENUM_H
#define _MKENUM_H

#include "resource.h"       // main symbols

#include "cenumpnp.h"
#include "devmon.h"

// flags for CreateClassEnumerator
static const DWORD CREATE_ENUM_OMITTED = 0x1;

class CCreateSwEnum : 
    public ICreateDevEnum,
    public CComObjectRoot,
    public CComCoClass<CCreateSwEnum,&CLSID_SystemDeviceEnum>
{
    typedef CComEnum<IEnumMoniker,
        &IID_IEnumMoniker, IMoniker*,
        _CopyInterface<IMoniker> >
    CEnumMonikers;
    
public:

BEGIN_COM_MAP(CCreateSwEnum)
    COM_INTERFACE_ENTRY(ICreateDevEnum)
    COM_INTERFACE_ENTRY_IID(CLSID_SystemDeviceEnum, CCreateSwEnum)
END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CCreateSwEnum) ;
    // Remove the comment from the line above if you don't want your object to 
    // support aggregation.  The default is to support it

    DECLARE_GET_CONTROLLING_UNKNOWN();

    // register all categories. x86 specific class managers done through devmon.h
    DECLARE_REGISTRY_RESOURCEID(IDR_REGISTRY)

    // ICreateDevEnum
    STDMETHOD(CreateClassEnumerator)(REFCLSID clsidDeviceClass,
                                     IEnumMoniker ** ppEnumMoniker,
                                     DWORD dwFlags);

    // private method
    STDMETHOD(CreateClassEnumerator)(
        REFCLSID clsidDeviceClass,
        IEnumMoniker ** ppEnumMoniker,
        DWORD dwFlags,
        IEnumMoniker ** ppEnumClassMgrMonikers);

    CCreateSwEnum();

private:

#ifdef PERF
    int m_msrEnum;
    int m_msrCreateOneSw;
#endif

    ICreateDevEnum * CreateClassManager(REFCLSID clsidDeviceClass, DWORD dwFlags);

    // S_FALSE to signal no more items
    HRESULT CreateOnePnpMoniker(
        IMoniker **pDevMon,
        const CLSID **rgpclsidKsCat,
        CEnumInternalState *pcenumState);

    // S_FALSE to signal non-fatal error
    HRESULT CreateOneSwMoniker(
        IMoniker **pDevMon,
        HKEY hkClass,
	const TCHAR *szThisClass,
        DWORD iKey);

    HRESULT CreateSwMonikers(
        CComPtr<IUnknown> **prgpMoniker,
        UINT *pcMonikers,
	REFCLSID clsidDeviceClass);

    HRESULT CreateCmgrMonikers(
        CComPtr<IUnknown> **prgpMoniker,
        UINT *pcMonikers,
	REFCLSID clsidDeviceClass,
        CEnumMonikers **ppEnumMonInclSkipped,
        IMoniker **ppPreferred);

    HRESULT CreateOneCmgrMoniker(
        IMoniker **pDevMon,
        HKEY hkClass,
	const TCHAR *szThisClass,
        DWORD iKey,
        bool *pfShouldSkip,
        bool *pfIsDefaultDevice);        

    HRESULT CreatePnpMonikers(
        CGenericList<IMoniker> *plstMoniker,
	REFCLSID clsidDeviceClass);

    HRESULT CreateDmoMonikers(
        CGenericList<IMoniker> *plstMoniker,
	REFCLSID clsidDeviceClass);

    CEnumPnp *m_pEnumPnp;
};


#endif // _MKENUM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\qzfilter.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "qzfilter.h"
#include "util.h"

#ifdef DEBUG
static void DbgValidateHeaps()
{
  HANDLE rgh[512];
  DWORD dwcHeaps = GetProcessHeaps(512, rgh);
  for(UINT i = 0; i < dwcHeaps; i++)
    ASSERT(HeapValidate(rgh[i], 0, 0) );
}
#else
static inline void DbgValidateHeaps()
{
}
#endif




const TCHAR g_szQzfDriverIndex[] = TEXT("ClassManagerFlags");
static const WCHAR g_wszQzfDriverIndex[] = L"ClassManagerFlags";

static const TCHAR g_szFiltersReg[] = TEXT("Filter");

CQzFilterClassManager::CQzFilterClassManager() :
        CClassManagerBase(TEXT("CLSID")),
        m_rgFilters(0)
{
}

CQzFilterClassManager::~CQzFilterClassManager()
{
    delete[] m_rgFilters;
}

// to reduce registry access, don't read filter names if fReadNames is
// false.
HRESULT CQzFilterClassManager::ReadLegacyDevNames(BOOL fReadNames)
{
    HRESULT hr = S_OK;
    BOOL bAnyLegacy = FALSE;
    m_cNotMatched = 0;
    m_cFilters = 0;

    // can't use quartz mapper because it'll use us
    HKEY hkFilter;
    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT, g_szFiltersReg, 0, KEY_READ, &hkFilter);
    if(lResult == ERROR_SUCCESS)
    {
        DWORD cEntries;
        LONG lResult = RegQueryInfoKey(hkFilter, 0, 0, 0, &cEntries, 0, 0, 0, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            delete[] m_rgFilters;
            m_rgFilters = new LegacyFilter[cEntries];
            if(m_rgFilters)
            {
                for(UINT iRegEntry = 0; iRegEntry < cEntries; iRegEntry++)
                {
                    LegacyFilter *pLf = &m_rgFilters[m_cFilters];

                    LONG lResult = RegEnumKey(
                        hkFilter, iRegEntry, pLf->szClsid, sizeof(pLf->szClsid));

                    if(lResult == ERROR_SUCCESS)
                    {
                        if(IsInvisibleInstanceKey(pLf->szClsid))
                        {
                            DbgLog((
                                LOG_TRACE, 10,
                                TEXT("CQzFilterClassManager: ReadLegacyDevNames: Skipping %s"),
                                pLf->szClsid));

                            continue;
                        }

                        // don't want the class manager to override
                        // anything registered directly
                        if(!IsNativeInInstanceKey(pLf->szClsid))
                        {
                            DbgLog((
                                LOG_TRACE, 10,
                                TEXT("CQzFilterClassManager: ReadLegacyDevNames: %s"),
                                pLf->szClsid));

                            bAnyLegacy = TRUE;
                            pLf->bNotMatched = TRUE;
                            ASSERT(pLf->szName == 0);

                            // see if this filter really exists in the
                            // CLSID\XXX. otherwise the filter
                            // migration code fails and the registry
                            // is perpetually out of sync. this
                            // doesn't fix all failures migrating
                            // registry keys.
                            //
                            HKEY hkPerhapsBogus = NULL;
                            TCHAR FilterCLSID[_MAX_PATH];
                            lstrcpy( FilterCLSID, TEXT("CLSID\\"));
                            lstrcat( FilterCLSID, pLf->szClsid );
                            LONG llll = RegOpenKeyEx( HKEY_CLASSES_ROOT, FilterCLSID, 0, KEY_READ, &hkPerhapsBogus );
                            if( llll != ERROR_SUCCESS )
                            {
                                DbgLog((
                                    LOG_TRACE, 10,
                                    TEXT("CQzFilterClassManager: ReadLegacyDevNames: could not read %s"), FilterCLSID ));
                                continue;
                            }
                            else
                            {
                                RegCloseKey( hkPerhapsBogus );
                            }

                            if(fReadNames)
                            {

                                HKEY hkEntry;
                                LONG lResult = RegOpenKeyEx(
                                    hkFilter, pLf->szClsid, 0,
                                    KEY_READ, &hkEntry);
                                if(lResult == ERROR_SUCCESS)
                                {
                                    TCHAR szName[MAX_PATH];
                                    DWORD dwType, dwcbRead = sizeof(szName);

                                    LONG lResult = RegQueryValueEx(
                                        hkEntry, 0, 0,
                                        &dwType, (BYTE *)szName, &dwcbRead);
                                    if(lResult == ERROR_SUCCESS)
                                    {
                                        pLf->szName = new TCHAR[dwcbRead];
                                        if(pLf->szName)
                                            lstrcpy(pLf->szName, szName);
                                        DbgLog((
                                            LOG_TRACE, 10,
                                            TEXT("CQzFilterClassManager: ReadLegacyDevNames: %s"),
                                            szName));
                                    }
                                    RegCloseKey(hkEntry);
                                }
                            } // fReadNames

                            m_cFilters++;
                        } // native
                        else
                        {
                            DbgLog((LOG_TRACE, 5,
                                    TEXT("CQzFilterClassManager: skipping native %s"),
                                    pLf->szClsid));
                        }
                    }
                    else
                    {
                        break;
                    }
                } // for
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        RegCloseKey(hkFilter);
    }

    m_cNotMatched = m_cFilters;

    return bAnyLegacy ? S_OK : S_FALSE;
}

// called by the base class
HRESULT CQzFilterClassManager::ReadLegacyDevNames()
{
    // don't read filter names
    return ReadLegacyDevNames(FALSE);
}


BOOL CQzFilterClassManager::MatchString(const TCHAR *szDevName)
{
    for(UINT iFilter = 0; iFilter < m_cFilters; iFilter++)
    {
        if(m_rgFilters[iFilter].bNotMatched &&
           lstrcmpi(m_rgFilters[iFilter].szClsid, szDevName) == 0)
        {
            m_rgFilters[iFilter].bNotMatched = FALSE;
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CQzFilterClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_LegacyAmFilterCategory);

    USES_CONVERSION;

    // do read filter names
    HRESULT hr = ReadLegacyDevNames(TRUE);
    if(hr == S_OK)
    {
        for(UINT iFilter = 0; iFilter < m_cFilters; iFilter++)
        {
            IMoniker *pMoniker = 0;
            LegacyFilter *pLf = &m_rgFilters[iFilter];
            hr = MigrateFilter(pFm2, pLf->szClsid, &pMoniker);
            if(SUCCEEDED(hr))
            {
                // write out class manager key so that we can tell
                // whether this filter was migrated or not.
                IPropertyBag *pPropBag;
                hr = pMoniker->BindToStorage(
                    0, 0, IID_IPropertyBag, (void **)&pPropBag);
                if(SUCCEEDED(hr))
                {
                    VARIANT var;
                    var.vt = VT_I4;
                    var.lVal = 0;
                    hr = pPropBag->Write(g_wszQzfDriverIndex, &var);

                    pPropBag->Release();
                }
                pMoniker->Release();
            }
        }
    }

    return S_OK;
}


#define MAX_STR_LEN 256

//
// Copy the filter info from hkcr/{filter_clsid} to the new data block
// value
//

HRESULT CQzFilterClassManager::MigrateFilter(
    IFilterMapper2 *pFm2,
    const TCHAR *szclsid,
    IMoniker **ppMoniker)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;

    TCHAR szFilterName[MAX_PATH];
    CRegFilterPin *rgRfp = 0;
    ULONG cPins = 0;

    TCHAR szTmp[MAX_PATH];
    lstrcpy(szTmp, TEXT("clsid\\"));
    lstrcat(szTmp, szclsid);

    CRegKey rkFilter;

    LONG lResult = rkFilter.Open(HKEY_CLASSES_ROOT, szTmp, KEY_READ);
    if(lResult == ERROR_SUCCESS)
    {

        // default to MERIT_NORMAL for compatibility with 1.0
        DWORD dwMerit = MERIT_NORMAL;
        rkFilter.QueryValue(dwMerit, TEXT("Merit"));

        // filter name (default to clsid string)
        DWORD dwcbszFilterName = sizeof(szFilterName);
        if(rkFilter.QueryValue(szFilterName, TEXT(""), &dwcbszFilterName) != ERROR_SUCCESS)
            lstrcpy(szFilterName, szclsid);

        CRegKey rkPins;
        if(rkPins.Open(rkFilter, TEXT("pins"), KEY_READ) == ERROR_SUCCESS)
        {
            lResult = RegQueryInfoKey(rkPins, 0, 0, 0, &cPins, 0, 0, 0, 0, 0, 0, 0);
            if(lResult == ERROR_SUCCESS)
            {
                rgRfp = new CRegFilterPin[cPins];
                if(rgRfp)
                {
                    lResult = MigrateFilterPins(cPins, rgRfp, rkPins);
                }
                else
                {
                    lResult = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }


        CLSID clsidFilter;
        if(lResult == ERROR_SUCCESS &&
           ((hr = CLSIDFromString((WCHAR *) T2CW(szclsid), &clsidFilter)) == S_OK))
        {

            REGFILTER2 rf2;
            rf2.dwVersion = 1;
            rf2.dwMerit = dwMerit;
            rf2.cPins = cPins;
            rf2.rgPins = rgRfp;

            *ppMoniker = 0; // 0 means return a moniker
            hr = RegisterClassManagerFilter(
                pFm2,
                clsidFilter,
                T2CW(szFilterName),
                ppMoniker,
                &CLSID_LegacyAmFilterCategory,
                NULL, // instance key
                &rf2);

            DbgLog((
                LOG_TRACE, 10,
                TEXT("CQzFilterClassManager::MigrateFilter: %08x, %s, ")
                TEXT("merit %08x, cPins %d"),
                clsidFilter.Data1, szFilterName, dwMerit, cPins));
        }

        delete[] rgRfp;
    }
    else
    {
        DbgLog((
            LOG_TRACE, 10,
            TEXT("CQzFilterClassManager::MigrateFilter failed to open key %s"),
            szTmp
            ));
    }

    return (lResult == ERROR_SUCCESS) ? hr :  HRESULT_FROM_WIN32(lResult);;
}

LONG CQzFilterClassManager::MigrateFilterPins(
    ULONG cPins, REGFILTERPINS *rgRfp, CRegKey &rkPins)
{
    USES_CONVERSION;
    LONG lResult = ERROR_SUCCESS;

    for(UINT iPin = 0; iPin < cPins; iPin++)
    {
        REGFILTERPINS *pRfp = &rgRfp[iPin];
        TCHAR strPin[MAX_STR_LEN];     // name of pin
        DWORD dwLen = NUMELMS(strPin);

        lResult = RegEnumKeyEx(rkPins, iPin, strPin, &dwLen, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            // do one pin

            CRegKey rkPin;
            lResult = rkPin.Open(rkPins, strPin, KEY_READ);
            if(lResult == ERROR_SUCCESS)
            {
                // do the flags
                DWORD dwRenderered = 0, dwOutput = 0, dwZero = 0, dwMany = 0;
                rkPin.QueryValue(dwRenderered, TEXT("IsRendered"));
                rkPin.QueryValue(dwOutput, TEXT("Direction"));
                rkPin.QueryValue(dwZero, TEXT("AllowedZero"));
                rkPin.QueryValue(dwMany, TEXT("AllowedMany"));
                // ignore errors (except direction?)

                pRfp->bRendered = dwRenderered;
                pRfp->bOutput = dwOutput; // 0 is input
                pRfp->bZero = dwZero;
                pRfp->bMany = dwMany;

                pRfp->strConnectsToPin = 0;
                TCHAR szConnectsTo[MAX_STR_LEN];
                ULONG cb = sizeof(szConnectsTo);
                if(rkPin.QueryValue(szConnectsTo, TEXT("ConnectsToPin"), &cb) == ERROR_SUCCESS)
                {
                    pRfp->strConnectsToPin = new WCHAR[lstrlen(szConnectsTo) + 1];
                    if(pRfp->strConnectsToPin)
                    {
                        lstrcpyW((WCHAR *)(pRfp->strConnectsToPin), T2W(szConnectsTo));
                    }
                    else
                    {
                        lResult = ERROR_OUTOFMEMORY;
                    }
                }
            }

            if(lResult == ERROR_SUCCESS)
            {
                pRfp->clsConnectsToFilter = new GUID;
                if(pRfp->clsConnectsToFilter)
                {
                    TCHAR szConnectsTo[CHARS_IN_GUID];
                    ULONG cb = sizeof(szConnectsTo);

                    *(GUID *)pRfp->clsConnectsToFilter = GUID_NULL;
                    if(rkPin.QueryValue(szConnectsTo, TEXT("ConnectsToFilter"), &cb) == ERROR_SUCCESS)
                    {
                        CLSIDFromString(T2W(szConnectsTo), (GUID *)pRfp->clsConnectsToFilter);
                    }
                }
                else
                {
                    lResult = E_OUTOFMEMORY;
                }
            }

            if(lResult == ERROR_SUCCESS)
            {
                pRfp->strName = new WCHAR[lstrlen(strPin) + 1];
                if(pRfp->strName)
                {
                    lstrcpyW(pRfp->strName, T2W(strPin));
                }
                else
                {
                    lResult = ERROR_OUTOFMEMORY;
                }
            }

            if(lResult == ERROR_SUCCESS)
            {
                ULONG cTypes;
                REGPINTYPES *rgrpt;
                lResult = MigratePinTypes(rkPin, &rgrpt, &cTypes);
                if(lResult == ERROR_SUCCESS)
                {
                    pRfp->lpMediaType = rgrpt;
                    pRfp->nMediaTypes = cTypes;
                }
            }

            DbgLog((
                LOG_TRACE, 10,
                TEXT("CQzFilterClassManager::MigrateFilterPins: strName: %s, ")
		TEXT("bRendered: %d, bOutput: %d, bZero: %d, bMany: %d, ")
		TEXT("clsConnectsToFilter: %08x, strConnectsToPin: %S, nMediaTypes: %d"),
                pRfp->strName, pRfp->bRendered, pRfp->bOutput, pRfp->bZero, pRfp->bMany,
                pRfp->clsConnectsToFilter->Data1,
                pRfp->strConnectsToPin ? pRfp->strConnectsToPin : L"",
                pRfp->nMediaTypes));
        }

        if(lResult != ERROR_SUCCESS)
        {
            break;
        }
    } // for

    return lResult;
}

LONG CQzFilterClassManager::MigratePinTypes(CRegKey &rkPin, REGPINTYPES **prgrpt, ULONG *pct)
{
    const ULONG MAX_MINOR_TYPES = 100;
    REGPINTYPES *rgRpt = 0;
    ULONG iMediaType = 0; // maj-min pair index
    LONG lResult = ERROR_SUCCESS;
    USES_CONVERSION;

    CRegKey rkTypes;
    if(ERROR_SUCCESS == rkTypes.Open(rkPin, TEXT("Types"), KEY_READ))
    {
        ULONG cMajorTypes;
        lResult = RegQueryInfoKey(rkTypes, 0, 0, 0, &cMajorTypes, 0, 0, 0, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            // assume a max of 100 minor types per major type.
            rgRpt = new REGPINTYPES[cMajorTypes * MAX_MINOR_TYPES];
            if(rgRpt)
            {
                ZeroMemory(rgRpt, sizeof(REGPINTYPES) * cMajorTypes * MAX_MINOR_TYPES);

                for(UINT iMajorType = 0; iMajorType < cMajorTypes; iMajorType++)
                {
                    TCHAR szClsidMajor[CHARS_IN_GUID];
                    DWORD dwLen = sizeof(szClsidMajor) / sizeof(TCHAR);
                    lResult = RegEnumKeyEx(rkTypes, iMajorType, szClsidMajor, &dwLen, 0, 0, 0, 0);
                    if(lResult == ERROR_SUCCESS)
                    {
                        CLSID clsMajor;
                        if(CLSIDFromString(T2W(szClsidMajor), &clsMajor) == S_OK)
                        {
                            CRegKey rkMajorType;
                            lResult = rkMajorType.Open(rkTypes, szClsidMajor, KEY_READ);
                            if(lResult == ERROR_SUCCESS)
                            {
                                for(ULONG iMinorType = 0; iMinorType < MAX_MINOR_TYPES; iMinorType++)
                                {
                                    TCHAR szClsidMinor[CHARS_IN_GUID];
                                    DWORD dwLen = sizeof(szClsidMinor) / sizeof(TCHAR);

                                    lResult = RegEnumKeyEx(rkMajorType, iMinorType, szClsidMinor, &dwLen, 0, 0, 0, 0);
                                    if(lResult == ERROR_SUCCESS)
                                    {
                                        CLSID clsMinor;
                                        if(CLSIDFromString(T2W(szClsidMinor), &clsMinor) == S_OK)
                                        {
                                            rgRpt[iMediaType].clsMajorType = new CLSID;
                                            rgRpt[iMediaType].clsMinorType = new CLSID;
                                            if(rgRpt[iMediaType].clsMajorType && rgRpt[iMediaType].clsMinorType)
                                            {
                                                *(GUID *)rgRpt[iMediaType].clsMajorType = clsMajor;
                                                *(GUID *)rgRpt[iMediaType].clsMinorType = clsMinor;
                                                iMediaType++;

                                                DbgLog((
                                                    LOG_TRACE, 10,
                                                    TEXT("CQzFilterClassManager::MigratePinTypes:")
						    TEXT("clsMaj: %08x, clsMin: %08x"),
                                                         clsMajor.Data1, clsMinor.Data1));
                                            }
                                            else
                                            {
                                                lResult = ERROR_OUTOFMEMORY;
                                            }
                                        }
                                        else
                                        {
                                            lResult = ERROR_INVALID_DATA;
                                        }
                                    }
                                    else
                                    {
                                        if(lResult == ERROR_NO_MORE_ITEMS)
                                        {
                                            lResult = ERROR_SUCCESS;
                                            break;
                                        }
                                    }


                                    if(lResult != ERROR_SUCCESS)
                                        break;
                                } // for
                            }
                        }
                        else
                        {
                            lResult = ERROR_INVALID_DATA;
                        }
                    }

                    if(lResult != ERROR_SUCCESS)
                        break;
                } // for loop
            }
            else
            {
                lResult = ERROR_OUTOFMEMORY;
            }
        }
    }

    if(lResult != ERROR_SUCCESS)
    {
        Del(rgRpt, iMediaType);
        rgRpt = 0;
        iMediaType = 0;

        // more useful errors: missing key means the registry isn't what
        // we expect
        if(lResult == ERROR_FILE_NOT_FOUND)
            lResult = ERROR_INVALID_DATA;
    }

    *prgrpt = rgRpt;
    *pct = iMediaType;

    return lResult;
}

void CQzFilterClassManager::Del(REGPINTYPES *rgRpt, ULONG cMediaTypes)
{
    if(rgRpt)
    {
        do
        {
            delete (void *) rgRpt[cMediaTypes].clsMajorType;
            delete (void *) rgRpt[cMediaTypes].clsMinorType;
        } while(cMediaTypes--);

        delete[] rgRpt;
    }
}

CRegFilterPin::CRegFilterPin()
{
    clsConnectsToFilter = 0;
    strConnectsToPin = 0;
    lpMediaType = 0;
    strName = 0;
    nMediaTypes = 0;
}

CRegFilterPin::~CRegFilterPin()
{
    delete (CLSID *)clsConnectsToFilter;
    delete[] (LPWSTR)strConnectsToPin;
    for(UINT iMt = 0; iMt < nMediaTypes; iMt++)
    {
        delete (CLSID *)lpMediaType[iMt].clsMinorType;
        delete (CLSID *)lpMediaType[iMt].clsMajorType;
    }

    delete[] (REGPINTYPES *)lpMediaType;
    delete[] (WCHAR *)strName;
}

// check if filter szClsid is a filter which we wish to mask and not enumerate
bool CQzFilterClassManager::IsInvisibleInstanceKey(const TCHAR *szClsid)
{
    bool fRet = false;
    USES_CONVERSION;   // atl string cvt

    CLSID clsidInstanceKey;
    if(CLSIDFromString((WCHAR *) T2CW(szClsid), &clsidInstanceKey) == S_OK)
    {
        fRet = clsidInstanceKey == CLSID_AVIMIDIRender ||
            clsidInstanceKey == CLSID_DSoundRender ||
            clsidInstanceKey == CLSID_AudioRender;
    }

    return fRet;
}

// check if filter szClsid registered directly in instance key
//
bool CQzFilterClassManager::IsNativeInInstanceKey(const TCHAR *szClsid)
{
    // check if CLSID\\{083*}\\Instance\\szClsid and ClassManagerFlags
    // value exist. !!! should use a moniker

    static const TCHAR szQzFilterClassRoot[] = TEXT(
     "CLSID\\{083863F1-70DE-11d0-BD40-00A0C911CE86}\\Instance");

    bool fResult = false;

    TCHAR szKey[MAX_PATH];
    // wsprintf("%s\\%s", szQzFilterClassRoot, szClsid)
    CopyMemory(szKey, szQzFilterClassRoot, sizeof(szQzFilterClassRoot) - sizeof(TCHAR));
    TCHAR *pch = szKey + NUMELMS(szQzFilterClassRoot) - 1;
    *(pch++) = TEXT('\\');
    CopyMemory(pch, szClsid, CHARS_IN_GUID * sizeof(TCHAR));

    HKEY hkInst;
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_READ, &hkInst) == ERROR_SUCCESS)
    {
        if(RegQueryValueEx(
            hkInst,
            g_szQzfDriverIndex,
            0,                  // reserved
            0,                  // type
            0,                  // data
            0) !=               // byte count
           ERROR_SUCCESS)
        {
            fResult = true;
        }
        RegCloseKey(hkInst);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\qzfilter.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"
#include "util.h"

class CQzFilterClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CQzFilterClassManager,&CLSID_CQzFilterClassManager>
{
    // legacy meaning doesn't support IPersistRegKey.
    struct LegacyFilter
    {
        LegacyFilter() { szName = 0; }
        ~LegacyFilter() { delete[] szName;}
        TCHAR szClsid[CCH_CLSID];
        TCHAR *szName;
        BOOL bNotMatched;
    } *m_rgFilters;

    ULONG m_cFilters;

    bool IsNativeInInstanceKey(const TCHAR *szClsid);
	bool IsInvisibleInstanceKey(const TCHAR *szClsid);

public:

    CQzFilterClassManager();
    ~CQzFilterClassManager();

    BEGIN_COM_MAP(CQzFilterClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CQzFilterClassManager);
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    HRESULT ReadLegacyDevNames(BOOL fReadNames);

    BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);

    HRESULT MigrateFilter(IFilterMapper2 *pFm2, const TCHAR *szclsid, IMoniker **ppMoniker);
    LONG MigrateFilterPins(ULONG cPins, REGFILTERPINS *rgRfp, CRegKey &rkPins);
    LONG MigratePinTypes(CRegKey &rkPin, REGPINTYPES **prgrpt, ULONG *pct);
    void Del(REGPINTYPES *rgRpt, ULONG cMediaTypes);
};

class CRegFilterPin : public REGFILTERPINS
{
public:
    CRegFilterPin();
    ~CRegFilterPin();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\mkenum.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// CreateDevEnum.cpp : Implementation of CdevenumApp and DLL registration.

#include "stdafx.h"
#include "mkenum.h"
#include "devmon.h"
#include "util.h"
#include "ks.h"
#include "ksmedia.h"

#include <mediaobj.h>
#include <dmoreg.h>

static const TCHAR g_szDriverDesc[] = TEXT("FriendlyName");
static const TCHAR g_szDriver[] = TEXT("Driver");
static const TCHAR g_szClsid[] = TEXT("CLSID");
const WCHAR g_wszClassManagerFlags[] = L"ClassManagerFlags";
const TCHAR g_szClassManagerFlags[] = TEXT("ClassManagerFlags");

// compiler bug prevents making this a static class member
PDMOEnum g_pDMOEnum = 0;

bool InitDmo();

CCreateSwEnum::CCreateSwEnum()
{
#ifdef PERF
    m_msrEnum = MSR_REGISTER(TEXT("CCreateSwEnum"));
    m_msrCreateOneSw = MSR_REGISTER(TEXT("CreateOneSwMoniker"));
#endif

    // get a refcounted setupapi.dll so we don't keep loading and
    // unloading it. we can't just load setupapi in DllEntry because
    // of the win95 bug freeing libraries in DETACH
    m_pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();

    // see if a new version of devenum.dll was installed since the
    // current user last enumerated devices.
    //
    // do this here because this is run less frequently than anything
    // else.
    //

    // if mutex was already created, we can skip the version check
    // because it has already been executed.
    extern HANDLE g_devenum_mutex;
    if(g_devenum_mutex) {
        return;
    }

    extern CRITICAL_SECTION g_devenum_cs;
    EnterCriticalSection(&g_devenum_cs);
    if(g_devenum_mutex == 0)
    {
        g_devenum_mutex = CreateMutex(
            NULL,                   // no security attributes
            FALSE,                  // not initially owned
            TEXT("eed3bd3a-a1ad-4e99-987b-d7cb3fcfa7f0")); // name
    }
    LeaveCriticalSection(&g_devenum_cs);
    if(g_devenum_mutex == NULL)
    {
        DbgLog((LOG_ERROR, 0, TEXT("g_devenum_mutex creation failed.")));
        return;
    }

    // serialize HKCU registry editing
    EXECUTE_ASSERT(WaitForSingleObject(g_devenum_mutex, INFINITE) ==
                   WAIT_OBJECT_0);

    bool fBreakCache = true;
    {
        CRegKey rk;
        LONG lResult = rk.Open(g_hkCmReg, g_szCmRegPath, KEY_READ);

        DWORD dwCachedVer;
        if(lResult == ERROR_SUCCESS)
        {
            lResult = rk.QueryValue(dwCachedVer, G_SZ_DEVENUM_VERSION);
        }
        if(lResult == ERROR_SUCCESS && dwCachedVer == DEVENUM_VERSION) {
            fBreakCache = false;
        }

        // auto close key (it is deleted below)
    }

    if(fBreakCache)
    {
        RegDeleteTree(g_hkCmReg, g_szCmRegPath);

        DbgLog((LOG_TRACE, 0,
                TEXT("CCreateSwEnum: resetting class manager keys.")));

        CRegKey rk;
        LONG lResult = rk.Create(
            g_hkCmReg,
            g_szCmRegPath,
            0,                  // lpszClass
            REG_OPTION_NON_VOLATILE, // dwOptions
            KEY_WRITE);
        if(lResult == ERROR_SUCCESS)
        {
            lResult = rk.SetValue(DEVENUM_VERSION, G_SZ_DEVENUM_VERSION);
        }
    }

    EXECUTE_ASSERT(ReleaseMutex(g_devenum_mutex));
};

// the one method from our published ICreateDevEnum interface
//
STDMETHODIMP CCreateSwEnum::CreateClassEnumerator(
  REFCLSID clsidDeviceClass,
  IEnumMoniker **ppEnumMoniker,
  DWORD dwFlags)
{
    // call the real method and pass in a null for the
    // ppEnumClassMgrMonikers argument
    return CreateClassEnumerator(clsidDeviceClass, ppEnumMoniker, dwFlags, 0);
}

void FreeMonList(CGenericList<IMoniker> *plstMoniker)
{
    for(POSITION pos = plstMoniker->GetHeadPosition();
        pos;
        pos = plstMoniker->Next(pos))
    {
        plstMoniker->Get(pos)->Release();
    }
}


//
// Routine Description
//
//     This routine returns an enumerator for the monikers for pnp,
//     software, and class-managed devices. optionally returns an
//     enumerator containing just the managed devices.
//
// Arguments
//
//     clsidDeviceClass - guid of the category we're enumerating
//
//     ppEnumMoniker - enumerator is returned here. cannot be null.
//
//     dwFlags - CDEF_BYPASS_CLASS_MANAGER - just enumerate what's in
//     the registry without letting the class manager have a go.
//
//     pEnumMonInclSkipped - (optional) an enumerator containing
//     only the devices maintained by the class manager. Used by the
//     class manager to verify that the registry is in sync. Does
//     include devices with the CLASS_MGR_OMIT flag.
//
STDMETHODIMP CCreateSwEnum::CreateClassEnumerator(
  REFCLSID clsidDeviceClass,
  IEnumMoniker **ppEnumMoniker,
  DWORD dwFlags,
  IEnumMoniker ** ppEnumClassMgrMonikers
  )
{
    PNP_PERF(static int msrCreatePnp = MSR_REGISTER(TEXT("mkenum: CreatePnp")));
    PNP_PERF(static int msrCreateSw = MSR_REGISTER(TEXT("mkenum: CreateSw")));
    MSR_INTEGER(m_msrEnum, clsidDeviceClass.Data1);

    CheckPointer(ppEnumMoniker, E_POINTER);
    *ppEnumMoniker = NULL;

    ICreateDevEnum *pClassManager = CreateClassManager(clsidDeviceClass, dwFlags);
    if (pClassManager)
    {
        HRESULT hr = pClassManager->CreateClassEnumerator(clsidDeviceClass, ppEnumMoniker, dwFlags);
        pClassManager->Release();
        MSR_INTEGER(m_msrEnum, clsidDeviceClass.Data1);
        return hr;
    }

    HRESULT hr = S_OK;

// if no mask flags are set then enumerate everything. Otherwise
// enumerate only the specified types.
#define CHECK_SEL(x) (((dwFlags & CDEF_DEVMON_SELECTIVE_MASK) == 0) || \
                      (dwFlags & x))

    PNP_PERF(MSR_START(msrCreatePnp));
    CGenericList<IMoniker> lstPnpMon(NAME("pnp moniker list"), 10);
    if(CHECK_SEL(CDEF_DEVMON_PNP_DEVICE)) {
        hr = CreatePnpMonikers(&lstPnpMon, clsidDeviceClass);
    }
    PNP_PERF(MSR_STOP(msrCreatePnp));

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("devenum: CreatePnpMonikers failed.")));
    }

    UINT cPnpMonikers = lstPnpMon.GetCount();

    PNP_PERF(MSR_START(msrCreateSw));
    CComPtr<IUnknown> *rgpCmMoniker = 0;
    CComPtr<IMoniker> pPreferredCmgrDev;
    CComPtr<CEnumMonikers> pEnumMonInclSkipped;
    UINT cCmMonikers = 0;
    if(CHECK_SEL(CDEF_DEVMON_CMGR_DEVICE)) {
        hr = CreateCmgrMonikers(
            &rgpCmMoniker, &cCmMonikers, clsidDeviceClass,
            &pEnumMonInclSkipped, &pPreferredCmgrDev );
    }

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("devenum: CreateCmgrMonikers failed.")));
    }

    CComPtr<IUnknown> *rgpSwMoniker = 0;
    UINT cSwMonikers = 0;
    if(CHECK_SEL(CDEF_DEVMON_FILTER)) {
        hr = CreateSwMonikers(&rgpSwMoniker, &cSwMonikers, clsidDeviceClass);
    }

    PNP_PERF(MSR_STOP(msrCreateSw));

    if(FAILED(hr)) {
        DbgLog((LOG_TRACE, 0, TEXT("devenum: CreateSwMonikers failed.")));
    }

    CGenericList<IMoniker> lstDmoMon(NAME("DMO moniker list"));
    if(CHECK_SEL(CDEF_DEVMON_DMO)) {
        hr = CreateDmoMonikers(&lstDmoMon, clsidDeviceClass);
    }
    if(FAILED(hr)) {
        DbgLog((LOG_ERROR, 0, TEXT("CreateDmoMonikers failed.")));
    }
    UINT cDmoMonikers = lstDmoMon.GetCount();


    DbgLog((LOG_TRACE, 5, TEXT("devenum: cat %08x. sw:%d, pnp:%d, cm:%d, dmo: %d"),
            clsidDeviceClass.Data1, cSwMonikers, cPnpMonikers, cCmMonikers, cDmoMonikers));

    UINT cMonikers = cPnpMonikers + cSwMonikers + cCmMonikers + cDmoMonikers;

    if(cMonikers != 0)
    {
        // copy all monikers into one array for CEnumMonikers

        IUnknown **rgpMonikerNotAddRefd = new IUnknown*[cMonikers];
        if(rgpMonikerNotAddRefd)
        {
            // order is important -- we want the enumerator to return
            // pnp things, then things installed directly, and finally
            // stuff installed by class managers. But the very first
            // thing is the "preferred device" if there is one.

            UINT iMonDest = 0;
            if(pPreferredCmgrDev) {
                rgpMonikerNotAddRefd[iMonDest++] = pPreferredCmgrDev;
            }


            POSITION pos = lstPnpMon.GetHeadPosition();
            for(UINT iMoniker = 0 ; iMoniker < cPnpMonikers; iMoniker++)
            {
                IMoniker *pDevMon = lstPnpMon.Get(pos);
                ASSERT(pDevMon);
                rgpMonikerNotAddRefd[iMonDest++] = pDevMon;
                pos = lstPnpMon.Next(pos) ;
            }
            ASSERT(pos == 0);

            pos = lstDmoMon.GetHeadPosition();
            for(iMoniker = 0 ; iMoniker < cDmoMonikers; iMoniker++)
            {
                IMoniker *pDevMon = lstDmoMon.Get(pos);
                ASSERT(pDevMon);
                rgpMonikerNotAddRefd[iMonDest++] = pDevMon;
                pos = lstDmoMon.Next(pos) ;
            }
            ASSERT(pos == 0);

            for(iMoniker = 0; iMoniker < cSwMonikers; iMoniker++)
            {
                ASSERT(rgpSwMoniker[iMoniker]);
                rgpMonikerNotAddRefd[iMonDest++] = rgpSwMoniker[iMoniker];
            }

            for(iMoniker = 0; iMoniker < cCmMonikers; iMoniker++)
            {
                ASSERT(rgpCmMoniker[iMoniker]);

                // skip the preferred device because we already
                // handled it above.
                if(rgpCmMoniker[iMoniker] != pPreferredCmgrDev) {
                    rgpMonikerNotAddRefd[iMonDest++] = rgpCmMoniker[iMoniker];
                }
            }

            ASSERT(iMonDest == cPnpMonikers + cSwMonikers + cCmMonikers + cDmoMonikers);

            CEnumMonikers *pDevEnum = new CComObject<CEnumMonikers>;
            if(pDevEnum)
            {
                IMoniker **ppMonikerRgStart = (IMoniker **)&rgpMonikerNotAddRefd[0];
                IMoniker **ppMonikerRgEnd = ppMonikerRgStart + cMonikers;

                hr = pDevEnum->Init(ppMonikerRgStart,
                                    ppMonikerRgEnd,
                                    GetControllingUnknown(),
                                    AtlFlagCopy);
                if(SUCCEEDED(hr))
                {
                    hr = S_OK;
                    pDevEnum->AddRef();
                    *ppEnumMoniker = pDevEnum;

                    if(ppEnumClassMgrMonikers && pEnumMonInclSkipped) {
                        *ppEnumClassMgrMonikers = pEnumMonInclSkipped;
                        pEnumMonInclSkipped->AddRef();
                    }
                }
                else
                {
                    delete pDevEnum;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete[] rgpMonikerNotAddRefd;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    delete[] rgpSwMoniker;
    delete[] rgpCmMoniker;

    FreeMonList(&lstPnpMon);
    FreeMonList(&lstDmoMon);

    MSR_INTEGER(m_msrEnum, clsidDeviceClass.Data1);
    return hr;
}


//
// Routine Description
//
//     This routine creates and returns one moniker for a device in
//     the class manager location in the registry.
//
// Arguments
//
//     ppDevMon - the moniker is returned here (with a refcount)
//
//     hkClass - The opened registry key of the key containing the
//     device registry key
//
//     szThisClass - the string for the category guid for the moniker
//
//     iKey - index of key in hkClass of the device to open
//
//     pfShouldSkip - returns whether the device should be skipped in
//     the enumerator. used when it's too expensive to determine
//     whether a particular item should be returned otherwise.
//
//     pfIsDefaultDevice - "preferred" devices. Indicates this one
//     should be returned first.
//

HRESULT CCreateSwEnum::CreateOneCmgrMoniker(
    IMoniker **ppDevMon,
    HKEY hkClass,
    const TCHAR *szThisClass,
    DWORD iKey,
    bool *pfShouldSkip,
    bool *pfIsDefaultDevice)
{
    PNP_PERF(static int msrCreateSw = MSR_REGISTER(TEXT("mkenum: CreateOneCmgrMoniker")));

    TCHAR szInstanceName[MAX_PATH];
    HRESULT hr = S_OK;
    *ppDevMon = 0;
    *pfIsDefaultDevice = false;
    *pfShouldSkip = false;

    if(RegEnumKey(hkClass, iKey, szInstanceName, MAX_PATH) != ERROR_SUCCESS)
        return S_FALSE;

    HKEY hkDevice;
    if(RegOpenKeyEx(hkClass, szInstanceName, 0, KEY_READ, &hkDevice) != ERROR_SUCCESS)
        return S_FALSE;

    bool bCloseDevKey = true;   // moniker may want to hold on to it

    DWORD dwType;

    DWORD dwFlags;
    DWORD dwcb = sizeof(dwFlags);
    if(RegQueryValueEx(hkDevice, g_szClassManagerFlags,
                       0, &dwType, (BYTE *)&dwFlags, &dwcb) ==
       ERROR_SUCCESS)
    {
        *pfShouldSkip = (dwFlags & CLASS_MGR_OMIT) != 0;
        *pfIsDefaultDevice = (dwFlags & CLASS_MGR_DEFAULT) != 0;
    }
    EXECUTE_ASSERT(ERROR_SUCCESS == RegCloseKey(hkDevice));

    if(hr == S_OK)
    {
        USES_CONVERSION;

        CComObject<CDeviceMoniker> *pDevMon = new CComObject<CDeviceMoniker>;
        if(pDevMon)
        {
            TCHAR szPersistentName[MAX_PATH * 2];
            lstrcpy(szPersistentName, TEXT("@device:cm:"));
            lstrcat(szPersistentName, szThisClass);
            lstrcat(szPersistentName, TEXT("\\"));
            lstrcat(szPersistentName, szInstanceName);

            hr = pDevMon->Init(T2CW(szPersistentName));
            if(SUCCEEDED(hr))
            {
                hr = S_OK;
                *ppDevMon = pDevMon;
                pDevMon->AddRef();
                bCloseDevKey = false;
            }
            else
            {
                delete pDevMon;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(bCloseDevKey)
    {
        RegCloseKey(hkDevice);
    }

    return hr;
}

//
// Routine
//
//     returns an array of monikers of devices created by a class
//     manager (in HKEY_CLASSES_ROOT).
//
// Arguments
//
//     prgpMoniker - array of monikers is returned here. excludes
//     devices that are registered with the "OMIT" flag.
//
//     pcMonikers - # of elements in array above is returned here.
//
//     clsidDeviceClass - category we're enumerating
//
//     ppEnumMoniker - enumerator containing all devices that the
//     class manager deals with is returned here (optional).

HRESULT CCreateSwEnum::CreateCmgrMonikers(
    CComPtr<IUnknown> **prgpMoniker,
    UINT *pcMonikers,
    REFCLSID clsidDeviceClass,
    CEnumMonikers **ppEnumMonInclSkipped,
    IMoniker **ppPreferred
    )
{
    *prgpMoniker = 0;
    *pcMonikers = 0;
    *ppPreferred = 0;

    if(ppEnumMonInclSkipped) {
        *ppEnumMonInclSkipped = 0;
    }

    HRESULT hr = S_OK;

    TCHAR szInstance[MAX_PATH];

    OLECHAR wszThisClass[CHARS_IN_GUID];
    EXECUTE_ASSERT(StringFromGUID2(clsidDeviceClass, wszThisClass, CHARS_IN_GUID) ==
                   CHARS_IN_GUID);

    USES_CONVERSION;
    const TCHAR *szThisClass = W2CT(wszThisClass);
    lstrcpy(szInstance, g_szCmRegPath);
    szInstance[NUMELMS(g_szCmRegPath) - 1] = TEXT('\\');
    lstrcpy(szInstance + NUMELMS(g_szCmRegPath), szThisClass);

    HKEY hkThisClass;
    LONG lResult = RegOpenKeyEx(g_hkCmReg, szInstance, 0, KEY_READ, &hkThisClass);
    if (lResult == ERROR_SUCCESS)
    {
        DWORD cEntries;
        LONG lResult = RegQueryInfoKey(hkThisClass, 0, 0, 0, &cEntries, 0, 0, 0, 0, 0, 0, 0);
        if(lResult == ERROR_SUCCESS)
        {
            CComPtr<IUnknown> *rgpMonikerExclSkipped = new CComPtr<IUnknown>[cEntries];
            if(rgpMonikerExclSkipped)
            {
                CComPtr<IUnknown> *rgpMonikerInclSkipped = 0;
                if(ppEnumMonInclSkipped) {
                    rgpMonikerInclSkipped = new CComPtr<IUnknown>[cEntries];
                }
                if(rgpMonikerInclSkipped || !ppEnumMonInclSkipped)
                {
                    CComPtr<IMoniker> pPreferred;

                    DWORD cEntriesFound = 0;
                    DWORD cEntriesLessSkipped = 0;
                    for(DWORD iEntry = 0; iEntry < cEntries; iEntry++)
                    {
                        //PNP_PERF(MSR_START(m_msrCreateOneSw));
                        bool fDefaultDevice;
                        bool fShouldSkip;
                        IMoniker *pDevMon;
                        hr = CreateOneCmgrMoniker(
                            &pDevMon,
                            hkThisClass,
                            szThisClass,
                            iEntry,
                            &fShouldSkip,
                            &fDefaultDevice);
                        //PNP_PERF(MSR_STOP(m_msrCreateOneSw));

                        if(hr == S_OK)
                        {
                            ASSERT(pDevMon);

                            if(fDefaultDevice)
                            {
                                ASSERT(pPreferred == 0);
                                pPreferred = pDevMon; // auto addref
                            }

                            if(ppEnumMonInclSkipped) {
                                // auto addref
                                rgpMonikerInclSkipped[cEntriesFound] = pDevMon;
                            }
                            cEntriesFound++;

                            if(!fShouldSkip)
                            {
                                // avoid auto addref; transfer refcount
                                rgpMonikerExclSkipped[cEntriesLessSkipped].p = pDevMon;

                                cEntriesLessSkipped++;
                            }
                            else
                            {
                                pDevMon->Release();
                            }
                        }
                        else if(hr == S_FALSE)
                        {
                            ASSERT(pDevMon == 0);

                            // non-fatal error
                            continue;
                        }
                        else
                        {
                            ASSERT(pDevMon == 0);

                            // fatal error
                            break;
                        }
                    }

                    CEnumMonikers *pEnumMonInclSkipped = 0;;
                    if(SUCCEEDED(hr) && ppEnumMonInclSkipped)
                    {
                        pEnumMonInclSkipped = new CComObject<CEnumMonikers>;
                        if(pEnumMonInclSkipped)
                        {
                            IMoniker **ppMonikerRgStart = (IMoniker **)rgpMonikerInclSkipped;
                            IMoniker **ppMonikerRgEnd = ppMonikerRgStart + cEntriesFound;

                            hr = pEnumMonInclSkipped->Init(
                                ppMonikerRgStart,
                                ppMonikerRgEnd,
                                GetControllingUnknown(),
                                AtlFlagCopy);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        hr = S_OK; // may see S_FALSE
                        *pcMonikers = cEntriesLessSkipped;
                        *prgpMoniker = rgpMonikerExclSkipped;
                        if(ppEnumMonInclSkipped) {
                            *ppEnumMonInclSkipped = pEnumMonInclSkipped;
                            pEnumMonInclSkipped->AddRef();
                        }

                        if(pPreferred)
                        {
                            *ppPreferred = pPreferred;
                            pPreferred->AddRef();
                        }
                    }

                    delete[] rgpMonikerInclSkipped;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                if(FAILED(hr))
                {
                    delete[] rgpMonikerExclSkipped;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        RegCloseKey(hkThisClass);
    }

    return hr;
}

//
// Routine Description
//
//     This routine creates and returns one moniker for a device in
//     the Instance location in the registry (HKCR\{category}\Instance
//
// Arguments
//
//     ppDevMon - the moniker is returned here (with a refcount)
//
//     hkClass - The opened registry key of the key containing the
//     device registry key
//
//     szThisClass - the string for the category guid for the moniker
//
//     iKey - index of key in hkClass of the device to open
//
//

HRESULT CCreateSwEnum::CreateOneSwMoniker(
    IMoniker **ppDevMon,
    HKEY hkClass,
    const TCHAR *szThisClass,
    DWORD iKey)
{
    PNP_PERF(static int msrCreateSw = MSR_REGISTER(TEXT("mkenum: CreateOneSwMoniker")));

    TCHAR szInstanceName[MAX_PATH];
    HRESULT hr = S_OK;
    *ppDevMon = 0;

    if(RegEnumKey(hkClass, iKey, szInstanceName, MAX_PATH) != ERROR_SUCCESS)
        return S_FALSE;

    HKEY hkDevice;
    if(RegOpenKeyEx(hkClass, szInstanceName, 0, KEY_READ, &hkDevice) != ERROR_SUCCESS)
        return S_FALSE;

    bool bCloseDevKey = true;   // moniker may want to hold on to it


    USES_CONVERSION;

    CComObject<CDeviceMoniker> *pDevMon = new CComObject<CDeviceMoniker>;
    if(pDevMon)
    {
        TCHAR szPersistentName[MAX_PATH * 2];
        lstrcpy(szPersistentName, TEXT("@device:sw:"));
        lstrcat(szPersistentName, szThisClass);
        lstrcat(szPersistentName, TEXT("\\"));
			
        {
            USES_CONVERSION;
            lstrcat(szPersistentName, szInstanceName);
        }
        hr = pDevMon->Init(T2CW(szPersistentName));
        if(SUCCEEDED(hr))
        {
            hr = S_OK;
            *ppDevMon = pDevMon;
            pDevMon->AddRef();
        }
        else
        {
            delete pDevMon;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }



    if(bCloseDevKey)
    {
        RegCloseKey(hkDevice);
    }

    return hr;
}


//
// Routine
//
//     returns an array of monikers of devices installed in the
//     Instance location (HKCR\{category}\Interface)
//
// Arguments
//
//     prgpMoniker - array of monikers is returned here.
//
//     pcMonikers - # of elements in array above is returned here.
//
//     clsidDeviceClass - category we're enumerating
//
HRESULT CCreateSwEnum::CreateSwMonikers(
    CComPtr<IUnknown> **prgpMoniker,
    UINT *pcMonikers,
    REFCLSID clsidDeviceClass)
{
    *prgpMoniker = 0;
    *pcMonikers = 0;

    HRESULT hr = S_OK;
    HKEY hkUserDevRoot;
    if(RegOpenKeyEx(HKEY_CLASSES_ROOT, g_szClsid, 0, KEY_READ, &hkUserDevRoot) == ERROR_SUCCESS)
    {
        TCHAR szInstance[MAX_PATH];

        OLECHAR wszThisClass[CHARS_IN_GUID];
        EXECUTE_ASSERT(StringFromGUID2(clsidDeviceClass, wszThisClass, CHARS_IN_GUID) ==
                       CHARS_IN_GUID);
        USES_CONVERSION;
        const TCHAR *szThisClass = W2CT(wszThisClass);
        lstrcpy(szInstance, szThisClass);
        lstrcpy(szInstance + CHARS_IN_GUID - 1, TEXT("\\Instance"));

        HKEY hkThisClass;
        LONG lResult;
        {
            USES_CONVERSION;
            lResult = RegOpenKeyEx(hkUserDevRoot, szInstance, 0, KEY_READ, &hkThisClass);
        }
        if (lResult == ERROR_SUCCESS)
        {
            // static const cchIndex = 5;
            DWORD cEntries;
            LONG lResult = RegQueryInfoKey(hkThisClass, 0, 0, 0, &cEntries, 0, 0, 0, 0, 0, 0, 0);
            if(lResult == ERROR_SUCCESS)
            {
                CComPtr<IUnknown> *rgpMoniker = new CComPtr<IUnknown>[cEntries];
                if(rgpMoniker)
                {
                    DWORD cEntriesFound = 0;
                    for(DWORD iEntry = 0; iEntry < cEntries; iEntry++)
                    {
                        //PNP_PERF(MSR_START(m_msrCreateOneSw));
                        IMoniker *pDevMon;
                        hr = CreateOneSwMoniker(
                            &pDevMon,
                            hkThisClass,
                            szThisClass,
                            iEntry);
                        //PNP_PERF(MSR_STOP(m_msrCreateOneSw));

                        if(hr == S_OK)
                        {
                            // avoid auto addref; transfer refcount
                            rgpMoniker[cEntriesFound].p = pDevMon;

                            cEntriesFound++;
                        }
                        else if(hr == S_FALSE)
                        {
                            // non-fatal error
                            continue;
                        }
                        else
                        {
                            break;
                        }
                    }

                    if(SUCCEEDED(hr))
                    {
                        hr = S_OK; // may see S_FALSE
                        *pcMonikers = cEntriesFound;
                        *prgpMoniker = rgpMoniker;
                    }
                    else
                    {
                        delete[] rgpMoniker;
                    }
                }
            }

            RegCloseKey(hkThisClass);
        }

        RegCloseKey(hkUserDevRoot);
    }

    return hr;
}


// instatiate and destroy device. gives George's filters a chance to
// register their filter data key
//
void RegisterFilterDataKey(DevMon *pDevMon)
{
    VARIANT var;
    var.vt = VT_EMPTY;
    HRESULT hr = pDevMon->Read(L"FilterData", &var, 0);
    if(SUCCEEDED(hr))
    {
        hr = VariantClear(&var);
        ASSERT(hr == S_OK);
    }
    else
    {
        IUnknown *pUnk;
        hr = pDevMon->BindToObject(
            0,                  // bindCtx
            0,                  // mkToLeft
            IID_IUnknown,
            (void **)&pUnk);
        if(SUCCEEDED(hr))
        {
            pUnk->Release();
        }
    }
}


HRESULT CCreateSwEnum::CreateOnePnpMoniker(
    IMoniker **ppDevMon,
    const CLSID **rgpclsidKsCat,
    CEnumInternalState *pcenumState)
{
    HRESULT hr = S_OK;

    WCHAR *wszDevicePath = 0;
    CEnumPnp *pEnumPnp = CEnumInterfaceClass::CreateEnumPnp();
    if(pEnumPnp)
    {
        hr = pEnumPnp->GetDevicePath(&wszDevicePath, rgpclsidKsCat, pcenumState);
        if(hr == S_OK)
        {
            DevMon *pDevMon = new DevMon;
            if(pDevMon)
            {
                pDevMon->AddRef(); // keep refcount from hitting 0
                USES_CONVERSION;

                UINT cchDevicePath = lstrlenW(wszDevicePath) + sizeof("@device:pnp:");
                WCHAR *wszPersistName = new WCHAR[cchDevicePath];
                if(wszPersistName)
                {
                    lstrcpyW(wszPersistName, L"@device:pnp:");
                    lstrcatW(wszPersistName, wszDevicePath);

                    ASSERT((UINT)lstrlenW(wszPersistName) == cchDevicePath - 1);

                    hr = pDevMon->Init(wszPersistName);
                    if(SUCCEEDED(hr))
                    {
                        RegisterFilterDataKey(pDevMon);

                        hr = S_OK;
                        *ppDevMon = pDevMon;
                        pDevMon->AddRef();
                    }

                    delete[] wszPersistName;
                }

                pDevMon->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete[] wszDevicePath;
        }
        else if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

#define MAX_INTERSECTIONS 10

// map CLSID_VideoInputDeviceCategory to KS_CAPTURE . KS_VIDEO. return
// a null terminated array of pointers
//
HRESULT
MapAmCatToKsCat(
    REFCLSID clsidAmCat,
    const CLSID **rgpclsidKsCat)
{

    // !!! table

    // put the shortest list first since that's the one we actually
    // enumerate

    // don't add ksproxy aud renderer devices this way
    //if(clsidAmCat == CLSID_AudioRendererCategory)
    //{
    //    rgpclsidKsCat[0] = &AM_KSCATEGORY_AUDIO;
    //    rgpclsidKsCat[1] = &AM_KSCATEGORY_RENDER;
    //    rgpclsidKsCat[0] = 0;
    //}
    //else
    if(clsidAmCat == CLSID_VideoRenderer)
    {
        rgpclsidKsCat[0] = &AM_KSCATEGORY_VIDEO;
        rgpclsidKsCat[1] = &AM_KSCATEGORY_RENDER;
        rgpclsidKsCat[2] = 0;
    }
    else if(clsidAmCat == CLSID_VideoInputDeviceCategory)
    {
        rgpclsidKsCat[0] = &AM_KSCATEGORY_CAPTURE;
        rgpclsidKsCat[1] = &AM_KSCATEGORY_VIDEO;
        rgpclsidKsCat[2] = 0;
    }
    // don't add ksproxy aud capture devices this way
    //else if(clsidAmCat == CLSID_AudioInputDeviceCategory)
    //{
    //    rgpclsidKsCat[0] = &AM_KSCATEGORY_CAPTURE;
    //    rgpclsidKsCat[1] = &AM_KSCATEGORY_AUDIO;
    //    rgpclsidKsCat[0] = 0;
    //}
    else
    {
        // don't return &clsidAmCat because it's on the caller's stack
        return S_FALSE;
    }

    return S_OK;
}

HRESULT CCreateSwEnum::CreatePnpMonikers(
    CGenericList<IMoniker> *plstMoniker,
    REFCLSID clsidDeviceClass)
{

    HRESULT hr = S_OK;

    const CLSID *rgpclsidKsCat[MAX_INTERSECTIONS];
    hr = MapAmCatToKsCat(clsidDeviceClass, rgpclsidKsCat);
    if(hr != S_OK)
    {
        rgpclsidKsCat[0] = &clsidDeviceClass;
        rgpclsidKsCat[1] = 0;
        hr = S_OK;
    }

    if(SUCCEEDED(hr))
    {
        CEnumInternalState cenumState;

        for(;;)
        {
            IMoniker *pDevMon;

            hr = CreateOnePnpMoniker(
                &pDevMon,
                rgpclsidKsCat,
                &cenumState);

            if(hr == S_OK)
            {
                // keep ref count
                plstMoniker->AddTail(pDevMon);
            }
            else
            {
                // CreateOne can return S_FALSE
                if(hr == S_FALSE)
                    hr = S_OK;
                break;
            }
        }
    }

    return hr;
}

static HRESULT DoDmoEnum(REFCLSID clsidDmoCat, CGenericList<IMoniker> *plstMoniker)
{
    IEnumDMO *pEnumDmo;

    HRESULT hr = g_pDMOEnum(clsidDmoCat,
            DMO_ENUMF_INCLUDE_KEYED, // dwFlags
            0, 0,                    // input type count / array
            0, 0,                    // output type count / array
            &pEnumDmo);

    if(SUCCEEDED(hr))
    {
        CLSID clsidDmo;
        WCHAR *wszDmo;
        ULONG cFetched;

        while(pEnumDmo->Next(1, &clsidDmo, &wszDmo, &cFetched) == S_OK)
        {
            ASSERT(cFetched == 1);
            DevMon *pDevMon = new DevMon;
            if(pDevMon)
            {
                pDevMon->AddRef(); // keep refcount from hitting zero

                //char szPrefix[] = "@device:dmo:";
                WCHAR wszPrefix[] = L"@device:dmo:";
                const cchName = 2 * (CHARS_IN_GUID - 1) + NUMELMS(wszPrefix);

                WCHAR wszName[cchName];
                lstrcpyW(wszName, wszPrefix);

                EXECUTE_ASSERT(StringFromGUID2(
                    clsidDmo,
                    wszName + NUMELMS(wszPrefix) - 1, CHARS_IN_GUID) ==
                               CHARS_IN_GUID);
                EXECUTE_ASSERT(StringFromGUID2(
                    clsidDmoCat,
                    wszName + CHARS_IN_GUID - 1 + NUMELMS(wszPrefix) - 1, CHARS_IN_GUID) ==
                               CHARS_IN_GUID);
                ASSERT(lstrlenW(wszName) + 1 == cchName);

                hr = pDevMon->Init(wszName);

                if(SUCCEEDED(hr))
                {
                    if(plstMoniker->AddTail(pDevMon))
                    {
                        hr = S_OK;
                        pDevMon->AddRef();
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                pDevMon->Release();
            }

            CoTaskMemFree(wszDmo);
        }
        pEnumDmo->Release();
    }

    return hr;
}

HRESULT CCreateSwEnum::CreateDmoMonikers(
    CGenericList<IMoniker> *plstMoniker,
    REFCLSID clsidDeviceClass)
{
    HRESULT hr = S_OK;

    if(!InitDmo()) {
        return E_FAIL;
    }

    // !!! registry lookup

    if(clsidDeviceClass == CLSID_LegacyAmFilterCategory)
    {
        hr = DoDmoEnum(DMOCATEGORY_AUDIO_DECODER, plstMoniker);
        //ignore error
        hr = DoDmoEnum(DMOCATEGORY_VIDEO_DECODER, plstMoniker);
    }
    else if(clsidDeviceClass == CLSID_VideoCompressorCategory)
    {
        hr = DoDmoEnum(DMOCATEGORY_VIDEO_ENCODER, plstMoniker);
    }
    else if(clsidDeviceClass == CLSID_AudioCompressorCategory)
    {
        hr = DoDmoEnum(DMOCATEGORY_AUDIO_ENCODER, plstMoniker);
    }
    else
    {
        // treat the class as a dmo category and enumerate it directly
        hr = DoDmoEnum(clsidDeviceClass, plstMoniker);
    }
    return hr;
}

ICreateDevEnum * CCreateSwEnum::CreateClassManager(
    REFCLSID clsidDeviceClass,
    DWORD dwFlags)
{
    ICreateDevEnum *pClassManager = NULL;
    if ((dwFlags & CDEF_BYPASS_CLASS_MANAGER) == 0) {
        {
            HRESULT hr = CoCreateInstance(clsidDeviceClass, NULL, CLSCTX_INPROC_SERVER,
                                          IID_ICreateDevEnum, (void **) &pClassManager);
            if(FAILED(hr))
            {
                pClassManager = NULL;
            }
        }
    }
    return pClassManager;
}

bool InitDmo()
{
    extern CRITICAL_SECTION g_devenum_cs;
    EnterCriticalSection(&g_devenum_cs);
    if(g_pDMOEnum == 0)
    {
        // note we leak msdmo.dll
        HINSTANCE h = LoadLibrary(TEXT("msdmo.dll"));
        if(h != 0)
        {
            g_pDMOEnum = (PDMOEnum)GetProcAddress(h, "DMOEnum");

            extern PDMOGetTypes g_pDMOGetTypes;
            extern PDMOGetName g_pDMOGetName;
            g_pDMOGetTypes = (PDMOGetTypes)GetProcAddress(h, "DMOGetTypes");
            g_pDMOGetName = (PDMOGetName)GetProcAddress(h, "DMOGetName");

            // probably not a valid assertion.
            ASSERT(g_pDMOGetName && g_pDMOGetTypes && g_pDMOEnum);
        }
    }

    if(g_pDMOEnum == 0)
    {
        // only valid failure would be out of memory failures.
        DbgBreak("msdmo.dll should be installed");

        // hack to cache failures.
        g_pDMOEnum = (PDMOEnum)1;
    }

    bool fRet = true;
    if(g_pDMOEnum == 0 || g_pDMOEnum == (PDMOEnum)1) {
        fRet = false;
    }
    LeaveCriticalSection(&g_devenum_cs);

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\stdafx.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif // _ATL_STATIC_REGISTRY

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\util.cpp ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
#include <Streams.h>
#include "stdafx.h"

// // copied from msdn
// DWORD RegDeleteTree(HKEY hStartKey , const TCHAR* pKeyName )
// {
//     DWORD   dwRtn, dwSubKeyLength;
//     LPTSTR  pSubKey = NULL;
//     TCHAR   szSubKey[MAX_PATH]; // (256) this should be dynamic.
//     HKEY    hKey;

//     // do not allow NULL or empty key name
//     if ( pKeyName &&  lstrlen(pKeyName))
//     {
//         if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
//                                 0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
//         {
//             while (dwRtn == ERROR_SUCCESS )
//             {
//                 dwSubKeyLength = MAX_PATH;
//                 dwRtn=RegEnumKeyEx(
//                     hKey,
//                     0,       // always index zero
//                     szSubKey,
//                     &dwSubKeyLength,
//                     NULL,
//                     NULL,
//                     NULL,
//                     NULL
//                     );

//                 if(dwRtn == ERROR_NO_MORE_ITEMS)
//                 {
//                     dwRtn = RegDeleteKey(hStartKey, pKeyName);
//                     break;
//                 }
//                 else if(dwRtn == ERROR_SUCCESS)
//                     dwRtn=RegDeleteTree(hKey, szSubKey);
//             }
//             RegCloseKey(hKey);
//             // Do not save return code because error
//             // has already occurred
//         }
//     }
//     else
//         dwRtn = ERROR_BADKEY;

//     return dwRtn;


// }

DWORD RegDeleteTree(HKEY hStartKey , const TCHAR* pKeyName )
{
  CRegKey key;
  key.Attach(hStartKey);
  LONG lResult = key.RecurseDeleteKey(pKeyName);
  key.Detach();
  return lResult;
}

#include <initguid.h>
DEFINE_GUID(IID_IConnectionPointContainer,
	0xB196B284,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
DEFINE_GUID(IID_IEnumConnectionPoints,
	0xB196B285,0xBAB4,0x101A,0xB6,0x9C,0x00,0xAA,0x00,0x34,0x1D,0x07);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\util.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.

#ifndef _DEVENUM_UTIL_H
#define _DEVENUM_UTIL_H


DWORD RegDeleteTree(HKEY hStartKey , const TCHAR* pKeyName );

// where in the registry do we find the class manager stuff?
// filterus\dexter\dxt\dxtenum looks at this too
static const HKEY g_hkCmReg = HKEY_CURRENT_USER;
static TCHAR g_szCmRegPath[] = TEXT("Software\\Microsoft\\ActiveMovie\\devenum");

static const CCH_CLSID = 39;        // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}\0

// class manager flags (goes in the registry)
static const CLASS_MGR_OMIT = 0x1;
static const CLASS_MGR_DEFAULT = 0x2;

#define DEVENUM_VERSION (6)
#define G_SZ_DEVENUM_VERSION (TEXT("Version"))
#define G_SZ_DEVENUM_PATH (TEXT("CLSID\\{62BE5D10-60EB-11d0-BD3B-00A0C911CE86}"))

#endif // _DEVENUM_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\vidcap.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"

#include <vfw.h>

static const g_cchCapName = 64;
static const g_cchCapDesc = 64;
static const NUM_LEGACY_DEVICES = 10;

class CVidCapClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CVidCapClassManager,&CLSID_CVidCapClassManager>
{
    struct LegacyCap
    {
        TCHAR szName[g_cchCapName];
        TCHAR szDesc[g_cchCapDesc];
        BOOL bNotMatched;
    } m_rgLegacyCap[NUM_LEGACY_DEVICES];


public:

    CVidCapClassManager();
    ~CVidCapClassManager();

    BEGIN_COM_MAP(CVidCapClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
// 	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CVidCapClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    BOOL MatchString(IPropertyBag *pPropBag);
    // BOOL MatchString(const TCHAR *szDevName);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);

private:

    typedef BOOL(VFWAPI *PcapGetDriverDescriptionA)(
        UINT wDriverIndex,
        LPSTR lpszName, int cbName,
        LPSTR lpszVer, int cbVer);        

    typedef BOOL(VFWAPI *PcapGetDriverDescriptionW)(
        UINT wDriverIndex,
        LPWSTR lpszName, int cbName,
        LPWSTR lpszVer, int cbVer);

#ifdef UNICODE
    typedef PcapGetDriverDescriptionW PcapGetDriverDescription;
#else
    typedef PcapGetDriverDescriptionA PcapGetDriverDescription;
#endif

    PcapGetDriverDescription m_capGetDriverDescription;
    HMODULE m_hmodAvicap32;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\vidcap.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "vidcap.h"
#include <vfw.h>
#include "util.h"

static const TCHAR g_szDriverClsid[] = TEXT("CLSID"); // !!!
static const WCHAR g_wszVidcapDriverIndex[] = L"VFWIndex";
const TCHAR g_szVidcapDriverIndex[] = TEXT("VFWIndex");

// !!! get this from Quartz?
static const TCHAR g_szClsidVfwFilter[] = TEXT("{1b544c22-fd0b-11ce-8c63-00aa0044b51e}");

#ifdef WIN64
#error build error -- this is x86 only
#endif

CVidCapClassManager::CVidCapClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_hmodAvicap32(0)
{
}

CVidCapClassManager::~CVidCapClassManager()
{
    if(m_hmodAvicap32)
    {
        FreeLibrary(m_hmodAvicap32);
    }
}

HRESULT CVidCapClassManager::ReadLegacyDevNames()
{

#ifdef UNICODE
    static const char sz_capGetDriverDescription[] = "capGetDriverDescriptionW";
#else
    static const char sz_capGetDriverDescription[] = "capGetDriverDescriptionA";
#endif

    if(m_hmodAvicap32 == 0)
    {
        if(m_hmodAvicap32 = LoadLibrary(TEXT("avicap32.dll")))
        {
            m_capGetDriverDescription = (PcapGetDriverDescription)
                GetProcAddress(m_hmodAvicap32, sz_capGetDriverDescription);
            if(m_capGetDriverDescription == 0)
            {
                DWORD dwLastError = GetLastError();
                FreeLibrary(m_hmodAvicap32);
                m_hmodAvicap32 = 0;
                return HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else
        {
            DWORD dwLastError = GetLastError();
            return HRESULT_FROM_WIN32(dwLastError);
        }
    }
    
    BOOL bAnyLegacy = FALSE;
    m_cNotMatched = 0;

#ifdef DEBUG
    DWORD dw;
    CRegKey rkSkipMapper;
    const bool fSkipMapper = !
        (rkSkipMapper.Open(g_hkCmReg, g_szCmRegPath) == ERROR_SUCCESS &&
         rkSkipMapper.QueryValue(dw, TEXT("EnumerateMappedDevices")) == ERROR_SUCCESS &&
         dw);
#else
    const bool fSkipMapper = true;
#endif
    
    for(int i = 0; i < NUM_LEGACY_DEVICES; i++)
    {
        m_rgLegacyCap[i].bNotMatched = FALSE;
        if(m_capGetDriverDescription(
            i,
            m_rgLegacyCap[i].szName, g_cchCapName,
            m_rgLegacyCap[i].szDesc, g_cchCapDesc))
        {
            // unlocalizable hack to skip the VFW capture mapper !!!
            // Just check the beginning of the string. There may be a
            // (win32) on the end of the nt version.
            static const TCHAR szMapper[] = TEXT("Microsoft WDM Image Capture");

            // make sure the string we're comparing is smaller than we
            // allocated 
            ASSERT(sizeof(m_rgLegacyCap[i].szName) >= sizeof(szMapper));
            
            if((fSkipMapper &&
                memcmp(m_rgLegacyCap[i].szName, szMapper, sizeof(szMapper) - sizeof(TCHAR)) != 0) ||
               !fSkipMapper)
            {
                m_rgLegacyCap[i].bNotMatched = bAnyLegacy = TRUE;
                m_cNotMatched++;
            }
        }
    }

    return bAnyLegacy ? S_OK : S_FALSE;
}

BOOL CVidCapClassManager::MatchString(IPropertyBag *pPropBag)
{
    USES_CONVERSION;

    VARIANT varName, varId;
    varName.vt = VT_EMPTY;
    varId.vt = VT_EMPTY;

    bool fRet = false;

    HRESULT hr = pPropBag->Read(g_wszVidcapDriverIndex, &varId, 0);
    if(SUCCEEDED(hr))
    {
        ASSERT(varId.vt == VT_I4);
        hr = pPropBag->Read(T2COLE(m_szUniqueName), &varName, 0);
    }
    if(SUCCEEDED(hr))
    {
        ASSERT(varName.vt == VT_BSTR);
    
        for (int i = 0; i < NUM_LEGACY_DEVICES; i++)
        {
            if (m_rgLegacyCap[i].bNotMatched)
            {
                if(lstrcmp(m_rgLegacyCap[i].szName, W2T(varName.bstrVal)) == 0)
                {
                    if(varId.lVal == i)
                    {
                        m_rgLegacyCap[i].bNotMatched = FALSE;
                        fRet =  true;
                        break;
                    }
                }
            }
        }

        SysFreeString(varName.bstrVal);
    } 
    
    return fRet;
}

HRESULT CVidCapClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_VideoInputDeviceCategory);
    USES_CONVERSION;


    HRESULT hr = ReadLegacyDevNames();
    if(hr == S_OK)
    {
        for (int i = 0; i < NUM_LEGACY_DEVICES; i++)
        {
            if (m_rgLegacyCap[i].bNotMatched)
            {
                IMoniker *pMoniker = 0;

                const WCHAR *wszUniq = T2CW(m_rgLegacyCap[i].szName);
            
                REGFILTER2 rf2;
                rf2.dwVersion = 1;
                rf2.dwMerit = MERIT_DO_NOT_USE;
                rf2.cPins = 0;
                rf2.rgPins = 0;
                
                hr = RegisterClassManagerFilter(
                    pFm2,
                    CLSID_VfwCapture,
                    wszUniq,
                    &pMoniker,
                    &CLSID_VideoInputDeviceCategory,
                    wszUniq,
                    &rf2);

                if(SUCCEEDED(hr))
                        
                {
                    IPropertyBag *pPropBag;
                    hr = pMoniker->BindToStorage(
                        0, 0, IID_IPropertyBag, (void **)&pPropBag);
                    if(SUCCEEDED(hr))
                    {
                        VARIANT var;
                        var.vt = VT_I4;
                        var.lVal = i;
                        hr = pPropBag->Write(g_wszVidcapDriverIndex, &var);

                        if(SUCCEEDED(hr))
                        {
//                             // hide VFW devices that also appear in
//                             // the WDM list.
                            
//                             BOOL bThisIsVfwWdm = FALSE;
//                             HANDLE h;
//                             if (videoOpen(&h, i, VIDEO_IN) == DV_ERR_OK) {
//                                 CHANNEL_CAPS Caps;
//                                 if (h && videoGetChannelCaps(h, &Caps, sizeof(CHANNEL_CAPS)) == DV_ERR_OK) {
//                                     bThisIsVfwWdm = (BOOL)(Caps.dwFlags & (DWORD)0x04000000);
//                                 }
//                             }

//                             if(bThisIsVfwWdm)
//                             {
//                                 VARIANT var;
//                                 var.vt = VT_I4;
//                                 var.lVal = CLASS_MGR_OMIT;

//                                 hr = pPropBag->Write(g_wszClassManagerFlags, &var);
//                             }
                        }

                        pPropBag->Release();
                    }
                    pMoniker->Release();
                }
            }
        }


 
        return S_OK;
    } else {
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\stdafx.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

// only devmon needs to be free threaded, but it's difficult to mix
// them with this precompiled header.
#define _ATL_FREE_THREADED

// // adds 5k. otherwise we need register.dll. also need statreg.h
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif


#ifndef _USRDLL
#define _USRDLL
#endif
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

extern CComModule _Module;

#include <streams.h>
#include <atlconv.h>

//#define PERFZ

#ifdef PERFZ
#define PNP_PERF(x) x
#else
#define PNP_PERF(x)
#endif

// this value is set in the property bag if this is the default device.
extern const WCHAR g_wszClassManagerFlags[];


extern const TCHAR g_szVidcapDriverIndex [];
extern const TCHAR g_szQzfDriverIndex    [];
extern const TCHAR g_szIcmDriverIndex    [];
extern const TCHAR g_szAcmDriverIndex    [];
extern const TCHAR g_szWaveoutDriverIndex[];
extern const TCHAR g_szDsoundDriverIndex [];
extern const TCHAR g_szWaveinDriverIndex [];
extern const TCHAR g_szMidiOutDriverIndex[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\waveinp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include <mmddk.h>
#include "waveinp.h"
#include <vfw.h>
#include <ks.h>
#include <ksmedia.h>
#include <ksproxy.h>
#include "util.h"
#include "cenumpnp.h"
#include "devmon.h"

static const WCHAR g_wszDriverIndex[] = L"WaveInId";
const TCHAR g_szWaveinDriverIndex[] = TEXT("WaveInId");
static const TCHAR g_szInput[] = TEXT("Record");

CWaveInClassManager::CWaveInClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_rgWaveIn(0),
        m_lKsProxyAudioDevices(NAME("ksaudio capture dev list"), 10)
{
    // only show ksproxy audio capture devices on nt5
    //extern OSVERSIONINFO g_osvi;
    //m_bEnumKs = (g_osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
    //             g_osvi.dwMajorVersion >= 5);
    m_bEnumKs = FALSE; // nevermind, don't show them on any os, for now
}

CWaveInClassManager::~CWaveInClassManager()
{

    delete[] m_rgWaveIn;
    DelLocallyRegisteredPnpDevData();

}

void GetPreferredDeviceName(TCHAR szNamePreferredDevice[MAXPNAMELEN],
                            const TCHAR *szVal, bool bOutput)
{
    // first try to use the new DRVM_MAPPER_PREFERRED_GET message to get the preferred
    // device id. note that this message was added in nt5 and so is not guaranteed to
    // be supported on all os's.
    DWORD dw1, dw2;

    MMRESULT mmr;
    if (bOutput) {
        mmr = waveOutMessage( (HWAVEOUT) IntToPtr(WAVE_MAPPER)   // assume waveIn will translate WAVE_MAPPER?
                           , DRVM_MAPPER_PREFERRED_GET
                           , (DWORD_PTR) &dw1
                           , (DWORD_PTR) &dw2 );
    } else {
        mmr = waveInMessage( (HWAVEIN) IntToPtr(WAVE_MAPPER)   // assume waveIn will translate WAVE_MAPPER?
                           , DRVM_MAPPER_PREFERRED_GET
                           , (DWORD_PTR) &dw1
                           , (DWORD_PTR) &dw2 );
    }
    if( MMSYSERR_NOERROR == mmr )
    {
        UINT uiPrefDevId = (UINT)dw1;
        TCHAR *szPname;
        if (bOutput) {
            WAVEOUTCAPS woCaps;
            szPname = woCaps.szPname;
            mmr = waveOutGetDevCaps( uiPrefDevId
                                  , &woCaps
                                  , sizeof( woCaps ) );
        } else {
            WAVEINCAPS wiCaps;
            szPname = wiCaps.szPname;
            mmr = waveInGetDevCaps( uiPrefDevId
                                  , &wiCaps
                                  , sizeof( wiCaps ) );
        }
        if( ( MMSYSERR_NOERROR == mmr ) && ( ( (UINT)-1 ) != uiPrefDevId ) )
        {
            lstrcpy( szNamePreferredDevice, szPname );
        }
        else
        {
            DbgLog( ( LOG_ERROR
                  , 0
                  , TEXT("devenum: Failed to get preferred dev (%s for dev id %ld returned %ld)")
                  , bOutput ? TEXT("waveOutGetDevCaps") :
                              TEXT("waveInGetDevCaps")
                  , uiPrefDevId
                  , mmr ) );
            szNamePreferredDevice[0] = 0;
        }
    }
    else
    {
        // revert back to reading the registry to get the preferred device name
        DbgLog( ( LOG_ERROR
              , 5
              , TEXT("devenum: waveInMessage doesn't support DRVM_MAPPER_PREFERRED_GET (err = %ld). Reading registry instead...")
              , mmr ) );

        HKEY hkSoundMapper;
        LONG lResult = RegOpenKeyEx(
            HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Multimedia\\Sound Mapper"),
            0,                      // reserved
            KEY_READ,
            &hkSoundMapper);
        if(lResult == ERROR_SUCCESS)
        {
            DWORD dwType, dwcb = MAXPNAMELEN * sizeof(TCHAR);
            lResult = RegQueryValueEx(
                hkSoundMapper,
                szVal,
                0,                  // reserved
                &dwType,
                (BYTE *)szNamePreferredDevice,
                &dwcb);

            ASSERT(lResult == ERROR_SUCCESS ? dwType == REG_SZ : TRUE);
            EXECUTE_ASSERT(RegCloseKey(hkSoundMapper) == ERROR_SUCCESS);
        }

        if(lResult != ERROR_SUCCESS) {
            DbgLog((LOG_ERROR, 0, TEXT("devenum: couldn't get preferred %s device from registry"),
                    szVal));
            szNamePreferredDevice[0] = 0;
        }
    }
}

HRESULT CWaveInClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;
    m_pPreferredDevice = 0;

    HRESULT hr = S_OK;
    m_cWaveIn = waveInGetNumDevs();
    if(m_cWaveIn == 0)
    {
        hr = S_FALSE;
    }
    else
    {
        TCHAR szNamePreferredDevice[MAXPNAMELEN];
        GetPreferredDeviceName(szNamePreferredDevice, g_szInput, false);

        delete[] m_rgWaveIn;
        m_rgWaveIn = new LegacyWaveIn[m_cWaveIn];
        if(m_rgWaveIn == 0)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // save names
            for(UINT i = 0; i < m_cWaveIn; i++)
            {
                WAVEINCAPS wiCaps;

                if(waveInGetDevCaps(i, &wiCaps, sizeof(wiCaps)) == MMSYSERR_NOERROR)
                {
                    m_rgWaveIn[i].dwWaveId = i;
                    lstrcpy(m_rgWaveIn[i].szName, wiCaps.szPname);

                    if(lstrcmp(wiCaps.szPname, szNamePreferredDevice) == 0)
                    {
                        ASSERT(m_pPreferredDevice == 0);
                        m_pPreferredDevice = &m_rgWaveIn[i];
                    }
                }
                else
                {
                    DbgLog((LOG_ERROR, 0, TEXT("waveInGetDevCaps failed")));
                    m_cWaveIn = i;
                    break;
                }
            }

            if(m_pPreferredDevice == 0) {
                m_pPreferredDevice = &m_rgWaveIn[0];
            }
        }
    }
    int cKsProxy = 0;
    if( S_OK == hr && m_bEnumKs )
    {
        PNP_PERF(static int k  = MSR_REGISTER("ksproxy audio capture device enum"));
        PNP_PERF(MSR_INTEGER(k, 1));
        // now handle any pnp devices that we register locally (so far this is only ksproxy audio devices)
        hr = ReadLocallyRegisteredPnpDevData();
        if( SUCCEEDED( hr ) )
            cKsProxy = m_lKsProxyAudioDevices.GetCount();
        else
            DbgLog( ( LOG_ERROR
                    , 1
                    , TEXT("ReadLegacyDeviceNames - ReadLocallyRegisteredPnpDevData failed[0x%08lx]")
                    , hr ) );

        PNP_PERF(MSR_INTEGER(k, 2));

        // NOTE!! should we return hr?
    }

    m_cNotMatched = m_cWaveIn + cKsProxy;
    return S_OK;
}

// the names and preferred devices need to match.
//

BOOL CWaveInClassManager::MatchString(IPropertyBag *pPropBag)
{
    BOOL fReturn = FALSE;

    VARIANT varName, varDefaultDevice, varDevId;
    varName.vt = VT_EMPTY;
    varDefaultDevice.vt = VT_I4;
    varDevId.vt = VT_I4;

    USES_CONVERSION;
    HRESULT hr = pPropBag->Read(T2COLE(m_szUniqueName), &varName, 0);
    if(SUCCEEDED(hr))
    {
        hr = pPropBag->Read(g_wszClassManagerFlags, &varDefaultDevice, 0);

        bool fPreferred = SUCCEEDED(hr) && (varDefaultDevice.lVal & CLASS_MGR_DEFAULT);

        for (UINT i = 0; i < m_cWaveIn; i++)
        {
            // xnor: is the preferred flag the same in the both places?
            if(fPreferred == (m_pPreferredDevice == &m_rgWaveIn[i]))
            {
                if (lstrcmp(m_rgWaveIn[i].szName, OLE2T(varName.bstrVal)) == 0)
                {
                    // last check, make sure device id hasn't changed!
                    hr = pPropBag->Read(g_wszDriverIndex, &varDevId, 0);
                    if( SUCCEEDED( hr ) && ( m_rgWaveIn[i].dwWaveId == (DWORD)varDevId.lVal ) )
                    {
                        fReturn = TRUE;
                        break;
                    }
                    else
                        DbgLog( ( LOG_TRACE
                              , 5
                              , TEXT("CWaveInClassManager: device ids changed (prop bag has %d, wo has %d)!")
                              , varDevId.lVal
                              , m_rgWaveIn[i].dwWaveId ) );
                }
            }
        }

        const TCHAR *szKsDevName = W2CT( varName.bstrVal );
        if( szKsDevName )
        {
            for(POSITION pos = m_lKsProxyAudioDevices.GetHeadPositionI();
                pos && !fReturn;
                pos = m_lKsProxyAudioDevices.Next(pos))
            {
                KsProxyAudioDev *pksp = m_lKsProxyAudioDevices.Get(pos);
                if( lstrcmp( pksp->szName, szKsDevName ) == 0 )
                {
                    // lastly, make sure device path hasn't changed
                    VARIANT varDevPath;
                    varDevPath.vt = VT_EMPTY;
                    
                    hr = pPropBag->Read(L"DevicePath", &varDevPath, 0);
                    if( SUCCEEDED( hr ) )
                    {
                        if( 0 == lstrcmp( pksp->lpstrDevicePath, W2T( varDevPath.bstrVal ) ) )
                        {
                            fReturn = TRUE;
                            DbgLog((LOG_TRACE, 5, TEXT("CWaveOutClassManager: matched %S"),
                                    varName.bstrVal));
                        }
                        else
                        {                        
                            DbgLog( ( LOG_TRACE
                                  , 5
                                  , TEXT("CWaveInClassManager: device path changed for ksproxy capture filter") ) );
                        }
                        SysFreeString( varDevPath.bstrVal );
                        
                        if( fReturn )
                            break;
                    }                                                          
                }
            }
        }

        SysFreeString(varName.bstrVal);
    }

    return fReturn;
}

HRESULT CWaveInClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_AudioInputDeviceCategory);

    USES_CONVERSION;

    ReadLegacyDevNames();
    for (DWORD i = 0; i < m_cWaveIn; i++)
    {
        const WCHAR *wszUniq = T2COLE(m_rgWaveIn[i].szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = 0;

        IMoniker *pMoniker = 0;
        HRESULT hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AudioRecord,
            wszUniq,
            &pMoniker,
            &CLSID_AudioInputDeviceCategory,
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = i;
                hr = pPropBag->Write(g_wszDriverIndex, &var);

                if(SUCCEEDED(hr) && m_pPreferredDevice == &m_rgWaveIn[i])
                {
                    VARIANT var;
                    var.vt = VT_I4;
                    var.lVal = CLASS_MGR_DEFAULT;
                    hr = pPropBag->Write(g_wszClassManagerFlags, &var);
                }

                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    } // for

    for( POSITION pos = m_lKsProxyAudioDevices.GetHeadPositionI();
         pos;
         pos = m_lKsProxyAudioDevices.Next(pos) )
    {
        KsProxyAudioDev *pksp = m_lKsProxyAudioDevices.Get( pos );

        const WCHAR *wszUniq = T2CW( pksp->szName );

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = MERIT_DO_NOT_USE;
        rf2.cPins = 0;
        rf2.rgPins = 0;

        IMoniker *pMoniker = 0;
        HRESULT hr = RegisterClassManagerFilter(
            pFm2,
            pksp->clsid,
            wszUniq,
            &pMoniker,
            &CLSID_AudioInputDeviceCategory,
            wszUniq,
            &rf2);
        ASSERT( SUCCEEDED( hr ) );
        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString( T2CW( pksp->lpstrDevicePath ) );
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(L"DevicePath", &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    }

    return S_OK;
}


HRESULT CWaveInClassManager::ReadLocallyRegisteredPnpDevData()
{
    ASSERT( m_bEnumKs );

    DelLocallyRegisteredPnpDevData();

    const CLSID *rgpclsidKsCat[2];
    rgpclsidKsCat[0] = &KSCATEGORY_AUDIO_DEVICE;
    rgpclsidKsCat[1] = 0;

    HRESULT hr = BuildPnpAudDeviceList( rgpclsidKsCat
                                      , m_lKsProxyAudioDevices
                                      , KSAUD_F_ENUM_WAVE_CAPTURE);
    return hr;
}


void CWaveInClassManager::DelLocallyRegisteredPnpDevData()
{
    KsProxyAudioDev *pksp;
    for(; pksp = m_lKsProxyAudioDevices.RemoveHead(); )
    {
        if( pksp->pPropBag )
            pksp->pPropBag->Release();

        delete[] pksp->lpstrDevicePath;
        delete[] pksp->szName;
        delete pksp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\waveoutp.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "stdafx.h"
#include "waveOutp.h"
#include "util.h"
#include "mmreg.h"

const TCHAR g_szDriverClsid[] = TEXT("CLSID");
const WCHAR g_wszDriverIndex[] = L"WaveOutId";
const TCHAR g_szWaveoutDriverIndex[] = TEXT("WaveOutId");
const TCHAR g_szDsoundDriverIndex[] = TEXT("DSGuid");
const TCHAR g_szOutput[] = TEXT("Playback");

const AMOVIESETUP_MEDIATYPE wavOpPinTypes =
{
    &MEDIATYPE_Audio,
    &MEDIASUBTYPE_NULL
};

// static BOOL __stdcall DSoundCallback(
//     GUID FAR * lpGuid,
//     LPSTR lpstrDescription,
//     LPSTR lpstrModule,
//     LPVOID lpContext)
// {
//     return CWaveOutClassManager::DSoundCallback(
//         lpGuid, lpstrDescription, lpstrModule, lpContext);
// }

// dsound accepts only pcm and float, waveout accepts any audio
const AMOVIESETUP_MEDIATYPE
wavInPinTypes = { &MEDIATYPE_Audio, &MEDIASUBTYPE_NULL };

const AMOVIESETUP_MEDIATYPE
dsoundInPinTypes[] =
{
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_PCM },
    // kmixer supports float & DRM natively, legacy dsound doesn't
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_DRM_Audio },
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_IEEE_FLOAT },
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_DOLBY_AC3_SPDIF }, // turn on ac3/spdif compressed formats for dsound
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_RAW_SPORT },
    { &MEDIATYPE_Audio, &MEDIASUBTYPE_SPDIF_TAG_241h }
};

const AMOVIESETUP_PIN
waveOutInPin = { NULL              // pin name
               , TRUE              // bRendered
               , FALSE             // bOutput
               , FALSE             // bZero
               , FALSE             // bMany
               , &CLSID_NULL       // clsConnectToFilter
               , NULL              // strConnectsToPin
               , 1                 // nMediaTypes
               , &wavOpPinTypes }; // lpMediaTypes

const AMOVIESETUP_PIN
dsoundInPin = {  NULL              // pin name
               , TRUE              // bRendered
               , FALSE             // bOutput
               , FALSE             // bZero
               , FALSE             // bMany
               , &CLSID_NULL       // clsConnectToFilter
               , NULL              // strConnectsToPin
               , NUMELMS(dsoundInPinTypes)                 // nMediaTypes
               , dsoundInPinTypes }; // lpMediaTypes


CWaveOutClassManager::CWaveOutClassManager() :
        CClassManagerBase(TEXT("FriendlyName")),
        m_lWaveoutDevices(NAME("waveout dev list"), 10),
        m_lDSoundDevices(NAME("dsound dev list"), 10)
{
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    BOOL f = GetVersionEx(&osvi);
    ASSERT(f);

    // use dsound on nt4 to work around latency problems and
    // crash. couldn't see any relevant entries in dscaps
    m_fUseWaveoutNotDsound = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
                              osvi.dwMajorVersion <= 4);

    m_hDSoundInstance = 0;
    m_pDirectSoundEnumerate = 0;

    PNP_PERF(static int i = MSR_REGISTER("dsound"));
    PNP_PERF(MSR_INTEGER(i, 1));


    PNP_PERF(MSR_INTEGER(i, 2));

}

CWaveOutClassManager::~CWaveOutClassManager()
{
    DelNames();

    // don't free it because the dsound renderer will usually just
    // load it again.

//      if(m_hDSoundInstance)
//      {
//          FreeLibrary(m_hDSoundInstance);
//      }
}

void CWaveOutClassManager::DelNames()
{
    LegacyWaveOut *plwo;
    for(; plwo = m_lWaveoutDevices.RemoveHead(); )
        delete plwo;
    DSoundDev *pdsd;
    for(; pdsd = m_lDSoundDevices.RemoveHead(); )
    {
        delete pdsd->szName;
        delete pdsd;
    }

}

HRESULT CWaveOutClassManager::ReadLegacyDevNames()
{
    m_cNotMatched = 0;
    DelNames();
    m_pPreferredDevice = 0;

    TCHAR szNamePreferredDevice[MAXPNAMELEN];
    extern void GetPreferredDeviceName(TCHAR szNamePreferredDevice[MAXPNAMELEN],
                                       const TCHAR *szVal, bool bOutput);
    if (m_fDoAllDevices) {
        GetPreferredDeviceName(szNamePreferredDevice, g_szOutput, true);
    }

    HRESULT hr = S_OK;

    // old waveOut devices
    WAVEOUTCAPS wiCaps;
    if (m_fDoAllDevices) {
        for(UINT i = 0;
            SUCCEEDED(hr) &&
                waveOutGetDevCaps(i, &wiCaps, sizeof(wiCaps)) == MMSYSERR_NOERROR;
            i++)
        {
            LegacyWaveOut *plwo = new LegacyWaveOut;
            if(plwo)
            {
                if(i == 0) {
                    m_pPreferredDevice = plwo;
                }

                lstrcpy(plwo->szName, wiCaps.szPname);
                plwo->dwWaveId = i;
                plwo->dwMerit = MERIT_DO_NOT_USE;

                if(lstrcmp(plwo->szName, szNamePreferredDevice) == 0)
                {
                    m_pPreferredDevice = plwo;
                }

                if(!m_lWaveoutDevices.AddTail(plwo)) {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    if (m_fDoAllDevices || m_fUseWaveoutNotDsound) {
        LegacyWaveOut *plwo = new LegacyWaveOut;
        if(plwo)
        {
            int ret = LoadString(
                _Module.GetResourceInstance(), IDS_WAVEOUTMAPPER,
                plwo->szName, MAXPNAMELEN);
            ASSERT(ret);

            plwo->dwWaveId = WAVE_MAPPER;
            plwo->dwMerit = m_fUseWaveoutNotDsound ? MERIT_PREFERRED : MERIT_DO_NOT_USE;
            m_lWaveoutDevices.AddTail(plwo);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (m_fDoAllDevices) {
        m_hDSoundInstance = LoadLibrary(TEXT("dsound.dll"));
        if(m_hDSoundInstance)
        {
            m_pDirectSoundEnumerate = (PDirectSoundEnumerate)GetProcAddress(
                m_hDSoundInstance,
#ifdef UNICODE
                "DirectSoundEnumerateW"
#else
                "DirectSoundEnumerateA"
#endif
                );
        }
    }

    if(SUCCEEDED(hr) && m_pDirectSoundEnumerate)
    {

        m_hrEnum = S_OK;
        LPDSENUMCALLBACK dscb = DSoundCallback;
        BOOL f = m_pDirectSoundEnumerate( dscb, (void *)this );

        if(f != DS_OK || FAILED(m_hrEnum))
        {
            DbgLog((LOG_ERROR, 1, TEXT("dsound enum failed %08x. so what."),
                    m_hrEnum));
        }
    }

    // always add in the default dsound device
    if(SUCCEEDED(hr) && (m_fDoAllDevices || !m_fUseWaveoutNotDsound))
    {
        DSoundDev *pdsd = new DSoundDev;
        if(pdsd)
        {
            TCHAR szDSoundName[100];
            int ret = LoadString(
                _Module.GetResourceInstance(), IDS_DSOUNDDEFAULTDEVICE,
                szDSoundName, 100);
            ASSERT(ret);

            pdsd->szName = new TCHAR[lstrlen(szDSoundName) + 1];
            if(pdsd->szName)
            {
                lstrcpy(pdsd->szName, szDSoundName);

                pdsd->guid = GUID_NULL; // used by dsr.cpp for default device
                pdsd->dwMerit = m_fUseWaveoutNotDsound ? MERIT_DO_NOT_USE : MERIT_PREFERRED;

                m_lDSoundDevices.AddTail(pdsd);
            }
            else
            {
                delete pdsd;
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    m_cNotMatched = m_lWaveoutDevices.GetCount() + m_lDSoundDevices.GetCount();

    return hr;
}

BOOL CWaveOutClassManager::DSoundCallback(
    GUID FAR * lpGuid,
    LPCTSTR lpstrDescription,
    LPCTSTR lpstrModule,
    LPVOID lpContext)
{
    CWaveOutClassManager *pThis = (CWaveOutClassManager *)lpContext;
    ASSERT(pThis->m_hrEnum == S_OK);

    if(lpGuid)
    {
        DSoundDev *pdsd = new DSoundDev;
        if(pdsd)
        {
            TCHAR szDSoundFmt[100];
            int ret = LoadString(
                _Module.GetResourceInstance(), IDS_DSOUNDPREFIX,
                szDSoundFmt, 100);

            pdsd->szName = new TCHAR[lstrlen(lpstrDescription) + 1 +
                                    lstrlen(szDSoundFmt) + 1];
            if(pdsd->szName)
            {
                wsprintf(pdsd->szName, szDSoundFmt, lpstrDescription);

                pdsd->guid = *lpGuid;
                pdsd->dwMerit = MERIT_DO_NOT_USE;

                pThis->m_lDSoundDevices.AddTail(pdsd);
            }
            else
            {
                delete pdsd;
                pThis->m_hrEnum = E_OUTOFMEMORY;
            }
        }
        else
        {
            pThis->m_hrEnum = E_OUTOFMEMORY;
        }
    }

    return SUCCEEDED(pThis->m_hrEnum);
}

BOOL CWaveOutClassManager::MatchString(IPropertyBag *pPropBag)
{
    BOOL fReturn = FALSE;

    VARIANT varName, varDefaultDevice, varDevId;
    varName.vt = VT_EMPTY;
    varDefaultDevice.vt = VT_I4;
    varDevId.vt = VT_I4;

    USES_CONVERSION;
    HRESULT hr = pPropBag->Read(T2COLE(m_szUniqueName), &varName, 0);
    if(SUCCEEDED(hr))
    {
        hr = pPropBag->Read(g_wszClassManagerFlags, &varDefaultDevice, 0);
        bool fPreferred = SUCCEEDED(hr) && (varDefaultDevice.lVal & CLASS_MGR_DEFAULT);
        TCHAR *szDevName = OLE2T(varName.bstrVal);

        for(POSITION pos = m_lWaveoutDevices.GetHeadPositionI();
            pos && !fReturn;
            pos = m_lWaveoutDevices.Next(pos))
        {
            LegacyWaveOut *plwo = m_lWaveoutDevices.Get(pos);

            // xnor: is the preferred flag the same in the both places?
            if(fPreferred == (m_pPreferredDevice == plwo))
            {
                if (lstrcmp(plwo->szName, szDevName) == 0)
                {
                    DbgLog((LOG_TRACE, 5, TEXT("CWaveOutClassManager: matched %S"),
                            varName.bstrVal));

                    // last check, make sure device id hasn't changed!
                    hr = pPropBag->Read(g_wszDriverIndex, &varDevId, 0);
                    if( SUCCEEDED( hr ) && ( plwo->dwWaveId == (DWORD)varDevId.lVal ) )
                        fReturn = TRUE;
                    else
                        DbgLog( ( LOG_TRACE
                              , 5
                              , TEXT("CWaveOutClassManager: device ids changed (prop bag has %d, wo has %d)!")
                              , varDevId.lVal
                              , plwo->dwWaveId ) );
                }
            }
        }

        for(pos = m_lDSoundDevices.GetHeadPositionI();
            pos && !fReturn;
            pos = m_lDSoundDevices.Next(pos))
        {
            DSoundDev *pdsd = m_lDSoundDevices.Get(pos);
            if(lstrcmp(pdsd->szName, szDevName) == 0)
            {
                DbgLog((LOG_TRACE, 5, TEXT("CWaveOutClassManager: matched %S"),
                        varName.bstrVal));
                fReturn = TRUE;
            }
        }

        SysFreeString(varName.bstrVal);
    }

    return fReturn;
}

HRESULT CWaveOutClassManager::CreateRegKeys(IFilterMapper2 *pFm2)
{
    ResetClassManagerKey(CLSID_AudioRendererCategory);

    USES_CONVERSION;
    HRESULT hr = S_OK;

    ReadLegacyDevNames();

    for(POSITION pos = m_lWaveoutDevices.GetHeadPositionI();
        pos;
        pos = m_lWaveoutDevices.Next(pos))
    {
        LegacyWaveOut *plwo = m_lWaveoutDevices.Get(pos);

        const WCHAR *wszUniq = T2COLE(plwo->szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = plwo->dwMerit;
        rf2.cPins = 1;
        rf2.rgPins = &waveOutInPin;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_AudioRender,
            wszUniq,
            &pMoniker,
            &CLSID_AudioRendererCategory,
            wszUniq,
            &rf2);
        if(SUCCEEDED(hr))
        {
            CComPtr<IPropertyBag> pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = plwo->dwWaveId;
                hr = pPropBag->Write(g_wszDriverIndex, &var);
            }


            if(SUCCEEDED(hr) && m_pPreferredDevice == plwo)
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = CLASS_MGR_DEFAULT;
                hr = pPropBag->Write(g_wszClassManagerFlags, &var);
            }

            pMoniker->Release();
        }
        else
        {
            break;
        }

    } // for

    for(pos = m_lDSoundDevices.GetHeadPositionI();
        pos;
        pos = m_lDSoundDevices.Next(pos))
    {
        DSoundDev *pdsd = m_lDSoundDevices.Get(pos);

        const WCHAR *wszUniq = T2CW(pdsd->szName);

        REGFILTER2 rf2;
        rf2.dwVersion = 1;
        rf2.dwMerit = pdsd->dwMerit;
        rf2.cPins = 1;
        rf2.rgPins = &dsoundInPin;

        IMoniker *pMoniker = 0;
        hr = RegisterClassManagerFilter(
            pFm2,
            CLSID_DSoundRender,
            wszUniq,
            &pMoniker,
            &CLSID_AudioRendererCategory,
            wszUniq,
            &rf2);

        if(SUCCEEDED(hr))
        {
            IPropertyBag *pPropBag;
            hr = pMoniker->BindToStorage(
                0, 0, IID_IPropertyBag, (void **)&pPropBag);
            if(SUCCEEDED(hr))
            {
                WCHAR szGuid[CHARS_IN_GUID];
                StringFromGUID2(pdsd->guid, szGuid, CHARS_IN_GUID);

                VARIANT var;
                var.vt = VT_BSTR;
                var.bstrVal = SysAllocString(szGuid);
                if(var.bstrVal)
                {
                    hr = pPropBag->Write(L"DSGuid", &var);
                    SysFreeString(var.bstrVal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                pPropBag->Release();
            }
            pMoniker->Release();
        }
        else
        {
            break;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\waveinp.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include "resource.h"
#include "cmgrbase.h"
#include "ksaudio.h"

class CWaveInClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CWaveInClassManager,&CLSID_CWaveinClassManager>
{
    struct LegacyWaveIn
    {
        TCHAR szName[MAXPNAMELEN];
        DWORD dwWaveId;
    } *m_rgWaveIn;

    CGenericList<KsProxyAudioDev> m_lKsProxyAudioDevices;
    void DelLocallyRegisteredPnpDevData();

    ULONG m_cWaveIn;
    BOOL  m_bEnumKs;

    // pointer to element in the array. 
    LegacyWaveIn *m_pPreferredDevice;

public:

    CWaveInClassManager();
    ~CWaveInClassManager();

    BEGIN_COM_MAP(CWaveInClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CWaveInClassManager) ;
    DECLARE_NO_REGISTRY();
    
    HRESULT ReadLegacyDevNames();
    HRESULT ReadLocallyRegisteredPnpDevData();
    BOOL MatchString(IPropertyBag *pPropBag);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\waveoutp.h ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
// class managwer for audio renderers (waveOut and DSound)

#include "resource.h"
#include "cmgrbase.h"

#include <dsound.h>


class CWaveOutClassManager :
    public CClassManagerBase,
    public CComObjectRoot,
    public CComCoClass<CWaveOutClassManager,&CLSID_CWaveOutClassManager>
{
    struct LegacyWaveOut
    {
        TCHAR szName[MAXPNAMELEN];
        DWORD dwMerit;
        DWORD dwWaveId;
    };

    CGenericList<LegacyWaveOut> m_lWaveoutDevices;

    struct DSoundDev
    {
        TCHAR *szName;
        GUID guid;
        DWORD dwMerit;
    };

    CGenericList<DSoundDev> m_lDSoundDevices;

    static BOOL DSoundCallback(
        GUID FAR * lpGuid,
        LPCTSTR lpstrDescription,
        LPCTSTR lpstrModule,
        LPVOID lpContext);

    HRESULT m_hrEnum;

    void DelNames();

    // instance handle to dsound.dll
    HINSTANCE           m_hDSoundInstance;

    typedef HRESULT (/* WINAPI */ *PDirectSoundEnumerateW)(
        LPDSENUMCALLBACKW lpCallback, LPVOID lpContext
        );
    typedef HRESULT (/* WINAPI */ *PDirectSoundEnumerateA)(
        LPDSENUMCALLBACKA lpCallback, LPVOID lpContext
        );

#ifdef UNICODE
    typedef PDirectSoundEnumerateW PDirectSoundEnumerate;
#else
    typedef PDirectSoundEnumerateA PDirectSoundEnumerate;
#endif

    PDirectSoundEnumerate m_pDirectSoundEnumerate;

    bool m_fUseWaveoutNotDsound;

    // pointer to element in the list.
    LegacyWaveOut *m_pPreferredDevice;

public:

    CWaveOutClassManager();
    ~CWaveOutClassManager();

    BEGIN_COM_MAP(CWaveOutClassManager)
	COM_INTERFACE_ENTRY2(IDispatch, ICreateDevEnum)
	COM_INTERFACE_ENTRY(ICreateDevEnum)
    END_COM_MAP();

    DECLARE_NOT_AGGREGATABLE(CWaveOutClassManager) ;
    DECLARE_NO_REGISTRY();

    HRESULT ReadLegacyDevNames();
    BOOL MatchString(IPropertyBag *pPropBag);
    HRESULT CreateRegKeys(IFilterMapper2 *pFm2);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\fakein.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>

// Generic Renderer Filter
//
// David Maymudes (davidmay@microsoft.com)  October 1996
//

// Basic usage method:
// Create a CFakeIn filter, add it to a graph.
// When you create it, you specify a media type that it will accept
//     and a callback for when new frames arrive
// It will have an input pin; connect something to that input pin.
// Run the graph, and your callback will be called with frames as they're ready.
// You probably want to do a SetSyncSource(NULL) on the graph, so that
//     it will run as fast as you can process the incoming frames.
// 


// Issues/to do:
// sufficient seeking support?
// more methods in callback?
// should support list of media types, not just one
// do we need a better C-style API, so we can hide the class definition?
// do we need to support changing media types on the fly?


interface IFakeInAppCallback : public IUnknown
{
    // convention: call with NULL for EOS, or is that dumb?
    virtual HRESULT FrameReady(IMediaSample *pSample) = 0;
};

//=============
// CFakeIn
//=============

/* Implements the input pin */
class CFakeIn;

class CFakeInPin : public CBaseInputPin
{
    CFakeIn *m_pFilter;

public:

    /* Constructor */

    CFakeInPin(CFakeIn *pBaseFilter, HRESULT * phr);

    /* Override pure virtual - return the media type supported */
    HRESULT ProposeMediaType(CMediaType* mtIn);

    /* Check that we can support this output type */
    HRESULT CheckMediaType(const CMediaType* mtOut);

    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

    /* Called from CBaseOutputPin to prepare the allocator's buffers */
    HRESULT DecideBufferSize(IMemAllocator * pAllocator);

    // return the allocator interface that this input pin
    // would like the output pin to use
    STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);

    // tell the input pin which allocator the output pin is actually
    // going to use.
    STDMETHODIMP NotifyAllocator(
                    IMemAllocator * pAllocator,
                    BOOL bReadOnly);

    STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps);
    
    // do something with this media sample
    STDMETHODIMP Receive(IMediaSample *pSample);

    STDMETHODIMP EndOfStream();

    // !!! do we need begin/end flush?
};

class CFakeIn : public CBaseFilter
{
    
public:

    /* Constructors etc */

    CFakeIn(LPUNKNOWN punk, 
	     HRESULT *phr,
	     AM_MEDIA_TYPE *pmt,
	     LONG lSize,
	     IFakeInAppCallback *pCallback);
    ~CFakeIn();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    
public:

    IBaseFilter * GetFilter();

    /* Return the number of pins and their interfaces */

    CBasePin *GetPin(int n);
    int GetPinCount() {
	return 1;
    };

#ifndef FAKEIN_NOSEEKING
    CRendererPosPassThru *m_pPosition;
#endif
    
public:

    /* Let the pin access our private state */

    friend class CFakeInPin;

    CFakeInPin		*m_pInputPin;
    CMediaType		 m_cmt;

    ALLOCATOR_PROPERTIES m_Properties;
    IMemAllocator	*m_pAlloc;
    BOOL		 m_fNeedToCopy;

    IFakeInAppCallback	*m_pCallback;
    
    CCritSec		 m_cs;



    HRESULT SetAllocator(IMemAllocator *pAlloc)
    {
	m_pAlloc = pAlloc; 
	if (pAlloc)
	    pAlloc->AddRef();
	return S_OK;
    }


};

/* Constructor */

CFakeIn::CFakeIn(
    IUnknown *punkOuter,
    HRESULT *phr,
    AM_MEDIA_TYPE *pmt,
    LONG lSize,
    IFakeInAppCallback *pCallback)
    : CBaseFilter(NAME("Filter interfaces"), punkOuter, &m_cs, CLSID_NULL),
    m_pAlloc(NULL)
{
    m_cmt = *pmt;

    m_Properties.cBuffers = 1; // !!!
    m_Properties.cbBuffer = lSize;
    m_Properties.cbPrefix = 0;
    m_Properties.cbAlign = 1;
    
    // create as many pins as necessary...
    //
    m_pInputPin = new CFakeInPin(this, phr);

    m_pCallback = pCallback;

    if (pCallback)
	pCallback->AddRef();

#ifndef FAKEIN_NOSEEKING
    m_pPosition = new CRendererPosPassThru(NAME("Renderer CPosPassThru"),
					   CBaseFilter::GetOwner(), phr,
					   (IPin *) GetPin(0));
#endif
    
    m_fNeedToCopy = FALSE;
}

// Overriden to say what interfaces we support and where

STDMETHODIMP CFakeIn::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    // Do we have this interface

#ifndef FAKEIN_NOSEEKING
    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        return m_pPosition->NonDelegatingQueryInterface(riid,ppv);
    } else
#endif
    {
        return CBaseFilter::NonDelegatingQueryInterface(riid,ppv);
    }
}

CFakeIn::~CFakeIn()
{
    if (m_pCallback)
	m_pCallback->Release();

    if (m_pAlloc)
	m_pAlloc->Release();
    
    delete m_pInputPin;
    
#ifndef FAKEIN_NOSEEKING
    delete m_pPosition;
#endif
}

/* Return our single output pin - not AddRef'd */

CBasePin *CFakeIn::GetPin(int n)
{
    /* We only support one output pin and it is numbered zero */
    ASSERT(n == 0);
    if (n != 0) {
	return NULL;
    }

    /* Return the pin not AddRef'd */
    return m_pInputPin;
}



/* Constructor */

CFakeInPin::CFakeInPin(
    CFakeIn *pFakeIn,
    HRESULT *phr)
    : CBaseInputPin(NAME("Test Input pin"), pFakeIn, &pFakeIn->m_cs, phr, L"Pin")
{
    m_pFilter = pFakeIn;
}


// !!! does an input pin need this?
HRESULT CFakeInPin::ProposeMediaType(CMediaType *pmtOut)
{
    /* Set the media type we like */

    *pmtOut = m_pFilter->m_cmt;

    return NOERROR;
}

// !!! does an input pin need this?
HRESULT CFakeInPin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition < 0)
	return E_FAIL;
    else if (iPosition > 0)
	return VFW_S_NO_MORE_ITEMS; /// end of ???

    *pMediaType = m_pFilter->m_cmt;
    return S_OK;
}

HRESULT CFakeInPin::CheckMediaType(const CMediaType* pmtOut) 
{
    return AreMediaTypesCloseEnough(pmtOut, &m_pFilter->m_cmt) ? NOERROR : E_FAIL;
}

HRESULT CFakeInPin::GetAllocator(IMemAllocator ** ppAllocator)
{
    // if there's an overridden allocator, use this one.
    if (m_pFilter->m_pAlloc) {
	m_pFilter->m_pAlloc->AddRef();
	*ppAllocator = m_pFilter->m_pAlloc;

	return S_OK;
    }
    
    return CBaseInputPin::GetAllocator(ppAllocator);
}

HRESULT CFakeInPin::NotifyAllocator(
                    IMemAllocator * pAllocator,
                    BOOL bReadOnly)
{
    m_pFilter->m_fNeedToCopy = FALSE;
    // if not our allocator, need to copy
    if (m_pFilter->m_pAlloc && !IsEqualObject(pAllocator, m_pFilter->m_pAlloc)) {
	m_pFilter->m_fNeedToCopy = TRUE;
    }

    return CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
}

HRESULT CFakeInPin::GetAllocatorRequirements(ALLOCATOR_PROPERTIES*pProps)
{
    *pProps = m_pFilter->m_Properties;
    
    return S_OK;
}


HRESULT CFakeInPin::Receive(IMediaSample *pSample)
{
    if (m_pFilter->m_fNeedToCopy) {
	REFERENCE_TIME tStart, tStop;
	REFERENCE_TIME * pStart = NULL;
	REFERENCE_TIME * pStop = NULL;
	if (NOERROR == pSample->GetTime(&tStart, &tStop)) {
	    pStart = (REFERENCE_TIME*)&tStart;
	    pStop  = (REFERENCE_TIME*)&tStop;
	}

	IMediaSample *pOutSample;

	HRESULT hr = m_pFilter->m_pAlloc->GetBuffer(&pOutSample, pStart, pStop, 0);

	if (FAILED(hr))
	    return hr;

	BYTE *pData1, *pData2;
	pSample->GetPointer(&pData1);
	pOutSample->GetPointer(&pData2);

	pOutSample->SetTime(pStart, pStop);
	pOutSample->SetSyncPoint(pSample->IsSyncPoint() == S_OK);

	LONGLONG MediaStart, MediaEnd;
	if (pSample->GetMediaTime(&MediaStart,&MediaEnd) == NOERROR) {
	    pOutSample->SetMediaTime(&MediaStart,&MediaEnd);
	}

	LONG cb = pSample->GetActualDataLength();

	ASSERT(pOutSample->GetSize() >= cb);
	
	CopyMemory(pData2, pData1, cb);

	pOutSample->SetActualDataLength(cb);

	hr = m_pFilter->m_pCallback->FrameReady(pOutSample);

	pOutSample->Release();
	
	return hr;
    } 

    // allow different modes here:
    // immediate callback?
    return m_pFilter->m_pCallback->FrameReady(pSample);
    
}


// Called when no more data will arrive
HRESULT CFakeInPin::EndOfStream(void)
{
    return m_pFilter->m_pCallback->FrameReady(NULL);
}



HRESULT CreateFakeInput(CMediaType *pmt, CFakeIn **ppFakeIn, LONG lSize,
		       IFakeInAppCallback *pCallback)
{
    HRESULT hr = S_OK;
    
    *ppFakeIn = new CFakeIn(NULL, &hr, pmt, lSize, pCallback);

    if (!*ppFakeIn)
       hr = E_OUTOFMEMORY;

    if (FAILED(hr))
	delete *ppFakeIn;

    return hr;
}

IBaseFilter * CFakeIn::GetFilter()
{
    IBaseFilter * pFilter = NULL;
    HRESULT hr = NonDelegatingQueryInterface (IID_IBaseFilter, (LPVOID *)&pFilter);
    if (FAILED(hr))
	return NULL;
    return pFilter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\test\intfcdev.cpp ===
//
// This utility retrieves a list of all interface devices in the system, and prints them all out.
//
//  Format:  intfcdev
//

//#define UNICODE

#include <windows.h>
#include "setupapi.h"
#include "d:\nt\public\sdk\inc\regstr.h"

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#if _MSC_VER >= 1100
#include <atlbase.h>
#include <atlcom.h>
#else
#include "atlbase.h"
extern CComModule _Module;
#include "atlcom.h"
#endif

CComModule _Module;

#if _MSC_VER >= 1100
#include <atlimpl.cpp>
#else
#include "atlimpl.cpp"
#endif


#define GUID_STRING_LEN   (39)
#define MAX_DEVICE_ID_LEN (200) // as defined in cfgmgr32.h

BYTE  BinaryBuffer[4096];
TCHAR DevInstIdBuffer[MAX_DEVICE_ID_LEN];

int
_CRTAPI1
main(
    IN int   argc,
    IN char *argv[]
    )
{
    HDEVINFO hDevInfo;
    DWORD i, j;
    HKEY hKeyDevClassRoot;
    FILETIME LastWriteTime;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    WCHAR TempGuidString[GUID_STRING_LEN];
    GUID ClassGuid;
    SP_INTERFACE_DEVICE_DATA InterfaceDeviceData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA InterfaceDeviceDetailData;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD DataBufferSize;

    hDevInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_ALLCLASSES | DIGCF_INTERFACEDEVICE);

    if(hDevInfo == INVALID_HANDLE_VALUE) {
        wprintf(L"SetupDiGetClassDevs failed with %lx\n", GetLastError());
        return -1;
    }

    HDEVINFO hDevInfo2 = SetupDiCreateDeviceInfoList(0, 0);
    if(hDevInfo2 == INVALID_HANDLE_VALUE)
    {
        printf("SetupDiCreateDeviceInfoList failed\n");
        return -1;
    }

    

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REGSTR_PATH_DEVICE_CLASSES,
                    0,
                    KEY_READ,
                    &hKeyDevClassRoot) != ERROR_SUCCESS) {

        wprintf(L"Couldn't open DeviceClasses key!\n");
        return -1;
    }

    InterfaceDeviceData.cbSize = sizeof(SP_INTERFACE_DEVICE_DATA);
    InterfaceDeviceDetailData = (PSP_INTERFACE_DEVICE_DETAIL_DATA)BinaryBuffer;
    InterfaceDeviceDetailData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    for(i = 0, DataBufferSize = GUID_STRING_LEN;
        RegEnumKeyEx(hKeyDevClassRoot,
                     i,
                     InterfaceGuidString,
                     &DataBufferSize,
                     NULL,
                     NULL,
                     NULL,
                     &LastWriteTime) == ERROR_SUCCESS;
        i++, DataBufferSize = GUID_STRING_LEN)
    {
	USES_CONVERSION;
        if(CLSIDFromString(T2OLE(InterfaceGuidString), &ClassGuid) != NOERROR) {
            wprintf(L"We couldn't convert %s into a GUID--skip it.\n", T2W(InterfaceGuidString));
            continue;
        } else {
            wprintf(L"We're enumerating interface class %s\n", T2W(InterfaceGuidString));
        }

        for(j = 0;
            SetupDiEnumInterfaceDevice(hDevInfo, NULL, &ClassGuid, j, &InterfaceDeviceData);
            j++)
        {
            StringFromGUID2(InterfaceDeviceData.InterfaceClassGuid, TempGuidString, GUID_STRING_LEN);
            wprintf(L"For class %s, here's one:\n", TempGuidString);

            if(!SetupDiGetInterfaceDeviceDetail(hDevInfo,
                                                &InterfaceDeviceData,
                                                InterfaceDeviceDetailData,
                                                sizeof(BinaryBuffer),
                                                NULL,
                                                &DeviceInfoData)) {
                
                wprintf(L"SetupDiGetInterfaceDeviceDetail failed with %lx\n", GetLastError());
                continue;
            }

            wprintf(L"     %s (%lx)\n", T2W(InterfaceDeviceDetailData->DevicePath), InterfaceDeviceData.Flags);
            wprintf(L"     (associated device instance is:\n");

            if(!SetupDiGetDeviceInstanceId(hDevInfo,
                                           &DeviceInfoData,
                                           DevInstIdBuffer,
                                           MAX_DEVICE_ID_LEN,
                                           NULL)) {
                wprintf(L"SetupDiGetDeviceInstanceId failed with %lx\n", GetLastError());
                continue;
            }


            wprintf(L"    %s\n\n", T2W(DevInstIdBuffer));

            {
                SP_DEVINFO_DATA DevInfoData;
                DevInfoData.cbSize = sizeof(DevInfoData);
                DWORD cbRequiredSize;
                DWORD rgbInterfaceDeviceDetailData[0x1000];
                PSP_INTERFACE_DEVICE_DETAIL_DATA pInterfaceDeviceDetailData = (PSP_INTERFACE_DEVICE_DETAIL_DATA)rgbInterfaceDeviceDetailData;
                pInterfaceDeviceDetailData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
                
                BOOL f = SetupDiGetInterfaceDeviceDetail(
                    hDevInfo,
                    &InterfaceDeviceData,
                    pInterfaceDeviceDetailData,
                    sizeof(rgbInterfaceDeviceDetailData),
                    0,
                    &DevInfoData);
                if(!f)
                {
                    wprintf(L"SetupDiGetInterfaceDeviceDetail failed\n");
                    continue;
                }
                    
                    
                HKEY hkey = SetupDiOpenDevRegKey(
                    hDevInfo,
                    &DevInfoData,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DRV,
                    KEY_READ);

                if(hkey == INVALID_HANDLE_VALUE) {
                    wprintf(L"SetupDiOpenInterfaceDeviceRegKey failed with %lx\n", GetLastError());
                    continue;
                }
                RegCloseKey(hkey);

                {
                    SP_INTERFACE_DEVICE_DATA InterfaceDeviceData;
                    InterfaceDeviceData.cbSize = sizeof(SP_INTERFACE_DEVICE_DATA);
                    SP_DEVINFO_DATA DevInfoData;
                    f = SetupDiOpenInterfaceDevice(
                        hDevInfo2,
                        InterfaceDeviceDetailData->DevicePath,
                        0,
                        &InterfaceDeviceData);

                    if(!f)
                    {
                        printf("SetupDiOpenInterfaceDevice failed %08x\n", GetLastError());
                        continue;
                    }
                }
            }
        }
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);
    
    printf("now from the saved list\n");

    {
        USES_CONVERSION;
        
        for(j = 0;
            SetupDiEnumInterfaceDevice(hDevInfo2, NULL, &ClassGuid, j, &InterfaceDeviceData);
            j++)
        {
            StringFromGUID2(InterfaceDeviceData.InterfaceClassGuid, TempGuidString, GUID_STRING_LEN);
            wprintf(L"For class %s, here's one:\n", TempGuidString);

            if(!SetupDiGetInterfaceDeviceDetail(hDevInfo2,
                                                &InterfaceDeviceData,
                                                InterfaceDeviceDetailData,
                                                sizeof(BinaryBuffer),
                                                NULL,
                                                &DeviceInfoData)) {
                
                wprintf(L"SetupDiGetInterfaceDeviceDetail failed with %lx\n", GetLastError());
                continue;
            }

            wprintf(L"     %s (%lx)\n", T2W(InterfaceDeviceDetailData->DevicePath), InterfaceDeviceData.Flags);
            wprintf(L"     (associated device instance is:\n");

            if(!SetupDiGetDeviceInstanceId(hDevInfo2,
                                           &DeviceInfoData,
                                           DevInstIdBuffer,
                                           MAX_DEVICE_ID_LEN,
                                           NULL)) {
                wprintf(L"SetupDiGetDeviceInstanceId failed with %lx\n", GetLastError());
                continue;
            }


            wprintf(L"    %s\n\n", T2W(DevInstIdBuffer));

            {
                SP_DEVINFO_DATA DevInfoData;
                DevInfoData.cbSize = sizeof(DevInfoData);
                DWORD cbRequiredSize;
                DWORD rgbInterfaceDeviceDetailData[0x1000];
                PSP_INTERFACE_DEVICE_DETAIL_DATA pInterfaceDeviceDetailData = (PSP_INTERFACE_DEVICE_DETAIL_DATA)rgbInterfaceDeviceDetailData;
                pInterfaceDeviceDetailData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
                
                BOOL f = SetupDiGetInterfaceDeviceDetail(
                    hDevInfo2,
                    &InterfaceDeviceData,
                    pInterfaceDeviceDetailData,
                    sizeof(rgbInterfaceDeviceDetailData),
                    0,
                    &DevInfoData);
                if(!f)
                {
                    wprintf(L"SetupDiGetInterfaceDeviceDetail failed\n");
                    continue;
                }
                    
                    
                HKEY hkey = SetupDiOpenDevRegKey(
                    hDevInfo2,
                    &DevInfoData,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DRV,
                    KEY_READ);

                if(hkey == INVALID_HANDLE_VALUE) {
                    wprintf(L"SetupDiOpenInterfaceDeviceRegKey failed with %lx\n", GetLastError());
                    continue;
                }
                RegCloseKey(hkey);

            }
        }
    }

    SetupDiDestroyDeviceInfoList(hDevInfo2);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\fakeout.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>


// Generic Source Filter
//
// David Maymudes (davidmay@microsoft.com)  October 1996
//

// Basic usage method:
// Create a CFakeOut filter, add it to a graph.
// When you create it, you specify a media type that it will be producing.
// It will have an output pin; connect something to that pin, or Render it.\.
// Run the graph, and then start calling SendDataOut
// You might to do a SetSyncSource(NULL) on the graph if you're writing a
//     file or something.  Note that if you're connected to a renderer that's
//     drawing to the screen and you don't provide enough data, the results won't
//     be that great.
// 


// Issues/to do:
// sufficient seeking support?  Notify app when downstream filter wants to seek?
// do we need to support changing media types on the fly?
// do we need a better C-style API, so we can hide the class definition?
// Currently, SendDataOut copies everything, probably want some interface
//     that uses the GetBuffer/Send concept so that we can avoid the copy.









//=============
// CFakeOut
//=============

class CFakeOut : public CBaseFilter
{

public:

    /* Constructors etc */

    CFakeOut(LPUNKNOWN, 
	     HRESULT *,
	     DWORDLONG,
	     AM_MEDIA_TYPE *,
	     LONG);
    ~CFakeOut();

public:

    IBaseFilter * GetFilter();

    /* Return the number of pins and their interfaces */

    CBasePin *GetPin(int n);
    int GetPinCount() {
		return 1;
    };

    /* Implements the output pin */
    class CFakePin : public CBaseOutputPin
    {
	CFakeOut *m_pFilter;

    public:
	
	/* Constructor */

	CFakePin(CFakeOut *pBaseFilter, HRESULT * phr);

	/* Override pure virtual - return the media type supported */
	HRESULT ProposeMediaType(CMediaType* mtIn);

	/* Check that we can support this output type */
	HRESULT CheckMediaType(const CMediaType* mtOut);

	HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

	/* Called from CBaseOutputPin to prepare the allocator's buffers */
	HRESULT DecideBufferSize(IMemAllocator * pAllocator,
				 ALLOCATOR_PROPERTIES *pRequest);

	HRESULT DecideAllocator(IMemInputPin * pPin, IMemAllocator ** pAlloc);
	HRESULT InitAllocator(IMemAllocator **ppAlloc);

	
	// Override to handle quality messages
	STDMETHODIMP Notify(IBaseFilter * pSender, Quality q)
	{    return NOERROR;             // ??? Could do better?
	};
    };

public:

    /* Let the nested interfaces access out private state */

    friend class CFakePin;

    CFakePin   *m_pOutputPin;       // IPin and IMemOutputPin
    CMediaType  m_cmt;
    LONG        m_lMaxData;
    DWORDLONG   m_rate;   // duration of a single frame

    IMemAllocator *m_pForceAllocator;
    
    HRESULT SetAllocator(IMemAllocator *pAlloc)
    {
	m_pForceAllocator = pAlloc; 
	if (pAlloc)
	    pAlloc->AddRef();
	return S_OK;
    }

    CCritSec    m_cs;
};

/* Constructor */

CFakeOut::CFakeOut(
    IUnknown *punkOuter,
    HRESULT *phr,
    DWORDLONG rate,
    AM_MEDIA_TYPE *pmt,
    LONG lMaxData) : 
    CBaseFilter(NAME("Filter interfaces"), punkOuter, &m_cs, CLSID_NULL)
{
     m_cmt = *pmt;
     m_rate = rate;
     m_lMaxData = lMaxData;
     m_pForceAllocator = NULL;
     
     // create as many pins as necessary...
     //
     m_pOutputPin = new CFakePin(this, phr);


}


CFakeOut::~CFakeOut()
{
    if (m_pForceAllocator)
	m_pForceAllocator->Release();
    delete m_pOutputPin;
}



/* Return our single output pin - not AddRef'd */

CBasePin *CFakeOut::GetPin(int n)
{
    /* We only support one output pin and it is numbered zero */
    ASSERT(n == 0);
    if (n != 0) {
	return NULL;
    }

    /* Return the pin not AddRef'd */
    return m_pOutputPin;
}



/* Constructor */

CFakeOut::CFakePin::CFakePin(
    CFakeOut *pFakeOut,
    HRESULT *phr)
    : CBaseOutputPin(NAME("Test output pin"), pFakeOut, &pFakeOut->m_cs, phr, L"Pin")
{
    m_pFilter = pFakeOut;
}


HRESULT CFakeOut::CFakePin::ProposeMediaType(CMediaType *pmtOut)
{
    /* Set the media type we like */

    *pmtOut = m_pFilter->m_cmt;

    return NOERROR;
}

HRESULT CFakeOut::CFakePin::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition < 0)
	return E_FAIL;
    else if (iPosition > 0)
	return VFW_S_NO_MORE_ITEMS; /// end of ???

    *pMediaType = m_pFilter->m_cmt;
	return S_OK;
}




HRESULT CFakeOut::CFakePin::CheckMediaType(const CMediaType* pmtOut) 
{
    return AreMediaTypesCloseEnough(pmtOut, &m_pFilter->m_cmt) ? NOERROR : E_FAIL;
}


/* For simplicity we always ask for the maximum buffer ever required */

HRESULT CFakeOut::CFakePin::DecideBufferSize(IMemAllocator * pAllocator,
					     ALLOCATOR_PROPERTIES *pRequest)
{
    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr;     /* General OLE return code */

    pRequest->cBuffers = 1; // allow >1 if target wants?
    pRequest->cbBuffer = m_pFilter->m_lMaxData;
	
    hr = pAllocator->SetProperties(pRequest, &Actual);
    ASSERT(SUCCEEDED(hr));
    ASSERT(pRequest->cbBuffer > 0);
    ASSERT(pRequest->cBuffers > 0);
    ASSERT(pRequest->cbAlign > 0);

    return hr;
}


HRESULT CFakeOut::CFakePin::InitAllocator(IMemAllocator **ppAlloc)
{
    if (m_pFilter->m_pForceAllocator) {
	*ppAlloc = m_pFilter->m_pForceAllocator;
	(*ppAlloc)->AddRef;

	return S_OK;
    }

    return CBaseOutputPin::InitAllocator(ppAlloc);
}

HRESULT CFakeOut::CFakePin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT hr = NOERROR;
    *ppAlloc = NULL;

    // get downstream prop request
    ALLOCATOR_PROPERTIES prop;
    ZeroMemory(&prop, sizeof(prop));

    // whatever he returns, we assume prop is either all zeros
    // or he has filled it out.
    pPin->GetAllocatorRequirements(&prop);

    // if he doesn't care about alignment, then set it to 1
    if (prop.cbAlign == 0) {
        prop.cbAlign = 1;
    }

    if (!m_pFilter->m_pForceAllocator) {
	/* Try the allocator provided by the input pin */

	hr = pPin->GetAllocator(ppAlloc);
	if (SUCCEEDED(hr)) {

	    hr = DecideBufferSize(*ppAlloc, &prop);
	    if (SUCCEEDED(hr)) {
		hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
		if (SUCCEEDED(hr)) {
		    return NOERROR;
		}
	    }
	}

	/* If the GetAllocator failed we may not have an interface */

	if (*ppAlloc) {
	    (*ppAlloc)->Release();
	    *ppAlloc = NULL;
	}
    }

    /* Try the output pin's allocator by the same method */

    hr = InitAllocator(ppAlloc);
    if (SUCCEEDED(hr)) {

        // note - the properties passed here are in the same
        // structure as above and may have been modified by
        // the previous call to DecideBufferSize
	hr = DecideBufferSize(*ppAlloc, &prop);
	if (SUCCEEDED(hr)) {
	    hr = pPin->NotifyAllocator(*ppAlloc, FALSE);
	    if (SUCCEEDED(hr)) {
		return NOERROR;
	    }
	}
    }

    /* Likewise we may not have an interface to release */

    if (*ppAlloc) {
	(*ppAlloc)->Release();
	*ppAlloc = NULL;
    }
    return hr;
}




HRESULT CreateFakeOutput(AM_MEDIA_TYPE *pmt, LONG lMaxData, DWORDLONG rate, CFakeOut **ppFakeOut)
{
    HRESULT hr = S_OK;
    
    *ppFakeOut = new CFakeOut(NULL, &hr, rate, pmt, lMaxData);

    if (!*ppFakeOut)
       hr = E_OUTOFMEMORY;

    if (FAILED(hr))
	delete *ppFakeOut;

    return hr;
}

IBaseFilter * CFakeOut::GetFilter()
{
    IBaseFilter * pFilter = NULL;
    HRESULT hr = NonDelegatingQueryInterface (IID_IBaseFilter, (LPVOID *)&pFilter);
    if (FAILED(hr))
	return NULL;
    return pFilter;
}


/* Send a samples down the connection */

extern "C" HRESULT SendDataOut(
   CFakeOut *pFakeOut,
   LPVOID    pData,
   LONG      cbData,
   DWORD     nFrame)
{
    PMEDIASAMPLE pMediaSample;      // Media sample for buffers
    HRESULT hr = NOERROR;           // OLE Return code

    /* Fill in the next media sample's time stamps */

    REFERENCE_TIME tStart = pFakeOut->m_rate * nFrame;
    REFERENCE_TIME tEnd = tStart + pFakeOut->m_rate;

    hr = pFakeOut->m_pOutputPin->GetDeliveryBuffer(&pMediaSample, &tStart, &tEnd, 0);
    
    if (FAILED(hr)) {
	ASSERT(pMediaSample == NULL);
	return hr;
    }

    // !!! should check that buffer is big enough!!!
    
    BYTE *pSampleData;
    pMediaSample->GetPointer(&pSampleData);
    ASSERT(pSampleData != NULL);
    CopyMemory(pSampleData, pData, cbData);

    // set actual size of data
    pMediaSample->SetActualDataLength(cbData);

    pMediaSample->SetTime(&tStart, &tEnd);

    /* Deliver the media sample to the input pin */

    hr = pFakeOut->m_pOutputPin->Deliver(pMediaSample);

    /* Done with the buffer, the connected pin may AddRef it to keep it */

    pMediaSample->Release();
    return hr;
}


extern "C" HRESULT SendSampleOut(CFakeOut *pFakeOut, IMediaSample *pSample)
{
    // !!! should adjust sample times, perhaps?

    HRESULT hr = pFakeOut->m_pOutputPin->Deliver(pSample);

    return hr;
}

extern "C" HRESULT SendEndOfStream(CFakeOut *pFake)
{
    return pFake->m_pOutputPin->DeliverEndOfStream();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pnp\devenum\test\intfcdev.c ===
//
// This utility retrieves a list of all interface devices in the system, and prints them all out.
//
//  Format:  intfcdev
//

//#define UNICODE

#include <windows.h>
#include "setupapi.h"
#include "d:\ntbld\public\sdk\inc\regstr.h"

#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <objbase.h>

#include <atlbase.h>

#define GUID_STRING_LEN   (39)
#define MAX_DEVICE_ID_LEN (200) // as defined in cfgmgr32.h

BYTE  BinaryBuffer[4096];
TCHAR DevInstIdBuffer[MAX_DEVICE_ID_LEN];

int
_CRTAPI1
main(
    IN int   argc,
    IN char *argv[]
    )
{
    HDEVINFO hDevInfo;
    DWORD i, j;
    HKEY hKeyDevClassRoot;
    FILETIME LastWriteTime;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    TCHAR TempGuidString[GUID_STRING_LEN];
    GUID ClassGuid;
    SP_INTERFACE_DEVICE_DATA InterfaceDeviceData;
    PSP_INTERFACE_DEVICE_DETAIL_DATA InterfaceDeviceDetailData;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD DataBufferSize;

    hDevInfo = SetupDiGetClassDevs(NULL, NULL, NULL, DIGCF_ALLCLASSES | DIGCF_INTERFACEDEVICE);

    if(hDevInfo == INVALID_HANDLE_VALUE) {
        wprintf(L"SetupDiGetClassDevs failed with %lx\n", GetLastError());
        return -1;
    }

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    REGSTR_PATH_DEVICE_CLASSES,
                    0,
                    KEY_READ,
                    &hKeyDevClassRoot) != ERROR_SUCCESS) {

        wprintf(L"Couldn't open DeviceClasses key!\n");
        return -1;
    }

    InterfaceDeviceData.cbSize = sizeof(SP_INTERFACE_DEVICE_DATA);
    InterfaceDeviceDetailData = (PSP_INTERFACE_DEVICE_DETAIL_DATA)BinaryBuffer;
    InterfaceDeviceDetailData->cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    for(i = 0, DataBufferSize = GUID_STRING_LEN;
        RegEnumKeyEx(hKeyDevClassRoot,
                     i,
                     InterfaceGuidString,
                     &DataBufferSize,
                     NULL,
                     NULL,
                     NULL,
                     &LastWriteTime) == ERROR_SUCCESS;
        i++, DataBufferSize = GUID_STRING_LEN)
    {

        if(CLSIDFromString(InterfaceGuidString, &ClassGuid) != NOERROR) {
            wprintf(L"We couldn't convert %s into a GUID--skip it.\n", InterfaceGuidString);
            continue;
        } else {
            wprintf(L"We're enumerating interface class %s\n", InterfaceGuidString);
        }

        for(j = 0;
            SetupDiEnumInterfaceDevice(hDevInfo, NULL, &ClassGuid, j, &InterfaceDeviceData);
            j++)
        {
            StringFromGUID2(&(InterfaceDeviceData.InterfaceClassGuid), TempGuidString, GUID_STRING_LEN);
            wprintf(L"For class %s, here's one:\n", TempGuidString);

            if(!SetupDiGetInterfaceDeviceDetail(hDevInfo,
                                                &InterfaceDeviceData,
                                                InterfaceDeviceDetailData,
                                                sizeof(BinaryBuffer),
                                                NULL,
                                                &DeviceInfoData)) {
                
                wprintf(L"SetupDiGetInterfaceDeviceDetail failed with %lx\n", GetLastError());
                continue;
            }

            wprintf(L"     %s (%lx)\n", InterfaceDeviceDetailData->DevicePath, InterfaceDeviceData.Flags);
            wprintf(L"     (associated device instance is:\n");

            if(!SetupDiGetDeviceInstanceId(hDevInfo,
                                           &DeviceInfoData,
                                           DevInstIdBuffer,
                                           MAX_DEVICE_ID_LEN,
                                           NULL)) {
                wprintf(L"SetupDiGetDeviceInstanceId failed with %lx\n", GetLastError());
                continue;
            }

            {
                HKEY hKey = SetupDiOpenInterfaceDeviceRegKey(hDevInfo, 
                                                             &InterfaceDeviceData, 
                                                             0, 
                                                             KEY_READ
                                                             );
                if(hKey == INVALID_HANDLE_VALUE) {
                    wprintf(L"SetupDiOpenInterfaceDeviceRegKey failed with %lx\n", GetLastError());
                    continue;
                }
                RegCloseKey(hKey);
            }

            wprintf(L"    %s\n\n", DevInstIdBuffer);
        }
    }
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\pputil.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

void WINAPI PrintGraph(IFilterGraph *pGraph)
{
    IEnumFilters *pFilters;

    printf(TEXT("DumpGraph [%x]\n"), pGraph);
    
    if (FAILED(pGraph->EnumFilters(&pFilters))) {
	printf(TEXT("EnumFilters failed!\n"));
	return;
    }

    IBaseFilter *pFilter;
    ULONG	n;
    while (pFilters->Next(1, &pFilter, &n) == S_OK) {
	FILTER_INFO	info;

	if (FAILED(pFilter->QueryFilterInfo(&info))) {
	    printf(TEXT("    Filter [%x]  -- failed QueryFilterInfo\n"), pFilter);
	} else {
	    QueryFilterInfoReleaseGraph(info);

	    // !!! should QueryVendorInfo here!
	    
	    printf(TEXT("    Filter [%x]  '%ls'\n"), pFilter, info.achName);

	    IEnumPins *pins;

	    if (FAILED(pFilter->EnumPins(&pins))) {
		printf(TEXT("EnumPins failed!\n"));
	    } else {

		IPin *pPin;
		while (pins->Next(1, &pPin, &n) == S_OK) {
		    PIN_INFO	info;

		    if (FAILED(pPin->QueryPinInfo(&info))) {
			printf(TEXT("          Pin [%x]  -- failed QueryPinInfo\n"), pPin);
		    } else {
			QueryPinInfoReleaseFilter(info);

			IPin *pPinConnected = NULL;

			HRESULT hr = pPin->ConnectedTo(&pPinConnected);

			if (pPinConnected) {
			    printf(TEXT("          Pin [%x]  '%ls' [%sput]"
							   "  Connected to pin [%x]\n"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out"),
				    pPinConnected);

			    pPinConnected->Release();

			    // perhaps we should really dump the type both ways as a sanity
			    // check?
			    if (info.dir == PINDIR_OUTPUT) {
				AM_MEDIA_TYPE mt;

				hr = pPin->ConnectionMediaType(&mt);

				if (SUCCEEDED(hr)) {
				    DisplayType("Connection type", &mt);

				    FreeMediaType(mt);
				}
			    }
			} else {
			    printf(TEXT("          Pin [%x]  '%ls' [%sput]\n"),
				    pPin, info.achName,
				    info.dir == PINDIR_INPUT ? TEXT("In") : TEXT("Out"));

			}
		    }

		    pPin->Release();

		}

		pins->Release();
	    }

	}
	
	pFilter->Release();
    }

    pFilters->Release();

}

#if 0
HRESULT WINAPI PrintGraphAsC(IFilterGraph *pGraph)
{
    HRESULT hr;
    IEnumFilters *pFilters;

    printf("IGraphBuilder *pGraph;\n");

    // just an idea--output C code to re-create the graph in question.... 
}
#endif


//=======================
// CreateFilterGraph
//=======================

BOOL CreateFilterGraph(IGraphBuilder **pGraph)
{
    HRESULT hr; // return code

    hr = CoCreateInstance(CLSID_FilterGraph, // get the graph object
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IGraphBuilder,
			  (void **) pGraph);

    if (FAILED(hr)) {
	*pGraph = NULL;
	return FALSE;
    }

    return TRUE;
}


BOOL CreateFilter(REFCLSID clsid, IBaseFilter **ppFilter)
{
    HRESULT hr;

    hr = CoCreateInstance(clsid,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IBaseFilter,
			  (void **) ppFilter);

    if (FAILED(hr)){
	*ppFilter = NULL;
	return FALSE;
    }

    return TRUE;
}


HRESULT SetNoClock(IFilterGraph *graph)
{
    // Keep a useless clock from being instantiated....
    IMediaFilter *graphF;
    HRESULT hr = graph->QueryInterface(IID_IMediaFilter, (void **) &graphF);

    if (SUCCEEDED(hr)) {
	hr = graphF->SetSyncSource(NULL);
	graphF->Release();
    }

    return hr;
}


HRESULT GetPin(IBaseFilter *pFilter, DWORD dwPin, IPin **ppPin)
{
    IEnumPins *pins;

    HRESULT hr = pFilter->EnumPins(&pins);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("EnumPins failed!  (%x)\n"), hr));

	return hr;
    }

    if (dwPin > 0) {
	hr = pins->Skip(dwPin);
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Skip(%d) failed!  (%x)\n"), dwPin, hr));

	    return hr;
	}

	if (hr == S_FALSE) {
	    DbgLog((LOG_ERROR,1,TEXT("Skip(%d) ran out of pins!\n"), dwPin));

	    return hr;
	}

    }

    DWORD n;
    hr = pins->Next(1, ppPin, &n);

    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("Next() failed!  (%x)\n"), hr));
    }

    if (hr == S_FALSE) {
	DbgLog((LOG_ERROR,1,TEXT("Next() ran out of pins!  \n")));

	return hr;
    }

    pins->Release();

    return hr;
}


BOOL AreEqualVideoTypes( const CMediaType *pmt1, const CMediaType *pmt2 )
{
    // The standard implementation is too strict - it demands an exact match
    // We just want to know is they are the same format and have the same
    // width / height

    ASSERT( IsEqualGUID( *pmt1->Type(), MEDIATYPE_Video ) );
    ASSERT( IsEqualGUID( *pmt2->Type(), MEDIATYPE_Video ) );
    ASSERT( *pmt1->FormatType() == FORMAT_VideoInfo );
    ASSERT( *pmt2->FormatType() == FORMAT_VideoInfo );

    VIDEOINFOHEADER *pvi1 = (VIDEOINFOHEADER *) pmt1->Format();
    VIDEOINFOHEADER *pvi2 = (VIDEOINFOHEADER *) pmt2->Format();

    return    IsEqualGUID( *pmt1->Subtype(), *pmt2->Subtype() )
           && pvi1->bmiHeader.biBitCount  == pvi2->bmiHeader.biBitCount
           && pvi1->bmiHeader.biWidth  == pvi2->bmiHeader.biWidth
           && pvi2->bmiHeader.biHeight == pvi2->bmiHeader.biHeight;
}


BOOL AreMediaTypesCloseEnough(const CMediaType *pmt1, const CMediaType *pmt2)
{
    if (*pmt1->Type() != *pmt2->Type())
	return FALSE;

    if (*pmt1->Type() == MEDIATYPE_Video) {
	if (*pmt1->FormatType() != FORMAT_VideoInfo)
	    return FALSE;
	
	return AreEqualVideoTypes(pmt1, pmt2);
    } else if (*pmt1->Type() == MEDIATYPE_Audio) {
	// don't compare subtypes for audio....
	return (pmt1->formattype == pmt2->formattype) && (pmt1->cbFormat == pmt2->cbFormat) &&
		  (memcmp(pmt1->pbFormat, pmt2->pbFormat, pmt1->cbFormat) == 0);
    }

    return (*pmt1 == *pmt2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\alloc.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
//  Attempt at an allocator specialized for the edit-list case where
//  you have multiple source graphs feeding into a single target graph.
//
//  In order to stall the source graphs until it's their turn and provide
//  the consistent allocator that the upstream graph expects, we provide a
//  "shadow" allocator to the upstream graphs.  It's sort of the same as the
//  real allocator, with two important differences:
//	1) if they Decommit() it, we ignore them, so that later graphs can
//	      keep using this allocator
//	2) we block GetBuffer unless we know it is their turn.
//
//
//  Right now, CMultiAllocator is a standalone allocator, but it seems like
//  perhaps the correct design is for it to be a wrapper that can be put on
//  top of any IMemAllocator, this would allow us to use arbitrary allocators
//  provided by downstream filters instead of the hardcoded CMemAllocator that
//  we have at present.



class CIndivAllocator;

class CMultiAllocator : public CMemAllocator
{
    friend class CIndivAllocator;
    
private:
    CGenericList<CIndivAllocator>	m_list;

    POSITION				m_posCurrent;

public:
	
    CMultiAllocator(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CMultiAllocator();

    HRESULT GetAnotherAllocator(IMemAllocator **ppIndivAlloc);
//    HRESULT RemoveFirstAllocator();

    HRESULT ResetPosition() { m_posCurrent = m_list.GetHeadPosition(); return NOERROR; }
    HRESULT NextOnesTurn();
    
};


// "shadow" allocator
class CIndivAllocator : public IMemAllocator, public CUnknown
{
private: // only used by CMultiAllocator and through IMemAllocator interface
    friend class CMultiAllocator;
    
    CIndivAllocator(CMultiAllocator *pMulti);
    ~CIndivAllocator();

    DECLARE_IUNKNOWN

    CMultiAllocator    *m_pMulti;

    CAMEvent		m_event;

    // override this to publicise our interfaces
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);

    STDMETHODIMP SetProperties(
		    ALLOCATOR_PROPERTIES* pRequest,
		    ALLOCATOR_PROPERTIES* pActual);

    // return the properties actually being used on this allocator
    STDMETHODIMP GetProperties(
		    ALLOCATOR_PROPERTIES* pProps);

    // these don't do anything, parent allocator really allocates.
    STDMETHODIMP Commit() { return S_OK; };
    STDMETHODIMP Decommit() { return S_OK; };

    // wait until our event is signaled to indicate it's our turn.

    STDMETHODIMP GetBuffer(IMediaSample **ppBuffer,
                           REFERENCE_TIME * pStartTime,
                           REFERENCE_TIME * pEndTime,
                           DWORD dwFlags);

    // should never be called, IMediaSample->Release() will go to the real allocator
    STDMETHODIMP ReleaseBuffer(IMediaSample *pBuffer);
};



CMultiAllocator::CMultiAllocator(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr)
    : CMemAllocator(pName, pUnk, phr),
    m_list("List of sub-allocators", 5),
    m_posCurrent(NULL)
{
}

CMultiAllocator::~CMultiAllocator()
{

}


//
// Main important external method:
// call this once for each sub-stream you're using.  The returned allocator
// will share buffers with the main allocator, but only one client will be able
// to get in and get buffers at a time.
//
HRESULT CMultiAllocator::GetAnotherAllocator(IMemAllocator **ppAlloc)
{
    CIndivAllocator *pAlloc = new CIndivAllocator(this);

    if (!pAlloc)
	return E_OUTOFMEMORY;

        // !!! hack, make first allocator active
    if (m_list.GetCount() == 1) {
	m_posCurrent = m_list.GetHeadPosition(); 
	pAlloc->m_event.Set();
    }
    

    DbgLog((LOG_TRACE, 3, TEXT("Created new allocator %x"), pAlloc));

    return pAlloc->NonDelegatingQueryInterface(IID_IMemAllocator, (void **)ppAlloc);
}


#if 0
// Inverse of GetAnotherAllocator
// should this come from the allocator's release somehow? 
HRESULT CMultiAllocator::RemoveFirstAllocator()
{
    // !!! check that this isn't the current allocator

    
    CIndivAllocator *pFirstAlloc = m_list.RemoveHead();

    if (pFirstAlloc == NULL)
	return E_FAIL;

    // is this release right?
    pFirstAlloc->Release();
}
#endif

// signal the next allocator in the chain that it's allowed to get buffers now.
HRESULT CMultiAllocator::NextOnesTurn()
{
    CIndivAllocator *pCurrent, *pNext;

    pCurrent = m_list.GetNext(m_posCurrent);
    pNext = m_list.Get(m_posCurrent);

    // stop current guy, go to next guy
    pCurrent->m_event.Reset();

    if (pNext)
	pNext->m_event.Set();

    DbgLog((LOG_TRACE, 3, TEXT("Switching from indiv. alloc %x to %x"), pCurrent, pNext));

    return pNext ? S_OK : S_FALSE;
}

CIndivAllocator::CIndivAllocator(
    CMultiAllocator *pMulti) :
    CUnknown(NAME("Individual Allcator"), NULL),
    m_event(TRUE)	// manual reset
{
    m_pMulti = pMulti;
    m_event.Reset();

    pMulti->m_list.AddTail(this);
}


CIndivAllocator::~CIndivAllocator()
{
    // !!! remove ourselves from the parent list????
    // !!! assume we're first?

    // !!! better make sure that it's not our turn!
    m_pMulti->m_list.RemoveHead();
}

/* Override this to publicise our interfaces */

STDMETHODIMP
CIndivAllocator::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    /* Do we know about this interface */

    if (riid == IID_IMemAllocator) {
        return GetInterface((IMemAllocator *) this, ppv);
    } else {
        return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


// Standard IMemAllocator interfaces:
// mostly, these are just forwarded to the main allocator.
STDMETHODIMP
CIndivAllocator::SetProperties(
                ALLOCATOR_PROPERTIES* pRequest,
                ALLOCATOR_PROPERTIES* pActual)
{
    // !!! should check that properties match!
    // are we required to return an error if we can't do the properties they want,
    // or are we supposed to return S_OK and just say "this is what we did"?

    // at least fill in what we're doing....
    GetProperties(pActual);

    return NOERROR;
}

STDMETHODIMP
CIndivAllocator::GetProperties(
    ALLOCATOR_PROPERTIES * pActual)
{
    // okay to let this go through
    return m_pMulti->GetProperties(pActual);
}



HRESULT CIndivAllocator::GetBuffer(IMediaSample **ppBuffer,
                                  REFERENCE_TIME *pStartTime,
                                  REFERENCE_TIME *pEndTime,
                                  DWORD dwFlags
                                  )
{
    // !!! this wait is pretty scary, we probably need code somewhere
    // to unblock this in some other situations, like on Stop.
    // perhaps Decommit needs to signal this event???
    
    m_event.Wait();

    // ok, event's been signalled, so it's our turn to ask mom.

    // !!! do we need to adjust these times?
    return m_pMulti->GetBuffer(ppBuffer, pStartTime, pEndTime, dwFlags);
}


/* Final release of a CMediaSample will call this */

STDMETHODIMP
CIndivAllocator::ReleaseBuffer(IMediaSample * pSample)
{
    // !!! this should never be called, we don't give out any buffers!
    
    ASSERT(0);
    
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\test.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <streams.h>
#include <stdio.h>

#include "fakein.cpp"
#include "fakeout.cpp"


//=======================
// CreateFilterGraph
//=======================

BOOL CreateFilterGraph(IGraphBuilder **pGraph)
{
    HRESULT hr; // return code

    hr = CoCreateInstance(CLSID_FilterGraph, // get the graph object
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IGraphBuilder,
			  (void **) pGraph);

	if (FAILED(hr)){
		*pGraph = NULL;
		return FALSE;
    }

    return TRUE;
}


HRESULT GetPin(IBaseFilter *pFilter, DWORD dwPin, IPin **ppPin)
{
    IEnumPins *pins;

    HRESULT hr = pFilter->EnumPins(&pins);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("EnumPins failed!  (%x"), hr));

	return hr;
    }

    if (dwPin > 0) {
	hr = pins->Skip(dwPin);
	if (FAILED(hr)) {
	    DbgLog((LOG_ERROR,1,TEXT("Skip(%d) failed!  (%x"), dwPin, hr));

	    return hr;
	}

	if (hr == S_FALSE) {
	    DbgLog((LOG_ERROR,1,TEXT("Skip(%d) ran out of pins!"), dwPin));

	    return hr;
	}

    }

    DWORD n;
    hr = pins->Next(1, ppPin, &n);

    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("Next() failed!  (%x"), hr));
    }

    if (hr == S_FALSE) {
	DbgLog((LOG_ERROR,1,TEXT("Next() ran out of pins!  ")));

	return hr;
    }

    pins->Release();

    return hr;
}


class CCallback : public CUnknown, public IFakeInAppCallback
{
    CFakeOut   *m_pFakeOut;
    DWORD	m_nFrame;
    BOOL	m_fDoneYet;
public:
    CCallback(CFakeOut *pFakeOut) : CUnknown(NAME("Callback object"), NULL)
    {
	m_pFakeOut = pFakeOut;
	m_nFrame = 0;
	m_fDoneYet = FALSE;
    }

    BOOL DoneYet()
    { 
	return m_fDoneYet;
    }

#ifdef DEFINE_AN_IID_SOMEDAY
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IFakeInAppCallback) {
	    return GetInterface((IFakeInAppCallback *) this, ppv);
	} else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
	}
    }
#endif

    DECLARE_IUNKNOWN

    HRESULT FrameReady(IMediaSample *pSample);
    HRESULT SupplyAllocator(IMemAllocator **ppAlloc);
};


HRESULT CCallback::FrameReady(IMediaSample *pSample)
{
    if (pSample == NULL) {
	printf("Got EndOfStream\n");
	m_fDoneYet = TRUE;
	SendEndOfStream(m_pFakeOut);
    } else {
	BYTE * pbuf;

	printf("Got frame #%d\n", m_nFrame);
	
	pSample->GetPointer(&pbuf);

	SendDataOut(m_pFakeOut, pbuf, pSample->GetActualDataLength(), m_nFrame++);
    }

    return S_OK;
}

HRESULT CCallback::SupplyAllocator(IMemAllocator **pAlloc)
{
    return S_OK;
}


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    WCHAR wszFile[256];

    int i = 1;

    if (argc < 2) {
        printf("No file specified\n");
        return -1;
    }

#if 0    
    while (argv[i][0] == '-' || argv[i][0] == '/') {
	// options

        i++;
    }
#endif
    
    MultiByteToWideChar(CP_ACP, 0, argv[i], -1,
				    wszFile, 256);
    printf("Using file %ls\n", wszFile);

    CoInitialize(NULL);

    CMediaType	mt;

    mt.ReallocFormatBuffer(sizeof(VIDEOINFOHEADER));

    LPBITMAPINFOHEADER lpbi = HEADER(mt.Format());
    lpbi->biSize = sizeof(BITMAPINFOHEADER);
    lpbi->biCompression = BI_RGB;
    lpbi->biWidth = 320; // !!!!
    lpbi->biHeight = 240; // !!!!
    lpbi->biPlanes = 1;
    lpbi->biBitCount = 24;
    lpbi->biClrUsed = 0;
    lpbi->biClrImportant = 0;
    lpbi->biSizeImage = DIBSIZE(*lpbi);

    // ((VIDEOINFOHEADER *)(mt.pbFormat))->dwBitRate = 
    ((VIDEOINFOHEADER *)(mt.pbFormat))->dwBitErrorRate = 0L;

    mt.SetSampleSize(lpbi->biSizeImage);

    mt.SetType(&MEDIATYPE_Video);
    mt.SetFormatType(&FORMAT_VideoInfo);
    mt.SetSubtype(&MEDIASUBTYPE_RGB24);

    HRESULT hr;
    
    printf("Creating graphs\n");

    CFakeOut	fakeOut(NULL, &hr, UNITS / 15 /* !!! */, &mt, lpbi->biSizeImage /* !!! */);

    CCallback	callback(&fakeOut);
    callback.AddRef();		// make sure it doesn't go away....
    
    CFakeIn	fakeIn(NULL, &hr, &mt, lpbi->biSizeImage /* !!! */,
		       (IFakeInAppCallback *)&callback);
    
    IGraphBuilder *graphIn, *graphOut;

    CreateFilterGraph(&graphIn);
    CreateFilterGraph(&graphOut);

    IBaseFilter *pFakeIn = fakeIn.GetFilter(),
		*pFakeOut = fakeOut.GetFilter();
    
    graphIn->AddFilter(pFakeIn, L"FakeInput");

    IBaseFilter *pSource;
    graphIn->AddSourceFilter(wszFile, L"Source", &pSource);

    IPin *pSourceOut, *pFakeInPin;

    GetPin(pSource, 0, &pSourceOut);
    pSource->Release();		// filtergraph holds refcount
    
    GetPin(pFakeIn, 0, &pFakeInPin);

    hr = graphIn->Connect(pSourceOut, pFakeInPin);
    pSourceOut->Release();
    pFakeInPin->Release();
    

    hr = graphOut->AddFilter(fakeOut.GetFilter(), L"FakeOutput");

    IPin *pFakeOutPin;
    GetPin(pFakeOut, 0, &pFakeOutPin);

    hr = graphOut->Render(pFakeOutPin);
    pFakeOutPin->Release();
    
    DumpGraph(graphIn, 0);
    DumpGraph(graphOut, 0);


    // here's where the neat code to step through the file grabbing
    // frames from the "In" graph and writing them to the "Out"
    // graph goes.

    IMediaControl *graphInC, *graphOutC;

    graphIn->QueryInterface(IID_IMediaControl, (void **) &graphInC);
    graphOut->QueryInterface(IID_IMediaControl, (void **) &graphOutC);

    graphOutC->Run();
    graphInC->Run();

    
    
    printf("Waiting for something to happen...\n");

    while (!callback.DoneYet()) {
	printf("  still waiting...\n");
	Sleep(1000);
    }


    // !!! do we need to stop things?

    printf("All done.\n");

    graphOutC->Stop();   graphOutC->Release();
    graphInC->Stop();    graphInC->Release();


    // clean up, exit

    graphIn->Release();
    graphOut->Release();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\minig.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
class CMiniGraph : public IFilterGraph, public IMediaFilter, public CUnknown
{
private:
    CGenericList<IBaseFilter>	m_list;

    DECLARE_IUNKNOWN
	    
public:
    CMiniGraph(TCHAR *pName);
    ~CMiniGraph();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    STDMETHODIMP GetClassID(CLSID *pClsID) { return E_NOTIMPL; };
    
    STDMETHODIMP AddFilter(IBaseFilter * pFilter, LPCWSTR pName);

    STDMETHODIMP RemoveFilter(IBaseFilter * pFilter);

    STDMETHODIMP EnumFilters(IEnumFilters **ppEnum) { return E_NOTIMPL; };

    STDMETHODIMP FindFilterByName(LPCWSTR pName, IBaseFilter ** ppFilter) { return E_NOTIMPL; };

    STDMETHODIMP ConnectDirect(IPin * ppinOut, IPin * ppinIn,
			  const AM_MEDIA_TYPE* pmt);

    // required???
    STDMETHODIMP Reconnect(IPin * ppin) { return E_NOTIMPL; };

    STDMETHODIMP Disconnect(IPin * ppin) { return E_NOTIMPL; };

    STDMETHODIMP SetDefaultSyncSource() { return E_NOTIMPL; };

// IBaseFilter
    STDMETHODIMP Stop(void);
    STDMETHODIMP Pause(void);
    STDMETHODIMP Run(REFERENCE_TIME tStart);

    STDMETHODIMP GetState(DWORD dwMilliSecsTimeout, FILTER_STATE *State) { return E_NOTIMPL;} ;

    STDMETHODIMP SetSyncSource(IReferenceClock * pClock) { return E_NOTIMPL; };

    STDMETHODIMP GetSyncSource(IReferenceClock ** pClock) { return E_NOTIMPL;} ;
};


CMiniGraph::CMiniGraph(TCHAR *pName) : CUnknown(pName, NULL),
	    m_list(NAME("list of filters"), 5)
{


}

CMiniGraph::~CMiniGraph()
{
    POSITION p = m_list.GetHeadPosition();

    IBaseFilter *pFilter;
    
    while (p) {
	pFilter = m_list.GetNext(p);

	pFilter->Release();
    }
}


STDMETHODIMP CMiniGraph::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    if (riid == IID_IMediaFilter) {
	return GetInterface((IMediaFilter *) this, ppv);
    } else if (riid == IID_IFilterGraph) {
	return GetInterface((IFilterGraph *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}


STDMETHODIMP CMiniGraph::Stop()
{
    HRESULT hr = S_OK;
    
    POSITION p = m_list.GetHeadPosition();

    IBaseFilter *pFilter;
    
    while (p) {
	pFilter = m_list.GetNext(p);

	hr = pFilter->Stop();
    }

    return hr;
}


STDMETHODIMP CMiniGraph::Pause()
{
    HRESULT hr = S_OK;
    
    POSITION p = m_list.GetHeadPosition();

    IBaseFilter *pFilter;
    
    while (p) {
	pFilter = m_list.GetNext(p);

	hr = pFilter->Pause();
    }

    return hr;
}

STDMETHODIMP CMiniGraph::Run(REFERENCE_TIME tStart)
{
    HRESULT hr = S_OK;
    
    POSITION p = m_list.GetHeadPosition();

    IBaseFilter *pFilter;
    
    while (p) {
	pFilter = m_list.GetNext(p);

	hr = pFilter->Run(tStart);
    }

    return hr;
}


STDMETHODIMP CMiniGraph::AddFilter(IBaseFilter * pFilter, LPCWSTR pName)
{
    m_list.AddTail(pFilter);

    pFilter->AddRef();

    return S_OK;
}


STDMETHODIMP CMiniGraph::RemoveFilter(IBaseFilter * pFilter)
{
    return E_NOTIMPL;
}


STDMETHODIMP CMiniGraph::ConnectDirect(IPin * ppinOut, IPin * ppinIn,
		      const AM_MEDIA_TYPE* pmt)
{
    return ppinOut->Connect(ppinIn, pmt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\use1\use1filt.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <streams.h>
#include <stdio.h>
#include <vfw.h>

#define FAKEIN_NOSEEKING

#include "pputil.h"
#include "minig.cpp"
#include "fakein.cpp"
#include "fakeout.cpp"

BOOL fVerbose = FALSE;


struct SavedSample {
    DWORD dwLen;
    LPBYTE lp;
};

class CCallback;

class CCallback : public CUnknown, public IFakeInAppCallback
{
    CFakeOut   *m_pFakeOut;
    DWORD	m_nFrame;
    BOOL	m_fDoneYet;

    CCritSec	m_cs;
    
    CGenericList<SavedSample> m_list;
    
public:
    CCallback(CFakeOut *pFakeOut) : CUnknown(NAME("Callback object"), NULL),
				    m_list(NAME("Done list"), 10)
    {
	m_pFakeOut = pFakeOut;
	m_nFrame = 0;
	m_fDoneYet = FALSE;
    }

    CFakeIn    *m_pFakeIn;
    
#ifdef DEFINE_AN_IID_SOMEDAY
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IFakeInAppCallback) {
	    return GetInterface((IFakeInAppCallback *) this, ppv);
	} else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
	}
    }
#endif

    DECLARE_IUNKNOWN

    HRESULT FrameReady(IMediaSample *pSample);


    // what passes for a public API from the callback:
    // has EOS been received?
    BOOL DoneYet()
    { 
	return m_fDoneYet && (m_list.GetCount() == 0);
    }

    // return done sample if present
    SavedSample * GetDoneSample();
};

HRESULT CCallback::FrameReady(IMediaSample *pSample)
{
    CAutoLock lock(&m_cs);
    if (pSample == NULL) {
	printf("Got EndOfStream\n");

	m_fDoneYet = TRUE;
    } else {
	BYTE * pbuf;

	// do something with the data....

	printf("Got frame #%d\n", m_nFrame++);

	pSample->GetPointer(&pbuf);

	SavedSample *pSave = new SavedSample;
	pSave->dwLen = pSample->GetActualDataLength();

	pSave->lp = new BYTE[pSave->dwLen];

	// we copy it so that the foreground thread can get at it.

	// easy, but not terribly efficient.
	CopyMemory(pSave->lp, pbuf, pSave->dwLen);

	m_list.AddTail(pSave);
	
    }

    return S_OK;
}


SavedSample * CCallback::GetDoneSample()
{
    CAutoLock lock(&m_cs);

    return m_list.RemoveHead();
}


// how to build an explicit FOURCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    WCHAR wszFile[256];

    int i = 1;
    if (argc < 2) {
        printf("No file specified\n");
        return -1;
    }

    while (argv[i][0] == '-' || argv[i][0] == '/') {
	// options

        if (lstrcmpi(argv[i] + 1, "v") == 0) {
            fVerbose = TRUE;
        }

	i++;
    }
    
    MultiByteToWideChar(CP_ACP, 0, argv[i], -1,
				    wszFile, 256);
    printf("Using file %ls\n", wszFile);

    CoInitialize(NULL);

    CMediaType	mtIn;

    mtIn.ReallocFormatBuffer(SIZE_VIDEOHEADER);

    LPBITMAPINFOHEADER lpbiIn = HEADER(mtIn.Format());
    lpbiIn->biSize = sizeof(BITMAPINFOHEADER);
    lpbiIn->biCompression = BI_RGB;
    lpbiIn->biWidth = 320; // !!!!
    lpbiIn->biHeight = 240; // !!!!
    lpbiIn->biPlanes = 1;
    lpbiIn->biBitCount = 24;
    lpbiIn->biClrUsed = 0;
    lpbiIn->biClrImportant = 0;
    lpbiIn->biSizeImage = DIBSIZE(*lpbiIn);

    ((VIDEOINFO *)(mtIn.pbFormat))->AvgTimePerFrame = UNITS/15;
    ((VIDEOINFO *)(mtIn.pbFormat))->dwBitErrorRate = 0L;

    mtIn.SetSampleSize(lpbiIn->biSizeImage);

    mtIn.SetType(&MEDIATYPE_Video);
    mtIn.SetFormatType(&FORMAT_VideoInfo);
    mtIn.SetSubtype(&MEDIASUBTYPE_RGB24);

    CMediaType	mtOut;

    mtOut.ReallocFormatBuffer(SIZE_VIDEOHEADER);

    LPBITMAPINFOHEADER lpbiOut = HEADER(mtOut.Format());
    lpbiOut->biSize = sizeof(BITMAPINFOHEADER);
    lpbiOut->biCompression = FCC('cvid');
    lpbiOut->biWidth = 320; // !!!!
    lpbiOut->biHeight = 240; // !!!!
    lpbiOut->biPlanes = 1;
    lpbiOut->biBitCount = 24;
    lpbiOut->biClrUsed = 0;
    lpbiOut->biClrImportant = 0;
    lpbiOut->biSizeImage = DIBSIZE(*lpbiOut);

    // ((VIDEOINFO *)(mtOut.pbFormat))->dwBitRate = 
    ((VIDEOINFO *)(mtOut.pbFormat))->dwBitErrorRate = 0L;

    mtOut.SetSampleSize(lpbiOut->biSizeImage);

    mtOut.SetType(&MEDIATYPE_Video);
    mtOut.SetFormatType(&FORMAT_VideoInfo);

    FOURCCMap fcc;
    fcc.SetFOURCC(lpbiOut->biCompression);
    mtOut.SetSubtype(&fcc);

    HRESULT hr;
    
    printf("Creating graphs\n");

    CFakeOut	fakeOut(NULL, &hr, UNITS / 15 /* !!! */, &mtIn, lpbiIn->biSizeImage /* !!! */);

    CCallback	callback(&fakeOut);
    callback.AddRef();		// make sure it doesn't go away....
    
    CFakeIn	fakeIn(NULL, &hr, &mtOut, lpbiOut->biSizeImage /* !!! */,
		       (IFakeInAppCallback *)&callback);

    callback.m_pFakeIn = &fakeIn;

    IGraphBuilder *graph;

    CMiniGraph minigraph(NAME("our graph!"));
    
    minigraph.NonDelegatingQueryInterface(IID_IFilterGraph, (void **) &graph);
    
    IBaseFilter *pFakeIn = fakeIn.GetFilter(),
		*pFakeOut = fakeOut.GetFilter();
    
    graph->AddFilter(pFakeIn, L"FakeInput");

    hr = graph->AddFilter(pFakeOut, L"FakeOutput");


    // !!! note that for compressing video, for instance, the ICM compression filter
    // won't be found by default since its merit is too low.  It may need to be
    // added by hand.

    // for compression, need to add "co" filter by hand.
    IBaseFilter *pCoFilter;
    if (CreateFilter(CLSID_AVICo, &pCoFilter)) {
	hr = graph->AddFilter(pCoFilter, L"VfW compression");

	// if you wanted to configure the filter further, you could keep this
	// pointer to it and call lots of fun methods
	pCoFilter->Release();	// graph keeps refcount
	printf("made a compression filter\n");
    } else {
	printf("Couldn't make a compression filter\n");
    }
    
    IPin *pFakeInPin, *pFakeOutPin;
    GetPin(pFakeIn, 0, &pFakeInPin);
    GetPin(pFakeOut, 0, &pFakeOutPin);
    
    IPin *pCoInPin, *pCoOutPin;
    GetPin(pCoFilter, 0, &pCoInPin);
    GetPin(pCoFilter, 1, &pCoOutPin);
    
    hr = graph->ConnectDirect(pFakeOutPin, pCoInPin, NULL);
    hr = graph->ConnectDirect(pCoOutPin, pFakeInPin, NULL);
    
    pFakeInPin->Release();
    pFakeOutPin->Release();
    pCoInPin->Release();
    pCoOutPin->Release();
    
    PrintGraph(graph);

    if (FAILED(hr)) {
	// this means that we couldn't find a way to convert from the input type to the
	// output type.

	printf("Connect failed!  hr = %x\n", hr);
    }


    // Keep a useless clock from being instantiated....
    IMediaFilter *graphF;
    graph->QueryInterface(IID_IMediaFilter, (void **) &graphF);
    graphF->SetSyncSource(NULL);
    graphF->Run(0);

       
    printf("Now feed data through the graph...\n");


    PAVIFILE	pFile;

    hr = AVIFileOpenW(
		    &pFile,
		    wszFile,
		    MMIO_READ | OF_SHARE_DENY_WRITE,
		    NULL);

    if (FAILED(hr)) {
	printf("Failed to open '%ls', hr = %x", wszFile, hr);
    } else {
	// add code here to get frames and send them through the graph....

	IAVIStream *ps;
	
	hr = pFile->GetStream(&ps, streamtypeVIDEO, 0);
	
	ASSERT(SUCCEEDED(hr));

	AVISTREAMINFOW info;
	hr = ps->Info(&info, sizeof(info));

	PGETFRAME pgf = AVIStreamGetFrameOpen(ps, lpbiIn);
	
	for (long i = 0; i < (long) info.dwLength; i++)
	// loop through frames....
	{
	    LPBITMAPINFOHEADER lpbi = (LPBITMAPINFOHEADER) AVIStreamGetFrame(pgf, i);


	    printf("Sending frame %d\n", i);
	    SendDataOut(&fakeOut, (LPVOID) (lpbi+1), lpbiIn->biSizeImage, i);

	    SavedSample *pSaved;
	    while (pSaved = callback.GetDoneSample()) {

		// do something with the saved data
		printf("Got a frame, size = %d\n", pSaved->dwLen);
		delete pSaved;
	    }
	}

	SendEndOfStream(&fakeOut);

	printf("Getting end of data....\n");
	
	// keep processing data until all done
	while (!callback.DoneYet()) {

	    SavedSample *pSaved;
	    while (pSaved = callback.GetDoneSample()) {

		// do something with the saved data
		printf("Got a frame, size = %d\n", pSaved->dwLen);
		delete pSaved;
	   
	    }
	}
    
	pFile->Release();
    }

    // !!! do we need to stop things?

    printf("All done.\n");

    graphF->Stop();    graphF->Release();


    // clean up, exit

    graph->Release();

    CoUninitialize();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\lyrread\lyrread.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

extern const AMOVIESETUP_FILTER sudLyricRead;

// CLSID_LyricReadr,
// {D51BD5A4-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_LyricReader,
0xd51bd5a4, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

#include "simpread.h"

typedef struct {
    DWORD	dwPosition;
    LPSTR	lpText;
} SONGLINE, *LPSONGLINE;

//
// CLyricRead
//
class CLyricRead : public CSimpleReader {
public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    CLyricRead(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CLyricRead();

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    LONG StartFrom(LONG sStart);
    HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t);
    CRefTime SampleToRefTime(LONG s);
    ULONG GetMaxSampleSize();

    
    DWORD CountLines();
    BOOL ReadLyrics(LPSONGLINE FAR*lplpLyrics, DWORD FAR *lpdwMaxPos);
    BOOL ParseLyricLine(BYTE * lpLine, LPSONGLINE lpSongLine);
    void NukeLyrics(LPSONGLINE FAR * lplpLyrics);

    int		m_MaxSize;
    LPSONGLINE	m_lpLyrics;
    DWORD	m_dwMaxPosition;
    BYTE *	m_lpFile;
    DWORD	m_cbFile;
    DWORD	m_dwLastPosition;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\pushpins\testcut\testcut.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#include <windows.h>
#include <streams.h>
#include <stdio.h>

#include "pputil.h"
#include "alloc.cpp"
#include "fakein.cpp"
#include "fakeout.cpp"

BOOL fVerbose = FALSE;

class CCallback;

class CCallback : public CUnknown, public IFakeInAppCallback
{
    CFakeOut   *m_pFakeOut;
    DWORD	m_nFrame;
    BOOL	m_fDoneYet;
    BOOL	m_fDoneFirst;
    REFERENCE_TIME m_tOffset;
    REFERENCE_TIME m_tLast;
public:
    CMultiAllocator *m_pAlloc;

    CCallback(CFakeOut *pFakeOut) : CUnknown(NAME("Callback object"), NULL)
    {
	m_pFakeOut = pFakeOut;
	m_nFrame = 0;
	m_fDoneYet = FALSE;
	m_pAlloc = NULL;
	m_fDoneFirst = FALSE;
	m_tOffset = 0;
	m_tLast = 0;
    }

    BOOL DoneYet()
    { 
	return m_fDoneYet;
    }

#ifdef DEFINE_AN_IID_SOMEDAY
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv) {
	if (riid == IID_IFakeInAppCallback) {
	    return GetInterface((IFakeInAppCallback *) this, ppv);
	} else {
	    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
	}
    }
#endif

    DECLARE_IUNKNOWN

    HRESULT FrameReady(IMediaSample *pSample);


};

HRESULT CCallback::FrameReady(IMediaSample *pSample)
{
    if (pSample == NULL) {
	printf("Got EndOfStream\n");

	m_tOffset = m_tLast;
	if (!m_fDoneFirst) {
	    m_fDoneFirst = TRUE;
	    m_pAlloc->NextOnesTurn();
	} else {
	    m_fDoneYet = TRUE;
	    SendEndOfStream(m_pFakeOut);
	}
    } else {
	if (fVerbose)
	    printf("Got frame #%d\n", m_nFrame++);

	REFERENCE_TIME tStart, tEnd;

	pSample->GetTime(&tStart, &tEnd);

	if (m_tOffset) {
	    tStart += m_tOffset;
	    tEnd += m_tOffset;
	    pSample->SetTime(&tStart, &tEnd);
	}

	m_tLast = tEnd;

	SendSampleOut(m_pFakeOut, pSample);
    }

    return S_OK;
}


HRESULT ConnectFileToFakeIn(IGraphBuilder *graph, IBaseFilter *pFakeIn, WCHAR *wszFile)
{
    graph->AddFilter(pFakeIn, L"FakeInput");

    IBaseFilter *pSource;
    graph->AddSourceFilter(wszFile, L"Source", &pSource);

    IPin *pSourceOut, *pFakeInPin;

    GetPin(pSource, 0, &pSourceOut);
    pSource->Release();		// filtergraph holds refcount
    
    GetPin(pFakeIn, 0, &pFakeInPin);

    HRESULT hr = graph->Connect(pSourceOut, pFakeInPin);
    pSourceOut->Release();
    pFakeInPin->Release();

    if (FAILED(hr)) {
	printf("Failed to connect file %ls to our input", wszFile);
    }

    return hr;
}


int __cdecl
main(
    int argc,
    char *argv[]
    )
{
    WCHAR wszFile1[256];
    WCHAR wszFile2[256];

    int i = 1;
    while (i < argc && argv[i][0] == '-' || argv[i][0] == '/') {
	// options

        if (lstrcmpi(argv[i] + 1, "v") == 0) {
            fVerbose = TRUE;
        }

	i++;
    }
    
    if (argc < i+2) {
        printf("Need two files\n");
        return -1;
    }

    MultiByteToWideChar(CP_ACP, 0, argv[i], -1,
				    wszFile1, 256);
    MultiByteToWideChar(CP_ACP, 0, argv[i+1], -1,
				    wszFile2, 256);
    printf("Using files %ls and %ls\n", wszFile1, wszFile2);

    CoInitialize(NULL);

    CMediaType	mtVideo;

    mtVideo.ReallocFormatBuffer(SIZE_VIDEOHEADER);

    LPBITMAPINFOHEADER lpbi = HEADER(mtVideo.Format());
    lpbi->biSize = sizeof(BITMAPINFOHEADER);
    lpbi->biCompression = BI_RGB;
    lpbi->biWidth = 320; // !!!!
    lpbi->biHeight = 240; // !!!!
    lpbi->biPlanes = 1;
    lpbi->biBitCount = 16;
    lpbi->biClrUsed = 0;
    lpbi->biClrImportant = 0;
    lpbi->biSizeImage = DIBSIZE(*lpbi);

    // ((VIDEOINFO *)(mtVideo.pbFormat))->dwBitRate = 
    ((VIDEOINFO *)(mtVideo.pbFormat))->dwBitErrorRate = 0L;

    mtVideo.SetSampleSize(lpbi->biSizeImage);

    mtVideo.SetType(&MEDIATYPE_Video);
    mtVideo.SetFormatType(&FORMAT_VideoInfo);
    mtVideo.SetSubtype(&MEDIASUBTYPE_RGB555);


    CMediaType	mtAudio;

    mtAudio.ReallocFormatBuffer(sizeof(WAVEFORMATEX));

    WAVEFORMATEX * pwfx = (WAVEFORMATEX *) mtAudio.Format();
    pwfx->wFormatTag = WAVE_FORMAT_PCM;
    pwfx->nChannels = 1;
    pwfx->nSamplesPerSec = 11025;
    pwfx->nAvgBytesPerSec = 11025;
    pwfx->nBlockAlign = 1;
    pwfx->wBitsPerSample = 8;
    pwfx->cbSize = 0;

    mtAudio.SetSampleSize(1);

    mtAudio.SetType(&MEDIATYPE_Audio);
    mtAudio.SetFormatType(&FORMAT_WaveFormatEx);
    mtAudio.SetSubtype(&GUID_NULL);
    
    HRESULT hr;
    
    printf("Creating graphs\n");

    CFakeOut	fakeOut(NULL, &hr, UNITS / 15 /* !!! */, &mtVideo, lpbi->biSizeImage /* !!! */);

    CCallback	callback(&fakeOut);
    callback.AddRef();		// make sure it doesn't go away....
    
    CFakeIn	fakeIn1(NULL, &hr, &mtVideo, lpbi->biSizeImage /* !!! */,
		       (IFakeInAppCallback *)&callback);

    CFakeIn	fakeIn2(NULL, &hr, &mtVideo, lpbi->biSizeImage /* !!! */,
		       (IFakeInAppCallback *)&callback);

    CMultiAllocator alloc(NAME("Test allocator"), NULL, &hr);
    alloc.AddRef();
    
    IMemAllocator *pAlloc;

    callback.m_pAlloc = &alloc;
    
    hr = alloc.QueryInterface(IID_IMemAllocator, (void **) &pAlloc);

    IMemAllocator *pAlloc1, *pAlloc2;
    alloc.GetAnotherAllocator(&pAlloc1);
    alloc.GetAnotherAllocator(&pAlloc2);

    alloc.ResetPosition();
    
    fakeIn1.SetAllocator(pAlloc1);
    fakeIn2.SetAllocator(pAlloc2);
    fakeOut.SetAllocator(pAlloc);

    CFakeOut	fakeOutA(NULL, &hr, UNITS / 15 /* !!! */, &mtAudio, 4096 /* !!! */);

    CCallback	callbackA(&fakeOutA);
    callbackA.AddRef();		// make sure it doesn't go away....
    
    CFakeIn	fakeIn1A(NULL, &hr, &mtAudio, 4096 /* !!! */,
		       (IFakeInAppCallback *)&callbackA);

    CFakeIn	fakeIn2A(NULL, &hr, &mtAudio, 4096 /* !!! */,
		       (IFakeInAppCallback *)&callbackA);

    CMultiAllocator allocA(NAME("Test audio allocator"), NULL, &hr);
    allocA.AddRef();
    
    IMemAllocator *pAllocA;

    callbackA.m_pAlloc = &allocA;
    
    hr = allocA.QueryInterface(IID_IMemAllocator, (void **) &pAllocA);

    IMemAllocator *pAlloc1A, *pAlloc2A;
    allocA.GetAnotherAllocator(&pAlloc1A);
    allocA.GetAnotherAllocator(&pAlloc2A);

    allocA.ResetPosition();
    
    fakeIn1A.SetAllocator(pAlloc1A);
    fakeIn2A.SetAllocator(pAlloc2A);
    fakeOutA.SetAllocator(pAllocA);
    
    IGraphBuilder *graphIn1, *graphIn2, *graphOut;

    CreateFilterGraph(&graphIn1);
    CreateFilterGraph(&graphIn2);
    CreateFilterGraph(&graphOut);

    IBaseFilter *pFakeIn1 = fakeIn1.GetFilter(),
		*pFakeIn2 = fakeIn2.GetFilter(),
		*pFakeOut = fakeOut.GetFilter();

    // target graph must be connected first to set up allocator properly
    hr = graphOut->AddFilter(fakeOut.GetFilter(), L"FakeOutput");

    IPin *pFakeOutPin;
    GetPin(pFakeOut, 0, &pFakeOutPin);

    hr = graphOut->Render(pFakeOutPin);
    pFakeOutPin->Release();

    // now set up source graphs
    graphIn1->AddFilter(pFakeIn1, L"Video FakeIn 1");
    graphIn2->AddFilter(pFakeIn2, L"Video FakeIn 2");

    IBaseFilter *pFakeIn1A = fakeIn1A.GetFilter(),
		*pFakeIn2A = fakeIn2A.GetFilter(),
		*pFakeOutA = fakeOutA.GetFilter();

    // target graph must be connected first to set up allocator properly
    hr = graphOut->AddFilter(fakeOutA.GetFilter(), L"FakeOutput for Audio");

    IPin *pFakeOutPinA;
    GetPin(pFakeOutA, 0, &pFakeOutPinA);

    hr = graphOut->Render(pFakeOutPinA);
    pFakeOutPinA->Release();

    // now set up source graphs
    graphIn1->AddFilter(pFakeIn1A, L"Audio FakeIn 1");
    graphIn2->AddFilter(pFakeIn2A, L"Audio FakeIn 2");

    hr = graphIn1->RenderFile(wszFile1, NULL);
    hr = graphIn2->RenderFile(wszFile2, NULL);

    SetNoClock(graphIn1);
    SetNoClock(graphIn2);

    PrintGraph(graphIn1);
    PrintGraph(graphIn2);
    
    PrintGraph(graphOut);


    // here's where the neat code to step through the file grabbing
    // frames from the "In" graph and writing them to the "Out"
    // graph goes.

    IMediaControl *graphIn1C, *graphIn2C, *graphOutC;

    graphIn1->QueryInterface(IID_IMediaControl, (void **) &graphIn1C);
    graphIn2->QueryInterface(IID_IMediaControl, (void **) &graphIn2C);
    graphOut->QueryInterface(IID_IMediaControl, (void **) &graphOutC);

    graphOutC->Run();
    graphIn1C->Run();
    graphIn2C->Run();

    printf("Waiting for something to happen...\n");

    while (!callback.DoneYet()) {
	if (fVerbose)
	    printf("  still waiting...\n");
	Sleep(1000);
    }


    // !!! do we need to stop things?

    printf("All done.\n");

    graphOutC->Stop();   graphOutC->Release();
    graphIn1C->Stop();    graphIn1C->Release();
    graphIn2C->Stop();    graphIn2C->Release();

    // clean up, exit

    graphIn1->Release();
    graphIn2->Release();
    graphOut->Release();

    CoUninitialize();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\seglist\seglist.cpp ===
#include <streams.h>

#include <initguid.h>

//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// EditList
//
// CTransInPlaceFilter derived.  Implements an edit list on a stream.
//
// Strategy:
// has a list of segments of the upstream data to be played.
// plays them one at a time by setting the start and stop positions
// of the upstream filter.
// when an end of stream notification is received, that indicates that
// a single segment has finished, and we go to the next segment, only
// passing the EOS through when there are no more segments to play.
//
//
// Still to be done:
// !!! The actual edit-list is currently hard-coded in the constructor.
// Needs a property page & a custom interface to allow setting these.
//
// ChangeStart, ChangeStop still need to be implemented: currently
// always plays the entire edit list, not the subsection a user might
// have chosen.
//

// Our CLSID; should be in uuids.h?
// EditList Filter Object
//
// {F97B8A62-31AD-11cf-B2DE-00DD01101B85}
DEFINE_GUID(CLSID_SegList,
0xf97b8a62, 0x31ad, 0x11cf, 0xb2, 0xde, 0x0, 0xdd, 0x1, 0x10, 0x1b, 0x85);

typedef struct {
    CRefTime rtStart;
    CRefTime rtStop;
} TimeSegment;

class CSegList;

#ifdef FIXPOSITIONSTUFF
// implementation of IMediaPosition
class CSLPosition : public CSourcePosition
{
protected:
    CSegList * m_pFilter;

    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();
public:
    CSLPosition(TCHAR*, CSegListFilter*, HRESULT*, CCritSec*);
    double Rate() {
	return m_Rate;
    };
    CRefTime Start() {
	return m_Start;
    };
    CRefTime Stop() {
	return m_Stop;
    };
};
#endif



class CNextSegThread : public CAMThread {
    DWORD ThreadProc();

    CSegList *m_pFilter;
public:
	
    BOOL Create(CSegList *pFilter) {
	m_pFilter = pFilter;
	return CAMThread::Create();
    }
};

//
// CSegList
//
class CSegList : public CTransInPlaceFilter {
    friend class CSLPosition;
    friend class CNextSegThread;

public:

    //
    // --- COM Stuff ---
    //

    static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *phr);

#ifdef FIXPOSITIONSTUFF
    // !!! this needs to be in the output pin, unfortunately.
    // !!! override CTransformFilter::GetIMediaPosition
    // override to expose our special IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
#endif

    //
    // --- CTransInPlaceFilter Overrides --
    //

    // Overrides the PURE virtual Transform of CTransInPlaceFilter base class
    HRESULT Transform(IMediaSample *pSample);
    HRESULT CheckInputType(const CMediaType *mtIn) {return NOERROR;};
    HRESULT CheckTransform(const CMediaType *mtIn, const CMediaType *mtOut) {return NOERROR;};
    HRESULT DecideBufferSize(IMemAllocator *pAlloc) {return NOERROR;};
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) {return E_NOTIMPL;};

    HRESULT StartStreaming();
    HRESULT EndOfStream();
    HRESULT BeginFlush();
    HRESULT EndFlush();

    HRESULT CheckConnect(PIN_DIRECTION dir,IPin *pPin);
    HRESULT CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin);

private:

    CSegList(LPUNKNOWN punk, HRESULT *phr);
    ~CSegList();

    HRESULT SetCurrentSegment();

    CCritSec	m_SegListLock;

    TimeSegment m_SegList[10]; //!!!
    int		m_Segments;		// # of edit-list segments
    int		m_curSeg;		// segment we're currently playing
    CRefTime	m_curOffset;		// current offset between incoming
					// and outgoing timestamps

    IMediaSeeking *m_posUpstream;	// cached upstream IMediaSeeking

    CNextSegThread m_thread;


    BOOL fStupidHack;

#ifdef FIXPOSITIONSTUFF
    CSLPosition	m_slp;			// our IMediaPosition implementation,
					// for the benefit of those upstream
					// from *us*.
#endif
};


// COM Global table of objects in this dll
CFactoryTemplate g_Templates[] = {

    {L"", &CLSID_SegList, CSegList::CreateInstance},
};
// Count of objects listed in g_cTemplates
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);



//
// CreateInstance
//
// Provide the way for COM to create a CSegList object
CUnknown *CSegList::CreateInstance(LPUNKNOWN punk, HRESULT *phr) {

    CSegList *pNewObject = new CSegList(punk, phr);
    if (pNewObject == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return pNewObject;
}



#ifdef FIXPOSITIONSTUFF
CSLPosition::CSLPosition(
    TCHAR * pName,
    LPUNKNOWN pUnk,
    HRESULT* phr,
    CCritSec * pLock) : CSourcePosition(pName, pUnk, pLock)
{
}

CSLPosition::ChangeRate()
{
    return m_posUpstream->put_Rate(m_Rate);
}

CSLPosition::ChangeStart()
{
    // !!!

    return E_NOTIMPL;
}

CSLPosition::ChangeRate()
{
    // !!!

    return E_NOTIMPL;
}
#endif

//
// CSegList::Constructor
//
CSegList::CSegList(LPUNKNOWN punk, HRESULT *phr)
    : CTransInPlaceFilter(NAME("SegList Filter"), punk, CLSID_SegList, phr)
#ifdef FIXPOSITIONSTUFF
	    , m_slp(NAME("SegList position"), punk, phr, &m_csFilter)
#endif
{
     m_Segments = 6;

     m_SegList[0].rtStart = CRefTime(0L);
     m_SegList[0].rtStop  = CRefTime(5000L);

     m_SegList[1].rtStart = CRefTime(10000L);
     m_SegList[1].rtStop  = CRefTime(15000L);

     m_SegList[2].rtStart = CRefTime(10000L);
     m_SegList[2].rtStop  = CRefTime(15000L);

     m_SegList[3].rtStart = CRefTime(10000L);
     m_SegList[3].rtStop  = CRefTime(15000L);

     m_SegList[4].rtStart = CRefTime(5000L);
     m_SegList[4].rtStop  = CRefTime(10000L);

     m_SegList[5].rtStart = CRefTime(0L);
     m_SegList[5].rtStop  = CRefTime(5000L);

#ifdef FIXPOSITIONSTUFF
     m_slp.m_Duration = 0;
     for (int i = 0; i < m_Segments; i++) {
	 m_slp.m_Duration += (m_SegList[i].rtStop - m_SegList[i].rtStart);
     }

     DbgLog((LOG_TRACE, 2, TEXT("SegList: total length %s"),
	    (LPCTSTR)CDisp(m_slp.m_Duration)));
#endif

     m_posUpstream = NULL;

     m_thread.Create(this);

}


CSegList::~CSegList()
{
    if (m_posUpstream)
	m_posUpstream->Release();
    m_thread.CallWorker(0);
}


HRESULT
CSegList::CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin)
{
    if (direction == PINDIR_INPUT)
	return pReceivePin->QueryInterface(IID_IMediaSeeking,
					   (void **) &m_posUpstream);

    return NOERROR;
}

// !!! is it bad to fail in CompleteConnect rather than CheckConnect?
HRESULT
CSegList::CheckConnect(PIN_DIRECTION dir,IPin *pPin)
{
    return NOERROR;
}


HRESULT
CSegList::SetCurrentSegment()
{
    HRESULT hr;

    // compute offset to be added to the timestamp of samples in the
    // current edit list segment
    m_curOffset = 0;
    int i = m_curSeg;
    while (--i >= 0) {
	m_curOffset += (m_SegList[i].rtStop - m_SegList[i].rtStart);
    }
    // m_curOffset -= m_SegList[m_curSeg].rtStart;

    hr = m_posUpstream->SetPositions((REFERENCE_TIME *) &m_SegList[m_curSeg].rtStart,
				     AM_SEEKING_AbsolutePositioning,
				     (REFERENCE_TIME *) &m_SegList[m_curSeg].rtStop,
				     AM_SEEKING_AbsolutePositioning);

    DbgLog((LOG_TRACE, 2, TEXT("Segment #%d: (%s - %s) offset is %s"),
	    m_curSeg,
	    (LPCTSTR)CDisp(m_SegList[m_curSeg].rtStart),
	    (LPCTSTR)CDisp(m_SegList[m_curSeg].rtStop),
	    (LPCTSTR)CDisp(m_curOffset) )) ;

    // !!! is the upstream filter necessarily running at this point,
    // or do we perhaps have to wake it up?

    return hr;
}

// !!! when do we set the initial segment; is StartStreaming
// soon enough, or does it have to happen before then?
HRESULT
CSegList::StartStreaming()
{
    m_curSeg = 0;

    fStupidHack = TRUE;

    return SetCurrentSegment();
}

HRESULT
CSegList::EndOfStream(void)
{
    if (!fStupidHack) {
	DbgLog((LOG_TRACE, 2, TEXT("Ignoring extra EOS")));
	return NOERROR;
    }

    DbgLog((LOG_TRACE, 2, TEXT("Finished with segment #%d"), m_curSeg));

    // !!! needs to respect the "stop time" set on this filter....
    if (++m_curSeg >= m_Segments) {
	DbgLog((LOG_TRACE, 2, TEXT("Sending endofstream")));

	return CTransInPlaceFilter::EndOfStream();
    } else {
	// return SetCurrentSegment();

	fStupidHack = FALSE;
	
	return (HRESULT) m_thread.CallWorker(1);
    }
}

// eat these so as not to upset the downstream filter.
// the fStupidHack flag tells us whether any data has been sent for this
// segment yet.  If it isn't set, we presume this BeginFlush is a spurious
// one sent because of the Seek we did.  It would be nice to have a special
// seek that didn't generate a BeginFlush.
HRESULT CSegList::BeginFlush()
{
    if (fStupidHack)
	return CTransInPlaceFilter::BeginFlush();

    return S_OK;
}


HRESULT CSegList::EndFlush()
{
    if (fStupidHack)
	return CTransInPlaceFilter::EndFlush();

    return S_OK;
}

DWORD CNextSegThread::ThreadProc()
{
    DWORD cmd;

    while (1) {
	cmd = GetRequest();

	Reply(NOERROR);
	
	if (cmd == 0)
	    break;

	m_pFilter->SetCurrentSegment();
    }
	

    return 0;
}



HRESULT
CSegList::Transform(IMediaSample *pSample)
{
    // !!! fix sample timestamp
    CRefTime rtStart, rtEnd;

    pSample->GetTime((REFERENCE_TIME *) &rtStart, (REFERENCE_TIME *) &rtEnd);

    CRefTime rtNewStart = rtStart + m_curOffset;
    DbgLog((LOG_TRACE, 2, TEXT("Adjusting sample start from %s to %s"),
	    (LPCTSTR)CDisp(rtStart),
	    (LPCTSTR)CDisp(rtNewStart) )) ;

    rtStart += m_curOffset;
    rtEnd += m_curOffset;
    pSample->SetTime((REFERENCE_TIME *) &rtStart, (REFERENCE_TIME *) &rtEnd);

    fStupidHack = TRUE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\lyrread\lyrread.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// lyric file parser
//
// based on code stolen from Nigel Thompson a long long time ago
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "lyrread.h"

//
// setup data
//

const AMOVIESETUP_MEDIATYPE
psudLyricReadType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &MEDIATYPE_Text } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudLyricReadOutType = { &MEDIATYPE_Text       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudLyricReadPins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudLyricReadType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudLyricReadOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudLyricRead = { &CLSID_LyricReader     // clsID
               , L"Lyric Parser"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudLyricReadPins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"Lyric Parser"
    , &CLSID_LyricReader
    , CLyricRead::CreateInstance
    , NULL
    , &sudLyricRead }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CLyricRead::Constructor
//
CLyricRead::CLyricRead(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
    : CSimpleReader(pName, lpunk, CLSID_LyricReader, &m_cStateLock, phr),
	m_lpLyrics(NULL),
	m_lpFile(NULL)
{

    CAutoLock l(&m_cStateLock);

    DbgLog((LOG_TRACE, 1, TEXT("CLyricRead created")));
}


//
// CLyricRead::Destructor
//
CLyricRead::~CLyricRead(void) {
    NukeLyrics(&m_lpLyrics);

    delete[] m_lpFile;
    DbgLog((LOG_TRACE, 1, TEXT("CLyricRead destroyed")) );
}


//
// CreateInstance
//
// Called by CoCreateInstance to create a QuicktimeReader filter.
CUnknown *CLyricRead::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CLyricRead(NAME("Lyric parsing filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


//
// Count the number of lines in a file
//

DWORD CLyricRead::CountLines()
{
    UINT uiBytes = m_cbFile;
    DWORD dwLines = 0l;
    BYTE * lpBuf = m_lpFile;

    while (uiBytes--) {
	if (*lpBuf == '\n') dwLines++;
	lpBuf++;
    }

    return dwLines;
}

//
// Nuke an existing lyric list
//

void CLyricRead::NukeLyrics(LPSONGLINE FAR * lplpLyrics)
{
    if (!*lplpLyrics) return;

    delete[] *lplpLyrics;
    *lplpLyrics = NULL;
}


BOOL MatchStart(BYTE *lpLine, char *lpStr)
{
    while (*lpStr) {
	if ((char) *lpLine++ != *lpStr++)
	    return FALSE;
    }

    return TRUE;
}

BOOL myisspace(char c) { return (c == ' ' || c == '\t'); }
BOOL myisdigit(char c) { return (c >= '0' && c <= '9'); }

//
// Parse a lyric file line. Returns TRUE if a songline was parsed
// If the numeric value at the start of a songline has TMSF format
// it's decoded as that. Otherwise it's decoded as milliseconds
//

BOOL CLyricRead::ParseLyricLine(BYTE * lpLine, LPSONGLINE lpSongLine)
{
    DWORD track;
    UINT mins, secs, frames;

    if (!*lpLine)
	return FALSE;

    while (*lpLine && myisspace(*lpLine)) lpLine++; // skip spaces

#if 0
    //
    // See if it's a tagged field we want
    //

    if (lstrcmpi(lpLine, "ARTIST") == 0) {
        lpLine += 6;
        while (*lpLine && myisspace(*lpLine)) lpLine++; // skip spaces
        lstrcpy(szArtist, lpLine);
        return FALSE;
    }

    if (lstrcmpi(lpLine, "TITLE") == 0) {
        lpLine += 5;
        while (*lpLine && myisspace(*lpLine)) lpLine++; // skip spaces
        lstrcpy(szTitle, lpLine);
        return FALSE;
    }
#endif

    if (MatchStart(lpLine, "LYRICS")) {
	return FALSE;
    }
    
    //
    // If it's numeric it's a song line, otherwise ignore it
    //

    if (!myisdigit(*lpLine)) return FALSE;

    //
    // Assume it's TMSF and collect the track, mins, secs and frames
    //

    track = 0;
    while (myisdigit(*lpLine)) {
        track *= 10;
        track += (DWORD)(*lpLine - '0');
        lpLine++;
    }

    //
    // See if it really is TMSF
    //

    if (*lpLine == ',') {

        //
        // Collect the rest of the TMSF value
        //

        lpLine++;
        mins = 0;
        while (myisdigit(*lpLine)) {
            mins *= 10;
            mins += *lpLine - '0';
            lpLine++;
        }
        if (*lpLine != ':') return FALSE;
        lpLine++;
        secs = 0;
        while (myisdigit(*lpLine)) {
            secs *= 10;
            secs += *lpLine - '0';
            lpLine++;
        }
        if (*lpLine != '.') return FALSE;
        lpLine++;
        frames = 0;
        while (myisdigit(*lpLine)) {
            frames *= 10;
            frames += *lpLine - '0';
            lpLine++;
        }
    
//        lpSongLine->dwPosition = MCI_MAKE_TMSF(track,mins,secs,frames);
	lpSongLine->dwPosition = frames * (1000 / 75) +
				 secs * 1000 +
				 mins * 60000L;

    } else {

        //
        // Assume it was a millisecond value
        //

        lpSongLine->dwPosition = track;

    }

    //
    // skip trailing white space
    // 

    while (*lpLine && myisspace(*lpLine)) lpLine++;

    int len = lstrlenA((LPSTR) lpLine) + 1;

    if (m_MaxSize < len)
	m_MaxSize = len;
    
    //
    // Allocate some memory for the text and copy it
    //

    lpSongLine->lpText = (LPSTR) lpLine; 
    if (!lpSongLine->lpText) return FALSE;

    return TRUE;
}

//
// Read a lyric file and build a new info list
//

BOOL CLyricRead::ReadLyrics(LPSONGLINE FAR*lplpLyrics, DWORD FAR *lpdwMaxPos)
{
    DWORD dwLines;
    UINT uiBytes = m_cbFile;
    BYTE * lpBuf = m_lpFile, * lpLine;
    LPSONGLINE lpSongLine;

    dwLines = CountLines();

    if (!dwLines) return FALSE;

    NukeLyrics(lplpLyrics); // get rid of any old ones

    //
    // Allocate a new array for the info
    //

    *lplpLyrics = new SONGLINE [dwLines+1];
    if (!*lplpLyrics) return FALSE;

    *lpdwMaxPos = 0;
    
    //
    // Read each line and fill out the info for each one
    //

    lpSongLine = *lplpLyrics;
    lpLine = lpBuf;
    while (uiBytes--) {

	switch (*lpBuf) {
	case '\r':
	case '\n':
	    *lpBuf = '\0';

	    // parse it and add to the info
	    if (ParseLyricLine(lpLine, lpSongLine)) {
		if (*lpdwMaxPos < lpSongLine->dwPosition)
		    *lpdwMaxPos = lpSongLine->dwPosition;
		lpSongLine++;
	    }
	    lpLine = lpBuf+1;
	    break;

	default:
	    break;
	}

	lpBuf++;
    }

    lpSongLine->lpText = NULL;
    
    return TRUE;
}




HRESULT CLyricRead::ParseNewFile()
{
    HRESULT         hr = NOERROR;

    LONGLONG llTotal, llAvailable;

    m_pAsyncReader->Length(&llTotal, &llAvailable);
    
    m_cbFile = (DWORD) llTotal;

    m_lpFile = new BYTE[m_cbFile];

    if (!m_lpFile)
	goto readerror;
    
    /* Try to read whole file */
    hr = m_pAsyncReader->SyncRead(0, m_cbFile, m_lpFile);

    if (hr != S_OK)
        goto readerror;


    if (!ReadLyrics(&m_lpLyrics, &m_dwMaxPosition))
	goto memerror;

    m_sLength = m_dwMaxPosition + 1; // !!!

    {
	CMediaType mtText;

	mtText.SetType(&MEDIATYPE_Text);
	mtText.SetFormatType(&GUID_NULL);
	mtText.SetVariableSize();
	mtText.SetTemporalCompression(FALSE);
	// !!! anything else?

	SetOutputMediaType(&mtText);
    }
    
    return hr;

memerror:
    hr = E_OUTOFMEMORY;
    goto error;

readerror:
    hr = VFW_E_INVALID_FILE_FORMAT;

error:
    return hr;
}


ULONG CLyricRead::GetMaxSampleSize()
{
    return m_MaxSize;
}


// !!! rounding
// returns the sample number showing at time t
LONG
CLyricRead::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * MILLISECONDS) / UNITS);
    return s;
}

CRefTime
CLyricRead::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, UNITS, MILLISECONDS, MILLISECONDS-1 );
}


HRESULT
CLyricRead::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != MEDIATYPE_Text)
        return E_INVALIDARG;

    return S_OK;
}


LONG CLyricRead::StartFrom(LONG sStart)
{
    LONG sLast = 0;
    
    SONGLINE * pLine = m_lpLyrics;
    while (pLine->lpText) {
	if (pLine->dwPosition > (DWORD) sStart)
	    break;
	sLast = (LONG) pLine->dwPosition;
	pLine++;
    }

    return sLast;
}

HRESULT CLyricRead::FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pdwSamples)
{
    PBYTE pbuf;
    const DWORD lSamples = 1;

    DWORD dwSize = pSample->GetSize();
    
    HRESULT hr = pSample->GetPointer(&pbuf);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	pSample->Release();
	return E_OUTOFMEMORY;
    }

    SONGLINE * pLine = m_lpLyrics;
    while (pLine->lpText) {
	if (pLine->dwPosition >= dwStart)
	    break;
	pLine++;
    }

    ASSERT(pLine->lpText); // !!! shouldn't have hit sentinel....
    
    if ((pLine+1)->lpText)
	*pdwSamples = (pLine+1)->dwPosition - pLine->dwPosition;
    else
	*pdwSamples = 1; // !!! 0?

    ASSERT(lstrlenA(pLine->lpText) < (int) dwSize);
    
    lstrcpyA((LPSTR) pbuf, pLine->lpText);
    
    hr = pSample->SetActualDataLength(lstrlenA(pLine->lpText)+1);
    ASSERT(SUCCEEDED(hr));

    // mark as a sync point if it should be....
    pSample->SetSyncPoint(TRUE);  // !!!
	
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\sami\rawparse.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.

struct STRING_ENTRY {
    char *	pTag;
    int		token;
};


typedef enum _PARSETOKEN {
    TOK_EMPTY = -3,
    TOK_NUMBER = -2,
    TOK_STRING = -1,
    TOK_CUSTOM = 100
} PARSETOKEN;

const int MAX_TAGS = 20;

const int MAX_STRING_LEN = 1024;

const int MAX_TAG_STRING_LEN = 20;      // QFE #33995 fix

class CToken {
public:
    PARSETOKEN	tokType;

    union {
	int	tokValue;

	struct {
	    char *	tokString;
	    int		cbString;
	};

	struct {
	    int	cTags;
	    struct {
		char tag[MAX_TAG_STRING_LEN];   // QFE #33995 fix
		char value[MAX_STRING_LEN];
		BOOL fUsed;
	    } tokTags[MAX_TAGS];

	    BOOL	fEnd;		// if custom tag, is this the end of a tag?
	    BOOL	fSingle;	// for XML-style tags, is it complete? <tag stuff />
	};

	// !!! how to represent custom data?
    };

};

const int MAX_TOKENS=50;	// number of new tokens


class CTokenInterpreter {
public:
    virtual BOOL	SpecialTagParsing(int token) = 0;
    virtual HRESULT	NewToken(CToken &tok) = 0;
};


class CRawParser {
    STRING_ENTRY	m_sTab[MAX_TOKENS];
    int			m_cTab;

    STRING_ENTRY *	m_sTabInitial;
    int			m_cTabInitial;

    CTokenInterpreter *	m_pInterp;

    BOOL		m_bReturnCopy;
    
public:
    CRawParser(CTokenInterpreter *pInterp,
	       STRING_ENTRY *sTabInitial = 0, int cTabInitial = 0, BOOL bReturnCopy = FALSE)
    {
	m_pInterp = pInterp;
	ResetStringTable(sTabInitial, cTabInitial);
	m_bReturnCopy = bReturnCopy;
    };

    HRESULT ResetStringTable(STRING_ENTRY *sTabInitial = 0, int cTabInitial = 0)
    {
	m_sTabInitial = sTabInitial;
	m_cTabInitial = cTabInitial;
	m_cTab = 0;

	return S_OK;
    };

    HRESULT Parse(char *pData, int cbData)
    {
	// does this need to be restartable, or can we get the whole file all at once?
	HRESULT hr = S_OK;

	CToken	tok;

	while (cbData--) {
	    char c = *pData++;

	    if (c == '\0') {
		DbgLog((LOG_ERROR, 1, TEXT("got null with %d chars left?"), cbData+1));
		break;
	    }

	    if (c == '<') {
		int cbTag = 0;
		BOOL fNot = FALSE;

		if (*pData == '/') {
		    fNot = TRUE;
		    pData++;
		    cbData--;
		}

		while (cbTag + 1 < cbData && pData[cbTag] != '>' &&
			       pData[cbTag] != ' ' &&
			       pData[cbTag] != '\t' &&
			       pData[cbTag] != '\r' &&
			       pData[cbTag] != '\n' &&
			       pData[cbTag] != '=')
		    ++cbTag;

		STRING_ENTRY *	pTagToTest = NULL;
		BOOL fFound = FALSE;
		if (cbTag == 0) {
		    if (fNot) {
			DbgLog((LOG_TRACE, 4, TEXT("Found /> tag")));
			fFound = TRUE;
		    } else {

		    }
		} else {
		    for (int i = 0; i < m_cTab + m_cTabInitial; i++) {
			if (i < m_cTabInitial) {
			    pTagToTest = &m_sTabInitial[i];
			} else {
			    pTagToTest = &m_sTab[i - m_cTabInitial];
			}

			int res = CompareStringA(0, NORM_IGNORECASE,
						pTagToTest->pTag, -1,
						pData, cbTag);

			if (res == 2) {	// are strings equal?

			    DbgLog((LOG_TRACE, 4, TEXT("Found token #%d '%hs'  fNot = %d...."),
				   pTagToTest->token, pTagToTest->pTag, fNot));

			    fFound = TRUE;
			    break;
			}
		    }
		}
		if (!fFound) {
		    DbgLog((LOG_TRACE, 2, TEXT("couldn't interpret %.10hs"), pData-1));
		    // !!! go handle as a string instead

		    if (fNot) {
			--pData;
			++cbData;
		    }
		} else {
		    // skip over tag name, up to space or closing bracket
		    pData += cbTag;
		    cbData -= cbTag;

		    if (pTagToTest) {
			tok.tokType = (PARSETOKEN) pTagToTest->token;
		    } else 
			tok.tokType = TOK_EMPTY;
		    tok.cTags = 0;
		    tok.fEnd = fNot;
		    tok.fSingle = FALSE;
		    if (FAILED(hr))	// what's hr here???
			return hr;

		    if (m_pInterp->SpecialTagParsing(tok.tokType)) {
			while (--cbData) {
			    char c = *pData++;

			    if (c == ' ' || c == '\r' || c == '\n' || c == '\t')
				continue;

			    if (c == '-')
				continue;

			    if (c == '>')
				break;

			    if (tok.cTags >= MAX_TAGS) {
				// !!!
				continue;
			    }

			    int cbTag = 0;
			    while (cbTag < cbData && cbTag < (MAX_TAG_STRING_LEN-1) && c != ' ' && c != '=' && c != '>') {  /* QFE #33995 fix */
				tok.tokTags[tok.cTags].tag[cbTag] = c;
				c = pData[cbTag++];
			    }
			    tok.tokTags[tok.cTags].tag[cbTag] = '\0';
			    tok.tokTags[tok.cTags].fUsed = FALSE;

			    pData += cbTag-1;
			    cbData -= cbTag-1;

			    int cbValue = 0;

			    if (c == ' ') { // we have a value, get that too
				pData++; --cbData;		// first skip '=' sign

				c = *pData++; --cbData;	// get first character of value
				if (c == '{') {
				    c = *pData++; --cbData;	// skip opening '{'
				}

				while (cbValue < cbData &&
				       cbValue < MAX_STRING_LEN-1 &&
				       c != '>') {
				    tok.tokTags[tok.cTags].value[cbValue] = c;
				    if (c == '}') {
					++cbValue;
					break;
				    }

				    c = pData[cbValue++];
				}

				pData += cbValue-1;
				cbData -= cbValue-1;
			    }

			    if (cbValue > 0 && tok.tokTags[tok.cTags].value[cbValue-1] == '}')
				--cbValue;

			    tok.tokTags[tok.cTags].value[cbValue] = '\0';

			    DbgLog((LOG_TRACE, 4, TEXT("Tag #%d: '%hs' = '%hs'"), tok.cTags,
				    tok.tokTags[tok.cTags].tag,
				    tok.tokTags[tok.cTags].value));

			    tok.cTags++;
			}
		    } else {
			while (--cbData) {
			    char c = *pData++;

			    if (c == '/' && *pData == '*') {
				DbgLog((LOG_TRACE, 4, TEXT("Found a C-style comment")));

				for (int cmtLength = 3; cmtLength < cbData; cmtLength++) {
				    if (pData[cmtLength-2] == '*' && pData[cmtLength-1] == '/') {
					pData += cmtLength;
					cbData -= cmtLength;
					break;
				    }
				}
				continue;
			    }

			    if (c == '/' && *pData == '>') {
				tok.fSingle = TRUE;
				c = *pData++;
				--cbData;
			    }

			    if (c == '>')
				break;

			    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
				continue;

			    if (tok.cTags >= MAX_TAGS) {
				// !!!
				continue;
			    }

			    int cbTag = 0;
                while (cbTag < cbData && cbTag < (MAX_TAG_STRING_LEN-1) && c != ' ' && c != '=' && c != '/' && c != '>') { /* QFE #33995 fix */
				tok.tokTags[tok.cTags].tag[cbTag] = c;
				c = pData[cbTag++];
			    }
			    tok.tokTags[tok.cTags].tag[cbTag] = '\0';

			    pData += cbTag;
			    cbData -= cbTag;

			    int cbValue = 0;

			    while (c == ' ' || c == '\r' || c == '\n' || c == '\t') {
				c = *pData++;
				--cbData;
			    }

			    if (c == '=') { // we have a value, get that too
				c = *pData++; --cbData;	// get first character of value

				while (c == ' ' || c == '\r' || c == '\n' || c == '\t') {
				    c = *pData++;
				    --cbData;
				}

				BOOL fQuoted = FALSE;
				if (c == '"') {
				    fQuoted = TRUE;
				    c= *pData++;
				    --cbData;
				}


				while (cbValue < cbData &&
				       cbValue < MAX_STRING_LEN-1 &&        /* QFE #33995 Fix */
				       !((fQuoted && c == '"') ||
					 (!fQuoted && (c == ' ' ||
						       c == '"' ||
						       c == '/' ||
						       c == '>' ||
						       c == '\t' ||
						       c == '\r' ||
						       c == '\n')))) {
				    tok.tokTags[tok.cTags].value[cbValue] = c;
				    c = pData[cbValue++];
				}

				pData += cbValue-1;
				cbData -= cbValue-1;

				if (c == '"') {
				    if (fQuoted) {
					// skip over ending quote
					pData++;
					cbData--;
				    } else {
					// random quote in the file
					return VFW_E_INVALID_FILE_FORMAT;
				    }
				}
			    } else {
				// push extra character back
				pData--;
				cbData++;
			    }

			    tok.tokTags[tok.cTags].value[cbValue] = '\0';

			    DbgLog((LOG_TRACE, 4, TEXT("Tag #%d: '%hs' = '%hs'"), tok.cTags,
				    tok.tokTags[tok.cTags].tag,
				    tok.tokTags[tok.cTags].value));

			    tok.cTags++;
			}
		    }

		    hr = m_pInterp->NewToken(tok);
		    if (FAILED(hr))
			return hr;

		    continue;
		}
	    }

	    if (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
		continue;
    #ifdef DO_WE_REALLY_SPECIAL_CASE_NUMBERS
	    } else if (c >= '0' && c <= '9') {
		int num = c - '0';

		while (cbData && (c = *pData, (c >= '0' && c <= '9'))) {
		    num = num * 10 + (c - '0');
		    ++pData;
		    --cbData;
		}

		DbgLog((LOG_TRACE, 2, TEXT("Found a number...%d"), num));
		tok.tokType = TOK_NUMBER;
		tok.tokValue = num;
		hr = m_pInterp->NewToken(tok);

		if (FAILED(hr))
		    return hr;
    #endif
	    } else {
		// it's a string, parse it somehow.
		int cbString = 0;

    #if 0
		BOOL fQuoted = FALSE;
		if (c == '"') {
		    fQuoted = TRUE;
		    c= *pData++;
		    --cbData;
		}

		char *pString = pData - 1;
		char achString[MAX_STRING_LEN];

		while (cbString < cbData &&
		       !((fQuoted && c == '"') ||
			 (!fQuoted && (c == ' ' ||
				       c == '<' ||
				       c == '/t' ||
				       c == '\r' ||
				       c == '\n')))) {
		    achString[cbString] = c;
		    c = pData[cbString++];
		}

		pData += cbString-1;
		cbData -= cbString-1;

		if (fQuoted && c == '"') {
		    // skip over ending quote
		    pData++;
		    cbData--;
		}
    #else
		char achString[MAX_STRING_LEN];

		char *pString = pData - 1;

		int iSinceNonSpace = 0;

		while (cbString < cbData && cbString < MAX_STRING_LEN-1 &&
					   ((cbString == 0) || (c != '<'))) {
		    if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
			++iSinceNonSpace;
		    else
			iSinceNonSpace = 0;

		    achString[cbString] = c;
		    c = pData[cbString++];
		}

		cbString -= iSinceNonSpace;

		if (cbString == cbData)
		    cbString++;	// normally, don't copy last char, but now we must

		pData += cbString-1;
		cbData -= cbString-1;
    #endif
		achString[cbString] = '\0';
		DbgLog((LOG_TRACE, 2, TEXT("Found a %d byte string, '%hs'"), cbString, achString));
		tok.tokType = TOK_STRING;
		tok.tokString = m_bReturnCopy ? achString : pString;
		tok.cbString = cbString;
		hr = m_pInterp->NewToken(tok);

		if (FAILED(hr))
		    return hr;
	    }
	}

	return S_OK;
    }

    HRESULT AddString(char *pString, int cString, int newID)
    {
	if (m_cTab == MAX_TOKENS)
	    return E_OUTOFMEMORY;

	m_sTab[m_cTab].pTag = new char[lstrlenA(pString)+1];
	lstrcpyA(m_sTab[m_cTab].pTag, pString);

	// !!! cString?
	m_sTab[m_cTab].token = newID;

	++m_cTab;

	return S_OK;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\sami\samiread.h ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.

extern const AMOVIESETUP_FILTER sudSAMIRead;

// {33FACFE0-A9BE-11d0-A520-00A0D10129C0}
DEFINE_GUID(CLSID_SAMIReader, 
0x33facfe0, 0xa9be, 0x11d0, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x29, 0xc0);

CUnknown *CreateSAMIInstance(LPUNKNOWN lpunk, HRESULT *phr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\sami\samiread.cpp ===
// Copyright (c) 1994 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// CC file parser
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "samiread.h"

#include "sami.cpp"

#include "simpread.h"


// !!! Things left to do:
//
// Support >1 language, either via a switch or >1 output pin
// expose descriptive audio somehow
// look at samiparam length, other samiparams
//
// Should switch to passing Unicode SCRIPTCOMMAND data, rather than text
//

//
// CSAMIRead
//
class CSAMIRead : public CSimpleReader, public IAMStreamSelect {
public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    CSAMIRead(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CSAMIRead();

    /* IAMStreamSelect */

    //  Returns total count of streams
    STDMETHODIMP Count(
        /*[out]*/ DWORD *pcStreams);      // Count of logical streams

    //  Return info for a given stream - S_FALSE if iIndex out of range
    //  The first steam in each group is the default
    STDMETHODIMP Info(
        /*[in]*/ long iIndex,              // 0-based index
        /*[out]*/ AM_MEDIA_TYPE **ppmt,   // Media type - optional
                                          // Use DeleteMediaType to free
        /*[out]*/ DWORD *pdwFlags,        // flags - optional
        /*[out]*/ LCID *plcid,            // Language id - optional
        /*[out]*/ DWORD *pdwGroup,        // Logical group - 0-based index - optional
        /*[out]*/ WCHAR **ppszName,       // Name - optional - free with CoTaskMemFree
                                          // Can return NULL
        /*[out]*/ IUnknown **ppPin,       // Associated pin - returns NULL - optional
                                          // if no associated pin
        /*[out]*/ IUnknown **ppUnk);      // Stream specific interface

    //  Enable or disable a given stream
    STDMETHODIMP Enable(
        /*[in]*/  long iIndex,
        /*[in]*/  DWORD dwFlags);

    // pure CSimpleReader overrides
    HRESULT ParseNewFile();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    LONG StartFrom(LONG sStart);
    HRESULT FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pcSamples);
    LONG RefTimeToSample(CRefTime t);
    CRefTime SampleToRefTime(LONG s);
    ULONG GetMaxSampleSize();

    DWORD	m_dwMaxPosition;
    BYTE *	m_lpFile;
    DWORD	m_cbFile;
    DWORD	m_dwLastPosition;

    CSAMIInterpreter	m_interp;

    CSAMIInterpreter::CStreamInfo *	m_pstream;
    CSAMIInterpreter::CStyleInfo *	m_pstyle;
};




//
// setup data
//

const AMOVIESETUP_MEDIATYPE
psudSAMIReadType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &CLSID_SAMIReader } }; //    clsMinorType


const AMOVIESETUP_MEDIATYPE
sudSAMIReadOutType = { &MEDIATYPE_Text       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudSAMIReadPins[] =  { { L"Input"             // strName
		    , FALSE                // bRendered
		    , FALSE                // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , psudSAMIReadType }, // lpTypes
		         { L"Output"             // strName
		    , FALSE                // bRendered
		    , TRUE                 // bOutput
		    , FALSE                // bZero
		    , FALSE                // bMany
		    , &CLSID_NULL          // clsConnectsToFilter
		    , L""                  // strConnectsToPin
		    , 1                    // nTypes
		    , &sudSAMIReadOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudSAMIRead = { &CLSID_SAMIReader     // clsID
               , L"SAMI (CC) Parser"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudSAMIReadPins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"SAMI (CC) file parser"
    , &CLSID_SAMIReader
    , CreateSAMIInstance
    , NULL
    , &sudSAMIRead }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CSAMIRead::Constructor
//
CSAMIRead::CSAMIRead(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
    : CSimpleReader(pName, lpunk, CLSID_SAMIReader, &m_cStateLock, phr),
	m_lpFile(NULL)
{

    CAutoLock l(&m_cStateLock);

    DbgLog((LOG_TRACE, 1, TEXT("CSAMIRead created")));
}


//
// CSAMIRead::Destructor
//
CSAMIRead::~CSAMIRead(void) {
    // !!! NukeLyrics();
    
    delete[] m_lpFile;
    DbgLog((LOG_TRACE, 1, TEXT("CSAMIRead destroyed")) );
}


CUnknown *CreateSAMIInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
    return CSAMIRead::CreateInstance(lpunk, phr);
}

//
// CreateInstance
//
// Called by CoCreateInstance to create our filter.
CUnknown *CSAMIRead::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CSAMIRead(NAME("SAMI parsing filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


/* Override this to say what interfaces we support and where */

STDMETHODIMP
CSAMIRead::NonDelegatingQueryInterface(REFIID riid,void ** ppv)
{
    /* Do we have this interface? */
    if (riid == IID_IAMStreamSelect) {
        return GetInterface((IAMStreamSelect *)this, ppv);
    }

    return CSimpleReader::NonDelegatingQueryInterface(riid,ppv);
}


HRESULT CSAMIRead::ParseNewFile()
{
    HRESULT         hr = NOERROR;

    LONGLONG llTotal, llAvailable;

    for (;;) {
	hr = m_pAsyncReader->Length(&llTotal, &llAvailable);
	if (FAILED(hr))
	    return hr;

	if (hr != VFW_S_ESTIMATED)
	    break;	// success....

        // need to dispatch messages if on the graph thread as urlmon
        // won't download o/w. a better fix would be to block SyncRead
        // which does this for us.
        MSG Message;
        while (PeekMessage(&Message, NULL, 0, 0, TRUE))
        {
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
        
	Sleep(10);	// wait until file has finished reading....
    }

    m_cbFile = (DWORD) llTotal;

    m_lpFile = new BYTE[m_cbFile];

    if (!m_lpFile)
	goto readerror;
    
    /* Try to read whole file */
    hr = m_pAsyncReader->SyncRead(0, m_cbFile, m_lpFile);

    if (hr != S_OK)
        goto error;


    hr = m_interp.ParseSAMI((char *) m_lpFile, m_cbFile);

    if (FAILED(hr))
	goto error;

    m_pstream = m_interp.m_streams.GetHead();
    if(!m_pstream) {
        return E_FAIL;
    }
    
    m_pstyle = m_interp.m_styles.GetHead();


    {
	CMediaType mtText;

	mtText.SetType(&MEDIATYPE_Text);
	mtText.SetFormatType(&GUID_NULL);
	mtText.SetVariableSize();
	mtText.SetTemporalCompression(FALSE);
	// !!! anything else?

	SetOutputMediaType(&mtText);
    }
    

    m_sLength = m_interp.m_dwLength + 1;
    
    return hr;

    hr = E_OUTOFMEMORY;
    goto error;

readerror:
    hr = VFW_E_INVALID_FILE_FORMAT;

error:
    return hr;
}


ULONG CSAMIRead::GetMaxSampleSize()
{
    return m_interp.m_cbMaxString + m_interp.m_cbMaxSource +
	    lstrlenA(m_interp.m_paraStyle) * 2 + lstrlenA(m_interp.m_sourceStyle) + 300;  // !!!
}


// !!! rounding
// returns the sample number showing at time t
LONG
CSAMIRead::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * MILLISECONDS) / UNITS);
    return s;
}

CRefTime
CSAMIRead::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, UNITS, MILLISECONDS, MILLISECONDS-1 );
}


HRESULT
CSAMIRead::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != CLSID_SAMIReader)
        return E_INVALIDARG;

    return S_OK;
}


LONG CSAMIRead::StartFrom(LONG sStart)
{
    LONG sLast = 0;

    POSITION pos = m_pstream->m_list.GetHeadPosition();

    while (pos) {
	TEXT_ENTRY *pText = m_pstream->m_list.GetNext(pos);
	if (pText->dwStart > (DWORD) sStart)
	    break;
	sLast = (LONG) pText->dwStart;
    }
    
    return sLast;
}

HRESULT CSAMIRead::FillBuffer(IMediaSample *pSample, DWORD dwStart, DWORD *pdwSamples)
{
    PBYTE pbuf;
    const DWORD lSamples = 1;

    DWORD dwSize = pSample->GetSize();
    
    HRESULT hr = pSample->GetPointer(&pbuf);
    if (FAILED(hr)) {
	DbgLog((LOG_ERROR,1,TEXT("pSample->GetPointer failed!")));
	pSample->Release();
	return E_OUTOFMEMORY;
    }

    // !!! keep locked while we're looking at the current stream
    CAutoLock lck(&m_cStateLock);

    DWORD dwTotalSize = 0;

    POSITION pos;
    TEXT_ENTRY *pText;

    // !!! insert HTML header?  style tags?
#ifdef USE_STYLESHEET
    if (m_interp.m_sourceStyle || m_interp.m_paraStyle || m_pstream->m_streamStyle) {
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				"<STYLE TYPE=\"text/css\"> <!--");

	if (m_interp.m_paraStyle) {
	    dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				" P %hs", m_interp.m_paraStyle);
	}
	if (m_pstream->m_streamStyle) {
	    dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				" .%hs %hs", m_pstream->m_streamTag, m_pstream->m_streamStyle);
	}
	if (m_interp.m_sourceStyle) {
	    dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				" #Source %hs", m_interp.m_sourceStyle);
	}
	
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize, "--> </STYLE> ");

    }
#endif

    // is there a "source" line?
    if (m_pstream->m_sourcelist.GetCount()) {

#ifdef USE_STYLESHEET
	// Insert a paragraph tag to mark this as source material
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				"<P Class=%s ID=Source>", m_pstream->m_streamTag);
#else
	// insert paragraph tag with inline styles....
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				"<P STYLE=\"%hs %hs %hs\">",
				 m_interp.m_paraStyle ? m_interp.m_paraStyle : "",
				 m_pstream->m_streamStyle ? m_pstream->m_streamStyle : "",
				 m_interp.m_sourceStyle ? m_interp.m_sourceStyle : "");
#endif
	// first, find the current 'source' tag
	pos = m_pstream->m_sourcelist.GetHeadPosition();

	pText = NULL;
	while (pos) {
	    TEXT_ENTRY *pNextText = m_pstream->m_sourcelist.GetNext(pos);
	    if (pNextText->dwStart > dwStart)
		break;

	    pText = pNextText;
	}

	if (pText) {
	    ASSERT(pText->cText + dwTotalSize < (int) dwSize);

	    lstrcpynA((LPSTR) pbuf+dwTotalSize, pText->pText, pText->cText+1);

	    dwTotalSize += pText->cText;
	}

	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize, "</P>");
    }


    // !!! insert a paragraph break?
#ifdef USE_STYLESHEET
    dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
			    "<P Class=%s>", m_pstream->m_streamTag);
#else
	// insert paragraph tag with inline styles....
	dwTotalSize += wsprintfA((char *) pbuf+dwTotalSize,
				"<P STYLE=\"%hs %hs %hs\">",
				 m_interp.m_paraStyle ? m_interp.m_paraStyle : "",
				 m_pstream->m_streamStyle ? m_pstream->m_streamStyle : "",
				 m_pstyle && m_pstyle->m_styleStyle ? m_pstyle->m_styleStyle : "");
#endif
    
    // now go back and get body text
    pos = m_pstream->m_list.GetHeadPosition();
    pText = NULL;

    POSITION posReal = pos;
    TEXT_ENTRY *pReal = NULL;
    
    // find the first block of text that's current
    while (pos) {
	TEXT_ENTRY *pNextText = m_pstream->m_list.Get(pos); // peek, don't advance...
	if (pNextText->dwStart > dwStart) {
	    pos = posReal;
	    pText = pReal;
	    break;
	}

	pText = m_pstream->m_list.GetNext(pos);

	if ((pReal == NULL) || (pText->dwStart > pReal->dwStart)) {
	    pReal = pText;
	    posReal = pos;
	}
    }

    DWORD dwThisStart = pText ? pText->dwStart : 0;
    
    if (pText) {
	for (;;) {    
	    ASSERT(pText->cText + dwTotalSize < (int) dwSize);

	    lstrcpynA((LPSTR) pbuf+dwTotalSize, pText->pText, pText->cText+1);

	    dwTotalSize += pText->cText;

	    // if there are other text blocks with the same timestamp, copy them too
	    if (!pos)
		break;
	    
	    pText = m_pstream->m_list.GetNext(pos);
	    if (pText->dwStart > dwThisStart)
		break;
	}
    } else {
	pText = m_pstream->m_list.GetNext(pos);
    }


    // !!! insert HTML footer?
    
    pbuf[dwTotalSize] = 0;
    hr = pSample->SetActualDataLength(dwTotalSize+1);
    ASSERT(SUCCEEDED(hr));

    *pdwSamples = pText ? pText->dwStart - dwThisStart : m_interp.m_dwLength - dwThisStart;

    if (0 == *pdwSamples)
        *pdwSamples = 1;

    // mark as a sync point if it should be....
    pSample->SetSyncPoint(TRUE);  // !!!

    return S_OK;
}


//  Returns total count of streams
STDMETHODIMP CSAMIRead::Count(
    /*[out]*/ DWORD *pcStreams)       // Count of logical streams
{
    CAutoLock lck(&m_cStateLock);

    *pcStreams = m_interp.m_streams.GetCount() + m_interp.m_styles.GetCount();

    return S_OK;
}

extern "C" {
typedef BOOL (*Rfc1766ToLcidA_t)(LCID *, LPCSTR);
}

HRESULT WSTRFromAnsi(WCHAR **pb, LPSTR p, int cb)
{
    if (!p)
	return E_NOTIMPL;
    
    *pb = (WCHAR *) CoTaskMemAlloc((cb + 1) * sizeof(WCHAR));

    if (!*pb)
	return E_OUTOFMEMORY;
    
    int len = MultiByteToWideChar( CP_ACP
				   , 0L
				   , p	
				   , cb
				   , *pb
				   , cb + 1 );

    if (len < cb+1)
	(*pb)[len] = L'\0';
    
    return S_OK;
}

//  Return info for a given stream - S_FALSE if iIndex out of range
//  The first steam in each group is the default
STDMETHODIMP CSAMIRead::Info(
    /*[in]*/ long iIndex,              // 0-based index
    /*[out]*/ AM_MEDIA_TYPE **ppmt,   // Media type - optional
                                      // Use DeleteMediaType to free
    /*[out]*/ DWORD *pdwFlags,        // flags - optional
    /*[out]*/ LCID *plcid,            // Language id
    /*[out]*/ DWORD *pdwGroup,        // Logical group - 0-based index - optional
    /*[out]*/ WCHAR **ppszName,       // Name - optional - free with CoTaskMemFree
                                      // Can return NULL
    /*[out]*/ IUnknown **ppPin,       // Pin if any
    /*[out]*/ IUnknown **ppUnk)       // Stream specific interface
{
    CAutoLock lck(&m_cStateLock);

    /*  Find the stream corresponding to this one that has a pin */
    CBasePin *pPin = GetPin(0);
    ASSERT(pPin != NULL);

    if (iIndex < m_interp.m_streams.GetCount()) {
	CSAMIInterpreter::CStreamInfo *pstream = NULL;

	POSITION pos = m_interp.m_streams.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstream = m_interp.m_streams.GetNext(pos);

	    if (pstream == NULL)
		return S_FALSE;
	}
	if (pdwFlags) {
	    *pdwFlags = pstream == m_pstream ? AMSTREAMSELECTINFO_ENABLED : 0;
	}
	if (ppUnk) {
	    *ppUnk = NULL;
	}
	if (pdwGroup) {
	    *pdwGroup = 0;
	}
	if (ppmt) {
	    CMediaType mtText;

	    mtText.SetType(&MEDIATYPE_Text);
	    mtText.SetSubtype(&GUID_NULL);
	    mtText.SetFormatType(&GUID_NULL);
	    mtText.SetVariableSize();
	    mtText.SetTemporalCompression(FALSE);
	    *ppmt = CreateMediaType(&mtText);
	}
	if (plcid) {
	    *plcid = 0;

	    LPSTR lpLang; int cbLang;
	    if (FindValueInStyle(pstream->m_streamStyle, "lang", lpLang, cbLang)) {
		// !!! load MLANG.DLL, find Rfc1766ToLcidA and call it
		UINT uOldErrorMode = SetErrorMode (SEM_NOOPENFILEERRORBOX);
		HINSTANCE hMLangDLL = LoadLibrary (TEXT("MLANG.DLL"));
		SetErrorMode (uOldErrorMode);

		if (hMLangDLL) {
		    Rfc1766ToLcidA_t pfnRfc1766ToLcidA;

		    pfnRfc1766ToLcidA = (Rfc1766ToLcidA_t)
					GetProcAddress (hMLangDLL, "Rfc1766ToLcidA");

		    if (pfnRfc1766ToLcidA) {
			char *p = new char[cbLang + 1];
			if (p) {
			    memcpy(p, lpLang, cbLang);
			    p[cbLang] = '\0';
			    pfnRfc1766ToLcidA(plcid, p);
			    delete[] p;

			    DbgLog((LOG_TRACE, 2, "Rfc1766ToLcidA(%hs) returned %x", pstream->m_streamTag, *plcid));
			}
		    } else {
			DbgLog((LOG_TRACE, 2, "Couldn't find Rfc1766ToLcidA in MLANG.DLL"));
		    }

		    FreeLibrary(hMLangDLL);
		} else {
		    DbgLog((LOG_TRACE, 2, "Couldn't find MLANG.DLL"));
		}
	    }
	}
	if (ppszName) {
	    *ppszName = NULL;	// !!! get name

	    LPSTR lpName; int cbName;
	    if (FindValueInStyle(pstream->m_streamStyle, "name", lpName, cbName)) {
		WSTRFromAnsi(ppszName, lpName, cbName); 
	    }
	}
    } else {
	CSAMIInterpreter::CStyleInfo *pstyle = NULL;

	iIndex -= m_interp.m_streams.GetCount();
	POSITION pos = m_interp.m_styles.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstyle = m_interp.m_styles.GetNext(pos);

	    if (pstyle == NULL)
		return S_FALSE;
	}
	if (pdwFlags) {
	    *pdwFlags = pstyle == m_pstyle ? AMSTREAMSELECTINFO_ENABLED : 0;
	}
	if (ppUnk) {
	    *ppUnk = NULL;
	}
	if (pdwGroup) {
	    *pdwGroup = 1;
	}
	if (ppmt) {
	    *ppmt = NULL;
	}
	if (plcid) {
	    *plcid = 0;
	}
	if (ppszName) {
	    *ppszName = NULL;	// !!! get name

	    LPSTR lpName; int cbName;
	    if (FindValueInStyle(pstyle->m_styleStyle, "name", lpName, cbName)) {
		WSTRFromAnsi(ppszName, lpName, cbName); 
	    }
	}
    }
    
    if (ppPin) {
        pPin->QueryInterface(IID_IUnknown, (void**)ppPin);
    }
    return S_OK;
}

//  Enable or disable a given stream
STDMETHODIMP CSAMIRead::Enable(
    /*[in]*/  long iIndex,
    /*[in]*/  DWORD dwFlags)
{
    if (!(dwFlags & AMSTREAMSELECTENABLE_ENABLE)) {
        return E_NOTIMPL;
    }

    CAutoLock lck(&m_cStateLock);

    if (iIndex < m_interp.m_streams.GetCount()) {
	/*  Find the stream from the index */
	CSAMIInterpreter::CStreamInfo *pstream = NULL;

	POSITION pos = m_interp.m_streams.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstream = m_interp.m_streams.GetNext(pos);

	    if (pstream == NULL)
		return E_INVALIDARG;
	}

	m_pstream = pstream;
    } else {
	iIndex -= m_interp.m_streams.GetCount();
	
	/*  Find the stream from the index */
	CSAMIInterpreter::CStyleInfo *pstyle = NULL;

	POSITION pos = m_interp.m_styles.GetHeadPosition();
	while (iIndex-- >= 0) {
	    pstyle = m_interp.m_styles.GetNext(pos);

	    if (pstyle == NULL)
		return E_INVALIDARG;
	}

	m_pstyle = pstyle;

    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\sami\samitab.h ===
TABLE_ENTRY("SAMI", TOK_SAMI)
TABLE_ENTRY("Head", TOK_HEAD)
TABLE_ENTRY("Copyright", TOK_COPYRIGHT)
TABLE_ENTRY("Title", TOK_TITLE)
TABLE_ENTRY("SAMIParam", TOK_SAMIPARAM)
TABLE_ENTRY("STYLE", TOK_STYLE)
TABLE_ENTRY("!--", TOK_COMMENT)
TABLE_ENTRY("Resource", TOK_RESOURCE)
TABLE_ENTRY("Body", TOK_BODY)
TABLE_ENTRY("SYNC", TOK_SYNC)
TABLE_ENTRY("P", TOK_PARA)
TABLE_ENTRY("Command", TOK_COMMAND)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\sami\sami.cpp ===
#include <streams.h>

// Idea for how to implement:
// Two classes.

// First one looks at raw text, calls second with "tokens" when it finds them.


// !!! notes
// should I just get rid of the "number" type?
// can I have helpers for copying quoted strings?
// standard logic for copying or not copying strings?
// macro/inline function for keeping lpData/cbData in synch?

// !!! SAMIParam--is stuff in a comment tag, or not?  What do I need to look at?
// !!! end of file handling may be wrong, are we giving a big enough duration?


#pragma warning(disable:4355)

#include "rawparse.h"


struct TEXT_ENTRY {
    DWORD	dwStart;
    char *	pText;
    int		cText;
};

#define TABLE_ENTRY(a,b)	b,
enum SAMI_TOKEN {
#include "samitab.h"
};

#undef TABLE_ENTRY
#define TABLE_ENTRY(a,b)	{ a, b },

STRING_ENTRY stabSAMI[] = {
#include "samitab.h"
};

const int ctabSAMI = sizeof(stabSAMI) / sizeof(stabSAMI[0]);

class CSAMIInterpreter : CTokenInterpreter
{
    CRawParser		m_parser;

    // need to keep track of where we are in the file....

    HRESULT NewToken(CToken &tok);
    BOOL    SpecialTagParsing(int token);

    enum SAMIParseState {
	STATE_INITIAL,
	STATE_FOUND_SAMI,
	STATE_IN_HEAD,
	STATE_AFTER_HEAD,
	STATE_IN_COPYRIGHT,
	STATE_IN_TITLE,
	STATE_IN_STYLE,
	STATE_IN_RESOURCE,
	STATE_IN_BODY,
	STATE_IN_SOURCEID,
	STATE_IN_PARA,
	STATE_IN_SYNC,
	STATE_AFTER_BODY,
	STATE_FINAL
	// !!! more?

    } m_state;

    BOOL	m_fWasInCC;

    DWORD	m_msStart;
    DWORD	m_dwActiveStream;
    BOOL	m_fInSource;

    char *	m_SourceID;
    DWORD	m_SourceIDLen;

public:
    CSAMIInterpreter() : m_parser(this, stabSAMI, ctabSAMI),
	    m_streams(NAME("stream list")), m_sourceStyle(NULL),
	    m_styles(NAME("style list")), 
	    m_paraStyle(NULL) {};

    ~CSAMIInterpreter();

    HRESULT ParseSAMI(char *pData, int cbData);

    // more methods to get # of streams, information about streams
    // and also individual text items

    DWORD	m_cStreams;
    DWORD	m_cResources;

    class CStreamInfo {
	public:
	LPSTR		m_streamTag;

	LPSTR		m_streamStyle;
	
	CGenericList<TEXT_ENTRY> m_list;
	CGenericList<TEXT_ENTRY> m_sourcelist;

	CStreamInfo() : m_streamTag(NULL),
		    m_streamStyle(NULL),
		    m_list(NAME("text list")),
		    m_sourcelist(NAME("source list")){}

	~CStreamInfo();
    };

    CGenericList<CStreamInfo> m_streams;
	
    class CStyleInfo {
	public:
	LPSTR		m_styleTag;

	LPSTR		m_styleStyle;

	~CStyleInfo();
    };

    CGenericList<CStyleInfo> m_styles;
	
    
    CStreamInfo	*m_pActiveStream;
    DWORD	m_cbMaxString;
    DWORD	m_cbMaxSource;
    DWORD       m_msMaxToken;
    DWORD	m_dwLength;

    LPSTR	m_sourceStyle;

    LPSTR	m_paraStyle;
	
    HRESULT AddEntry(CStreamInfo *pInfo, CToken& tok);
};

HRESULT CSAMIInterpreter::ParseSAMI(char *pData, int cbData)
{
    m_state = STATE_INITIAL;

    m_cStreams = 0;
    m_cResources = 0;
    m_dwActiveStream = 0xffff;
    m_fInSource =  FALSE;

    m_cbMaxString = 0;
    m_cbMaxSource = 0;
    m_msMaxToken = -1;

    // !!! does this function do anything else?
    HRESULT hr = m_parser.Parse(pData, cbData);

    if (FAILED(hr))
	return hr;

    if (m_state != STATE_FINAL) {
	DbgLog((LOG_ERROR, 1, "didn't see final </SAMI> tag"));
	return E_INVALIDARG;
    }

    return hr;
}

BOOL CSAMIInterpreter::SpecialTagParsing(int token)
{
    if (token != TOK_COMMENT)
	return FALSE;

    return m_state == STATE_IN_STYLE;
}


HRESULT CSAMIInterpreter::AddEntry(CStreamInfo *pStream, CToken &tok)
{

    TEXT_ENTRY *pEntry = new TEXT_ENTRY;
    if (!pEntry)
	return E_OUTOFMEMORY;

    pEntry->dwStart = m_msStart;
    pEntry->pText = tok.tokString;
    pEntry->cText = tok.cbString;

    if (m_fInSource) {
	if (NULL == pStream->m_sourcelist.AddTail(pEntry))
	    return E_OUTOFMEMORY;
    } else {
	if (NULL == pStream->m_list.AddTail(pEntry))
	    return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CSAMIInterpreter::NewToken(CToken &tok)
{
    HRESULT hr = S_OK;

    switch (m_state) {
	case STATE_INITIAL:
	    if (tok.tokType != TOK_SAMI) {
		DbgLog((LOG_ERROR, 1, "Initial tag not <SAMI>"));
		return E_INVALIDARG;
	    }
	    break;


	case STATE_FINAL:
	    break;
    };

    switch(tok.tokType) {
	case TOK_SAMI:
	    if (!tok.fEnd) {
		if (m_state != STATE_INITIAL) {
		    DbgLog((LOG_ERROR, 1, "<SAMI> tag not at beginning?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_FOUND_SAMI;
	    } else {
		m_state = STATE_FINAL;
	    }
	    break;


	case TOK_HEAD:
	    if (!tok.fEnd) {
		if (m_state != STATE_FOUND_SAMI) {
		    DbgLog((LOG_ERROR, 1, "<HEAD> tag not at beginning?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_IN_HEAD;
	    } else {
		m_state = STATE_AFTER_HEAD;
	    }
	    break;

	case TOK_BODY:
	    if (!tok.fEnd) {
		if (m_state != STATE_AFTER_HEAD) {
		    DbgLog((LOG_ERROR, 1, "<BODY> tag not at expected place?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_IN_BODY;
	    } else {
		m_state = STATE_AFTER_BODY;
	    }
	    break;

#if 0
	case TOK_NUMBER:


	    break;
#endif

	case TOK_STRING:
	    switch (m_state) {
		case STATE_IN_PARA:
		{
		    // !!! might need to concatenate several strings
		    if (m_fInSource) {
                        if (m_msMaxToken != m_msStart)
                        {
			    if (tok.cbString > (int)m_cbMaxSource)
                            {
			        m_cbMaxSource = tok.cbString;
                                m_msMaxToken = m_msStart;
                            } 
                        } else { 
                            m_cbMaxSource += tok.cbString;
                        }
		    } else {
                        if (m_msMaxToken != m_msStart)
                        {
			    if (tok.cbString > (int)m_cbMaxString)
                            {
			        m_cbMaxString = tok.cbString;
                                m_msMaxToken = m_msStart;
                            } 
                        } else { 
                            m_cbMaxString += tok.cbString;
                        }
		    }

		    if (m_pActiveStream)
			hr = AddEntry(m_pActiveStream, tok);
		    else {
			CStreamInfo *pInfo;
			POSITION pos = m_streams.GetHeadPosition();
			while (pInfo = m_streams.GetNext(pos)) {
			    hr = AddEntry(pInfo, tok);

			    if (FAILED(hr))
				break;
			}
		    }

		    m_dwLength = m_msStart;
		}
		    break;

		case STATE_IN_SOURCEID:
		    m_SourceID = tok.tokString;
		    m_SourceIDLen = tok.cbString;
		    break;
		
		case STATE_IN_COPYRIGHT:
		    break;
		
		case STATE_IN_TITLE:
		    DbgLog((LOG_TRACE, 1, "Got title: %s", tok.tokString));
		    break;

		case STATE_IN_STYLE:
		    // !!! really shouldn't be something here....
		    break;

		case STATE_IN_BODY:
		    // !!! ignore strings in body, html headers we don't want?
		    // (or add to html header?)
		    break;
		default:
		    DbgLog((LOG_ERROR, 1, "Got a string in unexpected state #%d", m_state));

		    break;
	    }
	    break;

	case TOK_COPYRIGHT:
	    // handle copyright...
	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Copyright key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_COPYRIGHT;

		// !!! copyright has no end tag???
		m_state = STATE_IN_HEAD; // !!!!
	    } else {
		// check that we've seen the copyright?
		
		if (m_state != STATE_IN_COPYRIGHT) {
		    DbgLog((LOG_ERROR, 1, "/Copyright key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_TITLE:
	    // handle title...
	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Title key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_TITLE;
	    } else {
		// check that we've seen the TITLE?
		
		if (m_state != STATE_IN_TITLE) {
		    DbgLog((LOG_ERROR, 1, "/Title key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_STYLE:
	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Style not in header?"));
		    return E_INVALIDARG;
		}

		if (m_cStreams > 0) {
		    DbgLog((LOG_ERROR, 1, "duplicate STYLE key?"));
		    return E_INVALIDARG;
		}

		// !!! check that there's a TYPE key which says "text/css"?

		m_state = STATE_IN_STYLE;
	    } else {
		// check that we've seen a language?
		
		if (m_state != STATE_IN_STYLE) {
		    DbgLog((LOG_ERROR, 1, "/Style key not at right place?"));
		    return E_INVALIDARG;
		}

		if (m_cStreams == 0) {
		    DbgLog((LOG_ERROR, 1, "no streams defined in Style key?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_RESOURCE:
	    if (tok.cTags != 1)
		return E_INVALIDARG;

	    if (!tok.fEnd) {
		if (m_state != STATE_IN_HEAD) {
		    DbgLog((LOG_ERROR, 1, "Resource key not at right place?"));
		    return E_INVALIDARG;
		}

		DbgLog((LOG_TRACE, 1, "Adding new resource tag %s", tok.tokTags[0].tag));

		m_parser.AddString(tok.tokTags[0].tag, 0, 200 + m_cResources++);

		m_state = STATE_IN_RESOURCE;

		// !!! resource has no end tag???
		m_state = STATE_IN_HEAD; // !!!!
	    } else {
		if (m_state != STATE_IN_RESOURCE) {
		    DbgLog((LOG_ERROR, 1, "/Res key not at right place?"));
		    return E_INVALIDARG;
		}
		m_state = STATE_IN_HEAD;
	    }
	    break;

	case TOK_SAMIPARAM:
	    if (m_state != STATE_IN_HEAD) {
		DbgLog((LOG_ERROR, 1, "CC key not at right place?"));
		return E_INVALIDARG;
	    }

	    // !!! process tags....
	    break;

	case TOK_COMMENT:
	    if (m_state == STATE_IN_STYLE) {
		// tags are the style names....
		for (int i = 0; i < tok.cTags; i++) {
		    if (tok.tokTags[i].tag[0] == '.') {
			DbgLog((LOG_TRACE, 1, "Found new stream named %s '%s'",
				&tok.tokTags[i].tag[1],
			        tok.tokTags[i].value));
			
			// !!!
			CStreamInfo *pStream = new CStreamInfo();
			if (!pStream)
			    return E_OUTOFMEMORY;

			pStream->m_streamTag = new char[lstrlenA(&tok.tokTags[i].tag[1])+1];
			if (!pStream->m_streamTag)
			    return E_OUTOFMEMORY;

			lstrcpyA(pStream->m_streamTag, &tok.tokTags[i].tag[1]);

			pStream->m_streamStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			if (!pStream->m_streamStyle)
			    return E_OUTOFMEMORY;

			lstrcpyA(pStream->m_streamStyle, tok.tokTags[i].value);

			if (NULL == m_streams.AddTail(pStream))
			    return E_OUTOFMEMORY;

			++m_cStreams;
		    } else if (tok.tokTags[i].tag[0] == '#') {
			DbgLog((LOG_TRACE, 1, "Found style tag named %s '%s'",
				&tok.tokTags[i].tag[1],
			        tok.tokTags[i].value));

			// !!! should we check that it says "source"?
			if (lstrcmpiA("Source", &tok.tokTags[i].tag[1]) == 0) {
			    m_sourceStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			    if (!m_sourceStyle)
				return E_OUTOFMEMORY;

			    lstrcpyA(m_sourceStyle, tok.tokTags[i].value);
			} else {
			    CStyleInfo *pStyle = new CStyleInfo;
			    if (!pStyle)
				return E_OUTOFMEMORY;

			    // copy style tag without the #
			    pStyle->m_styleTag = new char[lstrlenA(tok.tokTags[i].tag)];
			    if (!pStyle->m_styleTag)
				return E_OUTOFMEMORY;

			    lstrcpyA(pStyle->m_styleTag, tok.tokTags[i].tag+1);

			    pStyle->m_styleStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			    if (!pStyle->m_styleStyle)
				return E_OUTOFMEMORY;

			    lstrcpyA(pStyle->m_styleStyle, tok.tokTags[i].value);

			    m_styles.AddTail(pStyle);
			}
		    } else {
			// what's this?
			DbgLog((LOG_TRACE, 1, "Found extra style tag: %s '%s'",
				tok.tokTags[i].tag,
			        tok.tokTags[i].value));

			if (lstrcmpiA("P", tok.tokTags[i].tag) == 0) {
			    m_paraStyle = new char[lstrlenA(tok.tokTags[i].value)+1];
			    if (!m_paraStyle)
				return E_OUTOFMEMORY;

			    lstrcpyA(m_paraStyle, tok.tokTags[i].value);
			} else {
			    // !!!
			}
		    }
		}
	    } else {
		// !!! random other comment???
	    }
	    break;

	case TOK_PARA:
	    if (!tok.fEnd) {
		if ((m_state != STATE_IN_SYNC) && (m_state != STATE_IN_PARA)) {
		    DbgLog((LOG_ERROR, 1, "P key not at right place?"));
		    return E_INVALIDARG;
		}

		if (m_cStreams == 0) {
		    DbgLog((LOG_ERROR, 1, "CC data with no streams defined?"));

		    // !!! we could handle this case specially, and default one stream....
		
		    return E_INVALIDARG;
		}

		int tagClass = -1;
		BOOL fSource = FALSE;
		if (tok.cTags == 0) {
		    DbgLog((LOG_TRACE, 1, "P token with no tags???"));
		
		}

		for (int i = 0; i < tok.cTags; i++) {
		    if (lstrcmpiA("class", tok.tokTags[i].tag) == 0) {
			tagClass = i;
		    } else if (lstrcmpiA("ID", tok.tokTags[i].tag) == 0) {
			if (lstrcmpiA("Source", tok.tokTags[i].value) != 0) {
			    DbgLog((LOG_TRACE, 1, "P token with odd ID '%s'?",
				    tok.tokTags[i].value));
			    continue;
			}
			fSource = TRUE;
		    } else {
			DbgLog((LOG_TRACE, 1, "P token with odd tag '%s'?",
				tok.tokTags[i].tag));
		    }
		}

		CStreamInfo *pInfo;
		DWORD dwActiveStream = 0;
		m_fInSource = fSource;
		BOOL	fFound = FALSE;

		if (tagClass == -1) {
		    DbgLog((LOG_TRACE, 1, "P token with no class?"));
		} else {
		    POSITION pos = m_streams.GetHeadPosition();
		    while (pInfo = m_streams.GetNext(pos)) {
			if (lstrcmpA(pInfo->m_streamTag, tok.tokTags[tagClass].value) == 0) {
			    fFound = TRUE;
			    break;
			}
			++dwActiveStream;
		    }

		    if (!fFound) {
			DbgLog((LOG_TRACE, 1, "Didn't find stream '%s'",
				tok.tokTags[tagClass].value));
		    }
		}
		
		if (fFound) {
		    m_pActiveStream = pInfo;

		    m_dwActiveStream = dwActiveStream;
		} else {
		    m_pActiveStream = NULL;

		    m_dwActiveStream = (DWORD) -1;
		}
		
		m_state = STATE_IN_PARA;
	    } else {
		if (m_state != STATE_IN_PARA) {
		    DbgLog((LOG_ERROR, 1, "/P key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_SYNC;
	    }


	    break;

	case TOK_SYNC:
	    if (!tok.fEnd) {
		// get the start tag....
		BOOL fStart = FALSE;

		for (int i = 0; i < tok.cTags; i++) {
		    if (lstrcmpiA("start", tok.tokTags[i].tag) == 0) {
			fStart = TRUE;
			m_msStart = atoiA(tok.tokTags[i].value);
		    }
		}

		if (!fStart) {
		    DbgLog((LOG_ERROR, 1, "CC key missing start?"));
		    return E_INVALIDARG;
		}
		
		DbgLog((LOG_TRACE, 2, "Found Sync key: start = %d", m_msStart));

		m_state = STATE_IN_SYNC;
	    } else {
		if ((m_state != STATE_IN_SYNC) && (m_state != STATE_IN_PARA)) {
		    DbgLog((LOG_ERROR, 1, "/sync key not at right place?"));
		    return E_INVALIDARG;
		}

		m_state = STATE_IN_BODY;
	    }
	    break;

	default:
	    if (tok.tokType >= 100 && tok.tokType < 100 + (int)m_cStreams) {
		DbgLog((LOG_TRACE, 4, "Switch to stream #%d", tok.tokType - 100));

		m_dwActiveStream = tok.tokType - 100;
		
	    } else if (tok.tokType >= 200 && tok.tokType < 200 + (int)m_cStreams) {
		DbgLog((LOG_TRACE, 4, "Switch to resource #%d", tok.tokType - 200));
	    } else {
		DbgLog((LOG_ERROR, 0, "Unexpected token %d", tok.tokType));
// !!!		ASSERT(0);
	    }
	    break;
    };





    return hr;
}

CSAMIInterpreter::~CSAMIInterpreter()
{
    CStreamInfo *pInfo;
    POSITION pos = m_streams.GetHeadPosition();
    while (pInfo = m_streams.GetNext(pos)) {
	delete pInfo;
    }

    CStyleInfo *pStyle;
    pos = m_styles.GetHeadPosition();
    while (pStyle = m_styles.GetNext(pos)) {
	delete pStyle;
    }

    delete [] m_paraStyle;
    delete [] m_sourceStyle;
}

CSAMIInterpreter::CStreamInfo::~CStreamInfo()
{
    POSITION pos = m_list.GetHeadPosition();

    while (pos) {
	TEXT_ENTRY *pEntry = m_list.GetNext(pos);

	delete pEntry;
    }

    pos = m_sourcelist.GetHeadPosition();

    while (pos) {
	TEXT_ENTRY *pEntry = m_sourcelist.GetNext(pos);

	delete pEntry;
    }

    delete[] m_streamTag;
    delete[] m_streamStyle;
}

CSAMIInterpreter::CStyleInfo::~CStyleInfo()
{
    delete[] m_styleTag;
    delete[] m_styleStyle;
}



BOOL FindValueInStyle(LPSTR lpStyle, LPSTR lpTag, LPSTR& lpOut, int &cbOut)
{
    char achThisTag[100];
    int	 cbThisTag = 0;

    enum _findstate { TAG, AFTERTAG, VALUE, QUOTEDVALUE, AFTERVALUE };

    _findstate state = AFTERVALUE;
    char c;
    while (c = *lpStyle++) {

	switch (state) {
	    case TAG:
		if (c == ':') {
		    achThisTag[cbThisTag] = '\0';
		    state = AFTERTAG;
		} else if (cbThisTag < 99)
		    achThisTag[cbThisTag++] = c;
		break;

	    case AFTERTAG:
		if (c == '"') {
		    lpOut = lpStyle;
		    cbOut = 0;
		    state = QUOTEDVALUE;
		} else if (c != ' ' && c != '\t' && c != '\r' && c != '\n') {
		    state = VALUE;
		    lpOut = lpStyle - 1;
		    cbOut = 1;
		}
		
		break;

	    case VALUE:
		if (c == ';') {
		    if (lstrcmpiA(achThisTag, lpTag) == 0)
			return TRUE;
		    
		    state = AFTERVALUE;
		} else
		    cbOut++;
		    
		break;

	    case QUOTEDVALUE:
		if (c == '"') {
		    if (lstrcmpiA(achThisTag, lpTag) == 0)
			return TRUE;
		    
		    state = AFTERVALUE;
		} else
		    cbOut++;
		break;

	    case AFTERVALUE:
		if (c != ' ' && c != '\t' && c != '\r' && c != '\n') {
		    cbThisTag = 1;
		    achThisTag[0] = c;
		    state = TAG;
		}
		break;
	}

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\textrend\textrend.cpp ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#ifdef FILTER_DLL
#include <initguid.h>
#endif

#pragma warning(disable:4355)

#include "textrend.h"

// Setup data

const AMOVIESETUP_MEDIATYPE sudTRPinTypes[] =
{
    { &MEDIATYPE_ScriptCommand, &MEDIASUBTYPE_NULL },
    { &MEDIATYPE_Text, &MEDIASUBTYPE_NULL }
};

const AMOVIESETUP_PIN sudTRPin =
{
    L"Input",                     // The Pins name
    TRUE,                         // Is rendered
    FALSE,                        // Is an output pin
    FALSE,                        // Allowed none
    FALSE,                        // Allowed many
    &CLSID_NULL,                  // Connects to filter
    NULL,                         // Connects to pin
    NUMELMS(sudTRPinTypes),       // Number of types
    sudTRPinTypes                 // Pin details
};

const AMOVIESETUP_FILTER sudTextRend =
{
    &CLSID_TextThing,            // Filter CLSID
    L"Internal Script Command Renderer",  // String name
    MERIT_PREFERRED + 1,          // Filter merit higher than the sample text renderer
    1,                            // Number of pins
    &sudTRPin                     // Pin details
};

#ifdef FILTER_DLL

CFactoryTemplate g_Templates[] = {
    { L""
    , &CLSID_TextThing
    , CTextThing::CreateInstance
    , NULL
    , NULL } // &sudRASource
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif



//
CTextThing::CTextThing(LPUNKNOWN pUnk,HRESULT *phr) :
    CBaseRenderer(CLSID_TextThing, NAME("TextOut Filter"), pUnk, phr),
    m_pfn(NULL),
    m_pContext(NULL)
{
} // (Constructor)


//
// Destructor
//
CTextThing::~CTextThing()
{
}


//
// CreateInstance
//
// This goes in the factory template table to create new instances
//
CUnknown * WINAPI CTextThing::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    CTextThing *pTextOutFilter = new CTextThing(pUnk,phr);
    if (pTextOutFilter == NULL) {
        return NULL;
    }
    return (CBaseMediaFilter *) pTextOutFilter;

} // CreateInstance


//
// NonDelegatingQueryInterface
//
// Overriden to say what interfaces we support and where
//
STDMETHODIMP
CTextThing::NonDelegatingQueryInterface(REFIID riid,void **ppv)
{
    CheckPointer(ppv,E_POINTER);

    if (riid == IID_ITextThing) {
        return GetInterface((ITextThing *)this, ppv);
    }
    return CBaseRenderer::NonDelegatingQueryInterface(riid,ppv);

} // NonDelegatingQueryInterface


//
// CheckMediaType
//
// Check that we can support a given proposed type
//
HRESULT CTextThing::CheckMediaType(const CMediaType *pmt)
{
    // Accept text or "script commands"

    if (pmt->majortype != MEDIATYPE_ScriptCommand && pmt->majortype != MEDIATYPE_Text) {
        return E_INVALIDARG;
    }

    // !!! check other things about the format?
    
    return NOERROR;

} // CheckMediaType

//
// SetMediaType
//
// Called when the media type is really chosen
//
HRESULT CTextThing::SetMediaType(const CMediaType *pmt)
{
    // Accept text or "script commands"

    if (pmt->majortype == MEDIATYPE_Text) {
        m_fOldTextFormat = TRUE;
    } else {
        // !!! check if it really is "script commands"?
        m_fOldTextFormat = FALSE;
    }


    return NOERROR;

} // CheckMediaType


//
// DoRenderSample
//
// This is called when a sample is ready for rendering
//
HRESULT CTextThing::DoRenderSample(IMediaSample *pMediaSample)
{
    ASSERT(pMediaSample);
    DrawText(pMediaSample);
    return NOERROR;

} // DoRenderSample


//
// OnReceiveFirstSample
//
// Display an image if not streaming
//
void CTextThing::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
    // !!! anything to do?
    if(IsStreaming() == FALSE)
    {
        ASSERT(pMediaSample);
        DrawText(pMediaSample);
    }
} // OnReceiveFirstSample


//
// DrawText
//
// This is called with an IMediaSample interface on the image to be drawn. We
// are called from two separate code paths. The first is when we're signalled
// that an image has become due for rendering, the second is when we need to
// refresh a static window image. NOTE it is safe to check the type of buffer
// allocator as to change it we must be inactive, which by definition means
// we cannot have any samples available to render so we cannot be here
//
void CTextThing::DrawText(IMediaSample *pMediaSample)
{
    BYTE *pText;        // Pointer to image data

    pMediaSample->GetPointer(&pText);
    ASSERT(pText != NULL);

    // Ignore zero length samples

    LONG lActual = pMediaSample->GetActualDataLength();
    if (lActual == 0) {
        // !!! or draw blank?
        return;
    }

    // Remove trailing NULL from the text data

    // !!! do something!!!

    if (m_pfn) {
        ASSERT(0);      // remove this case!
        
        (m_pfn)(m_pContext, (char *) pText);
    } else {
        if (m_pSink) {

            if(m_fOldTextFormat)
            {
                ULONG cNulls = 0;
                for(int i = 0; i < lActual && cNulls < 1; i++)
                {
                    if(pText[i] == 0)
                    {
                        cNulls++;
                    }
                }
            


                if (cNulls >= 1)
                {
                    DWORD dwSize = MultiByteToWideChar(CP_ACP, 0L, (char *) pText, -1, 0, 0);

                    BSTR bstr = SysAllocStringLen(NULL, dwSize);

                    if (bstr) {
                        MultiByteToWideChar(CP_ACP, 0L, (char *) pText, -1, bstr, dwSize+1);

                        BSTR bstrType = SysAllocString(L"Text");

                        if (bstrType) {
                            if (FAILED(NotifyEvent(EC_OLE_EVENT, (LONG_PTR) bstrType, (LONG_PTR) bstr))) {
                                DbgLog(( LOG_ERROR, 5, TEXT("WARNING in CTextThing::DrawText(): CBaseFilter::NotifyEvent() failed.") ));
                            }
                        } else {
                            SysFreeString(bstr);
                        }
                    
                    }
                }
                else
                {
                    // corrupt
                }
            }
            else
            {
                WCHAR *pw = (WCHAR *) pText;
                ULONG cNulls = 0;
                for(int i = 0; i < lActual / 2 && cNulls < 2; i++)
                {
                    if(pw[i] == 0)
                    {
                        cNulls++;
                    }
                }
            

                if(cNulls >= 2) {
                    // buffer is two unicode strings, with a NULL in between....

                    BSTR bstrType = SysAllocString(pw);

                    if (bstrType) {
                        BSTR bstr = SysAllocString(pw + lstrlenW(pw) + 1);
                        if (bstr) {
                            if (FAILED(NotifyEvent(EC_OLE_EVENT, (LONG_PTR) bstrType, (LONG_PTR) bstr))) {
                                DbgLog(( LOG_ERROR, 5, TEXT("WARNING in CTextThing::DrawText(): CBaseFilter::NotifyEvent() failed.") ));
                            }
                        } else {
                            SysFreeString(bstrType);
                        }
                    }
                } else {
                    // corrupt
                }
            }
        }
    }
} // DrawText


// !!!! get rid of this!
HRESULT CTextThing::SetEventTarget(void * pContext, TEXTEVENTFN fn)
{

    m_pfn = fn;
    m_pContext = pContext;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\sami\test\samitest.cpp ===
#include <streams.h>
#include "..\sami.cpp"
#include <stdio.h>

int __cdecl main(int argc, char *argv[])
{
    WCHAR wszFile[256];

    int i = 1;
    if (argc < 2) {
        printf("No file specified\n");
        return -1;
    }

    while (argv[i][0] == '-' || argv[i][0] == '/') {
	// options

	i++;
    }
    
    printf("Using file %s\n", argv[i]);

    // open the file, unbuffered if not network
    HANDLE hFile = CreateFile(argv[i],
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
			       FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        DWORD dwErr = GetLastError();
        printf("Failed to open file - code %d\n", dwErr);
	return 0;
    }

    DWORD dwSize = GetFileSize(hFile, NULL);

    char *pFile = new char[dwSize];

    ReadFile(hFile, (void *) pFile, dwSize, &dwSize, NULL);

    CSAMIInterpreter sami;

    sami.ParseSAMI(pFile, dwSize);

    printf("%d streams...\r\n", sami.m_streams.GetCount());
    POSITION pos = sami.m_streams.GetHeadPosition();

    while (pos) {
	CSAMIInterpreter::CStreamInfo *pStream = sami.m_streams.GetNext(pos);
	printf("   Tag: %s     %d entries  (%d source tags)\r\n",
	       pStream->m_streamTag,
	       pStream->m_list.GetCount(),
	       pStream->m_sourcelist.GetCount());

	POSITION pos2 = pStream->m_list.GetHeadPosition();

	while (pos2) {
	    TEXT_ENTRY *pEntry = pStream->m_list.GetNext(pos2);

	    printf("      Time: %06d   '%.*s'\r\n",
		   pEntry->dwStart, pEntry->cText, pEntry->pText);
	}

	pos2 = pStream->m_sourcelist.GetHeadPosition();

	while (pos2) {
	    TEXT_ENTRY *pEntry = pStream->m_sourcelist.GetNext(pos2);

	    printf("     STime: %06d   '%.*s'\r\n",
		   pEntry->dwStart, pEntry->cText, pEntry->pText);
	}

    }
    
    delete[] pFile;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\text\textrend\textrend.h ===
// Copyright (c) 1997  Microsoft Corporation.  All Rights Reserved.
DEFINE_GUID(IID_ITextThing,
0x48025244, 0x2d39, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66);


typedef HRESULT (* TEXTEVENTFN)(void *, LPSTR); 

interface ITextThing : IUnknown
{
    virtual HRESULT SetEventTarget(void * pContext, TEXTEVENTFN fn) = 0;
};


DEFINE_GUID(CLSID_TextThing,
0x48025243, 0x2d39, 0x11ce, 0x87, 0x5d, 0x0, 0x60, 0x8c, 0xb7, 0x80, 0x66);

#ifdef __STREAMS__

extern const AMOVIESETUP_FILTER sudTextRend;

class CTextThing : public CBaseRenderer, public ITextThing
{
public:

    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    CTextThing(LPUNKNOWN pUnk,HRESULT *phr);
    ~CTextThing();

    DECLARE_IUNKNOWN
	    
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT DoRenderSample(IMediaSample *pMediaSample);
    void OnReceiveFirstSample(IMediaSample *pMediaSample);
    void DrawText(IMediaSample *pMediaSample);

    HRESULT SetEventTarget(void * pContext, TEXTEVENTFN fn);
    void *m_pContext;
    TEXTEVENTFN m_pfn;

    BOOL m_fOldTextFormat;
}; // CTextThing


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\acmwrap\acmwrap.h ===
//
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//
//  Wrapper for ACM
//
//   10/17/95 - mikegi, created
//

extern const AMOVIESETUP_FILTER sudAcmWrap;

class CACMWrapper : public CTransformFilter     DYNLINKACM,
                    public IPersistPropertyBag, public CPersistStream
 {
  public:
    CACMWrapper(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CACMWrapper();

    DECLARE_IUNKNOWN

    CBasePin *GetPin(int n);	// overridden to make special output pin
    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut);
    HRESULT Receive(IMediaSample *pInSample);
    HRESULT EndOfStream();
    HRESULT SendExtraStuff();
    HRESULT ProcessSample(BYTE *pbSrc, LONG cbSample, IMediaSample *pOut,
                          LONG *pcbUsed, LONG* pcbDstUsed, BOOL fBlockAlign);

    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn);

    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn, const CMediaType* mtOut);

    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pProperties);

    // optional overrides - we want to know when streaming starts and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();
    HRESULT EndFlush();

    HRESULT BreakConnect(PIN_DIRECTION pindir);

    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);
    HRESULT InitMediaTypes();	// helper function
    HRESULT MakePCMMT(int freq);// helper function

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // overridden to do some pretty fancy reconnecting footwork
    HRESULT SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt);

    // IPersistRegistryKey
   // IPersistPropertyBag methods
   STDMETHOD(InitNew)(THIS);
   STDMETHOD(Load)(THIS_ LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
   STDMETHOD(Save)(THIS_ LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                   BOOL fSaveAllProperties);

    STDMETHODIMP GetClassID(CLSID *pClsid);

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

  private:
    HACMSTREAM m_hacmStream;
    BOOL       m_bStreaming;
    REFERENCE_TIME m_tStartFake;
    DWORD      m_nAvgBytesPerSec;
    LPWAVEFORMATEX m_lpwfxOutput;
    int 	   m_cbwfxOutput;
    LPBYTE m_lpExtra;	// samples we couldn't compress last time Receive called
    int m_cbExtra;	// size of lpExtra
    REFERENCE_TIME m_rtExtra;	// time stamp of extra stuff
	
    CCritSec m_csReceive; 	// for Receive

	TCHAR *m_rgFormatMap;	 // acm codec format mapper strings
	TCHAR *m_pFormatMapPos;
	WORD 	m_wCachedTryFormat;
	WORD	m_wCachedSourceFormat;
	WORD	m_wCachedTargetFormat;
	WORD 	m_wSourceFormat;
	WORD 	m_wTargetFormat;

	DWORD 	ACMCodecMapperOpen(WORD wFormatTag);
	void 	ACMCodecMapperClose();
	WORD 	ACMCodecMapperQuery();

        MMRESULT CallacmStreamOpen(
                                   LPHACMSTREAM            phas,       // pointer to stream handle
                                   HACMDRIVER              had,        // optional driver handle
                                   LPWAVEFORMATEX          pwfxSrc,    // source format to convert
                                   LPWAVEFORMATEX          pwfxDst,    // required destination format
                                   LPWAVEFILTER            pwfltr,     // optional filter
                                   DWORD_PTR               dwCallback, // callback
                                   DWORD_PTR               dwInstance, // callback instance data
                                   DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
                                  );

        
  public:
    // !!! ack - public so enum callback can see them!

    WORD m_wFormatTag;		// only produce outputs with this format tag

    #define MAXTYPES 200
    LPWAVEFORMATEX m_lpwfxArray[MAXTYPES];	// all the things we return
    int m_cArray;				// in GetMediaType

  friend class CACMOutputPin;
 };


class CACMPosPassThru : public CPosPassThru
{
public:

    CACMPosPassThru(const TCHAR *, LPUNKNOWN, HRESULT*, IPin *);
    DECLARE_IUNKNOWN

    // IMediaSeeking methods
    STDMETHODIMP SetTimeFormat(const GUID * pFormat);
    STDMETHODIMP IsFormatSupported( const GUID * pFormat);
    STDMETHODIMP QueryPreferredFormat( GUID *pFormat);
    STDMETHODIMP ConvertTimeFormat(LONGLONG *pTarget, const GUID *pTargetFormat, LONGLONG Source, const GUID *pSourceFormat);
};


// We need a new class to support IAMStreamConfig
//
class CACMOutputPin : public CTransformOutputPin, IAMStreamConfig
{

public:

    CACMOutputPin(
        TCHAR *pObjectName,
        CACMWrapper *pFilter,
        HRESULT * phr,
        LPCWSTR pName);

    virtual ~CACMOutputPin();

    DECLARE_IUNKNOWN

    // IAMStreamConfig stuff
    STDMETHODIMP SetFormat(AM_MEDIA_TYPE *pmt);
    STDMETHODIMP GetFormat(AM_MEDIA_TYPE **ppmt);
    STDMETHODIMP GetNumberOfCapabilities(int *piCount, int *piSize);
    STDMETHODIMP GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType);

private:
    CACMWrapper *m_pFilter;

    CACMPosPassThru *m_pPosition;

    // for GetStreamCaps... how many different format tags can we do?
    #define MAXFORMATTAGS 100
    int m_awFormatTag[MAXFORMATTAGS];
    int m_cFormatTags;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\amsrc\amsrc.h ===
//
// Copyright (c) Microsoft Corporation 1994-1996. All Rights Reserved
//
//
//  Wrapper for AudioMan objects
//
//   3/28/96 -- davidmay
//


// {E023E320-705E-11cf-BBEE-00AA00B944D8}
DEFINE_GUID(CLSID_AudioManSource,
0xe023e320, 0x705e, 0x11cf, 0xbb, 0xee, 0x0, 0xaa, 0x0, 0xb9, 0x44, 0xd8);


// {E023E321-705E-11cf-BBEE-00AA00B944D8}
DEFINE_GUID(CLSID_AudioManFilter,
0xe023e321, 0x705e, 0x11cf, 0xbb, 0xee, 0x0, 0xaa, 0x0, 0xb9, 0x44, 0xd8);


class CAMSource;


// implementation of IMediaPosition
class CAMSourcePosition : public CSourcePosition
{
protected:
    CAMSource *m_pFilter;
    HRESULT ChangeStart();
    HRESULT ChangeStop();
    HRESULT ChangeRate();
public:
    CAMSourcePosition(TCHAR*, CAMSource*, HRESULT*);
    double Rate() {
	return m_Rate;
    };
    CRefTime Start() {
	return m_Start;
    };
    CRefTime Stop() {
	return m_Stop;
    };
};

// ==================================================
// Implements the output pin
// ==================================================

class CAMSourcePin : public CBaseOutputPin
{
protected:
    CAMSource *m_pFilter;

public:

    CAMSourcePin(
        TCHAR *pObjectName,
        CAMSource *pAMSource,
        HRESULT * phr,
        LPCWSTR pName);

    ~CAMSourcePin();

    // override to expose IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    CAMSourcePosition *m_pPosition;

    // --- CBaseOutputPin ------------

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtOut);

    // set the connection media type
    HRESULT SetMediaType(const CMediaType *pmt);

    // called from CBaseOutputPin during connection to ask for
    // the count and size of buffers we need.
    HRESULT DecideBufferSize(
                IMemAllocator * pAlloc,
                ALLOCATOR_PROPERTIES *pProp);

    // returns the preferred formats for a pin
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // inherited from IQualityControl via CBasePin
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };
};


class CAMSource : public CBaseFilter, private CAMThread
{
public:
    CAMSource(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAMSource();

    DECLARE_IUNKNOWN

    virtual int GetPinCount();
    virtual CBasePin * GetPin(int n);

    // override state changes to allow derived transform filter
    // to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
// implementation details
protected:

    BOOL m_bEOSDelivered;              // have we sent EndOfStream

    // critical section protecting filter state.

    CCritSec m_csFilter;

    // these hold our input and output pins

    friend class CAMSourcePin;
    friend class CAMSourcePosition;
    CAMSourcePin *m_pOutput;

    // optional overrides - we want to know when streaming starts and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // thread commands
    enum Command {CMD_INIT, CMD_RUN, CMD_STOP, CMD_EXIT};
    HRESULT InitThread(void) { return CallWorker(CMD_INIT); }
    HRESULT ExitThread(void) { return CallWorker(CMD_EXIT); }
    HRESULT RunThread(void) { return CallWorker(CMD_RUN); }
    HRESULT StopThread(void) { return CallWorker(CMD_STOP); }

protected:
    Command GetRequest(void) { return (Command) CAMThread::GetRequest(); }
    BOOL    CheckRequest(Command *pCom) { return CAMThread::CheckRequest( (DWORD *) pCom); }

    HRESULT EndOfStream(void);

    HRESULT BeginFlush(void);

    HRESULT EndFlush(void);

    HRESULT DoBufferProcessingLoop();
    HRESULT FillBuffer(IMediaSample *pSample);

    DWORD ThreadProc(void);  		// the thread function
private:
    BOOL            m_bStreaming;
    DWORD           m_dwPosition;
    DWORD	    m_dwEndingPosition;

    IAMSound	   *m_AMSound;
    AUXDATA	    m_AMAuxData;
};



//
//
// TODO: am wrapper that isn't just for sources, but has an input pin
//
//




class AMFilter;

class CAMInputPin : public CBaseInputPin
{
    friend class CAMFilter;

    CAMFilter *m_pFilter;

public:
    CAMInputPin(
        TCHAR *pObjectName,
        CAMFilter *pAMFilter,
        HRESULT * phr,
        LPCWSTR pName);

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtIn);

    // set the connection media type
    HRESULT SetMediaType(const CMediaType* mt);

    // --- IMemInputPin -----

    // here's the next block of data from the stream.
    // AddRef it yourself if you need to hold it beyond the end
    // of this call.
    STDMETHODIMP Receive(IMediaSample * pSample);

    // provide EndOfStream
    STDMETHODIMP EndOfStream(void);

    STDMETHODIMP BeginFlush(void);

    STDMETHODIMP EndFlush(void);

    STDMETHODIMP NewSegment(
                        REFERENCE_TIME tStart,
                        REFERENCE_TIME tStop,
                        double dRate);

    // Pass a Quality notification on to the appropriate sink
    HRESULT PassNotify(Quality q);

    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };
};


// ==================================================
// Implements the output pin
// ==================================================

class CAMOutputPin : public CBaseOutputPin
{
protected:
    CAMFilter *m_pFilter;

public:

    CAMOutputPin(
        TCHAR *pObjectName,
        CAMFilter *pAMFilter,
        HRESULT * phr,
        LPCWSTR pName);

    ~CAMOutputPin();

    // override to expose IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    // implement IMediaPosition by passing upstream
    CPosPassThru * m_pPosition;

    // --- CBaseOutputPin ------------

    // check that we can support this output type
    HRESULT CheckMediaType(const CMediaType* mtOut);

    // set the connection media type
    HRESULT SetMediaType(const CMediaType *pmt);

    // called from CBaseOutputPin during connection to ask for
    // the count and size of buffers we need.
    HRESULT DecideBufferSize(
                IMemAllocator * pAlloc,
                ALLOCATOR_PROPERTIES *pProp);

    // returns the preferred formats for a pin
    HRESULT GetMediaType(int iPosition,CMediaType *pMediaType);

    // inherited from IQualityControl via CBasePin
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);
    // Media type
public:
    CMediaType& CurrentMediaType() { return m_mt; };
};



class CAMFilter : public CBaseFilter, private CAMThread
{
public:
    CAMFilter(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CAMFilter();

    DECLARE_IUNKNOWN

    virtual int GetPinCount();
    virtual CBasePin * GetPin(int n);

    // override state changes to allow derived transform filter
    // to control streaming start/stop
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();

    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *);
// implementation details
protected:

    BOOL m_bEOSDelivered;              // have we sent EndOfStream
    BOOL m_bEOSReceived;               // have we sent EndOfStream

    // critical section protecting filter state.

    CCritSec m_csFilter;

    // critical section stopping state changes (ie Stop) while we're
    // processing a sample.
    //
    // This critical section is held when processing
    // events that occur on the receive thread - Receive() and EndOfStream().
    //
    // If you want to hold both m_csReceive and m_csFilter then grab
    // m_csFilter FIRST - like CTransformFilter::Stop() does.

    CCritSec m_csReceive;

    // these hold our input and output pins

    friend class CAMInputPin;
    friend class CAMOutputPin;
    CAMInputPin *m_pInput;
    CAMOutputPin *m_pOutput;

    HRESULT Receive(IMediaSample * pSample);

    HRESULT ProcessSample( BYTE *pbSrc, LONG cbSample, IMediaSample *pOut, LONG *pcbUsed );

    // optional overrides - we want to know when streaming starts and stops
    HRESULT StartStreaming();
    HRESULT StopStreaming();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv);

    // thread commands
    enum Command {CMD_INIT, CMD_RUN, CMD_STOP, CMD_EXIT};
    HRESULT InitThread(void) { return CallWorker(CMD_INIT); }
    HRESULT ExitThread(void) { return CallWorker(CMD_EXIT); }
    HRESULT RunThread(void) { return CallWorker(CMD_RUN); }
    HRESULT StopThread(void) { return CallWorker(CMD_STOP); }

    // Is the filter currently active?
    BOOL MyIsActive(void) {
                          return (   (m_State == State_Paused)
                                  || (m_State == State_Running)
                                 );
                        }
protected:
    Command GetRequest(void) { return (Command) CAMThread::GetRequest(); }
    BOOL    CheckRequest(Command *pCom) { return CAMThread::CheckRequest( (DWORD *) pCom); }

    HRESULT EndOfStream(void);

    HRESULT BeginFlush(void);

    HRESULT EndFlush(void);

    HRESULT SendBuffer(LPMIDIHDR pmh);
    HRESULT DoBufferProcessingLoop();
    HRESULT FillBuffer(IMediaSample *pSample);

    void FigureClockRate(DWORD dwDivision);

    DWORD ThreadProc(void);  		// the thread function
private:
    BOOL            m_bStreaming;
    DWORD           m_dwPosition;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\amsrc\amsrc.cpp ===
// Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
// AudioMan Quartz wrapper, avidMay, March 1996
//
//
//

#include <streams.h>

#include <initguid.h>
#include "audioman.h"
#include "amflts.h"
#include "amsrc.h"

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

// List of class IDs and creator functions for class factory

CFactoryTemplate g_Templates[] =
  {
//   { L"", &CLSID_AudioManSource, CAMSource::CreateInstance }
       { &CLSID_AudioManSource, CAMSource::CreateInstance }
//   { L"", &CLSID_AudioManFilter, CAMFilter::CreateInstance }
       { &CLSID_AudioManFilter, CAMFilter::CreateInstance }
  };

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//
// CreateInstance()
//
//

CUnknown *CAMSource::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
     return new CAMSource(NAME("AudioMan Wrapper filter"), pUnk, phr);
}


//*****************************************************************************
//
// NonDelegatingQueryInterface()
//
//

STDMETHODIMP CAMSource::NonDelegatingQueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;

    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


//*****************************************************************************
//
// CAMSource()
//
//

const char szFile[] = "c:\\windows\\media\\chimes.wav";

CAMSource::CAMSource( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
    : CBaseFilter( pName,
                   pUnk,
		   &m_csFilter,
                   CLSID_AudioManSource),
      m_bStreaming(FALSE),
      m_pOutput(NULL)
{
     DbgLog((LOG_TRACE,2,TEXT("CAMSource")));

#if 0
     // could obviously be replaced with something more interesting,
     // but okay for testing purposes. !!!
     *phr = AllocSoundFromFile(&m_AMSound,
				   szFile,
			       0,
			       FALSE,
			       NULL);
#else
     IAMSound * pSound;
     *phr = AllocSoundFromFile(&pSound,
				   szFile,
			       0,
			       FALSE,
			       NULL);

     if (SUCCEEDED(*phr)) {
	 *phr = AllocLoopFilter(&m_AMSound,
				pSound,
				3);

	 pSound->Release();
     }

#endif
     DbgLog((LOG_TRACE,1,TEXT("Created AMSound: hr = %x, m_AMSound = %x"),
	    *phr, m_AMSound));

     if (SUCCEEDED(*phr)) {
	 m_AMAuxData.dwSize = sizeof(m_AMAuxData);
	 m_AMAuxData.dwFinishPos = (DWORD) -1;
	 m_AMAuxData.pEvents = NULL;
	 m_AMAuxData.pSink = NULL; // !!! should have a sink

	 *phr = m_AMSound->RegisterSink(m_AMAuxData.pSink);

	 *phr = m_AMSound->SetActive(m_AMAuxData.pSink, TRUE);
     }
}


//*****************************************************************************
//
// ~CAMSource()
//
//

CAMSource::~CAMSource()
{
    CAutoLock lock(&m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("~CAMSource")));


    // Delete the pins

    if (m_AMSound) {
	m_AMSound->SetActive(m_AMAuxData.pSink, FALSE);
	
	m_AMSound->UnregisterSink(m_AMAuxData.pSink);
	m_AMSound->Release();
    }

    if (m_pOutput) {
        delete m_pOutput;
        m_pOutput = NULL;
    }
}


// return the number of pins we provide

int CAMSource::GetPinCount()
{
    return 2;
}


// return a non-addrefed CBasePin * for the user to addref if he holds onto it
// for longer than his pointer to us. We create the pins dynamically when they
// are asked for rather than in the constructor. This is because we want to
// give the derived class an oppportunity to return different pin objects

// We return the objects as and when they are needed. If either of these fails
// then we return NULL, the assumption being that the caller will realise the
// whole deal is off and destroy us - which in turn will delete everything.

const WCHAR wszPin[] = L"WAVE Out";

CBasePin *
CAMSource::GetPin(int n)
{
    HRESULT hr = S_OK;

    // Create an input pin if necessary

    if (n == 0 && m_pOutput == NULL) {

        m_pOutput = (CAMSourcePin *)
		   new CAMSourcePin(NAME("AudioMan output pin"),
                                            this,            // Owner filter
                                            &hr,             // Result code
                                            wszPin);     // Pin name

        // a failed return code should delete the object

        if (FAILED(hr) || m_pOutput == NULL) {
            delete m_pOutput;
            m_pOutput = NULL;
        }
    }

    // Return the appropriate pin

    return m_pOutput;
}

//*****************************************************************************
//
// DecideBufferSize()
//
//  There is a design flaw in the Transform filter when it comes
//  to decompression, the Transform override doesn't allow a single
//  input buffer to map to multiple output buffers. This flaw exposes
//  a second flaw in DecideBufferSize, in order to determine the
//  output buffer size I need to know the input buffer size and
//  the compression ratio. Well, I don't have access to the input
//  buffer size and, more importantly, don't have a way to limit the
//  input buffer size. For example, our new TrueSpeech(TM) codec has
//  a ratio of 12:1 compression and we get input buffers of 12K
//  resulting in an output buffer size of >144K.
//
//  To get around this flaw I overrode the Receive member and
//  made it capable of mapping a single input buffer to multiple
//  output buffers. This allows DecideBufferSize to choose a size
//  that it deems appropriate, in this case 1/4 second.
//


//*****************************************************************************
//
// StartStreaming()
//
//

HRESULT CAMSource::StartStreaming()
{
    HRESULT hr = S_OK;
    CAutoLock    lock(&m_csFilter);

    if (m_pOutput->m_pPosition) {
	WAVEFORMATEX *pwfxOut = (WAVEFORMATEX *) m_pOutput->CurrentMediaType().Format();
	
	m_dwPosition = (DWORD) (m_pOutput->m_pPosition->Start() * pwfxOut->nSamplesPerSec);
	m_dwEndingPosition = (DWORD) (m_pOutput->m_pPosition->Stop() * pwfxOut->nSamplesPerSec);
    } else {
	m_dwPosition = 0;
	m_dwEndingPosition = m_AMSound->GetDuration();
    }


    DbgLog((LOG_TRACE, 1, TEXT("CAMSource::StartStreaming")));

    ASSERT(!ThreadExists());

    // start the thread
    if (!Create()) {
        return E_FAIL;
    }

    // Tell thread to initialize. If OnThreadCreate Fails, so does this.
    hr = InitThread();
    if (FAILED(hr))
	return hr;

    return RunThread();
}


STDMETHODIMP
CAMSource::Stop()
{
    CAutoLock lck1(&m_csFilter);
    if (m_State == State_Stopped) {
        return NOERROR;
    }

    // Succeed the Stop if we are not completely connected

    if (m_pOutput == NULL || m_pOutput->IsConnected() == FALSE) {
                m_State = State_Stopped;
                m_bEOSDelivered = FALSE;
                return NOERROR;
    }

    ASSERT(m_pOutput);

    // DO NOT synchronize with Receive calls

//    CAutoLock lck2(&m_csReceive);
    m_pOutput->Inactive();

    // allow a class derived from CTransformFilter
    // to know about starting and stopping streaming

    HRESULT hr = StopStreaming();


    // !!! do we have to delay this until receive exits?
    if (SUCCEEDED(hr)) {
	// complete the state transition
	m_State = State_Stopped;
	m_bEOSDelivered = FALSE;
    }
    return hr;
}


STDMETHODIMP
CAMSource::Pause()
{
    CAutoLock lck(&m_csFilter);
    HRESULT hr = NOERROR;

    if (m_State == State_Paused) {
    }

    // We may have no output connection

    else if (m_pOutput == NULL || m_pOutput->IsConnected() == FALSE) {
        m_State = State_Paused;
    }
    else {
	if (m_State == State_Stopped) {
	    // allow a class derived from CTransformFilter
	    // to know about starting and stopping streaming
	    hr = StartStreaming();
	}
	if (SUCCEEDED(hr)) {
	    hr = CBaseFilter::Pause();
	}
    }

    return hr;
}


//*****************************************************************************
//
// StopStreaming()
//
//

HRESULT CAMSource::StopStreaming()
{
    HRESULT    hr;
    CAutoLock lock(&m_csFilter);

    DbgLog((LOG_TRACE, 1, TEXT("CAMSource::StopStreaming")));
    if (ThreadExists()) {
	hr = StopThread();

	if (FAILED(hr)) {
	    return hr;
	}

	hr = ExitThread();
	if (FAILED(hr)) {
	    return hr;
	}

	Close();	// Wait for the thread to exit, then tidy up.
    }

    return hr;
}


// =================================================================
// Implements the CAMSourcePin class
// =================================================================

// constructor

CAMSourcePin::CAMSourcePin(
    TCHAR *pObjectName,
    CAMSource *pAMSource,
    HRESULT * phr,
    LPCWSTR pPinName)
    : CBaseOutputPin(pObjectName, pAMSource, &pAMSource->m_csFilter, phr, pPinName),
      m_pPosition(NULL)
{
    DbgLog((LOG_TRACE,2,TEXT("CAMSourcePin::CAMSourcePin")));
    m_pFilter = pAMSource;
}


// destructor

CAMSourcePin::~CAMSourcePin()
{
    DbgLog((LOG_TRACE,2,TEXT("CAMSourcePin::~CAMSourcePin")));

    if (m_pPosition) {
	delete m_pPosition;
    }
}


CAMSourcePosition::CAMSourcePosition(
    TCHAR* pName,
    CAMSource* pFilter,
    HRESULT* phr)
    : CSourcePosition(pName, pFilter->GetOwner(), phr, &pFilter->m_csFilter),
      m_pFilter(pFilter)
{
    WAVEFORMATEX *pwfxOut = (WAVEFORMATEX *) m_pFilter->m_pOutput->CurrentMediaType().Format();

    m_Duration = (LONGLONG) m_pFilter->m_AMSound->GetDuration() *
		 10000000 / pwfxOut->nSamplesPerSec;
    m_Stop = m_Duration;

    DbgLog((LOG_TRACE,2,TEXT("CAMSourcePosition: Duration = %s"),
	   (LPCTSTR)CDisp(m_Duration)));

}



// ------ IMediaPosition implementation -----------------------

HRESULT
CAMSourcePosition::ChangeStart()
{
    // this lock should not be the same as the lock that protects access
    // to the start/stop/rate values. The worker thread will need to lock
    // that on some code paths before responding to a Stop and thus will
    // cause deadlock.

    // what we are locking here is access to the worker thread, and thus we
    // should hold the lock that prevents more than one client thread from
    // accessing the worker thread.

//    CAutoLock lock(&m_pStream->m_Worker.m_AccessLock);

    if (m_pFilter->ThreadExists()) {

	// next time round the loop the worker thread will
	// pick up the position change.
	// We need to flush all the existing data - we must do that here
	// as our thread will probably be blocked in GetBuffer otherwise

	m_pFilter->m_pOutput->DeliverBeginFlush();

	// make sure we have stopped pushing
	m_pFilter->StopThread();

	// complete the flush
	m_pFilter->m_pOutput->DeliverEndFlush();

	// restart
	m_pFilter->RunThread();
    }
    return S_OK;
}

HRESULT
CAMSourcePosition::ChangeRate()
{
    // changing the rate means flushing and re-starting from current position
    return ChangeStart();
}

HRESULT
CAMSourcePosition::ChangeStop()
{
    // if stop has changed when running, simplest is to
    // flush data in case we have gone past the new stop pos. Perhaps more
    // complex strategy later. Stopping and restarting the worker thread
    // like this should not cause a change in current position if
    // we have not changed start pos.
    return ChangeStart();
}


// overriden to expose IMediaPosition control interface

STDMETHODIMP
CAMSourcePin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;


    // !!! also need to expose some other interface here to allow
    // downstream people direct access to our IAMSound interface,
    // if they like that sort of thing.

    if (riid == IID_IMediaPosition) {
        if (m_pPosition == NULL) {

            HRESULT hr = S_OK;
            m_pPosition = new CAMSourcePosition(NAME("AMSource CSourcePosition"),
                                           m_pFilter,
                                           &hr);
            if (m_pPosition == NULL) {
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr)) {
                delete m_pPosition;
                m_pPosition = NULL;
                return hr;
            }
        }
        return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}



// check a given output type

HRESULT
CAMSourcePin::CheckMediaType(const CMediaType* pmtOut)
{
    //---------------------  Do some format verification  -----------------------

    if (m_pFilter->IsActive()) {
        DbgLog((LOG_ERROR, 1, TEXT("  already streaming!")));
        return E_FAIL;
    }

    // and we only output audio
    if (*pmtOut->Type() != MEDIATYPE_Audio) {
        DbgLog((LOG_ERROR, 1, TEXT("  pmtOut->Type != MEDIATYPE_Audio!")));
        return E_INVALIDARG;
    }

    // check this is a waveformatex
    if (*pmtOut->FormatType() != FORMAT_WaveFormatEx) {
        DbgLog((LOG_ERROR, 1, TEXT("  pmtOut->FormatType != FORMAT_WaveFormatEx!")));
        return E_INVALIDARG;
    }

    WAVEFORMATEX *pwfxOut = (WAVEFORMATEX *)pmtOut->Format();

    WAVEFORMATEX wfx;

    m_pFilter->m_AMSound->GetFormat(&wfx, sizeof(wfx));

    if (memcmp(pwfxOut, &wfx, sizeof(wfx))) {
        DbgLog((LOG_ERROR, 1, TEXT("  pmtOut not right wave format")));
        return E_INVALIDARG;
    }

    return S_OK;
}


// called after we have agreed a media type to actually set it

HRESULT
CAMSourcePin::SetMediaType(const CMediaType* pmtOut)
{
    HRESULT hr = NOERROR;

    // Set the base class media type (should always succeed)
    hr = CBasePin::SetMediaType(pmtOut);
    ASSERT(SUCCEEDED(hr));

    // Check this is a good type (should always succeed)
    ASSERT(SUCCEEDED(CheckMediaType(pmtOut)));

    // !!! should remember the type if we supported more than one!

    return NOERROR;
}


// agree with the downstream connection on what buffers to use....

HRESULT
CAMSourcePin::DecideBufferSize(
    IMemAllocator * pAllocator,
    ALLOCATOR_PROPERTIES* pProperties)
{
    DbgLog((LOG_TRACE, 1, TEXT("CAMSource::DecideBufferSize")));

    WAVEFORMATEX *pwfxOut = (WAVEFORMATEX *) m_mt.Format();

    ALLOCATOR_PROPERTIES Actual;
    pProperties->cBuffers     = 4; // !!!
    if (pwfxOut) {
        pProperties->cbBuffer     = 4096; // !!!!
    } else {
        DbgLog((LOG_ERROR, 1, TEXT("CAMSource::DecideBufferSize: why no pwfxOut????")));
    }

    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);

    if (FAILED(hr)) {
        return hr;
    }

    if (Actual.cbBuffer < (LONG)m_mt.GetSampleSize()) {
        // can't use this allocator
        return E_INVALIDARG;
    }

    return S_OK;
}



// return a specific media type indexed by iPosition

HRESULT
CAMSourcePin::GetMediaType(
    int iPosition,
    CMediaType *pmt)
{
    CAutoLock lock(&m_pFilter->m_csFilter);

    DbgLog((LOG_TRACE, 1, TEXT("CAMSource::GetMediaType")));
    DbgLog((LOG_TRACE, 1, TEXT("  iPosition = %d"),iPosition));

    // check it is the single type they want
    if (iPosition<0) {
        return E_INVALIDARG;
    }
    if (iPosition>0) {
        return VFW_S_NO_MORE_ITEMS;
    }

    pmt->SetType(&MEDIATYPE_Audio);
    pmt->SetFormatType(&FORMAT_WaveFormatEx);

    // generate a wave format!!!
    WAVEFORMATEX wfx;

    m_pFilter->m_AMSound->GetFormat(&wfx, sizeof(wfx));

    if (!(pmt->SetFormat((LPBYTE) &wfx, sizeof(wfx)))) {
	//SetFormat failed...
        return E_OUTOFMEMORY;
    }

    pmt->SetSampleSize(wfx.nBlockAlign);

    pmt->SetTemporalCompression(FALSE);

    return NOERROR;
}


// Override this if you can do something constructive to act on the
// quality message.  Consider passing it upstream as well


STDMETHODIMP
CAMSourcePin::Notify(IBaseFilter * pSender, Quality q)
{
    CheckPointer(pSender,E_POINTER);
    ValidateReadPtr(pSender,sizeof(IBaseFilter));

    return E_FAIL; // !!!

} // Notify



HRESULT CAMSource::FillBuffer(IMediaSample *pSample)
{
    PBYTE pBuf;

    // !!! need to wait here until pushing thread has gone by this location

    HRESULT hr = pSample->GetPointer(&pBuf);
    if (FAILED(hr)) {
	pSample->Release();
        DbgLog((LOG_ERROR, 1, TEXT("GetPointer failed in FillBuffer")));
	return E_OUTOFMEMORY;
    }

    WAVEFORMATEX *pwfxOut = (WAVEFORMATEX *) m_pOutput->CurrentMediaType().Format();

    DWORD dwSamples = pSample->GetSize() / pwfxOut->nBlockAlign;

    if (m_dwPosition + dwSamples > m_dwEndingPosition)
	dwSamples = m_dwEndingPosition - m_dwPosition;

    // now call audioman to get data!!!
    hr = m_AMSound->GetData(pBuf, m_dwPosition, &dwSamples,
			     &m_AMAuxData);

    if (hr == E_OUTOFRANGE)
	dwSamples = 0;

    if (dwSamples > 0) {
	DWORD dwPosEnd = m_dwPosition + dwSamples;

	REFERENCE_TIME rtStart, rtEnd;
	rtStart = (LONGLONG) m_dwPosition * 10000000 / pwfxOut->nSamplesPerSec;
	rtEnd = (LONGLONG) dwPosEnd * 10000000 / pwfxOut->nSamplesPerSec;

	pSample->SetTime(&rtStart, &rtEnd);

	pSample->SetActualDataLength(dwSamples * pwfxOut->nBlockAlign);

	m_dwPosition += dwSamples;
    } else {
	DbgLog((LOG_TRACE, 1, TEXT("We appear to be done, exiting")));
        hr = S_FALSE;
    }

    return hr;
}


//
// ThreadProc
//
// When this returns the thread exits
// Return codes > 0 indicate an error occured
DWORD CAMSource::ThreadProc(void) {

    Command com;

    do {
	com = GetRequest();
	if (com != CMD_INIT) {
	    DbgLog((LOG_ERROR, 1, TEXT("Thread expected init command")));
	    Reply(E_UNEXPECTED);
	}
    } while (com != CMD_INIT);

    DbgLog((LOG_TRACE, 1, TEXT("CAMSource worker thread initializing")));

    // Initialisation suceeded
    Reply(NOERROR);

    Command cmd;
    do {
	cmd = GetRequest();

        DbgLog((LOG_TRACE, 1, TEXT("got cmd %d"), cmd));
	switch (cmd) {

	case CMD_EXIT:
	    Reply(NOERROR);
	    break;

	case CMD_RUN:
	    Reply(NOERROR);
            DbgLog((LOG_TRACE, 1, TEXT("entering DoBufferProcessingLoop")));

	    m_bStreaming = TRUE;

	    DoBufferProcessingLoop();

	    m_bStreaming = FALSE;

	    DbgLog((LOG_TRACE, 1, TEXT("done with DoBufferProcessingLoop")));
	    break;

	case CMD_STOP:
            DbgLog((LOG_TRACE, 1, TEXT("CMD_STOP while not running anyway?")));
	    Reply(NOERROR);
	    break;

	default:
	    DbgLog((LOG_ERROR, 1, TEXT("Unknown command %d received!"), cmd));
	    Reply(E_NOTIMPL);
	    break;
	}
    } while (cmd != CMD_EXIT);

    DbgLog((LOG_TRACE, 1, TEXT("CAMSource worker thread exiting")));
    return 0;
}


//
// DoBufferProcessingLoop
//
// Grabs a buffer and calls the users processing function.
// Overridable, so that different delivery styles can be catered for.
HRESULT CAMSource::DoBufferProcessingLoop(void) {

    Command com;

//    OnThreadStartPlay();

    do {
	while (!CheckRequest(&com)) {

	    IMediaSample *pSample;

	    HRESULT hr = m_pOutput->GetDeliveryBuffer(&pSample,NULL,NULL,0);
	    if (FAILED(hr)) {
		continue;	// go round again. Perhaps the error will go away
			    // or the allocator is decommited & we will be asked to
			    // exit soon.
	    }

	    // Virtual function user will override.
	    hr = FillBuffer(pSample);

	    if (hr == S_OK) {
		hr = m_pOutput->Deliver(pSample);
	    } else if (hr == S_FALSE) {
		pSample->Release();
		m_pOutput->DeliverEndOfStream();
		return S_OK;
	    } else {
		DbgLog((LOG_ERROR, 1, TEXT("Error %08lX from FillBuffer!!!"), hr));
	    }

	    pSample->Release();

	    if (hr == S_FALSE) {
		DbgLog((LOG_TRACE, 1, TEXT("S_FALSE from Receive, stopping")));
		return S_FALSE;
	    }
	}
	
	if (com == CMD_RUN) {
            DbgLog((LOG_TRACE, 1, TEXT("got run cmd while running")));
	    com = GetRequest(); // throw command away
	    Reply(0);
        } else if (com != CMD_STOP) {
	    DbgLog((LOG_ERROR, 1, TEXT("Unexpected command!!!")));
	    com = GetRequest(); // throw command away
	    Reply(0);
	}
    } while (com != CMD_STOP);

    Reply(0);
    DbgLog((LOG_TRACE, 1, TEXT("exiting with CMD_STOP")));
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\acmwrap\acmwrap.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Quartz wrapper for ACM, David Maymudes, January 1996
//
//  10/15/95 mikegi - created
//

#include <streams.h>
#include <mmsystem.h>
#include <mmreg.h>
#include <msacm.h>
#include <measure.h>
#include <dynlink.h>
#include <malloc.h>
#include <tchar.h>

#ifdef FILTER_DLL
// define the GUIDs for streams and my CLSID in this file
#include <initguid.h>
#endif

#include "acmwrap.h"

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
// setup data

const AMOVIESETUP_MEDIATYPE
sudPinTypes = { &MEDIATYPE_Audio      // clsMajorType
, &MEDIASUBTYPE_NULL }; // clsMinorType

const AMOVIESETUP_PIN sudpPins [] =
{
    { L"Input"             // strName
        , FALSE              // bRendered
        , FALSE              // bOutput
        , FALSE              // bZero
        , FALSE              // bMany
        , &CLSID_NULL        // clsConnectsToFilter
        , L"Output"          // strConnectsToPin
        , 1                  // nTypes
        , &sudPinTypes       // lpTypes
    },
    { L"Output"            // strName
    , FALSE              // bRendered
    , TRUE               // bOutput
    , FALSE              // bZero
    , FALSE              // bMany
    , &CLSID_NULL        // clsConnectsToFilter
    , L"Input"           // strConnectsToPin
    , 1                  // nTypes
    , &sudPinTypes       // lpTypes
    }
};


const AMOVIESETUP_FILTER sudAcmWrap =
{ &CLSID_ACMWrapper    // clsID
, L"ACM Wrapper"       // strName
, MERIT_NORMAL         // dwMerit
, 2                    // nPins
, sudpPins };          // lpPin


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

#ifdef FILTER_DLL
// List of class IDs and creator functions for class factory
CFactoryTemplate g_Templates[] =
{
    { L"ACM Wrapper"
        , &CLSID_ACMWrapper
        , CACMWrapper::CreateInstance
        , NULL
        , &sudAcmWrap }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
// exported entry points for registration and unregistration (in this case they
// only call through to default implmentations).
//

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************
//
// CreateInstance()
//
//

CUnknown *CACMWrapper::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::CreateInstance")));

    return new CACMWrapper(TEXT("ACM wrapper transform"), pUnk, phr);
}


//*****************************************************************************
//
// NonDelegatingQueryInterface()
//
//

STDMETHODIMP CACMWrapper::NonDelegatingQueryInterface( REFIID riid, void **ppv )
{
    *ppv = NULL;

    if( riid == IID_IPersist )
    {
        return GetInterface((IPersist *) (CTransformFilter *)this, ppv);
    }
    else if( riid == IID_IPersistPropertyBag )
    {
        return GetInterface((IPersistPropertyBag *)this, ppv);
    }
    else if( riid == IID_IPersistStream )
    {
        return GetInterface((IPersistStream *)this, ppv);
    }

    {
        return CTransformFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}


//*****************************************************************************
//
// CACMWrapper()
//
//

CACMWrapper::CACMWrapper( TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr )
: CTransformFilter( pName,
                   pUnk,
                   CLSID_ACMWrapper),
                   m_hacmStream(NULL),
                   m_bStreaming(FALSE),
                   m_lpwfxOutput(NULL),
                   m_cbwfxOutput(0),
                   m_cArray(0),
                   m_lpExtra(NULL),
                   m_cbExtra(0),
                   m_wFormatTag(WAVE_FORMAT_PCM),
                   m_rgFormatMap(NULL),
                   m_pFormatMapPos(NULL),
                   m_wCachedTryFormat(0),
                   m_wSourceFormat(0),
                   m_wTargetFormat(0),
                   m_wCachedSourceFormat(0),
                   m_wCachedTargetFormat(0),
                   CPersistStream(pUnk, phr)
{
    DbgLog((LOG_TRACE,2,TEXT("CACMWrapper constructor")));

}


//*****************************************************************************
//
// ~CACMWrapper()
//
//

CACMWrapper::~CACMWrapper()
{
    CAutoLock lock(&m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("~CACMWrapper")));

    if( m_hacmStream )
    {
        DbgLog((LOG_TRACE,5,TEXT("  closing m_hacmStream")));
        acmStreamClose( m_hacmStream, 0 );
        m_hacmStream = NULL;
    }

    if (m_lpwfxOutput)
        QzTaskMemFree(m_lpwfxOutput);

    // our cached formats we can offer through GetMediaType
    while (m_cArray-- > 0)
        QzTaskMemFree(m_lpwfxArray[m_cArray]);

    if (m_cbExtra)
        QzTaskMemFree(m_lpExtra);
}


// !!! stolen from msaudio.h
#if !defined(WAVE_FORMAT_MSAUDIO)
#   define  WAVE_FORMAT_MSAUDIO     353
#   define  MSAUDIO_ENCODE_KEY "F6DC9830-BC79-11d2-A9D0-006097926036"
#   define  MSAUDIO_DECODE_KEY "1A0F78F0-EC8A-11d2-BBBE-006008320064"
#endif
#if !defined(WAVE_FORMAT_MSAUDIOV1)
#   define  WAVE_FORMAT_MSAUDIOV1     352
#endif

#include "..\..\..\filters\asf\wmsdk\inc\wmsdk.h"

MMRESULT CACMWrapper::CallacmStreamOpen
(
 LPHACMSTREAM            phas,       // pointer to stream handle
 HACMDRIVER              had,        // optional driver handle
 LPWAVEFORMATEX          pwfxSrc,    // source format to convert
 LPWAVEFORMATEX          pwfxDst,    // required destination format
 LPWAVEFILTER            pwfltr,     // optional filter
 DWORD_PTR               dwCallback, // callback
 DWORD_PTR               dwInstance, // callback instance data
 DWORD                   fdwOpen     // ACM_STREAMOPENF_* and CALLBACK_*
 ) {

    if (pwfxSrc && (pwfxSrc->wFormatTag == WAVE_FORMAT_MSAUDIO ||
        pwfxSrc->wFormatTag == WAVE_FORMAT_MSAUDIOV1)) {
        if (m_pGraph) {
            IObjectWithSite *pSite;
            HRESULT hrKey = m_pGraph->QueryInterface(IID_IObjectWithSite, (VOID **)&pSite);
            if (SUCCEEDED(hrKey)) {
                IServiceProvider *pSP;
                hrKey = pSite->GetSite(IID_IServiceProvider, (VOID **)&pSP);
                pSite->Release();

                if (SUCCEEDED(hrKey)) {
                    IUnknown *pKey;
                    hrKey = pSP->QueryService(__uuidof(IWMReader), IID_IUnknown, (void **) &pKey);
                    pSP->Release();

                    if (SUCCEEDED(hrKey)) {
                        // !!! verify key?
                        pKey->Release();
                        DbgLog((LOG_TRACE, 1, "Unlocking MSAudio codec"));

                        char *p = (char *) _alloca(sizeof(WAVEFORMATEX) + pwfxSrc->cbSize + sizeof(MSAUDIO_DECODE_KEY));

                        CopyMemory(p, pwfxSrc, sizeof(WAVEFORMATEX) + pwfxSrc->cbSize);

                        pwfxSrc = (WAVEFORMATEX *) p;

                        if (pwfxSrc->cbSize < sizeof(MSAUDIO_DECODE_KEY)) {
                            strcpy(p + sizeof(WAVEFORMATEX) + pwfxSrc->cbSize, MSAUDIO_DECODE_KEY);
                            pwfxSrc->cbSize += sizeof(MSAUDIO_DECODE_KEY);
                        } else {
                            strcpy(p + sizeof(WAVEFORMATEX) + pwfxSrc->cbSize - sizeof(MSAUDIO_DECODE_KEY),
                                MSAUDIO_DECODE_KEY);
                        }
                    }
                }
            }
        }
    }

    if (pwfxDst && (pwfxDst->wFormatTag == WAVE_FORMAT_MSAUDIO ||
        pwfxDst->wFormatTag == WAVE_FORMAT_MSAUDIOV1)) {
        char *p = (char *) _alloca(sizeof(WAVEFORMATEX) + pwfxDst->cbSize + sizeof(MSAUDIO_ENCODE_KEY));

        CopyMemory(p, pwfxDst, sizeof(WAVEFORMATEX) + pwfxDst->cbSize);

        pwfxDst = (WAVEFORMATEX *) p;

        if (pwfxDst->cbSize < sizeof(MSAUDIO_ENCODE_KEY)) {
            strcpy(p + sizeof(WAVEFORMATEX) + pwfxDst->cbSize, MSAUDIO_ENCODE_KEY);
            pwfxDst->cbSize += sizeof(MSAUDIO_ENCODE_KEY);
        } else {
            strcpy(p + sizeof(WAVEFORMATEX) + pwfxDst->cbSize - sizeof(MSAUDIO_ENCODE_KEY),
                MSAUDIO_ENCODE_KEY);
        }
    }

    return acmStreamOpen(phas, had, pwfxSrc, pwfxDst, pwfltr, dwCallback, dwInstance, fdwOpen);
}



















//*****************************************************************************
//
// DumpWAVEFORMATEX()
//
//



#ifdef DEBUG
// note: the debug build will not use dynamic linking to MSACM32.

#define DumpWAVEFORMATEX(args) XDumpWAVEFORMATEX args

 void XDumpWAVEFORMATEX( char *psz, WAVEFORMATEX *pwfx )
 {

     ACMFORMATTAGDETAILS acmftd;

     ACMFORMATDETAILS acmfd;
     DWORD            dwSize;
     WAVEFORMATEX     *pwfxQuery;


     if( psz ) DbgLog((LOG_TRACE,4,TEXT("%s" ),psz));

     //--------------------  Dump WAVEFORMATEX  ------------------------

     DbgLog((LOG_TRACE,4,TEXT("  wFormatTag           %u" ), pwfx->wFormatTag));
     DbgLog((LOG_TRACE,4,TEXT("  nChannels            %u" ), pwfx->nChannels));
     DbgLog((LOG_TRACE,4,TEXT("  nSamplesPerSec       %lu"), pwfx->nSamplesPerSec));
     DbgLog((LOG_TRACE,4,TEXT("  nAvgBytesPerSec      %lu"), pwfx->nAvgBytesPerSec));
     DbgLog((LOG_TRACE,4,TEXT("  nBlockAlign          %u" ), pwfx->nBlockAlign));
     DbgLog((LOG_TRACE,4,TEXT("  wBitsPerSample       %u" ), pwfx->wBitsPerSample));

     //  if( pmt->FormatLength() >= sizeof(WAVEFORMATEX) )
     //   {
     //    DbgLog((LOG_TRACE,1,TEXT("  cbSize                %u"), pwfx->cbSize));
     //   }

     //---------------------  Dump format type  ------------------------

     memset( &acmftd, 0, sizeof(acmftd) );

     acmftd.cbStruct    = sizeof(acmftd);
     acmftd.dwFormatTag = (DWORD)pwfx->wFormatTag;

     MMRESULT mmr;
     mmr = acmFormatTagDetails( NULL, &acmftd, ACM_FORMATTAGDETAILSF_FORMATTAG );
     if( mmr == 0 )
     {
         DbgLog((LOG_TRACE,4,TEXT("  szFormatTag          '%s'"),acmftd.szFormatTag));
     }
     else
     {
         DbgLog((LOG_ERROR,1,TEXT("*** acmFormatTagDetails failed, mmr = %u"),mmr));
     }


     //-----------------------  Dump format  ---------------------------

     dwSize = sizeof(WAVEFORMATEX)+pwfx->cbSize;

     pwfxQuery = (WAVEFORMATEX *)LocalAlloc( LPTR, dwSize );
     if( pwfxQuery )
     {
         memcpy( pwfxQuery, pwfx, dwSize );

         memset( &acmfd, 0, sizeof(acmfd) );

         acmfd.cbStruct    = sizeof(acmfd);
         acmfd.dwFormatTag = (DWORD)pwfx->wFormatTag;
         acmfd.pwfx        = pwfxQuery;
         acmfd.cbwfx       = dwSize;

         mmr = acmFormatDetails( NULL, &acmfd, ACM_FORMATDETAILSF_FORMAT );
         if( mmr == 0 )
         {
             DbgLog((LOG_TRACE,4,TEXT("  szFormat             '%s'"),acmfd.szFormat));
         }
         else
         {
             DbgLog((LOG_ERROR,1,TEXT("*** acmFormatDetails failed, mmr = %u"),mmr));
         }

         LocalFree( pwfxQuery );
     }
     else
     {
         DbgLog((LOG_ERROR,1,TEXT("*** LocalAlloc failed")));
     }
 }

#else

#define DumpWAVEFORMATEX(args)

#endif

 //*****************************************************************************
 //
 // CheckInputType()
 //
 // We will accept anything that we can transform into a type with the
 // format tag we are supposed to always be outputting
 //


 HRESULT CACMWrapper::CheckInputType(const CMediaType* pmtIn)
 {
     HRESULT      hr;
     WAVEFORMATEX *pwfx;
     MMRESULT     mmr;
     DWORD        dwSize;
     WAVEFORMATEX *pwfxOut, *pwfxMapped;

     DbgLog((LOG_TRACE, 3, TEXT("CACMWrapper::CheckInputType")));

     //DisplayType("pmtIn details:", pmtIn);

     hr = VFW_E_INVALIDMEDIATYPE;

     pwfx = (WAVEFORMATEX *)pmtIn->Format();

     if (pmtIn->majortype != MEDIATYPE_Audio) {
         DbgLog((LOG_ERROR, 1, TEXT("*** CheckInputType only takes audio")));
         return hr;
     }

     if (pmtIn->FormatLength() < sizeof(PCMWAVEFORMAT)) {
         DbgLog((LOG_ERROR, 1, TEXT("*** pmtIn->FormatLength < PCMWAVEFORMAT")));
         return hr;
     }

     if (*pmtIn->FormatType() != FORMAT_WaveFormatEx) {
         DbgLog((LOG_ERROR,1,TEXT("*** pmtIn->FormatType != FORMAT_WaveFormatEx"
             )));
         return hr;
     }

     // some invalid formats have non-zero cbSize with PCM, which makes me blow
     // up
     if (((LPWAVEFORMATEX)(pmtIn->Format()))->wFormatTag == WAVE_FORMAT_PCM &&
         ((LPWAVEFORMATEX)(pmtIn->Format()))->cbSize > 0) {
         DbgLog((LOG_ERROR,1,TEXT("*** cbSize > 0 for PCM !!!")));
         return hr;
     }

     // it takes 200ms for acmFormatSuggest to say, "yes, I can convert PCM".
     // What a waste of time!  Of course we can accept any PCM data, as long as
     // we're in "accepting PCM" mode
     if (m_wFormatTag == WAVE_FORMAT_PCM && pwfx->wFormatTag == WAVE_FORMAT_PCM)
         return S_OK;

     mmr = acmMetrics( NULL, ACM_METRIC_MAX_SIZE_FORMAT, &dwSize );
     if (mmr == 0) {

         // make sure that the size returned is big enough for a WAVEFORMATEX
         // structure.

         if (dwSize < sizeof (WAVEFORMATEX))
             dwSize = sizeof (WAVEFORMATEX) ;

         // Hack for VoxWare codec bug
         if (dwSize < 256)
             dwSize = 256;

         pwfxOut = (WAVEFORMATEX *)LocalAlloc( LPTR, dwSize );
         if (pwfxOut) {

             // ask for formats with a specific tag
             pwfxOut->wFormatTag = m_wFormatTag;
             //pwfxOut->cbSize = 0;

             if (pwfx->wFormatTag != m_wCachedSourceFormat) {
                 // usual case
                 mmr = acmFormatSuggest(NULL, pwfx, pwfxOut, dwSize, ACM_FORMATSUGGESTF_WFORMATTAG);
             } else {
                 DbgLog((LOG_TRACE, 1, TEXT("*** CheckInputType: remapping input format %u to %u"), m_wCachedSourceFormat, m_wCachedTryFormat));

                 pwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + pwfx->cbSize);
                 CopyMemory(pwfxMapped, pwfx, sizeof(WAVEFORMATEX) + pwfx->cbSize);
                 pwfxMapped->wFormatTag = m_wCachedTryFormat;  // remap tags

                 mmr = acmFormatSuggest(NULL, pwfxMapped, pwfxOut, dwSize, ACM_FORMATSUGGESTF_WFORMATTAG);
             }

             if(mmr == 0) {
                 if(pwfx->wFormatTag == m_wCachedSourceFormat)
                     m_wCachedTargetFormat = m_wCachedTryFormat; // save our new cached target format

                 DumpWAVEFORMATEX(("Input accepted. It can produce:", pwfxOut));
                 hr = NOERROR;
             } else {
                 DbgLog((LOG_TRACE,3,TEXT("Input rejected: Cannot produce tag %d"), m_wFormatTag));
             }

             LocalFree( pwfxOut );
         } else {
             DbgLog((LOG_ERROR,1,TEXT("LocalAlloc failed")));
         }
     } else {
         DbgLog((LOG_ERROR,1,TEXT("acmMetrics failed, mmr = %u"), mmr));
     }

     if (mmr && !m_wCachedTryFormat) {
         DbgLog((LOG_TRACE, 1, TEXT("CheckInputType: Trying ACMCodecMapper....")));
         if (ACMCodecMapperOpen(m_wCachedSourceFormat = pwfx->wFormatTag) != ERROR_SUCCESS) {
             m_wCachedTryFormat = m_wCachedSourceFormat = m_wCachedTargetFormat = 0;
             ACMCodecMapperClose();  // may have been a partial open failure
             return hr;
         }

         while(m_wCachedTryFormat = ACMCodecMapperQuery()) {
             if(m_wCachedTryFormat == pwfx->wFormatTag)  // no need to retry our current format
                 continue;

             if(SUCCEEDED(CheckInputType(pmtIn))) {
                 ACMCodecMapperClose();
                 return NOERROR;
             }
         }
         ACMCodecMapperClose();
     }

     return hr;
}

// helper function used for cleaning up after the acm codec mapper (a set of registry entries specifying equivalence classes for wave format tags)
void CACMWrapper::ACMCodecMapperClose()
{
    DbgLog((LOG_TRACE,2,TEXT("::ACMCodecMapperClose()")));

    if (m_rgFormatMap) {
        delete[] m_rgFormatMap;
        m_rgFormatMap  = NULL;
    }

    m_pFormatMapPos     = NULL;
    m_wCachedTryFormat  = 0;
}

// helper function used for opening the codec mapper (a set of registry entries specifying equivalence classes for wave format tags) and finding
// the equivalence class for format 'dwFormatTag'
DWORD CACMWrapper::ACMCodecMapperOpen(WORD dwFormatTag)
{
    DbgLog((LOG_TRACE,2,TEXT("::ACMCodecMapperOpen(%u)"), dwFormatTag));

    ASSERT(m_rgFormatMap == NULL);

    HKEY hkMapper;
    LONG lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SOFTWARE\\Microsoft\\NetShow\\Player\\CodecMapper\\ACM"),
        0,
        KEY_READ,
        &hkMapper);

    if (lResult != ERROR_SUCCESS) {
        DbgLog((LOG_ERROR,1,TEXT("RegOpenKeyEx failed lResult = %u"), lResult));
        return lResult;
    }

    TCHAR szTarget[10];

    wsprintf(szTarget, TEXT("%d"), dwFormatTag);

    DWORD dwFormatMapLengthBytes;
    lResult = RegQueryValueEx(hkMapper, szTarget, NULL, NULL, NULL, &dwFormatMapLengthBytes);
    if(lResult != ERROR_SUCCESS) {
        DbgLog((LOG_TRACE,1,TEXT("RegQueryValueEx failed lResult = %u"), lResult));
        RegCloseKey(hkMapper);
        return lResult;
    }

    m_rgFormatMap = new TCHAR[dwFormatMapLengthBytes/sizeof(TCHAR) + 1];
    if (!m_rgFormatMap) {
        RegCloseKey(hkMapper);
        return E_OUTOFMEMORY;
    }

    m_pFormatMapPos = m_rgFormatMap;

    lResult = RegQueryValueEx(hkMapper, szTarget, NULL, NULL,
        (BYTE *) m_rgFormatMap, &dwFormatMapLengthBytes);
    if(lResult != ERROR_SUCCESS) {
        DbgLog((LOG_TRACE,1,TEXT("RegQueryValueEx failed lResult = %u"), lResult));
    }

    RegCloseKey(hkMapper);

    return lResult;
}

// helper function used getting the next entry in the codec mapper (a set of registry entries specifying equivalence classes for wave format tags)
WORD CACMWrapper::ACMCodecMapperQuery()
{
    DbgLog((LOG_TRACE,3,TEXT("::ACMCodecMapperQuery()")));

    if(!m_rgFormatMap || !m_pFormatMapPos)
        return 0;   // 0 is an invalid format

    DbgLog((LOG_TRACE,3,TEXT("Finding next format")));

    TCHAR *pCurFormat;
    WORD wCurFormat;
    pCurFormat = m_pFormatMapPos;
    for(;;) {
        if(*pCurFormat == TCHAR(',')) {
            *pCurFormat = TCHAR('\0');  // null terminate the substring from m_pFormatMapPos to pCurFormatPos (if necessary)
            wCurFormat = (WORD)_ttoi(m_pFormatMapPos); // cvt this substring

            DbgLog((LOG_TRACE,3,TEXT("Found delimeter, wCurFormat=%u"), wCurFormat));

            m_pFormatMapPos = ++pCurFormat; // prepare for the next substring
            return wCurFormat;
        } else if(*pCurFormat == TCHAR('\0')) {
            wCurFormat = (WORD)_ttoi(m_pFormatMapPos); // cvt this substring

            DbgLog((LOG_TRACE,3,TEXT("Found eos, wCurFormat=%u"), wCurFormat));

            m_pFormatMapPos = NULL; // we're done for good
            return wCurFormat;
        }

        ++pCurFormat;
    }

    DbgLog((LOG_TRACE,2,TEXT("Exiting ::ACMCodecMapperQuery(), no format found")));

    return 0; // invalid format
}

// Every format supported comes through here.  We memorize them all so we
// can quickly offer them in GetMediaType without taking O(n) time
// We will only memorize formats that match the kind of formats we're
// supposed to allow (we only work with a specific format tag, m_wFormatTag
//
BOOL FormatEnumCallback(HACMDRIVERID had, LPACMFORMATDETAILS lpafd, DWORD_PTR dwInstance, DWORD fdwSupport)
{
    CACMWrapper *pC = (CACMWrapper *)dwInstance;

    if (pC->m_cArray < MAXTYPES) {
        // Is this a format we care to offer?
        if (lpafd->pwfx->wFormatTag == pC->m_wFormatTag) {
            DWORD dwSize = max(sizeof(WAVEFORMATEX), lpafd->cbwfx);
            pC->m_lpwfxArray[pC->m_cArray] = (LPWAVEFORMATEX)QzTaskMemAlloc(
                dwSize);
            if (pC->m_lpwfxArray[pC->m_cArray]) {
                CopyMemory(pC->m_lpwfxArray[pC->m_cArray], lpafd->pwfx,
                    lpafd->cbwfx);
                if (lpafd->pwfx->wFormatTag == WAVE_FORMAT_PCM)
                    // not necessarily 0 in MSACM but Quartz promises it will be
                    pC->m_lpwfxArray[pC->m_cArray]->cbSize = 0;
                pC->m_cArray++;
            } else {
                return FALSE;
            }
        }
    } else {
        return FALSE;   // I'm stuffed
    }
    return TRUE;
}


HRESULT CACMWrapper::MakePCMMT(int freq)
{
    int xx, yy;
    for (xx=16;xx>=8;xx-=8) {
        for (yy=2;yy>=1;yy--) {
            m_lpwfxArray[m_cArray] = (LPWAVEFORMATEX)QzTaskMemAlloc(
                sizeof(WAVEFORMATEX));
            if (m_lpwfxArray[m_cArray] == NULL)
                return E_OUTOFMEMORY;
            m_lpwfxArray[m_cArray]->wFormatTag = WAVE_FORMAT_PCM;
            m_lpwfxArray[m_cArray]->wBitsPerSample = (WORD)xx;
            m_lpwfxArray[m_cArray]->nChannels = (WORD)yy;
            m_lpwfxArray[m_cArray]->nSamplesPerSec = freq;
            m_lpwfxArray[m_cArray]->nBlockAlign = (xx / 8) * yy;
            m_lpwfxArray[m_cArray]->nAvgBytesPerSec = freq * (xx / 8) * yy;
            m_lpwfxArray[m_cArray]->cbSize = 0;
            m_cArray++;
        }
    }
    return S_OK;
}


// Helper function for GetMediaType
// Makes a note of all the formats we can output given our current input.
// If we have no input type yet, just get all the formats this tag can possibly
// produce. (NetShow will use that part)
//
HRESULT CACMWrapper::InitMediaTypes()
{
    HRESULT hr;
    MMRESULT mmr;
    DWORD dwSize;
    ACMFORMATDETAILS afd;
    LPWAVEFORMATEX lpwfxMapped;
    LPWAVEFORMATEX lpwfxEnum;
    LPWAVEFORMATEX lpwfxIn;
    if (m_pInput->IsConnected())
        lpwfxIn = (LPWAVEFORMATEX)m_pInput->CurrentMediaType().Format();
    else
        lpwfxIn = NULL;

    // we've been called before.
    if (m_cArray > 0)
        return NOERROR;

    DbgLog((LOG_TRACE, 2, TEXT("*** Enumerating our MediaTypes")));

    // Find out every type we can convert our input format into

    // How big is the biggest format?
    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &dwSize);
    if (mmr != 0)
        return E_FAIL;
    if (dwSize < sizeof(WAVEFORMATEX))
        dwSize = sizeof(WAVEFORMATEX) ;

    // Hack for VoxWare codec bug
    if (dwSize < 256)
        dwSize = 256;

    if (lpwfxIn == NULL)
        goto SkipSuggest;

    // The first thing we want to offer is ACM's suggested preferred format,
    // because that's usually the best choice.
    // But if we are converting PCM to PCM, then the first thing we want to
    // offer is the same format as the input format so we NEVER CONVERT by
    // default.
    // !!! We'll end up offering this twice, once now, once when we enum all
    m_lpwfxArray[0] = (LPWAVEFORMATEX)QzTaskMemAlloc(dwSize);
    if (m_lpwfxArray[0] == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(m_lpwfxArray[0], dwSize);

    if (m_wFormatTag == WAVE_FORMAT_PCM && lpwfxIn->wFormatTag ==
        WAVE_FORMAT_PCM) {
        CopyMemory(m_lpwfxArray[0], lpwfxIn, sizeof(WAVEFORMATEX));
        m_cArray = 1;
    } else {
        // ask for formats with a specific tag
        m_lpwfxArray[0]->wFormatTag = m_wFormatTag;


        if(lpwfxIn->wFormatTag != m_wSourceFormat)
        {
            // this is the typical case
            mmr = acmFormatSuggest(NULL, lpwfxIn, m_lpwfxArray[0], dwSize,
                ACM_FORMATSUGGESTF_WFORMATTAG);
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("*** InitMediaTypes: remapping input format %u to %u"), m_wSourceFormat, m_wTargetFormat));

            // should we bound this alloc/copy by dwSize to protect against a bogus cbSize?
            // but if we did we'd need to update the format's cbSize
            lpwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + lpwfxIn->cbSize);
            CopyMemory(lpwfxMapped, lpwfxIn, sizeof(WAVEFORMATEX) + lpwfxIn->cbSize);
            lpwfxMapped->wFormatTag = m_wTargetFormat;  // remap tags

            mmr = acmFormatSuggest(NULL, lpwfxMapped, m_lpwfxArray[0], dwSize, ACM_FORMATSUGGESTF_WFORMATTAG);
        }

        if (mmr == 0) {
            m_cArray = 1;       // OK, we have our first format
            if (m_lpwfxArray[0]->wFormatTag == WAVE_FORMAT_PCM)
                // not necessarily 0 in MSACM, but Quartz promises it will be
                m_lpwfxArray[0]->cbSize = 0;
        } else {
            QzTaskMemFree(m_lpwfxArray[0]);
        }
    }

SkipSuggest:

    // Now, if we are in PCM conversion mode, we want to construct all of the
    // formats we offer in some logical order, and not waste time asking ACM
    // which will not admit to 48000 and 32000, and offer bad quality formats
    // first, and take a long time to do it
    if (m_wFormatTag == WAVE_FORMAT_PCM && (lpwfxIn == NULL ||
        lpwfxIn->wFormatTag == WAVE_FORMAT_PCM)) {
        MakePCMMT(44100);
        MakePCMMT(22050);
        MakePCMMT(11025);
        MakePCMMT(8000);
        MakePCMMT(48000);       // done last so we'll connect to fussy filters
        hr = MakePCMMT(32000);  // but not prefer these wierd formats

        return hr;
    }

    lpwfxEnum = (LPWAVEFORMATEX)QzTaskMemAlloc(dwSize);
    if (lpwfxEnum == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(lpwfxEnum, dwSize);
    if (lpwfxIn == NULL)
        lpwfxEnum->wFormatTag = m_wFormatTag;

    // Now enum the formats we can convert our input format into
    ZeroMemory(&afd, sizeof(afd));
    afd.cbStruct = sizeof(afd);
    afd.pwfx = lpwfxEnum;
    afd.cbwfx = dwSize;
    afd.dwFormatTag = (lpwfxIn == NULL) ? m_wFormatTag : WAVE_FORMAT_UNKNOWN;

    if (lpwfxIn) {
        if (lpwfxIn->wFormatTag != m_wSourceFormat) {
            // typical case
            
            // ensure we don't copy more than the buffer size, in the case of a bogus cbSize.
            // note that the format we pass to acmFormatEnum assumes this, too.
            CopyMemory(lpwfxEnum, lpwfxIn, min( sizeof(WAVEFORMATEX) + lpwfxIn->cbSize, dwSize ) );
        } else {
            ASSERT(lpwfxMapped != NULL);
            ASSERT(lpwfxMapped->wFormatTag == m_wTargetFormat);

            // ensure we don't copy more than the buffer size, in the case of a bogus cbSize
            CopyMemory(lpwfxEnum, lpwfxMapped, min( sizeof(WAVEFORMATEX) + lpwfxMapped->cbSize, dwSize ) );
        }
    }

    if (lpwfxIn == NULL) {
        mmr = acmFormatEnum(NULL, &afd, (ACMFORMATENUMCB)FormatEnumCallback,
            (DWORD_PTR)this, ACM_FORMATENUMF_WFORMATTAG);
    } else {
        mmr = acmFormatEnum(NULL, &afd, (ACMFORMATENUMCB)FormatEnumCallback,
            (DWORD_PTR)this, ACM_FORMATENUMF_CONVERT);
    }

    if (mmr != 0) {
        DbgLog((LOG_ERROR, 1, TEXT("*acmFormatEnum FAILED! %d"), mmr));
        QzTaskMemFree(lpwfxEnum);
        return E_FAIL;
    }

    QzTaskMemFree(lpwfxEnum);
    return NOERROR;
}


//*****************************************************************************
//
// GetMediaType()
//
//
// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.

HRESULT CACMWrapper::GetMediaType(int iPosition, CMediaType *pmt)
{
#if 0   // NetShow needs to see possible outputs before connecting input
    // output types depend on input types... no input yet?
    // This is pointless!  We'll never get here if we're not connected
    if (!m_pInput->CurrentMediaType().IsValid())
        return VFW_E_NOT_CONNECTED;
#endif

    DbgLog((LOG_TRACE, 3, TEXT("CACMWrapper::GetMediaType %d"), iPosition));

    // Somebody called SetFormat().  Offer this first, instead of the
    // preferred format that normally heads our list
    if (m_lpwfxOutput && iPosition == 0) {
        return CreateAudioMediaType(m_lpwfxOutput, pmt, TRUE);
    }

    // figure out what we offer
    InitMediaTypes();

    if (m_cArray <= iPosition) {
        DbgLog((LOG_TRACE, 3, TEXT("No more formats")));
        return VFW_S_NO_MORE_ITEMS;
    }

    //DisplayType("*** Offering:",  pmt);
    LPWAVEFORMATEX lpwfx = m_lpwfxArray[iPosition];
    DbgLog((LOG_TRACE,3,TEXT("*** ACM giving tag:%d ch:%d freq:%d bits:%d"),
        lpwfx->wFormatTag, lpwfx->nChannels,
        lpwfx->nSamplesPerSec, lpwfx->wBitsPerSample));

    // Here it is!
    return CreateAudioMediaType(m_lpwfxArray[iPosition], pmt, TRUE);
}


//*****************************************************************************
//
// CheckTransform()
//
//

HRESULT CACMWrapper::CheckTransform(const CMediaType* pmtIn,
                                    const CMediaType* pmtOut)
{
    MMRESULT     mmr;
    WAVEFORMATEX *pwfxIn, *pwfxOut, *pwfxMapped;

    DbgLog((LOG_TRACE, 3, TEXT("CACMWrapper::CheckTransform")));

    //DisplayType("pmtIn:",  pmtIn);
    //DisplayType("pmtOut:", pmtOut);


    //---------------------  Do some format verification  -----------------------

    // we can't convert between toplevel types.
    if (*pmtIn->Type() != *pmtOut->Type()) {
        DbgLog((LOG_TRACE,3,TEXT("  pmtIn->Type != pmtOut->Type!")));
        return E_INVALIDARG;
    }

    // and we only accept audio
    if (*pmtIn->Type() != MEDIATYPE_Audio) {
        DbgLog((LOG_TRACE,3,TEXT("  pmtIn->Type != MEDIATYPE_Audio!")));
        return E_INVALIDARG;
    }

    // check this is a waveformatex
    if (*pmtOut->FormatType() != FORMAT_WaveFormatEx) {
        DbgLog((LOG_TRACE,3,TEXT("  pmtOut->FormatType != FORMAT_WaveFormatEx!")));
        return E_INVALIDARG;
    }

    // we only transform into formats with a specific tag
    if (((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag != m_wFormatTag) {
        DbgLog((LOG_TRACE,3,TEXT("  Wrong FormatTag! %d not %d"),
            ((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag, m_wFormatTag));
        return E_INVALIDARG;
    }

    //---------------------  See if ACM can do conversion  -----------------------

    pwfxIn  = (WAVEFORMATEX *)pmtIn->Format();
    pwfxOut = (WAVEFORMATEX *)pmtOut->Format();

    if(pwfxIn->wFormatTag != m_wSourceFormat)
    {
        // the usual case
        mmr = CallacmStreamOpen(NULL,
            NULL,
            pwfxIn,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            ACM_STREAMOPENF_QUERY | ACM_STREAMOPENF_NONREALTIME);

    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("*** CheckTransform: remapping input format %u to %u"), m_wSourceFormat, m_wTargetFormat));

        pwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        CopyMemory(pwfxMapped, pwfxIn, sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        pwfxMapped->wFormatTag = m_wTargetFormat;  // remap tags

        mmr = CallacmStreamOpen(NULL,
            NULL,
            pwfxMapped,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            ACM_STREAMOPENF_QUERY | ACM_STREAMOPENF_NONREALTIME);
    }

    if( mmr == 0 )
    {
        DbgLog((LOG_TRACE, 5, TEXT("  acmStreamOpen succeeded")));
        return NOERROR;
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("  acmStreamOpen failed, mmr = %u"),mmr));
    }


    return E_INVALIDARG;
}


//*****************************************************************************
//
// DecideBufferSize()
//
//  There is a design flaw in the Transform filter when it comes
//  to decompression, the Transform override doesn't allow a single
//  input buffer to map to multiple output buffers. This flaw exposes
//  a second flaw in DecideBufferSize, in order to determine the
//  output buffer size I need to know the input buffer size and
//  the compression ratio. Well, I don't have access to the input
//  buffer size and, more importantly, don't have a way to limit the
                                    //  input buffer size. For example, our new TrueSpeech(TM) codec has
//  a ratio of 12:1 compression and we get input buffers of 12K
//  resulting in an output buffer size of >144K.
//
//  To get around this flaw I overrode the Receive member and
//  made it capable of mapping a single input buffer to multiple
//  output buffers. This allows DecideBufferSize to choose a size
//  that it deems appropriate, in this case 1/4 second.
//


HRESULT CACMWrapper::DecideBufferSize( IMemAllocator * pAllocator,
                                      ALLOCATOR_PROPERTIES *pProperties )
{
    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::DecideBufferSize")));

    WAVEFORMATEX *pwfxOut = (WAVEFORMATEX *) m_pOutput->CurrentMediaType().Format();
    WAVEFORMATEX *pwfxIn  = (WAVEFORMATEX *) m_pInput->CurrentMediaType().Format();

    if (pProperties->cBuffers < 1)
        pProperties->cBuffers = 1;
    if (pProperties->cbBuffer < (LONG)pwfxOut->nAvgBytesPerSec / 4)
        pProperties->cbBuffer = pwfxOut->nAvgBytesPerSec / 4;
    if (pProperties->cbBuffer < (LONG)m_pOutput->CurrentMediaType().GetSampleSize())
        pProperties->cbBuffer = (LONG)m_pOutput->CurrentMediaType().GetSampleSize();
    if (pProperties->cbAlign < 1)
        pProperties->cbAlign = 1;
    // pProperties->cbPrefix = 0;

    DWORD cbStream;
    MMRESULT mmr;
    HACMSTREAM hacmStreamTmp;

    mmr = CallacmStreamOpen( &hacmStreamTmp
        , NULL
        , pwfxIn
        , pwfxOut
        , NULL
        , NULL
        , NULL
        , ACM_STREAMOPENF_NONREALTIME );
    if( mmr == 0 )
    {
        // Check with the decoder that this output buffer is big enough for at least a single
        // input data block.
        // Encoders like wma may use a large block align that will produce more than 1/4 second
        // of data
        mmr = acmStreamSize( hacmStreamTmp
            , pwfxIn->nBlockAlign
            , &cbStream
            , ACM_STREAMSIZEF_SOURCE );
        if( mmr == 0 && cbStream > (DWORD)pProperties->cbBuffer )
        {
            DbgLog( (LOG_TRACE
                , 2
                , TEXT("!Need a larger buffer size in CACMWrapper::DecideBufferSize cbStream needed = %d")
                , cbStream) );
            // just guard against ridiculously big buffers now that we allow for anything acm says (say 8 seconds?)
            if( pProperties->cbBuffer < (LONG)pwfxOut->nAvgBytesPerSec * 8 )
                pProperties->cbBuffer = cbStream;
#ifdef DEBUG
            else
                DbgLog( (LOG_TRACE
                , 1
                , TEXT("Error! CACMWrapper::DecideBufferSize cbStream exceeds limit, possibly bogus so ignoring...")
                , cbStream) );
#endif
        }
        acmStreamClose( hacmStreamTmp, 0 );
    }

    ALLOCATOR_PROPERTIES Actual;
    HRESULT hr = pAllocator->SetProperties(pProperties,&Actual);

    if( FAILED(hr) )
    {
        DbgLog((LOG_ERROR,1,TEXT("Allocator doesn't like properties")));
        return hr;
    }
    if( Actual.cbBuffer < pProperties->cbBuffer )
    {
        // can't use this allocator
        DbgLog((LOG_ERROR,1,TEXT("Allocator buffers too small")));
        DbgLog((LOG_ERROR,1,TEXT("Got %d, need %d"), Actual.cbBuffer,
            m_pOutput->CurrentMediaType().GetSampleSize()));
        return E_INVALIDARG;
    }

    return S_OK;
}


//*****************************************************************************
//
// StartStreaming()
//
//

HRESULT CACMWrapper::StartStreaming()
{
    MMRESULT     mmr;
    WAVEFORMATEX *pwfxIn, *pwfxOut, *pwfxMapped;
    CAutoLock    lock(&m_csFilter);


    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::StartStreaming")));


    pwfxIn  = (WAVEFORMATEX *)m_pInput->CurrentMediaType().Format();
    pwfxOut = (WAVEFORMATEX *)m_pOutput->CurrentMediaType().Format();

    if(pwfxIn->wFormatTag != m_wSourceFormat)
    {

        mmr = CallacmStreamOpen(&m_hacmStream,
            NULL,
            pwfxIn,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            // this is what VFW did
            ACM_STREAMOPENF_NONREALTIME);
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("*** StartStreaming: remapping input format %u to %u"), m_wSourceFormat, m_wTargetFormat));

        pwfxMapped = (LPWAVEFORMATEX)_alloca(sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        CopyMemory(pwfxMapped, pwfxIn, sizeof(WAVEFORMATEX) + pwfxIn->cbSize);
        pwfxMapped->wFormatTag = m_wTargetFormat;  // remap tags

        mmr = CallacmStreamOpen(&m_hacmStream,
            NULL,
            pwfxMapped,
            pwfxOut,
            NULL,
            NULL,
            NULL,
            // this is what VFW did
            ACM_STREAMOPENF_NONREALTIME);
    }

    if( mmr == 0 )
    {
        m_bStreaming = TRUE;
        DbgLog((LOG_TRACE, 5, TEXT("  acmStreamOpen succeeded")));

        // If our input samples are not time stamped, make some time stamps up by
        // using the number they would be based on the stream's avg bytes per sec
        // This won't account for discontinuities, etc, but it's better than
        // nothing
        m_tStartFake = 0;

        // also, at this time, save the "average bytes per sec" that we play
        // out of the output pin. This will be used to adjust the time
        // stamps of samples.
        m_nAvgBytesPerSec = pwfxOut->nAvgBytesPerSec ;
        DbgLog((LOG_TRACE,2,TEXT("Output nAvgBytesPerSec =  %lu"), m_nAvgBytesPerSec));

        return NOERROR;
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("  acmStreamOpen failed, mmr = %u"),mmr));
    }

    return E_INVALIDARG;
}


HRESULT CACMWrapper::EndFlush()
{
    CAutoLock lock(&m_csFilter);

    // forget any pending conversion - wait till EndFlush because otherwise
    // we could be in the middle of a Receive
    CAutoLock lock2(&m_csReceive);// OK, call me paranoid
    if (m_lpExtra) {
        QzTaskMemFree(m_lpExtra);
        m_cbExtra = 0;
        m_lpExtra = NULL;
    }

    return CTransformFilter::EndFlush();
}


//*****************************************************************************
//
// StopStreaming()
//
//

HRESULT CACMWrapper::StopStreaming()
{
    HRESULT    mmr;
    CAutoLock lock(&m_csFilter);


    DbgLog((LOG_TRACE, 2, TEXT("CACMWrapper::StopStreaming")));

    if( m_bStreaming )
    {
        mmr = acmStreamClose( m_hacmStream, 0 );
        if( mmr != 0 )
        {
            DbgLog((LOG_ERROR, 1, TEXT("  acmStreamClose failed!")));
        }

        m_hacmStream = NULL;
        m_bStreaming = FALSE;
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("*** StopStreaming called when not streaming!")));
    }

    // forget any pending conversion
    CAutoLock lock2(&m_csReceive);// we'll blow up if Receive is using it
    if (m_lpExtra) {
        QzTaskMemFree(m_lpExtra);
        m_cbExtra = 0;
        m_lpExtra = NULL;
    }

    return NOERROR;
}


HRESULT CACMWrapper::Transform( IMediaSample *pIn, IMediaSample *pOut )
{
    DbgLog((LOG_ERROR, 1, TEXT("*** CACMWrapper->Transform() called!")));
    return S_FALSE;   // ???
}


HRESULT CACMWrapper::ProcessSample(BYTE *pbSrc, LONG cbSample,
                                   IMediaSample *pOut, LONG *pcbUsed,
                                   LONG *pcbDstUsed, BOOL fBlockAlign)
{
    HRESULT   hr;
    BYTE      *pbDst;
    LONG      cbDestBuffer, cbStream;

    // Don't take the filter lock in Receive, you FOOL!!
    // CAutoLock lock(&m_csFilter);


    DbgLog((LOG_TRACE, 5, TEXT("CACMWrapper::ProcessSample")));

    *pcbUsed = 0;
    *pcbDstUsed = 0;

    hr = pOut->GetPointer(&pbDst);
    if( !FAILED(hr) )
    {
        MMRESULT        mmr;
        ACMSTREAMHEADER acmSH;

        DbgLog((LOG_TRACE, 9, TEXT("  pOut->GetPointer succeeded")));

        hr = S_FALSE;

        cbDestBuffer = pOut->GetSize();

        mmr = acmStreamSize( m_hacmStream, (DWORD)cbDestBuffer,
            (DWORD *)&cbStream, ACM_STREAMSIZEF_DESTINATION );
        if( mmr == 0 )
        {
            DbgLog((LOG_TRACE, 9, TEXT("  cbStream = %d"),cbStream));


            memset(&acmSH,0,sizeof(acmSH));

            acmSH.cbStruct    = sizeof(acmSH);

            acmSH.pbSrc       = pbSrc;

            // !!! trick PrepareHeader into succeeding... it will fail if
            // we tell it how many bytes we're actually converting (cbSample)
            // if it's smaller than what's necessary to make a destination block
            // size
            int cbHack = min(cbStream, cbSample);
            int cbAlign = ((LPWAVEFORMATEX)m_pOutput->CurrentMediaType().Format())
                ->nBlockAlign;
            int cbSrcAlign;
            mmr = acmStreamSize(m_hacmStream, (DWORD)cbAlign,
                (DWORD *)&cbSrcAlign, ACM_STREAMSIZEF_DESTINATION);
            if (mmr == 0 && cbHack < cbSrcAlign) {
                cbHack = cbSrcAlign;
                DbgLog((LOG_TRACE,4,TEXT("Hacking PrepareHeader size to %d"),
                    cbHack));
            }
            acmSH.cbSrcLength = cbHack;

            acmSH.pbDst       = pbDst;
            acmSH.cbDstLength = (DWORD)cbDestBuffer;

            DbgLog((LOG_TRACE, 6, TEXT("  Calling acmStreamPrepareHeader")));
            DbgLog((LOG_TRACE, 6, TEXT("    pbSrc       = 0x%.8X"), acmSH.pbSrc));
            DbgLog((LOG_TRACE, 6, TEXT("    cbSrcLength = %u"),     acmSH.cbSrcLength));
            DbgLog((LOG_TRACE, 6, TEXT("    pbDst       = 0x%.8X"), acmSH.pbDst));
            DbgLog((LOG_TRACE, 6, TEXT("    cbDstLength = %u"),     acmSH.cbDstLength));

            mmr = acmStreamPrepareHeader( m_hacmStream, &acmSH, 0 );

            // now set the source length to the proper conversion size to be done
            acmSH.cbSrcLength = min(cbStream, cbSample);

            if( mmr == 0 )
            {
                DbgLog((LOG_TRACE, 5, TEXT("  Calling acmStreamConvert")));

                mmr = acmStreamConvert(m_hacmStream, &acmSH,
                    fBlockAlign? ACM_STREAMCONVERTF_BLOCKALIGN : 0);

                // now put it back to what it was for Prepare so Unprepare works
                acmSH.cbSrcLength = cbHack;

                if( mmr == 0 )
                {
                    DbgLog((LOG_TRACE, 6, TEXT("  acmStreamConvert succeeded")));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbSrcLength     = %u"),acmSH.cbSrcLength));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbSrcLengthUsed = %u"),acmSH.cbSrcLengthUsed));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbDstLength     = %u"),acmSH.cbDstLength));
                    DbgLog((LOG_TRACE, 6, TEXT("    cbDstLengthUsed = %u"),acmSH.cbDstLengthUsed));

                    hr = NOERROR;

                    *pcbUsed = acmSH.cbSrcLengthUsed;
                    *pcbDstUsed = acmSH.cbDstLengthUsed;

                    pOut->SetActualDataLength( acmSH.cbDstLengthUsed );
                }
                else
                {
                    DbgLog((LOG_ERROR, 1, TEXT("  acmStreamConvert failed, mmr = %u"),mmr));
                }

                // acmStreamUnprepareHeader()'s documentation states "An application must
                // specify the source and destination buffer lengths (cbSrcLength and
                // cbDstLength, respectively) that were used during a call to the
                // corresponding acmStreamPrepareHeader. Failing to reset these member
                // values will cause acmStreamUnprepareHeader to fail with an
                // MMSYSERR_INVALPARAM error." (MSDN July 2000).  This code ensures that
                // cbDstLength contains the same value used to call acmStreamPrepareHeader().
                DbgLog((LOG_TRACE, 9, TEXT("  setting cbDstLength ")));
                acmSH.cbDstLength = cbDestBuffer;

                DbgLog((LOG_TRACE, 9, TEXT("  calling acmStreamUnprepareHeader")));
                mmr = acmStreamUnprepareHeader( m_hacmStream, &acmSH, 0 );
                if( mmr != 0 )
                {
                    DbgLog((LOG_ERROR, 1, TEXT("  acmStreamUnprepareHeader failed, mmr = %u"),mmr));
                }
            }
            else
            {
                DbgLog((LOG_TRACE,4,TEXT("  acmStreamPrepareHeader failed, mmr = %u"),mmr));
            }
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("  acmStreamSize failed, mmr = %u"),mmr));
        }
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("*** pOut->GetPointer() failed")));
    }

    DbgLog((LOG_TRACE, 9, TEXT("  returning hr = %u"),hr));

    return hr;
}


//*****************************************************************************
//
// Receive()
//
//
//

HRESULT CACMWrapper::Receive( IMediaSample *pInSample )
{
    HRESULT      hr = NOERROR;
    CRefTime     tStart, tStop, tIntStop;
    IMediaSample *pOutSample;

    CAutoLock lock(&m_csReceive);

    BYTE *pbSample;
    LONG  cbSampleLength, cbUsed, cbDstUsed;

    AM_MEDIA_TYPE *pmt;
    pInSample->GetMediaType(&pmt);
    if (pmt != NULL && pmt->pbFormat != NULL)
    {
        // spew some debug output
        ASSERT(!IsEqualGUID(pmt->majortype, GUID_NULL));
#ifdef DEBUG
        WAVEFORMATEX *pwfx = (WAVEFORMATEX *) pmt->pbFormat;
        DbgLog((LOG_TRACE,1,TEXT("*Changing input type on the fly to %d channel %d bit %dHz"),
            pwfx->nChannels, pwfx->wBitsPerSample, pwfx->nSamplesPerSec));
#endif

        // now switch to using the new format.  I am assuming that the
        // derived filter will do the right thing when its media type is
        // switched and streaming is restarted.

        StopStreaming();
        m_pInput->CurrentMediaType() = *pmt;
        DeleteMediaType(pmt);
        // not much we can do if this fails
        hr = StartStreaming();
    }

    cbSampleLength = pInSample->GetActualDataLength();

    DbgLog((LOG_TRACE, 4, TEXT("Received %d samples"), cbSampleLength));

    // this is a discontinuity.  we better send any extra stuff that was pending
    // separately from the new stuff we got
    if (pInSample->IsDiscontinuity() == S_OK) {
        DbgLog((LOG_TRACE,4,TEXT("Discontinuity - Sending extra bytes NOW")));
        SendExtraStuff();
        // !!! if this fails, throw it away, or leave it prepended?
    }

    // get input start and stop times, or fake them up

    int nAvgBytes = ((WAVEFORMATEX *)m_pInput->CurrentMediaType().Format())
        ->nAvgBytesPerSec;
    hr = pInSample->GetTime((REFERENCE_TIME *)&tStart, (REFERENCE_TIME *)&tStop);
    if (FAILED(hr)) {
        // If we have no time stamps, make some up using a best guess
        tStart = m_tStartFake;
        tStop = tStart + (cbSampleLength * UNITS) / nAvgBytes;
        DbgLog((LOG_TRACE,5,TEXT("No time stamps... faking them")));
    }
    // the next fake number will be this...
    m_tStartFake = tStop;

    pInSample->GetPointer( &pbSample );

    DbgLog((LOG_TRACE, 5, TEXT("Total Sample: Start = %s End = %s"),
        (LPCTSTR)CDisp((LONGLONG)(tStart),CDISP_HEX),
        (LPCTSTR)CDisp((LONGLONG)(tStop),CDISP_HEX)));

    // We have extra stuff left over from the last Receive.  We need to do
    // that first, and then get on with the new stuff
    if (m_cbExtra) {
        DbgLog((LOG_TRACE,4,TEXT("Still %d bytes left from last time"),
            m_cbExtra));
        m_cbExtra += cbSampleLength;
        LPBYTE lpSave = m_lpExtra;
        m_lpExtra = (LPBYTE)QzTaskMemAlloc(m_cbExtra);
        if (m_lpExtra == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Extra bytes - Out of memory!")));
            m_cbExtra = 0;
            return E_OUTOFMEMORY;
        }
        CopyMemory(m_lpExtra, lpSave, m_cbExtra - cbSampleLength);
        QzTaskMemFree(lpSave);
        CopyMemory(m_lpExtra + m_cbExtra - cbSampleLength, pbSample,
            cbSampleLength);
        pbSample = m_lpExtra;
        cbSampleLength = m_cbExtra;

        // the time stamp we got above is for the beginning of the new data.
        // we need to go back to the time of the extra bits we're doing first
        tStart -= m_rtExtra;
    }

    cbDstUsed = 10000;    // don't quit yet
    while(cbSampleLength > 0 && cbDstUsed > 0)
    {
        hr = m_pOutput->GetDeliveryBuffer( &pOutSample, NULL, NULL, 0 );
        if( FAILED(hr) )
        {
            DbgLog((LOG_ERROR, 1, TEXT("GetDeliveryBuffer(pOutSample) failed, hr = %x"),hr));
            return hr;
        }

        pOutSample->SetSyncPoint( pInSample->IsSyncPoint() == S_OK );
        pOutSample->SetDiscontinuity( pInSample->IsDiscontinuity() == S_OK );

        MSR_START(m_idTransform);


        //
        //    // have the derived class transform the data
        //    hr = Transform( pSample, pOutSample );
        //

        hr = ProcessSample(pbSample, cbSampleLength, pOutSample, &cbUsed, &cbDstUsed
            ,TRUE);

        //  MPEG can consume data without outputting any
        //ASSERT(cbDstUsed > 0 || cbUsed == 0);

        if( cbUsed <= cbSampleLength )
        {
            cbSampleLength -= cbUsed;
            pbSample       += cbUsed;
            DbgLog((LOG_TRACE,4,TEXT("turned %d bytes into %d:  %d left"), cbUsed,
                cbDstUsed, cbSampleLength));
        }
        else
        {
            DbgLog((LOG_ERROR,1,TEXT("*** cbUsed > cbSampleLength!")));
            cbSampleLength = 0;
        }

        // Hmm... ACM didn't convert anything (it doesn't have enough data)
        // That's bad.  Let's remember the rest for next time and do that first.
        //  (If there is no next time, then they weren't important).
        if (cbDstUsed == 0 && cbSampleLength != 0) {
            DbgLog((LOG_TRACE,4,TEXT("We will have %d bytes left"),cbSampleLength));
            // remember, pbSample may point somewhere in m_lpExtra's buffer!
            if (m_lpExtra) {
                CopyMemory(m_lpExtra, pbSample, cbSampleLength);
            } else {
                m_lpExtra = (LPBYTE)QzTaskMemAlloc(cbSampleLength);
                if (m_lpExtra)
                    CopyMemory(m_lpExtra, pbSample, cbSampleLength);
            }
            if (m_lpExtra) {
                m_cbExtra = cbSampleLength;
                // when we finally do this left over stuff, this is how much
                // earlier stuff there is to do
                m_rtExtra = tStop - tStart;
            } else {
                DbgLog((LOG_ERROR,1,TEXT("Extra memory - Out of memory!")));
                m_cbExtra = 0;
                hr = E_OUTOFMEMORY;
            }
        }

        // we used up everything, and there is nothing left over for next time
        if (hr == NOERROR && 0 == cbSampleLength) {
            DbgLog((LOG_TRACE,4,TEXT("We used up everything we had!")));
            m_cbExtra = 0;
            QzTaskMemFree(m_lpExtra);
            m_lpExtra = NULL;
        }


        // adjust the start and stop times based on the amount of data used up.
        LONGLONG tDelta = (cbDstUsed * UNITS) / m_nAvgBytesPerSec ;
        tIntStop = tStart + tDelta ;

        pOutSample->SetTime( (REFERENCE_TIME *) &tStart,
            (REFERENCE_TIME *) &tIntStop );

        DbgLog((LOG_TRACE, 5, TEXT("  Breaking up: Start = %s End = %s"),
            (LPCTSTR)CDisp((LONGLONG)(tStart),CDISP_HEX),
            (LPCTSTR)CDisp((LONGLONG)(tIntStop),CDISP_HEX)));

        tStart += tDelta ;


        // Stop the clock and log it (if PERF is defined)
        MSR_STOP(m_idTransform);

        if(FAILED(hr))
        {
            DbgLog((LOG_ERROR,1,TEXT("Error from transform")));
            pOutSample->Release();
            return hr;
        }


        // the Transform() function can return S_FALSE to indicate that the
        // sample should not be delivered; we only deliver the sample if it's
        // really S_OK (same as NOERROR, of course.)

        // pretend nothing went wrong, but dont' deliver it, just GET OUT
        // OF HERE!
        if (hr == S_FALSE)
        {
            pOutSample->Release();
            hr = NOERROR;
            break;
        }

        // don't deliver empty samples
        if (hr == NOERROR && cbDstUsed)
        {
            DbgLog((LOG_TRACE,4,TEXT("Delivering...")));
            hr = m_pOutput->Deliver(pOutSample);
            if (hr != S_OK) {
                pOutSample->Release();
                break;
            }
        }

        // release the output buffer. If the connected pin still needs it,
        // it will have addrefed it itself.
        pOutSample->Release();

   }

   //tIntStop at this point should be same as tStop ??
   DbgLog((LOG_TRACE, 5, TEXT("  tStop = %s tIntStop = %s"),
       (LPCTSTR)CDisp((LONGLONG)(tStop),CDISP_HEX),
       (LPCTSTR)CDisp((LONGLONG)(tIntStop),CDISP_HEX)));


   return hr;
}


// send our leftover data
//
HRESULT CACMWrapper::SendExtraStuff()
{
    int cbAlign, cbSrcAlign;

    // nothing extra to send
    if (m_cbExtra == 0)
        return NOERROR;

    // wait till receive finishes processing what it has
    CAutoLock lock(&m_csReceive);
    DbgLog((LOG_TRACE,2,TEXT("Processing remaining %d bytes"), m_cbExtra));

    IMediaSample *pOutSample;
    CRefTime tStart, tStop;
    HRESULT hr = m_pOutput->GetDeliveryBuffer(&pOutSample, NULL, NULL, 0);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR,1,TEXT("GetBuffer failed: can't deliver last bits")));
        return hr;
    }
    pOutSample->SetSyncPoint(TRUE);             // !!!
    pOutSample->SetDiscontinuity(FALSE);

    // !!! ProcessSample is going to have to lie about the size of the input
    // to work around an ACM bug, so we may have to grow the size of
    // our input to be as big as we are going to lie and say it is
    cbAlign = ((LPWAVEFORMATEX)m_pOutput->CurrentMediaType().Format())
        ->nBlockAlign;
    MMRESULT mmr = acmStreamSize(m_hacmStream, (DWORD)cbAlign,
        (DWORD *)&cbSrcAlign, ACM_STREAMSIZEF_DESTINATION);
    if (mmr == 0 && m_cbExtra < cbSrcAlign) {
        DbgLog((LOG_TRACE,4,TEXT("Growing m_lpExtra to lie to ACM")));
        LPBYTE lpExtra = (LPBYTE)QzTaskMemRealloc(m_lpExtra, cbSrcAlign);
        // don't update m_cbExtra... that's the real amount of data
        if (lpExtra == NULL) {
            DbgLog((LOG_ERROR,1,TEXT("Out of memory growing m_lpExtra")));
            pOutSample->Release();
            return E_OUTOFMEMORY;
        }
        m_lpExtra = lpExtra;
    }

    LONG cbUsed, cbDstUsed;
    // Do NOT block align the last bits... there isn't enough
    hr = ProcessSample(m_lpExtra, m_cbExtra, pOutSample, &cbUsed, &cbDstUsed,
        FALSE);

    // !!! nothing we can do if it anything's left over?
    DbgLog((LOG_TRACE,4,TEXT("turned %d bytes into %d:  %d left"), cbUsed,
        cbDstUsed, m_cbExtra - cbUsed));

    // well, no more extra stuff
    m_cbExtra = 0;
    QzTaskMemFree(m_lpExtra);
    m_lpExtra = NULL;

    if (cbDstUsed == 0) {
        DbgLog((LOG_ERROR,1,TEXT("can't convert last bits")));
        pOutSample->Release();
        return E_FAIL;
    }

    // set the start and stop times based on the amount of data used up.
    tStart = m_tStartFake - m_rtExtra;
    tStop = tStart + (cbDstUsed * UNITS) / m_nAvgBytesPerSec ;
    pOutSample->SetTime((REFERENCE_TIME *)&tStart, (REFERENCE_TIME *)&tStop);

    hr = m_pOutput->Deliver(pOutSample);
    pOutSample->Release();

    DbgLog((LOG_TRACE, 5, TEXT("Extra time stamps: tStart=%s tStop=%s"),
        (LPCTSTR)CDisp((LONGLONG)(tStart),CDISP_HEX),
        (LPCTSTR)CDisp((LONGLONG)(tStop),CDISP_HEX)));

    return NOERROR;
}


// overridden to send the leftover data
//
HRESULT CACMWrapper::EndOfStream()
{
    SendExtraStuff();
    return CTransformFilter::EndOfStream();
}


// overridden to complete our fancy reconnection footwork
//
HRESULT CACMWrapper::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt)
{
    HRESULT hr;

    // Set the OUTPUT type.
    if (direction == PINDIR_OUTPUT) {

        DbgLog((LOG_TRACE,2,TEXT("*Set OUTPUT type tag:%d %dbit %dchannel %dHz")
            ,((LPWAVEFORMATEX)(pmt->Format()))->wFormatTag,
            ((LPWAVEFORMATEX)(pmt->Format()))->wBitsPerSample,
            ((LPWAVEFORMATEX)(pmt->Format()))->nChannels,
            ((LPWAVEFORMATEX)(pmt->Format()))->nSamplesPerSec));

        // Uh oh.  As part of our fancy footwork we may be being asked to
        // provide a media type we cannot provide unless we reconnect our
        // input pin to provide a different type
        if (m_pInput && m_pInput->IsConnected()) {

            // If we can actually provide this type now, don't worry
            hr = CheckTransform(&m_pInput->CurrentMediaType(),
                &m_pOutput->CurrentMediaType());
            if (hr == NOERROR)
                return hr;

            DbgLog((LOG_TRACE,2,TEXT("*Set OUTPUT requires RECONNECT of INPUT!")));

            // Oh boy. Reconnect our input pin.  Cross your fingers.
            return m_pGraph->Reconnect(m_pInput);

        }

        return NOERROR;
    }

    // some invalid formats have non-zero cbSize with PCM, which makes me blow
    // up
    ASSERT(((LPWAVEFORMATEX)(pmt->Format()))->wFormatTag != WAVE_FORMAT_PCM ||
        ((LPWAVEFORMATEX)(pmt->Format()))->cbSize == 0);


    DbgLog((LOG_TRACE,2,TEXT("*Set INPUT type tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->Format()))->wFormatTag,
        ((LPWAVEFORMATEX)(pmt->Format()))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->Format()))->nChannels,
        ((LPWAVEFORMATEX)(pmt->Format()))->nSamplesPerSec));

    // we have a new input type, we need to recalculate the types we can
    // provide
    while (m_cArray-- > 0)
        QzTaskMemFree(m_lpwfxArray[m_cArray]);
    m_cArray = 0;       // will be -1 if it started out at 0

    hr = CheckInputType(pmt);  // refresh acm codec mapper cache
    if(FAILED(hr))
        return hr;
    m_wSourceFormat = m_wCachedSourceFormat;
    m_wTargetFormat = m_wCachedTargetFormat;

    // If we accept an input type that requires changing our output type,
    // we need to do this, but only if necessary, or we'll infinite loop
#if 0
    ASSERT(direction == PINDIR_INPUT);

    // If we can actually do this right now, don't bother reconnecting
    hr = CheckTransform(&m_pInput->CurrentMediaType(),
        &m_pOutput->CurrentMediaType());
    if (hr == NOERROR)
        return hr;

    if (m_pOutput && m_pOutput->IsConnected()) {
        DbgLog((LOG_TRACE,2,TEXT("***Changing IN when OUT already connected")));
        return ((CACMOutputPin *)m_pOutput)->Reconnect();
    }
#endif

    // !!! TEST
#if 0
    int i, z;
    AM_MEDIA_TYPE *pmtx;
    AUDIO_STREAM_CONFIG_CAPS ascc;
    ((CACMOutputPin *)m_pOutput)->GetNumberOfCapabilities(&i);
    DbgLog((LOG_TRACE,1,TEXT("We support %d caps"), i));
    for (z=0; z<i; z++) {
        ((CACMOutputPin *)m_pOutput)->GetStreamCaps(z, &pmtx, &ascc);
        DbgLog((LOG_TRACE,1,TEXT("%d: %d"), z,
            ((LPWAVEFORMATEX)pmtx->pbFormat)->wFormatTag));
    }
    DeleteMediaType(pmtx);
#endif

    return NOERROR;
}


HRESULT CACMWrapper::BreakConnect(PIN_DIRECTION direction)
{
    // our possible output formats change if input is not connected
    if (direction == PINDIR_INPUT) {
        while (m_cArray-- > 0)
            QzTaskMemFree(m_lpwfxArray[m_cArray]);
        m_cArray = 0;   // will be -1 if it started out at 0
    }
    return CTransformFilter::BreakConnect(direction);
}


// override to have a special output pin
//
CBasePin * CACMWrapper::GetPin(int n)
{
    HRESULT hr = S_OK;

    DbgLog((LOG_TRACE,5,TEXT("CACMWrapper::GetPin")));

    // Check for valid input
    if (n != 0 && n != 1)
    {
        DbgLog((LOG_ERROR,1,TEXT("CACMWrapper::GetPin: Invalid input parameter")));
        return NULL;
    }

    // Create pins if necessary

    if (m_pInput == NULL) {

        DbgLog((LOG_TRACE,2,TEXT("Creating an input pin")));

        m_pInput = new CTransformInputPin(NAME("Transform input pin"),
            this,              // Owner filter
            &hr,               // Result code
            L"Input");         // Pin name


        if (FAILED(hr) || m_pInput == NULL) {
            return NULL;
        }

        // Create the output pin

        DbgLog((LOG_TRACE,2,TEXT("Creating an output pin")));

        m_pOutput = new CACMOutputPin(NAME("Transform output pin"),
            this,            // Owner filter
            &hr,             // Result code
            L"Output");      // Pin name

        if (FAILED(hr) || m_pOutput == NULL) {
            // delete the input pin
            delete m_pInput;
            m_pInput = NULL;
            return NULL;
        }
    }


    // Return the appropriate pin

    if (0 == n)
        return m_pInput;
    else if (1 == n)
        return m_pOutput;
    else
        return NULL;
}


// --- CACMOutputPin ----------------------------------------

/*
CACMOutputPin constructor
*/
CACMOutputPin::CACMOutputPin(
                             TCHAR              * pObjectName,
                             CACMWrapper        * pFilter,
                             HRESULT            * phr,
                             LPCWSTR              pPinName) :

CTransformOutputPin(pObjectName, pFilter, phr, pPinName),
m_pFilter(pFilter),
m_pPosition(NULL),
m_cFormatTags(0)
{
    DbgLog((LOG_TRACE,2,TEXT("*Instantiating the CACMOutputPin")));

    // !!! TESTING ONLY
#if 0
    CMediaType cmt;
    WAVEFORMATEX wfx;

    wfx.wFormatTag = WAVE_FORMAT_PCM;
    wfx.wBitsPerSample = 16;
    wfx.nChannels = 2;
    wfx.nSamplesPerSec = 44100;
    wfx.nBlockAlign = 4;
    wfx.nAvgBytesPerSec = 44100 * 2 * 2;
    wfx.cbSize = 0;

    cmt.SetType(&MEDIATYPE_Audio);
    cmt.SetSubtype(&GUID_NULL);
    cmt.SetFormatType(&FORMAT_WaveFormatEx);
    cmt.SetTemporalCompression(FALSE);
    cmt.SetSampleSize(4);

    cmt.AllocFormatBuffer(sizeof(wfx));
    CopyMemory(cmt.Format(), &wfx, sizeof(wfx));

    SetFormat(&cmt);
#endif
}

CACMOutputPin::~CACMOutputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("*Destroying the CACMOutputPin")));
    if (m_pPosition)
        delete m_pPosition;
};


// overriden to expose IMediaPosition and IMediaSeeking control interfaces
// and all the capture interfaces we support
// !!! The base classes change all the time and I won't pick up their bug fixes!
STDMETHODIMP CACMOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));
    *ppv = NULL;

    DbgLog((LOG_TRACE,99,TEXT("QI on CACMOutputPin")));

    if (riid == IID_IAMStreamConfig) {
        return GetInterface((LPUNKNOWN)(IAMStreamConfig *)this, ppv);
    }

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        if (m_pPosition == NULL) {
            HRESULT hr = S_OK;
            m_pPosition = new CACMPosPassThru(NAME("ACM PosPassThru"),
                GetOwner(),
                &hr,
                (IPin *)m_pFilter->m_pInput);
            if (m_pPosition == NULL) {
                return E_OUTOFMEMORY;
            }
            if (FAILED(hr)) {
                delete m_pPosition;
                m_pPosition = NULL;
                return hr;
            }
        }
        return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    } else {
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }
}


// Overridden to do fancy reconnecting footwork to allow a chain of 3 ACM
// filters to be found by the filtergraph.
//
HRESULT CACMOutputPin::CheckMediaType(const CMediaType *pmtOut)
{
    DWORD j;
    HRESULT hr;
    CMediaType *pmtEnum;
    BOOL fFound = FALSE;
    IEnumMediaTypes *pEnum;

    if (!m_pFilter->m_pInput->IsConnected()) {
        DbgLog((LOG_TRACE,3,TEXT("Input not connected")));
        return VFW_E_NOT_CONNECTED;
    }

    // There's no way we can do anything but audio
    if (*pmtOut->FormatType() != FORMAT_WaveFormatEx) {
        DbgLog((LOG_TRACE,3,TEXT("Format type not WaveFormatEx")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    if ( pmtOut->majortype != MEDIATYPE_Audio) {
        DbgLog((LOG_TRACE,3,TEXT("Type not Audio")));
        return VFW_E_INVALIDMEDIATYPE;
    }
    if ( pmtOut->FormatLength() < sizeof(PCMWAVEFORMAT)) {
        DbgLog((LOG_TRACE,3,TEXT("Format length too small")));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // Somebody called SetFormat, so don't accept anything that isn't that.
    if (m_pFilter->m_lpwfxOutput) {
        LPWAVEFORMATEX lpwfxTry = (LPWAVEFORMATEX)pmtOut->Format();
        if (m_pFilter->m_lpwfxOutput->cbSize != lpwfxTry->cbSize) {
            DbgLog((LOG_TRACE,3,TEXT("Only accepting one thing")));
            return VFW_E_INVALIDMEDIATYPE;
        }
        if (_fmemcmp(lpwfxTry, m_pFilter->m_lpwfxOutput, lpwfxTry->cbSize) != 0)
        {
            DbgLog((LOG_TRACE,3,TEXT("Only accepting one thing")));
            return VFW_E_INVALIDMEDIATYPE;
        }
    }

    // we only transform into formats with a specific tag - there's no sense
    // wasting time trying to see if reconnecting our input will help.  We know
    // right now we should fail.
    if (((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag !=
        m_pFilter->m_wFormatTag) {
        DbgLog((LOG_TRACE,3,TEXT("  Wrong FormatTag! %d not %d"),
            ((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag,
            m_pFilter->m_wFormatTag));
        return VFW_E_INVALIDMEDIATYPE;
    }

    // We can accept this output type like normal; nothing fancy required
    hr = m_pFilter->CheckTransform(&m_pFilter->m_pInput->CurrentMediaType(),
        pmtOut);
    if (hr == NOERROR)
        return hr;

    DbgLog((LOG_TRACE,3,TEXT("*We can't accept this output media type")));
    DbgLog((LOG_TRACE,3,TEXT(" tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmtOut->Format()))->wFormatTag,
        ((LPWAVEFORMATEX)(pmtOut->Format()))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmtOut->Format()))->nChannels,
        ((LPWAVEFORMATEX)(pmtOut->Format()))->nSamplesPerSec));
    DbgLog((LOG_TRACE,3,TEXT(" But how about if we reconnected our input...")));
    DbgLog((LOG_TRACE,3,TEXT(" Current input: tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->wFormatTag,
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->wBitsPerSample,
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->nChannels,
        ((LPWAVEFORMATEX)m_pFilter->m_pInput->CurrentMediaType().Format())->nSamplesPerSec));

    // Now let's get fancy.  We could accept this type if we reconnected our
    // input pin... in other words if the guy our input pin is connected to
    // could provide a type that we could convert into the necessary type
    hr = m_pFilter->m_pInput->GetConnected()->EnumMediaTypes(&pEnum);
    if (hr != NOERROR)
        return E_FAIL;
    while (1) {
        hr = pEnum->Next(1, (AM_MEDIA_TYPE **)&pmtEnum, &j);

        // all out of enumerated types
        if (hr == S_FALSE || j == 0) {
            break;
        }

        // can we convert between these?
        hr = m_pFilter->CheckTransform(pmtEnum, pmtOut);

        if (hr != NOERROR) {
            DeleteMediaType(pmtEnum);
            continue;
        }

        // OK, it offers the type, and we like it, but will it accept it NOW?
        hr = m_pFilter->m_pInput->GetConnected()->QueryAccept(pmtEnum);
        // nope
        if (hr != NOERROR) {
            DeleteMediaType(pmtEnum);
            continue;
        }
        // OK, I'm satisfied
        fFound = TRUE;
        DbgLog((LOG_TRACE,2,TEXT("*We can only accept this output type if we reconnect")));
        DbgLog((LOG_TRACE,2,TEXT("our input to tag:%d %dbit %dchannel %dHz"),
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->wFormatTag,
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->wBitsPerSample,
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->nChannels,
            ((LPWAVEFORMATEX)(pmtEnum->pbFormat))->nSamplesPerSec));
        // all done with this
        DeleteMediaType(pmtEnum);
        break;
    }
    pEnum->Release();

    if (!fFound)
        DbgLog((LOG_TRACE,3,TEXT("*NO! Reconnecting our input won't help")));

    return fFound ? NOERROR : VFW_E_INVALIDMEDIATYPE;
}

// overridden just so we can cleanup after the acm codec mapper
HRESULT CACMOutputPin::BreakConnect()
{
    m_pFilter->ACMCodecMapperClose();
    m_pFilter->m_wCachedSourceFormat = 0;
    m_pFilter->m_wCachedTargetFormat = 0;
    return CBaseOutputPin::BreakConnect();
}

// overridden to get media types even when the input is not connected
//
HRESULT CACMOutputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);
    ASSERT(m_pFilter->m_pInput != NULL);

    return m_pFilter->GetMediaType(iPosition, pmt);
}


////////////////////////////////
// IAMStreamConfig stuff      //
////////////////////////////////


HRESULT CACMOutputPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
    HRESULT hr;
    LPWAVEFORMATEX lpwfx;
    DWORD dwSize;

    if (pmt == NULL)
        return E_POINTER;

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(&m_pFilter->m_csFilter);

    DbgLog((LOG_TRACE,2,TEXT("::SetFormat to tag:%d %dbit %dchannel %dHz"),
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wFormatTag,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->wBitsPerSample,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nChannels,
        ((LPWAVEFORMATEX)(pmt->pbFormat))->nSamplesPerSec));

    if (m_pFilter->m_State != State_Stopped)
        return VFW_E_NOT_STOPPED;

    // our possible output formats depend on our input format
    if (!m_pFilter->m_pInput->IsConnected())
        return VFW_E_NOT_CONNECTED;

    // We're already using this format
    if (IsConnected() && CurrentMediaType() == *pmt)
        return NOERROR;

    // see if we like this type
    if ((hr = CheckMediaType((CMediaType *)pmt)) != NOERROR) {
        DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::SetFormat rejected")));
        return hr;
    }

    // If we are connected to somebody, make sure they like it
    if (IsConnected()) {
        hr = GetConnected()->QueryAccept(pmt);
        if (hr != NOERROR)
            return VFW_E_INVALIDMEDIATYPE;
    }

    // Now make a note that from now on, this is the only format allowed
    lpwfx = (LPWAVEFORMATEX)pmt->pbFormat;
    dwSize = lpwfx->cbSize + sizeof(WAVEFORMATEX);
    CoTaskMemFree(m_pFilter->m_lpwfxOutput);
    m_pFilter->m_lpwfxOutput = (LPWAVEFORMATEX)QzTaskMemAlloc(dwSize);
    if (NULL == m_pFilter->m_lpwfxOutput) {
        return E_OUTOFMEMORY;
    }
    m_pFilter->m_cbwfxOutput = dwSize;
    CopyMemory(m_pFilter->m_lpwfxOutput, pmt->pbFormat, dwSize);

    // Changing the format means reconnecting if necessary
    if (IsConnected())
        m_pFilter->m_pGraph->Reconnect(this);

    return NOERROR;
}


HRESULT CACMOutputPin::GetFormat(AM_MEDIA_TYPE **ppmt)
{
    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetFormat")));

    if (ppmt == NULL)
        return E_POINTER;

    // our possible output formats depend on our input format
    if (!m_pFilter->m_pInput->IsConnected())
        return VFW_E_NOT_CONNECTED;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(0, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
        return hr;
    }
    return NOERROR;
}


HRESULT CACMOutputPin::GetNumberOfCapabilities(int *piCount, int *piSize)
{
    if (piCount == NULL || piSize == NULL)
        return E_POINTER;

#if 0   // NetShow needs to see possible outputs before connecting input
    // output types depend on input types...
    if (!m_pFilter->m_pInput->CurrentMediaType().IsValid())
        return VFW_E_NOT_CONNECTED;
#endif

    // make the list of the media types we support
    m_pFilter->InitMediaTypes();

    *piCount = m_pFilter->m_cArray;
    *piSize = sizeof(AUDIO_STREAM_CONFIG_CAPS);

    return NOERROR;
}


HRESULT CACMOutputPin::GetStreamCaps(int i, AM_MEDIA_TYPE **ppmt, LPBYTE pSCC)
{
    AUDIO_STREAM_CONFIG_CAPS *pASCC = (AUDIO_STREAM_CONFIG_CAPS *)pSCC;

    DbgLog((LOG_TRACE,2,TEXT("IAMStreamConfig::GetStreamCaps")));

    // make sure this is current
    m_pFilter->InitMediaTypes();

    if (i < 0)
        return E_INVALIDARG;
    if (i >= m_pFilter->m_cArray)
        return S_FALSE;
    if (pSCC == NULL || ppmt == NULL)
        return E_POINTER;

#if 0   // NetShow needs to see possible outputs before connecting input
    // our possible output formats depend on our input format
    if (!m_pFilter->m_pInput->IsConnected())
        return VFW_E_NOT_CONNECTED;
#endif

    // I don't know how to modify the waveformats I get from ACM to produce
    // other acceptable types.  All I can give them is what ACM gives me.
    ZeroMemory(pASCC, sizeof(AUDIO_STREAM_CONFIG_CAPS));
    pASCC->guid = MEDIATYPE_Audio;

    *ppmt = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (*ppmt == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(*ppmt, sizeof(AM_MEDIA_TYPE));
    HRESULT hr = GetMediaType(i, (CMediaType *)*ppmt);
    if (hr != NOERROR) {
        CoTaskMemFree(*ppmt);
        *ppmt = NULL;
    }
    return hr;
}


STDMETHODIMP CACMWrapper::Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
    CAutoLock cObjectLock(&m_csFilter);
    if(m_State != State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    VARIANT var;
    var.vt = VT_I4;
    HRESULT hr = pPropBag->Read(L"AcmId", &var, 0);
    if(SUCCEEDED(hr))
    {
        hr = S_OK;
        m_wFormatTag = (WORD)var.lVal;

        DbgLog((LOG_TRACE,1,TEXT("CACMWrapper::Load: wFormatTag: %d"),
            m_wFormatTag));
    } else {
        // If we are NOT chosen via PNP as an audio compressor, then we
        // are supposed to be an audio DECOMPRESSOR
        m_wFormatTag = WAVE_FORMAT_PCM;
        hr = S_OK;
    }

    return hr;
}


STDMETHODIMP CACMWrapper::Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                               BOOL fSaveAllProperties)
{
    return E_NOTIMPL;
}

struct AcmPersist
{
    DWORD dwSize;
    WORD wFormatTag;
};

HRESULT CACMWrapper::WriteToStream(IStream *pStream)
{
    AcmPersist ap;
    ap.dwSize = sizeof(ap);
    ap.wFormatTag = m_wFormatTag;

    return pStream->Write(&ap, sizeof(AcmPersist), 0);
}


HRESULT CACMWrapper::ReadFromStream(IStream *pStream)
{
    CAutoLock cObjectLock(&m_csFilter);
    if(m_State != State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    if(m_wFormatTag != WAVE_FORMAT_PCM) {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    }

    AcmPersist ap;
    HRESULT hr = pStream->Read(&ap, sizeof(ap), 0);
    if(SUCCEEDED(hr))
    {
        if(ap.dwSize == sizeof(ap))
        {
            m_wFormatTag = ap.wFormatTag;
            DbgLog((LOG_TRACE,1,TEXT("CACMWrapper::ReadFromStream  wFormatTag: %d"),
                m_wFormatTag));

        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }


    return hr;
}


int CACMWrapper::SizeMax()
{
    return sizeof(AcmPersist);
}


STDMETHODIMP CACMWrapper::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;
}


STDMETHODIMP CACMWrapper::InitNew()
{
    if (m_wFormatTag != WAVE_FORMAT_PCM) {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_INITIALIZED);
    } else {
        return S_OK;
    }
}

// When you play a file with 1,000,000 samples in it, if the ACM wrapper is in
// the graph compressing or decompressing, it's going to output more or less
// than 1,000,000 samples.  So if somebody asks our output pin how many samples
// are in this file, it's wrong to propogate the request upstream and respond
// with the number of samples the file source thinks there are.
// I will be lazy and refuse any seeking requests that have anything to do with
// samples so we don't end up reporting the wrong thing.

CACMPosPassThru::CACMPosPassThru(const TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, IPin *pPin) :
CPosPassThru(pName, pUnk, phr, pPin)
{
}


STDMETHODIMP CACMPosPassThru::SetTimeFormat(const GUID * pFormat)
{
    if(pFormat && *pFormat == TIME_FORMAT_SAMPLE)
        return E_INVALIDARG;
    return CPosPassThru::SetTimeFormat(pFormat);
}


STDMETHODIMP CACMPosPassThru::IsFormatSupported(const GUID *pFormat)
{
    if (pFormat && *pFormat == TIME_FORMAT_SAMPLE)
        return S_FALSE;
    return CPosPassThru::IsFormatSupported(pFormat);
}


STDMETHODIMP CACMPosPassThru::QueryPreferredFormat(GUID *pFormat)
{
    if (pFormat)
        *pFormat = TIME_FORMAT_MEDIA_TIME;
    return S_OK;
}


STDMETHODIMP CACMPosPassThru::ConvertTimeFormat(LONGLONG *pTarget, const GUID *pTargetFormat, LONGLONG Source, const GUID *pSourceFormat)
{
    if ((pSourceFormat && *pSourceFormat == TIME_FORMAT_SAMPLE) ||
        (pTargetFormat && *pTargetFormat == TIME_FORMAT_SAMPLE))
        return E_INVALIDARG;
    return CPosPassThru::ConvertTimeFormat(pTarget, pTargetFormat, Source,
        pSourceFormat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\amsrc\audioman.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Contains AudioMan Core Component Interfaces and Types
//
//	Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//    
//	4/27/95 Brian McDowell
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _AUDIOMAN_PUBLICINTEFACES_
#define _AUDIOMAN_PUBLICINTEFACES_

#include <mmsystem.h>

#ifdef __cplusplus
extern "C" {
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Definitions 
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#define lAMIIDFirst				0xA0634E10
#define DEFINE_AMIID(name, x)	DEFINE_GUID(name, lAMIIDFirst + x, 0x9573,0x11CE,0xB6,0x1B,0x00,0xAA,0x00,0x6E,0xBB,0xE5)

DEFINE_AMIID(IID_IAMMixer, 				0);
DEFINE_AMIID(IID_IAMChannel, 			1);
DEFINE_AMIID(IID_IAMVolume, 			2);
DEFINE_AMIID(IID_IAMSound, 				3);
DEFINE_AMIID(IID_IAMNotifySink, 		4);
DEFINE_AMIID(IID_IAMWavFileSrc, 		5);
DEFINE_AMIID(IID_IAMConvertFilter, 		6);
DEFINE_AMIID(IID_IAMLoopFilter, 		7);
DEFINE_AMIID(IID_IAMCacheFilter, 		8);
DEFINE_AMIID(IID_IAMPlaySound, 			9);
DEFINE_AMIID(IID_IAMSoundSink, 			10);


///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Interface Typedefs
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef interface IAMMixer				IAMMixer;
typedef IAMMixer *						LPMIXER;

typedef interface IAMChannel			IAMChannel;
typedef IAMChannel *					LPCHANNEL;

typedef interface IAMVolume				IAMVolume;
typedef IAMVolume *						LPVOLUME;

typedef interface IAMSound				IAMSound;
typedef IAMSound *						LPSOUND;

typedef interface IAMNotifySink			IAMNotifySink;
typedef IAMNotifySink *					LPNOTIFYSINK;

typedef interface IAMWavFileSrc			IAMWavFileSrc;
typedef IAMWavFileSrc *					LPWAVFILESRC;

typedef interface IAMConvertFilter		IAMConvertFilter;
typedef IAMConvertFilter *				LPCONVERTFILTER;

typedef interface IAMLoopFilter			IAMLoopFilter;
typedef IAMLoopFilter *					LPLOOPFILTER;

typedef interface IAMCacheFilter		IAMCacheFilter;
typedef IAMCacheFilter *				LPCACHEFILTER;

typedef interface IAMPlaySound			IAMPlaySound;
typedef IAMPlaySound *					LPPLAYSOUND;

typedef interface IAMSoundSink			IAMSoundSink;
typedef IAMSoundSink *					LPSOUNDSINK;

#ifndef LPSTREAM
typedef IStream *						LPSTREAM;
#endif

#ifndef LPUNKNOWN
typedef IUnknown *						LPUNKNOWN;
#endif



///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	Audio HRESULT Return Codes
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

// Success Codes

#define AM_S_FIRST				(OLE_S_FIRST + 5000)

#define	S_ENDOFSOUND			(AM_S_FIRST + 1)
#define S_SOUNDIDLE				(AM_S_FIRST + 2)
#define S_MIXEREXISTS			(AM_S_FIRST + 3)

// Error Codes

#define AM_E_FIRST				(OLE_E_FIRST + 5000)

#define E_INCOMPATIBLEDLL		(AM_E_FIRST + 1)
#define E_NOSOUNDCARD			(AM_E_FIRST + 2)
#define E_INVALIDCARD			(AM_E_FIRST + 3)
#define E_AUDIODEVICEBUSY		(AM_E_FIRST + 4)
#define E_NOTACTIVE				(AM_E_FIRST + 5)
#define E_NEEDSETUP				(AM_E_FIRST + 6)
#define	E_OPENDEVICEFAILED		(AM_E_FIRST + 7)
#define E_INITFAILED			(AM_E_FIRST + 8)
#define E_NOTINITED				(AM_E_FIRST + 9)
#define E_MMSYSERROR			(AM_E_FIRST + 10)
#define E_MMSYSBADDEVICEID		(AM_E_FIRST + 11)
#define E_MMSYSNOTENABLED		(AM_E_FIRST + 12)
#define E_MMSYSALLOCATED		(AM_E_FIRST + 13)
#define E_MMSYSINVALHANDLE		(AM_E_FIRST + 14)
#define E_MMSYSNODRIVER			(AM_E_FIRST + 15)
#define E_MMSYSNOMEM			(AM_E_FIRST + 16)
#define E_MMSYSNOTSUPPORTED		(AM_E_FIRST + 17)
#define E_MMSYSBADERRNUM		(AM_E_FIRST + 18)
#define E_MMSYSINVALFLAG		(AM_E_FIRST + 19)
#define E_MMSYSINVALPARAM		(AM_E_FIRST + 20)
#define E_MMSYSHANDLEBUSY		(AM_E_FIRST + 21)
#define E_MMSYSINVALIDALIAS		(AM_E_FIRST + 22)
#define E_MMSYSBADDB			(AM_E_FIRST + 23)
#define E_MMSYSKEYNOTFOUND		(AM_E_FIRST + 24)
#define E_MMSYSREADERROR		(AM_E_FIRST + 25)
#define E_MMSYSWRITEERROR		(AM_E_FIRST + 26)
#define E_MMSYSDELETEERROR		(AM_E_FIRST + 27)
#define E_MMSYSVALNOTFOUND		(AM_E_FIRST + 28)
#define E_MMSYSNODRIVERCB		(AM_E_FIRST + 29)
#define E_WAVEERRBADFORMAT		(AM_E_FIRST + 30)
#define E_WAVEERRSTILLPLAYING	(AM_E_FIRST + 31)
#define E_WAVERRUNPREPARED		(AM_E_FIRST + 32)
#define E_WAVERRSYNC			(AM_E_FIRST + 33)
#define	E_TIMERRNOCANDO			(AM_E_FIRST	+ 34)
#define	E_TIMERRSTRUCT			(AM_E_FIRST	+ 35)
#define E_ALREADYREGISTERED		(AM_E_FIRST + 36)
#define E_CHANNELNOTREGISTERED	(AM_E_FIRST + 37)
#define E_ALLGROUPSALLOCATED	(AM_E_FIRST + 38)
#define E_GROUPNOTALLOCATED		(AM_E_FIRST + 39)
#define E_BADTIMERPERIOD		(AM_E_FIRST + 40)
#define E_NOTIMER				(AM_E_FIRST + 41)
#define E_NOTREGISTERED			(AM_E_FIRST + 42)
#define E_OUTOFRANGE			(AM_E_FIRST + 43)
#define E_ALREADYINITED			(AM_E_FIRST + 44)
#define E_NOSOUND				(AM_E_FIRST + 45)
#define E_NONOTIFYSINK			(AM_E_FIRST + 46)
#define E_INVALIDSOUND			(AM_E_FIRST + 47)
#define E_MIXERALLOCATED		(AM_E_FIRST + 48)
#define E_RTFM					(AM_E_FIRST + 49)
#define E_HFILE_ERROR			(AM_E_FIRST + 50)

#define E_BADPCMFORMAT			E_WAVEERRBADFORMAT



///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// AudioMan common defines
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

enum SOUND_PROPERTIES 
{
	SOUND_FORMAT		= 	0x0001,		
	SOUND_ALIGNMENT		= 	0x0002,		
	SOUND_DURATION		= 	0x0004,
	SOUND_TIME			=	0x0008,
	SOUND_ALL			= 	0xFFFF	
};

enum SMPTE_FRAMERATES
{
	SMPTE_30_FPS		= 	3000,	
	SMPTE_29DF_FPS		= 	2997,	
	SMPTE_25_FPS		= 	2500,
	SMPTE_24_FPS		=	2400	
}; 

enum NOTIFYSINKFLAGS
{
	NOTIFYSINK_ONSTART			= 0x0001,	
	NOTIFYSINK_ONCOMPLETION		= 0x0002,
	NOTIFYSINK_ONERROR			= 0x0004,	
	NOTIFYSINK_ONSPARSEOBJECT	= 0x0008	
};

enum VOLUME_BIT_FLAGS
{
	BIT_dB_SCALE				= 0x00000001,
	BIT_LINEAR_SCALE			= 0x00000002,

	BIT_VOLPAN_STYLE			= 0x00000004,	
	BIT_LEFTRIGHT_STYLE			= 0x00000008,

	BIT_CONST_POWER_PAN			= 0x00000010,

	BIT_SET_PARAM1				= 0x00000020,
	BIT_SET_PARAM2				= 0x00000040,

	BIT_SET_RELATIVE			= 0x00000080,

	BIT_VOLPAN_dB				= BIT_VOLPAN_STYLE | BIT_dB_SCALE,	
	BIT_LEFTRIGHT_dB			= BIT_LEFTRIGHT_STYLE | BIT_dB_SCALE,

	BIT_VOLPAN_LINEAR			= BIT_VOLPAN_STYLE | BIT_LINEAR_SCALE,	
	BIT_LEFTRIGHT_LINEAR		= BIT_LEFTRIGHT_STYLE | BIT_LINEAR_SCALE,

	BIT_SET_BOTH				= BIT_SET_PARAM1 | BIT_SET_PARAM2
};

enum VOLUME_FLAGS
{
	AM_VOLUME					= BIT_VOLPAN_LINEAR | BIT_SET_PARAM1,

	AM_VOLPAN_dB				= BIT_VOLPAN_dB | BIT_CONST_POWER_PAN | BIT_SET_BOTH,
	AM_VOL_dB					= BIT_VOLPAN_dB | BIT_CONST_POWER_PAN | BIT_SET_PARAM1,
	AM_PAN_dB					= BIT_VOLPAN_dB | BIT_CONST_POWER_PAN | BIT_SET_PARAM2,

	AM_LEFTRIGHT_dB				= BIT_LEFTRIGHT_dB | BIT_SET_BOTH,
	AM_LEFT_dB					= BIT_LEFTRIGHT_dB | BIT_SET_PARAM1,
	AM_RIGHT_dB					= BIT_LEFTRIGHT_dB | BIT_SET_PARAM2,

	AM_VOLPAN_LINEAR			= BIT_VOLPAN_LINEAR | BIT_CONST_POWER_PAN | BIT_SET_BOTH,
	AM_VOL_LINEAR				= BIT_VOLPAN_LINEAR | BIT_CONST_POWER_PAN | BIT_SET_PARAM1,
	AM_PAN_LINEAR				= BIT_VOLPAN_LINEAR | BIT_CONST_POWER_PAN | BIT_SET_PARAM2,

	AM_LEFTRIGHT_LINEAR			= BIT_LEFTRIGHT_LINEAR  | BIT_SET_BOTH,
	AM_LEFT_LINEAR				= BIT_LEFTRIGHT_LINEAR  | BIT_SET_PARAM1,
	AM_RIGHT_LINEAR				= BIT_LEFTRIGHT_LINEAR  | BIT_SET_PARAM2,

	AM_RELATIVE					= BIT_SET_RELATIVE
};

enum MEM_FAULT_FLAGS
{
	MEM_FAULT_RESET				= 0,
	MEM_FAULT_BYTES				= 1,
	MEM_FAULT_ALLOC				= 2

};

///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// AudioMan Type definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////
				
typedef struct SMPTE							
{
	BYTE					hour;				
	BYTE					min;
	BYTE					sec;
	BYTE					frame;
	DWORD					fps;	
}SMPTE, *LPSMPTE;

typedef struct CacheConfig
{
	DWORD					dwSize;
	BOOL					fSrcFormat;
	LPWAVEFORMATEX			lpFormat;
	DWORD					dwFormat;
	DWORD					dwCacheTime;
}CACHECONFIG, *LPCACHECONFIG;


typedef struct AdvMixerConfig
{					   	
	DWORD					dwSize;
	UINT					uVoices;
	BOOL					fRemixEnabled;
	UINT					uBufferTime;
}ADVMIXCONFIG, *LPADVMIXCONFIG;
								
	
typedef struct MixerConfig
{
	DWORD					dwSize;
	LPWAVEFORMATEX			lpFormat;
	DWORD					dwFormat;
}MIXERCONFIG, *LPMIXERCONFIG;


typedef struct AuxData
{
	DWORD					dwSize;
	LPSOUNDSINK				pSink;
	LPVOID					pEvents;
	DWORD					dwFinishPos;
}AUXDATA, *LPAUXDATA;


typedef struct MemoryData
{
	DWORD					dwSize;
	DWORD					dwMaxBytes;
	DWORD					dwCurrentBytes;
	DWORD					dwMaxAlloc;
	DWORD					dwCurrentAlloc;
} MEMORYDATA, *LPMEMORYDATA;



///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// AudioMan Interface Definitions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#undef INTERFACE
#define INTERFACE IAMVolume
DECLARE_INTERFACE_(IAMVolume, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IAMVolume methods--- 
	
	STDMETHOD (SetVolume)				(THIS_	float flParam1, 
												float flParam2,
												DWORD fdwFlags) PURE;

	STDMETHOD (GetVolume)				(THIS_	float *pflParam1, 
												float *pflParam2,
												DWORD fdwFlags) PURE;

};

#undef INTERFACE
#define INTERFACE IAMMixer
DECLARE_INTERFACE_( IAMMixer, IAMVolume)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

    //---  IAMVolume methods--- 
	
	STDMETHOD (SetVolume)				(THIS_	float flParam1, 
												float flParam2,
												DWORD fdwFlags) PURE;

	STDMETHOD (GetVolume)				(THIS_	float *pflParam1, 
												float *pflParam2,
												DWORD fdwFlags) PURE;	
	//--- IAMMixer methods---

	STDMETHOD (Init)					(THIS_	LPMIXERCONFIG pMixerConfig,
												LPADVMIXCONFIG pAdvMixConfig) PURE;
		
	STDMETHOD (Activate)				(THIS_	BOOL fActive) PURE;

	STDMETHOD (Suspend)					(THIS_	BOOL fSuspend) PURE;

 	STDMETHOD (SetConfig)				(THIS_	LPMIXERCONFIG pMixerConfig,
												LPADVMIXCONFIG pAdvMixConfig) PURE;

	STDMETHOD (GetConfig)				(THIS_	LPMIXERCONFIG pMixerConfig,
												LPADVMIXCONFIG pAdvMixConfig) PURE;
	
	STDMETHOD (PlaySound)				(THIS_	LPSOUND pSound) PURE;

	STDMETHOD_(BOOL, RemixMode)			(THIS_	BOOL fActive) PURE;

	STDMETHOD (GetdBMeter)				(THIS_	float *pflLeftdB,
												float *pflRightdB)	PURE;

	STDMETHOD (AllocGroup)				(THIS_	LPDWORD lpdwGroup) PURE;

	STDMETHOD (FreeGroup)				(THIS_	DWORD dwGroup) PURE;
  	
  	STDMETHOD (EnlistGroup)				(THIS_	LPUNKNOWN pUnknown,
												DWORD dwGroup) PURE;

	STDMETHOD (DefectGroup)				(THIS_	LPUNKNOWN pUnknown,
												DWORD dwGroup) PURE;

	STDMETHOD (PlayGroup)				(THIS_	DWORD dwGroup) PURE;

	STDMETHOD (StopGroup)				(THIS_	DWORD dwGroup) PURE;

	STDMETHOD (FinishGroup)				(THIS_	DWORD dwGroup,
												DWORD dwPlayGroup) PURE;

	STDMETHOD (SetGroupVolume)			(THIS_	DWORD dwGroup, 
												float flParam1,
												float flParam2,
												DWORD fdwFlags,
												BOOL fAbsolute) PURE;

	STDMETHOD (SetGroupPosition)		(THIS_	DWORD dwGroup, 
												DWORD dwPosition) PURE;

	STDMETHOD (SetPriority)				(THIS_	LPUNKNOWN pUnknown,
												DWORD dwPriority) PURE;

	STDMETHOD (GetPriority)				(THIS_	LPUNKNOWN pUnknown,
												LPDWORD lpdwPriority) PURE;

	STDMETHOD_(DWORD,CPULoad)			(THIS_	BOOL fReset) PURE;
};


#undef INTERFACE
#define INTERFACE IAMChannel
DECLARE_INTERFACE_(IAMChannel, IAMVolume)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;


    //---  IAMVolume methods--- 
	
	STDMETHOD (SetVolume)				(THIS_	float flParam1, 
												float flParam2,
												DWORD fdwFlags) PURE;

	STDMETHOD (GetVolume)				(THIS_	float *pflParam1, 
												float *pflParam2,
												DWORD fdwFlags) PURE;	
	//---  IAMChannel methods---
    
	STDMETHOD (RegisterNotify)			(THIS_	LPNOTIFYSINK pNotifySink,
												DWORD fdwNotifyFlags) PURE;

	STDMETHOD (SetSoundSrc)				(THIS_	LPSOUND pSound) PURE;

	STDMETHOD (GetSoundSrc)				(THIS_	LPSOUND *ppSound) PURE;

   	STDMETHOD (Play)					(THIS)	PURE;

	STDMETHOD (Stop)					(THIS)	PURE;

	STDMETHOD (Finish)					(THIS)	PURE;

	STDMETHOD_(BOOL,IsPlaying)			(THIS)	PURE;

	STDMETHOD_(DWORD,GetDuration)		(THIS)	PURE;

	STDMETHOD (SetEvent)				(THIS_	DWORD dwEventPos,
												DWORD dwRecurrences,
												DWORD dwPeriod) PURE;

	STDMETHOD (PreRoll)					(THIS_	DWORD dwSample) PURE;

	STDMETHOD (Mute)					(THIS_	BOOL fMute) PURE;

	STDMETHOD (SetPosition)				(THIS_	DWORD dwSample) PURE;

	STDMETHOD (GetPosition)				(THIS_	LPDWORD lpdwSample) PURE;


	STDMETHOD (GetSMPTEPos)				(THIS_	LPSMPTE lpSMPTE) PURE;

	STDMETHOD (SetSMPTEPos)				(THIS_	LPSMPTE lpSMPTE) PURE;

	STDMETHOD (GetTimePos)				(THIS_	LPDWORD lpdwTime) PURE;

	STDMETHOD (SetTimePos)				(THIS_	DWORD dwTime) PURE;

};



#undef INTERFACE
#define INTERFACE IAMSound
DECLARE_INTERFACE_(IAMSound, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IAMSound methods--- 
	
	STDMETHOD (RegisterSink)			(THIS_	LPSOUNDSINK pSink) PURE;

	STDMETHOD (UnregisterSink)			(THIS_	LPSOUNDSINK pSink)	PURE;

	STDMETHOD (GetFormat)				(THIS_	LPWAVEFORMATEX pFormat, DWORD cbSize) PURE;

	STDMETHOD_(DWORD,GetDuration)		(THIS)	PURE;

	STDMETHOD (GetAlignment)			(THIS_	LPDWORD	lpdwLeftAlign,
												LPDWORD lpdwRightAlign)	PURE;

	STDMETHOD (GetData)					(THIS_	LPBYTE lpBuffer,
												DWORD dwPosition, 
											    LPDWORD lpdwSamples,
											    const LPAUXDATA lpAuxData) PURE;

	STDMETHOD (SetCacheSize)			(THIS_	LPSOUNDSINK pSink,
												DWORD dwCacheSize) PURE;

	STDMETHOD (SetActive)				(THIS_	LPSOUNDSINK pSink,
												BOOL fActive) PURE;
};



#undef INTERFACE
#define INTERFACE IAMSoundSink
DECLARE_INTERFACE_( IAMSoundSink, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IAMSoundSink methods--- 
	
	STDMETHOD_(void,BeginInval)			(THIS)	PURE;

	STDMETHOD_(void,EndInval)			(THIS)	PURE;

   	STDMETHOD_(DWORD,InvalRange)		(THIS_	DWORD dwStartSample,
   												DWORD dwEndSample) PURE;

	STDMETHOD_(void,InvalProperties)	(THIS_	DWORD fdwProperties) PURE;
};




#undef INTERFACE
#define INTERFACE IAMNotifySink
DECLARE_INTERFACE_( IAMNotifySink, IUnknown)
{
    //---  IUnknown methods--- 
    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;

    //---  IAMNotifySink methods--- 

	STDMETHOD_(void,OnStart)			(THIS_	LPSOUND	pSound,
												DWORD dwPosition)	PURE;

	STDMETHOD_(void,OnCompletion)		(THIS_	LPSOUND	pSound,
												DWORD dwPosition)	PURE;
	
	STDMETHOD_(void,OnError)			(THIS_	LPSOUND	pSound,
												DWORD dwPosition,
												HRESULT	hrError)	PURE;

	STDMETHOD_(DWORD,OnEvent)			(THIS_	LPSOUND	pSound,
												DWORD	dwPosition,
												DWORD	dwOccurance) PURE;

	STDMETHOD_(void,OnSparseObject)		(THIS_	LPSOUND	pSound,
												DWORD	dwPosition,
												void *	pvObject)	PURE;
};


#undef INTERFACE
#define INTERFACE IAMWavFileSrc
DECLARE_INTERFACE_(IAMWavFileSrc, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

	//--- IAMWavFileSrc methods---

	STDMETHOD (InitFromStream)			(THIS_	IStream *pStream,
												BOOL fSpooled) PURE;
};


// Core Filters


#undef INTERFACE
#define INTERFACE IAMCacheFilter
DECLARE_INTERFACE_(IAMCacheFilter, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

	//--- IAMCacheFilter methods---

	STDMETHOD (Init)					(THIS_	LPSOUND pSound, LPCACHECONFIG lpCacheConfig) PURE;
};



#undef INTERFACE
#define INTERFACE IAMLoopFilter
DECLARE_INTERFACE_(IAMLoopFilter, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

	//--- IAMLoopFilter methods---

   	STDMETHOD (Init)					(THIS_	LPSOUND pSoundSrc, DWORD dwLoops) PURE;
};



#undef INTERFACE
#define INTERFACE IAMConvertFilter
DECLARE_INTERFACE_(IAMConvertFilter, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

	//--- IAMConvertFilter methods---

	STDMETHOD (Init)					(THIS_	LPSOUND pSoundSrc, LPWAVEFORMATEX lpwfxDest) PURE; 
};




#undef INTERFACE
#define INTERFACE IAMPlaySound
DECLARE_INTERFACE_(IAMPlaySound, IUnknown)
{
    //---  IUnknown methods--- 

    STDMETHOD (QueryInterface) 			(THIS_ REFIID riid, LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) 			(THIS) PURE;
    STDMETHOD_(ULONG,Release) 			(THIS) PURE;
 

	//--- IAMPlaySound methods---

	STDMETHOD (Play)					(THIS_	LPMIXER pMixer, LPSOUND pSound) PURE;
	STDMETHOD (PlayInGroup)				(THIS_	LPMIXER pMixer, LPSOUND pSound, DWORD dwGroupID) PURE; 
	STDMETHOD (PlayAtVolume)			(THIS_	LPMIXER pMixer, LPSOUND pSound, float flParam1, float flParam2, DWORD fdwFlags) PURE;  
};




///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	AudioMan Allocator Functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

STDAPI_(void) AMGetVersion(int *piMajor, int *piMinor, int *piBuild);

STDAPI AllocMixer(LPMIXER *ppMixer, LPMIXERCONFIG pMixerConfig, LPADVMIXCONFIG pAdvMixConfig);
STDAPI AllocChannel (LPCHANNEL *ppChannel, LPMIXER pMixer);

STDAPI AllocDeviceVolume(LPVOLUME *ppVolume);

STDAPI AllocSoundFromFile (LPSOUND *ppSound, const char *szFileName,  DWORD dwOffset, BOOL fSpooled, LPCACHECONFIG lpCacheConfig);
STDAPI AllocSoundFromMemory (LPSOUND *ppSound, char *lpMemory, DWORD dwLength);
STDAPI AllocSoundFromResource (LPSOUND *ppSound, const char *szWaveFilename, HINSTANCE hInst, const char *szResourceType);
STDAPI AllocSoundFromStream (LPSOUND *ppSound, LPSTREAM pStream, BOOL fSpooled, LPCACHECONFIG lpCacheConfig);

STDAPI AllocStreamFromFile (LPSTREAM *ppStream, const char *szFileName,  DWORD dwOffset);
STDAPI AllocStreamFromMemory (LPSTREAM *ppStream, char *lpMemory, DWORD dwLength);
STDAPI AllocStreamFromResource (LPSTREAM *ppStream, const char *szWaveName, HINSTANCE hInst, const char *szResourceType);

STDAPI AllocCacheFilter	(LPSOUND *ppSound,LPSOUND pSoundSrc,LPCACHECONFIG lpCacheConfig);
STDAPI AllocLoopFilter (LPSOUND *ppSound, LPSOUND pSoundSrc, DWORD dwLoops);
STDAPI AllocConvertFilter (LPSOUND *ppSound, LPSOUND pSoundSrc, LPWAVEFORMATEX lpwfx);
STDAPI AllocDbgFilter (LPSOUND *ppSound,LPSOUND pSound, DWORD dwLevel, char *szTitle);
STDAPI AllocPlaySound (LPPLAYSOUND *pPlaySound);


///////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	AudioMan Helper Functions
//
///////////////////////////////////////////////////////////////////////////////////////////////////////

STDAPI			EnableDirectSound(HWND hWnd);

STDAPI_(DWORD)	TimeToSamples (LPSOUND pSound, DWORD dwTime);
STDAPI_(DWORD)	SamplesToTime (LPSOUND pSound, DWORD dwSamples);
STDAPI_(DWORD)	SizeToSamples (LPSOUND pSound, DWORD dwSize);
STDAPI_(DWORD)	SamplesToSize (LPSOUND pSound, DWORD dwSamples);

STDAPI_(DWORD)	BytesToSamples(LPWAVEFORMATEX pwfx, DWORD dwBytes);
STDAPI_(DWORD)	BytesToMillisec(LPWAVEFORMATEX pwfx, DWORD dwBytes);
STDAPI_(DWORD)	MillisecToBytes(LPWAVEFORMATEX pwfx, DWORD dwTime);
STDAPI_(DWORD)	MillisecToSamples(LPWAVEFORMATEX pwfx, DWORD dwTime);
STDAPI_(DWORD)	SamplesToBytes(LPWAVEFORMATEX pwfx, DWORD dwSamples);
STDAPI_(DWORD)	SamplesToMillisec(LPWAVEFORMATEX pwfx, DWORD dwSamples);

STDAPI_(BOOL)	MillisecToSMPTE(LPSMPTE pSMPTE, DWORD dwTime);
STDAPI_(BOOL)	SMPTEToMillisec(LPSMPTE pSMPTE, LPDWORD pdwTime);

STDAPI_(BOOL)	IsStandardFormat(LPWAVEFORMATEX pwfx);
STDAPI_(BOOL)	SameFormats(LPWAVEFORMATEX pwfxA, LPWAVEFORMATEX pwfxB);
STDAPI_(BOOL)	FormatToWFX(LPWAVEFORMATEX pwfx, DWORD dwFormat);
STDAPI_(DWORD)	WFXToFormat(LPWAVEFORMATEX pwfx);
STDAPI_(DWORD)	RemapSamples(LPSOUND pSound, DWORD dwSamples, LPWAVEFORMATEX pwfx);

STDAPI_(float)	PercentToDecibel(float flPercent);
STDAPI_(float)	DecibelToPercent(float flVolDB);

STDAPI_(int)	DetectLeaks(BOOL fDebugOut, BOOL fMessageBox);
STDAPI_(void)	FreeLeaks(void);
STDAPI			MemoryAudit(LPMEMORYDATA pmd, BOOL fDebugDump, BOOL fResetMax);
STDAPI			SetMemoryFault(DWORD dwLimit, DWORD fdwFlags);
STDAPI_(void)	SetDebugLevel(UINT uLevel);

// NOTE:  AllocStaticAudioMan is only available in the Static LIB Version.
STDAPI			AllocStaticAudioMan(LPUNKNOWN *ppUnk);




#ifdef __cplusplus
};
#endif

#endif  //_AUDIOMAN_PUBLICINTEFACES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\tonegen\synthurl.cpp ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
// simple filter that implements URLs like
//              tone://440
// to generate sine wave pure tones.
// works by aggregating the audio synth filter from the SDK.


#include <streams.h>
#include <initguid.h>

// include header from audio synthesizer example from SDK 
#include <isynth.h>

DEFINE_GUID(CLSID_SynthFilter,
0x79a98de0, 0xbc00, 0x11ce, 0xac, 0x2e, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);



// {3F89DAE0-A4E9-11d2-ACBE-0080C75E246E}
DEFINE_GUID(CLSID_SynthWrap, 
0x3f89dae0, 0xa4e9, 0x11d2, 0xac, 0xbe, 0x0, 0x80, 0xc7, 0x5e, 0x24, 0x6e);



CUnknown *CreateSynthWrapInstance(LPUNKNOWN, HRESULT *);

class CSynthWrap : public CUnknown, public IFileSourceFilter
{
    LPOLESTR   	          m_pFileName; // null until loaded

    IUnknown *		  m_punkRealFilter;
    
public:
		
    // construction / destruction

    CSynthWrap(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr);
    ~CSynthWrap();

    // -- CUnknown methods --

    // we export IFileSourceFilter 
    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void **);

    // -- IFileSourceFilter methods ---

    STDMETHODIMP Load(LPCOLESTR pszFileName, const AM_MEDIA_TYPE *mt);
    STDMETHODIMP GetCurFile(LPOLESTR * ppszFileName, AM_MEDIA_TYPE *mt);
};

CSynthWrap::CSynthWrap(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
       CUnknown(pName, pUnk), m_pFileName(NULL), m_punkRealFilter(NULL)
{
    *phr = CoCreateInstance(CLSID_SynthFilter,
                                  (IUnknown *) (IFileSourceFilter *) this,
                                  CLSCTX_INPROC_SERVER,
                                  IID_IUnknown,
                                  (void**) &m_punkRealFilter);
}

CSynthWrap::~CSynthWrap()
{
    delete[] m_pFileName;

    if (m_punkRealFilter)
	m_punkRealFilter->Release();
}

STDMETHODIMP
CSynthWrap::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    if (riid == IID_IFileSourceFilter) {
	return GetInterface((IFileSourceFilter*) this, ppv);
    } else if (riid != IID_IUnknown) {
	// delegate other methods to contained filter
	if (m_punkRealFilter)
	    return m_punkRealFilter->QueryInterface(riid, ppv);
    }
    return CUnknown::NonDelegatingQueryInterface(riid, ppv);
}


//  Load a (new) file

HRESULT
CSynthWrap::Load(
LPCOLESTR lpwszFileName, const AM_MEDIA_TYPE *pmt)
{
    CheckPointer(lpwszFileName, E_POINTER);

    // we only support URLs that start "tone://"
    
    if (lpwszFileName[0] != L't' ||
        lpwszFileName[1] != L'o' ||
	lpwszFileName[2] != L'n' ||
        lpwszFileName[3] != L'e' ||
	lpwszFileName[4] != L':' ||
        lpwszFileName[5] != L'/' ||
        lpwszFileName[6] != L'/') {
        return E_INVALIDARG;
    }

    int iFreq = atoiW(lpwszFileName + 7);
    if (iFreq < 10 || iFreq > 44100)
        return E_INVALIDARG;
        
    ISynth *pSynth;
    HRESULT hr = m_punkRealFilter->QueryInterface(IID_ISynth, (void **) &pSynth);
    if (FAILED(hr))
        return hr;

    // set up the synthesizer the way we wanted it.
    pSynth->put_Frequency(iFreq);
    pSynth->put_Waveform(0 /* WAVE_SINE */);
    pSynth->put_BitsPerSample(16);
    pSynth->put_SamplesPerSec(44100);
    pSynth->put_Amplitude(100);
    pSynth->put_Channels(1);
    
    if (SUCCEEDED(hr)) {
        int cch = lstrlenW(lpwszFileName) + 1;
        m_pFileName = new WCHAR[cch];
        if (m_pFileName!=NULL) {
	    CopyMemory(m_pFileName, lpwszFileName, cch*sizeof(WCHAR));
        }
    }

    return hr;
}

// Modelled on IPersistFile::Load
// Caller needs to CoTaskMemFree or equivalent.

STDMETHODIMP
CSynthWrap::GetCurFile(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt)
{
    CheckPointer(ppszFileName, E_POINTER);
    *ppszFileName = NULL;
    if (m_pFileName!=NULL) {
	DWORD n = sizeof(WCHAR)*(1+lstrlenW(m_pFileName));

        *ppszFileName = (LPOLESTR) CoTaskMemAlloc( n );
        if (*ppszFileName!=NULL) {
              CopyMemory(*ppszFileName, m_pFileName, n);
        } else
	    return E_OUTOFMEMORY;
    }

    return NOERROR;
}




const AMOVIESETUP_FILTER
sudSynthWrap = { &CLSID_SynthWrap         // clsID
              , L"Tone Generator for tone:// URLs"          // strName
              , MERIT_UNLIKELY          // dwMerit
              , 0                       // nPins
              , NULL };                 // lpPin

#ifdef FILTER_DLL
/* List of class IDs and creator functions for the class factory. This
   provides the link between the OLE entry point in the DLL and an object
   being created. The class factory will call the static CreateInstance
   function when it is asked to create a CLSID_FileSource object */

CFactoryTemplate g_Templates[] = {
    { L"Tone Generator"
    , &CLSID_SynthWrap
    , CreateSynthWrapInstance
    , NULL
    , &sudSynthWrap }
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

/* Create a new instance of this class */

CUnknown *CreateSynthWrapInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CSynthWrap(NAME("Tone generator"), pUnk, phr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\wavemsr\wavemsr.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

//
//  WAV file parser
//

// Caveats
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif
#include <mmsystem.h>
#include <vfw.h>
#include "basemsr.h"
#include "wavemsr.h"

//
// setup data
//

const AMOVIESETUP_MEDIATYPE
psudWAVEParseType[] = { { &MEDIATYPE_Stream       // 1. clsMajorType
                        , &MEDIASUBTYPE_WAVE }    //    clsMinorType
                      , { &MEDIATYPE_Stream       // 2. clsMajorType
                        , &MEDIASUBTYPE_AU   }    //    clsMinorType
                      , { &MEDIATYPE_Stream       // 3. clsMajorType
                        , &MEDIASUBTYPE_AIFF } }; //    clsMinorType

const AMOVIESETUP_MEDIATYPE
sudWAVEParseOutType = { &MEDIATYPE_Audio       // 1. clsMajorType
                       , &MEDIASUBTYPE_NULL }; //    clsMinorType

const AMOVIESETUP_PIN
psudWAVEParsePins[] =  { { L"Input"             // strName
            , FALSE                // bRendered
            , FALSE                // bOutput
            , FALSE                // bZero
            , FALSE                // bMany
            , &CLSID_NULL          // clsConnectsToFilter
            , L""                  // strConnectsToPin
            , 3                    // nTypes
            , psudWAVEParseType }, // lpTypes
                 { L"Output"             // strName
            , FALSE                // bRendered
            , TRUE                 // bOutput
            , FALSE                // bZero
            , FALSE                // bMany
            , &CLSID_NULL          // clsConnectsToFilter
            , L""                  // strConnectsToPin
            , 1                    // nTypes
            , &sudWAVEParseOutType } }; // lpTypes

const AMOVIESETUP_FILTER
sudWAVEParse = { &CLSID_WAVEParser     // clsID
               , L"Wave Parser"        // strName
               , MERIT_UNLIKELY        // dwMerit
               , 2                     // nPins
               , psudWAVEParsePins };   // lpPin

#ifdef FILTER_DLL
// COM global table of objects available in this dll
CFactoryTemplate g_Templates[] = {

    { L"WAVE Parser"
    , &CLSID_WAVEParser
    , CWAVEParse::CreateInstance
    , NULL
    , &sudWAVEParse }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// exported entry points for registration and
// unregistration (in this case they only call
// through to default implmentations).
//
STDAPI DllRegisterServer()
{
  return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
  return AMovieDllRegisterServer2( FALSE );
}
#endif

//
// CWAVEParse::Constructor
//
CWAVEParse::CWAVEParse(TCHAR *pName, LPUNKNOWN lpunk, HRESULT *phr)
        : CBaseMSRFilter(pName, lpunk, CLSID_WAVEParser, phr),
          m_pInfoList(0),
          m_fNoInfoList(false)
{

    //  Override seeking caps
    m_dwSeekingCaps = AM_SEEKING_CanSeekForwards
                    | AM_SEEKING_CanSeekBackwards
                    | AM_SEEKING_CanSeekAbsolute
                    | AM_SEEKING_CanGetStopPos
                    | AM_SEEKING_CanGetDuration
                    | AM_SEEKING_CanDoSegments;
    CreateInputPin(&m_pInPin);

    DbgLog((LOG_TRACE, 1, TEXT("CWAVEParse created")));
}


//
// CWAVEParse::Destructor
//
CWAVEParse::~CWAVEParse(void) {

    DbgLog((LOG_TRACE, 1, TEXT("CWAVEParse destroyed")) );

    ASSERT(m_pInfoList == 0);
    ASSERT(!m_fNoInfoList);
}


//
// CreateInstance
//
// Called by CoCreateInstance to create a QuicktimeReader filter.
CUnknown *CWAVEParse::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr) {

    CUnknown *punk = new CWAVEParse(NAME("WAVE parsing filter"), lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }
    return punk;
}


#define SWAP(x,y)   (((x)^=(y)), ((y)^=(x)), ((x)^=(y)))

void inline SwapDWORD( DWORD *pdw )
{
    *pdw = _lrotl(((*pdw & 0xFF00FF00) >> 8) | ((*pdw & 0x00FF00FF) << 8), 16);
}

WORD inline SwapWORD(WORD w)
{
        return ((w & 0x00FF) << 8) |
               ((w & 0xFF00) >> 8) ;
}

void inline SwapWORD( WORD *pw )
{
    *pw = SwapWORD(*pw);
}


typedef struct {
    DWORD magic;               /* magic number SND_MAGIC */
    DWORD dataLocation;        /* offset or poDWORDer to the data */
    DWORD dataSize;            /* number of bytes of data */
    DWORD dataFormat;          /* the data format code */
    DWORD samplingRate;        /* the sampling rate */
    DWORD channelCount;        /* the number of channels */
    DWORD fccInfo;             /* optional text information */
} SNDSoundStruct;

#define  SND_FORMAT_MULAW_8   1 // 8-bit mu-law samples
#define  SND_FORMAT_LINEAR_8  2 // 8-bit linear samples (twos complement)
#define  SND_FORMAT_LINEAR_16 3 // 16-bit linear samples (twos complement, moto order)


// get an extended value and return this value converted to a long
LONG ExtendedToLong(BYTE *pExt)
{
    LONG lRtn;
    WORD wNeg, wExp;

    wNeg = pExt[0] & 0x80;

    wExp = (((WORD)(pExt[0] & 0x7F)<<8) + (BYTE)pExt[1] - 16383) & 0x07FF;

    if( (wExp > 24) || (wExp <= 0 ) ) {
        return( (LONG)0xFFFFFFFF );
    }

    if( wExp > 15 ) {
        lRtn = ((wExp < 7) ? ( (BYTE)pExt[2] >> (7-wExp) ) :
            (DWORD)((BYTE)pExt[2] << (wExp-7)));
    } else {
        lRtn = ((wExp < 7) ? ( (BYTE)pExt[2] >> (7-wExp) ) :
            (WORD)((BYTE)pExt[2] << (wExp-7)));
    }

    lRtn += ((wExp<15) ? ( (BYTE)pExt[3] >> (15-wExp) ) :
            ((BYTE)pExt[3] << (wExp-15)));

    lRtn += ((wExp<23) ? ( (BYTE)pExt[4] >> (23-wExp) ) :
            ((BYTE)pExt[4] << (wExp-23)));

    if( wNeg ) {
        lRtn = 0 - lRtn;
    }

    return( lRtn );
}


#include <pshpack2.h>
typedef struct {
    WORD    channels;
    BYTE    frames[4];
    WORD    bits;
    BYTE    extRate[10];        // IEEE extended double
} AIFFFMT;

// Extended Common Chunk
struct AIFCFMT :
    public AIFFFMT
{
    DWORD   compressionType;    // this is the DWORD on a WORD boundary
    // BYTE    compressionName; // variable size string for compression type
};
#include <poppack.h>




//
// structures for manipulating RIFF headers
//
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))


// functions shared between avi parser and wav parser
HRESULT SearchList(
    IAsyncReader *pAsyncReader,
    DWORDLONG *qwPosOut, FOURCC fccSearchKey,
    DWORDLONG qwPosStart, ULONG *cb);

HRESULT SaveInfoChunk(
    RIFFLIST UNALIGNED *pRiffInfo, IPropertyBag *pbag);

HRESULT GetInfoStringHelper(RIFFLIST *pInfoList, DWORD dwFcc, BSTR *pbstr);


#define C_QUEUED_SAMPLES 5


HRESULT CWAVEParse::CreateOutputPins()
{
    HRESULT         hr = NOERROR;
    RIFFLIST        ckhead;

    const int MAX_STREAMS = 1;
    m_rgpOutPin = new CBaseMSROutPin*[MAX_STREAMS];
    if (!m_rgpOutPin)
        return E_OUTOFMEMORY;

    m_rgpOutPin[0] = 0;

    /* Try to read RIFF chunk header */
    hr = m_pAsyncReader->SyncRead(0, sizeof(ckhead), (BYTE *) &ckhead);

    if (hr != S_OK)
        goto readerror;

    CWAVEStream *ps;

    if (ckhead.fcc == FCC('RIFF')) {
        DWORD dwPos = sizeof(RIFFLIST);

        DWORD dwFileSize = ckhead.cb + sizeof(RIFFCHUNK);

        if (ckhead.fccListType != FCC('WAVE'))
            goto formaterror;

        RIFFCHUNK ck;
        while (1) {
            if (dwPos > dwFileSize - sizeof(RIFFCHUNK)) {
                DbgLog((LOG_TRACE, 1, TEXT("eof while searching for fmt")));
                goto readerror;
            }

            hr = m_pAsyncReader->SyncRead(dwPos, sizeof(ck), (BYTE *) &ck);
            if (hr != S_OK)
                goto readerror;

            // !!! handle 'fact' chunk here?

            if (ck.fcc == FCC('fmt '))
                break;

            dwPos += sizeof(ck) + (ck.cb + (ck.cb & 1));
        }

        DbgLog((LOG_TRACE, 1, TEXT("found fmt at %x"), dwPos));

        m_rgpOutPin[0] = ps = new CWAVEStream(NAME("WAVE Stream Object"), &hr, this,
                                   L"output", m_cStreams);
        if (FAILED(hr)) {
            delete m_rgpOutPin[0];
            m_rgpOutPin[0] = NULL;
        }

        if (!m_rgpOutPin[0])
            goto memerror;

        m_cStreams++;
        m_rgpOutPin[0]->AddRef();

        BYTE *pbwfx = new BYTE[ck.cb];
        if (pbwfx == NULL)
            goto memerror;

        hr = m_pAsyncReader->SyncRead(dwPos + sizeof(RIFFCHUNK), ck.cb, pbwfx);
        if (hr != S_OK)
        {
            delete[] pbwfx;
            goto readerror;
        }

        extern HRESULT SetAudioSubtypeAndFormat(CMediaType *pmt, BYTE *pbwfx, ULONG cbwfx);
        HRESULT hrTmp = SetAudioSubtypeAndFormat(&ps->m_mtStream, pbwfx, ck.cb);
        delete[] pbwfx;

        if(hrTmp != S_OK) {
            goto memerror;
        }
    

        

        // work around acm bug for broken pcm files
        {
            WAVEFORMATEX *pwfx = (WAVEFORMATEX *)ps->m_mtStream.Format();
            if(pwfx->wFormatTag == WAVE_FORMAT_PCM /* && pwfx->cbSize != 0 */)
                pwfx->cbSize = 0;
        }

        // keep a private copy of the interesting part
        CopyMemory((void *)&ps->m_wfx, ps->m_mtStream.Format(), sizeof(WAVEFORMATEX));

        // verify important header fields?
        if (ps->m_wfx.nBlockAlign == 0) // would cause div by 0
            goto readerror;

        //CreateAudioMediaType(&ps->m_wfx, &ps->m_mtStream, FALSE);
        ps->m_mtStream.majortype            = MEDIATYPE_Audio;
        ps->m_mtStream.formattype           = FORMAT_WaveFormatEx;
        ps->m_mtStream.bFixedSizeSamples    = TRUE;
        ps->m_mtStream.bTemporalCompression = FALSE;
        ps->m_mtStream.lSampleSize          = ps->m_wfx.nBlockAlign;
        ps->m_mtStream.pUnk                 = NULL;

        while (1) {
            dwPos += sizeof(ck) + (ck.cb + (ck.cb & 1));
            if (dwPos > dwFileSize - sizeof(RIFFCHUNK)) {
                DbgLog((LOG_TRACE, 1, TEXT("eof while searching for data")));
                goto readerror;
            }

            hr = m_pAsyncReader->SyncRead(dwPos, sizeof(ck), (BYTE *) &ck);
            if (hr != S_OK)
                goto readerror;

            if (ck.fcc == FCC('data'))
                break;
        }

        DbgLog((LOG_TRACE, 1, TEXT("found data at %x"), dwPos));

        ps->m_dwDataOffset = dwPos + sizeof(ck);
        ps->m_dwDataLength = ck.cb;
    } else if (ckhead.fcc == FCC('FORM')) {
        //
        //  AIFF and some AIFF-C support
        //

        DWORD   dwPos = sizeof(RIFFLIST);
        BOOL    bFoundSSND = FALSE;
        BOOL    bFoundCOMM = FALSE;

        SwapDWORD(&ckhead.cb);
        DWORD dwFileSize = ckhead.cb + sizeof(RIFFCHUNK);

        if (ckhead.fccListType != FCC('AIFF') &&
            ckhead.fccListType != FCC('AIFC'))
            goto formaterror;

        m_rgpOutPin[0] = ps = new CWAVEStream(NAME("WAVE Stream Object"), &hr, this,
                                   L"output", m_cStreams);
        if (FAILED(hr)) {
            delete m_rgpOutPin[0];
            m_rgpOutPin[0] = NULL;
        }

        if (!m_rgpOutPin[0])
            goto memerror;

        m_cStreams++;
        m_rgpOutPin[0]->AddRef();

        RIFFCHUNK ck;
        AIFFFMT     header;

        while (!(bFoundCOMM && bFoundSSND)) {
            if (dwPos > dwFileSize - sizeof(RIFFCHUNK)) {
                DbgLog((LOG_TRACE, 1, TEXT("eof while searching for COMM")));
                goto readerror;
            }

            hr = m_pAsyncReader->SyncRead(dwPos, sizeof(ck), (BYTE *) &ck);
            if (hr != S_OK)
                goto readerror;

            SwapDWORD(&ck.cb);

            if (ck.fcc == FCC('COMM')) {

                // treat the mystery common chunk with 2 extra bytes
                // as a normal common chunk
                if(ck.cb == sizeof(AIFFFMT) || ck.cb == sizeof(AIFFFMT) + 2) {
                    /* Try to read AIFF format */
                    hr = m_pAsyncReader->SyncRead(dwPos + sizeof(RIFFCHUNK), sizeof(header), (BYTE *) &header);

                    if (hr != S_OK)
                        goto readerror;

                    DbgLog((LOG_TRACE, 1, TEXT("found COMM at %x"), dwPos));

                    SwapWORD(&header.channels);
                    SwapWORD(&header.bits);

                    bFoundCOMM = TRUE;
                }
                else if(ck.cb >= sizeof(AIFCFMT))
                {
                    AIFCFMT extHeader;
                    /* Try to read AIFC format */
                    hr = m_pAsyncReader->SyncRead(dwPos + sizeof(RIFFCHUNK), sizeof(extHeader), (BYTE *) &extHeader);

                    if (hr != S_OK)
                        goto readerror;

                    // we can only handle uncompressed AIFC...
                    if(extHeader.compressionType != FCC('NONE'))
                    {
                        DbgLog((LOG_ERROR, 1, TEXT("wavemsr: unhandled AIFC")));
                        hr = VFW_E_UNSUPPORTED_AUDIO;
                        goto error;
                    }

                    DbgLog((LOG_TRACE, 1, TEXT("found extended-COMM at %x"), dwPos));
                    CopyMemory(&header, &extHeader, sizeof(header));

                    SwapWORD(&header.channels);
                    SwapWORD(&header.bits);

                    bFoundCOMM = TRUE;
                }
                else
                {
                    DbgLog((LOG_ERROR, 1, TEXT("bad COMM size %x"), ck.cb));
                    goto formaterror;
                }
            }

            if (ck.fcc == FCC('SSND')) {
                DbgLog((LOG_TRACE, 1, TEXT("found data SSND at %x"), dwPos));
                bFoundSSND = TRUE;
                /* Tell rest of handler where data is */
                ps->m_dwDataOffset = dwPos + sizeof(ck);

                LONGLONG llLength = 0, llAvail;
                m_pAsyncReader->Length(&llLength, &llAvail);
                if(llLength != 0)
                  ps->m_dwDataLength = min(ck.cb, ((ULONG)(llLength - ps->m_dwDataOffset)));
                else
                  ps->m_dwDataLength = ck.cb;
            }

            dwPos += sizeof(ck) + ck.cb;
        }

        // fill in wave format fields
        ps->m_wfx.wFormatTag = WAVE_FORMAT_PCM;
        ps->m_wfx.nChannels = header.channels;
        ps->m_wfx.nSamplesPerSec = ExtendedToLong(header.extRate);
        ps->m_wfx.wBitsPerSample = header.bits;
        ps->m_wfx.nBlockAlign = header.bits / 8 * header.channels;
        ps->m_wfx.nAvgBytesPerSec = ps->m_wfx.nSamplesPerSec * ps->m_wfx.nBlockAlign;
        ps->m_wfx.cbSize = 0;

        if (header.bits == 8)
            ps->m_bSignMunge8 = TRUE;
        else if (header.bits == 16)
            ps->m_bByteSwap16 = TRUE;
        else
            goto formaterror;

        if (ps->m_mtStream.AllocFormatBuffer(sizeof(WAVEFORMATEX)) == NULL)
            goto memerror;

        // keep a private copy of the interesting part
        CopyMemory(ps->m_mtStream.Format(), (void *)&ps->m_wfx, sizeof(WAVEFORMATEX));

        CreateAudioMediaType(&ps->m_wfx, &ps->m_mtStream, FALSE);
        // !!! anything else?

    } else {
        //
        //  AU support
        //

        SNDSoundStruct  header;

        /* Try to read AU header */
        hr = m_pAsyncReader->SyncRead(0, sizeof(header), (BYTE *) &header);

        if (hr != S_OK)
            goto readerror;

        // validate header
        if (header.magic != FCC('.snd'))
            goto formaterror;


        SwapDWORD(&header.dataFormat);
        SwapDWORD(&header.dataLocation);
        SwapDWORD(&header.dataSize);
        SwapDWORD(&header.samplingRate);
        SwapDWORD(&header.channelCount);


        m_rgpOutPin[0] = ps = new CWAVEStream(NAME("WAVE Stream Object"), &hr, this,
                                   L"output", m_cStreams);
        if (FAILED(hr)) {
            delete m_rgpOutPin[0];
            m_rgpOutPin[0] = NULL;
        }

        if (!m_rgpOutPin[0])
            goto memerror;

        m_cStreams++;
        m_rgpOutPin[0]->AddRef();

        // fill in wave format fields
        if (header.dataFormat == SND_FORMAT_MULAW_8) {
            ps->m_wfx.wFormatTag = WAVE_FORMAT_MULAW;
            ps->m_wfx.wBitsPerSample = 8;

            // !!! HACK: if the sampling rate is almost 8KHz, make it be
            // exactly 8KHz, so that more sound cards will play it right.
            if (header.samplingRate > 7980 && header.samplingRate < 8020)
                header.samplingRate = 8000;

        } else if (header.dataFormat == SND_FORMAT_LINEAR_8) {
            ps->m_wfx.wFormatTag = WAVE_FORMAT_PCM;
            ps->m_wfx.wBitsPerSample = 8;
            ps->m_bSignMunge8 = TRUE;
        } else if (header.dataFormat == SND_FORMAT_LINEAR_16) {
            ps->m_wfx.wFormatTag = WAVE_FORMAT_PCM;
            ps->m_wfx.wBitsPerSample = 16;
            ps->m_bByteSwap16 = TRUE;
        } else
            goto error;

        ps->m_wfx.nChannels = (UINT) header.channelCount;
        ps->m_wfx.nSamplesPerSec = header.samplingRate;
        ps->m_wfx.nBlockAlign = ps->m_wfx.wBitsPerSample * ps->m_wfx.nChannels / 8;
        ps->m_wfx.nAvgBytesPerSec =  header.samplingRate * ps->m_wfx.nBlockAlign;
        ps->m_wfx.cbSize = 0;

        /* Tell rest of handler where data is */
        ps->m_dwDataOffset = header.dataLocation;
        LONGLONG llLength = 0, llAvail;
        m_pAsyncReader->Length(&llLength, &llAvail);
        if (header.dataSize == 0xffffffff) {
            // can't really play these if the length is zero (ftp case)
            ps->m_dwDataLength = (DWORD) llLength - header.dataLocation;
        } else {
            if(llLength != 0)
              ps->m_dwDataLength = min(header.dataSize, (DWORD) llLength - header.dataLocation);
            else
              ps->m_dwDataLength = header.dataSize;
        }

        if (ps->m_mtStream.AllocFormatBuffer(sizeof(WAVEFORMATEX)) == NULL)
            goto memerror;

        // keep a private copy of the interesting part
        CopyMemory(ps->m_mtStream.Format(), (void *)&ps->m_wfx, sizeof(WAVEFORMATEX));

        CreateAudioMediaType(&ps->m_wfx, &ps->m_mtStream, FALSE);
        // !!! anything else?
    }

    if (hr == S_OK) {
        // set up allocator
        ALLOCATOR_PROPERTIES Request,Actual;

        // plus ten so that there are more samples than samplereqs;
        // GetBuffer blocks only when the downstream guy has a few
        // samples
        Request.cBuffers = C_QUEUED_SAMPLES + 3;

        Request.cbBuffer = ps->GetMaxSampleSize();
        Request.cbAlign = (LONG) 1;
        Request.cbPrefix = (LONG) 0;

        // m_pAllocator is not set, so use m_pRecAllocator
        HRESULT hr = ps->m_pRecAllocator->SetPropertiesInternal(&Request,&Actual);
        ASSERT(SUCCEEDED(hr));

        // ask for 8 buffers (2 seconds) at pin
        ps->m_pRecAllocator->SetCBuffersReported(8);

    }

    return hr;

formaterror:
    hr = VFW_E_INVALID_FILE_FORMAT;
    goto error;

memerror:
    hr = E_OUTOFMEMORY;
    goto error;

readerror:
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    if (SUCCEEDED(hr)) {
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CWAVEParse::GetCacheParams(
  StreamBufParam *rgSbp,
  ULONG *pcbRead,
  ULONG *pcBuffers,
  int *piLeadingStream)
{
  HRESULT hr = CBaseMSRFilter::GetCacheParams(
    rgSbp,
    pcbRead,
    pcBuffers,
    piLeadingStream);
  if(FAILED(hr))
    return hr;

  // from the base class
  ASSERT(*piLeadingStream < 0);

  // configure the reader to try to read 1 a second at a time (matches the DSOUND buffer length) and use 2 buffers.
  // (AVI files can give a dwMaxBytesPerSec that is too small)
  WAVEFORMAT *pwfx = ((WAVEFORMAT *)((CWAVEStream *)m_rgpOutPin[0])->m_mtStream.Format());

  *pcbRead = max(pwfx->nAvgBytesPerSec, pwfx->nBlockAlign);
  *pcBuffers = 2;

  rgSbp[0].cSamplesMax = C_QUEUED_SAMPLES;

  return S_OK;
}

STDMETHODIMP
CWAVEParse::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if(riid == IID_IPersistMediaPropertyBag)
    {
        return GetInterface((IPersistMediaPropertyBag *)this, ppv);
    }
    else if(riid == IID_IAMMediaContent)
    {
        return GetInterface((IAMMediaContent *)this, ppv);
    }
    else
    {
        return CBaseMSRFilter::NonDelegatingQueryInterface(riid, ppv);
    }
}

// ------------------------------------------------------------------------
// IPersistMediaPropertyBag

STDMETHODIMP CWAVEParse::Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog)
{
    CheckPointer(pPropBag, E_POINTER);

    // the avi parser is read-only!
    HRESULT hr = STG_E_ACCESSDENIED;
    return hr;
}

// dump everything in the info chunk into the caller's property bag

STDMETHODIMP CWAVEParse::Save(
    IMediaPropertyBag *pPropBag,
    BOOL fClearDirty,
    BOOL fSaveAllProperties)
{
    CAutoLock l (m_pLock);
    HRESULT hr = CacheInfoChunk();
    if(SUCCEEDED(hr))
    {
        hr = SaveInfoChunk(m_pInfoList, pPropBag);
    }
    
    return hr;

}

STDMETHODIMP CWAVEParse::InitNew()
{
    return S_OK;
}

STDMETHODIMP CWAVEParse::GetClassID(CLSID *pClsID)
{
    return CBaseFilter::GetClassID(pClsID);
}

HRESULT CWAVEParse::NotifyInputDisconnected()
{
  delete[] (BYTE *)m_pInfoList;
  m_pInfoList = 0;
  m_fNoInfoList = false;

  return CBaseMSRFilter::NotifyInputDisconnected();
}

HRESULT CWAVEParse::CacheInfoChunk()
{
    ASSERT(CritCheckIn(m_pLock));
    
    if(m_pInfoList) {
        return S_OK;
    }
    if(m_fNoInfoList) {
        return VFW_E_NOT_FOUND;
    }

    HRESULT hr = S_OK;

    CMediaType mtIn;
    hr = m_pInPin->ConnectionMediaType(&mtIn);
    if(SUCCEEDED(hr))
    {
        if(*(mtIn.Subtype()) != MEDIASUBTYPE_WAVE)
        {
            hr= E_FAIL;
        }
    }

    if(SUCCEEDED(hr))
    {

        // !!! don't block waiting for progressive download

        // search the first RIFF list for an INFO list
        DWORDLONG dwlInfoPos;
        ULONG cbInfoList;
        hr = SearchList(
            m_pAsyncReader,
            &dwlInfoPos, FCC('INFO'), sizeof(RIFFLIST), &cbInfoList);
        if(SUCCEEDED(hr))
        {
            hr = AllocateAndRead((BYTE **)&m_pInfoList, cbInfoList, dwlInfoPos);
        }
    }
    if(FAILED(hr)) {
        ASSERT(!m_fNoInfoList);
        m_fNoInfoList = true;
    }

    return hr;
    
}

// *
// * Implements CWAVEStream - manages the output pin
//

//
// CWAVEStream::Constructor
//
// keep the driver index to open.
// We will open it when we go active, as we shouldn't keep resources
// whilst inactive.
CWAVEStream::CWAVEStream(TCHAR     *pObjectName
                      , HRESULT *phr
                      , CWAVEParse    *pParentFilter
                      , LPCWSTR pPinName
                      , int     id
                      )
    : CBaseMSROutPin(pParentFilter, pParentFilter, id,
                     pParentFilter->m_pImplBuffer, phr, pPinName),
       m_id(id),
       m_bByteSwap16(FALSE),
       m_bSignMunge8(FALSE),
       m_pFilter(pParentFilter)
    {

    DbgLog( (LOG_TRACE, 1, TEXT("CWAVEStream created") ) );
}


//
// CWAVEStream::Destructor
//
// we should be inactive before this is called.
CWAVEStream::~CWAVEStream(void) {
    ASSERT(!m_pFilter->IsActive());

    DbgLog( (LOG_TRACE, 1, TEXT("CWAVEStream destroyed") ) );
}


//
// GetMediaType
//
// Queries the video driver and places an appropriate media type in *pmt
HRESULT CWAVEStream::GetMediaType(int iPosition, CMediaType *pmt) {
    CAutoLock l(&m_cSharedState);

    HRESULT hr;

    // check it is the single type they want
    // This method is only called by base class code so we don't have to
    // check arguments
    if (iPosition != 0 && 
        !(iPosition == 1 && m_wfx.wFormatTag == WAVE_FORMAT_MPEG)) {
        hr =  VFW_S_NO_MORE_ITEMS;
    } else {
        *pmt = m_mtStream;
    
        //  Backwards compatibility
        if (iPosition == 1) {
            pmt->subtype = MEDIASUBTYPE_MPEG1Payload;
        }
        if (pmt->pbFormat == NULL) {
            hr = E_OUTOFMEMORY;
        } else {
            hr = S_OK;
        }
    }

    return hr;
}


//
// Active
//
//
HRESULT CWAVEStream::OnActive() {

    HRESULT hr = NOERROR;

    if(!m_pWorker) {
        m_pWorker = new CWAVEMSRWorker(m_id, m_rpImplBuffer, this);
        if(m_pWorker == 0)
            return E_OUTOFMEMORY;
    }

    return hr;
}

BOOL CWAVEStream::UseDownstreamAllocator()
{
  return m_bSignMunge8 || m_bByteSwap16;
}

HRESULT CWAVEStream::DecideBufferSize(
    IMemAllocator * pAlloc,
    ALLOCATOR_PROPERTIES *pProperties) {
    HRESULT hr;

    ALLOCATOR_PROPERTIES Request,Actual;

    // configure this allocator same as internal allocator. note
    // GetProperties reports the value saved in SetCBuffersReported
    hr = m_pRecAllocator->GetProperties(&Request);
    if(FAILED(hr))
      return hr;

    hr = pAlloc->SetProperties(&Request,&Actual);
    if(FAILED(hr))
      return hr;

    if(Actual.cbBuffer < Request.cbBuffer)
      return E_UNEXPECTED;

    return S_OK;
}

ULONG CWAVEStream::GetMaxSampleSize()
{
    ULONG ul = max(m_wfx.nAvgBytesPerSec / 4, m_wfx.nBlockAlign);

    ul += (m_wfx.nBlockAlign - 1);
    ul -= (ul % m_wfx.nBlockAlign);
    return ul;
}

HRESULT CWAVEStream::GetDuration(LONGLONG *pDuration)
{
  if(m_guidFormat == TIME_FORMAT_SAMPLE)
  {
    *pDuration = ((m_dwDataLength + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign);
  }
  else
  {
    ASSERT(m_guidFormat == TIME_FORMAT_MEDIA_TIME);
    *pDuration = SampleToRefTime(((m_dwDataLength + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign));
  }

  return S_OK;
}

HRESULT CWAVEStream::GetAvailable(LONGLONG * pEarliest, LONGLONG * pLatest)
{
  if (pEarliest)
    *pEarliest = 0;

  if (pLatest)
  {
    // ask the source file reader how much of the file is available
    LONGLONG llLength, llAvail;
    m_pFilter->m_pAsyncReader->Length(&llLength, &llAvail);

    DWORD dwAvail = 0;

    // the current read position may be before the actual wave data
    // !!! wouldn't work right for wave files > 2GB
    if ((DWORD) llAvail > m_dwDataOffset)
        dwAvail = (DWORD) llAvail - m_dwDataOffset;

    // or after the end....
    if (dwAvail > m_dwDataLength)
        dwAvail = m_dwDataLength;


    if(m_guidFormat == TIME_FORMAT_SAMPLE)
    {
      *pLatest = ((dwAvail + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign);
    }
    else
    {
      ASSERT(m_guidFormat == TIME_FORMAT_MEDIA_TIME);
      *pLatest = SampleToRefTime(((dwAvail + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign));
    }
  }

  return S_OK;
}

HRESULT CWAVEStream::IsFormatSupported(const GUID *const pFormat)
{
  // !!! only support time_format_sample for pcm?

  if(*pFormat == TIME_FORMAT_MEDIA_TIME)
    return S_OK;
  else if(*pFormat == TIME_FORMAT_SAMPLE &&
          ((WAVEFORMATEX *)m_mtStream.Format())->wFormatTag == WAVE_FORMAT_PCM)
    return S_OK;

  return S_FALSE;
}



HRESULT CWAVEStream::RecordStartAndStop(
  LONGLONG *pCurrent, LONGLONG *pStop, REFTIME *pTime,
  const GUID *const pGuidFormat
  )
{
  if(*pGuidFormat == TIME_FORMAT_MEDIA_TIME)
  {
    if(pCurrent)
      m_llCvtImsStart = RefTimeToSample(*pCurrent);

    // we want to round up the stop time for apps which round down the
    // stop time then get confused when we round it down further. This
    // relies on RefTimeToSample rounding down always
    if(pStop)
      m_llCvtImsStop = RefTimeToSample(*pStop + SampleToRefTime(1) - 1);

    if(pTime)
    {
      ASSERT(pCurrent);
      *pTime = (double)(*pCurrent) / UNITS;
    }

    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ms"),
            pCurrent ? (long)(*pCurrent) : -1,
            pStop ? (long)(*pStop) : -1));
    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ticks"),
            (long)m_llCvtImsStart,
            (long)m_llCvtImsStop));
  }
  else
  {
    ASSERT(*pGuidFormat == TIME_FORMAT_SAMPLE);
    if(pCurrent)
      m_llCvtImsStart = *pCurrent;

    if(pStop)
      m_llCvtImsStop = *pStop;

    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ticks"),
            pCurrent ? (long)(*pCurrent) : -1,
            pStop ? (long)(*pStop) : -1));

    DbgLog((LOG_TRACE, 5,
            TEXT("wav parser RecordStartAndStop: %d to %d ticks"),
            (long)m_llCvtImsStart,
            (long)m_llCvtImsStop));

    if(pTime)
    {
      ASSERT(pCurrent);
      *pTime = (double)SampleToRefTime((long)(*pCurrent)) / UNITS;
    }
  }

  return S_OK;
}

REFERENCE_TIME CWAVEStream::ConvertInternalToRT(const LONGLONG llVal)
{
  return SampleToRefTime((long)llVal);
}

LONGLONG CWAVEStream::ConvertRTToInternal(const REFERENCE_TIME rtVal)
{
  return RefTimeToSample(rtVal);
}

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

CWAVEMSRWorker::CWAVEMSRWorker(UINT stream,
                             IMultiStreamReader *pReader,
                             CWAVEStream *pStream) :
    CBaseMSRWorker(stream, pReader),
    m_ps(pStream)
{
}


// Start streaming & reset time samples are stamped with.
HRESULT CWAVEMSRWorker::PushLoopInit(LONGLONG *pllCurrentOut, ImsValues *pImsValues)
{
// !!!!    CAutoLock l(&m_cSharedState);

    m_sampCurrent = (long)pImsValues->llTickStart;

    DbgLog((LOG_TRACE, 1, TEXT("Playing samples %d to %d, starting from %d"),
            (ULONG)pImsValues->llTickStart, (ULONG)pImsValues->llTickStop, m_sampCurrent));

    *pllCurrentOut = pImsValues->llTickStart;

    return NOERROR;
}


HRESULT CWAVEMSRWorker::AboutToDeliver(IMediaSample *pSample)
{
    if (m_ps->m_wfx.wFormatTag == WAVE_FORMAT_MPEG ||
        m_ps->m_wfx.wFormatTag == WAVE_FORMAT_MPEGLAYER3) {
        FixMPEGAudioTimeStamps(pSample, m_cSamples == 0, &m_ps->m_wfx);
    }
    if (m_cSamples == 0) {
        pSample->SetDiscontinuity(TRUE);
    }

    return S_OK;
}


// QueueBuffer
//
// Queue another read....
HRESULT CWAVEMSRWorker::TryQueueSample(
  LONGLONG &rllCurrent,         // current time updated
  BOOL &rfQueuedSample,         // [out] queued sample?
  ImsValues *pImsValues
  )
{
    HRESULT hr;
    rfQueuedSample = FALSE;

    // sample passed into QueueRead().
    CRecSample *pSampleOut = 0;

    // actually read data

    // get an empty sample w/ no allocated space. ok if this blocks
    // because we configured it with more samples than there are
    // SampleReqs for this stream in the buffer. that means that if
    // it blocks it is because down stream filters have refcounts on
    // samples
    hr = m_ps->GetDeliveryBufferInternal(&pSampleOut, 0, 0, 0);
    if (FAILED(hr)) {
        DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::PushLoop: getbuffer failed")));
        return hr;
    }

    ASSERT(pSampleOut != 0);

    LONG        lSamplesTotal = m_ps->GetMaxSampleSize() / m_ps->m_wfx.nBlockAlign;

    LONG        lSamplesRead = 0;
    LONG        lBytesRead = 0;
    LONG        lSampleStart = m_sampCurrent;

    if (m_sampCurrent + lSamplesTotal > pImsValues->llTickStop)
    {
        lSamplesTotal = (long)pImsValues->llTickStop - m_sampCurrent;

        // Had to add the bomb proofing.  Don't know why...
        if (lSamplesTotal < 0) lSamplesTotal = 0;
    }

    if (lSamplesTotal == 0)
    {
        hr = VFW_S_NO_MORE_ITEMS;
    }
    else  {
        LONG lByteOffset = m_sampCurrent * m_ps->m_wfx.nBlockAlign;
        lBytesRead = lSamplesTotal * m_ps->m_wfx.nBlockAlign;
        if(lByteOffset + lBytesRead > (long)m_ps->m_dwDataLength)
          lBytesRead = m_ps->m_dwDataLength - lByteOffset;

        hr = m_pReader->QueueReadSample(lByteOffset + m_ps->m_dwDataOffset,
                                        lBytesRead, pSampleOut, m_id);

        if (hr == S_OK) {
            m_sampCurrent += lSamplesTotal;
        }
    }

    if (hr == S_OK) {
        pSampleOut->SetActualDataLength(lBytesRead);
    }

    if (hr == E_OUTOFMEMORY) {
        DbgLog((LOG_TRACE, 5, TEXT("CBaseMSRWorker::TryQSample: q full") ));
        hr = S_FALSE;
    }

    // real error or the downstream filter stopped.
    if(FAILED(hr))
    {
      DbgLog(( LOG_ERROR, 5, TEXT("CWAVEMSRWorker::TryQSample: error %08x"), hr ));
    }

    if (hr == S_OK) {

        REFERENCE_TIME rtstStart = (REFERENCE_TIME)m_ps->SampleToRefTime(lSampleStart - (long)pImsValues->llTickStart);
        REFERENCE_TIME rtstEnd = (REFERENCE_TIME)m_ps->SampleToRefTime(m_sampCurrent - (long)pImsValues->llTickStart);

        // adjust both times by Rate. !!! adjust media time?
        if(pImsValues->dRate != 1 && pImsValues->dRate != 0)
        {
            // scale up and divide
            rtstStart = (REFERENCE_TIME)((double)rtstStart / pImsValues->dRate);
            rtstEnd = (REFERENCE_TIME)((double)rtstEnd / pImsValues->dRate);
        }

        rtstStart += m_pPin->m_rtAccumulated;
        rtstEnd   += m_pPin->m_rtAccumulated;

        pSampleOut->SetTime(&rtstStart, &rtstEnd);

        LONGLONG llmtStart = lSampleStart, llmtEnd = m_sampCurrent;
        pSampleOut->SetMediaTime(&llmtStart, &llmtEnd);

        rfQueuedSample = TRUE;

        DbgLog((LOG_TRACE, 0x3f,
                TEXT("wav parser: queued %d to %d ticks. %d bytes"),
                (LONG)llmtStart, (LONG)llmtEnd, lBytesRead));
    }

    // !!! set discontinuity, key frame bits

    // Release sample, refcount will be kept by reader code if appropriate.
    pSampleOut->Release();

    return hr;
}


// returns the sample number showing at time t
LONG
CWAVEStream::RefTimeToSample(CRefTime t)
{
    // Rounding down
    LONG s = (LONG) ((t.GetUnits() * m_wfx.nAvgBytesPerSec) / (UNITS * m_wfx.nBlockAlign));

    return s;
}

CRefTime
CWAVEStream::SampleToRefTime(LONG s)
{
    // Rounding up
    return llMulDiv( s, m_wfx.nBlockAlign * UNITS, m_wfx.nAvgBytesPerSec, m_wfx.nAvgBytesPerSec-1 );
}

LONGLONG CWAVEStream::GetStreamStart()
{
    return 0;
}

LONGLONG CWAVEStream::GetStreamLength()
{
    // !!! rounding?
    return (m_dwDataLength + m_wfx.nBlockAlign - 1) / m_wfx.nBlockAlign;
}


HRESULT
CWAVEParse::CheckMediaType(const CMediaType* pmt)
{
    if (*(pmt->Type()) != MEDIATYPE_Stream)
        return E_INVALIDARG;

    if (*(pmt->Subtype()) != MEDIASUBTYPE_WAVE
        && *(pmt->Subtype()) != MEDIASUBTYPE_AU
        && *(pmt->Subtype()) != MEDIASUBTYPE_AIFF)
        return E_INVALIDARG;

    return S_OK;
}


HRESULT CWAVEMSRWorker::CopyData(IMediaSample **ppSampleOut, IMediaSample *pms)
{
    BYTE        *pData;
    BYTE        *pDataOut;
    long        lDataLen;

    ASSERT(m_ps->m_bByteSwap16 || m_ps->m_bSignMunge8);

    // this is the GetDeliveryBuffer in CBaseOutputPin which gets it
    // from the allocator negotiated by the pins. (takes IMediaSample,
    // not CRecSample)
    HRESULT hr = m_pPin->GetDeliveryBuffer(ppSampleOut, 0, 0, 0);
    if(FAILED(hr))
      return hr;

    pms->GetPointer(&pData);
    (*ppSampleOut)->GetPointer(&pDataOut);

    lDataLen = pms->GetActualDataLength();
    ASSERT(lDataLen <= (*ppSampleOut)->GetSize());
    hr = (*ppSampleOut)->SetActualDataLength(lDataLen);
    if(FAILED(hr))
      return hr;

    if (m_ps->m_bByteSwap16) {
        WORD *pw = (WORD *) pData;
        WORD *pwOut = (WORD *)pDataOut;
        for (long l = 0; l < lDataLen / 2; l++) {
            pwOut[l] = SwapWORD(pw[l]);
        }

        // let TwosComplement work from the altered buffer
        pData = (BYTE *)pwOut;
    }

    if (m_ps->m_bSignMunge8) {
        for (long l = 0; l < lDataLen; l++) {
            pDataOut[l] = pData[l] ^ 0x80;
        }
    }

    REFERENCE_TIME rtStart, rtEnd;
    if (SUCCEEDED(pms->GetTime(&rtStart, &rtEnd)))
        (*ppSampleOut)->SetTime(&rtStart, &rtEnd);
    LONGLONG llmtStart, llmtEnd;
    if (SUCCEEDED(pms->GetMediaTime(&llmtStart, &llmtEnd)))
        (*ppSampleOut)->SetMediaTime(&llmtStart, &llmtEnd);

    return S_OK;
}

HRESULT CWAVEParse::GetInfoString(DWORD dwFcc, BSTR *pbstr)
{
    *pbstr = 0;
    CAutoLock l(m_pLock);
    
    HRESULT hr = CacheInfoChunk();
    if(SUCCEEDED(hr)) {
        hr = GetInfoStringHelper(m_pInfoList, dwFcc, pbstr);
    }
    return hr;
}



HRESULT CWAVEParse::get_Copyright(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('ICOP'), pbstrX);
}
HRESULT CWAVEParse::get_AuthorName(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('IART'), pbstrX);
}
HRESULT CWAVEParse::get_Title(BSTR FAR* pbstrX)
{
    return GetInfoString(FCC('INAM'), pbstrX);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wav\wavemsr\wavemsr.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.

extern const AMOVIESETUP_FILTER sudWAVEParse;

#include <aviriff.h>

// CLSID_WAVEParser,
// {D51BD5A1-7548-11cf-A520-0080C77EF58A}
DEFINE_GUID(CLSID_WAVEParser,
0xd51bd5a1, 0x7548, 0x11cf, 0xa5, 0x20, 0x0, 0x80, 0xc7, 0x7e, 0xf5, 0x8a);

#include "reader.h"
#include "alloc.h"
#include "qnetwork.h"

class CWAVEStream;       // manages the output stream & pin

//
// CWAVEParse
//
class CWAVEParse :
    public CBaseMSRFilter,
    public IAMMediaContent,    
    public IPersistMediaPropertyBag
{
    friend class CWAVEStream;
    friend class CWAVEMSRWorker;

public:

    // Construct our filter
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    CCritSec m_cStateLock;      // Lock this when a function accesses
                                // the filter state.
                                // Generally _all_ functions, since access to this
                                // filter will be by multiple threads.

private:

    DECLARE_IUNKNOWN

    // During construction we create the single CWAVEStream object that provides the
    // output pin.
    CWAVEParse(TCHAR *, LPUNKNOWN, HRESULT *);
    ~CWAVEParse();

    // pure CBaseMSRFilter overrides
    HRESULT CreateOutputPins();
    HRESULT CheckMediaType(const CMediaType* mtOut);

    HRESULT GetCacheParams(
      StreamBufParam *rgSbp,
      ULONG *pcbRead,
      ULONG *pcBuffers,
      int *piLeadingStream);

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IPersistMediaPropertyBag methods
    STDMETHODIMP InitNew();
    STDMETHODIMP Load(IMediaPropertyBag *pPropBag, LPERRORLOG pErrorLog);
    STDMETHODIMP Save(IMediaPropertyBag *pPropBag, BOOL fClearDirty,
                      BOOL fSaveAllProperties);
    STDMETHODIMP GetClassID(CLSID *pClsid);

    //
    HRESULT NotifyInputDisconnected();

    HRESULT CacheInfoChunk();
    RIFFLIST *m_pInfoList;
    bool m_fNoInfoList;         // search failed; don't keep searching

  // IAMMediaContent

  STDMETHODIMP GetTypeInfoCount(THIS_ UINT FAR* pctinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetTypeInfo(
    THIS_
    UINT itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo) { return E_NOTIMPL; }

  STDMETHODIMP GetIDsOfNames(
    THIS_
    REFIID riid,
    OLECHAR FAR* FAR* rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID FAR* rgdispid) { return E_NOTIMPL; }

  STDMETHODIMP Invoke(
    THIS_
    DISPID dispidMember,
    REFIID riid,
    LCID lcid,
    WORD wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr) { return E_NOTIMPL; }

  STDMETHODIMP get_AuthorName(BSTR FAR* pbstrAuthorName);
  STDMETHODIMP get_Title(BSTR FAR* pbstrTitle);
  STDMETHODIMP get_Rating(BSTR FAR* pbstrRating) { return E_NOTIMPL; }
  STDMETHODIMP get_Description(BSTR FAR* pbstrDescription) { return E_NOTIMPL; }
  STDMETHODIMP get_Copyright(BSTR FAR* pbstrCopyright);
  STDMETHODIMP get_BaseURL(BSTR FAR* pbstrBaseURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoURL(BSTR FAR* pbstrLogoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_LogoIconURL(BSTR FAR* pbstrLogoIconURL) { return E_NOTIMPL; }
  STDMETHODIMP get_WatermarkURL(BSTR FAR* pbstrWatermarkURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoURL(BSTR FAR* pbstrMoreInfoURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerURL(BSTR FAR* pbstrMoreInfoBannerURL) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoBannerImage(BSTR FAR* pbstrMoreInfoBannerImage) { return E_NOTIMPL; }
  STDMETHODIMP get_MoreInfoText(BSTR FAR* pbstrMoreInfoText) { return E_NOTIMPL; }

  STDMETHODIMP GetInfoString(DWORD dwFcc, BSTR *pbstr);
};


//
// CWAVEStream
//
// Manages the output pins for the various streams
class CWAVEStream : public CBaseMSROutPin {
    friend class CWAVEParse;

public:

    CWAVEStream( TCHAR           *pObjectName
              , HRESULT         *phr
              , CWAVEParse		*pParentFilter
              , LPCWSTR         pPinName
	      , int		id
              );

    ~CWAVEStream();

    //
    //  --- CSourceStream implementation ---
    //
public:

    // base class overrides
    ULONG GetMaxSampleSize();

    // in m_guidFormat units
    HRESULT GetDuration(LONGLONG *pDuration);
    HRESULT GetAvailable(LONGLONG *pEarliest, LONGLONG *pLatest);
    HRESULT IsFormatSupported(const GUID *const pFormat);

    HRESULT RecordStartAndStop(
      LONGLONG *pCurrent, LONGLONG *pStop, REFTIME *pTime,
      const GUID *const pGuidFormat
      );

    REFERENCE_TIME ConvertInternalToRT(const LONGLONG llVal);
    LONGLONG ConvertRTToInternal(const REFERENCE_TIME rtVal);

    HRESULT OnActive();
    BOOL UseDownstreamAllocator();
    HRESULT DecideBufferSize(IMemAllocator * pAlloc, ALLOCATOR_PROPERTIES *pProperties);

private:

    // base class overrides
    HRESULT GetMediaType(int iPosition, CMediaType* pt);
    LONGLONG GetStreamStart();
    LONGLONG GetStreamLength();

private:        // State shared between worker & client
    CCritSec            m_cSharedState;         // Lock this to access this state,
                                                // shared with the worker thread

    // returns the sample number starting at or after time t
    LONG RefTimeToSample(CRefTime t);

    // returns the RefTime for s (media time)
    CRefTime SampleToRefTime(LONG s);

    WAVEFORMATEX            m_wfx;

    CMediaType		    m_mtStream;

    CWAVEParse *	    m_pFilter;

    int			    m_id;			// stream #

    DWORD                   m_dwDataOffset;
    DWORD                   m_dwDataLength;

    BOOL                    m_bByteSwap16;
    BOOL                    m_bSignMunge8;

    friend class CWAVEMSRWorker;
};

// ------------------------------------------------------------------------
// ------------------------------------------------------------------------

class CWAVEMSRWorker : public CBaseMSRWorker
{
public:
  // constructor
  CWAVEMSRWorker(
    UINT stream,
    IMultiStreamReader *pReader,
    CWAVEStream *pStream);

  // pure base overrides
  HRESULT PushLoopInit(LONGLONG *pllCurrentOut, ImsValues *pImsValues);

  // Perform any necessary modifications
  HRESULT AboutToDeliver(IMediaSample *pSample);

  HRESULT TryQueueSample(
    LONGLONG &rllCurrent,       // [in, out]
    BOOL &rfQueuedSample,       // [out]
    ImsValues *pImsValues
    );

  HRESULT CopyData(IMediaSample **ppSampleOut, IMediaSample *pms);

private:

    CWAVEStream *m_ps;

    LONG		    m_sampCurrent;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\camera.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// 1394 based camera filter
//

// Uses CSource & CSourceStream to generate a movie on the fly of
// frames from a 1394 based camera

#include <streams.h>
#include <olectl.h>
#include <initguid.h>
#include <olectlid.h>
#include <stdio.h>
#include "winioctl.h"
#include "icamera.h"
#include "camuids.h"
#include "camera.h"
#include "camerapp.h"
#include "1394cam.h"
#include "p1394.h"
#include "1394api.h"


//-----------------------------------------------------------------------------
// define all kinds of static data that we need for the camera hardware
//-----------------------------------------------------------------------------
static  BYTE	Lookup[256*32*32*4];
static  PBYTE	pBuffer1;
static  PUCHAR		    IsochBufferArray[MAX_CAMERA_BUFFERS];
static  USER_1394_REQUEST   userRequest;
static  DEVICE_OBJECT_ARRAY DeviceObjectArray;
static  DWORD		    cbReturned;
static  ULONG		    Quadlet;
static  ULONG		    Channel;
static  ULONG		    CommandBase;
static  ULONG		    DeviceObject;
static  HANDLE		    hDriver;
static  HANDLE		    hResource;
static  HANDLE		    hBandwidth;


//-----------------------------------------------------------------------------
// COM global table of objects in this dll
//-----------------------------------------------------------------------------
CFactoryTemplate g_Templates[] = {

    {L"", &CLSID_Camera, CCamera::CreateInstance},
    {L"", &CLSID_CameraPropertyPage, CCameraProperties::CreateInstance}

};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//-----------------------------------------------------------------------------
// CreateInstance
//
// The only allowed way to create Cameras.
//-----------------------------------------------------------------------------
CUnknown *CCamera::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CCamera(lpunk, phr);
    if (punk == NULL) {
        *phr = E_OUTOFMEMORY;
    }

    return punk;
}


//-----------------------------------------------------------------------------
// CCamera::Constructor
//
// initialise a CCameraStream object so that we have a pin.
//-----------------------------------------------------------------------------
CCamera::CCamera(LPUNKNOWN lpunk, HRESULT *phr)
    : CSource(NAME("1394 Camera"),lpunk, CLSID_Camera)
{
    CAutoLock l(&m_cStateLock);
    m_bSimFlag = FALSE ;                // not simulating
    m_bFileLoaded = FALSE ;             // initialize
    m_bCameraInited = FALSE ;           // initialize
    m_szFile [0] = NULL ;
    m_nFrameRate = 15 ;
    m_n1394Bandwidth = 320 ;            // 320 bytes for 15 fps
    m_nFrameQuadlet = 0x60000000 ;      // correspond to fps
    m_rtStart = 0 ;
    m_paStreams    = (CSourceStream **) new CCameraStream*[1];
    if (m_paStreams == NULL)
    {
        *phr = E_OUTOFMEMORY;
	    return;
    }
    m_paStreams[0] = new CCameraStream(phr, this, L"A 1394 Camera!");
    if (m_paStreams[0] == NULL)
        *phr = E_OUTOFMEMORY;

    // build the lookup table
    {

        float r, g, b ;
        int idx = 0;
        for (int u = -16; u < 16; u++)
        {
            for (int v = -16; v < 16; v++)
            {
                for (int y = 0; y < 256; y++)
                {
	                r = (y + v*8 * 1.5);                 // Red
	                g = (y - u*8 * 0.25 - v*8 * 0.75);   // Green	    	
	                b = (y + u*8 * 1.75);                // Blue	
	                r = max(min(r,255),0);
	                g = max(min(g,255),0);
	                b = max(min(b,255),0);	
	                Lookup[idx++] = (BYTE)b;
	                Lookup[idx++] = (BYTE)g;
	                Lookup[idx++] = (BYTE)r;
	                idx++;
	            }
            }
        }
    }

	return;

}
//-----------------------------------------------------------------------------
// CCamera::Destructor
//
//-----------------------------------------------------------------------------
CCamera::~CCamera(void)
{
    //
    //  Base class will free our pins
    //
    if (!m_bSimFlag && m_bCameraInited)
        ReleaseCamera () ;

}
//-----------------------------------------------------------------------------
// CCamera::LoadFile -- for simulation testing
//-----------------------------------------------------------------------------
HRESULT CCamera::LoadFile ()
{
    FILE     *stream;
    PDWORD   pb;
    int	     pixcount;
    DWORD    dw;
    int      i ;

    pBuffer1 = (PBYTE) GlobalAllocPtr(GMEM_MOVEABLE,320*240*2);
    if (!pBuffer1)
    {
        DbgLog(( LOG_TRACE, 1, TEXT("Could not alloc raw video buffer"))) ;
        return E_FAIL ;
    }

    if ( NULL == (stream = fopen(m_szFile,"rt") ))
    {
        DbgLog(( LOG_TRACE, 1, TEXT("Could not open file"))) ;
	    return E_FAIL ;
    }

    pb = (PDWORD) pBuffer1;
    pixcount = 0;
    while (pixcount < 240*320)
    {
	    fscanf(stream, "%lx ", &dw);
	    if (0 == dw)
            break;
	    for (i=0; i<4; i++)
        {
            fscanf(stream, "%lx ", &dw);
            *pb++ = dw;
            pixcount += 2;
	    }
    }
    return NOERROR ;
}
//-----------------------------------------------------------------------------
// NonDelegatingQueryInterface
// Reveals ICamera & ISpecifyPropertyPages
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::NonDelegatingQueryInterface(REFIID riid, void ** ppv) {

    if (riid == IID_ICamera)
    {
        return GetInterface((ICamera *) this, ppv);
    }
    else if (riid == IID_ISpecifyPropertyPages)
    {
        return GetInterface((ISpecifyPropertyPages *) this, ppv);
    }
    else
    {
        return CSource::NonDelegatingQueryInterface(riid, ppv);
    }
}
//-----------------------------------------------------------------------------
// DoInitializations
//-----------------------------------------------------------------------------
BOOL CCamera::DoInitializations ()
{
    if (!m_bSimFlag)
    {
        // Init the camera if this is the first time through here

        if (!m_bCameraInited)
        {
            // Init the camera
            if (!InitCamera())
            {
                DbgLog(( LOG_TRACE, 1, TEXT("Could not initialize camera"))) ;
                return FALSE ;
            }
            m_bCameraInited = TRUE ;
        }
    }
    else
    {
        // Load the file if this is the first time through here

        if (!m_bFileLoaded)
        {
            HRESULT hr ;
            hr = LoadFile () ;
            m_bFileLoaded = TRUE ;
            if (FAILED(hr))
                return FALSE ;
        }

    }
    return TRUE ;
}
//-----------------------------------------------------------------------------
// CCmarera::Pause
// -----------------------------------------------------------------------------
STDMETHODIMP CCamera::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    BOOL b = DoInitializations () ;
    if (!b)
        return E_FAIL ;
    HRESULT hr = CSource::Pause () ;
    if (FAILED (hr) && m_bCameraInited)
        ReleaseCamera () ;
    return hr ;
}
//-----------------------------------------------------------------------------
// CCmareRa::Run
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CSource::Run (tStart) ;
    if (FAILED (hr))
        return hr ;
    else
    {
        m_rtStart = tStart ;
        return S_OK ;
    }
}
//-----------------------------------------------------------------------------
// CCamera::GetStreamTime
//-----------------------------------------------------------------------------
HRESULT CCamera::GetStreamTime (REFERENCE_TIME *prTime)
{
    if (m_pClock)               // There is a reference clock
    {
        HRESULT hr = m_pClock->GetTime (prTime) ;
        *prTime -= m_rtStart ;
        return hr ;
    }
    else
        return E_FAIL ;
}
//-----------------------------------------------------------------------------
//  InitCamera
//  Tries to open the 1394Drvr and send it IOCTLs to talk to the camera
//-----------------------------------------------------------------------------
BOOL CCamera::InitCamera()
{
    ULONG i;

    //
    // Try to open the device
    //

    if ((hDriver = CreateFile("\\\\.\\1394DRVR",
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) != ((HANDLE)-1)) {
        //
        // No error
        //
    }

    else {

        //
        // Error occurred
        //

        DbgLog(( LOG_TRACE, 1, TEXT("ERROR: Couldn't open the 1394 Test Driver\n"))) ;
        return FALSE;
    }

    //
    // We've gotta do a hack here since Plug N Play isn't quite working.
    // Currently, the 1394 Class driver enumerates the bus and discovers
    // the existing devices.  Unfortuneately, there is no facility yet
    // for device drivers to be loaded based on what the 1394 Class
    // driver found.  So you've gotta hand load these device drivers,
    // and they've gotta ask the 1394 Class driver "What's my Device Object?"
    // That's what we'll do here.  Make a call to get an Array of Device
    // Objects.  Given the Device Object(s) that come back from the Class
    // driver, we use that Device Object as input to the 1394 Test Driver.
    // NOTE: This hacked up scheme is only temporary, and only really
    // works if you have one device out there on the bus.
    //

    DeviceObjectArray.Returned = 0;

    userRequest.FunctionNumber = CLS_REQUEST_GET_DEVICE_OBJECTS;
    userRequest.u.GetDeviceObjects.nSizeOfBuffer = sizeof(DeviceObjectArray);

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &DeviceObjectArray,
        sizeof(DeviceObjectArray),
       &cbReturned,
        NULL
        );

    DeviceObject = DeviceObjectArray.Buffer[0];

    //
    // Now we send down an IOCtl to the miniport to "enable busted hardware
    // workarounds".  This IOCtl request is caught by the Texas Instruments
    // port driver, who enables some software workarounds when using the
    // Texas Instruments card with the Sony Beta 4 camera.
    //

    userRequest.FunctionNumber = CLS_REQUEST_CONTROL;
    userRequest.u.IoControl.ulIoControlCode = ENABLE_BUSTED_HARDWARE_WORKAROUNDS;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &cbReturned,
        NULL
        );


    //
    // Ok, do some reads to start setting this thing up.  First read
    // configuration ROM and make sure this really is the camera we're
    // talking to
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_READ;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low  = P1394_ROOT_DIR_LOCATION_LO + sizeof(ULONG);
    userRequest.u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    userRequest.u.AsyncRead.nBlockSize = 0;
    userRequest.u.AsyncRead.fulFlags = 0;
    userRequest.u.AsyncRead.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );


    if (Quadlet != '1394') {

        //
        // Something weird happened, better punt
        //

        DbgLog(( LOG_TRACE, 1, TEXT("This device doesn't have the 1394 signiture!\n"))) ;
        CloseHandle(hDriver);
        exit (-1);

    }

    //
    // Obviously a 1394 node, let's see what this guys Unique Node ID is.
    // Should be 0x08004602, which means the Beta 4 Sony camera...
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_READ;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low  = 0xf000040c;
    userRequest.u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    userRequest.u.AsyncRead.nBlockSize = 0;
    userRequest.u.AsyncRead.fulFlags = 0;
    userRequest.u.AsyncRead.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );


    if (Quadlet != 0x08004602) {

        //
        // Something weird happened, better punt
        //

        DbgLog(( LOG_TRACE, 1, TEXT("This is not a Beta4 Sony desktop camera!\n"))) ;
        CloseHandle(hDriver);
        exit (-1);

    }


    //
    // Looking good, now figure out what his offset to unit directory is.
    // From there can traverse thru the directory to see where we really
    // talk to him at.  Offset to unit directory should be 4 quadlets.
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_READ;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low  = 0xf0000424;
    userRequest.u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    userRequest.u.AsyncRead.nBlockSize = 0;
    userRequest.u.AsyncRead.fulFlags = 0;
    userRequest.u.AsyncRead.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );


    if (Quadlet != 0xd1000004) {

        //
        // Something weird happened, better punt
        //

        DbgLog(( LOG_TRACE, 1, TEXT("This camera's unit directory offset is incorrect!\n"))) ;
        CloseHandle(hDriver);
        exit (-1);

    }

    //
    // Only the lower 24 bits of the Unit directory are significant, chuck
    // the upper 8 bits.  Use the offset to read the unit directory.
    //

    Quadlet &= Quadlet & 0x00ffffff;


    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_READ;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low  += ((Quadlet << 2) + 0x0c);
    userRequest.u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    userRequest.u.AsyncRead.nBlockSize = 0;
    userRequest.u.AsyncRead.fulFlags = 0;
    userRequest.u.AsyncRead.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );


    if (Quadlet != 0xd4000001) {

        //
        // Something weird happened, better punt
        //

        DbgLog(( LOG_TRACE, 1, TEXT("This camera's unit dependent directory offset is incorrect!\n"))) ;
        CloseHandle(hDriver);
        exit (-1);

    }

    //
    // Only the lower 24 bits of the Unit dependent directory are significant,
    // chuck the upper 8 bits.  Use the offset to read the unit dependent
    // directory.
    //

    Quadlet &= Quadlet & 0x00ffffff;


    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_READ;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncRead.DestinationAddress.IA_Destination_Offset.Off_Low  += ((Quadlet << 2) + 0x04);
    userRequest.u.AsyncRead.nNumberOfBytesToRead = sizeof(ULONG);
    userRequest.u.AsyncRead.nBlockSize = 0;
    userRequest.u.AsyncRead.fulFlags = 0;
    userRequest.u.AsyncRead.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );


    //
    // Only the lower 24 bits of the command base registers are significant,
    // chuck the upper 8 bits.  After we shift it by 2, and add it to the
    // initial register space definition, we've got the address at which
    // the cameras registers live.
    //

    Quadlet &= Quadlet & 0x00ffffff;
    CommandBase = (Quadlet << 2) + P1394_INITIAL_REGISTER_SPACE;

    //
    // Let's initialize this camera back to factory settings
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_WRITE;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low  = CommandBase + INITIALIZE_REGISTER;
    userRequest.u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    userRequest.u.AsyncWrite.nBlockSize = 0;
    userRequest.u.AsyncWrite.fulFlags = 0;
    userRequest.u.AsyncWrite.Reserved = DeviceObject;
    Quadlet = 0x80000000;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );


    //
    // Try to claim Isochronous hardware/software resources
    //

    userRequest.FunctionNumber = CLS_REQUEST_ISOCH_ALLOCATE_RESOURCES;
    userRequest.u.AllocateResources.fulSpeed = SPEED_FLAGS_100;
    userRequest.u.AllocateResources.fulFlags = ISOCH_RESOURCE_USED_IN_LISTENING;
    userRequest.u.AllocateResources.hResource = NULL;
    userRequest.u.AllocateResources.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &cbReturned,
        NULL
        );


    //
    // Get our resource handle from the 1394 Class driver
    //

    hResource = userRequest.u.AllocateResources.hResource;

    if (!hResource) {

        //
        // Something weird happened, better punt
        //

        DbgLog(( LOG_TRACE, 1, TEXT("Couldn't allocate Isochronous hardware/software resources!\n"))) ;
        CloseHandle(hDriver);
        exit (-1);

    }

    //
    // We're going to do 3.75 frames per second, Using Mode 1, Format 0.
    // This turns out to be 80 bytes per Isochronous packet.  Given this,
    // we're actually allocating enough bandwidth for 640,000 bytes/sec or
    // 5.1 Megabits/sec
    //

    userRequest.FunctionNumber = CLS_REQUEST_ISOCH_ALLOCATE_BANDWIDTH;
    userRequest.u.AllocateBandwidth.nMaxBytesPerFrameRequested = m_n1394Bandwidth;
    userRequest.u.AllocateBandwidth.fulSpeed = SPEED_FLAGS_100;
    userRequest.u.AllocateBandwidth.hBandwidth = NULL;
    userRequest.u.AllocateBandwidth.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &cbReturned,
        NULL
        );


    hBandwidth = userRequest.u.AllocateBandwidth.hBandwidth;

    if (!hBandwidth) {

        //
        // Something weird happened, better punt
        //

        DbgLog(( LOG_TRACE, 1, TEXT("Couldn't allocate Isochronous bandwidth needed!\n"))) ;
        CloseHandle(hDriver);
        exit (-1);

    }

    //
    // Let's get ownership of a Isochronous channel.  Since this Sony
    // Beta 4 camera only supports a few channels (0-15), we better get
    // one of those, otherwise we're in trouble.
    //

    for (i=0; i < MAX_CAMERA_CHANNELS; i++) {

        userRequest.FunctionNumber = CLS_REQUEST_ISOCH_ALLOCATE_CHANNEL;
        userRequest.u.AllocateChannel.nRequestedChannel = i;
        userRequest.u.AllocateChannel.Channel = 0xffffffff;
        userRequest.u.AllocateChannel.Reserved = DeviceObject;

        //
        // Talk to the 1394 Test driver
        //

        DeviceIoControl(
            hDriver,
            (DWORD) IOCTL_P1394_CLASS,
           &userRequest,
            sizeof(USER_1394_REQUEST),
           &userRequest,
            sizeof(USER_1394_REQUEST),
           &cbReturned,
            NULL
            );


        if (userRequest.u.AllocateChannel.Channel != 0xffffffff) {

            //
            // We successfully allocated a channel.  Break out of this
            // loop...
            //

            Channel = userRequest.u.AllocateChannel.Channel;
            break;

        }

    }

    //
    // Allocate some buffers and attach them to the resource handle
    // we secured earlier.  As we allocate each buffer and setup it's
    // respective descriptor, use the index (i) as context information.
    // By doing this, when our IOCtl IRP completes (which indicates that
    // that the buffer has been filled) we know exactly which buffer has
    // been completed.
    //

    for (i=0; i < MAX_CAMERA_BUFFERS; i++) {

        //
        // Allocate memory that this Isoch descriptor will use
        //

        IsochBufferArray[i] = (PUCHAR) GlobalAlloc(GPTR, CAMERA_BUFFER_SIZE);

        if (!IsochBufferArray[i]) {

            //
            // We couldn't allocate memory, just quit.  We're not releasing
            // any bandwidth or channels that we did previously, but if
            // we can't even allocate this memory - we're already pretty
            // hosed.
            //

            DbgLog(( LOG_TRACE, 1, TEXT("Couldn't allocate Isochronous buffers!\n"))) ;
            CloseHandle(hDriver);
            exit (-1);

        }

        userRequest.FunctionNumber = CLS_REQUEST_ISOCH_ATTACH_BUFFERS;
        userRequest.u.AttachBuffers.hResource = hResource;
        userRequest.u.AttachBuffers.IsochDescriptor.fulFlags = ISOCH_DESCRIPTOR_FLAGS_CALLBACK | ISOCH_DESCRIPTOR_FLAGS_CIRCULAR;
        userRequest.u.AttachBuffers.IsochDescriptor.ulLength = CAMERA_BUFFER_SIZE;
        userRequest.u.AttachBuffers.IsochDescriptor.ulSynchronize = 0;
        userRequest.u.AttachBuffers.IsochDescriptor.lpContext = (LPVOID) i;
        userRequest.u.AttachBuffers.Reserved = DeviceObject;


        //
        // Talk to the 1394 Test driver
        //

        DeviceIoControl(
            hDriver,
            (DWORD) IOCTL_P1394_CLASS,
           &userRequest,
            sizeof(USER_1394_REQUEST),
            IsochBufferArray[i],
            CAMERA_BUFFER_SIZE,
           &cbReturned,
            NULL
            );

    }

    //
    // We're almost ready to rock n roll.  All of the Isoch stuff on our
    // end is setup.  However, we need to setup the remaining controls
    // on the camera so we get stuff in the right format, right speed, etc.
    //
    // Set the frame rate to 3.75 frames/sec
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_WRITE;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low  = CommandBase + CURRENT_FRAME_RATE ;
    userRequest.u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    userRequest.u.AsyncWrite.nBlockSize = 0;
    userRequest.u.AsyncWrite.fulFlags = 0;
    userRequest.u.AsyncWrite.Reserved = DeviceObject;
    Quadlet = m_nFrameQuadlet ;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );

    //
    // Set the video mode to Mode 1 320 X 240 YUV 4:2:2
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_WRITE;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low  = CommandBase + CURRENT_VIDEO_MODE;
    userRequest.u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    userRequest.u.AsyncWrite.nBlockSize = 0;
    userRequest.u.AsyncWrite.fulFlags = 0;
    userRequest.u.AsyncWrite.Reserved = DeviceObject;
    Quadlet = 0x20000000;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );

    //
    // Set the video format to Format 0 (VGA)
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_WRITE;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low  = CommandBase + CURRENT_VIDEO_FORMAT;
    userRequest.u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    userRequest.u.AsyncWrite.nBlockSize = 0;
    userRequest.u.AsyncWrite.fulFlags = 0;
    userRequest.u.AsyncWrite.Reserved = DeviceObject;
    Quadlet = 0x80000000;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );

    //
    // Set the Isoch channel to what we've secured
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_WRITE;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low  = CommandBase + CURRENT_VIDEO_FORMAT;
    userRequest.u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    userRequest.u.AsyncWrite.nBlockSize = 0;
    userRequest.u.AsyncWrite.fulFlags = 0;
    userRequest.u.AsyncWrite.Reserved = DeviceObject;
    _asm mov eax, Channel
    _asm bswap eax
    _asm mov Quadlet, eax


    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );

    //
    // Start listening to the specified channel
    //

    userRequest.FunctionNumber = CLS_REQUEST_ISOCH_LISTEN;
    userRequest.u.Listen.nChannel = Channel;
    userRequest.u.Listen.hResource = hResource;
    userRequest.u.Listen.fulFlags = 0;
    userRequest.u.Listen.nStartCycle = 0;
    userRequest.u.Listen.StartTime.QuadPart = 0;
    userRequest.u.Listen.ulSynchronize = 0;
    userRequest.u.Listen.ulTag = 0;
    userRequest.u.Listen.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &cbReturned,
        NULL
        );

    return TRUE;

}
//-----------------------------------------------------------------------------
// ReleaseCamera
//-----------------------------------------------------------------------------
void CCamera::ReleaseCamera()
{
    //
    // Stop listening on the channel
    //

    userRequest.FunctionNumber = CLS_REQUEST_ISOCH_STOP;
    userRequest.u.Stop.nChannel = Channel;
    userRequest.u.Stop.hResource = hResource;
    userRequest.u.Stop.fulFlags = 0;
    userRequest.u.Stop.nStopCycle = 0;
    userRequest.u.Stop.StopTime.QuadPart = 0;
    userRequest.u.Stop.ulSynchronize = 0;
    userRequest.u.Stop.ulTag = 0;
    userRequest.u.Stop.Reserved = DeviceObject;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &cbReturned,
        NULL
        );


    //
    // Tell the camera to stop transmitting
    //

    userRequest.FunctionNumber = CLS_REQUEST_ASYNC_WRITE;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
    userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low  = CommandBase + ISOCH_ENABLE;
    userRequest.u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
    userRequest.u.AsyncWrite.nBlockSize = 0;
    userRequest.u.AsyncWrite.fulFlags = 0;
    userRequest.u.AsyncWrite.Reserved = DeviceObject;
    Quadlet = 0;

    //
    // Talk to the 1394 Test driver
    //

    DeviceIoControl(
        hDriver,
        (DWORD) IOCTL_P1394_CLASS,
       &userRequest,
        sizeof(USER_1394_REQUEST),
       &Quadlet,
        sizeof(Quadlet),
       &cbReturned,
        NULL
        );


}
//-----------------------------------------------------------------------------
//
//  CCameraStream
//
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// CCameraStream::Constructor
//
//-----------------------------------------------------------------------------
CCameraStream::CCameraStream(HRESULT *phr, CCamera *pParent, LPCWSTR pPinName)
    : CSourceStream(NAME("1394 Camera output pin manager"),phr, pParent, pPinName)
    , m_iDefaultRepeatTime(20) // 50 fps
{
    m_Camera = pParent ;

#ifdef PERF
    char foo [1024] ;
    sprintf(foo, "FillBuffer Sample Start");
    m_perfidSampleStart = MSR_REGISTER(foo);
#endif

}


//-----------------------------------------------------------------------------
// CCameraStream::Destructor
//
//-----------------------------------------------------------------------------
CCameraStream::~CCameraStream(void)
{
}


//-----------------------------------------------------------------------------
// FillBuffer
//
// Get a frame from the camera
//-----------------------------------------------------------------------------
HRESULT CCameraStream::FillBuffer(IMediaSample *pms)
{

    BYTE	*pData;
    long	lDataLen;
    PDWORD  pSrcBits ;
    PBYTE   pDstBits ;
    int     col, row, stride ;

    if (!(m_Camera->IsSimulation()))
    {

        // When this thread starts up,
        // We're already listening to the channel specified, but we need to tell
        // the camera to start transmitting.  The reason we listen before we kick
        // the camera to transmit, is cuz if we listen after kicking the camera
        // we have no idea where the start of the Isoch data began.
        //

        userRequest.FunctionNumber = CLS_REQUEST_ASYNC_WRITE;
        userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_High = P1394_ROOT_DIR_LOCATION_HI;
        userRequest.u.AsyncWrite.DestinationAddress.IA_Destination_Offset.Off_Low  = CommandBase + ISOCH_ENABLE;
        userRequest.u.AsyncWrite.nNumberOfBytesToWrite = sizeof(ULONG);
        userRequest.u.AsyncWrite.nBlockSize = 0;
        userRequest.u.AsyncWrite.fulFlags = 0;
        userRequest.u.AsyncWrite.Reserved = DeviceObject;
        Quadlet = 0x80000000;

        //
        // Talk to the 1394 Test driver
        //

        DeviceIoControl(
            hDriver,
            (DWORD) IOCTL_P1394_CLASS,
           &userRequest,
            sizeof(USER_1394_REQUEST),
           &Quadlet,
            sizeof(Quadlet),
           &cbReturned,
            NULL
            );
    }

    pms->GetPointer(&pData);
    lDataLen = pms->GetSize();

    if (!(m_Camera->IsSimulation()))
    {
        //
        // Submit IOCtl to the test driver.  When each descriptor
        // completes, this IOCtl will return, with the context stating
        // which descriptor finished (0 - MAX_CAMERA_BUFFERS)
        //

        userRequest.FunctionNumber = CRUDE_CALLBACK;

        DeviceIoControl(
            hDriver,
            (DWORD) IOCTL_P1394_CLASS,
           &userRequest,
            sizeof(USER_1394_REQUEST),
           &userRequest,
            sizeof(USER_1394_REQUEST),
           &cbReturned,
            NULL
            );

        //
        // Get the context (Index of buffer) that just completed
        //

	    pSrcBits = (PDWORD)IsochBufferArray[userRequest.u.CrudeCallback.Context];
    }
    else
    {
        pSrcBits = (PDWORD) pBuffer1 ;
    }

    pSrcBits += 239*160 ;   // position at the end of last scan line (this will do
                            // DWORD add as pSrcBits is a PDWORD

	pDstBits = pData ;
    row = 240 ;
    col = 320 ;
    stride = 320*4 ; // stride to get back in dwords


	_asm
    {
		mov esi,pSrcBits
		mov edi,pDstBits
l0:
        mov ebx,col
l1:	    			
		mov eax,[esi]		// eax = uuuuuuuu yyyyyyyy vvvvvvvv YYYYYYYY
		add esi,4
		mov cl,al		// save y1
		shr eax,8		// eax = 00000000 uuuuuuuu yyyyyyyy vvvvvvvv
		xchg al,ah		// eax = 00000000 uuuuuuuu vvvvvvvv yyyyyyyy
		ror eax,8		// eax = yyyyyyyy 00000000 uuuuuuuu vvvvvvvv
		shr ah,3		// eax = yyyyyyyy 00000000 000uuuuu vvvvvvvv
		shr ax,3		// eax = yyyyyyyy 00000000 000000uu uuuvvvvv
		rol eax,8		// eax = 00000000 000000uu uuuvvvvv yyyyyyyy

		mov edx,dword ptr Lookup[eax*4]
		mov [edi],edx			 // store it
		mov al,cl
		mov edx,dword ptr Lookup[eax*4]			
		mov [edi+4],edx			 // store it			

		add edi,8
        sub ebx,2
		jnz l1
        sub esi,stride
        sub row,1
        jnz l0
	}



    // do the time stamping

    MSR_NOTE(m_perfidSampleStart) ;

    CRefTime rtStart  ;
    REFERENCE_TIME rt ;
    if (m_Camera->GetStreamTime (&rt) != NOERROR)
        rtStart = m_rtSampleTime ;
    else
    {
        rtStart = rt ;
        m_rtSampleTime = rtStart ;
    }
    m_rtSampleTime   += (LONG)m_iRepeatTime;    // increment to find the finish time

                                                // (adding mSecs to ref time)

//  DbgLog(( LOG_TRACE, 1, TEXT("Start Time %lu, Stop Time: %lu")
//             , (LONG) rtStart, (ULONG) m_rtSampleTime));


    pms->SetTime((REFERENCE_TIME *) &rtStart,
                 (REFERENCE_TIME *) &m_rtSampleTime);

    pms->SetSyncPoint(TRUE);
    return NOERROR;
}


//-----------------------------------------------------------------------------
// Notify
//
// Alter the repeat rate.  Wind it up or down according to the flooding level
// Skip forward if we are notified of Late-ness
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraStream::Notify(IBaseFilter * pSender, Quality q) {

    // Adjust the repeat rate.
    if (q.Proportion<=0) {

        m_iRepeatTime = 1000;        // We don't go slower than 1 per second
    }
    else {

        m_iRepeatTime = m_iRepeatTime*1000/q.Proportion;
        DbgLog(( LOG_TRACE, 1, TEXT("New time: %d, Proportion: %d")
               , m_iRepeatTime, q.Proportion));

        if (m_iRepeatTime>1000) {
            m_iRepeatTime = 1000;    // We don't go slower than 1 per second
        }
        else if (m_iRepeatTime<10) {
            m_iRepeatTime = 10;      // We don't go faster than 100/sec
        }
    }

    // skip forwards
    if (q.Late > 0) {
        m_rtSampleTime += q.Late;
    }

    return NOERROR;
}
//-----------------------------------------------------------------------------
//
// Format Support
//
// For now we will do 24 Bpp format alone. Will also restrict this to be
// 320x240
//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
// GetMediaType
//
// Prefered types should be ordered by quality, zero as highest quality
// Therefore iPosition =
// 0	return a 24bit mediatype
// iPostion > 1 is invalid.
//-----------------------------------------------------------------------------
HRESULT CCameraStream::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock l(m_pFilter->pStateLock());

    if (iPosition != 0)
        return E_INVALIDARG;

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pmt->AllocFormatBuffer(
			sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));
    if (NULL == pvi)
	    return(E_OUTOFMEMORY);

    ZeroMemory(pvi, sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));
	pvi->bmiHeader.biCompression = BI_RGB;
	pvi->bmiHeader.biBitCount    = 32;

    // Adjust the parameters common to all formats.

    pvi->bmiHeader.biSize		    = sizeof(BITMAPINFOHEADER);
    pvi->bmiHeader.biWidth		    = 320 ;
    pvi->bmiHeader.biHeight		    = 240 ;
    pvi->bmiHeader.biPlanes		    = 1;
    pvi->bmiHeader.biSizeImage		= GetBitmapSize(&pvi->bmiHeader);
    pvi->bmiHeader.biClrUsed		= 0;
    pvi->bmiHeader.biClrImportant	= 0;

    SetRectEmpty(&(pvi->rcSource));	// we want the whole image area rendered.
    SetRectEmpty(&(pvi->rcTarget));	// no particular destination rectangle

    pmt->SetType(&MEDIATYPE_Video);
    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->SetTemporalCompression(FALSE);

    // Work out the GUID for the subtype from the header info.
    const GUID SubTypeGUID = GetBitmapSubtype(&pvi->bmiHeader);
    pmt->SetSubtype(&SubTypeGUID);
    pmt->SetSampleSize(pvi->bmiHeader.biSizeImage);
    return NOERROR;
}


//-----------------------------------------------------------------------------
// CheckMediaType
//
// We will accept 24 bit video formats, 320x240 images
// Returns E_INVALIDARG if the mediatype is not acceptable, S_OK if it is
//-----------------------------------------------------------------------------
HRESULT CCameraStream::CheckMediaType(const CMediaType *pMediaType)
{

    CAutoLock l(m_pFilter->pStateLock());

    if (   (*(pMediaType->Type()) != MEDIATYPE_Video)	// we only output video!
	|| !(pMediaType->IsFixedSize()) ) {		// ...in fixed size samples
        return E_INVALIDARG;
    }

    // Check for the subtypes we support
    const GUID *SubType = pMediaType->Subtype();
    if (   (*SubType != MEDIASUBTYPE_RGB32))
        return E_INVALIDARG;

    // Get the format area of the media type
    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) pMediaType->Format();

    if (pvi == NULL)
	return E_INVALIDARG;

    // Check the image size.
    if (   (pvi->bmiHeader.biWidth != 320)
        || (pvi->bmiHeader.biHeight != 240) )
	    return E_INVALIDARG;

    return S_OK;  // This format is acceptable.
}


//-----------------------------------------------------------------------------
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what size image we agreed.
// Then we can ask for buffers of the correct size to contain them.
//-----------------------------------------------------------------------------
HRESULT CCameraStream::DecideBufferSize(IMemAllocator *pAlloc,
                                      ALLOCATOR_PROPERTIES *pProperties)
{
    CAutoLock l(m_pFilter->pStateLock());
    ASSERT(pAlloc);
    ASSERT(pProperties);
    HRESULT hr = NOERROR;

    VIDEOINFOHEADER *pvi = (VIDEOINFOHEADER *) m_mt.Format();
    pProperties->cBuffers = 1;
    pProperties->cbBuffer = pvi->bmiHeader.biSizeImage;

    ASSERT(pProperties->cbBuffer);

    // Ask the allocator to reserve us some sample memory, NOTE the function
    // can succeed (that is return NOERROR) but still not have allocated the
    // memory that we requested, so we must check we got whatever we wanted

    ALLOCATOR_PROPERTIES Actual;
    hr = pAlloc->SetProperties(pProperties,&Actual);
    if (FAILED(hr)) {
        return hr;
    }

    // Is this allocator unsuitable

    if (Actual.cbBuffer < pProperties->cbBuffer)
        return E_FAIL;

    // Make sure that we have only 1 buffer

    ASSERT( Actual.cBuffers == 1 );

    return NOERROR;
}


//-----------------------------------------------------------------------------
// SetMediaType
//
// Overriden from CBasePin. Call the base class and then set the
// any  parameters that depend on media type
//-----------------------------------------------------------------------------
HRESULT CCameraStream::SetMediaType(const CMediaType *pMediaType)
{

    CAutoLock l(m_pFilter->pStateLock());

    HRESULT hr;		            // return code from base class calls

    // Pass the call up to my base class
    hr = CSourceStream::SetMediaType(pMediaType);
    if (SUCCEEDED(hr))
	    return NOERROR;
    else
        return hr;
}


//-----------------------------------------------------------------------------
// OnThreadCreate
//
// as we go active reset the stream time to zero
//-----------------------------------------------------------------------------
HRESULT CCameraStream::OnThreadCreate(void)
{

    CAutoLock lShared(&m_cSharedState);

    m_rtSampleTime = 0;

    // we need to also reset the repeat time in case the system
    // clock is turned off after m_iRepeatTime gets very big
    m_iRepeatTime = m_iDefaultRepeatTime;

    // Zero the output buffer on the first frame.

    return NOERROR;
}
//-----------------------------------------------------------------------------
// --- ICamera ---
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// get_bSimFlag
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::get_bSimFlag (BOOL *bSimFlag)
{

    CAutoLock l(&m_cStateLock);
    *bSimFlag = m_bSimFlag ;
    return NOERROR;
}
//-----------------------------------------------------------------------------
// set_bSimFlag
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::set_bSimFlag (BOOL bSimFlag)
{
    CAutoLock l(&m_cStateLock);
    m_bSimFlag = bSimFlag ;
    return NOERROR;
}
//-----------------------------------------------------------------------------
// set_szSimFile
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::set_szSimFile (char *pszFile)
{
    CAutoLock l(&m_cStateLock);
    char *ps = pszFile ;
    char *pd = m_szFile ;
    while (*ps)
        *pd++ = *ps++ ;
    *pd = '\0' ;
    return NOERROR;
}

//-----------------------------------------------------------------------------
// get_szSimFile
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::get_szSimFile (char *pszFile)
{
    CAutoLock l(&m_cStateLock);
    char *pd = pszFile ;
    char *ps = m_szFile ;
    while (*ps)
        *pd++ = *ps++ ;
    *pd = '\0' ;

    return NOERROR;
}
//-----------------------------------------------------------------------------
// get_FrameRate
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::get_FrameRate (int *nRate)
{
    CAutoLock l(&m_cStateLock);
    *nRate = m_nFrameRate ;
    return NOERROR;
}
//-----------------------------------------------------------------------------
// get_BitCount
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::get_BitCount (int *nBpp)
{
    CAutoLock l(&m_cStateLock);
    *nBpp = m_nBitCount ;
    return NOERROR;
}

//-----------------------------------------------------------------------------
// set_FrameRate
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::set_FrameRate (int nRate)
{
    CAutoLock l(&m_cStateLock);
    m_nFrameRate = nRate ;

    // translate frame rate to code for the device.
    if (nRate >= 15)
    {
        // clamp it at 15.
        m_nFrameRate = 15 ;
        m_nFrameQuadlet = 0x60000000 ;
        m_n1394Bandwidth = 320 ;
    }
    else if (nRate < 15 && nRate >= 7.5)
    {
        // clamp it at 7.5
        m_nFrameQuadlet = 0x40000000 ;
        m_n1394Bandwidth = 160 ;
    }
    else
    {
        // clamp it at 3.75
        m_nFrameQuadlet = 0x20000000 ;
        m_n1394Bandwidth = 80 ;
    }
    return NOERROR;
}
//-----------------------------------------------------------------------------
// set_FrameRate
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::set_BitCount (int nBpp)
{
    CAutoLock l(&m_cStateLock);
    if (nBpp == 24)
    {
        m_nBitCount = 24 ;
        m_nBitCountOffset = 3 ;
    }
    else
    {
        m_nBitCount = 32 ;
        m_nBitCountOffset = 4 ;
    }
    return NOERROR;
}

//-----------------------------------------------------------------------------
// --- ISpecifyPropertyPages ---
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// GetPages
//
// Returns the clsid's of the property pages we support
//-----------------------------------------------------------------------------
STDMETHODIMP CCamera::GetPages(CAUUID *pPages)
{

    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    *(pPages->pElems) = CLSID_CameraPropertyPage;

    return NOERROR;
}
//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\1394cam.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    camera.h

Abstract:

    Include file for camera.c

Author:
    
    Shaun Pierce (shaunp) 12-Feb-96

Environment:

    User mode

Notes:


Revision History:

--*/


//
// Various structures
//

typedef struct _DEVICE_OBJECT_ARRAY {
    ULONG   Returned;
    ULONG   Buffer[25];
} DEVICE_OBJECT_ARRAY, *PDEVICE_OBJECT_ARRAY;


//
// Various definitions
//

#define P1394_INITIAL_REGISTER_SPACE        0xf0000000
#define ENABLE_BUSTED_HARDWARE_WORKAROUNDS  0x87878787

#define INITIALIZE_REGISTER                 0x00000000
#define CURRENT_FRAME_RATE                  0x00000600
#define CURRENT_VIDEO_MODE                  0x00000604
#define CURRENT_VIDEO_FORMAT                0x00000608
#define CURRENT_ISOCH_CHANNEL               0x0000060c
#define ISOCH_ENABLE                        0x00000614


#define MAX_CAMERA_CHANNELS                 15
#define MAX_CAMERA_BUFFERS                  15
#define CAMERA_BUFFER_SIZE                  320*240*2

#define CRUDE_CALLBACK                      10000

//
// Definitions that p1394.h uses (only applicable as device driver - but
// needed to compile clean
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS; // windbgkd
#define PMDL PVOID
#define PIRP PVOID
#define KIRQL PVOID
#define PKINTERRUPT PVOID
#define NTSTATUS ULONG
#define PDEVICE_OBJECT PVOID
#define DEVICE_OBJECT ULONG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\camerapp.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//-----------------------------------------------------------------------------
// camerapp.cpp
//-----------------------------------------------------------------------------


#include <windows.h>
#include <windowsx.h>
#include <streams.h>
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>

#include "resource.h"
#include "camuids.h"
#include "icamera.h"
#include "camera.h"
#include "camerapp.h"

//-----------------------------------------------------------------------------
// CCameraProperties
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// CreateInstance
//-----------------------------------------------------------------------------
CUnknown *CCameraProperties::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{

    CUnknown *punk = new CCameraProperties(lpunk, phr);
    if (punk == NULL) {
	*phr = E_OUTOFMEMORY;
    }
    return punk;
}

//-----------------------------------------------------------------------------
// CCameraProperties::Constructor
//-----------------------------------------------------------------------------
CCameraProperties::CCameraProperties(LPUNKNOWN lpunk, HRESULT *phr)
    : CUnknown(NAME("Camera Property Page"), lpunk)
    , m_hwnd(NULL)
    , m_pPropPageSite(NULL)
    , m_pICamera(NULL)
    , m_hrDirtyFlag(S_FALSE)   // initially the page is clean
    , m_bSimFlag (0)

{
    m_szFile[0] = NULL ;
    m_nFrameRate = 15 ;
}

//-----------------------------------------------------------------------------
// NonDelegatingQueryInterface
//
// Reveal our property page
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{

    if (riid == IID_IPropertyPage) {
	return GetInterface((IPropertyPage *) this, ppv);
    } else {
	return CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }
}

//-----------------------------------------------------------------------------
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
//-----------------------------------------------------------------------------
void CCameraProperties::SetDirty()
{
    ASSERT(m_pPropPageSite);

    m_hrDirtyFlag = S_OK;
    m_pPropPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

//-----------------------------------------------------------------------------
// SetPageSite
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::SetPageSite(IPropertyPageSite *pPageSite)
{
    if (pPageSite != NULL) {
        //
        // Remember the pointer AND AddRef it.
        //

        if (m_pPropPageSite != NULL) {
            return(E_UNEXPECTED);
        }

        m_pPropPageSite = pPageSite;
        m_pPropPageSite->AddRef();
    }
    else {
        //
        // Clear the pointer and Release it.

        if (m_pPropPageSite == NULL) {
            return(E_UNEXPECTED);
        }

        m_pPropPageSite->Release();
        m_pPropPageSite = NULL;
    }

    return( S_OK );
}

//-----------------------------------------------------------------------------
// GetPageInfo
//
// set the page info so that the page site can size itself, etc
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::GetPageInfo(LPPROPPAGEINFO pPageInfo)
{

    WCHAR szTitle[] = L"Camera Properties";

    LPOLESTR pszTitle = (LPOLESTR) CoTaskMemAlloc(sizeof(szTitle));
    memcpy(pszTitle, &szTitle, sizeof(szTitle));

    pPageInfo->cb               = sizeof(PROPPAGEINFO);
    pPageInfo->pszTitle         = pszTitle;
    pPageInfo->size.cx          = 76;
    pPageInfo->size.cy          = 100;
    pPageInfo->pszDocString     = NULL;
    pPageInfo->pszHelpFile      = NULL;
    pPageInfo->dwHelpContext    = 0;

    return NOERROR;

}


//-----------------------------------------------------------------------------
// DialogProc
//
// Handles the messages for our property window
//-----------------------------------------------------------------------------
BOOL CALLBACK CCameraProperties::DialogProc( HWND hwnd
					 , UINT uMsg
					 , WPARAM wParam
					 , LPARAM lParam)
{

    CCameraProperties *pThis = (CCameraProperties *) GetWindowLong(hwnd, GWL_USERDATA);



    switch (uMsg) {
    case WM_INITDIALOG:	// GWL_USERDATA has not been set yet. pThis in lParam

        {

	        TCHAR   sz[60];
            WORD i ;
            pThis = (CCameraProperties *) lParam;
            if (pThis->m_bSimFlag)
                i = 1 ;
            else
                i = 0 ;
            SendMessage ((GetDlgItem(hwnd, IDC_SIMCHECK)),BM_SETCHECK, i, 0) ;
	        _stprintf(sz, TEXT("%d"), pThis->m_nFrameRate);
	        Edit_SetText(GetDlgItem(hwnd, IDC_FRAMERATE), sz);
	        return TRUE;    // I don't call setfocus...
        }

    case WM_COMMAND:
        if (pThis)
            pThis->SetDirty();
			
	return TRUE;

    case WM_DESTROY:
        ASSERT(pThis);
	return TRUE;

    default:
	return FALSE;

    }
}


//-----------------------------------------------------------------------------
// SetObjects
//
// Notification of which object this property page should be displayed.
// We query the object for the IICamera interface.
//
// If cObjects == 0 then we must release the interface.
//
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk)
{

    if (cObjects == 1) {
        //
        // Initialisation
        //
        if ( (ppunk == NULL) || (*ppunk == NULL) ) {
            return(E_POINTER);
        }

        ASSERT(m_pICamera == NULL);

        HRESULT hr = (*ppunk)->QueryInterface(IID_ICamera, (void **) &m_pICamera);
        if (FAILED(hr)) {
            return E_NOINTERFACE;
        }

        ASSERT(m_pICamera);

        // Get the initial simulation flag
        m_pICamera->get_bSimFlag (&m_bSimFlag) ;

        // And the file name
        m_pICamera->get_szSimFile (m_szFile) ;

        // And the frame rate
        m_pICamera->get_FrameRate (&m_nFrameRate) ;


    }
    else if (cObjects == 0) {
        //
        // Release of Interface after setting the appropriate old effect value
        //

        if (m_pICamera == NULL) {
            return E_UNEXPECTED;
        }
        m_pICamera->Release();
        m_pICamera = NULL;
    }
    else {
        ASSERT(!"No support for more than 1 object");
        return(E_UNEXPECTED);
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Activate
//
// Create the window we will use to edit properties
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::Activate(HWND hwndParent, LPCRECT prect, BOOL fModal)
{

    m_bApplyDone = FALSE ;
    m_hwnd = CreateDialogParam( g_hInst
			      , MAKEINTRESOURCE(IDD_CAMERAPROP)
			      , hwndParent
			      , DialogProc
			      , (LPARAM) this
			      );

    if (m_hwnd == NULL) {
	DWORD dwErr = GetLastError();
	DbgLog((LOG_ERROR, 1, TEXT("Could not create window: 0x%x"), dwErr));
	return E_FAIL;
    }

    SetWindowLong(m_hwnd, GWL_USERDATA,(LONG) this);
    return Move(prect);
}


//-----------------------------------------------------------------------------
// Show
//
// Display the property dialog
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::Show(UINT nCmdShow)
{

    if (m_hwnd == NULL) {
	return E_UNEXPECTED;
    }
    ShowWindow(m_hwnd, nCmdShow);
    InvalidateRect(m_hwnd, NULL, TRUE);

    return NOERROR;
}


//-----------------------------------------------------------------------------
// Deactivate
//
// Destroy the dialog
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::Deactivate(void)
{

    // remember the effect for next activate
    ASSERT(m_pICamera);
    m_pICamera->get_bSimFlag (&m_bSimFlag);
    m_pICamera->get_szSimFile (m_szFile) ;
    m_pICamera->get_FrameRate (&m_nFrameRate);

    if (m_hwnd == NULL) {
	return E_UNEXPECTED;
    }

    if (DestroyWindow(m_hwnd)) {
	m_hwnd = NULL;
	return NOERROR;
    }
    else {
	return E_FAIL;
    }
}


//-----------------------------------------------------------------------------
// Move
//
// put the property page over its home in the parent frame.
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::Move(LPCRECT prect)
{

    if (MoveWindow( m_hwnd
		  , prect->left
		  , prect->top
		  , prect->right - prect->left
		  , prect->bottom - prect->top
		  , TRUE                // send WM_PAINT
		  ) ) {
	return NOERROR;
    }
    else {
	return E_FAIL;
    }
}

//-----------------------------------------------------------------------------
// Apply
//
// Changes made should be kept.
//-----------------------------------------------------------------------------
STDMETHODIMP CCameraProperties::Apply()
{
    WORD i ;
    OPENFILENAME ofn ;

    if (m_bApplyDone)
        return NOERROR ;

    m_bApplyDone = TRUE ;

    ASSERT(m_pICamera);
    i = (WORD) SendMessage ((GetDlgItem(m_hwnd, IDC_SIMCHECK)), BM_GETCHECK, 0,0) ;
    if (i == 0)
        m_bSimFlag = FALSE ;
    else
        m_bSimFlag = TRUE ;

    // get the frame rate
    {
        TCHAR sz[60];
        Edit_GetText(GetDlgItem(m_hwnd, IDC_FRAMERATE), sz, 60);
        m_nFrameRate = atoi (sz) ;
    }

    // get file name if we are simulating
    if (m_bSimFlag)
    {
    	ofn.lStructSize= sizeof (OPENFILENAME) ;
    	ofn.hwndOwner = NULL ;
    	ofn.hInstance = NULL ;
    	ofn.lpstrFilter = NULL ;
    	ofn.lpstrCustomFilter = NULL ;
    	ofn.nMaxCustFilter = 0 ;
    	ofn.lpstrFile = m_szFile ;
    	ofn.nMaxFile = MAX_PATH ;
    	ofn.lpstrFileTitle = NULL ;
    	ofn.nMaxFileTitle = MAX_PATH + 4 ;
    	ofn.lpstrInitialDir = NULL ;
    	ofn.lpstrTitle = NULL ;
    	ofn.Flags = 0 ;
    	ofn.nFileOffset = 0 ;
    	ofn.nFileExtension = 0 ;
    	ofn.lpstrDefExt = NULL ;
    	ofn.lCustData = 0L ;
    	ofn.lpfnHook = NULL ;
    	ofn.lpTemplateName = NULL ;
    	GetOpenFileName (&ofn) ;
    }
    // pass the info on. Set Sim flag last
    m_pICamera->set_FrameRate (m_nFrameRate) ;
    m_pICamera->set_szSimFile (m_szFile) ;
    m_pICamera->set_bSimFlag (m_bSimFlag) ;
    m_hrDirtyFlag = S_FALSE; // the page is now clean
    return(NOERROR);
}

//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\1394api.h ===
/*++

Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

Module Name:

    1394api.h

Abstract:

    User mode API definitions and structures

Author:
    
    Shaun Pierce (shaunp) 2-Feb-96

Environment:

    User & Kernel mode definitions

Revision History:


--*/


//
// Various structures
//

typedef struct _ASYNC_READ {
    P1394_IO_ADDRESS DestinationAddress;            // Address to read from 
    ULONG            nNumberOfBytesToRead;          // Bytes to read
    ULONG            nBlockSize;                    // Block size of read
    ULONG            fulFlags;                      // Flags pertinent to read
    ULONG            Reserved;                      // Reserved for future use
} ASYNC_READ, *PASYNC_READ;

typedef struct _ASYNC_WRITE {
    P1394_IO_ADDRESS DestinationAddress;            // Address to write to
    ULONG            nNumberOfBytesToWrite;         // Bytes to write
    ULONG            nBlockSize;                    // Block size of write
    ULONG            fulFlags;                      // Flags pertinent to write
    ULONG            Reserved;                      // Reserved for future use
} ASYNC_WRITE, *PASYNC_WRITE;

typedef struct _ASYNC_LOCK {
    P1394_IO_ADDRESS DestinationAddress;            // Address to lock to
    ULONG            nNumberOfArgBytes;             // Bytes in Arguments
    ULONG            nNumberOfDataBytes;            // Bytes in DataValues
    ULONG            fulTransactionType;            // Lock transaction type
    ULONG            fulFlags;                      // Flags pertinent to lock
    ULONG            Arguments[2];                  // Arguments used in Lock
    ULONG            DataValues[2];                 // Data values 
    ULONG            ReturnedData[4];               // Returned data values
    ULONG            Reserved;                      // Reserved for future use
} ASYNC_LOCK, *PASYNC_LOCK;

typedef struct _ALLOCATE_BANDWIDTH {
    ULONG           nMaxBytesPerFrameRequested; // Bytes per Isoch frame
    ULONG           fulSpeed;                   // Speed flags
    HANDLE          hBandwidth;                 // Returned bandwidth handle
    ULONG           BytesPerFrameAvailable;     // Returned bytes per frame available
    ULONG           SpeedSelected;              // Returned speed selected
    ULONG           Reserved;                   // Reserved for future use
} ALLOCATE_BANDWIDTH, *PALLOCATE_BANDWITH;


typedef struct _ALLOCATE_CHANNEL {
    ULONG           nRequestedChannel;          // Need a specific channel
    ULONG           Channel;                    // Returned channel
    LARGE_INTEGER   ChannelsAvailable;          // Returned channels available
    ULONG           Reserved;                   // Reserved for future use
} ALLOCATE_CHANNEL, *PALLOCATE_CHANNEL;

typedef struct _ALLOCATE_RESOURCES {
    ULONG           fulSpeed;                   // Speed flags
    ULONG           fulFlags;                   // Flags
    HANDLE          hResource;                  // Returned Resources
    ULONG           Reserved;                   // Reserved for future use
} ALLOCATE_RESOURCES, *PALLOCATE_RESOURCES;

typedef struct _ATTACH_BUFFERS {
    HANDLE              hResource;              // Resource handle
    ISOCH_DESCRIPTOR    IsochDescriptor;        // Isoch descriptors
    ULONG               Reserved;               // Reserved for future use
} ATTACH_BUFFERS, *PATTACH_BUFFERS;

typedef struct _DETACH_BUFFERS {
    HANDLE              hResource;              // Resource handle
    ISOCH_DESCRIPTOR    IsochDescriptor;        // Pointer to Isoch descriptors
    ULONG               Reserved;               // Reserved for future use
} DETACH_BUFFERS, *PDETACH_BUFFERS;

typedef struct _FREE_BANDWIDTH {
    HANDLE              hBandwidth;             // Bandwidth handle to release
    ULONG               Reserved;               // Reserved for future use
} FREE_BANDWIDTH, *PFREE_BANDWIDTH;

typedef struct _FREE_CHANNEL {
    ULONG               nChannel;               // Channel to release
    ULONG               Reserved;               // Reserved for future use
} FREE_CHANNEL, *PFREE_CHANNEL;

typedef struct _FREE_RESOURCES {
    HANDLE              hResource;              // Resource handle
    ULONG               Reserved;               // Reserved for future use
} FREE_RESOURCES, *PFREE_RESOURCES;

typedef struct _LISTEN {
    ULONG               nChannel;               // Channel to listen on
    HANDLE              hResource;              // Resource handle to listen on
    ULONG               fulFlags;               // Flags
    ULONG               nStartCycle;            // Start cycle
    LARGE_INTEGER       StartTime;              // Start time
    ULONG               ulSynchronize;          // Sy 
    ULONG               ulTag;                  // Tag
    ULONG               Reserved;               // Reserved for future use
} LISTEN, *PLISTEN;

typedef struct QUERY_CURRENT_CYCLE_NUMBER {
    ULONG               CycleNumber;            // Returned Current cycle number 
} QUERY_CURRENT_CYCLE_NUMBER, *PQUERY_CURRENT_CYCLE_NUMBER;

typedef struct _STOP {
    ULONG               nChannel;               // Channel to stop on
    HANDLE              hResource;              // Resource handle to stop on
    ULONG               fulFlags;               // Flags
    ULONG               nStopCycle;             // Cycle to stop on
    LARGE_INTEGER       StopTime;               // Time to stop on
    ULONG               ulSynchronize;          // Sy
    ULONG               ulTag;                  // Tag
    ULONG               Reserved;               // Reserved for future use
} STOP, *PSTOP;

typedef struct _TALK {
    ULONG               nChannel;               // Channel to talk on
    HANDLE              hResource;              // Resource handle to talk on
    ULONG               fulFlags;               // Flags
    ULONG               nStartCycle;            // Cycle to start on
    LARGE_INTEGER       StartTime;              // Time to start on
    ULONG               ulSynchronize;          // Sy
    ULONG               ulTag;                  // Tag
    ULONG               Reserved;               // Reserved for future use
} TALK, *PTALK;

typedef struct _IOCONTROL {
    ULONG               ulIoControlCode;        // Control code
    ULONG               Reserved;               // Reserved for future use
} IOCONTROL, *PIOCONTROL;
    
typedef struct _GET_DEVICE_OBJECTS {
    ULONG               nSizeOfBuffer;
} GET_DEVICE_OBJECTS, *PGET_DEVICE_OBJECTS;

typedef struct _CRUDE_IOCALLBACK {
    ULONG               Context;                // Context that completed
} CRUDE_IOCALLBACK, *PCRUDE_IOCALLBACK;


typedef struct _USER_1394_REQUEST {

    //
    // Holds the zero based Function number that corresponds to the request
    // that the application is asking the class driver to carry out.
    //
    ULONG FunctionNumber;

    //
    // Holds Flags that may be unique to this particular operation
    //
    ULONG Flags;

    //
    // Reserved for internal use and/or future expansion
    //
    ULONG Reserved[4];

    union {

        ASYNC_READ AsyncRead;
        ASYNC_WRITE AsyncWrite;
        ASYNC_LOCK AsyncLock;
        ALLOCATE_BANDWIDTH AllocateBandwidth;
        ALLOCATE_CHANNEL AllocateChannel;
        ALLOCATE_RESOURCES AllocateResources;
        ATTACH_BUFFERS AttachBuffers;
        DETACH_BUFFERS DetachBuffers;
        FREE_BANDWIDTH FreeBandwidth;
        FREE_CHANNEL FreeChannel;
        FREE_RESOURCES FreeResources;
        LISTEN Listen;
        QUERY_CURRENT_CYCLE_NUMBER QueryCurrentCycleNumber;
        STOP Stop;
        TALK Talk;
        IOCONTROL IoControl;
        GET_DEVICE_OBJECTS GetDeviceObjects;
        CRUDE_IOCALLBACK CrudeCallback;

    } u;

} USER_1394_REQUEST, *PUSER_1394_REQUEST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\camera.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
// 1394 Camera based source filter
//

// Uses CSource & CSourceStream to generate a movie on the fly of
// frames captured from a camera

//-----------------------------------------------------------------------------



//-----------------------------------------------------------------------------
class CCameraStream ;       // The class managing the output pin.
//-----------------------------------------------------------------------------
// CCamera to manage filter level stuff
//-----------------------------------------------------------------------------
class CCamera : public CSource,
                public ISpecifyPropertyPages,
                public ICamera
{
public:


    // The only allowed way to create  Cameras!
    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);
    ~CCamera();

    DECLARE_IUNKNOWN;

    // Reveals ICamera & ISpecifyPropertyPages
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // over ride to do some initializations.
    STDMETHODIMP Pause();

    // over ride for stream time handling.
    STDMETHODIMP Run(REFERENCE_TIME tStart);


    //
    // --- ICamera
    //

    STDMETHODIMP get_bSimFlag (BOOL *pbFlag) ;
    STDMETHODIMP set_bSimFlag (BOOL bFlag) ;
    STDMETHODIMP set_szSimFile (char *pszFile) ;
    STDMETHODIMP get_szSimFile (char *pszFile) ;
    STDMETHODIMP get_FrameRate (int *nRate) ;
    STDMETHODIMP set_FrameRate (int nRate) ;
    STDMETHODIMP get_BitCount (int *nBpp) ;
    STDMETHODIMP set_BitCount (int nBpp) ;


    //
    // --- ISpecifyPropertyPages ---
    //

    STDMETHODIMP GetPages(CAUUID *pPages);
    BOOL IsSimulation () {return m_bSimFlag; } ;
    BOOL DoInitializations () ;
    HRESULT GetStreamTime (REFERENCE_TIME *prTime) ;


private:

    // it is only allowed to to create these objects with CreateInstance
    CCamera(LPUNKNOWN lpunk, HRESULT *phr);
    BOOL InitCamera () ;
    void ReleaseCamera () ;
    HRESULT LoadFile () ;

    BOOL m_bSimFlag ;              // TRUE if we are simulation
    BOOL m_bFileLoaded ;           // file loaded or not
    BOOL m_bCameraInited ;         // camera init done or not
    char m_szFile [MAX_PATH] ;     // file being used for simulation
    int  m_nFrameRate ;            // user specified frame rate
    int  m_n1394Bandwidth ;        // for clamping the bus bandwith.
    int  m_nFrameQuadlet ;         // more camera specific stuff
    int  m_nBitCount ;             // bit count of output.
    int  m_nBitCountOffset ;       // related to bit count.
    REFERENCE_TIME m_rtStart ;     // starting reference time

};

//-----------------------------------------------------------------------------
//
// CCameraStream  manages data flow from output pin
//-----------------------------------------------------------------------------
class CCameraStream : public CSourceStream
{
public:

    CCameraStream(HRESULT *phr, CCamera *pParent, LPCWSTR pPinName);
    ~CCameraStream();

    // plots a Camera into the supplied video frame.
    HRESULT FillBuffer(IMediaSample *pms) ;

    // Ask for buffers of the size appropriate to the agreed media type.
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties);

    // Set the agreed media type, and set up the necessary Camera
    // parameters that depend on the media type, ie CameraPixel[], iPixelSize, etc.
    HRESULT SetMediaType(const CMediaType *pMediaType);

    // because we calculate the Camera there is no reason why we can't calculate it in
    // any one of a set of formats...
    HRESULT CheckMediaType(const CMediaType *pMediaType);
    HRESULT GetMediaType(int iPosition, CMediaType *pmt);

    // resets the stream time to zero.
    HRESULT OnThreadCreate(void);

    // Quality control notifications sent to us
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

private:

    int m_iRepeatTime;              // Time in msec between frames
    const int m_iDefaultRepeatTime; // Initial m_iRepeatTime
    CCritSec	m_cSharedState;	    // use this to lock access to m_rtSampleTime and m_Camera which are
    				                // shared with the worker thread.

    CRefTime 	m_rtSampleTime;	    // The time to be stamped on each sample
    CCamera	    *m_Camera;	        // the current Camera.

    BOOL        m_bSimFlag ;            // simulation or not
    char        m_szFile [MAX_PATH] ;   // file name for simulation

#ifdef PERF
    int         m_perfidSampleStart ;   // start time of samples
#endif

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\camerapp.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
// camerapp.h
//

class CCameraProperties : public CUnknown,
			    public IPropertyPage {

public:

    static CUnknown *CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

    DECLARE_IUNKNOWN;

    // override this to reveal our property interface
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    STDMETHODIMP SetPageSite(LPPROPERTYPAGESITE pPageSite) ;
    STDMETHODIMP Activate(HWND hwndParent, LPCRECT prect, BOOL fModal);
    STDMETHODIMP Deactivate(void);
    STDMETHODIMP GetPageInfo(LPPROPPAGEINFO pPageInfo);
    STDMETHODIMP SetObjects(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHODIMP Show(UINT nCmdShow);
    STDMETHODIMP Move(LPCRECT prect);
    STDMETHODIMP IsPageDirty(void) 	
        { return m_hrDirtyFlag; }
    STDMETHODIMP Apply(void);
    STDMETHODIMP Help(LPCWSTR lpszHelpDir)		{ return E_UNEXPECTED; }
    STDMETHODIMP TranslateAccelerator(LPMSG lpMsg)      { return m_pPropPageSite->TranslateAccelerator(lpMsg); }

private:
    void SetDirty();

    CCameraProperties(LPUNKNOWN lpunk, HRESULT *phr);

    static BOOL CALLBACK DialogProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND	    m_hwnd;		            // Handle of property window
    BOOL        m_bSimFlag ;            // Simulating or not
    char        m_szFile [MAX_PATH] ;   // file name
    BOOL        m_bApplyDone ;          // apply has been done once.
    int         m_nFrameRate ;          // user specified frame rate
    int         m_nBitCount ;           // the bit count
    ICamera 	*m_pICamera ;           // ICamera interface
    HRESULT     m_hrDirtyFlag;         // S_OK - Page is dirty, S_FALSE - Page is clean
    IPropertyPageSite *m_pPropPageSite;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\icamera.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//
// icamera.h
//

// A custom interface to allow the user to set properties for Camera
// Currently we simply have a flag which lets us simulate. We will
// perhaps add more properties later.


#ifndef __ICamera__
#define __ICamera__

#ifdef __cplusplus
extern "C" {
#endif


//
// ICamera GUID
//
// {EE189540-7212-11cf-A520-00A0D10108F0}
DEFINE_GUID(IID_ICamera,
0xee189540, 0x7212, 0x11cf, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x8, 0xf0);


//
// ICamera
//
DECLARE_INTERFACE_(ICamera, IUnknown) {

    STDMETHOD(get_bSimFlag) (THIS_
    				  BOOL *pbFlag       // [out] // simulating or not
				 ) PURE;
    STDMETHOD(set_bSimFlag) (THIS_
    				  BOOL bFlag         // [out] // simulating or not
				 ) PURE;

    STDMETHOD(get_FrameRate) (THIS_
    				  int   *nRate       // [out] // simulating or not
				 ) PURE;
    STDMETHOD(set_FrameRate) (THIS_
    				  int   nRate        // [out] // simulating or not
				 ) PURE;
    STDMETHOD(set_szSimFile) (THIS_
    				  char *pszFile      // [out] // file to be used for simulation

				 ) PURE;
    STDMETHOD(get_szSimFile) (THIS_
    				  char *pszFile      // [in] // file to be used for simulation

				 ) PURE;
    STDMETHOD(get_BitCount) (THIS_
    				  int   *nBpp        // [out] // bpp 
				 ) PURE;
    STDMETHOD(set_BitCount) (THIS_
    				  int   nBpp        // [out] // bpp
				 ) PURE;
};


#ifdef __cplusplus
}
#endif

#endif // __ICamera__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\camuids.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.

// CLSID_Camera
// {F6F21280-6BA1-11cf-BCB1-444553540000}
DEFINE_GUID(CLSID_Camera,
0xf6f21280, 0x6ba1, 0x11cf, 0xbc, 0xb1, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0);


// CLSID_CameraProperties
// {B051C9E0-721A-11cf-A520-00A0D10108F0}
DEFINE_GUID(CLSID_CameraPropertyPage,
0xb051c9e0, 0x721a, 0x11cf, 0xa5, 0x20, 0x0, 0xa0, 0xd1, 0x1, 0x8, 0xf0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\resource.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by camprop.rc
//
#define VERSION_RES_MINOR_VER           0
#define VERSION_RES_BUILD               0
#define VER_DEBUG                       0
#define VERSION_RES_MAJOR_VER           1
#define IDD_CAMERAPROP                  100
#define IDC_SIMCHECK                    1001
#define IDC_FRAMERATE                   1013
#define VERSION_RES_LANGUAGE            0x409
#define VERSION_RES_CHARSET             1252
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\wdm\cam1394\p1394.h ===
/*++

Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.

Module Name:

    p1394.h

Abstract:

    Definitions for 1394 class and/or port drivers

Author:
    
    Shaun Pierce (shaunp) 5-Sep-95

Environment:

    Kernel mode only

Revision History:


--*/


//
// 1394 Node Address format
//
typedef struct _P1394_NODE_ADDRESS {
    USHORT              NA_Node_Number:6;   // Bits 10-15
    USHORT              NA_Bus_Number:10;   // Bits 0-9
} P1394_NODE_ADDRESS, *PP1394_NODE_ADDRESS;

//
// 1394 Address Offset format (48 bit addressing)
//
typedef struct _P1394_OFFSET {
    USHORT              Off_High;
    ULONG               Off_Low;
} P1394_OFFSET, *PP1394_OFFSET;

// 
// 1394 I/O Address format
//
typedef struct _P1394_IO_ADDRESS {
    P1394_NODE_ADDRESS  IA_Destination_ID;
    P1394_OFFSET        IA_Destination_Offset;
} P1394_IO_ADDRESS, *PP1394_IO_ADDRESS;

//
// Self ID packet format
//
typedef struct _P1394_SELF_ID {
    ULONG               SID_More_Packets:1; // Bit 0
    ULONG               SID_Initiated_Rst:1;// Bit 1
    ULONG               SID_Port3:2;        // Bits 2-3
    ULONG               SID_Port2:2;        // Bits 4-5
    ULONG               SID_Port1:2;        // Bits 6-7
    ULONG               SID_Power_Class:3;  // Bits 8-10
    ULONG               SID_Contender:1;    // Bit 11
    ULONG               SID_Delay:2;        // Bits 12-13
    ULONG               SID_Speed:2;        // Bits 14-15
    ULONG               SID_Gap_Count:6;    // Bits 16-21
    ULONG               SID_Link_Active:1;  // Bit 22
    ULONG               SID_Zero:1;         // Bit 23
    ULONG               SID_Phys_ID:6;      // Bits 24-29
    ULONG               SID_Packet_ID:2;    // Bits 31-30
} P1394_SELF_ID, *PP1394_SELF_ID;

//
// 1394 Topology Map format - first Self ID is the local node
// (host controller) as represented by the port driver 
//
typedef struct _TOPOLOGY_MAP {
    USHORT              TOP_Length;         // number of quadlets in map
    USHORT              TOP_Reserved;       // Reserved (CRC)
    USHORT              TOP_Node_Count;     // Node count
    USHORT              TOP_Self_ID_Count;  // Number of Self IDs
    P1394_SELF_ID       TOP_Self_ID_Array[];// Array of Self IDs
} TOPOLOGY_MAP, *PTOPOLOGY_MAP;

//
// 1394 Root directory ROM format (always at 0xffff f0000400 : IEEE 1212)
//
typedef struct _ROOT_DIR {
    ULONG               RD_Reserved;
    ULONG               RD_Signiture;
    ULONG               RD_Reserved1;
    LARGE_INTEGER       RD_Node_UniqueID;
    USHORT              RD_Root_CRC;
    USHORT              RD_Root_Length;
    ULONG               RD_Module_VendorID:24;
    ULONG               RD_Reserved2:8;
    ULONG               RD_Reserved3;
    ULONG               RD_Directory_Offset:24;
    ULONG               RD_Reserved4:8;
} ROOT_DIR, *PROOT_DIR;

//
// 1394 Unit directory format
//
typedef struct _UNIT_DIR {
    USHORT              UD_Signiture;
    USHORT              UD_Crc;
    UCHAR               UD_Spec_prefix;
    ULONG               UD_Spec_ID:24;
    UCHAR               UD_SW_Prefix;
    ULONG               UD_SW_Version:24;
    UCHAR               UD_Dep_Prefix;
    ULONG               UD_Dep_Dir_Offset:24;
} UNIT_DIR, *PUNIT_DIR;

//
// 1394 Unit Dependent directory format
//
typedef struct _UNIT_DEP_DIR {
    USHORT              UDD_Unit_Dependent_Info;
    USHORT              UDD_Reserved1;
    UCHAR               UDD_Reserved2;
    ULONG               UDD_Command_Base_Offset:24;
    UCHAR               UDD_Reserved3;
    ULONG               UDD_Vendor_Leaf_Offset:24;
    UCHAR               UDD_Reserved4;
    ULONG               UDD_Model_Name_Offset:24;
} UNIT_DEP_DIR, *PUNIT_DEP_DIR;

//
// 1394 Vendor Leaf format
//
typedef struct _VENDOR_LEAF {
    USHORT              VL_Vendor_Leaf_Length;
    USHORT              VL_Vendor_Leaf_CRC;
    ULONG               VL_Vendor_Leaf_Data;
} VENDOR_LEAF, *PVENDOR_LEAF;

//
// 1394 Model Leaf format
//
typedef struct _MODEL_LEAF {
    USHORT              ML_Model_Leaf_Length;
    USHORT              ML_Model_Leaf_CRC;
    ULONG               ML_Model_Leaf_Data;
} MODEL_LEAF, *PMODEL_LEAF;

//
// Information block used with GetLocalHostInformation
//
typedef struct _INFO_BLOCK1 {
    ULONG               fulCapabilities;
    ULONG               nClassDriverVersion;
    ULONG               nPortDriverVersion;
    ULONG               nDMAResourcesAvail;
} INFO_BLOCK1, *PINFO_BLOCK1;


//
// Isoch descriptor header
//
typedef struct _ISOCH_DESCRIPTOR {

    //
    // Holds list to other descriptors in the buffer
    //
    LIST_ENTRY IsochDescriptorList;

    //
    // Flags (used in synchronization)
    //
    ULONG fulFlags;

    //
    // Mdl pointing to buffer
    //
    PMDL lpBuffer;

    //
    // Length of lpBuffer
    //
    ULONG ulLength;
    
    //
    // Synchronization field; equivalent to sy
    //
    ULONG ulSynchronize;
    
    //
    // Cycle number to synchronize on
    //
    ULONG ulCycle;

    //
    // System Time as defined by NT kernel services - used to sychronize on
    //
    LARGE_INTEGER SystemTime;
    
    //
    // Callback routine (if any) to be called when this descriptor completes
    //
    PVOID lpCallback;

    //
    // Context routine (if any) to be passed when doing callbacks
    //
    PVOID lpContext;

    //
    // Holds the final status of this descriptor
    //
    ULONG status;

    //
    // Holds reserved fields used by 1394 Class driver
    //
    ULONG Reserved[4];

} ISOCH_DESCRIPTOR, *PISOCH_DESCRIPTOR;
    

//
// This device extension is common for all device objects the 1394 Class
// driver created on behalf of a device driver.
//

typedef struct _P1394_DEVICE_EXTENSION {

    //
    // Holds Tag to determine if this is really a "Device" Extension
    //
    ULONG Tag;

    //
    // Holds the Root Directory for this device.  Multi-functional 
    // devices (i.e. many units) will share this same Root Directory
    // structure, but they are represented as a different Device Object
    //
    ROOT_DIR RootDirectory;

    //
    // Holds the Unit Directory for this device.  Even on multi-functional
    // devices (i.e. many units) this should be unique to each Device Object.
    //
    UNIT_DIR UnitDirectory;

    //
    // Holds the 1394 10 bit BusId / 6 bit NodeId structure
    //
    P1394_NODE_ADDRESS NodeAddress;

    //
    // Holds the speed to be used in reaching this device
    //
    UCHAR Speed;


} P1394_DEVICE_EXTENSION, *PP1394_DEVICE_EXTENSION;
    

//
// This class request structure is the basis of how other device drivers
// communicate with the P1394 Class driver.
//

typedef struct _P1394_CLASS_REQUEST {

    //
    // Holds the zero based Function number that corresponds to the request
    // that device drivers are asking the class driver to carry out.
    //
    ULONG FunctionNumber;

    //
    // Holds Flags that may be unique to this particular operation
    //
    ULONG Flags;

    //
    // Reserved for internal use and/or future expansion
    //

    ULONG Reserved[4];

    //
    // Holds the structures used in performing the various 1394 APIs
    //

    union {

        //
        // Fields necessary in order for the class driver to carry out an
        // AllocateAddressRange request.
        // 
        struct {
            PMDL             lpBuffer;              // Address to map to 1394 space
            ULONG            nLength;               // Length of 1394 space desired
            ULONG            fulAccessType;         // Desired access: R, W, L
            ULONG            fulNotificationOptions;// Notify options on Async access
            PVOID            lpCallback;            // Pointer to callback routine
            PVOID            lpContext;             // Pointer to driver supplied data
            P1394_OFFSET     Required1394Offset;    // Offset that must be returned
            PULONG           lpAddressesReturned;   // Pointer to number of address returned
            PLARGE_INTEGER   lp1394Address;         // Returned 1394 Address(es)
            ULONG            Reserved;              // Reserved for future use
        } clsAllocateAddressRange;

        //
        // Fields necessary in order for the class driver to carry out a
        // FreeAddressRange request.
        //
        struct {
            ULONG            nAddressesToFree;      // Number of Addresses to free
            PLARGE_INTEGER   lp1394Address;         // Array of 1394 Address(es) to Free
            ULONG            Reserved;              // Reserved for future use
        } clsFreeAddressRange;

        // 
        // Fields necessary in order for the class driver to carry out an
        // AsyncRead request.  
        //
        struct {
            P1394_IO_ADDRESS DestinationAddress;    // Address to read from 
            ULONG            nNumberOfBytesToRead;  // Bytes to read
            ULONG            nBlockSize;            // Block size of read
            ULONG            fulFlags;              // Flags pertinent to read
            PMDL             lpBuffer;              // Destination buffer
            ULONG            Reserved;              // Reserved for future use
        } clsAsyncRead;

        // 
        // Fields necessary in order for the class driver to carry out an
        // AsyncWrite request.
        //
        struct {
            P1394_IO_ADDRESS DestinationAddress;    // Address to write to
            ULONG            nNumberOfBytesToWrite; // Bytes to write
            ULONG            nBlockSize;            // Block size of write
            ULONG            fulFlags;              // Flags pertinent to write
            PMDL             lpBuffer;              // Destination buffer
            ULONG            Reserved;              // Reserved for future use
        } clsAsyncWrite;

        // 
        // Fields necessary in order for the class driver to carry out an
        // AsyncLock request.
        //
        struct {
            P1394_IO_ADDRESS DestinationAddress;    // Address to lock to
            ULONG            nNumberOfArgBytes;     // Bytes in Arguments
            ULONG            nNumberOfDataBytes;    // Bytes in DataValues
            ULONG            fulTransactionType;    // Lock transaction type
            ULONG            fulFlags;              // Flags pertinent to lock
            ULONG            Arguments[2];          // Arguments used in Lock
            ULONG            DataValues[2];         // Data values 
            PVOID            lpBuffer;              // Destination buffer (virtual address)
            ULONG            Reserved;              // Reserved for future use
        } clsAsyncLock;

        //
        // Fields necessary in order for the class driver to carry out an
        // IsochAllocateBandwidth request
        //
        struct {
            ULONG           nMaxBytesPerFrameRequested; // Bytes per Isoch frame
            ULONG           fulSpeed;                   // Speed flags
            PHANDLE         lpBandwidth;                // Pointer to bandwidth handle
            PULONG          lpBytesPerFrameAvailable;   // Available bytes per frame
            PULONG          lpSpeedSelected;            // Pointer to speed to be used
        } clsIsochAllocateBandwidth;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochAllocateChannel request.
        //
        struct {
            ULONG           nRequestedChannel;      // Need a specific channel
            PULONG          lpChannel;              // Points to returned channel
            PLARGE_INTEGER  lpChannelsAvailable;    // Channels available
        } clsIsochAllocateChannel;

        //
        // Fields necessary in order for the class driver to carry out a
        // IsochAllocateResources request
        //
        struct {
            ULONG           fulSpeed;               // Speed flags
            ULONG           fulFlags;               // Flags
            PHANDLE         lpResource;             // lpResources
        } clsIsochAllocateResources;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochAttachBuffers request
        //
        struct {
            HANDLE              hResource;          // Resource handle
            PISOCH_DESCRIPTOR   lpIsochDescriptor;  // Pointer to Isoch descriptors
        } clsIsochAttachBuffers;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochDetachBuffers request
        //
        struct {
            HANDLE              hResource;          // Resource handle
            PISOCH_DESCRIPTOR   lpIsochDescriptor;  // Pointer to Isoch descriptors
        } clsIsochDetachBuffers;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochFreeChannel request
        //
        struct {
            HANDLE              hBandwidth;         // Bandwidth handle to release
        } clsIsochFreeBandwidth;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochFreeChannel request
        //
        struct {
            ULONG               nChannel;           // Channel to release
        } clsIsochFreeChannel;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochFreeResources request
        //
        struct {
            HANDLE              hResource;          // Resource handle
        } clsIsochFreeResources;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochListen request.
        //
        struct {
            ULONG               nChannel;           // Channel to listen on
            HANDLE              hResource;          // Resource handle to listen on
            ULONG               fulFlags;           // Flags
            ULONG               nStartCycle;        // Start cycle
            LARGE_INTEGER       StartTime;          // Start time
            ULONG               ulSynchronize;      // Sy 
            ULONG               ulTag;              // Tag
        } clsIsochListen;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochQueryCurrentCycleNumber request.
        //
        struct {
            PULONG              lpCycleNumber;      // Current cycle number returned
        } clsIsochQueryCurrentCycleNumber;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochQueryResources request.
        //
        struct {
            PULONG              lpBytesPerFrameAvailable;   // Per Isoch Frame
            PLARGE_INTEGER      lpChannelsAvailable;        // Available channels
        } clsIsochQueryResources;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochSetChannelBandwidth request.
        //
        struct {
            HANDLE              hBandwidth;         // Bandwidth handle
            ULONG               nMaxBytesPerFrame;  // bytes per Isoch frame
        } clsIsochSetChannelBandwidth;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochStop request.
        //
        struct {
            ULONG               nChannel;           // Channel to stop on
            HANDLE              hResource;          // Resource handle to stop on
            ULONG               fulFlags;           // Flags
            ULONG               nStopCycle;         // Cycle to stop on
            LARGE_INTEGER       StopTime;           // Time to stop on
            ULONG               ulSynchronize;      // Sy
            ULONG               ulTag;              // Tag
        } clsIsochStop;

        //
        // Fields necessary in order for the class driver to carry out a 
        // IsochTalk request.
        //
        struct {
            ULONG               nChannel;           // Channel to talk on
            HANDLE              hResource;          // Resource handle to talk on
            ULONG               fulFlags;           // Flags
            ULONG               nStartCycle;        // Cycle to start on
            LARGE_INTEGER       StartTime;          // Time to start on
            ULONG               ulSynchronize;      // Sy
            ULONG               ulTag;              // Tag
        } clsIsochTalk;

        //
        // Fields necessary in order for the class driver to carry out a 
        // AppendUnitDirectoryEntry request.
        //
        struct {
            UNIT_DIR        UnitDirectory;          // Unit dir to append
            UNIT_DEP_DIR    UnitDependentDirectory; // Unit dep dir to append
            VENDOR_LEAF     VendorLeaf;             // Vendor leaf to append
            MODEL_LEAF      ModelLeaf;              // Model leaf
            PHANDLE         lpDirHandle;            // returned handle
        } clsAppendUnitDirectoryEntry;

        //
        // Fields necessary in order for the class driver to carry out a 
        // DeleteUnitDirectoryEntry request.
        //
        struct {
            HANDLE          hDirHandle;             // handle to delete
        } clsDeleteUnitDirectoryEntry;

        //
        // Fields necessary in order for the class driver to carry out a 
        // GetLocalHostInformation request.
        //
        struct {
            ULONG           nLevel;                 // level of info requested
            INFO_BLOCK1     InfoBlock1;             // returned information
        } clsGetLocalHostInformation;

        //
        // Fields necessary in order for the class driver to carry out a 
        // Get1394AddressFromDeviceObject request.
        //
        struct {
            PP1394_NODE_ADDRESS lpNodeAddress;      // Returned Node address
        } clsGet1394AddressFromDeviceObject;

        //
        // Fields necessary in order for the class driver to carry out a 
        // Control request.
        //
        struct {
            ULONG           ulIoControlCode;        // Control code
            PMDL            lpInBuffer;             // Input buffer
            ULONG           ulInBufferLength;       // Input buffer length
            PMDL            lpOutBuffer;            // Output buffer
            ULONG           ulOutBufferLength;      // Output buffer length
            PULONG          lpBytesReturned;        // Bytes returned
        } clsControl;

        //
        // Fields necessary in order for the class driver to carry out a 
        // GetMaxSpeedBetweenDevices request.
        //
        struct {
            ULONG           ulNumberOfDestinations; // Number of destinations
            PDEVICE_OBJECT  hDestinationDeviceObjects[64]; // Destinations
            PULONG          lpSpeed;                // Max speed returned
        } clsGetMaxSpeedBetweenDevices;

        //
        // Fields necessary in order for the class driver to carry out a 
        // SetDeviceSpeed request.
        //
        struct {
            ULONG           fulSpeed;               // Speed
        } clsSetDeviceSpeed;

        //
        // Fields necessary in order for the class driver to carry out a 
        // GetConfigurationInformation request.
        // 
        struct {
            PROOT_DIR       lpRootDirectory;        // Pointer to root directory
            PUNIT_DIR       lpUnitDirectory;        // Pointer to unit directory
            ULONG           UnitDependentDirectoryBufferSize;
            PULONG          lpUnitDependentDirectoriesReturned;
            PUNIT_DEP_DIR   lpUnitDependentDirectory;
            ULONG           VendorLeafBufferSize;   // Size available to get vendor leafs
            PULONG          lpVendorLeafsReturned;  // Number of leafs returned
            PVENDOR_LEAF    lpVendorLeaf;           // Pointer to vendor leafs
            ULONG           ModelLeafBufferSize;    // Size available to get model leafs
            PULONG          lpModelLeafsReturned;   // Number of leafs returned
            PMODEL_LEAF     lpModelLeaf;            // Pointer to model leafs
        } clsGetConfigurationInformation;

        //
        // Fields necessary in order for the class driver to carry out a
        // Get1394DeviceObjects request.
        //
        struct {
            ULONG           nSizeOfBuffer;          // Size of incoming buffer
            PMDL            lpBuffer;               // Where to put DeviceObjects
        } clsGet1394DeviceObjects;

    } u;        

} P1394_CLASS_REQUEST, *PP1394_CLASS_REQUEST;


//
// This miniport request structure is the basis of communication to the 
// 1394 port driver.
//

typedef struct _P1394_PORT_REQUEST {

    //
    // Holds the zero based Function number that corresponds to the request
    // that the class driver is asking the miniport to carry out.
    //
    ULONG FunctionNumber;

    //
    // Holds Flags that may be unique to this particular operation
    //
    ULONG Flags;

    //
    // Reserved for internal use and/or future expansion
    //

    ULONG Reserved[4];

    //
    // Holds the structures used in performing the various 1394 APIs
    //

    union {

        //
        // Fields necessary in order for the port driver to carry out an
        // AllocateAddressRange request.
        //
        struct {
            PMDL             lpBuffer;              // Address to map to 1394 space
            ULONG            nLength;               // Length of 1394 space desired
            ULONG            fulAccessType;         // Desired access: R, W, L
            ULONG            fulNotificationOptions;// Notify options on Async access
            PVOID            lpCallback;            // Pointer to callback routine
            PVOID            lpContext;             // Pointer to driver supplied data
            P1394_OFFSET     Required1394Offset;    // Offset that must be returned
            PULONG           lpAddressesReturned;   // Pointer to number of address returned (filled in by class)
            PLARGE_INTEGER   lp1394Address;         // Returned 1394 Address(es) (filled in by class)
            PVOID            DeviceExtension;       // Device Extension who created this mapping
        } prtAllocateAddressRange;

        //
        // Fields necessary in order for the port driver to carry out a
        // FreeAddressRange request.
        //
        struct {
            ULONG            nAddressesToFree;      // Number of Addresses To Free
            PLARGE_INTEGER   lp1394Address;         // Pointer to 1394 Address(es) to free
            PVOID            DeviceExtension;       // Device Extension who created this mapping
        } prtFreeAddressRange;

        //
        // Fields necessary in order for the port driver to carry out an
        // AsyncRead request.
        //
        struct {
            P1394_IO_ADDRESS DestinationAddress;    // Address to read from
            ULONG            nNumberOfBytesToRead;  // Bytes to read
            ULONG            nBlockSize;            // Block size of read
            ULONG            fulFlags;              // Flags pertinent to read
            PMDL             lpBuffer;              // Destination buffer
            UCHAR            chPriority;            // Priority to send
            UCHAR            nSpeed;                // Speed at which to send
            UCHAR            tCode;                 // Type of Read to do
        } prtAsyncRead;

        //
        // Fields necessary in order for the port driver to carry out an
        // AsyncWrite request.
        // 
        struct {
            P1394_IO_ADDRESS DestinationAddress;    // Address to write to
            ULONG            nNumberOfBytesToWrite; // Bytes to write
            ULONG            nBlockSize;            // Block size of write
            ULONG            fulFlags;              // Flags pertinent to write
            PMDL             lpBuffer;              // Destination buffer
            UCHAR            chPriority;            // Priority to send
            UCHAR            nSpeed;                // Speed at which to send
            UCHAR            tCode;                 // Type of Write to do
        } prtAsyncWrite;

        //
        // Fields necessary in order for the port driver to carry out an
        // AsyncWrite request.
        // 
        struct {
            P1394_IO_ADDRESS DestinationAddress;    // Address to write to
            ULONG            nNumberOfArgBytes;     // Bytes in Arguments
            ULONG            nNumberOfDataBytes;    // Bytes in DataValues
            ULONG            Extended_tCode;        // Lock transaction type
            ULONG            fulFlags;              // Flags pertinent to lock
            ULONG            Arguments[2];          // Arguments used in Lock
            ULONG            DataValues[2];         // Data values 
            PVOID            lpBuffer;              // Destination buffer (virtual address)
            UCHAR            chPriority;            // Priority to send
            UCHAR            nSpeed;                // Speed at which to send
            UCHAR            tCode;                 // Type of Write to do
        } prtAsyncLock;

        //
        // Fields necessary in order for the port driver to carry out a
        // IsochAllocateResources request
        //
        struct {
            ULONG           fulSpeed;               // Speed flags
            ULONG           fulFlags;               // Flags
            PHANDLE         lpResource;             // lpResources
        } prtIsochAllocateResources;

        //
        // Fields necessary in order for the port driver to carry out a 
        // IsochAttachBuffers request
        //
        struct {
            HANDLE              hResource;          // Resource handle
            PISOCH_DESCRIPTOR   lpIsochDescriptor;  // Pointer to Isoch descriptors
        } prtIsochAttachBuffers;

        //
        // Fields necessary in order for the port driver to carry out a 
        // IsochDetachBuffers request
        //
        struct {
            HANDLE              hResource;          // Resource handle
            PISOCH_DESCRIPTOR   lpIsochDescriptor;  // Pointer to Isoch descriptors
        } prtIsochDetachBuffers;

        //
        // Fields necessary in order for the port driver to carry out a 
        // IsochFreeResources request
        //
        struct {
            HANDLE              hResource;          // Resource handle
        } prtIsochFreeResources;

        //
        // Fields necessary in order for the port driver to carry out a 
        // IsochListen request.
        //
        struct {
            ULONG               nChannel;           // Channel to listen on
            HANDLE              hResource;          // Resource handle to listen on
            ULONG               fulFlags;           // Flags
            ULONG               nStartCycle;        // Start cycle
            LARGE_INTEGER       StartTime;          // Start time
            ULONG               ulSynchronize;      // Sy 
            ULONG               ulTag;              // Tag
        } prtIsochListen;

        //
        // Fields necessary in order for the port driver to carry out an
        // IsochQueryCurrentCycleNumber request
        //
        struct {
            PULONG           lpCycleNumber;         // Cycle number (returned by port driver)
        } prtIsochQueryCurrentCycleNumber;

        //
        // Fields necessary in order for the port driver to carry out a 
        // IsochStop request.
        //
        struct {
            ULONG               nChannel;           // Channel to stop on
            HANDLE              hResource;          // Resource handle to stop on
            ULONG               fulFlags;           // Flags
            ULONG               nStopCycle;         // Cycle to stop on
            LARGE_INTEGER       StopTime;           // Time to stop on
            ULONG               ulSynchronize;      // Sy
            ULONG               ulTag;              // Tag
        } prtIsochStop;

        //
        // Fields necessary in order for the port driver to carry out a 
        // IsochTalk request.
        //
        struct {
            ULONG               nChannel;           // Channel to talk on
            HANDLE              hResource;          // Resource handle to talk on
            ULONG               fulFlags;           // Flags
            ULONG               nStartCycle;        // Cycle to start on
            LARGE_INTEGER       StartTime;          // Time to start on
            ULONG               ulSynchronize;      // Sy
            ULONG               ulTag;              // Tag
        } prtIsochTalk;

        //
        // Fields necessary in order for the port driver to carry out a
        // Control request.
        //
        struct {
            ULONG           ulIoControlCode;        // Control code
            PMDL            lpInBuffer;             // Input buffer
            ULONG           ulInBufferLength;       // Input buffer length
            PMDL            lpOutBuffer;            // Output buffer
            ULONG           ulOutBufferLength;      // Output buffer length
            PULONG          lpBytesReturned;        // Bytes returned
        } prtControl;
        
        //
        // Fields necessary in order for the port driver to carry out a
        // GetTopologyMap request.
        //
        struct {
            ULONG           nSizeOfBuffer;          // Size of provided buffer
            PVOID           lpBuffer;               // Where to put Self IDs
            PULONG          lpSpaceNeeded;          // How much do we need?
        } prtGetTopologyMap;

        //
        // Fields necessary in order for the port driver to carry out a
        // GetCapabilityBits request.
        // 
        struct {
            PULONG          lpPortCapabilities;     // Capabilities bits
        } prtGetCapabilityBits;

    } u;

} P1394_PORT_REQUEST, *PP1394_PORT_REQUEST;


//
// Various definitions
//

#define IOCTL_P1394_CLASS       CTL_CODE( \
                                    FILE_DEVICE_BUS_EXTENDER, \
                                    0, \
                                    METHOD_IN_DIRECT, \
                                    FILE_ANY_ACCESS \
                                    )

//
// Various Interesting 1394 IEEE 1212 locations
//
#define P1394_ROOT_DIR_LOCATION_HI    0xffff
#define P1394_ROOT_DIR_LOCATION_LO    0xf0000400


//
// 1394 Transaction codes 
//

#define TCODE_WRITE_REQUEST_QUADLET     0   
#define TCODE_WRITE_REQUEST_BLOCK       1
#define TCODE_WRITE_RESPONSE            2
#define TCODE_RESERVED1                 3
#define TCODE_READ_REQUEST_QUADLET      4
#define TCODE_READ_REQUEST_BLOCK        5
#define TCODE_READ_RESPONSE_QUADLET     6
#define TCODE_READ_RESPONSE_BLOCK       7
#define TCODE_CYCLE_START               8
#define TCODE_LOCK_REQUEST              9
#define TCODE_ISOCH_DATA_BLOCK          10
#define TCODE_LOCK_RESPONSE             11
#define TCODE_RESERVED2                 12
#define TCODE_RESERVED3                 13
#define TCODE_SELFID                    14
#define TCODE_RESERVED4                 15

//
// 1394 Extended Transaction codes
//

#define EXT_TCODE_RESERVED0             0
#define EXT_TCODE_MASK_SWAP             1
#define EXT_TCODE_COMPARE_SWAP          2
#define EXT_TCODE_FETCH_ADD             3
#define EXT_TCODE_LITTLE_ADD            4
#define EXT_TCODE_BOUNDED_ADD           5
#define EXT_TCODE_WRAP_ADD              6

//
// 1394 Acknowledgement codes
//
#define ACODE_RESERVED_0                0
#define ACODE_ACK_COMPLETE              1
#define ACODE_ACK_PENDING               2
#define ACODE_RESERVED_3                3
#define ACODE_ACK_BUSY_X                4
#define ACODE_ACK_BUSY_A                5
#define ACODE_ACK_BUSY_B                6
#define ACODE_RESERVED_7                7
#define ACODE_RESERVED_8                8
#define ACODE_RESERVED_9                9
#define ACODE_RESERVED_10               10
#define ACODE_RESERVED_11               11
#define ACODE_RESERVED_12               12
#define ACODE_ACK_DATA_ERROR            13
#define ACODE_ACK_TYPE_ERROR            14
#define ACODE_RESERVED_15               15

//
// 1394 Response codes
//
#define RCODE_RESPONSE_COMPLETE         0
#define RCODE_RESERVED1                 1
#define RCODE_RESERVED2                 2
#define RCODE_RESERVED3                 3
#define RCODE_CONFLICT_ERROR            4
#define RCODE_DATA_ERROR                5
#define RCODE_TYPE_ERROR                6
#define RCODE_ADDRESS_ERROR             7
#define RCODE_TIMED_OUT                 15

//
// 1394 Speed codes
//
#define SCODE_100_RATE                  0
#define SCODE_200_RATE                  1
#define SCODE_400_RATE                  2
#define SCODE_FUTURE                    3

#define SELF_ID_CONNECTED_TO_CHILD      3
#define SELF_ID_CONNECTED_TO_PARENT     2

//
// 1394 Async Data Payload Sizes
//
#define ASYNC_PAYLOAD_100_RATE          512
#define ASYNC_PAYLOAD_200_RATE          1024
#define ASYNC_PAYLOAD_400_RATE          2048

#define P1394_LOCAL_BUS                 0x3ff

#define P1394_CLASS_NAME                L"P1394Class"
#define P1394_PORT_BASE_NAME            L"P1394Port"
#define P1394_PORT_DEVICE_NAME          L"\\Device\\P1394Port"
#define P1394_DOS_DEVICE_NAME           L"\\DosDevices\\P1394"

#define P1394_DEVICE_EXTENSION_TAG      0xdeadbeef
#define P1394_CLASS_EXTENSION_TAG       0xdeafcafe
#define P1394_ROOT_DIR_SIGNITURE        0x31333934


//
// Request to Class driver function number definitions.  Try to keep function
// numbers the same as the port driver function numbers.  Then we can reuse
// some fields withing the class request structure.
//

#define CLS_REQUEST_ALLOCATE_ADDRESS_RANGE      0
#define CLS_REQUEST_FREE_ADDRESS_RANGE          1
#define CLS_REQUEST_ASYNC_READ                  2
#define CLS_REQUEST_ASYNC_WRITE                 3
#define CLS_REQUEST_ASYNC_LOCK                  4
#define CLS_REQUEST_ISOCH_ALLOCATE_BANDWIDTH    5
#define CLS_REQUEST_ISOCH_ALLOCATE_CHANNEL      6
#define CLS_REQUEST_ISOCH_ALLOCATE_RESOURCES    7
#define CLS_REQUEST_ISOCH_ATTACH_BUFFERS        8
#define CLS_REQUEST_ISOCH_DETACH_BUFFERS        9
#define CLS_REQUEST_ISOCH_FREE_BANDWIDTH        10
#define CLS_REQUEST_ISOCH_FREE_CHANNEL          11
#define CLS_REQUEST_ISOCH_FREE_RESOURCES        12
#define CLS_REQUEST_ISOCH_LISTEN                13
#define CLS_REQUEST_ISOCH_QUERY_CYCLE_NUMBER    14
#define CLS_REQUEST_ISOCH_QUERY_RESOURCES       15
#define CLS_REQUEST_ISOCH_SET_CHANNEL_BANDWIDTH 16
#define CLS_REQUEST_ISOCH_STOP                  17
#define CLS_REQUEST_ISOCH_TALK                  18
#define CLS_REQUEST_APPEND_UNIT_DIRECTORY_ENTRY 19
#define CLS_REQUEST_DELETE_UNIT_DIRECTORY_ENTRY 20
#define CLS_REQUEST_GET_LOCAL_HOST_INFO         21
#define CLS_REQUEST_GET_ADDR_FROM_DEVICE_OBJECT 22
#define CLS_REQUEST_CONTROL                     23
#define CLS_REQUEST_GET_SPEED_BETWEEN_DEVICES   24
#define CLS_REQUEST_SET_DEVICE_SPEED            25
#define CLS_REQUEST_GET_CONFIGURATION_INFO      26

#define CLS_REQUEST_GET_DEVICE_OBJECTS          1000    // DEBUG

//
// Request to miniport driver function number definitions.  Try to
// keep the same as Class function number definitions.  Then we might
// be able to reuse portions of the class request structure.
//

#define PORT_REQUEST_ALLOCATE_ADDRESS_RANGE     0
#define PORT_REQUEST_FREE_ADDRESS_RANGE         1
#define PORT_REQUEST_ASYNC_READ                 2
#define PORT_REQUEST_ASYNC_WRITE                3
#define PORT_REQUEST_ASYNC_LOCK                 4
#define PORT_REQUEST_ISOCH_ALLOCATE_RESOURCES   7
#define PORT_REQUEST_ISOCH_ATTACH_BUFFERS       8
#define PORT_REQUEST_ISOCH_DETACH_BUFFERS       9
#define PORT_REQUEST_ISOCH_FREE_RESOURCES       12
#define PORT_REQUEST_ISOCH_LISTEN               13
#define PORT_REQUEST_ISOCH_QUERY_CYCLE_NUMBER   14
#define PORT_REQUEST_ISOCH_STOP                 17
#define PORT_REQUEST_ISOCH_TALK                 18
#define PORT_REQUEST_CONTROL                    23
#define PORT_REQUEST_GET_TOPOLOGY_MAP           28

#define PORT_REQUEST_GET_CAPABILITY_BITS        1001


//
// Definition of port capability bits
//

//
// Specifies port can do AllocateAdddressRange/FreeAddressRange internally.
// This bit forces the 1394 Class driver to hand down the AllocateAddressRange
// or FreeAddressRange requests exactly as it received them.  The Port driver
// is now responsible for returning and maintaining the 1394 Offsets returned.
//
#define PORT_SUPPORTS_ADDRESS_MAPPING           1

//
// Specifies port can handle large Async requests.  For instance, AsyncRead
// and AsyncWrite take a ULONG as input for the amount of data to transfer.
// If this capability bit is NOT on, then the 1394 Class driver will break
// up Async requests if the amount of data to transfer is larger than the
// payload size supported by the data rate.  If this capability bit IS on,
// then the 1394 Class driver will NOT break up these large Async requests,
// and simply hand the request to the port driver.  It is then up to the
// port driver to deal with issuing seperate 1394 requests in order to
// satisfy the amount of data requested.
//
#define PORT_SUPPORTS_LARGE_ASYNC_REQUESTS      2

//
// Specifies port can handle Async requests with nBlockSize != 0.  If this
// bit is NOT on, the 1394 Class driver will break up Async requests when 
// nBlockSize != 0, so the port driver will not have to.  If this bit is
// ON, then the 1394 Class driver expects the port driver to send the
// request out at the appropriate block size.
//
#define PORT_SUPPORTS_ASYNC_BLOCKSIZE           4



//
// Definition of fulFlags in Async Read/Write/Lock requests
//

#define ASYNC_FLAGS_NONINCREMENTING             1

//
// Definition of fulAccessType for clsAllocateAddressRange
//

#define ACCESS_FLAGS_TYPE_READ                  1
#define ACCESS_FLAGS_TYPE_WRITE                 2
#define ACCESS_FLAGS_TYPE_LOCK                  4

//
// Definition of fulNotificationOptions for clsAllocateAddressRange
//

#define NOTIFY_FLAGS_AFTER_READ                 1
#define NOTIFY_FLAGS_AFTER_WRITE                2
#define NOTIFY_FLAGS_AFTER_LOCK                 4
#define NOTIFY_FLAGS_BEFORE_READ                8
#define NOTIFY_FLAGS_BEFORE_WRITE               16
#define NOTIFY_FLAGS_BEFORE_LOCK                32

//
// Definitions of Speed flags used throughout 1394 Class APIs
//

#define SPEED_FLAGS_100                         1
#define SPEED_FLAGS_200                         2
#define SPEED_FLAGS_400                         4
#define SPEED_FLAGS_1600                        8
#define SPEED_FLAGS_FASTEST                     16

//
// Definitions of Channel flags
//

#define ISOCH_ANY_CHANNEL                       0xffffffff
#define ISOCH_MAX_CHANNEL                       63

//
// Definition of Resource flags used with Isochronous transfers
//

#define ISOCH_RESOURCE_USED_IN_LISTENING        1
#define ISOCH_RESOURCE_USED_IN_TALKING          2

//
// Definitions of Isoch Descriptor flags
//

#define ISOCH_DESCRIPTOR_FLAGS_CALLBACK         0x80000000
#define ISOCH_DESCRIPTOR_FLAGS_CIRCULAR         0x40000000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\writer\aviutil.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

//
// container classes, help functions. not necessarily thread-safe
//

#ifndef _util_h
#define _util_h

// thread-safe pool of objects.
template <class TYPE> class CPool {
private:
  int nMax;                     // Max objects allowed in queue
  int iNextPut;                 // Array index of next "PutMsg"
  int iNextGet;                 // Array index of next "GetMsg"
  int cObj;                     // count of pool entries
  TYPE **QueueObjects;          // Array of pointers
  TYPE *ObjectPool;             // array of objects
  CCritSec m_cs;                // critical section

  void Initialize(int n);

public:
  CPool(int n) { Initialize(n); }
  ~CPool() { delete[] QueueObjects; delete[] ObjectPool; }
  TYPE *Get();
  void Put(TYPE *Object);
};

template<class TYPE>
inline void CPool<TYPE>::Initialize(int n)
{
  iNextPut = iNextGet = 0;
  nMax = n;

  ObjectPool = new TYPE[n];
  QueueObjects = new TYPE*[n];

  for(int i = 0; i < nMax; i++)
    QueueObjects[i] = &(ObjectPool[i]);

  cObj = nMax;
}

template<class TYPE>
inline TYPE* CPool<TYPE>::Get()
{
  CAutoLock lock(&m_cs);

  cObj--;
  ASSERT(cObj >= 0);

  TYPE* Object = QueueObjects[iNextGet++];
  ASSERT(Object <= &ObjectPool[nMax] && Object >= &ObjectPool[0]);
  if(iNextGet >= nMax)
    iNextGet = 0;


  return Object;
}

template<class TYPE>
inline void CPool<TYPE>::Put(TYPE* Object)
{
  CAutoLock lock(&m_cs);

  ASSERT(Object <= &ObjectPool[nMax] && Object >= &ObjectPool[0]);

  cObj++;
  ASSERT(cObj <= nMax);

  QueueObjects[iNextPut++] = Object;
  if(iNextPut >= nMax)
    iNextPut = 0;
}

// ------------------------------------------------------------------------
// conversion from integers to two character hex and back (for AVI
// riff chunk ids)

inline unsigned int WFromHexrg2b(BYTE* rgb)
{
  unsigned high, low;

  low  = rgb[1] <= '9' && rgb[1] >= '0' ? rgb[1] - '0' : rgb[1] - 'A' + 0xa;
  high = rgb[0] <= '9' && rgb[0] >= '0' ? rgb[0] - '0' : rgb[0] - 'A' + 0xa;

  ASSERT((rgb[1] <= '9' && rgb[1] >= '0') || (rgb[1] <= 'F' && rgb[1] >= 'A'));
  ASSERT((rgb[0] <= '9' && rgb[0] >= '0') || (rgb[0] <= 'F' && rgb[0] >= 'A'));

  ASSERT(high <= 0xf && low <= 0xf);

  return low + 16 * high;
}

inline void Hexrg2bFromW(BYTE *rgbDest_, unsigned int wSrc_)
{
  ASSERT(wSrc_ <= 255);
  unsigned high = wSrc_ / 16, low = wSrc_ % 16;
  ASSERT(high <= 0xf && low <= 0xf);

  rgbDest_[1] = low  <= 9 ? low  + '0' : low - 0xa  + 'A';
  rgbDest_[0] = high <= 9 ? high + '0' : high -0xa + 'A';

  ASSERT((rgbDest_[1] <= '9' && rgbDest_[1] >= '0') ||
         (rgbDest_[1] <= 'F' && rgbDest_[1] >= 'A'));
  ASSERT((rgbDest_[0] <= '9' && rgbDest_[0] >= '0') ||
         (rgbDest_[0] <= 'F' && rgbDest_[0] >= 'A'));
}

typedef unsigned __int64 ULONGLONG;

#ifdef DEBUG
#define DEBUG_EX(x) x
#else
#define DEBUG_EX(x)
#endif

#endif // _util_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\writer\bufio.cpp ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "bufio.h"

CImperfectBufIo::CImperfectBufIo(
  TCHAR *szName,
  ULONG cbBuffer,
  ULONG cBuffers,
  HRESULT *phr)
    : CFileIo(szName, phr)
{
  m_cbBuffer = cbBuffer;
  m_cBuffers = cBuffers;
  m_cbAlign = 0;
  m_pAllocator = 0;
  m_pSample = 0;
}

CImperfectBufIo::~CImperfectBufIo()
{
  ASSERT(m_pSample == 0);
  if(m_pAllocator != 0)
    m_pAllocator->Release();
  m_pAllocator = 0;
}

HRESULT CImperfectBufIo::Create()
{
  //
  // make our allocator
  //
  if(m_cbAlign == 0)
  {
    DbgLog(( LOG_ERROR, 2,
             NAME("CImperfectBufIo::Create:: GetMemReq not called.")));
    return E_UNEXPECTED;
  }

  HRESULT hr = S_OK;

  CMemAllocator *pMemObject = NULL;
  pMemObject = new CMemAllocator(NAME("avidest:bufio allocator"),NULL, &hr);
  if(pMemObject == 0)
    return E_OUTOFMEMORY;
  if(FAILED(hr))
  {
    delete pMemObject;
    return hr;
  }

  hr = pMemObject->QueryInterface(IID_IMemAllocator,(void **)&m_pAllocator);
  if (FAILED(hr))
  {
    delete pMemObject;
    return hr;
  }
  ASSERT(m_pAllocator != NULL);

  ALLOCATOR_PROPERTIES Request, Actual;

  Request.cBuffers = m_cBuffers;
  Request.cbBuffer = m_cbBuffer;
  Request.cbAlign = m_cbAlign;
  Request.cbPrefix = 0;         // !!!

  hr = m_pAllocator->SetProperties(&Request, &Actual);

  if(FAILED(hr))
  {
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             NAME("CImperfectBufIo::Create:: SetProperties failed.")));
    return hr;
  }

  if ((Request.cbBuffer > Actual.cbBuffer) ||
      (Request.cBuffers > Actual.cBuffers) ||
      (Request.cbAlign > Actual.cbAlign))
  {
    ASSERT(!"our allocator refused our values");
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             NAME("CImperfectBufIo::Create:: allocator refused values.")));
    return E_UNEXPECTED;
  }

  hr = m_pAllocator->Commit();
  if(FAILED(hr))
  {
    ASSERT(!"our allocator won't commit");
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             NAME("CImperfectBufIo::Create:: Commit failed.")));
    return hr;
  }

  hr = CFileIo::Create();
  if(FAILED(hr))
  {
    m_pAllocator->Release();
    m_pAllocator = 0;
    DbgLog(( LOG_ERROR, 2,
             NAME("CImperfectBufIo::Create:: Create failed.")));
    return hr;
  }

  return S_OK;
}

HRESULT CImperfectBufIo::Close()
{
  if(m_pAllocator)
    m_pAllocator->Release();
  m_pAllocator = 0;
  return CFileIo::Close();
}

HRESULT CImperfectBufIo::StreamingStart(ULONGLONG ibFile)
{
  if(m_pSample != 0)
  {
    ASSERT(!"already streaming");
    return E_UNEXPECTED;
  }

  GetBuffer();
  m_ibFile = ibFile;
  if(ibFile % m_cbAlign != 0)
  {
    m_ibFile -= ibFile % m_cbAlign;
    m_ibBuffer += (ULONG)(ibFile % m_cbAlign);
  }

  ASSERT(m_ibFile % m_cbAlign == 0);

  return CFileIo::StreamingStart(m_ibFile);
}

HRESULT CImperfectBufIo::StreamingEnd()
{
  HRESULT hr =  FlushBuffer();
  if(FAILED(hr))
  {
    CFileIo::StreamingEnd();
  }
  else
  {
    hr = CFileIo::StreamingEnd();
  }
  ASSERT(m_pSample == 0);

  return hr;
}

HRESULT CImperfectBufIo::StreamingGetFilePointer(ULONGLONG *pibFile)
{
  if(m_pSample)
  {
    *pibFile =  m_ibFile + m_ibBuffer;
    return S_OK;
  }

  return E_UNEXPECTED;
}

HRESULT CImperfectBufIo::StreamingSeek(ULONG cbSeek)
{
  HRESULT hr = S_OK;

  ULONG cbSeeked;
  if(m_ibBuffer + cbSeek > m_cbBuffer)
    cbSeeked = m_cbBuffer - m_ibBuffer;
  else
    cbSeeked = cbSeek;

  m_ibBuffer += cbSeeked;
  cbSeek -= cbSeeked;

  ASSERT(m_ibBuffer <= m_cbBuffer);
  if(m_ibBuffer == m_cbBuffer)
  {
    hr = FlushBuffer();
    if(FAILED(hr))
      return hr;

    GetBuffer();
  }

  ASSERT(m_ibFile % m_cbAlign == 0);

  if(cbSeek != 0)
  {
    if(cbSeek % m_cbAlign != 0)
    {
      m_ibBuffer += cbSeek % m_cbAlign;
      cbSeek -= cbSeek % m_cbAlign;
      m_ibFile += cbSeek;
    }

    ASSERT(m_ibFile % m_cbAlign == 0);
    ASSERT(cbSeek % m_cbAlign == 0);
    return CFileIo::StreamingSeek(cbSeek);
  }

  return S_OK;
}

HRESULT CImperfectBufIo::StreamingWrite(
  BYTE *pbData,
  ULONG cbData,
  FileIoCallback fnCallback,
  void *pMisc)
{
  while(cbData > 0)
  {
    ULONG cbCopied;
    if(m_ibBuffer + cbData > m_cbBuffer)
      cbCopied = m_cbBuffer - m_ibBuffer;
    else
      cbCopied = cbData;

    BYTE *pb;
    HRESULT hr = m_pSample->GetPointer(&pb);
    ASSERT(SUCCEEDED(hr));
    CopyMemory(
      pb + m_ibBuffer,
      pbData,
      cbCopied);

    m_ibBuffer += cbCopied;
    cbData -= cbCopied;
    pbData += cbCopied;

    ASSERT(m_ibBuffer <= m_cbBuffer);
    if(m_ibBuffer == m_cbBuffer)
    {
      HRESULT hr = FlushBuffer();
      if(FAILED(hr))
      {
        DbgLog(( LOG_ERROR, 2,
                 NAME("CImperfectBufIo::StreamingWrite: FlushBuffer failed.")));
        if(fnCallback)
          fnCallback(pMisc);
        return hr;
      }

      GetBuffer();
    }
  }

  if(fnCallback)
    fnCallback(pMisc);
  return S_OK;
}

void CImperfectBufIo::GetMemReq(
  ULONG* pAlignment,
  ULONG *pcbPrefix,
  ULONG *pcbSuffix)
{
  CFileIo::GetMemReq(pAlignment, pcbPrefix, pcbSuffix);
  ASSERT(*pcbPrefix == 0 && *pcbSuffix == 0);
  m_cbAlign = *pAlignment;

  if(m_cbBuffer % m_cbAlign != 0)
    m_cbBuffer += m_cbAlign - m_cbBuffer % m_cbAlign;

  *pAlignment = 1;
}

HRESULT CImperfectBufIo::SetMaxPendingRequests(ULONG cRequests)
{
  return CFileIo::SetMaxPendingRequests(m_cBuffers);
}

HRESULT CImperfectBufIo::GetBuffer()
{
  HRESULT hr = m_pAllocator->GetBuffer(&m_pSample, 0, 0, 0);
  ASSERT(SUCCEEDED(hr));

  m_ibBuffer = 0;
  return S_OK;
}

HRESULT CImperfectBufIo::FlushBuffer()
{
  BYTE *pb;
  HRESULT hr = m_pSample->GetPointer(&pb);
  ASSERT(SUCCEEDED(hr));

  ULONG cbWrite = m_ibBuffer;
  if(cbWrite % m_cbAlign != 0)
    cbWrite += m_cbAlign - cbWrite % m_cbAlign;

  ASSERT(cbWrite <= m_cbBuffer);

  DbgLog(( LOG_TRACE, 2, NAME("CImperfectBufIo::FlushBuffer: Flushing.")));
  hr = CFileIo::StreamingWrite(pb, cbWrite, SampleCallback, m_pSample);
  m_pSample = 0;
  m_ibFile += m_ibBuffer;
  m_ibBuffer = 0;
  return hr;
}

void CImperfectBufIo::SampleCallback(void *pMisc)
{
  IMediaSample *pSample = (IMediaSample*)pMisc;
  pSample->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\writer\bufio.h ===
// Copyright (c) 1996  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// Asynchronous, buffered file writer using fileio class
//


#ifndef _Bufio_H
#define _Bufio_H

#include "aviutil.h"
#include "fileio.h"

class CImperfectBufIo : public CFileIo
{
public:

  CImperfectBufIo(TCHAR *szName, ULONG cbBuffer, ULONG cBuffers, HRESULT *phr);
  ~CImperfectBufIo();

  virtual HRESULT Create();
  virtual HRESULT Close();

  virtual HRESULT StreamingStart(ULONGLONG ibFile);
  virtual HRESULT StreamingEnd();
  virtual HRESULT StreamingGetFilePointer(ULONGLONG *pibFile);
  virtual HRESULT StreamingSeek(ULONG cbSeek);
  virtual HRESULT StreamingWrite(
    BYTE *pbData,
    ULONG cbData,
    FileIoCallback fnCallback,
    void *pMisc);

  virtual void GetMemReq(ULONG* pAlignment, ULONG *pcbPrefix, ULONG *pcbSuffix);
  virtual HRESULT SetMaxPendingRequests(ULONG cRequests);

private:

  HRESULT FlushBuffer();
  HRESULT GetBuffer();

  static void SampleCallback(void *pMisc);

  ULONG m_cbAlign;
  ULONG m_cbBuffer, m_cBuffers;
  IMemAllocator *m_pAllocator;

  ULONGLONG m_ibFile;           // current streaming file position
  ULONG m_ibBuffer;

  IMediaSample *m_pSample;
};

#endif // _Bufio_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\writer\fio.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

// Asynchronous, unbuffered file writer using completion ports and a
// separate writer thread
//


#ifndef _FileIo_H
#define _FileIo_H

extern const AMOVIESETUP_FILTER sudFileWriter ;


#include <windows.h>            // for win32 functions, types
#include "fw.h"
#include "aviutil.h"

// This structure is passed in for a write. The misc pointer is for a
// container object which needs to be Released() when the write is
// complete. dwSize field may be overwritten.
//
struct WriteRequest : OVERLAPPED
{
  void SetPos(DWORDLONG dwlPos)
    {
      Offset = (DWORD)(dwlPos & 0xffffffff), OffsetHigh = (DWORD)(dwlPos >> 32);
    }

  DWORD dwSize;
  BYTE *pb;
  void *pMisc;
  FileIoCallback fnCallback;
};

class CFileIo;

class CFileWriterFilter :
  public CBaseWriterFilter,
  public CPersistStream,
  public IFileSinkFilter2
{
public:
  CFileWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr);
  ~CFileWriterFilter();
  
  HRESULT Open();               // needed to get alignment
  HRESULT Close();              // needed to return error value
  HRESULT GetAlignReq(ULONG *pcbAlign);

  HRESULT AsyncWrite(
    const DWORDLONG dwlFileOffset,
    const ULONG cb,
    BYTE *pb,
    FileIoCallback fnCallback,
    void *pCallbackArg);

  STDMETHODIMP NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly);  

  HRESULT CreateFileObject();

  static CUnknown *CreateInstance(LPUNKNOWN punk, HRESULT *pHr);

  DECLARE_IUNKNOWN;  
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // Return IStream
  STDMETHODIMP CreateIStream(void **ppStream);

    //
  // Implements the IFileSinkFilter interface
  //
  STDMETHODIMP SetFileName(
    LPCOLESTR pszFileName,
    const AM_MEDIA_TYPE *pmt);

  STDMETHODIMP SetMode(
    DWORD dwFlags);

  STDMETHODIMP GetCurFile(
    LPOLESTR * ppszFileName,
    AM_MEDIA_TYPE *pmt);

  STDMETHODIMP GetMode(
    DWORD *pdwFlags);

  STDMETHODIMP CanPause();

private:

  // CPersistStream
  HRESULT WriteToStream(IStream *pStream);
  HRESULT ReadFromStream(IStream *pStream);
  int SizeMax();
  STDMETHODIMP GetClassID(CLSID *pClsid);
    

  CFileIo *m_pFileIo;

  BOOL m_fBufferedIo;
  OLECHAR *m_wszFileName;
  DWORD m_dwOpenFlags;
};

class CFileIo :
  public CAMThread
{
public:

  CFileIo(WCHAR *wszName, BOOL fBuffered, BOOL fOpenExisting, HRESULT *phr);
  virtual ~CFileIo();

  HRESULT Open();
  virtual HRESULT DoCreateFile();
  HRESULT Close();
  HRESULT GetAlignReq(ULONG *pcbAlign);

  HRESULT AsyncWrite(
    const DWORDLONG dwlFileOffset,
    const ULONG cb,
    BYTE *pb,
    FileIoCallback fnCallback,
    void *pCallbackArg);

protected:

  virtual HRESULT QueueAsyncWrite(
    WriteRequest *pReq);

  virtual HRESULT GetCompletedWrite(
    DWORD *pdwcbTransferred,
    DWORD_PTR *pdwCompletionKey,
    WriteRequest **ppReq);

  // this is used to unblock the worker if it is blocked and there is
  // no pending write to unblock it.
  virtual HRESULT PostCompletedMsg(DWORD_PTR dwKey);

protected:

  void Cleanup();
  BOOL GetRoot(TCHAR szDest_[MAX_PATH], TCHAR *const szSrc_);
  HRESULT SetFilename(WCHAR* wszName);

  ULONG m_cbSector;
  TCHAR m_szName[MAX_PATH];

  HANDLE m_hFileFast;           /* unbuffered, possibly asynchronous */
  HANDLE m_hCPort;

  // thread commands
  HRESULT StopWorker();

  // thread
  DWORD ThreadProc();
  
  CQueue<WriteRequest *> m_qWriteReq;
  long m_ilcActive;
  HRESULT m_hrError;
  WriteRequest *m_rgWriteReq;

  BOOL m_fBuffered;
  BOOL m_fOpenExisting;

  volatile BOOL m_fStopping;

  enum Command
  {
    CMD_EXIT
  };
  
  void CallCallback(WriteRequest *pReq);

#ifdef PERF
  int m_idPerfWrite;
#endif PERF
};

// uses synchronous i/o with a separate thread to queue writes
class CSyncFileIo :
  public CFileIo
{
public:
  CSyncFileIo(WCHAR *wszName, BOOL fBuffered, BOOL fOpenExisting, HRESULT *phr);
  HRESULT DoCreateFile();  

  HRESULT QueueAsyncWrite(
    WriteRequest *pReq);

  HRESULT GetCompletedWrite(
    DWORD *pdwcbTransferred,
    DWORD_PTR *pdwCompletionKey,
    WriteRequest **ppReq);

  HRESULT PostCompletedMsg(DWORD_PTR dwKey);

private:
  CQueue<WriteRequest *> m_qPendingWrites;  
};

class CFwIStream :
  public IStream,
  public CUnknown
{
public:
  CFwIStream(WCHAR *wszName, TCHAR *pName, LPUNKNOWN lpUnk, bool fTruncate, HRESULT *phr);
    
  ~CFwIStream();

  // IStream interfaces
  DECLARE_IUNKNOWN
  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);

  STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);

  STDMETHODIMP CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten);

  STDMETHODIMP Commit(DWORD grfCommitFlags);
  STDMETHODIMP Revert();

  STDMETHODIMP LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType);

  STDMETHODIMP UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType);

  STDMETHODIMP Clone(IStream **ppstm);

  STDMETHODIMP Write(CONST VOID *pv, ULONG cb, PULONG pcbWritten);
  STDMETHODIMP Read(void * pv, ULONG cb, PULONG pcbRead);
  STDMETHODIMP Seek(
    LARGE_INTEGER dlibMove, DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition);
  STDMETHODIMP Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag);

private:

  HANDLE m_hFileSlow;           /* synchronous buffered */
  CCritSec m_cs;
  bool m_fTruncate;
  TCHAR *m_szFilename;
};


#endif // _FileIo_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\writer\fio.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#pragma warning(disable: 4097 4511 4512 4514 4705)

#include <streams.h>
#include "fio.h"

// number of WriteRequest structures allocated. limits the number of
// simultaneous writes possible. should this be configurable? 
static const C_WRITE_REQS = 32; // number duplicated in mux

// calls to these methods must be serialized by the caller.

// Completion events and new requests come to the completion port; the
// key field is used to distinguish them
//
enum Keys
{
  CKEY_WRITE,
  CKEY_EOS,
  CKEY_EXIT
};

CFileWriterFilter::CFileWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr) :
    CBaseWriterFilter(pUnk, pHr),
    m_pFileIo(0),
    m_fBufferedIo(FALSE),
    m_dwOpenFlags(0),
    m_wszFileName(0),
    CPersistStream(pUnk, pHr)
{
}

CFileWriterFilter::~CFileWriterFilter()
{
  delete[] m_wszFileName;
  delete m_pFileIo;
}

HRESULT CFileWriterFilter::Open()
{
  // we refuse to pause otherwise
  ASSERT(m_pFileIo);
  
  return m_pFileIo->Open();
}

HRESULT CFileWriterFilter::Close()
{
  if(m_pFileIo)
    return m_pFileIo->Close();
  else
    return S_OK;
}

HRESULT CFileWriterFilter::GetAlignReq(ULONG *pcbAlign)
{
  if(m_pFileIo)
  {
    return m_pFileIo->GetAlignReq(pcbAlign);
  }
  else
  {
    // will reconnect when file name set
    *pcbAlign = 1;
    return S_OK;
  }
}

HRESULT CFileWriterFilter::AsyncWrite(
  const DWORDLONG dwlFileOffset,
  const ULONG cb,
  BYTE *pb,
  FileIoCallback fnCallback,
  void *pCallbackArg)
{
  return m_pFileIo->AsyncWrite(dwlFileOffset, cb, pb, fnCallback, pCallbackArg);
}

HRESULT CFileWriterFilter::CreateFileObject()
{
  if(m_wszFileName == 0) {
    return S_OK;
  }
  
  delete m_pFileIo;
  
  OSVERSIONINFO osvi;
  osvi.dwOSVersionInfoSize = sizeof(osvi);

  BOOL f = GetVersionEx(&osvi);
  ASSERT(f);

  // really should check whether CreateIoCompletionPort succeeds. to
  // do that, i need to make one class which does both modes, and let
  // it decide on the stop->pause transition. !!!

  BOOL fOpenExisting = !(m_dwOpenFlags & AM_FILE_OVERWRITE);
  
  HRESULT hr = S_OK;
  if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
  {
//     DbgBreak("not using overlapped io");
//     m_pFile = new CSyncFileIo(m_wszFileName, FALSE, &hr);
    m_pFileIo = new CFileIo(m_wszFileName, m_fBufferedIo, fOpenExisting, &hr);
  }
  else
  {
    m_pFileIo = new CSyncFileIo(m_wszFileName, m_fBufferedIo, fOpenExisting, &hr);
  }
  if(m_pFileIo == 0)
    return E_OUTOFMEMORY;
  if(FAILED(hr))
  {
    delete m_pFileIo;
    m_pFileIo = 0;
    return hr;
  }

  return S_OK;
}

STDMETHODIMP
CFileWriterFilter::NotifyAllocator(
  IMemAllocator * pAllocator,
  BOOL bReadOnly)
{
  // we will go through this again when we do set a file because we
  // force a reconnect which calls NotifyAllocator
  if(!m_pFileIo)
    return S_OK;

  ULONG cbAlignFile;
  HRESULT hr = m_pFileIo->GetAlignReq(&cbAlignFile);
  if(SUCCEEDED(hr))
  {
    ALLOCATOR_PROPERTIES apUpstream;
    hr = pAllocator->GetProperties(&apUpstream);

    if(SUCCEEDED(hr) && apUpstream.cbAlign >= (LONG)cbAlignFile)
    {
      DbgLog((LOG_TRACE, 2,
              TEXT("CBaseWriterInput::NotifyAllocator: unbuffered io")));
      m_fBufferedIo = FALSE;
      return S_OK;
    }
  }

  DbgLog((LOG_TRACE, 2,
          TEXT("CBaseWriterInput::NotifyAllocator: buffered io")));
  m_fBufferedIo = TRUE;

  return CreateFileObject();
}

// ------------------------------------------------------------------------
// IFileSinkFilter

STDMETHODIMP CFileWriterFilter::SetFileName(
  LPCOLESTR wszFileName,
  const AM_MEDIA_TYPE *pmt)
{
  CheckPointer(wszFileName, E_POINTER);
  CAutoLock lock(&m_cs);

  if(m_State != State_Stopped)
    return VFW_E_WRONG_STATE;

  if(pmt && m_inputPin.IsConnected() && (
      m_mtSet.majortype != pmt->majortype ||
      m_mtSet.subtype != pmt->subtype))
  {
      return E_FAIL;
  }

  delete[] m_wszFileName;
  m_wszFileName = 0;

  long cLetters = lstrlenW(wszFileName);
//   if(cLetters > MAX_PATH)
//     return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);

  m_wszFileName = new WCHAR[cLetters + 1];
  if(m_wszFileName == 0)
    return E_OUTOFMEMORY;

  lstrcpyW(m_wszFileName, wszFileName);

  if(pmt)
  {
    m_mtSet.majortype = pmt->majortype;
    m_mtSet.subtype = pmt->subtype;
  }
  else
  {
    m_mtSet.majortype = MEDIATYPE_Stream;
    m_mtSet.subtype = GUID_NULL;
  }

  HRESULT hr = CreateFileObject();
  if(FAILED(hr))
  {
    return hr;
  }

  // alignment requirement may have changed. reconnect.
  if(m_inputPin.IsConnected())
  {
    hr = m_pGraph->Reconnect(&m_inputPin);
    if(FAILED(hr))
      return hr;
  }

  return S_OK;
}

STDMETHODIMP CFileWriterFilter::SetMode(
    DWORD dwFlags)
{
    // refuse flags we don't know 
    if(dwFlags & ~AM_FILE_OVERWRITE)
    {
        return E_INVALIDARG;
    }
    
    CAutoLock lock(&m_cs);

    HRESULT hr = S_OK;

    if(m_State == State_Stopped)
    {
        m_dwOpenFlags = dwFlags;
        SetDirty(TRUE);
        hr = CreateFileObject();
    }
    else
    {
        hr = VFW_E_WRONG_STATE;
    }

    return hr;
}

STDMETHODIMP CFileWriterFilter::GetCurFile(
  LPOLESTR * ppszFileName,
  AM_MEDIA_TYPE *pmt)
{
  CheckPointer(ppszFileName, E_POINTER);

  *ppszFileName = NULL;
  if(m_wszFileName!=NULL)
  {
    *ppszFileName = (LPOLESTR)
      QzTaskMemAlloc(sizeof(WCHAR) * (1+lstrlenW(m_wszFileName)));
    if (*ppszFileName != NULL)
      lstrcpyW(*ppszFileName, m_wszFileName);
    else
      return E_OUTOFMEMORY;
  }

  if(pmt)
  {
    pmt->majortype = m_mtSet.majortype;
    pmt->subtype = m_mtSet.subtype;
  }

  return S_OK;
}

STDMETHODIMP CFileWriterFilter::GetMode(
    DWORD *pdwFlags)
{
    CheckPointer(pdwFlags, E_POINTER);
    *pdwFlags = m_dwOpenFlags;
    return S_OK;
}


STDMETHODIMP CFileWriterFilter::CanPause()
{
  if(m_pFileIo == 0)
  {
    ASSERT(m_State == State_Stopped);
    return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
  }
  else
  {
    return S_OK;
  }
}

struct FwPersist
{
    DWORD dwSize;
    DWORD dwFlags;
};

HRESULT CFileWriterFilter::WriteToStream(IStream *pStream)
{
    FwPersist fp;
    fp.dwSize = sizeof(fp);
    fp.dwFlags = m_dwOpenFlags;
    
    return pStream->Write(&fp, sizeof(fp), 0);
}

HRESULT CFileWriterFilter::ReadFromStream(IStream *pStream)
{
   FwPersist fp;
   HRESULT hr = pStream->Read(&fp, sizeof(fp), 0);
   if(FAILED(hr)) {
       return hr;
   }

   if(fp.dwSize != sizeof(fp)) {
       return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
   }

   m_dwOpenFlags = fp.dwFlags;

   return CreateFileObject();
}

int CFileWriterFilter::SizeMax()
{
    return sizeof(FwPersist);
}

STDMETHODIMP CFileWriterFilter::GetClassID(CLSID *pClsid)
{
    CheckPointer(pClsid, E_POINTER);
    *pClsid = m_clsid;
    return S_OK;  
}


STDMETHODIMP CFileWriterFilter::NonDelegatingQueryInterface(
  REFIID riid, void ** ppv)
{
  if(riid == IID_IFileSinkFilter2)
  {
    return GetInterface((IFileSinkFilter2 *) this, ppv);
  }
  if(riid == IID_IFileSinkFilter)
  {
    return GetInterface((IFileSinkFilter *) this, ppv);
  }
  if(riid == IID_IPersistStream)
  {
    return GetInterface((IPersistStream *) this, ppv);
  }
  
  return CBaseWriterFilter::NonDelegatingQueryInterface(riid, ppv);
}

STDMETHODIMP
CFileWriterFilter::CreateIStream(void **ppStream)
{
  // you get a new one with its own state each time
  HRESULT hr = S_OK;
  CFwIStream *pIStream = new CFwIStream(
    m_wszFileName,
    NAME("file writer istream"),
    0,
    m_dwOpenFlags & AM_FILE_OVERWRITE,
    &hr);
  if(pIStream == 0)
    return E_OUTOFMEMORY;
  if(FAILED(hr))
  {
    delete pIStream;
    return hr;
  }
  return GetInterface((IStream *)pIStream, ppStream);
}


// ------------------------------------------------------------------------
// constructor

CFileIo::CFileIo(
    WCHAR *wszName,
    BOOL fBuffered,
    BOOL fOpenExisting,
    HRESULT *phr) :
        m_qWriteReq(C_WRITE_REQS),
        m_fOpenExisting(fOpenExisting),
        m_fBuffered(fBuffered)
{
  m_rgWriteReq = 0;
  Cleanup();
  m_cbSector = 0;
  m_ilcActive = 0;
  m_szName[0] = 0;
  m_hrError = S_OK;

#ifdef PERF
  m_idPerfWrite = Msr_Register(TEXT("cfileio: write queued/completed"));
#endif // PERF
  
  if(FAILED(*phr))
    return;

  m_rgWriteReq = new WriteRequest[C_WRITE_REQS];
  if(m_rgWriteReq == 0)
  {
    *phr = E_OUTOFMEMORY;
    return;
  }
  for(int i = 0; i < C_WRITE_REQS; i++)
    m_qWriteReq.PutQueueObject(&m_rgWriteReq[i]);
    

  *phr = SetFilename(wszName);
  return;
  
}

void CFileIo::Cleanup()
{
  m_hFileFast = INVALID_HANDLE_VALUE;
  m_hCPort = 0;
  m_fStopping = FALSE;
}

CFileIo::~CFileIo()
{
  ASSERT(m_hFileFast == INVALID_HANDLE_VALUE);
  ASSERT(m_hCPort == 0);
  Cleanup();
  delete[] m_rgWriteReq;
}

// ------------------------------------------------------------------------
// get filesystem's sector size from filename

HRESULT CFileIo::SetFilename(WCHAR *wszName)
{
  if(lstrlenW(wszName) > MAX_PATH)
    return HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE);

  DWORD dwFreeClusters, dwBytesPerSector, dwSectorsPerCluster, dwClusters;

  TCHAR szName[MAX_PATH];
  
# if defined(WIN32) && !defined(UNICODE)
  {
    if(!WideCharToMultiByte(CP_ACP, 0, wszName, -1, szName, MAX_PATH, 0, 0))
      return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
  }
# else
  {
    lstrcpyW(szName, wszName);
  }
# endif
  
  TCHAR root[MAX_PATH];
  BOOL b = GetRoot(root, szName);
  if(b)
  {
      b = GetDiskFreeSpace(
          root,
          &dwSectorsPerCluster,
          &dwBytesPerSector,
          &dwFreeClusters,
          &dwClusters);
  }

  // GetDiskFreeSpace doesn't work on Win95 to a network
  m_cbSector = b ? dwBytesPerSector : 1;

  lstrcpy(m_szName, szName);

  return S_OK;
}

// ------------------------------------------------------------------------
// create / open the file, create completion port, create writer
// thread

HRESULT CFileIo::Open()
{
  ASSERT(m_hFileFast == INVALID_HANDLE_VALUE);
  ASSERT(m_hCPort == 0);
  m_fStopping = FALSE;
  m_hrError = S_OK;

  // must have been given a filename.
  ASSERT(m_cbSector != 0);

  HRESULT hr = DoCreateFile();
  if(FAILED(hr))
    return hr;

  // create worker thread
  if(!this->Create())
  {
    DbgBreak("fio: couldn't create worker thread");
    Close();
    return E_UNEXPECTED;
  }

  return S_OK;
}

HRESULT CFileIo::DoCreateFile()
{
  const DWORD dwfBuffering = m_fBuffered ? 0 : FILE_FLAG_NO_BUFFERING;
  const DWORD dwCreationDistribution =
      m_fOpenExisting ? OPEN_ALWAYS : CREATE_ALWAYS;

  DbgLog((LOG_TRACE, 5, TEXT("CFileIo: opening file. buffering: %d"),
          m_fBuffered ));

  m_hFileFast = CreateFile(
    m_szName,                   // lpFileName
    GENERIC_WRITE,              // dwDesiredAccess
    FILE_SHARE_WRITE | FILE_SHARE_READ, // dwShareMode
    0,                          // lpSecurityAttribytes
    dwCreationDistribution,
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | dwfBuffering,
    0);

  if(m_hFileFast == INVALID_HANDLE_VALUE)
  {
    DWORD dwLastError = GetLastError();
    DbgLog(( LOG_TRACE, 2,
             NAME("CFileIo::CreateFile: CreateFile overlapped failed. %i"),
             dwLastError));

    Close();
    return AmHresultFromWin32(dwLastError);
  }

  m_hCPort = CreateIoCompletionPort(
    m_hFileFast,                // file handle
    0,                          // existing completion port
    CKEY_WRITE,                 // completion key
    0);                         // # concurrent threads

  if(m_hCPort == 0)
  {
    DWORD dwLastError = GetLastError();
    Close();
    DbgLog(( LOG_TRACE, 2,
             NAME("CFileIo::CreateFile: CreateIoCompletionPort failed. %i"),
             dwLastError));
    return AmHresultFromWin32(dwLastError);
  }

  return S_OK;
}


HRESULT CFileIo::Close()
{
  DbgLog((LOG_TRACE, 5, TEXT("CFileIo: closing file")));

  HRESULT hr = S_OK;
  DWORD dwLastError = 0;

  m_fStopping = TRUE;

  StopWorker();
  if(m_hCPort != 0)
  {
    CloseHandle(m_hCPort);
  }
  m_hCPort = 0;

  if(m_hFileFast != INVALID_HANDLE_VALUE)
    if(!CloseHandle(m_hFileFast))
      dwLastError = GetLastError(), hr = AmHresultFromWin32(dwLastError);
  m_hFileFast = INVALID_HANDLE_VALUE;

  return hr == S_OK ? m_hrError : hr;
}

HRESULT CFileIo::StopWorker()
{
  if(!ThreadExists())
    return S_OK;
  
  HRESULT hr = PostCompletedMsg(CKEY_EXIT);
  if(FAILED(hr))
  {
    DbgBreak("PostQueuedCompletionStatus failed");
    return E_UNEXPECTED;
  }
  hr = CallWorker(CMD_EXIT);
  ASSERT(hr == S_OK);
  CAMThread::Close();
  ASSERT(m_hThread == 0);
  return S_OK;
}

HRESULT CFileIo::GetAlignReq(ULONG *pcbAlign)
{
  ASSERT(m_szName[0] != 0);

  *pcbAlign = m_cbSector;
  
  return S_OK;
}

HRESULT CFileIo::AsyncWrite(
  const DWORDLONG dwlFileOffset,
  const ULONG cb,
  BYTE *pb,
  FileIoCallback fnCallback,
  void *pCallbackArg)
{
  // relies on filter cs
  if(!m_fBuffered)
  {
    ASSERT(dwlFileOffset % m_cbSector == 0);
    DbgAssertAligned(pb, m_cbSector );
    ASSERT(cb % m_cbSector == 0);
  }

  if(m_hrError != S_OK)
    return m_hrError;

  // we're flushing
  if(m_fStopping)
  {
    DbgLog((LOG_TRACE, 10, TEXT("Write while flushing.")));
    return S_FALSE;
  }

  WriteRequest *pReq = m_qWriteReq.GetQueueObject();
  pReq->hEvent = 0;
  pReq->SetPos(dwlFileOffset);
  pReq->fnCallback = fnCallback;
  pReq->dwSize = cb;
  pReq->pb = pb;
  pReq->pMisc = pCallbackArg;

  long sign = InterlockedIncrement(&m_ilcActive);
  ASSERT(sign > 0);

  MSR_INTEGER(m_idPerfWrite, (long)pReq->Offset);

  HRESULT hr = QueueAsyncWrite(pReq);
  if(FAILED(hr))
  {
    DbgLog((LOG_ERROR, 5, TEXT("CFileIo: QueueAsyncWrite failed: %08x"), hr));
    long sign = InterlockedDecrement(&m_ilcActive);
    ASSERT(sign >= 0);
    m_hrError = hr;
    return hr;
  }
  else
  {
    DbgLog((LOG_TRACE, 10, TEXT("CFileIo: queued 0x%08x offset=%08x%08x"),
            pReq, (DWORD)(dwlFileOffset >> 32), (dwlFileOffset & 0xffffffff)));
    return S_OK;
  }
}

HRESULT CFileIo::QueueAsyncWrite(
  WriteRequest *pReq)
{
  BOOL fWrite = WriteFile(m_hFileFast, pReq->pb, pReq->dwSize, 0, pReq);
  if(!fWrite)
  {
    DWORD dwError = GetLastError();
    if(dwError == ERROR_IO_PENDING)
      return S_OK;
    return AmHresultFromWin32(dwError);
  }
  return S_OK;
}

HRESULT CFileIo::GetCompletedWrite(
  DWORD *pdwcbTransferred,
  DWORD_PTR *pdwCompletionKey,
  WriteRequest **ppReq)
{
  BOOL fResult = GetQueuedCompletionStatus(
    m_hCPort,
    pdwcbTransferred,
    pdwCompletionKey,
   (OVERLAPPED **)ppReq,
    INFINITE);

  if(!fResult)
  {
    DbgBreak("GetQueuedCompletionStatus failed");
    DWORD dwRes = GetLastError();
    return AmHresultFromWin32(dwRes);
  }

  if(*ppReq && (*ppReq)->dwSize != *pdwcbTransferred)
  {
    DbgBreak("Incomplete write");
    return HRESULT_FROM_WIN32(ERROR_DISK_FULL);
  }
  
  return S_OK;
}

HRESULT CFileIo::PostCompletedMsg(DWORD_PTR dwKey)
{
  ASSERT(dwKey != CKEY_WRITE);
  BOOL f = PostQueuedCompletionStatus(
    m_hCPort,
    0,
    dwKey,
    0);
  if(!f)
  {
    DWORD dwRes = GetLastError();
    return AmHresultFromWin32(dwRes);
  }
  return S_OK;
}

// ------------------------------------------------------------------------
// return the "root" of a full path. doesn't handle all cases
//

BOOL CFileIo::GetRoot(
  TCHAR szDest_[MAX_PATH],
  TCHAR *const szSrc_)
{
  LPTSTR ptmp;    //required arg

  // need to find path for root directory on drive containing
  // this file.

  LONG l = GetFullPathName(szSrc_, MAX_PATH, szDest_, &ptmp);
  if(l == 0 || l >= MAX_PATH) {
      return FALSE;
  }

  // truncate this to the name of the root directory
  if ((szDest_[0] == TEXT('\\')) && (szDest_[1] == TEXT('\\')))
  {

    // path begins with  \\server\share\path so skip the first
    // three backslashes
    ptmp = &szDest_[2];
    while (*ptmp && (*ptmp != TEXT('\\')))
    {
      ptmp++;
    }
    if (*ptmp)
    {
      // advance past the third backslash
      ptmp++;
    }
  } else {
    // path must be drv:\path
    ptmp = szDest_;
  }

  // find next backslash and put a null after it
  while (*ptmp && (*ptmp != TEXT('\\')))
  {
    ptmp++;
  }
  // found a backslash ?
  if (*ptmp)
  {
    // skip it and insert null
    ptmp++;
    *ptmp = (TCHAR)0;
  }

  return TRUE;
}

// ------------------------------------------------------------------------
// Thread work loop

DWORD CFileIo::ThreadProc()
{
  BOOL fStop = FALSE;
  for(;;)
  {
    WriteRequest *pReq;
    DWORD dwcbTransferred;
    DWORD_PTR dwCompletionKey;
    HRESULT hr = GetCompletedWrite(
      &dwcbTransferred,
      &dwCompletionKey,
      &pReq);

    if(FAILED(hr))
    {
      m_hrError = hr;
      DbgLog((LOG_ERROR, 5, TEXT("CFileIo: GetCompletedWrite failed")));
    }

    if(dwCompletionKey == CKEY_EXIT)
    {
      ASSERT(m_fStopping);
      
      if(pReq)
        CallCallback(pReq);
      
      fStop = TRUE;
      DbgLog((LOG_TRACE, 10, ("CFileIo: stop requested %08x"),
              pReq));
    }
    else
    {
      ASSERT(dwCompletionKey == CKEY_WRITE);

      CallCallback(pReq);

      MSR_INTEGER(m_idPerfWrite, -(long)pReq->Offset);      
    
      long sign = InterlockedDecrement(&m_ilcActive);
      ASSERT(sign >= 0);
      DbgLog((LOG_TRACE, 15, ("CFileIo: completed write %08x. %d active"),
              pReq, m_ilcActive));
    }

    if(fStop && m_ilcActive == 0)
      break;
  }

  ULONG com = GetRequest();
  ASSERT(com == CMD_EXIT);
  
  Reply(NOERROR);
  return 0;                     // ?
}

void CFileIo::CallCallback(WriteRequest *pReq)
{
  void *pMisc = pReq->pMisc;
  FileIoCallback fnCallback = pReq->fnCallback;
  m_qWriteReq.PutQueueObject(pReq);
  if(fnCallback)
    fnCallback(pMisc);
}

// ------------------------------------------------------------------------
// CSyncFileIo

CSyncFileIo::CSyncFileIo(
    WCHAR *wszName,
    BOOL fBuffered,
    BOOL fOpenExisting,
    HRESULT *phr) :
        CFileIo(wszName, fBuffered, fOpenExisting, phr),
        m_qPendingWrites(C_WRITE_REQS)
{
}

HRESULT CSyncFileIo::DoCreateFile()
{
  const DWORD dwfBuffering = m_fBuffered ? 0 : FILE_FLAG_NO_BUFFERING;
  const DWORD dwCreationDistribution =
      m_fOpenExisting ? OPEN_ALWAYS : CREATE_ALWAYS;

  m_hFileFast = CreateFile(
    m_szName,                   // lpFileName
    GENERIC_WRITE,              // dwDesiredAccess
    FILE_SHARE_WRITE | FILE_SHARE_READ, // dwShareMode
    0,                          // lpSecurityAttribytes
    dwCreationDistribution,
    FILE_ATTRIBUTE_NORMAL | dwfBuffering,
    0);

  if(m_hFileFast == INVALID_HANDLE_VALUE)
  {
    DWORD dwLastError = GetLastError();
    DbgLog(( LOG_TRACE, 2,
             NAME("CSyncFileIo::CreateFile: CreateFile failed. %i"),
             dwLastError));

    Close();
    return AmHresultFromWin32(dwLastError);
  }

  DbgLog((LOG_TRACE, 5, TEXT("CFileIo: opened file. buffering: %d"),
          dwfBuffering ? 1 : 0));

  
  return S_OK;
}

HRESULT CSyncFileIo::QueueAsyncWrite(
  WriteRequest *pReq)
{
  pReq->Internal = CKEY_WRITE;
  m_qPendingWrites.PutQueueObject(pReq);
  return S_OK;
}

HRESULT CSyncFileIo::GetCompletedWrite(
  DWORD *pdwcbTransferred,
  DWORD_PTR *pdwCompletionKey,
  WriteRequest **ppReq)
{
  HRESULT hr = S_OK;
  WriteRequest *pReq = m_qPendingWrites.GetQueueObject();
  *pdwCompletionKey = pReq->Internal;
  *ppReq = pReq;
  if(pReq->Internal == CKEY_WRITE)
  {
    *pdwcbTransferred = 0;
    LONG HighPart = pReq->OffsetHigh;
    DWORD dwResult = SetFilePointer(
      m_hFileFast,
      pReq->Offset,
      &HighPart,
      FILE_BEGIN);
    if(dwResult == 0xffffffff)
    {
      DWORD dwLastError = GetLastError();
      if(dwLastError != 0)
      {
        DbgLog(( LOG_ERROR, 2,
                 NAME("CSyncFileIo::Seek: SetFilePointer failed.")));
        hr =  AmHresultFromWin32(dwLastError);
      }
    }
    if(hr == S_OK)
    {
      DWORD cbWritten;
      BOOL fResult = WriteFile(
        m_hFileFast, pReq->pb, pReq->dwSize, &cbWritten, 0);
      if(!fResult)
      {
        DbgLog(( LOG_ERROR, 2,
                 NAME("CSyncFileIo:: WriteFile failed.")));
        DWORD dwLastError = GetLastError();
        hr = AmHresultFromWin32(dwLastError);
      }
      else
      {
        *pdwcbTransferred = cbWritten;
        if(cbWritten != pReq->dwSize)
        {
          DbgBreak("Incomplete write");
          hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
        }
      }
    }
  }
  else
  {
    DbgLog((LOG_TRACE, 10, TEXT("CSyncFileIo:GetCompletedWrite: CKEY_EXIT")));
    ASSERT(pReq->Internal == CKEY_EXIT);
  }

  return hr;
}

HRESULT CSyncFileIo::PostCompletedMsg(DWORD_PTR dwKey)
{
  WriteRequest *pReq = m_qWriteReq.GetQueueObject();
  ASSERT(dwKey != CKEY_WRITE);
  pReq->Internal = dwKey;
  pReq->fnCallback = 0;
  m_qPendingWrites.PutQueueObject(pReq);  
  return S_OK;
}

 
// ------------------------------------------------------------------------
// IStream

CFwIStream::CFwIStream(
  WCHAR *wszName,
  TCHAR *pName,
  LPUNKNOWN lpUnk,
  bool fTruncate,
  HRESULT *phr) :
    CUnknown(pName, lpUnk),
    m_hFileSlow(INVALID_HANDLE_VALUE),
    m_fTruncate(fTruncate),
    m_szFilename(0)
{
  DbgLog((LOG_TRACE, 15, TEXT("CFwIStream::CFwIStream")));
  if(FAILED(*phr))
    return;
  
  TCHAR szName[MAX_PATH];
  
# if defined(WIN32) && !defined(UNICODE)
  {
    if(!WideCharToMultiByte(CP_ACP, 0, wszName, -1, szName, MAX_PATH, 0, 0))
    {
      *phr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
      return;
    }
  }
# else
  {
    lstrcpyW(szName, wszName);
  }
# endif

  int cch = lstrlen(szName) + 1;
  m_szFilename = new TCHAR[cch];
  if(!m_szFilename) {
      *phr = E_OUTOFMEMORY;
      return;
  }
  CopyMemory(m_szFilename, szName, cch * sizeof(TCHAR));
  
  m_hFileSlow = CreateFile(
    szName,                     // lpFileName
    GENERIC_WRITE | GENERIC_READ, // dwDesiredAccess
    FILE_SHARE_WRITE | FILE_SHARE_READ, // dwShareMode
    0,                          // lpSecurityAttribytes
    OPEN_ALWAYS,                // dwCreationDistribution
    FILE_ATTRIBUTE_NORMAL,
    0);

  if(m_hFileSlow == INVALID_HANDLE_VALUE)
  {
    DWORD dwLastError = GetLastError();
    DbgLog(( LOG_ERROR, 2,
             NAME("CFwIStream:: CreateFile m_hFileSlow failed. %i"),
             dwLastError));
    *phr = AmHresultFromWin32(dwLastError);
  }

  return;
}

STDMETHODIMP CFwIStream::NonDelegatingQueryInterface(REFIID riid, void ** pv)
{
  if (riid == IID_IStream) {
    return GetInterface((IStream *)this, pv);
  } else {
    return CUnknown::NonDelegatingQueryInterface(riid, pv);
  }
}


CFwIStream::~CFwIStream()
{
  DbgLog((LOG_TRACE, 15, TEXT("CFwIStream::~CFwIStream")));
  if(m_hFileSlow != INVALID_HANDLE_VALUE)
  {
      DWORD dwh, dwl = GetFileSize(m_hFileSlow, &dwh);
      CloseHandle(m_hFileSlow);

      // check for zero byte file (w/ error check)
      if((dwl | dwh) == 0) {
          DeleteFile(m_szFilename);
      }
  }
  delete[] m_szFilename;
}

STDMETHODIMP CFwIStream::SetSize(ULARGE_INTEGER libNewSize)
{
  // don't set size to zero if trying to preserve preallocated file
  if(!m_fTruncate && libNewSize.QuadPart == 0) {
      return S_OK;
  }
  
  // needs serialization since we change the file pointer
  CAutoLock l(&m_cs);

  HRESULT hr = S_OK;

  // SetSize() should preserve the file pointer.
  LARGE_INTEGER liOldPos;
  liOldPos.QuadPart = 0;
  liOldPos.LowPart = SetFilePointer(
      m_hFileSlow,
      liOldPos.LowPart,
      &liOldPos.HighPart,
      FILE_CURRENT);
  if(liOldPos.LowPart == 0xffffffff)
  {
      DWORD dwResult = GetLastError();
      if(dwResult != NO_ERROR)
      {
          DbgLog(( LOG_ERROR, 0,
                   TEXT("CFwIStream::SetSize: SetFilePointer failed.")));
          hr = AmHresultFromWin32(dwResult);
      }
  }

  bool fResetFilePointer = false;
  
  if(SUCCEEDED(hr))
  {
      LONG HighPart = libNewSize.HighPart;
    
      DWORD dwResult= SetFilePointer(
          m_hFileSlow,
          libNewSize.LowPart,
          &HighPart,
          FILE_BEGIN);

      if(dwResult == 0xffffffff)
      {
          DWORD dwResult = GetLastError();
          if(dwResult != NO_ERROR)
          {
              DbgLog(( LOG_ERROR, 0,
                       TEXT("CFwIStream::SetSize: SetFilePointer failed.")));
              hr = AmHresultFromWin32(dwResult);
          }
      }

      fResetFilePointer = SUCCEEDED(hr);

      if(SUCCEEDED(hr))
      {

          BOOL f = SetEndOfFile(m_hFileSlow);
          if(f)
          {
              // succcess.
          }
          else
          {
              DWORD dwResult = GetLastError();
              hr = AmHresultFromWin32(dwResult);
          }
      }
  }

  if(fResetFilePointer)
  {
      LONG HighPart = liOldPos.HighPart;
    
      DWORD dwResult= SetFilePointer(
          m_hFileSlow,
          liOldPos.LowPart,
          &HighPart,
          FILE_BEGIN);

      if(dwResult == 0xffffffff)
      {
          DWORD dwResult = GetLastError();
          if(dwResult != NO_ERROR)
          {
              DbgLog(( LOG_ERROR, 0,
                       TEXT("CFwIStream::SetSize: SetFilePointer failed.")));
              hr = AmHresultFromWin32(dwResult);
          }
      }
  }

  return hr;
}

STDMETHODIMP CFwIStream::CopyTo(
  IStream *pstm, ULARGE_INTEGER cb,
  ULARGE_INTEGER *pcbRead,
  ULARGE_INTEGER *pcbWritten)
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::Commit(DWORD grfCommitFlags)
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::Revert()
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::LockRegion(
  ULARGE_INTEGER libOffset,
  ULARGE_INTEGER cb,
  DWORD dwLockType)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFwIStream::UnlockRegion(
  ULARGE_INTEGER libOffset,
  ULARGE_INTEGER cb,
  DWORD dwLockType)
{
  return E_NOTIMPL;
}
STDMETHODIMP CFwIStream::Clone(IStream **ppstm)
{
  return E_NOTIMPL;
}

STDMETHODIMP CFwIStream::Write(
  CONST VOID * pv, ULONG cb, PULONG pcbWritten)
{
  CAutoLock l(&m_cs);
  DWORD dwcbWritten;
  if(!WriteFile(
    m_hFileSlow,
    pv,
    cb,
    &dwcbWritten,
    0))
  {
    DbgLog(( LOG_ERROR, 2,
             NAME("CFwIStream::Write: WriteFile failed.")));

    if(pcbWritten)
      *pcbWritten = 0;
    
    DWORD dwResult = GetLastError();
    return AmHresultFromWin32(dwResult);
  }

  if(pcbWritten)
    *pcbWritten = dwcbWritten;

  if(dwcbWritten != cb)
  {
    // !!! need to test disk full scenario
    DbgBreak("disk full?");
    return HRESULT_FROM_WIN32(ERROR_DISK_FULL);
  }

  return S_OK;
}

STDMETHODIMP CFwIStream::Read(
  void * pv, ULONG cb, PULONG pcbRead)
{
  CAutoLock l(&m_cs);
  DWORD dwcbRead;
  if(!ReadFile(
    m_hFileSlow,
    (void *)pv,
    cb,
    &dwcbRead,
    0))
  {
    DbgLog(( LOG_ERROR, 2,
             NAME("CFileIo::SynchronousRead: ReadFile failed.")));
    DWORD dwResult = GetLastError();
    return AmHresultFromWin32(dwResult);
  }

  if(pcbRead)
    *pcbRead = dwcbRead;

  if(dwcbRead != cb)
  {
    DbgLog((LOG_ERROR, 5, ("CFwIStream: reading off the end")));
    return HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);
  }

  return S_OK;
}

STDMETHODIMP CFwIStream::Seek(
  LARGE_INTEGER dlibMove, DWORD dwOrigin,
  ULARGE_INTEGER *plibNewPosition)
{
  CAutoLock l(&m_cs);
  DWORD dwMoveMethod;
  switch(dwOrigin)
  {
    case STREAM_SEEK_SET:
      dwMoveMethod = FILE_BEGIN;
      break;
              
    case STREAM_SEEK_CUR:
      dwMoveMethod = FILE_CURRENT;
      break;
      
    case STREAM_SEEK_END:
      dwMoveMethod = FILE_END;
      break;

    default:
      DbgBreak("unexpected");
      return E_INVALIDARG;
  }

  LONG HighPart = dlibMove.HighPart;

  DWORD dwResult= SetFilePointer(
    m_hFileSlow,
    dlibMove.LowPart,
    &HighPart,
    dwMoveMethod);

  if(dwResult == 0xffffffff && GetLastError() != NO_ERROR)
  {
    DbgLog(( LOG_ERROR, 2,
             NAME("CFwIStream::Seek: SetFilePointer failed.")));
    DWORD dwResult = GetLastError();
    return AmHresultFromWin32(dwResult);
  }

  if(plibNewPosition)
  {
    plibNewPosition->LowPart = dwResult;
    plibNewPosition->HighPart = HighPart;
  }

  return S_OK;
}

STDMETHODIMP CFwIStream::Stat(
  STATSTG *pstatstg,
  DWORD grfStatFlag)
{
  return E_NOTIMPL;
}

// ------------------------------------------------------------------------
// setup and quartz filter stuff

#ifdef FILTER_DLL

HRESULT DllRegisterServer()
{
  return AMovieDllRegisterServer2(TRUE);
}

HRESULT DllUnregisterServer()
{
  return AMovieDllRegisterServer2(FALSE);
}

CFactoryTemplate g_Templates[]= {
  {L"file writer", &CLSID_FileWriter, CFileWriterFilter::CreateInstance, NULL, &sudFileWriter},
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);;

#endif // FILTER_DLL

// setup data - allows the self-registration to work.
AMOVIESETUP_MEDIATYPE sudWriterPinTypes =   {
  &MEDIATYPE_NULL,              // clsMajorType
  &MEDIASUBTYPE_NULL };         // clsMinorType

AMOVIESETUP_PIN psudWriterPins[] =
{
  { L"Input"                    // strName
    , FALSE                     // bRendered
    , FALSE                     // bOutput
    , FALSE                     // bZero
    , FALSE                     // bMany
    , &CLSID_NULL               // clsConnectsToFilter
    , L""                       // strConnectsToPin
    , 1                         // nTypes
    , &sudWriterPinTypes        // lpTypes
  }
};


const AMOVIESETUP_FILTER sudFileWriter =
{
  &CLSID_FileWriter             // clsID
  , L"File writer"              // strName
  , MERIT_DO_NOT_USE            // dwMerit
  , 1                           // nPins
  , psudWriterPins              // lpPin
};

CUnknown *CFileWriterFilter::CreateInstance(LPUNKNOWN punk, HRESULT *pHr)
{
  return new CFileWriterFilter(punk, pHr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\writer\fw.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <initguid.h>
#include "fw.h"

// ------------------------------------------------------------------------
// filter

#pragma warning(disable:4355)
CBaseWriterFilter::CBaseWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr) :
    CBaseFilter(NAME("fw filter"), pUnk, &m_cs, CLSID_FileWriter),
    m_inputPin(NAME("fw inpin"), this, &m_cs, pHr)
{
  ASSERT(m_mtSet.majortype == GUID_NULL);
  ASSERT(m_mtSet.subtype == GUID_NULL);
}

CBaseWriterFilter::~CBaseWriterFilter()
{
}

STDMETHODIMP
CBaseWriterFilter::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
  if(riid == IID_IAMFilterMiscFlags)
    return GetInterface((IAMFilterMiscFlags *)this, ppv);
  else
    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);    
}

int CBaseWriterFilter::GetPinCount()
{
  return 1;
}

CBasePin *CBaseWriterFilter::GetPin(int pin)
{
  return pin == 0 ? &m_inputPin : 0;
}

HRESULT CBaseWriterFilter::Pause()
{
  CAutoLock lock(&m_cs);

  if(m_State == State_Stopped)
  {
    m_fEosSignaled = FALSE;
    m_fErrorSignaled = FALSE;

    HRESULT hr = CanPause();
    if(FAILED(hr))
    {
      m_fErrorSignaled = TRUE;
      return hr;
    }
    
    // send an EC_COMPLETE event first time we run with input
    // disconnected
    if(!m_inputPin.IsConnected())
    {
      m_fEosSignaled = TRUE;
    }
    
    hr = Open();
    if(FAILED(hr))
    {
      m_fErrorSignaled = TRUE;
      return hr;
    }
  }

  return CBaseFilter::Pause();
}

HRESULT CBaseWriterFilter::Run(REFERENCE_TIME rtStart)
{
  CAutoLock Lock(&m_cs);
  HRESULT hr = CBaseFilter::Run(rtStart);

  // every time we transition to Run, need to send EC_COMPLETE if
  // we're done.
  if(m_fEosSignaled && !m_fErrorSignaled)
  {
    NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
  }

  return hr;
    
}

HRESULT CBaseWriterFilter::Stop()
{
  CAutoLock lock(&m_cs);
  HRESULT hrClose = Close();
  HRESULT hrStop = CBaseFilter::Stop();
  if(m_fErrorSignaled)
    return hrStop;
  else
    return FAILED(hrClose) ? hrClose : hrStop;
}



// could be used to close asynchronous file handle (used by
// IMemInputPin) early

STDMETHODIMP CBaseWriterFilter::EndOfStream()
{
  DbgLog((LOG_TRACE, 3, TEXT("CBaseWriterFilter: EOS")));
  CAutoLock lock(&m_cs);
  ASSERT(!m_fEosSignaled);
  m_fEosSignaled = TRUE;

  if(!m_fErrorSignaled)
  {
    if(m_State == State_Running)
    {
      NotifyEvent(EC_COMPLETE, S_OK, (LONG_PTR)(IBaseFilter *)this);
    }
    else if(m_State == State_Paused)
    {
      // m_fEosSignaled set, so will be signaled on run
    }
    else
    {
      ASSERT(m_State == State_Stopped);
      // we could have stopped already; ignore EOS
    }
  }
  
  return S_OK;
}


// ------------------------------------------------------------------------
// input pin

CBaseWriterInput::CBaseWriterInput(
  TCHAR *pObjectName,
  CBaseWriterFilter *pFilter,
  CCritSec *pLock,
  HRESULT *phr) : 
    CBaseInputPin(pObjectName, pFilter, pLock, phr, L"in"),
    m_pFwf(pFilter)
{
}

STDMETHODIMP
CBaseWriterInput::NonDelegatingQueryInterface(REFIID riid, void ** pv)
{
  if(riid == IID_IStream)
  {
    return m_pFwf->CreateIStream(pv);
  }
  else
  {
    return CBaseInputPin::NonDelegatingQueryInterface(riid, pv);
  }
}

HRESULT CBaseWriterInput::CheckMediaType(const CMediaType *pmt)
{
  // accept what's set or anything if not set
  if((m_pFwf->m_mtSet.majortype == pmt->majortype ||
      m_pFwf->m_mtSet.majortype == GUID_NULL) &&
     (m_pFwf->m_mtSet.subtype == pmt->subtype ||
      m_pFwf->m_mtSet.subtype == GUID_NULL))
  {
    return S_OK;
  }
  else
  {
    return S_FALSE;
  }
}

STDMETHODIMP
CBaseWriterInput::BeginFlush(void)
{
  return E_UNEXPECTED;
}

STDMETHODIMP
CBaseWriterInput::EndFlush(void)
{
  return E_UNEXPECTED;
}

STDMETHODIMP CBaseWriterInput::GetAllocator(IMemAllocator **ppA)
{
  *ppA = 0;
  // what do you want with my allocator.... you can't set the data
  // pointer on it...
  return E_INVALIDARG;
}

// return disk sector size through here
STDMETHODIMP CBaseWriterInput::GetAllocatorRequirements(
  ALLOCATOR_PROPERTIES *pAp)
{
  ULONG cb;
  ZeroMemory(pAp, sizeof(*pAp));
  HRESULT hr = m_pFwf->GetAlignReq(&cb);
  ASSERT(hr == S_OK);
  pAp->cbAlign = cb;

  return S_OK;
}

STDMETHODIMP CBaseWriterInput::Receive(IMediaSample *pSample)
{
  CAutoLock l(&m_pFwf->m_cs);
  if(m_pFwf->m_fErrorSignaled)
    return S_FALSE;

  ASSERT(!m_pFwf->m_fEosSignaled);
  
  REFERENCE_TIME rtStart, rtEnd;
  HRESULT hr = pSample->GetTime(&rtStart, &rtEnd);
  if(hr != S_OK)
  {
    m_pFwf->m_fErrorSignaled = TRUE;
    m_pFwf->NotifyEvent(EC_ERRORABORT, hr, 0);
    return hr;
  }

//   ULONG cb = pSample->GetActualDataLength();
//   if(rtStart + cb != rtEnd)
//   {
//     DbgBreak("start, stop, and size don't mathc");
//     return E_INVALIDARG;
//   }

  ULONG cb = (ULONG)(rtEnd - rtStart);
  BYTE *pb;
  
  hr = pSample->GetPointer(&pb);
  ASSERT(hr == S_OK);

  pSample->AddRef();
  hr = m_pFwf->AsyncWrite(rtStart, cb, pb, Callback, pSample);
  if(hr != S_OK)
  {
    DbgLog((LOG_ERROR, 5, TEXT("CBaseWriterInput: AsyncWrite returned %08x"),
            hr));

    // the call back is called only if AsyncWrite succeeds.
    pSample->Release();

    if(FAILED(hr))
    {
      DbgLog((LOG_ERROR, 1, TEXT("fw Receive: signalling error")));
      m_pFwf->m_fErrorSignaled = TRUE;
      m_pFwf->NotifyEvent(EC_ERRORABORT, hr, 0);
    }
  }

  return hr;
}

STDMETHODIMP CBaseWriterInput::EndOfStream()
{
  return m_pFwf->EndOfStream();
}


STDMETHODIMP
CBaseWriterInput::NotifyAllocator(
  IMemAllocator * pAllocator,
  BOOL bReadOnly)
{
  HRESULT hr = CBaseInputPin::NotifyAllocator(pAllocator, bReadOnly);
  if(FAILED(hr))
    return hr;
  else
    return m_pFwf->NotifyAllocator(pAllocator, bReadOnly);
}


void CBaseWriterInput::Callback(void *pMisc)
{
  IMediaSample *pSample = (IMediaSample *)pMisc;
  pSample->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "GuideStore_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\channel.cpp ===
// Channel.cpp : Implementation of CChannel
#include "stdafx.h"
#include "Channel.h"

/////////////////////////////////////////////////////////////////////////////
// CChannel


/////////////////////////////////////////////////////////////////////////////
// CChannels


/////////////////////////////////////////////////////////////////////////////
// CChannelLineup


/////////////////////////////////////////////////////////////////////////////
// CChannelLineups


STDMETHODIMP CChannel::get_Name(BSTR *pbstrName)
{
ENTER_API
	{
	ValidateOut(pbstrName);

	return m_pdb->DescriptionPropSet::_get_Name((IChannel *)this, pbstrName);
	}
LEAVE_API
}

STDMETHODIMP CChannel::put_Name(BSTR bstrName)
{
ENTER_API
	{
	ValidateOut(bstrName);

	return m_pdb->DescriptionPropSet::_put_Name((IChannel *) this, _variant_t(bstrName));
	}
LEAVE_API
}

STDMETHODIMP CChannel::get_Service(IService **ppservice)
{
ENTER_API
	{
	ValidateOutPtr<IService>(ppservice, NULL);

	HRESULT hr;
	if (m_pservice == NULL)
		{
		hr = _get_ItemRelatedBy(m_pdb->ChannelPropSet::ServiceMetaPropertyType(),
				(IService **) &m_pservice);
		if (hr == S_FALSE || FAILED(hr))
			return hr;
		}

	m_pservice.CopyTo(ppservice);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CChannel::putref_Service(IService *pservice)
{
ENTER_API
	{
	ValidateInPtr_NULL_OK<IService>(pservice);

	m_pservice = pservice;
	if (m_pservice == NULL)
		{
		//TODO: Remove the item relationship.
		return S_OK;
		}

	return put_ItemRelatedBy(m_pdb->ChannelPropSet::ServiceMetaPropertyType(),
			(IService *) m_pservice);
	}
LEAVE_API
}

STDMETHODIMP CChannel::get_ChannelLineups(IChannelLineups **ppchanlineups)
{
ENTER_API
	{
	ValidateOutPtr<IChannelLineups>(ppchanlineups, NULL);

	HRESULT hr;
	CObjectType *pobjtype;

	hr = m_pdb->get_ChannelLineupObjectType(&pobjtype);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjsT;
	hr = m_pdb->get_ObjectsWithType(pobjtype, &pobjsT);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjs;
	hr = pobjsT->get_ItemsInverseRelatedToBy((IChannel *) this,
			m_pdb->ChannelsPropSet::ChannelMetaPropertyType(), &pobjs);
	if (FAILED(hr))
		return hr;

	return pobjs->QueryInterface(__uuidof(IChannelLineups), (void **)ppchanlineups);
	}
LEAVE_API
}

STDMETHODIMP CChannels::AddAt(IChannel *pchan, long i)
{
ENTER_API
	{
	ValidateInPtr<IChannel>(pchan);

	CComQIPtr<IObjects> pobjs(GetControllingUnknown());

	return pobjs->AddAt(pchan, i);
	}
LEAVE_API
}


STDMETHODIMP CChannels::get_AddNewAt(IService *pservice, BSTR bstrName, long i, IChannel **ppchan)
{
ENTER_API
	{
	ValidateInPtr_NULL_OK<IService>(pservice);
	ValidateIn(bstrName);
	ValidateOutPtr<IChannel>(ppchan, NULL);

	HRESULT hr;
	CComPtr<IChannel> pchan;

	hr = _get_AddNewAt(i, &pchan);
	if (FAILED(hr))
		return hr;
	
	hr = pchan->put_Name(bstrName);
	if (FAILED(hr))
		return hr;

	if (pservice != NULL)
		{
		hr = pchan->putref_Service(pservice);
		if (FAILED(hr))
			return hr;
		}
	
	*ppchan = pchan.Detach();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CChannels::get_ItemWithName(BSTR bstrName, IChannel **ppchan)
{
ENTER_API
	{
	ValidateIn(bstrName);
	ValidateOutPtr<IChannel>(ppchan, NULL);

	// UNDONE: Test
	CComPtr<IMetaPropertyType> pproptype= m_pdb->DescriptionPropSet::NameMetaPropertyType();
	CComPtr<IMetaProperty> pprop;
	HRESULT hr;

	hr = pproptype->get_New(0, _variant_t(bstrName), &pprop);
	if (FAILED(hr))
		return hr;

	CComPtr<IMetaPropertyCondition> ppropcond;

	hr = pprop->get_Cond(_bstr_t(_T("=")), &ppropcond);
	if (FAILED(hr))
		return hr;

	CComQIPtr<IObjects> pobjsThis(GetControllingUnknown());
	CComPtr<IObjects> pobjs;

	hr = pobjsThis->get_ItemsWithMetaPropertyCond(ppropcond, &pobjs);
	if (FAILED(hr))
		return hr;

	CComPtr<IUnknown> pobj;

	hr = pobjs->get_Item(_variant_t(0L), &pobj);
	if (FAILED(hr))
		return hr;

	hr = pobj->QueryInterface(__uuidof(IChannel), (void **) ppchan);

	return hr;
	}
LEAVE_API
}

STDMETHODIMP CChannelLineup::get_Name(BSTR *pbstrName)
{
ENTER_API
	{
	ValidateOut(pbstrName);

	return m_pdb->DescriptionPropSet::_get_Name((IChannelLineup *)this, pbstrName);
	}
LEAVE_API
}

STDMETHODIMP CChannelLineup::put_Name(BSTR bstrName)
{
ENTER_API
	{
	ValidateIn(bstrName);

	return m_pdb->DescriptionPropSet::_put_Name((IChannelLineup *)this, bstrName);
	}
LEAVE_API
}

STDMETHODIMP CChannelLineup::get_Channels(IChannels **ppchans)
{
ENTER_API
	{
	ValidateOutPtr<IChannels>(ppchans, NULL);

	if (m_pchans == NULL)
		{
		HRESULT hr;
		CObjectType *pobjtype;

		hr = m_pdb->get_ChannelObjectType(&pobjtype);
		if (FAILED(hr))
			return hr;

		CComPtr<IObjects> pobjs;
	
		hr = pobjtype->get_NewCollection(&pobjs);
		if (FAILED(hr))
			return hr;
		
		CComQIPtr<CObjects> pobjsT(pobjs);
		CComQIPtr<CMetaPropertyType> pproptype(m_pdb->ChannelsPropSet::ChannelMetaPropertyType());
		long idRel = pproptype->GetID();

		pobjsT->InitRelation(GetControllingUnknown(), idRel, FALSE);

		pobjs->QueryInterface(__uuidof(IChannels), (void **)&m_pchans);
		}
	
	(*ppchans = m_pchans)->AddRef();

	return S_OK;
	}
LEAVE_API
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\channel.h ===
// Channel.h : Declaration of the CChannel

#ifndef __CHANNEL_H_
#define __CHANNEL_H_

#include "resource.h"       // main symbols
#include "guidedb.h"
#include "object.h"
#include "GuideStoreCP.h"

/////////////////////////////////////////////////////////////////////////////
// CChannel
class ATL_NO_VTABLE CChannel : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CChannel, &CLSID_Channel>,
	public IConnectionPointContainerImpl<CChannel>,
	public CObjectGlue,
	public IDispatchImpl<IChannel, &IID_IChannel, &LIBID_GUIDESTORELib>
{
public:
	CChannel()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHANNEL)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CChannel)
	COM_INTERFACE_ENTRY(IChannel)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CChannel)
END_CONNECTION_POINT_MAP()


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
		{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
		}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	void Init(IService *pservice, BSTR bstrName)
		{
		m_pservice = pservice;
		m_bstrName = bstrName;
		}

// IChannel
public:
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *ppprops)
		{
		return CObjectGlue::get_MetaProperties(ppprops);
		}
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pid)
		{
		return CObjectGlue::get_ID(pid);
		}
	STDMETHOD(get_ChannelLineups)(/*[out, retval]*/ IChannelLineups * *pVal);
	STDMETHOD(putref_Service)(IService * pservice);
	STDMETHOD(get_Service)(/*[out, retval]*/ IService * *ppservice);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);

protected:
	_bstr_t m_bstrName;
	CComPtr<IService> m_pservice;
};

	
// Channel.h : Declaration of the CChannels


/////////////////////////////////////////////////////////////////////////////
// CChannels
class ATL_NO_VTABLE CChannels : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CChannels, &CLSID_Channels>,
	public IConnectionPointContainerImpl<CChannels>,
	public CObjectsGlue<IChannels, IChannel>,
	public IDispatchImpl<IChannels, &IID_IChannels, &LIBID_GUIDESTORELib>,
	public CProxyIChannelsEvents< CChannels >
{
public:
	CChannels()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHANNELS)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CChannels)
	COM_INTERFACE_ENTRY(IChannels)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IObjectsNotifications)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CChannels)
CONNECTION_POINT_ENTRY(DIID_IChannelsEvents)
END_CONNECTION_POINT_MAP()


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
		{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
		}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IObjectsNotifications
	STDMETHOD(Notify_ItemAdded)(IUnknown *punk)
		{
		CComQIPtr<IChannel> pchan(punk);
		return Fire_ItemAdded(pchan);
		}
	STDMETHOD(Notify_ItemRemoved)(long idObj)
		{
		return Fire_ItemRemoved(idObj);
		}
	STDMETHOD(Notify_ItemChanged)(IUnknown *punk)
		{
		CComQIPtr<IChannel> pchan(punk);

		return Fire_ItemChanged(pchan);
		}
	STDMETHOD(Notify_ItemsChanged)()
		{
		return Fire_ItemsChanged();
		}

// IChannels
public:
	STDMETHOD(get_ItemWithName)(BSTR bstrName, /*[out, retval]*/ IChannel **ppchan);
	STDMETHOD(get_ItemsWithMetaPropertyCond)(IMetaPropertyCondition *pcond, /*[out, retval]*/ IChannels * *ppchans)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyCondition>(pcond);
			ValidateOutPtr<IChannels>(ppchans, NULL);

			return _get_ItemsWithMetaPropertyCond(pcond, ppchans);
			}
		LEAVE_API
		}
	STDMETHOD(get_AddNewAt)(IService *pservice, BSTR bstrName, long index,
			/*[out, retval]*/ IChannel * *pVal);
	STDMETHOD(AddAt)(IChannel *pchan, long index);

	STDMETHOD(Remove)(VARIANT varIndex)
		{
		ENTER_API
			{
			return _Remove(varIndex);
			}
		LEAVE_API
		}
	STDMETHOD(RemoveAll)()
		{
		ENTER_API
			{
			return _RemoveAll();
			}
		LEAVE_API
		}
	STDMETHOD(Resync)()
		{
		ENTER_API
			{
			return _Resync();
			}
		LEAVE_API
		}

	STDMETHOD(UnreferencedItems)(/*[out, retval]*/ IChannels * *ppchans)
		{
		ENTER_API
			{
			ValidateOutPtr<IChannels>(ppchans, NULL);

			return _UnreferencedItems(ppchans);
			}
		LEAVE_API
		}

	STDMETHOD(get_ItemsByKey)(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, IChannels **ppchans)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyType>(pproptype);
			ValidateInPtr_NULL_OK<IGuideDataProvider>(pprovider);
			ValidateOutPtr<IChannels>(ppchans, NULL);

			return _get_ItemsByKey(pproptype, pprovider, idLang, vt, ppchans);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithKey)(VARIANT varKey, /*[out, retval]*/ IChannel * *ppchan)
		{
		ENTER_API
			{
			ValidateOutPtr<IChannel>(ppchan, NULL);

			return _get_ItemWithKey(varKey, ppchan);
			}
		LEAVE_API
		}
	STDMETHOD(get_Item)(VARIANT varIndex, /*[out, retval]*/ IChannel * *ppchan)
		{
		ENTER_API
			{
			ValidateOutPtr<IChannel>(ppchan, NULL);

			return _get_Item(varIndex, ppchan);
			}
		LEAVE_API
		}

	STDMETHOD(get_Count)(/*[out, retval]*/ long *plCount)
		{
		ENTER_API
			{
			ValidateOut<long>(plCount, 0);

			return _get_Count(plCount);
			}
		LEAVE_API
		}

#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk, NULL);

			return _get__NewEnum(ppunk);
			}
		LEAVE_API
		}
#endif

protected:
};

	
// Channel.h : Declaration of the CChannelLineup


/////////////////////////////////////////////////////////////////////////////
// CChannelLineup
class ATL_NO_VTABLE CChannelLineup : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CChannelLineup, &CLSID_ChannelLineup>,
	public IConnectionPointContainerImpl<CChannelLineup>,
	public CObjectGlue,
	public IDispatchImpl<IChannelLineup, &IID_IChannelLineup, &LIBID_GUIDESTORELib>
{
public:
	CChannelLineup()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_pchans = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHANNELLINEUP)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CChannelLineup)
	COM_INTERFACE_ENTRY(IChannelLineup)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CChannelLineup)
END_CONNECTION_POINT_MAP()


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
		{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
		}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IChannelLineup
public:
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *ppprops)
		{
		return CObjectGlue::get_MetaProperties(ppprops);
		}
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pid)
		{
		return CObjectGlue::get_ID(pid);
		}
	STDMETHOD(get_Channels)(/*[out, retval]*/ IChannels * *pVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Name)(/*[in]*/ BSTR newVal);

protected:
	CComPtr<IChannels> m_pchans;
};

	
// Channel.h : Declaration of the CChannelLineups


/////////////////////////////////////////////////////////////////////////////
// CChannelLineups
class ATL_NO_VTABLE CChannelLineups : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CChannelLineups, &CLSID_ChannelLineups>,
	public CObjectsGlue<IChannelLineups, IChannelLineup>,
	public IConnectionPointContainerImpl<CChannelLineups>,
	public IDispatchImpl<IChannelLineups, &IID_IChannelLineups, &LIBID_GUIDESTORELib>,
	public CProxyIChannelLineupsEvents< CChannelLineups >
{
public:
	CChannelLineups()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHANNELLINEUPS)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CChannelLineups)
	COM_INTERFACE_ENTRY(IChannelLineups)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IObjectsNotifications)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CChannelLineups)
CONNECTION_POINT_ENTRY(DIID_IChannelLineupsEvents)
END_CONNECTION_POINT_MAP()


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
		{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
		}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IObjectsNotifications
	STDMETHOD(Notify_ItemAdded)(IUnknown *punk)
		{
		CComQIPtr<IChannelLineup> pchanlineup(punk);

		return Fire_ItemAdded(pchanlineup);
		}
	STDMETHOD(Notify_ItemRemoved)(long idObj)
		{
		return Fire_ItemRemoved(idObj);
		}
	STDMETHOD(Notify_ItemChanged)(IUnknown *punk)
		{
		CComQIPtr<IChannelLineup> pchanlineup(punk);

		return Fire_ItemChanged(pchanlineup);
		}
	STDMETHOD(Notify_ItemsChanged)()
		{
		return Fire_ItemsChanged();
		}

// IChannelLineups
	STDMETHOD(Remove)(VARIANT varIndex)
		{
		ENTER_API
			{
			return _Remove(varIndex);
			}
		LEAVE_API
		}
	STDMETHOD(RemoveAll)()
		{
		ENTER_API
			{
			return _RemoveAll();
			}
		LEAVE_API
		}
	STDMETHOD(Resync)()
		{
		ENTER_API
			{
			return _Resync();
			}
		LEAVE_API
		}

	STDMETHOD(UnreferencedItems)(/*[out, retval]*/ IChannelLineups * *ppchanlineups)
		{
		ENTER_API
			{
			ValidateOutPtr<IChannelLineups>(ppchanlineups, NULL);

			return _UnreferencedItems(ppchanlineups);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsByKey)(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, IChannelLineups **ppchanlineups)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyType>(pproptype);
			ValidateInPtr_NULL_OK<IGuideDataProvider>(pprovider);
			ValidateOutPtr<IChannelLineups>(ppchanlineups, NULL);

			return _get_ItemsByKey(pproptype, pprovider, idLang, vt, ppchanlineups);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithKey)(VARIANT varKey, /*[out, retval]*/ IChannelLineup * *ppchanlineup)
		{
		ENTER_API
			{
			ValidateOutPtr<IChannelLineup>(ppchanlineup, NULL);

			return _get_ItemWithKey(varKey, ppchanlineup);
			}
		LEAVE_API
		}
	STDMETHOD(get_Item)(VARIANT varIndex, /*[out, retval]*/ IChannelLineup **ppchanlineup)
		{
		ENTER_API
			{
			ValidateOutPtr<IChannelLineup>(ppchanlineup, NULL);

			return _get_Item(varIndex, ppchanlineup);
			}
		LEAVE_API
		}
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plCount)
		{
		ENTER_API
			{
			ValidateOut<long>(plCount, 0);

			return _get_Count(plCount);
			}
		LEAVE_API
		}
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk, NULL);

			return _get__NewEnum(ppunk);
			}
		LEAVE_API
		}
#endif
public:

	STDMETHOD(get_AddNew)(BSTR bstrName, /*[out, retval]*/ IChannelLineup * *ppchanlineup)
		{
		ENTER_API
			{
			ValidateIn(bstrName);
			ValidateOutPtr<IChannelLineup>(ppchanlineup, NULL);

			HRESULT hr = _get_AddNew(ppchanlineup);
			if (FAILED(hr))
				return hr;
			
			return (*ppchanlineup)->put_Name(bstrName);
			}
		LEAVE_API
		}

protected:
};

#endif //__CHANNEL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__C60B63F2_0BC6_4E89_8C9B_C588D7A19CAB__INCLUDED_)
#define AFX_DLLDATAX_H__C60B63F2_0BC6_4E89_8C9B_C588D7A19CAB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__C60B63F2_0BC6_4E89_8C9B_C588D7A19CAB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filterus\writer\fw.h ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.
// base classes for filter which supports asynchronous writes to
// media via IMemInputPin. Also support for IStream

typedef void (*FileIoCallback)(void *pCallbackArg);

class CBaseWriterFilter;

class CBaseWriterInput :
  public CBaseInputPin
{
public:

  STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** pv);
  
  CBaseWriterInput(
    TCHAR *pObjectName,         // Object description
    CBaseWriterFilter *pFwf,    // Owning filter who knows about pins
    CCritSec *pLock,            // Object who implements the lock
    HRESULT *phr);              // General OLE return code

  // CBasePin
  HRESULT CheckMediaType(const CMediaType *);
  STDMETHODIMP BeginFlush(void);
  STDMETHODIMP EndFlush(void);

  // IMemInputPin... derived class may want these
  STDMETHODIMP GetAllocator(IMemAllocator ** ppAllocator);
  STDMETHODIMP GetAllocatorRequirements(ALLOCATOR_PROPERTIES *pProps);

  STDMETHODIMP Receive(IMediaSample *pSample);
  STDMETHODIMP ReceiveCanBlock() { return S_OK;}
  STDMETHODIMP EndOfStream();
  STDMETHODIMP SignalEos();

  virtual STDMETHODIMP NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly);
                                        
private:

  CBaseWriterFilter *m_pFwf;
  static void Callback(void *pMisc);
};

class CBaseWriterFilter :
  public CBaseFilter,
  public IAMFilterMiscFlags
{
public:
  
  virtual HRESULT Open() PURE;  // needed to get alignment
  virtual HRESULT Close() PURE; // needed to return error value
  virtual HRESULT GetAlignReq(ULONG *pcbAlign) PURE;

  virtual HRESULT AsyncWrite(
    const DWORDLONG dwlFileOffset,
    const ULONG cb,
    BYTE *pb,
    FileIoCallback fnCallback,
    void *pCallbackArg) PURE;

  DECLARE_IUNKNOWN;
  virtual STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

  // should return a new IStream (with its own seek ptr)
  virtual STDMETHODIMP CreateIStream(void **ppIStream) PURE;
  
   CBaseWriterFilter(LPUNKNOWN pUnk, HRESULT *pHr);
  ~CBaseWriterFilter();
                       
  CBasePin* GetPin(int n);
  int GetPinCount();

  virtual STDMETHODIMP NotifyAllocator(
    IMemAllocator * pAllocator,
    BOOL bReadOnly) { return S_OK; }

  // messy to override Pause
  virtual STDMETHODIMP CanPause() { return S_OK; }

  STDMETHODIMP Pause();
  STDMETHODIMP Stop();
  STDMETHODIMP Run(REFERENCE_TIME rtStart);

  STDMETHODIMP EndOfStream();

protected:

  // only the major & minor types are used. the media type we accept
  // or null media types. set by derived class
  CMediaType m_mtSet;

  CCritSec m_cs;

  CBaseWriterInput m_inputPin;

private:

  // report only one error to graph
  BOOL m_fErrorSignaled;

  // EOS signaled. or EOS needs to be signaled on Run()
  BOOL m_fEosSignaled;

  friend class CBaseWriterInput;

  STDMETHODIMP_(ULONG) GetMiscFlags(void) { return AM_FILTER_MISC_FLAGS_IS_RENDERER; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidedataprovider.h ===
// GuideDataProvider.h : Declaration of the CGuideDataProvider

#ifndef __GUIDEDATAPROVIDER_H_
#define __GUIDEDATAPROVIDER_H_

#include "resource.h"       // main symbols

#include "object.h"
#include "GuideStoreCP.h"

class CGuideDataProvider;
class CGuideDataProviders;
 
class DECLSPEC_UUID("e78e3f11-3c6f-4b32-834a-753a1909588e") ATL_NO_VTABLE CGuideDataProvider : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CGuideDataProvider, &CLSID_GuideDataProvider>,
	public CObjectGlue,
	public IDispatchImpl<IGuideDataProvider, &IID_IGuideDataProvider, &LIBID_GUIDESTORELib>
{
public:
	CGuideDataProvider()
		{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		}

DECLARE_REGISTRY_RESOURCEID(IDR_GUIDEDATAPROVIDER)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CGuideDataProvider)
	COM_INTERFACE_ENTRY(IGuideDataProvider)
	COM_INTERFACE_ENTRY(CGuideDataProvider)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
		{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
		}

	void FinalRelease()
		{
		m_pUnkMarshaler.Release();
		}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IGuideDataProvider
public:
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *ppprops)
		{
		return CObjectGlue::get_MetaProperties(ppprops);
		}
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pid)
		{
		return CObjectGlue::get_ID(pid);
		}
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pbstrDesc);
	STDMETHOD(put_Description)(/*[in]*/ BSTR bstrDesc);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);
};

	
// GuideDataProvider.h : Declaration of the CGuideDataProviders


/////////////////////////////////////////////////////////////////////////////
// CGuideDataProviders
class ATL_NO_VTABLE CGuideDataProviders : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CGuideDataProviders, &CLSID_GuideDataProviders>,
	public IConnectionPointContainerImpl<CGuideDataProviders>,
	public CObjectsGlue<IGuideDataProviders, IGuideDataProvider>,
	public CProxyIGuideDataProvidersEvents< CGuideDataProviders >,
	public IDispatchImpl<IGuideDataProviders, &IID_IGuideDataProviders, &LIBID_GUIDESTORELib>
{
public:
	CGuideDataProviders()
		{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		}

DECLARE_REGISTRY_RESOURCEID(IDR_GUIDEDATAPROVIDERS)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CGuideDataProviders)
	COM_INTERFACE_ENTRY(IGuideDataProviders)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CGuideDataProviders)
CONNECTION_POINT_ENTRY(DIID_IGuideDataProvidersEvents)
END_CONNECTION_POINT_MAP()


// Reflect Notifications from CObjectsGlue<>
	STDMETHOD(Notify_ItemAdded)(IUnknown *punk)
		{
		CComQIPtr<IGuideDataProvider> pprovider(punk);

		return Fire_ItemAdded(pprovider);
		}
	STDMETHOD(Notify_ItemRemoved)(long idObj)
		{
		return Fire_ItemRemoved(idObj);
		}
	STDMETHOD(Notify_ItemChanged)(IUnknown *punk)
		{
		CComQIPtr<IGuideDataProvider> pprovider(punk);

		return Fire_ItemChanged(pprovider);
		}
	STDMETHOD(Notify_ItemsChanged)()
		{
		return Fire_ItemsChanged();
		}


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
		{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
		}

	void FinalRelease()
		{
		m_pUnkMarshaler.Release();
		}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IGuideDataProviders
	STDMETHOD(get_ItemWithName)(BSTR bstrName, /*[out, retval]*/ IGuideDataProvider **ppdataprovider);
	STDMETHOD(get_AddNew)(/* [in] */ BSTR bstrName, /*[out, retval]*/ IGuideDataProvider * *ppdataprovider)
		{
		ENTER_API
			{
			HRESULT hr;
			ValidateOutPtr<IGuideDataProvider>(ppdataprovider, NULL);

			hr = get_ItemWithName(bstrName, ppdataprovider);
			if (SUCCEEDED(hr))
				return hr;

			hr = _get_AddNew(ppdataprovider);
			if (FAILED(hr))
				return hr;
			
			return m_pdb->DescriptionPropSet::_put_Name(*ppdataprovider, bstrName);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsWithMetaPropertyCond)(IMetaPropertyCondition *pcond, /*[out, retval]*/ IGuideDataProviders * *ppdataproviders)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyCondition>(pcond);
			ValidateOutPtr<IGuideDataProviders>(ppdataproviders, NULL);

			return _get_ItemsWithMetaPropertyCond(pcond, ppdataproviders);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsWithMetaProperty)(IMetaProperty *pprop, /*[out, retval]*/ IGuideDataProviders * *ppdataproviders)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaProperty>(pprop);
			ValidateOutPtr<IGuideDataProviders>(ppdataproviders, NULL);

			return _get_ItemsWithMetaProperty(pprop, ppdataproviders);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithID)(long id, /*[out, retval]*/ IGuideDataProvider * *ppdataprovider)
		{
		ENTER_API
			{
			ValidateOutPtr<IGuideDataProvider>(ppdataprovider, NULL);

			return _get_ItemWithID(id, ppdataprovider);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsByKey)(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, IGuideDataProviders **ppdataproviders)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyType>(pproptype);
			ValidateInPtr_NULL_OK<IGuideDataProvider>(pprovider);
			ValidateOutPtr<IGuideDataProviders>(ppdataproviders, NULL);

			return _get_ItemsByKey(pproptype, pprovider, idLang, vt, ppdataproviders);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithKey)(VARIANT varKey, /*[out, retval]*/ IGuideDataProvider * *ppdataprovider)
		{
		ENTER_API
			{
			ValidateOutPtr<IGuideDataProvider>(ppdataprovider, NULL);

			return _get_ItemWithKey(varKey, ppdataprovider);
			}
		LEAVE_API
		}
	STDMETHOD(get_Item)(VARIANT varIndex, /*[out, retval]*/ IGuideDataProvider * *ppdataprovider)
		{
		ENTER_API
			{
			ValidateOutPtr<IGuideDataProvider>(ppdataprovider, NULL);

			return _get_Item(varIndex, ppdataprovider);
			}
		LEAVE_API
		}
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plCount)
		{
		ENTER_API
			{
			ValidateOut<long>(plCount, 0);

			return _get_Count(plCount);
			}
		LEAVE_API
		}
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk, NULL);
			return _get__NewEnum(ppunk);
			}
		LEAVE_API
		}
#endif
	STDMETHOD(Resync)()
		{
		ENTER_API
			{
			return _Resync();
			}
		LEAVE_API
		}
public:
};

#endif //__GUIDEDATAPROVIDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidedataprovider.cpp ===
// GuideDataProvider.cpp : Implementation of CGuideDataProvider
#include "stdafx.h"
#include "GuideDataProvider.h"

/////////////////////////////////////////////////////////////////////////////
// CGuideDataProvider


STDMETHODIMP CGuideDataProvider::get_Name(BSTR *pbstrName)
{
ENTER_API
	{
	ValidateOut(pbstrName);

	return m_pdb->DescriptionPropSet::_get_Name((IGuideDataProvider *) this, pbstrName);
	}
LEAVE_API
}

STDMETHODIMP CGuideDataProvider::get_Description(BSTR *pbstrDescription)
{
ENTER_API
	{
	ValidateOut(pbstrDescription);

	return m_pdb->DescriptionPropSet::_get_OneParagraph((IGuideDataProvider *) this, pbstrDescription);
	}
LEAVE_API
}

STDMETHODIMP CGuideDataProvider::put_Description(BSTR bstrDescription)
{
ENTER_API
	{
	ValidateIn(bstrDescription);

	return m_pdb->DescriptionPropSet::_put_OneParagraph((IGuideDataProvider *) this, bstrDescription);
	}
LEAVE_API
}

/////////////////////////////////////////////////////////////////////////////
// CGuideDataProviders

STDMETHODIMP CGuideDataProviders::get_ItemWithName(BSTR bstrName, IGuideDataProvider **ppdataprovider)
{
ENTER_API
	{
	ValidateIn(bstrName);
	ValidateOutPtr<IGuideDataProvider>(ppdataprovider, NULL);

	// UNDONE: Test
	CComPtr<IMetaPropertyType> pproptype= m_pdb->DescriptionPropSet::NameMetaPropertyType();
	CComPtr<IMetaProperty> pprop;
	HRESULT hr;

	hr = pproptype->get_New(0, _variant_t(bstrName), &pprop);
	if (FAILED(hr))
		return hr;

	CComPtr<IMetaPropertyCondition> ppropcond;

	hr = pprop->get_Cond(_bstr_t(_T("=")), &ppropcond);
	if (FAILED(hr))
		return hr;

	CComQIPtr<IObjects> pobjsThis(GetControllingUnknown());
	CComPtr<IObjects> pobjs;

	hr = pobjsThis->get_ItemsWithMetaPropertyCond(ppropcond, &pobjs);
	if (FAILED(hr))
		return hr;

	CComPtr<IUnknown> pobj;

	hr = pobjs->get_Item(_variant_t(0L), &pobj);
	if (FAILED(hr))
		return hr;

	hr = pobj->QueryInterface(__uuidof(IGuideDataProvider), (void **) ppdataprovider);

	return hr;
	}
LEAVE_API
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidedb.h ===
#ifndef __GUIDEDB_H_
#define __GUIDEDB_H_

#include "resource.h"       // main symbols
#include "stdprop.h"
#include "SharedMemory.h"

// External classes
class CObject;
class CObjectType;
class CObjectTypes;

class CGuideDB;

/////////////////////////////////////////////////////////////////////////////
// CGuideDB
class ATL_NO_VTABLE CGuideDB : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public IConnectionPointContainerImpl<CGuideDB>,
	public CategoriesPropSet,
	public ChannelPropSet,
	public ChannelsPropSet,
	public CopyrightPropSet,
	public TimePropSet,
	public DescriptionPropSet,
	public ProviderPropSet,
	public RatingsPropSet,
	public MPAARatingsPropSet,
	public ScheduleEntryPropSet,
	public ServicePropSet
{
public:
	CGuideDB() : m_cacheObj(128), m_cacheObjs(0)
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_fSQLServer = FALSE;

		m_pobjtypes = NULL;

		m_pobjtypeGeneric = NULL;
		m_pobjtypeGuideDataProvider = NULL;
		m_pobjtypeService = NULL;
		m_pobjtypeScheduleEntry = NULL;
		m_pobjtypeProgram = NULL;
		m_pobjtypeChannel = NULL;
		m_pobjtypeChannelLineup = NULL;

		m_hwnd = NULL;
		m_rgmsgItemEvent[Added] = NULL;
		m_rgmsgItemEvent[Removed] = NULL;
		m_rgmsgItemEvent[Changed] = NULL;

		m_iTransLevel = 0;
	}

	~CGuideDB()
		{
		if (m_hwnd != NULL)
			DestroyWindow(m_hwnd);
		}

	HRESULT GetDB(CGuideDB **ppdb)
		{
		*ppdb = this;
		return S_OK;
		}
	
	_bstr_t & get_UUID()
		{
		return m_bstrUUID;
		}

DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CGuideDB)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CGuideDB)
END_CONNECTION_POINT_MAP()


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

public:
	HRESULT CreateDB(const TCHAR *szDBName, const TCHAR *szDBFileName, const TCHAR *szConnection);
	HRESULT CreateSQLDB(const TCHAR *szDBName, const TCHAR *szDBFileName, const TCHAR *szConnection);
	HRESULT InitDB(ADOX::_Catalog *pcatalog);
	HRESULT InitSQLDB(SQLDMO::_Database *pdb);
	HRESULT OpenDB(IGuideStore *pgs, const TCHAR *szDBName);

	boolean FSQLServer()
		{
		return m_fSQLServer;
		}

	enum ItemEvent {Added = 0, Removed, Changed};
	UINT m_rgmsgItemEvent[3];
	void Broadcast_ItemEvent(enum ItemEvent ev, long idObj, long idType);
	void Broadcast_ItemAdded(long idObj, long idType)
		{
		Broadcast_ItemEvent(Added, idObj, idType);
		}
	void Broadcast_ItemRemoved(long idObj, long idType)
		{
		Broadcast_ItemEvent(Removed, idObj, idType);
		}
	void Broadcast_ItemChanged(long idObj, long idType)
		{
		Broadcast_ItemEvent(Changed, idObj, idType);
		}
	void Broadcast_ItemChanged(long idObj);
	void Broadcast_ItemsChanged(long idType)
		{
		Broadcast_ItemEvent(Changed, 0, idType);
		}
	void Fire_ItemEvent(enum ItemEvent ev, long idObj, long lExtra);
	static ATOM s_atomWindowClass;

	static LRESULT _WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
		{
		CGuideDB *pdb = (CGuideDB *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

		if (msg == WM_CREATE)
		    {
		    LPCREATESTRUCT pcreatestruct = (LPCREATESTRUCT) lparam;

		    pdb = (CGuideDB *) pcreatestruct->lpCreateParams;

		    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pdb);
		    }

		if (pdb == NULL)
			return DefWindowProc(hwnd, msg, wparam, lparam);;
		
		return pdb->WindowProc(msg, wparam, lparam);
		}

	LRESULT WindowProc(UINT msg, WPARAM wparam, LPARAM lparam)
		{
		if (msg == m_rgmsgItemEvent[Added])
			Fire_ItemEvent(Added, wparam, lparam);
		else if (msg == m_rgmsgItemEvent[Removed])
			Fire_ItemEvent(Removed, wparam, lparam);
		else if (msg == m_rgmsgItemEvent[Changed])
			Fire_ItemEvent(Changed, wparam, lparam);
		else
			return DefWindowProc(m_hwnd, msg, wparam, lparam);
		
		return 0;
		}
	
	HRESULT CreateEventSinkWindow()
		{
		if (s_atomWindowClass == NULL)
			{
			WNDCLASS wndclass;

			wndclass.style = 0;
			wndclass.lpfnWndProc = _WindowProc;
			wndclass.cbClsExtra = 0; 
			wndclass.cbWndExtra = 0; 
			wndclass.hInstance = _Module.GetModuleInstance(); 
			wndclass.hIcon = NULL; 
			wndclass.hCursor = NULL; 
			wndclass.hbrBackground = NULL; 
			wndclass.lpszMenuName = NULL; 
			wndclass.lpszClassName = _T("GuideStoreEventSink"); 

			s_atomWindowClass = RegisterClass(&wndclass);
			if (s_atomWindowClass == NULL)
				return HRESULT_FROM_WIN32(GetLastError());
			}
		
		if (m_rgmsgItemEvent[Added] == 0)
			{
			TCHAR szMsg[128];
			_bstr_t bstrUUID = get_UUID();

			wsprintf(szMsg, _T("ItemAdded(%s)"), (LPCTSTR) bstrUUID);
			m_rgmsgItemEvent[Added] = RegisterWindowMessage(szMsg);

			wsprintf(szMsg, _T("ItemRemoved(%s)"), (LPCTSTR) bstrUUID);
			m_rgmsgItemEvent[Removed] = RegisterWindowMessage(szMsg);

			wsprintf(szMsg, _T("ItemChanged(%s)"), (LPCTSTR) bstrUUID);
			m_rgmsgItemEvent[Changed] = RegisterWindowMessage(szMsg);
			}
		
		m_hwnd = CreateWindow( (LPCTSTR)(LONG_PTR)MAKELONG(s_atomWindowClass, 0),	// registered class name
								_T(""),				// window name
								WS_POPUP,			// window style
								0, 0, 0, 0,			// window size and position
								NULL,				// handle to parent or owner window
								NULL,				// menu handle or child identifier
								_Module.GetModuleInstance(),
								(LPVOID) this			// window-creation data
								);

		if (m_hwnd == NULL)
			return HRESULT_FROM_WIN32(GetLastError());

		return S_OK;
		}
	
	CComPtr<IGuideDataProvider> m_pdataprovider;

	long GetIDGuideDataProvider();
	HRESULT get_GuideDataProvider(IGuideDataProvider **ppdataprovider);
	HRESULT putref_GuideDataProvider(IGuideDataProvider *pdataprovider);

	HRESULT BeginTrans()
		{
		HRESULT hr;
		long iLevel;
		hr = m_pdb->BeginTrans(&iLevel);
		if (FAILED(hr))
			return hr;
		
		m_iTransLevel++;
		if (m_iTransLevel != iLevel)
			return E_FAIL;

		return S_OK;
		}

	HRESULT CommitTrans()
		{
		HRESULT hr;
		hr =  m_pdb->CommitTrans();
		if (FAILED(hr))
			return hr;
		//UNDONE: Fire a bulk update event.
		m_iTransLevel--;
		if (m_iTransLevel == 0)
			TransactionDone(TRUE);
		return S_OK;
		}

	HRESULT RollbackTrans()
		{
		HRESULT hr;
		hr = m_pdb->RollbackTrans();
		if (FAILED(hr))
			return hr;
		m_iTransLevel--;
		if (m_iTransLevel == 0)
			TransactionDone(FALSE);
		return S_OK;
		}
	
	void TransactionDone(boolean fCommit);

	HRESULT NewQuery(_bstr_t bstrQuery, ADODB::_Recordset **pprs)
		{
        _variant_t varDB((IDispatch *)m_pdb);
		_variant_t varQuery(bstrQuery);
        ADODB::_RecordsetPtr prs;
        HRESULT hr;
		DeclarePerfTimer("CGuideDB::NewQuery");

		PerfTimerReset();
        hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
        if (FAILED(hr))
            return hr;
        hr = prs->Open(varQuery,
             varDB, ADODB::adOpenUnspecified, ADODB::adLockPessimistic, ADODB::adCmdText);
        if (FAILED(hr))
            return hr;

        *pprs = prs;
        if (*pprs != NULL)
            (*pprs)->AddRef();
		
		PerfTimerDump("Succeeded");
        return S_OK;
		}

	HRESULT Execute(BSTR bstrCmd, VARIANT *pvarCount = NULL,
			long lOptions = ADODB::adExecuteNoRecords, ADODB::_Recordset **pprs = NULL)
		{
		HRESULT hr;
        hr = m_pdb->Execute(bstrCmd, pvarCount, lOptions, pprs);
		if (FAILED(hr))
			{
			DumpObjsCache(_T("CGuideDB::Execute() - After Fail\n"), TRUE);
			CloseRels();
			hr = m_pdb->Execute(bstrCmd, pvarCount, lOptions, pprs);
			DumpObjsCache(_T("CGuideDB::Execute() - After Retry\n"), FALSE);
			}
		return hr;
		}
	
	HRESULT get_StringsRS(ADODB::_Recordset **pprs)
		{
		*pprs = m_prsStrings;
		if (*pprs != NULL)
			(*pprs)->AddRef();
		return S_OK;
		}
	
	HRESULT get_PropSetsRS(ADODB::_Recordset **pprs)
		{
		*pprs = m_prsPropSets;
		if (*pprs != NULL)
			(*pprs)->AddRef();
		return S_OK;
		}
	
	HRESULT get_PropTypesRS(ADODB::_Recordset **pprs)
		{
		*pprs = m_prsPropTypes;
		if (*pprs != NULL)
			(*pprs)->AddRef();
		return S_OK;
		}
	
	HRESULT get_PropsRS(ADODB::_Recordset **pprs)
		{
		*pprs = m_prsProps;
		if (*pprs != NULL)
			(*pprs)->AddRef();
		return S_OK;
		}

	HRESULT get_PropsIndexed(ADODB::_Recordset **pprs)
		{
		*pprs = m_prsPropsIndexed;

		if (*pprs != NULL)
			(*pprs)->AddRef();
		return S_OK;
		}
	
	HRESULT get_ObjTypesRS(ADODB::_Recordset **pprs)
		{
		*pprs = m_prsObjTypes;
		if (*pprs != NULL)
			(*pprs)->AddRef();
		return S_OK;
		}
	
	void RequeryObjectsTables()
		{
		m_prsObjs = NULL;
		m_prsObjsByID = NULL;
		m_prsObjsByType = NULL;
		}
	HRESULT get_ObjsRS(ADODB::_Recordset **pprs);
	HRESULT get_ObjsByType(ADODB::_Recordset **pprs);
	HRESULT get_ObjsByID(ADODB::_Recordset **pprs);

	HRESULT get_RelsByID1Rel(ADODB::_Recordset **pprs);
	HRESULT get_RelsByID2Rel(ADODB::_Recordset **pprs);
	void CloseRels()
		{
		if (m_prsRelsByID1Rel != NULL)
			m_prsRelsByID1Rel.Release();
		if (m_prsRelsByID2Rel != NULL)
			m_prsRelsByID2Rel.Release();
		}
	
	HRESULT get_MetaPropertySet(BSTR bstrName, IMetaPropertySet **pppropset)
		{
		return m_ppropsets->get_AddNew(bstrName, pppropset);
		}

	HRESULT get_MetaPropertyType(BSTR bstrName, IMetaPropertyType **ppproptype)
		{
		if (m_ppropsets == NULL)
			return E_INVALIDARG;
		
		return m_ppropsets->get_Lookup(bstrName, ppproptype);
		}
	HRESULT get_MetaPropertyType(long idPropType, IMetaPropertyType **ppproptype);
	HRESULT put_MetaPropertyType(long idPropType, IMetaPropertyType *pproptype);

	HRESULT SaveObject(IUnknown *punk, long *pid);

	void DumpObjsCache(const TCHAR *psz, boolean fPurge);
	HRESULT CacheCollection(IObjects *pobjs)
		{
		return m_cacheObjs.Cache((LONG_PTR)pobjs, pobjs);
		}

	HRESULT CacheObject(long idObj, long idObjType, IUnknown **ppobj);
	HRESULT CacheObject(long idObj, CObjectType *pobjtype, IUnknown **ppobj);
	HRESULT UncacheObject(long idObj);
	HRESULT get_Object(long idObj, IUnknown **ppobj);
	HRESULT get_IdOf(IUnknown *pobj, long *pid);
	HRESULT get_MetaPropertiesOf(long id, IMetaProperties **ppprops);
	STDMETHOD(get_MetaPropertiesOf)(/*[in]*/ IUnknown *punk, /*[out, retval]*/ IMetaProperties **ppprops)
		{
		ENTER_API
			{
			long idObj;
			HRESULT hr;

			hr = get_IdOf(punk, &idObj);
			if (FAILED(hr))
				return hr;
			
			return get_MetaPropertiesOf(idObj, ppprops);
			}
		LEAVE_API
		}

	HRESULT get_ObjectsWithType(long idType, IObjects **ppobjs);
	HRESULT get_ObjectsWithType(CObjectType *pobjtype, IObjects **ppobjs);
	HRESULT get_ObjectsWithType(CLSID clsid, IObjects **ppobjs)
		{
		CObjectType *pobjtype;

		get_ObjectType(clsid, &pobjtype);

		return get_ObjectsWithType(pobjtype, ppobjs);
		}

	HRESULT get_ObjectType(long idObjType, CObjectType **ppobjtype);
	HRESULT put_ObjectType(long idObjType, CObjectType *pobjtype);

	HRESULT get_ObjectTypes(CObjectTypes **ppobjtypes);
	HRESULT get_ObjectType(BSTR bstrCLSID, CObjectType **ppobjtype);
	HRESULT get_ObjectType(CLSID clsid, CObjectType **ppobjtype);

	HRESULT get_GenericObjectType(CObjectType **ppobjtype)
		{
		HRESULT hr;

		if (m_pobjtypeGeneric == NULL)
			{
			hr = get_ObjectType(__uuidof(IUnknown), &m_pobjtypeGeneric);
			if (FAILED(hr))
				return hr;
			}

		if ((*ppobjtype = m_pobjtypeGeneric) == NULL)
			return E_FAIL;

		return S_OK;
		}

	HRESULT get_GuideDataProviderObjectType(CObjectType **ppobjtype)
		{
		HRESULT hr;

		if (m_pobjtypeGuideDataProvider == NULL)
			{
			hr = get_ObjectType(CLSID_GuideDataProvider, &m_pobjtypeGuideDataProvider);
			if (FAILED(hr))
				return hr;
			}

		if ((*ppobjtype = m_pobjtypeGuideDataProvider) == NULL)
			return E_FAIL;

		return S_OK;
		}

	HRESULT get_ServiceObjectType(CObjectType **ppobjtype)
		{
		HRESULT hr;

		if (m_pobjtypeService == NULL)
			{
			hr = get_ObjectType(CLSID_Service, &m_pobjtypeService);
			if (FAILED(hr))
				return hr;
			}

		if ((*ppobjtype = m_pobjtypeService) == NULL)
			return E_FAIL;

		return S_OK;
		}

	HRESULT get_ProgramObjectType(CObjectType **ppobjtype)
		{
		HRESULT hr;

		if (m_pobjtypeProgram == NULL)
			{
			hr = get_ObjectType(CLSID_Program, &m_pobjtypeProgram);
			if (FAILED(hr))
				return hr;
			}

		if ((*ppobjtype = m_pobjtypeProgram) == NULL)
			return E_FAIL;

		return S_OK;
		}

	HRESULT get_ScheduleEntryObjectType(CObjectType **ppobjtype)
		{
		HRESULT hr;

		if (m_pobjtypeScheduleEntry == NULL)
			{
			hr = get_ObjectType(CLSID_ScheduleEntry, &m_pobjtypeScheduleEntry);
			if (FAILED(hr))
				return hr;
			}

		if ((*ppobjtype = m_pobjtypeScheduleEntry) == NULL)
			return E_FAIL;

		return S_OK;
		}

	HRESULT get_ChannelObjectType(CObjectType **ppobjtype)
		{
		HRESULT hr;

		if (m_pobjtypeChannel == NULL)
			{
			hr = get_ObjectType(CLSID_Channel, &m_pobjtypeChannel);
			if (FAILED(hr))
				return hr;
			}

		if ((*ppobjtype = m_pobjtypeChannel) == NULL)
			return E_FAIL;

		return S_OK;
		}

	HRESULT get_ChannelLineupObjectType(CObjectType **ppobjtype)
		{
		HRESULT hr;

		if (m_pobjtypeChannelLineup == NULL)
			{
			hr = get_ObjectType(CLSID_ChannelLineup, &m_pobjtypeChannelLineup);
			if (FAILED(hr))
				return hr;
			}

		if ((*ppobjtype = m_pobjtypeChannelLineup) == NULL)
			return E_FAIL;

		return S_OK;
		}
	
	long ObjectCount()
		{
		return m_cacheObj.Count();
		}
	
	IUnknown * Object(long i)
		{
		return m_cacheObj.Item(i);
		}
	
	long CachedObjectCount()
		{
		return m_cacheObj.CachedCount();
		}
	
	HRESULT PurgeCachedObjects()
		{
		m_cacheObj.Keep(0);
		m_cacheObj.Keep(128);
		return S_OK;
		}
	CComObjectCacheByID  & CacheObjs() { return m_cacheObjs; }


protected:
	CComPtr<IMetaPropertySets> m_ppropsets;
	ADODB::_ConnectionPtr m_pdb;
	boolean m_fSQLServer;
	ADODB::_RecordsetPtr m_prsStrings;
	ADODB::_RecordsetPtr m_prsPropSets;
	ADODB::_RecordsetPtr m_prsPropTypes;
	ADODB::_RecordsetPtr m_prsProps;
	ADODB::_RecordsetPtr m_prsPropsIndexed;
	ADODB::_RecordsetPtr m_prsObjTypes;
	ADODB::_RecordsetPtr m_prsObjs;
	ADODB::_RecordsetPtr m_prsObjsByType;
	ADODB::_RecordsetPtr m_prsObjsByID;
	ADODB::_RecordsetPtr m_prsRelsByID1Rel;
	ADODB::_RecordsetPtr m_prsRelsByID2Rel;

	typedef map<long, IMetaPropertyType *> t_mapPropTypes;
	t_mapPropTypes m_mapPropTypes;

	CComObjectCacheByID m_cacheObj;
	CComObjectCacheByID m_cacheObjs;

	typedef map<long, IMetaProperties *> t_mapIdProps;
	t_mapIdProps m_mapIdProps;

	typedef map<long, IObjects *> t_mapObjsWithType;
	t_mapObjsWithType m_mapObjsWithType;

	typedef map<long, CObjectType *> t_mapObjTypes;
	t_mapObjTypes m_mapObjTypes;

	CObjectTypes *m_pobjtypes;

	CObjectType *m_pobjtypeGeneric;
	CObjectType *m_pobjtypeGuideDataProvider;
	CObjectType *m_pobjtypeService;
	CObjectType *m_pobjtypeScheduleEntry;
	CObjectType *m_pobjtypeProgram;
	CObjectType *m_pobjtypeChannel;
	CObjectType *m_pobjtypeChannelLineup;

	_bstr_t m_bstrUUID;

	HWND m_hwnd;
	long m_iTransLevel;
};

ATOM __declspec(selectany) CGuideDB::s_atomWindowClass = NULL;

#endif //__GUIDEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidestore.cpp ===
// GuideStore.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for GuideStore.idl by adding the following 
//      files to the Outputs.
//          GuideStore_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f GuideStoreps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "dlldatax.h"

#include <mstvgs_i.c>
#include "Property.h"
#include "GuideStore2.h"
#include "Service.h"
#include "Program.h"
#include "ScheduleEntry.h"
#include "Channel.h"
#include "object.h"
#include "GuideDataProvider.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
#if 0
OBJECT_ENTRY(CLSID_MetaPropertySet, CMetaPropertySet)
OBJECT_ENTRY(CLSID_MetaPropertySets, CMetaPropertySets)
OBJECT_ENTRY(CLSID_MetaPropertyType, CMetaPropertyType)
OBJECT_ENTRY(CLSID_MetaPropertyTypes, CMetaPropertyTypes)
OBJECT_ENTRY(CLSID_MetaProperty, CMetaProperty)
OBJECT_ENTRY(CLSID_MetaProperties, CMetaProperties)
OBJECT_ENTRY(CLSID_MetaPropertyCondition, CMetaPropertyCondition)
OBJECT_ENTRY(CLSID_GuideStore, CGuideStore)
OBJECT_ENTRY(CLSID_Service, CService)
OBJECT_ENTRY(CLSID_Services, CServices)
OBJECT_ENTRY(CLSID_Program, CProgram)
OBJECT_ENTRY(CLSID_Programs, CPrograms)
OBJECT_ENTRY(CLSID_ScheduleEntry, CScheduleEntry)
OBJECT_ENTRY(CLSID_ScheduleEntries, CScheduleEntries)
OBJECT_ENTRY(CLSID_Channel, CChannel)
OBJECT_ENTRY(CLSID_Channels, CChannels)
OBJECT_ENTRY(CLSID_ChannelLineup, CChannelLineup)
OBJECT_ENTRY(CLSID_ChannelLineups, CChannelLineups)
OBJECT_ENTRY(CLSID_Object, CObject)
OBJECT_ENTRY(CLSID_ObjectType, CObjectType)
OBJECT_ENTRY(CLSID_Objects, CObjects)
OBJECT_ENTRY(CLSID_ObjectTypes, CObjectTypes)
OBJECT_ENTRY(CLSID_TestTuneRequest, CTestTuneRequest)
OBJECT_ENTRY(CLSID_GuideDataProvider, CGuideDataProvider)
OBJECT_ENTRY(CLSID_GuideDataProviders, CGuideDataProviders)
#else
OBJECT_ENTRY(CLSID_GuideStore, CGuideStore)
OBJECT_ENTRY(CLSID_Objects, CObjects)
OBJECT_ENTRY(CLSID_Service, CService)
OBJECT_ENTRY(CLSID_Services, CServices)
OBJECT_ENTRY(CLSID_Program, CProgram)
OBJECT_ENTRY(CLSID_Programs, CPrograms)
OBJECT_ENTRY(CLSID_ScheduleEntry, CScheduleEntry)
OBJECT_ENTRY(CLSID_ScheduleEntries, CScheduleEntries)
OBJECT_ENTRY(CLSID_Channel, CChannel)
OBJECT_ENTRY(CLSID_Channels, CChannels)
OBJECT_ENTRY(CLSID_ChannelLineup, CChannelLineup)
OBJECT_ENTRY(CLSID_ChannelLineups, CChannelLineups)
OBJECT_ENTRY(CLSID_GuideDataProvider, CGuideDataProvider)
OBJECT_ENTRY(CLSID_GuideDataProviders, CGuideDataProviders)
#endif
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_GUIDESTORELib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidestore2.cpp ===
// GuideStore2.cpp : Implementation of CGuideStore
#include "stdafx.h"
#include "GuideStore2.h"
#include "Property.h"
#include "Service.h"
#include "Program.h"
#include "ScheduleEntry.h"

/////////////////////////////////////////////////////////////////////////////
// CGuideStore

HRESULT CGuideStore::OpenDB(const TCHAR *szDBName)
{
	HRESULT hr = E_FAIL;

	if (m_pdb == NULL)
		{
		m_pdb = NewComObject(CGuideDB);

		if (m_pdb == NULL)
			return E_OUTOFMEMORY;
		}

	hr = m_pdb->OpenDB(this, szDBName);

	return hr;
}

STDMETHODIMP CGuideStore::get_Objects(IObjects **ppobjs)
{
ENTER_API
	{
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	if (m_pobjs == NULL)
		{
		HRESULT hr;
		
		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(__uuidof(IUnknown), &pobjs);
		if (FAILED(hr))
			return hr;

		m_pobjs = pobjs;
		}
	
	*ppobjs = m_pobjs;
	if (*ppobjs != NULL)
		(*ppobjs)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_ActiveGuideDataProvider(IGuideDataProvider **ppdataprovider)
{
ENTER_API
	{
	ValidateOutPtr<IGuideDataProvider>(ppdataprovider, NULL);

	return m_pdb->get_GuideDataProvider(ppdataprovider);
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::putref_ActiveGuideDataProvider(IGuideDataProvider *pdataprovider)
{
ENTER_API
	{
	ValidateInPtr_NULL_OK<IGuideDataProvider>(pdataprovider);

	return m_pdb->putref_GuideDataProvider(pdataprovider);
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_GuideDataProviders(IGuideDataProviders **ppdataproviders)
{
ENTER_API
	{
	ValidateOutPtr<IGuideDataProviders>(ppdataproviders, NULL);

	if (m_pdataproviders == NULL)
		{
		HRESULT hr;

		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(CLSID_GuideDataProvider, &pobjs);
		if (FAILED(hr))
			return hr;

		hr = pobjs->QueryInterface(__uuidof(IGuideDataProviders), (void **)&m_pdataproviders);
		if (FAILED(hr))
			return hr;
		}
	
	(*ppdataproviders = m_pdataproviders)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_Services(IServices **ppservices)
{
ENTER_API
	{
	ValidateOutPtr<IServices>(ppservices, NULL);

	if (m_pservices == NULL)
		{
		HRESULT hr;

		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(CLSID_Service, &pobjs);
		if (FAILED(hr))
			return hr;

		hr = pobjs->QueryInterface(__uuidof(IServices), (void **)&m_pservices);
		if (FAILED(hr))
			return hr;
		}
	
	(*ppservices = m_pservices)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_Programs(IPrograms **ppprograms)
{
ENTER_API
	{
	ValidateOutPtr<IPrograms>(ppprograms, NULL);

	if (m_pprograms == NULL)
		{
		HRESULT hr;

		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(CLSID_Program, &pobjs);
		if (FAILED(hr))
			return hr;

		hr = pobjs->QueryInterface(__uuidof(IPrograms), (void **)&m_pprograms);
		if (FAILED(hr))
			return hr;
		}
	
	(*ppprograms = m_pprograms)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_ScheduleEntries(IScheduleEntries **ppschedentries)
{
ENTER_API
	{
	ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

	if (m_pschedentries == NULL)
		{
		HRESULT hr;

		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(CLSID_ScheduleEntry, &pobjs);
		if (FAILED(hr))
			return hr;

		hr = pobjs->QueryInterface(__uuidof(IScheduleEntries), (void **)&m_pschedentries);
		if (FAILED(hr))
			return hr;
		}
	
	(*ppschedentries = m_pschedentries)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_ChannelLineups(IChannelLineups **ppchanlineups)
{
ENTER_API
	{
	ValidateOutPtr<IChannelLineups>(ppchanlineups, NULL);

	CComPtr<IServices> pservices;
	HRESULT hr;

	hr = get_Services(&pservices);
	if (FAILED(hr))
		return hr;
	
	return pservices->get_ChannelLineups(ppchanlineups);
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_Channels(IChannels **ppchans)
{
ENTER_API
	{
	ValidateOutPtr<IChannels>(ppchans, NULL);

	if (m_pchans == NULL)
		{
		HRESULT hr;

		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(CLSID_Channel, &pobjs);
		if (FAILED(hr))
			return hr;

		hr = pobjs->QueryInterface(__uuidof(IChannels), (void **)&m_pchans);
		if (FAILED(hr))
			return hr;
		}
	
	(*ppchans = m_pchans)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::get_MetaPropertySets(IMetaPropertySets **pppropsets)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertySets>(pppropsets, NULL);

	if (m_ppropsets == NULL)
		{
		CComPtr<CMetaPropertySets> ppropsets = NewComObject(CMetaPropertySets);

		if (ppropsets == NULL)
			return E_OUTOFMEMORY;
		
		if (m_pdb == NULL)
			return E_FAIL;

		ppropsets->Init(m_pdb);
		ppropsets->Load();
		
		m_ppropsets = ppropsets;
		}
	
	(*pppropsets = m_ppropsets)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CGuideStore::Open(BSTR bstrNameIn)
{
ENTER_API
	{
	ValidateIn(bstrNameIn);
	_bstr_t bstrName(bstrNameIn);
	
	// Name is NULL... look in the registry for the default file.
	if (bstrName.length() == 0)
		{
		HKEY hkey;
		long lErr;
		lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\GuideStore"),
				0, KEY_READ, &hkey);

		if (lErr == ERROR_SUCCESS)
			{
			OLECHAR szPath[MAX_PATH];
			DWORD cb = sizeof(szPath);
			DWORD regtype;
			lErr = RegQueryValueEx(hkey, _T("Path"), 0, &regtype, (LPBYTE) szPath, &cb);
			RegCloseKey(hkey);
			if ((lErr == ERROR_SUCCESS) && (regtype == REG_SZ))
				bstrName = szPath;
			}
		}
	
	// Name not found in the registry... use default location
	if (bstrName.length() == 0)
		{
		HKEY hkey;
		long lErr;
		lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				_T("Software\\Microsoft\\Windows\\CurrentVersion"),
				0, KEY_READ, &hkey);

		if (lErr != ERROR_SUCCESS)
			return E_FAIL;

		OLECHAR szPath[MAX_PATH];
		DWORD cb = sizeof(szPath);
		DWORD regtype;
		lErr = RegQueryValueEx(hkey, _T("MediaPath"), 0, &regtype, (LPBYTE) szPath, &cb);
		RegCloseKey(hkey);
		if ((lErr != ERROR_SUCCESS) || (regtype != REG_SZ))
			GetSystemDirectoryW(szPath, cb);

		wcscat(szPath, L"\\guidestore.mgs");
		bstrName = szPath;
		}

	HRESULT hr;

	hr = OpenDB(bstrName);
	if (FAILED(hr))
		return hr;

	// Make sure the property sets are all loaded.
	CComPtr<IMetaPropertySets> ppropsets;
	get_MetaPropertySets(&ppropsets);

	// Make sure the object types are all loaded.
	CObjectTypes *pobjtypes;
	m_pdb->get_ObjectTypes(&pobjtypes);

	return S_OK;
	}
LEAVE_API
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidestore2.h ===
// GuideStore2.h : Declaration of the CGuideStore

#ifndef __GUIDESTORE2_H_
#define __GUIDESTORE2_H_

#include "resource.h"       // main symbols
#include "property.h"
#include "Service.h"
#include "Program.h"
#include "ScheduleEntry.h"
#include "GuideDataProvider.h"
#include "object.h"
#include "GuideDB.h"

class CGuideStore;

/////////////////////////////////////////////////////////////////////////////
// CGuideStore
class ATL_NO_VTABLE CGuideStore : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CGuideStore, &CLSID_GuideStore>,
	public IConnectionPointContainerImpl<CGuideStore>,
	public IDispatchImpl<IGuideStore, &IID_IGuideStore, &LIBID_GUIDESTORELib>,
	public IGuideStoreInternal
{
public:
	CGuideStore()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_pobjs = NULL;
		m_pdb = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_GUIDESTORE)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CGuideStore)
	COM_INTERFACE_ENTRY(IGuideStore)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
	COM_INTERFACE_ENTRY(IGuideStoreInternal)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CGuideStore)
END_CONNECTION_POINT_MAP()


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
		{
		m_pUnkMarshaler.Release();
		}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	HRESULT OpenDB(const TCHAR *szDBName);

// IGuideStoreInternal
	STDMETHOD(get_ObjectCount)(/*[out, retval] */ long *plCount)
		{
		ENTER_API
			{
			ValidateOut<long>(plCount);

			*plCount = m_pdb->ObjectCount();
			return S_OK;
			}
		LEAVE_API
		}
	STDMETHOD(get_Object)(/* [in] */ long iObject, /*[out, retval] */ IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk);

			*ppunk = m_pdb->Object(iObject);
			return S_OK;
			}
		LEAVE_API
		}
	STDMETHOD(get_CachedObjectCount)(/*[out, retval] */ long *plCount)
		{
		ENTER_API
			{
			*plCount = m_pdb->CachedObjectCount();
			return S_OK;
			}
		LEAVE_API
		}
	STDMETHOD(PurgeCachedObjects)()
		{
		ENTER_API
			{
			return m_pdb->PurgeCachedObjects();
			}
		LEAVE_API
		}

// IGuideStore
public:
	STDMETHOD(BeginTrans)()
		{
		return m_pdb->BeginTrans();
		}
	STDMETHOD(CommitTrans)()
		{
		return m_pdb->CommitTrans();
		}
	STDMETHOD(RollbackTrans)()
		{
		return m_pdb->RollbackTrans();
		}
	STDMETHOD(get_UUID)(/* [out, retval] */ BSTR *pbstrUUID)
		{
		ENTER_API
			{
			ValidateOut(pbstrUUID);

			*pbstrUUID = m_pdb->get_UUID().copy();

			return S_OK;
			}
		LEAVE_API
		}

	STDMETHOD(get_IdOf)(/*[in]*/ IUnknown *punk, /*[out, retval]*/ long *pid)
		{
		ENTER_API
			{
			return m_pdb->get_IdOf(punk, pid);
			}
		LEAVE_API
		}
	STDMETHOD(get_MetaPropertiesOf)(/*[in]*/ IUnknown *punk, /*[out, retval]*/ IMetaProperties **ppprops)
		{
		ENTER_API
			{
			return m_pdb->get_MetaPropertiesOf(punk, ppprops);
			}
		LEAVE_API
		}
	
	STDMETHOD(get_ActiveGuideDataProvider)(/*[out, retval]*/ IGuideDataProvider * *pVal);
	STDMETHOD(putref_ActiveGuideDataProvider)(/*[in]*/ IGuideDataProvider * newVal);
	STDMETHOD(get_Channels)(/*[out, retval]*/ IChannels * *pVal);
	STDMETHOD(get_ChannelLineups)(/*[out, retval]*/ IChannelLineups * *pVal);
	STDMETHOD(get_Objects)(/*[out, retval]*/ IObjects * *pVal);
	STDMETHOD(Open)(BSTR bstrName);
	STDMETHOD(get_MetaPropertySets)(/*[out, retval]*/ IMetaPropertySets **pppropsets);
	STDMETHOD(get_ScheduleEntries)(/*[out, retval]*/ IScheduleEntries * *pVal);
	STDMETHOD(get_Programs)(/*[out, retval]*/ IPrograms * *pVal);
	STDMETHOD(get_Services)(/*[out, retval]*/ IServices * *pVal);
	STDMETHOD(get_GuideDataProviders)(/*[out, retval]*/ IGuideDataProviders * *pVal);

protected:
	CComPtr<IObjects> m_pobjs;
	CComPtr<IGuideDataProviders> m_pdataproviders;
	CComPtr<IServices> m_pservices;
	CComPtr<IPrograms> m_pprograms;
	CComPtr<IChannels> m_pchans;
	CComPtr<IScheduleEntries>  m_pschedentries;
	CComPtr<CMetaPropertySets> m_ppropsets;

	CComPtr<CGuideDB> m_pdb;
};

#endif //__GUIDESTORE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidedb.cpp ===
// GuideDB.cpp : Implementation of CGuideDB
#include "stdafx.h"
#include "GuideDB.h"
#include "object.h"
#include "GuideDataProvider.h"

/////////////////////////////////////////////////////////////////////////////
// CGuideDB

const TCHAR *g_szConnection =
	_T("Provider=Microsoft.Jet.OLEDB.4.0;")
	_T("Data Source=\"%s\";")
	_T("Password=\"\";")
	_T("User ID=Admin;")
	_T("Mode=Share Deny None;")
	_T("Extended Properties=\"\";")
	_T("Jet OLEDB:System database=\"\";")
	_T("Jet OLEDB:Registry Path=\"\";")
	_T("Jet OLEDB:Database Password=\"\";")
	_T("Jet OLEDB:Engine Type=5;")
	_T("Jet OLEDB:Database Locking Mode=1;")
	_T("Jet OLEDB:Global Partial Bulk Ops=2;")
	_T("Jet OLEDB:Global Bulk Transactions=1;")
	_T("Jet OLEDB:New Database Password=\"\";")
	_T("Jet OLEDB:Create System Database=False;")
	_T("Jet OLEDB:Encrypt Database=False;")
	_T("Jet OLEDB:Don't Copy Locale on Compact=False;")
	_T("Jet OLEDB:Compact Without Replica Repair=False;")
	_T("Jet OLEDB:SFP=False")
	;

const TCHAR *g_szConnectionSQL =
	_T("Provider=SQLOLEDB;")
	// _T("DRIVER=SQL Server;")
	// _T("UID=leeac;")
	_T("SERVER=(local);")
	_T("DATABASE=%s;")
	_T("Trusted_Connection=Yes;")
	// _T("WSID=LEEAC;")
	// _T("APP=Microsoft Open Database Connectivity;")
	;

const _bstr_t g_bstrDBUser(_T("Admin"));
const _bstr_t g_bstrDBPassword(_T(""));
const _variant_t g_varPropertySets(_T("PropertySets"));
const _variant_t g_varStrings(_T("Strings"));

const _variant_t g_varPropertyTypes(_T("PropertyTypes"));
const _variant_t g_varProperties(_T("Properties"));
const _variant_t g_varObjectTypes(_T("ObjectTypes"));
const _variant_t g_varObjects(_T("Objects"));

const _bstr_t g_bstrIDType(_T("idType"));
const _variant_t g_varObjectRelationships(_T("ObjectRelationships"));
const _bstr_t g_bstrIDObj1(_T("idObj1"));
const _bstr_t g_bstrIDObj2(_T("idObj2"));
const _bstr_t g_bstrIDObj1Rel(_T("idObj1Rel"));
const _bstr_t g_bstrIDObj2Rel(_T("idObj2Rel"));
const _bstr_t g_bstrValue(_T("Value"));

class ColumnDesc
{
public:
	const TCHAR *m_szName;
	ADOX::DataTypeEnum m_type;
	long m_size;
	bool m_fAutoIncrement;
	bool m_fAllowNulls;
};

class IndexDesc
{
public:
	const TCHAR *m_szName;
	boolean m_fUnique;
	int m_cColumns;
	ColumnDesc **m_rgpcolumndesc;
};
#define IndexDescInit(b, n, fUnique) {_T(#n), fUnique, sizeofarray(g_rgpcolumndesc##b##_##n), g_rgpcolumndesc##b##_##n}
#define PrimaryKeyInit(b, n) {_T("PK_") _T(#b), TRUE, sizeofarray(g_rgpcolumndesc##b##_##n), g_rgpcolumndesc##b##_##n}

class TableDesc
{
public:
	const TCHAR *m_szName;
	IndexDesc *m_pindexdescPrimary;
	ColumnDesc *m_rgcolumndesc;
	IndexDesc *m_rgindexdesc;
};

#define TableDescInit(n) \
	{_T(#n), &g_indexdescPrimaryKey##n, g_rgcolumndesc##n, g_rgindexdesc##n}
#define TableDescInit_NoPrimaryKey(n) \
	{_T(#n), NULL, g_rgcolumndesc##n, g_rgindexdesc##n}

ColumnDesc g_rgcolumndescObjectTypes[] =
{
	{_T("id"), ADOX::adInteger, 0, TRUE, FALSE},
	{_T("clsid"), ADOX::adVarWChar, 255, FALSE, FALSE},
	{NULL}
};

ColumnDesc *g_rgpcolumndescObjectTypes_id[] =
{
	g_rgcolumndescObjectTypes + 0,
};

ColumnDesc *g_rgpcolumndescObjectTypes_clsid[] =
{
	g_rgcolumndescObjectTypes + 1,
};

IndexDesc g_indexdescPrimaryKeyObjectTypes =
	PrimaryKeyInit(ObjectTypes, id);

IndexDesc g_rgindexdescObjectTypes[] =
{
	IndexDescInit(ObjectTypes, clsid, TRUE),
	{NULL}
};

ColumnDesc g_rgcolumndescObjects[] =
{
	{_T("id"), ADOX::adInteger, 0, TRUE, FALSE},
	{_T("idtype"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("oValue"), ADOX::adLongVarBinary, 0, FALSE, TRUE},
	{NULL}
};

ColumnDesc *g_rgpcolumndescObjects_id[] =
{
	g_rgcolumndescObjects + 0,
};

ColumnDesc *g_rgpcolumndescObjects_idType[] =
{
	g_rgcolumndescObjects + 1,
};

IndexDesc g_indexdescPrimaryKeyObjects =
	PrimaryKeyInit(Objects, id);

IndexDesc g_rgindexdescObjects[] =
{
	IndexDescInit(Objects, idType, FALSE),
	{NULL}
};

ColumnDesc g_rgcolumndescObjectRelationships[] =
{
	{_T("idObj1"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("idRel"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("order"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("idObj2"), ADOX::adInteger, 0, FALSE, FALSE},
	{NULL}
};

ColumnDesc *g_rgpcolumndescObjectRelationships_idObj1Rel[] =
{
	g_rgcolumndescObjectRelationships + 0,
	g_rgcolumndescObjectRelationships + 1,
	g_rgcolumndescObjectRelationships + 2,
};

ColumnDesc *g_rgpcolumndescObjectRelationships_idObj2Rel[] =
{
	g_rgcolumndescObjectRelationships + 3,
	g_rgcolumndescObjectRelationships + 1,
	g_rgcolumndescObjectRelationships + 2,
};

IndexDesc g_rgindexdescObjectRelationships[] =
{
	IndexDescInit(ObjectRelationships, idObj1Rel, FALSE),
	IndexDescInit(ObjectRelationships, idObj2Rel, FALSE),
	{NULL}
};

ColumnDesc g_rgcolumndescPropertySets[] =
{
	{_T("id"), ADOX::adInteger, 0, TRUE, FALSE},
	{_T("Name"), ADOX::adVarWChar, 255, FALSE, FALSE},
	{NULL}
};

ColumnDesc *g_rgpcolumndescPropertySets_id[] =
{
	g_rgcolumndescPropertySets + 0,
};

ColumnDesc *g_rgpcolumndescPropertySets_Name[] =
{
	g_rgcolumndescPropertySets + 1,
};

IndexDesc g_indexdescPrimaryKeyPropertySets =
	PrimaryKeyInit(PropertySets, id);

IndexDesc g_rgindexdescPropertySets[] =
{
	IndexDescInit(PropertySets, Name, TRUE),
	{NULL}
};

ColumnDesc g_rgcolumndescPropertyTypes[] =
{
	{_T("id"), ADOX::adInteger, 0, TRUE, FALSE},
	{_T("idPropSet"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("idProp"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("Name"), ADOX::adVarWChar, 255, FALSE, FALSE},
	{NULL}
};

ColumnDesc *g_rgpcolumndescPropertyTypes_id[] =
{
	g_rgcolumndescPropertyTypes + 0,
};

ColumnDesc *g_rgpcolumndescPropertyTypes_idPropSet[] =
{
	g_rgcolumndescPropertyTypes + 1,
};

ColumnDesc *g_rgpcolumndescPropertyTypes_idPropSetidProp[] =
{
	g_rgcolumndescPropertyTypes + 1,
	g_rgcolumndescPropertyTypes + 2,
};

ColumnDesc *g_rgpcolumndescPropertyTypes_idPropSetName[] =
{
	g_rgcolumndescPropertyTypes + 1,
	g_rgcolumndescPropertyTypes + 3,
};

IndexDesc g_indexdescPrimaryKeyPropertyTypes =
	PrimaryKeyInit(PropertyTypes, id);

IndexDesc g_rgindexdescPropertyTypes[] =
{
	IndexDescInit(PropertyTypes, idPropSet, FALSE),
	IndexDescInit(PropertyTypes, idPropSetidProp, FALSE),
	IndexDescInit(PropertyTypes, idPropSetName, TRUE),
	{NULL}
};

ColumnDesc g_rgcolumndescProperties[] =
{
	{_T("idObj"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("idPropType"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("idProvider"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("idLanguage"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("ValueType"), ADOX::adInteger, 0, FALSE, FALSE},
	{_T("lValue"), ADOX::adInteger, 0, FALSE, TRUE},
	{_T("sValue"), ADOX::adLongVarWChar, 0, FALSE, TRUE},
	{_T("fValue"), ADOX::adDouble, 0, FALSE, TRUE},
	{NULL}
};

ColumnDesc *g_rgpcolumndescProperties_PrimaryKey[] =
{
	g_rgcolumndescProperties + 0,
	g_rgcolumndescProperties + 1,
	g_rgcolumndescProperties + 2,
	g_rgcolumndescProperties + 3,
};

IndexDesc g_indexdescPrimaryKeyProperties =
	PrimaryKeyInit(Properties, PrimaryKey);

IndexDesc g_rgindexdescProperties[] =
{
	{NULL}
};

ColumnDesc g_rgcolumndescStrings[] =
{
	{_T("id"), ADOX::adInteger, 0, TRUE, FALSE},
	{_T("Value"), ADOX::adVarWChar, 255, FALSE, FALSE},
	{NULL}
};

ColumnDesc *g_rgpcolumndescStrings_PrimaryKey[] =
{
	g_rgcolumndescStrings + 0,
};

IndexDesc g_indexdescPrimaryKeyStrings =
	PrimaryKeyInit(Strings, PrimaryKey);

ColumnDesc *g_rgpcolumndescStrings_Value[] =
{
	g_rgcolumndescStrings + 1,
};

IndexDesc g_rgindexdescStrings[] =
{
	IndexDescInit(Strings, Value, FALSE),
	{NULL}
};

TableDesc g_rgtabledesc[] =
{
	TableDescInit(ObjectTypes),
	TableDescInit(Objects),
	TableDescInit_NoPrimaryKey(ObjectRelationships),
	TableDescInit(PropertySets),
	TableDescInit(PropertyTypes),
	TableDescInit(Properties),
	TableDescInit(Strings),
	{NULL}
};


HRESULT CGuideDB::CreateDB(const TCHAR *szDBName, const TCHAR *szDBFileName,
		const TCHAR *szConnection)
{
	if (m_fSQLServer)
		return CreateSQLDB(szDBName, szDBFileName, szConnection);

	HRESULT hr;
	ADOX::_CatalogPtr pcatalog;

	hr = pcatalog.CreateInstance(__uuidof(ADOX::Catalog));
	if (FAILED(hr))
		return hr;
	
	_variant_t varConnection;
	
	hr = pcatalog->Create(_bstr_t(szConnection), &varConnection);
	if (FAILED(hr))
		return hr;
	
	return InitDB(pcatalog);
}

HRESULT CGuideDB::CreateSQLDB(const TCHAR *szDBName, const TCHAR *szDBFileName,
		const TCHAR *szConnection)
{
	HRESULT hr = E_FAIL;

    SQLDMO::_SQLServerPtr pSQLServer;

	hr = pSQLServer.CreateInstance(__uuidof(SQLDMO::SQLServer));
	if (FAILED(hr))
		return hr;

	hr = pSQLServer->put_LoginTimeout(10);
	if (FAILED(hr))
		return hr;

	hr = pSQLServer->put_LoginSecure(TRUE);
	if (FAILED(hr))
		return hr;

	hr = pSQLServer->put_ApplicationName(_bstr_t(_T("GuideStore")));
	if (FAILED(hr))
		return hr;


	hr = pSQLServer->Connect(_variant_t(_T(".")), _variant_t(_T("")), _variant_t(_T("")));
	if (FAILED(hr))
		return hr;

	SQLDMO::DatabasesPtr pdbs;

	hr = pSQLServer->get_Databases(&pdbs);

	SQLDMO::_DatabasePtr pdb;

	hr = pdb.CreateInstance(__uuidof(SQLDMO::Database));

	hr = pdb->put_Name(_bstr_t(szDBName));

	SQLDMO::_DBFilePtr pdbfile;

	hr = pdbfile.CreateInstance(__uuidof(SQLDMO::DBFile));

	hr = pdbfile->put_PhysicalName(_bstr_t(szDBFileName));

	hr = pdbfile->put_Name(_bstr_t(szDBName));

	hr = pdbfile->put_PrimaryFile(TRUE);

	SQLDMO::FileGroupsPtr pfilegroups;
	SQLDMO::_FileGroupPtr pfilegroup;
	SQLDMO::DBFilesPtr pdbfiles;

	hr = pdb->get_FileGroups(&pfilegroups);
	hr = pfilegroups->Item(_variant_t(_T("PRIMARY")), &pfilegroup);
	hr = pfilegroup->get_DBFiles(&pdbfiles);
	hr = pdbfiles->Add(pdbfile);

	hr = pdbs->Add(pdb);

	return InitSQLDB(pdb);
}

HRESULT CGuideDB::InitSQLDB(SQLDMO::_Database *pdb)
{
	HRESULT hr;

	SQLDMO::TablesPtr ptables;

	hr = pdb->get_Tables(&ptables);
	if (FAILED(hr))
		return hr;

	for (TableDesc *ptabledesc = g_rgtabledesc; ptabledesc->m_szName != NULL; ptabledesc++)
		{
		_bstr_t bstrTableName(ptabledesc->m_szName);
		SQLDMO::_TablePtr ptable;
		hr = ptable.CreateInstance(__uuidof(SQLDMO::Table));
		if (FAILED(hr))
			return hr;

		hr = ptable->put_Name(bstrTableName);
		if (FAILED(hr))
			return hr;

		SQLDMO::ColumnsPtr pcols;
		hr = ptable->get_Columns(&pcols);
		if (FAILED(hr))
			return hr;

		ColumnDesc *pcolumndesc;
		for (pcolumndesc = ptabledesc->m_rgcolumndesc;
				pcolumndesc->m_szName != NULL; pcolumndesc++)
			{
			_bstr_t bstrColumnName(pcolumndesc->m_szName);
			_variant_t varColumnName(bstrColumnName);
			SQLDMO::_ColumnPtr pcol;

			hr = pcol.CreateInstance(__uuidof(SQLDMO::Column));
			if (FAILED(hr))
				return hr;
			
			hr = pcol->put_Name(bstrColumnName);
			_bstr_t bstrType;
			switch (pcolumndesc->m_type)
				{
				default:
					_ASSERTE(0);
					break;
				case ADOX::adInteger:
					bstrType = "integer";
					break;
				case ADOX::adLongVarWChar:
					bstrType = "text";
					if (pcolumndesc->m_size != 0)
						hr = pcol->put_Length(pcolumndesc->m_size);
					break;
				case ADOX::adVarWChar:
					bstrType = "varchar";
					hr = pcol->put_Length(pcolumndesc->m_size);
					break;
				case ADOX::adDouble:
					bstrType = "float";
					break;
				
				case ADOX::adLongVarBinary:
					bstrType = "image";
					long size = pcolumndesc->m_size;
					if (size == 0)
						size = 8000;
					hr = pcol->put_Length(size);
					break;
				}
			hr = pcol->put_Datatype(bstrType);

			if (pcolumndesc->m_fAutoIncrement)
				{
				hr = pcol->put_Identity((VARIANT_BOOL) -1);
				}

			if (pcolumndesc->m_fAllowNulls)
				{
				hr = pcol->put_AllowNulls((VARIANT_BOOL) -1);
				}
			
			hr = pcols->Add(pcol);
			}

		hr = ptables->Add(ptable);

		if (ptabledesc->m_rgindexdesc != NULL)
			{
			SQLDMO::IndexesPtr pindexes;
			hr = ptable->get_Indexes(&pindexes);

			for (IndexDesc *pindexdesc = ptabledesc->m_rgindexdesc;
					pindexdesc->m_szName != NULL; pindexdesc++)
				{
				_bstr_t bstrIndexName(pindexdesc->m_szName);
				int cColumns = pindexdesc->m_cColumns;

				_ASSERTE(cColumns > 0);

				SQLDMO::_IndexPtr pindex;

				hr = pindex.CreateInstance(__uuidof(SQLDMO::Index));
				_ASSERTE(SUCCEEDED(hr));

				hr = pindex->put_Name(bstrIndexName);
				_ASSERTE(SUCCEEDED(hr));

				_bstr_t bstrColumns;

				ColumnDesc **ppcolumndesc = pindexdesc->m_rgpcolumndesc;
				bstrColumns =  _bstr_t((*ppcolumndesc++)->m_szName);
				for (long iColumn = 1; iColumn < cColumns; iColumn++, ppcolumndesc++)
					{
					bstrColumns +=  _bstr_t(" ") + (*ppcolumndesc)->m_szName;
					}
				hr = pindex->put_IndexedColumns(bstrColumns);
				SQLDMO::SQLDMO_INDEX_TYPE lType = SQLDMO::SQLDMOIndex_Default;
				if (pindexdesc->m_fUnique)
					lType = (SQLDMO::SQLDMO_INDEX_TYPE)(lType | SQLDMO::SQLDMOIndex_Unique);
				hr = pindex->put_Type(lType);
				hr = pindexes->Add(pindex);
				_ASSERTE(SUCCEEDED(hr));
				}
			}

		if (ptabledesc->m_pindexdescPrimary != NULL)
			{
			IndexDesc *pindexdesc = ptabledesc->m_pindexdescPrimary;
			SQLDMO::KeysPtr pkeys;

			hr = ptable->get_Keys(&pkeys);

			SQLDMO::_KeyPtr pkey;

			hr = pkey.CreateInstance(__uuidof(SQLDMO::Key));

			hr = pkey->put_Name(_bstr_t(pindexdesc->m_szName));
			hr = pkey->put_Type(SQLDMO::SQLDMOKey_Primary);

			SQLDMO::NamesPtr pnames;
			hr = pkey->get_KeyColumns(&pnames);

			int cColumns = pindexdesc->m_cColumns;

			_ASSERTE(cColumns > 0);
			ColumnDesc **ppcolumndesc = pindexdesc->m_rgpcolumndesc;
			for (long iColumn = 0; iColumn < cColumns; iColumn++, ppcolumndesc++)
				{
				_bstr_t bstrColumnName((*ppcolumndesc)->m_szName);

				hr = pnames->Add(bstrColumnName);
				}
			
			hr = pkeys->Add(pkey);
			}
		}
	

	return S_OK;
}

HRESULT AddIndex(ADOX::Indexes *pindexes, IndexDesc *pindexdesc, boolean fPrimary)
{
	HRESULT hr;
	_bstr_t bstrIndexName(pindexdesc->m_szName);
	int cColumns = pindexdesc->m_cColumns;

	_ASSERTE(cColumns > 0);

	ADOX::_IndexPtr pindex;

	hr = pindex.CreateInstance(__uuidof(ADOX::Index));
	_ASSERTE(SUCCEEDED(hr));

	hr = pindex->put_Name(bstrIndexName);
	_ASSERTE(SUCCEEDED(hr));
	if (pindexdesc->m_fUnique)
		{
		if (fPrimary)
			{
			hr = pindex->put_PrimaryKey(-1);
			_ASSERTE(SUCCEEDED(hr));
			}
		else
			{
			hr = pindex->put_Unique(-1);
			_ASSERTE(SUCCEEDED(hr));
			}
		}

	ADOX::ColumnsPtr pcols;

	hr = pindex->get_Columns(&pcols);
	_ASSERTE(SUCCEEDED(hr));

	ColumnDesc **ppcolumndesc = pindexdesc->m_rgpcolumndesc;
	for (long iColumn = 0; iColumn < cColumns; iColumn++, ppcolumndesc++)
		{
		ColumnDesc *pcolumndesc = *ppcolumndesc;
		_variant_t varColumnName((*ppcolumndesc)->m_szName);

		hr = pcols->Append(varColumnName, pcolumndesc->m_type, pcolumndesc->m_size);
		_ASSERTE(SUCCEEDED(hr));
		}
	_variant_t varIndex((IDispatch*) pindex);
	hr = pindexes->Append(varIndex);
	_ASSERTE(SUCCEEDED(hr));

	return hr;
}

HRESULT CGuideDB::InitDB(ADOX::_Catalog *pcatalog)
{
	HRESULT hr;

	ADOX::TablesPtr ptables;

	hr = pcatalog->get_Tables(&ptables);
	if (FAILED(hr))
		return hr;

	for (TableDesc *ptabledesc = g_rgtabledesc; ptabledesc->m_szName != NULL; ptabledesc++)
		{
		_bstr_t bstrTableName(ptabledesc->m_szName);
		ADOX::_TablePtr ptable;
		hr = ptable.CreateInstance(__uuidof(ADOX::Table));
		if (FAILED(hr))
			return hr;

		hr = ptable->put_Name(bstrTableName);
		if (FAILED(hr))
			return hr;
		
		hr = ptable->put_ParentCatalog(pcatalog);
		if (FAILED(hr))
			return hr;

		ADOX::ColumnsPtr pcols;
		hr = ptable->get_Columns(&pcols);
		if (FAILED(hr))
			return hr;

		ColumnDesc *pcolumndesc;
		for (pcolumndesc = ptabledesc->m_rgcolumndesc;
				pcolumndesc->m_szName != NULL; pcolumndesc++)
			{
			_bstr_t bstrColumnName(pcolumndesc->m_szName);
			_variant_t varColumnName(bstrColumnName);
			long type = pcolumndesc->m_type;
			long size = pcolumndesc->m_size;
			switch (type)
				{
				case ADOX::adVarWChar:
					//UNDONE: Must handle strings > 255 with Jet.
					if (!m_fSQLServer && (size > 255))
						size = 255;
					break;
				}
			hr = pcols->Append(varColumnName, pcolumndesc->m_type, size);

			ADOX::_Column *pcolumn;
			hr = pcols->get_Item(varColumnName, &pcolumn);
			if (pcolumndesc->m_fAutoIncrement || pcolumndesc->m_fAllowNulls
				|| (pcolumndesc->m_type == ADOX::adVarWChar))
				{
				ADOX::PropertiesPtr pprops;

				hr = pcolumn->get_Properties(&pprops);

#if 0
				long cProps;
				pprops->get_Count(&cProps);

				for (long i = 0; i < cProps; i++)
					{
					ADOX::PropertyPtr pprop;
					CComBSTR bstrName;

					pprops->get_Item(_variant_t(i), &pprop);

					pprop->get_Name(&bstrName);
					}
#endif

				if (pcolumndesc->m_fAutoIncrement)
					{
					ADOX::PropertyPtr pprop;
					hr = pprops->get_Item(_variant_t(_T("AutoIncrement")), &pprop);

					pprop->put_Value(_variant_t((bool) TRUE));
					}

				if (pcolumndesc->m_fAllowNulls)
					{
					ADOX::PropertyPtr pprop;
					hr = pprops->get_Item(_variant_t(_T("Nullable")), &pprop);

					if (SUCCEEDED(hr))
						pprop->put_Value(_variant_t((bool) TRUE));
					}

				if (pcolumndesc->m_type == ADOX::adVarWChar)
					{
					ADOX::PropertyPtr pprop;
					hr = pprops->get_Item(_variant_t(_T("Jet OLEDB:Allow Zero Length")), &pprop);

					if (SUCCEEDED(hr))
						pprop->put_Value(_variant_t((bool) TRUE));
					}
				}
			}
		
		ADOX::IndexesPtr pindexes;
		hr = ptable->get_Indexes(&pindexes);
		if (ptabledesc->m_pindexdescPrimary != NULL)
			{
			hr = AddIndex(pindexes, ptabledesc->m_pindexdescPrimary, TRUE);
			_ASSERTE(SUCCEEDED(hr));
			}
		if (ptabledesc->m_rgindexdesc != NULL)
			{
			for (IndexDesc *pindexdesc = ptabledesc->m_rgindexdesc;
					pindexdesc->m_szName != NULL; pindexdesc++)
				{
				hr = AddIndex(pindexes, pindexdesc, FALSE);
				_ASSERTE(SUCCEEDED(hr));
				}
			}

		hr = ptables->Append(_variant_t((IDispatch *)ptable));
		}

	return hr;
}

HRESULT CGuideDB::OpenDB(IGuideStore *pgs, const TCHAR *szDBName)
{
	HRESULT hr = E_FAIL;
	DeclarePerfTimer("CGuideDB::OpenDB");

	if (m_pdb == NULL)
		{
		ADODB::_ConnectionPtr pdb;
		TCHAR szConnection[4096];
		const TCHAR *szConnectionTemplate = g_szConnection;

		if (szDBName[0] == _T('*'))
			{
			m_fSQLServer = TRUE;
			szConnectionTemplate = g_szConnectionSQL;
			szDBName++;
			}

		wsprintf(szConnection, szConnectionTemplate, szDBName);
		hr = pdb.CreateInstance(__uuidof(ADODB::Connection));
		if (FAILED(hr))
			return hr;
		
		for (int cTries = 2; cTries > 0; cTries--)
			{
			PerfTimerReset();
			hr = pdb->Open(_bstr_t(szConnection), /*g_bstrDBUser*/ _T(""), /*g_bstrDBPassword*/ _T(""), 0);
			PerfTimerDump("Open");
			if (SUCCEEDED(hr))
				break;
			
			TCHAR szFilename[MAX_PATH];
			wsprintf(szFilename, _T("f:\\tmp\\%s.mdf"), szDBName);
			hr = CreateDB(szDBName, szFilename, szConnection);
			if (FAILED(hr))
				return hr;
			}
		m_pdb = pdb;
		}

	_variant_t varDB((IDispatch *)m_pdb);

	if (m_fSQLServer)
		{
		hr = m_pdb->put_CursorLocation(ADODB::adUseClient);
		}

	if (m_prsStrings == NULL)
		{
		ADODB::_RecordsetPtr prs;

		hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
		if (FAILED(hr))
			return hr;

		hr = prs->Open(g_varStrings, varDB, ADODB::adOpenUnspecified,
			ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
		if (FAILED(hr))
			return hr;
		
		m_prsStrings = prs;

		hr = m_prsStrings->MoveFirst();
		// First string is the version/uuid for the database
		_bstr_t bstrUUID;
		if (FAILED(hr))
			{
			UUID uuid;

			hr = UuidCreate(&uuid);
			if (hr != RPC_S_OK)
				return E_FAIL;
			
			OLECHAR sz[40];

			StringFromGUID2(uuid, sz, sizeof(sz)/sizeof(OLECHAR));

			bstrUUID = sz;
			m_prsStrings->AddNew();
			m_prsStrings->Fields->Item[g_bstrValue]->Value = bstrUUID;
			m_prsStrings->Update();
			}
		else
			{
			bstrUUID = m_prsStrings->Fields->Item[g_bstrValue]->Value;
			}
		}

	if (m_prsPropSets == NULL)
		{
		ADODB::_RecordsetPtr prs;

		hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
		if (FAILED(hr))
			return hr;

		hr = prs->Open(g_varPropertySets, varDB, ADODB::adOpenUnspecified,
			ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
		if (FAILED(hr))
			return hr;
		
		m_prsPropSets = prs;
		}

	if (m_prsPropTypes == NULL)
		{
		ADODB::_RecordsetPtr prs;

		hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
		if (FAILED(hr))
			return hr;

		hr = prs->Open(g_varPropertyTypes, varDB, ADODB::adOpenUnspecified,
				ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
		if (FAILED(hr))
			return hr;
		
		hr = prs->put_Index(_T("idPropSet"));
		m_prsPropTypes = prs;
		}

	if (m_prsProps == NULL)
		{
		ADODB::_RecordsetPtr prs;

		hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
		if (FAILED(hr))
			return hr;
		hr = prs->Open(g_varProperties, varDB, ADODB::adOpenUnspecified,
				ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
		if (FAILED(hr))
			return hr;
		
		m_prsProps = prs;
		}

	if (m_prsPropsIndexed == NULL)
		{
		if (m_fSQLServer)
			{
			hr = NewQuery("SELECT * FROM Properties"
					" ORDER BY Properties.idObj, Properties.idPropType, "
					"Properties.idProvider, Properties.idLanguage;",
					&m_prsPropsIndexed);
			}
		else
			{
			ADODB::_RecordsetPtr prs;

			hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
			if (FAILED(hr))
				return hr;
			hr = prs->Open(g_varProperties, varDB, ADODB::adOpenUnspecified,
					ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
			if (FAILED(hr))
				return hr;
		
			hr = prs->put_Index(_bstr_t("PK_Properties"));
			
			m_prsPropsIndexed = prs;
			}
		}

	if (m_prsObjTypes == NULL)
		{
		ADODB::_RecordsetPtr prs;

		hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
		if (FAILED(hr))
			return hr;
		hr = prs->Open(g_varObjectTypes, varDB, ADODB::adOpenUnspecified,
			ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
		if (FAILED(hr))
			return hr;
		
		m_prsObjTypes = prs;
		}

	hr = pgs->get_MetaPropertySets(&m_ppropsets);
	if (FAILED(hr))
		return hr;

	CategoriesPropSet::Init(m_ppropsets);
	ChannelPropSet::Init(m_ppropsets);
	ChannelsPropSet::Init(m_ppropsets);
	TimePropSet::Init(m_ppropsets);
	DescriptionPropSet::Init(m_ppropsets);
	CopyrightPropSet::Init(m_ppropsets);
	ProviderPropSet::Init(m_ppropsets);
	ScheduleEntryPropSet::Init(m_ppropsets);
	ServicePropSet::Init(m_ppropsets);
	RatingsPropSet::Init(m_ppropsets);
	MPAARatingsPropSet::Init(m_ppropsets);

	// Preload all the standard properties

	CComPtr<IMetaPropertyType> pproptype;
	pproptype = DescriptionPropSet::IDMetaPropertyType();
	pproptype = DescriptionPropSet::NameMetaPropertyType();
	pproptype = DescriptionPropSet::TitleMetaPropertyType();
	pproptype = DescriptionPropSet::SubtitleMetaPropertyType();
	pproptype = DescriptionPropSet::OneSentenceMetaPropertyType();
	pproptype = DescriptionPropSet::OneParagraphMetaPropertyType();
	pproptype = DescriptionPropSet::VersionMetaPropertyType();

	pproptype = TimePropSet::StartMetaPropertyType();
	pproptype = TimePropSet::EndMetaPropertyType();

	pproptype = CopyrightPropSet::TextMetaPropertyType();
	pproptype = CopyrightPropSet::DateMetaPropertyType();

	pproptype = ServicePropSet::TuneRequestMetaPropertyType();

	pproptype = ChannelPropSet::ServiceMetaPropertyType();
	pproptype = ChannelsPropSet::ChannelMetaPropertyType();

	pproptype = ScheduleEntryPropSet::ServiceMetaPropertyType();
	pproptype = ScheduleEntryPropSet::ProgramMetaPropertyType();

	pproptype = RatingsPropSet::MinimumAgeMetaPropertyType();
	pproptype = RatingsPropSet::SexMetaPropertyType();
	pproptype = RatingsPropSet::ViolenceMetaPropertyType();
	pproptype = RatingsPropSet::LanguageMetaPropertyType();

	pproptype = MPAARatingsPropSet::RatingMetaPropertyType();
	
	pproptype = CategoriesPropSet::Reserved_00MetaPropertyType();
	pproptype = CategoriesPropSet::MovieMetaPropertyType();
	pproptype = CategoriesPropSet::SportsMetaPropertyType();
	pproptype = CategoriesPropSet::SpecialMetaPropertyType();
	pproptype = CategoriesPropSet::SeriesMetaPropertyType();
	pproptype = CategoriesPropSet::NewsMetaPropertyType();
	pproptype = CategoriesPropSet::ShoppingMetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_07MetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_08MetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_09MetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_0AMetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_0BMetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_0CMetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_0DMetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_0EMetaPropertyType();
	pproptype = CategoriesPropSet::Reserved_0FMetaPropertyType();

	pproptype = CategoriesPropSet::ActionMetaPropertyType();
	pproptype = CategoriesPropSet::AdventureMetaPropertyType();
	pproptype = CategoriesPropSet::ChildrenMetaPropertyType();
	pproptype = CategoriesPropSet::ComedyMetaPropertyType();
	pproptype = CategoriesPropSet::DramaMetaPropertyType();
	pproptype = CategoriesPropSet::FantasyMetaPropertyType();
	pproptype = CategoriesPropSet::HorrorMetaPropertyType();
	pproptype = CategoriesPropSet::MusicalMetaPropertyType();
	pproptype = CategoriesPropSet::RomanceMetaPropertyType();
	pproptype = CategoriesPropSet::SciFiMetaPropertyType();
	pproptype = CategoriesPropSet::WesternMetaPropertyType();

	pproptype = CategoriesPropSet::BaseballMetaPropertyType();
	pproptype = CategoriesPropSet::BasketballMetaPropertyType();
	pproptype = CategoriesPropSet::BoxingMetaPropertyType();
	pproptype = CategoriesPropSet::FootballMetaPropertyType();
	pproptype = CategoriesPropSet::GolfMetaPropertyType();
	pproptype = CategoriesPropSet::HockeyMetaPropertyType();
	pproptype = CategoriesPropSet::RacingMetaPropertyType();
	pproptype = CategoriesPropSet::SkiingMetaPropertyType();
	pproptype = CategoriesPropSet::SoccerMetaPropertyType();
	pproptype = CategoriesPropSet::TennisMetaPropertyType();
	pproptype = CategoriesPropSet::WrestlingMetaPropertyType();

	pproptype = CategoriesPropSet::CulturalArtsMetaPropertyType();
	pproptype = CategoriesPropSet::EducationalMetaPropertyType();
	pproptype = CategoriesPropSet::GeneralInterestMetaPropertyType();
	pproptype = CategoriesPropSet::HowToMetaPropertyType();
	pproptype = CategoriesPropSet::MatureMetaPropertyType();
	pproptype = CategoriesPropSet::MusicMetaPropertyType();
	pproptype = CategoriesPropSet::ReligiousMetaPropertyType();
	pproptype = CategoriesPropSet::SoapOperaMetaPropertyType();
	pproptype = CategoriesPropSet::TalkMetaPropertyType();

	pproptype = CategoriesPropSet::BusinessMetaPropertyType();
	pproptype = CategoriesPropSet::CurrentMetaPropertyType();
	pproptype = CategoriesPropSet::WeatherMetaPropertyType();

	pproptype = CategoriesPropSet::HomeShoppingMetaPropertyType();
	pproptype = CategoriesPropSet::ProductInfoMetaPropertyType();

	pproptype = ProviderPropSet::NameMetaPropertyType();
	pproptype = ProviderPropSet::NetworkNameMetaPropertyType();
	pproptype = ProviderPropSet::DescriptionMetaPropertyType();

	
	hr = CreateEventSinkWindow();
	if (FAILED(hr))
		return hr;
	return hr;
}

HRESULT CGuideDB::get_RelsByID1Rel(ADODB::_Recordset **pprs)
	{
	HRESULT hr;

	if (m_prsRelsByID1Rel == NULL)
		{
		if (m_fSQLServer)
			{
			hr = NewQuery("SELECT * FROM ObjectRelationships"
					" ORDER BY ObjectRelationships.idObj1,"
					" ObjectRelationships.idRel, ObjectRelationships.[order];",
					&m_prsRelsByID1Rel);
			}
		else
			{
			_variant_t varDB((IDispatch *)m_pdb);
			ADODB::_RecordsetPtr prs;

			hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
			if (FAILED(hr))
				return hr;
			hr = prs->Open(g_varObjectRelationships, varDB, ADODB::adOpenUnspecified,
					ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
			if (FAILED(hr))
				return hr;
			
		
			hr = prs->put_Index(g_bstrIDObj1Rel);

			m_prsRelsByID1Rel = prs;
			}
		}

	*pprs = m_prsRelsByID1Rel;
	if (*pprs != NULL)
		(*pprs)->AddRef();
	return S_OK;
	}

HRESULT CGuideDB::get_RelsByID2Rel(ADODB::_Recordset **pprs)
	{
	HRESULT hr;

	if (m_prsRelsByID2Rel == NULL)
		{
		if (m_fSQLServer)
			{
			hr = NewQuery("SELECT * FROM ObjectRelationships"
					" ORDER BY ObjectRelationships.idObj2,"
					" ObjectRelationships.idRel, ObjectRelationships.[order];",
					&m_prsRelsByID2Rel);
			}
		else
			{
			_variant_t varDB((IDispatch *)m_pdb);
			ADODB::_RecordsetPtr prs;

			hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
			if (FAILED(hr))
				return hr;
			hr = prs->Open(g_varObjectRelationships, varDB, ADODB::adOpenUnspecified,
					ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
			if (FAILED(hr))
				return hr;
			
		
			hr = prs->put_Index(g_bstrIDObj2Rel);
			
			m_prsRelsByID2Rel = prs;
			}
		}

	*pprs = m_prsRelsByID2Rel;
	if (*pprs != NULL)
		(*pprs)->AddRef();
	return S_OK;
	}


HRESULT CGuideDB::get_ObjsRS(ADODB::_Recordset **pprs)
	{
	HRESULT hr;

	if (m_prsObjs == NULL)
		{
		_variant_t varDB((IDispatch *)m_pdb);
		ADODB::_RecordsetPtr prs;

		hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
		if (FAILED(hr))
			return hr;
		hr = prs->Open(g_varObjects, varDB, ADODB::adOpenUnspecified,
				ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
		if (FAILED(hr))
			return hr;
		
		m_prsObjs = prs;
		}

	*pprs = m_prsObjs;
	if (*pprs != NULL)
		(*pprs)->AddRef();
	return S_OK;
	}

HRESULT CGuideDB::get_ObjsByType(ADODB::_Recordset **pprs)
	{
	HRESULT hr;

	if (m_prsObjsByType == NULL)
		{
		if (m_fSQLServer)
			{
			hr = NewQuery("SELECT * FROM Objects ORDER BY Objects.idType;", &m_prsObjsByType);
			}
		else
			{
			_variant_t varDB((IDispatch *)m_pdb);
			ADODB::_RecordsetPtr prs;

			hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
			if (FAILED(hr))
				return hr;
			
			hr = prs->Open(g_varObjects, varDB, ADODB::adOpenUnspecified,
					ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
			if (FAILED(hr))
				return hr;

			hr = prs->put_Index(g_bstrIDType);
			
			m_prsObjsByType = prs;
			}
		}

	*pprs = m_prsObjsByType;
	if (*pprs != NULL)
		(*pprs)->AddRef();
	return S_OK;
	}

HRESULT CGuideDB::get_ObjsByID(ADODB::_Recordset **pprs)
	{
	HRESULT hr;

	if (m_prsObjsByID == NULL)
		{
		_variant_t varDB((IDispatch *)m_pdb);
		ADODB::_RecordsetPtr prs;

		hr = prs.CreateInstance(__uuidof(ADODB::Recordset));
		if (FAILED(hr))
			return hr;
		hr = prs->Open(g_varObjects, varDB, ADODB::adOpenUnspecified,
				ADODB::adLockPessimistic, ADODB::adCmdTableDirect);
		if (FAILED(hr))
			return hr;
		
		hr = prs->put_Index(_T("PK_Objects"));
		
		m_prsObjsByID = prs;
		}

	*pprs = m_prsObjsByID;
	if (*pprs != NULL)
		(*pprs)->AddRef();
	return S_OK;
	}

HRESULT CGuideDB::get_MetaPropertyType(long idPropType, IMetaPropertyType **ppproptype)
{
	*ppproptype = NULL;

	t_mapPropTypes::iterator it = m_mapPropTypes.find(idPropType);
	if (it == m_mapPropTypes.end())
		return E_INVALIDARG;

	*ppproptype = (*it).second;
	(*ppproptype)->AddRef();

	return S_OK;
}

HRESULT CGuideDB::put_MetaPropertyType(long idPropType, IMetaPropertyType *pproptype)
{
	m_mapPropTypes[idPropType] = pproptype;
	pproptype->AddRef();

	return S_OK;
}

HRESULT CGuideDB::CacheObject(long idObj, long idType, IUnknown **ppobj)
{
	HRESULT hr;
	CObjectType *pobjtype;
	if (idType == 0)
		{
		// Look it up
		ADODB::_RecordsetPtr prs;

		hr = get_ObjsByID(&prs);
		if (FAILED(hr))
			return hr;

		if (m_fSQLServer)
			{
			TCHAR szFind[32];

			prs->MoveFirst();
			wsprintf(szFind, _T("id = %d"), idObj);
			hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
			}
		else
			{
			_variant_t var(idObj);
			hr = prs->Seek(var, ADODB::adSeekFirstEQ);
			}
		if (FAILED(hr))
			return hr;
		if (prs->EndOfFile)
			return E_INVALIDARG;
		idType = prs->Fields->Item[g_bstrIDType]->Value;
		}

	get_ObjectType(idType, &pobjtype);

	return CacheObject(idObj, pobjtype, ppobj);
}

HRESULT CGuideDB::CacheObject(long idObj, CObjectType *pobjtype, IUnknown **ppobj)
{
	HRESULT hr;
	*ppobj = NULL;

	*ppobj = m_cacheObj.get_Unknown(idObj);
	if (*ppobj != NULL)
		return S_OK;

	hr = pobjtype->CreateInstance(idObj, ppobj);
	if (FAILED(hr))
		return hr;

	hr = m_cacheObj.Cache(idObj, *ppobj);
	if (FAILED(hr))
		return hr;
			
	CComQIPtr<CObject> pobj(*ppobj);
	return pobj->Load();
}

HRESULT CGuideDB::UncacheObject(long idObj)
{
	m_cacheObj.Uncache(idObj);

	return S_OK;
}

HRESULT CGuideDB::get_MetaPropertiesOf(long id, IMetaProperties **ppprops)
{
	*ppprops = NULL;
	t_mapIdProps::iterator it = m_mapIdProps.find(id);
	if (it != m_mapIdProps.end())
		{
		*ppprops = (*it).second;
		(*ppprops)->AddRef();
		return S_OK;
		}

	CComPtr<CMetaProperties> pprops = NewComObject(CMetaProperties);
	
	if (pprops != NULL)
		pprops->Init(id, 0, this);
	
	*ppprops = pprops;
	(*ppprops)->AddRef();

	m_mapIdProps[id] = pprops.Detach();
	
	return S_OK;
}

HRESULT CGuideDB::get_IdOf(IUnknown *pobj, long *pid)
{
	*pid = m_cacheObj.get_ID(pobj);

	return (*pid == 0) ? E_INVALIDARG : S_OK;
}

HRESULT CGuideDB::get_Object(long idObj, IUnknown **ppobj)
{
	*ppobj = m_cacheObj.get_Unknown(idObj);
	if (*ppobj == NULL)
		return E_INVALIDARG;
	
	return S_OK;
}

HRESULT CGuideDB::get_ObjectsWithType(long idType, IObjects **ppobjs)
{
	*ppobjs = NULL;

	t_mapObjsWithType::iterator it = m_mapObjsWithType.find(idType);
	if (it == m_mapObjsWithType.end())
		return S_FALSE;

	*ppobjs = (*it).second;
	(*ppobjs)->AddRef();

	return S_OK;
}

HRESULT CGuideDB::get_ObjectsWithType(CObjectType *pobjtype, IObjects **ppobjs)
{
	HRESULT hr;
	long idType;
	*ppobjs = NULL;

	hr = pobjtype->get_ID(&idType);
	if (FAILED(hr))
		return hr;
	
	hr = get_ObjectsWithType(idType, ppobjs);
	if (hr == S_OK)
		return S_OK;
	
	hr = pobjtype->get_NewCollection(ppobjs);
	if (FAILED(hr))
		return hr;

	m_mapObjsWithType[idType] = *ppobjs;
	(*ppobjs)->AddRef();

	return S_OK;
}

void CGuideDB::Broadcast_ItemEvent(enum ItemEvent ev, long idObj, long idType)
{
    HRESULT hr;
	if (m_iTransLevel == 0)
		{
		if (m_rgmsgItemEvent[ev] != NULL)
			PostMessage(HWND_BROADCAST, m_rgmsgItemEvent[ev], idObj, idType);
		}
	else
		{
		CComPtr<IObjects> pobjs;

		hr = get_ObjectsWithType(idType, &pobjs);
		if (hr != S_OK)
			return;

		CComQIPtr<CObjects> pobjsT(pobjs);

		pobjsT->NoteChanged(idObj);
		}
}
void CGuideDB::Broadcast_ItemChanged(long idObj)
	{
	HRESULT hr;

	CComPtr<IUnknown> punk = m_cacheObj.get_Unknown(idObj);
	if (punk == NULL)
		return;
	
	CComQIPtr<CObject> pobj(punk);
	if (pobj == NULL)
		return;
	
	CObjectType *ptype;
	hr = pobj->get_Type(&ptype);
	if (FAILED(hr))
		return;

	long idType;
	hr = ptype->get_ID(&idType);
	if (FAILED(hr))
		return;

	Broadcast_ItemEvent(Changed, idObj, idType);
	}

void CGuideDB::TransactionDone(boolean fCommit)
{
	t_mapObjsWithType::iterator it;

	for (it = m_mapObjsWithType.begin(); it != m_mapObjsWithType.end(); it++)
		{
		CComPtr<IObjects> pobjs = (*it).second;
		CComQIPtr<CObjects> pobjsT(pobjs);

		pobjsT->TransactionDone(fCommit);
		}
	
}

void CGuideDB::Fire_ItemEvent(enum ItemEvent ev, long idObj, long idType)
{
	HRESULT hr;
	CComPtr<IUnknown> pobj;
	CComPtr<IObjects> pobjs;

	if (idType == NULL)
		return;

	RequeryObjectsTables();

	hr = get_ObjectsWithType(idType, &pobjs);
	if (hr != S_OK)
		return;

	if ((idObj != NULL) && (ev != Removed))
		{
		hr = CacheObject(idObj, (long) 0, &pobj);
		if (FAILED(hr))
			return;
		}

	CComQIPtr<CObjects> pobjsT(pobjs);
	switch (ev)
		{
		case Added:
			hr = pobjsT->Notify_ItemAdded(pobj);
			break;
		case Removed:
			hr = pobjsT->Notify_ItemRemoved(idObj);
			break;
		case Changed:
			hr = pobjsT->Notify_ItemChanged(pobj);
			break;
		}
}

HRESULT CGuideDB::get_ObjectType(long idObjType, CObjectType **ppobjtype)
{
	*ppobjtype = NULL;

	t_mapObjTypes::iterator it = m_mapObjTypes.find(idObjType);
	if (it == m_mapObjTypes.end())
		return E_INVALIDARG;

	*ppobjtype = (*it).second;

	return S_OK;
}

HRESULT CGuideDB::put_ObjectType(long idObjType, CObjectType *pobjtype)
{
	m_mapObjTypes[idObjType] = pobjtype;

	return S_OK;
}

HRESULT CGuideDB::get_ObjectTypes(CObjectTypes **ppobjtypes)
{
	if (m_pobjtypes == NULL)
		{
		m_pobjtypes = new CObjectTypes;

		if (m_pobjtypes == NULL)
			return E_OUTOFMEMORY;
		
		m_pobjtypes->Init(this);
		}

	*ppobjtypes = m_pobjtypes;

	return S_OK;
}

HRESULT CGuideDB::get_ObjectType(CLSID clsid, CObjectType **ppobjtype)
{
	OLECHAR sz[40];

	StringFromGUID2(clsid, sz, sizeof(sz)/sizeof(OLECHAR));

	_bstr_t bstrCLSID(sz);

	return get_ObjectType(bstrCLSID, ppobjtype);
}

HRESULT CGuideDB::get_ObjectType(BSTR bstrCLSID, CObjectType **ppobjtype)
{
	CObjectTypes *pobjtypes;
	HRESULT hr = get_ObjectTypes(&pobjtypes);
	if (FAILED(hr))
		return hr;

	hr = pobjtypes->get_AddNew(bstrCLSID, ppobjtype);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

long CGuideDB::GetIDGuideDataProvider()
{
	if (m_pdataprovider == NULL)
		return 0;
	
	long id;
	get_IdOf(m_pdataprovider, &id);

	return id;
}

HRESULT CGuideDB::get_GuideDataProvider(IGuideDataProvider **ppdataprovider)
{
	*ppdataprovider = m_pdataprovider;

	if (*ppdataprovider != NULL)
		(*ppdataprovider)->AddRef();
	
	return S_OK;
}

HRESULT CGuideDB::putref_GuideDataProvider(IGuideDataProvider *pdataprovider)
{
	if (pdataprovider == NULL)
		{
		m_pdataprovider = NULL;
		return S_OK;
		}

	return pdataprovider->QueryInterface(__uuidof(IGuideDataProvider), (void **)&m_pdataprovider);
}

HRESULT CGuideDB::SaveObject(IUnknown *punk, long *pid)
{
	HRESULT hr;
	boolean fNew = FALSE;

	CComQIPtr<CObject> pobj(punk);
	if (pobj == NULL)
		{
		fNew = TRUE;

		CComQIPtr<IPersist> ppersist(punk);
		if (ppersist == NULL)
			return E_INVALIDARG;
		
		CLSID clsid;
		hr = ppersist->GetClassID(&clsid);
		if (FAILED(hr))
			return hr;

		CObjectType *pobjtype;
		hr = get_ObjectType(clsid, &pobjtype);

		CComPtr<IUnknown> punkObj;
		hr = pobjtype->get_New(&punkObj);
		if (FAILED(hr))
			return hr;

		pobj = punkObj;
		if (pobj == NULL)
			return E_FAIL;
		}

	pobj->get_ID(pid);
	pobj->Save(punk);
	if (fNew)
		pobj->Load();

	return S_OK;
}

void CGuideDB::DumpObjsCache(const TCHAR *psz, boolean fPurge)
	{
#ifdef _DEBUG
	OutputDebugString(psz);
#endif
	long cItems = m_cacheObjs.Count();
	for (int i = 0; i < cItems; i++)
		{
		CComQIPtr<CObjects> pobjs(m_cacheObjs.Item(i));

		pobjs->Dump();
		if (fPurge)
			pobjs->Resync();
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\object.h ===
// object.h : Declaration of the CObject

#ifndef __Object_H_
#define __Object_H_

#include "resource.h"       // main symbols

#include "property.h"
#include "guidedb.h"

class CObjectType;
class CObjectTypes;
class CObject;
class CObjectGlue;
class CObjects;
class CObjectPropertyBag;

/////////////////////////////////////////////////////////////////////////////
// CObjectType
class CObjectType
{
public:
	CObjectType()
	{
	m_fKnowCollectionCLSID = FALSE;
	}

	HRESULT CreateInstance(long id, IUnknown **ppobj);

	HRESULT Init(CGuideDB *pdb, long id, BSTR bstrCLSID)
	
		{
		CLSID clsid;

		HRESULT hr = CLSIDFromString(bstrCLSID, &clsid);
		if (hr == CO_E_CLASSSTRING)
			return E_INVALIDARG;
		
		return Init(pdb, id, clsid);
		}

	HRESULT Init(CGuideDB *pdb, long id, IID clsid)
		{
		m_pdb = pdb;
		m_id = id;
		m_clsid = clsid;
		return S_OK;
		}
	
	HRESULT GetDB(CGuideDB **ppdb);

public:
	STDMETHOD(get_NewCollection)(/*[out, retval]*/ IObjects * *ppobjs);
	STDMETHOD(get_New)(/*[out, retval]*/ IUnknown * *pVal);
	STDMETHOD(get_IID)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pVal);

	friend CObject;
protected:
	CComPtr<CGuideDB> m_pdb;
	CLSID m_clsid;
	long m_id;
	boolean m_fKnowCollectionCLSID;
	CLSID m_clsidCollection;
};
	
/////////////////////////////////////////////////////////////////////////////
// CObjectTypes
class CObjectTypes
{
public:
	HRESULT Init(CGuideDB *pdb);

	CObjectType *Cache(long id, BSTR bstrCLSID);

public:
	STDMETHOD(get_AddNew)(BSTR bstrIID, /*[out, retval]*/ CObjectType * *pVal);
#if 0
	STDMETHOD(get_AddNew)(CLSID clsid, /*[out, retval]*/ CObjectType * *pVal);
#endif
	STDMETHOD(get_ItemWithCLSID)(BSTR bstrCLSID, /*[out, retval]*/ CObjectType * *pVal);
	// STDMETHOD(get_ItemWithCLSID)(CLSID clsid, /*[out, retval]*/ CObjectType * *pVal);

protected:
	CComPtr<CGuideDB> m_pdb;
	ADODB::_RecordsetPtr m_prsObjTypes;

	typedef MemCmpLess<CLSID> CLSIDLess;
	typedef map<CLSID, CObjectType *, CLSIDLess> t_map;
	t_map m_map;
};

/////////////////////////////////////////////////////////////////////////////
// CObject
class DECLSPEC_UUID("4789011b-bc6d-49e2-b4df-420e40f4e318") ATL_NO_VTABLE CObject :
	public IUnknown,
	public CComObjectRootEx<CComObjectThreadModel>
{
public:
	CObject()
	{
		m_id = 0;
	}

DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CObject)
	COM_INTERFACE_ENTRY(CObject)
	COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_punk.p)
END_COM_MAP()

	friend class CObjectGlue;

	CGuideDB *GetDB()
		{
		//UNSAFE... doesn't do AddRef()... use the pointer quickly!
		return m_pdb;
		}

	HRESULT get_RelatedObjectID(boolean fInverse, long id, long idRel, long *pidRet);
	HRESULT get_ItemsRelatedBy(CObjectType *pobjtype,
			long idRel, boolean fInverse, IObjects **ppobjs);
	
	HRESULT CreatePropBag(IPersist *ppersist);

public:
	STDMETHOD(Init)(long id, CObjectType * pobjtype);
	STDMETHOD(Save)(IUnknown *punk);
	STDMETHOD(Load)();
	STDMETHOD(get_ItemsInverseRelatedBy)(CObjectType *pobjtype, /* [in] */ long idRel, /*[out, retval]*/ IObjects **ppobjs1);
	STDMETHOD(get_ItemInverseRelatedBy)(/* [in] */ long idRel, /*[out, retval]*/ IUnknown **ppobj1);
	STDMETHOD(get_ItemsRelatedBy)(CObjectType *pobjtype, /* [in] */ long idRel, /*[out, retval]*/ IObjects **ppobjs2);
	STDMETHOD(get_ItemRelatedBy)(/* [in] */ long idRel, /*[out, retval]*/ IUnknown **ppobj2);
	STDMETHOD(put_ItemRelatedBy)(/* [in] */ long idRel, /*[in]*/ IUnknown *pobj2);
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *pVal);
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_Type)(/*[out, retval]*/ CObjectType * *pVal);

protected:
	CObjectType *m_pobjtype;
	CComPtr<IUnknown> m_punk;
	CComPtr<CGuideDB> m_pdb;
	CComPtr<IMetaProperties> m_pprops;
	long m_id;
	CComPtr<CObjectPropertyBag> m_ppropbag;
};

class CObjectGlue
{
public:
	virtual IUnknown *GetControllingUnknown() = 0;

	HRESULT get_ItemsRelatedBy(CObjectType *pobjtype,
			IMetaPropertyType *pproptype, boolean fInverse, IObjects **ppobjs)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());
		CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);
		long idRel = pproptypeT->GetID();

		return pobj->get_ItemsRelatedBy(pobjtype, idRel, fInverse, ppobjs);
		}

// IObjectInt
protected:
	STDMETHOD(Init)(long id, CObjectType * pobjtype)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());

		return pobj->Init(id, pobjtype);
		}

public:
	STDMETHOD(get_ItemsInverseRelatedBy)(CObjectType *pobjtype,
			IMetaPropertyType *pproptype, /*[out, retval]*/ IObjects **ppobjs1)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());
		CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);
		long idRel = pproptypeT->GetID();

		return pobj->get_ItemsInverseRelatedBy(pobjtype, idRel, ppobjs1);
		}
	STDMETHOD(get_ItemInverseRelatedBy)(IMetaPropertyType *pproptype, /*[out, retval]*/ IUnknown **ppobj1)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());
		CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);
		long idRel = pproptypeT->GetID();

		return pobj->get_ItemInverseRelatedBy(idRel, ppobj1);
		}
	STDMETHOD(get_ItemsRelatedBy)(CObjectType *pobjtype, 
			IMetaPropertyType *pproptype, /*[out, retval]*/ IObjects **ppobjs2)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());
		CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);
		long idRel = pproptypeT->GetID();

		return pobj->get_ItemsRelatedBy(pobjtype, idRel, ppobjs2);
		}
	STDMETHOD(get_ItemRelatedBy)(IMetaPropertyType *pproptype, /*[out, retval]*/ IUnknown **ppobj2)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());
		CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);
		long idRel = pproptypeT->GetID();

		return pobj->get_ItemRelatedBy(idRel, ppobj2);
		}
	STDMETHOD(put_ItemRelatedBy)(IMetaPropertyType *pproptype, /*[in]*/ IUnknown *pobj2)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());
		CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);
		long idRel = pproptypeT->GetID();

		return pobj->put_ItemRelatedBy(idRel, pobj2);
		}
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *ppprops)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());

		return pobj->get_MetaProperties(ppprops);
		}
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pid)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());

		return pobj->get_ID(pid);
		}
	STDMETHOD(get_Type)(/*[out, retval]*/ CObjectType * *pobjtype)
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());

		return pobj->get_Type(pobjtype);
		}

	template<class T_Related>
	HRESULT _get_ItemRelatedBy(IMetaPropertyType *pproptype, T_Related **ppT)
		{
		CComPtr<IUnknown> pobj;
		HRESULT hr;

		hr = get_ItemRelatedBy(pproptype,  &pobj);
		if (hr == S_FALSE || FAILED(hr))
			return hr;
		
		return pobj->QueryInterface(__uuidof(T_Related), (void **) ppT);
		}
	template<class T_Related>
	HRESULT _put_ItemRelatedBy(IMetaPropertyType *pproptype, T_Related *pT)
		{
		return put_ItemRelatedBy(pproptype, pT);
		}

	__declspec(property(get=GetDB)) CGuideDB *m_pdb;
	CGuideDB *GetDB()
		{
		CComQIPtr<CObject> pobj(GetControllingUnknown());

		return pobj->GetDB();
		}
};

/////////////////////////////////////////////////////////////////////////////
// CObjects

class ATL_NO_VTABLE DECLSPEC_UUID("AC0F25D9-81C8-4C9E-B7AC-031E9A539E1E") CObjects : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CObjects, &CLSID_Objects>,
	public IObjectsPrivate,
	public IObjects
{
public:
	CObjects()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_cItems = -1;
		m_fInverse = FALSE;
		m_pobjtype = NULL;
		m_fOnlyUnreferenced = FALSE;
		m_idChanged = NULL;
		m_cChanged = 0;

		m_idPropTypeKey = 0;
		m_idProviderKey = 0;
		m_idLangKey = 0;
		m_vtKey = 0;
	}

	CGuideDB *GetDB()
		{
		//UNSAFE... doesn't do AddRef()... use the pointer quickly!
		return m_pdb;
		}
	
	void Dump();

	HRESULT Clone(IObjects **ppobjs);

	HRESULT AddRelationshipAt(long idObj1, long idRel, long iItem, long idObj2);

	HRESULT put_OnlyUnreferenced(boolean fOnlyUnreferenced)
		{
		m_fOnlyUnreferenced = fOnlyUnreferenced;
		return S_OK;
		}
	
	// If in a transaction, NoteChanged() will be called to keep track of changes.
	// TransactionDone() will be called when the transaction is done.
	void NoteChanged(long idObj)
		{
		if (m_idChanged == 0)
		    {
		    m_idChanged = idObj;
		    m_cChanged++;
		    }
		else if (m_idChanged != idObj)
		    {
		    m_cChanged++;
		    }
		}
	
	void TransactionDone(boolean fCommited)
		{
		if (fCommited && (m_cChanged > 0))
			{
			long idType;
			m_pobjtype->get_ID(&idType);

			if (m_cChanged == 1)
				{
				m_pdb->Broadcast_ItemChanged(m_idChanged, idType);
				}
			else
				{
				m_pdb->Broadcast_ItemsChanged(idType);
				}
			}
		m_cChanged = 0;
		m_idChanged = NULL;
		}

DECLARE_REGISTRY_RESOURCEID(IDR_OBJECTS)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CObjects)
	COM_INTERFACE_ENTRY(IObjects)
	COM_INTERFACE_ENTRY(CObjects)
	COM_INTERFACE_ENTRY(IObjectsPrivate)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
	COM_INTERFACE_ENTRY_AGGREGATE_BLIND(m_punkCollection.p)
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	HRESULT Init(CLSID &clsid)
		{
		return m_punkCollection.CoCreateInstance(clsid, (IObjects *) this);
		}
	// Call IObjectsNotifications to notify Add/Remove/Change Item
	HRESULT Notify_ItemAdded(IUnknown * pobj)
		{
		CComQIPtr<IObjectsNotifications> pobjsevents((IObjects *) this);

		if (pobjsevents == NULL)
			return S_OK;

		return pobjsevents->Notify_ItemAdded(pobj);
		}
	HRESULT Notify_ItemRemoved(long idObj)
		{
		CComQIPtr<IObjectsNotifications> pobjsevents((IObjects *) this);

		if (pobjsevents == NULL)
			return S_OK;

		return pobjsevents->Notify_ItemRemoved(idObj);
		}
	HRESULT Notify_ItemChanged(IUnknown * pobj)
		{
		CComQIPtr<IObjectsNotifications> pobjsevents((IObjects *) this);

		if (pobjsevents == NULL)
			return S_OK;

		return pobjsevents->Notify_ItemChanged(pobj);
		}
	HRESULT Notify_ItemsChanged()
		{
		CComQIPtr<IObjectsNotifications> pobjsevents((IObjects *) this);

		if (pobjsevents == NULL)
			return S_OK;

		return pobjsevents->Notify_ItemsChanged();
		}
	//

	HRESULT GetRS(ADODB::_Recordset **pprs);
	enum QueryType {Select, Delete};
	HRESULT GetQuery(QueryType qtype, _bstr_t *pbstr);

	HRESULT get_DB(CGuideDB **ppdb)
		{
		m_pdb.CopyTo(ppdb);
		return S_OK;
		}
	HRESULT put_DB(CGuideDB *pdb)
		{
		m_pdb = pdb;
		return S_OK;
		}

	HRESULT put_ObjectType(CObjectType *pobjtype)
		{
#if 0
		return pobjtype->QueryInterface(__uuidof(CObjectType), (void **) &m_pobjtype);
#else
		m_pobjtype = pobjtype;
		return S_OK;
#endif
		}

	HRESULT get_ObjectType(CObjectType **ppobjtype)
		{
		if ((*ppobjtype = m_pobjtype))
			return S_OK;

		return E_FAIL;
		}

	HRESULT put_MetaPropertyCond(IMetaPropertyCondition *ppropcond)
		{
		m_ppropcond = ppropcond;
		return S_OK;
		}
	
	HRESULT InitRelation(IUnknown *pobj, long idRel, boolean fInverse)
		{
		m_pobjRelated = pobj;
		m_idRel = idRel;
		m_fInverse = fInverse;

		return S_OK;
		}

	HRESULT get_ItemsRelatedToBy(IUnknown *pobj, IMetaPropertyType *pproptype,
			boolean fInverse, IObjects **ppobjs);

	HRESULT Remove(IUnknown *pobj);
	HRESULT RemoveFromRelationship(IUnknown *pobj);
	HRESULT get_ItemsWithType(CObjectType *ptype, /*[out, retval]*/ IObjects * *pVal);

	HRESULT put_Key(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider,
			long idLang, long vt)
		{
		CComQIPtr<CMetaPropertyType> pproptypeKey(pproptype);

		m_idPropTypeKey = pproptypeKey->GetID();

		if (pprovider != NULL)
			{
			CComQIPtr<CObject> pobj(pprovider);
			pobj->get_ID(&m_idProviderKey);
			}
		m_idLangKey = idLang;
		m_vtKey = vt;
		return S_OK;
		}

// IObjects
public:
	STDMETHOD(Resync)()
		{
		return Reset();
		}
	STDMETHOD(UnreferencedItems)(/* [out, retval] */ IObjects **ppobjs);
	STDMETHOD(RemoveAll)();
	STDMETHOD(Reset)();
	STDMETHOD(get_ItemsInverseRelatedToBy)(IUnknown *pobj, /* [in] */ IMetaPropertyType *pproptype, /*[out, retval]*/ IObjects **ppobjs);

	STDMETHOD(get_ItemsRelatedToBy)(IUnknown *pobj, /* [in] */ IMetaPropertyType *pproptype, /*[out, retval]*/ IObjects **ppobjs);

	STDMETHOD(get_ItemsInTimeRange)(DATE dtStart, DATE dtEnd, /*[out, retval]*/ IObjects * *pVal);
	STDMETHOD(get_SQLQuery)(/*[out, retval]*/ BSTR *pbstr)
		{
		ENTER_API
			{
			ValidateOut(pbstr);
			//UNDONE: Remove this method...just for debugging

			_bstr_t bstr;

			GetQuery(Select, &bstr);

			*pbstr = bstr.copy();

			return S_OK;
			}
		LEAVE_API
		}

	STDMETHOD(Remove)(VARIANT varIndex);
	STDMETHOD(AddAt)(IUnknown *pobj, long index);
	STDMETHOD(get_AddNew)(/*[out, retval]*/ IUnknown * *pVal);
	STDMETHOD(get_AddNewAt)(long index, /*[out, retval]*/ IUnknown * *pVal);
	STDMETHOD(get_ItemsWithMetaPropertyCond)(IMetaPropertyCondition *ppropcond, /*[out, retval]*/ IObjects * *pVal);
	STDMETHOD(get_ItemsWithMetaProperty)(IMetaProperty *pprop, /*[out, retval]*/ IObjects * *pVal);
	STDMETHOD(get_ItemWithID)(long id, /*[out, retval]*/ IUnknown * *pVal);
	STDMETHOD(get_ItemsWithType)(BSTR bstrCLSID, /*[out, retval]*/ IObjects * *pVal);
	STDMETHOD(get_ItemWithKey)(VARIANT varIndex, /*[out, retval]*/ IUnknown * *pVal);
	STDMETHOD(get_ItemsByKey)(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, IObjects * *pVal);
	STDMETHOD(get_Item)(VARIANT varIndex, /*[out, retval]*/ IUnknown * *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk, NULL);

			return E_NOTIMPL;
			}
		LEAVE_API
		}
#endif

protected:
	void CObjects::Copy(CObjects *pobjs)
		{
		m_pdb = pobjs->m_pdb;
		m_ppropcond = pobjs->m_ppropcond;
		m_pobjRelated = pobjs->m_pobjRelated;
		m_idRel = pobjs->m_idRel;
		m_fInverse = pobjs->m_fInverse;
		m_fOnlyUnreferenced = pobjs->m_fOnlyUnreferenced;
		m_idPropTypeKey = pobjs->m_idPropTypeKey;
		m_idProviderKey = pobjs->m_idProviderKey;
		m_idLangKey = pobjs->m_idLangKey;
		}

	CComPtr<CGuideDB> m_pdb;

	// All items in this collection are of the type specified by m_pobjtype.
	CObjectType *m_pobjtype;

	CComPtr<IUnknown> m_punkCollection;

	CComPtr<IMetaPropertyCondition> m_ppropcond;

	// All the items in this collection are related (or inverse related) to
	// m_pobjRelated by the relationship m_idRel.
	CComPtr<IUnknown> m_pobjRelated;
	long m_idRel;
	boolean m_fInverse;

	ADODB::_RecordsetPtr m_prs;
	long m_cItems;

	boolean m_fOnlyUnreferenced;

	long m_idChanged;
	long m_cChanged;

	long m_idPropTypeKey;
	long m_idProviderKey;
	long m_idLangKey;
	long m_vtKey;
};

/////////////////////////////////////////////////////////////////////////////
// CObjectsGlue

template<class T_Collection, class T_Item>
	class ATL_NO_VTABLE CObjectsGlue : public IObjectsNotifications
{
public:
	typedef CObjectsGlue<T_Collection, T_Item> ThisClass;
	CObjectsGlue()
		{
		}
	~CObjectsGlue()
		{
		}

// Thunks to IObjects interface of aggregated CLSID_Objects object.
	HRESULT _Remove(VARIANT varIndex)
		{
		HRESULT hr;
		CComQIPtr<IObjects> pobjs(this);

		hr = pobjs->Remove(varIndex);

		return hr;
		}

	HRESULT _RemoveAll()
		{
		CComQIPtr<IObjects> pobjs(this);

		return pobjs->RemoveAll();
		}

	HRESULT _Resync()
		{
		CComQIPtr<IObjects> pobjs(this);

		return pobjs->Resync();
		}

	HRESULT _get_AddNew(T_Item **ppobj)
		{
		HRESULT hr;
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IUnknown> pobj;

		hr = pobjs->get_AddNew(&pobj);
		if (FAILED(hr))
			return hr;

		hr = pobj->QueryInterface(__uuidof(T_Item), (void **) ppobj);

		return hr;
		}

	HRESULT _get_AddNewAt(long index, T_Item **ppobj)
		{
		HRESULT hr;
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IUnknown> pobj;

		hr = pobjs->get_AddNewAt(index, &pobj);
		if (FAILED(hr))
			return hr;

		hr = pobj->QueryInterface(__uuidof(T_Item), (void **) ppobj);

		return hr;
		}

	HRESULT _AddAt(T_Item *pobj, long index)
		{
		HRESULT hr;
		CComQIPtr<IObjects> pobjs(this);

		hr = pobjs->AddAt(pobj, index);

		return hr;
		}

	HRESULT _get_Item(VARIANT varIndex, T_Item **ppobj)
		{
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IUnknown> pobj;

		HRESULT hr = pobjs->get_Item(varIndex, &pobj);
		if (FAILED(hr))
			return hr;
		
		return pobj->QueryInterface(__uuidof(T_Item), (void **) ppobj);
		}

	HRESULT _get_ItemWithID(long id, T_Item **ppobj)
		{
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IUnknown> pobj;

		HRESULT hr = pobjs->get_ItemWithID(id, &pobj);
		if (FAILED(hr))
			return hr;
		
		return pobj->QueryInterface(__uuidof(T_Item), (void **) ppobj);
		}

	HRESULT _get_ItemWithKey(VARIANT varKey, T_Item **ppobj)
		{
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IUnknown> pobj;

		HRESULT hr = pobjs->get_ItemWithKey(varKey, &pobj);
		if (FAILED(hr))
			return hr;
		
		return pobj->QueryInterface(__uuidof(T_Item), (void **) ppobj);
		}

	HRESULT _get_ItemsByKey(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, T_Collection **ppobjs)
		{
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IObjects> pobjsNew;

		HRESULT hr = pobjs->get_ItemsByKey(pproptype, pprovider, idLang, vt, &pobjsNew);
		if (FAILED(hr))
			return hr;
		
		return pobjsNew->QueryInterface(__uuidof(T_Collection), (void **) ppobjs);
		}

	HRESULT _get_ItemsWithMetaPropertyCond(IMetaPropertyCondition *ppropcond, T_Collection **ppobjs)
		{
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IObjects> pobjsNew;

		HRESULT hr = pobjs->get_ItemsWithMetaPropertyCond(ppropcond, &pobjsNew);
		if (FAILED(hr))
			return hr;
		
		return pobjsNew->QueryInterface(__uuidof(T_Collection), (void **) ppobjs);
		}
	HRESULT _get_ItemsInTimeRange(DATE dtStart, DATE dtEnd, /*[out, retval]*/ T_Collection * *ppitems)
		{
		HRESULT hr;
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IObjects> pobjsNew;

		hr = pobjs->get_ItemsInTimeRange(dtStart, dtEnd, &pobjsNew);
		if (FAILED(hr))
			return hr;

		return  pobjsNew->QueryInterface(__uuidof(T_Collection), (void **) ppitems);
		}
	HRESULT _get_ItemsWithMetaProperty(IMetaProperty *pprop, T_Collection * *ppobjs)
		{
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IObjects> pobjsNew;

		HRESULT hr = pobjs->get_ItemsWithMetaProperty(pprop, &pobjsNew);
		if (FAILED(hr))
			return hr;
		
		return pobjsNew->QueryInterface(__uuidof(T_Collection), (void **) ppobjs);
		}

	HRESULT _UnreferencedItems(T_Collection **ppobjs)
		{
		CComQIPtr<IObjects> pobjs(this);
		CComPtr<IObjects> pobjsNew;

		HRESULT hr = pobjs->UnreferencedItems(&pobjsNew);
		if (FAILED(hr))
			return hr;
		
		return pobjsNew->QueryInterface(__uuidof(T_Collection), (void **) ppobjs);

		}

	HRESULT _get_Count(long *plCount)
		{
		CComQIPtr<IObjects> pobjs(this);

		return pobjs->get_Count(plCount);
		}

#ifdef IMPLEMENT_NewEnum
	HRESULT _get__NewEnum(IUnknown **ppunk)
		{
		CComQIPtr<IObjects> pobjs(this);

		return pobjs->get__NewEnum(ppunk);
		}
#endif
	
	virtual IUnknown *GetControllingUnknown() = 0;
	__declspec(property(get=GetDB)) CGuideDB *m_pdb;
	CGuideDB *GetDB()
		{
		CComQIPtr<CObjects> pobjs(GetControllingUnknown());

		return pobjs->GetDB();
		}
};

class CObjectPropertyBag :
	public CComObjectRootEx<CComObjectThreadModel>,
#if SUPPORT_PROPBAG2
	public IPropertyBag2,
#endif
	public IPropertyBag
{
public:

	void Init(IMetaProperties *pprops, IMetaPropertyTypes *pproptypes)
		{
		m_pprops = pprops;
		m_pproptypes = pproptypes;
		}

protected:
	IMetaProperty * GetProp(_bstr_t bstrPropName, boolean fCreate);
	
BEGIN_COM_MAP(CObjectPropertyBag)
	COM_INTERFACE_ENTRY(IPropertyBag)
#if SUPPORT_PROPBAG2
	COM_INTERFACE_ENTRY(IPropertyBag2)
#endif
END_COM_MAP()

// IPropertyBag interface
	STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog);
	STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pvar);

#if SUPPORT_PROPBAG2
// IPropertyBag2 interface
	STDMETHOD(CountProperties)(long *plCount);
	STDMETHOD(GetPropertyInfo)(ULONG iProp, ULONG cProps, PROPBAG2 *ppropbag2, ULONG *pcProps);
	STDMETHOD(LoadObject)(LPCOLESTR pstrName, DWORD dwHint, IUnknown *punk, IErrorLog *perrlog);
	STDMETHOD(Read)(ULONG cProps, PROPBAG2 *ppropbag2, IErrorLog *perrlog, VARIANT *rgvar, HRESULT *phr);
	STDMETHOD(Write)(ULONG cProps, PROPBAG2 *ppropbag2, VARIANT *rgvar);
#endif

protected:
	CComPtr<IMetaProperties> m_pprops;
	CComPtr<IMetaPropertyTypes> m_pproptypes;
};

#endif //__Object_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\guidestorecp.h ===
#ifndef _GUIDESTORECP_H_
#define _GUIDESTORECP_H_







template <class T>
class CProxyIGuideDataProvidersEvents : public IConnectionPointImpl<T, &DIID_IGuideDataProvidersEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_ItemsChanged()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(198, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}
	HRESULT Fire_ItemAdded(IGuideDataProvider * pprovider)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pprovider;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemRemoved(long idObj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = idObj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemChanged(IGuideDataProvider * pprovider)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pprovider;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};

template <class T>
class CProxyIProgramsEvents : public IConnectionPointImpl<T, &DIID_IProgramsEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_ItemsChanged()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(198, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}
	HRESULT Fire_ItemAdded(IProgram * pprog)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pprog;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemRemoved(long idObj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = idObj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemChanged(IProgram * pprog)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pprog;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};

template <class T>
class CProxyIServicesEvents : public IConnectionPointImpl<T, &DIID_IServicesEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_ItemsChanged()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(198, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}
	HRESULT Fire_ItemAdded(IService * pservice)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pservice;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemRemoved(long idObj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = idObj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemChanged(IService * pservice)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pservice;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};

template <class T>
class CProxyIScheduleEntriesEvents : public IConnectionPointImpl<T, &DIID_IScheduleEntriesEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_ItemsChanged()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(198, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}
	HRESULT Fire_ItemAdded(IScheduleEntry * pschedentry)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pschedentry;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemRemoved(long idObj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = idObj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemChanged(IScheduleEntry * pschedentry)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pschedentry;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};

template <class T>
class CProxyIChannelLineupsEvents : public IConnectionPointImpl<T, &DIID_IChannelLineupsEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_ItemsChanged()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(198, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}
	HRESULT Fire_ItemAdded(IChannelLineup * pchanlineup)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pchanlineup;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemRemoved(long idObj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = idObj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemChanged(IChannelLineup * pchanlineup)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pchanlineup;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};

template <class T>
class CProxyIChannelsEvents : public IConnectionPointImpl<T, &DIID_IChannelsEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_ItemsChanged()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(198, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}
	HRESULT Fire_ItemAdded(IChannel * pchan)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pchan;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemRemoved(long idObj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = idObj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemChanged(IChannel * pchan)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pchan;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};


#if 0
template <class T>
class CProxyIObjectsEvents : public IConnectionPointImpl<T, &DIID_IObjectsEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	HRESULT Fire_ItemsChanged()
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				DISPPARAMS disp = { NULL, NULL, 0, 0 };
				pDispatch->Invoke(198, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		return varResult.scode;
	}
	HRESULT Fire_ItemAdded(IUnknown * pobj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pobj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc3, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemRemoved(long idObj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = idObj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc5, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
	HRESULT Fire_ItemChanged(IUnknown * pobj)
	{
		CComVariant varResult;
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				VariantClear(&varResult);
				pvars[0] = pobj;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(0xc4, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, &varResult, NULL, NULL);
			}
		}
		delete[] pvars;
		return varResult.scode;
	
	}
};
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\object.cpp ===
// object.cpp : Implementation of CObject
#include "stdafx.h"
#include "object.h"
#include "Property.h"
#include "Service.h"
#include "Program.h"
#include "ScheduleEntry.h"

#if 0
#undef TIMING
#define TIMING 1
#include "timing.h"
#endif

class _bstr_t2 : public _bstr_t
{
public:
	_bstr_t2(IID iid)
		{
		OLECHAR sz[40];

		StringFromGUID2(iid, sz, sizeof(sz)/sizeof(OLECHAR));

		_bstr_t::operator =(sz);
		}
};

HRESULT CObject::get_RelatedObjectID(boolean fInverse, long id, long idRel, long *pidRet)
{
	HRESULT hr;
	ADODB::_RecordsetPtr prs;
	const TCHAR *szID = !fInverse ? _T("idObj1") : _T("idObj2");
	const TCHAR *szIDRet = !fInverse ? _T("idObj2") : _T("idObj1");

	if (!fInverse)
		{
		hr = m_pdb->get_RelsByID1Rel(&prs);
		szID = _T("idObj1");
		szIDRet = _T("idObj2");
		}
	else
		{
		hr = m_pdb->get_RelsByID2Rel(&prs);
		szID = _T("idObj2");
		szIDRet = _T("idObj1");
		}

	*pidRet = 0;

	if (m_pdb->FSQLServer())
		{
		TCHAR szFind[32];

		prs->MoveFirst();
		wsprintf(szFind, _T("%s = %d"), szID, id);
		hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
		}
	else
		{
		_variant_t var(id);
		hr = prs->Seek(var, ADODB::adSeekFirstEQ);
		}
	if (FAILED(hr))
		return S_FALSE;
	
	while (!prs->EndOfFile)
		{
		long idCur = prs->Fields->Item[szID]->Value;
		if (idCur != id)
			return S_FALSE;
		
		long idRelCur = prs->Fields->Item["idRel"]->Value;
		if (idRelCur == idRel)
			{
			*pidRet = prs->Fields->Item[szIDRet]->Value;
			return S_OK;
			}
		prs->MoveNext();
		}
	
	return S_FALSE;
}

HRESULT AddRelationship(ADODB::_RecordsetPtr prs, long idObj1, long idRel, long iOrder, long idObj2)
{
	HRESULT hr;

	hr = prs->AddNew();
	if (FAILED(hr))
		return hr;
	
	prs->Fields->Item["idObj1"]->Value = idObj1;
	prs->Fields->Item["idRel"]->Value = idRel;
	prs->Fields->Item["order"]->Value = iOrder;
	prs->Fields->Item["idObj2"]->Value = idObj2;
	hr = prs->Update();

	return hr;
}

HRESULT CObjects::AddRelationshipAt(long idObj1, long idRel, long iItem, long idObj2)
{
	HRESULT hr;
	const long iOrderInc = 10;

	ADODB::_RecordsetPtr prs;
	hr = m_pdb->get_RelsByID1Rel(&prs);
	if (FAILED(hr))
		return hr;

	if (m_pdb->FSQLServer())
		{
		TCHAR szFind[32];

		prs->MoveFirst();
		wsprintf(szFind, _T("idObj1 = %d"), idObj1);
		hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
		}
	else
		{
		_variant_t var(idObj1);
		hr = prs->Seek(var, ADODB::adSeekFirstEQ);
		}
	if (FAILED(hr))
		return hr;

	long iOrder = iOrderInc;
	long i;
	// Scan until we reach the requested item (or end)
	for (i = 0; (i <= iItem) || (iItem == -1); i++)
		{
		if (prs->EndOfFile)
			break;

		long idCur = prs->Fields->Item["idObj1"]->Value;
		if (idCur != idObj1)
			break;
		
		long idRelCur = prs->Fields->Item["idRel"]->Value;
		if (idRelCur != idRel)
			break;

		prs->MoveNext();
		}

	// If there were any items, back up, and use the "order" value for the that one.
	if (i > 0)
		{
		prs->MovePrevious();
		iOrder = prs->Fields->Item["order"]->Value;
		
		// Now open up space by pushing up the items which follow.
		if (iItem == -1)
			iOrder += iOrderInc;
		else
			{
			long iOrderCur = iOrder + 2*iOrderInc;
			long cItems = 1;

			prs->MoveNext();

			// Scan forward looking for a big enough gap.
			while (!prs->EndOfFile)
				{
				long idCur = prs->Fields->Item["idObj1"]->Value;
				if (idCur == idObj1)
					{
					long idRelCur = prs->Fields->Item["idRel"]->Value;
					if (idRelCur == idRel)
						{
						iOrderCur = prs->Fields->Item["order"]->Value;
						if (iOrderCur > iOrder + cItems*2)
							break;
						cItems++;
						prs->MoveNext();
						continue;
						}
					}

				// We've reached the end... just space them all iOrderInc apart.
				iOrderCur = iOrder + (cItems + 1)*iOrderInc;
				break;
				}
			
			long dSpace = (iOrderCur - iOrder)/(cItems + 1);

			// Then scan backward spreading the gap evenly between the items.
			for (long c = 0; c < cItems; c++)
				{
				if (prs->EndOfFile)
					{
					// MovePrevious doen't seem to work from EndOfFile...
					// Use MoveLast instead
					prs->MoveLast();
#ifdef _DEBUG
					long iOrderOld = prs->Fields->Item["order"]->Value;
#endif
					}
				else
					prs->MovePrevious();
				iOrderCur -= dSpace;
#ifdef _DEBUG
				long iOrderOld = prs->Fields->Item["order"]->Value;
				TCHAR sz[256];
				wsprintf(sz, _T("AddRelationshipAt : %d --> %d\n"), iOrderOld, iOrderCur);
				OutputDebugString(sz);
#endif

				prs->Fields->Item["order"]->Value = iOrderCur;
				prs->Update();
				}
			}

		}
	
	// The slot at iOrder has been opened up, so the new relation can now be added.
	
	return AddRelationship(prs, idObj1, idRel, iOrder, idObj2);
}


/////////////////////////////////////////////////////////////////////////////
// CObjectType

STDMETHODIMP CObjectType::get_ID(long *pid)
{
ENTER_API
	{
	ValidateOut<long>(pid, m_id);

	return S_OK;
	}
LEAVE_API
}
HRESULT CObjectType::GetDB(CGuideDB **ppdb)
	{
	*ppdb = m_pdb;
	if (*ppdb == NULL)
		return E_FAIL;

	(*ppdb)->AddRef();

	return S_OK;
	}

STDMETHODIMP CObjectType::get_IID(BSTR *pbstrIID)
{
ENTER_API
	{
	ValidateOut(pbstrIID);

	OLECHAR sz[40];

	StringFromGUID2(m_clsid, sz, sizeof(sz)/sizeof(OLECHAR));

	_bstr_t bstr(sz);

	*pbstrIID = bstr.copy();

	return S_OK;
	}
LEAVE_API
}

HRESULT CObjectType::CreateInstance(long id, IUnknown **ppunk)
{
	HRESULT hr;

	CComPtr<CObject> pobj = NewComObjectCachedLRU(CObject);

	if (pobj == NULL)
		return E_OUTOFMEMORY;

	hr = pobj->Init(id, this);
	if (FAILED(hr))
		return hr;
	
	*ppunk = pobj.Detach();

	return S_OK;
}

HRESULT CObjectType::get_NewCollection(IObjects * *ppobjs)
{
	HRESULT hr;

	CComPtr<CObjects> pobjs = NewComObjectCachedLRU(CObjects);
	if (pobjs == NULL)
		return E_OUTOFMEMORY;
	
	m_pdb->CacheCollection(pobjs);
	
	pobjs->put_DB(m_pdb);
	pobjs->put_ObjectType(this);
	
	if (!m_fKnowCollectionCLSID)
		{
		OLECHAR szCLSID[128];

		wcscpy(szCLSID, L"CLSID\\");
		long cch = wcslen(szCLSID);

		StringFromGUID2(m_clsid, szCLSID + cch, sizeof(szCLSID)/sizeof(OLECHAR) - cch);

		HKEY hkey;
		long lErr;
		lErr = RegOpenKeyEx(HKEY_CLASSES_ROOT, szCLSID, 0, KEY_READ, &hkey);
		if (lErr == ERROR_SUCCESS)
			{
			OLECHAR szCollectionCLSID[128];
			DWORD cb = sizeof(szCollectionCLSID);
			DWORD regtype;
			lErr = RegQueryValueEx(hkey, _T("CollectionCLSID"), 0,
					&regtype, (LPBYTE) szCollectionCLSID, &cb);
			RegCloseKey(hkey);
			if ((lErr == ERROR_SUCCESS) && (regtype == REG_SZ))
				{
				hr = CLSIDFromString(szCollectionCLSID, &m_clsidCollection);
				if (SUCCEEDED(hr))
					m_fKnowCollectionCLSID = TRUE;
				}
			}
		}

	if (m_fKnowCollectionCLSID)
		{
		pobjs->Init(m_clsidCollection);
		}
	
	*ppobjs = pobjs.Detach();
	
	return S_OK;
}

STDMETHODIMP CObjectType::get_New(IUnknown **ppobj)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppobj, NULL);

	HRESULT hr;
	
	ADODB::_RecordsetPtr prs;
	hr = m_pdb->get_ObjsRS(&prs);
	if (FAILED(hr))
		return hr;

	// Create a new record.
	hr = prs->AddNew();

	prs->Fields->Item["idType"]->Value = m_id;

	hr = prs->Update();

	long id = prs->Fields->Item["id"]->Value;
	
	return m_pdb->CacheObject(id, this, ppobj);
	}
LEAVE_API
}

/////////////////////////////////////////////////////////////////////////////
// CObjectTypes

HRESULT CObjectTypes::Init(CGuideDB *pdb)
{
	m_pdb = pdb;

	if (pdb == NULL)
		return E_INVALIDARG;

	// Special case the "Object" object type
	CObjectType *pobjtype;
	pobjtype = Cache(0, _bstr_t2(__uuidof(IUnknown)));

	ADODB::_RecordsetPtr prs;
	m_pdb->get_ObjTypesRS(&prs);
	
	prs->MoveFirst();
	while (!prs->EndOfFile)
		{
		// Read in all the records

		long id = prs->Fields->Item["id"]->Value;
		bstr_t bstrCLSID = prs->Fields->Item["clsid"]->Value;

		pobjtype = Cache(id, bstrCLSID);
		prs->MoveNext();
		}

	return S_OK;
}

STDMETHODIMP CObjectTypes::get_ItemWithCLSID(BSTR bstrCLSID, CObjectType **ppobjtype)
{
ENTER_API
	{
	ValidateIn(bstrCLSID);
	ValidateOutPtr<CObjectType>(ppobjtype, NULL);

	CLSID clsid;

	HRESULT hr = CLSIDFromString(bstrCLSID, &clsid);
	if (hr == CO_E_CLASSSTRING)
		return hr;

	t_map::iterator it = m_map.find(clsid);
	if (it == m_map.end())
		return E_INVALIDARG;

	*ppobjtype = (*it).second;

	return S_OK;
	}
LEAVE_API
}

CObjectType *CObjectTypes::Cache(long id, BSTR bstrCLSID)
{
	CObjectType *pobjtype = NULL;
	CLSID clsid;

	HRESULT hr = CLSIDFromString(bstrCLSID, &clsid);

	if (hr == CO_E_CLASSSTRING)
		return NULL;

	t_map::iterator it = m_map.find(clsid);
	if (it != m_map.end())
		{
		pobjtype = (*it).second;
		}
	else
		{
		pobjtype = new CObjectType;

		if (pobjtype == NULL)
			return NULL;

		pobjtype->Init(m_pdb, id, clsid);

		m_map[clsid] = pobjtype;
		m_pdb->put_ObjectType(id, pobjtype);
		}

	return pobjtype;
}

STDMETHODIMP CObjectTypes::get_AddNew(BSTR bstrCLSID, CObjectType **ppobjtype)
{
ENTER_API
	{
	ValidateIn(bstrCLSID);
	ValidateOutPtr<CObjectType>(ppobjtype, NULL);

	HRESULT hr;

	hr = get_ItemWithCLSID(bstrCLSID, ppobjtype);
	if (SUCCEEDED(hr))
		return hr;

	ADODB::_RecordsetPtr prs;
	hr = m_pdb->get_ObjTypesRS(&prs);
	if (FAILED(hr))
		return hr;
	// Create a new record.
	hr = prs->AddNew();
	if (FAILED(hr))
		return hr;

	prs->Fields->Item["clsid"]->Value = bstrCLSID;

	hr = prs->Update();
	if (FAILED(hr))
		return hr;

	long id = prs->Fields->Item["id"]->Value;

	*ppobjtype = Cache(id, bstrCLSID);

	if (*ppobjtype == NULL)
		return E_OUTOFMEMORY;

	return S_OK;
	}
LEAVE_API
}

#if 0
STDMETHODIMP CObjectTypes::get_AddNew(CLSID clsid, CObjectType **ppobjtype)
{
ENTER_API
	{
	ValidateOutPtr<CObjectType>(ppobjtype, NULL);

	return S_OK;
	}
LEAVE_API
}
#endif

/////////////////////////////////////////////////////////////////////////////
// CObject

STDMETHODIMP CObject::Init(long id, CObjectType *pobjtype)
{
	HRESULT hr;
	if (m_id != 0)
		return E_INVALIDARG;
	
	m_id = id;
	m_pobjtype = pobjtype;
	_ASSERTE(m_pobjtype != NULL);
	m_pdb = m_pobjtype->m_pdb;

	if (m_pobjtype->m_id != 0)
		{
		hr = m_punk.CoCreateInstance(pobjtype->m_clsid, GetControllingUnknown());
		if (FAILED(hr))
			return hr;
		}

	return S_OK;
}

STDMETHODIMP CObject::Save(IUnknown *punk)
{
    HRESULT hr;
    if (punk == NULL)
	    punk = this;

    CComQIPtr<IPersistPropertyBag> ppersistpropbag(punk);
    if (ppersistpropbag != NULL)
	    {
	    hr = CreatePropBag(ppersistpropbag);

	    hr = ppersistpropbag->Save(m_ppropbag, TRUE, FALSE);
	    }
    else
	    {
		CComQIPtr<IPersistStream> ppersiststream(punk);
		if (ppersiststream != NULL)
			{
			CComPtr<IStream> pstream;
			hr = CreateStreamOnHGlobal(NULL, TRUE, &pstream);
			if (FAILED(hr))
				return hr;

			// Write a tag to indicate IPersistStream was used.
			char ch = Format_IPersistStream;
			ULONG cb = sizeof(ch);
			hr = pstream->Write(&ch, cb, &cb);
			if (FAILED(hr))
				return hr;
			
			// Now have the object save it's bits.
			hr = ppersiststream->Save(pstream, TRUE);
			if (FAILED(hr))
				return hr;
			
			// Create a SafeArray from the bits.
			HANDLE hdata;
			hr = GetHGlobalFromStream(pstream, &hdata);
			if (FAILED(hr))
				return hr;
			
			long cbData = GlobalSize(hdata);
			SAFEARRAY *parray = SafeArrayCreateVector(VT_UI1, 0, cbData);
			if (parray == NULL)
				return E_OUTOFMEMORY;
			
			BYTE *pbDst;
			hr = SafeArrayAccessData(parray, (void **) &pbDst);
			if (FAILED(hr))
				return hr;
			BYTE *pbSrc = (BYTE *) GlobalLock(hdata);

			memcpy(pbDst, pbSrc, cbData);

			GlobalUnlock(hdata);
			SafeArrayUnaccessData(parray);

			// Put the SafeArray in a variant
			_variant_t varT;
			varT.vt = VT_ARRAY | VT_UI1;
			varT.parray = parray;
			
			// Write the bits to the database
			ADODB::_RecordsetPtr prs;
			hr = m_pdb->get_ObjsByID(&prs);
			if (FAILED(hr))
				return hr;

			_variant_t var = m_id;
			prs->Seek(var, ADODB::adSeekFirstEQ);
			if (prs->EndOfFile)
				return E_FAIL;

			hr = prs->Fields->Item["oValue"]->AppendChunk(varT);
			if (FAILED(hr))
				return hr;
			}
		else
			{
			return E_INVALIDARG;
			}
	    }
    
    return hr;
}

STDMETHODIMP CObject::Load()
{
    HRESULT hr;
    CComQIPtr<IPersistPropertyBag> ppersistpropbag(this);
    if (ppersistpropbag != NULL)
	    {
	    hr = CreatePropBag(ppersistpropbag);

	    hr = ppersistpropbag->Load(m_ppropbag, NULL);
	    }
    else
	    {
		CComQIPtr<IPersistStream> ppersiststream(this);
		if (ppersiststream != NULL)
			{
			ADODB::_RecordsetPtr prs;
			hr = m_pdb->get_ObjsByID(&prs);
			if (FAILED(hr))
				return hr;
			_variant_t var = m_id;
			prs->Seek(var, ADODB::adSeekFirstEQ);
			if (prs->EndOfFile)
				return E_FAIL;

			long cb;
			ADODB::FieldPtr pfield;
			pfield.Attach(prs->Fields->Item["oValue"]);
			hr = pfield->get_ActualSize(&cb);
			if (FAILED(hr))
				return hr;

			_variant_t varData;
			hr = pfield->GetChunk(cb, &varData);
			if (FAILED(hr))
				return hr;
			
			if ((varData.vt & VT_ARRAY) == 0)
				return E_FAIL;
			
			BYTE *pbSrc;
			hr = SafeArrayAccessData(varData.parray, (void **) &pbSrc);
			if (FAILED(hr))
				return hr;
			
			HANDLE hdata;
			BOOL fFree = FALSE;
			hdata = GlobalHandle(pbSrc);
			if (hdata == NULL)
				{
				hdata = GlobalAlloc(GHND, cb);
				if (hdata == NULL)
					{
					SafeArrayUnaccessData(varData.parray);
					return E_OUTOFMEMORY;
					}
				
				BYTE *pbDst = (BYTE *) GlobalLock(hdata);

				memcpy(pbDst, pbSrc, cb);
				fFree = TRUE;
				}
			else
				{
				BYTE *pbTest = (BYTE *) GlobalLock(hdata);
				int i = 0;
				if (pbTest != pbSrc)
					i++;
				GlobalUnlock(hdata);
				}

			{
			CComPtr<IStream> pstream;
			hr = CreateStreamOnHGlobal(hdata, fFree, &pstream);
			if (FAILED(hr))
				{
				if (fFree)
					GlobalFree(hdata);
				return hr;
				}
			
			char ch;
			ULONG cbT = sizeof(ch);
			hr = pstream->Read(&ch, cbT, &cbT);
			switch (ch)
				{
				case Format_IPersistStream:
					hr = ppersiststream->Load(pstream);
					break;
				
				default:
					hr = STG_E_DOCFILECORRUPT;
				}
			}
			SafeArrayUnaccessData(varData.parray);
			}
	    }

	return S_OK;
}

HRESULT CObject::CreatePropBag(IPersist *ppersist)
{
    HRESULT hr;
    if (m_ppropbag == NULL)
	    {
	    CComPtr<IMetaProperties> pprops;
	    hr = get_MetaProperties(&pprops);
	    if (FAILED(hr))
		    return hr;
	    
	    CLSID clsid;
	    hr = ppersist->GetClassID(&clsid);
	    if (FAILED(hr))
		    return hr;
	    
	    OLECHAR sz[40];

	    StringFromGUID2(clsid, sz, sizeof(sz)/sizeof(OLECHAR));

	    _bstr_t bstrCLSID(sz);
	    CComPtr<IMetaPropertySet> ppropset;
	    hr = m_pdb->get_MetaPropertySet(bstrCLSID, &ppropset);
	    CComPtr<IMetaPropertyTypes> pproptypes;
	    hr = ppropset->get_MetaPropertyTypes(&pproptypes);
	    m_ppropbag = NewComObject(CObjectPropertyBag);
	    m_ppropbag->Init(pprops, pproptypes);
	    }
	
	return S_OK;
}

STDMETHODIMP CObject::get_Type(CObjectType **ppobjtype)
{
ENTER_API
	{
	ValidateOutPtr<CObjectType>(ppobjtype, NULL);

	_ASSERTE(m_pobjtype != NULL);
	*ppobjtype = m_pobjtype;

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CObject::get_ID(long *pid)
{
ENTER_API
	{
	ValidateOut<long>(pid, m_id);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CObject::get_MetaProperties(IMetaProperties **ppprops)
{
ENTER_API
	{
	ValidateOutPtr<IMetaProperties>(ppprops, NULL);
	HRESULT hr;

	if (m_pprops == NULL)
		{
		hr = m_pdb->get_MetaPropertiesOf((IUnknown *) this, &m_pprops);
		if (FAILED(hr))
			return hr;
		}

	if (m_pprops == NULL)
		return E_OUTOFMEMORY;
	
	return m_pprops.QueryInterface(ppprops);
	}
LEAVE_API
}

STDMETHODIMP CObject::get_ItemInverseRelatedBy(long idRel, IUnknown **ppobj1)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppobj1, NULL);

	HRESULT hr;

	long idObj1;
	hr = get_RelatedObjectID(TRUE, m_id, idRel, &idObj1);
	if (hr == S_FALSE || FAILED(hr))
		return hr;

	return m_pdb->CacheObject(idObj1, (long) 0, ppobj1);
	}
LEAVE_API
}

HRESULT CObject::get_ItemsRelatedBy(CObjectType *pobjtype,
		long idRel, boolean fInverse, IObjects **ppobjs)
{
	HRESULT hr;
	
	hr = pobjtype->get_NewCollection(ppobjs);
	if (FAILED(hr))
		return hr;
	
	CComQIPtr<CObjects> pobjs(*ppobjs);

	hr = pobjs->InitRelation(this, idRel, fInverse);

	return hr;
}

STDMETHODIMP CObject::get_ItemsInverseRelatedBy(CObjectType *pobjtype, long idRel, IObjects **ppobjs)
{
ENTER_API
	{
	ValidateInPtr<CObjectType>(pobjtype);
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	return get_ItemsRelatedBy(pobjtype, idRel, TRUE, ppobjs);
	}
LEAVE_API
}

STDMETHODIMP CObject::get_ItemRelatedBy(long idRel, IUnknown **ppobj2)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppobj2, NULL);

	HRESULT hr;

	long idObj2;
	hr = get_RelatedObjectID(FALSE, m_id, idRel, &idObj2);
	if (hr == S_FALSE || FAILED(hr))
		return hr;

	return m_pdb->CacheObject(idObj2, (long) 0, ppobj2);
	}
LEAVE_API
}

STDMETHODIMP CObject::put_ItemRelatedBy(long idRel, IUnknown *pobj2)
{
ENTER_API
	{
	ValidateInPtr<IUnknown>(pobj2);

	HRESULT hr;
	long idObj2;

	m_pdb->get_IdOf(pobj2, &idObj2);


	ADODB::_RecordsetPtr prs;

	hr = m_pdb->get_RelsByID1Rel(&prs);

	if (m_pdb->FSQLServer())
		{
		TCHAR szFind[32];

		prs->MoveFirst();
		wsprintf(szFind, _T("idObj1 = %d"), m_id);
		hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
		}
	else
		{
		_variant_t var(m_id);
		hr = prs->Seek(var, ADODB::adSeekFirstEQ);
		}
	if (FAILED(hr))
		return hr;
	
	while (!prs->EndOfFile)
		{
		long idCur = prs->Fields->Item["idObj1"]->Value;
		if (idCur != m_id)
			break;
		
		long idRelCur = prs->Fields->Item["idRel"]->Value;
		if (idRelCur == idRel)
			{
			prs->Fields->Item["idObj2"]->Value = idObj2;
			return S_OK;
			}
		prs->MoveNext();
		}
	
	return AddRelationship(prs, m_id, idRel, 0, idObj2);
	}
LEAVE_API
}

STDMETHODIMP CObject::get_ItemsRelatedBy(CObjectType *pobjtype, long idRel, IObjects **ppobjs)
{
ENTER_API
	{
	ValidateInPtr<CObjectType>(pobjtype);
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	return get_ItemsRelatedBy(pobjtype, idRel, FALSE, ppobjs);
	}
LEAVE_API
}

HRESULT CObjects::Clone(IObjects **ppobjs)
{
	HRESULT hr;
	
	hr = m_pobjtype->get_NewCollection(ppobjs);
	if (FAILED(hr))
		return hr;

	CComQIPtr<CObjects> pobjs(*ppobjs);

	pobjs->Copy(this);
	
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CObjects

// Sample Query:
//
// SELECT DISTINCT Objects.id
// FROM ((((
//   Objects
//     INNER JOIN ObjectRelationships
//       ON Objects.id = ObjectRelationships.idObj2)
//     INNER JOIN Properties AS Properties_0
//       ON Objects.id = Properties_0.idObj)
//     INNER JOIN Properties AS Properties_1
//       ON Objects.id = Properties_1.idObj)
//     INNER JOIN Properties AS Properties_2
//       ON Objects.id = Properties_2.idObj)
// WHERE
//   (((
//   Objects.idType = 1)
//   AND (ObjectRelationships.idObj1 = 10))
//     AND
//       (
//       ((Properties_0.idPropType=15) AND (Properties_0.sValue="Arthur"))
//         OR
//       ((Properties_2.idPropType=15) AND (Properties_2.sValue="Jeopardy!"))
//       )
//   );

HRESULT CObjects::GetQuery(QueryType qtype, _bstr_t *pbstr)
{
	TCHAR sz[8*1024];
	HRESULT hr;
	_bstr_t bstrCmd;
	_bstr_t bstrFrom;
	_bstr_t bstrOrder;
	_bstr_t bstrWhere;
	long cWhere = 0;

	switch (qtype)
		{
		case Select:
			bstrCmd = _T("SELECT DISTINCT Objects.id, Objects.idType ");
			break;

		case Delete:
			bstrCmd = _T("DELETE Objects.* ");
			break;
		}

	bstrFrom = "Objects";

	_ASSERTE(m_pobjtype != NULL);

	long idType = 0;

	hr = m_pobjtype->get_ID(&idType);
	if (FAILED(hr))
		return hr;
	
	if (idType != 0)
		{
		wsprintf(sz, _T("Objects.idType = %d"), idType);
		bstrWhere = sz;
		cWhere++;
		}
	
	if (m_fOnlyUnreferenced)
		{
		if (cWhere > 0)
			bstrWhere = bstrWhere + " AND ";

		bstrWhere =  bstrWhere
			+ "(Objects.id NOT IN"
			+    " (SELECT DISTINCT ObjectRelationships.idObj2 FROM ObjectRelationships))"
			+ " AND (Objects.id NOT IN"
			+    " (SELECT DISTINCT Properties.lValue FROM Properties WHERE Properties.ValueType = 13))";
		cWhere++;
		}
	
	if ((qtype == Select) && (m_idPropTypeKey != 0))
		{
		switch (m_vtKey)
			{
			default:
				return E_UNEXPECTED;

			case VT_I2:
			case VT_I4:
				bstrCmd = bstrCmd + ", Props_Key.lValue";
				bstrOrder = _T(" ORDER BY Props_Key.lValue");
				break;
			
			case VT_R4:
			case VT_R8:
			case VT_DATE:
				bstrCmd = bstrCmd + ", Props_Key.fValue";
				bstrOrder = _T(" ORDER BY Props_Key.fValue");
				break;
			
			case VT_BSTR_BLOB:
			case VT_BSTR:
				bstrCmd = bstrCmd + ", left(Props_Key.sValue,255) AS sValue";
				bstrOrder = _T(" ORDER BY left(Props_Key.sValue,255)");
				break;
			}

		wsprintf(sz, _T("(%s INNER JOIN Properties AS Props_Key")
			_T(" ON Objects.id = Props_Key.idObj)"),
			(const TCHAR *) bstrFrom);
		bstrFrom = sz;
		if (cWhere++ > 0)
			bstrWhere = bstrWhere + " AND ";
		wsprintf(sz, _T("(Props_Key.idPropType = %d) AND (Props_Key.ValueType = %d)"),
				m_idPropTypeKey, m_vtKey);
		bstrWhere = bstrWhere + sz;
		if (m_idProviderKey != 0)
			{
			wsprintf(sz, _T("AND (Props_Key.idProvider = %d)"), m_idProviderKey);
			bstrWhere = bstrWhere + sz;
			}
		if (m_idLangKey != 0)
			{
			wsprintf(sz, _T("AND (Props_Key.idLanguage = %d)"), m_idLangKey);
			bstrWhere = bstrWhere + sz;
			}
		
		}
	
	if (m_pobjRelated != NULL)
		{
		const TCHAR *szRelatedField;
		const TCHAR *szResultField;

		if (!m_fInverse)
			{
			szRelatedField = _T("idObj1");
			szResultField  = _T("idObj2");
			if (qtype == Select)
				{
				bstrCmd = bstrCmd + _T(", ObjectRelationships.[order]");
				bstrOrder = _T(" ORDER BY ObjectRelationships.[order]");
				}
			}
		else
			{
			szRelatedField = _T("idObj2");
			szResultField  = _T("idObj1");
			}

		wsprintf(sz, _T("(%s INNER JOIN ObjectRelationships")
				_T(" ON Objects.id = ObjectRelationships.%s)"),
				(const TCHAR *) bstrFrom, szResultField);
		
		bstrFrom = sz;

		long id;

		m_pdb->get_IdOf(m_pobjRelated, &id);

		if (cWhere++ == 0)
			{
			wsprintf(sz, _T("(ObjectRelationships.idRel = %d)")
					_T(" AND (ObjectRelationships.%s = %d)"),
					m_idRel, szRelatedField, id);
			}
		else
			{
			wsprintf(sz, _T("(%s) AND ")
					_T("(ObjectRelationships.idRel = %d)")
					_T(" AND (ObjectRelationships.%s = %d)"),
					(const TCHAR *) bstrWhere,
					m_idRel, szRelatedField, id);
			}
		bstrWhere = sz;
		}

	if (m_ppropcond != NULL)
		{
		long cProps = 0;
		CComQIPtr<CMetaPropertyCondition> ppropcond(m_ppropcond);
		_bstr_t bstrWhereClause;

		hr = ppropcond->get_QueryClause(cProps, &bstrWhereClause);
		if (FAILED(hr))
			return hr;

		if (cProps > 0)
			{
			if (cWhere > 0)
				{
				wsprintf(sz, _T("(%s) AND (%s)"),
					(const TCHAR *) bstrWhere,
					(const TCHAR *) bstrWhereClause);
				
				bstrWhere = sz;
				}
			else
				{
				bstrWhere += bstrWhereClause;
				}
			cWhere++;
			
			for (int i = 0; i < cProps; i++)
				{
				wsprintf(sz, _T("(%s INNER JOIN Properties AS Props_%d")
					_T(" ON Objects.id = Props_%d.idObj)"),
					(const TCHAR *) bstrFrom, i, i);
				bstrFrom = sz;
				}
			}
		}

	if (!!bstrWhere)
		{
		bstrWhere = _bstr_t(" WHERE ") + bstrWhere;
		}

	*pbstr = bstrCmd + _T(" FROM ") + bstrFrom
				+ bstrWhere + bstrOrder + _T(";");

	return S_OK;
}

HRESULT CObjects::GetRS(ADODB::_Recordset **pprs)
{
	HRESULT hr;
#if 1
	BOOL fQuery = TRUE;
#else
	BOOL fQuery = ((m_ppropcond != NULL) || (m_pobjRelated != NULL));
#endif

	if (m_prs == NULL)
		{
		if (fQuery)
			{
			_bstr_t bstrQuery;

			hr = GetQuery(Select, &bstrQuery);
			if (FAILED(hr))
				return hr;

			hr = m_pdb->NewQuery(bstrQuery, &m_prs);
			if (FAILED(hr))
				return hr;
			}
		else
			{
			hr = m_pdb->get_ObjsByType(&m_prs);
			if (FAILED(hr))
				return hr;
			}
		}
	
	if (m_prs == NULL)
		return E_FAIL;

	(*pprs = m_prs)->AddRef();

	return fQuery ? S_OK : S_FALSE;
}

STDMETHODIMP CObjects::get_Count(long *plCount)
{
ENTER_API
	{
	ValidateOut<long>(plCount, 0);
	DeclarePerfTimer("get_Count");

	HRESULT hr;

	if (m_cItems == -1)
		{
		long idType;
		long cItems = 0;
		
		ADODB::_RecordsetPtr prs;

		hr = GetRS(&prs);
		if (FAILED(hr))
			return hr;
		
		bool fFast = (hr == S_OK);
#if 0
		if (fFast)
			{
			PerfTimerReset();
			hr = prs->MoveLast();
			hr = prs->get_RecordCount(&cItems);
			if (SUCCEEDED(hr) && (cItems >= 0))
			    {
			    PerfTimerDump("Succeeded get_RecordCount");
			    goto ReturnIt;
			    }
			cItems = 0;
			PerfTimerDump("Failed get_RecordCount");
			}
#endif

		PerfTimerReset();
		hr = m_pobjtype->get_ID(&idType);
		if (FAILED(hr))
			return E_FAIL;

		if (!fFast && idType != 0)
			{
			if (m_pdb->FSQLServer())
				{
				TCHAR szFind[32];

				prs->MoveFirst();
				wsprintf(szFind, _T("idType = %d"), idType);
				hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
				}
			else
				{
				_variant_t var(idType);
				prs->Seek(var, ADODB::adSeekAfterEQ);
				}
			}
		else
			{
			hr = prs->MoveFirst();
			if (hr == MAKE_HRESULT(SEVERITY_ERROR, FACILITY_CONTROL, ADODB::adErrNoCurrentRecord))
				goto ReturnIt;
			}

		// UNDONE: This is not the most efficient, but it's what works for now.
		while (!prs->EndOfFile)
			{
			if (idType != 0)
				{
				long idType2 = prs->Fields->Item["idType"]->Value;
				if (idType != idType2)
					break;
				}
			cItems++;
			prs->MoveNext();
			}
		PerfTimerDump("Count done");
ReturnIt:
		m_cItems = cItems;
		}

	*plCount = m_cItems;
	
	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_Item(VARIANT varIndex, IUnknown **ppobj)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppobj, NULL);

	HRESULT hr;
	_variant_t var(varIndex);

	try
		{
		var.ChangeType(VT_I4);
		}
	catch (_com_error)
		{
		return E_INVALIDARG;
		}
	
	long i = var.lVal;

	if (i < 0)
		return E_INVALIDARG;

	long idType;

	hr = m_pobjtype->get_ID(&idType);
	if (FAILED(hr))
		return E_FAIL;
	
	ADODB::_RecordsetPtr prs;

	hr = GetRS(&prs);
	if (FAILED(hr))
		return hr;

	if (hr == S_OK)
		{
		prs->MoveFirst();
		}
	else
		{
		if (m_pdb->FSQLServer())
			{
			TCHAR szFind[32];

			wsprintf(szFind, _T("idType = %d"), idType);
			hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
			}
		else
			{
			var = idType;
			prs->Seek(var, ADODB::adSeekAfterEQ);
			}
		}

	if (prs->EndOfFile)
		return E_INVALIDARG;

	if (i > 0)
		prs->Move(i);

	if (prs->EndOfFile)
		return E_INVALIDARG;

	long idType2 = prs->Fields->Item["idType"]->Value;
	if ((idType != 0) && (idType != idType2))
		return E_INVALIDARG;
	
	long idObj = prs->Fields->Item["id"]->Value;

	if (idType == 0)
		return m_pdb->CacheObject(idObj, idType2, ppobj);

	return m_pdb->CacheObject(idObj, m_pobjtype, ppobj);
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemWithID(long id, IUnknown **ppobj)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppobj, NULL);
	HRESULT hr;

	hr = m_pdb->get_Object(id, ppobj);
	if (SUCCEEDED(hr))
		return hr;

	long idType;

	hr = m_pobjtype->get_ID(&idType);
	if (FAILED(hr))
		return E_FAIL;
	
	ADODB::_RecordsetPtr prs;

	hr = m_pdb->get_ObjsByID(&prs);

		if (m_pdb->FSQLServer())
			{
			TCHAR szFind[32];

			prs->MoveFirst();
			wsprintf(szFind, _T("idObj = %d"), id);
			hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
			}
		else
			{
			_variant_t var = id;
			prs->Seek(var, ADODB::adSeekFirstEQ);
			}

	if (prs->EndOfFile)
		return E_INVALIDARG;

	if (idType != 0)
		{
		long idType2 = prs->Fields->Item["idType"]->Value;
		if (idType != idType2)
			return E_INVALIDARG;
		}

	return m_pdb->CacheObject(id, m_pobjtype, ppobj);
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemWithKey(VARIANT varKey, IUnknown **ppobj)
{
ENTER_API
	{
	HRESULT hr;
	_bstr_t bstrKey;

	try
		{
		bstrKey = varKey;
		}
	catch (_com_error)
		{
		return E_INVALIDARG;
		}

	ADODB::_RecordsetPtr prs;

	hr = GetRS(&prs);
	if (FAILED(hr))
		return hr;

	_bstr_t bstrFind;

	switch (varKey.vt)
		{
		default:
			return E_INVALIDARG;

		case VT_I2:
		case VT_I4:
			bstrFind = _T("lValue = ") + bstrKey;
			break;
		
		case VT_R4:
		case VT_R8:
		case VT_DATE:
			bstrFind = _T("fValue = ") + bstrKey;
			break;
		
		case VT_BSTR_BLOB:
		case VT_BSTR:
			// UNDONE: Handle embedded quotes in bstrKey
			bstrFind = _T("sValue = '") + bstrKey + _T("'");
			break;
		}

	DeclarePerfTimer("get_ItemWithKey");
	PerfTimerReset();
	hr = prs->MoveFirst();
	hr = prs->Find(bstrFind, 0, ADODB::adSearchForward);
	if (FAILED(hr))
		return hr;
	PerfTimerDump("MoveFirst + Find");

	if (prs->EndOfFile)
		return E_INVALIDARG;

	long idType = prs->Fields->Item["idType"]->Value;
	
	long idObj = prs->Fields->Item["id"]->Value;

	return m_pdb->CacheObject(idObj, idType, ppobj);
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemsWithType(BSTR bstrCLSID, IObjects **ppobjs)
{
ENTER_API
	{
	ValidateOutPtr<IObjects>(ppobjs, NULL);
	CObjectType *pobjtype;

	m_pdb->get_ObjectType(bstrCLSID, &pobjtype);

	return get_ItemsWithType(pobjtype, ppobjs);
	}
LEAVE_API
}

HRESULT CObjects::get_ItemsWithType(CObjectType *pobjtype, IObjects **ppobjs)
{
ENTER_API
	{
	ValidateInPtr<CObjectType>(pobjtype);
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	// Objects can't have two types... if this collection is for objects of
	// a specific type, then it contains no objects of the requested type.
	_ASSERTE(m_pobjtype != NULL);

	long idType;
	m_pobjtype->get_ID(&idType);
	if (idType != 0)
		return E_INVALIDARG;
	
	// If there's no related object clause nor a property condition then
	// we're after the base collection of objects of the specified type.
	// That's cached in by m_pdb.
	if ((m_pobjRelated == NULL) && (m_ppropcond == NULL))
		return m_pdb->get_ObjectsWithType(pobjtype, ppobjs);

	HRESULT hr = pobjtype->get_NewCollection(ppobjs);
	if (FAILED(hr))
		return hr;

	CComQIPtr<CObjects> pobjs(*ppobjs);

	pobjs->Copy(this);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemsWithMetaProperty(IMetaProperty *pprop, IObjects **ppobjs)
{
ENTER_API
	{
	ValidateInPtr<IMetaProperty>(pprop);
	ValidateOutPtr<IObjects>(ppobjs);

	HRESULT hr;
	CComPtr<IMetaPropertyCondition> pcond;

	hr = pprop->get_Cond(_bstr_t("="), &pcond);
	if (FAILED(hr))
		return hr;
	
	hr = get_ItemsWithMetaPropertyCond(pcond, ppobjs);

	return hr;
	}
LEAVE_API
}

STDMETHODIMP CObjects::UnreferencedItems(IObjects **ppobjs)
{
ENTER_API
	{
	ValidateOutPtr<IObjects>(ppobjs, NULL);
	HRESULT hr;

	hr = Clone(ppobjs);
	if (FAILED(hr))
		return hr;
	
	CComQIPtr<CObjects> pobjs(*ppobjs);
	if (FAILED(hr))
		return hr;

	hr = pobjs->put_OnlyUnreferenced(TRUE);

	return hr;
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemsWithMetaPropertyCond(IMetaPropertyCondition *ppropcond, IObjects **ppobjs)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyCondition>(ppropcond);
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	HRESULT hr;
	CComPtr<IMetaPropertyCondition> ppropcond2;

	if (m_ppropcond != NULL)
		{
		hr = m_ppropcond->get_And(ppropcond, &ppropcond2);
		if (FAILED(hr))
			return hr;
		
		ppropcond = ppropcond2;
		}

	hr = Clone(ppobjs);

	CComQIPtr<CObjects> pobjs(*ppobjs);

	pobjs->put_MetaPropertyCond(ppropcond);
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemsByKey(IMetaPropertyType *pproptype,
		IGuideDataProvider *pprovider, long idLang, long vt, IObjects * *ppobjs)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyType>(pproptype);
	ValidateInPtr_NULL_OK<IGuideDataProvider>(pprovider);
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	switch (vt)
		{
		default:
			return E_INVALIDARG;

		case VT_I2:
		case VT_I4:
		case VT_R4:
		case VT_R8:
		case VT_DATE:
		case VT_BSTR_BLOB:
		case VT_BSTR:
			break;
		}

	HRESULT hr = Clone(ppobjs);
	if (FAILED(hr))
		return hr;

	CComQIPtr<CObjects> pobjs(*ppobjs);

	pobjs->put_Key(pproptype, pprovider, idLang, vt);

	return hr;
	}
LEAVE_API
}

STDMETHODIMP CObjects::Reset()
{
	m_cItems = -1;  // UNDONE: Is "m_cItems++;" sufficient?
	if (m_prs != NULL)
		m_prs.Release();
	
	return S_OK;
}

STDMETHODIMP CObjects::get_AddNew(IUnknown **ppobj)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppobj, NULL);

	HRESULT hr;

	// Force the collection to be requeried so the new item shows up.
	Reset();

	if ((m_pobjRelated == NULL) && (m_ppropcond == NULL))
		{
		// This collection is the base collection for this type.

		hr = m_pobjtype->get_New(ppobj);
		if (FAILED(hr))
			return hr;

		//UNDONE: Too many AddRef()s?
		if (*ppobj != NULL)
			(*ppobj)->AddRef();
	
		// Only fire the ItemAdded() event when adding to the base collection.
		if (SUCCEEDED(hr))
		    {
		    long id;
			long idType;

		    m_pdb->get_IdOf(*ppobj, &id);
			m_pobjtype->get_ID(&idType);
		    m_pdb->Broadcast_ItemAdded(id, idType);
		    }
		}
	else
		{
		hr = get_AddNewAt(-1, ppobj);
		}
	
	return hr;
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_AddNewAt(long index, IUnknown **ppobj)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppobj, NULL);
	HRESULT hr = E_INVALIDARG;

	// Can't add items if there is no object type
	_ASSERTE(m_pobjtype != NULL);

	// Force the collection to be requeried so the new item shows up.
	Reset();
	
	if ((m_pobjRelated == NULL) && (m_ppropcond == NULL) && (index != -1))
		{
		hr = get_AddNew(ppobj);
		}
	else if (m_pobjRelated != NULL)
		{
		// This is a subset of the base collection of items of this type.
		// It contains only the items of the specified type which are
		// related to m_pobjRelated by the relationship m_idRel.
		// We must first create a new item in the base collection
		// and then add it to the subset.

		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(m_pobjtype, &pobjs);
		if (FAILED(hr))
			return hr;
		
		hr = pobjs->get_AddNew(ppobj);
		if (FAILED(hr))
			return hr;
		
		hr = AddAt(*ppobj, index);
		}

	return hr;
	}
LEAVE_API
}

STDMETHODIMP CObjects::AddAt(IUnknown *pobj, long index)
{
ENTER_API
	{
	ValidateInPtr<IUnknown>(pobj);

	HRESULT hr;

	// Can't add an item at a particular index if this is not an ordered collection.
	// Order is only expressed for related objects and not for inverse related objects.
	if (m_pobjRelated == NULL || m_fInverse)
		return E_INVALIDARG;
		
	m_cItems = -1;  // UNDONE: Is "m_cItems++;" sufficient?
	if (m_prs != NULL)
		m_prs.Release();
	
	long idObjRelated;

	m_pdb->get_IdOf(m_pobjRelated, &idObjRelated);

	long idObj;
	m_pdb->get_IdOf(pobj, &idObj);

	hr = AddRelationshipAt(idObjRelated, m_idRel, index, idObj);

	return hr;
	}
LEAVE_API
}

STDMETHODIMP CObjects::Remove(VARIANT varIndex)
{
ENTER_API
	{
	HRESULT hr;
	CComPtr<IUnknown> pobj;

	switch (varIndex.vt)
		{
		case VT_UNKNOWN:
		case VT_DISPATCH:
			{
			hr = varIndex.punkVal->QueryInterface(__uuidof(IUnknown), (void **) &pobj);
			if (FAILED(hr))
				return hr;
			}
			break;
		
		default:
			{
			hr = get_Item(varIndex, &pobj);
			if (FAILED(hr))
				return hr;
			}
		}

	return (m_pobjRelated != NULL) ? RemoveFromRelationship(pobj) : Remove(pobj);
	}
LEAVE_API
}

HRESULT CObjects::Remove(IUnknown *pobjRemove)
{
	HRESULT hr;
	CComQIPtr<CObject> pobj(pobjRemove);
	long idObj;
	CObjectType *pobjtype;

	pobj->get_Type(&pobjtype);

	long idtype;
	m_pobjtype->get_ID(&idtype);

	if ((idtype != NULL) && (pobjtype != m_pobjtype))
		return E_INVALIDARG;

	pobj->get_ID(&idObj);

	m_pdb->UncacheObject(idObj);

	// Delete all the properties
	TCHAR sz[1024];

	wsprintf(sz, _T("DELETE * FROM Properties WHERE idObj=%d;"), idObj);

	hr = m_pdb->Execute(_bstr_t(sz));

	// Remove any properties pointing to the deleted object
	wsprintf(sz,
		_T("DELETE * FROM Properties WHERE (ValueType = 13) AND (lValue = %d);"), idObj);

	hr = m_pdb->Execute(_bstr_t(sz));

	// Remove the object from all relationships

	wsprintf(sz, _T("DELETE * FROM ObjectRelationships")
			_T(" WHERE (idObj1=%d) OR (idObj2=%d);"), idObj, idObj);

	hr = m_pdb->Execute(_bstr_t(sz));

	// Remove the object.

	wsprintf(sz, _T("DELETE * FROM Objects WHERE id=%d;"), idObj);

	hr = m_pdb->Execute(_bstr_t(sz));

	if (SUCCEEDED(hr))
	    {
	    long idType = 0;
		pobjtype->get_ID(&idType);
	    m_pdb->Broadcast_ItemRemoved(idObj, idType);
	    }

	Reset();
	
	return hr;
}

STDMETHODIMP CObjects::RemoveAll()
{
ENTER_API
	{
	HRESULT hr;
	_bstr_t bstrQuery;
	boolean fTransacted = TRUE;

	hr = GetQuery(Delete, &bstrQuery);
	if (FAILED(hr))
		return hr;
	
	hr = m_pdb->BeginTrans();
	if (FAILED(hr))
		fTransacted = FALSE;

	hr = m_pdb->Execute(bstrQuery);
	if (FAILED(hr))
	    goto Cleanup;

	// Delete all the dangling properties
	hr = m_pdb->Execute( _bstr_t("DELETE * FROM Properties"
						 " WHERE idObj NOT IN"
						 " (SELECT Objects.id FROM Objects);") );
	if (FAILED(hr))
	    goto Cleanup;

	// Remove the object from all relationships
	hr = m_pdb->Execute( _bstr_t("DELETE * FROM ObjectRelationships"
						 " WHERE idObj1 NOT IN"
						 " (SELECT Objects.id FROM Objects);") );
	if (FAILED(hr))
    	    goto Cleanup;
	
	if (!m_fOnlyUnreferenced)
		{
		// If this collection only contains unreferenced objects then
		// there is no need to execute the following.
		// Otherwise...

		// Remove dangling object references.
		hr = m_pdb->Execute( _bstr_t("DELETE * FROM ObjectRelationships"
							 " WHERE idObj2 NOT IN"
							 " (SELECT Objects.id FROM Objects);") );
		if (FAILED(hr))
			goto Cleanup;

		// Remove any properties pointing to deleted objects
		hr = m_pdb->Execute( _bstr_t("DELETE * FROM Properties"
							 " WHERE (ValueType = 13) AND (lValue NOT IN"
							 " (SELECT Objects.id FROM Objects));") );
		}

Cleanup:
	if (fTransacted)
		{
		if (FAILED(hr))
			m_pdb->RollbackTrans();
		else
			hr = m_pdb->CommitTrans();
		}
	
	if (SUCCEEDED(hr))
		{
		Reset();
		m_pdb->PurgeCachedObjects();
		}

	return hr;
	}
LEAVE_API
}

HRESULT CObjects::RemoveFromRelationship(IUnknown *pobjRemove)
{
	long idObj1;
	long idObj2;

	m_pdb->get_IdOf(m_pobjRelated, &idObj1);
	m_pdb->get_IdOf(pobjRemove, &idObj2);

	if (m_fInverse)
		swap(idObj1, idObj2);

	TCHAR sz[1024];

	wsprintf(sz, _T("DELETE *")
		_T(" FROM ObjectRelationships")
		_T(" WHERE ((ObjectRelationships.idObj1=%d)")
		_T("   AND (ObjectRelationships.idRel=%d)")
		_T("   AND (ObjectRelationships.idObj2=%d));"),
		idObj1, m_idRel, idObj2);

	m_cItems = -1;  // UNDONE: Is "m_cItems++;" sufficient?
	if (m_prs != NULL)
		m_prs.Release();

	return m_pdb->Execute(_bstr_t(sz));
}


HRESULT CObjects::get_ItemsRelatedToBy(IUnknown *pobj, IMetaPropertyType *pproptype,
		boolean fInverse, IObjects **ppobjs)
{
	// Can't handle multiple relations yet.
	if (m_pobjRelated != NULL)
		return E_INVALIDARG;
	
	CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);

	if (pproptypeT == NULL)
		return E_INVALIDARG;
	
	long idRel = pproptypeT->GetID();
	
	HRESULT hr;

	hr = Clone(ppobjs);
	if (FAILED(hr))
		return hr;

	CComQIPtr<CObjects> pobjs(*ppobjs);
	if (FAILED(hr))
		return hr;

	hr = pobjs->InitRelation(pobj, idRel, fInverse);

	return hr;
}

STDMETHODIMP CObjects::get_ItemsRelatedToBy(IUnknown *pobj, IMetaPropertyType *pproptype,
		IObjects **ppobjs)
{
ENTER_API
	{
	ValidateInPtr<IUnknown>(pobj);
	ValidateInPtr<IMetaPropertyType>(pproptype);
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	return get_ItemsRelatedToBy(pobj, pproptype, FALSE, ppobjs);
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemsInverseRelatedToBy(IUnknown *pobj, IMetaPropertyType *pproptype,
		IObjects **ppobjs)
{
ENTER_API
	{
	ValidateInPtr<IUnknown>(pobj);
	ValidateInPtr<IMetaPropertyType>(pproptype);
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	return get_ItemsRelatedToBy(pobj, pproptype, TRUE, ppobjs);
	}
LEAVE_API
}

STDMETHODIMP CObjects::get_ItemsInTimeRange(DATE dt1, DATE dt2, IObjects **ppobjs)
{
ENTER_API
	{
	ValidateOutPtr<IObjects>(ppobjs, NULL);

	HRESULT hr;

	// Ensure that dt1 is less than or equal to dt2
	if (dt1 > dt2)
		swap(dt1, dt2);

	_variant_t varT1(dt1, VT_DATE);
	_variant_t varT2(dt2, VT_DATE);

	CComPtr<IMetaPropertyType> pproptypeStartTime = m_pdb->StartMetaPropertyType();
	CComPtr<IMetaPropertyType> pproptypeEndTime = m_pdb->EndMetaPropertyType();

	CComPtr<IMetaPropertyCondition> ppropcond1;
	CComPtr<IMetaPropertyCondition> ppropcond2;
	_bstr_t bstrLT(_T("<"));
	_bstr_t bstrGT(_T(">"));
	_bstr_t bstrLE(_T("<="));

	if (dt1 < dt2)
		{
		// Look for StartTime > dt2 & EndTime < dt1
		hr = pproptypeStartTime->get_Cond(bstrLT, 0, varT2, &ppropcond1);
		if (FAILED(hr))
			return hr;
		hr = pproptypeEndTime->get_Cond(bstrGT, 0, varT1, &ppropcond2);
		if (FAILED(hr))
			return hr;
		}
	else
		{
		// Look for StartTime <= dt1 & EndTime > dt1
	    hr = pproptypeStartTime->get_Cond(bstrLE, 0, varT1, &ppropcond1);
		if (FAILED(hr))
			return hr;
		hr = pproptypeEndTime->get_Cond(bstrGT, 0, varT1, &ppropcond2);
		if (FAILED(hr))
			return hr;
		}

	CComPtr<IMetaPropertyCondition> ppropcond;
	hr = ppropcond1->get_And(ppropcond2, &ppropcond);
	if (FAILED(hr))
		return hr;

	return get_ItemsWithMetaPropertyCond(ppropcond, ppobjs);
	}
LEAVE_API
}

IMetaProperty * CObjectPropertyBag::GetProp(_bstr_t bstrPropName, boolean fCreate)
{
	HRESULT hr;

	if (m_pproptypes == NULL)
		return NULL;

	CComPtr<IMetaPropertyType> pproptype;

	_variant_t varNil;
	hr = m_pproptypes->get_AddNew(0, bstrPropName, &pproptype);

	CComPtr<IMetaProperty> pprop;
	hr = m_pprops->get_ItemWithTypeProviderLang(pproptype, NULL, 0, &pprop);
	if (FAILED(hr))
		{
		if (!fCreate)
			return NULL;

		CComQIPtr<CMetaProperties> ppropsT(m_pprops);
		hr = ppropsT->get_AddNew(pproptype, NULL, NULL, varNil, &pprop);
		if (FAILED(hr))
			return NULL;
		}
	
	return pprop.Detach();
}

STDMETHODIMP CObjectPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog)
{
ENTER_API
	{
	ValidateOut(pvar);

	CComPtr<IMetaProperty> pprop;
	
	pprop.Attach(GetProp(_bstr_t(pszPropName), FALSE));
	if (pprop == NULL)
		return E_INVALIDARG;

	return pprop->get_Value(pvar);
	}
LEAVE_API
}

STDMETHODIMP CObjectPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
ENTER_API
	{
	CComPtr<IMetaProperty> pprop;
	
	pprop.Attach(GetProp(_bstr_t(pszPropName), TRUE));
	if (pprop == NULL)
		return E_FAIL;

	CComQIPtr<CMetaProperty> ppropT(pprop);

	return ppropT->PutValue(*pvar);
	}
LEAVE_API
}
void CObjects::Dump()
	{
#ifdef _DEBUG
	TCHAR sz[256];
	wsprintf(sz, _T("CObjects::Dump(%x)\n"), (long) this);
	OutputDebugString(sz);

	long idType;
	m_pobjtype->get_ID(&idType);
	wsprintf(sz, _T("    type == %d\n"), idType);
	OutputDebugString(sz);

	wsprintf(sz, _T("    m_cItems == %d\n"), m_cItems);
	OutputDebugString(sz);

	if (m_idPropTypeKey != 0)
		{
		wsprintf(sz, _T("    key == %d:%d:%d:%d\n"), m_idPropTypeKey,
				m_idProviderKey, m_idLangKey, m_vtKey);
		OutputDebugString(sz);
		}

	if (m_prs != NULL)
		{
		wsprintf(sz, _T("    m_prs == %x\n"), m_prs);
		OutputDebugString(sz);
		}

	if (m_pobjRelated != NULL)
		{
		long id;

		m_pdb->get_IdOf(m_pobjRelated,&id);
		wsprintf(sz, _T("    %s to %d by %d\n"),
				m_fInverse ? _T("Inverse Related") : _T("Related"),
				id, m_idRel);
		OutputDebugString(sz);
		}
	if (m_fOnlyUnreferenced)
		{
		OutputDebugString(_T("    Only Unreferenced\n"));
		}

	_bstr_t bstr;

	GetQuery(Select, &bstr);
	OutputDebugString(_T("    Query: "));
	OutputDebugString(bstr);
	OutputDebugString(_T("\n"));
#endif
	}

#if SUPPORT_PROPBAG2
// IPropertyBag2 interface
STDMETHODIMP CObjectPropertyBag::CountProperties(long *plCount)
{
	*plCount = 0;
	return S_OK;
}
STDMETHODIMP CObjectPropertyBag::GetPropertyInfo(ULONG iProp, ULONG cProps, PROPBAG2 *ppropbag2, ULONG *pcProps)
{
	return E_NOTIMPL;
}

STDMETHODIMP CObjectPropertyBag::LoadObject(LPCOLESTR pstrName, DWORD dwHint, IUnknown *punk, IErrorLog *perrlog)
{
	return E_NOTIMPL;
}

STDMETHODIMP CObjectPropertyBag::Read(ULONG cProps, PROPBAG2 *ppropbag2, IErrorLog *perrlog, VARIANT *rgvar, HRESULT *phr)
{
	return E_NOTIMPL;
}

STDMETHODIMP CObjectPropertyBag::Write(ULONG cProps, PROPBAG2 *ppropbag2, VARIANT *rgvar)
{
	return E_NOTIMPL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\property.cpp ===
// prop.cpp : Implementation of CMetaPropertySet
#include "stdafx.h"
#include "Property.h"
#include "util.h"

HRESULT SaveObjectToField(VARIANT var, ADODB::Field *pfield)
{
	HRESULT hr;
	if ((var.vt != VT_UNKNOWN) && (var.vt != VT_DISPATCH))
		return E_INVALIDARG;

	CComPtr<IStream> pstream;
	hr = CreateStreamOnHGlobal(NULL, TRUE, &pstream);
	if (FAILED(hr))
		return hr;
	
	CComQIPtr<IPersistStream> ppersiststream(var.punkVal);

	if (ppersiststream != NULL)
		{
		// Write a tag to indicate IPersistStream was used.
		char ch = Format_IPersistStream;
		ULONG cb = sizeof(ch);
		hr = pstream->Write(&ch, cb, &cb);
		if (FAILED(hr))
			return hr;

		hr = OleSaveToStream(ppersiststream, pstream);
		if (FAILED(hr))
			return hr;
		}
	else
		{
		CComQIPtr<IPersistPropertyBag> ppersistpropbag(var.punkVal);
		if (ppersistpropbag == NULL)
			return E_INVALIDARG;
		
		// Write a tag to indicate IPersistPropertyBag was used.
		char ch = Format_IPersistPropertyBag;
		ULONG cb = sizeof(ch);
		hr = pstream->Write(&ch, cb, &cb);
		if (FAILED(hr))
			return hr;
		
		hr = SaveToPropBagInStream(ppersistpropbag, pstream);
		if (FAILED(hr))
			return hr;
		}
	
	HANDLE hdata;
	hr = GetHGlobalFromStream(pstream, &hdata);
	if (FAILED(hr))
		return hr;
	
	long cb = GlobalSize(hdata);
	SAFEARRAY *parray = SafeArrayCreateVector(VT_UI1, 0, cb);
	if (parray == NULL)
		return E_OUTOFMEMORY;
	
	BYTE *pbDst;
	hr = SafeArrayAccessData(parray, (void **) &pbDst);
	if (FAILED(hr))
		return hr;
	BYTE *pbSrc = (BYTE *) GlobalLock(hdata);

	memcpy(pbDst, pbSrc, cb);

	GlobalUnlock(hdata);
	SafeArrayUnaccessData(parray);

	_variant_t varT;
	varT.vt = VT_ARRAY | VT_UI1;
	varT.parray = parray;

	hr = pfield->AppendChunk(varT);
	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT LoadObjectFromField(ADODB::Field *pfield, VARIANT *pvar)
{
	HRESULT hr;
	long cb;
	hr = pfield->get_ActualSize(&cb);
	if (FAILED(hr))
		return hr;

	_variant_t varData;
	hr = pfield->GetChunk(cb, &varData);
	if (FAILED(hr))
		return hr;
	
	if ((varData.vt & VT_ARRAY) == 0)
		return E_FAIL;
	
	BYTE *pbSrc;
	hr = SafeArrayAccessData(varData.parray, (void **) &pbSrc);
	if (FAILED(hr))
		return hr;
	
	HANDLE hdata;
	BOOL fFree = FALSE;
	hdata = GlobalHandle(pbSrc);
	if (hdata == NULL)
		{
		hdata = GlobalAlloc(GHND, cb);
		if (hdata == NULL)
			{
			SafeArrayUnaccessData(varData.parray);
			return E_OUTOFMEMORY;
			}
		
		BYTE *pbDst = (BYTE *) GlobalLock(hdata);

		memcpy(pbDst, pbSrc, cb);
		fFree = TRUE;
		}
	else
		{
		BYTE *pbTest = (BYTE *) GlobalLock(hdata);
		int i = 0;
		if (pbTest != pbSrc)
			i++;
		GlobalUnlock(hdata);
		}

	CComPtr<IUnknown> punk;
	{
	CComPtr<IStream> pstream;
	hr = CreateStreamOnHGlobal(hdata, fFree, &pstream);
	if (FAILED(hr))
		{
		if (fFree)
			GlobalFree(hdata);
		return hr;
		}
	
	char ch;
	ULONG cbT = sizeof(ch);
	hr = pstream->Read(&ch, cbT, &cbT);
	switch (ch)
		{
		case Format_IPersistStream:
			hr = OleLoadFromStream(pstream, __uuidof(IUnknown), (void **) &punk);
			break;
		
		case Format_IPersistPropertyBag:
			hr = LoadFromPropBagInStream(pstream, &punk);
			break;
		
		default:
			return STG_E_DOCFILECORRUPT;
		}
	}
	SafeArrayUnaccessData(varData.parray);

	if (FAILED(hr))
		return hr;

	pvar->vt = VT_UNKNOWN;
	pvar->punkVal = punk.Detach();

	return S_OK;
}

HRESULT SeekPropsRS(ADODB::_RecordsetPtr prs, boolean fSQLServer,
		long idObj, long idPropType, boolean fAnyProvider, long idProvider, long idLang)
{
	_ASSERTE(idObj != 0);
	HRESULT hr;

	if (fAnyProvider && idProvider != NULL)
		{
		// First try to find the specified provider, only if it is not found
		// do we look for any provider.
		hr = SeekPropsRS(prs, fSQLServer, idObj, idPropType, FALSE, idProvider, idLang);
		if (SUCCEEDED(hr))
			return hr;
		
		idProvider = NULL;
		}

	try
		{
		TCHAR szFind[32];
		DeclarePerfTimerOff(perf, "SeekPropsRS");

#if 1
		{
		static bool fDump= FALSE;

		if (fDump)
			{
			prs->MoveFirst();
			while (!prs->EndOfFile)
				{
				long idObjCur = prs->Fields->Item["idObj"]->Value;
				long idPropTypeCur = prs->Fields->Item["idPropType"]->Value;

				TRACE("idObj = %d idPropType = %d\n", idObjCur, idPropTypeCur);
				prs->MoveNext();
				}
			}
		}
		
#endif
		PerfTimerReset();
		if (fSQLServer)
			{
			prs->MoveFirst();
			wsprintf(szFind, _T("idObj = %d"), idObj);
			prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);

			wsprintf(szFind, _T("idPropType = %d"), idPropType);
			prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
			}
		else
			{
			// Create elements used in the array
			_variant_t varCriteria[4];
			varCriteria[0] = idObj;
			varCriteria[1] = idPropType;
			varCriteria[2] = idProvider;
			varCriteria[3] = idLang;
			const int nCrit = sizeof varCriteria / 
							 sizeof varCriteria[0];

			// Create SafeArray Bounds and initialize the array
			SAFEARRAYBOUND rgsabound[1];
			rgsabound[0].lLbound   = 0;   
			rgsabound[0].cElements = nCrit;
			SAFEARRAY *psa         = SafeArrayCreate( VT_VARIANT, 1, rgsabound );

			hr = S_OK;
			// Set the values for each element of the array
			for( long i = 0 ; i < nCrit && SUCCEEDED( hr );i++)
			{
				hr  = SafeArrayPutElement(psa, &i,&varCriteria[i]); 
			}

			// Initialize and fill the SafeArray
			VARIANT var;
			var.vt = VT_VARIANT | VT_ARRAY;
			V_ARRAY(&var) = psa;

			hr = prs->Seek(var,
					fAnyProvider ? ADODB::adSeekAfterEQ : ADODB::adSeekFirstEQ);

			if (FAILED(hr))
				return hr;
			if (prs->EndOfFile)
				return E_INVALIDARG;
			if (!fAnyProvider)
				return S_OK;
			}

		while (TRUE)
			{
			if (prs->EndOfFile)
				break;

			long idObjCur = prs->Fields->Item["idObj"]->Value;
			if (idObjCur != idObj)
				break;

			long idPropTypeCur = prs->Fields->Item["idPropType"]->Value;
			if (idPropTypeCur != idPropType)
				break;
			
			long idLang2 = prs->Fields->Item["idLanguage"]->Value;
			long idProvider2 = prs->Fields->Item["idProvider"]->Value;
			if ((idLang == idLang2) && (fAnyProvider || (idProvider == idProvider2)))
				{
				PerfTimerDump("Successful seek");
				return S_OK;
				}
			prs->MoveNext();
			}
		
		PerfTimerDump("Failed seek");
		return E_INVALIDARG;
		}
	catch (_com_error & e)
		{
		TCHAR sz[1024];
		wsprintf(sz, _T("Error: %s"), e.ErrorMessage());

		return e.Error();
		}
}

/////////////////////////////////////////////////////////////////////////////
// CMetaPropertySet

HRESULT CMetaPropertySet::Load()
{
	HRESULT hr;

	ADODB::_RecordsetPtr prs;
	hr = m_pdb->get_PropTypesRS(&prs);
	if (FAILED(hr))
		return hr;
	
	if (!CreatePropTypes())
		return E_OUTOFMEMORY;
	
	prs->MoveFirst();
	TCHAR szFind[20];
	wsprintf(szFind, _T("idPropSet = %d"), m_id);
	prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);

	while (!prs->EndOfFile)
		{
		CComPtr<CMetaPropertyType> pproptype;
		long idPropSet = prs->Fields->Item["idPropSet"]->Value;
		if (idPropSet != m_id)
			break;
		
		bstr_t bstrName = prs->Fields->Item["Name"]->Value;
		long idPropType = prs->Fields->Item["idProp"]->Value;
		long id = prs->Fields->Item["id"]->Value;
		variant_t varNil;

		hr = m_pproptypes->Cache(id, idPropType, bstrName, &pproptype);
		prs->MoveNext();
		}

	return S_OK;
}


STDMETHODIMP CMetaPropertySet::get_Name(BSTR *pbstrName)
{
ENTER_API
	{
	ValidateOut(pbstrName);

	*pbstrName = m_bstrName.copy();

	return S_OK;
	}
LEAVE_API
}

bool CMetaPropertySet::CreatePropTypes()
{
	if (m_pproptypes == NULL)
		{
		CComPtr<CMetaPropertyTypes> pproptypes = NewComObject(CMetaPropertyTypes);

		if (pproptypes == NULL)
			return FALSE;
		
		pproptypes->Init(m_pdb, this);
		m_pproptypes = pproptypes;
		}
	
	return TRUE;
}

STDMETHODIMP CMetaPropertySet::get_MetaPropertyTypes(IMetaPropertyTypes **ppproptypes)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertyTypes>(ppproptypes, NULL);

	if (!CreatePropTypes())
		return E_OUTOFMEMORY;

	(*ppproptypes = m_pproptypes)->AddRef();

	return S_OK;
	}
LEAVE_API
}

/////////////////////////////////////////////////////////////////////////////
// CMetaPropertySets
HRESULT CMetaPropertySets::Load()
{
	HRESULT hr;
	
	ADODB::_RecordsetPtr prs;
	hr = m_pdb->get_PropSetsRS(&prs);
	if (FAILED(hr))
		return hr;
	
	prs->MoveFirst();
	while (!prs->EndOfFile)
		{
		// Read in all the records
		CComPtr<CMetaPropertySet> ppropset;

		long id = prs->Fields->Item["id"]->Value;
		bstr_t bstrName = prs->Fields->Item["Name"]->Value;

		hr = Cache(id, bstrName, &ppropset);
		if (SUCCEEDED(hr) && ppropset != NULL)
			{
			ppropset->Load();
			}
		prs->MoveNext();
		}

	return S_OK;
}

STDMETHODIMP CMetaPropertySets::get_Count(long *plCount)
{
ENTER_API
	{
	ValidateOut<long>(plCount);

	*plCount = m_map.size();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertySets::get_Item(VARIANT varIndex, IMetaPropertySet **pppropset)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertySet>(pppropset, NULL);

	if (varIndex.vt == VT_BSTR)
		return get_ItemWithName(varIndex.bstrVal, pppropset);

	_variant_t var(varIndex);
	try
		{
		var.ChangeType(VT_I4);
		}
	catch (_com_error &)
		{
		return E_INVALIDARG;
		}
	
	long i = var.lVal;

	if ((i < 0) || (i >= m_map.size()))
		return E_INVALIDARG;

	t_map::iterator it = m_map.begin();

	while (i--)
		it++;

	*pppropset = (*it).second;

	if (*pppropset != NULL)
		(*pppropset)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertySets::get_ItemWithName(BSTR bstrName, IMetaPropertySet **pppropset)
{
ENTER_API
	{
	ValidateIn(bstrName);
	ValidateOutPtr<IMetaPropertySet>(pppropset, NULL);

	t_map::iterator it = m_map.find(bstrName);
	if (it == m_map.end())
		return E_INVALIDARG;

	*pppropset = (*it).second;
	(*pppropset)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertySets::get_Lookup(BSTR bstrName, IMetaPropertyType **ppproptype)
{
ENTER_API
	{
	HRESULT hr;
	ValidateIn(bstrName);
	ValidateOutPtr<IMetaPropertyType>(ppproptype, NULL);

	if (bstrName == NULL)
		return E_INVALIDARG;

	wchar_t *szDot = wcschr(bstrName, L'.');
	if (szDot == NULL)
		return E_INVALIDARG;
	
	_bstr_t bstrPropTypeName(szDot+1);

	_bstr_t bstrPropSetName = SysAllocStringLen(bstrName, szDot - bstrName);

	CComPtr<IMetaPropertySet> ppropset;
	hr = get_AddNew(bstrPropSetName, &ppropset);
	if (FAILED(hr))
		return hr;

	CComPtr<IMetaPropertyTypes> pproptypes;
	hr = ppropset->get_MetaPropertyTypes(&pproptypes);
	if (FAILED(hr))
		return hr;
	
	CComPtr<IMetaPropertyType> pproptype;
	_variant_t varNil;
	hr = pproptypes->get_AddNew(0, bstrPropTypeName, &pproptype);
	if (FAILED(hr))
		return hr;

	*ppproptype = pproptype.Detach();

	return S_OK;
	}
LEAVE_API
}

HRESULT CMetaPropertySets::Cache(long id, BSTR bstrName, CMetaPropertySet **pppropset)
{
	CComPtr<CMetaPropertySet> ppropset = NULL;

	t_map::iterator it = m_map.find(bstrName);
	if (it != m_map.end())
		{
		ppropset = (*it).second;
		}
	else
		{
		ppropset = NewComObject(CMetaPropertySet);

		if (ppropset == NULL)
			return E_OUTOFMEMORY;

		ppropset->Init(m_pdb, id, bstrName);

		BSTR bstrNameT = SysAllocString(bstrName);
		if (bstrNameT == NULL)
			return E_OUTOFMEMORY;
		ppropset.CopyTo(&m_map[bstrNameT]);
		}

	*pppropset = ppropset.Detach();

	return S_OK;
}

STDMETHODIMP CMetaPropertySets::get_AddNew(BSTR bstrName, IMetaPropertySet **pppropset)
{
ENTER_API
	{
	ValidateIn(bstrName);
	ValidateOutPtr<IMetaPropertySet>(pppropset, NULL);

	HRESULT hr;

	hr = get_ItemWithName(bstrName, pppropset);
	if (SUCCEEDED(hr))
		return hr;

	static long idCur = 1;
	long id;
	if (m_pdb == NULL)
		id = idCur++;
	else
		{
		ADODB::_RecordsetPtr prs;
		hr = m_pdb->get_PropSetsRS(&prs);
		if (FAILED(hr))
			return hr;

		// Create a new record.
		hr = prs->AddNew();

		prs->Fields->Item["Name"]->Value = bstrName;

		hr = prs->Update();

		id = prs->Fields->Item["id"]->Value;
		}
	CMetaPropertySet *ppropset;
	hr = Cache(id, bstrName, &ppropset);
	*pppropset = ppropset;

	return hr;
	}
LEAVE_API
}

/////////////////////////////////////////////////////////////////////////////
// CMetaPropertyType

STDMETHODIMP CMetaPropertyType::get_MetaPropertySet(IMetaPropertySet **pppropset)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertySet>(pppropset, m_ppropset);

	(*pppropset)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyType::get_ID(long *pid)
{
ENTER_API
	{
	ValidateOut<long>(pid, m_idPropType);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyType::get_Name(BSTR *pbstrName)
{
ENTER_API
	{
	ValidateOut(pbstrName);

	*pbstrName = m_bstrName.copy();
	return S_OK;
	}
LEAVE_API
}

HRESULT CMetaPropertyType::GetNew(long idProvider, long lang, VARIANT varValue, IMetaProperty **ppprop)
{
ENTER_API
	{
	ValidateOutPtr<IMetaProperty>(ppprop, NULL);

	CComPtr<CMetaProperty> pprop = NewComObject(CMetaProperty);

	if (pprop == NULL)
		return E_OUTOFMEMORY;

	pprop->Init(m_pdb, m_id, idProvider, lang, varValue);

	*ppprop = pprop.Detach();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyType::get_Cond(BSTR bstrCond, long lang, VARIANT varValue, IMetaPropertyCondition **pppropcond)
{
ENTER_API
	{
	ValidateIn(bstrCond);
	ValidateOutPtr<IMetaPropertyCondition>(pppropcond, NULL);

	if (bstrCond == NULL)
		return E_INVALIDARG;

	HRESULT hr;
	CComPtr<IMetaProperty> pprop;

	hr = get_New(lang, varValue, &pprop);
	if (FAILED(hr))
		return hr;

	return pprop->get_Cond(bstrCond, pppropcond);
	}
LEAVE_API
}

/////////////////////////////////////////////////////////////////////////////
// CMetaPropertyTypes

STDMETHODIMP CMetaPropertyTypes::get_Count(long *plCount)
{
ENTER_API
	{
	ValidateOut<long>(plCount, m_map.size());

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyTypes::get_Item(VARIANT varIndex, IMetaPropertyType **ppproptype)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertyType>(ppproptype, NULL);

	if (varIndex.vt == VT_BSTR)
		return get_ItemWithName(varIndex.bstrVal, ppproptype);

	_variant_t var(varIndex);

	try
		{
		var.ChangeType(VT_I4);
		}
	catch (_com_error &)
		{
		return E_INVALIDARG;
		}
	
	long i = var.lVal;

	if ((i < 0) || (i >= m_map.size()))
		return E_INVALIDARG;

	t_map::iterator it = m_map.begin();

	while (i--)
		it++;

	*ppproptype = (*it).second;

	if (*ppproptype != NULL)
		(*ppproptype)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyTypes::get_MetaPropertySet(IMetaPropertySet **pppropset)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertySet>(pppropset, m_ppropset);

	if (*pppropset != NULL)
		(*pppropset)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyTypes::get_ItemWithName(BSTR bstrName, IMetaPropertyType **ppproptype)
{
ENTER_API
	{
	ValidateIn(bstrName);
	ValidateOutPtr<IMetaPropertyType>(ppproptype, NULL);

	t_map::iterator it = m_map.find(bstrName);
	if (it == m_map.end())
		return E_INVALIDARG;

	(*ppproptype = (*it).second)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyTypes::get_ItemWithID(long id, IMetaPropertyType **ppproptype)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertyType>(ppproptype, NULL);

	for (t_map::iterator it = m_map.begin(); it != m_map.end(); it++)
		{
		CComPtr<IMetaPropertyType> pproptype = (*it).second;
		long idCur;

		pproptype->get_ID(&idCur);

		if (idCur == id)
			{
			*ppproptype = pproptype.Detach();
			return S_OK;
			}
		}

	return E_INVALIDARG;
	}
LEAVE_API
}

HRESULT CMetaPropertyTypes::Cache(long id, long idPropType, BSTR bstrName,
		CMetaPropertyType **ppproptype)
{
	CComPtr<CMetaPropertyType> pproptype;

	t_map::iterator it = m_map.find(bstrName);
	if (it != m_map.end())
		{
		pproptype = (*it).second;
		}
	else
		{
		pproptype = NewComObject(CMetaPropertyType);

		if (pproptype == NULL)
			return E_OUTOFMEMORY;

		pproptype->Init(m_pdb, m_ppropset, id, idPropType, bstrName);

		BSTR bstrT = SysAllocString(bstrName);
		pproptype.CopyTo(&m_map[bstrT]);

		m_pdb->put_MetaPropertyType(id, pproptype);
		}

	*ppproptype = pproptype.Detach();

	return S_OK;
}

STDMETHODIMP CMetaPropertyTypes::get_AddNew(long idProp, BSTR bstrName, IMetaPropertyType **ppproptype)
{
ENTER_API
	{
	ValidateIn(bstrName);
	ValidateOutPtr<IMetaPropertyType>(ppproptype, NULL);

	HRESULT hr;

	hr = get_ItemWithName(bstrName, ppproptype);
	if (SUCCEEDED(hr))
		return hr;

	CComPtr<CMetaPropertyType> pproptype;

	static long idCur = 1;
	long id;

	if (m_pdb == NULL)
		id = idCur++;
	else
		{
		ADODB::_RecordsetPtr prs;
		hr = m_pdb->get_PropTypesRS(&prs);
		if (FAILED(hr))
			return hr;

		// Create a new record.
		hr = prs->AddNew();

		prs->Fields->Item["idPropSet"]->Value = m_ppropset->GetID();
		prs->Fields->Item["idProp"]->Value = idProp;
		prs->Fields->Item["Name"]->Value = bstrName;

		hr = prs->Update();

		id = prs->Fields->Item["id"]->Value;
		}
	
	hr = Cache(id, idProp, bstrName, &pproptype);

	if (FAILED(hr))
		return hr;
	
	*ppproptype = pproptype.Detach();

	return S_OK;
	}
LEAVE_API
}

/////////////////////////////////////////////////////////////////////////////
// CMetaProperty

STDMETHODIMP CMetaProperty::get_MetaPropertyType(IMetaPropertyType **ppproptype)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertyType>(ppproptype, NULL);

	return m_pdb->get_MetaPropertyType(m_idPropType, ppproptype);
	}
LEAVE_API
}

STDMETHODIMP CMetaProperty::get_Language(long *pidLang)
{
ENTER_API
	{
	ValidateOut<long>(pidLang, m_idLang);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaProperty::get_Value(VARIANT *pvarValue)
{
ENTER_API
	{
	ValidateOut(pvarValue);

	return VariantCopy(pvarValue, &m_varValue);
	}
LEAVE_API
}

STDMETHODIMP CMetaProperty::put_Value(VARIANT varValue)
{
ENTER_API
	{
	// Changing the value, so must reset the provider.
	m_idProvider = m_pdb->GetIDGuideDataProvider();

	return PutValue(varValue);
	}
LEAVE_API
}

STDMETHODIMP CMetaProperty::PutValue(VARIANT varValue)
{
	HRESULT hr;
	ADODB::_RecordsetPtr prs;

	m_varValue = varValue;

	hr = m_pdb->get_PropsIndexed(&prs);
	if (FAILED(hr))
		return hr;

	hr = SeekPropsRS(prs, m_pdb->FSQLServer(), m_idObj,
			m_idPropType, FALSE, m_idProvider, m_idLang);
	
	if (FAILED(hr))
		{
		hr = AddNew(prs);
		if (FAILED(hr))
			return hr;
		}

	hr = SaveValue(prs);
	if (FAILED(hr))
		{
		prs->CancelUpdate();
		return hr;
		}

	hr = prs->Update();
	if (FAILED(hr))
		return hr;
	
	m_pdb->Broadcast_ItemChanged(m_idObj);

	return hr;
}

STDMETHODIMP CMetaProperty::get_QueryClause(long &i, TCHAR *szOp, _bstr_t *pbstr)
{
	TCHAR *szFieldName;
	TCHAR *szValue = NULL;

	switch (m_varValue.vt)
		{
		default:
			return E_INVALIDARG;

		case VT_EMPTY:
			return E_NOTIMPL; //Special case

		case VT_I2:
		case VT_I4:
			{
			szFieldName = _T("lValue");

			int cb = 32;
			szValue = new TCHAR [cb];
			if (szValue == NULL)
				return E_OUTOFMEMORY;

			_sntprintf(szValue, cb, _T("%d"), (long) m_varValue);
			}
			break;
		
		case VT_R4:
		case VT_R8:
			{
			szFieldName = _T("fValue");

			int cb = 32;
			szValue = new TCHAR [cb];
			if (szValue == NULL)
				return E_OUTOFMEMORY;

			_sntprintf(szValue, cb, _T("%.17f"), (double) m_varValue);
			}
			break;

		case VT_DATE:
			{
			szFieldName = _T("fValue");

			_variant_t varT;

			::VariantChangeTypeEx(&varT, &m_varValue,
				MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), 0, VT_BSTR);

			long cb = SysStringLen(varT.bstrVal) + 3;
			szValue = new TCHAR [cb];
			if (szValue == NULL)
				return E_OUTOFMEMORY;

			_sntprintf(szValue, cb, _T("#%s#"), (const TCHAR *) varT.bstrVal);
			}
			break;
		
		case VT_BSTR:
			{

			_bstr_t bstr = m_varValue.bstrVal;
			int cb = bstr.length() + 3; // Add on 2 quotes and null terminator

			szValue = new TCHAR [cb];
			if (szValue == NULL)
				return E_OUTOFMEMORY;


			if (bstr.length() < 255)
				{
				szFieldName = _T("sValue");
				_sntprintf(szValue, cb, _T("\"%s\""),
					(const TCHAR *) bstr);
				}
			else
				{
				delete [] szValue;
				return E_INVALIDARG; //UNDONE: What to do?
				}
			}
			break;
		}

	int cb = -1;
	int cbBuf = 128;
	TCHAR *sz = NULL;
	while (cb < 0)
		{
		delete [] sz;
		sz = new TCHAR [cbBuf];
		if (sz == NULL)
			return E_OUTOFMEMORY;

		cb = _sntprintf(sz, cbBuf,
				_T("(Props_%i.idPropType = %i) AND (Props_%i.%s %s %s)"),
				i, m_idPropType, i, szFieldName, szOp, szValue);
		cbBuf *= 2;
		}

	i++;
	*pbstr = sz;
	delete [] sz;
	delete [] szValue;
	return S_OK;
}

STDMETHODIMP CMetaProperty::get_Cond(BSTR bstrCond, IMetaPropertyCondition **pppropcond)
{
ENTER_API
	{
	ValidateIn(bstrCond);
	ValidateOutPtr<IMetaPropertyCondition>(pppropcond, NULL);

	if (bstrCond == NULL)
		return E_INVALIDARG;

	CComPtr<CMetaPropertyCondition1Prop> ppropcond = NULL;

	if (wcscmp(bstrCond, L"=") == 0)
		{
		ppropcond = NewComObject(CMetaPropertyConditionEQ);
		}
	else if ((wcscmp(bstrCond, L"!=") == 0) || (wcscmp(bstrCond, L"<>") == 0))
		{
		ppropcond = NewComObject(CMetaPropertyConditionNE);
		}
	else if (_wcsicmp(bstrCond, L"LIKE") == 0)
		{
		ppropcond = NewComObject(CMetaPropertyConditionLike);
		}
	else if (_wcsicmp(bstrCond, L"NOT LIKE") == 0)
		{
		ppropcond = NewComObject(CMetaPropertyConditionNotLike);
		}
	else if (wcscmp(bstrCond, L"<") == 0)
		{
		ppropcond = NewComObject(CMetaPropertyConditionLT);
		}
	else if (wcscmp(bstrCond, L"<=") == 0)
		{
		ppropcond = NewComObject(CMetaPropertyConditionLE);
		}
	else if (wcscmp(bstrCond, L">") == 0)
		{
		ppropcond = NewComObject(CMetaPropertyConditionGT);
		}
	else if (wcscmp(bstrCond, L">=") == 0)
		{
		ppropcond = NewComObject(CMetaPropertyConditionGE);
		}
	else
		{
		return E_INVALIDARG;
		}

	if (ppropcond == NULL)
		return E_OUTOFMEMORY;

	ppropcond->Init(this);

	*pppropcond = ppropcond.Detach();

	return S_OK;
	}
LEAVE_API
}

HRESULT CMetaProperty::AddNew(ADODB::_RecordsetPtr prs)
{
	HRESULT hr;

	// Create a new record.
	hr = prs->AddNew();
	if (FAILED(hr))
		return hr;

	prs->Fields->Item["idObj"]->Value = m_idObj;
	prs->Fields->Item["idPropType"]->Value = m_idPropType;
	prs->Fields->Item["idProvider"]->Value = m_idProvider;
	prs->Fields->Item["idLanguage"]->Value = m_idLang;

	return S_OK;
}

HRESULT CMetaProperty::SaveValue(ADODB::_RecordsetPtr prs)
{
	HRESULT hr;
	try
		{
		VARTYPE vt = m_varValue.vt;
		IUnknown *punk;
		switch (vt)
			{
			default:
				return E_INVALIDARG;

			case VT_EMPTY:
				break;

			case VT_I2:
			case VT_I4:
				prs->Fields->Item["lValue"]->Value = m_varValue;
				break;
			
			case VT_R4:
			case VT_R8:
			case VT_DATE:
				prs->Fields->Item["fValue"]->Value = m_varValue;
				break;
			
			case VT_BSTR_BLOB:
			case VT_BSTR:
				prs->Fields->Item["sValue"]->Value = m_varValue;
				break;
			
			case VT_DISPATCH:
			case VT_UNKNOWN:
#if 0
				hr = SaveObjectToField(m_varValue, prs->Fields->Item["oValue"]);
				if (FAILED(hr))
					return hr;
#else
				punk = m_varValue.punkVal;
				goto SaveObj;
#endif
				break;
			
			case VT_BYREF | VT_UNKNOWN:
				punk = *m_varValue.ppunkVal;
				vt = VT_UNKNOWN;
SaveObj:
				{
				// Temporarily set to NULL
				prs->Fields->Item["ValueType"]->Value = _variant_t((long) VT_UNKNOWN);
				prs->Fields->Item["lValue"]->Value = _variant_t((long) NULL);

				if (punk != NULL)
					{
					hr = prs->Update();
					long idObj;
					hr = m_pdb->SaveObject(punk, &idObj);
					if (FAILED(hr))
						return hr;
					
					// Seek back and fix it up.
					hr = SeekPropsRS(prs, m_pdb->FSQLServer(), m_idObj,
							m_idPropType, FALSE, m_idProvider, m_idLang);
					if (FAILED(hr))
						return hr;
					prs->Fields->Item["lValue"]->Value = idObj;
					}
				}
				break;
			}

		prs->Fields->Item["ValueType"]->Value = _variant_t((long) vt);
		}
	catch (_com_error & e)
		{
		return e.Error();
		}

	return S_OK;
}

HRESULT CMetaProperty::LoadValue(ADODB::_RecordsetPtr prs)
{
	HRESULT hr;
	_variant_t varType = prs->Fields->Item["ValueType"]->Value;

	try
		{
		varType.ChangeType(VT_I4);
		}
	catch (_com_error &)
		{
		return E_INVALIDARG;
		}
	
	switch (varType.lVal)
		{
		default:
			return E_INVALIDARG;

		case VT_EMPTY:
			m_varValue.Clear();
			break;

		case VT_I2:
		case VT_I4:
			m_varValue = prs->Fields->Item["lValue"]->Value;
			break;
		
		case VT_R4:
		case VT_R8:
		case VT_DATE:
			m_varValue = prs->Fields->Item["fValue"]->Value;
			break;
		
		case VT_BSTR_BLOB:
		case VT_BSTR:
			m_varValue = prs->Fields->Item["sValue"]->Value;
			m_varValue.vt = varType.lVal;
			break;
		
		case VT_UNKNOWN:
#if 0
			hr = LoadObjectFromField(prs->Fields->Item["oValue"], &m_varValue);
			if (FAILED(hr))
				return hr;
#else
			{
			CComPtr<IUnknown> punk;
			long idObj = prs->Fields->Item["lValue"]->Value;
			if (idObj != NULL)
				{
				hr = m_pdb->CacheObject(idObj, (long) 0, &punk);
				if (FAILED(hr))
					return hr;
				}
			
			m_varValue = punk;
			}
#endif
			break;
		}

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CMetaProperties

STDMETHODIMP CMetaProperties::get_Count(long *plCount)
{
ENTER_API
	{
	ValidateOut<long>(plCount, 0);

	HRESULT hr;
	
	ADODB::_RecordsetPtr prs;

	hr = m_pdb->get_PropsIndexed(&prs);
	
	prs->MoveFirst();
	TCHAR szFind[32];
	wsprintf(szFind, _T("idObj = %d"), m_idObj);
	hr = prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);
	if (FAILED(hr))
		return S_OK;

	if (m_idPropType != 0)
		{
		wsprintf(szFind, _T("idPropType = %d"), m_idPropType);
		prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);

		if (prs->EndOfFile)
			return S_OK;
		}

	// UNDONE: This is not the most efficient, but it's what works for now.
	while (!prs->EndOfFile)
		{
		long idObj2 = prs->Fields->Item["idObj"]->Value;
		if (m_idObj != idObj2)
			break;
		
		if (m_idPropType != 0)
			{
			long idPropType = prs->Fields->Item["idPropType"]->Value;
			if (m_idPropType != idPropType)
				break;
			}
		(*plCount)++;
		hr = prs->MoveNext();
		if (FAILED(hr))
			return hr;
		}
	
	return S_OK;
	}
LEAVE_API
}

HRESULT CMetaProperties::Load(long idPropType, ADODB::_RecordsetPtr prs, IMetaProperty **ppprop)
{
	HRESULT hr;
	CComPtr<IMetaPropertyType> pproptype;
	CComPtr<IMetaProperty> pprop;

	hr = m_pdb->get_MetaPropertyType(idPropType, &pproptype);
	if (FAILED(hr))
		return hr;
	
	long idLang = prs->Fields->Item["idLanguage"]->Value;
	long idProvider = prs->Fields->Item["idProvider"]->Value;

	CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);
	_variant_t varValue;
	hr = pproptypeT->GetNew(idProvider, idLang, varValue, &pprop);

	if (FAILED(hr))
		return hr;
	
	CComQIPtr<CMetaProperty> ppropT(pprop);

	ppropT->SetObjectID(m_idObj);

	hr = ppropT->LoadValue(prs);
	if (FAILED(hr))
		return hr;
	
	*ppprop = pprop.Detach();
	
	return S_OK;
}

STDMETHODIMP CMetaProperties::get_Item(VARIANT varIndex, IMetaProperty **ppprop)
{
ENTER_API
	{
	ValidateOutPtr<IMetaProperty>(ppprop, NULL);

	HRESULT hr;

	if (varIndex.vt == VT_BSTR)
		{
		CComPtr<IMetaPropertyType> pproptype;
		hr = m_pdb->get_MetaPropertyType(varIndex.bstrVal, &pproptype);
		if (FAILED(hr))
			return E_INVALIDARG;
		
		hr = get_ItemWith(pproptype, 0, ppprop);
		if (FAILED(hr))
			{
			CComPtr<IGuideDataProvider> pprovider;
			m_pdb->get_GuideDataProvider(&pprovider);

			_variant_t varNil;
			hr = get_AddNew(pproptype, pprovider, 0, varNil, ppprop);
			}
		return hr;
		}

	_variant_t var(varIndex);

	try
		{
		var.ChangeType(VT_I4);
		}
	catch (_com_error &)
		{
		return E_INVALIDARG;
		}
	
	if (var.lVal < 0)
		return E_INVALIDARG;

	ADODB::_RecordsetPtr prs;

	hr = m_pdb->get_PropsIndexed(&prs);

	prs->MoveFirst();
	TCHAR szFind[32];
	wsprintf(szFind, _T("idObj = %d"), m_idObj);
	prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);

	if (prs->EndOfFile)
		return E_INVALIDARG;

	if (m_idPropType != 0)
		{
		wsprintf(szFind, _T("idPropType = %d"), m_idPropType);
		prs->Find(_bstr_t(szFind), 0, ADODB::adSearchForward);

		if (prs->EndOfFile)
			return E_INVALIDARG;
		}
	
	if (var.lVal > 0)
		{
		hr = prs->Move(var.lVal);
		if (FAILED(hr))
			return hr;
		}

	if (prs->EndOfFile)
		return E_INVALIDARG;

	long idObj2 = prs->Fields->Item["idObj"]->Value;
	if (m_idObj != idObj2)
		return E_INVALIDARG;

	long idPropType = prs->Fields->Item["idPropType"]->Value;
	if (m_idPropType != 0 && (m_idPropType != idPropType))
			return E_INVALIDARG;

	return Load(idPropType, prs, ppprop);
	}
LEAVE_API
}

HRESULT CMetaProperties::get_AddNew(IMetaPropertyType *pproptype,
		IGuideDataProvider *pprovider, long lang, VARIANT varValue,
		IMetaProperty **ppprop)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyType>(pproptype);
	ValidateOutPtr<IMetaProperty>(ppprop, NULL);
	HRESULT hr;

	CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);

	long idProvider = 0;

	if (pprovider != NULL)
		pprovider->get_ID(&idProvider);

	hr = pproptypeT->GetNew(idProvider, lang, varValue, ppprop);

	if (FAILED(hr))
		return hr;
	
	return Add(*ppprop);
	}
LEAVE_API
}

STDMETHODIMP CMetaProperties::get_AddNew(IMetaPropertyType *pproptype, long lang, VARIANT varValue, IMetaProperty **ppprop)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyType>(pproptype);
	ValidateOutPtr<IMetaProperty>(ppprop, NULL);

	HRESULT hr = pproptype->get_New(lang, varValue, ppprop);

	if (FAILED(hr))
		return hr;
	
	return Add(*ppprop);
	}
LEAVE_API
}

#if 0
STDMETHODIMP CMetaProperties::get_UpdateOrAddNew(IMetaPropertyType *pproptype, long lang, VARIANT varValue, IMetaProperty **ppprop)
{
	HRESULT hr;
	CComPtr<IMetaProperty> pprop;

	hr = get_ItemWith(pproptype, lang, &pprop);
	if (FAILED(hr))
		return AddNew(pproptype, lang, varValue, ppprop);

	hr = pprop->put_Value(varValue);
	if (FAILED(hr))
		return hr;
	
	*ppprop = pprop.Detach();

	return S_OK;
}
#endif

STDMETHODIMP CMetaProperties::Add(IMetaProperty *pprop)
{
	HRESULT hr;
	if (pprop == NULL)
		return E_FAIL;

	ADODB::_RecordsetPtr prs;

	m_pdb->get_PropsRS(&prs);

	CComQIPtr<CMetaProperty> ppropT(pprop);

	hr = ppropT->SetObjectID(m_idObj);
	if (FAILED(hr))
		return hr;

	hr = ppropT->AddNew(prs);
	if (FAILED(hr))
		return hr;
	
	hr = ppropT->SaveValue(prs);
	if (FAILED(hr))
		{
		prs->CancelUpdate();
		return hr;
		}

	hr = prs->Update();
	if (FAILED(hr))
		return hr;

	m_pdb->Broadcast_ItemChanged(m_idObj);

	return hr;
}

STDMETHODIMP CMetaProperties::get_ItemWithTypeProviderLang(IMetaPropertyType *pproptype,
		IGuideDataProvider *pprovider, long idLang, IMetaProperty **ppprop)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyType>(pproptype);
	ValidateOutPtr<IMetaProperty>(ppprop, NULL);

	long idProvider = 0;
	if (pprovider != NULL)
	    pprovider->get_ID(&idProvider);

	return get_ItemWithTypeProviderLang(pproptype, FALSE, idProvider, idLang, ppprop);
	}
LEAVE_API
}

HRESULT CMetaProperties::get_ItemWithTypeProviderLang(IMetaPropertyType *pproptype,
		boolean fAnyProvider, long idProvider, long idLang, IMetaProperty **ppprop)
{
	HRESULT hr;
	ADODB::_RecordsetPtr prs;

	CComQIPtr<CMetaPropertyType> pproptypeT(pproptype);

	long idPropType = pproptypeT->GetID();

	hr = m_pdb->get_PropsIndexed(&prs);

	hr = SeekPropsRS(prs, m_pdb->FSQLServer(), m_idObj,
			idPropType, fAnyProvider, idProvider, idLang);
	if (FAILED(hr))
		return hr;

	return Load(idPropType, prs, ppprop);
}

STDMETHODIMP CMetaProperties::get_ItemWith(IMetaPropertyType *pproptype, long idLang, IMetaProperty **ppprop)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyType>(pproptype);
	ValidateOutPtr<IMetaProperty>(ppprop);

	long idProvider = m_pdb->GetIDGuideDataProvider();
	return get_ItemWithTypeProviderLang(pproptype, TRUE, idProvider, idLang, ppprop);
	}
LEAVE_API
}

STDMETHODIMP CMetaProperties::get_ItemsWithMetaPropertyType(IMetaPropertyType *ptype, IMetaProperties **ppprops)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyType>(ptype);
	ValidateOutPtr<IMetaProperties>(ppprops, NULL);
	CComQIPtr<CMetaPropertyType> ptypeT(ptype);

	if (ptypeT == NULL)
		return E_POINTER;

	long idPropType;

	idPropType = ptypeT->GetID();

	CComPtr<CMetaProperties> pprops = NewComObject(CMetaProperties);
	
	if (pprops != NULL)
		pprops->Init(m_idObj, idPropType, m_pdb);
	
	*ppprops = pprops.Detach();
	return S_OK;
	}
LEAVE_API
}

/////////////////////////////////////////////////////////////////////////////
// CMetaPropertyCondition

STDMETHODIMP CMetaPropertyCondition::get_And(IMetaPropertyCondition *ppropcond2, IMetaPropertyCondition **pppropcond)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyCondition>(ppropcond2);
	ValidateOutPtr<IMetaPropertyCondition>(pppropcond, NULL);

	CComPtr<CMetaPropertyConditionAnd> ppropcond = NewComObject(CMetaPropertyConditionAnd);

	if (ppropcond == NULL)
		return E_OUTOFMEMORY;

	ppropcond->Init(this, ppropcond2);

	*pppropcond = ppropcond.Detach();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyCondition::get_Or(IMetaPropertyCondition *ppropcond2, IMetaPropertyCondition **pppropcond)
{
ENTER_API
	{
	ValidateInPtr<IMetaPropertyCondition>(ppropcond2);
	ValidateOutPtr<IMetaPropertyCondition>(pppropcond, NULL);

	CComPtr<CMetaPropertyConditionOr> ppropcond = NewComObject(CMetaPropertyConditionOr);

	if (ppropcond == NULL)
		return E_OUTOFMEMORY;

	ppropcond->Init(this, ppropcond2);

	*pppropcond = ppropcond.Detach();

	return S_OK;
	}
LEAVE_API
}

#if 0
STDMETHODIMP CMetaPropertyCondition::get_Not(IMetaPropertyCondition **pppropcond)
{
ENTER_API
	{
	ValidateOutPtr<IMetaPropertyCondition>(pppropcond, NULL);

	CComPtr<CMetaPropertyConditionNot> ppropcond = NewComObject(CMetaPropertyConditionNot);

	if (ppropcond == NULL)
		return E_OUTOFMEMORY;

	ppropcond->Init(this);

	*pppropcond = ppropcond.Detach();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CMetaPropertyCondition::get_Test(IMetaProperties *pprops, BOOL *pfOk)
{
ENTER_API
	{
	ValidateInPtr<IMetaProperties>(pprops);
	ValidateOut<BOOL>(pfOk, FALSE);

	return S_OK;
	}
LEAVE_API
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\program.cpp ===
// Program.cpp : Implementation of CProgram
#include "stdafx.h"
#include "Property.h"
#include "Program.h"
#include "ScheduleEntry.h"

STDMETHODIMP CProgram::get_ScheduleEntries(IScheduleEntries **ppschedentries)
{
ENTER_API
	{
	ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

	CObjectType *pobjtype;
	HRESULT hr;

	hr = m_pdb->get_ScheduleEntryObjectType(&pobjtype);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjsT;
	hr = m_pdb->get_ObjectsWithType(pobjtype, &pobjsT);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjs;
	hr = pobjsT->get_ItemsInverseRelatedToBy((IProgram *) this,
	    m_pdb->ScheduleEntryPropSet::ProgramMetaPropertyType(), &pobjs);
	if (FAILED(hr))
		return hr;

	return pobjs->QueryInterface(__uuidof(IScheduleEntries), (void **) ppschedentries);
	}
LEAVE_API
}

STDMETHODIMP CProgram::get_Title(BSTR *pbstrTitle)
{
ENTER_API
	{
	ValidateOut(pbstrTitle);

	return m_pdb->_get_Title((IProgram *) this, pbstrTitle);
	}
LEAVE_API
}

STDMETHODIMP CProgram::put_Title(BSTR bstrTitle)
{
ENTER_API
	{
	ValidateIn(bstrTitle);

	return m_pdb->_put_Title((IProgram *) this, bstrTitle);
	}
LEAVE_API
}

STDMETHODIMP CProgram::get_Description(BSTR *pbstrDescription)
{
ENTER_API
	{
	ValidateOut(pbstrDescription);

	return m_pdb->DescriptionPropSet::_get_OneParagraph((IProgram *) this, pbstrDescription);
	}
LEAVE_API
}

STDMETHODIMP CProgram::put_Description(BSTR bstrDescription)
{
ENTER_API
	{
	ValidateIn(bstrDescription);

	return m_pdb->DescriptionPropSet::_put_OneParagraph((IProgram *) this, bstrDescription);
	}
LEAVE_API
}

STDMETHODIMP CProgram::get_CopyrightDate(DATE *pdt)
{
ENTER_API
	{
	ValidateOut<DATE>(pdt, 0);

	return m_pdb->CopyrightPropSet::_get_Date((IProgram *) this, pdt);
	}
LEAVE_API
}

STDMETHODIMP CProgram::put_CopyrightDate(DATE dt)
{
ENTER_API
	{
	return m_pdb->CopyrightPropSet::_put_Date((IProgram *) this, dt);
	}
LEAVE_API
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\property.h ===
// property.h : Declaration of the CMetaPropertySet

#ifndef __PROPERTY_H_
#define __PROPERTY_H_

#define IID_ANY_BSTR 0

#include "resource.h"       // main symbols

#include "guidedb.h"

class CMetaPropertySet;
class CMetaPropertySets;
class CMetaPropertyType;
class CMetaPropertyTypes;
class CMetaProperty;
class CMetaProperties;
class CMetaPropertyCond;
class CMetaPropertyCond1Cond;
class CMetaPropertyCond2Cond;
class CMetaPropertyCondLT;
class CMetaPropertyCondLE;
class CMetaPropertyCondEQ;
class CMetaPropertyCondGE;
class CMetaPropertyCondGT;

#include "stdprop.h"

HRESULT SeekPropsRS(ADODB::_RecordsetPtr prs, boolean fSQLServer, long idObj, long idPropType, boolean fAnyProvider, long idProvider, long idLang);

enum PersistFormat { Format_IPersistStream = 0, Format_IPersistPropertyBag };

/////////////////////////////////////////////////////////////////////////////
// CMetaPropertySet
class ATL_NO_VTABLE CMetaPropertySet : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CMetaPropertySet, &CLSID_MetaPropertySet>,
	public IDispatchImpl<IMetaPropertySet, &IID_IMetaPropertySet, &LIBID_GUIDESTORELib>
{
public:
	CMetaPropertySet()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_pproptypes = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTYSET)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CMetaPropertySet)
	COM_INTERFACE_ENTRY(IMetaPropertySet)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	bool CreatePropTypes();

	void Init(CGuideDB *pdb, long id, BSTR bstrName)
		{
		m_pdb = pdb;
		m_id = id;
		m_bstrName = bstrName;
		}

	HRESULT Load();

// IMetaPropertySet
public:
	STDMETHOD(get_MetaPropertyTypes)(/*[out, retval]*/ IMetaPropertyTypes* *ppproptypes);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pbstrName);

	long GetID()
		{
			return m_id;
		}

protected:
	CComPtr<CGuideDB> m_pdb;
	long m_id;
	_bstr_t m_bstrName;
	CComPtr<CMetaPropertyTypes> m_pproptypes;
};
	
// property.h : Declaration of the CMetaPropertySets


/////////////////////////////////////////////////////////////////////////////
// CMetaPropertySets
class ATL_NO_VTABLE CMetaPropertySets : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CMetaPropertySets, &CLSID_MetaPropertySets>,
	public IDispatchImpl<IMetaPropertySets, &IID_IMetaPropertySets, &LIBID_GUIDESTORELib>
{
public:
	CMetaPropertySets()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

	HRESULT Init(CGuideDB *pdb)
		{
		m_pdb = pdb;
		return S_OK;
		}
	HRESULT Load();

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTYSETS)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMetaPropertySets)
	COM_INTERFACE_ENTRY(IMetaPropertySets)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	HRESULT Cache(long id, BSTR bstrName, CMetaPropertySet **pppropset);

public:

// IMetaPropertySets
	STDMETHOD(get_Lookup)(BSTR bstrName, IMetaPropertyType **ppproptype);
	STDMETHOD(get_AddNew)(BSTR bstrName, /*[out, retval]*/ IMetaPropertySet **pppropset);
	STDMETHOD(get_ItemWithName)(BSTR bstrName, /*[out, retval]*/ IMetaPropertySet* *ppropset);
	STDMETHOD(get_Item)(VARIANT index, /*[out, retval]*/ IMetaPropertySet* *ppropset);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plCount);
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk);

			return E_NOTIMPL;
			}
		LEAVE_API
		}
#endif

protected:
	CComPtr<CGuideDB> m_pdb;
	typedef map<BSTR, CMetaPropertySet *, BSTRCmpLess> t_map;
	t_map m_map;
};

	
// property.h : Declaration of the CMetaPropertyType


/////////////////////////////////////////////////////////////////////////////
// CMetaPropertyType
class DECLSPEC_UUID("67CA8AB9-0A0E-43A8-B9B5-D4D10889A9E6") ATL_NO_VTABLE CMetaPropertyType : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CMetaPropertyType, &CLSID_MetaPropertyType>,
	public IDispatchImpl<IMetaPropertyType, &IID_IMetaPropertyType, &LIBID_GUIDESTORELib>
{
public:
	CMetaPropertyType()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTYTYPE)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CMetaPropertyType)
	COM_INTERFACE_ENTRY(IMetaPropertyType)
	COM_INTERFACE_ENTRY(CMetaPropertyType)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	void Init(CGuideDB *pdb, CMetaPropertySet *ppropset, long id, long idPropType,
			BSTR bstrName)
		{
		m_pdb = pdb;
		m_ppropset = ppropset;
		m_id = id;
		m_idPropType = idPropType;

		m_bstrName = bstrName;
		}

public:
	long GetID()
		{
		return m_id;
		}

	STDMETHOD(GetNew)(long idProvider, long lang, VARIANT val, /*[out, retval]*/ IMetaProperty* *ppprop);

// IMetaPropertyType
	STDMETHOD(get_Cond)(BSTR bstrCond, long lang, VARIANT varValue, /*[out, retval]*/ IMetaPropertyCondition* *ppropcond);
	STDMETHOD(get_New)(long lang, VARIANT val, /*[out, retval]*/ IMetaProperty* *ppprop)
		{
		return GetNew(m_pdb->GetIDGuideDataProvider(), lang, val, ppprop);
		}
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_MetaPropertySet)(/*[out, retval]*/ IMetaPropertySet* *ppropset);

//UNDONE: shouldn't be public.
	CComPtr<CGuideDB> m_pdb;
protected:
	CComPtr<CMetaPropertySet> m_ppropset;
	long m_id;
	long m_idPropType;
	_bstr_t m_bstrName;
};

	
// property.h : Declaration of the CMetaPropertyTypes


/////////////////////////////////////////////////////////////////////////////
// CMetaPropertyTypes
class ATL_NO_VTABLE CMetaPropertyTypes : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CMetaPropertyTypes, &CLSID_MetaPropertyTypes>,
	public IDispatchImpl<IMetaPropertyTypes, &IID_IMetaPropertyTypes, &LIBID_GUIDESTORELib>
{
public:
	CMetaPropertyTypes()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTYTYPES)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CMetaPropertyTypes)
	COM_INTERFACE_ENTRY(IMetaPropertyTypes)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	void Init(CGuideDB *pdb, CMetaPropertySet *ppropset)
		{
		m_pdb = pdb;
		m_ppropset = ppropset;
		}

	HRESULT Cache(long id, long idPropType, BSTR bstName, CMetaPropertyType **ppproptype);

// IMetaPropertyTypes
public:
	STDMETHOD(get_MetaPropertySet)(/*[out, retval]*/ IMetaPropertySet * *pVal);
	STDMETHOD(get_AddNew)(long id, BSTR bstrName, /*[out, retval]*/ IMetaPropertyType * *pVal);
	STDMETHOD(get_ItemWithName)(BSTR bstrName, /*[out, retval]*/ IMetaPropertyType* *pproptype);
	STDMETHOD(get_ItemWithID)(long id, /*[out, retval]*/ IMetaPropertyType* *pproptype);
	STDMETHOD(get_Item)(VARIANT index, /*[out, retval]*/ IMetaPropertyType* *pproptype);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk);

			return E_NOTIMPL;
			}
		LEAVE_API
		}
#endif

protected:
	CComPtr<CGuideDB> m_pdb;
	CComPtr<CMetaPropertySet> m_ppropset;

	typedef map<BSTR, CMetaPropertyType *, BSTRCmpLess> t_map;
	t_map m_map;
};


/////////////////////////////////////////////////////////////////////////////
// CMetaProperty
class DECLSPEC_UUID("f23d3b6d-c2a2-4a23-8f54-64cf97c4b6d5") ATL_NO_VTABLE CMetaProperty : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CMetaProperty, &CLSID_MetaProperty>,
	public IDispatchImpl<IMetaProperty, &IID_IMetaProperty, &LIBID_GUIDESTORELib>
{
public:
	CMetaProperty()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_idObj = 0;
		m_idProvider = 0;
		m_idPropType = 0;
		m_idLang = 0;
	}

	void Init(CGuideDB *pdb, long idPropType, long idProvider, long idLang, VARIANT varValue)
		{
		m_pdb = pdb;
		m_idPropType = idPropType;
		m_idProvider = idProvider;
		m_idLang = idLang;
		m_varValue = varValue;
		}

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTY)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMetaProperty)
	COM_INTERFACE_ENTRY(IMetaProperty)
	COM_INTERFACE_ENTRY(CMetaProperty)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IID(CLSID_MetaProperty, CMetaProperty)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	HRESULT AddNew(ADODB::_RecordsetPtr prs);
	HRESULT SaveValue(ADODB::_RecordsetPtr prs);
	HRESULT LoadValue(ADODB::_RecordsetPtr prs);

	
	long GetObjectID()
		{
		return m_idObj;
		}
	HRESULT SetObjectID(long idObj)
		{
		if (m_idObj != 0)
			return E_INVALIDARG;

		m_idObj = idObj;

		return S_OK;
		}

	STDMETHOD(PutValue)(/*[in]*/ VARIANT varValue);

public:
	STDMETHOD(get_QueryClause)(long &i, TCHAR *szOp, _bstr_t *pbstr);

// IMetaProperty
	STDMETHOD(get_Cond)(BSTR bstrCond, /*[out, retval]*/ IMetaPropertyCondition* *ppropcond);
	STDMETHOD(get_Value)(/*[out, retval]*/ VARIANT *pvarValue);
	STDMETHOD(put_Value)(/*[in]*/ VARIANT varValue);
	STDMETHOD(putref_Value)(/*[in]*/ IUnknown *punk)
		{
		VARIANT var;
		var.vt = VT_UNKNOWN | VT_BYREF;
		var.ppunkVal = &punk;
		return put_Value(var);
		}
	STDMETHOD(get_GuideDataProvider)(/*[out, retval]*/ IGuideDataProvider **ppprovider)
		{
		ENTER_API
			{
			ValidateOutPtr<IGuideDataProvider>(ppprovider, NULL);
			HRESULT hr;

			if (m_idProvider == NULL)
				return S_OK;

			CComPtr<IObjects> pobjs;
			hr = m_pdb->get_ObjectsWithType(__uuidof(GuideDataProvider), &pobjs);
			if (FAILED(hr))
			return hr;

			CComPtr<IUnknown> punk;
			hr = pobjs->get_ItemWithID(m_idProvider, &punk);
			if (FAILED(hr))
				return hr;
			return punk->QueryInterface(__uuidof(IGuideDataProvider), (void **) ppprovider);
			}
		LEAVE_API
		}
	STDMETHOD(get_Language)(/*[out, retval]*/ long *pidLang);
	STDMETHOD(get_MetaPropertyType)(/*[out, retval]*/ IMetaPropertyType* *pproptype);

protected:
	CComPtr<CGuideDB> m_pdb;
	long m_idObj;
	long m_idPropType;
	long m_idProvider;
	long m_idLang;
	_variant_t m_varValue;
};

	
/////////////////////////////////////////////////////////////////////////////
// CMetaProperties
class ATL_NO_VTABLE DECLSPEC_UUID("ec6b3b45-5f2c-4c2e-891e-bb1f504b481e") CMetaProperties : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CMetaProperties, &CLSID_MetaProperties>,
	public IDispatchImpl<IMetaProperties, &IID_IMetaProperties, &LIBID_GUIDESTORELib>
{
public:
	CMetaProperties()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTIES)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CMetaProperties)
	COM_INTERFACE_ENTRY(IMetaProperties)
	COM_INTERFACE_ENTRY(CMetaProperties)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	HRESULT Init(long idObj, long idPropType, CGuideDB *pdb)
		{
		m_idObj = idObj;
		m_idPropType = idPropType;
		m_pdb = pdb;
		return S_OK;
		}

	HRESULT Load(long idPropType, ADODB::_RecordsetPtr prs, IMetaProperty **ppprop);

	HRESULT get_AddNew(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider,
			long lang, VARIANT varValue, /*[out, retval]*/ IMetaProperty * *pVal);

	HRESULT get_ItemWithTypeProviderLang(IMetaPropertyType *ptype,
			boolean fAnyProvider, long idProvider, long lang,
			/*[out, retval]*/ IMetaProperty* *pprop);

// IMetaProperties
public:
	STDMETHOD(Add)(IMetaProperty *pprop);
	STDMETHOD(get_AddNew)(IMetaPropertyType *pproptype, long lang, VARIANT varValue, /*[out, retval]*/ IMetaProperty * *pVal);
	STDMETHOD(get_ItemsWithMetaPropertyType)(IMetaPropertyType *ptype, /*[out, retval]*/ IMetaProperties* *pprops);
	STDMETHOD(get_ItemWith)(IMetaPropertyType *ptype, long lang, /*[out, retval]*/ IMetaProperty* *pprop);
	STDMETHOD(get_ItemWithTypeProviderLang)(IMetaPropertyType *ptype, IGuideDataProvider *pprovider, long lang, /*[out, retval]*/ IMetaProperty* *pprop);
	STDMETHOD(get_Item)(VARIANT index, /*[out, retval]*/ IMetaProperty* *pprop);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk);

			return E_NOTIMPL;
			}
		LEAVE_API
		}
#endif

protected:
	CComPtr<CGuideDB> m_pdb;
	long m_idObj;
	long m_idPropType;
};

/////////////////////////////////////////////////////////////////////////////
// CMetaPropertyCondition

class ATL_NO_VTABLE DECLSPEC_UUID("ec5b84b5-eee5-45a2-88d1-415d21fe7aca") CMetaPropertyCondition : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CMetaPropertyCondition, &CLSID_MetaPropertyCondition>,
	public IDispatchImpl<IMetaPropertyCondition, &IID_IMetaPropertyCondition, &LIBID_GUIDESTORELib>
{
public:
	CMetaPropertyCondition()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROPERTYCONDITION)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CMetaPropertyCondition)
	COM_INTERFACE_ENTRY(IMetaPropertyCondition)
	COM_INTERFACE_ENTRY(CMetaPropertyCondition)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

	STDMETHOD(get_QueryClause)(long &i, _bstr_t *pbstr)
		{
		return E_FAIL;
		}

// IMetaPropertyCondition
public:

#if 0
	STDMETHOD(get_Not)(/*[out, retval]*/ IMetaPropertyCondition* *ppropcond);
#endif
	STDMETHOD(get_Or)(IMetaPropertyCondition *pcond2, /*[out, retval]*/ IMetaPropertyCondition* *ppropcond);
	STDMETHOD(get_And)(IMetaPropertyCondition *pcond2, /*[out, retval]*/ IMetaPropertyCondition* *ppropcond);
};

class CMetaPropertyCondition1Cond : public CMetaPropertyCondition
{
public:
	CMetaPropertyCondition1Cond()
		{
		m_szOp = _T("");
		}

	~CMetaPropertyCondition1Cond()
		{
		if (m_ppropcond1 != NULL)
			m_ppropcond1->Release();
		}

	void Init(IMetaPropertyCondition *ppropcond1)
		{
		m_ppropcond1 = ppropcond1;
		if (m_ppropcond1 != NULL)
			m_ppropcond1->AddRef();
		}

protected:
	STDMETHOD(get_QueryClause)(long &i, _bstr_t *pbstr)
		{
		_bstr_t bstr1;

		CComQIPtr<CMetaPropertyCondition> ppropcond1(m_ppropcond1);

		ppropcond1->get_QueryClause(i, &bstr1);

		*pbstr = m_szOp + (_T("(") + bstr1 + _T(")"));

		return S_OK;
		}

protected:
	IMetaPropertyCondition *m_ppropcond1;
	TCHAR *m_szOp;
};

class CMetaPropertyCondition2Cond : public CMetaPropertyCondition1Cond
{
public:
	~CMetaPropertyCondition2Cond()
		{
		if (m_ppropcond2 != NULL)
			m_ppropcond2->Release();
		}

	void Init(IMetaPropertyCondition *ppropcond1, IMetaPropertyCondition *ppropcond2)
		{
		CMetaPropertyCondition1Cond::Init(ppropcond1);
		m_ppropcond2 = ppropcond2;
		if (m_ppropcond2 != NULL)
			m_ppropcond2->AddRef();
		}

protected:
	STDMETHOD(get_QueryClause)(long &i, _bstr_t *pbstr)
		{
		_bstr_t bstr1;

		CComQIPtr<CMetaPropertyCondition> ppropcond1(m_ppropcond1);

		ppropcond1->get_QueryClause(i, &bstr1);

		_bstr_t bstr2;

		CComQIPtr<CMetaPropertyCondition> ppropcond2(m_ppropcond2);

		ppropcond2->get_QueryClause(i, &bstr2);

		*pbstr = (_T("(") + bstr1 + _T(")")) + m_szOp + (_T("(") + bstr2 + _T(")"));

		return S_OK;
		}

protected:
	IMetaPropertyCondition *m_ppropcond2;
};

class CMetaPropertyConditionAnd : public CMetaPropertyCondition2Cond
{
public:
	CMetaPropertyConditionAnd()
		{
		m_szOp = _T(" AND ");
		}

};

class CMetaPropertyConditionOr : public CMetaPropertyCondition2Cond
{
public:
	CMetaPropertyConditionOr()
		{
		m_szOp = _T(" OR ");
		}

};

#if 0
class CMetaPropertyConditionNot : public CMetaPropertyCondition1Cond
{
public:
	CMetaPropertyConditionNot()
		{
		m_szOp = _T("NOT ");
		}

};
#endif

class CMetaPropertyCondition1Prop : public CMetaPropertyCondition
{
public:
	~CMetaPropertyCondition1Prop()
		{
		if (m_pprop != NULL)
			m_pprop->Release();
		}
	
	void Init(IMetaProperty *pprop)
		{
		m_pprop = pprop;
		if (m_pprop != NULL)
			m_pprop->AddRef();
		}

	STDMETHOD(get_QueryClause)(long &i, _bstr_t *pbstr)
		{
		_bstr_t bstr1;

		CComQIPtr<CMetaProperty> pprop(m_pprop);

		return pprop->get_QueryClause(i, m_szOp, pbstr);
		}
	
	virtual BOOL FCompare(VARIANT var1, VARIANT var2) = 0;

protected:
	TCHAR * m_szOp;
	IMetaProperty *m_pprop;
};

inline int VariantCompare(VARIANT & var1, VARIANT & var2)
{
	switch(VarCmp(&var1, &var2, LOCALE_USER_DEFAULT, 0))
		{
		case VARCMP_EQ:
			return 0;
		case VARCMP_LT:
			return -1;
		case VARCMP_GT:
			return 1;
		case VARCMP_NULL:
			return -1;
		}

		return -1;
}

class CMetaPropertyConditionEQ : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionEQ()
		{
		m_szOp = _T(" = ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return (VariantCompare(var1, var2) == 0);
		}
};

class CMetaPropertyConditionNE : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionNE()
		{
		m_szOp = _T(" <> ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return (VariantCompare(var1, var2) != 0);
		}
};

class CMetaPropertyConditionLike : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionLike()
		{
		m_szOp = _T(" LIKE ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return FALSE; //UNDONE
		}
};

class CMetaPropertyConditionNotLike : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionNotLike()
		{
		m_szOp = _T(" NOT LIKE ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return FALSE; //UNDONE
		}
};

class CMetaPropertyConditionLT : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionLT()
		{
		m_szOp = _T(" < ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return (VariantCompare(var1, var2) > 0);
		}
};

class CMetaPropertyConditionLE : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionLE()
		{
		m_szOp = _T(" <= ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return (VariantCompare(var1, var2) <= 0);
		}
};

class CMetaPropertyConditionGT : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionGT()
		{
		m_szOp = _T(" > ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return (VariantCompare(var1, var2) > 0);
		}
};

class CMetaPropertyConditionGE : public CMetaPropertyCondition1Prop
{
public:
	CMetaPropertyConditionGE()
		{
		m_szOp = _T(" >= ");
		}

	virtual BOOL FCompare(VARIANT var1, VARIANT var2)
		{
		return (VariantCompare(var1, var2) >= 0);
		}
};


#endif //__PROPERTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\program.h ===
// Program.h : Declaration of the CProgram

#ifndef __PROGRAM_H_
#define __PROGRAM_H_

#include "resource.h"       // main symbols

#include "object.h"
#include "GuideStoreCP.h"


class CProgram;
class CPrograms;

/////////////////////////////////////////////////////////////////////////////
// CProgram
class ATL_NO_VTABLE CProgram : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CProgram, &CLSID_Program>,
	public CObjectGlue,
	public IDispatchImpl<IProgram, &IID_IProgram, &LIBID_GUIDESTORELib>
{
public:
	CProgram()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROGRAM)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CProgram)
	COM_INTERFACE_ENTRY(IProgram)
	COM_INTERFACE_ENTRY2(IDispatch, IProgram)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IProgram
public:
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *ppprops)
		{
		return CObjectGlue::get_MetaProperties(ppprops);
		}
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pid)
		{
		return CObjectGlue::get_ID(pid);
		}
	STDMETHOD(get_CopyrightDate)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(put_CopyrightDate)(/*[in]*/ DATE newVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Description)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Title)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_Title)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_ScheduleEntries)(/*[out, retval]*/ IScheduleEntries * *pVal);

protected:
};

	
// Program.h : Declaration of the CPrograms


/////////////////////////////////////////////////////////////////////////////
// CPrograms
class ATL_NO_VTABLE CPrograms : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CPrograms, &CLSID_Programs>,
	public IConnectionPointContainerImpl<CPrograms>,
	public CObjectsGlue<IPrograms, IProgram>,
	public IDispatchImpl<IPrograms, &IID_IPrograms, &LIBID_GUIDESTORELib>,
	public CProxyIProgramsEvents< CPrograms >
{
public:
	CPrograms()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PROGRAMS)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CPrograms)
	COM_INTERFACE_ENTRY(IPrograms)
	COM_INTERFACE_ENTRY2(IDispatch, IPrograms)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IObjectsNotifications)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CPrograms)
CONNECTION_POINT_ENTRY(DIID_IProgramsEvents)
END_CONNECTION_POINT_MAP()


#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IObjectsNotifications
	STDMETHOD(Notify_ItemAdded)(IUnknown *punk)
		{
		CComQIPtr<IProgram> pprog(punk);

		return Fire_ItemAdded(pprog);
		}
	STDMETHOD(Notify_ItemRemoved)(long idObj)
		{
		return Fire_ItemRemoved(idObj);
		}
	STDMETHOD(Notify_ItemChanged)(IUnknown *punk)
		{
		CComQIPtr<IProgram> pprog(punk);

		return Fire_ItemChanged(pprog);
		}
	STDMETHOD(Notify_ItemsChanged)()
		{
		return Fire_ItemsChanged();
		}
// IPrograms
public:
#if 0
	STDMETHOD(get_ItemsInTimeRange)(DATE dtStart, DATE dtEnd, /*[out, retval]*/ IPrograms * *ppprograms)
		{
		HRESULT hr;
		CComQIPtr<IObjects> pobjs(m_punkObjs);
		CComPtr<IObjects> pobjsNew;

		hr = pobjs->get_ItemsInTimeRange(dtStart, dtEnd, &pobjsNew);
		if (FAILED(hr))
			return hr;

		return  pobjsNew->QueryInterface(__uuidof(IPrograms), (void **) ppprograms);
		}
#endif

	STDMETHOD(get_AddNew)(/*[out, retval]*/ IProgram * *ppprog)
		{
		ENTER_API
			{
			ValidateOutPtr<IProgram>(ppprog, NULL);

			return _get_AddNew(ppprog);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsWithMetaPropertyCond)(IMetaPropertyCondition *pcond, /*[out, retval]*/ IPrograms * *ppprogs)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyCondition>(pcond);
			ValidateOutPtr<IPrograms>(ppprogs, NULL);

			return _get_ItemsWithMetaPropertyCond(pcond, ppprogs);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsWithMetaProperty)(IMetaProperty *pprop, /*[out, retval]*/ IPrograms * *ppprogs)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaProperty>(pprop);
			ValidateOutPtr<IPrograms>(ppprogs, NULL);

			return _get_ItemsWithMetaProperty(pprop, ppprogs);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsByKey)(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, IPrograms **ppprogs)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyType>(pproptype);
			ValidateInPtr_NULL_OK<IGuideDataProvider>(pprovider);
			ValidateOutPtr<IPrograms>(ppprogs, NULL);

			return _get_ItemsByKey(pproptype, pprovider, idLang, vt, ppprogs);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithKey)(VARIANT varKey, /*[out, retval]*/ IProgram * *ppprog)
		{
		ENTER_API
			{
			ValidateOutPtr<IProgram>(ppprog, NULL);

			return _get_ItemWithKey(varKey, ppprog);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithID)(long id, /*[out, retval]*/ IProgram * *ppprog)
		{
		ENTER_API
			{
			ValidateOutPtr<IProgram>(ppprog, NULL);

			return _get_ItemWithID(id, ppprog);
			}
		LEAVE_API
		}
	STDMETHOD(get_Item)(VARIANT varIndex, /*[out, retval]*/ IProgram * *ppprog)
		{
		ENTER_API
			{
			ValidateOutPtr<IProgram>(ppprog, NULL);

			return _get_Item(varIndex, ppprog);
			}
		LEAVE_API
		}
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plCount)
		{
		ENTER_API
			{
			ValidateOut<long>(plCount, 0);

			return _get_Count(plCount);
			}
		LEAVE_API
		}
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk, NULL);
			return _get__NewEnum(ppunk);
			}
		LEAVE_API
		}
#endif
	STDMETHOD(Remove)(VARIANT var)
		{
		ENTER_API
			{
			return _Remove(var);
			}
		LEAVE_API
		}
	STDMETHOD(RemoveAll)()
		{
		ENTER_API
			{
			return _RemoveAll();
			}
		LEAVE_API
		}
	STDMETHOD(Resync)()
		{
		ENTER_API
			{
			return _Resync();
			}
		LEAVE_API
		}

	STDMETHOD(UnreferencedItems)(/*[out, retval]*/ IPrograms * *ppprogs)
		{
		ENTER_API
			{
			ValidateOutPtr<IPrograms>(ppprogs, NULL);

			return _UnreferencedItems(ppprogs);
			}
		LEAVE_API
		}

protected:
};

#endif //__PROGRAM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\scheduleentry.cpp ===
// ScheduleEntry.cpp : Implementation of CScheduleEntry
#include "stdafx.h"
#include "ScheduleEntry.h"
#include "Property.h"

/////////////////////////////////////////////////////////////////////////////
// CScheduleEntry


/////////////////////////////////////////////////////////////////////////////
// CScheduleEntries


STDMETHODIMP CScheduleEntries::get_ItemWithServiceAtTime(IService *pservice, DATE dt, IScheduleEntry **ppschedentry)
{
ENTER_API
	{
	HRESULT hr;
	ValidateInPtr<IService>(pservice);
	ValidateOutPtr<IScheduleEntry>(ppschedentry, NULL);

	CComPtr<IScheduleEntries> pschedentries;
	hr = get_ItemsWithService(pservice, &pschedentries);
	if (FAILED(hr))
		return hr;

	long cItems;
	hr = pschedentries->get_Count(&cItems);
	if (FAILED(hr))
	    return hr;
	if (cItems == 0)
	    return E_INVALIDARG;

	CComQIPtr<IObjects> pobjs(pschedentries);
	CComPtr<IObjects> pobjs2;
	hr = pobjs->get_ItemsInTimeRange(dt, dt, &pobjs2);
	if (FAILED(hr))
		return hr;

	hr = pobjs2->get_Count(&cItems);
	if (FAILED(hr))
	    return hr;
	if (cItems == 0)
	    return E_INVALIDARG;

	CComPtr<IUnknown> punk;
	hr = pobjs2->get_Item(_variant_t(0L), &punk);
	if (FAILED(hr))
		return hr;

	return punk->QueryInterface(__uuidof(IScheduleEntry), (void **) ppschedentry);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntries::get_ItemsWithService(IService *pservice, IScheduleEntries **ppschedentries)
{
ENTER_API
	{
	ValidateInPtr<IService>(pservice);
	ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

	CComQIPtr<CObjects> pobjs(GetControllingUnknown());
	CComPtr<IObjects> pobjsT;
	HRESULT hr;

	hr = pobjs->get_ItemsInverseRelatedToBy(pservice,
			m_pdb->ScheduleEntryPropSet::ServiceMetaPropertyType(), &pobjsT);
	if (FAILED(hr))
		return hr;

	return pobjsT->QueryInterface(__uuidof(IScheduleEntries), (void **) ppschedentries);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntries::get_AddNew(DATE dtStart, DATE dtEnd, IService *pservice, IProgram *pprog, IScheduleEntry **ppschedentry)
{
ENTER_API
	{
	ValidateInPtr<IService>(pservice);
	ValidateOutPtr<IScheduleEntry>(ppschedentry, NULL);

	HRESULT hr;

	hr = _get_AddNew(ppschedentry);
	if (FAILED(hr))
		return hr;

	(*ppschedentry)->putref_Service(pservice);
	(*ppschedentry)->putref_Program(pprog);
	(*ppschedentry)->put_StartTime(dtStart);
	(*ppschedentry)->put_EndTime(dtEnd);
	
	return hr;
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::get_Service(IService **ppservice)
{
ENTER_API
	{
	ValidateOutPtr<IService>(ppservice, NULL);

	HRESULT hr;
	if (m_pservice == NULL)
		{
		hr = _get_ItemRelatedBy(m_pdb->ScheduleEntryPropSet::ServiceMetaPropertyType(), (IService **) &m_pservice);
		if (hr == S_FALSE || FAILED(hr))
			return hr;
		}

	m_pservice.CopyTo(ppservice);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::putref_Service(IService *pservice)
{
ENTER_API
	{
	ValidateInPtr<IService>(pservice);

	m_pservice = pservice;
	return _put_ItemRelatedBy(m_pdb->ScheduleEntryPropSet::ServiceMetaPropertyType(),
			(IService *) m_pservice);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::get_Program(IProgram **ppprog)
{
ENTER_API
	{
	ValidateOutPtr<IProgram>(ppprog, NULL);

	HRESULT hr;
	if (m_pprog == NULL)
		{
		hr = _get_ItemRelatedBy(m_pdb->ScheduleEntryPropSet::ProgramMetaPropertyType(),
				(IProgram **) &m_pprog);
		if (FAILED(hr))
			return hr;
		}

	m_pprog.CopyTo(ppprog);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::putref_Program(IProgram *pprog)
{
ENTER_API
	{
	ValidateInPtr<IProgram>(pprog);

	m_pprog = pprog;

	return _put_ItemRelatedBy(m_pdb->ScheduleEntryPropSet::ProgramMetaPropertyType(),
			(IProgram *) m_pprog);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::get_StartTime(DATE *pdtStart)
{
ENTER_API
	{
	ValidateOut<DATE>(pdtStart);

	return m_pdb->_get_Start((IScheduleEntry *) this, pdtStart);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::put_StartTime(DATE dtStart)
{
ENTER_API
	{
	return m_pdb->_put_Start((IScheduleEntry *) this, dtStart);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::get_EndTime(DATE *pdtEnd)
{
ENTER_API
	{
	ValidateOut<DATE>(pdtEnd);

	return m_pdb->_get_End((IScheduleEntry *) this, pdtEnd);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::put_EndTime(DATE dtEnd)
{
ENTER_API
	{
	return m_pdb->_put_End((IScheduleEntry *) this, dtEnd);
	}
LEAVE_API
}

STDMETHODIMP CScheduleEntry::get_Length(long *plSecs)
{
ENTER_API
	{
	ValidateOut<long>(plSecs, 0);

	// UNDONE: Test
	DATE dtStart;
	DATE dtEnd;
	HRESULT hr;

	hr = get_StartTime(&dtStart);
	if (FAILED(hr))
		return hr;
	hr = get_EndTime(&dtEnd);
	if (FAILED(hr))
		return hr;

	*plSecs = (long) ((dtEnd - dtStart)*86400.0); // 86400 = 24*60*60

	return S_OK;
	}
LEAVE_API
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GuideStore.rc
//
#define IDS_PROJNAME                    100
#define IDR_PROPERTYSET                 101
#define IDR_PROPERTYSETS                102
#define IDR_PROPERTYTYPE                103
#define IDR_PROPERTYTYPES               104
#define IDR_PROPERTY                    105
#define IDR_PROPERTIES                  106
#define IDR_PROPERTYCONDITION           107
#define IDR_GUIDESTORE                  108
#define IDR_GUIDESTORE1                 109
#define IDR_SERVICE                     110
#define IDR_SERVICES                    111
#define IDR_PROGRAM                     112
#define IDR_PROGRAMS                    113
#define IDR_SCHEDULEENTRY               114
#define IDR_SCHEDULEENTRIES             115
#define IDR_CHANNEL                     116
#define IDR_CHANNELS                    117
#define IDR_CHANNELLINEUP               118
#define IDR_CHANNELLINEUPS              119
#define IDR_OBJECT                      120
#define IDR_OBJECTTYPE                  121
#define IDR_OBJECTS                     122
#define IDR_OBJECTTYPES                 123
#define IDR_OBJECTFACTORY               124
#define IDR_PROGRAMFACTORY              125
#define IDR_SERVICEFACTORY              126
#define IDR_SCHEDULEENTRYFACTORY        127
#define IDR_CHANNELFACTORY              128
#define IDR_CHANNELLINEUPFACTORY        129
#define IDR_TESTTUNEREQUEST             130
#define IDR_GUIDEDATAPROVIDER           131
#define IDR_GUIDEDATAPROVIDERS          132
#define IDR_GUIDEDATAPROVIDERFACTORY    133

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           134
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\scheduleentry.h ===
// ScheduleEntry.h : Declaration of the CScheduleEntry

#ifndef __SCHEDULEENTRY_H_
#define __SCHEDULEENTRY_H_

#include "resource.h"       // main symbols

#include "object.h"
#include "GuideStoreCP.h"

class CScheduleEntry;
class CScheduleEntries;

/////////////////////////////////////////////////////////////////////////////
// CScheduleEntry
class ATL_NO_VTABLE CScheduleEntry : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CScheduleEntry, &CLSID_ScheduleEntry>,
	public CObjectGlue,
	public IDispatchImpl<IScheduleEntry, &IID_IScheduleEntry, &LIBID_GUIDESTORELib>
{
public:

	CScheduleEntry()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SCHEDULEENTRY)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CScheduleEntry)
	COM_INTERFACE_ENTRY(IScheduleEntry)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
	}

	void FinalRelease();

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IScheduleEntry
public:
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *ppprops)
		{
		return CObjectGlue::get_MetaProperties(ppprops);
		}
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pid)
		{
		return CObjectGlue::get_ID(pid);
		}
	STDMETHOD(get_Length)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_EndTime)(/*[out, retval]*/ DATE *pdt);
	STDMETHOD(put_EndTime)(/*[in]*/ DATE dt);
	STDMETHOD(get_StartTime)(/*[out, retval]*/ DATE *pdt);
	STDMETHOD(put_StartTime)(/*[in]*/ DATE dt);
	STDMETHOD(get_Program)(/*[out, retval]*/ IProgram * *ppprog);
	STDMETHOD(putref_Program)(/*[in]*/ IProgram * pprog);
	STDMETHOD(get_Service)(/*[out, retval]*/ IService * *ppservice);
	STDMETHOD(putref_Service)(/*[in]*/ IService * pservice);

protected:

	CComPtr<IService> m_pservice;
	CComPtr<IProgram> m_pprog;
};

/////////////////////////////////////////////////////////////////////////////
// CScheduleEntries
class ATL_NO_VTABLE CScheduleEntries : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CScheduleEntries, &CLSID_ScheduleEntries>,
	public IConnectionPointContainerImpl<CScheduleEntries>,
	public CObjectsGlue<IScheduleEntries, IScheduleEntry>,
	public IDispatchImpl<IScheduleEntries, &IID_IScheduleEntries, &LIBID_GUIDESTORELib>,
	public CProxyIScheduleEntriesEvents< CScheduleEntries >
{
public:
	CScheduleEntries()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SCHEDULEENTRIES)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CScheduleEntries)
	COM_INTERFACE_ENTRY(IScheduleEntries)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IObjectsNotifications)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CScheduleEntries)
CONNECTION_POINT_ENTRY(DIID_IScheduleEntriesEvents)
END_CONNECTION_POINT_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IObjectsNotifications
	STDMETHOD(Notify_ItemAdded)(IUnknown *punk)
		{
		CComQIPtr<IScheduleEntry> pschedentry(punk);

		return Fire_ItemAdded(pschedentry);
		}
	STDMETHOD(Notify_ItemRemoved)(long idObj)
		{
		return Fire_ItemRemoved(idObj);
		}
	STDMETHOD(Notify_ItemChanged)(IUnknown *punk)
		{
		CComQIPtr<IScheduleEntry> pschedentry(punk);

		return Fire_ItemChanged(pschedentry);
		}
	STDMETHOD(Notify_ItemsChanged)()
		{
		return Fire_ItemsChanged();
		}

// IScheduleEntries
public:
	STDMETHOD(Remove)(VARIANT var)
		{
		ENTER_API
			{
			return _Remove(var);
			}
		LEAVE_API
		}
	STDMETHOD(RemoveAll)()
		{
		ENTER_API
			{
			return _RemoveAll();
			}
		LEAVE_API
		}
	STDMETHOD(Resync)()
		{
		ENTER_API
			{
			return _Resync();
			}
		LEAVE_API
		}

	STDMETHOD(UnreferencedItems)(/*[out, retval]*/ IScheduleEntries * *ppschedentries)
		{
		ENTER_API
			{
			ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

			return _UnreferencedItems(ppschedentries);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsInTimeRange)(DATE dtStart, DATE dtEnd, /*[out, retval]*/ IScheduleEntries * *ppschedentries)
		{
		ENTER_API
			{
			ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

			return _get_ItemsInTimeRange(dtStart, dtEnd, ppschedentries);
			}
		LEAVE_API
		}
	STDMETHOD(get_AddNew)(DATE dtStart, DATE dtEnd, IService *pservice, IProgram *pprog, /*[out, retval]*/ IScheduleEntry * *pVal);
	STDMETHOD(get_ItemsWithMetaPropertyCond)(IMetaPropertyCondition *pcond, /*[out, retval]*/ IScheduleEntries * *ppschedentries)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyCondition>(pcond);
			ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

			return _get_ItemsWithMetaPropertyCond(pcond, ppschedentries);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsWithMetaProperty)(IMetaProperty *pprop, /*[out, retval]*/ IScheduleEntries * *ppschedentries)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaProperty>(pprop);
			ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

			return _get_ItemsWithMetaProperty(pprop, ppschedentries);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsWithService)(IService *pservice, /*[out, retval]*/ IScheduleEntries **ppschedentries);
	STDMETHOD(get_ItemWithServiceAtTime)(IService *pservice, DATE dt, /*[out, retval]*/ IScheduleEntry * *pVal);
	STDMETHOD(get_ItemsByKey)(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, IScheduleEntries **ppschedentries)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyType>(pproptype);
			ValidateInPtr_NULL_OK<IGuideDataProvider>(pprovider);
			ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

			return _get_ItemsByKey(pproptype, pprovider, idLang, vt, ppschedentries);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithKey)(VARIANT varKey, /*[out, retval]*/ IScheduleEntry * *ppschedentry)
		{
		ENTER_API
			{
			ValidateOutPtr<IScheduleEntry>(ppschedentry, NULL);

			return _get_ItemWithKey(varKey, ppschedentry);
			}
		LEAVE_API
		}
	STDMETHOD(get_Item)(VARIANT varIndex, /*[out, retval]*/ IScheduleEntry * *ppschedentry)
		{
		ENTER_API
			{
			ValidateOutPtr<IScheduleEntry>(ppschedentry, NULL);

			return _get_Item(varIndex, ppschedentry);
			}
		LEAVE_API
		}
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plCount)
		{
		ENTER_API
			{
			ValidateOut<long>(plCount, 0);

			return _get_Count(plCount);
			}
		LEAVE_API
		}
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk, NULL);

			return _get__NewEnum(ppunk);
			}
		LEAVE_API
		}
#endif

protected:
};

#if defined(_ATL_FREE_THREADED)
inline void CScheduleEntry::FinalRelease()
{
	m_pUnkMarshaler.Release();
}
#endif

#endif //__SCHEDULEENTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\service.cpp ===
// Service.cpp : Implementation of CService
#include "stdafx.h"
#include "Service.h"
#include "channel.h"
#include "Property.h"
#include "ScheduleEntry.h"

/////////////////////////////////////////////////////////////////////////////
// CService


/////////////////////////////////////////////////////////////////////////////
// CServices

STDMETHODIMP CServices::get_ChannelLineups(IChannelLineups **ppchanlineups)
{
ENTER_API
	{
	ValidateOutPtr<IChannelLineups>(ppchanlineups, NULL);

	if (m_pchanlineups == NULL)
		{
		HRESULT hr;
		CObjectType *pobjtype;

		hr = m_pdb->get_ChannelLineupObjectType(&pobjtype);
		if (FAILED(hr))
			return hr;

		CComPtr<IObjects> pobjs;
		hr = m_pdb->get_ObjectsWithType(pobjtype, &pobjs);
		if (FAILED(hr))
			return hr;

		hr = pobjs->QueryInterface(__uuidof(IChannelLineups), (void **)&m_pchanlineups);
		if (FAILED(hr))
			return hr;
		}
	
	(*ppchanlineups = m_pchanlineups)->AddRef();

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CServices::get_AddNew(IUnknown *punkTuneRequest, BSTR bstrProviderName, BSTR bstrProviderDescription, BSTR bstrProviderNetworkName, DATE dtStart, DATE dtEnd, IService **ppservice)
{
ENTER_API
	{
	ValidateInPtr_NULL_OK<IUnknown>(punkTuneRequest);
	ValidateIn(bstrProviderName);
	ValidateIn(bstrProviderDescription);
	ValidateIn(bstrProviderNetworkName);
	ValidateOutPtr<IService>(ppservice, NULL);

	CComQIPtr<IObjects> pobjs(GetControllingUnknown());
	CComPtr<IUnknown> pobj;

	HRESULT hr = pobjs->get_AddNew(&pobj);
	if (FAILED(hr))
		return hr;

	hr = pobj->QueryInterface(IID_IService, (void **) ppservice);
	if (FAILED(hr))
		return hr;

	(*ppservice)->putref_TuneRequest(punkTuneRequest);
	(*ppservice)->put_ProviderName(bstrProviderName);
	(*ppservice)->put_ProviderDescription(bstrProviderDescription);
	(*ppservice)->put_ProviderNetworkName(bstrProviderNetworkName);
	(*ppservice)->put_StartTime(dtStart);
	(*ppservice)->put_EndTime(dtEnd);
	
	return hr;
	}
LEAVE_API
}


STDMETHODIMP CServices::get_ItemWithProviderName(BSTR bstrProviderName, IService **ppservice)
{
ENTER_API
	{
	ValidateIn(bstrProviderName);
	ValidateOutPtr<IService>(ppservice, NULL);

	// UNDONE: Test
	CComPtr<IMetaPropertyType> pproptype= m_pdb->ProviderPropSet::NameMetaPropertyType();
	CComPtr<IMetaProperty> pprop;
	HRESULT hr;

	hr = pproptype->get_New(0, _variant_t(bstrProviderName), &pprop);
	if (FAILED(hr))
		return hr;

	CComPtr<IMetaPropertyCondition> ppropcond;

	hr = pprop->get_Cond(_bstr_t(_T("=")), &ppropcond);
	if (FAILED(hr))
		return hr;

	CComQIPtr<IObjects> pobjsThis(GetControllingUnknown());
	CComPtr<IObjects> pobjs;

	hr = pobjsThis->get_ItemsWithMetaPropertyCond(ppropcond, &pobjs);
	if (FAILED(hr))
		return hr;

	CComPtr<IUnknown> pobj;

	hr = pobjs->get_Item(_variant_t(0L), &pobj);
	if (FAILED(hr))
		return hr;

	hr = pobj->QueryInterface(__uuidof(IService), (void **) ppservice);

	return hr;
	}
LEAVE_API
}


STDMETHODIMP CService::get_TuneRequest(IUnknown **ppunk)
{
ENTER_API
	{
	ValidateOutPtr<IUnknown>(ppunk, NULL);

	HRESULT hr;

	if (m_punkTuneRequest == NULL)
		{
		_variant_t var;
		hr = m_pdb->_get_TuneRequest((IService *) this, &var);
		if (FAILED(hr))
			return hr;
		
		switch (var.vt)
		    {
		    case VT_UNKNOWN:
			break;
		    case VT_EMPTY:
			return S_FALSE;
		    default:
			return E_FAIL;
		    }
		
		m_punkTuneRequest = var.punkVal;
		}

	m_punkTuneRequest.CopyTo(ppunk);

	return S_OK;
	}
LEAVE_API
}

STDMETHODIMP CService::putref_TuneRequest(IUnknown *punk)
{
ENTER_API
	{
	ValidateInPtr_NULL_OK<IUnknown>(punk);

	m_punkTuneRequest = punk;


	VARIANT var;
	if (punk != NULL)
		{
		var.vt = VT_UNKNOWN | VT_BYREF;
		var.ppunkVal = &punk;
		}
	else
	    {
	    var.vt = VT_EMPTY;
	    var.lVal = 0;
	    }
	return m_pdb->_put_TuneRequest((IService *) this, var);
	}
LEAVE_API
}


STDMETHODIMP CService::get_StartTime(DATE *pdtStart)
{
ENTER_API
	{
	ValidateOut<DATE>(pdtStart, 0);

	return m_pdb->_get_Start((IService *) this, pdtStart);
	}
LEAVE_API
}

STDMETHODIMP CService::put_StartTime(DATE dtStart)
{
ENTER_API
	{
	return m_pdb->_put_Start((IService *) this, _variant_t(dtStart));
	}
LEAVE_API
}

STDMETHODIMP CService::get_EndTime(DATE *pdtEnd)
{
ENTER_API
	{
	ValidateOut<DATE>(pdtEnd, 0);

	return m_pdb->_get_End((IService *) this, pdtEnd);
	}
LEAVE_API
}

STDMETHODIMP CService::put_EndTime(DATE dtEnd)
{
ENTER_API
	{
	return m_pdb->_put_End((IService *) this, dtEnd);
	}
LEAVE_API
}

STDMETHODIMP CService::get_ProviderName(BSTR *pbstrName)
{
ENTER_API
	{
	ValidateOut(pbstrName);

	return m_pdb->ProviderPropSet::_get_Name((IService *) this, pbstrName);
	}
LEAVE_API
}

STDMETHODIMP CService::put_ProviderName(BSTR bstrName)
{
ENTER_API
	{
	ValidateIn(bstrName);

	return m_pdb->ProviderPropSet::_put_Name((IService *) this, bstrName);
	}
LEAVE_API
}

STDMETHODIMP CService::get_ProviderNetworkName(BSTR *pbstrName)
{
ENTER_API
	{
	ValidateOut(pbstrName);

	return m_pdb->ProviderPropSet::_get_NetworkName((IService *) this, pbstrName);
	}
LEAVE_API
}

STDMETHODIMP CService::put_ProviderNetworkName(BSTR bstrName)
{
ENTER_API
	{
	ValidateIn(bstrName);

	return m_pdb->ProviderPropSet::_put_NetworkName((IService *) this, bstrName);
	}
LEAVE_API
}

STDMETHODIMP CService::get_ProviderDescription(BSTR *pbstrDescr)
{
ENTER_API
	{
	ValidateOut(pbstrDescr);

	return m_pdb->ProviderPropSet::_get_Description((IService *) this, pbstrDescr);
	}
LEAVE_API
}

STDMETHODIMP CService::put_ProviderDescription(BSTR bstrDescr)
{
ENTER_API
	{
	ValidateIn(bstrDescr);

	return m_pdb->ProviderPropSet::_put_Description((IService *) this, bstrDescr);
	}
LEAVE_API
}

STDMETHODIMP CService::get_ScheduleEntries(IScheduleEntries **ppschedentries)
{
ENTER_API
	{
	ValidateOutPtr<IScheduleEntries>(ppschedentries, NULL);

	CObjectType *pobjtype;
	HRESULT hr;

	hr = m_pdb->get_ScheduleEntryObjectType(&pobjtype);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjsT;
	hr = m_pdb->get_ObjectsWithType(pobjtype, &pobjsT);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjs;
	hr = pobjsT->get_ItemsInverseRelatedToBy((IService *) this,
	    m_pdb->ScheduleEntryPropSet::ServiceMetaPropertyType(), &pobjs);
	if (FAILED(hr))
		return hr;

	return pobjs->QueryInterface(__uuidof(IScheduleEntries), (void **) ppschedentries);
	}
LEAVE_API
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\sharedmemory.cpp ===
#include "stdafx.h"
#include "SharedMemory.h"

int CircBuffWrite(BYTE *pbStart, int cbBuff, int obDst, BYTE *pbSrc, int cb)
{
	// Assumes cb bytes are available and 0 <= obDst <= cbBuff.

	// cb1 is the lesser of number of bytes before the end of the buffer
	//   and the number of bytes to write.
	int cb1 = min(cb, cbBuff - obDst);
	if (cb1 > 0)
		{
		memcpy(pbStart + obDst, pbSrc, cb1);
		obDst += cb1;
		cb -= cb1;
		}

	// If there's anything left, then we wrapped around to the
	// beginning of the buffer.
	if (cb > 0)
		{
		memcpy(pbStart, pbSrc + cb1, cb);
		obDst = cb1;
		}
	
	return obDst;
}

int CircBuffRead(BYTE *pbStart, int cbBuff, int obSrc, BYTE *pbDst, int cb)
{
	// Assumes cb bytes are available and 0 <= obDst <= cbBuff.

	// cb1 is the lesser of number of bytes before the end of the buffer
	//   and the number of bytes to write.
	int cb1 = min(cb, cbBuff - (pbDst - pbStart));
	if (cb1 > 0)
		{
		memcpy(pbDst, pbStart + obSrc, cb1);
		obSrc += cb1;
		cb -= cb1;
		}

	// If there's anything left, then we wrapped around to the
	// beginning of the buffer.
	if (cb > 0)
		{
		memcpy(pbDst + cb1, pbStart, cb);
		obSrc = cb1;
		}
	
	return obSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\service.h ===
// Service.h : Declaration of the CService

#ifndef __SERVICE_H_
#define __SERVICE_H_

#include "resource.h"       // main symbols

#include "object.h"
#include "GuideStoreCP.h"

class CService;
class CServices;

/////////////////////////////////////////////////////////////////////////////
// CService
class ATL_NO_VTABLE CService : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CService, &CLSID_Service>,
	public CObjectGlue,
	public IDispatchImpl<IService, &IID_IService, &LIBID_GUIDESTORELib>
{
public:
	CService()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_punkTuneRequest = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SERVICE)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CService)
	COM_INTERFACE_ENTRY(IService)
	COM_INTERFACE_ENTRY(IDispatch)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
END_COM_MAP()

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
	}

	void FinalRelease();

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IService
public:
	STDMETHOD(get_MetaProperties)(/*[out, retval]*/ IMetaProperties * *ppprops)
		{
		return CObjectGlue::get_MetaProperties(ppprops);
		}
	STDMETHOD(get_ID)(/*[out, retval]*/ long *pid)
		{
		return CObjectGlue::get_ID(pid);
		}
	STDMETHOD(get_ScheduleEntries)(/*[out, retval]*/ IScheduleEntries * *pVal);
	STDMETHOD(get_ProviderDescription)(/*[out, retval]*/ BSTR *pbstrDesc);
	STDMETHOD(put_ProviderDescription)(/*[in]*/ BSTR pbstrDesc);
	STDMETHOD(get_ProviderNetworkName)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_ProviderNetworkName)(/*[in]*/ BSTR bstrName);
	STDMETHOD(get_ProviderName)(/*[out, retval]*/ BSTR *pbstrName);
	STDMETHOD(put_ProviderName)(/*[in]*/ BSTR pbstrName);
	STDMETHOD(get_EndTime)(/*[out, retval]*/ DATE *pdt);
	STDMETHOD(put_EndTime)(/*[in]*/ DATE dt);
	STDMETHOD(get_StartTime)(/*[out, retval]*/ DATE *pdt);
	STDMETHOD(put_StartTime)(/*[in]*/ DATE dt);
	STDMETHOD(get_TuneRequest)(/*[out, retval]*/ IUnknown * *ppunk);
	STDMETHOD(putref_TuneRequest)(/*[in]*/ IUnknown  *punk);

protected:
	CComPtr<IUnknown> m_punkTuneRequest;
};

	
// Service.h : Declaration of the CServices


/////////////////////////////////////////////////////////////////////////////
// CServices
class ATL_NO_VTABLE CServices : 
	public CComObjectRootEx<CComObjectThreadModel>,
	public CComCoClass<CServices, &CLSID_Services>,
	public IConnectionPointContainerImpl<CServices>,
	public CObjectsGlue<IServices, IService>,
	public IDispatchImpl<IServices, &IID_IServices, &LIBID_GUIDESTORELib>,
	public CProxyIServicesEvents< CServices >
{
public:
	CServices()
	{
#if defined(_ATL_FREE_THREADED)
		m_pUnkMarshaler = NULL;
#endif
		m_pchanlineups = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SERVICES)
DECLARE_GET_CONTROLLING_UNKNOWN()

#if defined(_ATL_FREE_THREADED)
DECLARE_PROTECT_FINAL_CONSTRUCT()
#endif

BEGIN_COM_MAP(CServices)
	COM_INTERFACE_ENTRY(IServices)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
#if defined(_ATL_FREE_THREADED)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
#endif
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IObjectsNotifications)
END_COM_MAP()
BEGIN_CONNECTION_POINT_MAP(CServices)
CONNECTION_POINT_ENTRY(DIID_IServicesEvents)
END_CONNECTION_POINT_MAP()


// IObjectsNotifications
	STDMETHOD(Notify_ItemAdded)(IUnknown *punk)
		{
		CComQIPtr<IService> pservice(punk);

		return Fire_ItemAdded(pservice);
		}
	STDMETHOD(Notify_ItemRemoved)(long idObj)
		{
		return Fire_ItemRemoved(idObj);
		}
	STDMETHOD(Notify_ItemChanged)(IUnknown *punk)
		{
		CComQIPtr<IService> pservice(punk);

		return Fire_ItemChanged(pservice);
		}
	STDMETHOD(Notify_ItemsChanged)()
		{
		return Fire_ItemsChanged();
		}

#if defined(_ATL_FREE_THREADED)
	HRESULT FinalConstruct()
	{
		HRESULT hr;

		hr = CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);

		return hr;
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
		m_pchanlineups.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;
#endif

// IServices
public:
	STDMETHOD(get_ItemsInTimeRange)(DATE dtStart, DATE dtEnd, /*[out, retval]*/ IServices * *ppservices)
		{
		ENTER_API
			{
			ValidateOutPtr<IServices>(ppservices, NULL);
			return _get_ItemsInTimeRange(dtStart, dtEnd, ppservices);
			}
		LEAVE_API
		}

	STDMETHOD(get_AddNew)(IUnknown *punkTuneRequest, BSTR bstrProviderName, BSTR bstrProviderDescription, BSTR bstrProviderNetworkName, DATE dtStart, DATE dtEnd, /*[out, retval]*/ IService * *pVal);
	STDMETHOD(get_ItemsWithMetaPropertyCond)(IMetaPropertyCondition *pcond, /*[out, retval]*/ IServices * *ppservices)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyCondition>(pcond);
			ValidateOutPtr<IServices>(ppservices, NULL);

			return _get_ItemsWithMetaPropertyCond(pcond, ppservices);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemsWithMetaProperty)(IMetaProperty *pprop, /*[out, retval]*/ IServices * *ppservices)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaProperty>(pprop);
			ValidateOutPtr<IServices>(ppservices, NULL);

			return _get_ItemsWithMetaProperty(pprop, ppservices);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithProviderName)(BSTR bstrProviderName, /*[out, retval]*/ IService * *pVal);
	STDMETHOD(get_ItemsByKey)(IMetaPropertyType *pproptype, IGuideDataProvider *pprovider, long idLang, long vt, IServices **ppservices)
		{
		ENTER_API
			{
			ValidateInPtr<IMetaPropertyType>(pproptype);
			ValidateInPtr_NULL_OK<IGuideDataProvider>(pprovider);
			ValidateOutPtr<IServices>(ppservices, NULL);

			return _get_ItemsByKey(pproptype, pprovider, idLang, vt, ppservices);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithKey)(VARIANT varKey, /*[out, retval]*/ IService * *ppservice)
		{
		ENTER_API
			{
			ValidateOutPtr<IService>(ppservice, NULL);

			return _get_ItemWithKey(varKey, ppservice);
			}
		LEAVE_API
		}
	STDMETHOD(get_ItemWithID)(long id, /*[out, retval]*/ IService * *ppservice)
		{
		ENTER_API
			{
			ValidateOutPtr<IService>(ppservice, NULL);

			return _get_ItemWithID(id, ppservice);
			}
		LEAVE_API
		}
	STDMETHOD(Remove)(VARIANT varIndex)
		{
		ENTER_API
			{
			return _Remove(varIndex);
			}
		LEAVE_API
		}
	STDMETHOD(RemoveAll)()
		{
		ENTER_API
			{
			return _RemoveAll();
			}
		LEAVE_API
		}
	STDMETHOD(Resync)()
		{
		ENTER_API
			{
			return _Resync();
			}
		LEAVE_API
		}

	STDMETHOD(UnreferencedItems)(/*[out, retval]*/ IServices * *ppservices)
		{
		ENTER_API
			{
			ValidateOutPtr<IServices>(ppservices, NULL);

			return _UnreferencedItems(ppservices);
			}
		LEAVE_API
		}
	STDMETHOD(get_ChannelLineups)(/*[out, retval]*/ IChannelLineups * *pVal);
	STDMETHOD(get_Item)(VARIANT varIndex, /*[out, retval]*/ IService * *ppservice)
		{
		ENTER_API
			{
			ValidateOutPtr<IService>(ppservice, NULL);

			return _get_Item(varIndex, ppservice);
			}
		LEAVE_API
		}
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plCount)
		{
		ENTER_API
			{
			ValidateOut<long>(plCount, 0);

			return _get_Count(plCount);
			}
		LEAVE_API
		}
#ifdef IMPLEMENT_NewEnum
	STDMETHOD(get__NewEnum)(IUnknown **ppunk)
		{
		ENTER_API
			{
			ValidateOutPtr<IUnknown>(ppunk, NULL);

			return _get__NewEnum(ppunk);
			}
		LEAVE_API
		}
#endif

protected:
	CComPtr<IChannelLineups> m_pchanlineups;
};


#if defined(_ATL_FREE_THREADED)
inline void CService::FinalRelease()
{
	m_pUnkMarshaler.Release();
}
#endif


#endif //__SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\sharedmemory.h ===
#ifndef _SHAREDMEMORY_H_
#define _SHAREDMEMORY_H_

int CircBuffWrite(BYTE *pbStart, int cbBuff, int obDst, BYTE *pbSrc, int cb);
int CircBuffRead(BYTE *pbStart, int cbBuff, int obSrc, BYTE *pbDst, int cb);

class SharedMemorySignature
{
public:
	void Ready()
		{
		m_fReady = TRUE;
		}

	void Sign(const char *sz)
		{
		strncpy(m_sz, sz, sizeof(m_sz));
		}

	void WaitUntilReady()
		{
		while (!m_fReady)
			Sleep(0);
		}

	char m_sz[4];
	long m_fReady;
};

class SharedMemoryLock
{
public:
	class PerProcessData
		{
		friend SharedMemoryLock;

		public:

		PerProcessData()
			{
			m_hWaitRead = 0;
			m_hWaitWrite = 0;
			m_hWaitNew = 0;
			}
		
		~PerProcessData()
			{
			Close();
			}
		
		HRESULT Open(const TCHAR *szName)
			{
			TCHAR sz[MAX_PATH];

			// Create an auto-reset event for waiting readers
			wsprintf(sz, _TEXT("%s_R"), szName);
			m_hWaitRead = CreateEvent(NULL, FALSE, FALSE, sz);

			// Create an auto-reset event for waiting writers
			wsprintf(sz, _TEXT("%s_W"), szName);
			m_hWaitWrite = CreateEvent(NULL, FALSE, FALSE, sz);

			// Create an auto-reset event for those waiting for new data
			wsprintf(sz, _TEXT("%s_N"), szName);
			m_hWaitNew = CreateEvent(NULL, FALSE, FALSE, sz);
			}
		
		void Close()
			{
			if (m_hWaitRead != NULL)
				{
				CloseHandle(m_hWaitRead);
				m_hWaitRead = NULL;
				}
			if (m_hWaitWrite != NULL)
				{
				CloseHandle(m_hWaitWrite);
				m_hWaitWrite = NULL;
				}
			if (m_hWaitNew != NULL)
				{
				CloseHandle(m_hWaitNew);
				m_hWaitNew = NULL;
				}
			}
		protected:

		HANDLE m_hWaitRead;
		HANDLE m_hWaitWrite;
		HANDLE m_hWaitNew;
		};

	void Init()
		{
		m_lSpinLock = 0;
		m_cWaitingNew = 0;
		m_cReadersActive = 0;
		m_cReadersWaiting = 0;
		m_cWritersActive = 0;
		m_cWritersWaiting = 0;
		}
	
	DWORD WaitToRead(PerProcessData *pperprocess, DWORD dwMillisecs)
		{
		Lock();
		while (m_cWritersActive > 0)
			{
			// Can't read if there are any writers active
			m_cReadersWaiting++;

			Unlock();
			DWORD dw = WaitForSingleObject(pperprocess->m_hWaitRead, dwMillisecs);
			Lock();

			if (dw != WAIT_OBJECT_0)
				{
				m_cReadersWaiting--;
				Unlock();
				return dw;
				}
			}
		
		m_cReadersActive++;
		Unlock();
		
		return WAIT_OBJECT_0;
		}
	
	void ReadComplete(PerProcessData *pperprocess)
		{
		Lock();
		m_cReadersActive--;
		if ((m_cReadersActive == 0) && (m_cWritersWaiting > 0))
			{
			// Give a writer a chance.
			m_cWritersWaiting--;
			SetEvent(pperprocess->m_hWaitWrite);
			}
		Unlock();
		}
	
	DWORD WaitForNew(PerProcessData *pperprocess, DWORD dwMillisecs)
		{
		Lock();
		m_cWaitingNew++;
		Unlock();
		return WaitForSingleObject(pperprocess->m_hWaitNew, dwMillisecs);
		}
	
	DWORD WaitToWrite(PerProcessData *pperprocess, DWORD dwMillisecs)
		{
		Lock();
		while ((m_cWritersActive != 0) || (m_cReadersActive != 0))
			{
			// Can't write if there are any readers or any writers
			m_cWritersWaiting++;

			Unlock();
			DWORD dw = WaitForSingleObject(pperprocess->m_hWaitRead, dwMillisecs);
			Lock();

			if (dw != WAIT_OBJECT_0)
				{
				m_cWritersWaiting--;
				Unlock();
				return dw;
				}
			}
		
		m_cWritersActive++;
		Unlock();
		
		return WAIT_OBJECT_0;
		}
	
	void WriteComplete(PerProcessData *pperprocess, boolean fNewData)
		{
		Lock();
		m_cWritersActive--;

		if (fNewData)
			{
			// Release anybody who's waiting for new data.
			while (m_cWaitingNew > 0)
				{
				SetEvent(pperprocess->m_hWaitNew);
				m_cWaitingNew--;
				}
			}
		
		if (m_cReadersWaiting)
			{
			// Unblock all the readers.
			while (m_cReadersWaiting--)
				SetEvent(pperprocess->m_hWaitRead);
			}
		else if (m_cWritersWaiting)
			{
			// Unblock one writer.
			m_cWritersWaiting--;
			SetEvent(pperprocess->m_hWaitWrite);
			}
		Unlock();
		}

protected:
	void Lock()
		{
		// Spin and get access to the shared memory
		while (InterlockedExchange(&m_lSpinLock, 1) != 0)
			Sleep(0);
		}

	void Unlock()
		{
		InterlockedExchange(&m_lSpinLock, 0);
		}

    long m_lSpinLock;        // Used to gain access to this structure
	int m_cWaitingNew;
	int m_cReadersActive;
	int m_cReadersWaiting;
	int m_cWritersActive;
	int m_cWritersWaiting;
};

template <class TShared, int nLocks>
class SharedMemory
{
public:
	SharedMemory()
		{
		}
	void Open(LPCTSTR lpName);
	void Close();

	TShared * SharedData()
		{
		return m_pvClient;
		}

	void InitLock(int iLock)
		{
		m_rglock[i].Init();
		}
	~SharedMemory()
		{
		Close();
		}

	DWORD WaitToRead(int i, DWORD dwMilliseconds)
		{
		return m_rglock[i].WaitToRead(m_rglockperprocess[i], dwMilliseconds);
		}

	void ReadComplete(int i)
		{
		return m_rglock[i].ReadComplete(m_rglockperprocess[i]);
		}

	DWORD WaitForNew(int i, DWORD dwMillisecs)
		{
		return m_rglock[i].WaitForNew(m_rglockperprocess[i], dwMilliseconds);
		}

	DWORD WaitToWrite(int i, DWORD dwMillisecs)
		{
		return m_rglock[i].WaitToWrite(m_rglockperprocess[i], dwMilliseconds);
		}

	void WriteComplete(int i, boolean fNewData)
		{
		return m_rglock[i].WriteComplete(m_rglockperprocess[i], fNewData);
		}


protected:
	HRESULT CreateFileView(LPCTSTR lpName);

protected:
    SharedMemoryLock *m_rglock;
	SharedMemoryLock::PerProcessData m_rglockperprocess[nLocks];

    HANDLE m_hFileMap;         // Handle to memory mapped file

	void *m_pvSharedMem;
	TShared *m_pvClient;
};

template <class TShared, int nLocks>
void SharedMemory<TShared, nLocks>::Open(LPCTSTR lpName)
{
	HRESULT hr;

	// Try to create the memory mapped file
	hr = CreateFileView(lpName);

	if (FAILED(hr))
		{
		Close();
		return;
		}
	
	for (int i = 0; i < nLocks; i++)
		{
		TCHAR sz[MAX_PATH];

        wsprintf(sz, _T("CLA_%s_%d"), lpName, i);
		m_rglockperprocess[i].Open(sz);
		}
}

template <class TShared, int nLocks>
void SharedMemory<TShared, nLocks>::Close()
{
	// Clean up
	if (m_pvSharedMem)
		{
		UnmapViewOfFile(m_pvSharedMem);
		m_pvSharedMem= NULL;
		m_rglock = NULL;
		m_pvClient = NULL;
		}
	if (m_hFileMap)
		{
		CloseHandle(m_hFileMap);
		m_hFileMap = NULL;
		}
	for (int i = 0; i < nLocks; i++)
		m_rglockperprocess[i].Close();
}

template <class TShared, int nLocks>
HRESULT SharedMemory<TShared, nLocks>::CreateFileView(LPCTSTR lpName)
{
    if (lpName == NULL)
		return E_INVALIDARG;

	int cb = sizeof(SharedMemorySignature) + nLocks*sizeof(SharedMemoryLock)
			+ sizeof(TShared);

	m_hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL,
			PAGE_READWRITE, 0, cb, lpName);
 
    // Map a view of the file
    if (m_hFileMap)
		{
		DWORD dwLastError = GetLastError();
		m_pvSharedMem = MapViewOfFile(m_hFileMap, FILE_MAP_WRITE, 0, 0, 0);
        if (m_pvSharedMem)
			{
			m_psignature = (SharedMemorySignature *) m_pvSharedMem;
			m_rglock = (SharedMemoryLock *) (m_psignature + 1);
			m_pvClient = (TShared *) (m_rglock + nLocks);
            if (dwLastError != ERROR_ALREADY_EXISTS)
				{
				m_psignature->Sign("CLA");
				for (int i = 0; i < nLocks; i++)
					InitLock(i);
				m_psignature->Ready();
				}
            else
				{
				// It already exists; wait until it is initialized by the creator
		        m_psignature->WaitUntilReady();
				}
            return S_OK;
			}
		}
    return E_FAIL; //UNDONE: Proper error code
}

template <int cReadersMax, int cbShared, int cbThread>
class MulticastQueue
{
	typedef MulticastQueue<cReadersMax, cbShared, cbThread> ThisClass;

public:
	MulticastQueue()
		{
		m_iReader = -1;
		m_hCopySharedMemThread = 0;
		m_fRunCopySharedMemThread = FALSE;
		}
	
	HRESULT Open(LPCTSTR lpName)
		{
		m_shared.Open(lpName);

		m_pSharedBuff = m_shared.SharedData();

		m_iReader = m_pSharedBuff.AllocReader();

		StartCopySharedMemThread();
		}
	
	void StartCopySharedMemThread()
		{
		DWORD id;
		m_fRunCopySharedMemThread = TRUE;
		m_hCopySharedMemThread = CreateThread(NULL, 0, _CopySharedMemThread,
				(void *) this, 0, &id);
		}
	
	void StopCopySharedMemThread()
		{
		// Thread will exit once it sees this go to FALSE.
		m_fRunCopySharedMemThread = FALSE;
		}
	
	static DWORD WINAPI _CopySharedMemThread(LPVOID pv)
		{
		ThisClass *pThis = (ThisClass *) pv;

		return pThis->CopySharedMemThread();
		}

	HRESULT ReadShared(BYTE *pb, int cb)
		{
		HRESULT hr;
		
		while (m_pSharedBuff->CbAvailable() < cb)
			m_shared.WaitForNew(0, 0);

		hr = E_FAILED;
		while (FAILED(hr))
			{
			m_shared.WaitToRead(0, 0);
			hr = m_pSharedBuff->Read(pb, cb);
			m_shared.ReadComplete(0);
			}
		
		return S_OK;
		}
	
	DWORD CopySharedMemThread()
		{
		while (m_fRunCopySharedMemThread)
			{
			int cb;
			while (TRUE)
				{
				cb = m_pSharedBuff->CbAvailable();
				if (cb <= 0)
					m_shared.WaitForNew(0, 0);
					
				cb = min(m_ThreadBuff.CbFree(), cb);
				if (cb > 0)
					break;

				// UNDONE : wait for space available in thread buffer
				}
			m_shared.WaitToRead(0, 0);
			m_pSharedBuff->Read(&buff, cb);
			m_ThreadBuff->Write(&buff, cb);
			}

		return 0;
		}

	class ThreadBuffer
		{
		public:
			ThreadBuffer()
				{
				m_obRead = 0;
				m_obWrite = 0;
				}
			
			int CbAvailable()
				{
				int cb = m_obWrite - m_obRead;
				if (cb < 0)
					cb += cbThread;

				return cb;
				}

			HRESULT Read(BYTE *pb, int cb)
				{
				if (CbAvailable() < cb)
					return E_FAIL;
				
				m_obRead = CircBuffRead(m_rgb, cbThread, m_obRead, pb, cb);
				
				return S_OK;
				}
			
			HRESULT Write(BYTE *pb, int cb)
				{
				if (cbThread - CbAvailable() < cb)
					return E_FAIL;

				m_obWrite = CircBuffWrite(m_rgb, cbThread, m_obWrite, pb, cb);
				return S_OK;
				}
		protected:	
			int m_obRead;
			int m_obWrite;
			BYTE m_rgb[cbThread];
		};
	
	class SharedBuffer
		{
		void Init()
			{
			m_cReadersMac = 0;
			m_oWriteCur = 0;
			for (int i = 0; i < cReadersMax; i++)
				m_rgoReadCur[i] = -1;
			}
		
		int CbAvailable(int i)
			{
			if (m_rgoReadCur[i] == -1)
				return 0;

			int cb = m_oWriteCur - m_rgoReadCur[i];
			if (cb < 0)
				cb += cbShared;
			
			return cb;
			}
		
		HRESULT Write(BYTE *pb, int cb)
			{
			int cbFree = cbShared;
			for (int i = 0; i < m_cReadersMac; i++)
				{
				int cbCur = cbShared - CbAvailable(i);
				if (cbCur < cbFree)
					cbFree = cbCur;
				}
			
			if (cbFree < cb)
				return E_FAIL;
			
			m_obWrite = CircBuffWrite(m_rgb, cbShared, m_obWrite, pb, cb);
			
			return S_OK;
			}
		
		HRESULT Read(int i, BYTE *pb, int cb, int *pcbRead)
			{
			_ASSERTE((i >= 0) && (i < m_cReadersMac) && (m_rgoReadCur[i] != -1));

			cb = min(cb, CbAvailable(i));
			if (pcbRead != NULL)
				*pcbRead = cb;
			if (cb == 0)
				return S_FALSE;
			
			m_rgoReadCur[i] = CircBuffRead(m_rgb, cbShared, m_rgoReadCur[i], pb, cb);
			
			return S_OK;
			}
		
		int AllocReader()
			{
			int i;
			for (i = 0; (i < m_cReadersMac) && (m_rgoReadCur[i] == -1); i++)
				;
			
			if (i >= cReadersMax)
				return -1;
			
			if (i >= m_cReadersMac)
				m_iReaderMac = i + 1;

			m_rgoReadCur[i] = m_oWriteCur;
			return i;
			}

		int m_iReaderMac;
		int m_oWriteCur;
		int m_rgoReadCur[cReadersMax];
		BYTE m_rgb[cbShared];
		};
	
	HRESULT Read(BYTE *pb, int cb, int *pcbRead, boolean fWait)
		{
		*pcbRead = 0;
		while (cb > 0)
			{
			int cbRead = min(cb, m_ThreadBuff.CbAvailable());
			if (cbRead > 0)
				{
				m_ThreadBuff.Read(pb, cbRead);
				pb += cbRead;
				*pcbRead += cbRead;
				cb -= cbRead;
				}
			else
				{
				if (!fWait)
					return S_FALSE;
				m_ThreadBuff.WaitForNew(0);
				}
			}

		return S_OK;
		}

	HRESULT Write(BYTE *pb, int cb)
		{
		HRESULT hr = E_FAIL;

		if (cb > cbShared)
			return E_FAIL;

		while (FAILED(hr))
			{
			m_shared.WaitToWrite(0, 0);
			hr = m_pSharedBuff->Write(pb, cb);
			m_shared.WriteComplete(0, SUCCEEDED(hr));
			}

		return hr;
		}
	
	int ReaderNumber()
		{
		return m_iReader;
		}

protected:
	int m_iReader;
	SharedMemory<SharedBuffer, 1> m_shared;
	SharedBuffer *m_pSharedBuff;
	ThreadBuffer m_ThreadBuff;

	BOOL m_fRunCopySharedMemThread;
	HANDLE m_hCopySharedMemThread;
};

#endif // _SHAREDMEMORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\stdprop.h ===
#ifndef __STDPROP_H_
#define __STDPROP_H_
	
IMetaProperty *GetMetaProperty(IUnknown *pobj, IMetaPropertyType *pproptype, long lang = 0);
HRESULT GetMetaPropertyValue(IUnknown *pobj, IMetaPropertyType *pproptype,
		VARIANT *pvarValue);
HRESULT PutMetaPropertyValue(IUnknown *pobj, IMetaPropertyType *pproptype,
		VARIANT varValue);

class CGuideDB;

class CStdPropSet
{
public:
	CStdPropSet(const char *szName)
		{
		m_bstrName = szName;
		m_ppropset = NULL;
		}
	
	virtual HRESULT GetDB(CGuideDB **ppdb) = 0;
	
	IMetaPropertyType *GetMetaPropertyType(long id, const char *szName);
	void Init(IMetaPropertySets *ppropsets)
		{
		m_ppropsets = ppropsets;
		}

	IMetaProperty *GetMetaProperty(IUnknown *pobj, IMetaPropertyType *pproptype, long lang = 0);
	HRESULT GetMetaPropertyValue(IUnknown *pobj, IMetaPropertyType *pproptype,
		VARIANT *pvarValue);
	HRESULT PutMetaPropertyValue(IUnknown *pobj, IMetaPropertyType *pproptype,
		VARIANT varValue);

protected:
	CComPtr<IMetaPropertySet> m_ppropset;
	CComPtr<IMetaPropertySets> m_ppropsets;
	_bstr_t m_bstrName;
};

#define BEGIN_PROPERTYSET_(n, s) \
	class n ## PropSet : public CStdPropSet \
		{ \
		public: \
		n ## PropSet() : CStdPropSet(s) \
			{ \
			}

#define BEGIN_PROPERTYSET(n) BEGIN_PROPERTYSET_(n, #n)

#define PROPSET_ENTRY_(id, n, s) \
	CComPtr<IMetaPropertyType> m_p##n; \
	IMetaPropertyType * n##MetaPropertyType() \
		{ \
		if (m_p##n == NULL) \
			m_p##n = GetMetaPropertyType(id, s); \
		return m_p##n; \
		} \
	template <class T> \
	HRESULT _get_##n(T *pT, VARIANT *pvarValue) \
		{ \
		CComQIPtr<IMetaPropertyType> pproptype = n##MetaPropertyType(); \
		if (pproptype == NULL) \
			return E_FAIL; \
		return GetMetaPropertyValue(pT, pproptype, pvarValue); \
		} \
	template <class T> \
	HRESULT _get_##n(T *pT, BSTR *pbstr) \
		{ \
		HRESULT hr; \
		_variant_t varValue; \
		CComQIPtr<IMetaPropertyType> pproptype = n##MetaPropertyType(); \
		if (pproptype == NULL) \
			return E_FAIL; \
		hr = GetMetaPropertyValue(pT, pproptype, &varValue); \
		if (FAILED(hr)) \
			return hr; \
		*pbstr = _bstr_t(varValue).copy(); \
		return S_OK; \
		} \
	template <class T> \
	HRESULT _get_##n(T *pT, DATE *pdate) \
		{ \
		HRESULT hr; \
		_variant_t varValue; \
		hr = GetMetaPropertyValue(pT, n##MetaPropertyType(), &varValue); \
		if (FAILED(hr)) \
			return hr; \
		try \
			{ \
			varValue.ChangeType(VT_DATE); \
			} \
		catch (_com_error & e) \
			{ \
			return e.Error(); \
			} \
		*pdate = varValue.date; \
		return S_OK; \
		} \
	HRESULT _get_##n(IUnknown *punk, VARIANT *pvarValue) \
		{ \
		return GetMetaPropertyValue(punk, n##MetaPropertyType(), pvarValue); \
		} \
	template <class T> \
	HRESULT _put_##n(T *pT, VARIANT varValue) \
		{ \
		return PutMetaPropertyValue(pT, n##MetaPropertyType(), varValue); \
		} \
	template <class T> \
	HRESULT _put_##n(T *pT, BSTR bstr) \
		{ \
		_variant_t varValue(bstr); \
		return PutMetaPropertyValue(pT, n##MetaPropertyType(), varValue); \
		} \
	template <class T> \
	HRESULT _put_##n(T *pT, DATE date) \
		{ \
		_variant_t varValue(date); \
		return PutMetaPropertyValue(pT, n##MetaPropertyType(), varValue); \
		} \
	HRESULT _put_##n(IUnknown *punk, VARIANT varValue) \
		{ \
		return PutMetaPropertyValue(punk, n##MetaPropertyType(), varValue); \
		} \


#define PROPSET_ENTRY(id, n) PROPSET_ENTRY_(id, n, #n)

#define END_PROPERTYSET(n) \
	}; \

BEGIN_PROPERTYSET(Description)
	PROPSET_ENTRY(0, ID)
	PROPSET_ENTRY(1, Name)
	PROPSET_ENTRY(2, Title)
	PROPSET_ENTRY(3, Subtitle)
	PROPSET_ENTRY_(4, OneSentence, "One Sentence")
	PROPSET_ENTRY_(5, OneParagraph, "One Paragraph")
	PROPSET_ENTRY(6, Version)
END_PROPERTYSET(Description)


BEGIN_PROPERTYSET(Time)
	PROPSET_ENTRY(1, Start)
	PROPSET_ENTRY(2, End)
END_PROPERTYSET(Time)

BEGIN_PROPERTYSET(Copyright)
	PROPSET_ENTRY(1, Text)
	PROPSET_ENTRY(2, Date)
END_PROPERTYSET(Copyright)
	
BEGIN_PROPERTYSET(Service)
	PROPSET_ENTRY(1, TuneRequest)
END_PROPERTYSET(Service)
	
BEGIN_PROPERTYSET(ScheduleEntry)
	PROPSET_ENTRY(1, Service)
	PROPSET_ENTRY(2, Program)
END_PROPERTYSET(Service)

BEGIN_PROPERTYSET(Channels)
	PROPSET_ENTRY(1, Channel)
END_PROPERTYSET(Channels)


BEGIN_PROPERTYSET(Channel)
	PROPSET_ENTRY(1, Service)
END_PROPERTYSET(Channel)

BEGIN_PROPERTYSET(Ratings)
	PROPSET_ENTRY(1, MinimumAge)
	PROPSET_ENTRY(2, Sex)
	PROPSET_ENTRY(3, Violence)
	PROPSET_ENTRY(4, Language)
END_PROPERTYSET(Ratings)

BEGIN_PROPERTYSET_(MPAARatings, "MPAA Ratings")
	PROPSET_ENTRY(1, Rating)
END_PROPERTYSET(MPAARatings)

BEGIN_PROPERTYSET(Categories)
	PROPSET_ENTRY( 0x00, Reserved_00)
	PROPSET_ENTRY( 0x01, Movie)
	PROPSET_ENTRY( 0x02, Sports)
	PROPSET_ENTRY( 0x03, Special)
	PROPSET_ENTRY( 0x04, Series)
	PROPSET_ENTRY( 0x05, News)
	PROPSET_ENTRY( 0x06, Shopping)
	PROPSET_ENTRY( 0x07, Reserved_07)
	PROPSET_ENTRY( 0x08, Reserved_08)
	PROPSET_ENTRY( 0x09, Reserved_09)
	PROPSET_ENTRY( 0x0A, Reserved_0A)
	PROPSET_ENTRY( 0x0B, Reserved_0B)
	PROPSET_ENTRY( 0x0C, Reserved_0C)
	PROPSET_ENTRY( 0x0D, Reserved_0D)
	PROPSET_ENTRY( 0x0E, Reserved_0E)
	PROPSET_ENTRY( 0x0F, Reserved_0F)

	PROPSET_ENTRY( 0x10, Action)
	PROPSET_ENTRY( 0x11, Adventure)
	PROPSET_ENTRY( 0x12, Children)
	PROPSET_ENTRY( 0x13, Comedy)
	PROPSET_ENTRY( 0x14, Drama)
	PROPSET_ENTRY( 0x15, Fantasy)
	PROPSET_ENTRY( 0x16, Horror)
	PROPSET_ENTRY( 0x17, Musical)
	PROPSET_ENTRY( 0x18, Romance)
	PROPSET_ENTRY_(0x19, SciFi, "Sci-Fi")
	PROPSET_ENTRY( 0x1A, Western)

	PROPSET_ENTRY( 0x20, Baseball)
	PROPSET_ENTRY( 0x21, Basketball)
	PROPSET_ENTRY( 0x22, Boxing)
	PROPSET_ENTRY( 0x23, Football)
	PROPSET_ENTRY( 0x24, Golf)
	PROPSET_ENTRY( 0x25, Hockey)
	PROPSET_ENTRY( 0x26, Racing)
	PROPSET_ENTRY( 0x27, Skiing)
	PROPSET_ENTRY( 0x28, Soccer)
	PROPSET_ENTRY( 0x29, Tennis)
	PROPSET_ENTRY( 0x2A, Wrestling)

	PROPSET_ENTRY_(0x32, CulturalArts, "Cultural Arts")
	PROPSET_ENTRY( 0x34, Educational)
	PROPSET_ENTRY_(0x35, GeneralInterest, "General Interest")
	PROPSET_ENTRY_(0x36, HowTo, "How-to")
	PROPSET_ENTRY( 0x37, Mature)
	PROPSET_ENTRY( 0x38, Music)
	PROPSET_ENTRY( 0x39, Religious)
	PROPSET_ENTRY_(0x3A, SoapOpera, "Soap Opera")
	PROPSET_ENTRY( 0x3B, Talk)

	PROPSET_ENTRY( 0x50, Business)
	PROPSET_ENTRY( 0x51, Current)
	PROPSET_ENTRY( 0x53, Weather)

	PROPSET_ENTRY_(0x60, HomeShopping, "Home Shopping")
	PROPSET_ENTRY_(0x61, ProductInfo, "Product Information")
END_PROPERTYSET(Categories)

BEGIN_PROPERTYSET(Provider)
	PROPSET_ENTRY(1, Name)
	PROPSET_ENTRY(2, NetworkName)
	PROPSET_ENTRY(3, Description)
END_PROPERTYSET(Provider)

#endif //__STDPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B7E9C4D4_B8E5_48DE_A578_B75F8096FB42__INCLUDED_)
#define AFX_STDAFX_H__B7E9C4D4_B8E5_48DE_A578_B75F8096FB42__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#if 0
#define _ATL_DEBUG_INTERFACES 1
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

#import "msado21.tlb" rename("EOF", "EndOfFile") raw_method_prefix("") high_method_prefix("_")
#import "sqldmo.rll" raw_method_prefix("") high_method_prefix("_") rename("GetUserName", "_GetUserName")
#import "msadox.dll" raw_method_prefix("") high_method_prefix("_")

#include <icrsint.h>
#undef END_ADO_BINDING
#define END_ADO_BINDING()   {0, ADODB::adEmpty, 0, 0, 0, 0, 0, 0, 0, FALSE}};\
	return rgADOBindingEntries;}
#include <oledb.h>

#include <map>
#include <list>
#include <vector>
using namespace std;

#define THIS_FILE __FILE__

#define sizeofarray(a) (sizeof(a)/sizeof((a)[0]))

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

class ILRUCache
{
public:
	virtual void Lock() = 0;
	virtual void Unlock() = 0;
	virtual void AddToCache(IUnknown *punk) = 0;
	virtual void RemoveFromCache(IUnknown *punk) = 0;
};

class DECLSPEC_UUID("321ADAAD-5334-4227-8982-585A9A3F4C02") ILRUCachedObject : public IUnknown
{
public:
	virtual HRESULT put_Cache(ILRUCache *pcache) = 0;
#if 0
	virtual ULONG RefCount() = 0;
#endif
};

template <class T>
class CComObjectCachedLRU : public T, public ILRUCachedObject
{
public:
	CComObjectCachedLRU<T>()
		{
		m_pcache = NULL;
		}

	// Set refcount to 1 to protect destruction
	~CComObjectCachedLRU()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)()
	{
		m_csCached.Lock();
		ULONG l = InternalAddRef();
		if (m_dwRef == 2)
			{
			_Module.Lock();
			if (m_pcache != NULL)
				m_pcache->RemoveFromCache(GetControllingUnknown());
			}
		m_csCached.Unlock();
		return l;
	}
	STDMETHOD_(ULONG, Release)()
	{
		m_csCached.Lock();
		InternalRelease();
		ULONG l = m_dwRef;
	
		if (l > 1)
			{
			m_csCached.Unlock();
			return l;
			}

		if (l == 1)
			{
			if (m_pcache != NULL)
				{
				_Module.Unlock();
				// Can't reference any member variables after call to AddToCache()
				// because AddToCache() might Release() this object down to
				// zero refs... that would cause the object to be deleted.
				ILRUCache *pcache = m_pcache;

				pcache->Lock();
				m_csCached.Unlock();
				pcache->AddToCache(GetControllingUnknown());
				pcache->Unlock();
				}
			else
				{
				m_csCached.Unlock();
				}

			return l;
			}

		if (l == 0)
			{
			m_csCached.Unlock();
			delete this;
			// Return right away so member variables aren't accidently referenced.
			return l;
			}
		
		_ASSERTE(TRUE);  // Should never get here.
		return 0;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
		{
		HRESULT hr;
		hr = _InternalQueryInterface(iid, ppvObject);
		if (hr == E_NOINTERFACE)
			{
			if (iid == __uuidof(ILRUCachedObject))
				{
				*ppvObject = (void *)(ILRUCachedObject *)this;
				AddRef();
				hr = S_OK;
				}
			}
		return  hr;
		}

	static HRESULT WINAPI CreateInstance(CComObjectCachedLRU<T>** pp);

	// ILRUCachedObject
	virtual HRESULT put_Cache(ILRUCache *pcache)
		{
		// NOTE: No reference count
		m_pcache = pcache;
		return S_OK;
		}

#if 0
	virtual ULONG RefCount()
		{
		return m_dwRef;
		}
#endif

protected:
	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
	ILRUCache *m_pcache;
};

template <class T>
HRESULT WINAPI CComObjectCachedLRU<T>::CreateInstance(CComObjectCachedLRU<T>** pp)
{
	ATLASSERT(pp != NULL);
	HRESULT hRes = E_OUTOFMEMORY;
	CComObjectCachedLRU<T>* p = NULL;
	ATLTRY(p = new CComObjectCachedLRU<T>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

class CComObjectCacheByID : public ILRUCache
{
	typedef map<long, IUnknown *> t_mapIdUnk;
	typedef map<IUnknown *, long> t_mapUnkId;
	typedef list<IUnknown *> t_listCache;
public:
	CComObjectCacheByID(long cKeep)
		{
		m_cKeep = cKeep;
		}
	
	void _Lock()
		{
		m_csCached.Lock();
		}
	void _Unlock()
		{
		m_csCached.Unlock();
		}
	
	long Count()
		{
		return m_mapIdUnk.size();
		}
	
	IUnknown * Item(long i)
		{
		t_mapIdUnk::iterator it;
		it = m_mapIdUnk.begin();
		while (i--)
			it++;
		if (it == m_mapIdUnk.end())
			return NULL;
		IUnknown *punk = ((*it).second);

		// If it is in the cache then return NULL
		t_listCache::iterator it2;
		it2 = m_listCache.begin();
		while (it2 != m_listCache.end())
			{
			if (*it2 == punk)
				return NULL;
			it2++;
			}
		
		punk->AddRef();
		return punk;
		}
	
	long CachedCount()
		{
		return m_listCache.size();
		}

	HRESULT Cache(long id, IUnknown *punk)
		{
		HRESULT hr = S_OK;
		Lock();

		// Need the canonical IUnknown
		punk->QueryInterface(__uuidof(IUnknown), (void **) &punk);

		t_mapIdUnk::iterator it = m_mapIdUnk.find(id);
		if (it != m_mapIdUnk.end())
			{
			// If it is already there... just return...

			hr = (punk == ((*it).second)) ? S_FALSE : E_INVALIDARG;

			// ... but don't forget to release the ref count
			// from the above QueryInterface() call.
			punk->Release();
			}
		else
			{
			CComQIPtr<ILRUCachedObject> pobj(punk);

			pobj->put_Cache(this);

			// Just keep one ref count (from QueryInterface() above) for both pointers.
			m_mapIdUnk[id] = punk;
			m_mapUnkId[punk] = id;
			}
		Unlock();

		return hr;
		}
	
	long get_ID(IUnknown *pobj)
		{
		long id = 0;
		Lock();
		CComPtr<IUnknown> punk;
		pobj->QueryInterface(__uuidof(IUnknown), (void **) &punk);
		t_mapUnkId::iterator it = m_mapUnkId.find(punk);
		if (it != m_mapUnkId.end())
			id = (*it).second;
		Unlock();
		return id;
		}
	
	IUnknown * get_Unknown(long idObj)
		{
		CComPtr<IUnknown> punk;
		Lock();
		t_mapIdUnk::iterator it = m_mapIdUnk.find(idObj);
		if (it != m_mapIdUnk.end())
			punk = ((*it).second);
		Unlock();
		return punk.Detach();
		}

	void Uncache(IUnknown *punk)
		{
		Lock();
		t_mapUnkId::iterator it = m_mapUnkId.find(punk);
		if (it != m_mapUnkId.end())
			{
			long idObj = ((*it).second);

			t_mapIdUnk::iterator it2 = m_mapIdUnk.find(idObj);
			if (it2 != m_mapIdUnk.end())
				m_mapIdUnk.erase(it2);

			m_mapUnkId.erase(it);

			RemoveFromCache(punk);

			// Just one Release for both maps because only one ref count is held
			// for all references from the cache.
			punk->Release();
			}
		Unlock();
		}
	
	void Uncache(long idObj)
		{
		Lock();
		t_mapIdUnk::iterator it = m_mapIdUnk.find(idObj);
		if (it != m_mapIdUnk.end())
			{
			IUnknown *punk = ((*it).second);

			t_mapUnkId::iterator it2 = m_mapUnkId.find(punk);
			if (it2 != m_mapUnkId.end())
				m_mapUnkId.erase(it2);

			m_mapIdUnk.erase(it);

			RemoveFromCache(punk);

			// Just one Release for both maps because only one ref count is held
			// for all references from the cache.
			punk->Release();
			}
		Unlock();
		}
	
	void Keep(long cKeep)
		{
		m_cKeep = cKeep;
		if (m_cKeep >= 0)
			{
			long cPurge = m_listCache.size() - m_cKeep;
			while (cPurge-- > 0)
				{
				Uncache(m_listCache.back());
				}
			}
		}
	
	// ILRUCache interface
	
	virtual void Lock()
		{
		_Lock();
		}
	virtual void Unlock()
		{
		_Unlock();
		}
	virtual void AddToCache(IUnknown *punk)
		{
		// if m_cKeep < 0 then keep infinite
		// if m_cKeep == 0 then keep none
		// else keep m_cKeep
		if (m_cKeep == 0)
			{
			// Not keeping any, so just release it.
			Uncache(punk);
			}
		else
			{
			m_listCache.push_front(punk);
			Keep(m_cKeep);
			}
		}
	
	virtual void RemoveFromCache(IUnknown *punk)
		{
		t_listCache::iterator it;
		it = m_listCache.begin();
		while (it != m_listCache.end())
			{
			if (*it == punk)
				{
				m_listCache.erase(it);
				return;
				}
			it++;
			}
		}

protected:

	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
	t_mapIdUnk m_mapIdUnk;
	t_mapUnkId m_mapUnkId;
	t_listCache m_listCache;
	long m_cKeep;
};

#if 0 && defined(_DEBUG)
#define NewComObject(T) _NewComObject<T>(THIS_FILE, __LINE__)
template<class T>
T * _NewComObject(LPCSTR lpszFileName, int nLine)
	{
	T* pT = NULL;
	try
		{
		pT = new(lpszFileName, nLine) CComObject<T>;
		}
	catch (CMemoryException *pe)
		{
		pe->Delete();
		}
	
	return pT;
	}
#define NewComObjectCachedLRU(T) _NewComObjectCachedLRU<T>(THIS_FILE, __LINE__)
template<class T>
T * _NewComObjectCachedLRU(LPCSTR lpszFileName, int nLine)
	{
	CComObjectCachedLRU<T> *pT = NULL;
	try
		{
		pT = new(lpszFileName, nLine) CComObjectCachedLRU<T>();
		}
	catch (CMemoryException *pe)
		{
		pe->Delete();
		}
	
	return pT;
	}
#else
#define NewComObject(T) _NewComObject<T>()
template<class T>
T * _NewComObject()
	{
	CComObject<T> *pT = NULL;
	HRESULT hr = CComObject<T>::CreateInstance(&pT);

	return pT;
	}
#define NewComObjectCachedLRU(T) _NewComObjectCachedLRU<T>()
template<class T>
T * _NewComObjectCachedLRU()
	{
	CComObjectCachedLRU<T> *pT = NULL;
	HRESULT hr = CComObjectCachedLRU<T>::CreateInstance(&pT);
	
	return pT;
	}
#endif

#if 0
#define new DEBUG_NEW
#endif

template<class T> class MemCmpLess // : binary_function<T, T, bool>
{
public:
	bool operator()(const T & _X, const T & _Y) const
		{
		return (memcmp(&_X, &_Y, sizeof(T)) < 0);
		}
};

class BSTRCmpLess // : binary_function<BSTR, BSTR, bool>
{
public:
	bool operator()(const BSTR & _X, const BSTR _Y) const
		{
		return (wcscmp(_X, _Y) < 0);
		}
};

#define TRACE AtlTrace
#define TIMING 0
#include "timing.h"

#include "valid.h"

#include <mstvgs.h>
#include "_GuideStore.h"
#define LIBID_GUIDESTORELib LIBID_MSTVGS	//UNDONE when cpp files that ref this are fixed.

#endif // !defined(AFX_STDAFX_H__B7E9C4D4_B8E5_48DE_A578_B75F8096FB42__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\stdprop.cpp ===
#include "stdafx.h"
#include "guidedb.h"
#include "stdprop.h"


IMetaPropertyType *CStdPropSet::GetMetaPropertyType(long id, const char *szName)
{
	HRESULT hr;

	IMetaPropertyType *pproptype = NULL;

	if (m_ppropset == NULL)
		{
		hr = m_ppropsets->get_ItemWithName(m_bstrName, &m_ppropset);
		if (FAILED(hr))
			{
			hr = m_ppropsets->get_AddNew(m_bstrName, &m_ppropset);
			if (FAILED(hr))
				return NULL;
			}
		}

	CComPtr<IMetaPropertyTypes> pproptypes;
	hr = m_ppropset->get_MetaPropertyTypes(&pproptypes);
	if (FAILED(hr))
		return NULL;

	hr = pproptypes->get_ItemWithID(id, &pproptype);
	if (FAILED(hr))
		{
		_bstr_t bstr(szName);
		_variant_t varNil;

		hr = pproptypes->get_AddNew(id, bstr, &pproptype);
		if (FAILED(hr))
			return NULL;
		}

	return pproptype;
};

IMetaProperty *CStdPropSet::GetMetaProperty(IUnknown *pobj, IMetaPropertyType *pproptype, long lang)
{
	HRESULT hr;

	CComPtr<IMetaProperties> pprops;
	CComPtr<CGuideDB> pdb;
	hr = GetDB(&pdb);
	if (FAILED(hr))
		return NULL;
	hr = pdb->get_MetaPropertiesOf(pobj, &pprops);
	if (FAILED(hr))
		return NULL;

	CComPtr<IMetaProperty> pprop;

	hr = pprops->get_ItemWith(pproptype, lang, &pprop);
	if (FAILED(hr))
		{
		_variant_t varNil;

		hr = pprops->get_AddNew(pproptype, lang, varNil, &pprop);

		if (FAILED(hr))
			return NULL;
		}
	
	return pprop.Detach();
}

HRESULT CStdPropSet::GetMetaPropertyValue(IUnknown *pobj, IMetaPropertyType *pproptype, VARIANT *pvarValue)
{
	CComPtr<IMetaProperty> pprop = GetMetaProperty(pobj, pproptype);

	if (pprop == NULL)
		return E_INVALIDARG;

	return pprop->get_Value(pvarValue);
}

HRESULT CStdPropSet::PutMetaPropertyValue(IUnknown *pobj, IMetaPropertyType *pproptype, VARIANT varValue)
{
	CComPtr<IMetaProperty> pprop = GetMetaProperty(pobj, pproptype);

	if (pprop == NULL)
		return E_INVALIDARG;

	return pprop->put_Value(varValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\util.h ===
// util.h : Utilities

#ifndef __UTIL_H_
#define __UTIL_H_

#define LoadSaveHelpers 0
#define PropBagInStream 1

#if LoadSaveHelpers
BOOL	IsPersistable(IUnknown *pUnk);
HRESULT SaveToStream(IUnknown *punk, IStorage *pstore, TCHAR *szPrefix, int n);
HRESULT LoadFromStream(IStorage *pstore, TCHAR *szPrefix, int n, IUnknown **ppunk);
HRESULT SaveToStorage(IUnknown *punk, IStorage *pstore, TCHAR *szPrefix, int n);
HRESULT LoadFromStorage(IStorage *pstore, TCHAR *szPrefix, int n, IUnknown **ppunk);A
#endif

#if PropBagInStream
HRESULT SaveToPropBagInStream(IPersistPropertyBag *ppersistpropbag, IStream *pstream);
HRESULT LoadFromPropBagInStream(IStream *pstream, IUnknown **ppunk);

class PropertyBag :
	public CComObjectRootEx<CComObjectThreadModel>,
	public IPropertyBag
{
public:
	~PropertyBag();

BEGIN_COM_MAP(PropertyBag)
	COM_INTERFACE_ENTRY(IPropertyBag)
END_COM_MAP()

	HRESULT ReadFromStream(IStream *pstream);
	HRESULT WriteToStream(IStream *pstream);

// IPropertyBag interface
	STDMETHOD(Read)(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
	STDMETHOD(Write)(LPCOLESTR pszPropName, VARIANT *pVar);

protected:
	typedef map<BSTR, VARIANT, BSTRCmpLess> t_map;
	t_map m_mapProps;
	enum {t_Variant, t_PropertyBag, t_NULL, t_Blob};
};
#endif

#endif // __UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\timing.h ===
//
// The CPerfTimer class can be used to time operations to an accuracy of 
// around 1 microsecond.
//

// "#define TIMING 1" to turn Timer macros on.

#undef DeclarePerfTimerOn
#undef DeclarePerfTimerOff
#undef PerfTimerOn_
#undef PerfTimerOff_
#undef PerfTimerResetTotal_
#undef PerfTimerDumpTotal_
#undef PerfTimerReset_
#undef PerfTimerDump_

#undef DeclarePerfTimer
#undef PerfTimerResetTotal
#undef PerfTimerDumpTotal
#undef PerfTimerReset
#undef PerfTimerDump

#if TIMING

// #pragma message(__FILE__ " : warning : PerfTimer macros enabled")

#define DeclarePerfTimerOn(t, sz) CPerfTimer t(sz)
#define DeclarePerfTimerOff(t, sz) CPerfTimer t(sz, FALSE)

#define PerfTimerOn_(perf) perf.On()
#define PerfTimerOff_(perf) perf.Off()
#define PerfTimerResetTotal_(perf) perf.ResetTotal()
#define PerfTimerDumpTotal_(perf,sz) perf.DumpTotal(sz)
#define PerfTimerReset_(perf) perf.Reset()
#define PerfTimerDump_(perf,sz) perf.Dump(sz)


#define DeclarePerfTimer(sz) CPerfTimer perf(sz)
#define PerfTimerResetTotal() PerfTimerResetTotal_(perf)
#define PerfTimerDumpTotal(sz) PerfTimerDumpTotal_(perf, sz)
#define PerfTimerReset() PerfTimerReset_(perf)
#define PerfTimerDump(sz) PerfTimerDump_(perf,sz)

class CPerfTimer
  {
  public:
    CPerfTimer(const char *sz)
        {
        Init(sz, TRUE);
        }

    CPerfTimer(const char *sz, BOOL fEnabled)
        {
        Init(sz, fEnabled);
        }

    void Init(const char *sz, BOOL fEnabled)
        {
        m_sz = sz;
        m_cEnabled = fEnabled ? 1 : 0;
        m_ulTimeStart = 0;
        m_ulTimeTotal = 0;
        QueryPerformanceFrequency((LARGE_INTEGER *)&m_ulFreq);
        }

    void On(void)
        {
        m_cEnabled++;
        }

    void Off()
        {
        m_cEnabled--;
        }

    void ResetTotal(void)
        {
        m_ulTimeTotal = 0;
        }

    void Reset(void)
        {
        QueryPerformanceCounter((LARGE_INTEGER *) &m_ulTimeStart);
        }

    void Dump(const char *sz)
        {
        _int64 ulTime;
        QueryPerformanceCounter((LARGE_INTEGER *) &ulTime);
        ulTime -= m_ulTimeStart;

        m_ulTimeTotal += ulTime;

        DumpTime(sz, ulTime);
        
        Reset();
        }

    void DumpTotal(const char *sz)
        {
        DumpTime(sz, m_ulTimeTotal);
        }
    
    void DumpTime(const char *sz, _int64 ulTime)
        {
        if (m_cEnabled > 0)
            {
            _int64 nSecs = (ulTime / m_ulFreq);
            _int64 nMilliSecs = ((ulTime * 1000L) / m_ulFreq) % 1000;
            _int64 nMicroSecs = ((ulTime * 1000000L) / m_ulFreq) % 1000; 

            TRACE("%s %s: %lu s %lu.%3.3lu ms\n", m_sz, sz,
                (ULONG) nSecs, (ULONG) nMilliSecs, (ULONG) nMicroSecs);
            }
        }

  protected:
    const char * m_sz;
    _int64 m_ulTimeStart;
    _int64 m_ulTimeTotal;
    _int64 m_ulFreq;
    int m_cEnabled;
  };

#else

#define DeclarePerfTimerOn(sz,t)
#define DeclarePerfTimerOff(sz,t)
#define PerfTimerOn_(perf)
#define PerfTimerOff_(perf)
#define PerfTimerResetTotal_(perf)
#define PerfTimerDumpTotal_(perf,sz)
#define PerfTimerReset_(perf)
#define PerfTimerDump_(perf,sz)


#define DeclarePerfTimer(sz)
#define PerfTimerResetTotal()
#define PerfTimerDumpTotal(sz)
#define PerfTimerReset()
#define PerfTimerDump(sz)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\util.cpp ===
// Util.cpp
#include "stdafx.h"
#include "util.h"

#if LoadSaveHelpers
BOOL IsPersistable(IUnknown *punk)			// returns TRUE if object supports one of the supported peristence interfaces
{
	CComQIPtr<IPersistStream> ppersiststream(punk);
	if (ppersiststream == NULL)
		{
		CComQIPtr<IPersistStorage> ppersiststorage(punk);
		if (ppersiststorage == NULL)
			{
			CComQIPtr<IPersistPropertyBag> ppersistpropbag(punk);
			if (ppersistpropbag == NULL)
				return false;
			}
		}

	return true;
}

HRESULT SaveToStream(IUnknown *punk, IStorage *pstore, TCHAR *szPrefix, int n)
{
	HRESULT hr;
	CComQIPtr<IPersistStream> ppersiststream(punk);

	if (ppersiststream == NULL)
		return E_INVALIDARG;

	CComPtr<IStream> pstream;
	const TCHAR szFormat[] = _T("%s Stream %d");
	TCHAR szName[100 +  sizeof(szFormat)/sizeof(TCHAR) + 10];
	if (wcslen(szPrefix) > 100)
		return E_INVALIDARG;
	wsprintf(szName, szFormat, szPrefix, n);

	CComBSTR bstrName(szName);

	hr = pstore->CreateStream(bstrName,
			STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0,&pstream);

	if (SUCCEEDED(hr))
		{
		hr = OleSaveToStream(ppersiststream, pstream);
		}

	return hr;
}

HRESULT LoadFromStream(IStorage *pstore, TCHAR *szPrefix, int n, IUnknown **ppunk)
{
	HRESULT hr;
	CComPtr<IStream> pstream;

	const TCHAR szFormat[] = _T("%s Stream %d");
	TCHAR szName[100 +  sizeof(szFormat)/sizeof(TCHAR) + 10];
	if (wcslen(szPrefix) > 100)
		return E_INVALIDARG;
	wsprintf(szName, szFormat, szPrefix, n);

	CComBSTR bstrName(szName);

	hr = pstore->OpenStream(bstrName, NULL,
			STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pstream);
	if (FAILED(hr))
		return S_FALSE;
	
	hr = OleLoadFromStream(pstream, IID_IUnknown, (void **)ppunk);

	return hr;
}

HRESULT SaveToStorage(IUnknown *punk, IStorage *pstore, TCHAR *szPrefix, int n)
{
	HRESULT hr;
	CComQIPtr<IPersistStorage> ppersiststore(punk);

	if (ppersiststore == NULL)
		return E_INVALIDARG;


	CComPtr<IStorage> pstore2;

	const TCHAR szFormat[] = _T("%s Store %d");
	TCHAR szName[100 +  sizeof(szFormat)/sizeof(TCHAR) + 10];
	if (wcslen(szPrefix) > 100)
		return E_INVALIDARG;
	wsprintf(szName, szFormat, szPrefix, n);

	CComBSTR bstrName(szName);

	hr = pstore->CreateStorage(bstrName,
			STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &pstore2);

	if (SUCCEEDED(hr))
		{
		hr = OleSave(ppersiststore, pstore2, FALSE);
		}

	return hr;
}

HRESULT LoadFromStorage(IStorage *pstore, TCHAR *szPrefix, int n, IUnknown **ppunk)
{
	HRESULT hr;
	CComPtr<IStorage> pstore2;

	const TCHAR szFormat[] = _T("%s Store %d");
	TCHAR szName[100 +  sizeof(szFormat)/sizeof(TCHAR) + 10];
	if (wcslen(szPrefix) > 100)
		return E_INVALIDARG;
	wsprintf(szName, szFormat, szPrefix, n);

	CComBSTR bstrName(szName);

	hr = pstore->OpenStorage(bstrName, NULL,
			STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &pstore2);
	
	if (FAILED(hr))
		return S_FALSE;

	hr = OleLoad(pstore2, IID_IUnknown, NULL, (void **) ppunk);
	CComQIPtr<IPersist> ppersist(*ppunk);
	CLSID clsid;
	hr = ppersist->GetClassID(&clsid);
	
	return hr;
}
#endif

#if PropBagInStream
HRESULT SaveToPropBagInStream(IPersistPropertyBag *ppersistpropbag, IStream *pstream)
{
	HRESULT hr;

	if (ppersistpropbag == NULL)
		return E_INVALIDARG;

	CLSID clsid;

	hr = ppersistpropbag->GetClassID(&clsid);
	if (FAILED(hr))
	    return hr;
	hr = WriteClassStm(pstream, clsid);
	if (FAILED(hr))
	    return hr;

	CComPtr<PropertyBag> ppropbag = NewComObject(PropertyBag);
	if (ppropbag == NULL)
		hr = E_OUTOFMEMORY;

	hr = ppersistpropbag->Save(ppropbag, TRUE, TRUE);

	if (SUCCEEDED(hr))
		hr = ppropbag->WriteToStream(pstream);

	return hr;
}

HRESULT LoadFromPropBagInStream(IStream *pstream, IUnknown **ppunk)
{
	HRESULT hr;
	CComPtr<PropertyBag> ppropbag;

	CLSID clsid;
	ReadClassStm(pstream, &clsid);

	CComPtr<IUnknown> punk;
	
	hr = punk.CoCreateInstance(clsid);
	if (FAILED(hr))
		return hr;

	CComQIPtr<IPersistPropertyBag> ppersistpropbag(punk);
	if (ppersistpropbag == NULL)
		return STG_E_DOCFILECORRUPT;

	ppropbag = NewComObject(PropertyBag);
	if (ppropbag == NULL)
		return E_OUTOFMEMORY;

	ppropbag->ReadFromStream(pstream);

	ppersistpropbag->Load(ppropbag, NULL);

	*ppunk = punk.Detach();
	
	return hr;
}

PropertyBag::~PropertyBag()
{
	for (t_map::iterator iter = m_mapProps.begin(); iter != m_mapProps.end(); iter++)
		{
		BSTR bstrName = (*iter).first;

		if (bstrName != NULL)
			SysFreeString(bstrName);
		
		::VariantClear(&(*iter).second);
		}
}

HRESULT PropertyBag::ReadFromStream(IStream *pstream)
{
	HRESULT hr;
	long lCount;
	ULONG cb = sizeof(lCount);

	hr = pstream->Read(&lCount, cb, &cb);
	if (FAILED(hr))
		return STG_E_DOCFILECORRUPT;

	for (long i=0; i < lCount; i++)
		{
		CComBSTR bstrName;

		bstrName.ReadFromStream(pstream);

		CComVariant varVal;
		char ch;
		cb = sizeof(ch);

		hr = pstream->Read(&ch, cb, &cb);
		if (FAILED(hr))
			return STG_E_DOCFILECORRUPT;
		
		switch (ch)
			{
			case t_NULL:
			    varVal = (IUnknown *) NULL;
			    break;

			case t_Blob:
			    {
			    CComBSTR bstr;
			    bstr.ReadFromStream(pstream);
			    varVal = bstr;
			    varVal.vt = VT_BSTR_BLOB;
			    }
			    break;

			case t_Variant:
			    varVal.ReadFromStream(pstream);
			    break;

			case t_PropertyBag:
			    {
			    varVal.vt = VT_UNKNOWN;
			    hr = LoadFromPropBagInStream(pstream, &varVal.punkVal);
			    }
			    break;
			
			default:
			    return STG_E_DOCFILECORRUPT;
			}


		VARIANT &var = m_mapProps[bstrName.Detach()];
    		::VariantInit(&var);
		varVal.Detach(&var);
		}
	return S_OK;
}

HRESULT PropertyBag::WriteToStream(IStream *pstream)
{
	HRESULT hr;
	long lCount = (long) m_mapProps.size();
	ULONG cb = sizeof(lCount);
	pstream->Write(&lCount, cb, &cb);

	for (t_map::iterator iter = m_mapProps.begin(); iter != m_mapProps.end(); iter++)
		{
		CComBSTR bstrName((*iter).first);

		bstrName.WriteToStream(pstream);

		VARIANT & var = (*iter).second;

		switch (var.vt)
			{
			case VT_BSTR_BLOB:
			    {
			    char ch = t_Blob;
			    cb = sizeof(ch);
			    hr = pstream->Write(&ch, cb, &cb);
			    CComBSTR bstr;
			    bstr.Attach(var.bstrVal);
			    bstr.WriteToStream(pstream);
			    bstr.Detach();
			    }
			    break;

			case VT_UNKNOWN:
			case VT_DISPATCH:
				{
				if (var.punkVal == NULL)
				    {
DoNull:
				    char ch = t_NULL;
				    cb = sizeof(ch);
				    hr = pstream->Write(&ch, cb, &cb);
				    break;
				    }

				CComQIPtr<IPersistStream> ppersiststream(var.punkVal);
				if (ppersiststream != NULL)
					goto defaultCase;

				CComQIPtr<IPersistPropertyBag> ppersistpropbag(var.punkVal);
				if (ppersistpropbag == NULL)
				    goto DoNull;

				char ch = t_PropertyBag;
				cb = sizeof(ch);
				hr = pstream->Write(&ch, cb, &cb);
				hr = SaveToPropBagInStream(ppersistpropbag, pstream);
				if (FAILED(hr))
					return hr;
				}
				break;

defaultCase:
			default:
				{
				char ch = t_Variant;
				cb = sizeof(ch);
				hr = pstream->Write(&ch, cb, &cb);
				CComVariant varT;
				varT.Attach(&var);
				varT.WriteToStream(pstream);
				varT.Detach(&var);
				}
				break;
			}
		}

	return S_OK;
}

STDMETHODIMP PropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog)
{
ENTER_API
	{
	if ((pszPropName == NULL) || (pVar == NULL))
		return E_POINTER;

	CComBSTR bstrName(pszPropName);

	t_map::iterator iter = m_mapProps.find(bstrName);
	if (iter == m_mapProps.end())
		return E_INVALIDARG;

	return ::VariantCopy(pVar, &(*iter).second);
	}
LEAVE_API
}

STDMETHODIMP PropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
ENTER_API
	{
	HRESULT hr;
	if ((pszPropName == NULL) || (pvar == NULL))
		return E_POINTER;

	if ((pvar->vt & ~VT_TYPEMASK) && (pvar->vt != VT_BSTR_BLOB))
		return E_INVALIDARG;

	CComBSTR bstrName(pszPropName);

	VARIANT &var = m_mapProps[bstrName.Detach()];
	::VariantInit(&var);
	hr = ::VariantCopy(&var, pvar);
	return hr;
	}
LEAVE_API
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__A8E7CAA9_70A5_46E9_ABB1_3AC3DC7E1F26__INCLUDED_)
#define AFX_DLLDATAX_H__A8E7CAA9_70A5_46E9_ABB1_3AC3DC7E1F26__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__A8E7CAA9_70A5_46E9_ABB1_3AC3DC7E1F26__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by psisload.rc
//
#define IDS_PROJNAME                    100
#define IDR_TIFLOAD                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\psisload.cpp ===
// psisload.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for psisload.idl by adding the following 
//      files to the Outputs.
//          psisload_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f psisloadps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "bdatif.h"
#include "dlldatax.h"

#include "bdatif_i.c"
#include "TIFLoad.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TIFLoad, CTIFLoad)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_PSISLOADLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\valid.h ===
// Enter and Leave macros for all externally called functions.  Debug version does not
// have try/catch block to make gp faults easier to track down.
//
// Examples:
//
// // This is the standard way to wrap APIs.
// HRESULT API1(...)
// {
// ENTER_API
//     {
//
//     // API code here.
//
//     }
// LEAVE_API
// }
//
// // This is how you would do it if you need more control.
// HRESULT API2(...)
// {
//     STD_MANAGE_STATE
//
//     try
//         {
//
//         // Your code here.
//
//         }
//     catch (CSpecialException *pexcept)
//         {
//         // This is how you would catch an exception that required
//         // special processing (beyond just returning an hresult).
//         }
//
//     // This is the default way to return E_OutOfMemory for CMemoryException
//     DefCatchMemory
//
//     // This is required to catch all other exceptions and return E_FAIL
//     DefCatchAll
// }

#if defined(AFX_MANAGE_STATE)
// Note that we must manage MFC .dll state around each of our public
// entry points via this call to AFX_MANAGE_STATE(AfxGetStaticModuleState())

#define STD_MANAGE_STATE AFX_MANAGE_STATE(AfxGetStaticModuleState());
#else
#define STD_MANAGE_STATE
#endif

#if 0
#define DefCatchMemory \
    catch (CMemoryException *pe) \
		{ \
        pe->Delete(); \
        return E_OUTOFMEMORY; \
		}

#define DefCatchOleException \
    catch (COleException *pe) \
		{ \
		HRESULT hr = pe->m_sc; \
        pe->Delete(); \
        return hr; \
		}

#define DefCatchOleDispatchException \
    catch (COleDispatchException *pe) \
		{ \
		HRESULT hr = pe->m_scError; \
        pe->Delete(); \
        return hr; \
		}
#endif

#define DefCatchHRESULT \
	catch (HRESULT hr) \
		{ \
		return hr; \
		}

#define DefCatchComError \
	catch (_com_error ce) \
		{ \
		return ce.Error(); \
		}

#define DefCatchAll \
    catch (...) \
		{ \
        return E_FAIL; \
		}

#if 0
#define StdCatchMost \
	DefCatchHRESULT \
	DefCatchComError \
	DefCatchMemory \
	DefCatchOleException \
	DefCatchOleDispatchException
#else
#define StdCatchMost \
	DefCatchHRESULT \
	DefCatchComError
#endif

// Don't do DefCatchAll in _DEBUG so unexpected exceptions will fault.
#ifdef _DEBUG
#define StdCatchAll StdCatchMost
#else
#define StdCatchAll \
	StdCatchMost \
	DefCatchAll
#endif

#define ENTER_API \
        STD_MANAGE_STATE \
        try

#define LEAVE_API \
		StdCatchAll \
		return ERROR_SUCCESS;

template <typename X>
inline void ValidateInPtr(X *px)
{
	if ((px == NULL) || IsBadReadPtr(px, sizeof(X)))
		_com_issue_error(E_POINTER);
}

template <typename X>
inline void ValidateInPtr_NULL_OK(X *px)
{
	if (px != NULL)
		ValidateInPtr<X>(px);
}

template <typename X>
inline void _ValidateOut(X *px)
{
	ValidateInPtr<X>(px);
	if (IsBadWritePtr(px, sizeof(X)))
		_com_issue_error(E_POINTER);
}

template <typename X>
inline void ValidateOut(X *px)
{
	_ValidateOut<X>(px);
}

template <typename X>
inline void ValidateOut(X *px, X x)
{
	_ValidateOut<X>(px);
	
	*px = x;
}

template <typename X>
inline void ValidateOutPtr(X **ppx)
{
	ValidateOut<X *>(ppx);

	*ppx = NULL;
}

template <typename X>
inline void ValidateOutPtr(X **ppx, X * px)
{
	ValidateOut<X *>(ppx);
	
	*ppx = px;
}



inline void ValidateOut(VARIANT *pvar)
{
	_ValidateOut<VARIANT>(pvar);

	VariantClear(pvar);
}

inline void ValidateIn(BSTR bstr)
{
	if ((bstr != NULL) && IsBadStringPtrW(bstr, -1))
		_com_issue_error(E_POINTER);
}

inline void ValidateOut(BSTR *pbstr)
{
	_ValidateOut<BSTR>(pbstr);

#if 0
	if (*pbstr != NULL)
		{
		ValidateIn(*pbstr);
		SysFreeString(*pbstr);
		*pbstr = NULL;
		}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__968D3D08_8BB6_4FBF_ADD1_636656AC4529__INCLUDED_)
#define AFX_STDAFX_H__968D3D08_8BB6_4FBF_ADD1_636656AC4529__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "bdatif.h"
#import "mstvgs.tlb" no_namespace raw_interfaces_only

#endif // !defined(AFX_STDAFX_H__968D3D08_8BB6_4FBF_ADD1_636656AC4529__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\channels.h ===
#ifndef _CHANNELS_H_
#define _CHANNELS_H_

#include <fcntl.h>
#include <io.h>
#include <stdio.h>
#if 0
#include <bdaiface.h>
#endif
#include <uuids.h>      
#if 0
#include <tuner.h>      
#else
#pragma warning(disable : 4192)
//#import <tuner.tlb> no_namespace raw_method_prefix("") high_method_prefix("_")
#import <tuner.tlb> no_namespace raw_method_prefix("") raw_interfaces_only
#endif

#define HEADEND_ANTENNA       _T("LOCALBR")

// index of tuning spaces 
enum NETWORK_TYPE 
{
    CABLE           = 0x0001,
    ANTENNA         = 0x0002,
    ATSC            = 0x0003,
    DIGITAL_CABLE   = 0x0004,
    DVB             = 0x0005
};

// gsChannelLineups - The gsChannelLineups class manages the ChannelLineups 
//              collection associated with the Guide Store
//
class gsChannelLineups
{
public:

    gsChannelLineups()
	{
		m_pChannelLineups = NULL;
        m_pProviderIDProp = NULL;
	}
    ~gsChannelLineups(){}

	ULONG  Init(IGuideStorePtr  pGuideStore);

	IChannelLineupPtr AddChannelLineup(_bstr_t bstrLineupName);

	IChannelLineupPtr GetChannelLineup(_bstr_t bstrLineupName);
    
	IChannelLineupsPtr GetChannelLineups(VOID);

    ULONG  RemoveChannelLineup(IChannelLineupPtr pChannelLineupToRemove){};

private:
    IMetaPropertyTypePtr AddProviderIDProp(IMetaPropertySetsPtr pPropSets);
    
	IMetaPropertyTypePtr m_pProviderIDProp;

	IChannelLineupsPtr     m_pChannelLineups;
};


class gsChannelLineup
{
public:

    gsChannelLineup()
	{
		m_pChannelLineup = NULL;
		m_pITuningSpace  = NULL;
	}
    ~gsChannelLineup(){}

	ULONG  Init(IChannelLineupPtr  pChannelLineup, LPCTSTR lpHeadEndName)
	{
	    ULONG   ulRet = ERROR_FAIL;
        int     nNetworkType = -1;

		if (NULL == pChannelLineup || NULL == lpHeadEndName)
		{
            return ERROR_INVALID_PARAMETER;
		}

		m_pChannelLineup = pChannelLineup;

		if ( _tcsstr(lpHeadEndName, HEADEND_ANTENNA) )
		{
            nNetworkType = ANTENNA;
		}
		else
		{
            nNetworkType = CABLE;
		}

		if ( SUCCEEDED(LoadTuningSpace(nNetworkType) ) )
            ulRet = INIT_SUCCEEDED;

		return ulRet;
	}

	IChannelLineupPtr GetChannelLineup(VOID)
	{
        return m_pChannelLineup;
	}

	ITuningSpace* GetTuningSpace(VOID)
	{
        return m_pITuningSpace;
	}

private:
    HRESULT LoadTuningSpace(int nNetworkType);

	// The ChannelLineup interface pointer
	//
	IChannelLineupPtr     m_pChannelLineup;

	// The tuning space assoicated with the lineup
	//
	ITuningSpace*         m_pITuningSpace;
};


// gsChannels - The gsChannels class manages the Channels 
//              collection associated with the Guide Store
//
class gsChannels
{
public:

    gsChannels()
	{
		m_pChannels = NULL;
		m_pchansByKey = NULL;
		m_pServiceIDProp = NULL;

	}
    ~gsChannels(){}

	ULONG  Init(IGuideStorePtr  pGuideStore, IChannelLineupPtr  pChannelLineup);

	IChannelPtr AddChannel(struct IService * pservice,
		             _bstr_t bstrServiceID,
					 _bstr_t bstrName,
					 long index);

	BOOL        DoesChannelExist(_bstr_t bstrChannelName, _bstr_t bstrServiceID);

	IChannelPtr FindChannelMatch(_bstr_t bstrChannelName, _bstr_t bstrServiceID);

    ULONG       RemoveChannel(IChannelPtr pChannelToRemove){};

private:
    IMetaPropertyTypePtr AddServiceIDProp(IMetaPropertySetsPtr pPropSets);

	// Channels Collection interface pointer
	//
	IChannelsPtr     m_pChannels;
	IChannelsPtr     m_pchansByKey;

	// Channel Service ID MetaProperty type pointer
	//
    IMetaPropertyTypePtr m_pServiceIDProp;
};

#endif // _CHANNELS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\errcodes.h ===
#ifndef _ERRCODES_H_
#define _ERRCODES_H_

#define ERROR_INVALID_ARGS     -1

#define INIT_SUCCEEDED         0x0000

// Error codes for Guide Store object and interface initializations
//
#define ERROR_FAIL             0x0001 // General failure getting collections interface
#define ERROR_GUIDESTORE_SETUP 0x0002 // Could not retrieve CLSID/Createinstance failed
#define ERROR_GUIDESTORE_OPEN  0x0004 // Could not open GuideStore


#define UPDATE_SUCCEEDED       0x0000

// Error codes for Processing guide data 
//
#define ERROR_UPDATE           0x0010 // General failure 
#define ERROR_UPDATE_ADD       0x0020 // Could not add to guide store
#define ERROR_UPDATE_OPEN      0x0040 // Could not open a guide store object


#define IMPORT_SUCCEEDED       0x0000

// Error codes from Processing the input
//
#define ERROR_FILE_OPEN        0x0100
#define ERROR_FILE_READ        0x0200
#define ERROR_FILE_MAP         0x0400
#define ERROR_FILE_VIEW        0x0800
#define ERROR_FILE_INPUT       0x1000
#define ERROR_STORE_UPDATE     0x2000


#endif // _ERRCODES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\thread.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// RegExThread.cpp : Implementation of CRegExThread
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "tifload.h"

// --- CBaseThread ----------------------

// when the thread starts, it calls this function. We unwrap the 'this'
//pointer and call ThreadProc.
DWORD WINAPI
CBaseThread::InitialThreadProc(LPVOID pv)
{
    CBaseThread * pThread = (CBaseThread *) pv;

    HRESULT hrCoInit = CBaseThread::CoInitializeHelper(pThread->m_dwCoInitFlags);
    if(FAILED(hrCoInit)) {
        return hrCoInit;
    }


    HRESULT hr = pThread->ThreadProc();

    if(SUCCEEDED(hrCoInit)) {
        CoUninitialize();
    }

    return hr;
}

BOOL
CBaseThread::Create()
{
    DWORD threadid;

    CAutoLock lock(&m_AccessLock);

    if (ThreadExists()) {
	return FALSE;
    }

    m_hThread = CreateThread(
		    NULL,
		    0,
		    CBaseThread::InitialThreadProc,
		    this,
		    0,
		    &threadid);

    if (!m_hThread) {
	return FALSE;
    }

    return TRUE;
}

DWORD
CBaseThread::CallWorker(DWORD dwParam)
{
    // lock access to the worker thread for scope of this object
    CAutoLock lock(&m_AccessLock);

    if (!ThreadExists()) {
		return (DWORD) E_FAIL;
    }

    // set the parameter
    m_dwParam = dwParam;

	m_dwReturnVal = 0;
    // signal the worker thread
    m_EventSend.Set();

    // wait for the completion to be signalled or the thread to terminate
	HANDLE h[2];
	h[0] = m_EventComplete;
	h[1] = m_hThread;
	DWORD rc = WaitForMultipleObjects(2, h, 0, INFINITE);

    // done - this is the thread's return value
    return m_dwReturnVal;
}

// is there a request?
BOOL
CBaseThread::CheckRequest(DWORD * pParam)
{
    if (!m_EventSend.Check()) {
	return FALSE;
    } else {
	if (pParam) {
	    *pParam = m_dwParam;
	}
	return TRUE;
    }
}

HRESULT CBaseThread::CoInitializeHelper(DWORD dwCoInitFlags)
{
    // call CoInitializeEx and tell OLE not to create a window (this
    // thread probably won't dispatch messages and will hang on
    // broadcast msgs o/w).
    //
    // If CoInitEx is not available, threads that don't call CoCreate
    // aren't affected. Threads that do will have to handle the
    // failure. Perhaps we should fall back to CoInitialize and risk
    // hanging?
    //

    // older versions of ole32.dll don't have CoInitializeEx

    HRESULT hr = E_FAIL;
    HINSTANCE hOle = GetModuleHandle(TEXT("ole32.dll"));
    if(hOle)
    {
        typedef HRESULT (STDAPICALLTYPE *PCoInitializeEx)(
            LPVOID pvReserved, DWORD dwCoInit);
        PCoInitializeEx pCoInitializeEx =
            (PCoInitializeEx)(GetProcAddress(hOle, "CoInitializeEx"));
        if(pCoInitializeEx)
        {
            hr = (*pCoInitializeEx)(NULL, dwCoInitFlags);
        }
    }

    return hr;
}


// end of private copy of dshow stuff

DWORD CGSThread::ThreadProc(void) {

    ::SetThreadPriority(::GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);

    HRESULT hr = m_pTIFLoader->InitGS();
    if (FAILED(hr)) {
        return 0;
    }

	for (;;) {
		OP req = GetRequest();
		switch (req) {
		case RETHREAD_DATA_ACQUIRED: {
			hr = DataAcquired();
			break;
		} case RETHREAD_EXIT:
			goto exit_thread;
		};
	};
exit_thread:
	return 0;
}

HRESULT CGSThread::DataAcquired() {
    EventQEntry e;
    while (GetNextEvent(e)) {
        switch(e.ea) {
        case EA_GuideDataAcquired:
            m_pTIFLoader->ExecuteGuideDataAcquired();
            break;
        case EA_ProgramChanged:
            m_pTIFLoader->ExecuteProgramChanged(e.v);
            break;
        case EA_ServiceChanged:
            m_pTIFLoader->ExecuteServiceChanged(e.v);
            break;
        case EA_ScheduleEntryChanged:
            m_pTIFLoader->ExecuteScheduleEntryChanged(e.v);
            break;
        case EA_ProgramDeleted:
            m_pTIFLoader->ExecuteProgramDeleted(e.v);
            break;
        case EA_ServiceDeleted:
            m_pTIFLoader->ExecuteServiceDeleted(e.v);
            break;
        case EA_ScheduleEntryDeleted:
            m_pTIFLoader->ExecuteScheduleDeleted(e.v);
            break;
        }
    }
	return NOERROR;
}
    
// end of file - Thread.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\thread.h ===
/////////////////////////////////////////////////////////////////////////////////////
// GSThread.h : Declaration of the CSystemTuningSpaces
// Copyright (c) Microsoft Corporation 1999.

#ifndef __GSThread_H_
#define __GSThread_H_

#pragma once

#include <queue>

#define EXECUTE_ASSERT(x) x

const int MAX_Q_SIZE = 20;

////////////////////////////////////////////////////////
// this is a private copy of some stuff from dshow's wxutil.h, .cpp.   i just need some of the win32 
// synchronization objects and thread stuff and i don't want to pull in all the rest of the 
// baggage in that file
// i've made some minor changes to CAMThread and renamed it to CBaseThread in order to avoid 
// any problems in the future

#ifndef __THREAD__
// wrapper for whatever critical section we have
class CCritSec {

    // make copy constructor and assignment operator inaccessible

    CCritSec(const CCritSec &refCritSec);
    CCritSec &operator=(const CCritSec &refCritSec);

    CRITICAL_SECTION m_CritSec;

public:
    CCritSec() {
		InitializeCriticalSection(&m_CritSec);
    };

    ~CCritSec() {
		DeleteCriticalSection(&m_CritSec);
    };

    void Lock() {
		EnterCriticalSection(&m_CritSec);
    };

    void Unlock() {
		LeaveCriticalSection(&m_CritSec);
    };
};

// locks a critical section, and unlocks it automatically
// when the lock goes out of scope
class CAutoLock {

    // make copy constructor and assignment operator inaccessible

    CAutoLock(const CAutoLock &refAutoLock);
    CAutoLock &operator=(const CAutoLock &refAutoLock);

protected:
    CCritSec * m_pLock;

public:
    CAutoLock(CCritSec * plock)
    {
        m_pLock = plock;
        m_pLock->Lock();
    };

    ~CAutoLock() {
        m_pLock->Unlock();
    };
};



// wrapper for event objects
class CAMEvent
{

    // make copy constructor and assignment operator inaccessible

    CAMEvent(const CAMEvent &refEvent);
    CAMEvent &operator=(const CAMEvent &refEvent);

protected:
    HANDLE m_hEvent;
public:
    CAMEvent(BOOL fManualReset = FALSE)
	{
		m_hEvent = CreateEvent(NULL, fManualReset, FALSE, NULL);
		_ASSERT(m_hEvent);
	}
    ~CAMEvent()
	{
		if (m_hEvent) {
			EXECUTE_ASSERT(CloseHandle(m_hEvent));
		}
	}

    // Cast to HANDLE - we don't support this as an lvalue
    operator HANDLE () const { return m_hEvent; };

    void Set() {EXECUTE_ASSERT(SetEvent(m_hEvent));};
    BOOL Wait(DWORD dwTimeout = INFINITE) {
	return (WaitForSingleObject(m_hEvent, dwTimeout) == WAIT_OBJECT_0);
    };
    BOOL Check() { return Wait(0); };
    void Reset() { ResetEvent(m_hEvent); };
};

#endif // __WXUTIL__


// support for a worker thread

// simple thread class supports creation of worker thread, synchronization
// and communication. Can be derived to simplify parameter passing
class __declspec(novtable) CBaseThread {

    // make copy constructor and assignment operator inaccessible

    CBaseThread(const CBaseThread &refThread);
    CBaseThread &operator=(const CBaseThread &refThread);

    CAMEvent m_EventComplete;

    DWORD m_dwParam;
    DWORD m_dwReturnVal;
	DWORD m_dwCoInitFlags;

protected:
    CAMEvent m_EventSend;
    HANDLE m_hThread;

    // thread will run this function on startup
    // must be supplied by derived class
    virtual DWORD ThreadProc() = 0;

public:
    CBaseThread(DWORD dwFlags = COINIT_DISABLE_OLE1DDE) :  // standard dshow behavior
		m_EventSend(TRUE),     // must be manual-reset for CheckRequest()
		m_dwCoInitFlags(dwFlags) 
	{
		m_hThread = NULL;
	}

	virtual ~CBaseThread() {
		Close();
	}

    CCritSec m_AccessLock;	// locks access by client threads
    CCritSec m_WorkerLock;	// locks access to shared objects

    // thread initially runs this. param is actually 'this'. function
    // just gets this and calls ThreadProc
    static DWORD WINAPI InitialThreadProc(LPVOID pv);

    // start thread running  - error if already running
    BOOL Create();

    // signal the thread, and block for a response
    //
    DWORD CallWorker(DWORD);

    // accessor thread calls this when done with thread (having told thread
    // to exit)
    void Close() {
        HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0);
        if (hThread) {
            WaitForSingleObject(hThread, INFINITE);
            CloseHandle(hThread);
        }
    };

    // ThreadExists
    // Return TRUE if the thread exists. FALSE otherwise
    BOOL ThreadExists(void) const
    {
        if (m_hThread == 0) {
            return FALSE;
        } else {
            return TRUE;
        }
    }

    // is there a request?
    BOOL CheckRequest(DWORD * pParam);

    // If you want to do WaitForMultipleObjects you'll need to include
    // this handle in your wait list or you won't be responsive
    HANDLE GetRequestHandle() const { return m_EventSend; };

    // Find out what the request was
    DWORD GetRequestParam() const { return m_dwParam; };

    // call CoInitializeEx (COINIT_DISABLE_OLE1DDE) if
    // available. S_FALSE means it's not available.
    static HRESULT CoInitializeHelper(DWORD dwCoInitFlags);
};

////////////////////////////////////////////////////////////////////////////////
// end of copying dshow wxutil.h
///////////////////////////////////////////////////////////////////////////////

class CTIFLoad;

class CGSThread : public CBaseThread {
public:
	typedef enum OP {
		RETHREAD_NOREQUEST,
		RETHREAD_DATA_ACQUIRED,
		RETHREAD_EXIT,
	} OP;

    enum EventAction {
        EA_GuideDataAcquired,
        EA_ProgramChanged,
        EA_ServiceChanged,
        EA_ScheduleEntryChanged,
        EA_ProgramDeleted,
        EA_ServiceDeleted,
        EA_ScheduleEntryDeleted,
    };

    typedef struct EventQEntry {
        EventAction ea;
        _variant_t v;
    } EventQEntry;

    typedef std::queue<EventQEntry> EventQ;
    
private:	
	virtual DWORD ThreadProc(void);

	OP GetRequest() {
        HANDLE h[2];
        h[0] = m_EventSend;
        h[1] = m_EventTerminate;
		for (;;) {
			DWORD rc = MsgWaitForMultipleObjectsEx(2, h, INFINITE, QS_ALLEVENTS, 0);
			if (rc == WAIT_OBJECT_0) {
				m_EventSend.Reset();
				return RETHREAD_DATA_ACQUIRED;
			} else if (rc == WAIT_OBJECT_0 + 1) {
                return RETHREAD_EXIT;
			} else {
				// pump messages so com runs
				MSG msg;
				while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}

		}
	}

    HRESULT DataAcquired();

    bool CGSThread::GetNextEvent(EventQEntry& e) {
	    CAutoLock lock(&m_WorkerLock);
        int temp = m_AcquisitionQ.size();
        if (!temp) {
            return false;
        }
        e = m_AcquisitionQ.front();
        m_AcquisitionQ.pop();
        return true;
    }

    CTIFLoad *m_pTIFLoader;
    EventQ m_AcquisitionQ;
    CAMEvent m_EventTerminate;

public:
	CGSThread(CTIFLoad* pTIF) : 
		CBaseThread(COINIT_APARTMENTTHREADED),
        m_pTIFLoader(pTIF) {
        }
	~CGSThread() {
        m_EventTerminate.Set();
		Close();
	}

    HRESULT CGSThread::Notify(EventAction ea, _variant_t& v) {
        EventQEntry e;
        e.ea = ea;
        e.v = v;
		CAutoLock lock(&m_WorkerLock);
        if (m_AcquisitionQ.size() >= MAX_Q_SIZE) {
            return E_FAIL;
        }
        m_AcquisitionQ.push(e);
        // signal the worker thread
        m_EventSend.Set();

        return NOERROR;
    }

};  // class CGSThread

#endif
// end of file thread.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\tifload.h ===
// TIFLoad.h : Declaration of the CTIFLoad

#ifndef __TIFLOAD_H_
#define __TIFLOAD_H_

#include "resource.h"       // main symbols
#include "thread.h"
#include "bdatif.h"

/////////////////////////////////////////////////////////////////////////////
// CTIFLoad
class ATL_NO_VTABLE CTIFLoad : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CTIFLoad, &CLSID_TIFLoad>,
    public IGuideDataLoader,
    public IGuideDataEvent
{
public:
    CTIFLoad() : 
        m_pUnkMarshaler(NULL),
        m_dwPGDCookie(0),
        m_dwAdviseGuideDataEvents(0),
        m_pGSThread(NULL) {}

    ~CTIFLoad()
        {
        Terminate();
        }

DECLARE_REGISTRY_RESOURCEID(IDR_TIFLOAD)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTIFLoad)
    COM_INTERFACE_ENTRY(IGuideDataLoader)
    COM_INTERFACE_ENTRY(IGuideDataEvent)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
        {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
        }

    void FinalRelease()
        {
        m_pUnkMarshaler.Release();
        }

    CComPtr<IUnknown> m_pUnkMarshaler;

    HRESULT InitGS();

    STDMETHOD(ExecuteGuideDataAcquired)();
    STDMETHOD(ExecuteProgramChanged)(VARIANT varProgramDescriptionID);
    STDMETHOD(ExecuteServiceChanged)(VARIANT varServiceDescriptionID);
    STDMETHOD(ExecuteScheduleEntryChanged)(VARIANT varScheduleEntryDescriptionID);
    STDMETHOD(ExecuteProgramDeleted)(VARIANT varProgramDescriptionID);
    STDMETHOD(ExecuteServiceDeleted)(VARIANT varServiceDescriptionID);
    STDMETHOD(ExecuteScheduleDeleted)(VARIANT varScheduleEntryDescriptionID);

// ITIFLoad
    STDMETHOD(Init)(IGuideData *pgd);
    STDMETHOD(Terminate)();

	HRESULT GetGuideDataProperty(IEnumGuideDataProperties *penumprops, const TCHAR *sz, long idLang, VARIANT *pvar) {
        if (!penumprops) {
            return E_POINTER;
        }
        HRESULT hr = penumprops->Reset();
        if (FAILED(hr)) {
            return E_UNEXPECTED;
        }
        DWORD count;
        USES_CONVERSION;
        CComBSTR bsz(T2COLE(sz));
        CComPtr<IGuideDataProperty> pprop;
		hr = penumprops->Next(1, &pprop, &count);
        while (SUCCEEDED(hr) && hr != S_FALSE) {
            CComBSTR name;
            hr = pprop->get_Name(&name);
            if (SUCCEEDED(hr) && name == bsz) {
				long lang;
				hr = pprop->get_Language(&lang);
				if (SUCCEEDED(hr) && idLang == lang) {
					hr = pprop->get_Value(pvar);
					if (SUCCEEDED(hr)) {
						return NOERROR;
					}
				}
			}
            pprop.Release();
			hr = penumprops->Next(1, &pprop, &count);
        }

		return E_FAIL;
	}
	HRESULT RemoveAllUnreferenced(IUnknown *punk);
	HRESULT LoadServices();
	HRESULT LoadPrograms();
	HRESULT LoadScheduleEntries();
	HRESULT AddService(IEnumGuideDataProperties *penumprops, IService **ppservice);
	HRESULT AddProgram(IEnumGuideDataProperties *penumprops, IProgram **ppprog);
	HRESULT AddScheduleEntry(IEnumGuideDataProperties *penumprops, IScheduleEntry **ppschedentry);
	HRESULT AddObject(IObjects *pobjs, IEnumGuideDataProperties *penumprops,
		IUnknown **ppunk);
	HRESULT PutMetaProperty(IMetaProperties *pprops, IMetaPropertyType *pproptype,
		long idLang, VARIANT varValue);
	HRESULT PutMetaProperty(IUnknown *punk, IMetaPropertyType *pproptype,
		long idLang, VARIANT varValue);
	HRESULT UpdateObject(IUnknown *punk, IEnumGuideDataProperties *penumprops);
	HRESULT UpdateMetaProps(IMetaProperties *pprops, IEnumGuideDataProperties *penumprops);

// IGuideDataEvent
        STDMETHOD(GuideDataAcquired)();
        STDMETHOD(ProgramChanged)(VARIANT varProgramDescriptionID);
        STDMETHOD(ServiceChanged)(VARIANT varServiceDescriptionID);
        STDMETHOD(ScheduleEntryChanged)(VARIANT varScheduleEntryDescriptionID);
        STDMETHOD(ProgramDeleted)(VARIANT varProgramDescriptionID);
        STDMETHOD(ServiceDeleted)(VARIANT varServiceDescriptionID);
        STDMETHOD(ScheduleDeleted)(VARIANT varScheduleEntryDescriptionID);

// ITIFLoad
public:

protected:

    // vars in tif thread context
    DWORD m_dwPGDCookie;  // original IGuideData*
    DWORD m_dwAdviseGuideDataEvents;
    CComPtr<IGlobalInterfaceTable> m_pGIT;
    CComPtr<IConnectionPoint> m_pcp;

    // vars in worker thread context
    CComPtr<IGuideData> m_pgd;
    IGuideStorePtr m_pgs;
    CComPtr<IGuideDataProvider> m_pprovider;
    CComPtr<IMetaPropertySets> m_ppropsets;

    CComPtr<IMetaPropertyType> m_pproptypeID;
    CComPtr<IMetaPropertyType> m_pproptypeVersion;

    CComPtr<IMetaPropertyType> m_pproptypeSchedEntryServiceID;
    CComPtr<IMetaPropertyType> m_pproptypeSchedEntryProgramID;

    CComPtr<IMetaPropertyCondition> m_ppropcondNonBlankSchedEntryServiceID;

    CComPtr<IServices> m_pservices;
    CComPtr<IPrograms> m_pprogs;
    CComPtr<IScheduleEntries> m_pschedentries;
    CComPtr<IChannels> m_pchans;

    CGSThread* m_pGSThread;
};

#endif //__TIFLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\psisload\tifload.cpp ===
// TIFLoad.cpp : Implementation of CTIFLoad
#include "stdafx.h"
#include "TIFLoad.h"

#if DBG==1
#include "_guidestore.h"
#endif

#define ENABLE_TRANSACTIONS 1

const TCHAR *g_szDescriptionID = _T("Description.ID");
const _bstr_t g_bstrDescriptionID(g_szDescriptionID);
const TCHAR *g_szDescriptionVersion = _T("Description.Version");
const _bstr_t g_bstrDescriptionVersion(g_szDescriptionVersion);
const TCHAR *g_szSchedEntryServiceID = _T("ScheduleEntry.ServiceID");
const _bstr_t g_bstrSchedEntryServiceID(g_szSchedEntryServiceID);
const TCHAR *g_szSchedEntryProgramID = _T("ScheduleEntry.ProgramID");
const _bstr_t g_bstrSchedEntryProgramID(g_szSchedEntryProgramID);

const long langNeutral = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

const TCHAR *g_szBlank = _T("");
const _bstr_t g_bstrBlank(g_szBlank);
const _variant_t g_varBlank(g_bstrBlank);

const _bstr_t g_bstrNotEqual("<>");

/////////////////////////////////////////////////////////////////////////////
// CTIFLoad

// called from tif thread
STDMETHODIMP CTIFLoad::Init(IGuideData *pgd) {
    if (!pgd) {
        return E_POINTER;
    }
    if (m_dwPGDCookie || m_pGIT || m_pGSThread) {
        return E_FAIL;  // don't allow ourselves to be init'd twice
                        // if they want to re-init us they can create a new one
    }

    CComQIPtr<IConnectionPointContainer> pcpcontainer(pgd);
    if (pcpcontainer == NULL) {
        return E_UNEXPECTED;
    }
    
    HRESULT hr = pcpcontainer->FindConnectionPoint(IID_IGuideDataEvent, &m_pcp);
    if (FAILED(hr)) {
        return hr;
    }
    
    hr = m_pcp->Advise(GetControllingUnknown(), &m_dwAdviseGuideDataEvents);
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_pGIT->RegisterInterfaceInGlobal(pgd, __uuidof(IGuideData), &m_dwPGDCookie);
    if (FAILED(hr)) {
        return hr;
    }

    m_pGSThread = new CGSThread(this);
    if (!m_pGSThread) {
        return E_OUTOFMEMORY;
    }
	BOOL rc = m_pGSThread->Create();
	if (!rc) {
		return E_FAIL;
	}
    
    return S_OK;
}

// called from tif thread
STDMETHODIMP CTIFLoad::Terminate() {
    if (m_dwAdviseGuideDataEvents) {
        HRESULT hr = m_pcp->Unadvise(m_dwAdviseGuideDataEvents);
        if (FAILED(hr)) {
            return hr;
        }
		m_dwAdviseGuideDataEvents = 0;
    }
    delete m_pGSThread;
    m_pGSThread = NULL;
    if (m_pGIT && m_dwPGDCookie) {
        HRESULT hr = m_pGIT->RevokeInterfaceFromGlobal(m_dwPGDCookie);
        if (FAILED(hr)) {
            return hr;
        }
		m_pGIT.Release();
		m_dwPGDCookie = 0;
    }

    return NOERROR;
}

STDMETHODIMP CTIFLoad::GuideDataAcquired() {   
    _variant_t v;
    m_pGSThread->Notify(CGSThread::EA_GuideDataAcquired, v);
    return S_OK;
}

STDMETHODIMP CTIFLoad::ProgramChanged(VARIANT varProgramDescriptionID) {
    _variant_t v(varProgramDescriptionID);
    m_pGSThread->Notify(CGSThread::EA_ProgramChanged, v);
    return S_OK;
}
STDMETHODIMP CTIFLoad::ServiceChanged(VARIANT varServiceDescriptionID) {
    _variant_t v(varServiceDescriptionID);
    m_pGSThread->Notify(CGSThread::EA_ServiceChanged, v);
    return S_OK;
}
STDMETHODIMP CTIFLoad::ScheduleEntryChanged(VARIANT varScheduleEntryDescriptionID) {
    _variant_t v(varScheduleEntryDescriptionID);
    m_pGSThread->Notify(CGSThread::EA_ScheduleEntryChanged, v);
    return S_OK;
}
STDMETHODIMP CTIFLoad::ProgramDeleted(VARIANT varProgramDescriptionID) {
    _variant_t v(varProgramDescriptionID);
    m_pGSThread->Notify(CGSThread::EA_ProgramDeleted, v);
    return S_OK;
}
STDMETHODIMP CTIFLoad::ServiceDeleted(VARIANT varServiceDescriptionID) {
    _variant_t v(varServiceDescriptionID);
    m_pGSThread->Notify(CGSThread::EA_ServiceDeleted, v);
    return S_OK;
}
STDMETHODIMP CTIFLoad::ScheduleDeleted(VARIANT varScheduleEntryDescriptionID) {
    _variant_t v(varScheduleEntryDescriptionID);
    m_pGSThread->Notify(CGSThread::EA_ScheduleEntryDeleted, v);
    return S_OK;
}

//
// all subsequent functions called from worker thread
//

HRESULT CTIFLoad::InitGS() {

    CComPtr<IGlobalInterfaceTable> pGIT;
    HRESULT hr = pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
    if (FAILED(hr)) {
        return hr;
    }

    hr = pGIT->GetInterfaceFromGlobal(m_dwPGDCookie, __uuidof(IGuideData), reinterpret_cast<LPVOID*>(&m_pgd));
    if (FAILED(hr)) {
        return hr;
    }

    hr = m_pgs.CreateInstance(_uuidof(GuideStore));
    if (FAILED(hr))
	return hr;
    
    hr = m_pgs->Open(g_bstrBlank);
    if (FAILED(hr))
	return hr;

#ifdef ENABLE_TRANSACTIONS
    m_pgs->BeginTrans();
#endif

    CComPtr<IGuideDataProviders> pproviders;
    hr = m_pgs->get_GuideDataProviders(&pproviders);

#if 1
    // Specify who we are to the GuideStore (all data entered will be tagged
    // with as being added by us).
    hr = pproviders->get_AddNew(_bstr_t("TIFLoad"), &m_pprovider);
    hr = m_pgs->putref_ActiveGuideDataProvider(m_pprovider);
#endif
    
    // Hang on to some collections we will use a lot.
    hr = m_pgs->get_Programs(&m_pprogs);
    hr = m_pgs->get_Services(&m_pservices);
    hr = m_pgs->get_ScheduleEntries(&m_pschedentries);

    // Create our channel lineup.
    CComPtr<IChannelLineups> pchanlineups;
    hr = m_pgs->get_ChannelLineups(&pchanlineups);

    CComPtr<IChannelLineup> pchanlineup;
    pchanlineups->get_AddNew(_bstr_t("ATSC"), &pchanlineup); //UNDONE: Lookup first.
    

    hr = m_pgs->get_MetaPropertySets(&m_ppropsets);
    if (FAILED(hr)) {
#ifdef ENABLE_TRANSACTIONS
        m_pgs->RollbackTrans();
#endif
	    return hr;
    }
    
    // The "Description.ID" MetaProperty is used as an index...
    // ... hang onto the collections indexed by that meta property.
    hr = m_ppropsets->get_Lookup(g_bstrDescriptionID, &m_pproptypeID);

    hr = m_ppropsets->get_Lookup(g_bstrDescriptionVersion, &m_pproptypeVersion);

    hr = m_ppropsets->get_Lookup(g_bstrSchedEntryServiceID, &m_pproptypeSchedEntryServiceID);
    hr = m_ppropsets->get_Lookup(g_bstrSchedEntryProgramID, &m_pproptypeSchedEntryProgramID);

	hr = m_pproptypeSchedEntryServiceID->get_Cond(g_bstrNotEqual, langNeutral,
			g_varBlank, &m_ppropcondNonBlankSchedEntryServiceID);

#ifdef ENABLE_TRANSACTIONS
    m_pgs->CommitTrans();
#endif

    return NOERROR;
}

STDMETHODIMP CTIFLoad::ExecuteGuideDataAcquired() {
    LoadServices();
    LoadPrograms();
    LoadScheduleEntries();
        
    return S_OK;
}

HRESULT CTIFLoad::ExecuteProgramChanged(VARIANT varProgramDescriptionID) { 
    LoadPrograms();
    return S_OK; 
}
HRESULT CTIFLoad::ExecuteServiceChanged(VARIANT varServiceDescriptionID) { 
    LoadServices();
    return S_OK; 
}
HRESULT CTIFLoad::ExecuteScheduleEntryChanged(VARIANT varScheduleEntryDescriptionID) { 
    LoadScheduleEntries();
    return S_OK; 
}
HRESULT CTIFLoad::ExecuteProgramDeleted(VARIANT varProgramDescriptionID) { 
    LoadPrograms();
    return S_OK; 
}
HRESULT CTIFLoad::ExecuteServiceDeleted(VARIANT varServiceDescriptionID) { 
    LoadServices();
    return S_OK; 
}
HRESULT CTIFLoad::ExecuteScheduleDeleted(VARIANT varScheduleEntryDescriptionID) { 
    LoadScheduleEntries();
    return S_OK; 
}

HRESULT CTIFLoad::LoadServices() {
    CComPtr<IServices> pservicesByID;

    HRESULT hr = m_pservices->get_ItemsByKey(m_pproptypeID,
	    m_pprovider, langNeutral, VT_BSTR, &pservicesByID);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    CComQIPtr<IEnumTuneRequests> penumtunereq;
    m_pgd->GetServices(&penumtunereq);
    HRESULT hrenum = penumtunereq->Reset();
    if (FAILED(hrenum)) {
        return E_UNEXPECTED;
    }

#ifdef ENABLE_TRANSACTIONS
    m_pgs->BeginTrans();
#endif
    
    hrenum = S_OK;
    DWORD servicecount = 0;
    CComPtr<ITuneRequest> plasttunereq;
    while (SUCCEEDED(hrenum) && hrenum != S_FALSE) {
        DWORD count;
        CComPtr<ITuneRequest> ptunereq;  // we want to save the last tunereq to get a clsid for cleanup at the end 
	    hrenum = penumtunereq->Next(1, &ptunereq, &count);
	    if (SUCCEEDED(hrenum) && hrenum != S_FALSE) {
            plasttunereq = ptunereq;
	        CComPtr<IEnumGuideDataProperties> penumprops;
	        hr = m_pgd->GetServiceProperties(ptunereq, &penumprops);
            if (FAILED(hr)) {
		        continue; //UNDONE: Error?
            }
	        _variant_t varID;
	        hr = GetGuideDataProperty(penumprops, g_szDescriptionID, langNeutral, &varID);
            if (FAILED(hr)) {
		        continue; //UNDONE: Error?
            }
	        CComPtr<IService> pservice;

	        hr = pservicesByID->get_ItemWithKey(varID, &pservice);
            if (SUCCEEDED(hr)) {
		        hr = UpdateObject(pservice, penumprops);
                _ASSERT(hr);
            } else {
		        hr = AddService(penumprops, &pservice);
                _ASSERT(hr);
            }
            if (SUCCEEDED(hr)) {
    	        hr = pservice->putref_TuneRequest(ptunereq);
                _ASSERT(hr);
                if (SUCCEEDED(hr)) {
                    ++servicecount;
                }
            }
	        //UNDONE use the Description.Name property as the name for a channel
	    }
        ptunereq.Release();
        MSG msg;
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
	}

    // clean up all the old tune request that have now been replaced with new ones
	hr = RemoveAllUnreferenced(plasttunereq);
    if (FAILED(hr)) {
		goto Rollback;
    }

    {
	    CComPtr<ITuningSpace> ptuningspace;
	    hr = plasttunereq->get_TuningSpace(&ptuningspace);
	    if (SUCCEEDED(hr) && ptuningspace != NULL) {
		    hr = RemoveAllUnreferenced(ptuningspace);
            if (FAILED(hr)) {
			    goto Rollback;
            }
	    }
	    
        {
            CComPtr<ILocator> plocator;
	        hr = ptuningspace->get_DefaultLocator(&plocator);
	        if (SUCCEEDED(hr) && plocator != NULL) {
		        hr = RemoveAllUnreferenced(plocator);
                if (FAILED(hr)){
			        goto Rollback;
                }
            }
        }
        {
            CComPtr<ILocator> plocator;
	        hr = plasttunereq->get_Locator(&plocator);
	        if (SUCCEEDED(hr) && plocator != NULL) {
		        hr = RemoveAllUnreferenced(plocator);
                if (FAILED(hr)){
			        goto Rollback;
                }
            }
        }
    }

#ifdef ENABLE_TRANSACTIONS
    m_pgs->CommitTrans();
#endif

	{
#ifdef ENABLE_TRANSACTIONS
    m_pgs->BeginTrans();
#endif

	CComPtr<IScheduleEntries> pschedentries;
	hr = m_pschedentries->get_ItemsWithMetaPropertyCond(m_ppropcondNonBlankSchedEntryServiceID,
			&pschedentries);
	if (FAILED(hr))
		goto Rollback;

#if DBG==1
    CComQIPtr<IObjectsPrivate> pobjsP(pschedentries);
    CComBSTR bT;
    hr = pobjsP->get_SQLQuery(&bT);
    if (FAILED(hr)) {
        OutputDebugString(_T("can't get SQL"));
    } else {
        OutputDebugString(bT);
    }
#endif
	
	long cItems;
	hr = pschedentries->get_Count(&cItems);
	if (cItems > 0) {
		pservicesByID->Resync();

		for (long i = 0; i < cItems; i++) {
			CComPtr<IScheduleEntry> pschedentry;
			hr = pschedentries->get_Item(_variant_t(i), &pschedentry);
			if (FAILED(hr))
				break;
			
			CComPtr<IMetaProperties> pprops;
			hr = pschedentry->get_MetaProperties(&pprops);
			if (FAILED(hr))
				break;
			
			CComPtr<IMetaProperty> pprop;
			hr = pprops->get_ItemWith(m_pproptypeSchedEntryServiceID, langNeutral, &pprop);
			if (FAILED(hr))
				break;
			
			_variant_t varVal;

			hr = pprop->get_Value(&varVal);

	        CComPtr<IService> pservice;
			hr = pservicesByID->get_ItemWithKey(varVal, &pservice);
			if (FAILED(hr))
				continue;
			
			hr = pschedentry->putref_Service(pservice);
			if (FAILED(hr))
				continue;
			
#if 0
			pprops->Remove(pprop);
#else
			hr = PutMetaProperty(pschedentry, m_pproptypeSchedEntryServiceID,
					langNeutral, g_varBlank);
#endif
		}
	}
	}

#ifdef ENABLE_TRANSACTIONS
    m_pgs->CommitTrans();
#endif

    return S_OK;

Rollback:
#ifdef ENABLE_TRANSACTIONS
    m_pgs->RollbackTrans();
#endif

	return hr;
}

HRESULT CTIFLoad::LoadPrograms(){
    CComPtr<IPrograms> pprogsByID;

    HRESULT hr = m_pprogs->get_ItemsByKey(m_pproptypeID,
	    m_pprovider, langNeutral, VT_BSTR, &pprogsByID);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    CComPtr<IEnumVARIANT> penumProgs;
    hr = m_pgd->GetGuideProgramIDs(&penumProgs);
    HRESULT hrenum = penumProgs->Reset();
    if (FAILED(hrenum)) {
        return E_UNEXPECTED;
    }

#ifdef ENABLE_TRANSACTIONS
    m_pgs->BeginTrans();
#endif
    
    hrenum = S_OK;
    DWORD programcount = 0;
    while (SUCCEEDED(hrenum) && hrenum != S_FALSE) {
	    _variant_t varProg;
	    unsigned long cItems;

	    hrenum = penumProgs->Next(1, &varProg, &cItems);
	    if (SUCCEEDED(hrenum) && hrenum != S_FALSE) {
	        CComPtr<IEnumGuideDataProperties> penumprops;
	        hr = m_pgd->GetProgramProperties(varProg, &penumprops);
            if (FAILED(hr)) {
		        continue; //UNDONE: Error?
            }
	        _variant_t varID;
	        hr = GetGuideDataProperty(penumprops, g_szDescriptionID, langNeutral, &varID);
            if (FAILED(hr)) {
		        continue; //UNDONE: Error?
            }	        
	        CComPtr<IProgram> pprog;

	        hr = pprogsByID->get_ItemWithKey(varID, &pprog);
            if (SUCCEEDED(hr)) {
		        hr = UpdateObject(pprog, penumprops);
                _ASSERT(hr);
            } else {
		        hr = AddProgram(penumprops, &pprog);
                _ASSERT(hr);
            }
            ++programcount;
	    }
	    MSG msg;
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

#ifdef ENABLE_TRANSACTIONS
    m_pgs->CommitTrans();
#endif

    return S_OK;
}

HRESULT CTIFLoad::LoadScheduleEntries() {
    CComPtr<IServices> pservicesByID;
    HRESULT hr = m_pservices->get_ItemsByKey(m_pproptypeID,
	    m_pprovider, langNeutral, VT_BSTR, &pservicesByID);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    CComPtr<IPrograms> pprogsByID;
    hr = m_pprogs->get_ItemsByKey(m_pproptypeID,
	    m_pprovider, langNeutral, VT_BSTR, &pprogsByID);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    CComPtr<IScheduleEntries> pschedentriesByID;
    hr = m_pschedentries->get_ItemsByKey(m_pproptypeID,
	    m_pprovider, langNeutral, VT_BSTR, &pschedentriesByID);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }
    
    CComPtr<IEnumVARIANT> penumSchedEntries;
    hr = m_pgd->GetScheduleEntryIDs(&penumSchedEntries);
    if (FAILED(hr)) {
        return hr;
    }

    HRESULT hrenum = penumSchedEntries->Reset();
    if (FAILED(hrenum)) {
        return E_UNEXPECTED;
    }

#ifdef ENABLE_TRANSACTIONS
    m_pgs->BeginTrans();
#endif
    
    hrenum = S_OK;
    DWORD entrycount = 0;

    while (SUCCEEDED(hrenum) && hrenum != S_FALSE) {
	    _variant_t varSchedEntry;
	    unsigned long cItems;

	    hrenum = penumSchedEntries->Next(1, &varSchedEntry, &cItems);
	    if (SUCCEEDED(hrenum) && hrenum != S_FALSE) {
	        CComPtr<IEnumGuideDataProperties> penumprops;
	        hr = m_pgd->GetScheduleEntryProperties(varSchedEntry, &penumprops);
            if (FAILED(hr)) {
		        continue; //UNDONE: Error?
            }
	        _variant_t varID;
	        hr = GetGuideDataProperty(penumprops, g_szDescriptionID, langNeutral, &varID);
            if (FAILED(hr)) {
		        continue; //UNDONE: Error?
            }
	        CComPtr<IScheduleEntry> pschedentry;

	        hr = pschedentriesByID->get_ItemWithKey(varID, &pschedentry);
            if (SUCCEEDED(hr)) {
		        hr = UpdateObject(pschedentry, penumprops);
                _ASSERT(hr);
            } else {
		        hr = AddScheduleEntry(penumprops, &pschedentry);
                _ASSERT(hr);
            }
            if (SUCCEEDED(hr)) {
	            _variant_t varServiceID;
	            hr = GetGuideDataProperty(penumprops, g_szSchedEntryServiceID,
		            langNeutral, &varServiceID);
	            CComPtr<IService> pservice;
	            hr = pservicesByID->get_ItemWithKey(varServiceID, &pservice);
                if (SUCCEEDED(hr)) {
					hr = pschedentry->putref_Service(pservice);
					if (FAILED(hr)) {
						continue; //UNDONE: Error?
					}
				}
				else {
                    // probably the EIT has come in before the SDT.
                    // Assume that a service update event will occur soon and the
					// service will be created at that time.
					// For now, just set the ScheduleEntry.ServiceID, and when the
					// service is created, all the corresponding ScheduleEntries will
					// be fixed up.
					hr = PutMetaProperty(pschedentry,
							m_pproptypeSchedEntryServiceID, langNeutral, varServiceID);
					// UNDONE: Error?
                }
	            
	            _variant_t varProgramID;
	            hr = GetGuideDataProperty(penumprops, g_szSchedEntryProgramID,
		            langNeutral, &varProgramID);
                if (FAILED(hr)) {
		            continue; //UNDONE: Error?
                }
	            CComPtr<IProgram> pprog;
	            hr = pprogsByID->get_ItemWithKey(varProgramID, &pprog);
                if (FAILED(hr)) {
                    // note: for atsc/dvb we know that programs and schedule entries both
                    // come from the EIT and since we control the tif we know that 
                    // program notifications happen before schedule entry notifications
                    // if we ever need to support 3rd party tif that does this different 
                    // or a tif with separate programs and sched entries
                    // then we need to add a new program here and assume that a program
                    // update will occur soon.  this is analogous to the service case
                    // above.
		            continue; //UNDONE: Error?
                }
	            hr = pschedentry->putref_Program(pprog);
                if (FAILED(hr)) {
		            continue; //UNDONE: Error?
                }
                ++entrycount;
            }
	    }
        MSG msg;
        while (PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
	}
    // undone: clean up unreferenced progs, services, and aged sched entries here???

#ifdef ENABLE_TRANSACTIONS
    m_pgs->CommitTrans();
#endif

    return S_OK;
}

HRESULT CTIFLoad::AddService(IEnumGuideDataProperties *penumprops, IService **ppservice)
    {
    CComQIPtr<IObjects> pobjs(m_pservices);
    CComPtr<IUnknown> punk;

    HRESULT hr;

    hr = AddObject(pobjs, penumprops, &punk);
    if (FAILED(hr)) {
        return hr;
    }

    return punk->QueryInterface(ppservice);
    }

HRESULT CTIFLoad::AddProgram(IEnumGuideDataProperties *penumprops, IProgram **ppprog)
    {
    CComQIPtr<IObjects> pobjs(m_pprogs);
    CComPtr<IUnknown> punk;

    HRESULT hr;

    hr = AddObject(pobjs, penumprops, &punk);
    if (FAILED(hr)) {
        return hr;
    }

    return punk->QueryInterface(ppprog);
    }

HRESULT CTIFLoad::AddScheduleEntry(IEnumGuideDataProperties *penumprops, IScheduleEntry **ppschedentry)
    {
    CComQIPtr<IObjects> pobjs(m_pschedentries);
    CComPtr<IUnknown> punk;

    HRESULT hr;

    hr = AddObject(pobjs, penumprops, &punk);
    if (FAILED(hr)) {
        return hr;
    }

    return punk->QueryInterface(ppschedentry);
    }

HRESULT CTIFLoad::AddObject(IObjects *pobjs, IEnumGuideDataProperties *penumprops,
	IUnknown **ppunk)
    {
    HRESULT hr;

    hr = pobjs->get_AddNew(ppunk);
    if (FAILED(hr)) {
        return hr;
    }

    return UpdateObject(*ppunk, penumprops);
    }

HRESULT CTIFLoad::UpdateObject(IUnknown *punk, IEnumGuideDataProperties *penumprops)
    {
    HRESULT hr;
    CComPtr<IMetaProperties> pprops;

    hr = m_pgs->get_MetaPropertiesOf(punk, &pprops);
    if (FAILED(hr)) {
        return hr;
    }

    return UpdateMetaProps(pprops, penumprops);
    }

HRESULT CTIFLoad::UpdateMetaProps(IMetaProperties *pprops, IEnumGuideDataProperties *penumprops)
    {
    _variant_t varVersion;
    HRESULT hr;

    if (!penumprops) {
        return E_POINTER;
    }

    _variant_t varCurVersion;
    CComPtr<IMetaProperty> pprop;

    hr = GetGuideDataProperty(penumprops, g_szDescriptionVersion, langNeutral, &varVersion);
    if (SUCCEEDED(hr)) {
		hr = pprops->get_ItemWithTypeProviderLang(m_pproptypeVersion, m_pprovider, langNeutral, &pprop);
		if (SUCCEEDED(hr)) {
			hr = pprop->get_Value(&varCurVersion);
		}
	}
    if (SUCCEEDED(hr) && varCurVersion.vt != VT_EMPTY && varVersion.vt != VT_EMPTY && (varCurVersion == varVersion))
	    return S_OK;
    
    hr = penumprops->Reset();
    while (SUCCEEDED(hr) && hr != S_FALSE) {
		unsigned long cItems;
		CComPtr<IGuideDataProperty> pprop;
		hr = penumprops->Next(1, &pprop, &cItems);
		if (SUCCEEDED(hr) && hr != S_FALSE) {
			_bstr_t bstrPropName;
			_variant_t varValue;
			long idLang;

			BSTR bstrT;
			hr = pprop->get_Name(&bstrT);
			bstrPropName = bstrT;
			hr = pprop->get_Language(&idLang);
			_ASSERT(hr);
			hr = pprop->get_Value(&varValue);
			_ASSERT(hr);

			// The following prop names are handled specially outside this routine.
			if (bstrPropName == g_bstrSchedEntryProgramID) {
    			continue;
			}

			if (bstrPropName == g_bstrSchedEntryServiceID) {
	    		continue;
			}

			CComPtr<IMetaPropertyType> pproptype;

			hr = m_ppropsets->get_Lookup(bstrPropName, &pproptype);
			_ASSERT(hr);
            // undone: what does a failure here mean????

			PutMetaProperty(pprops, pproptype, idLang, varValue);
		}
	}
    
    return S_OK;
    }

HRESULT CTIFLoad::PutMetaProperty(IUnknown *punk, IMetaPropertyType *pproptype,
		long idLang, VARIANT varValue) {
	HRESULT hr;
    CComPtr<IMetaProperties> pprops;

    hr = m_pgs->get_MetaPropertiesOf(punk, &pprops);
    if (FAILED(hr)) {
        return hr;
    }

	return PutMetaProperty(pprops, pproptype, idLang, varValue);
}

HRESULT CTIFLoad::PutMetaProperty(IMetaProperties *pprops, IMetaPropertyType *pproptype,
		long idLang, VARIANT varValue) {
	HRESULT hr;

	CComPtr<IMetaProperty> pmetaprop;
	hr = pprops->get_ItemWith(pproptype, idLang, &pmetaprop);
	if (SUCCEEDED(hr)) {
		_variant_t varT;
		hr = pmetaprop->get_Value(&varT);
		if (FAILED(hr) || varT != varValue) {
			hr = pmetaprop->put_Value(varValue);
		}
	} else {
		hr = pprops->get_AddNew(pproptype, idLang, varValue, &pmetaprop);
	}
	return hr;
}

HRESULT CTIFLoad::RemoveAllUnreferenced(IUnknown *punk) {
    CComQIPtr<IPersist> ppersist(punk);
    CLSID clsid;
	if (ppersist == NULL)
		return E_INVALIDARG;

    HRESULT hr = ppersist->GetClassID(&clsid);
	if (FAILED(hr))
		return hr;

	OLECHAR sz[40];
	hr = StringFromGUID2(clsid, sz, sizeof(sz)/sizeof(OLECHAR));
	if (FAILED(hr))
		return hr;

	_bstr_t bstrClsid(sz);
	CComPtr<IObjects> pobjsAll;
	hr = m_pgs->get_Objects(&pobjsAll);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjsWithType;
	hr = pobjsAll->get_ItemsWithType(bstrClsid, &pobjsWithType);
	if (FAILED(hr))
		return hr;

	CComPtr<IObjects> pobjsToRemove;
	hr = pobjsWithType->UnreferencedItems(&pobjsToRemove);
	if (FAILED(hr))
		return hr;

	return pobjsToRemove->RemoveAll();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\channels.cpp ===
/////////////////////////////////////////////////////////////////////
//
// MODULE: CHANNELS.CPP
//
// PURPOSE: Provides the wrapper methods for the channel lineups
//          and channel collections
//
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "errcodes.h"
#include "channels.h"

#define PROP_CHANNELLINEUP_GUID            "{9531CA1C-1946-4b37-BA67-B35E712B9470}"
#define PROPSET_CHANNELLINEUPS             "TMS Loader: ChannelLineups"
#define CHANNELLINEUP_BASEPROP_ID          1000
#define PROP_CHANNELLINEUP_PROVIDERID      CHANNELLINEUP_BASEPROP_ID + 1
#define PROPNAME_CHANNELLINEUP_PROVIDERID  "ChannelLineup-ProviderID"


#define PROP_CHANNEL_GUID            "{970D11AA-03D9-47e7-A634-70197E093C7C}"
#define PROPSET_CHANNELS             "TMS Loader: Channels"
#define CHANNEL_BASEPROP_ID          2000
#define PROP_CHANNEL_SERVICEID       CHANNEL_BASEPROP_ID + 1
#define PROPNAME_CHANNEL_SERVICEID   "Channel-ServiceID"



        
/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddProviderIDProp
//
//  PARAMETERS: [IN] pPropSets    - GuideStore MetaPropertySets collection
//
//  PURPOSE: Add new ProviderID metaproperty to identify the lineups
//           added by this provider
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IMetaPropertyTypePtr gsChannelLineups::AddProviderIDProp(IMetaPropertySetsPtr pPropSets)
{
	HRESULT          hr              = NOERROR;
	IMetaPropertySetPtr  pChannelPropSet = NULL;
    IMetaPropertyTypePtr pServiceIDProp  = NULL;
    _bstr_t          bstrChannelProp_GUID = PROP_CHANNELLINEUP_GUID;
    _bstr_t          bstrChannelProp_Name = PROPSET_CHANNELLINEUPS;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Add the new service related metaproperty set
	//
    hr = pPropSets->get_AddNew(bstrChannelProp_Name, &pChannelPropSet );

	if (SUCCEEDED(hr) && (NULL != pChannelPropSet))
	{
		// Get the metaproperty types
		//
        IMetaPropertyTypesPtr pChannelPropTypes = pChannelPropSet->GetMetaPropertyTypes();
		
		if (NULL != pChannelPropTypes)
		{
			_bstr_t          bstrServiceIDProp_Name = PROPNAME_CHANNELLINEUP_PROVIDERID;

			// Add the Service ID metaproperty type to the metaproperty types
			//
			hr = pChannelPropTypes->get_AddNew(PROP_CHANNELLINEUP_PROVIDERID, 
						bstrServiceIDProp_Name, 
						&m_pProviderIDProp);

			if (FAILED(hr))
				return NULL;
		}
    }

	return m_pProviderIDProp;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: Init
//
//  PARAMETERS: [IN] pGuideStore    - GuideStore Interface pointer
//
//  PURPOSE: Retrieves the ChannelLineups interface
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG  gsChannelLineups::Init(IGuideStorePtr  pGuideStore)
{
    HRESULT hr    = NOERROR;
	ULONG   ulRet = ERROR_FAIL;

	if (NULL == pGuideStore)
	{
        return ERROR_INVALID_PARAMETER;
	}

	// Get the Channel Lineups Collection
	//
	hr = pGuideStore->get_ChannelLineups(&m_pChannelLineups);

	if(FAILED(hr))
	{
	   TRACE(_T("gsChannelLineups - Init: Failed to get ChannelLineups Collection\n"));
	   ulRet = ERROR_FAIL;
	}
	else if (NULL != m_pChannelLineups)
	{
#ifdef _DEBUG
		if (m_pChannelLineups->Count)
		{
			TRACE(_T("gsChannelLineups - Init: ChannelLineups in Guide Store\n"));
		}
#endif
        ulRet = INIT_SUCCEEDED;
	}

    return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddChannelLineup
//
//  PARAMETERS: [IN] bstrLineupName  - Channel Lineup to add
//
//  PURPOSE: Adds a new Channel Lineup Entry in the ChannelLineups
//           collection
//
//  RETURNS: Valid ChannelLineup interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IChannelLineupPtr gsChannelLineups::AddChannelLineup(_bstr_t bstrLineupName)
{
	ULONG                ulRet = 0;

	if (NULL == m_pChannelLineups)
	{
		return NULL; 
	}

	return m_pChannelLineups->GetAddNew( bstrLineupName );
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: GetChannelLineup
//
//  PARAMETERS: [IN] bstrLineupName - Channel Lineup to Get
//
//  PURPOSE: 
//
//  RETURNS: Valid ChannelLineup interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IChannelLineupPtr gsChannelLineups::GetChannelLineup(_bstr_t bstrLineupName)
{
	ULONG                ulRet = FALSE;
    IChannelLineupPtr    pExistingChannelLineup = NULL;

	if (NULL == m_pChannelLineups)
	{
		return NULL; 
	}

	// TODO: Profile this code
	//
	long lChannelLineupCount = m_pChannelLineups->GetCount ( );

	// Interate through Channel Lineups Collection
	//
	for (long lCount = 0; lCount < lChannelLineupCount; lCount++)
	{
		pExistingChannelLineup = m_pChannelLineups->GetItem(lCount);

		if (NULL != pExistingChannelLineup)
		{
			// Check if there is match
			//
			if ( pExistingChannelLineup->Name == bstrLineupName )
			{
				return pExistingChannelLineup;
			}
		}
	}

	//
	// TODO: Profile this code

	return  NULL; 
}

IChannelLineupsPtr gsChannelLineups::GetChannelLineups(VOID)
{
    return m_pChannelLineups;
}

/////////////////////////////////////////////////////////////////////////
//
//  METHOD: LoadTuningSpace
//
//  PARAMETERS: [IN] nNetworkType - network type value
//
//  PURPOSE: Get the Tuning space corresponding to the network type
//           
//  RETURNS: HRESULT
//
/////////////////////////////////////////////////////////////////////////
//
HRESULT gsChannelLineup::LoadTuningSpace(int nNetworkType)
{
	HRESULT                 hr                      = S_OK;
	ITuningSpaceContainer*  pITuningSpaceContainer  = NULL;

	// Get the tuning space container from the system tuning spaces object
	//
    hr = CoCreateInstance(__uuidof(SystemTuningSpaces), NULL, CLSCTX_INPROC_SERVER, 
            __uuidof(ITuningSpaceContainer), (LPVOID*)(&pITuningSpaceContainer)); //reinterpret_cast<void**>(&pITuningSpaceContainer)); 

	if(SUCCEEDED(hr) && pITuningSpaceContainer) 
	{
		
		_variant_t var(_bstr_t(_T("Cable")) /*nNetworkType*/);
    
		// Get the associated tuning space
		//
		hr = pITuningSpaceContainer->get_Item(var, &m_pITuningSpace);

		if(FAILED(hr) || !m_pITuningSpace)
		{
			TRACE(_T("Unable to retrieve Tuning Space\n"));
		}
	}
	else
	{
		TRACE(_T("Could not CoCreate SystemTuningSpaces object\n"));
	}

	if (NULL != pITuningSpaceContainer)
	    pITuningSpaceContainer->Release();

	return hr;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddServiceIDProp
//
//  PARAMETERS: [IN] pPropSets    - GuideStore MetaPropertySets collection
//
//  PURPOSE: Add new ServiceID metaproperty to uniquely identify the service
//           This property type is used for storing unique service IDs
//           associated with the service reccrds
//
//  RETURNS: Valid property type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IMetaPropertyTypePtr gsChannels::AddServiceIDProp(IMetaPropertySetsPtr pPropSets)
{
	HRESULT          hr              = NOERROR;
	IMetaPropertySetPtr  pChannelPropSet = NULL;
    IMetaPropertyTypePtr pServiceIDProp  = NULL;
    _bstr_t          bstrChannelProp_GUID = PROP_CHANNEL_GUID;
    _bstr_t          bstrChannelProp_Name = PROPSET_CHANNELS;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Add the new service related property set
	//
    hr = pPropSets->get_AddNew(bstrChannelProp_Name, &pChannelPropSet);

	if (SUCCEEDED(hr) && (NULL != pChannelPropSet))
	{
		// Get the property types
		//
        IMetaPropertyTypesPtr pChannelPropTypes = pChannelPropSet->GetMetaPropertyTypes();
		
		if (NULL != pChannelPropTypes)
		{
			_bstr_t          bstrServiceIDProp_Name = PROPNAME_CHANNEL_SERVICEID;

			// Add the Service ID property type to the property types
			//
			hr = pChannelPropTypes->get_AddNew(PROP_CHANNEL_SERVICEID, 
						bstrServiceIDProp_Name, 
						&m_pServiceIDProp);

			if (FAILED(hr))
				return NULL;
		}
    }

	return m_pServiceIDProp;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: Init
//
//  PARAMETERS: [IN] pGuideStore    - GuideStore Interface
//              [IN] pChannelLineup - Parent ChannelLineup
//
//  PURPOSE: Gets the Channel Collection interface
//           Adds the Service ID MetaProperty type
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG  gsChannels::Init(IGuideStorePtr  pGuideStore, IChannelLineupPtr  pChannelLineup)
{
    HRESULT hr    = NOERROR;
	ULONG   ulRet = ERROR_FAIL;

	if (NULL == pChannelLineup)
	{
        return ERROR_INVALID_PARAMETER;
	}

	// Get the Channels Collection
	//
	hr = pChannelLineup->get_Channels(&m_pChannels);

	if(FAILED(hr))
	{
	   TRACE(_T("gsChannels - Init: Failed to get Channels Collection\n"));
	   ulRet = ERROR_FAIL;
	}
	else if(NULL != m_pChannels)
	{
#ifdef _DEBUG
		if (m_pChannels->Count)
		{
			TRACE(_T("gsChannels - Init: Channels in Guide Store\n"));
		}
#endif
		// Add the Service ID proprty type
		//
		AddServiceIDProp(pGuideStore->GetMetaPropertySets ());

		if (NULL != m_pServiceIDProp)
			{
			hr = m_pChannels->get_ItemsByKey(m_pServiceIDProp, NULL, 0, VT_BSTR, &m_pchansByKey);
			if (SUCCEEDED(hr))
				ulRet = INIT_SUCCEEDED;
			}
	}
	return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddChannel
//
//  PARAMETERS: pservice,      - assocaited service interface pointer
//				bstrServiceID  - assocaited service id
//				bstrName       - channel name  
//				index          - position in ordered collection
//
//  PURPOSE: Add new Channel
//
//  RETURNS: Valid Channel interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IChannelPtr gsChannels::AddChannel( struct IService * pservice,
									_bstr_t bstrServiceID,
									_bstr_t bstrName,
									long chanNumber )
{
	ULONG          ulRet = 0;
	IChannelPtr    pChannel = NULL;
	IMetaPropertiesPtr pProps = NULL;

	if ((NULL == m_pChannels) || (NULL == pservice))
	{
		return NULL; 
	}

	// Make a Channel entry in the Channels collection
	//
	long index = -1;  //UNDONE: map chanNumber to index.
	pChannel = m_pChannels->GetAddNewAt( pservice, bstrName, index );

	if (NULL != pChannel)
	{
		pProps = pChannel->GetMetaProperties ( );

		if (pProps != NULL)
		{
			// Add the associated service ID property to the Channel properties
			//
			pProps->GetAddNew(m_pServiceIDProp, 0, bstrServiceID);
		}
	}

	return pChannel;

}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: FindChannelMatch
//
//  PARAMETERS: [IN] bstrChannelName  - Required Channel Name 
//              [IN] bstrServiceID    - Associated Service ID
//
//  PURPOSE: Searches for a particular channel using the name and 
//           associated Service ID 
//
//  RETURNS: Valid Channel interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IChannelPtr gsChannels::FindChannelMatch(_bstr_t bstrChannelName, _bstr_t bstrServiceID)
{
#if 0
    IMetaPropertyConditionPtr pServiceIDEqualCond = NULL;
    IChannelPtr           pChannel            = NULL;
	_bstr_t                bstrOperator        = "=";  

	// Set the search parameters
	//
    pServiceIDEqualCond = m_pServiceIDProp->GetCond(bstrOperator, 0, bstrServiceID);

	if (NULL != pServiceIDEqualCond)
	{
		IObjectsPtr  pChannelsObj      = (IObjectsPtr) m_pChannels;
		IChannelsPtr pMatchingChannels = NULL;

		// Setup the query
		//
        pMatchingChannels = (IChannelsPtr) pChannelsObj->GetItemsWithMetaPropertyCond(pServiceIDEqualCond);

		if (NULL != pMatchingChannels)
		{
			// Perform the search for the matching channel
			//
			long lChannelCount = pMatchingChannels->GetCount ( );

			for (long lCount = 0; lCount < lChannelCount; lCount++)
			{
				pChannel = pMatchingChannels->GetItem(lCount);

				if (NULL != pChannel)
				{
					// Sanity check
					//
					if ( pChannel->Name == bstrChannelName )
					{
						return pChannel;
					}
				}
			}
		}
	}
    return NULL;
#else
	HRESULT hr;
    IChannelPtr pchan;

	_variant_t varKey(bstrServiceID);
	hr = m_pchansByKey->get_ItemWithKey(varKey, &pchan);
	if (FAILED(hr))
		return NULL;
	
	return pchan;
#endif
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: DoesChannelExist
//
//  PARAMETERS: [IN] bstrChannelName  - Required Channel Name 
//              [IN] bstrServiceID    - Associated Service ID
//
//  PURPOSE: Checks for the existence of a particular channel name
//           using the name and associated Service ID 
//
//  RETURNS: TRUE/FALSE
//
/////////////////////////////////////////////////////////////////////////
//
BOOL gsChannels::DoesChannelExist(_bstr_t bstrChannelName, _bstr_t bstrServiceID)
{
	if (NULL == m_pChannels)
	{
		return FALSE; 
	}

	return ( FindChannelMatch(bstrChannelName, bstrServiceID) != NULL ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\guidestore.cpp ===
/////////////////////////////////////////////////////////////////////
//
// MODULE: GUIDESTORE.CPP
//
// PURPOSE: Provides the implementation of the gsGuideStore class
//          which encapsulates the Guide store interface
//          and providers methods to interact with the MS guide store 
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "errcodes.h"
#include "guidestore.h"
#include "services.h"
#include "channels.h"
#include "programs.h"
#include "schedules.h"
#include "wtmsload.h"

#define PROP_GUIDESTORE_GUID            "{0630D56A-CFE7-4ff7-97A9-2640502D9FE1}"
#define PROPSET_GUIDESTORE              "TMS Loader"
#define GUIDESTORE_BASEPROP_ID           500
#define PROP_GUIDESTORE_LASTUPDATE       GUIDESTORE_BASEPROP_ID + 1
#define PROPNAME_GUIDESTORE_LASTUPDATE   "GuideStore-LastUpdate"


        
// Add new LastUpdate metaproperty to Get the date/time guidestore record was updated
//
IMetaPropertyTypePtr AddLastUpdateProp(IMetaPropertySetsPtr pPropSets)
{
	IMetaPropertySetPtr pGuideStorePropSet = NULL;
    IMetaPropertyTypePtr pLastUpdateProp = NULL;
    _bstr_t          bstrGuideStoreProp_GUID = PROP_GUIDESTORE_GUID;
    _bstr_t          bstrGuideStoreProp_Name = PROPSET_GUIDESTORE;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Add the new GuideStore related metaproperty set
	//
    pGuideStorePropSet = pPropSets->GetAddNew(bstrGuideStoreProp_Name);

	if (NULL != pGuideStorePropSet)
	{
		// Get the metaproperty types
		//
        IMetaPropertyTypesPtr pGuideStorePropTypes = pGuideStorePropSet->GetMetaPropertyTypes();
		
		if (NULL != pGuideStorePropTypes)
		{
			_bstr_t          bstrLastUpdateProp_Name = PROPNAME_GUIDESTORE_LASTUPDATE;

			// Add the new GuideStore Lastupdated metaproperty type
			//
			pLastUpdateProp = pGuideStorePropTypes->GetAddNew(PROP_GUIDESTORE_LASTUPDATE, 
						bstrLastUpdateProp_Name);
		}
    }

	return pLastUpdateProp;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: Init
//
//  PARAMETERS: [IN] lpGuideStoreFile - GuideStore Database
//
//  PURPOSE: Retrieves the CLSID for the GuideStore
//           Creates an instance of the GuideStore object
//           Opens the GuideStore using the IGuideStore interface
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG gsGuideStore::Init(LPCTSTR lpGuideStoreFile)
{
	HRESULT hr     = NOERROR;
	_bstr_t gsbstr = lpGuideStoreFile;
    CLSID   CLSID_GuideStore;
	ULONG   ulRet  = 0;

	// Get the CLSID for the GuideStore
	//
	hr= CLSIDFromProgID(OLESTR("GuideStore.GuideStore"), &CLSID_GuideStore);
	if(FAILED(hr))
	{
	   TRACE(_T("gsGuideStore: Retrieval of ProgID failed\n"));
	   return ERROR_GUIDESTORE_SETUP;
	}


	// Createinstance of the Guide Store object
	//
	hr = m_pGuideStore.CreateInstance(CLSID_GuideStore);
	if(FAILED(hr))
	{
	   TRACE(_T("gsGuideStore: CreateInstance failed on GuideStore\n"));
	   return ERROR_GUIDESTORE_SETUP;
	}

	// Open the guide store: use Open 
	//
	hr = m_pGuideStore->Open(gsbstr);

	if(FAILED(hr))
	{
	   TRACE(_T("gsGuideStore: Failed to open Guide Store\n"));
	   return ERROR_GUIDESTORE_OPEN;
	}

	hr = m_pGuideStore->BeginTrans();
#if 0

	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_BELOW_NORMAL);
#endif

	return INIT_SUCCEEDED;
}


// Test interface 
//
ULONG gsGuideStore::VerifyGuideStorePrimaryInterfaces()
{
	IServicesPtr           pServices = NULL;
    IChannelLineupsPtr     pChannelLineups = NULL;
	IProgramsPtr           pPrograms = NULL;
	IScheduleEntriesPtr    pScheduleEntries = NULL;
	IMetaPropertySetsPtr       pPropSets = NULL;
    ULONG                  ulRet = 0;
	HRESULT                hr  = NOERROR;
    long                   bGuideDataAvailable = 0;

    pServices = m_pGuideStore->GetServices();

	if(NULL == pServices)
	{
	   TRACE(_T("VerifyGuideStorePrimaryInterfaces: Failed to get Services Collection\n"));
	   return 1;
	}
    else
	{
		if (pServices->Count)
		{
	        TRACE(_T("VerifyGuideStorePrimaryInterfaces: Services in Guide Store\n"));
		}
    }

    pChannelLineups = m_pGuideStore->GetChannelLineups();

	if(NULL == pChannelLineups)
	{
	   TRACE(_T("VerifyGuideStorePrimaryInterfaces: Failed to get Channel Lineup Collection\n"));
	   return 1;
	}
    else
	{
		if (pChannelLineups->Count)
		{
	        TRACE(_T("VerifyGuideStorePrimaryInterfaces: Lineups in Guide Store\n"));
		}
    }
	
    pPrograms = m_pGuideStore->GetPrograms();

	if(NULL == pPrograms)
	{
	  TRACE(_T("VerifyGuideStorePrimaryInterfaces: Failed to get Programs Collection\n"));
	  return 1;
	}
    else
	{
		if (pPrograms->Count)
		{
	        TRACE(_T("VerifyGuideStorePrimaryInterfaces: Programs in Guide Store\n"));
		}
    }

    pScheduleEntries = m_pGuideStore->GetScheduleEntries();
	if(NULL == pScheduleEntries)
	{
	   TRACE(_T("VerifyGuideStorePrimaryInterfaces: Failed to get Schedule Entries Collection\n"));
	   return 1;
	}
    else
	{
		if (pScheduleEntries->Count)
		{
	        TRACE(_T("VerifyGuideStorePrimaryInterfaces: Schedule Entries in Guide Store\n"));
		}
    }

    pPropSets = m_pGuideStore->GetMetaPropertySets ();

	if(NULL == pPropSets)
	{
	  TRACE(_T("VerifyGuideStorePrimaryInterfaces: Failed to get MetaProperty Sets Collection\n"));
	   return 1;
	}
    else
	{
		if (pPrograms->Count)
		{
	        TRACE(_T("VerifyGuideStorePrimaryInterfaces: MetaProperty Sets in Guide Store\n"));
		}
    }

	return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\guidestore.h ===
#ifndef _GUIDESTORE_H_
#define _GUIDESTORE_H_


class gsGuideStore
{
public:

    gsGuideStore()
	{
		m_pGuideStore = NULL;
	}
	~gsGuideStore()
	{
	if (m_pGuideStore != NULL)
		m_pGuideStore->CommitTrans();
	}

	ULONG Init(LPCTSTR lpGuideStoreFile);

    IGuideStorePtr  GetGuideStorePtr()
	{
        return m_pGuideStore;
	}

    ULONG ImportListings(LPCTSTR lpGuideDataFile){};

	// Test method: ExportListings
	//
	ULONG ExportListings(LPCTSTR lpGuideDataFile){};

	// Test method: VerifyGuideStorePrimaryInterfaces
	//
    ULONG VerifyGuideStorePrimaryInterfaces();

private:
    IGuideStorePtr         m_pGuideStore; 
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\ratings.cpp ===
#include "stdafx.h"



ULONG TestRatings()
{
    ULONG ulRet = 0;



	return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\progschd.h ===
#ifndef _PROGSCHD_H_
#define _PROGSCHD_H_

#define MAX_GENREID_SIZE   10
#define GENRES_PER_EPISODE 6

#define MAX_RATING_SIZE    20
#define DEFAULT_GENRE      "Miscellaneous"

typedef struct SRatingsID
{
   TCHAR szRating[MAX_RATING_SIZE];
   long lRatingID;
} *PSRatingID;

enum MPAARatingID
{
EPGMPAARatings_NO_RATING,
EPGMPAARatings_G,
EPGMPAARatings_PG,
EPGMPAARatings_PG13,
EPGMPAARatings_R,
EPGMPAARatings_NC17,
EPGMPAARatings_X,
EPGMPAARatings_NR,
EPGMPAARatings_Fields
};

enum TVRatingID
{
EPGTVRatings_TVY,
EPGTVRatings_TVY7,
EPGTVRatings_TVY7FV,
EPGTVRatings_TVG,
EPGTVRatings_TVPG,
EPGTVRatings_TV14,
EPGTVRatings_TVMA,
EPGTVRatings_Fields
};

enum MSEpisodeTimeSlotRec
{
EpisodeTimeSlotRec_Title,
EpisodeTimeSlotRec_Rated,
EpisodeTimeSlotRec_MPAARating,
EpisodeTimeSlotRec_Description,
EpisodeTimeSlotRec_Genre1Desc,
EpisodeTimeSlotRec_Genre2Desc,
EpisodeTimeSlotRec_Genre3Desc,
EpisodeTimeSlotRec_Genre4Desc,
EpisodeTimeSlotRec_Genre5Desc,
EpisodeTimeSlotRec_Genre6Desc,
EpisodeTimeSlotRec_Channel,
EpisodeTimeSlotRec_StationNum,
EpisodeTimeSlotRec_StartYYYYMMDD,
EpisodeTimeSlotRec_StartHHMM,
EpisodeTimeSlotRec_Length,
EpisodeTimeSlotRec_ClosedCaption,
EpisodeTimeSlotRec_Stereo,
EpisodeTimeSlotRec_Rerun,
EpisodeTimeSlotRec_PayPerView,
EpisodeTimeSlotRec_TVRating,
EpisodeTimeSlotRec_ProgramID,
EpisodeTimeSlotRec_Fields
};

//typedef map<CString, LONG> MAPRatingsID;

// CRecordProcessor: Derived class for Episode record processing; 
//
class CEpisodeTimeSlotRecordProcessor : public CRecordProcessor
{
public:

    CEpisodeTimeSlotRecordProcessor(int nNumFields, SDataFileFields ssfFieldsInfo[]);
    CEpisodeTimeSlotRecordProcessor();
	~CEpisodeTimeSlotRecordProcessor();

    int      m_Process(LPCTSTR lpData, int nDataSize, int* pBytesProcessed);
	int      m_UpdateDatabase(CRecordMap& cmRecord);
	int      m_GetState();
    int      m_GetError();
	int      m_GetErrorString(CString&);
	long     m_GetEpisodeID(LPCTSTR);

private:

	CMapStringToString  m_TVRatingsMap;
	CMapStringToString  m_MPAARatingsMap;

};


#endif // _PROGSCHD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\progschd.cpp ===
/////////////////////////////////////////////////////////////////////
//
// MODULE: PROGSCHD.CPP
//
// PURPOSE: Provides the implementation of the 
//          CEpisodeTimeSlotRecordProcessor class 
//          These methods parse and collection program and schedule
//          data that is then stored into the GuideStore using the
//          gsPrograms and gsScheduleEntries methods.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "errcodes.h"
#include <Afxtempl.h>
#include <crtdbg.h>
#include <fstream.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include "guidestore.h"
#include "services.h"
#include "channels.h"
#include "programs.h"
#include "schedules.h"
#include "tmsparse.h"
#include "servchan.h"
#include "progschd.h"
#include "wtmsload.h"
#define TIMING 0
#include "..\..\timing.h"

#ifdef _DUMP_LOADER
CString csDiagMil;
extern HANDLE hDiagFile;
extern char szDiagBuff[1024];
int         ChannelCnt = 0;
int         TimeSlotCnt = 0;
extern DWORD dwBytesWritten;
#endif


SRatingsID srMPAARatingIDMap[EPGMPAARatings_Fields] = 
{ 
	{_T("NA"), 0},
	{_T("G"), 2},
	{_T("PG"), 4},
	{_T("PG13"), 6},
	{_T("R"), 8},
	{_T("NC17"), 10},
	{_T("X"), 12},
	{_T("NR"), 14}
};


SRatingsID srTVRatingIDMap[EPGTVRatings_Fields] = 
{ 
	{_T("TVY"), 0},
	{_T("TVY7"), 1},
	{_T("TVY7FV"), 2},
	{_T("TVG"), 3},
	{_T("TVPG"), 4},
	{_T("TV14"), 5},
	{_T("TVMA"), 6}
};

SDataFileFields ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_Fields] = 
{ 
  TRUE, 120,
  TRUE, 1, 
  TRUE, 25,
  TRUE, 255,
  TRUE, 30,
  TRUE, 30,
  TRUE, 30,
  TRUE, 30,
  TRUE, 30,
  TRUE, 30,
  TRUE, 10,
  TRUE, 10,
  TRUE, 8,
  TRUE, 4,
  TRUE, 4,
  TRUE, 1,
  TRUE, 1,
  TRUE, 1,
  TRUE, 1,
  TRUE, 4,
  TRUE, 12
};



// CEpisodeTimeSlotRecordProcessor
//
CEpisodeTimeSlotRecordProcessor::CEpisodeTimeSlotRecordProcessor(int nNumFields, 
												 SDataFileFields ssfFieldsInfo[])
{
    TCHAR ConvBuffer[20] = {0};
    
	m_Init();
	m_pFieldsDesc = ssfFieldsInfo;
	m_nNumFields  = nNumFields;
	m_cmRecordMap.InitHashTable(m_nNumFields, TRUE);
    
	int iRatingsCount = 0;
	for (iRatingsCount=0; iRatingsCount<EPGMPAARatings_Fields; iRatingsCount++)
	{
        m_MPAARatingsMap[srMPAARatingIDMap[iRatingsCount].szRating] = 
			_ltot(srMPAARatingIDMap[iRatingsCount].lRatingID, ConvBuffer, 10); 
	}
	for (iRatingsCount=0; iRatingsCount<EPGTVRatings_Fields; iRatingsCount++)
	{
        m_TVRatingsMap[srTVRatingIDMap[iRatingsCount].szRating] = 
			_ltot(srTVRatingIDMap[iRatingsCount].lRatingID, ConvBuffer, 10); 
	}

}

CEpisodeTimeSlotRecordProcessor::CEpisodeTimeSlotRecordProcessor()
{
    TCHAR ConvBuffer[20] = {0};

    m_Init();
	m_pFieldsDesc = ssfEpisodeTimeSlotFieldInfo;
    m_nNumFields  = EpisodeTimeSlotRec_Fields;
	m_cmRecordMap.InitHashTable(m_nNumFields, TRUE);

	int iRatingsCount = 0;
	for (iRatingsCount=0; iRatingsCount<EPGMPAARatings_Fields; iRatingsCount++)
	{
        m_MPAARatingsMap[srMPAARatingIDMap[iRatingsCount].szRating] = 
			_ltot(srMPAARatingIDMap[iRatingsCount].lRatingID, ConvBuffer, 10); 
	}
	for (iRatingsCount=0; iRatingsCount<EPGTVRatings_Fields; iRatingsCount++)
	{
        m_TVRatingsMap[srTVRatingIDMap[iRatingsCount].szRating] = 
			_ltot(srTVRatingIDMap[iRatingsCount].lRatingID, ConvBuffer, 10); 
	}

}


CEpisodeTimeSlotRecordProcessor::~CEpisodeTimeSlotRecordProcessor()
{
	m_MPAARatingsMap.RemoveAll();
	m_TVRatingsMap.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////
//
//  METHOD: m_Process
//
//  PARAMETERS: [IN] lpData    - Data to be processed
//              [IN] nDataSize - Size of data
//
//  PURPOSE: Processes the Data stream for Channel records
//           Once Channel records have been parsed and
//           prepared for table updation signals end of channel records
//           to the file processor
//
/////////////////////////////////////////////////////////////////////////
//
int CEpisodeTimeSlotRecordProcessor::m_Process(LPCTSTR lpData, int nDataSize, int* pBytesProcessed)
{
    int nFields = 0;
	int nFieldSize = 0;
	int nParsePos = 0;
	int nBytesProcessed = 0;

	// Parameter validation
	//
	if (NULL == lpData || 0 == nDataSize)
	{
        return ERROR_INVALID_ARGS;
	}
    else
	{
		 *pBytesProcessed = 0;

         // Data Integrity Check
         //
         ASSERT( _CrtIsValidPointer((const void *)lpData, nDataSize, FALSE) );
		 
		 {
             // Data is valid - Start processing
			 //
             do
			 {

	 			 if (STATE_RECORD_INCOMPLETE == m_nState)
				 {
				     nFields = m_nCurrField;
					 nFieldSize = m_nCurrFieldSize;
				 }

                 for(;nParsePos < nDataSize; nParsePos++)
				 {
					 DeclarePerfTimer("CEpisodeTimeSlotRecordProcessor");
					 MSG msg;
					 while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
					 {
					 	TranslateMessage(&msg);
						DispatchMessage(&msg);
					 }
					 PerfTimerReset();
                     if (lpData[nParsePos] == EOC)
					 {
						 // End of field
						 //
                         //if (nParsePos > 0 && (lpData[nParsePos-1] != EOC))
						 if (nFieldSize > 0)
						 {
							 // TODO ASSERT(nFields <= StationRec_Fields);
                             
							 m_szValidField[nFieldSize] = '\0';
					         m_cmRecordMap[nFields] =  m_szValidField;
							 nFieldSize = 0;
							 m_nCurrFieldSize = 0;
						 }
						 else
						 {
                             //nFieldDataPos = nParsePos;
							 nFieldSize = 0;
							 m_nCurrFieldSize = 0;
						 }

						 nFields++;        
						 m_nCurrField++;
	 				 }
                     else if (lpData[nParsePos] == EOR)
					 {
						 // End of the record

						 //

#ifdef _DUMP_LOADER
						 TimeSlotCnt++;
						 wsprintf(szDiagBuff, _T("\r\nRec No#%d:\n"), TimeSlotCnt);
						 ::WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
						 for (int nCnt=0; nCnt<EpisodeTimeSlotRec_Fields; nCnt++)
						 {
							m_cmRecordMap.Lookup(nCnt, csDiagMil);
						    wsprintf(szDiagBuff, _T("%s\n"), csDiagMil);
							if (NULL != hDiagFile)
							{
								::WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
							}

						 }
#endif
							                  
						 DeclarePerfTimer("CEpisodeTimeSlotRecordProcessor");
						 PerfTimerReset();
						 if (UPDATE_SUCCEEDED != m_UpdateDatabase(m_cmRecordMap))
						 {
							 if (STATE_RECORD_ERROR == m_nState)
							 {
                                 m_nState = STATE_RECORDS_FAIL;
                                 return m_nState;
							 }
							 else
                                 m_nState = STATE_RECORD_ERROR;
						 }
						 PerfTimerDump("m_UpdateDatabase");

						 m_cmRecordMap.RemoveAll();
						 m_nCurrField = nFields = 0;
						 m_nCurrFieldSize = nFieldSize = 0;
					     continue;
	 				 }
                     else if (lpData[nParsePos] == EOT)
					 {
						 // End of the table
						 //
			             m_nState = STATE_RECORDS_PROCESSED;
						 nParsePos += 2*sizeof(TCHAR);
						 break;
	 				 }
					 else
					 {
						 // Valid field data
						 //
						 m_szValidField[nFieldSize] =  lpData[nParsePos];
                         nFieldSize++;
						 m_nCurrFieldSize++;
					 }
					 PerfTimerDump("for loop");
				 }

			 } while ((nParsePos < nDataSize) && (m_nState != STATE_RECORDS_PROCESSED));


			 *pBytesProcessed = nParsePos;

			 if (m_nState != STATE_RECORDS_PROCESSED)
			 {
				 if (lpData[--nParsePos] == EOR)
				 {
                     // More records
					 //
			         m_nState = STATE_RECORDS_INCOMPLETE;                      
				 }
				 else
				 {
                     // record incomplete
					 //
			         m_nState = STATE_RECORD_INCOMPLETE;                      					 
				 }
                  
			 }
		 }
         
	}
	
	return m_nState;

}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: m_UpdateDatabase
//
//  PARAMETERS: [IN] cmStationRecord  - map containing record fields
//
//  PURPOSE: Updates the GuideStore, adding program entries when necessary
//           Then adds the schedule entry to the schedule entries 
//           collection
//
/////////////////////////////////////////////////////////////////////////
//
int CEpisodeTimeSlotRecordProcessor::m_UpdateDatabase(CRecordMap& cmRecord)
{
	int                       iRet = ERROR_UPDATE;
	CString                   csRerun, csClosed_captioned, csStereo, csPayPerView, csLength;
	CString                   csTitle, csProgramID, csDescription, csRated, csMPAARating;
	CWtmsloadApp*             ctmsLoapApp = (CWtmsloadApp*) AfxGetApp();
	CStatChanRecordProcessor* pStatChan = ctmsLoapApp->m_scrpStatChans;
	long                      lEpisodeID=0, lServiceID=0, lLength=0;
	CString                   csGenre;
    CString                   csTVRating;
	LONG                      lTVRatingID = -1;
	LONG                      lMPAARatingID = -1;
    IProgramPtr               pTMSProgram = NULL;
	IServicePtr               pTMSService = NULL;

	// Lookup the program Title
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_Title, csTitle);
	csTitle = csTitle.Left(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_Title].nWidth);
	csTitle.TrimLeft();
	csTitle.TrimRight();

	// Lookup the program unique Identifier
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_ProgramID, csProgramID);
	csDescription = csDescription.Left(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_ProgramID].nWidth);
	csDescription.TrimLeft();
	csDescription.TrimRight();

	// Lookup the program Description
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_Description, csDescription);
	csDescription = csDescription.Left(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_Description].nWidth);
	csDescription.TrimLeft();
	csDescription.TrimRight();

	// Lookup the program Rating Data: Rated?
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_Rated, csRated);
	csRated.TrimLeft();
	csRated.TrimRight();

	// Lookup the program Rating Data: MPAA Rating
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_MPAARating, csMPAARating);
	csMPAARating.TrimLeft();
	csMPAARating.TrimRight();

	// Lookup the program Rating Data: TV Rating
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_TVRating, csTVRating);
	csTVRating.TrimLeft();
	csTVRating.TrimRight();

	BOOL bRated = _ttoi(csRated);
	
	if (bRated)
	{
		// If this Program has an MPAA rating, it is a movie
		//
		if (!csMPAARating.IsEmpty())
		{
			CString csRatingID;

			// Lookup the Rating ID - metaproperty value
			//
			m_MPAARatingsMap.Lookup(csMPAARating, csRatingID);

			if (!csRatingID.IsEmpty())
			{
			    lMPAARatingID = _ttol(csRatingID);
			}
		}
	}

	if (!csTVRating.IsEmpty())	
	{
		CString csRatingID;

		// Lookup the Rating ID - metaproperty value
		//
		m_TVRatingsMap.Lookup(csTVRating, csRatingID);
		
		if (!csRatingID.IsEmpty())
		{
		    lTVRatingID = _ttol(csRatingID);
		}
	}

	

    // For the moment we're using a dummy copyright date
    //
    DATE             dtCopyrightDate = 0;

	// Find a Match for this program in the Programs Collection
	//
	pTMSProgram = ctmsLoapApp->m_pgsPrograms.FindProgramMatch(
		csTitle.GetBuffer(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_Title].nWidth),
        csProgramID.GetBuffer(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_ProgramID].nWidth));

	if (NULL == pTMSProgram)
	{
		// There is no matching program in the collection - add it
		//
		pTMSProgram = ctmsLoapApp->m_pgsPrograms.AddProgram(
			 csTitle.GetBuffer(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_Title].nWidth),
			 csDescription.GetBuffer(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_Description].nWidth),
			 csProgramID.GetBuffer(ssfEpisodeTimeSlotFieldInfo[EpisodeTimeSlotRec_ProgramID].nWidth),
			 dtCopyrightDate,
			 lTVRatingID,
			 lMPAARatingID);


		if (NULL != pTMSProgram)
		{
			IMetaPropertiesPtr pProgramProps = pTMSProgram->GetMetaProperties();


			if (NULL != pProgramProps)
			{
				// Set the Program Categorization metaproperties
				//
				for (int iGenreCount = EpisodeTimeSlotRec_Genre1Desc;
						 iGenreCount < EpisodeTimeSlotRec_Genre6Desc; iGenreCount++)
				{
					CString csGenre;
					cmRecord.Lookup(iGenreCount, csGenre);
					if (!csGenre.IsEmpty())
					{
						// There is a valid Category to be set for this Program
						// Set the Program Categorization metaproperties
						//
						ctmsLoapApp->m_pgsPrograms.AddProgramCategory(pProgramProps, 
							csGenre.GetBuffer(ssfEpisodeTimeSlotFieldInfo[iGenreCount].nWidth+1));
					}
					else
						break;
				}
			}
		}
		else
			return ERROR_UPDATE_ADD;
	}

	// Lookup the associated Channel Number
	//
	CString csTimeSlotChannelNumStr;
    cmRecord.Lookup(EpisodeTimeSlotRec_Channel, csTimeSlotChannelNumStr);

	// Lookup the associated Station Number
	//
	CString csTimeSlotStationNumStr;
    cmRecord.Lookup(EpisodeTimeSlotRec_StationNum, csTimeSlotStationNumStr);
    
	CString csStatChan = csTimeSlotStationNumStr + _T(",") + csTimeSlotChannelNumStr;

	// Get the corresponding Service ID
	//
	lServiceID = pStatChan->m_GetChannelID(csStatChan);

	// Lookup the rerun field
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_Rerun, csRerun);
	LONG lRerun = _ttol(csRerun);

#ifdef _DUMP_LOADER
	wsprintf(szDiagBuff, _T("Fetching #%d Channel ID for %s : %d\r\n"), TimeSlotCnt, csStatChan, lChannelID);
	if (NULL != hDiagFile)
	{
        ::WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
	}
#endif

	// Lookup the Close Captioned field
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_ClosedCaption, csClosed_captioned);
	LONG lClosed_captioned = _ttol(csClosed_captioned);

	// Lookup the Stereo field
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_Stereo, csStereo);
	LONG lStereo = _ttol(csStereo);

	// Lookup the Pay per view field
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_PayPerView, csPayPerView);
	LONG lPayPerView = _ttol(csPayPerView);

    CString csStartYYYYMMDD, csStartHHMM;	
    IScheduleEntryPtr pScheduleEntry = NULL;

	// Lookup the Schedule Entry Date 
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_StartYYYYMMDD, csStartYYYYMMDD);

	// Lookup the Schedule Entry Time
	//
	cmRecord.Lookup(EpisodeTimeSlotRec_StartHHMM, csStartHHMM);

	int nmin = _ttoi(csStartHHMM.Right(2));
	int nhour = _ttoi(csStartHHMM.Left(2));
	int nmday = _ttoi(csStartYYYYMMDD.Right(2));
	int nwday = 0;
	int nyday = 0;
	int nmon = _ttoi(csStartYYYYMMDD.Mid(4,2));
	int nyear = _ttoi(csStartYYYYMMDD.Left(4));

	cmRecord.Lookup(EpisodeTimeSlotRec_Length, csLength);
	lLength = _ttol(csLength.Left(2))*60 + _ttol(csLength.Right(2));	

	COleDateTime codtStart(nyear, nmon, nmday, nhour, nmin, 0); 
	COleDateTime codtEnd = codtStart + COleDateTimeSpan(0, 0, lLength, 0);
	// This recalulation is necessary to eliminate the unseen fractional
	// second that messes up datetime comparisons.  We only have to do 
	// it for this one because this is calculated with the DateTimeSpan.
	codtEnd.SetDateTime(codtEnd.GetYear(), codtEnd.GetMonth(), 
								codtEnd.GetDay(), codtEnd.GetHour(), codtEnd.GetMinute(), 0);

	pTMSService = ctmsLoapApp->m_pgsServices.GetService(lServiceID);

	if ( NULL != pTMSService
		 && NULL != pTMSProgram)
	{
		// Add the new schdule entry
		//
		pScheduleEntry = ctmsLoapApp->m_pgsScheduleEntries.AddScheduleEntry(codtStart,
							codtEnd,
							COleDateTime::GetCurrentTime() + ctmsLoapApp->m_odtsTimeZoneAdjust, 
							lRerun,
							lClosed_captioned,
							lStereo,
							lPayPerView,
							pTMSService,
							pTMSProgram);
	}


   
	if (NULL != pScheduleEntry)
	{
#ifdef _DUMP_LOADER
		wsprintf(szDiagBuff, _T("Failure: Updating #%d TimeSlot ID Title: %s : %d\r\n"), TimeSlotCnt, csTitle);
		if (NULL != hDiagFile)
		{
			::WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
		}
#endif
        // Update the Guide Start time
		//
		if (COleDateTime::invalid == ctmsLoapApp->m_codtGuideStartTime.GetStatus() 
			|| codtStart < ctmsLoapApp->m_codtGuideStartTime)
			ctmsLoapApp->m_codtGuideStartTime = codtStart;

        // Update the Guide End time
		//
		if (COleDateTime::invalid == ctmsLoapApp->m_codtGuideEndTime.GetStatus() 
			|| codtEnd > ctmsLoapApp->m_codtGuideEndTime)
			ctmsLoapApp->m_codtGuideEndTime = codtEnd;

        iRet = UPDATE_SUCCEEDED;	     
	}

	return iRet;
}

int CEpisodeTimeSlotRecordProcessor::m_GetState()
{
	return m_nState;
}

int CEpisodeTimeSlotRecordProcessor::m_GetError()
{
	return m_nError;
}

int CEpisodeTimeSlotRecordProcessor::m_GetErrorString(CString& csErrStr)
{
	if (m_nError)
	{
		// If there is an error to return 
		//
        return csErrStr.LoadString(m_nError);

	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\programs.cpp ===
/////////////////////////////////////////////////////////////////////
//
// MODULE: PROGRAMS.CPP
//
// PURPOSE: Provides the implementation of the gsPrograms class 
//          methods for efficient access to the programs collection
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "errcodes.h"
#include "programs.h"

#define PROP_PROGRAM_GUID            "{92AD4D25-8BF5-422b-8532-C545CE425A96}"
#define PROPSET_PROGRAMS             "TMS Loader: Programs"
#define PROGRAM_BASEPROP_ID          3000
#define PROP_PROGRAM_PROGRAMID       PROGRAM_BASEPROP_ID + 1
#define PROPNAME_PROGRAM_PROGRAMID   "Program-ID"

TCHAR TMS_Genre_Set[NO_OF_GENRES][31] =
{
_T("Miscellaneous"), //for any genres not covered below
_T("Action"),
_T("Adults only"),
_T("Adventure"),
_T("Animals"),
_T("Animated"),
_T("Animated Musical"),
_T("Anthology"),
_T("Art"),
_T("Auto"),
_T("Awards"),
_T("Ballet"),
_T("Baseball"),
_T("Basketball"),
_T("Beauty"),
_T("Bicycle"),
_T("Billiards"),
_T("Biography"),
_T("Boat"),
_T("Bodybuilding"),
_T("Bowling"),
_T("Boxing"),
_T("Bus./Financial"),
_T("Bus./Financial Special"),
_T("Bus./Financial Talk"),
_T("Business"),
_T("Children"),
_T("Children Special"),
_T("Children Talk"),
_T("Childrens Music"),
_T("Classic"),
_T("Collectibles"),
_T("Comedy"),
_T("Comedy-drama"),
_T("Computers"),
_T("Cooking"),
_T("Crime"),
_T("Crime drama"),
_T("Curling"),
_T("Dance"),
_T("Diving"),
_T("Docudrama"),
_T("Documentary"),
_T("Drama"),
_T("Educational"),
_T("Electronics"),
_T("Event"),
_T("Exercise"),
_T("Family"),
_T("Fantasy"),
_T("Fashion"),
_T("Fiction"),
_T("Fishing"),
_T("Football"),
_T("French"),
_T("Fundraiser"),
_T("Game"),
_T("Golf"),
_T("Gymnastics"),
_T("Health"),
_T("Historical"),
_T("Historical drama"),
_T("Hockey"),
_T("Holiday"),
_T("Holiday Children"),
_T("Holiday Childrens Special"),
_T("Holiday Music"),
_T("Holiday Music Special"),
_T("Holiday Special"),
_T("Horror"),
_T("Horse"),
_T("House/Garden"),
_T("Housewares"),
_T("How-to"),
_T("International"),
_T("Interview"),
_T("Jewelery"),
_T("Lacrosse"),
_T("Magazine"),
_T("Martial arts"),
_T("Medical"),
_T("Miniseries"),
_T("Motor"),
_T("Motorcycle"),
_T("Music"),
_T("Music Special"),
_T("Music Talk"),
_T("Musical"),
_T("Musical Comedy"),
_T("Musical Romance"),
_T("Mystery"),
_T("Nature"),
_T("News"),
_T("Non Event"),
_T("Olympics"),
_T("Opera"),
_T("Outdoors"),
_T("Parental Advisory"),
_T("Play"),
_T("Public Affairs"),
_T("Racing"),
_T("Racquet"),
_T("Reality"),
_T("Religious"),
_T("Rodeo"),
_T("Romance"),
_T("Romance-comedy"),
_T("Rugby"),
_T("Running"),
_T("Satire"),
_T("Science"),
_T("Science fiction"),
_T("Self-help"),
_T("Shopping"),
_T("Situation"),
_T("Skating"),
_T("Skiing"),
_T("Sled Dogs"),
_T("Snow"),
_T("Soap"),
_T("Soap Opera"),
_T("Soap Special"),
_T("Soccer"),
_T("Softball"),
_T("Spanish"),
_T("Special"),
_T("Sports"),
_T("Sports Event"),
_T("Sports Talk"),
_T("Sports, Non-Event"),
_T("Suspense"),
_T("Suspense-comedy"),
_T("Swimming"),
_T("Talk"),
_T("Tennis"),
_T("Thriller"),
_T("Track/Field"),
_T("Travel"),
_T("Variety"),
_T("Volleyball"),
_T("War"),
_T("Water"),
_T("Weather"),
_T("Western"),
_T("Western comedy"),
_T("Wrestling")
};


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddProgramIDProp
//
//  PARAMETERS: [IN] pPropSets    - GuideStore MetaPropertySets collection
//
//  PURPOSE: Adds the Program ID metaproperty type to the types collection
//           This metaproperty type is used for storing unique program IDs
//           associated with the program reccrds
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IMetaPropertyTypePtr gsPrograms::AddProgramIDProp(IMetaPropertySetsPtr pPropSets)
{
	HRESULT          hr              = NOERROR;
	IMetaPropertySetPtr  pProgramPropSet = NULL;
    _bstr_t          bstrProgramProp_GUID = PROP_PROGRAM_GUID;
    _bstr_t          bstrProgramProp_Name = PROPSET_PROGRAMS;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Add the new service related metaproperty set
	//
    hr = pPropSets->get_AddNew(bstrProgramProp_Name, &pProgramPropSet);

	if (SUCCEEDED(hr) && (NULL != pProgramPropSet))
	{
		// Get the metaproperty types
		//
        IMetaPropertyTypesPtr pProgramPropTypes = pProgramPropSet->GetMetaPropertyTypes();
		
		if (NULL != pProgramPropTypes)
		{
			_bstr_t  bstrProgramIDProp_Name = PROPNAME_PROGRAM_PROGRAMID;

			// Add the program ID metaproperty type
			//
			hr = pProgramPropTypes->get_AddNew(PROP_PROGRAM_PROGRAMID, 
						bstrProgramIDProp_Name, 
						&m_pProgramIDProp);

			if (FAILED(hr))
				return NULL;
		}
    }

	return m_pProgramIDProp;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddTMSCategories
//
//  PARAMETERS: [IN] pPropSets    - GuideStore MetaPropertySets collection
//
//  PURPOSE: Adds the Program category types to the types collection
//           These are currently added to the standard Categories 
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IMetaPropertyTypesPtr gsPrograms::AddTMSCategories(IMetaPropertySetsPtr pPropSets)
{
	HRESULT           hrCat              = NOERROR;
	IMetaPropertySetPtr   pCategoriesPropSet = NULL;
    IMetaPropertyTypesPtr pCategoriesTypes = NULL;
    BOOL              bCatSet          = FALSE;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Get the metaproperty sets interface for Categories
	//
	_bstr_t bstrName = "Categories";
	pCategoriesPropSet = pPropSets->GetItemWithName(bstrName);

	if (NULL != pCategoriesPropSet)
	{
		pCategoriesTypes = pCategoriesPropSet->GetMetaPropertyTypes();

		if (NULL != pCategoriesTypes)
		{
			for (int iCatCount = 0; iCatCount < NO_OF_GENRES; iCatCount++)
			{
				_bstr_t bstrCategory = TMS_Genre_Set[iCatCount];

				struct IMetaPropertyType * pCategory = NULL;

				// Get the metaproperty type interface pointer for this category
				//
				HRESULT _hr = pCategoriesTypes->get_ItemWithName(bstrCategory, &pCategory);

				if (FAILED(_hr)) 
				{
					// This category does not exist so add it
					//
					hrCat = pCategoriesTypes->get_AddNew(PROP_TMSCATEGORY_STARTID+iCatCount, 
									bstrCategory, 
									&pCategory);
				}

				if (SUCCEEDED(hrCat) && (NULL != pCategory))
				{
					// Store the category pointer in the map for later use
					//
					m_CategoryMap[TMS_Genre_Set[iCatCount]] = pCategory;
				}
				else
					return NULL;
			}
		}
	}
	return pCategoriesTypes;
}

/////////////////////////////////////////////////////////////////////////
//
//  METHOD: Init
//
//  PARAMETERS: [IN] pGuideStore - GuideStore interface
//
//  PURPOSE: Initializes the guide store Programs collection
//           Ensures that all the metaproperty types needed by
//           the Program entry viz. 
//           1. Standard ratings type
//           2. MPAA Ratings type
//           3. Program ID type
//           4. Required Category types
//           are available
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
ULONG  gsPrograms::Init(IGuideStorePtr  pGuideStore)
{
    HRESULT hr    = NOERROR;
	ULONG   ulRet = ERROR_FAIL;

	if (NULL == pGuideStore)
	{
        return ERROR_INVALID_PARAMETER;
	}

	// Get the Programs interface for the Guide Store
	//
	hr = pGuideStore->get_Programs(&m_pPrograms);

	if (FAILED(hr))
	{
	   TRACE(_T("gsPrograms - Init: Failed to get Programs Collection\n"));
	   ulRet = ERROR_FAIL;
	}
	else if (NULL != m_pPrograms)
	{
#ifdef _DEBUG
		if (m_pPrograms->Count)
		{
			TRACE(_T("gsPrograms - Init: Programs in Guide Store\n"));
		}
#endif
        IMetaPropertySetsPtr pPropSets = pGuideStore->GetMetaPropertySets();                 

		if (NULL != pPropSets)
		{
			_bstr_t bstrName = "Ratings";

			// Get the Standard ratings metaproperty set
			//
			IMetaPropertySetPtr pStdRatingPropSet = pPropSets->GetItemWithName(bstrName);

			if (NULL != pStdRatingPropSet)
			{
				 IMetaPropertyTypesPtr pStdRatingTypes = pStdRatingPropSet->GetMetaPropertyTypes();

				 if (NULL != pStdRatingTypes)
				 {
					 _bstr_t bstrRatingType = STDRATING_MINAGE;

					 // Get the Minimum Age metaproperty type
					 //
					 m_pTVRatingProp = pStdRatingTypes->GetItemWithName(bstrRatingType);
				 }
			}


			bstrName = "MPAA Ratings";

			// Get the MPAA ratings metaproperty set
			//
			IMetaPropertySetPtr pMPAARatingPropSet = pPropSets->GetItemWithName(bstrName);

			if (NULL != pMPAARatingPropSet)
			{
				 IMetaPropertyTypesPtr pMPAARatingTypes = pMPAARatingPropSet->GetMetaPropertyTypes();

				 if (NULL != pMPAARatingTypes)
				 {
					 _bstr_t bstrRatingType = MPAARATING_RATING;

					 // Get the MPAA Ratings metaproperty type
					 //
					 m_pMPAARatingProp = pMPAARatingTypes->GetItemWithName(bstrRatingType);
				 }
			}

			// Add the Program ID metaproperty type
			//
			AddProgramIDProp(pPropSets);

			if (m_pProgramIDProp != NULL)
				{
				m_pPrograms->get_ItemsByKey(m_pProgramIDProp, NULL, 0, VT_BSTR, &m_pprogsByKey);
				}

			// Add the TMS categories' metaproperty types
			//
            IMetaPropertyTypesPtr pProgPropTypes = AddTMSCategories(pPropSets);

			if (NULL != m_pTVRatingProp && NULL != m_pMPAARatingProp
				&& NULL != m_pProgramIDProp && NULL != pProgPropTypes
				&& m_pprogsByKey != NULL)
					ulRet = INIT_SUCCEEDED;
		}
	}
	return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddProgram
//
//  PARAMETERS: [IN] bstrTitle       - Program Title
//				[IN] bstrDescription - Program Title
//				[IN] bstrProgramID   - Program ID
//				[IN] dtCopyrightDate - Copyright Date
//				[IN] lMinAgeRating   - Min Age Rating
//				[IN] lMPAARating     - MPAA Rating
//
//  PURPOSE: Creates a new Program entry and adds it to the program's 
//           collection
//
//  RETURNS: Valid program interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IProgramPtr gsPrograms::AddProgram( _bstr_t bstrTitle,
									_bstr_t bstrDescription,
									_bstr_t bstrProgramID,
									DATE    dtCopyrightDate,
									long    lMinAgeRating,
									long    lMPAARating )
{
	ULONG           ulRet = 0;
	IProgramPtr     pProgram = NULL;
    IMetaPropertiesPtr  pProgProps = NULL;

	if (NULL == m_pPrograms)
	{
		return NULL; 
	}

	pProgram = m_pPrograms->GetAddNew();

	if (NULL != pProgram)
	{
		// Save the Program Title 
		//
		pProgram->PutTitle(bstrTitle);

		// Save the Program Description
		//
		if (0 != bstrDescription.length())
			pProgram->put_Description(bstrDescription);

		// Save the Program CopyrightDate
		//
		if (INVALID_DATE != dtCopyrightDate)
			pProgram->PutCopyrightDate(dtCopyrightDate);

		pProgProps = pProgram->GetMetaProperties ( );

		if (pProgProps != NULL)
		{
			// Add the Program ID
			//
			pProgProps->GetAddNew(m_pProgramIDProp, 0, bstrProgramID);
            m_bstrCachedProgramID = bstrProgramID;
			m_bstrCachedProgramPtr = pProgram;

			// Add the TV Rating Prop Value
			//
			if (INVALID_MINAGE != lMinAgeRating)
				pProgProps->GetAddNew(m_pTVRatingProp, 0, lMinAgeRating);

			// Add the MPAA Rating Prop Value
			//
			if (INVALID_MPAARATING != lMPAARating)
				pProgProps->GetAddNew(m_pMPAARatingProp, 0, lMPAARating);
		}

	}

	return pProgram;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddProgramCategory
//
//  PARAMETERS: [IN] pProgramProps - Program's metaproperties collection
//              [IN] lpCategory    - Category
//
//  PURPOSE: Adds the Program category to program's metaproperties
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG  gsPrograms::AddProgramCategory(IMetaPropertiesPtr pProgramProps, LPTSTR lpCategory)
{
	void* pCategory = NULL;
	
	if (NULL != pProgramProps)
	{
		// Lookup the category in the category map
		//
		m_CategoryMap.Lookup(lpCategory, pCategory);
		if (NULL != pCategory)
		{
			  // This is a known category - add the prop value
			  //
			  pProgramProps->GetAddNew((struct IMetaPropertyType *) pCategory, 0, (long) 1);   
		}
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: FindProgramMatch
//
//  PARAMETERS: [IN] bstrProgramTitle   - Program Title
//				[IN] bstrProgramID      - Program ID
//
//  PURPOSE: Adds the Program category to program's metaproperties
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
IProgramPtr gsPrograms::FindProgramMatch(_bstr_t bstrProgramTitle, _bstr_t bstrProgramID)
{
	// Check to see if this has been cached
	//
	if (bstrProgramID == m_bstrCachedProgramID)
	{
        return  m_bstrCachedProgramPtr;
	}

#if 0
    IMetaPropertyConditionPtr pProgramIDEqualCond = NULL;
    IProgramPtr           pProgram            = NULL;
	_bstr_t               bstrOperator        = "=";  

    pProgramIDEqualCond = m_pProgramIDProp->GetCond(bstrOperator, 0, bstrProgramID);

	if (NULL != pProgramIDEqualCond)
	{
		IProgramsPtr pMatchingPrograms = NULL;

		// Create the query for the program ID search
		//
        pMatchingPrograms = m_pPrograms->GetItemsWithMetaPropertyCond(pProgramIDEqualCond);

		if (NULL != pMatchingPrograms)
		{
			long lProgramCount = 0;

			// Perform the actual search for a matching program ID
			//
			HRESULT hr = pMatchingPrograms->get_Count(&lProgramCount);

			if (SUCCEEDED(hr))
			{
				for (long lCount = 0; lCount < lProgramCount; lCount++)
				{
					pProgram = pMatchingPrograms->GetItem(lCount);

					if (NULL != pProgram)
					{
						if ( pProgram->Title == bstrProgramTitle )
						{
							// Sanity check to see if this is the same program
							// 
							m_bstrCachedProgramID = bstrProgramID;
							m_bstrCachedProgramPtr = pProgram;

							return pProgram;
						}
					}
				}
			}
		}
	}
    return NULL;
#else
	HRESULT hr;
    IProgramPtr pprog;

	_variant_t varKey(bstrProgramID);
	hr = m_pprogsByKey->get_ItemWithKey(varKey, &pprog);
	if (FAILED(hr))
		return NULL;
	
	return pprog;
#endif
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: DoesProgramExist
//
//  PARAMETERS: [IN] bstrProgramTitle   - Program Title
//				[IN] bstrProgramID      - Program ID
//
//  PURPOSE: Does the program exist in the Programs collection; Search is
//           conducted using the Program ID
//
//  RETURNS: TRUE/FALSE
//
/////////////////////////////////////////////////////////////////////////
//
BOOL   gsPrograms::DoesProgramExist(_bstr_t bstrTitle, _bstr_t bstrDescription)
{
	ULONG          ulRet = FALSE;
    IProgramPtr    pExistingProgram = NULL;

	if (NULL == m_pPrograms)
	{
		return FALSE; 
	}

    return ( FindProgramMatch(bstrTitle, bstrDescription) != NULL ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\programs.h ===
#ifndef _PROGRAMS_H_
#define _PROGRAMS_H_


#define NO_OF_GENRES 146

#define IIDSTANDARDRATINGSET       "{f85dddcb-d6e1-4335-b2cb-04de29ed0929}"
#define IIDMPAARATINGSET           "{9b76024f-2528-4070-a382-559b265965fa}"
#define IIDCATEGORIESSET           "{82edb424-1992-48ae-8bc4-5fdb095656d1}"
#define PROP_TMSCATEGORY_STARTID   200
#define STDRATING_MINAGE           "MinimumAge"

#define MPAARATING_RATING          "Rating"

#define INVALID_DATE               0
#define INVALID_MINAGE             -1
#define INVALID_MPAARATING         -1

// gsPrograms - The gsPrograms class manages the Programs 
//              collection associated with the Guide Store
//
class gsPrograms
{
public:

    gsPrograms()
	{
		m_pPrograms = NULL;
		m_pprogsByKey = NULL;
        m_pProgramIDProp = NULL;
        m_pTVRatingProp = NULL;
        m_pMPAARatingProp = NULL;
        m_bstrCachedProgramPtr = NULL;
	}
    ~gsPrograms(){}

	ULONG       Init(IGuideStorePtr  pGuideStore);

	IProgramPtr AddProgram(_bstr_t bstrTitle,
					 _bstr_t bstrDescription,
					 _bstr_t bstrProgramID,
					 DATE    dtCopyrightDate,
					 long    lMinAgeRating,
					 long    lMPAARating);

	ULONG       AddProgramCategory(IMetaPropertiesPtr pProgramProps, LPTSTR lpCategory);

	IProgramPtr FindProgramMatch(_bstr_t bstrProgramTitle, _bstr_t bstrProgramID);

	BOOL        DoesProgramExist(_bstr_t bstrTitle, _bstr_t bstrDescription);

    ULONG       RemoveProgram(IProgramPtr pProgramToRemove){};

private:
	IMetaPropertyTypePtr  AddProgramIDProp(IMetaPropertySetsPtr pPropSets);
    IMetaPropertyTypesPtr AddTMSCategories(IMetaPropertySetsPtr pPropSets);

	IProgramsPtr     m_pPrograms;
	IProgramsPtr     m_pprogsByKey;

	// Source generated program ID metaproperty
	//
    IMetaPropertyTypePtr m_pProgramIDProp;

	// Ratings MetaProperties
	//
    IMetaPropertyTypePtr m_pTVRatingProp;
    IMetaPropertyTypePtr m_pMPAARatingProp;

	// Genre Map for CategoryTypes
	//
	CMapStringToPtr  m_CategoryMap;

	// Cache the current Program ID and it's Program Pointer
	//
    _bstr_t          m_bstrCachedProgramID;
    IProgramPtr      m_bstrCachedProgramPtr;
};


#endif // _PROGRAMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by WTMSLOAD.RC
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE	1000
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		1000
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\schedules.cpp ===
/////////////////////////////////////////////////////////////////////
//
// MODULE: SCHEDULES.CPP
//
// PURPOSE: Provides the implementation of the gsScheduleEntries class
//          methods for efficient access to the schedule entries 
//          collection
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "errcodes.h"
#include "schedules.h"

#define PROP_SCHEDULES_GUID            "{934F2B77-D918-46f0-990F-292CBE727A2B}"
#define PROPSET_SCHEDULES              "TMS Loader: Schedules"
#define SCHEDULE_BASEPROP_ID           2500
#define PROP_SCHEDULE_RERUN            SCHEDULE_BASEPROP_ID + 1
#define PROP_SCHEDULE_CAPTION          SCHEDULE_BASEPROP_ID + 2
#define PROP_SCHEDULE_STEREO           SCHEDULE_BASEPROP_ID + 3
#define PROP_SCHEDULE_PAYPERVIEW       SCHEDULE_BASEPROP_ID + 4
#define PROP_SCHEDULE_TIMEUPDATE       SCHEDULE_BASEPROP_ID + 10

#define PROPNAME_SCHEDULE_REREUN       "Schedule-Rerun"
#define PROPNAME_SCHEDULE_CAPTION      "Schedule-Caption"
#define PROPNAME_SCHEDULE_STEREO       "Schedule-Stereo"
#define PROPNAME_SCHEDULE_PAYPERVIEW   "Schedule-PayPerView"

#define PROPNAME_SCHEDULE_TIMEUPDATE   "Schedule-TimeUpdate"

/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddScheduleAttributeProps
//
//  PARAMETERS: [IN] pPropSets    - GuideStore MetaPropertySets collection
//
//  PURPOSE: Adds the Schedule Entries attributes types to the types collection
//           viz. Rerun, Close Captioned, Stereo and Pay Per View
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IMetaPropertyTypePtr gsScheduleEntries::AddScheduleAttributeProps(IMetaPropertySetsPtr pPropSets)
{
	HRESULT          hr               = NOERROR;
	IMetaPropertySetPtr  pSchedulePropSet = NULL;
    _bstr_t          bstrScheduleProp_GUID = PROP_SCHEDULES_GUID;
    _bstr_t          bstrScheduleProp_Name = PROPSET_SCHEDULES;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Add the new service related metaproperty set
	//
    hr = pPropSets->get_AddNew(bstrScheduleProp_Name, &pSchedulePropSet);

	if (SUCCEEDED(hr) && (NULL != pSchedulePropSet))
	{
		// Get the metaproperty types
		//
        IMetaPropertyTypesPtr pSchedulePropTypes = pSchedulePropSet->GetMetaPropertyTypes();
		
		if (NULL != pSchedulePropTypes)
		{
			HRESULT          hr                 = NOERROR;
			_bstr_t          bstrRerunProp_Name = PROPNAME_SCHEDULE_REREUN;
			_bstr_t          bstrCaptionProp_Name = PROPNAME_SCHEDULE_CAPTION;
			_bstr_t          bstrStereoProp_Name = PROPNAME_SCHEDULE_STEREO;
			_bstr_t          bstrPayPerViewProp_Name = PROPNAME_SCHEDULE_PAYPERVIEW;

			// Add the rerun metaproperty type
			//
			hr = pSchedulePropTypes->get_AddNew(PROP_SCHEDULE_RERUN, 
						bstrRerunProp_Name, 
						&m_pRerunProp);

			if (FAILED(hr))
                goto Exit; 				

			// Add the close captioned metaproperty type
			//
			hr = pSchedulePropTypes->get_AddNew(PROP_SCHEDULE_CAPTION, 
						bstrCaptionProp_Name, 
						&m_pCaptionProp);

			if (FAILED(hr))
                goto Exit; 				

			// Add the stereo metaproperty type
			//
			hr = pSchedulePropTypes->get_AddNew(PROP_SCHEDULE_STEREO, 
						bstrStereoProp_Name, 
						&m_pStereoProp);

			if (FAILED(hr))
                goto Exit; 				

			// Add the pay per view metaproperty type
			//
			hr = pSchedulePropTypes->get_AddNew(PROP_SCHEDULE_PAYPERVIEW, 
						bstrPayPerViewProp_Name, 
						&m_pPayPerViewProp);

			if (FAILED(hr))
                return NULL; 				

		}
    }

Exit:

	return m_pPayPerViewProp;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddTimeUpdatedProp
//
//  PARAMETERS: [IN] pPropSets    - GuideStore MetaPropertySets collection
//
//  PURPOSE: Adds the Schedule Entries - time updated metaproperty type to the 
//           types collection, this is used for the removal of conflicting
//           schedule entries
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IMetaPropertyTypePtr gsScheduleEntries::AddTimeUpdatedProp(IMetaPropertySetsPtr pPropSets)
{
	IMetaPropertySetPtr  pSchedulePropSet = NULL;
    _bstr_t          bstrScheduleProp_GUID = PROP_SCHEDULES_GUID;
    _bstr_t          bstrScheduleProp_Name = PROPSET_SCHEDULES;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Add the new service related metaproperty set
	//
    pSchedulePropSet = pPropSets->GetAddNew(bstrScheduleProp_Name);

	if (NULL != pSchedulePropSet)
	{
		// Get the metaproperty types
		//
        IMetaPropertyTypesPtr pSchedulePropTypes = pSchedulePropSet->GetMetaPropertyTypes();
		
		if (NULL != pSchedulePropTypes)
		{
			_bstr_t          bstrTimeUpdateProp_Name = PROPNAME_SCHEDULE_TIMEUPDATE;

			m_pTimeUpdateProp = pSchedulePropTypes->GetAddNew(PROP_SCHEDULE_TIMEUPDATE, 
						bstrTimeUpdateProp_Name);
		}
    }

	return m_pTimeUpdateProp;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: Init
//
//  PARAMETERS: [IN] pGuideStore - GuideStore interface
//
//  PURPOSE: Initializes the guide store Programs collection
//           Ensures that all the metaproperty types needed by
//           the Program entry viz. 
//           1. Standard ratings type
//           2. MPAA Ratings type
//           3. Program ID type
//           4. Required Category types
//           are available
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
ULONG  gsScheduleEntries::Init(IGuideStorePtr  pGuideStore)
{
    HRESULT hr    = NOERROR;
	ULONG   ulRet = ERROR_FAIL;

    if (NULL == pGuideStore)
	{
        return ERROR_INVALID_PARAMETER;
	}

	// Get the ScheduleEntries collection
	//
	hr = pGuideStore->get_ScheduleEntries(&m_pScheduleEntries );

	if (FAILED(hr))
	{
	   TRACE(_T("gsScheduleEntries - Init: Failed to get ScheduleEntries Collection\n"));
	   ulRet = ERROR_FAIL;;
	}
	else if (NULL != m_pScheduleEntries)
	{
#ifdef _DEBUG
		if (m_pScheduleEntries->Count)
		{
			TRACE(_T("gsScheduleEntries - Init: ScheduleEntries in Guide Store\n"));
		}
#endif
		// Add the Schedule Entries Attribute metaproperty types
		//
        AddScheduleAttributeProps(pGuideStore->GetMetaPropertySets());

		// Add the Time Updated metaproperty type
		//
        AddTimeUpdatedProp(pGuideStore->GetMetaPropertySets());
		
		if (NULL != m_pRerunProp && NULL != m_pCaptionProp 
			&& NULL != m_pStereoProp && NULL != m_pPayPerViewProp)
            ulRet = INIT_SUCCEEDED;
	}
	return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddScheduleEntry
//
//  PARAMETERS: [IN] dtStart     -   start time
//              [IN] dtEnd       -   End time
//              [IN] dtUpdated   -   Time updated to the store
//              [IN] lRerun      -   if rerun
//              [IN] lCaption    -   if close Captioned
//              [IN] lStereo     -   if stereo
//              [IN] lPayPerView -   if pay per view
//              [IN] pservice    -   Associated Service
//              [IN] pprog       -   Associated Program
//
//  PURPOSE: Adds a new Schedule Entry
//           Then sets the Rerun, Caption, Stereo and Paypervew props
//           Also sets the time updated value 
//
//  RETURNS: Valid Schedule Entry interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IScheduleEntryPtr gsScheduleEntries::AddScheduleEntry( DATE dtStart, 
													   DATE dtEnd,
													   DATE dtUpdated,
													   LONG lRerun,
													   LONG lCaption,
													   LONG lStereo,
													   LONG lPayPerView,
													   struct IService * pservice,
													   struct IProgram * pprog )
{
	ULONG             ulRet = 0;
    IScheduleEntryPtr pScheduleEntry = NULL;
	IMetaPropertiesPtr    pProps = NULL;

	if ((NULL == m_pScheduleEntries) || (NULL == pservice) || (NULL == pprog))
	{
		return NULL; 
	}

	// Add the new schedule entry to the Schedule entries collection
	//
	pScheduleEntry = m_pScheduleEntries->GetAddNew( dtStart, 
								   dtEnd,
								   pservice,
								   pprog);

	if (NULL != pScheduleEntry)
	{

		pProps = pScheduleEntry->GetMetaProperties ( );

		if (pProps != NULL)
		{
			// Add the rerun prop value
			//
			if (0 != lRerun)
				pProps->GetAddNew(m_pRerunProp, 0, lRerun);

			// Add the Caption prop value
			//
			if (0 != lCaption)
				pProps->GetAddNew(m_pCaptionProp, 0, lCaption);

			// Add the Stereo prop value
			//
			if (0 != lStereo)
				pProps->GetAddNew(m_pStereoProp, 0, lStereo);

			// Add the PayPerView prop value
			//
			if (0 != lPayPerView)
				pProps->GetAddNew(m_pPayPerViewProp, 0, lPayPerView);

			// Add the Time Updated prop value
			//
			pProps->GetAddNew(m_pTimeUpdateProp, 0, (const class _variant_t &) dtUpdated);
		}
	}
	return pScheduleEntry;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: DoesScheduleEntryExist
//
//  PARAMETERS: [IN] dtStart     -   start time
//              [IN] dtEnd       -   End time
//              [IN] pservice    -   Associated Service
//
//  PURPOSE: Check for the existence of a Schedule Entry in a given
//           range
//
//  RETURNS: TRUE/FALSE
//
//  REMARKS: Not in use
//
/////////////////////////////////////////////////////////////////////////
//
BOOL        gsScheduleEntries::DoesScheduleEntryExist(DATE dtStart, 
								   DATE dtEnd,
								   struct IService * pservice)
{
	ULONG                ulRet = FALSE;
    IScheduleEntryPtr    pExistingScheduleEntry = NULL;

	if (NULL == m_pScheduleEntries)
	{
		return FALSE; 
	}

	// TODO: Profile this code
	//
	if (NULL != pExistingScheduleEntry)
	{
		long lScheduleEntryCount = m_pScheduleEntries->GetCount ( );

		for (long lCount = 0; lCount < lScheduleEntryCount; lCount++)
		{
			pExistingScheduleEntry = m_pScheduleEntries->GetItem(lCount);

			if (NULL != pExistingScheduleEntry)
			{
				if ( dtStart == pExistingScheduleEntry->GetStartTime()
					&& dtEnd == pExistingScheduleEntry->GetEndTime()
					&& pservice == pExistingScheduleEntry->GetService() )
				{
					return TRUE;
				}
			}
		}
	}
	//
	// TODO: Profile this code


	return  ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: ClearOldScheduleEntries
//
//  PARAMETERS: [IN] dtStart     -   start time
//              [IN] dtEnd       -   End time
//              [IN] pservice    -   Associated Service
//
//  PURPOSE: To delete unupdated Schedule Entries with 
//           last update < now and start time < guide range end time
//
//  RETURNS: SUCCESS/FAILURE
//
//  REMARKS: Not in use
//
/////////////////////////////////////////////////////////////////////////
//
ULONG       gsScheduleEntries::ClearOldScheduleEntries(COleDateTime codtUpdateTime, 
													   COleDateTime codtGuideStartTime, 
													   COleDateTime codtGuideEndTime)
{
	ULONG ulRet = 1;
	COleDateTime codtStartTimeMinusDay = codtGuideStartTime;
	COleDateTimeSpan codtsDelta;
	codtsDelta.SetDateTimeSpan(1, 0, 0, 0);

	codtStartTimeMinusDay -= codtsDelta;

	// delete old schedule entries with end time < mpg start time
	// this removes any schedule entries that are obslete
    // TODO: This will now be done by the Guide Store maintenance functions
	//

    // delete unupdated schedule entries with last update < now and start time < guide range 
	// end time this removes any schedule entries that were in the mpg last time the loader 
	// ran but that aren't there now - resolving conflicts
    // TODO: Profile this code
	//
    IMetaPropertyConditionPtr pUnupdatedCond = NULL;
    IMetaPropertyConditionPtr pRangeCond = NULL;
	_bstr_t               bstrOperator        = "<";  

    pUnupdatedCond = m_pTimeUpdateProp->GetCond(bstrOperator, 0, (const class _variant_t &) codtUpdateTime);
    pRangeCond = m_pTimeUpdateProp->GetCond(bstrOperator, 0, (const class _variant_t &) codtGuideEndTime);
	
	if ( NULL != pUnupdatedCond && NULL != pRangeCond )
	{
		IMetaPropertyConditionPtr pDelCond = pUnupdatedCond->GetAnd (pRangeCond);

		if (NULL != pDelCond)
		{
			// Apply condition to  the schedule entries collection
			//
			IScheduleEntriesPtr pMatchingEntries = NULL;

			pMatchingEntries = m_pScheduleEntries->GetItemsWithMetaPropertyCond(pDelCond);

			if (NULL != pMatchingEntries)
			{
				// Remove these entries
				//
				// TODO: use "pMatchingEntries->RemoveAll()" interface
				ulRet = 0;
            }
		}
	}
	return ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\servchan.h ===
#ifndef _SERVCHAN_H_
#define _SERVCHAN_H_


enum MSStatChanRec
{
StatChanRec_Num,
StatChanRec_Name,
StatChanRec_CallLetters,
StatChanRec_NetworkID,
StatChanRec_ChannelNumber,
StatChanRec_Fields
};


class CStatChanRecordProcessor : public CRecordProcessor
{
public:

    CStatChanRecordProcessor(int nNumFields, 
		                    SDataFileFields ssfFieldsInfo[]);
    CStatChanRecordProcessor();

    int      m_Process(LPCTSTR lpData, int nDataSize, int* pBytesProcessed);
	int      m_UpdateDatabase(CRecordMap& cmRecord);
	int      m_GetState();
    int      m_GetError();
	int      m_GetErrorString(CString&);
	long     m_GetChannelID(LPCTSTR lpChannelNum);

private:
    CMapStringToString   m_ChannelIDMap;
};


#endif // _SERVCHAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\services.cpp ===
///////////////////////////////////////////////////////////////////
//
//  SERVICES.CPP
//
//  PURPOSE: Adds and removes services (stations). Ensures that 
//           services are not duplicated for the tuning space.
//           Adds a metaproperty called "StationNum" to uniquely
//           identify services.     
//
//
///////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "errcodes.h"
#include "services.h"

#define PROP_SERVICE_GUID             "{905E3380-60C0-4759-8419-B25BC0BCCFAD}"
#define PROPSET_SERVICES              "TMS Loader: Services"
#define SERVICE_BASEPROP_ID           1500
#define PROP_SERVICE_STATIONNUM       SERVICE_BASEPROP_ID + 1
#define PROP_SERVICE_LATESTTIME       SERVICE_BASEPROP_ID + 2
#define PROPNAME_SERVICE_STATIONNUM   "Service-StationNum"
#define PROPNAME_SERVICE_LATESTTIME   "Service-LatestTime"


    

/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddStationNumProp
//
//  PARAMETERS: [IN] pPropSets    - GuideStore MetaPropertySets collection
//
//  PURPOSE: Adds the Station No. metaproperty type to the types collection
//           This metaproperty type is used for storing unique station numbers
//           associated with the Service reccrds
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IMetaPropertyTypePtr gsServices::AddStationNumProp(IMetaPropertySetsPtr pPropSets)
{
	HRESULT          hr              = NOERROR;
	IMetaPropertySetPtr  pServicePropSet = NULL;
    _bstr_t          bstrServiceProp_GUID = PROP_SERVICE_GUID;
    _bstr_t          bstrServiceProp_Name = PROPSET_SERVICES;

    if (NULL == pPropSets)
	{
        return NULL;
	}

	// Add the new service related metaproperty set
	//
    hr = pPropSets->get_AddNew(bstrServiceProp_Name, &pServicePropSet);

	if (SUCCEEDED(hr) && (NULL != pServicePropSet))
	{
		// Get the metaproperty types
		//
        IMetaPropertyTypesPtr pServicePropTypes = pServicePropSet->GetMetaPropertyTypes();
		
		if (NULL != pServicePropTypes)
		{
			_bstr_t          bstrStationNumProp_Name = PROPNAME_SERVICE_STATIONNUM;

            // Add the Station Number metaproperty type
			//
			hr = pServicePropTypes->get_AddNew(PROP_SERVICE_STATIONNUM, 
						bstrStationNumProp_Name, 
						&m_pStationNumProp );

			if (FAILED(hr))
				return NULL;
		}
    }

	return m_pStationNumProp;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: Init
//
//  PARAMETERS: [IN] pGuideStore - GuideStore interface pointer
//
//  PURPOSE: Gets the pointer to the services collection
//           Ensures the addition on the Station Number metaproperty type
//
//  RETURNS: SUCCESS/FAILURE
//
/////////////////////////////////////////////////////////////////////////
//
ULONG  gsServices::Init(IGuideStorePtr  pGuideStore)
{
    HRESULT hr    = NOERROR;
	ULONG   ulRet = ERROR_FAIL;

	if (NULL == pGuideStore)
	{
        return ERROR_INVALID_PARAMETER;
	}

	// Get the Services Collection
	//
	hr = pGuideStore->get_Services(&m_pServices );

	if (FAILED(hr))
	{
	   TRACE(_T("gsServices - Init: Failed to get Services Collection\n"));
	   ulRet = ERROR_FAIL;
	}
	else if(NULL != m_pServices)
	{
#ifdef _DEBUG
		if (m_pServices->Count)
		{
			TRACE(_T("gsServices - Init: Services in Guide Store\n"));
		}
#endif
		// Add the StationNum MetaProperty type
		//
		AddStationNumProp(pGuideStore->GetMetaPropertySets ());

		if (NULL != m_pStationNumProp)
			ulRet = INIT_SUCCEEDED;
	}
	return ulRet;
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: AddService
//
//  PARAMETERS: [IN] bstrProviderName        - Name of the Station
//				[IN] bstrStationNum          - Station Number
//				[IN] bstrProviderDescription - Station Description
//				[IN] bstrProviderNetworkName - Associated Network
//				[IN] dtStart                 - Service Start
//				[IN] dtEnd                   - Service End
//
//  PURPOSE: Add a new Service Entry in the Services Collection
//           Also adds the associated Station Num prop value
//
//  RETURNS: Valid Service interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IServicePtr gsServices::AddService( ITuneRequest* pTuneRequest,
								    _bstr_t bstrProviderName,
								    _bstr_t bstrStationNum,
								    _bstr_t bstrProviderDescription,
									_bstr_t bstrProviderNetworkName,
									DATE dtStart,
									DATE dtEnd)
{
	ULONG                ulRet = 0;
	IServicePtr          pService = NULL;
	IMetaPropertiesPtr       pProps = NULL;

	if (NULL == m_pServices)
	{
		return NULL; 
	}

	// Add a new Service Entry in the Services Collection
	//
	pService = m_pServices->GetAddNew(pTuneRequest, 
						  bstrProviderName, 
						  bstrProviderDescription,
						  bstrProviderNetworkName,
						  dtStart,
						  dtEnd);

	if (NULL != pService)
	{

		pProps = pService->GetMetaProperties ( );

		if (pProps != NULL)
		{
			// Add the Station Num metaproperty value
			//
			pProps->GetAddNew(m_pStationNumProp, 0, bstrStationNum);
		}
	}

	return pService;

}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: GetService
//
//  PARAMETERS: [IN] lServiceID - unique service ID
//
//  PURPOSE: Gets the Service associated with the Service ID
//
//  RETURNS: Valid Service interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
IServicePtr gsServices::GetService(long lServiceID)
{
	if (NULL == m_pServices)
	{
		return NULL; 
	}
    return m_pServices->GetItemWithID(lServiceID);
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: DoesServiceExist
//
//  PARAMETERS: [IN] bstrStationNum - Station Number
//
//  PURPOSE: Check for the existence of a Service using the 
//           unique Station Number value
//
//  RETURNS: Valid metaproperty type interface pointer/NULL
//
/////////////////////////////////////////////////////////////////////////
//
BOOL gsServices::DoesServiceExist(_bstr_t bstrStationNum)
{
	ULONG          ulRet = FALSE;
    IServicePtr    pExistingService = NULL;
    IMetaPropertiesPtr pProps = NULL;
	IMetaPropertyPtr   pStationProp = NULL;

	if (NULL == m_pServices)
	{
		return FALSE; 
	}

	// TODO: Profile this code
	//
	if (NULL != pExistingService)
	{
		long lServiceCount = m_pServices->GetCount ( );

		// Iterate through the services collection
		//
		for (long lCount = 0; lCount < lServiceCount; lCount++)
		{
			pExistingService = m_pServices->GetItem(lCount);
            pProps = pExistingService->GetMetaProperties();

			if (NULL != pProps)
			{
				pStationProp = pProps->GetItemsWithMetaPropertyType(m_pStationNumProp);

                // ASSUMPTION: that there will be only one service with this ID
				//
				if ( bstrStationNum == (_bstr_t) pStationProp->GetValue() )
				{
					return TRUE;
				}
			}
		}
	}
	//
	// TODO: Profile this code

	return  ulRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wtmsload.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\schedules.h ===
#ifndef _SCHEDULES_H_
#define _SCHEDULES_H_

ULONG TestSchedules(IScheduleEntriesPtr  pScheduleEntries, IServicesPtr  pServices);


// gsScheduleEntries - The gsScheduleEntries class manages the ScheduleEntries 
//              collection associated with the Guide Store
//
class gsScheduleEntries
{
public:

    gsScheduleEntries()
	{
		m_pScheduleEntries = NULL;
        m_pRerunProp = NULL;
        m_pCaptionProp = NULL;
        m_pStereoProp = NULL;
        m_pPayPerViewProp = NULL;
		m_pTimeUpdateProp = NULL;
	}
    ~gsScheduleEntries(){}

	ULONG  Init(IGuideStorePtr  pGuideStore);

	IScheduleEntryPtr AddScheduleEntry(DATE dtStart, 
									   DATE dtEnd,
									   DATE dtUpdated,
                                       LONG lRerun,
                                       LONG lCaption,
                                       LONG lStereo,
                                       LONG lPayPerView,
									   struct IService * pservice,
									   struct IProgram * pprog );

	BOOL        DoesScheduleEntryExist(DATE dtStart, 
									   DATE dtEnd,
									   struct IService * pservice);

    ULONG       RemoveScheduleEntry(IScheduleEntryPtr pScheduleEntryToRemove){};

    ULONG       ClearOldScheduleEntries(COleDateTime codtUpdateTime, COleDateTime codtGuideStartTime, COleDateTime codtGuideEndTime);

private:
	IMetaPropertyTypePtr        AddScheduleAttributeProps(IMetaPropertySetsPtr pPropSets);
	IMetaPropertyTypePtr        AddTimeUpdatedProp(IMetaPropertySetsPtr pPropSets);

	IScheduleEntriesPtr     m_pScheduleEntries;

	// Attribute MetaProperties
	//
	IMetaPropertyTypePtr        m_pRerunProp;
	IMetaPropertyTypePtr        m_pCaptionProp;
	IMetaPropertyTypePtr        m_pStereoProp;
	IMetaPropertyTypePtr        m_pPayPerViewProp;

	// TimeUpdated MetaProperty
	//
	IMetaPropertyTypePtr        m_pTimeUpdateProp;
};

#endif // _SCHEDULES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__60C90416_E603_455E_B4B3_13B474B8EA73__INCLUDED_)
#define AFX_STDAFX_H__60C90416_E603_455E_B4B3_13B474B8EA73__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#import "mstvgs.tlb" no_namespace

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__60C90416_E603_455E_B4B3_13B474B8EA73__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\guidestore\loaders\tms\servchan.cpp ===
/////////////////////////////////////////////////////////////////////
//
// MODULE: SERVCHAN.CPP
//
// PURPOSE: Provides the implementation of the 
//          CStatChanRecordProcessor class 
//          These methods parse and collection schedule and channel
//          data that is then stored into the GuideStore using the
//          gsServices and gsChannels methods.
//
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "errcodes.h"
#include <Afxtempl.h>
#include <crtdbg.h>
#include <fstream.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include "guidestore.h"
#include "services.h"
#include "channels.h"
#include "programs.h"
#include "schedules.h"
#include "wtmsload.h"
#include "tmsparse.h"
#include "servchan.h"
#define TIMING 0
#include "..\..\timing.h"

#ifdef _DUMP_LOADER
CString csDiagMil;
extern HANDLE hDiagFile;
extern char szDiagBuff[1024];
int         ChannelCnt = 0;
int         TimeSlotCnt = 0;
extern DWORD dwBytesWritten;
#endif


SDataFileFields ssfStatChanFieldInfo[StatChanRec_Fields] = 
{ 
  TRUE, 10,
  TRUE, 40,
  TRUE, 5,
  TRUE, 10,
  TRUE, 10
};



// CStatChanRecordProcessor
//
CStatChanRecordProcessor::CStatChanRecordProcessor(int nNumFields, 
												 SDataFileFields ssfFieldsInfo[])
{
	m_Init();
	m_pFieldsDesc = ssfFieldsInfo;
	m_nNumFields  = nNumFields;
	m_ChannelIDMap.InitHashTable(MAX_CHANNELS, TRUE);
}

CStatChanRecordProcessor::CStatChanRecordProcessor()
{
    m_Init();
	m_pFieldsDesc = ssfStatChanFieldInfo;
    m_nNumFields  = StatChanRec_Fields;
	m_ChannelIDMap.InitHashTable(MAX_CHANNELS, TRUE);
}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: m_Process
//
//  PARAMETERS: [IN] lpData    - Data to be processed
//              [IN] nDataSize - Size of data
//
//  PURPOSE: Processes the Data stream for Channel records
//           Once Channel records have been parsed and
//           prepared for table updation signals end of channel records
//           to the file processor
//
/////////////////////////////////////////////////////////////////////////
//
int CStatChanRecordProcessor::m_Process(LPCTSTR lpData, int nDataSize, int* pBytesProcessed)
{
    int nFields = 0;
	int nFieldSize = 0;
	int nParsePos = 0;
	int nBytesProcessed = 0;

	// Parameter validation
	//
	if (NULL == lpData || 0 == nDataSize)
	{
        return ERROR_INVALID_ARGS;
	}
    else
	{
		 *pBytesProcessed = 0;

         // Data Integrity Check
         //
         ASSERT( _CrtIsValidPointer((const void *)lpData, nDataSize, FALSE) );

		 {
             // Data is valid - Start processing
			 //
             do
			 {
	 			 if (STATE_RECORD_INCOMPLETE == m_nState)
				 {
				     nFields = m_nCurrField;
					 nFieldSize = m_nCurrFieldSize;
				 }

                 for(;nParsePos < nDataSize; nParsePos++)
				 {
					 DeclarePerfTimer("CStatChanRecordProcessor");
					 MSG msg;
					 while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
					 {
						TranslateMessage(&msg);
						DispatchMessage(&msg);
					 }
					 PerfTimerReset();
                     if (lpData[nParsePos] == EOC)
					 {
						 // End of field
						 //
                         if (nParsePos > 0 && (lpData[nParsePos-1] != EOC))
						 {
							 // TODO ASSERT(nFields <= StationRec_Fields);
                             
							 m_szValidField[nFieldSize] = '\0';
					         m_cmRecordMap[nFields] =  m_szValidField;
							 nFieldSize = 0;
						 }
						 else
						 {
                             //nFieldDataPos = nParsePos;
							 nFieldSize = 0;
							 m_nCurrFieldSize = 0;
						 }

						 nFields++;        
						 m_nCurrField++;
	 				 }
                     else if (lpData[nParsePos] == EOR)
					 {
						 // End of the record
						 //
						 DeclarePerfTimer("CStatChanRecordProcessor");
						 PerfTimerReset();
						 if (UPDATE_SUCCEEDED != m_UpdateDatabase(m_cmRecordMap))
						 {
							 if (STATE_RECORD_ERROR == m_nState)
							 {
                                 m_nState = STATE_RECORDS_FAIL;
                                 return m_nState;
							 }
							 else
                                 m_nState = STATE_RECORD_ERROR;
						 }
						 PerfTimerDump("m_UpdateDatabase");

						 m_cmRecordMap.RemoveAll();
						 m_nCurrField = nFields = 0;
						 m_nCurrFieldSize = nFieldSize = 0;
					     continue;
	 				 }
                     else if (lpData[nParsePos] == EOT)
					 {
						 // End of the table
						 //
			             m_nState = STATE_RECORDS_PROCESSED;
						 nParsePos += 2*sizeof(TCHAR);
						 break;
	 				 }
					 else
					 {
						 // Valid field data
						 //
						 m_szValidField[nFieldSize] =  lpData[nParsePos];
                         nFieldSize++;
						 m_nCurrFieldSize++;
					 }
					 PerfTimerDump("for loop");
				 }

			 } while ((nParsePos < nDataSize) && (m_nState != STATE_RECORDS_PROCESSED));


			 *pBytesProcessed = nParsePos;

			 if (m_nState != STATE_RECORDS_PROCESSED)
			 {
				 if (lpData[--nParsePos] == EOR)
				 {
                     // More records
					 //
			         m_nState = STATE_RECORDS_INCOMPLETE;                      
				 }
				 else
				 {
                     // record incomplete
					 //
			         m_nState = STATE_RECORD_INCOMPLETE;                      					 
				 }
                  
			 }
		 }
         
	}
	
	return m_nState;

}


/////////////////////////////////////////////////////////////////////////
//
//  METHOD: m_UpdateDatabase
//
//  PARAMETERS: [IN] cmStationRecord  - map containing record fields
//
//  PURPOSE: Updates the Guide Store
//
/////////////////////////////////////////////////////////////////////////
//
int CStatChanRecordProcessor::m_UpdateDatabase(CRecordMap& cmRecord)
{
	int iRet = ERROR_UPDATE;
	CString csName, csCallLetters, csNetwork;
	CString csStationNumStr, csChannelNumStr;
	CWtmsloadApp* ctmsLoapApp = (CWtmsloadApp*) AfxGetApp();
	TCHAR   ConvBuffer[20] = {0};	
	IServicePtr pTMSService = NULL;
	IChannelPtr pTMSChannel = NULL;
	IChannelPtr pTMSChannelMatch = NULL;

	// Lookup the Name entry in the StationRecord Map
	//
    cmRecord.Lookup(StatChanRec_Name, csName);
    csName = csName.Left(ssfStatChanFieldInfo[StatChanRec_Name].nWidth);
	csName.TrimLeft();
	csName.TrimRight();

	// Lookup the Number entry in the StationRecord Map
	//
    cmRecord.Lookup(StatChanRec_Num, csStationNumStr);
	csStationNumStr.TrimLeft();
	csStationNumStr.TrimRight();

	// Lookup the Call Letters entry in the StationRecord Map
	//
	cmRecord.Lookup(StatChanRec_CallLetters, csCallLetters);
	csCallLetters = csCallLetters.Left(4);
	csCallLetters.MakeUpper();

	// Lookup the Network entry in the StationRecord Map
	//
	cmRecord.Lookup(StatChanRec_NetworkID, csNetwork);
	csNetwork.TrimLeft();
	csNetwork.TrimRight();

    // Lookup the Channel Number
	//
	cmRecord.Lookup(StatChanRec_ChannelNumber, csChannelNumStr);
	csChannelNumStr.TrimLeft();
	csChannelNumStr.TrimRight();

	// A new service will be added if the Service is for a Channel that does not already
	// have the "ServiceID" associated with it
	//
	pTMSChannelMatch = ctmsLoapApp->m_pgsChannels.FindChannelMatch(
		csChannelNumStr.GetBuffer(ssfStatChanFieldInfo[StatChanRec_ChannelNumber].nWidth),
		csStationNumStr.GetBuffer(ssfStatChanFieldInfo[StatChanRec_Num].nWidth));

	if (NULL != pTMSChannelMatch)
	{
			// Add the "channel + service" data for use by ScheduleEntries
			//
		    IServicePtr pServiceMatch = NULL;
            pServiceMatch = pTMSChannelMatch->GetService();

			m_ChannelIDMap[csChannelNumStr.GetBuffer(ssfStatChanFieldInfo[StatChanRec_ChannelNumber].nWidth)] 
				= _ltot(pServiceMatch->GetID(), ConvBuffer, 10);

			// Get the corresponding service ID
			//
			CString csChannelID(_ltot(pServiceMatch->GetID(), ConvBuffer, 10));

			// The hash table key is based on StationNum and ChannelNum
			//
			CString csStatChan = csStationNumStr + "," + csChannelNumStr;

			// Make the corresponding Hash table entry
			//
			m_ChannelIDMap.SetAt(csStatChan, csChannelID); // TODO: Add exception handling
	#ifdef _DUMP_LOADER
		wsprintf(szDiagBuff, "Saving #%d Channel ID for %s : %d\r\n", ChannelCnt, csStatChan, cct.ChannelID());
		if (NULL != hDiagFile)
		{
			::WriteFile(hDiagFile, szDiagBuff, lstrlen(szDiagBuff), &dwBytesWritten, 0);
		}
    #endif

		iRet = UPDATE_SUCCEEDED; 
	}
	else
	{
		ITuningSpace* pTuningSpace = ctmsLoapApp->m_pgsChannelLineup.GetTuningSpace();

		if (NULL != pTuningSpace)
		{
			ITuneRequest* pTuneRequest = NULL;
			
			// Create an empty tune request
			//
            pTuningSpace->CreateTuneRequest(&pTuneRequest);

			if (NULL != pTuneRequest)
			{
				IChannelTuneRequest*  pChannelTuneRequest = NULL;

				// Get a specialized tune request for Analog TV
				//
                pTuneRequest->QueryInterface(__uuidof(IChannelTuneRequest),
                        reinterpret_cast<void**>(&pChannelTuneRequest));

				if (NULL != pChannelTuneRequest)
				{
					// Set the Channel number
					//
					pChannelTuneRequest->put_Channel(_ttoi(csChannelNumStr));

					// Make the new service entry
					//
					pTMSService = ctmsLoapApp->m_pgsServices.AddS